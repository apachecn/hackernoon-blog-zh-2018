<html>
<head>
<title>Building a Serverless REST API with Node.js and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js和MongoDB构建无服务器REST API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-serverless-rest-api-with-node-js-and-mongodb-2e0ed0638f47?source=collection_archive---------0-----------------------#2018-01-02">https://medium.com/hackernoon/building-a-serverless-rest-api-with-node-js-and-mongodb-2e0ed0638f47?source=collection_archive---------0-----------------------#2018-01-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/444303eca3e4d0438f9568bf60f16d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJkxFqPn2f_-J467JhPC2A.jpeg"/></div></div></figure><div class=""/><p id="6c0b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在过去的几个月里，无服务器运动已经获得了一些动力。每个人似乎都在谈论它。有些人甚至称之为革命！但是，我们不要太兴奋。不要像我一样。我对这种很酷的东西过于兴奋，于是开始写文章。如果这对你来说是全新的，这里有一篇我不久前写的文章，解释了核心概念。</p><div class="ht hu fm fo hv ka"><a href="https://hackernoon.com/a-crash-course-on-serverless-with-node-js-632b37d58b44" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd ig fv z el kf eo ep kg er et ie dt translated">Node.js无服务器速成班</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">不管您的开发背景如何，在过去的一年中，您不可避免地会听到“无服务器”这个术语。这个词…</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">hackernoon.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko ib ka"/></div></div></a></div><p id="e0ee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本着这种精神，我花在探索使用无服务器架构构建什么是合理的时间可能超过了被视为健康的时间。我的结论是，几乎所有东西都可以用无服务器的方式构建。你唯一需要问自己的问题是，你是否真的需要它。Lambdas是无状态的，这意味着编写服务器端代码的整个概念需要重新学习。</p><p id="668c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">听起来很有趣？是啊，对我来说也是。我最近发表了一篇关于在现实生活中使用无服务器架构的实践课程。我把我所有的发现和使用无服务器的合理理由都倾注到这个课程中。我不断问自己这个问题<em class="kp">“为什么我需要无服务器？”</em>贯穿整个创作过程。你可以在下面找到我的想法。</p><div class="ht hu fm fo hv ka"><a href="https://www.packtpub.com/web-development/serverless-javascript-example-video" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd ig fv z el kf eo ep kg er et ie dt translated">无服务器JavaScript示例[视频] -视频|现在只需5美元</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">通过无服务器web开发的实时演示变得更加熟练</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">www.packtpub.com</p></div></div><div class="kj l"><div class="kq l kl km kn kj ko ib ka"/></div></div></a></div><h1 id="bcdb" class="kr ks if bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">为什么对REST APIs使用无服务器？</h1><p id="9025" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">为什么不呢？是因为我们可以，还是我们看到了相对于传统服务器的明显优势？硬币的两面都有有效的论据。无服务器被认为是永远运行的。因为你不需要管理任何东西，你不用担心正常运行时间，它只是工作。它还可以自动扩展。真好。真的很好。扩展服务器并不有趣。</p><p id="dee6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是持久存储呢？我们不能像过去那样在服务器上运行MongoDB数据库。然而，如果你一直遵循在过去一年中不断增长的<strong class="je ig">【关注点分离】</strong>的生活方式，你可能已经习惯了将你的数据库与你的后端分离。如果你习惯写微服务就更是如此。你只需给你的应用一个连接URL，数据库就准备好了。</p><h1 id="ceab" class="kr ks if bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">你准备好接受挑战了吗？</h1><p id="efc7" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">本文将向您展示如何将MongoDB数据库作为服务连接到无服务器REST API。可能有点厚脸皮，因为使用AWS无服务器架构的首选方式是使用他们的NoSQL DBaaS，名为<a class="ae lu" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>。但我喜欢组合奇怪的东西。而且，说实话，<a class="ae lu" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB图集</a>很惊艳。是MongoDB自己的DBaaS。你可以免费获得一个专用的MongoDB集群。</p><p id="cc6c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个设置最棒的地方是，我将向您展示如何以您已经习惯的方式编写代码。你在Node.js、Express和Mongoose中所知道的一切都将在本教程中重复使用。</p><p id="3c0f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新的是使用<a class="ae lu" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda计算服务</a>背后的思维模式。AWS Lambda函数基本上是一个<a class="ae lu" href="https://www.docker.com/what-docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器。一旦Lambda被调用，容器就开始旋转并运行代码。这是我们想要初始化数据库连接的时候，第一次调用函数，第一次初始化Docker容器。对Lambda函数的每个后续请求都应该使用现有的数据库连接。够简单吗？让我们开始吧！</p><h1 id="f6f6" class="kr ks if bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">启动并运行</h1><p id="7212" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">我假设您已经对无服务器框架有了基本的了解。我也希望你有一个AWS帐户设置。如果没有，请看一下我<a class="ae lu" href="https://hackernoon.com/a-crash-course-on-serverless-with-node-js-632b37d58b44" rel="noopener ugc nofollow" target="_blank">链接在顶部</a>的文章。</p><h2 id="8016" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">1.创建服务</h2><p id="7c10" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">首先，让我们创建一个新的服务来保存我们所有的代码。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="239c" class="lv ks if mo b fv ms mt l mu mv">$ sls create -t aws-nodejs -p rest-api &amp;&amp; cd rest-api</span></pre><p id="5fca" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个命令将搭建出所有必要的文件和代码来创建我们的Lambda函数和API网关事件。它将按照我们用<code class="eh mw mx my mo b">-p</code>标志给它的路径来做这件事。这意味着它将创建一个名为<code class="eh mw mx my mo b">rest-api</code>的目录。我们想换到那个目录，从那里开始工作。</p><h2 id="6877" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">2.安装模块</h2><p id="30e2" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">我们需要几个模块。首先，我们需要无服务器离线插件，以便在部署到AWS之前能够在本地运行我们的代码。然后我们需要抓住<a class="ae lu" href="https://www.npmjs.com/package/mongoose" rel="noopener ugc nofollow" target="_blank">猫鼬</a>，我选择的ORM，和<a class="ae lu" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>，因为我喜欢<strong class="je ig">而不是</strong>按下GitHub的键。把钥匙推到GitHub上糟透了。不要那样做。每当你按下GitHub的一个键，就会有一只小企鹅死去。我是说，不完全是，但还是很糟糕。</p><p id="e845" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">确保你在<code class="eh mw mx my mo b">rest-api</code>目录中。先离线安装Serverless，再安装mongoose和dotenv。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="8fd6" class="lv ks if mo b fv ms mt l mu mv">$ npm init -y<br/>$ npm i --save-dev serverless-offline<br/>$ npm i --save mongoose dotenv</span></pre><p id="19d9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就这样，让我们从终端休息一下，跳到Atlas来创建一个数据库。</p><h2 id="cbdc" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">3.在MongoDB Atlas上创建数据库</h2><p id="c1b7" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">准备好接受更多配置了吗？是啊，没人喜欢这部分。但是和我一起。跳到MongoDB Atlas并注册。</p><div class="ht hu fm fo hv ka"><a href="https://www.mongodb.com/cloud/atlas?jmp=nav" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd ig fv z el kf eo ep kg er et ie dt translated">完全托管的MongoDB，托管在AWS、Azure和GCP上</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">MongoDB Atlas是一个云托管的MongoDB服务，由构建数据库的同一个团队设计和运行。它…</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">www.mongodb.com</p></div></div><div class="kj l"><div class="mz l kl km kn kj ko ib ka"/></div></div></a></div><p id="248f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是免费的，不需要信用卡。这将是我们玩耍时需要的沙箱。设置好帐户后，打开您的帐户页面并添加一个新组织。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff na"><img src="../Images/ee523bd3120c46b4af4d615fe0a42f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hM21Qo6sum_Bcj98giFYzQ.png"/></div></div></figure><p id="e6a6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">加个你觉得合适的名字，我还是坚持用<code class="eh mw mx my mo b">rest-api</code>。点击“下一步”,继续创建组织。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nb"><img src="../Images/9f64de4dd8c708bae1cd5f5c58511de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JBOmTjNK0iSLb3VZEKwsw.png"/></div></div></figure><p id="49e7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很好。这将带您进入组织页面。按下新项目按钮。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nc"><img src="../Images/8a9c349d707ca5855999c9792f4332ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOxiyVzJjVFF_cV5V7oO6w.png"/></div></div></figure><p id="16bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将打开一个页面来命名您的项目。只需再次输入<code class="eh mw mx my mo b">rest-api</code>并点击下一步。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nd"><img src="../Images/e77ecc910320b9924792aa0fc4a114fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSSzcsD2g9z0JhFtAaWnBQ.png"/></div></div></figure><p id="4c49" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">MongoDB关心权限和安全性，所以Atlas将向您展示另一个管理权限页面。我们现在可以跳过这一步，创建项目。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ne"><img src="../Images/2fcfc1b3bc2557a226758ec6e5c2f82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCM_HJiy-Qw42CxxF-LBpg.png"/></div></div></figure><p id="e380" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">唷，我们找到了。最后，我们可以创建实际的集群！按下巨大的绿色<strong class="je ig">“建立新集群”</strong>按钮。这将打开一个巨大的集群创建窗口。您可以保留所有的默认值，只需确保选择<strong class="je ig"> M0 </strong>实例大小，并禁用备份。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nf"><img src="../Images/0ddaef1fb9ce795fbfcd4df1317da9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYF8SbJsPASbLX2su7p8AQ.png"/></div></div></figure><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ng"><img src="../Images/3e165382de429a84db55e9ab091110fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0keX3l5GWSefyprHzoNOA.png"/></div></div></figure><p id="1cf2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成所有这些后，只需为集群添加一个管理员用户，并给他一个非常强的密码。如您所见，该集群的价格将为<strong class="je ig">$ 0.00/永久</strong>。相当不错。就是这样，点击<strong class="je ig">“确认&amp;部署”</strong>。</p><p id="eac1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">部署您的集群需要几分钟时间。在此过程中，让我们最终开始编写一些代码。</p><h1 id="e93b" class="kr ks if bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">写一些代码</h1><p id="0b6e" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">那个装置很难。现在我们需要在<strong class="je ig"> serverless.yml </strong>文件中编写资源配置，并将实际的CRUD方法添加到<strong class="je ig"> handler.js </strong>中。</p><h2 id="0ba6" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">4.配置所有YAML</h2><p id="4004" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">无服务器框架的神奇之处在于它有很好的初始架构。您几乎可以仅使用<strong class="je ig"> serverless.yml </strong>文件中注释掉的代码来创建一个很好的配置。但是，因为我是一个爱干净的人，所以让我们把它全部删除，添加下面的代码。在你把它复制到你的<strong class="je ig"> serverless.yml </strong>文件之后，我会继续解释这一切。</p><figure class="mj mk ml mm fq hw"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="7134" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种配置非常简单，刚好满足我们的需求。我们已经将Lambdas的最大内存大小设置为128MB，这对于我们的需求来说已经足够了。在我自己测试了几天后，它们从未超过50MB。</p><p id="d15e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们进入有趣的部分，即<strong class="je ig">函数</strong>部分。我们一共增加了5个函数:<strong class="je ig">创建</strong>、<strong class="je ig">获取一个</strong>、<strong class="je ig">获取全部</strong>、<strong class="je ig">更新</strong>、<strong class="je ig">删除</strong>。它们都指向<strong class="je ig"> handler.js </strong>文件中同名的导出函数。它们的路径都遵循标准REST API的命名约定。令人惊讶的是，这就是我们设置API网关资源来触发Lambda函数所需要的全部。</p><p id="c75d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">差不多就这些了，最后就是增加一个插件部分和<strong class="je ig"> serverless-offline </strong>。我们在上面安装了这个模块，在部署到AWS之前，我们将用它来测试服务。我猜接下来我们准备好玩<strong class="je ig"> handler.js </strong>了。我们走吧！</p><h2 id="5e62" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">5.充实功能</h2><p id="2cfc" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">我们准备好享受真正的乐趣了。我们将首先定义我们需要的5个函数，并创建我们想要的行为的初始布局。之后，我们可以创建数据库连接，并添加与Mongoose的数据库交互逻辑。</p><p id="5624" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先打开<strong class="je ig"> handler.js </strong>文件。您将看到默认的hello函数。继续删除它，并添加下面的代码。</p><figure class="mj mk ml mm fq hw"><div class="bz el l di"><div class="nh ni l"/></div><figcaption class="nj nk fg fe ff nl nm bd b be z ek">Step 1 of adding logic to the handler.js</figcaption></figure><p id="4f43" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，有点不知所措是正常的。但是，没必要担心。这只是5个简单的功能。每个函数都有相同的值<code class="eh mw mx my mo b">context.callbackWaitsForEmptyEventLoop</code>设置为<code class="eh mw mx my mo b">false</code>，并以<code class="eh mw mx my mo b">connectToDatabase()</code>函数调用开始。一旦<code class="eh mw mx my mo b">connectToDatabase()</code>函数解决了这个问题，它将继续通过Mongoose执行数据库交互。我们将在实际的数据库交互中使用<code class="eh mw mx my mo b">Note</code>模型方法。但是等等，我们还没有定义或创建这些！你们一定在问自己我怎么了。我是故意这样做的，首先我想让你看到这并不复杂，与用Node.js和Express创建REST API也没有什么不同。</p><p id="b591" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="kp">注意</em> </strong> <em class="kp"> : </em> <code class="eh mw mx my mo b">context.callbackWaitsForEmptyEventLoop</code> — <em class="kp">默认情况下，回调会等到Node.js运行时事件循环为空后，才会冻结进程，并将结果返回给调用者。您可以将该属性设置为false，以请求AWS Lambda在调用</em> <code class="eh mw mx my mo b"><em class="kp">callback</em></code> <em class="kp">后立即冻结进程，即使事件循环中有事件。AWS Lambda将冻结Node.js事件循环中的流程、任何状态数据和事件(下一次调用Lambda函数时，如果AWS Lambda选择使用冻结的流程，将处理事件循环中的任何剩余事件)。<br/> - </em> <a class="ae lu" href="https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> AWS文档</em> </a></p><p id="3866" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是时候添加实际的数据库连接了。在我们添加代码之前，重要的是要理解连接将被建立一次。当Lambda第一次被调用时，这被称为冷启动，AWS将启动一个Docker容器来运行代码。这是我们连接到数据库的时候。所有后续请求都将使用现有的数据库连接。从概念上讲，这很容易理解，但是当我们需要在代码中理解它的时候，就很难了。开始了。</p><h2 id="f6fb" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">6.添加数据库连接</h2><p id="ae4a" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">连接到MongoDB的过程是双重的。我们需要创建一种动态的方式来创建连接，但也要确保重用相同的连接(如果可用的话)。我们会慢慢开始。</p><p id="7fc1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在服务的根目录下创建一个新文件，就在<strong class="je ig"> handler.js </strong>旁边。给它起一个很有逻辑的名字<strong class="je ig"> db.js </strong>，并添加下面的代码。</p><figure class="mj mk ml mm fq hw"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="4bc6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="kp">注意</em> </strong> <em class="kp">:此语法对mongose 5 . 0 . 0-rc0及以上版本有效。它将不会与低于5的任何版本的猫鼬一起工作。</em></p><p id="4199" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在第1行，我们需要mongose，就像我们习惯的那样，在第2行，我们添加了mongose使用的本地promise库。这是因为当我们用<code class="eh mw mx my mo b">Note</code>模型方法调用它们时，我们希望<code class="eh mw mx my mo b">.then</code>在<strong class="je ig"> handler.js </strong>中正常工作。</p><p id="870f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么<code class="eh mw mx my mo b">isConnected</code>变量呢？我们正在创建一个闭包，并将<code class="eh mw mx my mo b">isConnected</code>视为正在运行的Docker容器中的当前数据库状态。看看我们输出的<code class="eh mw mx my mo b">connectToDatabase</code>函数。在第12行，我们正在用一个环境变量提供的连接字符串建立一个连接。这个函数返回一个承诺，我们简单地用<code class="eh mw mx my mo b">.then</code>并得到一个<code class="eh mw mx my mo b">db</code>对象。这个对象表示当前的连接，并且有一个我们特别感兴趣的属性。<code class="eh mw mx my mo b">.readyState</code>将告诉我们连接是否存在。如果是，就等于<code class="eh mw mx my mo b">1</code>，否则就是<code class="eh mw mx my mo b">0</code>。</p><p id="5cd2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们基本上是缓存数据库连接，确保它不会被创建，如果它已经存在。那样的话我们就马上解决承诺。</p><p id="1bca" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<strong class="je ig"> db.js </strong>文件的创建，让我们在<strong class="je ig"> handler.js </strong>中要求它。只需将这段代码添加到处理程序的顶部。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="d8c2" class="lv ks if mo b fv ms mt l mu mv">// top of handler.js<br/>const connectToDatabase = require('./db');</span></pre><h2 id="f39e" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">7.添加注释模型</h2><p id="e9fc" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">再看一下handler.js。可以看到我们在函数中调用了<code class="eh mw mx my mo b">Note</code>模型来检索数据，但是没有定义模型。好吧，现在正是时候。</p><p id="b970" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在服务根目录下创建一个新文件夹，命名为<strong class="je ig"> models </strong>。在其中创建另一个文件并将其命名为<strong class="je ig"> Note.js </strong>。这将只是一个简单的mongoose模式和模型定义。</p><figure class="mj mk ml mm fq hw"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="d30a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将导出模型本身，以便在<strong class="je ig"> handler.js </strong>中使用它。这就是数据库连接性。我们只需要在处理程序的顶部添加另一个require语句，就可以开始了。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="db3f" class="lv ks if mo b fv ms mt l mu mv">// top of handler.js<br/>const connectToDatabase = require('./db');<br/>const Note = require('./models/Note');</span></pre><p id="ffe8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很好，现在剩下的就是添加一个环境变量来保存我们的MongoDB数据库连接URL。跟<strong class="je ig"> dotenv </strong>那是小菜一碟。</p><h2 id="0027" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">8.对环境变量使用dotenv</h2><p id="5b06" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">用dotenv将配置文件和密钥放在一个完全独立的文件中非常容易，这是一个真正的生活保护程序。您只需将文件添加到<strong class="je ig">中。gitignore </strong>并确保你不会冒险泄露任何密钥。让我展示给你看。</p><p id="8764" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">添加一个新文件，将其命名为<strong class="je ig"> variables.env </strong>。请确保将其放在服务的根目录中。文件本身只有一行，那是环境变量的名字和它的值。它看起来应该有点像这样。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="9174" class="lv ks if mo b fv ms mt l mu mv">DB=mongodb://&lt;user&gt;:<a class="ae lu" href="mailto:admin123@cluster0-shard-00-00-4ra8y.mongodb.net" rel="noopener ugc nofollow" target="_blank">&lt;password&gt;@</a>mongodb.net:27017/db</span></pre><p id="f982" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，首先我们需要找到连接URL。为此，我们需要回到阿特拉斯。在您之前创建的项目的主集群页面上，您将看到您的集群已经被创建。它有一个我们想按的连接按钮。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nn"><img src="../Images/ad4ebef8f13ce7ead67106f86690b689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCjlEYwbr8Itb-iIBopKZg.png"/></div></div></figure><p id="9f3d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将打开一个新的弹出窗口，您需要将一个IP地址添加到白名单中，这样您就可以访问数据库了。然后，您通过按下<strong class="je ig">“连接您的应用程序”</strong>按钮获取连接URL。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff no"><img src="../Images/04b404351fd6a433c5039875a1b0e492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKS4lPXQxcW9JC4HnreM4Q.png"/></div></div></figure><p id="14bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">按下<strong class="je ig">“连接应用程序”</strong>后，系统会提示您“<strong class="je ig">复制连接字符串”</strong>。按“<strong class="je ig">我使用的是3.4或更早版本的驱动程序”</strong>，你就可以复制网址了。哇，这是一个令人厌倦的旅程。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff np"><img src="../Images/30a3feab1de3785dad035985cacc44a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWheGowWjS9eV3D9ayDPkA.png"/></div></div></figure><p id="6eb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你复制了它，回到<strong class="je ig"> variables.env </strong>文件并添加实际的连接URL。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="ed32" class="lv ks if mo b fv ms mt l mu mv">DB=mongodb://dbadmin:<a class="ae lu" href="mailto:reallystrongpassword@cluster0-shard-00-00-e9ai4.mongodb.net" rel="noopener ugc nofollow" target="_blank">reallystrongpassword@cluster0-shard-00-00-e9ai4.mongodb.net</a>:27017,cluster0-shard-00-01-e9ai4.mongodb.net:27017,cluster0-shard-00-02-e9ai4.mongodb.net:27017/test?ssl=true&amp;replicaSet=Cluster0-shard-0&amp;authSource=admin</span></pre><p id="738b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">确保不要在<strong class="je ig"> DB </strong>和连接URL之间添加空格。更改您之前设置的密码<code class="eh mw mx my mo b">&lt;password&gt;</code>。我的密码是“真正的强密码”。现在会发生什么？这个文件中的变量将被加载到Node.js中的<code class="eh mw mx my mo b">process.env</code>对象中，这意味着你可以用你已经习惯的标准方式访问它们。</p><p id="eb56" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="kp">注意</em> </strong> <em class="kp">:不要忘记将变量. env添加到。gitignore！</em></p><p id="b0e7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，在开始测试之前，我们需要dotenv模块并指向保存环境变量的文件。将这个代码片段添加到您的<strong class="je ig"> handler.js </strong>文件的顶部。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="29d2" class="lv ks if mo b fv ms mt l mu mv">require('dotenv').config({ path: './variables.env' });</span></pre><p id="3a24" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。是时候尝试一下了。</p><h1 id="0f37" class="kr ks if bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">做些测试怎么样？</h1><p id="76a1" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">我们准备好测试API了。首先，我们需要离线运行无服务器。但是，由于我们在<strong class="je ig"> Note.js </strong>中的Mongoose模型定义，我们需要在运行它时添加一个标志。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="f7a3" class="lv ks if mo b fv ms mt l mu mv">$ sls offline start --skipCacheInvalidation</span></pre><p id="6767" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">在Node.js中当你 <code class="eh mw mx my mo b"><em class="kp">require()</em></code> <em class="kp">一个模块的时候，它存储了该模块的一个缓存版本，这样以后所有对</em> <code class="eh mw mx my mo b"><em class="kp">require()</em></code> <em class="kp">的调用都不用从文件系统重新加载该模块。</em></strong></p><p id="162a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦您在终端中运行了该命令，您应该会看到类似这样的内容。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nq"><img src="../Images/edec64054855723ac7b9baefcb91430b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44QsPUia_wFWi7IYWHRVSA.png"/></div></div></figure><p id="0228" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们所有的路线都正常运行。打开您选择的REST客户端，邮递员、失眠或任何您喜欢的，让我们继续测试。</p><p id="614a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<a class="ae lu" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠</a>，我用JSON主体创建了一个对<code class="eh mw mx my mo b"><a class="ae lu" href="http://localhost:3000/notes" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/notes</a></code>的POST请求。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/0477efccb8a2dfcc7d504b5842a1bbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eg1T3qGPKXpLJ4zPtgmPw.png"/></div></div></figure><p id="7587" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">检查终端，您可以看到<code class="eh mw mx my mo b">=&gt; using new database connection</code>被记录，这意味着初始数据库连接已经建立。再发一个帖子请求，你会看到<code class="eh mw mx my mo b">=&gt; using existing database connection</code>被登录了。</p><p id="2ec6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太棒了，添加一个新笔记很有效。让我们使用<strong class="je ig"> getOne </strong>方法检索刚刚添加的注释。从响应中复制<code class="eh mw mx my mo b">_id</code>并粘贴到GET请求的URL中。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/dc5673878b7812319e1dd70c703abfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLXWmBS3RLE4Ps-eag9ArQ.png"/></div></div></figure><p id="fbe4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">检索单个笔记也很好。把他们都找回来怎么样？删除ID路由路径参数，再次点击<strong class="je ig">“发送”</strong>。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/12d2ddaa7615527ac21b43a42e91ba12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBmXLpnhNo3SlJHZcq14Ig.png"/></div></div></figure><p id="c853" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只需再尝试两个方法，即编辑和删除方法。从检索到的音符中选择一个<code class="eh mw mx my mo b">_id</code>并再次将其添加为路径参数。现在将方法改为PUT并添加一个JSON主体。输入不同的标题和描述，然后点击<strong class="je ig">“发送”</strong>。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/c7d6b1a6352b140d1d4c8a53edbcf890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRtEFSnNu-_XUFUbpjO4tQ.png"/></div></div></figure><p id="0542" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编辑工作很好，正如我们所希望的那样。只剩下删除。更改删除方法，删除请求正文，最后一次点击<strong class="je ig">“发送”</strong>。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/a41d6d0c1e8867053f9fc777503789f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7dja3lmgtYSskIAsu626w.png"/></div></div></figure><p id="5101" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该注释已成功删除。关于测试，这已经足够了。我们已经准备好将服务部署到AWS。</p><h1 id="dd51" class="kr ks if bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">负责部署和监控</h1><p id="2951" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">唷，你需要考虑很多事情。我们在最后冲刺阶段。唯一剩下的事情就是部署服务，并通过使用一个名为<a class="ae lu" href="https://www.dashbird.io/" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>的监控工具来确保它按照我们想要的方式运行。</p><h2 id="79ca" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">9.部署</h2><p id="c1b6" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">无服务器框架使部署变得快速而轻松。你需要做的就是运行一个命令。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="8f19" class="lv ks if mo b fv ms mt l mu mv">$ sls deploy</span></pre><p id="bbba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它将自动在AWS上提供资源，打包并将所有代码推送到S3，然后从那里发送到Lambdas。终端应该显示类似如下的输出。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nr"><img src="../Images/7b7bbfb9c35d52d0e55870f644f7e42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMX_CTpS43BrX6y6ojpDdQ.png"/></div></div></figure><p id="f68e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="kp">注意</em> </strong> <em class="kp">:您可以使用提供的端点从上面重复测试过程。</em></p><p id="8057" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是部署流程的全部内容。简单对吗？这就是我如此热爱无服务器框架的原因。</p><h2 id="79cf" class="lv ks if bd kt lw lx ly kx lz ma mb lb jn mc md lf jr me mf lj jv mg mh ln mi dt translated">10.监视</h2><p id="e5e7" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">让我们用另一个很酷的工具来结束它。我用Dashbird 监控我的Lambdas，我很喜欢它。它有一个<a class="ae lu" href="https://dashbird.io/pricing/" rel="noopener ugc nofollow" target="_blank">免费层</a>并且不需要信用卡注册！我向您展示这一点也是为了让您看到Lambda函数调用的控制台日志。它们会告诉你Lambda何时使用新的或现有的数据库连接。这是主仪表板的样子，在这里我可以看到我所有的Lambdas和它们的统计数据。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/6b562da04a77d4edc9bcd8b6ca148b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOQgJ9vdO0tXqlbN9UzRdw.png"/></div></div></figure><p id="a2bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">按下<strong class="je ig">rest-API-dev-get all</strong>Lambda函数后，我将进入一个屏幕，显示这个特定函数的所有统计数据和日志。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/33907f9cd2db68c3b5e92db757afd7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPgnKSyUnDkn0qJEpNrhUg.png"/></div></div></figure><p id="d5c1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在底部，您可以看到对getAll函数的两次调用。在按下两者中较老的一个之后，它把我带到另一个页面，显示关于那个特定调用的信息。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/79e4426fd3d81d8860aa2540581d84c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60O0ePvfnQ4wL-hgl_eJKQ.png"/></div></div></figure><p id="880d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你所看到的，控制台用<code class="eh mw mx my mo b">=&gt; using new database connection</code>进行了记录，实际的请求花费了大约1.5秒。</p><p id="2d97" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">后退并按下另一个调用，我们可以看到一个类似的，但幸运的是，我们看到的是一个不同的图像。</p><figure class="mj mk ml mm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/98d09cbc2ccabf9a4a81d6b15f1734f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqWARKXs8gCxVGcUghTs1A.png"/></div></div></figure><p id="9d69" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦相同的Lambda函数被再次调用，它将重用现有的连接。在这里的日志中可以清楚的看到。</p><h1 id="2cef" class="kr ks if bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">线的尽头</h1><p id="d605" class="pw-post-body-paragraph jc jd if je b jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz hn dt translated">真是情绪过山车。您已经踏上了用MongoDB创建无服务器REST API的旅程。我已经尽了最大努力来传递我到今天为止所收集的经验，以向您展示创建合适的API的首选方式。我展示的许多技巧都是我自己日常使用的。明智地使用这些技能，并享受深入挖掘无服务器架构的可能性及其带来的一切。</p><p id="e3f8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想看看我们上面写的所有代码，<a class="ae lu" href="https://github.com/adnanrahic/building-a-serverless-rest-api-with-nodejs" rel="noopener ugc nofollow" target="_blank">这里是库</a>。或者如果你想看我最新的文章，请到这里来。</p><div class="ht hu fm fo hv ka"><a href="https://medium.com/@adnanrahic/latest" rel="noopener follow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd ig fv z el kf eo ep kg er et ie dt translated">阿德南·拉希奇写的最新故事</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">阅读Adnan Rahi在Medium上写的最新故事。软件工程师@bookvar_co .编码教育家@ACADEMY387…</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">medium.com</p></div></div><div class="kj l"><div class="ns l kl km kn kj ko ib ka"/></div></div></a></div><p id="c7b8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kp">希望你们喜欢读这篇文章，就像我喜欢写这篇文章一样。</em> <br/> <em class="kp">你觉得这个教程会对某人有帮助吗？不要犹豫分享。如果你喜欢，击碎下面的</em> <strong class="je ig"> <em class="kp">拍手</em> </strong> <em class="kp">这样其他人会在Medium上看到这个。</em></p><figure class="mj mk ml mm fq hw"><div class="bz el l di"><div class="nt ni l"/></div></figure></div></div>    
</body>
</html>