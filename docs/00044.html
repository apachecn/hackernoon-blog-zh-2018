<html>
<head>
<title>Strengthening OAuth2 for Mobile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加强移动OAuth2</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/strengthening-oauth2-for-mobile-f4f3925dbf18?source=collection_archive---------4-----------------------#2018-01-03">https://medium.com/hackernoon/strengthening-oauth2-for-mobile-f4f3925dbf18?source=collection_archive---------4-----------------------#2018-01-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ad68" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">应用证明技术弥补了常见的身份认证差距</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/b17d0bfd4fe261dec44a1080672731a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rE_j5qx5-sF6HYNKG7AcZA.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/photos/iPiTNFiB_oI?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Patrick Metzdorf</a> on <a class="ae jz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="76c0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">OAuth2 ，通常与<a class="ae jz" href="http://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID-Connect </a> (OIDC)结合使用，是一个流行的授权框架，使应用程序能够保护资源免受未授权的访问。它将用户身份验证委托给授权服务，然后授权第三方应用程序代表用户访问受保护的资源。OAuth2为web和移动应用程序提供了授权流。</p><p id="c438" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">OAuth2最流行的流程是授权代码授权流程，用于授权机密客户端访问受保护的资源。客户端使用客户端id来标识自己，并使用客户端密码向授权服务验证自己。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff kw"><img src="../Images/7e4943f02e980b32652d3efe6f6e6326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTkyLyIkcrqBkljzIYsOBQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">OAuth2 Authorization Code Grant Flow</figcaption></figure><p id="7e65" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">授权代码授权很好地分离了前端和后端流程。前端流被委托给用户代理，通常是系统浏览器，它验证用户凭证并要求用户授予客户端访问受保护资源的授权许可。成功后，授权码将返回给客户端。在后端流程中，客户端通过客户端密码进行身份验证，交换访问和刷新令牌的授权码。客户端使用访问令牌代表用户访问受保护的后端资源。</p><h1 id="e2a0" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">移动OAuth2代码授权</h1><p id="e788" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">在代码授权流程中，客户端机密仅向授权服务器公开。它永远不会通过潜在的不太安全的前端用户代理公开。</p><p id="acea" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在OAuth2中，机密客户端是能够安全保护客户端机密的客户端。不幸的是，本地应用被认为是公开的，而不是机密的客户端。他们无法<a class="ae jz" href="https://hackernoon.com/mobile-api-security-techniques-682a5da4fe10" rel="noopener ugc nofollow" target="_blank">保护静态机密</a>。混淆和代码强化技术使秘密更难窃取，但并非不可能。如果客户端秘密可以被窃取，那么任何人都可以使用它来完成授权码交换。</p><p id="2980" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">由于公开的客户秘密根本不是秘密，许多身份和授权服务提供商干脆放弃客户秘密。A <a class="ae jz" href="https://appauth.io/" rel="noopener ugc nofollow" target="_blank"> ppAuth </a>，一个流行的开源Android和iOS OAuth2 SDK，<a class="ae jz" href="https://github.com/openid/AppAuth-Android#utilizing-client-secrets-dangerous" rel="noopener ugc nofollow" target="_blank">建议不要利用客户端机密</a>:</p><blockquote class="lu lv lw"><p id="5115" class="ka kb lx kc b kd ke iv kf kg kh iy ki ly kk kl km lz ko kp kq ma ks kt ku kv hn dt translated"><strong class="kc hv">利用客户机密(危险)</strong></p><p id="b009" class="ka kb lx kc b kd ke iv kf kg kh iy ki ly kk kl km lz ko kp kq ma ks kt ku kv hn dt translated">我们<em class="hu">强烈建议</em>尽可能避免在本地应用程序中使用静态客户端机密。通过动态客户端注册获得的客户端机密可以安全使用，但静态客户端机密可以很容易地从您的应用程序中提取出来，并允许其他人假冒您的应用程序并窃取用户数据。如果您正在集成的OAuth2提供程序必须使用客户端机密，我们强烈建议在您的后端执行代码交换步骤，在这里可以隐藏客户端机密。</p></blockquote><p id="408b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">公共客户端容易受到各种攻击，包括授权代码和令牌窃取以及恶意软件的客户端冒充。对于不安全的秘密或根本没有秘密的情况，为了恢复用于移动设备的OAuth2代码授权流的完整性，本地应用保护必须从公共客户端强度提高到机密客户端强度。</p><h1 id="8a27" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">代码交换的证明密钥(PKCE)</h1><p id="af9a" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">在使用基本代码授权流的公共客户端上，任何可以观察到前端授权代码的人都可以尝试用它来交换访问和刷新令牌。<a class="ae jz" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank">代码交换的验证密钥</a> (PKCE)被添加到基本流程中，以帮助弥补这一弱点。它试图确保发起前端代码请求的客户端与随后请求后端代码交换的客户端是同一客户端。</p><p id="bbab" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">客户端首先生成一个名为<code class="eh mb mc md me b">code_verifier</code>的运行时秘密。在PKCE的stringer形式中，客户机散列这个秘密，并作为前端请求的一部分发送这个<code class="eh mb mc md me b">code_challenge</code>值。授权服务器保存该值。无论有没有客户端密码，客户端都会将代码验证器作为其后续后端代码交换请求的一部分。授权服务器将<code class="eh mb mc md me b">code_verifier</code>的散列与它收到的原始<code class="eh mb mc md me b">code_challenge</code>进行比较。如果它们匹配，服务将照常处理代码交换请求。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff kw"><img src="../Images/e8947f3e3136d52a818b512070c1164c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OLFDp6zgklIlUB6MXMqBUw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">OAuth2 Authorization Code Grant Flow with PKCE</figcaption></figure><p id="2826" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">利用PKCE，窃取授权代码的恶意行为者在不知道原始代码验证者的情况下不能成功地完成代码交换。代码验证器是运行时生成的秘密。因此，它是短暂的，不需要在客户端持久化，所以代码验证器在移动客户端可以被认为是机密的。</p><p id="1e7a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">围绕PKCE的可能攻击需要生成一个假的<code class="eh mb mc md me b">code_verifier</code>并将相应的假的<code class="eh mb mc md me b">code_challenge</code>散列注入到客户端的原始前端请求中。在观察到返回的授权码后，恶意参与者可以发送其假的<code class="eh mb mc md me b">code_verifier</code>来完成交换。</p><p id="7844" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">像<a class="ae jz" href="https://hackernoon.com/hands-on-mobile-api-security-pinning-client-connections-ebee4d82a911" rel="noopener ugc nofollow" target="_blank"> SSL/TLS和证书锁定</a>这样的技术可以防止这些类型的攻击，但它们不能防止重新打包的应用程序冒充应用程序及其授权流。</p><h1 id="ecd9" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">动态客户端身份验证</h1><p id="4610" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">动态客户端认证使用<a class="ae jz" href="https://hackernoon.com/api-protection-requires-both-user-and-app-authentication-8a8101ed3f23" rel="noopener ugc nofollow" target="_blank">远程证明技术</a>来验证应用程序是真实的和未经篡改的。</p><p id="dc5a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">客户端向应用认证服务请求认证。该服务发出一个随机的、证明性的质询，客户端用一个安全的、可验证的响应进行响应。服务器回复一个短期批准令牌，该令牌可能有效，也可能无效，具体取决于证明结果。在正常使用中，此批准令牌被添加到后端API调用中，以确保只有正版和批准的应用程序才能成功访问后端资源服务。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mf"><img src="../Images/8e043e6aa324ff6f0cfc232d8b287996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-T63yTQ8hjh9I39COzOL4w.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">API Protection Using Dynamic Client Authentication</figcaption></figure><p id="39bd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">使用动态客户端身份验证，客户端没有身份验证秘密。相反，应用认证服务和后端资源服务共享应用认证秘密。当应用程序认证服务认证客户端应用程序时，它使用认证秘密对批准令牌(通常是一个<a class="ae jz" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌(JWT) </a>)进行签名，并将签名的令牌返回给客户端。客户端将令牌添加到API调用，后端资源服务使用身份验证机密来验证批准令牌未过期，并且由相同的应用程序身份验证机密正确签名。即使令牌通过客户端，应用程序身份验证机密也不会直接暴露给客户端。</p><h1 id="4115" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">安全OAuth2代码授权流</h1><p id="6ca9" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">app authentication service充当批准令牌的来源，这些令牌实际上是短暂的运行时客户端机密。通过对代码授权流的简单扩展，您可以用一系列运行时客户端机密替换静态的<code class="eh mb mc md me b">client_secret</code>。由于客户端中不存在应用认证秘密，并且批准令牌在加密上是不可逆的，因此现在可以将应用视为机密的OAuth2客户端，符合安全授权码授权流的要求。</p><p id="9ddf" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">最重要的是，由于对客户端应用程序的任何篡改都会导致证明失败，因此在OAuth2流程中，假冒的应用程序无法再模拟有效的客户端。</p><h1 id="5e42" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">概念实施证明</h1><p id="1ed2" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">使用Android和<a class="ae jz" href="https://appauth.io/" rel="noopener ugc nofollow" target="_blank"> AppAuth </a>为Google身份服务演示了一个概念验证实现。</p><p id="11e4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在使用AppAuth SDK 将OAuth2添加到移动Android和iOS客户端的过程中，开发了一个搜索和查找喜爱书籍的Android应用程序，展示了<a class="ae jz" href="https://developers.google.com/identity/protocols/OAuth2" rel="noopener ugc nofollow" target="_blank"> Google OAuth2 </a>、<a class="ae jz" href="https://developers.google.com/apis-explorer" rel="noopener ugc nofollow" target="_blank">Google API</a>和<a class="ae jz" href="https://github.com/openid/AppAuth-Android" rel="noopener ugc nofollow" target="_blank"> Android AppAuth </a>库。我们使用CriticalBlue的免费<a class="ae jz" href="https://www.approov.io/demo-reg.html" rel="noopener ugc nofollow" target="_blank">approv演示服务</a>将动态应用认证添加到OAuth2流程中。</p><p id="f8b9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因为我们不能直接修改Google的OAuth2身份验证，所以我们添加了一个OAuth2适配器服务，它可以验证Approov的令牌并协调OAuth2代码以进行访问令牌交换。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mg"><img src="../Images/92fec27e13fa35480928df98dcff0e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hLNJ6fT0Pu-OLabp26KHw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Secure Mobile OAuth2 Code Grant Flow (PKCE not Shown)</figcaption></figure><p id="6af8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">Google的OAuth2适配器修改了两个授权端点。为了方便起见，OpenID发现端点被修改，以便客户端可以轻松地配置自己来使用修改后的身份验证服务。更重要的是，OAuth2令牌端点被修改为接受来自客户端的运行时批准令牌。</p><p id="e12e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">为了跟进，首先在GitHub上克隆app auth-oauth 2-approv演示项目，该项目可在<a class="ae jz" href="https://github.com/approov/AppAuth-OAuth2-Books-Demo" rel="noopener ugc nofollow" target="_blank">github.com/approov</a>获得。OAuth2适配器是一个节点服务器，位于克隆存储库的<strong class="kc hv"> oauth2-adapter </strong>子目录中。Android客户端应用程序位于克隆存储库的<strong class="kc hv"> books-client </strong>子目录中。</p><h2 id="4444" class="mh ky hu bd kz mi mj mk ld ml mm mn lh kj mo mp lj kn mq mr ll kr ms mt ln mu dt translated">OAuth2适配器TLS证书</h2><p id="c26f" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">客户端适配器路径受到TLS保护和固定是很重要的。由于概念验证将使用本地主机服务器进行演示，我们将把它的自签名证书绑定到Android客户端，并使用HTTPS在客户端、适配器、Google OAuth2和API路径之间进行通信。</p><p id="8db3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">要生成TLS公共证书-私钥对，请打开终端并运行:</p><pre class="jk jl jm jn fq mv me mw mx aw my dt"><span id="aa6a" class="mh ky hu me b fv mz na l nb nc">$ openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem <br/>    -days 3660 -nodes</span></pre><p id="bbf0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">将key.pem和cert.pem文件复制到OAuth2适配器的配置目录中，该目录位于<your-repo> /oauth2-adapter/config/。</your-repo></p><p id="ee9f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">将cert.pem文件复制到位于<your-repo>/Books-client/app/src/main/assets/的Books应用程序的资产目录中。</your-repo></p><h2 id="7e21" class="mh ky hu bd kz mi mj mk ld ml mm mn lh kj mo mp lj kn mq mr ll kr ms mt ln mu dt translated">Google客户端凭据</h2><p id="cb58" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">你将使用<a class="ae jz" href="https://developers.google.com/books/docs/v1/using" rel="noopener ugc nofollow" target="_blank">谷歌图书API </a>在Android上执行开放和授权的搜索。这需要一个API键来访问API的公共部分，比如开卷搜索。需要OAuth2访问令牌来访问API的私有部分，比如查找您最喜欢的书籍。</p><p id="07fe" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">为了注册Android的API密钥和OAuth2凭证，Google需要一个公钥SHA1指纹，它通常是签名您的Android应用程序包的公钥的指纹。对于这个演示，我们将创建一个新的秘密密钥库，并将相同的密钥材料用于API密钥、OAuth2凭证和应用程序的签名配置。</p><p id="bd12" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在终端中，使用Java keytool生成一个“秘密”密钥库，并提取指纹。为了方便起见，您可以对所有参数使用“secret”。</p><pre class="jk jl jm jn fq mv me mw mx aw my dt"><span id="3a12" class="mh ky hu me b fv mz na l nb nc">$ keytool -genkey -keystore secret.keystore -alias secret <br/>    -keyalg RSA -keysize 2048 -validity 10000 -keypass secret <br/>    -storepass secret -dname 'CN=secret'</span><span id="8252" class="mh ky hu me b fv nd na l nb nc">$ keytool -list -v -keystore secret.keystore -storepass secret | <br/>    grep SHA1</span><span id="4b86" class="mh ky hu me b fv nd na l nb nc">SHA1:<br/>C5:A9:B1:F8:A3:8D:07:B3:30:D2:12:06:D2:BA:1E:CF:91:FA:60:97</span></pre><p id="c0e3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">确保将<strong class="kc hv"> secret.keystore </strong>放在克隆存储库的&lt;your-repo&gt;/books-client/目录中。</p><p id="62b0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">接下来进入<a class="ae jz" href="https://console.developers.google.com" rel="noopener ugc nofollow" target="_blank">谷歌开发者控制台</a>并登录。选择或创建新项目。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/656ed5fedb2974b67493466577b4d872.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*-17huXKWt0lMbPGX-W_6yA.png"/></div></figure><p id="ad34" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">此屏幕截图中的项目显示为“验证演示”。使用秘密指纹创建API密钥:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/1200e4917714f23ad865bd13bc40a0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vCZ_pKVi_wE1mTCriAx_g.png"/></div></div></figure><p id="1ec1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">接下来，您将创建一个OAuth2客户端ID和密码。您可能希望使用Android应用程序类型，但是它不会生成客户端秘密。相反，请确保您选择了Web应用程序类型:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ng"><img src="../Images/93c1716befbe669fe733c58b1281b5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aa6i9eNtDjgz3wU6FDwOsA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Web Application OAuth2 Client Credentials</figcaption></figure><p id="688a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">完成OAuth2同意屏幕:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/b2ee8e69ba95bf782aa03cb4a440a11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*u7Q0FfmkhY1K3wWz_kKnAQ.png"/></div></figure><p id="1b83" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">最后，转到<a class="ae jz" href="https://console.developers.google.com/apis/library" rel="noopener ugc nofollow" target="_blank"> Google API库</a>页面，找到并启用Google Books API。</p><h2 id="2bfc" class="mh ky hu bd kz mi mj mk ld ml mm mn lh kj mo mp lj kn mq mr ll kr ms mt ln mu dt translated">Approov演示注册</h2><p id="74d7" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">证明服务用于在客户端和代理服务器之间建立信任。打开浏览器，访问<a class="ae jz" href="https://www.approov.io/demo-reg.html" rel="noopener ugc nofollow" target="_blank">https://www.approov.io/demo-reg.html</a>获得免费演示服务。完成注册，打开您的电子邮件，将附件解压到一个方便的地方。</p><h2 id="fa50" class="mh ky hu bd kz mi mj mk ld ml mm mn lh kj mo mp lj kn mq mr ll kr ms mt ln mu dt translated">OAuth2适配器设置</h2><p id="9ecb" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">将OAuth2适配器配置为使用来自客户端的Approov令牌和Google的Google client secret。</p><p id="121a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在<your-repo> /oauth2-adapter/config目录中，将secrets_sample.js文件复制到同一个目录中，并将其命名为secrets.js，将approov _ token _ secret值设置为演示包电子邮件中提供的字符串。将google_client_secret的值设置为在前面的Google credentials步骤中提供的客户端机密。</your-repo></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="dc5e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在OAuth2适配器目录中，运行npm install以完成适配器设置。</p><p id="a734" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">您现在应该能够使用npm start成功运行适配器，但是默认情况下，Approov强制将被禁用。</p><pre class="jk jl jm jn fq mv me mw mx aw my dt"><span id="d932" class="mh ky hu me b fv mz na l nb nc">&lt;your-repo&gt;/oauth2-adapter$ npm start</span><span id="d56e" class="mh ky hu me b fv nd na l nb nc">&gt; oauth2-approov-adapter@1.0.0 start &lt;your-repo&gt;/oauth2-adapter<br/>&gt; node server.js</span><span id="e369" class="mh ky hu me b fv nd na l nb nc"><strong class="me hv">CAUTION: Approov token checking is disabled!</strong></span><span id="3e68" class="mh ky hu me b fv nd na l nb nc">Server listening on ports 3000 &amp; 3001</span></pre><h2 id="e014" class="mh ky hu bd kz mi mj mk ld ml mm mn lh kj mo mp lj kn mq mr ll kr ms mt ln mu dt translated">AppAuth客户端设置</h2><p id="5fe1" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">在您项目的<strong class="kc hv"> books-client </strong>目录中，创建一个<strong class="kc hv"> secret.gradle </strong>文件，它将保存您的配置信息:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="e0d8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在Google credentials步骤中，将API键和客户机ID值复制到secrets文件中。</p><p id="a5a7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">gradle build会在构建应用程序时将这些配置信息插入到应用程序中。git将忽略<strong class="kc hv"> secret.keystore </strong>和<strong class="kc hv"> secret.gradle </strong>，因此这两个文件都不会保存在您的存储库中。</p><p id="420c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">接下来，将Approov SDK添加到Android客户端。使用之前解压缩的approv演示包，找到Android approov.aar库，并将其复制到位于<your-repo>/books-client/approv/的books客户端的approv子项目中。</your-repo></p><p id="8f5f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在，您应该能够成功构建图书应用程序了。一旦构建正确，您就可以在Android模拟器中测试它了。</p><p id="a1d8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">注意:用于web应用程序的Google OAuth2服务需要HTTPS重定向URI。最近的Android版本要求HTTPS应用程序链接通过托管资产链接文件验证该链接。为了避免额外的配置，建议用于测试的Android设备或仿真器运行Marshmallow (API 23)或更早的版本。</p><p id="c752" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">为了测试设置，启动OAuth2适配器，然后在Android中启动books客户端。如果正确注册了API键，您应该能够成功搜索图书:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/6a57d834a3917e26e582d5afaad247a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*QDB2MArSokQxN7mPUwJRnQ.png"/></div></figure><p id="3daa" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">要测试OAuth2服务，请在book client下拉菜单中选择login项。这将启动一个OAuth2同意屏幕:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/608ef2591b654e2dd829b59a36037a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*WgZdO3qHi9RVYLd8TTIbMw.png"/></div></figure><p id="a1f8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">使用任何Google用户凭证登录，现在您应该会在客户端的顶部栏中看到一个登录图标，并且在下拉菜单中，应该会启用favorites项。</p><p id="0fa0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">有关更多使用细节和调试，请参考文章<a class="ae jz" href="https://hackernoon.com/adding-oauth2-to-mobile-android-and-ios-clients-using-the-appauth-sdk-f8562f90ecff" rel="noopener ugc nofollow" target="_blank">使用AppAuth SDK将OAuth2添加到移动Android和iOS客户端</a>。</p><h2 id="f8dc" class="mh ky hu bd kz mi mj mk ld ml mm mn lh kj mo mp lj kn mq mr ll kr ms mt ln mu dt translated">Approov客户注册</h2><p id="53a1" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">要向approv注册图书客户端，请打开一个终端或命令窗口，并切换到解压缩的approv演示文档中的目录，该文档包含适用于Android和您的本地环境的注册工具。例如，在Linux上，该目录是<code class="eh mb mc md me b">&lt;your-demo-dir&gt;/registration-tools/Android/Linux</code>。运行注册工具，指定应用程序APK的路径。对于图书客户端，这将是<code class="eh mb mc md me b">&lt;your-repo&gt;/books-client/app/build/outputs/apk/app-debug.apk</code>:</p><pre class="jk jl jm jn fq mv me mw mx aw my dt"><span id="ee58" class="mh ky hu me b fv mz na l nb nc">tutorial$ cd &lt;your-demo-dir&gt;/registration-tools/Android/Linux</span><span id="3393" class="mh ky hu me b fv nd na l nb nc">tutorial$ ./registration -a &lt;your-repo&gt;/books-client/app/<br/>build/outputs/apk/app-debug.apk -t ../../registration_access.tok <br/>-e 2d</span><span id="a282" class="mh ky hu me b fv nd na l nb nc">Submitting data…</span><span id="ac3a" class="mh ky hu me b fv nd na l nb nc">Success: new app signature added to database.</span><span id="8a7b" class="mh ky hu me b fv nd na l nb nc">You can check in the Approov portal that signature ******************************************** has been added to the library ****************</span></pre><p id="bfb2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">一旦注册被处理，Approov令牌应该开始验证。在OAuth2适配器中，您可以通过编辑<your-repo>/oauth 2-adapter/config/config . js并将<code class="eh mb mc md me b">approov_enforcement</code>设置为<strong class="kc hv"> true </strong>来实施Approov令牌验证。重新启动适配器，只要安装的应用程序是正版的，客户端登录就会继续成功。</your-repo></p><p id="a36c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果您从头开始重新构建客户端应用程序并重新安装，登录将会失败，因为新安装的应用程序与原始应用程序不同。重复注册命令，开始批准新应用程序的新登录。</p><h1 id="cf89" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">安全OAuth2移动代码授权流</h1><p id="8ec2" class="pw-post-body-paragraph ka kb hu kc b kd lp iv kf kg lq iy ki kj lr kl km kn ls kp kq kr lt kt ku kv hn dt translated">概念验证成功地演示了向移动代码授权流添加动态运行时秘密。增强的流与原始的代码授权流兼容，只需要授权服务器验证签名的令牌而不是静态秘密。</p><p id="9532" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">增强的秘密处理可以很容易地添加到现有的认证服务中，或者对于遗留服务，OAuth2适配器可以方便地作为网关服务添加到应用程序资源后端集群中。</p><p id="9cce" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">虽然动态应用程序身份验证通常用于保护后端API调用，但它是对OAuth2授权代码授权流的简单扩展。除了给予机密客户端代码授权流的所有保护之外，app authentication还为所有用户添加了客户端篡改和假冒保护。</p></div><div class="ab cl nl nm hc nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hn ho hp hq hr"><p id="650e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">感谢阅读！有关移动API安全性的更多信息，请查看<a class="ae jz" href="https://approov.io" rel="noopener ugc nofollow" target="_blank">www . approv . io</a>。</p><p id="cc4b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果你推荐这篇文章(点击👏按钮)以便其他人可以找到它。</p></div></div>    
</body>
</html>