<html>
<head>
<title>Functional architecture for Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift的功能架构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-architecture-for-swift-dfa8854239cb?source=collection_archive---------7-----------------------#2018-01-03">https://medium.com/hackernoon/functional-architecture-for-swift-dfa8854239cb?source=collection_archive---------7-----------------------#2018-01-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2784560df607cbf3cf4b71a2b134930d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rHrtpuEEnQj19mOUpS-pQ.png"/></div></div></figure><p id="4e73" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将介绍一个用于设计iOS应用程序的库，名为ArchitectureKit:</p><blockquote class="ka kb kc"><p id="03ba" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">“功能套件的最简单架构”</p></blockquote><h1 id="5b20" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">目录</h1><ol class=""><li id="361b" class="lf lg hu je b jf lh jj li jn lj jr lk jv ll jz lm ln lo lp dt translated">介绍</li><li id="ee35" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">动机</li><li id="8e34" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">建筑信息技术</li><li id="a2b9" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">依赖注入</li><li id="c116" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">完整示例</li><li id="11ad" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">结论</li></ol><h1 id="7e8b" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">1.介绍</h1><p id="bf08" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">ArchitectureKit是一个库，它试图加强正确性并简化应用程序和系统的状态管理。它帮助您编写行为一致且易于测试的应用程序。它受到了<a class="ae ly" href="https://redux.js.org" rel="noopener ugc nofollow" target="_blank"> Redux </a>和<a class="ae ly" href="https://github.com/NoTests/RxFeedback.swift" rel="noopener ugc nofollow" target="_blank"> RxFeedback </a>的强烈启发。</p><h1 id="f319" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">2.动机</h1><p id="a6cf" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我一直在努力寻找一种合适的方法和架构来简化管理和处理移动应用程序状态的复杂性，并且易于测试。</p><p id="3e2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我从<a class="ae ly" href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" rel="noopener ugc nofollow" target="_blank">模型-视图-控制器</a> (MVC)开始，然后是<a class="ae ly" href="https://msdn.microsoft.com/en-us/library/hh848246.aspx" rel="noopener ugc nofollow" target="_blank">模型-视图-视图模型</a> (MVVM)，还有<a class="ae ly" href="https://en.wikipedia.org/wiki/Model–view–presenter" rel="noopener ugc nofollow" target="_blank">模型-视图-展示者</a> (MVP)以及<a class="ae ly" href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" rel="noopener ugc nofollow" target="_blank">干净的架构</a>。MVC不像MVVM和MVP那样容易测试。<strong class="je hv"> MVVM和MVP很容易测试</strong>，但是问题是<strong class="je hv"> UI状态可能会很混乱</strong>，因为没有一个集中的方法来更新它，并且你可以在改变状态的代码中有很多方法。</p><p id="8dce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后出现了<a class="ae ly" href="https://guide.elm-lang.org/architecture/" rel="noopener ugc nofollow" target="_blank"> Elm </a>和<a class="ae ly" href="https://redux.js.org" rel="noopener ugc nofollow" target="_blank"> Redux </a>等类似Redux的架构如<a class="ae ly" href="https://github.com/redux-observable/redux-observable" rel="noopener ugc nofollow" target="_blank"> Redux-Observable </a>、<a class="ae ly" href="https://github.com/NoTests/RxFeedback.swift" rel="noopener ugc nofollow" target="_blank"> RxFeedback </a>、<a class="ae ly" href="https://cycle.js.org" rel="noopener ugc nofollow" target="_blank"> Cycle.js </a>、<a class="ae ly" href="https://github.com/ReSwift/ReSwift" rel="noopener ugc nofollow" target="_blank">resswift</a>等。这些架构(包括ArchitectureKit)和MVP之间的主要区别在于，它们<strong class="je hv">引入了UI状态如何更新的约束，以加强正确性并使应用程序更容易推理。</strong></p><p id="dae7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ArchitectureKit与这些类似Redux的架构的不同之处在于，它使用反馈循环来运行效果，并将它们编码到状态的一部分中(我们将在第3点中看到这一点)，并使用FunctionalKit中的单子来包装效果。</p><p id="6de0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> ArchitectureKit为你运行</strong> <a class="ae ly" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">副作用</strong> </a> <strong class="je hv">。你的代码保持100%的纯净。</strong></p><h1 id="a510" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">3.建筑信息技术</h1><p id="2537" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">ArchitectureKit本身非常简单。</p><h2 id="f58a" class="lz ki hu bd kj ma mb mc kn md me mf kr jn mg mh kv jr mi mj kz jv mk ml ld mm dt translated">核心概念</h2><p id="2a09" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">应用程序的每个屏幕(以及整个应用程序)都有一个状态。在ArchitectureKit中，这种状态表示为and对象(即Struct)。例如，待办事项应用程序的状态可能如下所示:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="9019" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个状态对象代表了待办应用程序中“待办屏幕列表”的状态。“todos”变量包含所有可能在屏幕上绘制的待办事项，而“visibilityFilter”则告诉列表中应该显示哪些待办事项。</p><p id="1937" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用这种具有实际表示屏幕状态的对象的方法，<strong class="je hv">视图是状态</strong>的直接映射:</p><blockquote class="ka kb kc"><p id="8765" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><code class="eh mt mu mv mw b">view = f(state)</code></p></blockquote><p id="2a92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个“f”函数将是我们稍后会看到的UI绑定函数。</p><p id="8baf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要改变状态，您需要调度一个<strong class="je hv">事件</strong>。事件是描述发生了什么的枚举。以下是几个事件示例:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="65d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">强制将每一个变化都描述为一个事件，让我们对应用程序中发生的事情有一个清晰的理解。如果有些东西改变了，我们知道它为什么会改变。事件就像已经发生的面包屑。最后，为了将状态和动作联系在一起，我们编写了一个称为reducer的函数。它只是一个以状态和动作作为参数的函数，并返回应用程序的下一个状态:</p><blockquote class="ka kb kc"><p id="3cf7" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><strong class="je hv">(状态，事件)——&gt;状态</strong></p></blockquote><p id="a928" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们为每个屏幕的每个状态编写一个缩减器。有关todos屏幕的列表:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="1037" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，reducer是一个纯函数，就<a class="ae ly" href="https://en.wikipedia.org/wiki/Referential_transparency" rel="noopener ugc nofollow" target="_blank">参考透明</a>而言，对于状态S和事件E，它总是返回相同的状态，没有副作用。</p><p id="0d20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这基本上是ArchitectureKit的全部思想。注意，我们没有使用任何ArchitectureKit APIs。它附带了一些实用程序来促进这种模式，但主要思想是描述您的状态如何随着时间的推移而更新以响应事件，并且您编写的90%的代码都非常简单快捷，因此可以轻松地测试UI逻辑。</p><p id="5e00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是异步代码和副作用如API调用、DB调用、日志记录、读写文件呢？</p><h2 id="d33e" class="lz ki hu bd kj ma mb mc kn md me mf kr jn mg mh kv jr mi mj kz jv mk ml ld mm dt translated">异步结果和功能套件</h2><p id="db2c" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated"><code class="eh mt mu mv mw b"><a class="ae ly" href="https://github.com/RPallas92/ArchitectureKit/blob/master/ArchitectureKit/AsyncResult.swift" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">AsyncResult</strong></a></code> <strong class="je hv"> </strong>数据结构用于处理异步操作。AsyncResult只是一个<code class="eh mt mu mv mw b">typealias</code>到一个<code class="eh mt mu mv mw b">Reader&lt;Future&lt;Result&gt;&gt;</code>单子堆栈。这些单子(及其单子转换器)在<a class="ae ly" href="https://github.com/facile-it/FunctionalKit" rel="noopener ugc nofollow" target="_blank"> FunctionalKit </a>中可用，这是ArchitectureKit中唯一的依赖项。</p><p id="af6f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">FunctionalKit为<a class="ae ly" href="https://hackernoon.com/tagged/swift" rel="noopener ugc nofollow" target="_blank"> Swift </a>中的功能性<a class="ae ly" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>提供了基本函数和组合子，可以认为是对<code class="eh mt mu mv mw b">Foundation</code>的扩展。我们主要使用Reader monad以及Future和Result。</p><ul class=""><li id="d44e" class="lf lg hu je b jf jg jj jk jn mx jr my jv mz jz na ln lo lp dt translated"><a class="ae ly" href="https://github.com/facile-it/FunctionalKit/blob/master/Sources/FunctionalKit/ReaderType.swift" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">Reader monad:</strong></a><strong class="je hv"/>它用在monad栈的顶层，提供一种注入依赖的方式。稍后我们将深入了解。</li><li id="a33d" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated"><a class="ae ly" href="https://github.com/facile-it/FunctionalKit/blob/master/Sources/FunctionalKit/FutureType.swift" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">未来单子:</strong> </a>用来表示异步值。</li><li id="74ce" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated"><a class="ae ly" href="https://github.com/facile-it/FunctionalKit/blob/master/Sources/FunctionalKit/ResultType.swift" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">结果单子:</strong> </a>表示计算是否成功或有错误。</li></ul><p id="e714" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用monad转换器创建AsyncResult，作为这三个monad的堆栈。<strong class="je hv">async result是一个monad，表示返回成功值或错误的异步操作，并提供依赖注入机制。</strong></p><p id="b404" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以在下面的代码片段中看到一个使用AsyncResult的脸书登录示例:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="d98d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了创建一个AsyncResult，我们使用它的静态方法<code class="eh mt mu mv mw b">unfoldTT</code>(TT代表transformer，因为它是一个monad transformer)。它期望一个函数作为有两个输入的参数:一个环境或上下文和一个延续或回调。环境参数来自读取器monad，它是一个包含注入依赖项的对象。continuation参数是一个回调函数，必须用de异步操作返回的<code class="eh mt mu mv mw b">Result</code>值调用。在这个例子中，当成功时，结果返回一个<code class="eh mt mu mv mw b">string</code>。当登录成功时，我们使用来自脸书的令牌调用continuation方法。如果登录失败，我们调用包含错误的失败<code class="eh mt mu mv mw b">Result</code>的continuation方法。</p><p id="94d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AsyncResult必须用3个值参数化。第一个是环境类型(包含依赖项)，第二个是异步操作的实际期望值(在本例中我们使用<code class="eh mt mu mv mw b">string</code>，因为我们希望脸书登录返回登录令牌)，最后一个是出错时<code class="eh mt mu mv mw b">Result</code>将返回的错误类型。</p><p id="2436" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个异步操作和副作用必须使用AsyncResult monad来执行，我们将使用来自ArchitectureKit的反馈来执行它们的副作用。此外，我们将在完整的示例中看到如何使用AsyncResults。</p><h2 id="32e8" class="lz ki hu bd kj ma mb mc kn md me mf kr jn mg mh kv jr mi mj kz jv mk ml ld mm dt translated">设计反馈回路</h2><p id="4400" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">让我们在之前的待办事项应用程序中添加一个新功能！我们希望让用户把他们的待办事项保存到云端。这将需要一个网络调用，这是一个副作用，并且是异步的，所以为了实现它，我们将使用反馈循环。在体系结构中处理效果的方法是将它们编码成状态的一部分，然后设计反馈回路。</p><p id="661d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">反馈回路只是在某些情况下触发的计算，取决于系统的当前状态，它启动新的事件，并产生新的状态。</p><p id="40e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个完整的ArchitectureKit循环从一个触发事件的<a class="ae ly" href="https://github.com/RPallas92/ArchitectureKit/blob/master/ArchitectureKit/UserAction.swift" rel="noopener ugc nofollow" target="_blank"> UserAction </a>开始。然后reducer函数根据事件和先前的状态计算新的状态。ArchitectureKit检查是否必须从新状态触发任何反馈循环。如果是这样，反馈会异步产生一个新事件(通过执行副作用)和一个新状态(如果是从反馈的事件计算出来的)。</p><p id="e086" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们可以看到一个完整的ArchitectureKit循环，如下所示:</p><ol class=""><li id="ac14" class="lf lg hu je b jf jg jj jk jn mx jr my jv mz jz lm ln lo lp dt translated">UserAction产生一个事件。</li><li id="5095" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">减速器(当前状态，事件)-&gt;新状态。</li><li id="29da" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">查询新状态以检查是否必须触发反馈回路。</li><li id="6197" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">如果是，则触发新事件(执行副作用)。</li><li id="35db" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">reducer(新状态，新事件)-&gt;更新状态。</li><li id="374c" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz lm ln lo lp dt translated">从步骤3开始重复，直到不再有反馈(或最多5次反馈循环)</li></ol><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/1d2b4d73736fa3b9e7ee3bb7e94f100e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*HHbqRbOi9HHBrbwFahoCAQ.png"/></div></div><figcaption class="nc nd fg fe ff ne nf bd b be z ek">ArchitectureKit whole loop</figcaption></figure><p id="fc7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下面的代码片段中，我们可以看到一个如何在云中存储用户待办事项的反馈示例:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="e215" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了实现这个特性，添加了两个新事件<code class="eh mt mu mv mw b">storeTodos()</code>和<code class="eh mt mu mv mw b">todosStored(Bool)</code>，并且在状态中有一个新的布尔变量:<code class="eh mt mu mv mw b">mustStoreTodos</code>。<code class="eh mt mu mv mw b">storeUserTodos(todos:[Todo])</code>函数是在反馈循环中执行的函数，它返回一个AsyncResult monad，后者在执行副作用时返回<code class="eh mt mu mv mw b">todosStored(Bool)</code>事件。这个函数负责存储用户的待办事项。</p><p id="e2da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">反馈对象由两个接收当前状态作为参数的函数组成。第一个函数是要执行的实际AsyncResult，第二个函数根据状态检查何时必须执行反馈循环。在示例中，当<code class="eh mt mu mv mw b">mustStoreTodos</code>变量为真时，将执行用户的待办事项反馈。</p><p id="a461" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在新的减速器中，<code class="eh mt mu mv mw b">storeTodos()</code>事件将<code class="eh mt mu mv mw b">mustStoreTodos</code>设置为真，而<code class="eh mt mu mv mw b">todosStored(Bool)</code>将它设置回假。<code class="eh mt mu mv mw b">storeTodos()</code>事件将由用户动作触发，比如点击按钮。</p><p id="c1e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下图说明了存储用户待办事项的步骤:</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/5c3b94e05ff54866e21435c1be598a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gs6P6pEHxK6_iSNNaV4WbQ.png"/></div></div><figcaption class="nc nd fg fe ff ne nf bd b be z ek">How Feedback loop is executed after an UserAction</figcaption></figure><h2 id="1fa4" class="lz ki hu bd kj ma mb mc kn md me mf kr jn mg mh kv jr mi mj kz jv mk ml ld mm dt translated">谁调度事件？用户操作</h2><p id="daf2" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated"><a class="ae ly" href="https://github.com/RPallas92/ArchitectureKit/blob/master/ArchitectureKit/UserAction.swift" rel="noopener ugc nofollow" target="_blank"> UserAction </a>是来自ArchitectureKit的对象，表示来自用户或iOS框架的任何动作，该动作触发一个改变状态的事件(并且从该状态改变它可以触发一个反馈循环)。</p><p id="20a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它有两种方法:</p><ul class=""><li id="be0c" class="lf lg hu je b jf jg jj jk jn mx jr my jv mz jz na ln lo lp dt translated"><code class="eh mt mu mv mw b">init</code>:创建UserAction，并指定当执行用户操作时将触发什么事件</li><li id="c9eb" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated"><code class="eh mt mu mv mw b">execute</code>:执行用户动作。</li></ul><h2 id="1719" class="lz ki hu bd kj ma mb mc kn md me mf kr jn mg mh kv jr mi mj kz jv mk ml ld mm dt translated">简单的例子</h2><p id="faef" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我们可以在这里看到一个简单的例子，展示ArchitectureKit的代码是怎样的:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="1772" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个简单的计数器，带有递增和递减按钮。状态只是一个包含当前计数的整数。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/46038255fc47256175fa2e8dc60e38bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/1*Mk6XqMNScFYorwUbdrHEuQ.gif"/></div></figure><h1 id="978f" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">依赖注入</h1><p id="dda6" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">对于依赖注入，我们将使用位于AsyncResult单子堆栈顶层的<a class="ae ly" href="https://github.com/facile-it/FunctionalKit/blob/master/Sources/FunctionalKit/ReaderType.swift" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">读取器单子</strong> </a>。</p><p id="f6c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">阅读器用类型</strong> <code class="eh mt mu mv mw b"><strong class="je hv">(D) -&gt; A</strong></code> <strong class="je hv">包装一个计算，并启用该类型</strong>的复合计算。</p><p id="79d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mt mu mv mw b">D</code>代表<em class="kd">“阅读器上下文”</em>，它代表计算运行所需的依赖关系。它还自动向下传递依赖关系，因为它是自己完成的，这要归功于<code class="eh mt mu mv mw b">Readers</code>组合在一起的方式。</p><p id="5632" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，它推迟了所有级别的计算，因为它包装了计算，并且通过在不同的函数调用之间自动传递来注入依赖关系。</p><p id="c5ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">方法是创建一个包含所有需要的依赖项的Swift结构(我称之为Context ),并在运行<code class="eh mt mu mv mw b">Reader (AsyncResult)</code>计算时传递该对象。在下面的例子中，我们可以看到如何在ArchitectureKit中注入依赖关系:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="0657" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您在前面的代码片段中看到的,<strong class="je hv"> </strong> <code class="eh mt mu mv mw b">BaseContext</code>协议是用<code class="eh mt mu mv mw b">AppContext</code>类将拥有的必需依赖项定义的。在该类中，我们添加了应用程序的全局依赖项。然后我们为每个屏幕创建一个上下文类，像<code class="eh mt mu mv mw b">TodoListContext</code>。它从AppContext扩展而来，包含了待办事项列表屏幕的特定依赖项，比如视图。</p><p id="2c60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想要测试<code class="eh mt mu mv mw b">deleteAllTodosFromDatasource</code>反馈，我们可以创建一个带有模拟数据源和模拟视图的测试上下文。通过这种方法，我们还可以为每个服务器环境配置不同的上下文:生产、试运行、测试和开发。</p><p id="10cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下一节中，我们将看到一个完整的例子，其中我们使用不同的上下文来测试应用程序和实际代码。</p><p id="ae56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在Jorge Castillo的文章中看到更多关于依赖注入的内容:</p><div class="ni nj fm fo nk nl"><a rel="noopener follow" target="_blank" href="/@JorgeCastilloPr/kotlin-dependency-injection-with-the-reader-monad-7d52f94a482e"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd hv fv z el nq eo ep nr er et ht dt translated">使用阅读器Monad的Kotlin依赖注入</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">作为一名Android开发人员，我习惯于浪费大量时间来创建必要的基础设施以提供依赖性…</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ja nl"/></div></div></a></div><h1 id="ccd7" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">完整示例</h1><p id="45f4" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我使用ArchitectureKit和FunctionalKit创建了一个简单但功能齐全的应用程序，来说明如何使用这个库以及如何设计应用程序本身。你可以在这里  <strong class="je hv">找到app的<a class="ae ly" href="https://github.com/RPallas92/FunctionalSwiftArchitecture" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">源代码。</strong></a></strong></p><p id="1e89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用程序是关于查克·诺里斯的笑话，从这个API 中检索。第一个屏幕显示了笑话类别列表。当用户点击一个类别时，一个新的屏幕会出现该类别的随机笑话。我们可以看到一些截图(免责声明:我没有在UI上下功夫):</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff oa"><img src="../Images/071f55250c54bca2afbd9a1af4675002.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*HemBeCCveFEzS1tcw6Eg4Q.png"/></div><figcaption class="nc nd fg fe ff ne nf bd b be z ek">List of joke categories screen</figcaption></figure><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff oa"><img src="../Images/31a0fd248423120490d4e58b0b13f777.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*3anCI9QHCSpW-fCmPBB58w.png"/></div><figcaption class="nc nd fg fe ff ne nf bd b be z ek">Custom joke detail screen</figcaption></figure><p id="0321" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下图中，我们可以看到应用程序被划分成的层:</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff ob"><img src="../Images/aa6b09d14cc0f7a345dac081d85742e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*2E83juFItwgZqX-jouJfqw.png"/></div></figure><p id="e63e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它分为:</p><ul class=""><li id="43a3" class="lf lg hu je b jf jg jj jk jn mx jr my jv mz jz na ln lo lp dt translated"><strong class="je hv">数据</strong>:我们在哪里使用存储库模式</li><li id="249e" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated"><strong class="je hv">领域</strong>:这里有领域对象、服务和用例。</li><li id="2aa2" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated"><strong class="je hv">表现:</strong>我们可以建立表现逻辑(ArchitectureKit)</li><li id="3033" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated"><strong class="je hv">视图</strong>:app的视图(ViewControllers)</li><li id="1cdb" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated"><strong class="je hv"> DI: </strong>我们定义依赖注入所需的<em class="kd">上下文</em>对象</li></ul><p id="daca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你看一下<a class="ae ly" href="https://github.com/RPallas92/FunctionalSwiftArchitecture/tree/master/FunctionalSwiftArchitectureTests" rel="noopener ugc nofollow" target="_blank">测试文件夹</a>，你会看到我们是如何注入依赖关系的，以及使用一个非常简单的模拟视图测试整个应用程序是多么容易。</p><h1 id="a227" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">结论</h1><p id="ec4d" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我将使用ArchitectureKit作为一种干净的体系结构方法中的视图层的体系结构，取代Model View Presenter。此外，我会用<em class="kd">功能</em>干净的架构来设计应用，而不是OOP干净的架构。尽可能使用函数而不是类，使用AsyncResult monad来保持代码的纯净，编码副作用，注入依赖性，利用函数转换… <strong class="je hv">我认为</strong><a class="ae ly" href="https://github.com/RPallas92/FunctionalSwiftArchitecture" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">functional swift architecture</strong></a><strong class="je hv">是一个很好的例子，说明了我如何从头开始制作一个应用程序。</strong></p><p id="8122" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在ArchitectureKit中看到的<strong class="je hv">优势</strong>是:</p><ul class=""><li id="234c" class="lf lg hu je b jf jg jj jk jn mx jr my jv mz jz na ln lo lp dt translated">你的代码保持100%的纯净。所有的副作用都是由ArchitectureKit自己执行的。</li><li id="4f36" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated">状态的所有变化都很容易推理并有助于正确性。</li><li id="f541" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated">视图是状态的直接映射。</li><li id="40d4" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated">易于测试，由于干净的架构，所有业务逻辑都被隔离，UI逻辑是纯Swift代码。和依赖注入机制，使应用程序更容易测试。</li><li id="0212" class="lf lg hu je b jf lq jj lr jn ls jr lt jv lu jz na ln lo lp dt translated">带有一些概念的简单库。</li></ul><h2 id="cca9" class="lz ki hu bd kj ma mb mc kn md me mf kr jn mg mh kv jr mi mj kz jv mk ml ld mm dt translated">后续步骤</h2><p id="025f" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我计划改进用户行为机制。并为每个UIKIt控件创建一个特定的UserAction。</p><p id="3ff5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果出现新的用例，我将重构这个库并进行更改。</p><h2 id="51ec" class="lz ki hu bd kj ma mb mc kn md me mf kr jn mg mh kv jr mi mj kz jv mk ml ld mm dt translated">感谢</h2><p id="12eb" class="pw-post-body-paragraph jc jd hu je b jf lh jh ji jj li jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我想感谢<a class="oc od gr" href="https://medium.com/u/fc39ebe507ff?source=post_page-----dfa8854239cb--------------------------------" rel="noopener" target="_blank">杰西·曼努埃尔·洛佩斯·马丁内斯</a>和<a class="oc od gr" href="https://medium.com/u/d278e9977263?source=post_page-----dfa8854239cb--------------------------------" rel="noopener" target="_blank">何塞·路易斯·阿尔卡拉</a>帮助我开发了ArchitectureKit的代码库，并帮助我撰写了这篇文章。</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="oe ms l"/></div></figure></div></div>    
</body>
</html>