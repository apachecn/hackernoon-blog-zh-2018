<html>
<head>
<title>Our approach to software development consistency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们的软件开发一致性方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/our-approach-to-software-development-consistency-d101995bb843?source=collection_archive---------14-----------------------#2018-01-03">https://medium.com/hackernoon/our-approach-to-software-development-consistency-d101995bb843?source=collection_archive---------14-----------------------#2018-01-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="f3f8" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">不要记录您可以自动化的东西</h2></div><p id="a2b1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">访问https://www.mikenikles.com的<a class="ae kf" href="https://www.mikenikles.com" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv"/></a><strong class="jl hv">获取我的最新博文。</strong></p><p id="c552" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kg">这篇博文是我分享我们从部署在AWS上的单片应用程序(每个都有自己的源代码库)迁移到部署在Google云平台上的分布式服务架构(所有源代码都托管在monorepo中)的系列文章的一部分。</em></p><ul class=""><li id="825f" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated"><em class="kg">第一部分:</em> <a class="ae kf" href="https://hackernoon.com/a-monorepo-github-flow-and-automation-ftw-c41a2d9c48bb" rel="noopener ugc nofollow" target="_blank"> <em class="kg">一个monorepo，GitHub流和自动化FTW</em></a><em class="kg"/></li><li id="c092" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第2部分:“</em> <a class="ae kf" rel="noopener" href="/@mikenikles/one-vs-many-why-we-moved-from-multiple-git-repos-to-a-monorepo-and-how-we-set-it-up-f4abb0cfe469"> <em class="kg">一对多——为什么我们从多个git回购转移到单一回购，以及我们如何设置它</em></a><em class="kg">”</em></li><li id="8df2" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第三部分:</em><a class="ae kf" rel="noopener" href="/@mikenikles/a-mostly-automated-release-process-63bb9516985a"><em class="kg"/></a><em class="kg"/></li><li id="91bd" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第4部分(本文):“我们的一致性方法和对开发者体验的关注”</em></li><li id="8fc7" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><em class="kg">第5部分(即将推出):“本地调试微服务”</em></li></ul><h1 id="c7bd" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">什么是软件开发中的一致性？</h1><p id="2c5f" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">我认为一致性是成功交付软件不可或缺的一部分。我经常加入或者与很少或者没有一致性的软件团队一起工作。</p><p id="49ab" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它适用于开发的所有方面:代码风格、注释、工具、入职、新服务的创建。它还扩展到产品管理、定义和跟踪任务，以及一般的公司流程。</p><p id="add5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们以我当前项目的“创建新的包和服务”为例，在这个项目中，我们从单一的应用程序迁移到更小的、独立的和分布式的服务。下面是我们如何创建前3项服务的:</p><ul class=""><li id="d9ab" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated"><strong class="jl hv">服务1 </strong> : 100%手工制作，试用&amp;误差，很多死角。</li><li id="1714" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><strong class="jl hv">服务2 </strong>:复制&amp;粘贴服务1，必要时进行调整，用与服务2相关的新业务逻辑替换旧业务逻辑。重复，直到希望一切都以某种方式工作。</li><li id="b2e8" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><strong class="jl hv">服务3 </strong>:复制&amp;粘贴……<em class="kg">我们到底在做什么？</em></li></ul><p id="4a17" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你能看出这种一致性吗？正确，<em class="kg">复制&amp;粘贴</em>看起来相当一致。当花了一周时间建立服务1的人离开时会发生什么？谁知道创建服务8需要调整什么？想象一下当一个基本错误发生并影响所有服务时的噩梦…👻。</p><p id="5919" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在的问题是，我们如何使这更一致？我问了几个朋友，很多人回答:<strong class="jl hv">记录过程</strong>。</p><ul class=""><li id="73d6" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated"><strong class="jl hv">服务1 </strong> : 100%手工制作，试用&amp;误差，这里那里几句脏话。</li><li id="e9f1" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><strong class="jl hv"> <em class="kg">记录流程</em> </strong></li><li id="baf3" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><strong class="jl hv">服务2 </strong>:复制&amp;粘贴服务1，按照文档清单更新新服务。</li><li id="869e" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><strong class="jl hv">服务3 </strong>:遵循上述步骤，只要没有任何变化并且文档仍然是最新的🤞。</li></ul><h1 id="c911" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">不要记录您可以自动化的东西</h1><p id="2af0" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">作为一个在软件行业度过了大半辈子的人，我意识到在这个快速发展的环境中保持理智的最简单的方法是编写适合我的脚本。</p><p id="5795" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">文档是伟大的，只要它是准确的。有些情况下文档是必要的，但是对于我们在这篇博文中讨论的用例(创建新的包和服务)，文档是错误的方法。</p><p id="3528" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每一个新的包或服务都有某种形状，在所有其他的包或服务中相当相似，就像每所房子都有某种基础、一些墙壁、窗户和屋顶。</p><p id="975e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想象以下过程来创建3个服务:</p><ul class=""><li id="f35c" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated"><strong class="jl hv">服务1 </strong>:运行服务生成器，提供服务特定值，点击回车。</li><li id="3f62" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><strong class="jl hv">服务2 </strong>:运行服务生成器，提供服务特定值，点击回车。</li><li id="e4f0" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated"><strong class="jl hv">服务4 </strong>:运行服务生成器，提供特定于服务的值，点击回车。</li></ul><h1 id="a70f" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">自动化流程</h1><p id="bf0a" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">现在让我们不仅想象上面的过程，让我们看看我们是如何在我们的项目中实现的。</p><p id="3733" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了透明起见，我们显然有类似service 0的东西，我们手工制作一切，测试服务，部署，调整等等。然而，我们知道我们想自动化这个过程，所以我们从一开始就密切关注。</p><p id="572f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们选择的工具是<a class="ae kf" href="https://plopjs.com/" rel="noopener ugc nofollow" target="_blank">扑通</a>。一个流行的选择是自耕农。我们选择扑通是因为它简单，现在它支持<a class="ae kf" href="https://plopjs.com/documentation/#addmany" rel="noopener ugc nofollow" target="_blank"> AddMany </a>，它提供了我们需要的一切。</p><p id="5673" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们目前有两台发电机:</p><ul class=""><li id="dbef" class="kh ki hu jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp dt translated">包裹</li><li id="01c6" class="kh ki hu jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp dt translated">服务</li></ul><p id="8cc7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所有模板文件都保存在一个<code class="eh ls lt lu lv b">_templates</code>文件夹中。目录结构是:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="a1f5" class="me kw hu lv b fv mf mg l mh mi">.<br/>├── _templates<br/>│   ├── packages<br/>│   │   ├── README.md<br/>│   │   ├── iso<br/>│   │   ├── svr<br/>│   │   └── web<br/>│   └── services<br/>│       ├── README.md<br/>│       ├── svr<br/>│       └── web<br/>└── scripts<br/>   └── generators<br/>       ├── helpers.js<br/>       ├── index.js<br/>       ├── packages<br/>       │   └── index.js<br/>       └── services<br/>           └── index.js</span></pre><p id="7a8b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh ls lt lu lv b">README.md</code>模板文件一个用于包，一个用于服务。这确保了每个包(和每个服务)遵循相同的结构。一个<code class="eh ls lt lu lv b">README.md</code>文件包含任何人对一个包或服务做出贡献的必要信息。</p><p id="9b66" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">再往下，<code class="eh ls lt lu lv b">generators</code>被定义。生成器入口点和包生成器如下所示:</p><figure class="lw lx ly lz fq mj"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="604a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">服务生成器稍微复杂一点，因为它们还负责一些额外的服务设置，比如<a class="ae kf" href="https://cloud.google.com/deployment-manager/runtime-configurator/create-and-delete-runtimeconfig-resources#creating_a_config" rel="noopener ugc nofollow" target="_blank">在GCP </a>创建一个RuntimeConfig资源、<a class="ae kf" href="https://api.slack.com/methods/channels.create" rel="noopener ugc nofollow" target="_blank">在Slack </a>创建一个通道、<a class="ae kf" href="https://developer.atlassian.com/cloud/jira/platform/rest/#api-api-2-component-post" rel="noopener ugc nofollow" target="_blank">在吉拉</a>添加一个新组件，等等。</p><h1 id="9b39" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">结论</h1><p id="a5a1" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">生成器可以很好地捆绑到存储库根目录<code class="eh ls lt lu lv b">package.json</code>中的NPM脚本中，如下所示:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="e1e4" class="me kw hu lv b fv mf mg l mh mi">{<br/>  "scripts": {<br/>    "generate": "plop --plopfile ./scripts/generators/index.js"<br/>  },<br/>  "devDependencies": {<br/>    "plop": "^1.9.1"<br/>  }<br/>}</span></pre><p id="033a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在生成一个新的包只需要<code class="eh ls lt lu lv b">yarn generate</code>。然后，一个交互式CLI引导开发人员回答几个问题。一个很好的特性是，您可以将生成器名称作为一个参数传递，例如<code class="eh ls lt lu lv b">yarn generate service</code>会将您带到与服务相关的问题。</p></div></div>    
</body>
</html>