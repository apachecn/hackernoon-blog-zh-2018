<html>
<head>
<title>AWS Lambda — use the invocation context to better handle slow HTTP responses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda —使用调用上下文来更好地处理缓慢的HTTP响应</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/aws-lambda-use-the-invocation-context-to-better-handle-slow-http-responses-16fbfecfa4e9?source=collection_archive---------15-----------------------#2018-01-04">https://medium.com/hackernoon/aws-lambda-use-the-invocation-context-to-better-handle-slow-http-responses-16fbfecfa4e9?source=collection_archive---------15-----------------------#2018-01-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="198d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">语境。<code class="eh jj jk jl jm b">getRemainingTimeInMillis() gives you a flexible way to timeout requests on the client-side based on the amount of invocation time left rather than some arbitrarily hardcoded value.</code></h2></div><p id="f6ac" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">使用API Gateway和Lambda，您被迫在服务器端使用相对较短的超时:</p><ul class=""><li id="e452" class="kj kk hu jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr dt translated"><strong class="jp hv"> API网关在所有集成点上都有一个30秒的最大超时</strong></li><li id="23ac" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr dt translated">对于AWS Lambda函数，无服务器框架使用默认值6s</li></ul><p id="9ea2" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">然而，由于您对Lambda函数的冷启动时间的影响有限，并且无法控制API Gateway引入的延迟开销，因此您从调用函数中体验到的面向客户端的实际延迟很难预测。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ky"><img src="../Images/50f3943bd77b88dea8219d93a61ac9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKE_zsrkxUG3yf5qkbGPzA.png"/></div></div></figure><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff lk"><img src="../Images/2a6df34656459cb1a4ecb06262d95fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSRjnEQpcHW9ybO91S-ymQ.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek"><a class="ae lp" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/api-gateway-metrics-dimensions.html" rel="noopener ugc nofollow" target="_blank">https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/api-gateway-metrics-dimensions.html</a></figcaption></figure><p id="f76f" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">为了防止缓慢的HTTP响应导致调用函数超时(从而影响我们提供的用户体验)，我们应该确保在调用函数超时之前停止等待响应。</p><blockquote class="lq lr ls"><p id="efc0" class="jn jo kx jp b jq jr iv js jt ju iy jv lt jx jy jz lu kb kc kd lv kf kg kh ki hn dt translated">“超时策略的目标是给HTTP请求<strong class="jp hv">最大的成功机会</strong>，前提是这样做不会导致调用函数本身出错”——me</p></blockquote><p id="b75a" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">大多数时候，我看到人们使用固定的(硬编码或通过配置指定的)超时值，这通常很难决定:</p><ul class=""><li id="ecda" class="kj kk hu jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr dt translated">太短了，你不会给请求<em class="kx">成功的最好机会</em>，例如，在调用中还有5s，但是我们已经将超时设置为3s</li><li id="ebd2" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr dt translated">太长的时间会有让请求超时调用函数的风险，例如，调用还剩5秒，但我们已经将超时设置为6秒</li></ul><p id="8cdc" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">选择正确超时值的挑战变得更加复杂，因为我们经常在函数调用期间执行不止一个HTTP请求——例如，从DynamoDB读取，与一些内部API对话，然后将更改保存到DynamoDB，相当于一次调用中总共3个HTTP请求。</p><p id="9b4a" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">让我们来看看选择超时值的两种常见方法，以及它们达不到我们的目标的情况。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff lw"><img src="../Images/ce122f905e32350d51d9aee55b0946c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2mq01Qpyziv3kLSFT-fTw.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">requests are not given the best chance to succeed</figcaption></figure><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff lx"><img src="../Images/387a19f0d4db166d8f0a5106ce60bcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86gi54TpmZs4d9RN-NLY8Q.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">requests are allowed too much time to execute and caused the function to timeout.</figcaption></figure><p id="c14f" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">相反，我们应该<strong class="jp hv">根据剩余的调用时间量</strong>设置请求超时，同时考虑执行任何恢复步骤所需的时间——例如，在响应正文中返回一个有意义的错误和应用程序特定的错误代码，或者返回一个回退结果。</p><p id="9076" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">通过调用函数的<code class="eh jj jk jl jm b">context</code>对象，您可以很容易地发现当前调用还剩多少时间。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ly"><img src="../Images/5c3bd390ca074546e9b04f62b7b7d29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w0HJ91GbVcBiMU707-dsMw.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek"><a class="ae lp" href="https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html" rel="noopener ugc nofollow" target="_blank">https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html</a></figcaption></figure><p id="c2ed" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">例如，如果一个函数的<code class="eh jj jk jl jm b">timeout</code>是6s，但是当你发出HTTP请求时，你已经进入调用1s了(也许你必须先做一些昂贵的计算)，如果我们为恢复预留500ms，那么我们还有4.5s来等待HTTP响应。</p><p id="0712" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">通过这种方法，我们可以两全其美:</p><ul class=""><li id="681a" class="kj kk hu jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr dt translated">根据我们剩余的实际调用时间，允许请求有最大的成功机会；和</li><li id="ec80" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr dt translated">防止响应缓慢导致功能超时，这为我们提供了执行恢复操作的机会</li></ul><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff lz"><img src="../Images/d232a2d6895ef169c049e956fa0500db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGwy_fEXIgyvGPlz8CQ0IA.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">requests are given the best chance to succeed, without being restricted by an arbitrarily determined timeout.</figcaption></figure><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff lw"><img src="../Images/6c31c6381ece5564f397f070d7c804ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhqKs74mzoKY9_q7fPkMvg.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">slow responses are timed out before they cause the calling function to time out</figcaption></figure><p id="b19a" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">但是，在这些请求超时之后，您打算做什么呢？既然您不能完成您需要执行的任何操作，您不是仍然必须用HTTP错误来响应吗？</p><p id="6303" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">恢复措施至少应包括:</p><ul class=""><li id="661b" class="kj kk hu jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr dt translated">尽可能多地记录超时事件，包括所有相关的<a class="ae lp" href="https://hackernoon.com/capture-and-forward-correlation-ids-through-different-lambda-event-sources-220c227c65f5" rel="noopener ugc nofollow" target="_blank">关联id</a></li><li id="78cc" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr dt translated">跟踪<code class="eh jj jk jl jm b">serviceX.timedout</code>的定制指标，以便对其进行监控，并在情况升级时提醒团队</li><li id="0564" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr dt translated">在响应正文中返回一个应用程序错误代码(见下面的例子)，以及请求ID，这样面向用户的客户端应用程序可以显示一条用户友好的消息，如<em class="kx">“哎呀，看起来这个特性目前不可用，请稍后再试。如果这是紧急情况，请联系我们在xxx@domain.com，并引用请求ID f19a7dca。谢谢合作:-)" </em></li></ul><pre class="kz la lb lc fq ma jm mb mc aw md dt"><span id="126f" class="me mf hu jm b fv mg mh l mi mj">{<br/>  "errorCode": 10021,<br/>  "requestId": "f19a7dca",<br/>  "message": "service X timed out"<br/>}</span></pre><p id="dd4f" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">在<em class="kx">某些</em> <em class="kx">情况下</em>，你还可以使用fallbacks更优雅地恢复。</p><p id="5b3d" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">例如，网飞的<a class="ae lp" href="https://github.com/Netflix/Hystrix" rel="noopener ugc nofollow" target="_blank"> Hystrix </a>库通过它大量使用的<em class="kx">命令</em>模式支持几种风格的后退。事实上，如果你还没有看过它的维基页面，那么我强烈建议你去通读一下，那里有大量有用的信息和想法。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff mk"><img src="../Images/bdcf26b5a9adf210c0ebc0944d8fead5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtRgN-C5cuSVviMNX-rbTw.png"/></div></div></figure><p id="306a" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">至少，每个命令都允许您指定一个回退操作。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ml"><img src="../Images/2498856efbb395c184042053661179b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugsmh-5j3YhRvUy4kUVP7w.png"/></div></div></figure><p id="a9b6" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">您也可以通过各自的<code class="eh jj jk jl jm b">getFallback</code>方法链接命令，将回退链接在一起。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/cf7273cf71e0629a42c20cf1762425cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*G1ALK0-VxH3QfsghMC9Pbw.png"/></div></figure><p id="810d" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">举个例子，</p><ol class=""><li id="67da" class="kj kk hu jp b jq jr jt ju jw kl ka km ke kn ki mn kp kq kr dt translated">在<code class="eh jj jk jl jm b">CommandA</code>内部执行DynamoDB读取</li><li id="fac3" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki mn kp kq kr dt translated">在<code class="eh jj jk jl jm b">getFallback</code>方法中，执行<code class="eh jj jk jl jm b">CommandB</code>，这将返回一个先前缓存的响应(如果可用的话)</li><li id="0b4e" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki mn kp kq kr dt translated">如果没有缓存的响应，那么<code class="eh jj jk jl jm b">CommandB</code>将失败，并触发它自己的<code class="eh jj jk jl jm b">getFallback</code>方法</li><li id="1e9e" class="kj kk hu jp b jq ks jt kt jw ku ka kv ke kw ki mn kp kq kr dt translated">执行<code class="eh jj jk jl jm b">CommandC</code>，返回一个存根响应</li></ol><p id="0ee5" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">无论如何，看看<em class="kx"> Hystrix </em>吧，如果你还没有看的话，大部分嵌入到<em class="kx"> Hystrix </em>中的模式可以很容易地在我们的无服务器应用程序中采用，以帮助它们更好地适应失败——这是我正在积极探索的一个独立系列，关于<a class="ae lp" href="https://hackernoon.com/how-can-we-apply-the-principles-of-chaos-engineering-to-aws-lambda-80f87e3237e2" rel="noopener ugc nofollow" target="_blank">将混沌工程的原理应用到无服务器</a>。</p><p id="992a" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">顺便说一句，正如Danilo在评论中提到的，在编写递归函数时，你也可以使用<code class="eh jj jk jl jm b">context.getRemainingTimeInMillis()</code>来决定何时做更多的工作而不是recurse。在这篇<a class="ae lp" href="https://hackernoon.com/write-recursive-aws-lambda-functions-the-right-way-4a4b5ae633b6" rel="noopener ugc nofollow" target="_blank">文章</a>中，你可以读到更多关于这方面的内容以及其他编写递归Lambda函数的技巧。</p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><figure class="kz la lb lc fq ld fe ff paragraph-image"><div class="ab fr cl mv"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">嗨，我的名字是<strong class="jp hv">崔琰</strong>。我是一个<a class="ae lp" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hv"> AWS无服务器英雄</strong> </a>和<a class="ae lp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">你可以通过<a class="ae lp" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae lp" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank">推特</a>和<a class="ae lp" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">查看我的新课程，<a class="ae lp" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="jp hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">点击获取您的副本<a class="ae lp" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff mw"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="jp hv">最佳实践</strong>、本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">代码<strong class="jp hv"> ytcui </strong>还可以获得<strong class="jp hv">票面价格6折</strong>。</p><p id="93c4" class="pw-post-body-paragraph jn jo hu jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">点击获取您的副本<a class="ae lp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>