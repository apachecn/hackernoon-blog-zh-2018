<html>
<head>
<title>Restate — the story of Redux Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重述——红杉树的故事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/restate-the-story-of-redux-tree-27d8c5d1040a?source=collection_archive---------23-----------------------#2018-01-04">https://medium.com/hackernoon/restate-the-story-of-redux-tree-27d8c5d1040a?source=collection_archive---------23-----------------------#2018-01-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3d10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">redux——现代React应用的圣牛。但是这足够了吗？说实话——没有。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/35a9c0667322df82116d16aa95c50976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87dJ5EB3ydD7_AbhKb4UOQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><a class="ae kj" href="https://blog.codecentric.de/en/2017/12/developing-modern-offline-apps-reactjs-redux-electron-part-3-reactjs-redux-basics/" rel="noopener ugc nofollow" target="_blank">https://blog.codecentric.de/en/2017/12/developing-modern-offline-apps-reactjs-redux-electron-part-3-reactjs-redux-basics/</a></figcaption></figure><h1 id="16b6" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">“反应式”待办事项列表</h1><p id="78be" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">让我们尝试只使用React来构建图标式待办事项应用程序。</p><blockquote class="ln lo lp"><p id="7fda" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">代码以相反顺序被监听</p></blockquote><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="04ba" class="ly kl hu js b fv lz ma l mb mc">// first - create a underlying data structure<br/>const TODOs = [todo1, todo2, todo3];</span><span id="b57c" class="ly kl hu js b fv md ma l mb mc">// second pass into Application<br/>const Application = &lt;TodoList todos={TODOs} /&gt;</span><span id="c43c" class="ly kl hu js b fv md ma l mb mc">// third define todo list<br/>const TodoList = ({todos}) =&gt; (<br/>  &lt;ol&gt;<br/>    {todos.map( todo =&gt; &lt;Todo key={todo.id} {...todo} /&gt;<br/>  &lt;/ol&gt;<br/>);<br/>// last define Todo<br/>const Todo = (props) =&gt; &lt;div&gt;......&lt;/div&gt;</span></pre><p id="55f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的关键特性是— <strong class="it hv">子节点的所有数据都是由其父节点</strong>传递的。</p><h1 id="6300" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">“Redux”待办事项列表</h1><p id="48b2" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">让我们试着把它改造成redux变体</p><blockquote class="ln lo lp"><p id="46e7" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">这是<a class="ae kj" href="https://github.com/reactjs/redux/tree/master/examples/todos" rel="noopener ugc nofollow" target="_blank">原始Redux的待办事项列表</a>的简化版本</p></blockquote><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="40d0" class="ly kl hu js b fv lz ma l mb mc">// first - create a underlying data structure<br/>const store = createStore({<br/>   todos: [todo1, todo2, todo3]<br/>});</span><span id="1af7" class="ly kl hu js b fv md ma l mb mc">// second pass into Application<br/>const Application = <br/>&lt;Provider store={store}&gt;<br/> &lt;ConnectedTodoList/&gt;<br/>&lt;/Provider&gt;</span><span id="216a" class="ly kl hu js b fv md ma l mb mc">// third connect todo list<br/>const ConnectedTodoList = connect(<br/>   state =&gt; ({todos: state.todos})  // &lt;- here we inject the data<br/>)(TodoList)</span><span id="c400" class="ly kl hu js b fv md ma l mb mc">// forth define todo list<br/>const TodoList = ({todos}) =&gt; (<br/>  &lt;ol&gt;<br/>    {todos.map( todo =&gt; &lt;Todo key={todo.id} {...todo} /&gt;<br/>  &lt;/ol&gt;<br/>);<br/>// last define Todo<br/>const Todo = (props) =&gt; &lt;div&gt;......&lt;/div&gt;</span></pre><p id="1970" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的关键特性是，您可以随时连接到全球商店。获取数据并分派事件。这将整个应用程序解耦，但是，实际上，使得应用程序的各个部分更不可组合。</p><blockquote class="ln lo lp"><p id="541f" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">更有甚者——<strong class="it hv">组件构图</strong>(React的另一个圣牛)光是<strong class="it hv">就不行</strong>，因为long redux忽略了它在时空中的位置。</p></blockquote><h1 id="70b2" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">多一点“冗余”的待办事项</h1><p id="436b" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">所以。我可以在这里提到一个可以改进的时刻。TodoList太<code class="eh jp jq jr js b">reactish</code>。而托多绝对不是<code class="eh jp jq jr js b">reduxish</code>。让我们修理它</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="435c" class="ly kl hu js b fv lz ma l mb mc">....<br/>// third connect todo list<br/>const ConnectedTodoList = connect(<br/>   state =&gt; ({todos: idsFrom(state[todos])})// only ID, not all data<br/>)(TodoList)<br/>...<br/>// forth define todo list<br/>const TodoList = ({todos}) =&gt; (<br/>  &lt;ol&gt;<br/>    {todos.map( todo =&gt; &lt;ConnectedTodo key={todo.id} id={todo.id} /&gt;<br/>  &lt;/ol&gt;<br/>);</span><span id="2aed" class="ly kl hu js b fv md ma l mb mc">// use props to get the desired data<br/>const ConnectedTodoList = connect(<br/>   (state, props) =&gt; ({...state.todos[props.id]}) // get the TODO<br/>)(Todo)</span><span id="16dd" class="ly kl hu js b fv md ma l mb mc">// last define Todo<br/>const Todo = (props) =&gt; &lt;div&gt;......&lt;/div&gt;</span></pre><p id="397a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样更好。TODOList对Todo数据的任何更改都是不变的，Todo元素直接连接到存储。</p><p id="b4e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也很酷，因为它为事件传播创建了边界。</p><blockquote class="ln lo lp"><p id="ba39" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">Redux的connect <strong class="it hv">是任何更新的</strong> <strong class="it hv"> start </strong>，只要它直接连接到store，就直接触发。</p><p id="5728" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">Redux的connect <strong class="it hv">是任何更新的</strong> <strong class="it hv"> end </strong>，只要它是一个PureComponent，将只传递由Redux Store引入的更改，而不传递React更新。</p></blockquote><p id="b3b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它就像一只章鱼，处理并淹没你的应用程序。</p><blockquote class="me"><p id="8ff8" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated">想想事物的起源。开始和结束。</p></blockquote><figure class="mp mq mr ms mt jy fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/d7db77213b50c39214392ff76ed1a7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*2FaMxLCDHRVuvWly0ZGU8g.jpeg"/></div></figure><h1 id="9a03" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">最后的战斗</h1><p id="7d50" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">让我们再举一个例子。几乎待办事项列表，但有嵌套。这是资源的链接。</p><div class="mu mv fm fo mw mx"><a href="https://github.com/reactjs/redux/blob/master/examples/tree-view/src/containers/Node.js" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">反应/还原</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">JavaScript应用程序的redux -可预测状态容器</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl kd mx"/></div></div></a></div><p id="0680" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的关键特性是——你有一个节点，这个节点里面有一个列表。为了更新/编辑列表，您必须指定<code class="eh jp jq jr js b">nodeId</code>，而不仅仅是<code class="eh jp jq jr js b">listId</code>。</p><p id="18e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而redux没能<code class="eh jp jq jr js b">purely</code>解决这个问题。他们不能“正常地”提供预先填充了nodeId的调度，也不能为List提供nodeId，让List从存储中选择数据。</p><p id="5a3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他们能做什么？他们使用<strong class="it hv"> React </strong>处理程序来做<strong class="it hv"> Redux </strong>的工作。</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="592b" class="ly kl hu js b fv lz ma l mb mc">handleAddChildClick = e =&gt; {   <br/>    // get nodeId and dispatch function from a parent<br/>    const { addChild, createNode, id } = this.props;  <br/>    const childId = createNode().nodeId;<br/>    // dispatch event with both variables known<br/>    addChild(id, childId)  <br/>}</span></pre><blockquote class="me"><p id="769c" class="mf mg hu bd mh mi nm nn no np nq jo ek translated">这打破了组件方法。这是失败的。</p></blockquote><h1 id="9b2e" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv nr kx ky kz ns lb lc ld nt lf lg lh dt translated">重申救援</h1><blockquote class="ln lo lp"><p id="75b8" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">Redux-restate，Redux-tree，re-store，Redux-Lenses，Transformation……Redux缺的都是这些东西，<strong class="it hv"> Restate </strong>就是这些东西。</p></blockquote><p id="ae3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Restate是一个全新的库，它使你的应用程序变得更具反应性和冗余性。并且解决了最后一个例子的问题。</p><p id="8d6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">怎么会？让我们创建一个示例:</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="654f" class="ly kl hu js b fv lz ma l mb mc">....<br/>// third connect todo list<br/>const ConnectedTodoList = connect(<br/>   state =&gt; ({todos: idsFrom(state[todos])})// only ID, not all data<br/>)(TodoList)<br/>...<br/>// forth define todo list Mapper<br/>const TodoList = ({todos}) =&gt; (<br/>  &lt;ol&gt;<br/>    {todos.map( todo =&gt; &lt;ReconnectedTodo key={todo.id} id={todo.id} /&gt;<br/>  &lt;/ol&gt;<br/>);</span><span id="ee92" class="ly kl hu js b fv md ma l mb mc">// create a new redux connection point (<strong class="js hv">HERE IS THE MAGIC</strong>)<br/>// "focus" into the derived state</span><span id="7766" class="ly kl hu js b fv md ma l mb mc">const ReconnectedTodo = <strong class="js hv">reduxFocus</strong>( <br/>    // keep only selected TODO in the store<br/>    <strong class="js hv">(state, pros) =&gt; { todo: state.todos[id] },</strong> <br/>    // `restore` TODO id is on dispatch<br/>   (dispatch, event, props) =&gt; dispatch({...event, id: props.id})<br/>)(ConnectedTodo);</span><span id="58c3" class="ly kl hu js b fv md ma l mb mc">// use props to get the desired data<br/>const ConnectedTodoList = connect(<br/>   (state) =&gt; ({...state.todo}) // a single todo HERE, the right one<br/>)(Todo)</span><span id="be5c" class="ly kl hu js b fv md ma l mb mc">// last define Todo<br/>const Todo = (props) =&gt; &lt;div&gt;......&lt;/div&gt;</span></pre><p id="80ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lq"> PS: reduxFocus是Redux Restate的一部分。</em></p><p id="8a36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个例子使用了<code class="eh jp jq jr js b">react-redux-focus</code>——这个更简单的<code class="eh jp jq jr js b">react-redux-restate</code>版本，它是<code class="eh jp jq jr js b">redux-restate</code>的“反应”版本。</p><blockquote class="me"><p id="72bf" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated">这解决了主要的redux(全局状态)问题:可重用性。</p></blockquote><p id="1d8f" class="pw-post-body-paragraph ir is hu it b iu nu iw ix iy nv ja jb jc nw je jf jg nx ji jj jk ny jm jn jo hn dt translated">获得控制，形成子状态，子存储。映射并减少。作曲。</p><p id="4d21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许你已经有了一个<code class="eh jp jq jr js b">connected </code>组件，仅仅通过从状态中获取一些键，就紧紧地绑定到了某个状态结构上？你知道，那个组件是不可重复使用的。扔掉它</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="734c" class="ly kl hu js b fv lz ma l mb mc">const ConnectedXComponent = connect(mapStateToProps)(MyXComponent);</span><span id="225d" class="ly kl hu js b fv md ma l mb mc">....<br/>// just wrap it with redux state "adapter". Why not?</span><span id="cfb9" class="ly kl hu js b fv md ma l mb mc">const ReusableXConnectedComponent = reduxFocus( <br/>  (state,props) =&gt; createXState(state, props)<br/>)(ConnectedXComponent)</span></pre><h2 id="b78b" class="ly kl hu bd km nz oa ob kq oc od oe ku jc of og ky jg oh oi lc jk oj ok lg ol dt translated">它有什么作用？</h2><p id="7574" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated"><code class="eh jp jq jr js b">reduxFocus</code>在现有商店的基础上创建新店，<strong class="it hv">关注</strong>儿童的“更大”状态。ConnectedTodo将只接受一个Todo，它将与任何其他不需要的数据隔离开来。<em class="lq">(即将聚焦)</em></p><p id="80c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同时，只要long reduxFocus限定了数据的范围，就不需要传递“id ”,在dispatch中使用它，只要你可以用你知道的<code class="eh jp jq jr js b">todoId</code>来<strong class="it hv">增强</strong>所有<strong class="it hv">事件传递回</strong>到原始存储。</p><p id="ce91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也意味着，你可以将待办事项列表放在一个类似Trello的树中，只需定义<em class="lq">透镜</em>从一个“大”存储中获取一个待办事项列表，并将“nodeid”放在所有事件中，一个嵌套的组件将在将来被分派。</p><blockquote class="me"><p id="00d8" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated">这将启用组件模型，因此深受大家喜爱。</p></blockquote><h1 id="2a75" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv nr kx ky kz ns lb lc ld nt lf lg lh dt translated">更复杂的例子？</h1><p id="a8c0" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">React-redux-focus是一个简单的HOC，设计用于单一商店。最初的<code class="eh jp jq jr js b">React-redux-restate</code>旨在与多个one store合作。但是为什么呢？？</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="d875" class="ly kl hu js b fv lz ma l mb mc">const mapStateToProps = state =&gt; {<br/>   something: memoizedWithReselect(someComplexOperation(state))<br/>}<br/>connect(mapStateToProps)(Component)</span></pre><p id="48aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">组件的<strong class="it hv">渲染</strong>方法多久被调用一次？每次某个<code class="eh jp jq jr js b">real</code>更新都会经过记忆，并触发更新。所以——不经常。</p><p id="a486" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">多久会打一次<code class="eh jp jq jr js b">someComplexOperation</code>？每次状态更新时。即使你也会记忆它，你会调用记忆函数…很多次。从ReactRedux <code class="eh jp jq jr js b">render</code>方法。</p><blockquote class="ln lo lp"><p id="7232" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">如果您有100500个到商店的连接—所有这些连接都会在每次商店更新时调用mapStateToProps。除非你指定一个状态序列，但你不会。</p></blockquote><p id="0994" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">重申一下</strong>就是<strong class="it hv">是state sequal</strong>——全球儿童商店的一个“透镜化”的小部分，将他们与其他部分隔离开来。</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="840b" class="ly kl hu js b fv lz ma l mb mc">// default store will be accessible as `default`.<br/>const NestedStore = restate({}, ({ default:state }) =&gt; ({ state.only, state.data, state.i, state.need }))(RenderChildren);</span></pre><p id="0cb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是接下来，您可能会再次需要原始数据。但是也可能需要来自<code class="eh jp jq jr js b">current</code>sin titic store的计算数据。</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="6f83" class="ly kl hu js b fv lz ma l mb mc">const Reprovider = reprovider('superStore'); // copy store to the superStore</span><span id="199e" class="ly kl hu js b fv md ma l mb mc">const NestedNestedStore = restate(<br/>   { base: 'superStore' }, // get `superStore` as `base`<br/>   ({ default: state, base }) =&gt; ({ ...state, base.dataFromBase})<br/>   (dispatchers, event, props) =&gt; {<br/>      dispatch dispatches.default or dispatcher.base?<br/>   })...</span></pre><p id="f62f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是最好的例子，但有时可能必须存储在单个应用程序中，例如“应用程序”和“页面”,工作重述将使您能够组合来自这两个应用程序的数据，并将派单发送回正确的存储。</p><blockquote class="ln lo lp"><p id="bada" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">更重要的是——两个商店是使用MobX的常见方式</p></blockquote><h1 id="c00d" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">还是redux？</h1><p id="9b20" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">这个问题很好，因为很少有事情会打破核心概念。</p><ol class=""><li id="36e6" class="om on hu it b iu iv iy iz jc oo jg op jk oq jo or os ot ou dt translated">可以从商店创建派生商店吗？</li></ol><p id="65a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在数据库世界里，它被称为视图或矩阵视图(只要它们被记忆)。对mapStateToProps也是如此。从理论上来说是可以的。</p><p id="c0ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.回<code class="eh jp jq jr js b">route</code>急件可以吗？又冒泡了？</p><p id="35e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lq">首先——没有别的办法。第二—由于long routeDispatch是一个纯函数(与mapStateToProps或reducers相同)—它是</em> <code class="eh jp jq jr js b"><em class="lq">predictable</em></code> <em class="lq">。因为长期存储行为是可预测的——这是可以的。</em></p><p id="52ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.可以让容器对树中的位置敏感吗？</p><p id="7553" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这部分不见了。使用restate应用程序可以更好地使用redux更频繁、更容易、更正确。</p><p id="419b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.这是一家真正的<code class="eh jp jq jr js b">redux</code>商店吗？</p><p id="d2cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lq">没有。这只是一个具有类似redux的公共接口的视图，可由redux的connect down the tree重用。是假的。</em></p><p id="4204" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当前解决某些任务的方式是不正确的。回想一下树的例子——没有反应，没有重复，只是到处乱砍。</p><h1 id="cc06" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">不需要Redux？</h1><p id="fba3" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">这听起来可能有点奇怪，但是<strong class="it hv">重述没有Redux是可以的。</strong>可以将一个或多个状态合并在一起，也可以<strong class="it hv">从props形成一个新的状态，</strong>映射分派到React的组件方法。</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="387d" class="ly kl hu js b fv lz ma l mb mc"><strong class="js hv">return </strong>(<br/>    /* &lt;ReduxFocus focus={<strong class="js hv">bigState =&gt; smallState</strong>}&gt; */<br/>    &lt;ReduxFocus focus={<strong class="js hv">this</strong>.getState}&gt;      <br/>       &lt;ReduxDelay timeout={500}&gt;<br/>          counter: &lt;Counter /&gt; /* will connect to "redux" */ <br/>       &lt;/ReduxDelay&gt;<br/>    &lt;/ReduxFocus&gt;<br/>);</span></pre><p id="491a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重申一下，是一个强大的状态管理库。充分反应和Redux思想兼容。</p><h1 id="43aa" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">是时候试试了？</h1><p id="9f4f" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">重述是昨天发布的，但它已经准备好了。原始回购包含更多的例子，文件，和更多的理论。</p><div class="mu mv fm fo mw mx"><a href="https://github.com/theKashey/restate" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">凯西/重述</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">再次声明-使redux可组合！</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">github.com</p></div></div><div class="ng l"><div class="ov l ni nj nk ng nl kd mx"/></div></div></a></div><p id="bbfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让redux重新可组合！让组件架构开花结果！</p><p id="6657" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我有一个3(已经5)包给你。选择您需要的一个:</p><pre class="ju jv jw jx fq lu js lv lw aw lx dt"><span id="5d71" class="ly kl hu js b fv lz ma l mb mc">// to low-level redux manupulations<br/>import reduxRestate from 'redux-restate'; </span><span id="04d8" class="ly kl hu js b fv md ma l mb mc">// to work with multiple stores<br/>import reactReduxRestate from 'react-redux-restate'; </span><span id="cea3" class="ly kl hu js b fv md ma l mb mc">// to focus a lens on a single store<br/>import reactReduxFocus from 'react-redux-focus';</span><span id="747f" class="ly kl hu js b fv md ma l mb mc">// to freeze the time<br/>import reactReduxSemaphore from 'react-redux-semaphore';</span><span id="d3be" class="ly kl hu js b fv md ma l mb mc">// to optimize state changes<br/>import reactReduxDelay from 'react-redux-delay';</span><span id="9d25" class="ly kl hu js b fv md ma l mb mc">// to optimize update propagation<br/>import reactReduxUnbranch from 'react-redux-unbranch';</span></pre><p id="f92a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PS:每个组件的实际代码只有10-50 LoC。如果你读一下代码，事情可能会变得更清楚。</p><h2 id="ed00" class="ly kl hu bd km nz oa ob kq oc od oe ku jc of og ky jg oh oi lc jk oj ok lg ol dt translated">后续文章</h2><div class="mu mv fm fo mw mx"><a href="https://blog.cloudboost.io/the-state-of-the-state-of-the-state-f93c8bdc6b1b" rel="noopener  ugc nofollow" target="_blank"><div class="my ab ej"><div class="mz ab na cl cj nb"><h2 class="bd hv fv z el nc eo ep nd er et ht dt translated">国家的国家</h2><div class="ne l"><h3 class="bd b fv z el nc eo ep nd er et ek translated">换句话说，分形状态。更具体地说——还原分形状态。这是有可能创造分形使用…</h3></div><div class="nf l"><p class="bd b gc z el nc eo ep nd er et ek translated">blog.cloudboost.io</p></div></div><div class="ng l"><div class="ow l ni nj nk ng nl kd mx"/></div></div></a></div></div></div>    
</body>
</html>