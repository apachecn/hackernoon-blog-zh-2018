<html>
<head>
<title>Meltdown in a nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，彻底崩溃</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/meltdown-in-a-nutshell-bda0b79f84a2?source=collection_archive---------35-----------------------#2018-01-04">https://medium.com/hackernoon/meltdown-in-a-nutshell-bda0b79f84a2?source=collection_archive---------35-----------------------#2018-01-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0a9b" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">例外、渴望和电子</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/4cdef980bcbefc1d4da20d94c78e00f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNZxBb6ODBiTtitK0K3f4g.png"/></div></div></figure><h2 id="69c2" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">例外是起点</h2><p id="aebc" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">考虑这个伪代码:</p><p id="d8a2" class="pw-post-body-paragraph kt ku hu kv b kw lm iv ky kz ln iy lb kg lo ld le kk lp lg lh ko lq lj lk ll hn dt translated">x = read(memory _ location _ of _ OS _ where _ secret _ lies)//将导致异常</p><p id="3838" class="pw-post-body-paragraph kt ku hu kv b kw lm iv ky kz ln iy lb kg lo ld le kk lp lg lh ko lq lj lk ll hn dt translated">y = arr[x *4096] //根据x读取一些其他本地内存</p><h2 id="6d41" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated"><strong class="ak">CPU的急切</strong></h2><p id="909c" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">但是，第一行是一个例外，它不应该读取操作系统(OS)内存。由于在微操作中指令被中断的优化，在系统发现这是非法访问并清除/删除/清除x的值之前，x仅包含神圣的OS存储器的一小部分时间。</p><p id="1a80" class="pw-post-body-paragraph kt ku hu kv b kw lm iv ky kz ln iy lb kg lo ld le kk lp lg lh ko lq lj lk ll hn dt translated">与此同时，信不信由你，下一行代码已经准备好执行了，而且在操作系统清除x的值并引发异常之前就已经执行了。因此，如果x的值是' s '，那么内存arr['s' * 4096]将被CPU访问。</p><h2 id="98bc" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">电子产生热量</h2><p id="e920" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">在x被清除后，y的值也将很快被清除，因此攻击者无法再读取x或y。为了知道x的值，我们将检查缓存行，并以某种方式猜测x应该是什么。对arr['s' * 4096]地址的后续访问将激活高速缓存命中中的特定位。通过检查所有高速缓存地址中哪个地址是“热”的，我们可以找到“s”的值* 4096。然后我们做简单的数学运算，得到s。接下来，我们一次又一次地这样做，得到' e '，' c '，' r '，' e '，' t '。</p></div></div>    
</body>
</html>