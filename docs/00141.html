<html>
<head>
<title>Locally developing Kubernetes services (without waiting for a deploy)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本地开发Kubernetes服务(无需等待部署)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/locally-developing-kubernetes-services-without-waiting-for-a-deploy-f63995de7b99?source=collection_archive---------7-----------------------#2018-01-05">https://medium.com/hackernoon/locally-developing-kubernetes-services-without-waiting-for-a-deploy-f63995de7b99?source=collection_archive---------7-----------------------#2018-01-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d4c2a088e41f1a348b0501f1ec1333aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piSmb16pcpWgIrlzlGqOjg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/QQ9LainS6tI?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nate Grant</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="24ea" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<a class="ae jg" href="https://www.datawire.io" rel="noopener ugc nofollow" target="_blank"> Datawire </a>，我们所有的云服务都在Kubernetes上开发和部署。当我们开始开发服务时，我们注意到将代码更改到Kubernetes中是一个相当乏味的过程。通常，我们必须:</p><ul class=""><li id="7a4d" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">将代码更改保存到磁盘</li><li id="6b9a" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">重建包含代码的映像</li><li id="4236" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">标签图像</li><li id="b195" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">将图像推送到容器注册表</li><li id="745f" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">更新清单以指向新映像</li><li id="959e" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">运行<code class="eh kt ku kv kw b">kubectl apply</code></li></ul><p id="497c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们首先<a class="ae jg" href="https://forge.sh" rel="noopener ugc nofollow" target="_blank">自动化了这些步骤</a>，但是两行代码变更带来的延迟仍然令人烦恼(特别是对于我们这些习惯于解释语言实时重载的人)。</p><p id="a149" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们后退一步，问自己我们希望开发过程是什么样子的？我们得出了两个答案。首先，我们希望开发和生产环境保持一致。第二，我们希望在开发期间测试代码变更时零延迟。</p><h1 id="8bf9" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">集装箱化发展</h1><p id="f2f6" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们经历了试图找出为什么在开发中工作的服务在生产或我们的持续集成系统中不工作的痛苦。不可避免地，这些痛苦归结于环境差异。我们热衷于创造环境一致性，以尽量减少这种情况发生的机会。</p><p id="77d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">幸运的是，容器为这个问题提供了一个很好的解决方案。我们创建了一个用于开发和生产的标准Docker映像。这个Docker映像包含运行服务所需的所有依赖项。Docker客户机还允许我们将本地文件系统挂载到容器中，这允许我们在容器中运行代码时，使用我们最喜欢的编辑器编辑代码。</p><p id="beb2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种方法在开发过程中给了我们一个快速的反馈周期，同时在不同的环境之间创建了一致性。从事该服务的任何开发人员都能够使用相同的映像，这也是在生产中运行的相同映像。</p><h1 id="9416" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">远程服务</h1><p id="13c5" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们喜欢快速开发的容器方法。然而，我们的一些服务依赖于其他正在运行的服务，我们也想要一种开发多容器应用程序的方法。</p><p id="f90b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们首先开始试验minikube，但认为它不太适合，因为容器部署过程仍然会增加延迟。此外，minikube需要大量的RAM用于我们的一些服务(例如，需要JVM的服务)。</p><p id="a7c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还研究了Docker Compose，它很容易尝试，因为我们已经在使用容器了。我们决定不使用Compose，因为它从根本上为我们的应用程序(Docker)引入了不同于生产环境(Kubernetes/AWS)的运行时环境。这意味着我们必须维护两个不同的开发和生产环境。当我们开始考虑我们在云中运行的应用程序(例如AWS RDS)时，这个问题变得更加尖锐。</p><p id="2236" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们试验了一种面向网络的方法。我们已经熟悉了端口转发作为一种在集群中访问应用程序的方式，所以我们问自己是否有办法扩展这个概念。我们只需要找出一种方法让本地服务访问Kubernetes集群，反之亦然。</p><h1 id="f21b" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">远程呈现</h1><p id="7463" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们在<a class="ae jg" href="https://www.telepresence.io" rel="noopener ugc nofollow" target="_blank">网真</a>中实现了这个概念，我们在今年早些时候开源了它。网真用一个双向网络代理代替了在Kubernetes集群中运行的普通pod。这个pod将Kubernetes环境中的数据(例如，环境变量、机密、配置映射、TCP连接)代理到本地进程。本地进程透明地覆盖其网络，以便DNS调用和TCP连接通过代理路由到远程集群。</p><p id="d09a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个例子。克隆以下存储库:</p><p id="e1d9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kt ku kv kw b">$ git clone <a class="ae jg" href="https://github.com/datawire/hello-world-python" rel="noopener ugc nofollow" target="_blank">https://github.com/datawire/hello-world-python</a></code></p><p id="40ac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该存储库包含一个使用Flask web框架的简单Python应用程序:</p><pre class="ma mb mc md fq me kw mf mg aw mh dt"><span id="6ca7" class="mi ky hu kw b fv mj mk l ml mm">#!/usr/bin/python</span><span id="e4ab" class="mi ky hu kw b fv mn mk l ml mm">import time<br/>from flask import Flask<br/>app = Flask(__name__)</span><span id="ebc2" class="mi ky hu kw b fv mn mk l ml mm">START = time.time()</span><span id="3eaa" class="mi ky hu kw b fv mn mk l ml mm">def elapsed():<br/>    running = time.time() - START<br/>    minutes, seconds = divmod(running, 60)<br/>    hours, minutes = divmod(minutes, 60)<br/>    return "%d:%02d:%02d" % (hours, minutes, seconds)</span><span id="7c32" class="mi ky hu kw b fv mn mk l ml mm"><a class="ae jg" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def root():<br/>    return "Hello World (Python)! (up %s)\n" % elapsed()</span><span id="c59c" class="mi ky hu kw b fv mn mk l ml mm">if __name__ == "__main__":<br/>    app.run(debug=True, host="0.0.0.0", port=8080)</span></pre><p id="652b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它还包含一个Dockerfile，指定如何构建运行时容器:</p><pre class="ma mb mc md fq me kw mf mg aw mh dt"><span id="7dcc" class="mi ky hu kw b fv mj mk l ml mm">FROM python:3-alpine<br/>WORKDIR /service<br/>COPY requirements.txt .<br/>RUN pip install -r requirements.txt<br/>COPY . ./<br/>EXPOSE 8080<br/>ENTRYPOINT ["python3", "app.py"]</span></pre><p id="cd06" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们在本地构建开发环境:</p><p id="406c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kt ku kv kw b">$ cd hello-world-python</code></p><p id="17c2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kt ku kv kw b">$ docker build -t hello-world-dev .</code></p><p id="143c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让服务在Kubernetes中运行(我们使用Datawire映像，因此您不必推送至Docker注册表):</p><p id="5bd3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kt ku kv kw b">$ kubectl run hello --image=datawire/hello-world-python --port=8080 --expose</code></p><p id="02c1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，让我们测试一下这个服务。在另一个终端中，让我们在Kubernetes集群上启动一个pod来与服务对话。</p><pre class="ma mb mc md fq me kw mf mg aw mh dt"><span id="56f5" class="mi ky hu kw b fv mj mk l ml mm">$ kubectl run -i --tty alpine --image=alpine -- sh<br/>$ wget -q -O - <a class="ae jg" href="http://hello:8080" rel="noopener ugc nofollow" target="_blank">http://hello:8080</a><br/>Hello World (Python)! (up 0:00:45)</span></pre><p id="14a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，当您编写这个服务时，您必须经历一个构建容器、将其推送到注册中心以及重新部署的过程。让我们看看网真是如何工作的。确保您位于hello-world-python目录中，并键入:</p><p id="67fb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kt ku kv kw b">$ telepresence --swap-deployment hello --docker-run --rm -it -v $(pwd):/service hello-world-dev:latest</code></p><p id="bd71" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该命令做三件事:</p><ol class=""><li id="c180" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke mo kl km kn dt translated">它会将您现有的“hello”部署与远程呈现代理进行交换。</li><li id="d54a" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke mo kl km kn dt translated">它调用“docker run”来启动您的本地开发容器。</li><li id="5bad" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke mo kl km kn dt translated">它将您的本地文件系统(包含您的Git存储库)挂载到容器中，因此您可以进行实时编码。</li></ol><p id="390e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以通过修改<code class="eh kt ku kv kw b">app.py</code>来测试这一点。在您喜欢的编辑器中打开<code class="eh kt ku kv kw b">app.py </code>，将“Hello，World”字符串更改为您喜欢的任何内容。现在，从远程Kubernetes pod重新运行<code class="eh kt ku kv kw b">wget</code>命令:</p><pre class="ma mb mc md fq me kw mf mg aw mh dt"><span id="6308" class="mi ky hu kw b fv mj mk l ml mm">$ wget -q -O - <a class="ae jg" href="http://hello:8080" rel="noopener ugc nofollow" target="_blank">http://hello:8080</a><br/>Hello New World (Python)! (up 0:03:12)</span></pre><p id="4bb0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，您可以在本地编辑代码，更改会立即反映到Kubernetes集群中的客户端，而无需重新部署、创建Docker映像等等。</p><p id="3658" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您使用支持自动重新加载的服务器，Telepresence将使该功能再次发挥作用，您可以编辑服务器代码、保存并立即测试该功能。</p><h1 id="3066" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">结论</h1><p id="a8a1" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">远程呈现简化了我们的编码周期。我们已经将它<a class="ae jg" href="https://github.com/datawire/telepresence" rel="noopener ugc nofollow" target="_blank">开源</a>，并为Mac OS X和Linux 创建了<a class="ae jg" href="https://www.telepresence.io/reference/install" rel="noopener ugc nofollow" target="_blank"> OS原生包。我们希望您能尝试一下，看看它是否能让您的生活变得更轻松。欲了解更多信息，请访问</a><a class="ae jg" href="https://www.telepresence.io" rel="noopener ugc nofollow" target="_blank">https://www . tele presence . io</a>。</p></div></div>    
</body>
</html>