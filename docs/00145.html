<html>
<head>
<title>WebAssembly, the journey</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly，旅程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/webassembly-the-journey-a069d6ea18a?source=collection_archive---------11-----------------------#2018-01-05">https://medium.com/hackernoon/webassembly-the-journey-a069d6ea18a?source=collection_archive---------11-----------------------#2018-01-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="553c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大家好，我正在写一系列的帖子来展示我学习WebAssembly的旅程。我希望不久能带来更多这方面的文章。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/554e52b83d6a11fc124ebdad98744191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDDOWu7xMeti0QIqkBtqqQ.png"/></div></div></figure><p id="d8d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在2015年的BrazilJs conf上，我观看了Javascript的创造者<a class="kb kc gr" href="https://medium.com/u/bcf2eaa79e8c?source=post_page-----a069d6ea18a--------------------------------" rel="noopener" target="_blank"> BrendanEich </a>的闭幕主题演讲，他谈到了Js的诞生、成长和发展。了解他的人都知道，他最著名的一句名言是“<em class="kd">永远赌JS </em>”，但在他演讲的最后，他说了一句让我难以忘怀的话:</p><blockquote class="ke kf kg"><p id="7285" class="ir is kd it b iu iv iw ix iy iz ja jb kh jd je jf ki jh ji jj kj jl jm jn jo hn dt translated"><strong class="it hv">一直赌Js &amp; WASM </strong></p></blockquote><p id="c561" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那是我第一次接触这个名字，但是WebAssembly是什么？这项技术试图解决的问题是什么？在那一刻，我开始了回答所有这些问题的旅程。</p><h1 id="a5db" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">我们的概念证明</h1><p id="6c54" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">为了更好地理解这项技术，我和我的朋友兼开发人员<a class="kb kc gr" href="https://medium.com/u/7fb5087df4e4?source=post_page-----a069d6ea18a--------------------------------" rel="noopener" target="_blank"> Elia Maino </a>一起开发了一种算法，可以让我们比较WASM相对于普通JS的性能。</p><p id="cbf3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了证明我们的概念，我们选择了John Conway的生命游戏作为本次概念验证的问题。这是一个零玩家游戏，有一些简单的规则。</p><ul class=""><li id="62e3" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv dt translated">世界是一个矩阵，每个单元可以有两种状态:<code class="eh lw lx ly lz b">ALIVE</code>或<code class="eh lw lx ly lz b">DEAD</code>。</li><li id="96b6" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">唯一的外部输入是初始状态</li><li id="e978" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">当前单元与其水平、垂直和对角相邻单元的相互作用决定了特定单元的状态。</li><li id="fb9f" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">少于两个活邻居的活细胞死亡。</li><li id="2f4a" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">一个有两个或三个活邻居的活细胞可以存活到下一代。</li><li id="3520" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">具有三个以上活邻居的活细胞死亡。</li><li id="0035" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">正好有三个活邻居的死细胞变成活的。</li></ul><p id="0e19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这里的计划是创建一个大矩阵，用随机值(0或1)填充它，发送这个初始状态并呈现结果，然后计算下一个状态并再次呈现它，重复最后一步几次。</p><p id="2ae9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们计划用三种策略实现这个解决方案:<strong class="it hv"> Vanilla JS、WebAssembly和Web workers </strong>。我们的算法在所有方法上的时间复杂度是<strong class="it hv"> O(n*m) </strong>其中<strong class="it hv"> n </strong>是我们世界的宽度，而<strong class="it hv"> m </strong>是它的高度。由于渲染对于所有方法来说都是相同的代码，所以我们不会在结果测量中考虑它。</p><h1 id="6c43" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">香草JS</h1><p id="cbdd" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">该方法的基础架构在于创建新游戏，生成并发送第一状态(填充0和1的矩阵)给它。组件<code class="eh lw lx ly lz b">game</code>存储这个状态并返回一个函数<code class="eh lw lx ly lz b">next</code>,该函数在被调用时返回下一个状态。在这种情况下，我们从我们的<code class="eh lw lx ly lz b">environment.js</code>文件中调用getNextState()函数，这是普通的JS实现。</p><pre class="jq jr js jt fq mf lz mg mh aw mi dt"><span id="a149" class="mj kl hu lz b fv mk ml l mm mn">...</span><span id="329f" class="mj kl hu lz b fv mo ml l mm mn">const next = game(<br/>  document.getElementById('game'),<br/>  COLUMNS,<br/>  LINES,<br/>  createGameMatrix(LINES, COLUMNS), // generates the initial state<br/>  strategy(<br/>    STRATEGY,<br/>    COLUMNS,<br/>    LINES,<br/>    initialConfig<br/>  ) // Defines which strategy to use to calculate the next state<br/>);</span><span id="49a2" class="mj kl hu lz b fv mo ml l mm mn">...</span><span id="7f3b" class="mj kl hu lz b fv mo ml l mm mn">function loop() {<br/>  next().then(() =&gt; {<br/>    requestAnimationFrame(loop);<br/>  });<br/>};</span><span id="ea80" class="mj kl hu lz b fv mo ml l mm mn">loop();</span></pre><p id="5f19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh lw lx ly lz b">environment.js</code>组件中，我们不断地将问题分解成小的专门功能。这将有助于更容易地触发浏览器JIT编译器优化。我们将在下一篇文章中讨论这些优化。这些函数计算上面、旁边和下面的邻居的当前状态，覆盖所有边界的拐角情况。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mp"><img src="../Images/6d55de6d904e2b5a1f1b5d2bd3db01de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*698m0ipHVy4L6JuoiyfceQ.png"/></div></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">The average speed of this state calculation varied from 9 to 4ms for a matrix of 800x450.</figcaption></figure><p id="abd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能想知道下一个状态的计算有这么多变化的原因，或者为什么有这么多函数？要回答这些问题，我们需要向您展示JS JIT编译器是如何工作的，以及这是如何让JS变得如此之快。<a class="ae mu" rel="noopener" href="/p/dfa4081a6ffb">但这是下一篇文章</a>的主题。</p><h1 id="a21a" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">链接</h1><ul class=""><li id="58e9" class="ln lo hu it b iu li iy lj jc mv jg mw jk mx jo ls lt lu lv dt translated">本文葡萄牙语版:<a class="ae mu" rel="noopener" href="/@wmsbill/webassembly-a-jornada-f5aec56c507f">https://medium . com/@ WMS bill/web assembly-a-jornada-f 5 AEC 56 c 507 f</a></li><li id="b909" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">Brendan Eich年巴西闭幕主题演讲:<a class="ae mu" href="https://www.youtube.com/watch?v=bM79WQ9iMZQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=bM79WQ9iMZQ</a></li><li id="a9b3" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">约翰·康威生活的游戏:<a class="ae mu" href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Conway's_Game_of_Life</a></li><li id="a5a0" class="ln lo hu it b iu ma iy mb jc mc jg md jk me jo ls lt lu lv dt translated">我们的PoC Github回购:<a class="ae mu" href="https://github.com/eliamaino-fp/webassembly-js" rel="noopener ugc nofollow" target="_blank">https://github.com/eliamaino-fp/webassembly-js</a></li></ul></div></div>    
</body>
</html>