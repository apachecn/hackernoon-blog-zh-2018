<html>
<head>
<title>System calls have become more expensive with Meltdown. How to avoid them?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随着Meltdown的出现，系统调用变得更加昂贵。如何避开它们？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/system-calls-have-been-more-expensive-with-meltdown-how-to-avoid-them-af4b0026d35a?source=collection_archive---------22-----------------------#2018-01-05">https://medium.com/hackernoon/system-calls-have-been-more-expensive-with-meltdown-how-to-avoid-them-af4b0026d35a?source=collection_archive---------22-----------------------#2018-01-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/2eb892c32475527e50c9923cc9fe4196.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*-CAZlES6rsvZw4o0WR-KaA.png"/></div></figure><p id="cc67" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你现在应该听说过熔毁吧。这是一个硬件漏洞，允许未经授权的进程访问特权内存。它会影响自1995年以来生产的英特尔处理器。以下是一些细节:<a class="ae jw" href="https://en.wikipedia.org/wiki/Meltdown_%28security_vulnerability%29" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/…/Meltdown _(security _ vulnerability)</a></p><p id="5227" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">解决这个问题的唯一有效方法是对您的操作系统(Linux、Windows、macOS)的内核应用补丁，这将显著增加系统调用的成本:这将导致您在Linux、Windows或macOS上运行的所有程序的性能平均下降5–30%。更多详情在此:<a class="ae jw" href="https://www.theregister.co.uk/2018/01/02/intel_cpu_design_flaw/" rel="noopener ugc nofollow" target="_blank">https://www . the register . co . uk/…/01/02/Intel _ CPU _ design _ flaw/</a></p><p id="8dd5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这对你使用的软件意味着什么？每次操作的系统调用越多，效果越差。这对<a class="ae jw" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a> <a class="ae jw" href="https://hackernoon.com/tagged/management" rel="noopener ugc nofollow" target="_blank">管理</a>系统(DBMS)来说尤其糟糕，因为它们通常会在每次查询时进行大量的系统调用。这是传统关系DBMS处理事务的一个非常简化的执行链:</p><ol class=""><li id="8c1b" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">接受连接(系统调用)。</li><li id="2ce2" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">创建一个进程或线程(系统调用)，或者(如果数据库使用预先创建的线程池)在线程池中找到一个空闲线程(这意味着访问一个共享变量，该变量存储应该锁定和解锁的线程的状态，从而产生两个系统调用)</li><li id="30ec" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">从套接字读取查询(系统调用)。</li><li id="2c30" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">锁定互斥体(系统调用)。</li><li id="5d30" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">向RAM读取/写入内容。</li><li id="30fe" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">向磁盘读/写东西(至少一个syscall)。</li><li id="8ff6" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">解锁互斥锁(系统调用)。</li><li id="c4c1" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">将事务结果写入事务日志(syscall)。</li><li id="1595" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">向套接字写入响应(系统调用)。</li></ol><p id="d565" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">许多传统的数据库管理系统(MySQL、Postgres、Oracle等。)在每个事务中进行多次系统调用。在打了补丁的操作系统上，它们可能会变得非常慢，因为系统调用已经变得更加昂贵。</p><p id="4a55" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">幸运的是，有一些现代的DBMSs，如Redis、Aerospike或Tarantool，它们的目标是每个CPU内核每秒100K+事务的性能，它们采用了许多聪明的技巧来减少每个事务的系统调用次数。</p><p id="b1e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">其中一个技巧是对并行执行的多个查询使用单个套接字，这允许一次读取多个并行查询，一次将它们保存到事务日志中，一次将所有响应写入套接字。更少的系统调用——更多有用的工作。</p><p id="66a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请点击此处查看详情:</p><div class="kl km fm fo kn ko"><a rel="noopener follow" target="_blank" href="/@denisanikin/asynchronous-processing-with-in-memory-databases-or-how-to-handle-one-million-transactions-per-36a4c01fc4e4"><div class="kp ab ej"><div class="kq ab kr cl cj ks"><h2 class="bd hv fv z el kt eo ep ku er et ht dt translated">内存数据库的异步处理或如何处理每秒一百万个事务…</h2><div class="kv l"><h3 class="bd b fv z el kt eo ep ku er et ek translated">嘿！</h3></div><div class="kw l"><p class="bd b gc z el kt eo ep ku er et ek translated">medium.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc iw ko"/></div></div></a></div><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure></div></div>    
</body>
</html>