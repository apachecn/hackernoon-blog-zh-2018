<html>
<head>
<title>RxJS — Reduce Angular app bundle size using lettable operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS使用可允许的运算符减小角度应用程序包的大小</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rxjs-reduce-bundle-size-using-lettable-operators-418307295e85?source=collection_archive---------0-----------------------#2018-01-06">https://medium.com/hackernoon/rxjs-reduce-bundle-size-using-lettable-operators-418307295e85?source=collection_archive---------0-----------------------#2018-01-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/b85506cc4262295293273e7350f57e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*stCCFNrSLKPZvOHobBXB4w.png"/></div></figure><p id="822e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">RxJS版本5。5在RxJS的导入过程中引入了一个有影响的变化，并添加了可允许的操作符。这篇博客文章是一个小的比较，说明了lettable操作符是如何提高应用程序的包大小的。我选择Angular作为我的框架来展示这一点，但这可以在vanilla js或任何框架中完成。</p><h1 id="9e46" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">方法</h1><ul class=""><li id="71ff" class="ku kv hu ja b jb kw jf kx jj ky jn kz jr la jv lb lc ld le dt translated">RxJS导入流程的变化</li><li id="543a" class="ku kv hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">可出租运算符简介</li><li id="1500" class="ku kv hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">通过webpack或其他捆绑器使用RxJS&lt; 5.5</li><li id="b806" class="ku kv hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">Collect metrics on bundle sizes on RxJS &lt; 5.5</li><li id="e0c5" class="ku kv hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">Upgrade to RxJS 5.5 and update the application</li><li id="632c" class="ku kv hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">Collect metrics on upgraded application</li></ul><h1 id="9b95" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">Changes in the imports when using RxJS</h1><p id="9cab" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">In version 5.5, we can import operators/creation utils using es6 imports.</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="6037" class="lw jx hu ls b fv lx ly l lz ma"><br/>import { map, scan, filter } from 'rxjs/operators';<br/></span></pre><p id="2e0b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Any operator (function) can be imported from  【T0】 </p><p id="0cb3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Observable creation methods have also been updated.</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="c819" class="lw jx hu ls b fv lx ly l lz ma"><br/>import { of } from 'rxjs/observable/of';<br/>import { from } from 'rxjs/observable/from';<br/>import { range } from 'rxjs/observable/range';</span><span id="7383" class="lw jx hu ls b fv me ly l lz ma"><br/>const source$ = of(1,2,3);</span><span id="4cbe" class="lw jx hu ls b fv me ly l lz ma">const rangeSource$ = range(0,5);<br/></span></pre><h1 id="b561" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">Introduction to lettable operators</h1><p id="38e7" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">Lettable Operators are functions that accept an observable and return an observable. A new method has been introduced to Observable’s prototype called  【T1】 . Using  【T2】  we can compose n-number of functions to act on our observable-emitted values. Lets see an example of  【T3】  using map, scan and filter.</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="2134" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Operator which are part of the prototype of the observable are not<strong class="ja hv"><em class="mh">tree-shake able</em></strong>实现一个小应用。这将增加包的大小，因为即使不使用操作符，它们也会成为包的一部分。然而，可允许的操作符是纯函数。未使用时，它们被排除在捆绑包之外。即使是linters也能识别出这些函数是声明的，但并没有在任何地方使用。</p><p id="34fb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> <em class="mh">摇树就是死码淘汰的过程。</em>T12】</strong></p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="5d96" class="lw jx hu ls b fv lx ly l lz ma"><em class="mh">Note: A few operators have been renamed to avoid conflicts with Javascript keywords</em></span><span id="c7e6" class="lw jx hu ls b fv me ly l lz ma">do -&gt; tap <br/>switch -&gt; switchAll<br/>catch -&gt; catchError<br/>finally -&gt; finalize</span></pre><p id="f230" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这一点上，假设我们想在每次转换后执行控制台记录值的副作用。我们可以通过添加重命名的方法<code class="eh mb mc md ls b">tap</code>来实现。</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><h1 id="8e8b" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">RxJS中的Angular应用&lt; 5.5</h1><p id="6227" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">I am going to use an Angular application which I have used in few of my previous blog posts.</p><p id="d8c7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">demo: <a class="ae mi" href="https://ashwin-sureshkumar.github.io/angular-cache-service-blog/" rel="noopener ugc nofollow" target="_blank">https://ashwin-sureshkumar . github . io/angular-cache-service-blog/</a></p><p id="b695" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">github:<a class="ae mi" href="https://github.com/ashwin-sureshkumar/angular-cache-service-blog" rel="noopener ugc nofollow" target="_blank">https://github . com/ashwin-sureshkumar/angular-cache-service-blog</a></p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/e4eee862008badf92372596c6635b7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*LAvPXoCW_UAjEN4esQqCGg.gif"/></div></figure><p id="d382" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我不打算讨论这个应用程序是如何构建的，因为它已经在以前的博客文章中讨论过了。这篇文章主要关注RxJS和应用程序的构建标准。</p><h1 id="c289" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">收集捆绑包大小RxJS &lt; 5.5的指标</h1><p id="fe16" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">为了可视化我们的构建度量，我们需要安装<code class="eh mb mc md ls b">webpack-bundle-analyzer</code></p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="366c" class="lw jx hu ls b fv lx ly l lz ma">npm install webpack-bundle-analyzer --save-dev</span></pre><p id="59b4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，是时候构建我们的应用程序了。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="a39c" class="lw jx hu ls b fv lx ly l lz ma">ng build --prod --stats-json</span><span id="8a3d" class="lw jx hu ls b fv me ly l lz ma"><br/>// Above command builds our application in prod mode and also,      // generates stats.json, and stores it in /dist/stats.json</span></pre><p id="e53d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要可视化我们的指标，运行下面的命令。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="0f8e" class="lw jx hu ls b fv lx ly l lz ma">webpack-bundle-analyzer dist/stats.json</span></pre><p id="660f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这将在浏览器中打开一个应用程序。</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mk"><img src="../Images/d333d8be918ad36b23659fd322188ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tbr7eHPh_DPZClI4btqLRA.png"/></div></div></figure><p id="3990" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的截图中，重点关注<code class="eh mb mc md ls b">rxjs</code>部分。我们可以看到，每一个操作符、util、调度器和可观察类型都被导入到我们的供应商中，即使我们在应用程序中没有利用它们中的大部分。这是我们的应用程序附带的不必要的代码。关注下面的rxjs统计。</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mp"><img src="../Images/8191ec196a7703f69833432f3e9c5828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADgNmV0eE0Ew9G-RDtHn5w.png"/></div></div></figure><h1 id="19c0" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">将我们的应用程序升级到RxJS 5.5</h1><p id="877f" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">让我们将示例应用程序升级到RxJS 5.5，Angular版本升级到5.1，并安装所需的对等依赖项。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="4c31" class="lw jx hu ls b fv lx ly l lz ma">$ npm install @angular/{animations,common,compiler,compiler-cli,core,forms,http,platform-browser,platform-browser-dynamic,router}@5.1.1</span></pre><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mq mg l"/></div></figure><p id="0274" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">感谢</strong> <a class="mr ms gr" href="https://medium.com/u/96d4cd23fa0e?source=post_page-----418307295e85--------------------------------" rel="noopener" target="_blank"> <strong class="ja hv">伊戈尔·米纳尔</strong> </a> <strong class="ja hv">，我们知道Angular应用程序中的树摇动依赖于Angular build-optimizer包，所以请确保安装它。</strong></p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="5f7b" class="lw jx hu ls b fv lx ly l lz ma">// command to run</span><span id="69df" class="lw jx hu ls b fv me ly l lz ma">npm install @angular-devkit/build-optimizer</span></pre><p id="07a5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们的应用程序的主要变化是无限滚动指令、hackernews服务和AppComponent</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><h1 id="b589" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">收集升级后的应用程序的指标</h1><p id="ffda" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hn dt translated">在上一步中，我们已经安装了bundle analyzer，因此让我们构建应用程序并可视化我们的指标。</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="9cfb" class="lw jx hu ls b fv lx ly l lz ma">ng build --prod --stats-json</span><span id="772a" class="lw jx hu ls b fv me ly l lz ma">// once build is finished </span><span id="12de" class="lw jx hu ls b fv me ly l lz ma">webpack-bundle-analyzer dist/stats.json</span></pre><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mt"><img src="../Images/f88757c904462a38d836cb0a940c5031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OiyeuTx-tDxkYs4upLoZg.png"/></div></div></figure><p id="14de" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的metrics visual中，你可以看到rxjs部分并不包含操作符、可观察值、util函数等的完整列表。与我们之前看到的相比，这个包非常小。下面是对统计数据的进一步观察。</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mu"><img src="../Images/5c9ce146d30c365e3deec4453d1d9ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9EzltshoJlDgQzosD1-bBg.png"/></div></div></figure><p id="2b10" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">请注意确保您正在使用的外部库遵循相同的方法。如果没有，他们的进口将影响您的捆绑大小。</strong></p><p id="b21b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">虽然这篇文章描述了如何使用lettable操作符来减少包的大小，但我希望它能激起您对包的大小、性能以及如何在考虑性能的情况下构建应用程序的好奇心。如果你喜欢这篇文章，请分享，评论和推荐。</p></div></div>    
</body>
</html>