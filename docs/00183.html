<html>
<head>
<title>Services Stack — with CI/CD for your Infrastructure and Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务堆栈—为您的基础架构和代码提供CI/CD</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/services-stack-with-ci-cd-for-your-infrastructure-and-code-ede3e2919afa?source=collection_archive---------11-----------------------#2018-01-06">https://medium.com/hackernoon/services-stack-with-ci-cd-for-your-infrastructure-and-code-ede3e2919afa?source=collection_archive---------11-----------------------#2018-01-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="f8b0" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">只需签入您的基础架构和代码更改，它们就会自动部署，这不是很好吗？</h2></div><p id="e5df" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">早在十月份，我就发布了<a class="ae kf" href="https://hackernoon.com/the-services-stack-235cca4a15f7" rel="noopener ugc nofollow" target="_blank">服务栈</a>。<a class="ae kf" href="https://hackernoon.com/the-services-stack-235cca4a15f7" rel="noopener ugc nofollow" target="_blank">服务栈</a>是CloudFormation模板的集合，用于在AWS上创建微服务应用。如果你还没看过，请去看看。</p><p id="8246" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在发布了<a class="ae kf" href="https://hackernoon.com/the-services-stack-235cca4a15f7" rel="noopener ugc nofollow" target="_blank">服务栈</a>之后，我得到了很多很好的反馈，大部分都是好的；).原来缺少的是持续集成和持续部署(CI/CD)。</p><p id="549b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我已经回去添加了这些功能，今天很高兴与大家分享。没有进一步的延迟，这里是代码…</p><div class="kg kh fm fo ki kj"><a href="https://github.com/thestackshack/services-stack-cicd" rel="noopener  ugc nofollow" target="_blank"><div class="kk ab ej"><div class="kl ab km cl cj kn"><h2 class="bd hv fv z el ko eo ep kp er et ht dt translated">堆栈/服务-堆栈-cicd</h2><div class="kq l"><h3 class="bd b fv z el ko eo ep kp er et ek translated">服务-堆栈-cicd - ECS内置CI/CD的微服务堆栈</h3></div><div class="kr l"><p class="bd b gc z el ko eo ep kp er et ek translated">github.com</p></div></div><div class="ks l"><div class="kt l ku kv kw ks kx ky kj"/></div></div></a></div><h1 id="597f" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">管道</h1><blockquote class="lr ls lt"><p id="5a5b" class="jj jk lu jl b jm jn iv jo jp jq iy jr lv jt ju jv lw jx jy jz lx kb kc kd ke hn dt translated">一切都是管道</p></blockquote><p id="78f8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我使用CodePipeline不断更新所有CloudFormation栈，构建代码，部署代码。对于<code class="eh ly lz ma mb b">application</code>有一个流水线，对于每个<code class="eh ly lz ma mb b">service</code>有一个流水线。</p><p id="bba9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请看这张图表，然后我们将在下面讨论更多细节:</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mc"><img src="../Images/c7ee51830fcdcfc9fb92c7230ddd5396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQQY0Q01ubdYVQF_Cl1EQQ.png"/></div></div></figure><h2 id="3602" class="mn la hu bd lb mo mp mq lf mr ms mt lj js mu mv ll jw mw mx ln ka my mz lp na dt translated">应用程序管道</h2><p id="b6a2" class="pw-post-body-paragraph jj jk hu jl b jm nb iv jo jp nc iy jr js nd ju jv jw ne jy jz ka nf kc kd ke hn dt translated">应用程序管道创建应用程序特定的堆栈(即，与服务无关)，然后引导每个服务管道。</p><p id="d341" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">应用程序管道最初是通过命令行创建的。然后它在每次提交时执行。</p><p id="7975" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">应用程序管道由以下阶段组成:</p><ol class=""><li id="4004" class="ng nh hu jl b jm jn jp jq js ni jw nj ka nk ke nl nm nn no dt translated">通知阶段</li><li id="e925" class="ng nh hu jl b jm np jp nq js nr jw ns ka nt ke nl nm nn no dt translated">VPC阶段</li><li id="1988" class="ng nh hu jl b jm np jp nq js nr jw ns ka nt ke nl nm nn no dt translated">ECS阶段</li><li id="9291" class="ng nh hu jl b jm np jp nq js nr jw ns ka nt ke nl nm nn no dt translated">服务阶段</li></ol><p id="60c0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">通知阶段</strong></p><p id="bb70" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通知阶段包含两个操作。第一个操作创建一个CloudFormation堆栈，其中包含通知用户有关DevOps事件(如构建状态、部署状态等)的资源。第二个操作执行一个代码构建，以测试和部署前一个堆栈中的Lambda函数，并始终保持其新鲜。</p><p id="6461" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> VPC舞台</strong></p><p id="8550" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">VPC阶段包含一个动作。为我们的应用程序建立VPC的CloudFormation堆栈。</p><p id="3545" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> ECS阶段</strong></p><p id="f111" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">ECS阶段包含一个操作。一个CloudFormation堆栈，使用EC2和ALB设置ECS集群。</p><p id="67e5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">服务阶段</strong></p><p id="d453" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">服务阶段包含每个微服务的一个操作。每个动作都是一个CloudFormation堆栈，为该服务创建管道。</p><h2 id="3107" class="mn la hu bd lb mo mp mq lf mr ms mt lj js mu mv ll jw mw mx ln ka my mz lp na dt translated">服务管道</h2><p id="3de7" class="pw-post-body-paragraph jj jk hu jl b jm nb iv jo jp nc iy jr js nd ju jv jw ne jy jz ka nf kc kd ke hn dt translated">服务管道创建特定于服务的堆栈，执行代码构建，最后是代码部署。</p><p id="99a1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个服务管道在每个推送到特定服务的代码上执行。</p><p id="918a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">服务管道由以下阶段组成:</p><ol class=""><li id="4999" class="ng nh hu jl b jm jn jp jq js ni jw nj ka nk ke nl nm nn no dt translated">ECR和代码构建阶段</li><li id="3cfc" class="ng nh hu jl b jm np jp nq js nr jw ns ka nt ke nl nm nn no dt translated">服务阶段</li></ol><p id="5ba5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> ECR &amp;代码构建阶段</strong></p><p id="51af" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">ECR &amp; CodeBuild阶段有两个动作。</p><p id="dbec" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">ECR操作只是为我们的Docker图像创建一个ECR存储库。</p><p id="c4d9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">CodeBuild操作首先构建代码，然后将图像推送到ECR。</p><p id="23b1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">服务阶段</strong></p><p id="eead" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">服务阶段有一个单一的动作，它是所有服务相关资源的云形成栈。创建ECR任务时，将使用前一阶段新创建的ECR映像，从而部署最新的更改。如果希望手动部署，可以使用特定的版本。</p><h2 id="59ea" class="mn la hu bd lb mo mp mq lf mr ms mt lj js mu mv ll jw mw mx ln ka my mz lp na dt translated">环境</h2><p id="dcaa" class="pw-post-body-paragraph jj jk hu jl b jm nb iv jo jp nc iy jr js nd ju jv jw ne jy jz ka nf kc kd ke hn dt translated">支持两种环境，沙盒和生产。沙盒从“开发”分支触发，生产从“主”分支触发。</p><h1 id="2146" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">结论</h1><p id="aa0e" class="pw-post-body-paragraph jj jk hu jl b jm nb iv jo jp nc iy jr js nd ju jv jw ne jy jz ka nf kc kd ke hn dt translated">基础设施和代码一样重要。让两者都通过CI/CD是最佳做法。我希望你喜欢这一叠。<strong class="jl hv">如果有(或者没有)请鼓掌</strong>。</p></div></div>    
</body>
</html>