<html>
<head>
<title>Combining bezier curves and jQuery coordinates.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">结合贝塞尔曲线和jQuery坐标。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/combining-bezier-curves-and-jquery-coordinates-264e63669e2e?source=collection_archive---------14-----------------------#2018-01-06">https://medium.com/hackernoon/combining-bezier-curves-and-jquery-coordinates-264e63669e2e?source=collection_archive---------14-----------------------#2018-01-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/b5ffecc15a62daa15c828884b92bee3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3uYrPpNl-0faQqeAWUL9PQ.png"/></div></figure><div class=""/><p id="f7a4" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">我最近在做一个新的投资组合网站。我脑子里有这个想法，我希望它看起来像什么，为了让它工作，我必须尝试一些我不熟悉的东西。这是网站，如果你想尝试类似的东西，我会解释我是如何让它工作的想法:<a class="ae jx" href="https://ethansportfolio.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://ethansportfolio.herokuapp.com/</a></p><p id="cd47" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">如你所见，链接到我的每个网站的按钮在屏幕上浮动。当浮动时，它们在背景中创建一个几何形状，随着浮动按钮的移动而移动和调整。这或多或少是我开始时的想法。</p><p id="5a6e" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">我的思考过程是这样的:</p><ol class=""><li id="e55e" class="jy jz ib jb b jc jd jg jh jk ka jo kb js kc jw kd ke kf kg dt translated">我需要创建HTML元素。</li><li id="9dcb" class="jy jz ib jb b jc kh jg ki jk kj jo kk js kl jw kd ke kf kg dt translated">我需要动画的HTML元素。</li><li id="2489" class="jy jz ib jb b jc kh jg ki jk kj jo kk js kl jw kd ke kf kg dt translated">我需要创建一个svg多边形元素，它的点基于动画元素。</li></ol><h1 id="196a" class="km kn ib bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">HTML</h1><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="d294" class="lt kn ib lp b fv lu lv l lw lx">&lt;div class="linkContainer"&gt;<br/>    &lt;a href="/portfolioB"&gt;<br/>      &lt;div id="site1" value="Donald Trump Site" class="site1 active"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/a&gt;<br/>    &lt;a href="/portfolioF"&gt;<br/>      &lt;div id="site2" value="Simple Piano" class="site2"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/a&gt;<br/>    &lt;a href="/portfolioE"&gt;<br/>      &lt;div id="site3" value="Weather App" class="site3"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/a&gt;<br/>    &lt;a href="/portfolioA"&gt;<br/>      &lt;div id="site4" value="Search &amp; Play Music" class="site4"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/a&gt;<br/>    &lt;a href="/portfolioD"&gt;<br/>      &lt;div id="site5" value="Presentation Maker" class="site5"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/a&gt;<br/>    &lt;a href="/portfolioG"&gt;<br/>      &lt;div id="site6" value="DrayNori" class="site6"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/a&gt;<br/>    &lt;a href="/portfolioC"&gt;<br/>      &lt;div id="site7" value="Form Tests" class="site7"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/a&gt;<br/>  &lt;/div&gt;</span></pre><p id="f055" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">很简单。现在，我将创建一个空的Div，它将在背景中保存我的多边形。</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="9214" class="lt kn ib lp b fv lu lv l lw lx">&lt;div class="polygonContainer"&gt;<br/>    &lt;div id="polygon"&gt;&lt;/div&gt;<br/>  &lt;/div&gt;</span></pre><p id="aba7" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">太好了。目前看起来不错。接下来，我需要制作每个链接的动画。为了实现这一目标，我经历了几种可能性。最初，我开始计算屏幕/窗口的大小，然后根据当前的窗口尺寸在JavaScript中移动元素。那条路走得并不顺利。最后我看到了一篇关于使用贝塞尔曲线的文章。我以前在做过渡时使用过贝塞尔曲线，但从来没有在CSS的关键帧动画中使用过，但它看起来很有前途。在弹出代码后，很容易快速看到一些动画，但对我来说，因为这是我的第一次，所以需要相当多的技巧才能让动画看起来像我想象的那样。因为我希望每个元素的浮动都不同于其他元素，所以我为每个元素创建了不同的关键帧动画，并分别调整了每个元素。以下是我在CSS中用于关键帧动画的样板代码:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="9bde" class="lt kn ib lp b fv lu lv l lw lx">div#site1.site1 {<br/>  z-index: 2;<br/>  position: static;<br/>  transition-timing-function: cubic-bezier(0.64, 0.57, 0.67, 1.53);<br/>transition-duration: 1s;<br/>height: 10%;<br/>display: flex;<br/>align-items: center;<br/>-webkit-animation: xAxis1 80.5s infinite cubic-bezier(40.9, 0.9, 20.1, 50.0);<br/>animation: yAxis1 70.5s infinite cubic-bezier(0.7, 0.27, 0.57, 0.1);<br/>-webkit-animation: yAxis1 50.5s infinite cubic-bezier(40.7, 0.27, 20.57, 50.64);<br/>animation: xAxis1 80.5s infinite cubic-bezier(.002, 0.004, 0.1, 0.1);<br/>}</span><span id="bfed" class="lt kn ib lp b fv ly lv l lw lx">div#site1.site1::after {<br/>  transition-timing-function: cubic-bezier(0.64, 0.57, 0.67, 1.53);<br/>transition-duration: 1s;<br/>font-family: 'Sedgwick Ave Display', cursive;<br/>  background-size: cover;<br/>  object-fit: cover;<br/>  object-position: top;<br/>  cursor: pointer;<br/>  border: solid black;<br/>  border-left-width: 2.2px;<br/>  border-top-width: 1.8px;<br/>  border-right-width: 1.5px;<br/>  border-bottom-width: 1.2px;<br/>  z-index: 2;<br/>  font-size: 20px;<br/>  font-weight: bold;<br/>  padding: 10px;<br/>  width: 250px;<br/>  color: white;<br/>  text-shadow: rgb(11, 16, 18) 2px 0px 0px, rgb(11, 16, 18) 1.75517px 0.958851px 0px, rgb(11, 16, 18) 1.0806px 1.68294px 0px, rgb(11, 16, 18) 0.141474px 1.99499px 0px, rgb(11, 16, 18) -0.832294px 1.81859px 0px, rgb(11, 16, 18) -1.60229px 1.19694px 0px, rgb(11, 16, 18) -1.97998px 0.28224px 0px, rgb(11, 16, 18) -1.87291px -0.701566px 0px, rgb(11, 16, 18) -1.30729px -1.5136px 0px, rgb(11, 16, 18) -0.421592px -1.95506px 0px, rgb(11, 16, 18) 0.567324px -1.91785px 0px, rgb(11, 16, 18) 1.41734px -1.41108px 0px, rgb(11, 16, 18) 1.92034px -0.558831px 0px;<br/>  background-color: white;<br/>  display: flex;<br/>  justify-content: center;<br/>  align-items: center;<br/>  content: attr(value);<br/>  display: block;<br/>  -webkit-animation: xAxis1 80.5s infinite cubic-bezier(40.9, 0.9, 20.1, 50.0);<br/>  animation: xAxis1 80.5s infinite cubic-bezier(.002, 0.004, 0.1, 0.1);<br/>  animation: yAxis1 70.5s infinite cubic-bezier(0.7, 0.27, 0.57, 0.1);<br/>  -webkit-animation: yAxis1 50.5s infinite cubic-bezier(40.7, 0.27, 20.57, 50.64);<br/>}</span><span id="492a" class="lt kn ib lp b fv ly lv l lw lx">div#site1.site1:hover::after {<br/>  background-image:url('trump.png');<br/>  z-index: 2;<br/>  transition-timing-function: cubic-bezier(0.64, 0.57, 0.67, 1.53);<br/>transition-duration: 1s;<br/>  transform: scale(1.2);<br/>  filter: contrast(150%) brightness(140%);<br/>}</span><span id="6f5b" class="lt kn ib lp b fv ly lv l lw lx">div#site1.site1:hover{<br/>  flex-basis:0;<br/>  flex-grow: 2;<br/>}</span><span id="a619" class="lt kn ib lp b fv ly lv l lw lx">@-webkit-keyframes yAxis1 {<br/>  50% {<br/>    z-index: 2;<br/>    -webkit-animation-timing-function: cubic-bezier(200.02, 200.01, 200.21, 400);<br/>    animation-timing-function: cubic-bezier(200.02, 200.01, 200.21, 400);<br/>    -webkit-transform: translateY(80vh);<br/>    transform: translateY(80vh);<br/>  }<br/>}<br/>@-webkit-keyframes xAxis1 {<br/>  50% {<br/>    z-index: 2;<br/>    -webkit-animation-timing-function: cubic-bezier(200.3, 100.27, 400.07, 0.01);<br/>    animation-timing-function: cubic-bezier(200.3, 100.27, 400.07, 0.01);<br/>    -webkit-transform: translateX(80vw);<br/>    transform: translateX(80vw);<br/>  }<br/>}</span></pre><p id="fabe" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">现在，如果你在屏幕上有两个或三个元素，你想以某种随机的方式制作动画，就像我做的那样，编辑这个样板代码很容易做到。x轴和y轴都有“变换:平移”选项。我已经将我的每个元素设置为vh或vw设置。这基本上意味着它们将在回到另一个方向之前在视口中动画到那个点，有点像那些用球在屏幕上反弹的老式屏幕保护程序。每个动画也有时间，以秒为单位。因此，由于这个元素被设置为大约50秒和80vw，这意味着它将在50秒内动画显示大约80%的视口。如果你创建第二个元素，你可以将它调整到90vw和20s，虽然它非常相似，但当相互比较时，动画看起来会非常不同，因为它们以不同的速度移动，并采取稍微不同的路径。请记住，这是我第一次这样做，所以我还在熟悉这一切。以此为起点，您可以添加几个元素，并简单地调整平移和动画计时，以获得动画的几个路径。</p><h1 id="c926" class="km kn ib bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">协调</h1><p id="3ddd" class="pw-post-body-paragraph iz ja ib jb b jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js md ju jv jw hn dt translated">自然地，现在我已经在屏幕上显示了我的元素，我的下一个目标是跟踪它们的坐标。我想用这些坐标作为svg多边形元素的点。在jquery中偶然发现这个绝对的黄金功能之前，我在JavaScript中找到了几种方法。</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="d660" class="lt kn ib lp b fv lu lv l lw lx">getBoundingClientRect();</span></pre><p id="c8e3" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">使用它不仅可以得到屏幕上任何元素的x和y坐标，还可以得到顶部和左侧，以及任何元素的高度和宽度。超级好用！所以我想做的是追踪我的七个元素。可能有更好的方法，但是我想，因为它们一直在运动，我想每隔几毫秒检查一次新的坐标。我发现，如果我将setinterval函数设置为50毫秒，那就有点太不稳定了……任何高于50毫秒的值也是如此。任何低于5的都太强烈了。大约20毫秒对我来说似乎是一个神奇的数字。所以我首先创建了一个setinterval函数，并在其中使用了getBoundingClientRect()；函数，这将每隔20毫秒给我每个元素的坐标。这是它的样子:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="f26f" class="lt kn ib lp b fv lu lv l lw lx">setInterval(function(){</span><span id="ae87" class="lt kn ib lp b fv ly lv l lw lx">let element1 = site1.getBoundingClientRect();</span><span id="7169" class="lt kn ib lp b fv ly lv l lw lx">let element2 = site2.getBoundingClientRect();</span><span id="5303" class="lt kn ib lp b fv ly lv l lw lx">let element3 = site3.getBoundingClientRect();</span><span id="026d" class="lt kn ib lp b fv ly lv l lw lx">let element4 = site4.getBoundingClientRect();</span><span id="d68e" class="lt kn ib lp b fv ly lv l lw lx">let element5 = site5.getBoundingClientRect();</span><span id="1259" class="lt kn ib lp b fv ly lv l lw lx">let element6 = site6.getBoundingClientRect();</span><span id="8675" class="lt kn ib lp b fv ly lv l lw lx">let element7 = site7.getBoundingClientRect();</span></pre><p id="105b" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">现在，我可以控制台日志每个元素，以确保我得到了坐标。接下来的部分会看起来有点疯狂，但请听我说。所以我动态地创建了一个svg元素，每个多边形都在其中，我使用反勾号获取元素坐标，并将它们用作每个多边形的点。通常情况下，应该是这样的:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="8a99" class="lt kn ib lp b fv lu lv l lw lx">points=”${ element1.x,element1.y element2.x,element2.y......</span></pre><p id="9b60" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">诸如此类。但是因为我想在多边形中有一点随机性，所以我改变了它，使得每个坐标对的坐标并不完全匹配。我可能会使用element1.x和element7.y作为坐标对，而不是element1.x和element1.y。</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="df7f" class="lt kn ib lp b fv lu lv l lw lx">let polygon1 = `<br/>      &lt;svg class="polygonContainer" &gt;<br/>&lt;polygon style="stroke:black;stroke-width:${stroke1}" points="${element1.x},${element7.y} ${element2.x},${element6.y} ${element3.x},${element5.y} ${element1.x},${element4.y} ${element2.x},${element5.y} ${element3.x},${element6.y} ${element4.x},${element7.y}" class="white"  id="c"/&gt;</span><span id="3c10" class="lt kn ib lp b fv ly lv l lw lx">&lt;polygon style="stroke:lightgray;stroke-width:${stroke2}" points="${element1.x+5},${element3.y+15} ${element6.x+5},${element3.y+15} ${element7.x+5},${element3.y+15} ${element1.x+5},${element4.y+15} ${element6.x+5},${element5.y+15} ${element5.x+5},${element2.y+15} ${element1.x+5},${element4.y+15}" class="white4"  id="f"/&gt;</span><span id="7712" class="lt kn ib lp b fv ly lv l lw lx">&lt;polygon style="stroke:gray;stroke-width:${stroke3}" points="${element7.x},${element7.y+10} ${element1.x},${element1.y+10} ${element4.x},${element4.y+10} ${element5.x},${element5.y+10} ${element6.x},${element6.y+10} ${element3.x},${element3.y+10} ${element1.x},${element1.y+10}" class="white2"  id="d"/&gt;</span><span id="e667" class="lt kn ib lp b fv ly lv l lw lx">&lt;polygon style="stroke:darkgray;stroke-width:${stroke4}" points="${element3.x},${element1.y+20} ${element3.x},${element4.y+20} ${element7.x},${element2.y+20} ${element3.x},${element6.y+20} ${element4.x},${element5.y+20} ${element4.x},${element1.y+20} ${element2.x},${element5.y+20}" class="white3"  id="e"/&gt;<br/>                  &lt;/svg&gt;<br/>      `</span></pre><p id="bfae" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">你可以从这里看到，我还使用了y+15，y+10和y+20以及x+5作为一些坐标对。这是因为我不想让每个多边形精确地排成一行。让每个坐标偏离10、15或20，给它更多一点随机性，这就是我想要的。您还会注意到，我添加了另一个模板表达式来以内联样式定义笔画。如果你回到这个网站，你会注意到每个多边形的笔画不断变化的厚度。这是因为我把笔画定义为每个元素x坐标的百分比。下面是我如何定义它以在我的多边形内联样式中使用:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="a9b5" class="lt kn ib lp b fv lu lv l lw lx">let stroke1 = element2.x / 75;</span><span id="0463" class="lt kn ib lp b fv ly lv l lw lx">let stroke2 = element4.x / 75;</span><span id="d4d8" class="lt kn ib lp b fv ly lv l lw lx">let stroke3 = element7.x / 75;</span><span id="de8e" class="lt kn ib lp b fv ly lv l lw lx">let stroke4 = element3.x / 75;</span></pre><p id="3ae5" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">出于我的目的，元素坐标除以75给出了我想要的厚度。厚度永远不会变得太厚，也永远不会完全消失。但必要时可以调整。我还为每个stroke变量使用了不同的元素，因此每个多边形的stroke变化会稍有不同。</p><p id="bfd2" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">然后，我包装我的setinterval函数，并写入我的多边形div的innerHTML。这样做的目的是每20毫秒刷新和更新一次DOM，使用基于新坐标的新多边形。这似乎有些过分。但不管怎样。真的只是一个闪屏，所以我不太担心。下面是整段代码的样子:</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="4dd9" class="lt kn ib lp b fv lu lv l lw lx">setInterval(function(){</span><span id="6747" class="lt kn ib lp b fv ly lv l lw lx">let element1 = site1.getBoundingClientRect();</span><span id="8de0" class="lt kn ib lp b fv ly lv l lw lx">let element2 = site2.getBoundingClientRect();</span><span id="4489" class="lt kn ib lp b fv ly lv l lw lx">let element3 = site3.getBoundingClientRect();</span><span id="3343" class="lt kn ib lp b fv ly lv l lw lx">let element4 = site4.getBoundingClientRect();</span><span id="4b02" class="lt kn ib lp b fv ly lv l lw lx">let element5 = site5.getBoundingClientRect();</span><span id="789d" class="lt kn ib lp b fv ly lv l lw lx">let element6 = site6.getBoundingClientRect();</span><span id="3cdc" class="lt kn ib lp b fv ly lv l lw lx">let element7 = site7.getBoundingClientRect();</span><span id="f05d" class="lt kn ib lp b fv ly lv l lw lx">let stroke1 = element2.x / 75;</span><span id="e5c8" class="lt kn ib lp b fv ly lv l lw lx">let stroke2 = element4.x / 75;</span><span id="df13" class="lt kn ib lp b fv ly lv l lw lx">let stroke3 = element7.x / 75;</span><span id="7708" class="lt kn ib lp b fv ly lv l lw lx">let stroke4 = element3.x / 75;</span><span id="7228" class="lt kn ib lp b fv ly lv l lw lx">let polygon1 = `<br/>      &lt;svg class="polygonContainer" &gt;<br/>&lt;polygon style="stroke:black;stroke-width:${stroke1}" points="${element1.x},${element7.y} ${element2.x},${element6.y} ${element3.x},${element5.y} ${element1.x},${element4.y} ${element2.x},${element5.y} ${element3.x},${element6.y} ${element4.x},${element7.y}" class="white"  id="c"/&gt;</span><span id="49e9" class="lt kn ib lp b fv ly lv l lw lx">&lt;polygon style="stroke:lightgray;stroke-width:${stroke2}" points="${element1.x+5},${element3.y+15} ${element6.x+5},${element3.y+15} ${element7.x+5},${element3.y+15} ${element1.x+5},${element4.y+15} ${element6.x+5},${element5.y+15} ${element5.x+5},${element2.y+15} ${element1.x+5},${element4.y+15}" class="white4"  id="f"/&gt;</span><span id="383d" class="lt kn ib lp b fv ly lv l lw lx">&lt;polygon style="stroke:gray;stroke-width:${stroke3}" points="${element7.x},${element7.y+10} ${element1.x},${element1.y+10} ${element4.x},${element4.y+10} ${element5.x},${element5.y+10} ${element6.x},${element6.y+10} ${element3.x},${element3.y+10} ${element1.x},${element1.y+10}" class="white2"  id="d"/&gt;</span><span id="ab2c" class="lt kn ib lp b fv ly lv l lw lx">&lt;polygon style="stroke:darkgray;stroke-width:${stroke4}" points="${element3.x},${element1.y+20} ${element3.x},${element4.y+20} ${element7.x},${element2.y+20} ${element3.x},${element6.y+20} ${element4.x},${element5.y+20} ${element4.x},${element1.y+20} ${element2.x},${element5.y+20}" class="white3"  id="e"/&gt;<br/>                  &lt;/svg&gt;<br/>      `<br/>      document.getElementById('polygon').innerHTML = polygon1;<br/>    }, 20);</span></pre><p id="7f87" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">最后一步是返回CSS，为每个多边形定义一些我不想在内联样式中做的样式。最初，我对每个多边形进行了轻微的填充，这是一个很酷的效果，但由于浏览器试图每20毫秒刷新一次，因此大大降低了浏览器的速度。</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="a297" class="lt kn ib lp b fv lu lv l lw lx">polygon#c.white {<br/>  width: 100vw;<br/>  height: 100vh;<br/>  fill: transparent;<br/>  overflow: visible;<br/>  background-color: transparent;<br/>}</span><span id="7925" class="lt kn ib lp b fv ly lv l lw lx">polygon#d.white2 {<br/>  width: 100vw;<br/>  height: 100vh;<br/>  fill: transparent;<br/>  overflow: visible;<br/>  background-color: transparent;<br/>}</span><span id="a47f" class="lt kn ib lp b fv ly lv l lw lx">polygon#e.white3 {<br/>  width: 100vw;<br/>  height: 100vh;<br/>  fill: transparent;<br/>  overflow: visible;<br/>  background-color: transparent;<br/>}</span><span id="7ab6" class="lt kn ib lp b fv ly lv l lw lx">polygon#f.white4 {<br/>  width: 100vw;<br/>  height: 100vh;<br/>  fill: transparent;<br/>  overflow: visible;<br/>  background-color: transparent;<br/>}</span></pre><p id="0abc" class="pw-post-body-paragraph iz ja ib jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hn dt translated">每个链接都是可点击的，并转到每个项目的简介，以及每个项目的github，等等。这只是我在Node.js中设置的后端数据库，用来加载onclick中的每个文件。但那部分远没那么有趣，我就不深究了。如果你有任何问题或建议，我很乐意倾听。谢谢！</p></div></div>    
</body>
</html>