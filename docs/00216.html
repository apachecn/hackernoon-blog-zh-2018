<html>
<head>
<title>Easy OS Background Tasks in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中简单的操作系统后台任务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/easy-os-background-tasks-in-react-native-bc4476c48b8a?source=collection_archive---------0-----------------------#2018-01-08">https://medium.com/hackernoon/easy-os-background-tasks-in-react-native-bc4476c48b8a?source=collection_archive---------0-----------------------#2018-01-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/08319a3b9337208460c0f01bfdc50b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhzPso35nlhFMRIt8VCb7g.png"/></div></div></figure><div class=""/><p id="f608" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">多亏了几个相对较新的库，当你的react原生应用关闭时，在后台线程(也称为服务)中运行任务变得前所未有的简单。</p><p id="0880" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今天，我将带您完成设置任务的过程，这些任务会定期运行，即使您的应用程序已关闭。如果您已经有了React本机设置，并且现在正盯着您的IDE，那么您只需要大约15分钟就可以完全启动并运行这个完整的示例。</p><p id="3f9e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">我们将使用两个库来完成这个任务:</strong></p><ul class=""><li id="03db" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated"><a class="ae kj" href="https://github.com/billmalarky/react-native-queue" rel="noopener ugc nofollow" target="_blank"> React Native Queue </a>:控制流程和作业管理。</li><li id="e5f3" class="ka kb if je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><a class="ae kj" href="https://github.com/jamesisaac/react-native-background-task" rel="noopener ugc nofollow" target="_blank"> React原生后台任务</a>:注册关闭app时将执行的js处理函数。</li></ul><p id="b218" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">在我们的示例中，我们将进行基本的图像预取(是的是的，这有点无意义，但出于说明的目的，这很容易理解)。</strong></p><p id="0924" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">该功能更现实的用例示例:</strong></p><ul class=""><li id="e109" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">下载内容以供脱机访问。</li><li id="b4d9" class="ka kb if je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">媒体处理。</li><li id="26b5" class="ka kb if je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">缓存预热。</li><li id="02c5" class="ka kb if je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><em class="kp">对外部服务的持久</em> API调用，例如向各种第三方发布渠道API发布内容。</li><li id="a3a3" class="ka kb if je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">无论应用程序是打开、关闭还是反复打开和关闭，您都希望始终如一地处理复杂且耗时的作业。</li></ul><h1 id="66f0" class="kq kr if bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">装置</h1><p id="a5c1" class="pw-post-body-paragraph jc jd if je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">首先在您的工作目录中创建React本地应用程序的框架</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="06ca" class="mc kr if ly b fv md me l mf mg">$ react-native init backgroundexample</span></pre><p id="29c8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">快速安装<a class="ae kj" href="https://github.com/billmalarky/react-native-queue#installation" rel="noopener ugc nofollow" target="_blank"> react-native-queue </a>和<a class="ae kj" href="https://github.com/jamesisaac/react-native-background-task#installation" rel="noopener ugc nofollow" target="_blank">react-native-background-task</a>包并链接(注意react-native-background-fetch是iOS支持所需的react-native-background-task的可选依赖项)。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="5e25" class="mc kr if ly b fv md me l mf mg">$ yarn add react-native-queue<br/>$ react-native link realm<br/>$ yarn add react-native-background-task<br/>$ react-native link react-native-background-task<br/>$ yarn add react-native-background-fetch@2.0.x<br/>$ react-native link react-native-background-fetch</span></pre><p id="00cd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">手动更新MainApplication.java的onCreate()方法，如下所示</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="c1dc" class="mc kr if ly b fv md me l mf mg">// Update the following file as seen below<br/>// android/app/src/main/java/com/backgroundexample/MainApplication.java</span><span id="7370" class="mc kr if ly b fv mh me l mf mg">@Override<br/>public void onCreate() {<br/>  super.onCreate();<br/>  SoLoader.init(this, /* native exopackage */ false);<br/>  BackgroundTaskPackage.useContext(this); // ADD ME HERE!<br/>}</span></pre><h1 id="8ab5" class="kq kr if bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">构建特征</h1><p id="dc9a" class="pw-post-body-paragraph jc jd if je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">首先，让我们更新react原生骨架应用程序，以包含一个通过按钮切换的图像屏幕。没什么特别的。</p><h2 id="500e" class="mc kr if bd ks mi mj mk kw ml mm mn la jn mo mp le jr mq mr li jv ms mt lm mu dt translated">切换屏幕App.js更改</h2><p id="2b04" class="pw-post-body-paragraph jc jd if je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">这里没什么特别的。只需添加ScrollView，Button，Image导入，修改容器样式，添加图片样式，对skeleton App类做一些小的更新。</p><figure class="lt lu lv lw fq hw"><div class="bz el l di"><div class="mv mw l"/></div></figure><h2 id="b09b" class="mc kr if bd ks mi mj mk kw ml mm mn la jn mo mp le jr mq mr li jv ms mt lm mu dt translated">集成后台任务</h2><p id="b007" class="pw-post-body-paragraph jc jd if je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated"><strong class="je ig">在App.js的顶部，我们将定义我们希望操作系统在应用关闭时在后台定期调用的js函数(“后台任务”)。</strong></p><p id="b617" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们希望在这个后台任务函数中发生的事情是初始化队列，并在达到iOS强制的30秒超时(Android没有这个超时限制，但我们需要遵守跨平台支持的最严格约束)之前，立即开始从队列中取出作业并处理尽可能多的作业。<strong class="je ig">由于这个硬性超时限制，我们将调用queue . start(lifetime)的寿命为25秒</strong>。这样，队列将最多在25秒内开始处理作业(或者直到队列被清空)，然后停止处理，保证我们有时间在操作系统超时之前调用所需的Background.finish()。</p><p id="6e8c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的例子中，25秒足够处理整个队列，因为我们只预取3张图片。然而，想象一下，如果我们预取10，000张图像。<strong class="je ig">队列保持作业的持久性</strong>(作业完成后才会被删除，失败后可以自动重试)，所以每隔15分钟左右，当操作系统在后台再次启动该功能时，就会预取另一批图像，迟早所有的图像都会在后台被预取。</p><figure class="lt lu lv lw fq hw"><div class="bz el l di"><div class="mv mw l"/></div></figure><p id="fdb3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后将componentDidMount()生命周期方法添加到应用程序组件，以便在应用程序挂载时调度后台任务。</p><figure class="lt lu lv lw fq hw"><div class="bz el l di"><div class="mv mw l"/></div></figure><p id="6287" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的App.js文件现在应该看起来像这样:</p><figure class="lt lu lv lw fq hw"><div class="bz el l di"><div class="mv mw l"/></div></figure><h2 id="2a7b" class="mc kr if bd ks mi mj mk kw ml mm mn la jn mo mp le jr mq mr li jv ms mt lm mu dt translated">添加队列作业</h2><p id="5b40" class="pw-post-body-paragraph jc jd if je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">现在我们已经设置了后台任务来初始化队列，并在应用程序关闭时处理作业，我们需要一种方法来向队列添加作业！</p><p id="0222" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们将初始化应用程序中的队列，以便我们可以使用它来创建工作。</p><p id="614b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">参考下面第41–54行的最终App.js文件，对构造函数()进行必要的更新，以初始化应用程序中的队列。</p><p id="56e8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">初始化队列后，创建createPrefetchJobs()类方法，如下面第60–86行所示。在这个方法中，我们将引用存储在app组件状态中的队列实例来创建3个作业，这些作业预取图像并将其放入队列中。注意，我们将false作为最后一个参数传递给createJob()，这将阻止队列立即启动处理(这是默认行为)。在本例中，我们不希望队列在主应用程序线程中处理，所以我们将只在后台任务中调用queue.start()。</p><p id="06b2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后但同样重要的是，更新第92行中的render()以添加“Pre-fetch Images”按钮，并将其连接到我们之前创建的createPrefetchJobs()方法。</p><figure class="lt lu lv lw fq hw"><div class="bz el l di"><div class="mv mw l"/></div></figure><h2 id="2a95" class="mc kr if bd ks mi mj mk kw ml mm mn la jn mo mp le jr mq mr li jv ms mt lm mu dt translated">你完了！</h2><p id="c64e" class="pw-post-body-paragraph jc jd if je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">现在在一个真实的设备上启动你的react本地应用<strong class="je ig">(后台任务不会在模拟器中启动)</strong>。应用程序启动后，单击预取按钮将作业排队。</p><p id="4a6d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在剩下的就是分散应用程序的注意力，然后等待。如果应用程序处于焦点状态，操作系统后台任务将不会触发(这可能有点违背要点)。大约15分钟后，操作系统将启动后台任务，初始化队列，并通过您的3个预取作业启动队列。</p><p id="d2da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，您的远程图像已经预存在手机的本地磁盘中，当您单击“切换屏幕”查看图像时，它们将从您的本地磁盘而不是网络中提取。</p><h2 id="2240" class="mc kr if bd ks mi mj mk kw ml mm mn la jn mo mp le jr mq mr li jv ms mt lm mu dt translated">有问题吗？故障排除。</h2><p id="b62a" class="pw-post-body-paragraph jc jd if je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">如果你有任何问题，或者有任何疑问，欢迎发表评论，我可以直接帮助你。</p></div></div>    
</body>
</html>