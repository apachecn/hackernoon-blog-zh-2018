<html>
<head>
<title>The constructor is dead, long live the constructor!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构造者已死，构造者万岁！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-constructor-is-dead-long-live-the-constructor-c10871bea599?source=collection_archive---------1-----------------------#2018-01-08">https://medium.com/hackernoon/the-constructor-is-dead-long-live-the-constructor-c10871bea599?source=collection_archive---------1-----------------------#2018-01-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2e5d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">告别React组件中的中世纪类构造函数。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/92af751dfd834baee638ef5ba1b58ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKQ1VZhf-b7We4YN78xWlA.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/photos/VLioQ2c-VwE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Samuel Zeller</a> on <a class="ae jz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5be6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">虽然无状态功能组件(sfc)是您的武器库中的一个便利工具，但是<a class="ae jz" href="https://hackernoon.com/tagged/es6" rel="noopener ugc nofollow" target="_blank"> ES6 </a>类组件仍然是编写利用状态或生命周期挂钩的React组件的事实上的方法。</p><p id="a542" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">一个假设的ES6类组件可能看起来像这样(当然，没有错误检查，过于简化)。</p><pre class="jk jl jm jn fq kw kx ky kz aw la dt"><span id="5baa" class="lb lc hu kx b fv ld le l lf lg">class Foo extends Component {<br/>  constructor(props) {<br/>    super(props); <br/>    this.state = { loading: true };<br/>  }</span><span id="11ee" class="lb lc hu kx b fv lh le l lf lg">  async componentDidMount() {<br/>    const data = await loadStuff();<br/>    this.setState({ loading: false, data });<br/>  }</span><span id="f2eb" class="lb lc hu kx b fv lh le l lf lg">  render() {<br/>    const { loading, data } = this.state;<br/>    return (<br/>      {loading ? &lt;Loading /&gt; : &lt;View {...data} /&gt;}<br/>    );<br/>  }<br/>}</span></pre><p id="87c3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们在<code class="eh li lj lk kx b">constructor</code>中初始化我们的<code class="eh li lj lk kx b">state</code>，在<code class="eh li lj lk kx b">componentDidMount</code>中异步加载我们的数据，并基于<code class="eh li lj lk kx b">loading</code>状态呈现我们的<code class="eh li lj lk kx b">View</code>组件。一个非常标准的模式——至少对我来说是这样，如果你一直关注我的工作的话。</p><h1 id="1ae8" class="ll lc hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">类别属性</h1><p id="c83e" class="pw-post-body-paragraph ka kb hu kc b kd mc iv kf kg md iy ki kj me kl km kn mf kp kq kr mg kt ku kv hn dt translated">我们都知道<code class="eh li lj lk kx b">constructor</code>是我们初始化实例属性的地方，在本例中是<code class="eh li lj lk kx b">state</code>。如果你对自己说，“没错！”，那么你将是绝对正确的…如果不是因为即将到来的ES.next <a class="ae jz" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">类属性提案</a>，目前处于第3阶段。</p><p id="70e3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">有了它，我们现在可以直接定义类属性，就像这样。</p><pre class="jk jl jm jn fq kw kx ky kz aw la dt"><span id="dc47" class="lb lc hu kx b fv ld le l lf lg">class Foo extends Component {<br/>  state = { loading: true };<br/>  ...<br/>}</span></pre><p id="34e9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><a class="ae jz" href="https://hackernoon.com/tagged/babel" rel="noopener ugc nofollow" target="_blank"> Babel </a>会把你的代码转存过来，在幕后给你加一个<code class="eh li lj lk kx b">constructor</code>。这是我们编译上面的代码片段时Babel的输出。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/3d05321e021587d9d0ba686c657043d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*IK4vl_NlOIdCDlFYyizEeQ.png"/></div></figure><p id="83b3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">注意，Babel实际上传递了所有的参数——不仅仅是<code class="eh li lj lk kx b">props</code>——直到<code class="eh li lj lk kx b">super</code>。它还接受<code class="eh li lj lk kx b">super</code>的返回值并将其传递回调用者。这两者可能都有点矫枉过正，但这正是它应该做的。</p><blockquote class="mi"><p id="57ec" class="mj mk hu bd ml mm mn mo mp mq mr kv ek translated">构造函数还是有的，只是你没看到而已。</p></blockquote><h1 id="6725" class="ll lc hu bd lm ln lo lp lq lr ls lt lu ja ms jb lw jd mt je ly jg mu jh ma mb dt translated">绑定方法</h1><p id="a520" class="pw-post-body-paragraph ka kb hu kc b kd mc iv kf kg md iy ki kj me kl km kn mf kp kq kr mg kt ku kv hn dt translated">我们被教导使用<code class="eh li lj lk kx b">constructor</code>的另一个原因是为了将方法绑定到<code class="eh li lj lk kx b">this</code>，就像这样。</p><pre class="jk jl jm jn fq kw kx ky kz aw la dt"><span id="c70b" class="lb lc hu kx b fv ld le l lf lg">class Foo extends Component {<br/>  constructor(props) {<br/>    super(props); <br/>    this.myHandler = this.myHandler.bind(this);<br/>  }</span><span id="d261" class="lb lc hu kx b fv lh le l lf lg">  myHandler() {<br/>    // some code here that references this<br/>  }<br/>  ...<br/>}</span></pre><p id="a704" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">有些人通过给一个类属性分配一个函数表达式来忽略这一点，但这完全是另一回事。在我的其他ES6 React类文章<a class="ae jz" rel="noopener" href="/@donavon/demystifying-memory-usage-using-es6-react-classes-d9d904bc4557"> <strong class="kc hv">中阅读更多关于使用ES6 React类</strong> </a>揭秘内存使用的信息。</p><div class="mv mw fm fo mx my"><a rel="noopener follow" target="_blank" href="/@donavon/demystifying-memory-usage-using-es6-react-classes-d9d904bc4557"><div class="mz ab ej"><div class="na ab nb cl cj nc"><h2 class="bd hv fv z el nd eo ep ne er et ht dt translated">使用ES6 React类揭示内存使用</h2><div class="nf l"><h3 class="bd b fv z el nd eo ep ne er et ek translated">哪个效率更高？在构造函数中绑定，还是使用箭头函数作为类属性？</h3></div><div class="ng l"><p class="bd b gc z el nd eo ep ne er et ek translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jt my"/></div></div></a></div><p id="bfd8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们暂时假设你属于<code class="eh li lj lk kx b">bind</code>阵营(即使你不是，请原谅我)。我们需要绑定<code class="eh li lj lk kx b">constructor</code>，对吗？不一定。我们可以对上面的类属性做同样的事情。</p><pre class="jk jl jm jn fq kw kx ky kz aw la dt"><span id="1273" class="lb lc hu kx b fv ld le l lf lg">class Foo extends Component {<br/>  myHandler = this.myHandler.bind(this);</span><span id="7608" class="lb lc hu kx b fv lh le l lf lg">  myHandler() {<br/>    // some code here that references this<br/>  }<br/>  ...<br/>}</span></pre><h1 id="7597" class="ll lc hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">用道具初始化状态</h1><p id="86fb" class="pw-post-body-paragraph ka kb hu kc b kd mc iv kf kg md iy ki kj me kl km kn mf kp kq kr mg kt ku kv hn dt translated">当你需要从<code class="eh li lj lk kx b">props</code>中得到你的初始<code class="eh li lj lk kx b">state</code>时，比如说初始化一个默认值，该怎么办？我们肯定需要<code class="eh li lj lk kx b">constructor</code>来做这件事吧？</p><pre class="jk jl jm jn fq kw kx ky kz aw la dt"><span id="485c" class="lb lc hu kx b fv ld le l lf lg">class Foo extends Component {<br/>  constructor(props) {<br/>    super(props); <br/>    this.state = {<br/>      color: this.props.initialColor<br/>    };<br/>  }</span><span id="7b4a" class="lb lc hu kx b fv lh le l lf lg">  render() {<br/>    const { color } = this.state;<br/>    return (<br/>      &lt;div&gt;<br/>       {color}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="23e8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">没有。再次，阶级属性来拯救！我们可以访问<code class="eh li lj lk kx b">this</code>和<code class="eh li lj lk kx b">props</code>。</p><pre class="jk jl jm jn fq kw kx ky kz aw la dt"><span id="ec67" class="lb lc hu kx b fv ld le l lf lg">class Foo extends Component {<br/>  state = {<br/>    color: this.props.initialColor<br/>  };<br/>  ...<br/>}</span></pre><h1 id="a632" class="ll lc hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">数据提取</h1><p id="4e26" class="pw-post-body-paragraph ka kb hu kc b kd mc iv kf kg md iy ki kj me kl km kn mf kp kq kr mg kt ku kv hn dt translated">也许我们需要一个<code class="eh li lj lk kx b">constructor</code>来获取数据？几乎没有。正如我们在第一个代码示例中看到的，任何数据加载都应该在<code class="eh li lj lk kx b">componentDidMount</code>中完成。但是为什么是<code class="eh li lj lk kx b">componentDidMount</code>？我们这样做是为了在服务器上运行组件时不执行获取操作——就像在进行服务器端渲染(SSR)时一样——因为<code class="eh li lj lk kx b">componentDidMount</code>不是<em class="nn">在服务器端执行的。</em></p><h1 id="8a85" class="ll lc hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">结论</h1><p id="4f69" class="pw-post-body-paragraph ka kb hu kc b kd mc iv kf kg md iy ki kj me kl km kn mf kp kq kr mg kt ku kv hn dt translated">我们已经看到，为了设置我们的初始<code class="eh li lj lk kx b">state</code>，我们不再需要一个<code class="eh li lj lk kx b">constructor</code>(或者任何其他实例属性)。我们也不需要它来绑定方法到<code class="eh li lj lk kx b">this</code>。从<code class="eh li lj lk kx b">props</code>开始设置初始<code class="eh li lj lk kx b">state</code>也是如此。我们绝对不会在<code class="eh li lj lk kx b">constructor</code>中获取数据。</p><p id="2f0f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">那么为什么我们需要React组件中的<code class="eh li lj lk kx b">constructor</code>?</p><p id="46a3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">嗯……你不知道。</p><p id="f0a7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="nn">【然而，如果你发现一些模糊的用例，你需要在客户端和服务器端的组件中初始化一些东西，你仍然有一个out。总有</em> <code class="eh li lj lk kx b"><em class="nn">componentWillMount</em></code> <em class="nn">。在内部，React在客户端和服务器端“新建”类(调用</em> <code class="eh li lj lk kx b"><em class="nn">constructor</em></code> <em class="nn">)之后立即调用这个钩子。】</em></p><p id="4652" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">所以我认为对于React组件:构造函数死了，构造函数万岁！</p><h1 id="b77a" class="ll lc hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">进一步阅读</h1><p id="927f" class="pw-post-body-paragraph ka kb hu kc b kd mc iv kf kg md iy ki kj me kl km kn mf kp kq kr mg kt ku kv hn dt translated">嗯，不是阅读，但是<a class="no np gr" href="https://medium.com/u/db72389e89d8?source=post_page-----c10871bea599--------------------------------" rel="noopener" target="_blank"> Kent C. Dodds </a>有一个关于类属性的<a class="ae jz" href="https://egghead.io/lessons/egghead-use-class-components-with-react" rel="noopener ugc nofollow" target="_blank">不错的视频教程</a>，你可能想读，嗯…看。</p><p id="bfd4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">你也可以在AmericanExpress.io技术博客上阅读一堆基于React的文章(包括React 16.7中的一些关于钩子的文章，{…❤️}传播爱，以及React最佳实践)。</p></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><p id="81cc" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="nn">我也为美国运通工程博客写稿。在</em><a class="ae jz" href="http://americanexpress.io/" rel="noopener ugc nofollow" target="_blank"><em class="nn">American express . io</em></a><em class="nn">查看我的其他作品和我才华横溢的同事的作品。也可以</em> <a class="ae jz" href="https://twitter.com/donavon" rel="noopener ugc nofollow" target="_blank"> <em class="nn">在Twitter上关注我</em> </a> <em class="nn">。</em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nx ny l"/></div></figure></div></div>    
</body>
</html>