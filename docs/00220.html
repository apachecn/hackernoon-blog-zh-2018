<html>
<head>
<title>How to implement Generic Queries by combining EntityFramework Core and GraphQL.NET?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何结合EntityFramework Core和GraphQL实现泛型查询？网？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-implement-generic-queries-by-combining-entityframework-core-and-graphql-net-77ac8faf4a22?source=collection_archive---------4-----------------------#2018-01-08">https://medium.com/hackernoon/how-to-implement-generic-queries-by-combining-entityframework-core-and-graphql-net-77ac8faf4a22?source=collection_archive---------4-----------------------#2018-01-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8c18f21c25bb083ed295e84ec517fd57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vj5WjMDX78oNRqSGrWzeyg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://pixabay.com/en/graph-success-cooperation-together-1019845/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="df91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">目前，我一直在努力解决这样的问题，比如我必须对我的数据模型中的任何实体执行多次查询。我认为，如果我们可以将所有实体暴露给API，或者可以限制一些敏感的实体，其他方面或组件随后只需查询它(就像一个通用查询，以避免样板代码，当我们为系统中的所有实体反复实现查询功能时)。</p><p id="468c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我花了很长时间深入研究了<a class="ae jg" href="https://github.com/OData/WebApi" rel="noopener ugc nofollow" target="_blank"> OData </a>项目(实际上是解析器组件)，但结果并不令人满意。可能是因为它太复杂了，很多模式需要预先定义。此外，它仅由使用。NET生态系统(例如，<a class="ae jg" href="https://msdn.microsoft.com/en-us/library/gg334767%28v=crm.8%29.aspx?f=255&amp;MSPPError=-2147217396" rel="noopener ugc nofollow" target="_blank">微软动态CRM </a>，<a class="ae jg" href="https://docs.microsoft.com/en-us/sharepoint/dev/sp-add-ins/use-odata-query-operations-in-sharepoint-rest-requests" rel="noopener ugc nofollow" target="_blank">微软Sharepoint</a>……)。</p><p id="f960" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我真的想要一个能够很好地工作、适应和使用其他生态系统或组件(如前端、移动或物联网设备)的解决方案。这就是我选择脸书的GraphQL的原因。我想我不需要解释为什么这些时候会这么酷。关于它的更多信息，我强烈推荐你阅读这篇文章<a class="ae jg" href="https://dev-blog.apollodata.com/2017-the-year-in-graphql-124a050d04c6" rel="noopener ugc nofollow" target="_blank">2017:graph QL</a>中的一年。</p><p id="950a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文中，我将向您展示我的POC项目，该项目试图将<a class="ae jg" href="https://github.com/aspnet/EntityFrameworkCore" rel="noopener ugc nofollow" target="_blank">实体框架核心</a>和<a class="ae jg" href="https://github.com/graphql-dotnet/graphql-dotnet" rel="noopener ugc nofollow" target="_blank">GraphQL.NET</a>结合起来，然后我们可以使用它在前端提交<a class="ae jg" href="http://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank"> gql DSL语言</a>并通过后端查询您数据库中的每个实体。</p><p id="90e9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">谢谢你，<a class="kf kg gr" href="https://medium.com/u/282dc6f79eac?source=post_page-----77ac8faf4a22--------------------------------" rel="noopener" target="_blank">乔·麦克布莱德</a>和<a class="kf kg gr" href="https://medium.com/u/6a0d6cd86d0?source=post_page-----77ac8faf4a22--------------------------------" rel="noopener" target="_blank">斯特夫·海恩拉斯</a>的伟大图书馆(y)</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="120b" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">先决条件</h1><ul class=""><li id="1a73" class="lm ln hu jj b jk lo jo lp js lq jw lr ka ls ke lt lu lv lw dt translated"><a class="ae jg" href="https://www.microsoft.com/net/download" rel="noopener ugc nofollow" target="_blank">。网芯2.0 SDK </a></li><li id="6700" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://docs.microsoft.com/en-us/ef/core/" rel="noopener ugc nofollow" target="_blank">实体框架核心2.x </a></li><li id="b4cd" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">GraphQL.NET图书馆<a class="ae jg" href="https://graphql-dotnet.github.io/getting-started/" rel="noopener ugc nofollow" target="_blank"/></li><li id="7fad" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://github.com/StefH/System.Linq.Dynamic.Core" rel="noopener ugc nofollow" target="_blank">系统。Linq.Dynamic.Core </a>库</li><li id="db72" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a></li><li id="ad06" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://www.visualstudio.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Visual Studio 2017 </a></li></ul><h1 id="0c8c" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">数据库模式</h1><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/5df568c2e0d3d3f594f4cecdca46fc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*lkfUWDz9_J1ZJZuAoADXWg.png"/></div></figure><h1 id="1984" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">图形模式模型</h1><p id="52ba" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">我们将数据库中的列(数据库中表的元数据)模型定义如下</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="5c2b" class="mu kp hu mq b fv mv mw l mx my">public class ColumnMetadata<br/>{<br/>    public string ColumnName { get; set }<br/>    public string DataType { get; set; }<br/>}</span></pre><p id="5c5d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们对下表做同样的事情</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="671a" class="mu kp hu mq b fv mv mw l mx my">public class TableMetadata<br/>{<br/>    public string TableName { get; set; }<br/>    public string AssemblyFullName { get; set; }<br/>    public IEnumerable&lt;ColumnMetadata&gt; Columns { get; set; }<br/>}</span></pre><p id="f94d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我们已经为数据库中的每个表附加了前缀(例如dbo.crm_Tasks ),所以我们需要一个映射表来帮助我们解析实体的友好名称(例如当我们在UI中提交查询时的任务)</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="ee59" class="mu kp hu mq b fv mv mw l mx my">public interface ITableNameLookup<br/>{<br/>    bool InsertKeyName(string friendlyName);<br/>    string GetFriendlyName(string correctName);<br/>}</span><span id="c797" class="mu kp hu mq b fv mz mw l mx my">public class TableNameLookup : ITableNameLookup<br/>{<br/>    private IDictionary&lt;string, string&gt; _lookupTable = new Dictionary&lt;string, string&gt;();</span><span id="03a4" class="mu kp hu mq b fv mz mw l mx my">    public bool InsertKeyName(string correctName)<br/>    {<br/>        if(!_lookupTable.ContainsKey(correctName))<br/>        {<br/>            var friendlyName = CanonicalName(correctName);<br/>            _lookupTable.Add(correctName, friendlyName);<br/>            return true;<br/>        }<br/>        return false;<br/>    }</span><span id="d1e1" class="mu kp hu mq b fv mz mw l mx my">    public string GetFriendlyName(string correctName)<br/>    {<br/>        if (!_lookupTable.TryGetValue(correctName, out string value))<br/>            throw new Exception($"Could not get {correctName} out of the list.");<br/>        return value;<br/>    }</span><span id="70e3" class="mu kp hu mq b fv mz mw l mx my">    private string CanonicalName(string correctName)<br/>    {<br/>        var index = correctName.LastIndexOf("_");</span><span id="faaa" class="mu kp hu mq b fv mz mw l mx my">        var result = correctName.Substring(<br/>                index + 1,<br/>                correctName.Length - index - 1);</span><span id="ec98" class="mu kp hu mq b fv mz mw l mx my">        return Char.ToLowerInvariant(result[0]) + result.Substring(1);<br/>    }<br/>}</span></pre><p id="13a8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在是将所有模式模型放入数据库元数据的时候了，如下所示</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="b5be" class="mu kp hu mq b fv mv mw l mx my">public interface IDatabaseMetadata<br/>{<br/>    void ReloadMetadata();<br/>    IEnumerable&lt;TableMetadata&gt; GetTableMetadatas();<br/>}</span><span id="8bd2" class="mu kp hu mq b fv mz mw l mx my">public sealed class DatabaseMetadata : IDatabaseMetadata<br/>{<br/>    private readonly DbContext _dbContext;<br/>    private readonly ITableNameLookup _tableNameLookup;</span><span id="8567" class="mu kp hu mq b fv mz mw l mx my">    private string _databaseName;<br/>    private IEnumerable&lt;TableMetadata&gt; _tables;</span><span id="3a71" class="mu kp hu mq b fv mz mw l mx my">    public DatabaseMetadata(DbContext dbContext, ITableNameLookup tableNameLookup)<br/>    {<br/>        _dbContext = dbContext;<br/>        _tableNameLookup = tableNameLookup;</span><span id="d368" class="mu kp hu mq b fv mz mw l mx my">        _databaseName = _dbContext.Database.GetDbConnection().Database;</span><span id="0ee7" class="mu kp hu mq b fv mz mw l mx my">        if (_tables == null)<br/>            ReloadMetadata();<br/>    }</span><span id="00b2" class="mu kp hu mq b fv mz mw l mx my">    public IEnumerable&lt;TableMetadata&gt; GetTableMetadatas()<br/>    {<br/>        if (_tables == null)<br/>            return new List&lt;TableMetadata&gt;();</span><span id="5b48" class="mu kp hu mq b fv mz mw l mx my">        return _tables;<br/>    }</span><span id="6cbe" class="mu kp hu mq b fv mz mw l mx my">    public void ReloadMetadata()<br/>    {<br/>        _tables = FetchTableMetaData();<br/>    }</span><span id="33a1" class="mu kp hu mq b fv mz mw l mx my">    private IReadOnlyList&lt;TableMetadata&gt; FetchTableMetaData()<br/>    {<br/>        var metaTables = new List&lt;TableMetadata&gt;();</span><span id="e868" class="mu kp hu mq b fv mz mw l mx my">        foreach (var entityType in <strong class="mq hv">_dbContext.Model.GetEntityTypes()</strong>)<br/>        {<br/>            var tableName = <strong class="mq hv">entityType.Relational().TableName</strong>;</span><span id="7f74" class="mu kp hu mq b fv mz mw l mx my">            metaTables.Add(new TableMetadata<br/>            {<br/>                TableName = tableName,<br/>                AssemblyFullName = <strong class="mq hv">entityType.ClrType.FullName</strong>,<br/>                Columns = GetColumnsMetadata(entityType)<br/>            });</span><span id="9946" class="mu kp hu mq b fv mz mw l mx my">            _tableNameLookup.InsertKeyName(tableName);<br/>        }<br/>            <br/>        return metaTables;<br/>    }</span><span id="a530" class="mu kp hu mq b fv mz mw l mx my">    private IReadOnlyList&lt;ColumnMetadata&gt; GetColumnsMetadata(IEntityType entityType)<br/>    {<br/>        var tableColumns = new List&lt;ColumnMetadata&gt;();</span><span id="55b5" class="mu kp hu mq b fv mz mw l mx my">        foreach (var propertyType in entityType.GetProperties())<br/>        {<br/>            var relational = propertyType.Relational();<br/>            tableColumns.Add(new ColumnMetadata<br/>            {<br/>                ColumnName = relational.ColumnName,<br/>                DataType = relational.ColumnType<br/>            });<br/>        }</span><span id="6e92" class="mu kp hu mq b fv mz mw l mx my">        return tableColumns;<br/>    }<br/>}</span></pre><p id="2ff0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在代码上有模式模型，当应用程序启动时，这些模式模型将填充EfCore实体的所有模式信息。</p><h1 id="bcbd" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">图类型</h1><p id="42a6" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">让我们定义图表的类型如下</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="cd7b" class="mu kp hu mq b fv mv mw l mx my">public class TableType : ObjectGraphType&lt;object&gt;<br/>{<br/>    public QueryArguments TableArgs<br/>    {<br/>        get; set;<br/>    }</span><span id="6c46" class="mu kp hu mq b fv mz mw l mx my">    private IDictionary&lt;string, Type&gt; _databaseTypeToSystemType;<br/>    protected IDictionary&lt;string, Type&gt; DatabaseTypeToSystemType<br/>    {<br/>        get<br/>        {<br/>            if (_databaseTypeToSystemType == null)<br/>            {<br/>                _databaseTypeToSystemType = new Dictionary&lt;string, Type&gt; {<br/>                    { "uniqueidentifier", typeof(String) },<br/>                    { "char", typeof(String) },<br/>                    { "nvarchar", typeof(String) },<br/>                    { "int", typeof(int) },<br/>                    { "decimal", typeof(decimal) },<br/>                    { "bit", typeof(bool) }<br/>                };<br/>            }<br/>            return _databaseTypeToSystemType;<br/>        }<br/>    }</span><span id="57e6" class="mu kp hu mq b fv mz mw l mx my">    public TableType(TableMetadata tableMetadata)<br/>    {<br/>        Name = tableMetadata.TableName;<br/>        foreach (var tableColumn in tableMetadata.Columns)<br/>        {<br/>            InitGraphTableColumn(tableColumn);<br/>        }<br/>    }</span><span id="a157" class="mu kp hu mq b fv mz mw l mx my">    private void InitGraphTableColumn(ColumnMetadata columnMetadata)<br/>    {<br/>        var graphQLType = (ResolveColumnMetaType(columnMetadata.DataType)).GetGraphTypeFromType(true);<br/>        var columnField = Field(<br/>            graphQLType,<br/>            columnMetadata.ColumnName<br/>        );</span><span id="8b0e" class="mu kp hu mq b fv mz mw l mx my">        columnField.Resolver = new NameFieldResolver();<br/>        FillArgs(columnMetadata.ColumnName);<br/>    }</span><span id="333b" class="mu kp hu mq b fv mz mw l mx my">    private void FillArgs(string columnName)<br/>    {<br/>        if (TableArgs == null)<br/>        {<br/>            TableArgs = new QueryArguments(<br/>                new QueryArgument&lt;StringGraphType&gt;()<br/>                {<br/>                    Name = columnName<br/>                }<br/>            );<br/>        }<br/>        else<br/>        {<br/>            TableArgs.Add(new QueryArgument&lt;StringGraphType&gt; { Name = columnName });<br/>        }</span><span id="82e1" class="mu kp hu mq b fv mz mw l mx my">        TableArgs.Add(new QueryArgument&lt;IdGraphType&gt; { Name = "id" });<br/>        TableArgs.Add(new QueryArgument&lt;IntGraphType&gt; { Name = "first" });<br/>        TableArgs.Add(new QueryArgument&lt;IntGraphType&gt; { Name = "offset" });<br/>    }</span><span id="47d5" class="mu kp hu mq b fv mz mw l mx my">    private Type ResolveColumnMetaType(string dbType)<br/>    {<br/>        if (DatabaseTypeToSystemType.ContainsKey(dbType))<br/>            return DatabaseTypeToSystemType[dbType];</span><span id="51f6" class="mu kp hu mq b fv mz mw l mx my">        return typeof(String);<br/>    }<br/>}</span></pre><p id="bbf8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的代码帮助应用程序识别数据类型和一些查询参数，如分页、投影…当我向您展示查询结果时，请参阅本文的最后一部分。</p><h1 id="9f9b" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">图形解析器</h1><p id="8999" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">为了使GraphQL理解被填充的数据库模式，我们需要创建如下一些revolvers</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="3794" class="mu kp hu mq b fv mv mw l mx my">public class NameFieldResolver : IFieldResolver<br/>{<br/>    public object Resolve(ResolveFieldContext context)<br/>    {<br/>        var source = context.Source;</span><span id="0683" class="mu kp hu mq b fv mz mw l mx my">        if (source == null)<br/>        {<br/>            return null;<br/>        }</span><span id="6bd4" class="mu kp hu mq b fv mz mw l mx my">        var name = Char.ToUpperInvariant(context.FieldAst.Name[0]) + context.FieldAst.Name.Substring(1);<br/>        var value = GetPropValue(source, name);</span><span id="5320" class="mu kp hu mq b fv mz mw l mx my">        if (value == null)<br/>        {<br/>            throw new InvalidOperationException($"Expected to find property {context.FieldAst.Name} on {context.Source.GetType().Name} but it does not exist.");<br/>        }</span><span id="1d87" class="mu kp hu mq b fv mz mw l mx my">        return value;<br/>    }</span><span id="e8e9" class="mu kp hu mq b fv mz mw l mx my">    private static object GetPropValue(object src, string propName)<br/>    {<br/>        return src.GetType().GetProperty(propName).GetValue(src, null);<br/>    }<br/>}</span></pre><p id="aded" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，我们为数据库模式中的每个字段定义了解析器</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="d0b3" class="mu kp hu mq b fv mv mw l mx my">public class MyFieldResolver : IFieldResolver<br/>{<br/>    private TableMetadata _tableMetadata;<br/>    private DbContext _dbContext;</span><span id="51e1" class="mu kp hu mq b fv mz mw l mx my">    public MyFieldResolver(TableMetadata tableMetadata, DbContext dbContext)<br/>    {<br/>        _tableMetadata = tableMetadata;<br/>        _dbContext = dbContext;<br/>    }</span><span id="fb2e" class="mu kp hu mq b fv mz mw l mx my">    public object Resolve(ResolveFieldContext context)<br/>    {<br/>        var queryable = <strong class="mq hv">_dbContext.Query(_tableMetadata.AssemblyFullName)</strong>;<br/>        if (context.FieldName.Contains("_list"))<br/>        {<br/>            <br/>            var first = context.Arguments["first"] != null ? <br/>                context.GetArgument("first", int.MaxValue) :<br/>                int.MaxValue;</span><span id="efad" class="mu kp hu mq b fv mz mw l mx my">            var offset = context.Arguments["offset"] != null ? <br/>                context.GetArgument("offset", 0) : <br/>                0;</span><span id="335d" class="mu kp hu mq b fv mz mw l mx my">            return queryable<br/>                .Skip(offset)<br/>                .Take(first)<br/>                .ToDynamicList&lt;object&gt;();<br/>        }<br/>        else<br/>        {<br/>            var id = context.GetArgument&lt;Guid&gt;("id");<br/>            return <strong class="mq hv">queryable.FirstOrDefault($"Id == </strong><a class="ae jg" href="http://twitter.com/0" rel="noopener ugc nofollow" target="_blank"><strong class="mq hv">@0</strong></a><strong class="mq hv">", id)</strong>;<br/>        }<br/>    }<br/>}</span></pre><p id="2b18" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意上面代码中的动态LINQ(粗体文本颜色)。感谢<strong class="jj hv">系统。Linq.Dynamic.Core </strong> lib，没有它我们需要做很多工作才能得到这样的东西。现在增加了一个东西，使我们可以使用它的程序集名称进行查询</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="b8e0" class="mu kp hu mq b fv mv mw l mx my">public static class DbContextExtensions<br/>{<br/>    public static IQueryable Query(this DbContext context, string entityName) =&gt;<br/>     context.Query(context.Model.FindEntityType(entityName).ClrType);</span><span id="d3d9" class="mu kp hu mq b fv mz mw l mx my">    static readonly MethodInfo SetMethod = typeof(DbContext).GetMethod(nameof(DbContext.Set));</span><span id="08a8" class="mu kp hu mq b fv mz mw l mx my">    public static IQueryable Query(this DbContext context, Type entityType) =&gt;<br/>     (IQueryable)SetMethod.MakeGenericMethod(entityType).Invoke(context, null);<br/>}</span></pre><p id="a960" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您想了解有关该解决方案的更多信息，请访问<a class="ae jg" href="https://stackoverflow.com/questions/48041821/dynamically-access-table-in-ef-core-2-0" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/48041821/dynamic-access-table-in-ef-core-2-0</a>。</p><h1 id="ee8e" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">图形查询</h1><p id="d9ae" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">现在是我们需要为应用程序定义查询的时候了。需要注意以下两点</p><ul class=""><li id="979b" class="lm ln hu jj b jk jl jo jp js na jw nb ka nc ke lt lu lv lw dt translated">如果我们想要查询<strong class="jj hv">任务实体</strong>，那么我们想要根据我们已经定义的数据库模式，将它定义为<strong class="jj hv"> { tasks (id: " &lt; id此处为&gt;" { id，name} } </strong>。输出中将只返回一条记录</li><li id="0d32" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">如果要查询任务实体的<strong class="jj hv">列表，我们需要像<strong class="jj hv"> { tasks_list (offset:1，first:10) { id，name } } </strong>一样，从第1页开始查询任务实体列表，先得到10条记录。结果应该是通过后端数据库中的任务记录列表</strong></li></ul><p id="5b5f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如上所述，我们为数据库中的每个实体定义了2个字段。例如，如果DbContext中有10个实体，那么GraphQL定义中就有10 x 2=20个字段。让我给你看一个代码</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="4c1d" class="mu kp hu mq b fv mv mw l mx my">public class GraphQLQuery : ObjectGraphType&lt;object&gt;<br/>{<br/>    private IDatabaseMetadata _dbMetadata;<br/>    private ITableNameLookup _tableNameLookup;<br/>    private DbContext _dbContext;</span><span id="68b0" class="mu kp hu mq b fv mz mw l mx my">    public GraphQLQuery(<br/>        DbContext dbContext, <br/>        IDatabaseMetadata dbMetadata,<br/>        ITableNameLookup tableNameLookup)<br/>    {<br/>        _dbMetadata = dbMetadata;<br/>        _tableNameLookup = tableNameLookup;<br/>        _dbContext = dbContext;</span><span id="fe75" class="mu kp hu mq b fv mz mw l mx my">        Name = "Query";</span><span id="047a" class="mu kp hu mq b fv mz mw l mx my">        foreach (var metaTable in _dbMetadata.GetTableMetadatas())<br/>        {<br/>            var tableType = new TableType(metaTable);<br/>            var friendlyTableName = _tableNameLookup.GetFriendlyName(metaTable.TableName);</span><span id="aac5" class="mu kp hu mq b fv mz mw l mx my">            AddField(new FieldType<br/>            {<br/>                Name = friendlyTableName,<br/>                Type = tableType.GetType(),<br/>                ResolvedType = tableType,<br/>                Resolver = new MyFieldResolver(metaTable, _dbContext),<br/>                Arguments = new QueryArguments(<br/>                    tableType.TableArgs<br/>                )<br/>            });</span><span id="bfdd" class="mu kp hu mq b fv mz mw l mx my">            // lets add key to get list of current table<br/>            var listType = new ListGraphType(tableType);<br/>            AddField(new FieldType<br/>            {<br/>                Name = $"{friendlyTableName}_list",<br/>                Type = listType.GetType(),<br/>                ResolvedType = listType,<br/>                Resolver = new MyFieldResolver(metaTable, _dbContext),<br/>                Arguments = new QueryArguments(<br/>                    tableType.TableArgs                        <br/>                )<br/>            });<br/>        }<br/>    }<br/>}</span></pre><p id="3435" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们基于前面步骤中获得的模式来定义GraphQL查询的字段。这对你有意义吗？</p><h1 id="ae02" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">图形控制器</h1><p id="750e" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">本文的最后一步是定义控制器，这样我们就可以运行应用程序了。这真的很简单，如下</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="6837" class="mu kp hu mq b fv mv mw l mx my">[Route("graphql/api/query")]<br/>public class GraphQLController : Controller<br/>{<br/>    private readonly Schema graphQLSchema;</span><span id="9fde" class="mu kp hu mq b fv mz mw l mx my">    public GraphQLController(Schema schema)<br/>    {<br/>        graphQLSchema = schema;<br/>    }</span><span id="5b81" class="mu kp hu mq b fv mz mw l mx my">    [HttpPost]<br/>    public async Task&lt;string&gt; Get([FromQuery] string query = "{ tasks_list(offset:1, first:10) { id, name } }")<br/>    {<br/>        var result = await new DocumentExecuter().ExecuteAsync(<br/>            new ExecutionOptions()<br/>            {<br/>                Schema = graphQLSchema,<br/>                Query = query                    <br/>            }<br/>        ).ConfigureAwait(false);</span><span id="17fd" class="mu kp hu mq b fv mz mw l mx my">        if (result.Errors?.Count &gt; 0)<br/>        {<br/>            return result.Errors.ToString();<br/>        }</span><span id="6c2e" class="mu kp hu mq b fv mz mw l mx my">        var json = new DocumentWriter(indent: true).Write(result.Data);</span><span id="85cf" class="mu kp hu mq b fv mz mw l mx my">        return json;<br/>    }<br/>}</span></pre><p id="71fa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要忘记将所有组件连接到IOC容器</p><pre class="mi mj mk ml fq mp mq mr ms aw mt dt"><span id="c6c6" class="mu kp hu mq b fv mv mw l mx my">public static class ServiceCollectionExtensions<br/>{<br/>    public static IServiceCollection AddMyGraphQL(this IServiceCollection services)<br/>    {<br/>        services.AddScoped&lt;ITableNameLookup, TableNameLookup&gt;();<br/>        services.AddScoped&lt;IDatabaseMetadata, DatabaseMetadata&gt;();<br/>        services.AddScoped((resolver) =&gt;<br/>        {<br/>            var dbContext = resolver.GetRequiredService&lt;ApplicationDbContext&gt;();<br/>            var metaDatabase = resolver.GetRequiredService&lt;IDatabaseMetadata&gt;();<br/>            var tableNameLookup = resolver.GetRequiredService&lt;ITableNameLookup&gt;();</span><span id="aaa9" class="mu kp hu mq b fv mz mw l mx my">            var schema = new Schema { Query = new GraphQLQuery(dbContext, metaDatabase, tableNameLookup) };<br/>            schema.Initialize();</span><span id="56a5" class="mu kp hu mq b fv mz mw l mx my">            return schema;<br/>        });</span><span id="5c1b" class="mu kp hu mq b fv mz mw l mx my">        return services;<br/>    }<br/>}</span></pre><h1 id="9a87" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">把它们放在一起</h1><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/9e40a40828a85b6bd9287ffed93393ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pB1JVW757lHggQdOGBIEw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://pixabay.com/en/the-fishermen-fishing-the-work-2983615/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="1558" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在完成了上面的所有步骤之后，这个的结构如下图所示</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/7471a1e50bd431f24688688c6b52c61c.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*Xv8jzUVLqCmBNHG76ai8mA.png"/></div></figure><p id="96a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这只是一个概念项目，我将不得不在未来做更多的重构。还不确定。让我们按F5运行它，我将向您展示它是如何工作的</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/b025679a889f19f334dd24ee3b5fa876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieCPKilvKzN0m8w63cuZMg.png"/></div></div></figure><p id="242a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们输入一些上面的GraphQL查询然后点击<strong class="jj hv">试试吧！</strong></p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/75dc27769e4afd619b6bba9b98da91bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*06qhrq4VYsTp_P-fianmvg.png"/></div></figure><p id="9646" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">数据库模式自动加载为</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/6cebebe252d6fe984acc8b01138a637b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADANX5gZYYdYH1QG4VmHAA.png"/></div></div></figure><p id="0fca" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它将所有GraphQL字段构建为</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/d02c1b243b8f0088d216b963b9a2d4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCKmSlK0YGmJFU-1vlbxiA.png"/></div></div></figure><p id="eec0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以<strong class="jj hv"> { tasks_list(offset:1，first:10) { id，name } } </strong>为输入，您将收到</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nj"><img src="../Images/3d7ec321424e6b4c75d6e1ed3f14bbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDKk2QkqQJrZfOXOJS_zEg.png"/></div></div></figure><p id="03ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我改成<strong class="jj hv">{ tasks(id:" 621 CFF 32-A15D-4622–9938–0028 ea 0c 3 fee "){ name，id，taskStatus } } </strong>，应该是</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nk"><img src="../Images/af5b9ca7470f6bec0dfa00ada62cfd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7pYAFJrIJTyWUZcazcYqw.png"/></div></div></figure><p id="31c7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">今天到此为止:)让我知道你的感受。</p><h1 id="5b1f" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">源代码</h1><p id="e82c" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">所有的源代码都可以在https://github.com/vietnam-devs/crmcore找到。如果你喜欢它，给我一个掌声，我会更有动力把它做得更好。</p><h1 id="4099" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">概述</h1><p id="0a76" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">这篇文章是关于我为结合实体框架核心和GraphQL.NET所做的概念验证。结果是我们可以动态地使用。NET来使查询在真实的商业案例中更加动态和灵活。但是有一些警告如下</p><ul class=""><li id="1604" class="lm ln hu jj b jk jl jo jp js na jw nb ka nc ke lt lu lv lw dt translated">对实体的认证和授权还没有提到。</li><li id="965f" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">也许我们可以藏起来，不要像这篇文章一样把一切都暴露在世界之外。</li><li id="8353" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">本文还没有提到GraphQL的变异端和其他概念。</li><li id="375f" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">未与前端集成(与<a class="ae jg" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a> lib进行react/redux)。</li><li id="77e3" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">与当前实体的子关系的解决方案(我还没有一个解决方案，欢迎任何人帮助我:p)</li><li id="d61d" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">你说出它的名字，让我在评论中知道，然后我可以在以后改进它。</li></ul><h1 id="2ec1" class="ko kp hu bd kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll dt translated">附加阅读</h1><ul class=""><li id="5a72" class="lm ln hu jj b jk lo jo lp js lq jw lr ka ls ke lt lu lv lw dt translated"><a class="ae jg" href="http://graphql-dotnet.github.io" rel="noopener ugc nofollow" target="_blank">http://graph QL-dot net . github . io</a></li><li id="89b5" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://dev-blog.apollodata.com/2017-the-year-in-graphql-124a050d04c6" rel="noopener ugc nofollow" target="_blank">https://dev-blog . Apollo data . com/2017-the year-in-graph QL-124 a 050d 04c 6</a></li><li id="dd85" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">【https://github.com/chentsulin/awesome-graphql#lib-dotnet T2】号</li><li id="ccea" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://github.com/nreco/data/tree/master/examples/SqliteDemo.GraphQLApi" rel="noopener ugc nofollow" target="_blank">https://github . com/nreco/data/tree/master/examples/SqliteDemo。图表Api </a></li><li id="e2b0" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://github.com/landmarkhw/Dapper.GraphQL" rel="noopener ugc nofollow" target="_blank">https://github.com/landmarkhw/Dapper.GraphQL</a></li><li id="e8f7" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://github.com/JacekKosciesza/StarWars" rel="noopener ugc nofollow" target="_blank">https://github.com/JacekKosciesza/StarWars</a></li><li id="7003" class="lm ln hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated"><a class="ae jg" href="https://github.com/JuergenGutsch/GraphQlDemo" rel="noopener ugc nofollow" target="_blank">https://github.com/JuergenGutsch/GraphQlDemo</a></li></ul><p id="400a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">感谢阅读！</strong>如果您喜欢这篇文章，请务必<strong class="jj hv">点击</strong>👏所以<strong class="jj hv">下面的符号别人</strong>会<strong class="jj hv">看</strong>吧。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><ul class=""><li id="1689" class="lm ln hu jj b jk jl jo jp js na jw nb ka nc ke lt lu lv lw dt translated">2019年2月13日:更正本文中的一些含义和错别字</li></ul></div></div>    
</body>
</html>