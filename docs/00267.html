<html>
<head>
<title>The Hybrid Strategy for GraphQL Subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL订阅的混合策略</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-hybrid-strategy-for-graphql-subscriptions-dd5471c45755?source=collection_archive---------9-----------------------#2018-01-09">https://medium.com/hackernoon/the-hybrid-strategy-for-graphql-subscriptions-dd5471c45755?source=collection_archive---------9-----------------------#2018-01-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="414e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">订阅真的很难。这就是它们有趣的地方。GraphQL  &amp; Relay支持它们已经有几个月了，但例子仍然很少。最糟糕的部分？如果你试图在你的大规模应用中实现它们，那些确实存在的使用模式会让你头疼。相信我。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/c521ba0e0643f052ff45f9a137d776f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdAeQ-ExTXTHsPpiJRnfRg.jpeg"/></div></div></figure><p id="6856" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经过大量的反复试验，我终于发现了一种模式，它可以随着你的应用程序线性扩展。希望它能让你在开始实时应用程序时免受痛苦。</p><h2 id="9f52" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">一些背景</h2><p id="d4db" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">圣杯是一个页面，其中每个域状态都实时更新，代码可维护，并且没有过度蚀刻。自从第一次AJAX请求以来，情况一直如此。毕竟，伪实时应用已经存在几十年了。你每5秒钟发送一个AJAX来显示屏幕上的所有内容，然后你就在那里了。问题是真正算的时候，5秒太长，活动稀疏的时候，5秒太短。订阅解决了这个问题，因为服务器会告诉你发生了什么变化，而不是无休止地与服务器打交道。</p><p id="3d34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Meteor是第一个真正利用LiveQuery的框架。它跟踪<a class="ae jp" href="https://hackernoon.com/tagged/mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB </a> Oplog，并将更改推送到订阅的客户端。RethinkDB后来通过构建一个本地反应数据库完善了这一点。这两种策略都不错，但是有两个问题:</p><p id="3d3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，过度蚀刻:如果你关心一个<code class="eh lc ld le lf b">Todo</code>的<code class="eh lc ld le lf b">content</code>并且有人改变了<code class="eh lc ld le lf b">priority</code>，你仍然在处理整个糟糕的文档。当然，你可以在发送给客户端之前选择单独的字段，但是订阅不能在整个应用程序中重复使用，从那里开始，它会一路向下溢出。</p><p id="67ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，也是最重要的一点，它们受到数据存储方式的限制。如果您关心一个<code class="eh lc ld le lf b">Team</code> <strong class="it hv"> </strong>以及它们所拥有的Todos的数量，您要么需要将该计数反规格化到<code class="eh lc ld le lf b">Team</code> <strong class="it hv"> </strong>表中，要么您还需要订阅一个<code class="eh lc ld le lf b">Todo</code> <strong class="it hv"> </strong>计数并将2个计数拼凑在一起。后端改变以适应前端？那是代码的味道。</p><h2 id="3c7a" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">输入GraphQL</h2><p id="b09f" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">GraphQL用他们新奇的数据转换管道改变了这一切。它甚至可以用于上面提到的那些<strong class="it hv"> LiveQuery </strong>，尽管我不推荐它(要了解为什么，我强烈推荐GraphQL峰会的<a class="ae jp" href="https://youtu.be/BSw05rJaCpA?t=19m30s" rel="noopener ugc nofollow" target="_blank">牛逼演讲)。有了GraphQL，订阅不再受限于它在数据库中的存储方式，因为每个订阅都会触发一个客户端定义的查询。剩下要解决的唯一问题是如何对订阅进行细分。在与许多人交谈、阅读了大量代码并尝试了许多愚蠢的事情之后，我了解到有3种方法来划分订阅:<strong class="it hv">按查询、按实体和按变异</strong>。让我们来看看每一个。</a></p><h2 id="09a0" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">每个查询的订阅</h2><p id="bbb6" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">人群中的警笛声。你刚刚竖起大拇指，让你的应用程序的一部分反应，这样你就可以围绕单个组件建立订阅。如果该组件的查询中的任何数据发生变化，您的订阅将通过一个漂亮的有效负载让您知道。不幸的是，您的营销团队随后会更改页面的布局，您很快就会发现，随着组件的更改，您的服务器也必须更改。因为增加了一个新的<code class="eh lc ld le lf b">&lt;Footer/&gt;</code>而更新10个突变和你的订阅是蹩脚的，所以你寻找更好的模式。</p><h2 id="5734" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">每个实体的订阅</h2><p id="04fc" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">这种订阅方式最受欢迎。从PubSub教材到GraphQL示例repos，你随处可见。这非常简单:如果您有一个突变，它修改了ID为<code class="eh lc ld le lf b">123</code>的<code class="eh lc ld le lf b">Team</code>，那么您就以完美的<code class="eh lc ld le lf b">Topic.Channel</code>方式向<code class="eh lc ld le lf b">Team.123</code>发布一条消息。简单吧？嗯，直到你称之为<code class="eh lc ld le lf b">AddTeam</code>突变。如果你发布到频道<code class="eh lc ld le lf b">Team.124</code>，还没有人在听，所以你需要发布到父频道，比如<code class="eh lc ld le lf b">Team.userId</code>。另一个听你加入的队伍的频道？不算伟大，但也不可怕。</p><p id="8a62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，假设你有一个<code class="eh lc ld le lf b">RemoveFromCompany</code>突变，它将你从每个<code class="eh lc ld le lf b">Team</code>中移除，并为每个团队移除每个<code class="eh lc ld le lf b">Todo</code>项目。在<code class="eh lc ld le lf b">Team</code>和<code class="eh lc ld le lf b">Todo </code>频道上收听的贫穷客户端将接收每个待办事项、团队和公司的1条消息；那可是m*n + m + 1条消息啊！一个连续快速处理100次更新的客户端可能会降到60fps以下，但这并不可怕。智能批处理策略可以轻松缓解这一问题。</p><p id="86da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三，有趣的是，每个实体的订阅本质上是过度的。想象一个<code class="eh lc ld le lf b">ChangeTeamName</code>突变。您只更改了单个字段，但是订阅返回了整个<code class="eh lc ld le lf b">Team</code>对象，因为您与其他变体共享它。当然，获取这些字段中的一些可能会很昂贵，但是如果这意味着代码是可维护的，那么什么是有点过度提取呢…</p><p id="156d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，可维护性是一场噩梦，这让我们明白了每实体订阅是坏消息的真正原因:它们传输的是<em class="lg">状态</em>，而不是<em class="lg">事件</em>。例如，如果我在一个<code class="eh lc ld le lf b">Todo</code>被移除时弹出一个祝酒词，那么<code class="eh lc ld le lf b">RemoveFromCompany</code>会触发100个祝酒词吗？如果一个用户加入了一个团队，他们是全新的，还是重新激活的？谁加的？当你在电脑上看着同一个网页的时候，是你从手机上发来的吗？那天结束时，我残酷地意识到我需要的不仅仅是国家。我需要这个活动。</p><p id="a4fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在意识到问题是什么之前，我通过将状态和事件分成单独的<code class="eh lc ld le lf b">Team</code>和<code class="eh lc ld le lf b">Event</code>通道来解决这个问题。我告诉自己，<code class="eh lc ld le lf b">Team</code>通道将处理对<code class="eh lc ld le lf b">Team</code>对象的更新，而<code class="eh lc ld le lf b">Event</code>通道将处理任何祝酒词或一次性消息。随着应用程序的增长和业务逻辑的改变，我意识到<code class="eh lc ld le lf b">Event</code>有效负载通常包含整个<code class="eh lc ld le lf b">Team</code>对象，我甚至不需要<code class="eh lc ld le lf b">Team</code>通道！事实上，<code class="eh lc ld le lf b">Event</code>的有效负载几乎与触发它的突变的有效负载相同，然而在这里，我不知疲倦地工作来消除错误，以保持3个独立的查询和处理程序返回相同的结果。像个白痴一样。</p><h2 id="7194" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">每变异订阅</h2><p id="821a" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">订阅是一种你不知道自己想要的变化。考虑到这一点，订阅一个突变是非常有意义的。想象一个订阅负载，它看起来与突变负载相同，共享一个处理程序和查询片段。当业务逻辑发生变化时，您需要更新单一的事实来源。</p><p id="25c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，每查询订阅失败是因为它们需要对后端进行不断的更改，而每变异订阅失败是因为它们需要对前端进行不断的更改。想象一下，如果每个突变都有一个通道，就像<code class="eh lc ld le lf b">ChangeTeamName.123</code>。任何使用了<code class="eh lc ld le lf b">team.name</code>字段的组件也必须订阅它。看起来可维护性的另一个死胡同。</p><p id="b6a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，我们还在过度蚀刻。突变负载可能提供了比组件所需更多的数据。例如，<code class="eh lc ld le lf b">RemoveFromCompany</code>负载可能包括<code class="eh lc ld le lf b">teams</code>，但是您的<code class="eh lc ld le lf b">TodoList</code>组件只关心被移除的<code class="eh lc ld le lf b">Todos</code>。你是选择过度提取，还是编写第二个处理程序？</p><h2 id="306e" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">混合订阅</h2><p id="0498" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">如果您已经订阅了，您可能会在没有意识到的情况下实现某种混合。要么您有单独的添加/删除/更新订阅并在客户端同时订阅所有3个订阅，要么您的订阅有效负载是添加的项目、删除的项目或更新的项目的联合，要么您只获取整个项目而不管其类型(这对于删除的项目来说很棘手！).无论如何，每个实体和每个变异的订阅都缺乏可维护性，并遭受过度提取，但方式相反。回到固定有效载荷订阅的时代，我们必须选择一个。谢天谢地，这就是GraphQL拯救世界的地方。我们可以利用每个实体和每个突变策略的最佳部分，创建一种新型的混合订阅，这是以前不可能的，<em class="lg">直到现在</em> …</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lh"><img src="../Images/f4af1aba0713d64a68e5a56e0993851d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3qKRB_FjkRhaw-U7EiRjw.png"/></div></div></figure><p id="75ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">…开个玩笑！付费墙很烂，中等。</p><h2 id="0033" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">如何实现混合订阅</h2><p id="b70b" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">让我们从服务器开始。在<code class="eh lc ld le lf b">ChangeTeamName</code>突变中，我们返回一个<code class="eh lc ld le lf b">ChangeTeamNamePayload</code>像<code class="eh lc ld le lf b">team { name }</code>。我们知道发布到像<code class="eh lc ld le lf b">ChangeTeamName.123</code>这样的渠道会让前端开发人员的日子不好过，所以我们改为发布到<code class="eh lc ld le lf b">Team.123</code>。为什么要使用基于实体的渠道？因为这是完美的妥协。如果我们将所有内容发布到一个频道，那么我们将向用户发送每一条消息，即使是那些不影响她当前视图的消息。如果她现在不看她的待办事项列表，她可能不关心更新的<code class="eh lc ld le lf b">Todo</code>项目！相反，让一个<code class="eh lc ld le lf b">&lt;Team/&gt;</code>组件依赖于影响团队的不断变化的突变列表是很残酷的；但是都订阅了<code class="eh lc ld le lf b">Team</code>订阅的<code class="eh lc ld le lf b">&lt;Team/&gt;</code>和<code class="eh lc ld le lf b">&lt;TodoList/&gt;</code>组件呢？是的，这是可以控制的。</p><p id="ce09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，唯一要添加到对<code class="eh lc ld le lf b">publish</code>的调用中的是突变名称:<code class="eh lc ld le lf b">publish(Team.123, {team, type: ChangeTeamNamePayload})</code>。订阅有效负载只是一个基于具体类型解析该类型的<a class="ae jp" href="https://github.com/ParabolInc/action/blob/002996f0fbbb646fde7e5ca673e25a734f871d52/src/server/graphql/graphQLSubscriptionType.js" rel="noopener ugc nofollow" target="_blank">联合。它太简单了，就像实时应用程序中的贝蒂·克罗克。</a></p><p id="8c55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于变异和订阅返回相同的对象类型，它们可以共享处理程序。因为订阅在服务器上进行分组，所以组件不必这样做。剩下要解决的就是过度蚀刻了。</p><p id="ed1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了解决这个问题，我将每个突变查询分解成<a class="ae jp" href="https://github.com/ParabolInc/action/blob/002996f0fbbb646fde7e5ca673e25a734f871d52/src/universal/mutations/AddTeamMutation.js#L9-L32" rel="noopener ugc nofollow" target="_blank">个独立的片段</a>。举个例子，</p><pre class="jr js jt ju fq li lf lj lk aw ll dt"><span id="df6b" class="kc kd hu lf b fv lm ln l lo lp">fragment ChangeTeamNameMutation_team on ChangeTeamNamePayload {<br/>  team {<br/>    name<br/>  }<br/>}<br/>ChangeTeamNameMutation {<br/>  ...ChangeTeamNameMutation_team<br/>}<br/>TeamSubscription {<br/>  ...ChangeTeamNameMutation_team<br/>  ...ChangeTeamColorMutation_team<br/>}</span></pre><p id="cf9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如所见，在订阅中，我包含了每个带有_team后缀的片段。这并不太难，但是codemod可以让它变得更简单。编写每个通道的片段和处理程序非常有意义，因为1个变异调用许多订阅通道，1个订阅由许多变异触发。因为GraphQL允许在类型上进行分段，所以这不是问题。即使对于可以返回变化很大的有效载荷的变异(即增加或删除的<code class="eh lc ld le lf b">ToggleTeam</code>变异)，你仍然可以使用联合和接口。更好的是，这意味着如果您的所有业务逻辑都在同一个处理程序中。需要为mutator干杯，悄悄地更新mutator的其他设备上的状态，并向团队的其他成员宣布单独的消息吗？没问题。这是<a class="ae jp" href="https://github.com/ParabolInc/action/blob/002996f0fbbb646fde7e5ca673e25a734f871d52/src/universal/subscriptions/TeamSubscription.js#L12-L33" rel="noopener ugc nofollow" target="_blank">在生产中的样子</a>。</p><h2 id="bc63" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">结论</h2><p id="d4c2" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">希望这能激发你在你的应用中添加一些实时功能！多亏了GraphQL，我能够编写使用与我的变异相同的查询和处理程序的订阅，这意味着它们是可维护的，大大减少了过度提取，更好的是，模式可以模块化扩展，所以你可以让你的应用程序一次反应1个变异，这应该会让你的老板高兴。研究类似的东西？伸出手来！</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>