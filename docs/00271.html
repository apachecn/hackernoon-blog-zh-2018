<html>
<head>
<title>Where do we go after Git?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git之后我们去哪里？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/where-do-we-go-after-git-d4d40d8303ce?source=collection_archive---------13-----------------------#2018-01-09">https://medium.com/hackernoon/where-do-we-go-after-git-d4d40d8303ce?source=collection_archive---------13-----------------------#2018-01-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/cdfb0304b3e6f885951a68577e011d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0im_n-vzuK_guch55Fs-0A.png"/></div></div></figure><div class=""/><div class=""><h2 id="40a4" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">让我们开始这个派对吧</h2></div><h1 id="09f2" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">序文</h1><p id="fa05" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">Git重新定义了我们编写软件的方式。这是一项巧妙的技术，它的社区和生态系统充满活力。它变得如此无处不在，以至于很难想象会有什么东西跟随它。但这种想法现在听起来应该很可疑:人们对马和马车、煤气灯和固定电话说了同样的话。从根本上说，人类是一个不停创新的物种，而技术不会坐以待毙。因此，尽管Git可能仍然让人感觉新鲜——也许是因为它周围的一切都欣欣向荣——但值得记住的是，第一个版本是在第一代iPhone 之前两年<em class="li">发布的。至少可以说，自那时以来，情况发生了很大变化。</em></p><p id="5a3a" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">需要澄清的是，这不是一篇关于Git即将灭亡的文章。我喜欢Git，我不认为它已经达到了极限，也不认为它会很快消失。在可预见的未来，它可能会继续增长，而且很可能永远不会完全消失。或许有一天，经过一段时间的使用，Git甚至会复兴，让人想起黑胶唱片在<a class="ae lo" href="http://www.independent.co.uk/news/long_reads/vinyl-demand-lps-record-store-day-a7952911.html" rel="noopener ugc nofollow" target="_blank">的回归。但是Git之后会出现一些东西，似乎是时候开始猜测那可能是什么了。</a></p><p id="52c8" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">让我们先回到过去一会儿。Git对分布式工作流的支持反映了正在进行的计算的分散化。权力不再仅仅掌握在中央服务器上，客户也不再扮演从属的角色。端点可以尽自己的力量，结果是一个新的移动，新的自由世界。这是真正的解放！</p><p id="91a8" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">然而，新的问题出现了:最令人痛苦的是，不同设备之间的数据不同步，或者完全不可用。如果很难记起那是什么样子，那就想想Git发布的同一年<a class="ae lo" href="https://web.archive.org/web/20070705184347/https://www.foldershare.com/info/company/aboutUs.php" rel="noopener ugc nofollow" target="_blank">微软收购了FolderShare </a>，从而进入了<em class="li">“文件同步和远程访问技术的新兴领域，帮助客户跨多种设备访问信息”</em>。这比谷歌文档早了一年，比Dropbox早了两年。这就是Git诞生的世界。</p><p id="04aa" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">不用说，现在已经不是我们生活的世界了。技术领域不断变化，尤其是所有这些计算设备之间的连接方式发生了巨大变化。随着数字通信变得更快、更丰富、更可靠，不仅每个设备都可以处理自己的位处理，而且所有设备都可以实时有效地协同工作。一台计算机上的信息不同于另一台计算机上的信息的观念开始缓慢而不可避免地瓦解。这给了我们第一个提示，Git之后的版本控制在哪里。</p><h1 id="4770" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">预言</h1><p id="7931" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">由于Git的发展反映了十年前计算领域的发展，我们可能会怀疑它的继任者将反映我们今天正在经历的变革。因此，我们可能会看到其中一些:</p><h2 id="88fc" class="lp jv if bd jw lq lr ls ka lt lu lv ke kv lw lx kg kz ly lz ki ld ma mb kk mc dt translated">默认情况下已连接</h2><p id="fad3" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">Git使得将机器上的分支与远程设备上的分支关联起来变得很简单。但是默认情况下，这些关联只是指针，而不是连接。除非您手动获取更新，或者使用Git客户端定期为您获取更新，否则您机器上的数据会过时——即使所有设备都联网。对于任何现代技术用户来说，这应该感觉非常过时。如果有人和我做同样的事情，我希望不用问就能被告知。</p><h2 id="f407" class="lp jv if bd jw lq lr ls ka lt lu lv ke kv lw lx kg kz ly lz ki ld ma mb kk mc dt translated">总是在动</h2><p id="e610" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">Git的轻量级分支模型使得快速退出并尝试一些改变变得容易，而不用担心真的会把事情弄糟。您可以在您自己的分支中提交您的更改，确保它们不会丢失，并且只有当事情顺利时才将其合并回来。但是仍然有很多丢失工作的机会:如果停电而没有保存更改，或者如果您决定需要返回到提交之间的状态，您可能就不走运了。如今，我相信软件永远不会丢失我的工作，无论我是否或何时想保存。我的工作总是在进行中，我希望我的软件能跟上。</p><h2 id="7db6" class="lp jv if bd jw lq lr ls ka lt lu lv ke kv lw lx kg kz ly lz ki ld ma mb kk mc dt translated">社交场合</h2><p id="543e" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">Git的提交模型让我知道谁做了什么，什么时候做的——但只是在回顾的时候。当我们在各自的机器上工作时，没有人知道对方在做什么，即使我们在同一个文件中工作。现在，如果我和其他人同时编辑一个文件，我希望我的编辑能告诉我这一点，并准确地告诉我其他人在文件中的位置。GitHub的巨大成功证明了在源代码控制之上分层社交工作流的好处，但现在是我们开始烘焙社交的时候了。</p><h1 id="d298" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">聚会</h1><p id="6165" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">这些方面描述了与Git相当不同的东西。不仅仅是一个源代码控制管理系统，一些连接的、运动的和社交的东西听起来更像是…一个聚会。所以让我们开始派对吧。下面是对软件源代码控制的未来的一个假设。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="f9f8" class="lp jv if mi b fv mm mn l mo mp">$ party start myhouse @friend1 @friend2</span></pre><p id="b99e" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">为了让事情进展顺利，我们邀请了一个叫做T2的人，并邀请了我的两个朋友。这在我的机器和默认的中央服务器上建立了一个Git存储库，并向<code class="eh mq mr ms mi b">friend1</code>和<code class="eh mq mr ms mi b">friend2</code>发送通知。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="abd5" class="lp jv if mi b fv mm mn l mo mp">$ party talk app.js</span></pre><p id="205e" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">我们开始<code class="eh mq mr ms mi b">talk</code>互相合作，研究一些核心逻辑。当我们编辑时，我们都实时看到彼此的击键和插入点。这通常是我们在Git中保存、提交、拉取和推送的地方——但是这里什么都没有发生。大家一起狂欢。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="cd18" class="lp jv if mi b fv mm mn l mo mp">$ party punchline "Basic logic works"</span></pre><p id="fd7a" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">最终我们到达一个稳定点。尽管我们到目前为止采取的每一个行动都被自动记住了，但时间线中的一些点肯定比其他点更值得记住。为此，我们调用一个<code class="eh mq mr ms mi b">punchline</code>，它表示感兴趣的时间点。这些是方便将来使用的引用，类似于Git中的标记。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="740d" class="lp jv if mi b fv mm mn l mo mp">$ party clique refactoring @friend1</span></pre><p id="a9cb" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">最终，我和朋友1决定我们需要对逻辑做一些冒险的改变，我们不希望打断朋友2的工作。我创建了一个名为<code class="eh mq mr ms mi b">refactoring</code>的<code class="eh mq mr ms mi b">clique</code>，并邀请了friend1。尽管friend2可以实时查看重构团体中发生的一切，但只有friend1会被邀请进行编辑。因为集团用于隔离工作集，所以它们类似于Git中的主题分支。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="2f6f" class="lp jv if mi b fv mm mn l mo mp">$ party listen center</span></pre><p id="e58b" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">Friend2还在党的<code class="eh mq mr ms mi b">center</code>工作，相当于Git中的master分支。默认情况下，当我创建重构团体时，我和朋友1不再看到朋友2正在做的任何工作，这让我们专注于自己的工作。但是在进行了最重要的更改之后，我们希望再次跟上friend2正在做的事情，这样我们就可以解决任何冲突性的更改。我们进入了聚会的中心，并且立刻被朋友2的工作吸引住了。这类似于获取远程提交并在Git中本地合并它们。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="fbc6" class="lp jv if mi b fv mm mn l mo mp">$ party join center</span></pre><p id="14a9" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">一旦我们解决了一些合并冲突，并使一切处于良好状态，我们再次成为聚会的中心，此时朋友2会看到我们的工作。这相当于将工作推回到Git中的远程主机，只不过friend2不会手动获取这些更改。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="6ba3" class="lp jv if mi b fv mm mn l mo mp">$ party rewind 2min</span></pre><p id="a5ff" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">在这一点上，朋友2完成了一些事情，然后浏览了我们的工作。我们所做的大部分都很好，但结果是我们删除了他们计划使用的一些东西。因此，friend2决定提前几分钟参加聚会，以找到我们删除的代码。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="ca1f" class="lp jv if mi b fv mm mn l mo mp">$ party bring app.js:112–114</span></pre><p id="0c8d" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">他们确定他们想要第112行到第114行，然后他们将这些行返回到聚会中的当前点。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="b883" class="lp jv if mi b fv mm mn l mo mp">$ party punchline "Full logic implemented"</span></pre><p id="60ea" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">解决了这个问题后，我们接着标记另一个笑点，表明我们已经达到的状态。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="645b" class="lp jv if mi b fv mm mn l mo mp">$ party replay start</span></pre><p id="71f3" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">在结束之前，我们从头开始我们的工作——当然，速度加快了不少。因为聚会存储了我们采取的每一个行动，它能够回放我们开始以来的活动。</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="9e66" class="lp jv if mi b fv mm mn l mo mp">$ party end</span></pre><p id="21a7" class="pw-post-body-paragraph km kn if ko b kp lj jg kr ks lk jj ku kv ll kx ky kz lm lb lc ld ln lf lg lh hn dt translated">一切看起来都很好，所以我们<code class="eh mq mr ms mi b">end</code>的编辑会议到此为止。</p><h1 id="3fe3" class="ju jv if bd jw jx jy jz ka kb kc kd ke jl kf jm kg jo kh jp ki jr kj js kk kl dt translated">附言</h1><p id="c6ba" class="pw-post-body-paragraph km kn if ko b kp kq jg kr ks kt jj ku kv kw kx ky kz la lb lc ld le lf lg lh hn dt translated">Git的继任者可能会出现，也可能不会很快出现。它可能看起来像我这里描述的一样，也可能不一样。它最终可能会也可能不会像Git那样席卷全球。但是为什么要等到发现呢？必须有人让它发生——会是你吗？如果是的话，请务必邀请我参加聚会。</p></div></div>    
</body>
</html>