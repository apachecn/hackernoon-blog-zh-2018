<html>
<head>
<title>Property-based testing (with a sprinkle of JavaScript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于属性的测试(少量JavaScript)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/property-based-testing-4330e3e77381?source=collection_archive---------15-----------------------#2018-01-09">https://medium.com/hackernoon/property-based-testing-4330e3e77381?source=collection_archive---------15-----------------------#2018-01-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/13eea14447461bbe1e9367da19062e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jl9Q3B6O20T9QgVAQWC5KQ.png"/></div></div></figure><p id="bb93" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你来自面向对象，并且曾经测试过任何一款软件，那么你很有可能使用过基于实例的测试。换句话说，用一些预定义的输入调用被测函数，并根据一些预定义的期望检查返回值。例如，用<code class="eh ka kb kc kd b">1</code>和<code class="eh ka kb kc kd b">2</code>调用函数<code class="eh ka kb kc kd b">sum</code>，预期结果是<code class="eh ka kb kc kd b">3</code>。</p><p id="6b0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是这种方法存在一些问题。首先，只能检查有限数量的例子。其次，决定验证什么样的输入输出是一个人的事。不幸的是，这反映了开发者的偏见。因此，很有可能一些关键的输入没有得到检查。</p><p id="732d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果输入不是由开发人员选择的，怎么可能对函数的返回值有期望呢？</p><p id="0ada" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实证明，无论输入是什么，从代码中导出不变量(属性)总是正确的是可能的。如果你把它和随机值生成器混合，你会得到基于属性的测试。</p><p id="f667" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ka kb kc kd b">sum</code>的例子中，我们将使用一个数字生成器来产生输入。然后，我们将导出一些要测试的性质，如交换性(即<code class="eh ka kb kc kd b">x + y == y + x</code>)和结合性(即<code class="eh ka kb kc kd b">(x + y) + z == x + (y + z)</code>)。最后，基于属性的测试框架会生成一些集合<code class="eh ka kb kc kd b">x</code>、<code class="eh ka kb kc kd b">y</code>和<code class="eh ka kb kc kd b">z</code>，并多次检查属性是否成立。</p><p id="9f93" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在出现故障时，我们将取回第一组<code class="eh ka kb kc kd b">x</code>、<code class="eh ka kb kc kd b">y</code>和<code class="eh ka kb kc kd b">z</code>，对于它们，属性不成立。</p><p id="2782" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">sum</code>是一个简单的例子。但是我们可以想象一些更复杂的东西，包括其他函数调用和不那么琐碎的输入。在这种情况下，仅仅获得失败的输入集是不够的。</p><p id="e934" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是为什么大多数基于属性的测试框架都提供了一个叫做收缩的特性。换句话说，在失败后，框架试图通过删除或简化输入数据，将导致属性失败的输入缩小到最简单的形式。</p><h2 id="d36f" class="ke kf hu bd kg kh ki kj kk kl km kn ko jn kp kq kr jr ks kt ku jv kv kw kx ky dt translated">给我看看代码</h2><p id="6821" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">让我们将基于属性的测试应用到那些你在现实生活中永远不会看到的愚蠢例子中。我要用JavaScript和<a class="ae le" href="https://github.com/jsverify/jsverify" rel="noopener ugc nofollow" target="_blank"> JSVerify </a>。</p><p id="07ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们有以下需要测试的代码:</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="1f00" class="ke kf hu kd b fv ln lo l lp lq">const div = (dividend, divisor) =&gt; dividend / divisor</span></pre><p id="482e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很简单，对吧？以下基于示例的测试是绿色的，所以我们可以到此为止了！</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="2cb3" class="ke kf hu kd b fv ln lo l lp lq">describe('div', () =&gt; {<br/>  it('with natural numbers', () =&gt; {<br/>    const expected = 2</span><span id="4c94" class="ke kf hu kd b fv lr lo l lp lq">    const actual = div(6, 3)</span><span id="a962" class="ke kf hu kd b fv lr lo l lp lq">    assert.strictEqual(actual, expected)<br/>  })</span><span id="9788" class="ke kf hu kd b fv lr lo l lp lq">  it('with decimal numbers', () =&gt; {<br/>    const expected = 2</span><span id="d9ec" class="ke kf hu kd b fv lr lo l lp lq">    const actual = div(6.3, 3.15)</span><span id="ffcc" class="ke kf hu kd b fv lr lo l lp lq">    assert.strictEqual(actual, expected)<br/>  })<br/>})</span></pre><p id="347d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不完全是。让我们看看基于属性的测试会发生什么。</p><p id="acaa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，作为生成器，我们可以使用返回自然数的<code class="eh ka kb kc kd b">jsc.nat</code>。</p><p id="48b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其次，作为属性，让我们只检查“右分配”的属性(即<code class="eh ka kb kc kd b">(n1 + n2) / n3 == (n1 / n3) + (n2 / n3)</code>)。</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="8650" class="ke kf hu kd b fv ln lo l lp lq">describe('div', () =&gt; {<br/>  const naturalNumber = jsc.nat</span><span id="8a56" class="ke kf hu kd b fv lr lo l lp lq">  jsc.property(<br/>    'is right-distributive',<br/>    naturalNumber, naturalNumber, naturalNumber,<br/>    (n1, n2, n3) =&gt; div(n1 + n2, n3) === div(n1, n3) + div(n2, n3)<br/>  )<br/>})</span></pre><p id="f118" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嘣！</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="b3cf" class="ke kf hu kd b fv ln lo l lp lq">Error: Failed after 4 tests and 4 shrinks. rngState: 08b51479f83d6a20ec; Counterexample: 0; 0; 0;</span></pre><p id="952d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了<code class="eh ka kb kc kd b">n1 = 0</code>、<code class="eh ka kb kc kd b">n2 = 0</code>和<code class="eh ka kb kc kd b">n3 = 0</code>就出事了。从节点REPL</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="9f59" class="ke kf hu kd b fv ln lo l lp lq">div(0 + 0, 0) === div(0, 0) + div(0, 0)<br/>// false</span><span id="f7ae" class="ke kf hu kd b fv lr lo l lp lq">div(0 + 0, 0)<br/>// NaN</span><span id="f00e" class="ke kf hu kd b fv lr lo l lp lq">div(0, 0) + div(0, 0)<br/>// NaN</span><span id="fb7a" class="ke kf hu kd b fv lr lo l lp lq">NaN === NaN<br/>// false</span></pre><p id="4d42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JavaScript，对吧？如果我们再次运行基于属性的测试</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="b350" class="ke kf hu kd b fv ln lo l lp lq">Error: Failed after 4 tests and 4 shrinks. rngState: 08b51479f83d6a20ec; Counterexample: 2; 32; 3;</span></pre><p id="57ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再次爆炸。但这一次是不同的失败。从节点REPL</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="8de2" class="ke kf hu kd b fv ln lo l lp lq">div(2 + 32, 3) === div(2, 3) + div(32, 3)<br/>// false</span><span id="76be" class="ke kf hu kd b fv lr lo l lp lq">div(2 + 32, 3)<br/>// 11.333333333333334</span><span id="ac19" class="ke kf hu kd b fv lr lo l lp lq">div(2, 3) + div(32, 3)<br/>// 11.333333333333332</span></pre><p id="0e19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JavaScript和浮点运算，对吧？</p><p id="ea8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果基于属性的测试在2次运行中发现2个错误</p><pre class="lf lg lh li fq lj kd lk ll aw lm dt"><span id="6488" class="ke kf hu kd b fv ln lo l lp lq">const div = (dividend, divisor) =&gt; dividend / divisor</span></pre><p id="70cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一下它还能从更复杂的代码中发现什么。</p><h2 id="ecd8" class="ke kf hu bd kg kh ki kj kk kl km kn ko jn kp kq kr jr ks kt ku jv kv kw kx ky dt translated">结尾部分</h2><p id="eb10" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">基于属性的测试消除了偏见。这样就可以发现开发人员没有想到要测试的错误。</p><p id="5b99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，它迫使从另一个角度考虑代码，这是一件好事。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="f6cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同时，属性比例子更抽象一些(比如sum vs <code class="eh ka kb kc kd b">sum(1, 2) == 3</code>中的交换性)。这就是为什么混合两种风格是最好的主意。</p><p id="90e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还想吃吗？看看我在<a class="ae le" rel="noopener" href="/@riccardoodone/diamond-kata-via-property-based-tdd-in-javascript-5fa99acd3e62">后续文章</a>中使用了基于属性的TDD。</p><h2 id="6048" class="ke kf hu bd kg kh ki kj kk kl km kn ko jn kp kq kr jr ks kt ku jv kv kw kx ky dt translated">两颗北极指极星</h2><ul class=""><li id="87ea" class="lu lv hu je b jf kz jj la jn lw jr lx jv ly jz lz ma mb mc dt translated">约翰·休斯的《不要写测试》</li><li id="ccab" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">[视频] <a class="ae le" href="https://skillsmatter.com/skillscasts/6432-the-lazy-programmers-guide-to-writing-1000s-of-tests-an-introduction-to-property-based-testing#video" rel="noopener ugc nofollow" target="_blank">编写1000个测试的懒惰程序员指南:基于属性的测试介绍</a>作者Scott Wlaschin</li><li id="bb36" class="lu lv hu je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">[论文] <a class="ae le" href="http://shareandenjoy.saff.net/tdd-specifications.pdf" rel="noopener ugc nofollow" target="_blank">理论的实践:在“存在”测试中增加“为所有人”的陈述<br/></a></li></ul></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><p id="f4d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从我个人的电子邮件中获取最新内容。用你的想法回复。让我们互相学习。订阅我的<a class="ae le" href="https://odone.io#newsletter" rel="noopener ugc nofollow" target="_blank"> PinkLetter </a>！</p></div></div>    
</body>
</html>