<html>
<head>
<title>Serverless Stack — CI/CD — Blue-Green Deployments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器堆栈— CI/CD —蓝绿色部署</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-stack-ci-cd-blue-green-deployments-a6de63142094?source=collection_archive---------16-----------------------#2018-01-09">https://medium.com/hackernoon/serverless-stack-ci-cd-blue-green-deployments-a6de63142094?source=collection_archive---------16-----------------------#2018-01-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="01f6" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">查看这款内置CI/CD和蓝绿色部署的无服务器堆栈</h2></div><p id="3e4e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我喜欢构建CloudFormation堆栈，我知道这很疯狂…我也喜欢无服务器的事件驱动架构，谁不喜欢呢…</p><p id="973c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我想创建一个可重用的堆栈，可以轻松地用来构建web应用程序。</p><p id="fa65" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">堆栈由一个<strong class="jl hv"> API </strong>、<strong class="jl hv"> UI </strong>和<strong class="jl hv">异步任务</strong>组成。这不是最酷的部分。</p><p id="b812" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">酷的部分是通过代码管道和Lambda的蓝绿色部署的内置CI/CD。</p><p id="0833" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">CI/CD和蓝绿色部署对于应用程序的稳定性和健康非常重要。经常交付和快速失败是很重要的。</p><h1 id="0048" class="kf kg hu bd kh ki kj kk kl km kn ko kp ja kq jb kr jd ks je kt jg ku jh kv kw dt translated">密码</h1><p id="a354" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">密码。检查它，运行它，并让我知道你的想法…</p><div class="lc ld fm fo le lf"><a href="https://github.com/thestackshack/serverless-stack-cicd" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab ej"><div class="lh ab li cl cj lj"><h2 class="bd hv fv z el lk eo ep ll er et ht dt translated">堆栈/无服务器堆栈-cicd</h2><div class="lm l"><h3 class="bd b fv z el lk eo ep ll er et ek translated">无服务器堆栈-cicd -带CI/CD和蓝绿色部署的无服务器堆栈- API +静态UI +异步任务</h3></div><div class="ln l"><p class="bd b gc z el lk eo ep ll er et ek translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt lu lf"/></div></div></a></div><h1 id="47c0" class="kf kg hu bd kh ki kj kk kl km kn ko kp ja kq jb kr jd ks je kt jg ku jh kv kw dt translated">体系结构</h1><p id="5075" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">在讨论CI/CD和蓝绿部署之前，让我们先看一下体系结构。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff lv"><img src="../Images/bb836c18e72a67b9f7e0744dec4b2fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DF7FOj1c-OFbcYegmNBJmg.png"/></div></div></figure><h1 id="75ba" class="kf kg hu bd kh ki kj kk kl km kn ko kp ja kq jb kr jd ks je kt jg ku jh kv kw dt translated">CI/CD</h1><p id="cba6" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">当您将代码或基础结构更改推送到该应用程序时，CodePipeline会构建并更新所有内容。您的基础架构堆栈已更新。您的代码被构建、测试和部署。</p><p id="54f9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以做出改变，并且整天都在努力。发展将是快速和可预测的。快乐的日子。</p><p id="7d1a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">哦，还有一个<strong class="jl hv">沙盒</strong>和一个<strong class="jl hv">生产</strong>环境，所以你可以在把它们推向生产之前在沙盒中测试你的改变。在与您的团队一起生活之前，能够在沙盒环境中测试变更是一件好事。</p><p id="0f8f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是管道的样子:</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/1986fc4e7245abff89437860bddcbc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*7XxxSxxkdEoWM38XJl1I_w.png"/></div></figure><p id="c05d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们仔细看看每个管道阶段和行动。管道由多个阶段组成。每个阶段都由行动组成。</p><p id="226b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你如何组织你的阶段和行动取决于两件事。您希望处理阶段和操作的顺序，以及阶段输入和输出依赖关系。</p><p id="4927" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">阶段可以串联或并联或串联和并联组织。这是由阶段输入和输出工件定义的。</p><p id="d34a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">动作也可以以串行或并行方式组织，或者以串行和并行方式组织。这是由action <code class="eh mh mi mj mk b">order</code>属性以及输入和输出工件定义的。</p><p id="cbf7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果每个阶段的输入工件是前一阶段的输出工件，那么它们将是串联的。如果一个阶段的输入工件是前几个阶段的输出工件，并且这些前几个阶段互不依赖，那么这些前几个阶段将是并行的。</p><p id="9309" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关于CodePipeline已经说得够多了，让我们了解一下我们的管道:</p><h2 id="115d" class="ml kg hu bd kh mm mn mo kl mp mq mr kp js ms mt kr jw mu mv kt ka mw mx kv my dt translated">源阶段— GitHub推送</h2><p id="315e" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">每次GitHub推送都会触发源阶段。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="ccfc" class="ml kg hu mk b fv nd ne l nf ng">- <strong class="mk hv">Name: </strong>Source<br/>  <strong class="mk hv">Actions:<br/>    </strong>- <strong class="mk hv">Name: </strong>CloneRepository<br/>      <strong class="mk hv">ActionTypeId:<br/>        Category: </strong>Source<br/>        <strong class="mk hv">Owner: </strong>ThirdParty<br/>        <strong class="mk hv">Version: </strong>1<br/>        <strong class="mk hv">Provider: </strong>GitHub<br/>      <strong class="mk hv">OutputArtifacts:<br/>        </strong>- <strong class="mk hv">Name: </strong>GitSource<br/>      <strong class="mk hv">Configuration:<br/>        Owner: </strong>!Ref GitHubOwner<br/>        <strong class="mk hv">Branch: </strong>'master'<br/>        <strong class="mk hv">Repo: </strong>!Ref GitHubRepo<br/>        <strong class="mk hv">OAuthToken: </strong>!Ref GitHubToken<br/>      <strong class="mk hv">RunOrder: </strong>1</span></pre><p id="0e72" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mh mi mj mk b">prod</code>管道使用<code class="eh mh mi mj mk b">master</code> GitHub分支，<code class="eh mh mi mj mk b">sandbox</code>管道使用<code class="eh mh mi mj mk b">develop</code> GitHub分支。</p><h2 id="1542" class="ml kg hu bd kh mm mn mo kl mp mq mr kp js ms mt kr jw mu mv kt ka mw mx kv my dt translated">任务包阶段</h2><p id="7f8d" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">这个阶段使用CodeBuild来构建和测试Lambda，然后<strong class="jl hv">打包</strong>cloud formation模板。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="425b" class="ml kg hu mk b fv nd ne l nf ng">- <strong class="mk hv">Name: </strong>TasksPackage<br/>  <strong class="mk hv">Actions:<br/>    </strong>- <strong class="mk hv">Name: </strong>Package<br/>      <strong class="mk hv">ActionTypeId:<br/>        Category: </strong>Build<br/>        <strong class="mk hv">Owner: </strong>AWS<br/>        <strong class="mk hv">Provider: </strong>CodeBuild<br/>        <strong class="mk hv">Version: </strong>1<br/>      <strong class="mk hv">Configuration:<br/>        ProjectName: </strong>!Ref TasksCodeBuildProd<br/>      <strong class="mk hv">InputArtifacts:<br/>        </strong>- <strong class="mk hv">Name: </strong>GitSource<br/>      <strong class="mk hv">OutputArtifacts:<br/>        </strong>- <strong class="mk hv">Name: </strong>TasksOutput<br/>      <strong class="mk hv">RunOrder: </strong>1</span></pre><p id="68e6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">CloudFormation模板中的Lambda使用了一个相对的<code class="eh mh mi mj mk b">CodeUri</code>属性。当使用<code class="eh mh mi mj mk b">CodeUri</code>属性时，您必须使用CloudFormation包(<code class="eh mh mi mj mk b">aws cloudformation package</code>)。CloudFormation包做两件事。首先，它将位于<code class="eh mh mi mj mk b">CodeUri</code>位置的Lambda作为zip文件上传到S3，然后它导出模板，将<code class="eh mh mi mj mk b">CodeUri</code>替换为S3的zip文件位置。</p><p id="7fa9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是完整的代码构建<code class="eh mh mi mj mk b">buildspec.yml</code>。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="7828" class="ml kg hu mk b fv nd ne l nf ng"><strong class="mk hv">version: </strong>0.2<br/><strong class="mk hv">phases:<br/>  install:<br/>    commands:<br/>  pre_build:<br/>    commands:<br/>      </strong>- echo Installing source NPM dependencies...<br/>      - cd ./stacks/tasks &amp;&amp; npm install<br/>  <strong class="mk hv">build:<br/>    commands:<br/>      </strong>- echo Testing the code<br/>      - npm test<br/>      - echo Removing dev dependencies<br/>      - rm -Rf node_modules<br/>      - npm install --production<br/>  <strong class="mk hv">post_build:<br/>    commands:<br/>      </strong>- aws cloudformation package --template-file tasks.stack.yml --s3-bucket ${Bucket} --output-template-file tasks.stack.output.yml<br/><strong class="mk hv">artifacts:<br/>  base-directory: </strong>'stacks/tasks'<br/>  <strong class="mk hv">type: </strong>zip<br/>  <strong class="mk hv">files:<br/>    </strong>- tasks.stack.output.yml</span></pre><p id="c00c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该代码构建导出打包的CloudFormation模板。这将在下一阶段使用。</p><h2 id="625d" class="ml kg hu bd kh mm mn mo kl mp mq mr kp js ms mt kr jw mu mv kt ka mw mx kv my dt translated">任务堆栈阶段</h2><p id="493c" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">这个阶段改变(创建/更新)任务堆栈。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="21d6" class="ml kg hu mk b fv nd ne l nf ng">- <strong class="mk hv">Name: </strong>TasksStack<br/>  <strong class="mk hv">Actions:<br/>    </strong>- <strong class="mk hv">Name: </strong>CreateChangeSet<br/>      <strong class="mk hv">InputArtifacts:<br/>        </strong>- <strong class="mk hv">Name: </strong>TasksOutput<br/>      <strong class="mk hv">ActionTypeId:<br/>        Category: </strong>Deploy<br/>        <strong class="mk hv">Owner: </strong>AWS<br/>        <strong class="mk hv">Version: </strong>1<br/>        <strong class="mk hv">Provider: </strong>CloudFormation<br/>      <strong class="mk hv">Configuration:<br/>        TemplatePath: </strong>"TasksOutput::tasks.stack.output.yml"<br/>        <strong class="mk hv">ActionMode: </strong>CHANGE_SET_REPLACE<br/>        <strong class="mk hv">Capabilities: </strong>CAPABILITY_NAMED_IAM<br/>        <strong class="mk hv">RoleArn: </strong>!GetAtt CloudFormationRole.Arn<br/>        <strong class="mk hv">StackName: </strong>!Sub "${AWS::StackName}-tasks-prod"<br/>        <strong class="mk hv">ChangeSetName: </strong>!Sub "${AWS::StackName}-tasks-prod-cs"<br/>      <strong class="mk hv">RunOrder: </strong>1<br/>    - <strong class="mk hv">Name: </strong>ExecuteChangeSet<br/>      <strong class="mk hv">InputArtifacts:<br/>        </strong>- <strong class="mk hv">Name: </strong>TasksOutput<br/>      <strong class="mk hv">ActionTypeId:<br/>        Category: </strong>Deploy<br/>        <strong class="mk hv">Owner: </strong>AWS<br/>        <strong class="mk hv">Version: </strong>1<br/>        <strong class="mk hv">Provider: </strong>CloudFormation<br/>      <strong class="mk hv">Configuration:<br/>        ActionMode: </strong>CHANGE_SET_EXECUTE<br/>        <strong class="mk hv">Capabilities: </strong>CAPABILITY_NAMED_IAM<br/>        <strong class="mk hv">RoleArn: </strong>!GetAtt CloudFormationRole.Arn<br/>        <strong class="mk hv">StackName: </strong>!Sub "${AWS::StackName}-tasks-prod"<br/>        <strong class="mk hv">ChangeSetName: </strong>!Sub "${AWS::StackName}-tasks-prod-cs"<br/>      <strong class="mk hv">RunOrder: </strong>2</span></pre><p id="f2f5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个舞台有两个动作。</p><p id="06f7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第一个操作创建CloudFormation变更集。您可以看到输入工件是任务包阶段的输出工件。看一下<code class="eh mh mi mj mk b">TemplatePath</code>，它来自CodeBuild包命令。</p><p id="c00d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第二个动作执行变更堆栈的CloudFormation变更集。</p><h2 id="3431" class="ml kg hu bd kh mm mn mo kl mp mq mr kp js ms mt kr jw mu mv kt ka mw mx kv my dt translated">API包和API堆栈阶段</h2><p id="0c45" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">这些阶段与任务阶段完全相同。他们打包Lambda &amp; CloudFormation模板，然后创建CloudFormation变更集，最后变更该变更集。</p><h2 id="8bb9" class="ml kg hu bd kh mm mn mo kl mp mq mr kp js ms mt kr jw mu mv kt ka mw mx kv my dt translated">UI堆栈阶段</h2><p id="d027" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">UI堆栈阶段以相反的顺序做事情。而不是构建、测试和上传代码，然后改变堆栈。它改变堆栈，然后构建、测试和上传代码。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="d184" class="ml kg hu mk b fv nd ne l nf ng">- <strong class="mk hv">Name: </strong>UI<br/>  <strong class="mk hv">Actions:<br/>    </strong>- <strong class="mk hv">Name: </strong>Stack<br/>      <strong class="mk hv">InputArtifacts:<br/>        </strong>- <strong class="mk hv">Name: </strong>GitSource<br/>      <strong class="mk hv">ActionTypeId:<br/>        Category: </strong>Deploy<br/>        <strong class="mk hv">Owner: </strong>AWS<br/>        <strong class="mk hv">Version: </strong>1<br/>        <strong class="mk hv">Provider: </strong>CloudFormation<br/>      <strong class="mk hv">Configuration:<br/>        TemplatePath: </strong>"GitSource::stacks/ui/ui.stack.yml"<br/>        <strong class="mk hv">ActionMode: </strong>CREATE_UPDATE<br/>        <strong class="mk hv">Capabilities: </strong>CAPABILITY_NAMED_IAM<br/>        <strong class="mk hv">RoleArn: </strong>!GetAtt CloudFormationRole.Arn<br/>        <strong class="mk hv">StackName: </strong>!Sub "${AWS::StackName}-ui-prod"<br/>        <strong class="mk hv">ParameterOverrides: </strong>!Sub |<br/>          {<br/>            "Domain": "${Domain}",<br/>            "TLD" : "${TLD}"<br/>          }<br/>      <strong class="mk hv">RunOrder: </strong>1<br/>    - <strong class="mk hv">Name: </strong>Deploy<br/>      <strong class="mk hv">ActionTypeId:<br/>        Category: </strong>Build<br/>        <strong class="mk hv">Owner: </strong>AWS<br/>        <strong class="mk hv">Provider: </strong>CodeBuild<br/>        <strong class="mk hv">Version: </strong>1<br/>      <strong class="mk hv">Configuration:<br/>        ProjectName: </strong>!Ref UICodeBuildProd<br/>      <strong class="mk hv">InputArtifacts:<br/>        </strong>- <strong class="mk hv">Name: </strong>GitSource<br/>      <strong class="mk hv">RunOrder: </strong>2</span></pre><p id="5e5c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第一个操作改变了CloudFormation堆栈，并创建了我们在下一个操作中需要的S3桶。</p><p id="dcf9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第二个动作执行将代码上传到S3桶的代码构建，从而部署静态网站。</p><p id="0b6a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是代码构建<code class="eh mh mi mj mk b">buildspec.yml</code>。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="0fda" class="ml kg hu mk b fv nd ne l nf ng"><strong class="mk hv">version: </strong>0.1<br/><strong class="mk hv">phases:<br/>  install:<br/>    commands:<br/>  pre_build:<br/>    commands:<br/>  build:<br/>    commands:<br/>      </strong>- aws s3 sync stacks/ui/www "s3://$(aws cloudformation describe-stacks --stack-name ${StackName} --query "Stacks[0].Outputs[0].OutputValue" --output text)" --acl bucket-owner-full-control --acl public-read --delete --cache-control "max-age=1" --exclude stacks/ui/www/assets<br/>      - aws s3 sync stacks/ui/www/assets "s3://$(aws cloudformation describe-stacks --stack-name ${StackName} --query "Stacks[0].Outputs[0].OutputValue" --output text)/assets" --acl bucket-owner-full-control --acl public-read --delete --cache-control "max-age=31536000"<br/>  <strong class="mk hv">post_build:<br/>    commands:</strong></span></pre><p id="947d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这很有意思。我们通过从堆栈中获取输出参数来获得上一步中的S3存储桶名称。以下是命令:</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="8356" class="ml kg hu mk b fv nd ne l nf ng">$(<br/>  aws cloudformation describe-stacks <br/>    --stack-name ${StackName} <br/>    --query "Stacks[0].Outputs[0].OutputValue" <br/>    --output text<br/>)</span></pre><p id="4539" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就是这样。这就是管道为我们的基础设施和代码执行CI/CD的方式。</p><p id="630c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们来看看蓝绿色的部署。</p><h1 id="c856" class="kf kg hu bd kh ki kj kk kl km kn ko kp ja kq jb kr jd ks je kt jg ku jh kv kw dt translated">蓝绿色部署</h1><p id="3841" class="pw-post-body-paragraph jj jk hu jl b jm kx iv jo jp ky iy jr js kz ju jv jw la jy jz ka lb kc kd ke hn dt translated">在我们的api CloudFormation模板中，我们有一个Lambda。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="ef02" class="ml kg hu mk b fv nd ne l nf ng"><strong class="mk hv">LambdaFunction:<br/>  Type: </strong>AWS::Serverless::Function<br/>  <strong class="mk hv">Properties:<br/>    Handler: </strong>index.handler<br/>    <strong class="mk hv">Timeout: </strong>5<br/>    <strong class="mk hv">Role: </strong>!GetAtt IamRoleLambdaExecution.Arn<br/>    <strong class="mk hv">CodeUri: </strong>./<br/>    <strong class="mk hv">Runtime: </strong>nodejs6.10<br/>    <strong class="mk hv">AutoPublishAlias: </strong>live<br/>    <strong class="mk hv">DeploymentPreference:<br/>      Type: </strong>Canary10Percent5Minutes<br/>      <strong class="mk hv">Alarms:<br/>        </strong>- !Ref 5xxAlarm<br/>        - !Ref 4xxAlarm<br/>        - !Ref LatencyAlarm<br/>    <strong class="mk hv">Environment:<br/>      Variables:<br/>        TasksSnsTopic:<br/>          Fn::ImportValue:<br/>            </strong>!Sub "${TasksStack}-SNSTopic"</span></pre><p id="ebc8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个Lambda使用了<a class="ae nh" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank">无服务器应用模型</a> (SAM)，这是一个CloudFormation转换器。</p><p id="ad96" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当在CloudFormation模板中使用SAM类型时，您需要添加转换定义。<code class="eh mh mi mj mk b"><strong class="jl hv">Transform</strong>: AWS::Serverless-2016–10–31</code>。</p><p id="97f6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我不知道为什么山姆会存在。为什么CloudFormation没有扩展到包括这些新的SAM特性？我在哪里读到过萨姆不那么啰嗦。这是唯一的原因吗？如果是这样，那也不能弥补山姆带来的分裂和混乱。只是我的2美分…</p><p id="b4ba" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">看一下<code class="eh mh mi mj mk b">DeploymentPreference</code>属性。这就是我们定义<a class="ae nh" href="https://github.com/awslabs/serverless-application-model/blob/master/docs/safe_lambda_deployments.rst" rel="noopener ugc nofollow" target="_blank">安全交通转移</a>的地方。</p><p id="6f95" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用<code class="eh mh mi mj mk b">Canary10Percent5Minutes</code>,它将10%的流量路由到新的Lambda，然后等待5分钟，如果一切正常(没有警报响起),剩余的流量将被路由，部署完成。有3种类型的流量转换。</p><ul class=""><li id="d0f5" class="ni nj hu jl b jm jn jp jq js nk jw nl ka nm ke nn no np nq dt translated"><strong class="jl hv">linearxpercentyments</strong>:新版本的流量将每隔Y分钟线性增加X个百分点。例:<code class="eh mh mi mj mk b">Linear10PercentEvery10Minutes</code>每10分钟增加10%的流量，在100分钟内完成。</li><li id="2097" class="ni nj hu jl b jm nr jp ns js nt jw nu ka nv ke nn no np nq dt translated"><strong class="jl hv">canaryx percenty minutes</strong>:X %的流量将被路由到新版本一次，在此状态下等待Y分钟，然后将100%的流量发送到新版本。有人称之为蓝/绿部署。例如:<code class="eh mh mi mj mk b">Canary10Percent15Minutes</code>将向新版本发送10%的流量，15分钟后通过向新版本发送所有流量来完成部署。</li><li id="8be6" class="ni nj hu jl b jm nr jp ns js nt jw nu ka nv ke nn no np nq dt translated"><strong class="jl hv"> AllAtOnce </strong>:这是将100%的流量即时转移到新版本。如果您希望运行运行前/后挂钩，但不希望逐步部署，这将非常有用。如果你有一个管道，你可以设置Beta/Gamma阶段来立即部署，因为在这里部署的速度比安全更重要。</li></ul><p id="c9ed" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh mh mi mj mk b">alarms</code>属性中，您可以定义CloudWatch警报，以便在流量转移时进行监控。如果这些警报中的任何一个响起，部署将被恢复。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="b6da" class="ml kg hu mk b fv nd ne l nf ng"><strong class="mk hv">Alarms:<br/>  </strong>- !Ref 5xxAlarm<br/>  - !Ref 4xxAlarm<br/>  - !Ref LatencyAlarm</span></pre><p id="11b7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的警报基于API网关流量。我们是不是遇到了太多的5xx或4xx错误，还是延迟激增？如果是这样，我们的新版本有问题，我们不想部署它。</p><p id="9db4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是警报。</p><pre class="lw lx ly lz fq mz mk na nb aw nc dt"><span id="770d" class="ml kg hu mk b fv nd ne l nf ng"><strong class="mk hv">5xxAlarm:<br/>  Type: </strong>AWS::CloudWatch::Alarm<br/>  <strong class="mk hv">DependsOn: </strong>RestApi<br/>  <strong class="mk hv">Properties:<br/>    AlarmDescription: </strong>5xx alarm for api gateway<br/>    <strong class="mk hv">Namespace: </strong>'AWS/ApiGateway'<br/>    <strong class="mk hv">MetricName: </strong>5XXError<br/>    <strong class="mk hv">Dimensions:<br/>      </strong>- <strong class="mk hv">Name: </strong>ApiName<br/>        <strong class="mk hv">Value: </strong>!Ref RestApi<br/>    <strong class="mk hv">Statistic: </strong>Sum<br/>    <strong class="mk hv">Period: </strong>'60'<br/>    <strong class="mk hv">EvaluationPeriods: </strong>'3'<br/>    <strong class="mk hv">Threshold: </strong>'10'<br/>    <strong class="mk hv">ComparisonOperator: </strong>GreaterThanOrEqualToThreshold<br/><strong class="mk hv">4xxAlarm:<br/>  Type: </strong>AWS::CloudWatch::Alarm<br/>  <strong class="mk hv">DependsOn: </strong>RestApi<br/>  <strong class="mk hv">Properties:<br/>    AlarmDescription: </strong>4xx alarm for api gateway<br/>    <strong class="mk hv">Namespace: </strong>'AWS/ApiGateway'<br/>    <strong class="mk hv">MetricName: </strong>4XXError<br/>    <strong class="mk hv">Dimensions:<br/>      </strong>- <strong class="mk hv">Name: </strong>ApiName<br/>        <strong class="mk hv">Value: </strong>!Ref RestApi<br/>    <strong class="mk hv">Statistic: </strong>Sum<br/>    <strong class="mk hv">Period: </strong>'60'<br/>    <strong class="mk hv">EvaluationPeriods: </strong>'3'<br/>    <strong class="mk hv">Threshold: </strong>'10'<br/>    <strong class="mk hv">ComparisonOperator: </strong>GreaterThanOrEqualToThreshold<br/><strong class="mk hv">LatencyAlarm:<br/>  Type: </strong>AWS::CloudWatch::Alarm<br/>  <strong class="mk hv">DependsOn: </strong>RestApi<br/>  <strong class="mk hv">Properties:<br/>    AlarmDescription: </strong>latency alarm for api gateway<br/>    <strong class="mk hv">Namespace: </strong>'AWS/ApiGateway'<br/>    <strong class="mk hv">MetricName: </strong>Latency<br/>    <strong class="mk hv">Dimensions:<br/>      </strong>- <strong class="mk hv">Name: </strong>ApiName<br/>        <strong class="mk hv">Value: </strong>!Ref RestApi<br/>    <strong class="mk hv">Statistic: </strong>Average<br/>    <strong class="mk hv">Period: </strong>'60'<br/>    <strong class="mk hv">EvaluationPeriods: </strong>'3'<br/>    <strong class="mk hv">Threshold: </strong>'25000'<br/>    <strong class="mk hv">ComparisonOperator: </strong>GreaterThanOrEqualToThreshold</span></pre><p id="9516" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就是这样。我希望你喜欢这篇文章，并从中获得一些有用的东西。</p><p id="4268" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这篇文章，请<strong class="jl hv">鼓掌</strong>。</p></div></div>    
</body>
</html>