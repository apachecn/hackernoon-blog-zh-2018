<html>
<head>
<title>Another Way to Find Max Partitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找最大分区的另一种方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/another-way-to-find-max-partitions-36005590a2a5?source=collection_archive---------23-----------------------#2018-01-09">https://medium.com/hackernoon/another-way-to-find-max-partitions-36005590a2a5?source=collection_archive---------23-----------------------#2018-01-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e2e770cf829adcf77e9421c61affb143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APvhFmzJb82rixlRy5ckaw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Numbers are always fun!</figcaption></figure><p id="53ed" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您正在组织一次黑客马拉松，并决定向获胜者提供免费云存储作为奖励。对于奖金基金，您有1024 GB的云空间。你可以给这些千兆字节，条件是在黑客马拉松中位置越高，空间越大。因为你想让尽可能多的参与者开心，你想找到最大数量的位置来颁发奖品。这意味着，如果您只有8 GB可用，您将总共有3个位置—冠军获得5 GB，亚军获得2 GB，第三名获得1 GB(另一种变化是可能的— 4、3和1gb，但8 GB的位置数仍然是3)。</p><p id="c6b6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么如何解决这个问题呢？注意(如上例所示)，对于给定数量的位置，可能有多种分布(让我们称这个数字为<em class="ke"> p </em>)。事实上，这可以归结为用不同的较小数字的和来表示一个数字，这样就有尽可能多的这些数字。对于8g，我们可以选择<em class="ke"> 8 = 7 + 1 </em>或<em class="ke"> 8 = 5 + 3 </em>的形式，但这并不是最佳形式，因为8可以表示为不仅仅是几个数字的总和——如<em class="ke"> 8 = 5 + 2 + 1 </em>。一个可以为解决这个问题增加便利的数学概念是<em class="ke">分区——引用<a class="ae kf" href="https://en.wikipedia.org/wiki/Partition_(number_theory)" rel="noopener ugc nofollow" target="_blank">维基百科</a>的</em>，一个正整数<em class="ke"> n </em>的分区，也称为整数<strong class="ji hv">T15】分区，是将<em class="ke"> n </em>写成正整数之和的一种方式。所以在我们的例子中，我们只想计算512的划分，它有尽可能多的数。为了方便讨论，我们称之为<em class="ke">最大分区</em>。</strong></p><p id="4772" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在计算机科学中，这个问题属于某种类型的问题，其解决方案使用<em class="ke">贪婪算法— </em>程序，在解决方案的每个阶段做出局部最优选择，希望找到全局最优。</p><p id="d3dc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">解决我们例子的“贪婪”方法如下:从1开始作为第一个被加数不是很自然吗？剩下的就是将7表示为最大分区，并在其上加1。但是现在将7表示为最大分区有一个约束——我们不能使用1。所以我们使用2，然后将8 - (1+2) = 5表示为最大分区。同样，我们不能用1和2。我们也不能使用3或4，因为那样我们会再次分别使用2和1。因此，我们将5表示为它本身，这样就完成了——我们现在有了最大分区，即<em class="ke"> 8 = 1 + 2 + 5 </em>。很容易看出，当我们最初想要弹出的数字(这里是<em class="ke"> 3 </em>)至少是剩余数字(这里是<em class="ke"> 5 </em>)的一半时，这个最终条件出现。我把那部分留给你去想。</p><p id="5939" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，更正式地说，考虑我们最初有两个数字<em class="ke"> n= 8 </em>和<em class="ke"> l = 1 </em>。如果<em class="ke"> n ≤ 2l </em>，<em class="ke"> </em>我们简单地把<em class="ke"> n </em>表示为它本身，否则我们跳出<em class="ke"> l </em>然后解决把<em class="ke"> n - l </em>表示为一个最大划分的子问题使得划分中的每个数都是<em class="ke">至少l+1。</em>这个子问题的<em class="ke"> l </em>的值比原问题的值大1。所以对于我们的例子(<em class="ke"> n </em>，<em class="ke"> l </em>)表示8为最大划分，我们先弹出1，然后求解子问题(<em class="ke"> n-l </em>，<em class="ke"> l+1 </em>)，即(<em class="ke"> 7 </em>，<em class="ke"> 2 </em>)。对于这个子问题，我们跳出2然后求解子问题(7 <em class="ke"> -2 </em>，<em class="ke"> 2+1 </em>)，也就是(<em class="ke"> 5 </em>，<em class="ke"> 3 </em>)。现在，由于<em class="ke"> 5 ≤ 2x3 </em>，我们只要弹出<em class="ke"> 5 </em>就大功告成了。我们现在只是将弹出的数字相加得到<em class="ke"> 8 = 1 + 2 + 5 </em>。</p><p id="f1eb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">既然我们现在已经更正式地阐明了策略，就很容易想出一个工作程序来解决我们的问题。下面是Python 3中的一个简单实现:</p><pre class="kg kh ki kj fq kk kl km kn aw ko dt"><span id="a94a" class="kp kq hu kl b fv kr ks l kt ku">def max_partition(n, l=1):<br/>    partition = []<br/>    while n &gt; 2*l:<br/>        partition.append(l)<br/>        n = n - l<br/>        l += 1<br/>    partition.append(n)<br/>    return partition</span><span id="7453" class="kp kq hu kl b fv kv ks l kt ku">print(max_partition(int(input())))</span></pre></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="7f89" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是等等——我有另一种方法。也许更好。我注意到可以表示为第一个<em class="ke"> n个</em>自然数之和的数字是特殊的。他们炫耀身份的时候不是已经<em class="ke">max-partition形态</em>了吗？！比如<em class="ke"> 6 </em>写成<em class="ke"> 6 = 1 + 2 + 3 </em>的时候不是已经是max-partition形式了吗？<em class="ke"> 10 </em>写成<em class="ke"> 10 = 1 + 2 + 3 + 4 </em>的时候不是已经是max-partition形式了吗？为了这个对话，我们称这样的号码为“高级号码”。这种见解构成了我的算法的基础。</p><p id="a74a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们是这样进行的:如果我们必须找到其最大划分的数<em class="ke"> n </em>已经是一个高级数，我们简单地用它的<em class="ke"> n = 1 + 2 + 3 + … + k </em>形式来表示它。如果它不是一个高级数，我们仍然可以找到一个<em class="ke"> k </em>，它足够大，足以使总和<em class="ke"> s = </em> <em class="ke"> 1 + 2 + 3 + … + k </em>大于<em class="ke"> n </em>(足够大，我的意思是<em class="ke"> k </em>可以使<em class="ke"> 1+ 2 + 3 + … + k </em>大于<em class="ke"> n </em>，但不能对<em class="ke"> 1 + 2 + 3 +做同样的事情由于<em class="ke"> k </em>刚好大到<em class="ke"> s </em>大于<em class="ke"> n </em>，<em class="ke"> s-n </em>将小于<em class="ke"> k </em>。所以<em class="ke"> s-n </em>将会是<em class="ke"> 1 </em>、<em class="ke"> 2 </em>、<em class="ke"> 3 </em>、…、<em class="ke"> k-1 </em>中的一个数字。如果我们从第一个<em class="ke"> k </em>自然数的和中“抽出”<em class="ke"> s-n </em>会怎么样？这将给我们<em class="ke"> s-(s-n) </em>，也就是<em class="ke"> n </em>！</em></p><p id="d06f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ke">顺便说一下，上一段的最后一个字符不是阶乘的</em>🙂。让我们想象一下目前为止我们所学的观点。通常，<a class="ae kf" href="http://mathworld.wolfram.com/FerrersDiagram.html" rel="noopener ugc nofollow" target="_blank"> Ferrers图</a>用于可视化分区，但对于我们的目的，我发现我的自定义可视化更方便:在下面的树中，顶部节点是我们希望评估其最大分区的数字。树叶是最大划分表示中的数字，当然，这些数字相加得出顶部节点上的数字。对于一个高级号码来说，一切都很好:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/57e165a40ae00fcbfbe6060314f653a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*916SSjR3bqu5mmdthoeUbA.png"/></div></figure><p id="1b11" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于不是高级的号码，我们剪切适当的分支，以便不添加通过该分支连接到顶部节点的叶子上的号码。考虑9:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff le"><img src="../Images/d30222b480a60b8ee4fbc17ce23b8785.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*D9loLo4gMUlKWfwJ6jZFiA.png"/></div></figure><p id="e04e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是8的树。请注意，我们只是在寻找数字<em class="ke">k。</em>对于8和9，它是4。由于前4个自然数的和是10，我们首先画出10的树，然后用我们想要的数字替换顶部节点中的10——这里是8。然后我们切断连接顶部节点和数字10–8 = 2的分支。对于9，这个数字是10 - 9 = 1。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/62ef61004018cef11d23476168508c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*gNEqvbhVVGfqemJjBwp0Nw.png"/></div></figure><p id="5d0c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么最大划分就是剩余叶子的总和。我希望你现在明白我的算法了。</p><p id="9e31" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一个有待发现的微妙之处是找出“刚好足够大的T2”的方法。但这是一个非常简单的计算。前<em class="ke"> k个</em>自然数之和为<em class="ke"> n = k * (k+1) / 2 </em>。对一个正的<em class="ke"> k </em>解完这个方程，我们得到<em class="ke">k =(√( 1+8 * n)-1)/2</em>。因为如果<em class="ke"> n </em>不是一个高级数，那么<em class="ke"> k </em>将是一个小数，所以我们取它的上限。这使得k足够大。</p><p id="ebdc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我想现在我已经清楚地表达了这个算法。因此，我们可以对解决方案进行编程。这是Python 3中另一个简单的实现:</p><pre class="kg kh ki kj fq kk kl km kn aw ko dt"><span id="7d82" class="kp kq hu kl b fv kr ks l kt ku">import math</span><span id="a6b5" class="kp kq hu kl b fv kv ks l kt ku">def optimal_summands(n):<br/>    k = ((1 + 8*n)**0.5 - 1) / 2<br/>    k = math.ceil(k)<br/>    summands = list(range(1, k+1))<br/>    the_sum = int(k * (k+1) / 2)<br/>    if the_sum - n &gt; 0:  # If n is not senior.<br/>        del summands[the_sum-n-1]<br/>    return summands</span><span id="3ced" class="kp kq hu kl b fv kv ks l kt ku">print(optimum_summands(int(input())))</span></pre><p id="ce5b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果我们对这两种算法进行分析，我们会发现它们都运行在<em class="ke">线性时间内，</em>即<em class="ke"> O(n) </em>。然而，<em class="ke"> O(n) </em>中隐藏的隐形常数，对于<em class="ke"> optimal_summands() </em>来说，可能比<em class="ke"> max_partition() </em>要少得多。</p><p id="d143" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我用Python做了一些简单的检查，看看哪种方法更快，结果是后一种方法的执行速度是前一种方法的三倍。我使用Python的<code class="eh lg lh li kl b">timeit</code>模块对两种算法进行计时，下面是我在Python解释器上进行的一次检查的实例:</p><pre class="kg kh ki kj fq kk kl km kn aw ko dt"><span id="b1b0" class="kp kq hu kl b fv kr ks l kt ku">&gt;&gt;&gt; from timeit import timeit<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; timeit(setup='from different_summands import optimal_summands', stmt='optimal_summands(10000)', number=100000)<br/>0.8999944160023006<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; timeit(setup='from greedy_different_summands import max_partition', stmt='max_partition(10000)', number=100000)<br/>3.161972836998757<br/>&gt;&gt;&gt;</span></pre><p id="d834" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我经常观察到，了解一些数学事实可以让一个人开发出更好的算法，或者至少更快更直观地开发出一个算法。数学洞察力通常可以极大地提高程序的运行时间。数学和计算机科学——尤其是算法研究，是很好的朋友！</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/f73d316cd2b4db0c6654a8a122209ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YtieqHKCtP37N0P5vT1sxw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image source: xkcd</figcaption></figure><p id="1c19" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你知道其他一些让后一个程序运行更快的因素，请在评论中告诉我。最后，也许贪婪并不总是好的，但数学是好的。😀</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="d39b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">顺便说一下，您可以将这1024拆分为:</p><p id="39f8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ke">1024 = 1+2+3+4+5+6+7+8+9+10+12+13+14+15+16+17+18+19+20+21+22+23+24+25+26+27+28+29+30+31+32+33+34+35+36+37+38+39+40+41+42+43+43</em></p><p id="0765" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">(注意到缺号了吗？提示:是前45个自然数的<em class="ke">之和- 1024。)</em></p><p id="b83c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当然，你的黑客马拉松必须有超过45名参与者！🙂</p><p id="b4c5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">页（page的缩写）s:我应该为此写一篇ArXiv论文吗？</p></div></div>    
</body>
</html>