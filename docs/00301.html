<html>
<head>
<title>Introducing Immer: Immutability the easy way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Immer简介:不变性是最简单的方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3?source=collection_archive---------0-----------------------#2018-01-10">https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3?source=collection_archive---------0-----------------------#2018-01-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/0f50787bedf2019515597effe5738328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKzH_VVXXPwWL1ayo5IPaw.png"/></div></div></figure><div class=""/><p id="8c0f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不可变的、结构上共享的数据结构是存储状态的一个很好的范例。尤其是在与事件源架构结合使用时。然而，这是要付出代价的。在像<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>这样没有内置不变性的语言中，从以前的状态产生一个新的状态是一项枯燥乏味的任务。为了证明这一点:仅<a class="ae ka" href="https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities" rel="noopener ugc nofollow" target="_blank">Redux-生态系统链接</a>页面就列出了67个(！)包来帮助您处理Redux中不可变的数据结构。</p><p id="ed0a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而且还是；大部分都没有解决根本问题:缺乏语言支持。例如，在ClojureScript这样的语言中,<code class="eh kb kc kd ke b">update-in</code>是一个优雅的概念，任何对应的JavaScript基本上都依赖于难看的字符串路径。这些函数容易出错，很难进行类型检查，并且需要记住另一组API函数才能提高效率。</p><p id="e198" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，如果我们停止反对这种语言，而是拥抱它呢？而不放弃持久数据结构所提供的优雅。这正是<code class="eh kb kc kd ke b">immer</code>所做的。</p><p id="1a9c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kf">提示:如果不喜欢阅读，也可以看immer </em>的 <a class="ae ka" href="https://egghead.io/lessons/redux-simplify-creating-immutable-data-trees-with-immer" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> egghead教程</em> </a> <em class="kf"/></p><h1 id="c0cd" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">生产者</h1><p id="eba0" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">Immer通过编写生产者来工作，最简单的生产者可能是这样的:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">A minimal (empty) producer will return the original state</figcaption></figure><p id="a2d9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kf">产生</em>函数有两个参数。<em class="kf">当前状态</em>和<em class="kf">生产者</em>功能。当前状态决定了我们的起点，生产者表达了需要发生在它身上的事情。生产者函数接收一个参数，即<em class="kf">草案</em>，它是您传入的当前状态的代理。您对草稿所做的任何修改都将被记录下来，并用于生成<em class="kf">下一状态</em>。在此过程中，<em class="kf">当前状态</em>将保持不变。</p><p id="81d2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为immer使用的是<strong class="je ig">结构共享</strong>，而我们上面的例子生产者没有修改任何东西，上面的下一个状态就是我们开始时的状态。</p><p id="a784" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看当我们开始在我们的生成器中修改草稿时会发生什么。请注意，producer函数不返回任何内容，唯一重要的是我们所做的更改。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">A real producer. All changes to draft are reflected in the next state, which structurally shares untouched items with the previous state</figcaption></figure><p id="a52d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们实际上看到了<em class="kf">生产</em>的过程。我们创建了一个新的状态树，其中包含一个额外的todo项。此外，第二个待办事项的状态已更改。这些是我们应用到草稿中的更改，它们很好地反映在产生的下一个状态中。</p><p id="dba7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是还有更多。清单中最后的语句很好地显示了在草稿中被修改的状态部分产生了新的对象。但是，未更改的部分在结构上与先前的状态共享。这种情况下的第一个待办事项。</p><h1 id="af0d" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">带有生产者的减速器</h1><p id="7c97" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">现在我们学习了产生一个新国家的基础知识。让我们在一个示例性Redux减少器中利用这一点。下一个要点是基于官方的购物车示例，并加载该州的一批(可能)新产品。产品作为一个数组被接收，使用reduce进行转换，然后以它们的<em class="kf"> id </em>作为键存储在一个map中。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">A typical Redux reducer</figcaption></figure><p id="bb52" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的样板部分是:</p><ol class=""><li id="aeb9" class="lt lu if je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">我们必须构造一个新的state对象，在这个对象中，基本状态被保留，新产品映射被混合进来。在这个简单的例子中，这还不算太坏，但是这个过程必须对每个动作重复，并且在我们想要修改某些东西的每个层次上重复。</li><li id="767e" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">如果缩减器不做任何事情，我们必须确保返回到现有状态</li></ol><p id="c754" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了Immer，我们只需要思考相对于当前状态我们想要做出的改变。而不需要努力实际产生下一个状态。因此，当我们在reducer中使用produce时，我们的代码就变成了:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Simplifying the reducer by using Immer</figcaption></figure><p id="beae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意到掌握<code class="eh kb kc kd ke b">RECEIVE_PRODUCTS</code>实际上在做什么变得容易多了吗？噪音已经基本消除了。还要注意，我们不处理默认情况。不改变草稿就等于返回基本状态。原减速器和新减速器的性能完全相同。</p><h1 id="c4c3" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">无附加条件</h1><p id="621f" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">通过修改临时草稿来产生下一个不可变状态的想法并不新鲜。例如immutableJS提供了一个类似的机制:<a class="ae ka" href="https://facebook.github.io/immutable-js/docs/#/Map/withMutations" rel="noopener ugc nofollow" target="_blank"> withMutations </a>。然而，Immer的最大优势在于，您不必为您的数据结构学习(或加载)一个全新的库。Immer对普通的JavaScript对象和数组进行操作。</p><p id="240d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">优势还不止于此。为了减少样板文件，ImmutableJS和许多其他方法允许您用专用方法表达深层更新(和许多其他操作)。然而，这些路径是原始字符串，不能被类型检查器验证。它们很容易出错。例如，在下面的清单中，在ImmutableJS的情况下不能推断出<code class="eh kb kc kd ke b">list</code>的类型。其他库甚至更进一步，甚至将自己的DSL融入到这些路径查询中，支持更复杂的命令，如拼接。代价是在语言中引入一种迷你语言。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Immer remains typed doing deep updates</figcaption></figure><p id="02a2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Immer没有遭受这些；它在内置的JavaScript结构上运行。任何类型检查者都能完全理解。并且修改数据是通过你已经熟悉的API来完成的；语言中固有的东西。</p><h1 id="ed60" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">自动冻结</h1><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="mh lo l"/></div></figure><p id="1775" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个酷(<a class="ae ka" href="https://apps.timwhitlock.info/emoji/tables/unicode#emoji-modal" rel="noopener ugc nofollow" target="_blank">😒</a>)Immer的特点是它会自动<a class="ae ka" href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">冻结</a>你用<code class="eh kb kc kd ke b">produce</code>创建的任何数据结构。(在开发模式下)。这样你就能得到真正不变的数据。冻结整个状态会非常昂贵，事实上Immer可以冻结更改的部分，这使得它非常有效。而且，如果你的所有状态都是由<code class="eh kb kc kd ke b">produce</code>函数产生的，那么实际结果将是你的整个状态总是被冻结的。这意味着当你试图以任何方式修改状态时，你将得到一个异常。</p><h1 id="852a" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">Currying</h1><p id="d7fa" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">好的。最后一个特性:到目前为止，我们总是用两个参数调用<code class="eh kb kc kd ke b">produce</code>,<code class="eh kb kc kd ke b">baseState</code>和<code class="eh kb kc kd ke b">producer</code>函数。但是，在某些情况下，使用部分应用程序会很方便。可以只用生产者函数调用<code class="eh kb kc kd ke b">produce</code>。这将创建一个新的函数，当它在一个状态中被传递时，该函数将执行生产者。这个新函数还接受任意数量的附加参数，并将它们传递给生成器。</p><p id="d888" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不能解析最后的句子，不要担心。归根结底，您可以通过利用currying来进一步减少reducer的样板文件:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">A curried producer (also see the earlier listing for comparison)</figcaption></figure></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><p id="3e6b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kf">好了，基本上就有了</em><a class="ae ka" href="https://github.com/mweststrate/immer" rel="noopener ugc nofollow" target="_blank"><em class="kf">Immer</em></a><em class="kf">。请随时开始使用它。但是，此时你可能想知道:这是如何工作的？那么，请继续读下去</em></p></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><h1 id="3bff" class="kg kh if bd ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld dt translated">Immer是如何工作的？</h1><p id="1389" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">嗯，两个字；1) <a class="ae ka" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">写入时复制</a>。2).代理人。让我画一幅画。</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mu"><img src="../Images/39c6cdf8c9c6ecaff79ab9e153d0d835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZ2J4iIpsm2lMG4ZoXcj3A.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">The producer’s source tree and the draft tree shadowing it</figcaption></figure><p id="e690" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">绿色的树是原始状态树。你会注意到绿树中的一些圆圈周围有蓝色边框。这些被称为<em class="kf">代理。</em>最初，当生产者开始时，只有一个这样的代理。get传递给函数的是<code class="eh kb kc kd ke b">draft</code>对象。每当您从第一个代理读取任何非原始值时，它将依次为该值创建一个代理。这意味着你最终会得到一棵代理树，它覆盖(或遮蔽)了原始的基础树。然而，到目前为止，只有您在制作程序中访问过的部分。</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/3b2046aeed4d93fc08043e718e5024ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*Lyw8BfTTS3AbdLEDtvJvnA.png"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">High level overview of the internal decisions in a proxy. Delegating to either the base tree or a cloned node of the base tree.</figcaption></figure><p id="78f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，只要您试图更改代理上的某些内容(直接或通过任何API)，它就会立即在与之相关的源树中创建一个节点的浅层副本，并设置一个标志“modified”。从现在开始，对该代理的任何读写都不会在源树中结束，而是在副本中结束。此外，到目前为止任何未修改的父对象都将被标记为“已修改”。</p><p id="f735" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当生产者最终结束时，它将遍历代理树，并且，如果代理被修改，获取副本；或者，如果没有修改，只需返回原始节点。这个过程产生一个与先前状态在结构上共享的树。这基本上就是全部了。</p><h1 id="a9ff" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">没有代理？</h1><p id="1598" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">所有最新的浏览器都有代理。但仍然不是所有地方。最值得注意的例外是微软的ie浏览器和安卓系统的React T5。对于这些目标，Immer提供了纯ES5实现。语义相同，只是慢了一点。用<code class="eh kb kc kd ke b">import produce from "immer/es5"</code>就可以用了。</p><h1 id="c8e9" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">性能？</h1><p id="b62a" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">从性能角度来看，没有真正的理由不使用Immer。如<a class="ae ka" href="https://github.com/mweststrate/immer#performance" rel="noopener ugc nofollow" target="_blank">基准</a>中所指出的；Immer大约和ImmutableJS一样快，比高效的手工减速器慢一倍。这是一个微不足道的差别。但是ES5的实现要慢得多，所以对于那些目标上非常昂贵的reducer(处理成千上万个对象的reducer)，你可能想要跳过Immer。幸运的是，Immer是完全选择加入的，你可以决定是否要使用它。</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mw"><img src="../Images/cc0d2b8d273d5d5adaf79018840ca673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06JoozsfnI0KA15rlOQPDg.png"/></div></div></figure><p id="7eb3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常的口头禅在这里成立:优化开发者体验总是比优化运行时性能更好，除非<em class="kf">通过测量</em>证明你需要做其他事情。</p><h1 id="6118" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结束语</h1><p id="b959" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">Immer在Mendix 的一个研究日开始时只是一个玩代理的小实验。(在Mendix，所有开发人员都被期望每月两天提高技能，以任何他们认为合适的方式。听起来很酷？我们正在<a class="ae ka" href="https://www.mendix.com/careers/" rel="noopener ugc nofollow" target="_blank">招聘</a>。无论如何，它证明了当给开发者一点自由时，作为一个公司为OSS做贡献是多么容易。Immer在第一周已经收集了一千多颗github星星，在此之前没有任何官方声明。</p><h1 id="22f1" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="f252" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">当使用JavaScript处理不可变数据时，Immer提供了一些非常独特的特性。基本上是因为它不对抗语言，而是拥抱语言。</p><ol class=""><li id="d688" class="lt lu if je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">Immer使您能够使用标准的JavaScript数据结构和API来产生不可变的状态</li><li id="c89b" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">强类型；如果你的状态对象有一个类型，你将得到基于它的全部帮助</li><li id="be82" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">开箱即用的结构共享</li><li id="5975" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">开箱后冻结的对象</li><li id="4f40" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">显著减少样板文件。噪音更少，代码更简洁</li></ol><p id="d57a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，<a class="ae ka" href="https://apps.timwhitlock.info/emoji/tables/unicode#emoji-modal" rel="noopener ugc nofollow" target="_blank"> ✨ </a> <a class="ae ka" href="https://github.com/mweststrate/immer" rel="noopener ugc nofollow" target="_blank">明星吧</a> <a class="ae ka" href="https://apps.timwhitlock.info/emoji/tables/unicode#emoji-modal" rel="noopener ugc nofollow" target="_blank"> ✨ </a>！玩弄它，并利用它为你服务。而且，因为已经有67个以上的JavaScript不变性库…</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="mh lo l"/></div></figure><p id="ed68" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kf">鸣谢:感谢</em> <a class="mx my gr" href="https://medium.com/u/1bbc91942d0b?source=post_page-----9d73d8f71cb3--------------------------------" rel="noopener" target="_blank"> <em class="kf">亚光红宝石</em> </a> <em class="kf">的校对，感谢</em> <a class="ae ka" href="https://github.com/jkhedani" rel="noopener ugc nofollow" target="_blank"> <em class="kf">贾斯汀·赫达尼</em> </a> <em class="kf">的精彩插图</em></p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="mz lo l"/></div></figure></div></div>    
</body>
</html>