<html>
<head>
<title>Undefining the C++ Pre-processor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">取消对C++预处理器的定义</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/undefining-the-c-pre-processor-c4eeb3d06e1f?source=collection_archive---------5-----------------------#2018-01-10">https://medium.com/hackernoon/undefining-the-c-pre-processor-c4eeb3d06e1f?source=collection_archive---------5-----------------------#2018-01-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="96ee" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">世界上只有两种语言:人们抱怨的语言和没人使用的语言——比雅尼·斯特劳斯特鲁普</p></blockquote><p id="ba9a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我喜欢这句话。它解释了JavaScript和Haskell。从这个角度来看，预处理器是一门伟大的语言，因为人们经常使用它。它从未与C和C++分开考虑，但如果是的话，它将是TIOBE 上的头号语言。预处理器非常有用，而且无处不在。事实是，如果没有预处理器的参与，编写任何严肃的可移植的C++应用程序都是非常困难的。</p><blockquote class="ir is it"><p id="46bf" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">—预处理器很烂</p><p id="c289" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">我知道，对吗？这是最糟糕的。嘿，你能合并我的提交吗？我添加了一堆有用的宏。</p></blockquote><p id="dbef" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我想很多人都熟悉这种对话，如果我们不小心，20年后我们可能还会有这种对话。因为不幸的是，现有的是预处理器的唯一可取之处。唉，我的问题既不是理论的，哲学的，也不是理想主义的。</p><p id="8c35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我一点也不在乎预处理器让任何人在没有任何检查的情况下替换标识符、关键字(有人说，这是非法的，在实践中……)。我也不关心预处理器在不能正确处理逗号的情况下设法完成了。我甚至不关心包括和不包括警卫，我和<code class="eh jx jy jz ka b">#pragma</code>之间没有任何问题。有时候你必须务实。</p><p id="e592" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然而。</p><p id="45e8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我给你提供一个场景，你可能会发现这是人为的，但请原谅我。所以，假设你正在重构一个跨平台的应用程序，你决定做一些不寻常的事情，比如说，重命名一个函数。</p><p id="1d97" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">那是不可能的。从来没有，可能永远不会。</p><figure class="kb kc kd ke fq kf"><div class="bz el l di"><div class="kg kh l"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek">Renaming foo — an unsolvable problem for which there is no Millennium prize</figcaption></figure><p id="f4fd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">从根本上说，编译器和您的工具(一个工具必然是一个成熟的编译器前端)都不了解您的代码。被禁用的部分不被编译、解析、词法分析或以其他方式分析。</p><p id="87ac" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，被禁用的路径没有义务是有效的C++。这是有效的:</p><figure class="kb kc kd ke fq kf"><div class="bz el l di"><div class="kg kh l"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek">The best way to distribute your C++ application.</figcaption></figure><p id="7ea6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">因此，如果编译器考虑到预处理器的禁用路径，它可能无法获得有效的AST。更糟糕的是，预处理，顾名思义，作为一个单独的状态发生，预处理指令可能被插入到任何两个C++标记之间，包括任何表达式或语句的中间。</p><figure class="kb kc kd ke fq kf"><div class="bz el l di"><div class="kg kh l"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek">Some of these branches may form a valid C++ statement.</figcaption></figure><p id="7d96" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">另一个同样相关的问题是，编译器不可能知道什么样的<code class="eh jx jy jz ka b">#ifdef</code>和<code class="eh jx jy jz ka b">#defines</code>语句的组合应该构成一个有效的程序。</p><p id="3d07" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">例如，Qt提供了一组<code class="eh jx jy jz ka b">defines</code>,可以设置它们在编译时启用或禁用Qt的某些特性。假设你不需要一个日历小部件，你可以定义<code class="eh jx jy jz ka b">#QT_NO_CALENDAR_WIDGET</code>,这样可以得到一个更小的二进制文件。它不起作用。我怀疑它<em class="iw">从未</em>起作用。看，在某个时候Qt有大约100个这样的编译时配置选项。假设可能的构建配置的数量随着变量的数量呈指数增长。当你的程序有两个⁰⁰版本时，自动化证明是困难的，即使是在大网深云的规模上。</p><blockquote class="ir is it"><p id="d140" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">未经测试的代码是破损的代码。</p></blockquote><p id="313a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">你可能知道这句著名的格言。那么甚至没有编译过的代码呢？</p><p id="e21f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我应该指出，在平台特定的文件中放置一些平台特定的方法会导致完全相同的问题。基本上，编译器看到的代码应该是一个独立的真实来源，但是代码是支离破碎的，你对它的看法是不完整的。</p></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><h1 id="550e" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">预处理器被认为是有害的，我们能做些什么呢？</h1><p id="37e8" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">顺便说一下，不仅仅是预处理程序有缺陷。所有现代处理器显然也是如此。也许任何进行某种处理的东西都应该避免？</p><p id="b038" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">无论如何，今天让我们来看看我们能对预处理指令做些什么。</p><h2 id="8ea2" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated"><code class="eh jx jy jz ka b">1. Strongly Prefer</code>常量超过#define</h2><p id="363b" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">这个很简单，但是我仍然看到很多使用宏定义的常量。总是使用<code class="eh jx jy jz ka b">static const</code>或<code class="eh jx jy jz ka b">constexpr</code>而不是<code class="eh jx jy jz ka b">define</code>。如果您的构建过程涉及到设置一组变量，比如版本号或git hash，请考虑生成一个源文件，而不是使用defines作为构建参数。</p><h2 id="887b" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">2.函数总是比宏好</h2><figure class="kb kc kd ke fq kf"><div class="bz el l di"><div class="kg kh l"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek">Windows.h considered harmful</figcaption></figure><p id="4d95" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面的片段来自<strong class="ix hv"> Win32 API </strong>。即使对于“简单”和简短的一行程序，你也应该总是喜欢函数。</p><p id="e067" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你需要函数参数的延迟计算，使用lambda。讽刺的是，这是一个使用宏的解决方案，但这只是一个开始！</p><div class="mk ml fm fo mm mn"><a href="http://foonathan.net/blog/2017/06/27/lazy-evaluation.html" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">C++中函数参数的惰性计算</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">有时你计算一个昂贵的参数，然后函数根本不需要它！例如…</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">foonathan.net</p></div></div><div class="mw l"><div class="mx l my mz na mw nb nc mn"/></div></div></a></div><h2 id="2bdb" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">3.抽象出可移植性问题。</h2><p id="fbb1" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">在单独的文件、单独的库和方法中适当地隔离特定于平台的不愉快应该会减少代码中出现<code class="eh jx jy jz ka b">#ifdef</code>块。虽然它不能解决我上面提到的问题，但是当你不在这个平台上工作的时候，你不太可能想要重命名或者转换一个特定于平台的符号。</p><h2 id="8c95" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated"><strong class="ak"> 4。限制软件的变化数量。</strong></h2><blockquote class="ir is it"><p id="168e" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">这种依赖真的是可选的吗？</p></blockquote><p id="dc53" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你有可选的依赖项来启用你的软件的一些特性，考虑使用一个插件系统或者把你的项目分成几个部分，当依赖项丢失时，无条件地构建组件和应用程序，而不是使用<code class="eh jx jy jz ka b">#ifdef</code>来禁用一些代码路径。确保在有和没有依赖的情况下测试您的构建。为了避免麻烦，考虑永远不要让你的依赖成为可选的</p><blockquote class="ir is it"><p id="8b3f" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">这段代码真的只能在发布模式下执行吗？</p></blockquote><p id="ba91" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">避免有许多不同的调试/发布代码路径。记住，没有编译的代码就是坏代码。</p><blockquote class="ir is it"><p id="9185" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">该功能真的应该禁用吗？</p></blockquote><p id="a48a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">甚至比依赖关系更重要的是，特性在编译时不应该是可选的。为插件系统提供运行时标志。</p><h2 id="a244" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">5.首选杂注一次超过包含</h2><p id="38a1" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">现在不支持<code class="eh jx jy jz ka b">#pragma once</code>的奇葩C++编译器少之又少。使用<code class="eh jx jy jz ka b">#pragma once</code>更不容易出错，更容易也更快。和警卫吻别。</p><h2 id="55c7" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">6.喜欢更多的代码而不是更多的宏</h2><p id="67a5" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">虽然这种方法适用于每种情况，但在大多数情况下，用宏代替几个c++标记是不值得的。遵循语言的规则，不要试图过于聪明，容忍一些重复，这样可能会更易读，更易维护，你的IDE会感谢你的。</p><h2 id="901d" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">7.整理您的宏</h2><p id="2bc3" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">宏应该尽快用<code class="eh jx jy jz ka b">#undef</code>取消定义。不要让一个未记录的宏出现在头文件中。</p><p id="0be3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">宏没有限定作用域，请使用以项目名称为前缀的大写长名称。</p><p id="0217" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你使用的是第三方框架，比如Qt，它既有短宏名又有长宏名(<code class="eh jx jy jz ka b">signal</code>和<code class="eh jx jy jz ka b">QT_SIGNAL</code>)，一定要禁用前者，尤其是如果它们可能作为你的API的一部分泄漏的话。自己不要提供这么短的名字。宏名应该独立于代码的其余部分，并且不与<code class="eh jx jy jz ka b">boost::signal</code>或<code class="eh jx jy jz ka b">std::min</code>冲突</p><h2 id="a549" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">8.避免在C++语句中间放置<code class="eh jx jy jz ka b">ifdef</code>块。</h2><pre class="kb kc kd ke fq nd ka ne nf aw ng dt"><span id="f376" class="lw ku hu ka b fv nh ni l nj nk">foo( 42,<br/>#if 0<br/>  "42",<br/>#endif<br/> 42.0<br/>);</span></pre><p id="0a28" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面的代码有一些问题。它难以阅读，难以维护，并且会给<code class="eh jx jy jz ka b">clang-format</code>等工具带来问题。而且，它也碰巧坏了。</p><p id="3ad4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">相反，应该写两条不同的语句:</p><pre class="kb kc kd ke fq nd ka ne nf aw ng dt"><span id="09fd" class="lw ku hu ka b fv nh ni l nj nk">#if 0<br/>foo(42, "42", 42.0);<br/>#else<br/>foo(42, 42.0);<br/>#endif</span></pre><p id="9b49" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">您可能会发现在某些情况下很难做到这一点，但这可能是一个信号，表明您需要将代码分成更多的函数，或者更好地抽象您正在有条件编译的东西。</p><h2 id="cb00" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">9.优先选择static_assert而不是#error</h2><p id="aee2" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">简单地使用<code class="eh jx jy jz ka b">static_assert(false)</code>来使构建失败。</p></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><h1 id="dea0" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">未来过去的预处理器</h1><p id="e90e" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">虽然前面的建议适用于任何C++版本，但是如果您有足够新的编译器，有越来越多的方法可以帮助您减少每天摄入的宏。</p><h2 id="9e3a" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">1.优先选择模块而不是包含</h2><p id="02bf" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">虽然模块应该提高编译时间，但是它们也提供了一个屏障，宏不能从中泄漏。在2018年初，还没有具备该功能的生产就绪编译器，但GCC、MSVC和clang已经实现了该功能，或者正在实现该功能。</p><p id="e438" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">虽然总体上缺乏经验，但有理由希望模块将使工具更容易，更好地实现一些功能，例如自动包含与丢失的符号相对应的模块，清理不需要的模块…</p><h2 id="8641" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">2.尽可能使用if constexpr over #ifdef</h2><p id="ae88" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">当被禁用的代码路径是格式良好的(不引用未知符号)时，<code class="eh jx jy jz ka b">if constexpr</code>是比<code class="eh jx jy jz ka b">#ifdef</code>更好的选择，因为被禁用的代码路径仍然是AST的一部分，并且被编译器和您的工具检查，包括您的静态分析器和重构程序。</p><h2 id="a0b3" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">3.即使在后现代的世界里，你也可能需要求助于#ifdef，所以考虑使用后现代的。</h2><p id="f37b" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">虽然它们根本无助于解决手头的问题，<a class="ae jw" href="http://en.cppreference.com/w/cpp/experimental/feature_test" rel="noopener ugc nofollow" target="_blank">一组宏</a>正在被标准化，以检测你的编译器提供的一组标准设施。如果需要，就使用它们。我的建议是坚持使用所有编译器提供的特性。选了一条底线，坚持到底。考虑一下，将现代编译器移植到目标系统可能比用C++98编写应用程序更容易。</p><h2 id="683b" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">4.使用std::source_location，而不是__LINE__和__FILE__</h2><p id="d6f3" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">每个人都喜欢写自己的日志。现在您可以使用<a class="ae jw" href="http://en.cppreference.com/w/cpp/experimental/source_location" rel="noopener ugc nofollow" target="_blank"> std::source_location </a>用更少的宏或不用宏来完成这项工作。</p><h1 id="150c" class="kt ku hu bd kv kw nl ky kz la nm lc ld le nn lg lh li no lk ll lm np lo lp lq dt translated">走向无宏应用的漫长道路</h1><p id="6bf6" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">一些工具为一些宏的使用提供了更好的选择，但是实际上，你还是需要求助于预处理器，越早越好。但幸运的是，我们还有很多可以做的。</p><h2 id="ba7a" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">1.用编译器定义的变量替换-D</h2><p id="f6db" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated"><code class="eh jx jy jz ka b">define</code>最常见的用例之一是查询构建环境。调试/发布、目标架构、操作系统、优化…</p><p id="d6a5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们可以想象通过一个<code class="eh jx jy jz ka b">std::compiler</code>公开一组常量来公开一些构建环境变量。</p><pre class="kb kc kd ke fq nd ka ne nf aw ng dt"><span id="6c7f" class="lw ku hu ka b fv nh ni l nj nk">if constexpr(std::compiler.is_debug_build()) {  }</span></pre><p id="062d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">同样，我们可以想象在源代码中声明某种类型的<code class="eh jx jy jz ka b">extern compiler constexpr</code>变量，但是由编译器定义或覆盖。如果有一种方法来约束这些变量所能容纳的值，那么这只会比<code class="eh jx jy jz ka b">constexpr x = SOME_DEFINE;</code>有真正的好处。</p><p id="e23d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">也许是类似的东西</p><pre class="kb kc kd ke fq nd ka ne nf aw ng dt"><span id="159e" class="lw ku hu ka b fv nh ni l nj nk">enum class OS {<br/>    Linux,<br/>    Windows,<br/>    MacOsX<br/>};</span><span id="314f" class="lw ku hu ka b fv nq ni l nj nk">[[compilation_variable(OS::Linux, OS::Windows, OS::MacOsX)]]  extern constexpr int os;</span></pre><p id="8f35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我的希望是，给编译器更多关于各种配置变量是什么的信息，甚至什么样的变量组合是有效的，将导致源代码的更好的建模(以及工具和静态分析)。</p><h2 id="1a82" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">2.更多属性</h2><p id="d8e7" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">C++属性很棒，我们应该拥有更多。<code class="eh jx jy jz ka b">[[visibility]]</code>将是一个很好的起点。它可以将constexpr变量作为参数从导入切换到导出。</p><h2 id="3c34" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">3.从Rust的书里拿走一页</h2><p id="ff7b" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">Rust社区从不错过激烈宣传Rust语言优点的机会。事实上，铁锈能做很多事情。编译时配置就是其中之一。</p><figure class="kb kc kd ke fq kf"><div class="bz el l di"><div class="kg kh l"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek">Literally taken from the rust book</figcaption></figure><p id="9565" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">使用属性系统在编译单元中有条件地包含一个符号确实是一个非常有趣的想法。</p><p id="5fb6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，它是真正可读和自我记录的。第二，即使一个符号不包括在构建中，我们仍然可以尝试解析它，更重要的是，唯一的声明为编译器提供了关于实体的足够信息，以实现强大的工具、静态分析和重构。</p><p id="fe35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">考虑以下代码:</p><pre class="kb kc kd ke fq nd ka ne nf aw ng dt"><span id="2587" class="lw ku hu ka b fv nh ni l nj nk">[[static_if(std::compiler.arch() == "arm")]]<br/>void f() {}</span><span id="09c2" class="lw ku hu ka b fv nq ni l nj nk"><br/>void foo() {<br/>    if constexpr(std::compiler.arch() == "arm") {<br/>        f();<br/>    }<br/>}</span></pre><p id="dd10" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">它有一个惊人的特性:它结构良好。因为编译器知道<code class="eh jx jy jz ka b">f</code>是一个有效的实体，并且它是一个函数名，所以它可以明确地解析被丢弃的<code class="eh jx jy jz ka b">if constexpr</code>语句的主体。</p><p id="1ae2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">你可以将相同的语法应用于任何类型的C++声明，编译器将能够理解它。</p><pre class="kb kc kd ke fq nd ka ne nf aw ng dt"><span id="9808" class="lw ku hu ka b fv nh ni l nj nk">[[static_if(std::compiler.arch() == "arm")]]<br/>int x = /*...*/</span></pre><p id="9a70" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这里，编译器只能解析左侧，因为静态分析或工具不需要其余部分。</p><pre class="kb kc kd ke fq nd ka ne nf aw ng dt"><span id="f057" class="lw ku hu ka b fv nh ni l nj nk">[[static_if(std::compiler.is_debugbuild())]]<br/>class X {<br/>};</span></pre><p id="0622" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">出于静态分析的目的，我们只需要索引类名及其公共成员。</p><p id="1dde" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当然，从活动代码路径中引用一个被丢弃的声明是不良的，但是编译器可以检查它<em class="iw">永远不会</em>发生在任何有效的配置中。当然，这在计算上是不自由的，但是你可以保证所有的代码都是格式良好的。因为在Linux机器上编写代码而破坏windows版本会变得更加困难。</p><p id="8f33" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然而，这并不像听起来那么容易。如果被丢弃实体的主体包含当前编译器不知道的语法怎么办？也许是供应商扩展或一些更新的C++特性？我认为解析尽最大努力进行是合理的，当解析失败时，编译器可以跳过当前语句，并警告它不理解的源代码部分。“我无法在第110行和第130行之间重命名Foo”比“我已经重命名了Foo的一些实例”好得多。也许不是全部，祝你好运手动浏览整个项目，真的不用麻烦一个编译器，用grep就行了”。</p><h2 id="c60d" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">4.constexpr所有的东西。</h2><p id="713c" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">也许我们需要一个<code class="eh jx jy jz ka b">constexpr</code> <code class="eh jx jy jz ka b">std::chrono::system_clock::now()</code>来代替<code class="eh jx jy jz ka b">__TIME__</code></p><p id="8556" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们可能还需要一个<a class="ae jw" href="https://www.youtube.com/watch?v=rpn_5Mrrxf8" rel="noopener ugc nofollow" target="_blank">编译时随机数生成器</a>。为什么不呢？不管怎样，谁会关心可复制的构建呢？</p><h2 id="d46e" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">5.使用反射生成代码和符号</h2><p id="b897" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">元类的提议是自切片面包、模块和概念以来最好的东西。特别是<a class="ae jw" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0712r0.pdf" rel="noopener ugc nofollow" target="_blank"> P0712 </a>在许多方面都是一篇令人惊叹的论文。</p><p id="74d4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">引入的众多构造之一是<code class="eh jx jy jz ka b">declname</code>关键字，它从字符串和数字的任意序列中创建一个标识符</p><p id="6347" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><code class="eh jx jy jz ka b">int declname("foo", 42) = 0;</code>创建一个变量<code class="eh jx jy jz ka b">foo42</code>。考虑到字符串连接形成新的标识符是宏最常见的用例之一，这确实非常有趣。希望编译器能有足够的关于以这种方式创建(或引用)的符号的信息来正确地索引它们。</p><p id="3349" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">声名狼藉的<code class="eh jx jy jz ka b"><a class="ae jw" href="https://en.wikipedia.org/wiki/X_Macro" rel="noopener ugc nofollow" target="_blank">X macro</a></code>也应该在未来几年成为过去。</p><h2 id="fb60" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">6.为了摆脱宏，我们需要一种新的宏</h2><p id="9443" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">因为宏只是文本替换，所以它们参数被延迟计算。虽然我们可以使用lambda来模拟这种行为，但这相当麻烦。那么，我们能从函数的惰性求值中获益吗？</p><p id="1333" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这是我去年思考的一个话题</p><div class="mk ml fm fo mm mn"><a href="https://github.com/cor3ntin/CppInjectionReflection" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">cor 3n tin/CppInjectionReflection</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">CppInjectionReflection——c++中代码注入和反射的研究</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">github.com</p></div></div><div class="mw l"><div class="nr l my mz na mw nb nc mn"/></div></div></a></div><p id="6cc7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我的想法是使用代码注入提供的工具来创建一种新的“宏”,由于没有更好的名称，我称之为“语法宏”。基本上，如果您给一个代码片段(您可以在程序的给定点注入的一段代码)命名，并允许它接受一些参数，您就有了一个宏。而是在语法级别检查的宏(而不是预处理器提供的标记源)。</p><p id="cee3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">它是如何工作的？</p><figure class="kb kc kd ke fq kf"><div class="bz el l di"><div class="kg kh l"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek">Definition of usage of a S-Macro</figcaption></figure><p id="961e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">好吧，这里发生了什么。</p><p id="8c1a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们首先用<code class="eh jx jy jz ka b">constexpr { }</code>创建一个<code class="eh jx jy jz ka b">constexpr block</code>。这是元类提案的一部分。constexpr块是一个复合语句，其中所有变量都是<code class="eh jx jy jz ka b">constexpr</code>，没有副作用。该块的唯一目的是在编译时创建注入片段并修改声明该块的实体的属性。(<strong class="ix hv">元类</strong>是位于<strong class="ix hv"> constexpr </strong>块之上的语法糖，我认为我们实际上并不需要元类。)</p><p id="4a31" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在constexpr块中，我们定义了一个宏<code class="eh jx jy jz ka b">log</code>。请注意，宏不是函数。它们扩展为代码，它们不返回任何东西，也不存在于堆栈中。<code class="eh jx jy jz ka b">log</code>是可以限定的标识符，不能是同一范围内任何其他实体的名称。语法宏遵循与所有其他标识符相同的查找规则。</p><p id="1b0c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">他们使用<code class="eh jx jy jz ka b">-&gt;</code>注射操作器。<code class="eh jx jy jz ka b">-&gt;</code>可以用来描述所有与代码注入相关的操作，而不会与其当前的用法相冲突。在您的例子中，因为log是一个语法宏，是代码注入的一种形式，所以我们用<code class="eh jx jy jz ka b">log-&gt;(){....}</code>来定义这个宏。</p><p id="5d61" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">语法宏的主体本身是一个constexpr块，它可以包含任何可以在constexpr上下文中计算的C++表达式。</p><p id="7594" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">它可以包含0个、一个或多个由<code class="eh jx jy jz ka b">-&gt; {}</code>表示的<strong class="ix hv">注入语句</strong>。注入语句创建一个代码片段，并立即在调用点注入它，在语法宏的情况下，这是宏展开的位置。</p><p id="08f6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">一个宏既可以注入一个表达式，也可以注入0个或多个语句。注入表达式宏只能在需要表达式的地方展开，反之亦然。</p><p id="fca9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">虽然它没有类型，但它有一个由编译器决定的性质。</p><p id="9107" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">您可以将任何参数传递给语法宏，而语法宏可以传递给函数。参数在扩展之前进行计算，并且是强类型的。</p><p id="d1e1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">但是，您也可以在表达式上传递反射。假设能够反射任意的表情。表达式<code class="eh jx jy jz ka b">e</code>上的反射具有对应于<code class="eh jx jy jz ka b">decltype(e)</code>的类型。</p><p id="d2be" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">就实现而言，在上面的例子中，<code class="eh jx jy jz ka b">std::meta::expression&lt;char*&gt;</code>是一个与类型为<code class="eh jx jy jz ka b">char*</code>的表达式上的任何反射相匹配的概念。</p><p id="b251" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">评估宏的最后一个神奇之处是，表达式在扩展之前被隐式转换为它们的反射。</p><p id="bbca" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在基本层面上，我们四处移动AST节点，这与当前的反射和代码注入方法是一致的。</p><p id="09a6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，当我们注入<code class="eh jx jy jz ka b">print(-&gt;c, -&gt;(args)...)</code>时，请注意<code class="eh jx jy jz ka b">-&gt;</code>标记。将反射转换回原始表达式，然后进行计算。</p><p id="3f03" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">从调用点来看，<code class="eh jx jy jz ka b">log-&gt;("Hello %", "World");</code>看起来像一个常规的void函数调用，除了<code class="eh jx jy jz ka b">-&gt;</code>表明存在一个宏展开。</p><p id="dca9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，在求值之前将标识符作为参数传递的能力可以减少对新关键字的需要:</p><p id="3629" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在对x求值之前，<code class="eh jx jy jz ka b">std::reflexpr-&gt;(x)</code>可以扩展到__ <code class="eh jx jy jz ka b">std_reflexpr_intrasics(x)</code>。</p><h2 id="8438" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">S-Macro会完全取代预处理宏吗？</h2><p id="7e8f" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">他们没有，但他们也不打算这样做。值得注意是，因为它们必须是有效的c++且在多个点(在定义时，在扩展之前、期间和之后)被检查，所以它们主动禁止令牌汤。分别是有效C++，注入有效C++，使用有效C++作为参数。</p><p id="7e1e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这意味着它们不能注入部分语句、操作部分语句或者将任意语句作为参数。</p><p id="932b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">它们确实解决了懒惰求值和条件执行的问题。例如，你不能用它们实现<code class="eh jx jy jz ka b">foreach</code>，因为<code class="eh jx jy jz ka b">for(;;)</code>不是一个完整的语句(<code class="eh jx jy jz ka b">for(;;);</code>和<code class="eh jx jy jz ka b">for(;;){}</code>是，但它们不是很有用)。</p><p id="7535" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">关于姓名查找有很多问题。宏应该“看到”它展开的上下文吗？and参数应该知道宏的内部吗？这是声明上下文。</p><p id="e5b5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我认为限制是一件好事。如果你真的需要发明新的结构，也许语言是缺乏的，在这种情况下，写一个提议。或者你需要一个代码生成器。或者更多的抽象，或者更多的实际代码。</p><h2 id="913b" class="lw ku hu bd kv lx ly lz kz ma mb mc ld jt md me lh ju mf mg ll jv mh mi lp mj dt translated">这是真实的生活吗？</h2><p id="8709" class="pw-post-body-paragraph iu iv hu ix b iy lr ja jb jc ls je jf jt lt ji jj ju lu jm jn jv lv jq jr js hn dt translated">这是非常幻想的，绝对不是任何当前提议的一部分，但是我确实认为这是代码注入特性的逻辑发展。</p><p id="4770" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">它有点像<a class="ae jw" href="https://doc.rust-lang.org/1.10.0/book/macros.html" rel="noopener ugc nofollow" target="_blank">rust macros</a>——除了它不允许任意的语句作为参数——同时(我希望)感觉像是C++的一部分，而不是另一种具有独立语法的语言。</p></div><div class="ab cl km kn hc ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hn ho hp hq hr"><p id="44ce" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">预处理程序看起来肯定是致命的。但是你可以做很多事情来减少对它的依赖。通过提供更好的选择，C++社区可以做很多事情来降低宏的用处。</p><p id="18bc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这可能需要几十年的时间，但这是值得的。不是因为宏从根本上来说是不好的，而是因为工具越来越成为评判语言好坏的标准。</p><p id="7c0e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">因为我们迫切需要更好的工具，我们需要尽我们所能减少我们对预处理器的宿命依赖。</p><p id="d079" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><code class="eh jx jy jz ka b">#undef</code></p></div></div>    
</body>
</html>