<html>
<head>
<title>A Simplified Explanation of the “Meltdown” CPU Vulnerability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“Meltdown”CPU漏洞的简单解释</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-simplified-explanation-of-the-meltdown-cpu-vulnerability-ad316cd0f0de?source=collection_archive---------5-----------------------#2018-01-11">https://medium.com/hackernoon/a-simplified-explanation-of-the-meltdown-cpu-vulnerability-ad316cd0f0de?source=collection_archive---------5-----------------------#2018-01-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/6095ac47577bcc385e9cce82f624ca5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSsa_6LrxuwL9zrlL40giw.png"/></div></div></figure><div class=""/><p id="dcb8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我刚刚读了关于“Meltdown”CPU安全漏洞的白皮书，因为我很好奇这里到底发生了什么。白皮书详细解释了这一点，但它相当长，而且是学术性的，所以我认为一个简单的概述是合适的。</p><p id="4972" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/tagged/meltdown" rel="noopener ugc nofollow" target="_blank"> Meltdown </a>攻击是一种绕过许多现代CPU安全检查的狡猾方式，允许从未打补丁的操作系统上的任何进程读取内核模式内存。</p><p id="7f1f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章是关于它实际上是如何工作的——你可以在熔毁现场和其他地方阅读更多关于这些漏洞<a class="ae ka" href="https://meltdownattack.com/" rel="noopener ugc nofollow" target="_blank">的含义。</a></p><p id="e439" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，称这是一个“bug ”(很多人都这样认为)可能有点言过其实——CPU<a class="ae ka" href="https://hackernoon.com/tagged/cpu" rel="noopener ugc nofollow" target="_blank">的功能与广告宣传的一样。问题是有人发现了如何解读手术引起的副作用，而这些副作用本来是可以避免的。</a></p><p id="1e9a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来的内容有点技术性，但我会尽可能简单地解释。当然，我已经掩饰了细节——这里的要点只是从概念上传达它是如何工作的。</p><p id="71dc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在找到问题的真正原因之前，您需要了解几个先决条件。</p><h2 id="a7f7" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">先决条件#1 — CPU内存缓存</h2><p id="939e" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">CPU缓存是CPU上的一块内存，用于存储最近访问的数据页面。因为这些页面被直接缓存在CPU上，所以对它们的访问比一直回到主内存要快。</p><p id="1492" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当CPU从主内存中读取数据时，它会在CPU缓存中缓存该页面的副本。如果页面被缓存，下一次它需要从主存中读取时，它可以从更快的CPU上的缓存中加载值。</p><p id="bf30" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">缓存中的每个页面有4096个字节，缓存足够大，可以存储许多这样的页面(取决于CPU)</p><h2 id="170b" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">先决条件#2 —无序执行</h2><p id="bf46" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">每个CPU内核都有多个执行单元，每个执行单元都能够执行不同类型的操作。</p><p id="5948" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如:英特尔i7有17到20个执行单元——2个整数运算单元、1个除法单元、1个加载内存单元、1个存储内存单元等</p><p id="6fea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了让这些单元尽可能忙碌，CPU会提前查看即将到来的指令，并开始在不同的执行单元上执行它们，同时等待<em class="lb"> </em>当前指令完成。</p><p id="917d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lb">(这是一个过于简化的观点，但对于这个讨论来说已经足够了。实际上，指令被分解成微操作，这些微操作被分派给执行单元。</em></p><h2 id="5765" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">先决条件#3 —特权模式</h2><p id="622e" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">在任何时间点，CPU都在特权模式或非特权模式下运行。</p><ul class=""><li id="7aa9" class="lc ld if je b jf jg jj jk jn le jr lf jv lg jz lh li lj lk dt translated">内核代码以特权模式运行，可以访问所有映射内存。</li><li id="78b0" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lh li lj lk dt translated">用户代码在非特权模式下运行，如果它试图读取或写入标记为特权的内存，将会失败并出现异常。</li></ul><p id="8dd2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本上，操作系统以特权模式运行，安装的程序以非特权模式运行。</p><h2 id="78eb" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">问题是</h2><p id="05df" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">如果你考虑一下上面的内容，你会发现用户态(非特权)代码不应该能够读取内核态内存，因为CPU会抛出一个异常。</p><p id="b31b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问题在于:</p><ol class=""><li id="5a5d" class="lc ld if je b jf jg jj jk jn le jr lf jv lg jz lq li lj lk dt translated">在指令完成之前，不会执行特权模式检查。(即:不在乱序执行期间)。</li><li id="5240" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lq li lj lk dt translated">即将到来的指令的无序执行会导致可以观察到的副作用。</li></ol><h2 id="4513" class="kb kc if bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">它是这样工作的</h2><p id="43e1" class="pw-post-body-paragraph jc jd if je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">首先，攻击者分配一个由256页内存组成的内存块(即:256 * 4096字节)。这个内存块中的每个页面此时都不会被缓存，因为它从未被访问过。</p><p id="2c42" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，执行类似下面的代码序列。这被称为“发送者”:</p><ol class=""><li id="97d2" class="lc ld if je b jf jg jj jk jn le jr lf jv lg jz lq li lj lk dt translated">执行一些会抛出异常的指令(不管是什么)</li><li id="550a" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lq li lj lk dt translated">从特权内存中读取一个字节。让我们称之为“秘密”</li><li id="0452" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lq li lj lk dt translated">将密码乘以4096(缓存页面大小)</li><li id="21ca" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lq li lj lk dt translated">使用相乘的值作为分配的内存块的索引，并读取一个字节(即:从第N页读取一个字节，其中N是秘密)</li></ol><p id="0ee7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设CPU在指令1完成之前开始无序执行指令2–4，那么指令4将导致CPU上缓存一页分配的内存块。缓存的页面将与从内核模式内存中读取的字节直接相关。例如:如果秘密是21，那么分配的内存块的第21页现在将被缓存在CPU上。</p><p id="efe0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，“接收者”观察这种无序执行的副作用，以确定所读取的秘密字节。</p><ol class=""><li id="6de1" class="lc ld if je b jf jg jj jk jn le jr lf jv lg jz lq li lj lk dt translated">捕捉上面指令1抛出的异常。</li><li id="99db" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lq li lj lk dt translated">遍历分配的内存块中的每一页，然后…</li><li id="a90c" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lq li lj lk dt translated">计时从每页读取一个字节所需的时间。</li><li id="520e" class="lc ld if je b jf ll jj lm jn ln jr lo jv lp jz lq li lj lk dt translated">如果这个字节加载得很快，那么这个页面一定已经被缓存了，并且泄露了秘密。</li></ol><p id="1cc9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续上面的例子，所分配的内存块的第0页到第20页读取起来会很慢，但是第21页会快得多，所以秘密值必须是21。</p><p id="6cc3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，只要重复上面的一切，你想读取多少秘密字节。白皮书称，他们的读取速度高达500 kb/秒。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure></div></div>    
</body>
</html>