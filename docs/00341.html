<html>
<head>
<title>Reduce, Reuse, React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少、再利用、反应</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reduce-reuse-react-1cd487f16fe0?source=collection_archive---------13-----------------------#2018-01-11">https://medium.com/hackernoon/reduce-reuse-react-1cd487f16fe0?source=collection_archive---------13-----------------------#2018-01-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a002" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">初学者指南，将这一小块可重用的代码变成它自己的npm包。</h2></div><p id="7023" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">注:这是一个最初出现在</em> <a class="ae kg" href="https://www.javascriptjanuary.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> JavaScript一月</em> </a> <em class="kf">的交叉帖子。</em></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff kh"><img src="../Images/002aae8b2640ccb6a5f544da41f7a317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZK1D3GDz_ATMCHSzL2lYLw.jpeg"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Photo by <a class="ae kg" href="https://unsplash.com/photos/YzSZN3qvHeo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Gary Chan</a> on <a class="ae kg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d56c" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">背景</h1><p id="7f6e" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">不久前，在编写一个命中REST端点的React <a class="ae kg" href="https://hackernoon.com/tagged/application" rel="noopener ugc nofollow" target="_blank">应用程序</a>时，我编写了一个小工具来构建一个正确编码的Uri路径。当时我也没多想。它完成了工作，我继续前进。</p><p id="8781" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">几个月后，在进行另一个项目时，我需要类似的东西。我开始找到它并复制代码，但我不记得我最初写在哪里了。</p><p id="b5b6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我的本地文件系统和GitHub上做了大量的挖掘之后，我终于找到了它。我发誓这种事再也不会发生了。</p><h1 id="9aae" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">减少</h1><p id="1c08" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">正如我提到的，该实用程序构建了一个Uri路径。例如，给定一个资源<code class="eh lu lv lw lx b">“user”</code>和一个用户标识<code class="eh lu lv lw lx b">“123”</code>，它可能返回一个特定用户资源的路径，如下所示:<code class="eh lu lv lw lx b">"/users/123"</code>。</p><p id="f501" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">漫不经心的读者可能会说，“为什么不能把<code class="eh lu lv lw lx b">userId</code>连接到字符串<code class="eh lu lv lw lx b">"/users/"</code>的末尾，然后就到此为止呢？”可能是这样的。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="b9fd" class="mc ky hu lx b fv md me l mf mg">const resource = 'users';<br/>const userId = '123';<br/>const path = `/${resource}/${userId}`;</span></pre><p id="4786" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您可以在您母亲的墓前发誓，资源的名称或userId不包含任何需要Uri编码的字符，那就太好了——不仅是现在，而是永远。</p><p id="3acc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果<code class="eh lu lv lw lx b">userId</code>值不仅仅是数字，而是句柄，比如<code class="eh lu lv lw lx b">"bob"</code>、<code class="eh lu lv lw lx b">"jim"</code>等，会怎么样？而如果有<code class="eh lu lv lw lx b">"this&amp;that"</code>之类的手柄呢？这将产生一个无效的URL路径<code class="eh lu lv lw lx b">"/users/this&amp;that"</code>。</p><p id="5549" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者，如果用户输入他们的<code class="eh lu lv lw lx b">userId</code>为<code class="eh lu lv lw lx b">"?format=xml"</code>会怎么样？<code class="eh lu lv lw lx b">path</code>将以<code class="eh lu lv lw lx b">"/users/?format=xml"</code>结束，这可能以XML格式返回所有用户——完全不是我们所期望的。</p><p id="e5f4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以像这样解决前面例子中的Uri编码问题。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="7e8b" class="mc ky hu lx b fv md me l mf mg">const resource = encodeURIComponent('users');<br/>const userId = encodeURIComponent('123');<br/>const path = `/${resource}/${userId}`;</span></pre><p id="e3c5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完美！它工作了。但是……每次你想生成一条路径的时候，都要付出很多努力。</p><p id="1f2c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是为什么我想出了一个实用程序，你可以隐藏你的主要逻辑，并可以重复使用。它结合了非常有用但经常被误解的<code class="eh lu lv lw lx b">Array.reduce</code>方法，该方法采用一组值，并将它们缩减为单个值。在我们的例子中，我们接受一个字符串和值的数组，并将它们简化为一个字符串。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="fbf8" class="mc ky hu lx b fv md me l mf mg">const buildUriPath = (strings, ...values) =&gt; (<br/>  strings.reduce((partialUri, string, i) =&gt; (<br/>    `${partialUri}${encodeURIComponent(values[i - 1])}${string}`<br/>  ))<br/>);</span></pre><p id="2cdf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">按照这里所示方式使用它，编码每个变量的所有工作都被抽象掉了。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="8bba" class="mc ky hu lx b fv md me l mf mg">const resource = 'users';<br/>const userId = '123';<br/>const path = buildUriPath`/${resource}/${userId}`;</span></pre><p id="5ae1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">简单来说，它需要两个数组:<code class="eh lu lv lw lx b">strings</code>(字符串常量<code class="eh lu lv lw lx b">['/', '/', '']</code>)和<code class="eh lu lv lw lx b">values</code>(需要编码的模板化字符串值<code class="eh lu lv lw lx b">['users', '123']</code>)。它构造并返回一个字符串<code class="eh lu lv lw lx b">"/users/123"</code>。</p><p id="d83a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，那不完全是<em class="kf">准确。传递给它的是一个字符串数组，但我所说的值数组，实际上是可变数量的参数。我使用ES6“rest”语法将参数转换成一个值数组。</em></p><p id="c58e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们减少字符串时，字符串数组的第0个元素作为partialUri传递，迭代从第一个元素开始，依此类推。</p><p id="d359" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对<code class="eh lu lv lw lx b">buildUriPath</code>的调用后面没有括号？这是什么巫术？这被称为标记模板文字。它是我们上面使用的ES6模板文字的特殊形式，但是它允许我们用函数来处理它。</p><p id="b3aa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">记住我们不直接调用我们的代码。在将模板解析成单独的元素后，JavaScript的模板文字函数调用它。</p><p id="38c1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae kg" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式组件</a>的粉丝已经熟悉了这种语法。这是对ES6规范的一个非常强大的补充。</p><h1 id="90ea" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">再用</h1><p id="e7f9" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">所以现在我有了一个超级棒的、方便的<code class="eh lu lv lw lx b">buildUriPath</code>函数，让我们与世界分享它，这样每个人都可以使用它。但问题是...即使没有其他人想使用它，我仍然希望自己能够轻松地反复使用它。我们可以通过制作一个npm包来做到这一点。我很喜欢这个名字<code class="eh lu lv lw lx b">build-uri-path</code>，所以我希望它是可用的...的确如此。</p><p id="ad3e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我们在ES6中编写了我们的实用程序，但是这个世界仍然依赖于ES5，我们将使用Babel来为我们传输它。</p><p id="37ab" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面描述的所有内容的完整来源可以在我的<a class="ae kg" href="https://github.com/donavon/build-uri-path" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p><h1 id="b909" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">开源代码库</h1><p id="590f" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">首先创建一个GitHub帐户(如果你还没有)，然后创建一个空白回购。将其克隆到您的本地驱动器，并更改到目录中。执行<code class="eh lu lv lw lx b">npm init</code>创建一个骨架<code class="eh lu lv lw lx b">package.json</code>。务必将入口点设置为<code class="eh lu lv lw lx b">lib/index.js</code>。这将把下面的内容添加到您的<code class="eh lu lv lw lx b">package.json</code>文件中，它指示您的包的消费者最初执行什么文件。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="e64c" class="mc ky hu lx b fv md me l mf mg">"main": "lib/index.js",</span></pre><h1 id="1bf3" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">安装巴别塔</h1><p id="6433" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">我们将在ES6中编写代码，但现实是今天的浏览器并不完全支持我们编写的语法。幸运的是，有一个叫做Babel的工具可以让我们将ES6源代码转换成ES5可发布代码。</p><p id="2142" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要安装Babel，请在您选择的终端中执行以下命令。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="dfd0" class="mc ky hu lx b fv md me l mf mg">$ npm install -D babel-cli babel-preset-env</span></pre><p id="8082" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你还需要创建一个<code class="eh lu lv lw lx b">.babelrc</code>文件。这告诉巴贝尔如何变身。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="b731" class="mc ky hu lx b fv md me l mf mg">{<br/>  "presets": ["env"]<br/>}</span></pre><h1 id="2bdb" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">获取编码！</h1><p id="8ea3" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">打开你最喜欢的编辑器，用一个<code class="eh lu lv lw lx b">index.js</code>文件创建一个<code class="eh lu lv lw lx b">src</code>文件夹。这将是我们放置将被导出为<code class="eh lu lv lw lx b">default</code>的<code class="eh lu lv lw lx b">buildUriPath</code>函数的地方。</p><p id="e067" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">整个源代码看起来像这样。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="ec7b" class="mc ky hu lx b fv md me l mf mg">const buildUriPath = (strings, ...values) =&gt; (<br/>  strings.reduce((partialUri, string, i) =&gt; (<br/>    `${partialUri}${encodeURIComponent(values[i - 1])}${string}`<br/>  ))<br/>);</span><span id="148d" class="mc ky hu lx b fv mh me l mf mg">export default buildUriPath;</span></pre><h1 id="2fbe" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">建设</h1><p id="66be" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">运行<code class="eh lu lv lw lx b">npm run build</code>，您应该会看到Babel构建了一个<code class="eh lu lv lw lx b">lib/index.js</code>文件。如果你想看ES5编译的代码，可以看看这个文件。注意，它比它的ES6源代码要详细得多。这是ES6带来的语法优势。</p><p id="b35e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于较大的包，考虑使用像<a class="ae kg" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> rollup.js </a>这样的打包器，但是对于我们的小包，发布ES5代码应该没问题。</p><h1 id="03c1" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">测试</h1><p id="7566" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">作为一名开发人员，您必须通过编写大量测试向世界和您自己证明，您的代码可以在各种输入值下工作！它们对于<a class="ae kg" href="https://en.wikipedia.org/wiki/Software_regression" rel="noopener ugc nofollow" target="_blank">回归</a>也至关重要。</p><p id="f2f0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">测试本身就是一篇完整的文章。你可以在1月1日的<a class="ae kg" href="https://www.javascriptjanuary.com/" rel="noopener ugc nofollow" target="_blank">JavaScript 1月</a>文章"<a class="ae kg" href="https://www.javascriptjanuary.com/blog/but-really-what-is-a-javascript-test" rel="noopener ugc nofollow" target="_blank">中阅读更多关于<a class="ae kg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>测试的内容，但是，什么是JavaScript测试呢？</a></p><p id="a89b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，您可以通过运行<code class="eh lu lv lw lx b">npm test</code>看到我们的包通过了测试。</p><h1 id="a533" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">连续累计</h1><p id="6eda" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">你真的应该考虑建立持续集成(CI)，比如<a class="ae kg" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>或<a class="ae kg" href="https://www.travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> Travis </a>。测试将在每次推送到您的代码仓库时自动运行。当您有多个源代码贡献者时，这将有助于确保代码质量。</p><p id="d7f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，CI超出了本文的范围，但是您可以在这里找到关于<a class="ae kg" href="https://github.com/dwyl/learn-travis" rel="noopener ugc nofollow" target="_blank">设置Travis CI的相当全面的解释</a>。</p><h1 id="d4c9" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">林挺</h1><p id="fdca" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">设置一个linter，比如<a class="ae kg" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>也可以通过在编译和测试之前捕捉问题来帮助你减少错误。你可以考虑使用Airbnb 的ESLint配置。</p><h1 id="5981" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">剧本</h1><p id="bad2" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">我们需要在我们的<code class="eh lu lv lw lx b">package.json</code>文件中添加一些脚本来实现自动化。添加一个<code class="eh lu lv lw lx b">build</code>命令，允许我们手动传输我们的代码。添加一个<code class="eh lu lv lw lx b">prepublishOnly</code>钩子，这样我们就可以确保测试通过，并且每当我们执行<code class="eh lu lv lw lx b">npm publish</code>时，我们的代码都会被自动编译。</p><p id="8ec8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的脚本部分如下所示。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="3c23" class="mc ky hu lx b fv md me l mf mg">"scripts": {<br/>  "prepublishOnly": "npm test &amp;&amp; npm run build",<br/>  "build": "babel src --out-dir lib --ignore '**/*.test.js'",<br/>  "test": "eslint src &amp;&amp; jest"<br/>},</span></pre><h1 id="5355" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">类型脚本支持</h1><p id="02bc" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">如果你真的想留下深刻印象，你可以有选择地添加一个TypeScript类型定义文件(即所谓的<code class="eh lu lv lw lx b">d.ts</code>文件)，这样TypeScript用户就可以拥有一流的类型支持。</p><p id="5a9e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的例子中，只需创建文件<code class="eh lu lv lw lx b">types/build-uri-path.d.ts</code>。该文件将如下所示。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="707b" class="mc ky hu lx b fv md me l mf mg">declare module "build-uri-path" {<br/>  function buildEncodedUri(<br/>    strings: string[],<br/>    ...values: string[]<br/>   ): string;<br/>   export default buildEncodedUri;<br/>}</span></pre><p id="0711" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您还需要通过添加下面一行来引用您的<code class="eh lu lv lw lx b">package.json</code>文件中的文件。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="99a4" class="mc ky hu lx b fv md me l mf mg">"types": "types/build-uri-path.d.ts",</span></pre><p id="6d9f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">详见<a class="ae kg" href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html" rel="noopener ugc nofollow" target="_blank">打字稿文件</a>。</p><h1 id="c7cf" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">最后……发布到npm</h1><p id="95f3" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">剩下要做的就是发布到npm。但首先您必须是npm注册中心的用户。如果您没有帐户，请使用<code class="eh lu lv lw lx b">npm adduser</code>创建一个。一旦创建了npm用户，只需输入<code class="eh lu lv lw lx b">npm publish</code>。脚本将运行——测试和构建——如果成功，你将发布你的第一个npm包，我的朋友！</p><h1 id="aa09" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">反应</h1><p id="0fea" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">现在任何人都可以使用你闪亮的新包装。所以为什么我们不做第一个呢？我将使用CodeSandbox安装<code class="eh lu lv lw lx b">build-uri-path</code>，并基于使用它的组件文件夹模式编写一个简单的React应用程序。</p><p id="0b52" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">应用程序点击一个REST端点来获取一些数据。我正在使用<a class="ae kg" href="https://swapi.co/" rel="noopener ugc nofollow" target="_blank">星球大战API </a>作为我的后端。前端反应应用程序允许用户键入一个资源和一个ID。由于这些信息直接来自不可信的来源(即用户)，因此需要对它们进行编码。好在有一个npm包可以做到这一点！</p><p id="cb3e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以看到完整的应用程序，带源代码，运行在<a class="ae kg" href="https://codesandbox.io/s/7kw80l0owj" rel="noopener ugc nofollow" target="_blank"> CodeSandbox.io </a>上。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="mi mj l"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">You can see the complete app, with source code, running on <a class="ae kg" href="https://codesandbox.io/s/7kw80l0owj" rel="noopener ugc nofollow" target="_blank">CodeSandbox.io</a>.</figcaption></figure><p id="633c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">文件<code class="eh lu lv lw lx b">loadData.js</code>导入我们的<code class="eh lu lv lw lx b">buildUriPath</code>函数，并使用它来构建发送到后端REST API的路径。</p><pre class="ki kj kk kl fq ly lx lz ma aw mb dt"><span id="0e32" class="mc ky hu lx b fv md me l mf mg">import buildUriPath from 'build-uri-path';<br/>...<br/>const path = buildUriPath`/${resource}/${id}`;</span></pre><h1 id="6d30" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">结论</h1><p id="9c08" class="pw-post-body-paragraph jj jk hu jl b jm lp iv jo jp lq iy jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">您不必编写下一个React来为开源社区贡献一个包。如果你在工作中看到价值，那就把它拿出来。即使你是唯一受益者，这也是足够的理由。</p><p id="971b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但你可能会感到惊讶。其他人可能会发现它很有用，而您的微薄的小软件包可能是下一个开源轰动！</p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="8d7b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">感谢</em><a class="ae kg" href="https://twitter.com/paulbouzakis" rel="noopener ugc nofollow" target="_blank"><em class="kf">Paul Bouzakis</em></a><em class="kf">帮助打字稿部分，特别感谢</em><a class="ae kg" href="https://twitter.com/devdeprecating" rel="noopener ugc nofollow" target="_blank"><em class="kf">Renato se lenica</em></a><em class="kf">修复我的错误。；)</em></p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="f5db" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在美国运通公司工作，为美国运通工程博客写稿。在<a class="ae kg" href="http://americanexpress.io/" rel="noopener ugc nofollow" target="_blank"><em class="kf">American express . io</em></a><em class="kf">查看我的其他作品和我才华横溢的同事的作品。也可以</em> <a class="ae kg" href="https://twitter.com/donavon" rel="noopener ugc nofollow" target="_blank"> <em class="kf">在Twitter上关注我</em> </a> <em class="kf">。</em></p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="mi mj l"/></div></figure></div></div>    
</body>
</html>