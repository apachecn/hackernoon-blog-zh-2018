<html>
<head>
<title>WebAssembly, the journey — JIT Compilers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly，旅程— JIT编译器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/webassembly-the-journey-jit-compilers-dfa4081a6ffb?source=collection_archive---------12-----------------------#2018-01-12">https://medium.com/hackernoon/webassembly-the-journey-jit-compilers-dfa4081a6ffb?source=collection_archive---------12-----------------------#2018-01-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="cef6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是关于我们WebAssembly之旅的系列文章的第二部分。如果你从这篇文章开始，你可能想从<a class="ae jp" rel="noopener" href="/p/webassembly-the-journey-a069d6ea18a">那里</a>开始。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/0d1c78a87fb2e805d0b5633ba459e649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DH5f9LRFLTDgO7tsg8Bf3w.png"/></div></div></figure><p id="ef26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" rel="noopener" href="/p/webassembly-the-journey-a069d6ea18a">在上一篇文章</a>中，展示了我们测量WebAssembly的动机和概念验证，并解释了我们在Vanilla JS中的实现。为了继续理解为什么WebAssembly在理论上比JavaScript更快，我们需要先了解一点JavaScript的历史，以及是什么让它今天如此之快。</p><h1 id="242c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">一点历史</h1><p id="a017" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">JavaScript由Brendan Eich于1995年创建，目标是成为一种设计者可以轻松实现动态界面的语言，换句话说，它不是为了快速而构建的；它的创建是为了在HTML页面上舒适而直接地添加行为层。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lf"><img src="../Images/7d149c836c0b29600ce399f10de625d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qVpShj2GWvFnUaUw8TWUQ.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">When JavaScript was introduced, this was how the internet looked.</figcaption></figure><p id="1bcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最初，JavaScript是一种解释语言，使启动阶段更快，因为解释器只需要读取第一条指令，将其翻译成字节码并立即运行。对于90年代的互联网需求，JavaScript做得非常好。当应用程序开始变得更加复杂时，问题就出现了。</p><p id="f76f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在2000年的十年中，像Ajax这样的技术使web应用程序变得更加动态，2004年的Gmail和2005年的Google Maps是Ajax技术的一个趋势。这种构建web应用程序的新“方式”最终会在客户端编写更多的逻辑。在这个时候，JavaScript必须在他的性能上有一个飞跃，这发生在2008年谷歌和它的引擎V8的出现，它立即将所有的JavaScript代码编译成字节码。但是JIT编译器是如何工作的呢？</p><h1 id="7b99" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">JavaScript JIT是如何工作的？</h1><p id="0be0" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">总之，在加载JavaScript代码后，源代码被转换成一种称为抽象语法树或AST的树表示。之后，根据引擎/操作系统/平台，要么编译该代码的基线版本，要么创建字节码进行解释。</p><p id="4308" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">分析器</strong>是另一个需要观察的实体，它监视并收集代码执行数据。我将简要描述它是如何工作的，同时考虑到浏览器引擎之间的差异。</p><p id="04e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一次，一切都通过解释者；这个过程保证代码在AST生成后运行得更快。当一段代码被多次执行时，作为我们的<code class="eh lk ll lm ln b">getNextState()</code>函数，解释器失去了性能，因为它需要一遍又一遍地解释同一段代码，当这种情况发生时，分析器将这段代码标记为<strong class="it hv">热</strong>并且<strong class="it hv">基线编译器</strong>开始工作。</p><h2 id="78e5" class="lo kd hu bd ke lp lq lr ki ls lt lu km jc lv lw kq jg lx ly ku jk lz ma ky mb dt translated">基线编译器</h2><p id="810b" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">为了更好地说明JIT是如何工作的，从现在开始我们将使用下面的代码片段作为例子。</p><pre class="jr js jt ju fq mc ln md me aw mf dt"><span id="eacf" class="lo kd hu ln b fv mg mh l mi mj">function sum (x, y) {<br/>  return x + y;<br/>}</span><span id="72e7" class="lo kd hu ln b fv mk mh l mi mj">[1, 2, 3, 4, 5, '6', 7, 8, 9, 10].reduce(<br/>  (prev, curr) =&gt; sum(prev, curr),<br/>  0<br/>);</span></pre><p id="6263" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当探查器将一段代码标记为热代码时，JIT会将这段代码发送给基线编译器，后者会为这部分代码创建一个存根，同时探查器会继续收集关于这段代码使用的频率和类型的数据(以及其他数据)。当这个代码段被执行时(在我们假设的例子<code class="eh lk ll lm ln b">return x + y;</code>中)，JIT只需要再次获取这个编译过的代码段。当一个热代码以相同的方式(类似相同的类型)被调用多次时，它被标记为<strong class="it hv">热</strong>。</p><h2 id="816c" class="lo kd hu bd ke lp lq lr ki ls lt lu km jc lv lw kq jg lx ly ku jk lz ma ky mb dt translated">优化编译器</h2><p id="b97e" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">当一段代码被标记为热代码时，<strong class="it hv">优化器编译器</strong>会生成这段代码的更快版本。只有在一些假设的基础上，优化器编译器才会做出类似代码中使用的变量类型或对象形状这样的假设。在我们的例子中，我们可以说<code class="eh lk ll lm ln b">return x + y;</code>的热代码将假定<code class="eh lk ll lm ln b">x</code>和<code class="eh lk ll lm ln b">y</code>都被类型化为<code class="eh lk ll lm ln b">number</code>。</p><p id="94a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题是当这个代码遇到了这个优化编译器没有预料到的事情，在我们的例子中是<code class="eh lk ll lm ln b">sum(15, '6')</code>调用，因为<code class="eh lk ll lm ln b">y</code>是一个<code class="eh lk ll lm ln b">string</code>。当这种情况发生时，分析器认为它的假设是错误的，将所有内容都丢弃，再次返回到基本编译(或解释)版本。这个阶段被称为<strong class="it hv">去优化</strong>。有时这种情况发生得如此频繁，以至于优化版本比使用基本编译代码要慢。</p><p id="5215" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些JavaScript引擎对优化尝试的数量有一个限制，当达到这个限制时就停止优化代码。其他如V8，当它知道很有可能会优化失败时，会使用试探法阻止代码被优化。这个过程叫做<strong class="it hv">捞出</strong>。</p><p id="3e51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，总的来说，JIT编译器的阶段可以描述为:</p><ul class=""><li id="307d" class="ml mm hu it b iu iv iy iz jc mn jg mo jk mp jo mq mr ms mt dt translated">从语法上分析</li><li id="40e3" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">编制</li><li id="7de3" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">优化/去优化</li><li id="27c5" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">执行</li><li id="63fe" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">垃圾收集工</li></ul><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mz"><img src="../Images/eb60ad64bf970c7276d20abd00b60447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6eUu1Wy0xyu7dR54Pn5bQ.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Example of JIT phases on V8 by <a class="na nb gr" href="https://medium.com/u/2508e4c7a8ec?source=post_page-----dfa4081a6ffb--------------------------------" rel="noopener" target="_blank">Addy Osmani</a></figcaption></figure><p id="0c43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JIT编译器带来的所有这些进步使JavaScript比2008年在谷歌Chrome上出现之前更快，现在的应用程序更加健壮和复杂，这要归功于Javascript引擎的速度，但什么会使我们获得与JIT引入时一样的性能飞跃呢？我们将在下一篇文章中讨论它，那时我们将使用WebAssembly，以及是什么使它可能比JavaScript更快。</p><h2 id="343f" class="lo kd hu bd ke lp lq lr ki ls lt lu km jc lv lw kq jg lx ly ku jk lz ma ky mb dt translated">链接</h2><ul class=""><li id="26e1" class="ml mm hu it b iu la iy lb jc nc jg nd jk ne jo mq mr ms mt dt translated">本文葡萄牙语版本:<a class="ae jp" rel="noopener" href="/p/eef572899b5c">https://medium.com/p/eef572899b5c</a></li><li id="52bb" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">JIT编译器速成班(em inglês):<a class="ae jp" href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/" rel="noopener ugc nofollow" target="_blank">https://hacks . Mozilla . org/2017/02/a-crash-course-in-just-in-time-JIT编译器/ </a></li><li id="2831" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">JavaScript启动性能(em inglês):<a class="ae jp" rel="noopener" href="/reloading/javascript-start-up-performance-69200f43b201">https://medium . com/reloading/JavaScript-Start-up-Performance-69200 f43b 201</a></li><li id="1d2d" class="ml mm hu it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt dt translated">JavaScript再入门(JS教程):<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/A _ re-introduction _ to _ JavaScript</a></li></ul></div></div>    
</body>
</html>