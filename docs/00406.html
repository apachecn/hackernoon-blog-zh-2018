<html>
<head>
<title>Programming with JS: Bitwise Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JS编程:位运算</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/programming-with-js-bitwise-operations-393eb0745dc4?source=collection_archive---------4-----------------------#2018-01-13">https://medium.com/hackernoon/programming-with-js-bitwise-operations-393eb0745dc4?source=collection_archive---------4-----------------------#2018-01-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/36d042d788452bbc00a53c50d957f25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kd1rSwNwhDi8Hq2gn0gaHQ.jpeg"/></div></div></figure><p id="895d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一系列文章中，我们从JavaScript的角度来看不同的计算机科学主题。我们已经尝试了不同的算法，对一堆数组进行了排序。然而，回到最基本的概念总是一个好主意。</p><p id="e293" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我说基本时，我指的是它们中最基本的，1和0，也称为位。公平地说，我总是忽略位运算，因为我在日常工作中不使用它们，而且可能永远也不会使用。但是对于计算机来说，一切都取决于它们。</p><p id="1933" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理解位和位运算不会让你成为更好的JavaScript开发人员。它可能不会对你正在开发的React应用有所帮助，但通常会让你成为一名更好的软件开发人员。</p><p id="3dbb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你不需要知道所有的事情，事实上你永远也不会记得所有的事情。我在这篇文章中的目标将是涵盖一个人必须拥有的关于位和位操作的最基本的知识。</p><h1 id="ebfe" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">比特是什么？</h1><p id="6cf5" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">好的，从技术上来说，对于计算机来说，一切都是1和0。它不处理数字、字符或字符串，只使用二进制数字(位)。这个解释的简短版本是，一切都以二进制形式存储。然后，计算机使用UTF-8等编码将保存的位组合映射为字符、数字或不同的符号(ELI5版本)。</p><p id="4903" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你拥有的比特越多，排列就越多，你能代表的东西就越多。</p><p id="fcae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们以113这个数字为例。JS中获取它的二进制形式最简单的方法是这样的:<code class="eh ld le lf lg b">Number(113).toString(2)</code>。这会给我们<code class="eh ld le lf lg b">1110001</code>。知道一切都只是引擎盖下的比特，我们现在将看看我们如何操纵它们。</p><p id="9b11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很多文章都有十六进制数字的例子。这一次，我们将只看十进制和二进制数。背后的原因是，我觉得这是更直观的理解。当你有疑问时，你可以在一张纸上写下比特和所有的操作，并追踪正在发生的事情。</p><p id="e640" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另外需要注意的是，在JavaScript中没有办法直接输入二进制。如果你想将二进制数转换成十进制数，你可以使用<code class="eh ld le lf lg b">parseInt</code>函数:<code class="eh ld le lf lg b">parseInt(1111, 2) // 15</code>。</p><h1 id="4f1f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">&amp;(和)</h1><p id="3e51" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">很像我们已经在日常编程任务中使用的<code class="eh ld le lf lg b">&amp;&amp;</code>逻辑运算符，如果两个被比较的位都是1和0，那么这个运算符将返回1。它在两边取一个数(数，不是它的二进制形式)，然后逐个比较它们的位。</p><p id="7780" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们想象一下。数字<code class="eh ld le lf lg b">12</code>和<code class="eh ld le lf lg b">15</code>有<code class="eh ld le lf lg b">1100</code>和<code class="eh ld le lf lg b">1111</code>的二进制表示。让我们对这些数字使用<code class="eh ld le lf lg b">&amp;</code>运算符。如果您刚刚注销，您将再次收到<code class="eh ld le lf lg b">12</code>。奇怪，那有什么作用吗？</p><p id="c0ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的，它将<code class="eh ld le lf lg b">12</code>的每一位与<code class="eh ld le lf lg b">15</code>的相应位进行比较，由于操作者的工作方式，它再次得到<code class="eh ld le lf lg b">1100</code>，实际上是<code class="eh ld le lf lg b">12</code>。</p><p id="d73e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ld le lf lg b">&amp;</code>操作符的一个有趣的技巧是找出一个数字是奇数还是偶数。如果一个数是奇数，它的第一位将总是<code class="eh ld le lf lg b">1</code>。因此，我们可以使用<code class="eh ld le lf lg b">&amp;</code>并将该数字与<code class="eh ld le lf lg b">1</code>进行比较，因此，如果该数字是奇数，则结果总是<code class="eh ld le lf lg b">1</code>。然而，我不建议在你的实际代码库中使用它，因为它并不清楚你在做什么。</p><h1 id="4706" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">|(或)</h1><p id="2413" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">这个和<code class="eh ld le lf lg b">||</code>很像。它用于逐位比较两个二进制数，每次比较返回一个<code class="eh ld le lf lg b">1</code>，其中当比较位都是<code class="eh ld le lf lg b">0</code>时，至少有一个<code class="eh ld le lf lg b">1</code>和<code class="eh ld le lf lg b">0</code>。如果我们以前面的例子为例，使用这个操作符<code class="eh ld le lf lg b">12 | 15</code>将返回<code class="eh ld le lf lg b">15</code>。为什么这样</p><p id="a039" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ld le lf lg b">1100 | 1111</code>将为每个再次等于<code class="eh ld le lf lg b">1111</code>或<code class="eh ld le lf lg b">15</code>的比较返回一个<code class="eh ld le lf lg b">1</code>。</p><h1 id="d7c3" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">~(不是)</h1><p id="38d9" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">这是一个按位非运算。在二进制补码运算中，结果是负数。它的作用是将所有位从1转换为0，反之亦然。</p><p id="bdf6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，如果您退出<code class="eh ld le lf lg b">~15</code>，您将会看到结果是<code class="eh ld le lf lg b">-16</code>，即使这些位是正确的。这是因为在二进制补码运算中，为了得到一个数的负表示，你首先需要翻转它的位，然后加1。</p><p id="e01b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在谷歌上找到更好的解释，但这是你需要想当然的事情之一。</p><h1 id="e3da" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">^(异或)</h1><p id="51bd" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">这种运算符称为异或运算符或异或运算符。像<code class="eh ld le lf lg b">&amp;</code>和<code class="eh ld le lf lg b">|</code>运算符一样，它接受两边的数字，以不同的方式进行比较。</p><p id="b5f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它将比较相应的位，只有在只有一个<code class="eh ld le lf lg b">1</code>时才返回一个<code class="eh ld le lf lg b">1</code>。也许这不是一个很好的解释，所以让我们给出一个更直观的解释。<code class="eh ld le lf lg b">1 ^ 0</code>将回归<code class="eh ld le lf lg b">1</code>。但是<code class="eh ld le lf lg b">1 ^ 1</code>会回归<code class="eh ld le lf lg b">0</code>。</p><p id="199e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ld le lf lg b">^</code>操作符只在我们比较<code class="eh ld le lf lg b">1</code>和<code class="eh ld le lf lg b">0</code>的特定情况下返回1。</p><h1 id="c971" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">移位运算符</h1><p id="4970" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">有两个运算符处理移位— <code class="eh ld le lf lg b">&gt;&gt;</code>和<code class="eh ld le lf lg b">&lt;&lt;</code>。正如你所猜测的，它们之间的区别在于它们移动数字的位置。</p><p id="4c0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ld le lf lg b">&lt;&lt;</code>运算符将一个数的所有位移位<code class="eh ld le lf lg b">n</code>次。这里要注意的是，数字移位时出现的空格都是用0填充的。</p><p id="e4f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面,<code class="eh ld le lf lg b">&gt;&gt;</code>操作器向右移动。这与前面的移位运算符的不同之处在于，它将正数的位填充为0，负数的位填充为1。</p><p id="f031" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里需要指出的是，通常数字的第一位用来表示它的符号。如果是<code class="eh ld le lf lg b">1</code>则为负，如果是<code class="eh ld le lf lg b">0</code>则为正。因此，右移背后的原因是——它意味着保持我们正在移动的数字的符号。</p><h1 id="f4e2" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">位操作</h1><p id="a128" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">现在我们知道了操作符是做什么的，让我们看看如何利用它们来操作比特。</p><p id="6924" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们想在给定的位置设置一个位。我们希望从右边数第二个位被设置(为<code class="eh ld le lf lg b">1</code>)。这让我们想到了<strong class="je hv">面具</strong>的概念。掩码是二进制形式的数字，根据我们想要实现的目标，我们只需要将我们想要修改的位设置为<code class="eh ld le lf lg b">1</code>或<code class="eh ld le lf lg b">0</code>。我们也可以说它们被用作一个标志来定义哪些位要被改变。</p><p id="33de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想设置第一位，屏蔽将是<code class="eh ld le lf lg b">0001</code>。如果我们想要设置秒，它将是<code class="eh ld le lf lg b">0010</code>等等。</p><p id="fca3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个例子将使这一点更加清楚:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="0411" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，一切顺利。让我们看看如何清除一点——将其设置为<code class="eh ld le lf lg b">0</code>。这不会像前面的例子那么简单，因为我们需要保持所有其他位的原样。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="3fbb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的区别是，我们希望有一个充满1的掩码，并且只在我们希望清除的位置有一个<code class="eh ld le lf lg b">0</code>。然后我们使用<code class="eh ld le lf lg b">&amp;</code>操作符，它将只把需要的位置设置为<code class="eh ld le lf lg b">0</code>。</p><p id="bb95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在知道如何设置和清除位，但如果我们想翻转它呢？我们不知道该位是否被置位，但我们确实希望改变它的当前状态。这是XOR的工作。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="1c89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下使用XOR，因为将它与<code class="eh ld le lf lg b">1</code>一起使用可以保证翻转该位的值。</p><h1 id="8c1a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="dbdf" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">这篇文章的目的是覆盖位操作和操作符的基础。尽管我们仅仅触及了表面，但这足以揭开这个话题的神秘面纱，因此你可以独自冒险进入1和0的世界，进行不同类型的逐位恶作剧。</p><p id="2ea4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢您的阅读，希望这篇文章对您有所帮助。你可以帮我，按住鼓掌按钮一会儿(双关语)，把这篇文章分享给一个可能感兴趣的朋友！</p><blockquote class="ln lo lp"><p id="3537" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated"><strong class="je hv">用JS编程:</strong></p><p id="2fa1" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated"><strong class="je hv">递归</strong>:<a class="ae lu" href="https://hackernoon.com/programming-with-js-recursion-31371e2bf808" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/programming-with-js-Recursion-31371 e2bf 808</a><br/><strong class="je hv">合并排序</strong>:<a class="ae lu" rel="noopener" href="/@KondovAlexander/programming-with-js-merge-sort-deb677b777c0">https://medium . com/@ KondovAlexander/programming-with-js-Merge-Sort-deb 677 b 777 c 0</a><br/><strong class="je hv">二分搜索法</strong>:<a class="ae lu" rel="noopener" href="/@KondovAlexander/programming-with-js-binary-search-aaf86cef9cb3">https://medium . com/@</a></p></blockquote></div></div>    
</body>
</html>