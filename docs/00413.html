<html>
<head>
<title>Base recommendations for React apps.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用的基本建议。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/strategical-view-part-1-9a1da295a3c1?source=collection_archive---------11-----------------------#2018-01-13">https://medium.com/hackernoon/strategical-view-part-1-9a1da295a3c1?source=collection_archive---------11-----------------------#2018-01-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/86c72813e7fb71e4109b669821c0992c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*aE3lhlo_f9PMoth9a4IQig.png"/></div></figure></div><div class="ab cl iy iz hc ja" role="separator"><span class="jb bw bk jc jd je"/><span class="jb bw bk jc jd je"/><span class="jb bw bk jc jd"/></div><div class="hn ho hp hq hr"><h1 id="b0f5" class="jf jg hu bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">用于什么…</h1><p id="c9f9" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">几乎每个图书馆都有一个“克隆体”。您可以找到多个库来解决特定的任务。这意味着当你看到一个对<a class="ae lb" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>路由器的引用时，要确保这个库是“克隆”的，但不是Preact。</p><h1 id="1551" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">基于组件的库</h1><p id="b4dd" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">可以用React/Preact/Inferno。没关系。React是众所周知的和规范的。Preact很小，只能在生产中使用。</p><blockquote class="lh li lj"><p id="9a06" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">但这个“速度”在“现实生活”中并不重要。90%的速度问题都是app优化不好造成的，而不是一个框架。所以选择什么库没有区别(<strong class="kf hv">除了大小</strong>)。</p></blockquote><h1 id="728e" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">状态管理</h1><p id="220a" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">mobx/Redux/Flux/Kea——没关系。</p><blockquote class="lh li lj"><p id="bae9" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">“承诺中间件”允许使用承诺作为行动的有效载荷。Redux中异步的最简单解决方案。</p></blockquote><h1 id="ada3" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">样式和样式组件</h1><blockquote class="lh li lj"><p id="9f60" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">“样式组件”——设计方法。<br/><code class="eh lt lu lv lw b">styled-components</code>—React中设计样式组件的库。</p></blockquote><ul class=""><li id="c303" class="lx ly hu kf b kg ll kk lm ko lz ks ma kw mb la mc md me mf dt translated"><code class="eh lt lu lv lw b">styled-components</code> —臃肿，需要对CSS方法论有很好的理解。但是它非常强大并且有丰富的API。</li><li id="bac9" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated"><code class="eh lt lu lv lw b">glamorous</code> —类似于“样式化组件”的API，轻量级，性能良好。</li><li id="a44a" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated"><code class="eh lt lu lv lw b">radium</code> + <code class="eh lt lu lv lw b">styled-jsx</code> + <code class="eh lt lu lv lw b">glamor</code>也很酷。</li></ul><blockquote class="ml"><p id="7cb1" class="mm mn hu bd mo mp mq mr ms mt mu la ek translated">“在组件中思考，在组件中造型”。</p></blockquote><h2 id="80ed" class="mv jg hu bd jh mw mx my jl mz na nb jp ko nc nd jt ks ne nf jx kw ng nh kb ni dt translated">“样式化组件”有什么问题？</h2><ul class=""><li id="29e0" class="lx ly hu kf b kg kh kk kl ko nj ks nk kw nl la mc md me mf dt translated">有时很难覆盖你已经在使用的CSS框架。</li><li id="f7d2" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated">如果您是样式化组件的新手，您可能会将应用程序逻辑与样式直接联系起来。不正确。</li></ul><p id="0ef8" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">处理<code class="eh lt lu lv lw b">styled-components</code>时的一些建议:</p><ul class=""><li id="0159" class="lx ly hu kf b kg ll kk lm ko lz ks ma kw mb la mc md me mf dt translated">不要为应用程序中的每个组件都设计一个样式化的组件。仅将<code class="eh lt lu lv lw b">styled-components</code>用于可重复使用/通用组件。</li><li id="5a05" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated">HOCs可以节省你一些时间。</li><li id="c3cd" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated">不要混淆逻辑道具和UI道具。</li></ul><h1 id="c031" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">工具包和网络包</h1><blockquote class="lh li lj"><p id="dde1" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">查看<a class="ae lb" href="https://hackernoon.com/next-js-razzle-cra-why-you-should-use-them-for-a-next-project-a78d320de97f" rel="noopener ugc nofollow" target="_blank"><strong class="kf hv">“next . js，Razzle，CRA。为什么你应该在下一个项目中使用它们。”</strong> </a>了解为什么工具包更好的更多信息。</p></blockquote><blockquote class="ml"><p id="f9ae" class="mm mn hu bd mo mp mq mr ms mt mu la ek translated">不要从头开始写webpack.config！</p><p id="f595" class="mm mn hu bd mo mp nm nn no np nq la ek translated">没有样板，只有工具包。</p></blockquote><ul class=""><li id="135d" class="lx ly hu kf b kg nr kk ns ko nt ks nu kw nv la mc md me mf dt translated"><strong class="kf hv"> Creact-react-app </strong>，<strong class="kf hv"> Next.js </strong>，<strong class="kf hv">包裹</strong>，<strong class="kf hv">盖茨比。</strong></li><li id="7837" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated">服务器(如果有)和客户端都必须有HMR。</li></ul><blockquote class="lh li lj"><p id="f108" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated"><a class="ae lb" href="https://github.com/reyronald/awesome-toolkits" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hv">【牛逼-工具包】</strong>列表</a>。</p></blockquote><p id="6493" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">您可能错过的Webpack插件:</p><ul class=""><li id="0b4b" class="lx ly hu kf b kg ll kk lm ko lz ks ma kw mb la mc md me mf dt translated"><code class="eh lt lu lv lw b">circular-dependency-plugin</code> —检测循环依赖关系</li><li id="8b87" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated"><code class="eh lt lu lv lw b">autodll-webpack-plugin</code> —仅重新编译没有供应商的更新代码</li><li id="7811" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated"><code class="eh lt lu lv lw b">write-file-webpack-plugin</code> —将文件从内存文件系统写入真实文件系统。</li><li id="5fa8" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated"><code class="eh lt lu lv lw b">assets-webpack-plugin</code> —从编译器获取webpack统计数据</li></ul><h1 id="9ec7" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">用户界面</h1><p id="0014" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">也许，<a class="ae lb" href="https://hackernoon.com/the-coolest-react-ui-frameworks-for-your-new-react-app-ad699fffd651" rel="noopener ugc nofollow" target="_blank">这篇文章通过对不同UI框架的比较</a>可以帮助你为下一个项目选择一个框架。</p><p id="be4e" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">如果你想要一个超快的UI框架，那么选择由CSS-in-JS或inline-css库支持的框架。</p><blockquote class="lh li lj"><p id="95c2" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">蚂蚁设计和Material-UI都很棒。</p></blockquote><h1 id="4a49" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">静态分型</h1><p id="6f2d" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated"><strong class="kf hv">肯定是打字稿。</strong></p><blockquote class="lh li lj"><p id="60c6" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">Flow完全没有经过优化，缺少很多特性。MS &gt; FB <em class="hu">😉</em></p></blockquote><h1 id="a31e" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">文件夹结构</h1><p id="4c93" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">构造React/Redux项目有许多方法。请记住，这种结构可能会因您的设置而异。例如，Next.js和CRA有一些预定义的文件夹。</p><h2 id="90ae" class="mv jg hu bd jh mw nw my jl mz nx nb jp ko ny nd jt ks nz nf jx kw oa nh kb ni dt translated">“典型结构”</h2><p id="fb3f" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">没有推荐的结构。从任何简单的结构开始，并不断完善。</p><blockquote class="lh li lj"><p id="6b08" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">比较一些开源的React/Redux项目，你会发现它们之间有很大的不同。</p><p id="58b0" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">你可以使用<em class="hu">“鸭子”方法。<br/>优点:松耦合，代码清晰。缺点:不那么干。</em></p></blockquote><h1 id="1ed1" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">成分</h1><h2 id="3b70" class="mv jg hu bd jh mw nw my jl mz nx nb jp ko ny nd jt ks nz nf jx kw oa nh kb ni dt translated">组件vs纯组件vs“无状态组件”</h2><blockquote class="lh li lj"><p id="27b9" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated"><a class="ae lb" href="https://stackoverflow.com/questions/40703675/react-functional-stateless-component-purecomponent-component-what-are-the-dif" rel="noopener ugc nofollow" target="_blank">组件类型之间的差异。</a></p></blockquote><figure class="ob oc od oe fq iv"><div class="bz el l di"><div class="of og l"/></div></figure><p id="d26e" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">改变组件的类型并不能保证性能的提高。</p><h2 id="12a7" class="mv jg hu bd jh mw nw my jl mz nx nb jp ko ny nd jt ks nz nf jx kw oa nh kb ni dt translated">/组件</h2><p id="fc57" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">除了“原子”方法和其他启发式方法，没有关于构建<code class="eh lt lu lv lw b">/components</code>文件夹的实用建议。</p><blockquote class="lh li lj"><p id="63aa" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">注意:“原子”方法<strong class="kf hv">不起作用！大多数“原子”方法只会让事情变得更糟！</strong>只有<strong class="kf hv">你的团队和你</strong>真正知道如何以最佳方式构建<code class="eh lt lu lv lw b">/components</code></p></blockquote><p id="c8b1" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">最可靠的方法之一——将所有共享组件存储在<code class="eh lt lu lv lw b">/components</code>文件夹中。这对于一个中小型项目来说已经足够了。</p><blockquote class="lh li lj"><p id="6cd4" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">在开发的过程中，你会找到构建<code class="eh lt lu lv lw b">/components</code> <strong class="kf hv">的最佳方式。<strong class="kf hv">不要过早开始优化！</strong></strong></p></blockquote><h1 id="356a" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">艾滋病患者</h1><p id="bf05" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">使用离线插件。</p><h1 id="ceb8" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">埃斯林特</h1><p id="2637" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">标准代码样式是❤️.<br/>如果你关心a11y(可访问性)—添加<code class="eh lt lu lv lw b">eslint-plugin-jsx-a11y</code>。</p><blockquote class="lh li lj"><p id="ae1d" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">一些默认的StandardJS规则很烦人，比如<code class="eh lt lu lv lw b"><em class="hu">no-unused-vars</em></code>和<code class="eh lt lu lv lw b"><em class="hu">indent</em></code>。</p></blockquote><h1 id="2fa8" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">巴比伦式的城市</h1><p id="4250" class="pw-post-body-paragraph kd ke hu kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">生产中增加<code class="eh lt lu lv lw b">babel-preset-react-optimize</code>。如果你使用<code class="eh lt lu lv lw b">styled-components</code>，别忘了添加<code class="eh lt lu lv lw b">styled-components</code>插件。</p><h1 id="8f6a" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc dt translated">还原剂</h1><blockquote class="lh li lj"><p id="5904" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated"><a class="ae lb" rel="noopener" href="/statuscode/dissecting-twitters-redux-store-d7280b62c6b1">解剖Twitter的Redux Store </a>。</p></blockquote><p id="d778" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">任何应用程序中95%的状态都可以解释为:</p><figure class="ob oc od oe fq iv"><div class="bz el l di"><div class="of og l"/></div></figure><p id="c14d" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">Redux开发的主要关键是:</p><blockquote class="ml"><p id="5372" class="mm mn hu bd mo mp nm nn no np nq la ek translated">状态=内存数据库。</p><p id="4363" class="mm mn hu bd mo mp nm nn no np nq la ek translated">在状态下复制数据是可以的。[反规格化]</p></blockquote><h1 id="37c7" class="jf jg hu bd jh ji lc jk jl jm ld jo jp jq oh js jt ju oi jw jx jy oj ka kb kc dt translated">选择器</h1><blockquote class="lh li lj"><p id="6550" class="kd ke lk kf b kg ll ki kj kk lm km kn ln lo kq kr lp lq ku kv lr ls ky kz la hn dt translated">永远使用选择器！</p></blockquote><p id="2829" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">什么是“选择器”？<br/>如果你的<code class="eh lt lu lv lw b">mapStateToProps</code>看起来像:</p><figure class="ob oc od oe fq iv"><div class="bz el l di"><div class="of og l"/></div></figure><p id="1296" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">那你就错了，因为:</p><ul class=""><li id="8aee" class="lx ly hu kf b kg ll kk lm ko lz ks ma kw mb la mc md me mf dt translated">每次计算某些值的方式发生变化时，您都必须在整个应用程序中进行更改。</li><li id="9735" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated">每当你的状态结构改变时，你必须在应用程序中修改属性的路径。</li><li id="534b" class="lx ly hu kf b kg mg kk mh ko mi ks mj kw mk la mc md me mf dt translated">您将计算逻辑(<em class="lk">选择逻辑</em>)连接到容器。</li></ul><p id="34b1" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">相反:</p><figure class="ob oc od oe fq iv"><div class="bz el l di"><div class="of og l"/></div></figure></div><div class="ab cl iy iz hc ja" role="separator"><span class="jb bw bk jc jd je"/><span class="jb bw bk jc jd je"/><span class="jb bw bk jc jd"/></div><div class="hn ho hp hq hr"><p id="907b" class="pw-post-body-paragraph kd ke hu kf b kg ll ki kj kk lm km kn ko lo kq kr ks lq ku kv kw ls ky kz la hn dt translated">感谢阅读！<br/>Github:<a class="ae lb" href="https://github.com/Metnew" rel="noopener ugc nofollow" target="_blank">@ met new</a><br/>推特:<a class="ae lb" href="https://twitter.com/vladimir_metnew" rel="noopener ugc nofollow" target="_blank"> @vladimir_metnew </a></p><figure class="ob oc od oe fq iv"><div class="bz el l di"><div class="ok og l"/></div></figure></div></div>    
</body>
</html>