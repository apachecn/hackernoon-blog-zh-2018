<html>
<head>
<title>Why MobX?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么选择MobX？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-mobx-e0530aacd482?source=collection_archive---------9-----------------------#2018-01-14">https://medium.com/hackernoon/why-mobx-e0530aacd482?source=collection_archive---------9-----------------------#2018-01-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="3c87" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">消除国家管理的负担</h2></div><p id="49ed" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">状态管理和变更传播可以说是GUI <a class="ae kf" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>中最困难的<a class="ae kf" rel="noopener" href="/@eugenkiss/challenges-in-gui-programming-65d360466e3f">挑战</a>。许多范例承诺将我们从他们的负担中解救出来。只有少数人留下来了。其中就有<a class="ae kf" href="http://mobxjs.github.io/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>和它的风味<a class="ae kf" href="https://github.com/meteor/docs/blob/version-NEXT/long-form/tracker-manual.md#transparent-reactive-programming" rel="noopener ugc nofollow" target="_blank">透明反应式编程</a>。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/f29280253ebb6aeab86247ebf86d69ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hlj8qvb2M0oqjgk36Yz5LA.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">The MobX logo</figcaption></figure><p id="3b94" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要理解MobX的吸引力，首先理解React <a class="ae kf" rel="noopener" href="/techboi/why-react-d35dc6b2a2f3">如何革新</a> GUI编程是有帮助的。传统方法允许描述GUI的初始状态。进一步的GUI状态转换必须通过引用GUI元素和逐段突变来完成。这很容易出错，因为边缘案例很容易被遗漏。使用React，您可以在任何给定的时间点描述GUI <em class="kw">。换句话说，处理GUI状态转换，例如操作DOM，已经是过去的事情了:你的GUI代码已经变成了声明性的。</em></p><p id="ce7a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React的关键优势是使“如何”更新GUI变得透明。MobX重新应用了这个想法。不是用于GUI操作代码，而是用于状态管理和变更传播。事实上，React和MobX的结合是协同的，因为即使React很好地解决了如何更新GUI的问题，但是没有MobX，何时更新GUI仍然很麻烦。组件之间的交叉通信是最大的痛点。</p><p id="4b98" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们探索React和<a class="ae kf" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中的一个例子来说明MobX的优势:</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="91cf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个例子展示了一个非常简单的电子商务页面。这里有一个<a class="ae kf" href="https://941km8pp9o.codesandbox.io" rel="noopener ugc nofollow" target="_blank">演示</a>和它的<a class="ae kf" href="https://codesandbox.io/s/github/eugenkiss/mobx-cart-example" rel="noopener ugc nofollow" target="_blank">可实时编辑的源代码</a>。行为如下。最初，您的购物车是空的。当您点击“购买洗发水”时，您的购物车商品计数会增加一，最近购买的组件会显示“洗发水”。点击“购买肥皂”对“肥皂”做同样的事情。你也可以清空你的购物车。在真实的例子中，您将看到只有标题中的购物车被重新呈现，而不是标题本身。您还会看到，当您连续购买同一产品时，最近购买的组件不会重新呈现。</p><p id="8aa9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，未明确指定可观察变量<code class="eh kz la lb lc b">itemCount</code>和<code class="eh kz la lb lc b">lastItem</code>与组件之间的相关性。然而，组件可以正确有效地响应变化。你可能想知道这是如何实现的。答案是，MobX在组件呈现功能的执行过程中隐式地构建了一个依赖图，用于跟踪当可观察变量发生变化时哪些组件需要重新呈现。一种看待MobX的方式是从电子表格的角度来看，其中的组件是可观察变量的公式。不管“魔法”是如何工作的，也不管使用哪种类比，结果都很清楚:您从显式管理变更传播的负担中解放出来了！</p><p id="7b9a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总而言之，MobX是一个实用的、非礼仪的、高效的解决方案，可以应对状态管理和变更传播的挑战。它的工作原理是在可观察变量和组件之间建立一个运行时依赖图。同时使用React和MobX具有协同作用。我甚至可以说MobX不仅仅是一个库。它代表了一种态度，可能会从整体上改变你的编程方法。通过以下链接深入了解MobX世界:</p><ul class=""><li id="ebc6" class="ld le hu jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll dt translated"><a class="ae kf" rel="noopener" href="/@mweststrate/pure-rendering-in-the-light-of-time-and-state-4b537d8d40b1">纯粹根据时间和状态渲染</a></li><li id="3f3c" class="ld le hu jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll dt translated"><a class="ae kf" rel="noopener" href="/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254">变得完全反应式:MobX </a>的深度解读</li><li id="c42b" class="ld le hu jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll dt translated">数据绑定有什么好大惊小怪的？</li><li id="7d8f" class="ld le hu jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll dt translated"><a class="ae kf" href="https://hackernoon.com/computed-state-the-model-view-problem-9cbe8cf8486f" rel="noopener ugc nofollow" target="_blank">计算状态:模型视图问题</a></li><li id="17a8" class="ld le hu jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll dt translated"><a class="ae kf" href="http://danielearwicker.github.io/MobX_Like_React_but_for_Data.html" rel="noopener ugc nofollow" target="_blank"> MobX —类似React，但针对数据</a></li></ul></div><div class="ab cl lr ls hc lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hn ho hp hq hr"><h2 id="6846" class="ly lz hu bd ma mb mc md me mf mg mh mi js mj mk ml jw mm mn mo ka mp mq mr ms dt translated">附录</h2><p id="95b0" class="pw-post-body-paragraph jj jk hu jl b jm mt iv jo jp mu iy jr js mv ju jv jw mw jy jz ka mx kc kd ke hn dt translated">MobX的作者Michel Westrate用“管理数据流”来描述MobX的工作。</p><blockquote class="my mz na"><p id="1013" class="jj jk kw jl b jm jn iv jo jp jq iy jr nb jt ju jv nc jx jy jz nd kb kc kd ke hn dt translated">“也许，更准确的说法是MobX是一个数据流库，它使您能够以最小的努力推出自己的状态管理架构”<a class="ae kf" href="https://codeburst.io/the-curious-case-of-mobx-state-tree-7b4e22d461f" rel="noopener" target="_blank"> <em class="hu">来源</em> </a></p></blockquote><p id="adda" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文的上下文中，“管理数据流”和“状态管理和变更传播”是等价的。</p><p id="0495" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章重点介绍了MobX和React的用法。值得一提的是，MobX与React没有任何关系——MobX是一个独立的库。例如，它被成功地用于角形项目中。甚至还有GUI编程范围之外的用法。</p><p id="443b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">文章<a class="ae kf" href="https://www.andrewhfarmer.com/component-communication" rel="noopener ugc nofollow" target="_blank">8 React组件通信的无流量策略</a>很好地概述了在没有MobX的React中组件通信的不同方法。</p><p id="18e8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我没有忘记房间里的大象和它的味道。这是另一篇文章的主题。无论如何，对于好奇的人来说，已经有相当多的比较文章了。我也没有提到MobX状态树。主要是因为我还没用过。这似乎是一个可怕的项目，虽然！</p><p id="6f5f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章已经<a class="ae kf" href="https://jobs.zalando.com/tech/blog/why-mobx/" rel="noopener ugc nofollow" target="_blank">发表在Zalando Tech博客</a>上了！</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ne ky l"/></div></figure></div></div>    
</body>
</html>