<html>
<head>
<title>Crypto Curry with Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">秘制咖喱配长生不老药</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/crypto-curry-with-elixir-1c98a8b5f23?source=collection_archive---------12-----------------------#2018-01-14">https://medium.com/hackernoon/crypto-curry-with-elixir-1c98a8b5f23?source=collection_archive---------12-----------------------#2018-01-14</a></blockquote><div><div class="eg hj hk hl hm hn"/><div class="ho hp hq hr hs"><div class=""/><div class=""><h2 id="36d4" class="pw-subtitle-paragraph is hu hv bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj el translated">(更多)功能性酏剂— 1</h2></div><figure class="jl jm jn jo fr jp ff fg paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="ff fg jk"><img src="../Images/0f6f523c7e0d3ae8d75799155f9fa224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xMDR7lGxCe1MI1XR_mJ0w.jpeg"/></div></div></figure><p id="0760" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">如果你(像我一样)从面向对象语言开始接触Elixir，那么像<strong class="jy hw">curry、函数组合和无指针函数</strong>这样的概念可能不是很熟悉。其中一些默认情况下不适用于酏剂。但是它们是<strong class="jy hw">通用函数式编程(FP)概念</strong>的一部分，值得探索。</p><p id="efc1" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">我从一本同事推荐的免费书籍开始:<a class="ae ks" href="https://drboolean.gitbooks.io/mostly-adequate-guide/" rel="noopener ugc nofollow" target="_blank">弗里斯比教授的《函数式编程基本指南》</a>。我会把它推荐给任何开始接触函数式编程的人。它使用了<a class="ae ks" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>和一些库来举例说明这些概念。然而，JS并不是我的主要语言，所以我很想知道它们是如何应用于Elixir的。</p><p id="100f" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">如今，任何事情都与加密货币有关。为了跟上潮流，让我们建立一个小的加密价格检查器。然后我们将使用FP概念重构它。</p><h1 id="5c8d" class="kt ku hv bd kv kw kx ky kz la lb lc ld jb le jc lf je lg jf lh jh li ji lj lk dt translated">初始实施</h1><figure class="jl jm jn jo fr jp"><div class="bz em l di"><div class="ll lm l"/></div></figure><p id="a519" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">public函数将英镑金额作为唯一的参数。它输出你可以购买的加密硬币的数量。</p><p id="7102" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">示例:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="b2de" class="ls ku hv lo b fw lt lu l lv lw">buy_crypto_with_gbp(2000) =&gt;<br/>[<br/>  BTC: 0.18983617051918897,<br/>  ETH: 1.9337893873932355,<br/>  LTC: 10.66955239648603<br/>]</span></pre><p id="f829" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated"><code class="ei lx ly lz lo b">Support</code>模块的作用是与外部API通信并返回汇率。你可以在<a class="ae ks" href="https://github.com/iacobson/blog_crypto_curry/blob/master/lib/support.ex" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到实现。它公开了两个公共函数:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="3fe4" class="ls ku hv lo b fw lt lu l lv lw"># exchange rate between 2 currencies<br/>exchange_rate("USD", "GBP") =&gt; 0.7463 </span><span id="2af0" class="ls ku hv lo b fw ma lu l lv lw"># exchange rate between crypto and USD<br/>list_crypto_usd() =&gt; [BTC: 14256.67, ETH: 1371.76, LTC: 262.51]</span></pre><p id="a4ca" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">上面的代码中有几个简单的动作:</p><ul class=""><li id="7167" class="mb mc hv jy b jz ka kc kd kf md kj me kn mf kr mg mh mi mj dt translated">获取3种加密货币的美元价格列表</li><li id="3a87" class="mb mc hv jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated">获取两种货币之间的汇率</li><li id="c9dc" class="mb mc hv jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated">将加密价格列表从美元转换为英镑。</li><li id="a72f" class="mb mc hv jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated">映射每个加密硬币的数量</li></ul><p id="4c40" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">挑战在于使用currying、composing和pointfree的功能概念重构上面的代码。</p><h1 id="0c9f" class="kt ku hv bd kv kw kx ky kz la lb lc ld jb le jc lf je lg jf lh jh li ji lj lk dt translated">咖喱，作曲，免费</h1><p id="bda7" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">首先，我必须说，那些概念不是现成的灵丹妙药。我们可以自己实现其中的一些，但是使用这个神奇的包更安全也更容易:<a class="ae ks" href="https://github.com/expede/quark" rel="noopener ugc nofollow" target="_blank"> Quark </a>。你可能会说，我们已经可以用管道<code class="ei lx ly lz lo b">|&gt;</code>操作符在Elixir中组合函数了。听我说，我们要用的作曲略有不同。在mix文件中添加夸克包，并在模块顶部添加<code class="ei lx ly lz lo b">use Quark</code>。</p><h2 id="46b6" class="ls ku hv bd kv mu mv mw kz mx my mz ld kf na nb lf kj nc nd lh kn ne nf lj ng dt translated">Currying</h2><p id="1011" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">是调用带多个参数的函数的能力，一次一个参数。每次它将返回一个新的函数，直到应用最后一个参数并返回结果。</p><p id="8348" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">Quark为私有函数定义了与<code class="ei lx ly lz lo b">defcurry</code>或<code class="ei lx ly lz lo b">defcurryp</code>的curry。</p><p id="2db0" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">让我们从确定美元对英镑的汇率开始。在我们的<code class="ei lx ly lz lo b">Support.exchange_rate/2</code>函数周围添加一个包装器:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="e270" class="ls ku hv lo b fw lt lu l lv lw">defcurry exchange_rate(from, to) do<br/>    Support.exchange_rate(from, to)<br/>end</span></pre><p id="e786" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">现在，您可以开始将参数一个接一个地应用到我们的新函数中。您可以将部分结果(这是一个函数)赋给变量。或者它可以成为一个新的函数定义:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="3955" class="ls ku hv lo b fw lt lu l lv lw"># apply arguments<br/>exchange_rate.("USD").("GBP") =&gt; 0.7463</span><span id="7d16" class="ls ku hv lo b fw ma lu l lv lw"># assign resulting function to a variable<br/>from_usd = exchange_rate.("USD") =&gt; #Function&lt;5.65603100/1 in CryptoCurry.exchange_rate/0&gt;</span><span id="3033" class="ls ku hv lo b fw ma lu l lv lw">from_usd.("GBP") =&gt; 0.7463</span><span id="6803" class="ls ku hv lo b fw ma lu l lv lw"># new function definition<br/>def exchange_rate_from_usd do<br/>  exchange_rate().("USD")<br/>end</span><span id="b2e4" class="ls ku hv lo b fw ma lu l lv lw">exchange_rate_from_usd.("GBP") =&gt; 0.7463</span></pre><p id="327a" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">下一步是将上述转换应用于我们收到的加密货币信息<code class="ei lx ly lz lo b">{BTC: 14256.67}</code>。我们使用在初始实现中定义的相同的<code class="ei lx ly lz lo b">apply_conversion/2</code>函数，但是我们只是对它进行了修改:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="566f" class="ls ku hv lo b fw lt lu l lv lw">defcurry apply_conversion(rate, {crypto, value_usd}) do<br/>    {crypto, value_usd * rate}<br/>end</span></pre><p id="79af" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">如果我们遵循与上述相同的逻辑，我们现在可以对以英镑为单位的比特币价值进行如下操作:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="ce7e" class="ls ku hv lo b fw lt lu l lv lw">apply_conversion_gbp =<br/>  apply_conversion.(exchange_rate_from_usd.("GBP")) =&gt; #Function&lt;7.34465968/1 in CryptoCurry.apply_conversion/0&gt;</span><span id="371f" class="ls ku hv lo b fw ma lu l lv lw">apply_conversion_gbp.({:BTC, 14265.67}) =&gt;<br/>{:BTC, 10646.469520999999}</span></pre><p id="c1e3" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">变得有点困惑？这就是下一个概念可能派上用场的地方。</p><h2 id="8ec6" class="ls ku hv bd kv mu mv mw kz mx my mz ld kf na nb lf kj nc nd lh kn ne nf lj ng dt translated">组成</h2><p id="901b" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">Elixir管道操作符<code class="ei lx ly lz lo b">|&gt;</code>从左侧的表达式中获取输出，并将其作为第一个参数传递给右侧的函数调用。</p><p id="73d4" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">组合非常相似，只是它将一个函数作为参数传递给另一个函数。它可以是:</p><ul class=""><li id="8e23" class="mb mc hv jy b jz ka kc kd kf md kj me kn mf kr mg mh mi mj dt translated">从右到左——数学方法——用<code class="ei lx ly lz lo b">&lt;|&gt;</code>表示</li><li id="c98d" class="mb mc hv jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated">从左到右——流动方式，如仙丹管——用<code class="ei lx ly lz lo b">&lt;~&gt;</code>表示</li></ul><p id="4175" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">让我们看看测试应用程序之外的一个小例子:</p><figure class="jl jm jn jo fr jp"><div class="bz em l di"><div class="ll lm l"/></div><figcaption class="nh ni fh ff fg nj nk bd b be z el">where rl is right to left, and lr is left to right</figcaption></figure><p id="fbfc" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">在这种情况下:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="bed1" class="ls ku hv lo b fw lt lu l lv lw">bazz_rl.("a").("b") == bazz_lr.("a").("b")</span></pre><p id="327d" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">回到加密的例子，我们将保持接近FP的书，并使用数学的方式组成。我们希望定义一个函数，它将接受加密数据并将其转换为GBP。</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="c70d" class="ls ku hv lo b fw lt lu l lv lw">def apply_conversion_gbp do<br/>  (apply_conversion() &lt;|&gt; exchange_rate_from_usd()).("GBP")<br/>end</span></pre><p id="d575" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated"><code class="ei lx ly lz lo b">apply_conversion</code>将部分应用<code class="ei lx ly lz lo b">exchange_rate_from_usd</code>作为其第一个参数。将使用<code class="ei lx ly lz lo b">"GBP"</code>属性调用结果函数。当然，结果是另一个可以用加密数据调用的函数:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="b090" class="ls ku hv lo b fw lt lu l lv lw">apply_conversion_gbp.({:BTC, 14265.67}) =&gt;<br/>{:BTC, 10646.469520999999}</span></pre><p id="9521" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">我们快到了。需要一个函数，将返回我们可以用英镑购买的硬币数量。从最初的实现开始，我们就已经有了这个功能。只需要咖喱。</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="6b76" class="ls ku hv lo b fw lt lu l lv lw">defcurryp get_quantity({crypto, value_gbp}, amount) do<br/>  {crypto, amount / value_gbp}<br/>end</span></pre><h2 id="48a2" class="ls ku hv bd kv mu mv mw kz mx my mz ld kf na nb lf kj nc nd lh kn ne nf lj ng dt translated">映射和合成</h2><p id="b3d2" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">如果你还记得最初的例子，我们在加密数据列表上迭代了两次。一次应用汇率，然后获取数量:</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="1f21" class="ls ku hv lo b fw lt lu l lv lw">Support.list_crypto_usd()<br/>|&gt; Enum.map(&amp;apply_conversion(Support.exchange_rate("USD", "GBP"), &amp;1))<br/>|&gt; Enum.map(&amp;get_quantity(&amp;1, amount))</span></pre><p id="efad" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">这可能是低效的，但是数学在这里再次帮助了我们:</p><p id="61b2" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated"><code class="ei lx ly lz lo b">map(f2) &lt;|&gt; map(f1) == map(f2 &lt;|&gt; f1)</code></p><p id="2b87" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">所以我们可以组合这两个函数，并且只映射一次。</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="3b77" class="ls ku hv lo b fw lt lu l lv lw">def convert_gbp_and_get_quantity do<br/>  get_quantity() &lt;|&gt; apply_conversion_gbp()<br/>end</span><span id="43c5" class="ls ku hv lo b fw ma lu l lv lw">defcurry buy_crypto_with_gbp(amount) do<br/>  Enum.map(<br/>    Support.list_crypto_usd(),<br/>    &amp;convert_gbp_and_get_quantity().(&amp;1).(amount)<br/>  )<br/>end</span></pre><p id="127e" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">我们的应用程序现在处于工作状态。</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="b32e" class="ls ku hv lo b fw lt lu l lv lw">buy_crypto_with_gbp.(2000) =&gt;<br/>[<br/>  BTC: 0.19774571082071027,<br/>  ETH: 2.0169243958209693,<br/>  LTC: 11.090413196189877<br/>]</span></pre><h2 id="dbd1" class="ls ku hv bd kv mu mv mw kz mx my mz ld kf na nb lf kj nc nd lh kn ne nf lj ng dt translated">自由点</h2><p id="e6af" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">这最后一步是我们情况下的表面变化。这是我们举办<code class="ei lx ly lz lo b">buy_crypto_with_gbp/1</code>的唯一原因。</p><p id="6984" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">Pointfree是声明函数而不提及参数的能力。我们使用<code class="ei lx ly lz lo b">defx</code> Quark包为我们的应用程序定义一个无点接口函数。</p><pre class="jl jm jn jo fr ln lo lp lq aw lr dt"><span id="b976" class="ls ku hv lo b fw lt lu l lv lw">defx buy_crypto_with_gbp do<br/>  buy_crypto_with_gbp().()<br/>end</span></pre><p id="d8aa" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">我们可以用<code class="ei lx ly lz lo b">buy_crypto_with_gbp(2000).</code>来调用它</p><h2 id="dd1a" class="ls ku hv bd kv mu mv mw kz mx my mz ld kf na nb lf kj nc nd lh kn ne nf lj ng dt translated">把所有的放在一起</h2><p id="c0d2" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">相当长的旅程，但我们做到了。使用FP概念实现加密转换器。</p><figure class="jl jm jn jo fr jp"><div class="bz em l di"><div class="ll lm l"/></div></figure><h1 id="6c7c" class="kt ku hv bd kv kw kx ky kz la lb lc ld jb le jc lf je lg jf lh jh li ji lj lk dt translated">回到灵丹妙药</h1><p id="9dd0" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">然而，保持从上面的实现中学到的一些东西，我们可以重构我们的仙丹代码，而不需要库里或者额外的库。</p><figure class="jl jm jn jo fr jp"><div class="bz em l di"><div class="ll lm l"/></div></figure><h1 id="cde0" class="kt ku hv bd kv kw kx ky kz la lb lc ld jb le jc lf je lg jf lh jh li ji lj lk dt translated">结论</h1><p id="d365" class="pw-post-body-paragraph jw jx hv jy b jz mp iw kb kc mq iz ke kf mr kh ki kj ms kl km kn mt kp kq kr ho dt translated">如果我需要在上面的<code class="ei lx ly lz lo b">CryptoCurry</code>和<code class="ei lx ly lz lo b">CryptoElixir</code>实现中做出选择，我会选择最后一个。我发现长生不老药的原生方式更加清晰明了。</p><p id="d423" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">Currying和composing函数会使你的代码变得枯燥。可以帮助构建特殊功能和一般功能。此外，由于函数名更短，没有太多的参数，代码可能看起来更整洁。但是从长远来看，或者对于项目中的新人来说，这可能会令人困惑。</p><p id="3e43" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">让我们举个例子。我看到用两个连续的参数调用<code class="ei lx ly lz lo b">convert_gbp_and_get_quantity</code>。但我不能确定这是否只是部分应用。我不知道它是返回一个最终结果还是另一个等待更多参数的函数。</p><p id="9c4a" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">最后，重要的是要知道我们可以选择在Elixir中使用这些概念。特别是如果你有一个功能背景，你有时可能会错过他们。</p><p id="6be1" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">我希望帖子至少给了你一些关于库里、作曲和《长生不老》中freepoint的基本概念。</p><p id="409e" class="pw-post-body-paragraph jw jx hv jy b jz ka iw kb kc kd iz ke kf kg kh ki kj kk kl km kn ko kp kq kr ho dt translated">我很好奇你对长生不老药和那些FP概念的看法。如果你在其他语言中使用它们，你还需要它们吗？如果没有，你会考虑使用它们吗？</p><figure class="jl jm jn jo fr jp"><div class="bz em l di"><div class="nl lm l"/></div></figure></div></div>    
</body>
</html>