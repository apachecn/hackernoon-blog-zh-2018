<html>
<head>
<title>Async/Await Essentials for Production: Loops, Control Flows &amp; Limits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产的异步/等待要素:循环、控制流和限制</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/async-await-essentials-for-production-loops-control-flows-limits-23eb40f171bd?source=collection_archive---------1-----------------------#2018-01-15">https://medium.com/hackernoon/async-await-essentials-for-production-loops-control-flows-limits-23eb40f171bd?source=collection_archive---------1-----------------------#2018-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/82103023509c4ffacac46bb35f42461e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPhqPXhG3R5nGOs4aCRAFQ.jpeg"/></div></div></figure><div class=""/><p id="5717" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自从async/await在ES8中正式出现以来，它已经成为JavaScript未来的核心。每天都有新的NPM包被转换成支持承诺，然后支持全新但相对较旧的语法的承诺(有人是C#吗？)，现在你甚至可以在Node.js的core <em class="ke"> </em>中找到<code class="eh ka kb kc kd b">util.promisify</code>，以方便回调到承诺的转换。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><p id="20c1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt km translated">sync/await是Node初期人人都想要的“银弹”,但今天我们认为它不仅是Node的未来，也是JavaScript的未来。然而，我不相信有足够的资源去详细介绍这个美妙的新功能。在本文中，我们将这样做，探索日常使用案例和技巧，这可能有助于您在生产中摆脱<a class="ae kv" href="https://github.com/caolan/async" rel="noopener ugc nofollow" target="_blank">曹兰/异步</a>的依赖。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="653d" class="kw kx if bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">基础知识</h1><p id="b69a" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">在我们开始并行运行和限制循环中的项目之前，让我们回到基础。async await的一个常见模式是简单地等待一个承诺，获取它的值并继续函数，让我们假设我们想要获取一个用户并基于用户对象获取特定的提要，这可以通过用async标记我们的<em class="ke"> getUser </em>函数并在每个承诺返回函数调用之前使用<strong class="je ig"> await来轻松完成:</strong></p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="0896" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个简单的用例，适用于任何基于承诺的函数/库，但是如果我们想使用有承诺的好的旧回调怎么办？如果你以前使用过<a class="ae kv" href="https://github.com/petkaantonov/bluebird" rel="noopener ugc nofollow" target="_blank"> petkaantonov/bluebird </a>，也许你会熟悉promisify方法，幸运的是，如果你使用的是Node 8.0和更高版本，你可以节省几分钟的时间，因为你不需要安装这个模块，而是使用一个类似的功能，这个功能在Node的核心下可用，作为将错误优先回调转换为承诺的<code class="eh ka kb kc kd b">Util#promisify</code>:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="f450" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，从v9.4.0开始，使用<code class="eh ka kb kc kd b">Util#promisify</code> <a class="ae kv" href="https://github.com/nodejs/node/blob/c84582cbb6362fa8b2eb2d3bc153617fef2982d1/lib/internal/util.js#L276" rel="noopener ugc nofollow" target="_blank">返回多个参数只对Node内部的</a>可用，如果您在Node.js环境之外，您可以退回到前面提到的蓝鸟的<code class="eh ka kb kc kd b">Promise#promisify</code>。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="cca0" class="kw kx if bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">错误处理</h1><p id="6e49" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">* <a class="ae kv" href="https://mathiasbynens.be/notes/async-stack-traces" rel="noopener ugc nofollow" target="_blank">你不应该忘记的一个事实是</a>与一些流传的误解不同，async/await不仅仅是承诺上的语法糖，它还带有承诺的属性，可以极大地简化调试。它在调试和错误处理能力方面的一个最大优势就是它强大的try/catch块。在同一代码块中捕获同步错误和异步错误从未如此简单。</p><p id="6778" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了证明这一点，让我们写一个承诺，在任何时候都抛出大约100毫秒:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="da89" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用传统的try/catch块在异步函数中捕获来自这个承诺的错误，尽管下面的行将抛出一个永远不会到达的同步错误:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="802f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像在承诺中捕捉一样，您可以捕捉流程中发生的错误:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="2ee2" class="kw kx if bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">控制流</h1><p id="5936" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">无论您是并行运行任务，调度循环或创建级联结构或管道async/await都可以通过高效和可读的控制流简化您的流程在代码中的转换。让我们来看看一些常见的模式:</p><h2 id="5c7f" class="mf kx if bd ky mg mh mi lc mj mk ml lg jn mm mn lk jr mo mp lo jv mq mr ls ms dt translated">1.并行执行</h2><p id="9c62" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">使用async/await进行并行执行没有特定的语法，但是我们可以针对承诺数组(或任何可迭代的)使用<code class="eh ka kb kc kd b">Promise#all</code>来获得预期的结果:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="e53d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">Promise#all</code>将一个承诺列表组合成一个承诺，当所有承诺都被解析时，该承诺将返回数组中由这些承诺解析的所有值。这是并行发生的，除了这个简单而优雅的函数之外，我们不需要任何其他的技巧。</p><h2 id="aeba" class="mf kx if bd ky mg mh mi lc mj mk ml lg jn mm mn lk jr mo mp lo jv mq mr ls ms dt translated">2.超时设定</h2><p id="5fe6" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">也许async/await最少被歌颂的英雄是承诺超时。它是有效和必要的，尤其是在循环环境中使用时(参见下面的<strong class="je ig">延迟循环</strong>)，我们可以将传统的定时器(<code class="eh ka kb kc kd b">setTimeout</code>、<code class="eh ka kb kc kd b">setImmediate</code>)包装在如下承诺中:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="d9cf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们可以通过在两个函数之间创建一个异步暂停(非进程阻塞)来实施这些函数，而不管它们是同步的还是异步的:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="f401" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这种方式，我们永远不必离开函数的上下文，如果使用得当，这可以产生更优雅的代码。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="0e84" class="kw kx if bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">环</h1><p id="25f0" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">使用async/await，控制流非常简单，但我个人最喜欢的async/await实践是<em class="ke">循环</em>，一个简单的async循环可以用多种方式表示，当然我们将继续使用并行执行。</p><h2 id="d91f" class="mf kx if bd ky mg mh mi lc mj mk ml lg jn mm mn lk jr mo mp lo jv mq mr ls ms dt translated"><strong class="ak"> 1。串联回路</strong></h2><p id="939f" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">一个通过给定数量的项目执行多个异步操作的循环，在下面的示例中，在每一步都停止循环，以从数据库获取一些数据并记录结果，然后继续下一个项目，一个接一个，从而创建一个串联循环:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><h2 id="113e" class="mf kx if bd ky mg mh mi lc mj mk ml lg jn mm mn lk jr mo mp lo jv mq mr ls ms dt translated">2.延迟回路</h2><p id="449e" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">我们可以在循环中利用超时的概念，例如，如果我们想要创建一个方法，在总共10秒的时间内每秒钟向数组添加一个随机数，我们可以使用带有计数器的<code class="eh ka kb kc kd b">setTimeout</code>或<code class="eh ka kb kc kd b">setImmediate</code>或等待我们之前实现的<code class="eh ka kb kc kd b">timeoutPromise</code>的for循环:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="b163" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们甚至可以用while循环来实现条件 <code class="eh ka kb kc kd b">setInterval</code>:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><h2 id="9312" class="mf kx if bd ky mg mh mi lc mj mk ml lg jn mm mn lk jr mo mp lo jv mq mr ls ms dt translated">3.并行循环</h2><p id="9384" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">如果它是并行运行的，就并行化。可以通过将一个承诺推入一个数组来创建并行循环，该数组稍后将解析为一个值，因此所有的承诺在完全相同的时间开始，并且可以花费它们自己的时间来完成，最终结果将由<code class="eh ka kb kc kd b">Promise#all</code>自动排序:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="6318" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可以用<code class="eh ka kb kc kd b">Array#map</code>更好地表示，通过将项目数组映射到承诺数组并等待值，这有助于我们在现实世界的用例中实现更多的功能:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="7ed9" class="kw kx if bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">承诺竞赛和限制</h1><p id="623a" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">另一个很少探讨的话题是设置限制来控制与async/await并行执行的任务总数。如果你是<a class="ae kv" href="https://github.com/caolan/async" rel="noopener ugc nofollow" target="_blank">曹兰/异步</a>的狂热用户，你很可能会使用<code class="eh ka kb kc kd b">Async#parallelLimit</code>或<code class="eh ka kb kc kd b">Async#eachLimit</code>，但不要担心，设置限制是可能的。我们将回到我们的承诺魔法，开始一场比赛！</p><p id="7292" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">Promise#race</code>将返回一个承诺，该承诺将在给定承诺列表中的第一项解决时解决。</p><h2 id="374d" class="mf kx if bd ky mg mh mi lc mj mk ml lg jn mm mn lk jr mo mp lo jv mq mr ls ms dt translated">1.基本比赛</h2><p id="8fa4" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">可以通过传递一组承诺来创建一个简单的竞争，在下面的例子中，这些承诺是一个异步函数的返回，该函数在随机的时间内完成解析:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="e7b2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个承诺解决将赢得比赛，并作为我们的结果收集。</p><h2 id="d427" class="mf kx if bd ky mg mh mi lc mj mk ml lg jn mm mn lk jr mo mp lo jv mq mr ls ms dt translated">2.设置限制</h2><p id="2888" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">我们几乎可以利用到目前为止我们所介绍的所有内容来构建一个函数，该函数在给定的限制下并行执行其他异步函数。现实生活中的一个例子是一次只处理5个网页列表的截图。</p><p id="b7c2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了通过承诺和纯async/await实现这一点，我们需要有一种方法来存储当前正在进行的承诺，或者说还没有解决的承诺。不幸的是，这并不是spec-grade承诺的一部分，因此我们将使用<code class="eh ka kb kc kd b">Set</code>来存储和删除正在进行的承诺:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="45f8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们可以利用<code class="eh ka kb kc kd b">Set.size</code>来检查正在进行的承诺的总数，允许我们确定我们可以继续调度循环的多少次迭代。</p><p id="e7cd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将使用<code class="eh ka kb kc kd b">Promise#race</code>作为我们控制流武器库的一部分。我们需要的是一种方法来停止循环的迭代(在本例中是<code class="eh ka kb kc kd b">Array#map</code>)，直到下一个承诺被解决(我们将为此使用一个竞赛)，并检查正在进行的承诺的总数是否小于我们正在寻找的限制，如果不是，那么我们继续返回进行另一个竞赛。这很容易通过下面的while循环实现:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="4af1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将这两者结合在一起，我们将得到<code class="eh ka kb kc kd b">parallelLimit</code> <em class="ke">(继续运行这最后一点)</em>:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="mt me l"/></div></figure></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="9cd0" class="kw kx if bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">范式转变还是更好的语法？</h1><p id="92b7" class="pw-post-body-paragraph jc jd if je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">async/await对JavaScript和Node的影响仍有争议，但其影响是巨大的。Async/await由多年的专业技术支持，使用近乎完美的承诺和尽善尽美的<em class="ke">语法</em> *，同时保留了Node普及的大部分核心异步概念。有一点是肯定的，那就是它会一直存在，我希望这篇文章能够打破僵局，让几行async/await代码就能实现这一目标。</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="mu me l"/></div></figure></div></div>    
</body>
</html>