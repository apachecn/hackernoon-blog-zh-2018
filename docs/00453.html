<html>
<head>
<title>A Kubernetes guide for Docker Swarm lovers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker Swarm爱好者Kubernetes指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-kubernetes-guide-for-docker-swarm-users-c14c8aa266cc?source=collection_archive---------2-----------------------#2018-01-15">https://medium.com/hackernoon/a-kubernetes-guide-for-docker-swarm-users-c14c8aa266cc?source=collection_archive---------2-----------------------#2018-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a98d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">你已经掌握了蜂群。现在是掌握舵的时候了</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/b193c7dd4e1995ed70254b1209ae5632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9twcrLWAZGlo7iqtO8_G7Q.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Set sail!</figcaption></figure><p id="cba2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt kv translated">我从未关注过Kubernetes，因为Swarm给了我在容器编排方面所需要的一切。虽然简单易用，但它在一个像Mesos和Kubernetes这样的容器编排器很难设置的世界里大放异彩。</p><p id="1ab6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但现在在2018年，情况完全不同:所有三大云提供商(AWS、谷歌云和Azure)现在都将赌注压在Kubernetes上，将托管的Kubernetes作为一种服务。这很重要，因为它将管理集群的所有复杂性(在我看来，这是K8S的主要难点)都交给了云提供商。更不用说新版本的Docker Enterprise和Docker for Mac &amp; Windows将与Kubernetes捆绑在一起。</p><p id="15a6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">社区的规模也是这个故事的一大看点。每当我在Docker Swarm上遇到问题时，我都要花一段时间才能找到解决方案。相比之下，即使有更多的功能和配置可能性，简单的谷歌搜索和<a class="ae le" href="http://slack.k8s.io/" rel="noopener ugc nofollow" target="_blank">在Slack上提问</a>帮助我解决了迄今为止我在Kubernetes上遇到的所有问题。不要误解我的意思:Docker Swarm社区很好，但没有Kubernetes社区好。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lf"><img src="../Images/a04374c767136b7d6a2b5696895c0fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BICPnIGooYh9LC2aa228g.png"/></div></div></figure><p id="72ff" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这一点不是Docker Swarm的错:事实是，Kubernetes正在由Google、Microsoft、Red Hat、IBM(我猜还有Docker)等公司以及个人贡献者积极开发。看一下这两个Github库就会发现，事实上Kubernetes要活跃得多。</p><p id="8d33" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但是嘿！这应该是一个指南，所以让我们从比较如何在Swarm和K8S中实现类似的场景开始。</p><blockquote class="lg lh li"><p id="62f5" class="jz ka lj kb b kc kd iv ke kf kg iy kh lk kj kk kl ll kn ko kp lm kr ks kt ku hn dt translated"><strong class="kb hv">免责声明:本指南无意提供任何生产就绪场景。我把它变得简单，以便更容易地说明Swarm和K8S之间的相似之处。</strong></p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/6370d7e71a6f8ec12eff7c364233515e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*pagxrjFyJd0-ccjxVX0v1Q.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Not so much of a <strong class="bd lo">VS</strong>, but I found this image on the Internet</figcaption></figure><h1 id="30cf" class="lp lq hu bd lr ls lt lu lv lw lx ly lz ja ma jb mb jd mc je md jg me jh mf mg dt translated">启动集群(1个主集群和1个工作集群)</h1><p id="8513" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">为了简单起见，让我们构建一个简单的集群，其中有一个主集群和一个工作集群。</p><h2 id="1418" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">启动集群— Docker Swarm</h2><p id="3d14" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">在Docker Swarm中启动一个集群非常简单。机器上安装Docker后，只需:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="361f" class="mm lq hu nb b fv nf ng l nh ni">&gt; <strong class="nb hv">docker swarm init</strong></span><span id="a0d0" class="mm lq hu nb b fv nj ng l nh ni">Swarm initialized: current node (x5hmcwovhbpxrmthesxd0n1zx) is now a manager.</span><span id="b64f" class="mm lq hu nb b fv nj ng l nh ni">To add a worker to this swarm, run the following command:</span><span id="52b4" class="mm lq hu nb b fv nj ng l nh ni"><em class="lj">docker swarm join --token SWMTKN-1-5agb6u8svusxsrfisbpiarl6pdzfgqdv1w0exj8c9niv45y0ya-9eaw26eb6i4yq1pyl0a2zdvjz 192.168.65.3:2377</em></span><span id="eab0" class="mm lq hu nb b fv nj ng l nh ni">To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</span></pre><p id="095f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后，在同一网络中的另一台机器上，粘贴上述命令:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="1af6" class="mm lq hu nb b fv nf ng l nh ni">&gt; <strong class="nb hv">docker swarm join --token SWMTKN-1-5agb6u8svusxsrfisbpiarl6pdzfgqdv1w0exj8c9niv45y0ya-9eaw26eb6i4yq1pyl0a2zdvjz 192.168.65.3:2377</strong></span><span id="fbce" class="mm lq hu nb b fv nj ng l nh ni">The node joined the swarm as a worker</span></pre><h2 id="05e3" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">启动集群— Kubernetes(使用kubeadm)</h2><p id="0ec5" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">我几次提到建立Kubernetes集群是复杂的。虽然这仍然是事实，但有一个名为<strong class="kb hv"> kubeadm </strong>的工具(仍处于测试阶段)可以简化这个过程。其实用kubeadm设置一个K8S集群和Docker Swarm很像。安装kubeadm很容易，因为它可以与大多数包管理器(brew、apt等)一起安装</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="e74e" class="mm lq hu nb b fv nf ng l nh ni">&gt; <strong class="nb hv">kubeadm init</strong></span><span id="9ec4" class="mm lq hu nb b fv nj ng l nh ni">Your Kubernetes master has initialized successfully!<br/><br/>To start using your cluster, you need to run (as a regular user):<br/><br/>  mkdir -p $HOME/.kube<br/>  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br/>  sudo chown $(id -u):$(id -g) $HOME/.kube/config<br/><br/>You should now deploy a pod network to the cluster.<br/>Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:<br/>  http://kubernetes.io/docs/admin/addons/<br/><br/>You can now join any number of machines by running the following on each node<br/>as root:<br/><br/>  <em class="lj">kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</em></span></pre><p id="1937" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">该命令需要一段时间才能完成，因为Kubernetes依赖于etcd等外部服务的设置来运行。所有这些都通过kubeadm实现了自动化。</p><p id="e659" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">与Swarm一样，要加入另一个节点，只需在另一个节点上运行输出的命令:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="6ed1" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</strong></span><span id="a3d9" class="mm lq hu nb b fv nj ng l nh ni">Node join complete:<br/>* Certificate signing request sent to master and response<br/>  received.<br/>* Kubelet informed of new secure connection details.<br/><br/>Run 'kubectl get nodes' on the master to see this machine join.</span></pre><p id="b7b4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">到目前为止，这两个解决方案中的集群创建过程几乎是相同的。但是Kubernetes需要一个额外的步骤:</p><p id="4d45" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">安装pod网络</strong></p><p id="76c0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Docker swarm与一个服务网络捆绑在一起，该服务网络在集群内部提供联网功能。虽然这很方便，但Kubernetes在这方面有更大的灵活性，允许您安装自己选择的网络。官方实现包括<em class="lj">印花布、运河、法兰绒、Kube-Router、Romana和Weave Net </em>。安装它们的过程是相同的，但是在本教程中我将继续使用Calico。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="87a8" class="mm lq hu nb b fv nf ng l nh ni">&gt; <strong class="nb hv">kubectl apply -f https://docs.projectcalico.org/v2.6/getting-started/kubernetes/installation/hosted/kubeadm/1.6/calico.yaml</strong></span></pre><p id="02a7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">关于使用kubeadm的更多信息，请点击<a class="ae le" href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#24-initializing-your-master" rel="noopener ugc nofollow" target="_blank">这里</a></p><h2 id="14cc" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">启动集群— Kubernetes(使用minikube)</h2><p id="96ff" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">如果你想在你的本地机器上试验Kubernetes o，有一个很棒的工具叫做<strong class="kb hv"> minikube </strong>，它可以在一个虚拟机上运行一个Kubernetes集群。我不打算在这方面做太多扩展，但是您可以通过以下方式在您的系统中运行minikube:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="4a60" class="mm lq hu nb b fv nf ng l nh ni">&gt; <strong class="nb hv">minikube start</strong></span></pre><p id="facf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有关minikube的更多信息，请点击<a class="ae le" href="https://kubernetes.io/docs/getting-started-guides/minikube/" rel="noopener ugc nofollow" target="_blank">这里</a></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nk"><img src="../Images/d6abc8277ae3421304d113ec8669f017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjpVFhbdd-oNEF-zvqH7cg.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">The literal file name of this image was container-drugs.jpg. I hope the DEA isn’t reading any of this</figcaption></figure><h1 id="4ce0" class="lp lq hu bd lr ls lt lu lv lw lx ly lz ja ma jb mb jd mc je md jg me jh mf mg dt translated">运行服务</h1><p id="418b" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">现在我们已经有了一个正在运行的集群，让我们启动一些服务吧！虽然有一些差异，但这两个管弦乐队的做法非常相似。</p><h2 id="6c38" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">运行服务— Docker Swarm(内嵌)</h2><p id="5c8e" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">要使用内联命令运行服务，只需执行以下操作:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="979c" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; docker service create --publish 80:80 --name nginx nginx:latest</strong></span></pre><h2 id="b85f" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">运行服务— Kubernetes(内嵌)</h2><p id="d18a" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">可以想象，在Kubernetes做同样的事情并没有什么不同:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="040e" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; </strong><strong class="nb hv">kubectl run nginx --image=nginx:latest<br/></strong>deployment "nginx" created<br/><strong class="nb hv">&gt; kubectl expose deployment nginx --port 80 --type NodePort</strong><br/>service "nginx" exposed</span></pre><p id="7040" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如上所述，我们需要两个命令来复制Swarm的行为。两个orchestrators之间的主要区别在于，在Swarm的情况下，我们在主机上显式地公开了端口80。在Kubernetes中，端口是从预先配置的端口范围中随机选择的。我们可以选择带有标志的目标端口，但它需要在该范围内。我们可以使用以下命令查询所选端口:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="de58" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; kubectl get services</strong></span><span id="3254" class="mm lq hu nb b fv nj ng l nh ni">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        <br/>nginx        NodePort    10.105.188.192   &lt;none&gt;        80:<strong class="nb hv">30149</strong>/TCP   </span></pre><h2 id="7087" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">运营服务— Docker Swarm (YAML)</h2><p id="9ebb" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">您可以在堆栈文件中定义服务(以及卷、网络和配置)。堆栈文件是一种YAML文件，使用与Docker-Compose相同的符号，但增加了功能。让我们使用这种技术来加速我们的nginx服务:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="adab" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; cat nginx.yml</strong></span><span id="4183" class="mm lq hu nb b fv nj ng l nh ni">version: '3'</span><span id="ce9c" class="mm lq hu nb b fv nj ng l nh ni">services:<br/>  nginx:<br/>    image: nginx:latest<br/>    ports:<br/>      - 80:80<br/>    deploy:<br/>      mode: replicated<br/>      replicas: 1</span><span id="6594" class="mm lq hu nb b fv nj ng l nh ni"><strong class="nb hv">&gt; docker stack deploy --compose-file nginx.yml nginxstack</strong></span><span id="3491" class="mm lq hu nb b fv nj ng l nh ni">Creating network nginxstack_default<br/>Creating service nginxstack_nginx</span></pre><p id="7390" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">由于我们没有指定任何网络，Docker Swarm为我们创建了一个。请记住，这意味着nginx服务不能通过另一个服务的服务名来访问。如果我们想要这样做，我们可以定义需要在同一个YAML(以及一个网络)中相互通信的所有服务，或者在两个堆栈中导入一个预先存在的覆盖网络。</p><h2 id="f799" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">运行服务— <strong class="ak"> Kubernetes (YAML) </strong></h2><p id="4550" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">Kubernetes允许通过Kubernetes清单文件创建资源。这些文件可以是YAML文件，也可以是JSON文件。使用YAML是最推荐的，因为它几乎是标准。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="cd2e" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; cat nginx.yml</strong></span><span id="420b" class="mm lq hu nb b fv nj ng l nh ni">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      <em class="lj">app: nginx</em><br/>  template:<br/>    metadata:<br/>      labels:<br/>        <em class="lj">app: nginx</em><br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:latest<br/>        ports:<br/>        - containerPort: 80<br/>---</span><span id="5d7b" class="mm lq hu nb b fv nj ng l nh ni">apiVersion: v1<br/>kind: Service<br/>type: NodePort<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  selector:<br/>    <em class="lj">app: nginx</em><br/>  ports:<br/>  - port: 80</span><span id="e849" class="mm lq hu nb b fv nj ng l nh ni"><strong class="nb hv">&gt; kubectl apply -f nginx.yml</strong></span><span id="557b" class="mm lq hu nb b fv nj ng l nh ni">service "nginx" created<br/>deployment "nginx" created</span></pre><p id="73b8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因为它是围绕一个更加模块化的架构构建的，Kubernetes需要两种资源来实现与Swarm相同的功能:一个<em class="lj">部署</em>和一个<em class="lj">服务</em>。</p><p id="a66a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">一个<strong class="kb hv">部署</strong>很大程度上定义了一个服务的特征。它是定义容器、卷、秘密和配置的地方。部署还定义了副本的数量以及复制和放置策略。你可以把它们看作是swarm中的栈定义，只是没有负载平衡。</p><p id="e11c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">事实上，部署是对较低级别的Kubernetes资源的高级抽象，如pod和副本集。部署定义的<em class="lj">模板</em>部分中定义的一切都定义了一个<strong class="kb hv"> <em class="lj"> pod </em> </strong>，这是Kubernetes提供的最小调度单元。<strong class="kb hv">一个pod不等于一个container。这是一组应该一起安排的资源；例如一个容器和一个卷，或者两个容器。</strong>在大多数情况下，一个Pod只包含一个容器，但是理解这种差异是很重要的。</p><p id="25ee" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">文件的第二部分定义了一个服务资源</strong>，可以看作是引用网络中的一组pods以及它们之间的负载平衡的一种方式。NodePort类型告诉Kubernetes在集群的每个节点上分配一个外部可访问的端口(在所有节点上都相同)。这也是swarm所做的。<strong class="kb hv">你通过使用选择器</strong>告诉服务负载平衡，这就是为什么标签在Kubernetes中如此重要。</p><p id="10be" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这种情况下，Kubernetes要强大得多:例如，您可以定义一个LoadBalancer类型的服务，这将在您的云提供商(之前的配置)中产生一个负载平衡器，例如AWS中的ELB，它将指向您的服务。默认的服务类型是ClusterIP，它定义了一个可以在给定端口上的集群中的任何位置访问的服务，但不能从外部访问。使用ClusterIP相当于在Swarm中定义一个没有外部映射的服务。</p><h1 id="c29a" class="lp lq hu bd lr ls lt lu lv lw lx ly lz ja ma jb mb jd mc je md jg me jh mf mg dt translated">创建卷</h1><p id="3e90" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">需要卷来维护状态和提供配置。这两个编排器都提供了简单的方法来定义它们，但是Kubernetes以更多的功能领先。</p><h2 id="ca72" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">创建卷— Docker Swarm</h2><p id="f3d9" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">让我们为nginx服务添加一个卷:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="e588" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; cat nginx.yml</strong></span><span id="e727" class="mm lq hu nb b fv nj ng l nh ni">version: '3'</span><span id="6131" class="mm lq hu nb b fv nj ng l nh ni">services:<br/>  nginx:<br/>    image: nginx:latest<br/>    ports:<br/>      - 80:80<br/>    <strong class="nb hv">volumes:<br/>      - nginx-volume:</strong><strong class="nb hv">/srv/www</strong><br/>    deploy:<br/>      mode: replicated<br/>      replicas: 1</span><span id="380e" class="mm lq hu nb b fv nj ng l nh ni"><strong class="nb hv">volumes:<br/>  nginx-volume:</strong></span></pre><p id="813f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是最简单的情况，显然这种体积在这种情况下不会提供任何好处，但足以进行演示。</p><h2 id="8dc3" class="mm lq hu bd lr mn mo mp lv mq mr ms lz ki mt mu mb km mv mw md kq mx my mf mz dt translated">创建卷— Kubernetes</h2><p id="801e" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">在K8S中做同样的事情很容易:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="9e6e" class="mm lq hu nb b fv nf ng l nh ni"><strong class="nb hv">&gt; cat nginx.yml</strong></span><span id="3c3b" class="mm lq hu nb b fv nj ng l nh ni">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:latest<br/>        ports:<br/>        - containerPort: 80<br/>       <strong class="nb hv"> volumeMounts:<br/>        - mountPath: </strong><strong class="nb hv">/srv/www</strong><strong class="nb hv"><br/>          name: nginx-volume<br/>       volumes:<br/>         - name: nginx-volume<br/>           emptyDir: {}</strong></span><span id="07ec" class="mm lq hu nb b fv nj ng l nh ni">---</span><span id="cddf" class="mm lq hu nb b fv nj ng l nh ni">apiVersion: v1<br/>kind: Service<br/>type: NodePort<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  selector:<br/>    app: nginx<br/>  ports:<br/>  - port: 80</span></pre><p id="43a8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv"> emptyDir </strong>卷类型是Kubernetes提供的最简单的卷类型。它将容器中的一个文件夹映射到节点中的一个文件夹，该文件夹在pod停止时消失。<br/> Kubernetes附带了<a class="ae le" href="https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes" rel="noopener ugc nofollow" target="_blank"> 26种类型的卷</a>，所以我认为几乎涵盖了所有用例。例如，您可以在AWS中定义一个由EBS卷支持的卷。</p><h1 id="0395" class="lp lq hu bd lr ls lt lu lv lw lx ly lz ja ma jb mb jd mc je md jg me jh mf mg dt translated">好了</h1><p id="84c9" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">当然，除了服务和卷之外，还有更多资源，但是我现在将它们排除在本指南之外。kubernetes中我最喜欢的资源之一是<strong class="kb hv"> ConfigMaps </strong>，它类似于Docker配置，但提供了更好的功能。我会努力写另一个指南来比较这两者，但是现在，我们就到此为止吧。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/49c3b55d5c279058b6675f890b136106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*1bbAeOBN0pECU1U4cseJcA.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Anoter picture of containers. Just because.</figcaption></figure><h1 id="b239" class="lp lq hu bd lr ls lt lu lv lw lx ly lz ja ma jb mb jd mc je md jg me jh mf mg dt translated">结论</h1><p id="f5c8" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">像Swarm一样使用kubernetes比以往任何时候都更容易。我们需要一段时间来决定将所有基础设施迁移到Kubernetes。在写这篇文章的时候，Swarm给了我们所需要的一切，但很高兴知道K8S的入门门槛正在随着时间的推移而降低。</p><blockquote class="lg lh li"><p id="c499" class="jz ka lj kb b kc kd iv ke kf kg iy kh lk kj kk kl ll kn ko kp lm kr ks kt ku hn dt translated">我是一名驻阿根廷布宜诺斯艾利斯的软件工程师。目前在拉丁美洲领先的移动游戏公司Etermax担任平台工程师。</p></blockquote></div></div>    
</body>
</html>