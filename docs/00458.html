<html>
<head>
<title>Absolute Fundamentals of Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习的绝对基础</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/absolute-fundamentals-of-machine-learning-dca5deee78df?source=collection_archive---------7-----------------------#2018-01-15">https://medium.com/hackernoon/absolute-fundamentals-of-machine-learning-dca5deee78df?source=collection_archive---------7-----------------------#2018-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/35a8f22b6e65a84818eebcb753cd7996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3TNZbdu06LWNCpHixIFxQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://unsplash.com/photos/0E_vhMVqL9g" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/0E_vhMVqL9g</a></figcaption></figure><p id="599d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">机器学习，多么时髦的词。我相信你们都想了解机器学习，这也是我在这篇文章中要教授的内容。</p><p id="4be3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我发现在学习编程的同时学习理论知识会让学习这两方面变得更容易，所以这篇文章的特点是既易于理解数学又易于理解用Python实现的算法。此外，技术会很快过时。本教程中使用的代码可能在5年后变得毫无意义。因此，我决定也教机器学习的数学方面，它不会在几年内消失。</p><h1 id="e5cc" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么是机器学习？</h1><p id="5397" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">先说学习。学习是一个漫长而复杂的过程，但简而言之，它是将经验转化为知识。</p><p id="83bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">机器学习是教机器如何学习，这听起来很疯狂，但实际上利用概率是可行的。</p><p id="3a8a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我高度推荐你阅读这篇关于概率的文章，因为它是机器学习和人工智能的重要基础。在本文中，我们将再次复习条件概率和贝叶斯理论。</p><h1 id="6d26" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">学习的类型</h1><p id="d672" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">机器学习有许多不同的方式，在这里我试着解释不同的类型。</p><h2 id="ab69" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">监督学习</h2><p id="8096" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在监督学习中，我们从具有训练样本的数据集开始，每个样本都有一个标识它的分配标签。</p><p id="837c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这方面的一个例子如下:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/40fb39e01b7c444a089899a383093c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*RzTRpIv0IPvTuwRLdtAoWw.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Google ReCaptcha</figcaption></figure><p id="9951" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们希望机器能够识别饮料，因此我们向机器展示了9幅图像，其中一些包含饮料。然后我们选择包含饮料的图片，教计算机饮料是什么样子的。</p><p id="7c75" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它通过一种<strong class="jj hv">学习算法来运行标记的数据。</strong>监督学习的目标是能够正确识别提供给它的新数据，学会如何使用以前的数据集和学习算法识别数据。</p><h2 id="6d24" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">无监督学习</h2><p id="823d" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">无监督学习与有监督学习有很大不同，因为它几乎总是没有确定的输出。学习代理旨在发现数据中的结构或模式。</p><p id="8367" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一篇关于无监督学习的好文章可以在这里找到<a class="ae jg" rel="noopener" href="/machine-learning-for-humans/unsupervised-learning-f45587588294">。</a></p><h2 id="c80c" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">强化学习</h2><p id="f5b0" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">强化学习是学习者因其行为受到奖励和惩罚的地方。奖励可以简单地是效用，代理人可以被告知接受尽可能多的效用以“获胜”。这里的效用可能只是一个正态变量。</p><p id="c583" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">强化学习的一个很好的例子是:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="mb mc l"/></div></figure><h1 id="1803" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">机器学习</h1><p id="beb3" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在我们理解了机器学习的一些术语，我们实际上要教机器一些东西。为了做到这一点，我们需要学习一点概率。</p><p id="3952" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里的大部分概率都是直接从我写的另一篇关于概率的博文中抄袭来的，但我在这里只包括机器学习所需的重要部分。</p><h1 id="6670" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">条件概率</h1><p id="e4d3" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">条件概率是指一个事件只有在另一个事件已经发生的情况下才会发生。让我们从一个简单的问题开始:</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="976a" class="li kg hu me b fv mi mj l mk ml">John's favourite programming languages are Haskell and x86 Assembley. Let A represent the event that he forces a class to learn Haskell and B represent the event that he forces a class to learn x86 Assembley.</span><span id="a130" class="li kg hu me b fv mm mj l mk ml">On a randomly selected day, John is taken over by Satan himself, so the probability of P(A) is 0.6 and the probability of P(B) is 0.4 and the conditional probability that he teaches Haskell, given that he has taught x86 Assembley that day is P(A|B) = 0.7.</span><span id="0a63" class="li kg hu me b fv mm mj l mk ml">Based on the information, what is P(B|A), the conditional probability that John teaches x86 Assembley given that he taught Haskell, rounded to the nearest hundredth?</span></pre><p id="de1e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此概率P(A和B)= P(A | B)* P(B)；将“|”读作给定，如在中，“A|B”读作“给定B”。也可以写成P(B|A) * P(A)。</p><p id="0f60" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">之所以是P(A|B) * P(B)是因为给定“给定B发生的概率，A发生”的概率和B的概率asP(B)。(A|B)是与P(B)不同的概率，P(A和B)只有在P(B)发生时才能发生，而P(B|A)又允许P(B | A)发生。</p><p id="1a5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们可以把它转换成一个数学公式:</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="a3f8" class="li kg hu me b fv mi mj l mk ml">P(A and B) = P(A|B) * P(B) = 0.7 * 0.5 = 0.35</span><span id="45e3" class="li kg hu me b fv mm mj l mk ml">Solving it<br/>P(B|A) * P(A)<br/>P(A) = 0.5<br/>So<br/>0.6 * P(B|A)<br/>Now we don't know what P(B|A) is, but we want to find out. We know that P(B|A) must be a part of P(A and B) because P(A and B) is the probability that both of these events happen so...</span><span id="3286" class="li kg hu me b fv mm mj l mk ml">P(A and B) = 0.35</span><span id="1c9e" class="li kg hu me b fv mm mj l mk ml">0.35 = P(B|A) * 0.5<br/>With simple algebraic manipulation<br/>0.35/0.5 = P(B|A)<br/>P(B|A) = 0.7</span></pre><h1 id="aaec" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">贝叶斯定理</h1><p id="61cd" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">贝叶斯定理允许我们在已知事件的先验知识的情况下计算出事件的概率。与其说它是一个定理，不如说它是一个观察结果，因为它总是正确地工作。贝叶斯定理是由托马斯·贝叶斯创立的，他在一个笔记本上记录了这个观察结果。他从未发表过它，所以他在有生之年没有因为他著名的理论而遭到反对。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/85f3af60b24ee4fabdcf2d3933a2bc1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NP-Lj4PxOP98zmv6IfilA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">From <a class="ae jg" href="https://betterexplained.com/articles/colorized-math-equations/" rel="noopener ugc nofollow" target="_blank">https://betterexplained.com/articles/colorized-math-equations/</a></figcaption></figure><p id="c79b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很困惑，对吧？让我们看一个例子。</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="453b" class="li kg hu me b fv mi mj l mk ml">Suppose a new drug is found on the streets and the police want to identify whether someone is a user or not.</span><span id="e01b" class="li kg hu me b fv mm mj l mk ml">The drug is 99% sensitive, that is that the proportion of people who are correctly identified as taking the drug.</span><span id="703c" class="li kg hu me b fv mm mj l mk ml">The drug is 99% specific, that is that the proportion of people who are correctly identified as not taking the drug.</span><span id="63e4" class="li kg hu me b fv mm mj l mk ml">Note: there is a 1% false positive rate for both users and non users.</span><span id="feb9" class="li kg hu me b fv mm mj l mk ml">Suppose that 0.5% of people at John Moores (A rival university) takes the drug. What is the probability that a randomly selected John Moores student with a positive test is a user?</span></pre><p id="698d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们给这个着色，然后把它放进等式里</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/f5b5e6c283184338e44bd5c419514594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-RPfG6rszMYVuzVHrJy8A.png"/></div></div></figure><p id="629b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:我们不直接知道阳性测试实际上是阳性的机会，它不是给我们的，所以我们必须计算它，这就是为什么公式在第二部分扩展了分母。</p><h2 id="b26f" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">用贝叶斯理论学习</h2><p id="3fc6" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在，贝叶斯定理不是被设计成只能用一次的。它设计用于处理连续数据。贝耶最初用一个思维实验创造了这个。他想知道，如果他的助手在桌子上扔一个球，他能预测它会落在哪里吗？</p><p id="6094" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">贝耶要求他的助手这样做。然后，告诉他它是在原来位置的左边还是右边。他记下了它击中的每一个点，随着时间的推移，每次投掷，他都能更好地预测它会落在哪里。这就是贝叶斯理论发挥作用的地方，通过重复使用贝叶斯理论，我们可以计算出球可能会更准确地落在哪里。</p><p id="1d40" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们做一个简单的例子来得到一些数字:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/7e95ccc89d31d052d11436d666824aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9Bnx_rVyXqNJS64zSHTCA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Medium doesn’t support colours, so I have to copy and paste images. Sorry!</figcaption></figure><p id="9227" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，如果你去了另一家医院，获得了第二个意见，并由不同的实验室再次进行测试，会发生什么呢？这个测试也是阳性的，那么你得这种病的可能性有多大呢？</p><p id="af5e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们把测试前患病的概率改为9%，所以看起来是这样的:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/560ef4c2e2c3fd9c4d4c5ec3a669ccfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*LyJu_eojIeAF9-MHQYO5WQ.png"/></div></figure><p id="29a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在新的数字是0.9073319或91%的患病几率。</p><p id="19b2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有道理，两个不同实验室的两个阳性结果不太可能是一致的。如果你做了更多的实验，结果都是阳性，这个数字会逐渐增加到100%。</p><h1 id="9097" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">朴素贝叶斯分类器</h1><p id="2333" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">朴素贝叶斯分类器是一种基于贝叶斯理论的分类器，它假设预测器之间是独立的。朴素贝叶斯分类器假设特定特征的存在与任何其他特征的存在无关。例如，如果一个水果是红色的，圆形的，直径大约3英寸，就可以被认为是苹果。即使这些特征相互依赖或依赖于苹果所有其他特征的存在，所有这些都有助于该水果是苹果的概率，这就是为什么这种分类器被称为“幼稚”。</p><p id="293e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">维基百科说得好:</p><blockquote class="mr ms mt"><p id="5cc8" class="jh ji mu jj b jk jl jm jn jo jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd ke hn dt translated">简而言之，朴素贝叶斯分类器假定在给定类变量的情况下，类的特定特征的存在(或不存在)与任何其他特征的存在(或不存在)无关。例如，如果一个水果是红色的、圆形的、直径约为4英寸，那么它可以被认为是苹果。即使这些特征相互依赖或依赖于其他特征的存在，朴素贝叶斯分类器也会考虑所有这些属性，以独立地影响该水果是苹果的概率。</p></blockquote><p id="cf23" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">问题</strong></p><p id="729d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设我们有两个数据集，“游戏”和“天气”。我们想看看在这种天气下打球的可能性。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/4432c8fdbd2e57b4c4aae6491cc4286e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjbGBM9AUU8JVuT7q-2C0w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image from <a class="ae jg" href="https://www.analyticsvidhya.com/blog/2017/09/naive-bayes-explained/" rel="noopener ugc nofollow" target="_blank">https://www.analyticsvidhya.com/blog/2017/09/naive-bayes-explained/</a></figcaption></figure><ol class=""><li id="4fa7" class="mz na hu jj b jk jl jo jp js nb jw nc ka nd ke ne nf ng nh dt translated">第一步是将数据转换成频率表</li><li id="0640" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke ne nf ng nh dt translated">第二步是创建一个可能性表，通过找到像阴天= 0.29这样的概率，玩的概率是4 / 14(其中14是他们玩的总次数)，4是他们以前在那种天气玩的次数。</li><li id="d7ec" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke ne nf ng nh dt translated">现在使用奈伊夫贝叶斯方程来计算每个类的条件概率。</li></ol><p id="0ebe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个使用上述数据和等式解决的问题示例。</p><p id="2af0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">“如果天气晴朗，球员们就会比赛”这句话对吗？</strong></p><p id="f863" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">P(是|晴)= P(晴|是)* P(是)/P(晴)</p><p id="e16a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">记得贝叶斯定理吗？这是相同的，但是输入了变量名，以便于阅读。</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="f051" class="li kg hu me b fv mi mj l mk ml">Now we have P(Sunny|Yes) = 3/9 = 0.33.<br/>P(Sunny) = 5/14 = 0.36. <br/>P(yes) = 9/14 = 0.64</span><span id="b362" class="li kg hu me b fv mm mj l mk ml">Now using Bayes Therom we can work out<br/>P(Yes|Sunny) = 0.33 * 0.674 / 0.36 = 0.60 which has high probability.</span><span id="65f4" class="li kg hu me b fv mm mj l mk ml">Thus, given that it is sunny, there is a 60% chance they will play.</span></pre><h1 id="6628" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">使用Python的机器学习</h1><p id="cf1c" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">哇，这是一个多么无聊的阅读。我听到你说“理论计算机科学很无聊”。好吧，你会很兴奋地知道下一部分是关于使用Python的机器学习的应用。</p><p id="dc02" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们用机器学习来计算一下一封邮件是垃圾邮件还是ham(也就是正常的邮件)。</p><p id="e867" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，考虑到大量的垃圾邮件，我们需要训练这个模型。我们首先计算每封邮件中的每个单词在垃圾邮件和业余邮件中出现的次数。</p><p id="9687" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们将使用一个公式来计算每个单词的“spaminess”级别。我们将使用的公式非常简单。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/b98d75718be1d3be7d69edc01013d2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*8s6GK2l4s0gttxJ_2EMbMA.png"/></div></figure><p id="04d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，分子(上面的数字)显示该词在垃圾邮件中出现的次数，分母(底部)显示它在任何电子邮件中出现的次数。</p><p id="f473" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，假设有9封垃圾邮件和10封垃圾邮件，总共19封。如果一个单词出现在9封垃圾邮件中，但有1封是垃圾邮件，那么等式是9/10，这就给了我们90%的机会，这个单词意味着它是一封垃圾邮件。</p><p id="44bc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我们不能简单地只计算一个单词，我们需要对邮件中的所有单词都这样做。</p><p id="a9db" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们基本上有3个步骤:</p><ol class=""><li id="114a" class="mz na hu jj b jk jl jo jp js nb jw nc ka nd ke ne nf ng nh dt translated">查找邮件中每个单词的垃圾信息。</li><li id="6c2d" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke ne nf ng nh dt translated">找出一封邮件的垃圾邮件总数，比如通过乘以每个单词的垃圾邮件等级。这叫S[M]。</li><li id="77fe" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke ne nf ng nh dt translated">然后，通过将每个单词的(1-spaminess)级别相乘，找出每个单词的含意。这叫H[M]。</li></ol><p id="6ff6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，如果S[M] &gt; H[M]，则该消息是垃圾邮件，否则是垃圾邮件。</p><p id="faf3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好的，让我们来实现它。我们将只使用电子邮件的正文，为了便于解释，不会有很多电子邮件。此外，垃圾邮件非常明显。下面是我正在使用的不良电子邮件文本文件</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="18e4" class="li kg hu me b fv mi mj l mk ml">Viagra for sale, get sexy body soon!<br/>U want sum viagra bby? u sexy s00n<br/>VIAGRA VIAGRA VIAGRA VIAGRA VIAGRA<br/>SEXY SOON VIAGRA PLEASE YASSSSS <br/>VIAGRA BUY PLEASE<br/>I really like today</span></pre><p id="bbac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还有好的邮件</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="2252" class="li kg hu me b fv mi mj l mk ml">Hello, how are you?<br/>I hope you have the work ready for January the 8th.<br/>Do you like cats or dogs?<br/>Viagra<br/>viagra</span></pre><p id="6b5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以第一步是以某种方式获取这个文件并将其拆分。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="688e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该代码读取文件，并将其拆分为新的一行，产生2个列表。列表如下所示。下面是坏邮件</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="5109" class="li kg hu me b fv mi mj l mk ml">['Viagra for sale, get sexy body soon!', 'U want sum viagra bby? u sexy s00n', 'VIAGRA VIAGRA VIAGRA VIAGRA VIAGRA', 'SEXY SOON VIAGRA PLEASE YASSSSS ', 'VIAGRA BUY PLEASE', 'I really like today']</span></pre><p id="9449" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还有好的邮件</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="3501" class="li kg hu me b fv mi mj l mk ml">['Hello, how are you?', 'I hope you have the work ready for January the 8th.', 'Do you like cats or dogs?', 'Viagra', 'viagra']</span></pre><p id="8ffb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好了，现在我们需要计算每个单词的spaminess。我们找到这个词，看看它在坏邮件中出现了多少次，在好邮件中出现了多少次，基本公式如下:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/b98d75718be1d3be7d69edc01013d2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*8s6GK2l4s0gttxJ_2EMbMA.png"/></div></figure><p id="832b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，为了找出坏的和好的电子邮件中出现了多少单词，我们可以使用嵌套的for循环；但我选择在这里发挥一点作用。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="3e69" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，第一行是一个lambda(匿名)函数，它只是把一个列表变成一个列表。匿名函数是只打算使用一次或两次的函数。第二行和第三行也是如此。首先，他们将函数“x.split(" ")映射到列表中的每封电子邮件，生成电子邮件中单词列表的新列表，然后他们应用flatten函数将列表列表合并为一个列表。</p><p id="385d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们有两个列表，一个包含一封糟糕邮件中的所有单词，一个包含一封好邮件中的所有好单词。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="70f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们创建一个函数来计算一个单词的垃圾程度。首先，它计算一个单词在坏邮件中出现的次数。然后统计它在两封邮件中出现的次数。然后返回它在坏邮件中出现的次数除以它在所有邮件中出现的次数。</p><p id="c90b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们需要一本包含每个单词及其语法等级的词典。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="01d6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">word_Dict现在将返回</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="8c2f" class="li kg hu me b fv mi mj l mk ml">{'body': 1.0, '': 1.0, 'want': 1.0, 'get': 1.0, 'I': 0.5, 'January': 0.0, 's00n': 1.0, 'SOON': 1.0, 'you?': 0.0, 'dogs?': 0.0, 'sale,': 1.0, 'U': 1.0, 'are': 0.0, 'Viagra': 0.5, 'sexy': 1.0, 'ready': 0.0, 'SEXY': 1.0, 'the': 0.0, '8th.': 0.0, 'really': 1.0, 'Do': 0.0, 'Hello,': 0.0, 'BUY': 1.0, 'bby?': 1.0, 'like': 0.5, 'for': 0.5, 'sum': 1.0, 'work': 0.0, 'PLEASE': 1.0, 'VIAGRA': 1.0, 'YASSSSS': 1.0, 'how': 0.0, 'viagra': 0.5, 'cats': 0.0, 'u': 1.0, 'hope': 0.0, 'have': 0.0, 'you': 0.0, 'or': 0.0, 'today': 1.0, 'soon!': 1.0}</span></pre><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="9294" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">给定一条消息，这段代码将通过乘以每个单词的垃圾程度来计算这条消息有多垃圾。haskell中的reduce函数是foldl，它接受一个列表和一个函数，并通过将函数应用于列表中的每一项来返回一个值。在这种情况下，给定一个[x，y，x，y，x，y]列表，它将乘以x*y，然后将它们相加。</p><p id="4ea6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们需要找到每条信息的含意，这并不困难，因为我们可以找到spaminess。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="6b68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">哈密尔顿是spaminess</p><p id="29fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们只需要创建一个函数来确定它是垃圾邮件还是火腿。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="7bd9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果是真的，就是垃圾邮件，如果不是；是火腿。很明显，对于如此有限的数据集来说，这不会很好，但如果我们有数千封电子邮件，这应该会很好，尽管最初的启动时间很慢。</p><p id="9e2c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们刚刚使用了naieve bayes分类器——一种基于监督机器学习的垃圾邮件检测方法。听起来是不是很酷？</p><h1 id="e2bd" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">k-最近邻</h1><p id="e5dc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">像上面的Naieve Bayes一样，让我们创建一个关于K-最近邻的直觉。</p><p id="aba4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们从一些事实开始来建立这种直觉。</p><p id="c81c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">点是一个位置。它没有大小，但就像任何位置一样，它会告诉你东西在哪里。它可以用不同的方式来表示，这取决于它存在于多少个维度中。</p><p id="1416" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">线是一维对象。我们可以用这样的线来表示一个位置</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff np"><img src="../Images/5935517d6ea2d4b772f15b2b02189891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RhumPny-HLtWeRUVUK0cBQ.png"/></div></div></figure><p id="b7fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设这条线从数字3开始，到数字9结束，那么位置就是3到9之间的任何数字。在这个图中，它被表示为x。</p><p id="0f67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在二维物体中，比如正方形，我们可以用X和Y坐标来表示位置。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nq"><img src="../Images/dad213b8fe76d9450becbba76ac7b4f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZ8XKa2eKYoy8glSbem8fA.png"/></div></div></figure><p id="1ef2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用X和Y坐标可以到达这个正方形中的任何位置。</p><p id="79bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">立方体是一个三维的正方形，我们可以用3个坐标来表示它的位置</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/663655f878dffcefd8f5168614fcef50.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*OhQEZlQn6l2PQvWjc20QYQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Taken from <a class="ae jg" href="http://www.petercollingridge.co.uk/book/export/html/460" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="19b4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">几何中的点是一个位置。它没有大小，即没有宽度、长度和深度。一个点由一个点表示。</p><p id="61b3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以n维空间中的一个点需要n个坐标来表示。我们发现很难想象任何超过三维空间的东西(因为我们的世界是三维的)。</p><p id="9800" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个n维空间用一个n维<strong class="jj hv">超立方体</strong>来表示。</p><p id="1bb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">超立方体只是一个花哨的词，意思是任何位置都可以表示为n个数的元组。</p><p id="7bda" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，回到阻止垃圾邮件的例子。任何电子邮件都可以表示为超立方体中的一个点。</p><p id="4c71" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">比方说，我们有一个列表，里面列出了所有可能出现在电子邮件中的单词。</p><p id="0e70" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以有:</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="cb37" class="li kg hu me b fv mi mj l mk ml">W1, W2, ..., Wn </span></pre><p id="38ba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">列表中的单词。让我们简单点，比如说电子邮件中出现的每一个单词都是</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="ac50" class="li kg hu me b fv mi mj l mk ml">('Hello', 'Goodbye', 'Email', 'Cheese', 'United Kingdom')</span></pre><p id="17fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了简单起见，我们将假设在电子邮件中只有这些词是可能的。</p><p id="19d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每封电子邮件都会包含上述单词的子集，如下所示:</p><p id="e369" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“你好，奶酪。”或者“英国，再见。”</p><p id="d4b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些消息中的每一条都可以表示为1和0的列表，就像位向量一样。</p><p id="746b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以对于第一条信息:</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="de42" class="li kg hu me b fv mi mj l mk ml">('Hello', 'Cheese')<br/>(1, 0, 0, 1, 0)</span></pre><p id="909f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们简单地将电子邮件和所有可能单词中的单词转化为1，在这个例子中，第一个元素“Hello”和第四个元素“cheese”转化为1。</p><p id="fd6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以现在我们把一条信息转化成一个n维超立方体中的一个点。</p><p id="2dc4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们希望对我们想要分类的电子邮件以及我们保存信息的每封电子邮件都这样做。所以我们有训练数据，和要分类的消息。</p><p id="494a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们在一个n维超立方体中有一堆点，我们想计算每个点之间的距离。有许多方法可以计算距离。我们将在这里使用<a class="ae jg" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">欧几里德距离公式</strong> </a>。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/c7bf67b756aba96df04dc4d72c68362d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/1*phAWDJmnLx9TmPD7kBC3_A.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Taken from <a class="ae jg" href="https://hlab.stanford.edu/brian/making7.gif" rel="noopener ugc nofollow" target="_blank">here</a>. More on this later.</figcaption></figure><p id="546c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们插入要分类的新邮件时，我们会检查它最近的邻居。如果它附近的大部分邮件都是垃圾邮件，那么该邮件很可能就是垃圾邮件。但是如果它附近的邮件大部分是火腿，那么这个邮件很可能是火腿。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nt"><img src="../Images/0201072778708b280470abd4ef076a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wh8FzeWpN_VUw8xYahGzKQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The feature space for spam and ham emails</figcaption></figure><p id="9150" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们对训练数据进行了分类，这是它在图表上的样子。当我们把要分类的电子邮件放入其中时，图表看起来会像这样:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nu"><img src="../Images/9cf382bca20f8d5d420676c86249bd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0fYQgx3UsVf8aMPwaulIA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Feature space</figcaption></figure><p id="d07c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们知道要分类的电子邮件放在哪里，因为我们之前已经将它转换为一组坐标。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nv"><img src="../Images/8856c628fb43f9c5b4f69bf1ca64525e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBa1jEh0eHqZPYhlM9REwQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Feature space</figcaption></figure><p id="1f70" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在要分类的电子邮件周围画一个圆圈，因为大多数垃圾邮件都在圆圈内，所以我们将此电子邮件标记为垃圾邮件。这个比现实稍微简单一点。</p><p id="0cac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们将每封电子邮件分类为包含0和1的位向量时，通常我们会对电子邮件的子集进行哈希运算，并使用它来代替，距离可能不是一个简单的欧几里德公式，而是一个更复杂的公式，在训练中效果很好。</p><h2 id="1daf" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">距离测量</h2><p id="7f50" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我说过欧几里德距离是计算距离的一种方法，在这一节我会多讲一点。</p><p id="02da" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">欧几里德距离用于<strong class="jj hv">定量的</strong>数据，即只有数字的数据。</p><h2 id="625b" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">什么是「欧氏距离」？</h2><p id="4b80" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">首先让我们回到毕达哥拉斯的理论。我们都记得它是</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/4329294226e7b205e23e439c491e5272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JlqG-uqhSgxDz8LhcRpgQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Taken from <a class="ae jg" href="http://cdn.pythagorasandthat.co.uk/wp-content/uploads/2014/07/pythagoras-theorem-1024x675.png" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="5fd5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是毕达哥拉斯的理论可以应用于许多实例。简而言之，就是求直角两点之间的距离。假设你向东走3米，向北走4米，你离最初的源头有多远？嗯，直线距离5米。如果你想进一步了解毕达哥拉斯公式是如何被用来计算距离的，请阅读这篇文章:</p><div class="nx ny fm fo nz oa"><a href="https://betterexplained.com/articles/measure-any-distance-with-the-pythagorean-theorem/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab ej"><div class="oc ab od cl cj oe"><h2 class="bd hv fv z el of eo ep og er et ht dt translated">如何用勾股定理测量任意距离</h2><div class="oh l"><h3 class="bd b fv z el of eo ep og er et ek translated">我们一直低估了勾股定理。这与三角形无关；它适用于任何形状。这不是…</h3></div><div class="oi l"><p class="bd b gc z el of eo ep og er et ek translated">betterexplained.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ja oa"/></div></div></a></div><p id="7418" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">欧几里德距离的实际公式是:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff op"><img src="../Images/8d1bdfb0a03a9523aaa45939a1ec1082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucxWe05bMojzL6aUGIWH8Q.png"/></div></div></figure><p id="0ef7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意这和毕达哥拉斯的理论非常相似。</p><p id="d222" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设我们有这张桌子:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff oq"><img src="../Images/b9d0d02804a49643412f2fbc5868e404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*bfpwr8GxcKFRTOnMvL279g.png"/></div></figure><p id="fc93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们想要找出这两辆车之间的距离，因此我们将这些值插入欧几里德距离公式，如下所示:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff or"><img src="../Images/ba5399ed56cf5cbe44d384f9e59d4437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*M-pUsMAlllq4yLav5bp-yQ.png"/></div></figure><p id="5af7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，距离大约为220。</p><h2 id="d3eb" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">定性数据呢？</h2><p id="956d" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">定性数据是不能用数字表示的数据。让我们试一个例子:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff os"><img src="../Images/94fac8d2ff62c159586401af76baae6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKKdXM2S79tzqO4K-Gx0jA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Table inspired by slides from Frank Wolter, AI Lectuer @ UoL</figcaption></figure><p id="84ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设您有4天的天气数据，以及学校里的孩子是否在休息时间玩耍。这里没有数字，所以我们不能用欧几里德距离。你不能对像“阳光”这样的概念求平方，也不能对由此产生的概念求平方根。</p><p id="e6e9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们必须找到一种不同的方法来衡量一天和另一天有多近。让我们看看第一天和第三天。他们有多相似？有一种同样自然的方法，我们只需计算相同日期的特征的数量。</p><p id="61b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以第1天和第2天除了风之外都有相同的特征，所以我们给它的距离是1。我们计算不同特征的数量。</p><p id="4740" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以第1天和第3天的距离是2。</p><p id="a306" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以很容易地根据你认为更重要的东西来改变这个方法，这个方法不是一个放之四海而皆准的方法，而是一个你作为一个人类(而不是人工智能；希望)需要决定。</p><h2 id="f5d6" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">“邻居”的定义是什么</h2><p id="6af3" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">你可能已经注意到了一些奇怪的东西，我没有在这里详述:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nv"><img src="../Images/8856c628fb43f9c5b4f69bf1ca64525e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBa1jEh0eHqZPYhlM9REwQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Feature space</figcaption></figure><p id="e9f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">圆的大小是怎么决定的？好问题。这是学习中非常典型的问题。你想要最近的3个邻居还是最近的20个邻居？这取决于你的训练数据。这完全取决于你。</p><h2 id="b112" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">用Python实现K近邻</h2><p id="633f" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在我们了解了K近邻，让我们用Python来实现它。这是我们将使用的逗号分隔值(CSV)格式的数据。</p><p id="d9f1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注:本节使用此处<a class="ae jg" href="https://machinelearningmastery.com/tutorial-to-implement-k-nearest-neighbors-in-python-from-scratch/" rel="noopener ugc nofollow" target="_blank">、此处</a> <a class="ae jg" href="https://kevinzakka.github.io/2016/07/13/k-nearest-neighbor/" rel="noopener ugc nofollow" target="_blank">、此处</a><a class="ae jg" href="https://www.dataquest.io/blog/k-nearest-neighbors-in-python/" rel="noopener ugc nofollow" target="_blank"/>的代码。</p><p id="e1e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过运行以下命令，在这里下载文件<a class="ae jg" href="https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data" rel="noopener ugc nofollow" target="_blank"/></p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="25ae" class="li kg hu me b fv mi mj l mk ml">wget <a class="ae jg" href="https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data</a></span></pre><p id="a745" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在终端中或通过选择网站上的所有行，将它们复制并粘贴到名为<strong class="jj hv"> iris.data </strong>的文本文件中。</p><p id="78c8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，我们要像这样读入数据:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="97d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">csv模块允许我们处理逗号分隔值(CSV)文件。如果您通过在代码中添加以下内容来打印它</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="3b89" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您将得到类似这样的输出，但时间要长得多。</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="b6fa" class="li kg hu me b fv mi mj l mk ml">6.5, 3.2, 5.1, 2.0, Iris-virginica<br/>6.4, 2.7, 5.3, 1.9, Iris-virginica<br/>6.8, 3.0, 5.5, 2.1, Iris-virginica<br/>5.7, 2.5, 5.0, 2.0, Iris-virginica<br/>5.8, 2.8, 5.1, 2.4, Iris-virginica<br/>6.4, 3.2, 5.3, 2.3, Iris-virginica</span></pre><p id="be3e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们需要制作2个数据集，一个是训练数据集，另一个是测试数据集。训练数据集用于允许K近邻(KNN)进行预测(注意:KNN不<em class="mu">概括</em>数据)</p><p id="5295" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们刚刚加载的文件是作为字符串加载的，所以我们需要将它们转换成我们可以处理的数字，然后我们需要将数据集随机分成训练和测试数据集。2/3用于培训，1/3用于测试是通常使用的标准比率。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="fa24" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">给读者的提示:我很难自己尝试导入虹膜数据，所以这段代码完全是从这里的<a class="ae jg" href="https://machinelearningmastery.com/tutorial-to-implement-k-nearest-neighbors-in-python-from-scratch/" rel="noopener ugc nofollow" target="_blank">复制过来的</a>。</p><p id="82aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们要计算2个点之间的欧几里德距离，由于花数据集大部分是数字，最后是一个小字符串，我们可以只使用欧几里德距离，忽略最后一个特征。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="f78c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">哇哦。那是什么？这是函数式编程。我刚刚完成了为期12周的函数式编程课程，正如我的老师所说:</p><blockquote class="ot"><p id="e45f" class="ou ov hu bd ow ox oy oz pa pb pc ke ek translated">到12周结束的时候，你将会对你读到的每一点代码都说“这可以用一行函数来完成”</p></blockquote><p id="8296" class="pw-post-body-paragraph jh ji hu jj b jk pd jm jn jo pe jq jr js pf ju jv jw pg jy jz ka ph kc kd ke hn dt translated">让我们快速地从人工智能转移到这个功能代码上来。对于函数式，最好是从内向外阅读，所以我们将从代码的第一个函数位开始</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="639a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:remove_flowers函数将在后面讨论，但是如果没有这个函数，它将在后面的代码中导致错误。remove_flowers只是把一个数据项像</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="98bc" class="li kg hu me b fv mi mj l mk ml">5.0,3.4,1.5,0.2,Iris-setosa</span></pre><p id="150e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">到…里面</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="0c64" class="li kg hu me b fv mi mj l mk ml">5.0,3.4,1.5,0.2</span></pre><p id="3d68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Map是一个将函数应用于列表中每一项的函数。它应用的函数是lambda(匿名)函数。lambda函数是一个只用于一个目的的函数，所以它不需要有自己的define语句。lambda的语法如下所示:</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="8a20" class="li kg hu me b fv mi mj l mk ml">Lambda var1, var2: calculation</span></pre><p id="f3f2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个例子中，我们有两个变量，x和y，我们把它们放入毕达哥拉斯的定理中。映射语法是:</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="56ca" class="li kg hu me b fv mi mj l mk ml">map ( function, list)</span></pre><p id="81a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我们的映射有两个列表，X和y。当它进行数学运算时，它获取list1的第一个元素并将其转换为一个名为X的变量，然后获取list2的第二个元素并将其转换为一个名为y的变量。这样做直到两个列表中的所有项目都完成。</p><p id="bf5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后一部分，list，把我们的地图变成一个列表。所以我们得到了一个列表，包含了毕达哥拉斯对列表1和列表2中每一项的输出，这只是</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="cb2b" class="li kg hu me b fv mi mj l mk ml">[4, 4, 4]</span></pre><p id="4c45" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的下一段代码是</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="d53d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们知道了list(map(…我们是否可以忽略它，把它当作一个返回[4，4，4]的函数。</p><p id="1f08" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以留给我们这个时髦的函数:</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="8417" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，reduce只是来自Haskell的foldl，但用Python实现。它接受一个列表并把它转换成一个值。它通过将一个函数应用于一个列表来实现这一点。它应用的函数也是一个lambda函数，将x和y相加。x和y是什么？假设我们有这样一个列表</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="e05f" class="li kg hu me b fv mi mj l mk ml">[1, 2, 3]</span></pre><p id="14d6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后当我们加上x + y，我们得到</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="82ba" class="li kg hu me b fv mi mj l mk ml">[1, 2, 3]<br/>x = 1, y = 2<br/>1 + 2 = 3<br/>x = 3, y = 3<br/>x + y = 6</span></pre><p id="0fb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们知道lambda函数在reduce里面做了什么，它应用于什么列表？嗯，reduce是将我们之前的map函数生成的列表转换成一个值。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="6c3f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以list取[4，4，4]并把它们加在一起。4 + 4 + 4 = 12.所以输出是12。</p><p id="1071" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们只需要找到它的平方根，这很简单。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="b24f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然这可能不可读，但一旦你了解一些函数式编程，就很容易理解了。</p><p id="c3c5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有一个小错误，所有的花都以一个字符串结尾，代表它是什么花。我们不能对它进行数学运算，所以我们必须使用这个函数</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="5461" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们传递给欧几里德距离函数。</p><p id="5e8b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们需要找出从训练集中的每个项目到测试集中的项目的距离。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="3d5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码简单地将一个lambda(匿名)函数映射到训练集和测试集中的每个元素，该函数查找两个元素之间的距离，并在一个列表中返回这些距离。然后，第二部分以相应的距离将元素拉在一起。所以第一部分返回</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="e19d" class="li kg hu me b fv mi mj l mk ml">[3.4641016151377544, 0.0]</span></pre><p id="b435" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当给定这些参数时</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="b53f" class="li kg hu me b fv mi mj l mk ml">trainSet = [[2, 2, 2, 'a'], [4, 4, 4, 'b']]</span><span id="7b3c" class="li kg hu me b fv mm mj l mk ml">testInstance = [4, 4, 4]</span><span id="8d8a" class="li kg hu me b fv mm mj l mk ml">k = 1</span></pre><p id="8278" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第二部分返回这个</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="1a48" class="li kg hu me b fv mi mj l mk ml">[([2, 2, 2, ‘a’], 3.4641016151377544), ([4, 4, 4, ‘b’], 0.0)]</span></pre><p id="db44" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">代码的最后一部分对代码进行排序，并返回K个邻居，在本例中K = 1，所以它只返回</p><pre class="lx ly lz ma fq md me mf mg aw mh dt"><span id="e2a0" class="li kg hu me b fv mi mj l mk ml">[[4, 4, 4, 'b']]</span></pre><p id="c7da" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来我们需要投票决定K可能是什么，现在我们知道了它的邻居。我们将创建一个投票系统。每个邻居将对其属性(即它是什么)进行投票，多数投票将作为预测。因此，如果它的大多数邻居属于“a”类，那么预测将属于“a”类。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="no mc l"/></div></figure><p id="0920" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以这只是通过所有最近的邻居，并保持一个字典。字典就是花名+出现次数。每朵花为它们的类型投票到字典中，字典被排序，所以投票最多的出现在字典的第一项中，然后返回预测的花。</p><p id="0e1a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">仅此而已。我们已经建立了一个K近邻分类器。如果你想阅读更多关于实现这个算法的内容，我建议你阅读<a class="ae jg" href="https://machinelearningmastery.com/tutorial-to-implement-k-nearest-neighbors-in-python-from-scratch/" rel="noopener ugc nofollow" target="_blank">这个</a>或者<a class="ae jg" href="https://www.dataquest.io/blog/k-nearest-neighbors-in-python/" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><h1 id="de2e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">k近邻vs朴素贝叶斯</h1><p id="675e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">何时实现KNN或奈伊夫·贝叶斯完全取决于你。两者都有一些优点和缺点，所以我在这里列出来:</p><p id="3f88" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> K近邻优势</strong></p><ul class=""><li id="da82" class="mz na hu jj b jk jl jo jp js nb jw nc ka nd ke pi nf ng nh dt translated">简单但有效</li><li id="2644" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke pi nf ng nh dt translated">只有一个参数K可以通过交叉验证轻松学习</li></ul><p id="dbe6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">K-最近邻缺点</strong></p><ul class=""><li id="7127" class="mz na hu jj b jk jl jo jp js nb jw nc ka nd ke pi nf ng nh dt translated">最近是什么意思？需要定义一个距离度量</li><li id="2551" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke pi nf ng nh dt translated">计算成本—必须在测试时存储和搜索整个训练集。</li></ul><p id="6627" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:网飞进步奖获得者<a class="ae jg" href="http://cs229.stanford.edu/proj2006/HongTsamis-KNNForNetflix.pdf" rel="noopener ugc nofollow" target="_blank">实际上是K近邻。</a></p><p id="7b30" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">奈伊夫·贝叶斯的优势</strong></p><ul class=""><li id="a4a7" class="mz na hu jj b jk jl jo jp js nb jw nc ka nd ke pi nf ng nh dt translated">实现起来非常简单</li><li id="4161" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke pi nf ng nh dt translated">需要较少的训练数据</li><li id="cce0" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke pi nf ng nh dt translated">可以概括数据</li></ul><p id="43cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">朴素贝叶斯的缺点</strong></p><ul class=""><li id="84d5" class="mz na hu jj b jk jl jo jp js nb jw nc ka nd ke pi nf ng nh dt translated">数据越多，准确度越高，所以要达到95%或更高的准确度，你需要大量的数据</li><li id="7d85" class="mz na hu jj b jk ni jo nj js nk jw nl ka nm ke pi nf ng nh dt translated"><a class="ae jg" href="https://stats.stackexchange.com/questions/183056/what-does-it-mean-disadvantage-of-naive-bayes-classifier-strong-feature-indepe" rel="noopener ugc nofollow" target="_blank">强独立性假设</a></li></ul><p id="a3e6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你现在应该在机器学习方面有了坚实的基础。我决定教你定义这些算法的基础数学和理论，而不是教你一种很可能在3年内被取代的算法，然后展示两种可能会存在一段时间的最广泛使用的算法。</p><h1 id="bf24" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">请随时与我联系:</h1><p id="bde6" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated"><a class="ae jg" href="https://www.linkedin.com/in/brandonls/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae jg" href="https://github.com/brandonskerritt/" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="pj mc l"/></div></figure></div></div>    
</body>
</html>