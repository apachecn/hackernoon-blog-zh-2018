<html>
<head>
<title>Functional Programming Paradigm Demystified (Core Concepts)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去神秘化的函数式编程范式(核心概念)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-programming-paradigm-demystified-core-concepts-d9828762717e?source=collection_archive---------14-----------------------#2018-01-15">https://medium.com/hackernoon/functional-programming-paradigm-demystified-core-concepts-d9828762717e?source=collection_archive---------14-----------------------#2018-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ad1f120e49e2513fae15ed2098a215a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2gUD6BhNjkF7ac4UEwg5Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/5mZ_M06Fc9g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Roman Mager</a> on <a class="ae jg" href="https://unsplash.com/search/photos/math?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e21b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">准备好离开面向对象编程的领域，进入未知的领域。</p><p id="e9de" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">老实说，我真的很高兴和你一起揭开我最近一直困扰的一个话题的神秘面纱。</p><p id="f7d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是对<strong class="jj hv">函数式编程范例</strong>的概述。</p><p id="2fcc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我想探讨它背后的一些核心概念和基本思想。这些概念你现在就可以开始应用到大多数编程语言中。</p><p id="df57" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了尽可能顺利地进行，我将试着一路说明这一点。</p><p id="b466" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我真的希望这能让你和我一样，对函数式范例能给web开发的未来带来什么感到兴奋。</p><p id="f2a7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> <em class="kf">免责声明</em> </strong> <em class="kf">:我绝不是专业的函数式程序员。我仍然处于这种范式的早期，因为大约一年半前我才开始与它混合。一开始你可能会觉得这很神秘，但是请耐心听我说，我真的认为函数性是我逻辑思维中最大的突破之一。</em></p><p id="d364" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以不开玩笑了，让我们开始吧。</p><h1 id="3204" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">什么是函数式编程？</h1><p id="ab56" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated"><em class="kf">姑且称之为FP吧，为了酷孩子。</em></p><p id="025a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们偷懒吧，因为FP爱偷懒，引用一句名言来定义主题:</p><blockquote class="lj lk ll"><p id="f611" class="jh ji kf jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated"><em class="hu">功能</em> <a class="ae jg" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank"> <em class="hu">编程</em> </a> <em class="hu">有许多不同的定义。从Haskell的角度来看，Lisp程序员的定义是非常不同的。OCaml的FP与Erlang中的范式没有多少相似之处。你甚至会在</em><a class="ae jg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"><em class="hu">JavaScript</em></a><em class="hu">中找到几个相互竞争的定义。然而，有一个束缚——一些模糊的当我看到它时就知道的定义，很像淫秽(事实上，有些人确实觉得FP淫秽！)[…] </em></p></blockquote><p id="1eb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">布莱恩·朗斯多夫</p><p id="eef0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然这个定义越来越元，但随着你采用FP风格，它实际上会变得越来越有意义。</p><p id="4809" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了来自Brian Lonsdorf，一个功能性的大布道者，这个引用来自JS大师Kyle Simpson的书《Functional Light JS》的前言。如果你是一名网络开发人员，并且你对学习FP非常感兴趣，这应该是你的第一本<a class="ae jg" href="https://github.com/getify/Functional-Light-JS" rel="noopener ugc nofollow" target="_blank">必读书籍</a>。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/2caf9547ee2f33f0393f5f52338309a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*rlZ27cgu8ymb_MWU.png"/></div></figure><p id="0ef8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你真的很认真，很难找到学习FP的时间，那么停止阅读这篇文章(你这个傻瓜),开始读这本书，就像真的一样。</p><h1 id="db4b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">功能范式核心概念</h1><p id="0da5" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我们不会真的触及FP的任何深刻的学术数学根源，这是你可能会自然潜入的东西，如果你最终拿起范式，但我不认为这是必要的。</p><p id="4094" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们更倾向于关注适用于大多数编程语言的概念。有了这些，你就可以开始在日常生活中逐步使用它了。</p><h1 id="d822" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">功能不是你想象的那样</h1><p id="1eef" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在开始任何具体的事情之前，我想让你对FP中的术语“函数”有一些基本的了解。FP中的函数比你用命令式范式得到的经典定义要严格得多。</p><p id="155a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你以前从未做过FP，这可能对你来说是真实的:</p><blockquote class="lu"><p id="fe0d" class="lv lw hu bd lx ly lz ma mb mc md ke ek translated"><em class="me">函数==方法==过程==子程序。</em></p></blockquote><p id="4b02" class="pw-post-body-paragraph jh ji hu jj b jk mf jm jn jo mg jq jr js mh ju jv jw mi jy jz ka mj kc kd ke hn dt translated">不再是了，伙计。从现在起，你应该对函数采取更数学化的方法。</p><h2 id="15c2" class="mk kh hu bd ki ml mm mn km mo mp mq kq js mr ms ku jw mt mu ky ka mv mw lc mx dt translated">数学方法？</h2><p id="39e6" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在数学函数中，既没有范围也没有全局状态。除了<em class="kf">输入变量</em>之外，不能访问任何信息。</p><p id="8056" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这意味着，如果你把f(x) = x写在一张纸上，写在火星的沙土上，或者在电脑上定义函数，那么对于x = 5，它的值总是25。</p><p id="617d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你做到了这一点，你将最终获得数学世界的所有神奇好处(提示；比你想象的要多得多)。</p><h2 id="04c4" class="mk kh hu bd ki ml mm mn km mo mp mq kq js mr ms ku jw mt mu ky ka mv mw lc mx dt translated">一个函数应该是纯的</h2><p id="ada1" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">纯意味着给定相同的输入，函数应该<em class="kf">总是</em>返回相同的输出，这是确定性的。</p><p id="68d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们再次强调<em class="kf">总是</em>。这意味着那些不被认为是纯粹的:</p><ul class=""><li id="8977" class="my mz hu jj b jk jl jo jp js na jw nb ka nc ke nd ne nf ng dt translated">IO操作</li><li id="7242" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated">Web请求，</li><li id="01c5" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated">任何可以抛出异常的东西</li></ul><p id="74cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，一些像Haskell这样的纯函数式编程语言会强制执行这一规则，而一些则更加灵活。你可能会问，如果你不能做到所有这些，你的程序的目的到底是什么。嗯，答案是你确实可以，但是以一种非常特殊的方式。</p><p id="d6af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个概念对于这篇文章的目的来说太先进了，所以我们不会涉及它，但是如果你继续你的FP之旅，你肯定会自己在这上面绊倒。；)</p><h2 id="cea4" class="mk kh hu bd ki ml mm mn km mo mp mq kq js mr ms ku jw mt mu ky ka mv mw lc mx dt translated">这意味着什么？</h2><p id="5d37" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">一个函数调用唯一的外部交互是它的返回值。</p><p id="03bc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你将函数调用替换为它的返回值，这在你的程序中不会引起任何变化，这叫做<a class="ae jg" href="https://en.wikipedia.org/wiki/Referential_transparency" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">引用透明</strong> </a>。</p><p id="5268" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以这种方式使用函数大大减少了你的大脑为了理解逻辑而必须加载的信息量，从而使你在长期内更有效率。</p><p id="f67d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这样你就不必在心里计算程序在x时刻的整个当前状态。你只需看看函数的输入，就能<em class="kf">确定当前状态。</em></p><p id="ce86" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，老实说，在FP中有更多关于严格函数定义的“规则”,但这是我认为你现在应该知道的唯一一条。</p><h1 id="0900" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">范畴理论在程序设计中的应用</h1><p id="9dcc" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">正如我所说的，函数式编程植根于数学，但更具体地说是源于<a class="ae jg" href="https://en.wikipedia.org/wiki/Category_theory" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">范畴理论</strong> </a>。</p><p id="a1d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一数学分支主要旨在“理解保持数学结构的过程”</p><p id="affe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么和编码有关系？原来任何数据结构也是数学结构。对我们大多数开发人员来说，我们的工作主要是一遍又一遍地修改数据结构。</p><h2 id="baf3" class="mk kh hu bd ki ml mm mn km mo mp mq kq js mr ms ku jw mt mu ky ka mv mw lc mx dt translated">了解流程</h2><p id="1724" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">基本上，我们讨论的是对数据结构中的数据进行的任何转换。</p><p id="7063" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们来看一个例子。</p><p id="d190" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设我们用面向对象的方法来做这件事:</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><p id="1309" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是这段代码详细说明的内容:</p><ul class=""><li id="b1d9" class="my mz hu jj b jk jl jo jp js na jw nb ka nc ke nd ne nf ng dt translated">创建新数组(与先前的数组结构相同)</li><li id="474e" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated">如果数字是偶数，我们乘以2，并将其添加到新的数组中</li></ul><p id="6546" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果我们用我们刚刚谈到的“流程”和“结构”来分析这段代码，我们会得出以下结论:</p><ul class=""><li id="891a" class="my mz hu jj b jk jl jo jp js na jw nb ka nc ke nd ne nf ng dt translated">我们有两个流程:</li></ul><ol class=""><li id="fdb6" class="my mz hu jj b jk jl jo jp js na jw nb ka nc ke no ne nf ng dt translated">我们过滤掉奇数</li><li id="4f7a" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke no ne nf ng dt translated">我们将每个数字乘以2</li></ol><p id="5902" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就是这样，两个流程，一个结构。它非常符合我们刚刚谈到的数学分支。</p><p id="5365" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么在FP中会是什么样子呢？</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure><h2 id="aac1" class="mk kh hu bd ki ml mm mn km mo mp mq kq js mr ms ku jw mt mu ky ka mv mw lc mx dt translated">从这个函数式编程例子中得到的启示</h2><p id="b8d2" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">老实说，在这个例子中没有什么太大的改变，但是让我们试着从这个例子中得到一些启示。</p><p id="7682" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以看到一个直接在数组上使用的新函数，<strong class="jj hv">图</strong>之一。这个函数通常被简单地解释为“它允许你为列表中的每个元素应用一个函数”。</p><p id="d291" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然数组的map实现是正确的，但还有更多方法。</p><p id="3797" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们换一种方式来说:map函数提供了一种将函数应用于某个特定上下文中的方法，它留给特定的上下文来实现该方法。</p><blockquote class="lu"><p id="c228" class="lv lw hu bd lx ly lz ma mb mc md ke ek translated"><em class="me">这里的</em>  <em class="me">很好地介绍了这些概念。它更理论化一点，但仍然非常容易理解。</em></p></blockquote><p id="7e18" class="pw-post-body-paragraph jh ji hu jj b jk mf jm jn jo mg jq jr js mh ju jv jw mi jy jz ka mj kc kd ke hn dt translated">我们再聚精会神地读一遍这个:“[map]是一种将功能应用于某个特定上下文中所包装的东西的方式”。</p><p id="5b9d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们根据我们的例子来重新措辞:“[map]是一种将函数应用于包装在数组内的每个值的方法”。</p><p id="8892" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以看到我们回到了最初的琐碎定义，但我们现在理解了它背后的抽象概念。</p><p id="ea4e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里的要点不仅在于知道如何使用Array.map函数，而且在于掌握一个通用数据结构(如数组)如何能够给出一个抽象的实用函数，以便它能够处理其中的任何数据。</p><p id="057f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">到那时，也只有到那时，你才会开始感受到函数式编程的抚慰之光——在认识到这一点之前，FP通常会感觉像地狱，尽管有点有趣(一点也不像PHP)。</p><p id="318c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一张很好的图片，展示了你的学习过程可能会是什么样子:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff np"><img src="../Images/1ee27ad57ba807a37fad62a7b8afe914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*wdifL5Zlt05ILiSh.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Perseverance will pay, big time.</figcaption></figure><h1 id="d4df" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">可组合性和可重用性</h1><p id="88bd" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">你应该记住的启动FP之旅的最后一个概念是我们从一开始就一直默默指向的:可组合性。</p><p id="a6a4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过尽可能细粒度地表达您的数据操作，您将自然地创建小的逻辑构建块，这将提供比您可能习惯的更多的可组合性——换句话说:<strong class="jj hv">粒度孕育可组合性</strong>。</p><p id="0503" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可组合性是伟大编程的基础，因为它是实现适当的<em class="kf">可重用性</em>的条件。一旦你开始越来越多地摆弄FP原则，你会开始一遍又一遍地做事情，你会想要添加一些“元”实用功能，如作曲、咖喱、记忆等。</p><p id="9ed3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">目前这些可能不值得你使用，但是你绝对应该看一看。</p><h1 id="b774" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结束语和要点</h1><p id="079e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">事实证明，将修改数据的函数和应用它们的顺序分开是一个非常好的主意。它隔离了你的顾虑，减少了噪音。FP很自然的这样引导你。</p><p id="3592" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以想一想，甚至看看你已经写的一些代码，看看这些原则是否合适。我敢打赌，你写的大部分代码都是这样。只有一些架构概念很难在FP中建模，我不认为你现在就投入进去是好的。</p><p id="294b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关键是，你通常编写的“业务逻辑”的整个领域可以很容易地从这些原则中受益，而无需进行重大的修改。</p><h1 id="67cd" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">跳入功能范式</h1><p id="374b" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">一个非常好的库是<a class="ae jg" href="http://ramdajs.com/docs/" rel="noopener ugc nofollow" target="_blank"> Ramda.js </a>，阅读他们的文档会给你很好的见解。</p><p id="ca3c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以下是我鼓励您探索的其他参考资料，以便开始学习&amp;进一步发展您的函数式编程知识:</p><ul class=""><li id="a7f4" class="my mz hu jj b jk jl jo jp js na jw nb ka nc ke nd ne nf ng dt translated"><a class="ae jg" href="https://github.com/getify/Functional-Light-JS" rel="noopener ugc nofollow" target="_blank">功能灯JS </a>，凯尔·辛普森(这个怎么推荐都不过分)。</li><li id="0f2e" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated">弗里斯比教授的函数式编程指南</li><li id="4983" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated"><a class="ae jg" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener ugc nofollow" target="_blank">图片中的函子、应用程序和单子</a></li><li id="43ca" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated"><a class="ae jg" href="https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript" rel="noopener ugc nofollow" target="_blank">弗里斯比教授关于函数式编程的(令人敬畏的)书呆子视频系列</a></li><li id="bec5" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated"><a class="ae jg" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank">幻想世界规范，又名代数JavaScript规范</a>(这个带有一个警告——这里是更重、更抽象的东西)</li></ul><p id="8c49" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">但是，嘿，我能给你的最大建议是循序渐进，如果遇到困难就问问题。</strong></p><p id="cb1f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，这里有两个挑战你应该试着按顺序去做:</p><ul class=""><li id="2d23" class="my mz hu jj b jk jl jo jp js na jw nb ka nc ke nd ne nf ng dt translated">下个月不要写任何for循环</li><li id="dc1c" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated">一旦你做到了这一点，代码功能，如过滤器，地图和减少自己。这会给你一个很好的挑战，并迫使你了解在引擎盖下发生了什么。</li></ul><p id="cc04" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦你完成了这个，我希望你马上回来告诉我实验进行得怎么样了。我真的很感激让对话进行下去，所以点击下面的评论区的任何意见或问题！</p><p id="e996" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最重要的是，快乐的功能编码。；)</p></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><p id="3a41" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我最初在<a class="ae jg" href="https://snipcart.com/blog/functional-programming-paradigm-concepts" rel="noopener ugc nofollow" target="_blank">的Snipcart博客</a>上发表了这篇文章，并在我们的<a class="ae jg" href="http://eepurl.com/cDZnQ9" rel="noopener ugc nofollow" target="_blank">时事通讯</a>上分享了它。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nx nn l"/></div></figure></div></div>    
</body>
</html>