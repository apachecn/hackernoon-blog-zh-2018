<html>
<head>
<title>Beginner’s Guide to Interactive Rebasing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交互式重置基础初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/beginners-guide-to-interactive-rebasing-346a3f9c3a6d?source=collection_archive---------4-----------------------#2018-01-16">https://medium.com/hackernoon/beginners-guide-to-interactive-rebasing-346a3f9c3a6d?source=collection_archive---------4-----------------------#2018-01-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="347c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今年早些时候，我第一次做了一个交互式的rebase，我对人们可以用它做什么印象深刻。一开始我也觉得有点复杂。希望这个指南将有助于消除一些不确定性。</p><p id="af53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，因为它非常强大，您可以从根本上改写历史，在我们开始之前，有一个小小的警告:关于Git以及重新设置基础是否是一个好主意，有许多思想流派。这篇文章不会<strong class="it hv">深入这些讨论，而纯粹是为了介绍使用交互式重定基础的基础知识。</strong></p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><h1 id="800e" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="fe8a" class="ku kv hu it b iu kw iy kx jc ky jg kz jk la jo lb lc ld le dt translated">交互式重定基础可用于以多种方式更改提交，如编辑、删除和压缩。</li><li id="b322" class="ku kv hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">要告诉Git从哪里开始交互式rebase，使用您想要修改的提交之前的提交的SHA-1或索引。</li><li id="195e" class="ku kv hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">在交互式rebase过程中，当Git在您标记为edit的提交处暂停时，工作流与普通的提交过程没有什么不同——您暂存文件，然后提交它们。唯一的区别是您使用了命令<code class="eh lk ll lm ln b">git commit --amend</code>而不是<code class="eh lk ll lm ln b">git commit</code>。</li><li id="085b" class="ku kv hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">交互式重定基础将创建新的SHA-1，因此最好对尚未推送到远程分支的提交使用交互式重定基础。</li></ul></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><h1 id="9808" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">问题是</h1><p id="a080" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">在这个例子中，我们将经历这样一种情况:我们一直在一个特性分支中工作，并且我们有几个提交想要更改或删除。下面是我们的git日志的样子:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/0472a4b2965ad325beae1e0d8245a92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*YH_4G37Tc-sBVYe9.png"/></div></figure><p id="1beb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从上面的git日志中，这里是我们想要改变的两个提交:<br/> <code class="eh lk ll lm ln b">4a4d705</code> -在这个提交中我们意外地提交了一个合并冲突<br/> <code class="eh lk ll lm ln b">6c01350</code> -在这个提交中我们移除了合并冲突</p><p id="63ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们想要做的是及时回到<code class="eh lk ll lm ln b">4a4d705</code>，删除提交中的合并冲突，然后删除<code class="eh lk ll lm ln b">6c01350</code>，因为合并冲突已经解决，我们不再需要这个提交。这将是对我们提交历史的改进，原因有二:</p><ol class=""><li id="8411" class="ku kv hu it b iu iv iy iz jc lz jg ma jk mb jo mc lc ld le dt translated">我们不会有失败的提交(合并冲突)</li><li id="653e" class="ku kv hu it b iu lf iy lg jc lh jg li jk lj jo mc lc ld le dt translated">我们将只进行有意义的提交，而不进行仅与修复丢失的合并冲突相关的提交</li></ol></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><h1 id="67fb" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">解决方案</h1><p id="779a" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">这种情况很适合交互式重定基础。斯科特·沙孔在他的书<a class="ae md" href="https://git-scm.com/docs/git-rebase" rel="noopener ugc nofollow" target="_blank"> <em class="me"> Pro Git </em>这正是交互式rebase的用途:通过重新安排和编辑提交，将多个提交压缩为一个，在大量[工作已经提交]后使用它。”</a></p><h1 id="440e" class="jw jx hu bd jy jz mf kb kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt dt translated">我们想要修改哪些提交？</h1><p id="c7bb" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">要启动交互式rebase，我们需要告诉Git我们想要修改哪些提交。我们通过引用我们想要修改的最早提交之前的提交来做到这一点。或者，简单地说，根据斯科特·沙孔的说法，我们引用“我们希望保持原样的最后一次提交”。</p><p id="5a82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看我们的例子，以便更好地理解。有两种方法可以引用这个提交:<br/> <em class="me">由SHA-1</em>——我们想要保持原样的最后一个提交具有<code class="eh lk ll lm ln b">528f82e</code>的阿沙-1，因此我们可以将它传递到我们的交互式rebase命令中。<br/><em class="me">By Index</em>——我们想要保留的最后一个提交的索引位置为3 (Git使用基于零的索引)，因此我们可以将<code class="eh lk ll lm ln b">HEAD~3</code>传递给我们的交互式rebase命令。</p><p id="63bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意——如果您只有几个提交来进行交互式rebase，使用索引对大多数人来说可能更容易。但是，如果您有很多提交，使用SHA-1可能会更容易，这样您就不必一直计算git日志了。</p><h1 id="5075" class="jw jx hu bd jy jz mf kb kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt dt translated">开始交互式重置基础</h1><p id="e131" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">基于我们的示例，我们将运行:</p><p id="5e6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lk ll lm ln b">$ git rebase -i 528f82e</code></p><p id="0734" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><p id="ab9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lk ll lm ln b">$ git rebase -i HEAD~3</code></p><p id="5498" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将在Vim中打开此窗口:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mk"><img src="../Images/edd192bd963e98d81f41831583ee7e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K_tYrMvbzRdnWOMV.png"/></div></div></figure><p id="f816" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，提交的顺序与git log相反。在git日志中，最近的提交在最上面。在这个视图中，最近的提交在底部。还要注意，下面的注释给出了我们可以在每次提交时使用的有效命令的有用列表。</p><p id="1ccd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你不知道Vim，只需点击你想要编辑的每个单词<code class="eh lk ll lm ln b">pick</code>，然后按<code class="eh lk ll lm ln b">&lt;i&gt;</code>键(插入模式)。一旦你完成输入，点击<code class="eh lk ll lm ln b">&lt;esc&gt;</code>键退出插入模式。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mp"><img src="../Images/74a990d48152e8db545d3d033d3e624d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TCMQV9tbh-VOABFZ.png"/></div></div></figure><p id="a12a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的示例中，对于我们想要修改的提交，我们将命令更改为<code class="eh lk ll lm ln b">edit</code>,对于我们想要删除的提交，我们将命令更改为<code class="eh lk ll lm ln b">drop</code>。然后我们运行<code class="eh lk ll lm ln b">:wq</code>保存并退出Vim窗口。</p><h1 id="405f" class="jw jx hu bd jy jz mf kb kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt dt translated">修改提交</h1><p id="50db" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">回到终端，我们看到这条消息:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/0f808bd17dad15ebf30149b6ea5a4227.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/0*wQvDhUVmN_YU4KYg.png"/></div></figure><p id="433e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这使得我们在<code class="eh lk ll lm ln b">4a4d705</code>停止是有意义的。这是我们想要修改的一系列提交中最旧的提交。我们将从这个提交开始，并通过每个提交进行工作，直到最近的提交。</p><p id="3b38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提醒一下，<code class="eh lk ll lm ln b">4a4d705</code>是我们意外提交的带有合并冲突的提交。当我们打开编辑器时，我们看到了合并冲突:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/6cce525ba2932305f814054248b10a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*8OJQWCCLQiHIdQ_Q.png"/></div></figure><p id="e2e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们修复了文件中的合并冲突，但是我们现在做什么呢？当有疑问时，<code class="eh lk ll lm ln b">git status</code>:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/3c9a24075f71afc3cde1a9967f2dc150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*kZ3RRsbGJiHquWRa.png"/></div></figure><p id="b636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">酷！这其实是有帮助的。我们看到我们当前正在编辑<code class="eh lk ll lm ln b">4a4d705</code>，并且我们看到在这之后接下来的两个提交将被执行。</p><p id="cd51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">消息的其余部分是向我们解释一个熟悉的工作流程。Git告诉我们是否想要修改提交，我们运行<code class="eh lk ll lm ln b">git commit --amend</code>。这将基本上充当我们在正常工作流中使用的典型<code class="eh lk ll lm ln b">git commit</code>。在此消息的底部，我们看到我们的文件已被修改，反映了我们刚刚为消除合并冲突所做的更改。我们需要在提交前暂存文件。这与正常的工作流程没有什么不同。</p><p id="7757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们所做的就是<code class="eh lk ll lm ln b">git add tempChanger.js</code>暂存编辑过的文件，然后<code class="eh lk ll lm ln b">git commit --amend</code>提交暂存的文件！这将再次打开一个Vim窗口，并显示提交消息:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/85d8fa6e9dbaf264fae91673024a7c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*YkTrYamd36M9wS5b.png"/></div></figure><p id="cd23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以编辑提交消息，也可以保持原样。让我们选择保持提交消息不变，我们将键入<code class="eh lk ll lm ln b">:wq</code>保存并退出窗口。</p><p id="1d36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在已经编辑了我们的旧提交。那现在怎么办？运行<code class="eh lk ll lm ln b">git status</code>:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/c7972c390b98f241a2f80aadb9dd4941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/0*AUCY27hruX1tbaMX.png"/></div></figure><h1 id="86ed" class="jw jx hu bd jy jz mf kb kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt dt translated">继续交互式重置基础</h1><p id="0687" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">我们在提交中没有其他要更改的内容，所以让我们继续吧！</p><p id="95d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们运行<code class="eh lk ll lm ln b">git rebase --continue</code>并看到以下消息:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/8900bbfc20402bfc0c8f53e4cb9b2896.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*_mXTdumDSIajPg4D.png"/></div></figure><p id="db68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇，我们完了？但是另外两次呢？下一个要执行的提交是<code class="eh lk ll lm ln b">6c01350</code>。当我们开始交互式rebase时，我们将这个提交标记为删除(<code class="eh lk ll lm ln b">drop</code>)。Git自动删除它，并转移到下一次提交，<code class="eh lk ll lm ln b">41aa9d2</code>。这个在最初的交互式rebase中从未被修改过。它的默认命令是<code class="eh lk ll lm ln b">pick</code>，这意味着将使用提交。Git应用了这个提交，因为这是最后一次提交，所以交互的rebase完成了。</p><p id="6752" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，如果我们有更多的提交要编辑，我们将简单地移动到下一个提交，并开始修改它的过程，就像我们上面做的那样。这个循环一直持续到没有提交为止。</p><h1 id="a9ba" class="jw jx hu bd jy jz mf kb kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt dt translated">弹出按钮</h1><p id="c748" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">值得注意的是，如果在我们的交互式rebase的任何一点上我们把事情搞砸了，并且不知道如何修复它们，我们总是可以中止。在任何时候，我们都可以在终端中运行<code class="eh lk ll lm ln b">git rebase --abort</code>,交互式重设基础将被中止，不保存任何更改。然后，我们需要再次开始交互式rebase。</p><h1 id="ae71" class="jw jx hu bd jy jz mf kb kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt dt translated">交互式重置基础后</h1><p id="00ca" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">我们的git日志现在看起来像这样:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/f07e5ee5da013b78bc2dbdbd01d735b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/0*jUzN8xeV8qQZJpw9.png"/></div></figure><p id="abee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您会注意到，在我们开始交互式重新构建基础之前，有一些事情发生了变化:</p><ul class=""><li id="9175" class="ku kv hu it b iu iv iy iz jc lz jg ma jk mb jo lb lc ld le dt translated">我们不再有提交消息“移除合并冲突”的提交<code class="eh lk ll lm ln b">6c01350</code>。这是我们在交互式rebase中删除的提交。</li><li id="181b" class="ku kv hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">我们的提交我们编辑，<code class="eh lk ll lm ln b">4a4d705</code>，有一个不同的SHA-1，<code class="eh lk ll lm ln b">2b7443d</code>。</li><li id="e693" class="ku kv hu it b iu lf iy lg jc lh jg li jk lj jo lb lc ld le dt translated">我们原始git日志中最近的提交<code class="eh lk ll lm ln b">41aa9d2</code>也有一个新的SHA-1<code class="eh lk ll lm ln b">2b95e92</code>。此提交并未更改，而仅应用于其之前的提交<code class="eh lk ll lm ln b">2b7443d</code>。</li></ul><h1 id="980e" class="jw jx hu bd jy jz mf kb kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt dt translated">交互重定基准的副作用</h1><p id="9cd1" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">对于我们的git日志中最近的两个提交，由于它们具有新的SHA-1，Git将它们视为全新的提交。上一次提交<code class="eh lk ll lm ln b">2b95e92</code>时甚至是这样，提交消息和文件都没有更改。这就为交互式重定基准带来了一个要点:<strong class="it hv">如果修改一个提交，该提交和所有后续提交将具有新的SHA-1。</strong></p><p id="538c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果已修改的提交尚未推送到远程分支，则这不会影响任何操作。但是，如果您确实对已经推送到远程分支的提交完成了交互式rebase，然后再次推送到分支，您将看到:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/284fdd613ad899846770c297099f7bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*tDK5P-3oVJButKqq.png"/></div></figure><p id="ddff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从技术上讲，你可以通过使用<code class="eh lk ll lm ln b">git push --force</code>绕过这个，但这是非常危险的。如果远程分支具有来自其他人的提交，但您的本地分支还没有这些提交，则您将有效地删除他们的提交。</p><p id="90ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个解决方案是使用<code class="eh lk ll lm ln b">git push --force-with-lease</code>，它将只修改您的提交，而不修改属于其他人的提交，尽管这也可能是有问题的。例如，如果另一个开发人员已经拥有在他们的本地分支上被给予新SHA-1的那些提交，当他们拉远程分支时，他们将与这些提交中的每一个具有合并冲突。</p><p id="81d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh lk ll lm ln b">--force-with-lease</code>的时间超出了本文的讨论范围，但在此之前最好咨询一下团队中的其他成员。你可以在这里阅读更多关于<code class="eh lk ll lm ln b">git push --force-with-lease</code> <a class="ae md" href="https://git-scm.com/docs/git-push" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="ad03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本节的主要收获是，在尚未推送到远程分支的提交上使用交互式重定基准更加容易和安全。</p><p id="39c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="me">布莱克·德博执笔。最初发布于</em> <a class="ae md" href="https://dev.to/blakedeboer/beginners-guide-to-interactive-rebasing-1ob" rel="noopener ugc nofollow" target="_blank"> <em class="me"> Dev.to </em> </a></p></div><div class="ab cl jp jq hc jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hn ho hp hq hr"><p id="35b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">纽约市的资深、首席或主要开发人员？ <a class="ae md" href="https://www.stridenyc.com/careers" rel="noopener ugc nofollow" target="_blank"> <em class="me">大步流星正在招人</em> </a> <em class="me">！想要提升你的技术团队？</em> <a class="ae md" href="https://www.stridenyc.com/our-work" rel="noopener ugc nofollow" target="_blank"> <em class="me">看我们怎么做</em> </a> <em class="me">！</em><a class="ae md" href="http://www.stridenyc.com/" rel="noopener ugc nofollow" target="_blank"><em class="me">www.stridenyc.com</em></a></p></div></div>    
</body>
</html>