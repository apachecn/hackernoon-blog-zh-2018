<html>
<head>
<title>The Strategy Pattern Using Higher Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用高阶函数的策略模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-command-pattern-using-higher-order-functions-e482fe322460?source=collection_archive---------14-----------------------#2018-01-16">https://medium.com/hackernoon/the-command-pattern-using-higher-order-functions-e482fe322460?source=collection_archive---------14-----------------------#2018-01-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4c988db7d7d2e48d741caaaba9afd4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DI5CB1VUcSvNioCY8I48zA.png"/></div></div></figure><blockquote class="jc"><p id="0069" class="jd je hu bd jf jg jh ji jj jk jl jm ek translated">如果您的团队习惯于函数式编程，那么要知道像Strategy模式这样的设计模式也可以以函数的方式使用。</p></blockquote><p id="738d" class="pw-post-body-paragraph jn jo hu jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj jm hn dt translated">策略模式通常使用类来实现。然而，它可以很容易地在函数模式中实现。</p><p id="093d" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">通常，具有相同接口的所有策略对象都可以根据需要轻松交换。这是战略模式的主要好处之一。</p><p id="f47f" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">例如，如果您想要发送一封电子邮件，但是想要实现一种在通过Sparkpost还是通过AWS发送电子邮件之间进行切换的方法，您可以执行如下操作:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="f688" class="ky kz hu ku b fv la lb l lc ld">class EmailStrategy {<br/>  constructor() {}<br/>  execute(sender, receiver, subject, body) {<br/>    throw new Error('Not implemented');<br/>  }<br/>}</span><span id="38c2" class="ky kz hu ku b fv le lb l lc ld">class SparkPostEmailStrategy extends EmailStrategy {<br/>  constructor(apiKey, SparkPost) {<br/>    this.sparkpost = new SparkPost(apiKey);<br/>  }<br/>  execute(sender, receiver, subject, body) {<br/>    return this.sparkpost.transmissions.send({<br/>      content: {<br/>        from: sender,<br/>        subject,<br/>        html: body,<br/>      },<br/>      recipients: [<br/>        {address: sender}<br/>      ]<br/>    });<br/>  }<br/>}</span><span id="da0d" class="ky kz hu ku b fv le lb l lc ld">class AWSEmailCommand extends IEmailCommand {<br/>  constructor(AWS) {<br/>    this.ses = new AWS.SES();<br/>  }<br/>  execute(sender, receiver, subject, body) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      this.ses.sendEmail({<br/>        Destination: {<br/>          ToAddresses: [receiver]<br/>        }, <br/>        Message: {<br/>          Body: {<br/>            Html: {<br/>              Data: body,<br/>            },<br/>          }, <br/>          Subject: {<br/>            Data: subject,<br/>          }<br/>        }, <br/>        Source: sender,<br/>      }, (err, data) =&gt; {<br/>        if (err) reject(err);<br/>        resolve(data);<br/>      });<br/>    });<br/>  }<br/>}</span></pre><p id="1a0b" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">现在我们可以互换使用<code class="eh lf lg lh ku b">SparkPostEmailCommand</code>和<code class="eh lf lg lh ku b">AWSEmailCommand</code>:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="958a" class="ky kz hu ku b fv la lb l lc ld">const command = new SparkPostEmailCommand(myApiKey, SparkPost);<br/>command.execute('us@email.com', 'them@email.com', title, body)<br/>  .then((data) =&gt; console.log('success'))<br/>  .catch((err) =&gt; console.error('failure', err));</span></pre><p id="bc63" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">但是大多数命令对象只有两个方法:一个构造函数和一个执行方法(有时还有一个撤销方法)。感觉就像当我们调用构造函数时，我们只是延迟了<code class="eh lf lg lh ku b">execute</code>方法的执行，直到我们希望它执行它的副作用。</p><h1 id="89be" class="li kz hu bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me dt translated">使用高阶函数</h1><p id="a5de" class="pw-post-body-paragraph jn jo hu jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj jm hn dt translated">对我来说，这是一个使用高阶函数来简化上面的代码并消除对类的需求以支持简单函数的大好时机。</p><p id="0a4a" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">因为大多数时候，我们关心的只是建立一些依赖关系，然后延迟执行，所以我们可以将命令类写成函数:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="8f9d" class="ky kz hu ku b fv la lb l lc ld">const sparkPostEmailCommand = (apiKey, SparkPost) =&gt; {<br/>  const sparkpost = new SparkPost(apiKey);<br/>  return (sender, receiver, subject, body) =&gt; {<br/>    return sparkpost.transmissions.send({<br/>      // Same as above<br/>    });<br/>  };<br/>};</span><span id="e17d" class="ky kz hu ku b fv le lb l lc ld">const awsEmailCommand = (AWS) =&gt; {<br/>  const ses = new AWS.SES();<br/>  return (sender, receiver, subject, body) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      // Same as above<br/>    });<br/>  };<br/>};</span></pre><p id="e314" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">现在，我们不用创建新对象，只需将命令用作函数:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="09d3" class="ky kz hu ku b fv la lb l lc ld">sparkPostEmailCommand(myApiKey, SparkPost)('us@email.com', 'them@email.com', title, body)<br/>  .then((data) =&gt; console.log('success'))<br/>  .catch((err) =&gt; console.error('failure', err));</span></pre><p id="03b9" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">或者我们可以推迟执行:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="c363" class="ky kz hu ku b fv la lb l lc ld">const execute = sparkPostEmailCommand(myApiKey);<br/>// do some work<br/>execute('us@email.com', 'them@email.com', title, body);</span></pre><h1 id="cdf0" class="li kz hu bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me dt translated">为什么要使用高阶函数？</h1><p id="6887" class="pw-post-body-paragraph jn jo hu jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj jm hn dt translated">虽然其他语言中的类会给你一些类型提示和安全性，但在JavaScript中却不是这样。不幸的是，你不可能真的知道你的<code class="eh lf lg lh ku b">execute</code>方法的所有签名看起来都一样。</p><p id="7b8c" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">如果没有类型，就没有必要添加所有伴随类实现而来的臃肿。为什么担心<code class="eh lf lg lh ku b">this</code>的约束力？还是那个<code class="eh lf lg lh ku b">extends BaseCommand</code>？</p><p id="1551" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">使用这些设计模式的意义不在于它们需要面向对象。而是它们帮助你使用通用模式组织你的代码。构建一个具有依赖关系的对象，然后做一些事情是一种常见的模式，其中“做一些事情”可能以不同的方式完成。</p><p id="3d92" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">如果你的团队习惯了类和对象，那么就使用类和对象。</p><p id="2366" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt translated">如果你的团队习惯于功能性的<a class="ae mk" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>，那么要知道像命令模式这样的设计模式也可以以功能性的方式使用。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><blockquote class="ms mt mu"><p id="91b3" class="jn jo mv jp b jq kk js jt ju kl jw jx mw km ka kb mx kn ke kf my ko ki kj jm hn dt translated">Ivan Montiel是Clarity Hub的创始人兼首席执行官，该公司与Intercom集成，在帮助客户时为客户成功团队提供实时建议。</p><p id="a1f1" class="jn jo mv jp b jq kk js jt ju kl jw jx mw km ka kb mx kn ke kf my ko ki kj jm hn dt translated">你可以在<a class="ae mk" href="https://twitter.com/idmontie" rel="noopener ugc nofollow" target="_blank">推特</a>上关注他。</p></blockquote><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="59e7" class="pw-post-body-paragraph jn jo hu jp b jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ko ki kj jm hn dt">.</p></div></div>    
</body>
</html>