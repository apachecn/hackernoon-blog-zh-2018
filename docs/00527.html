<html>
<head>
<title>AWS Lambda Go vs. Node.js performance benchmark: updated 🔥</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda Go与Node.js性能指标评测:更新🔥</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/aws-lambda-go-vs-node-js-performance-benchmark-1c8898341982?source=collection_archive---------0-----------------------#2018-01-17">https://medium.com/hackernoon/aws-lambda-go-vs-node-js-performance-benchmark-1c8898341982?source=collection_archive---------0-----------------------#2018-01-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0c3980bbcf524592b99b6b2e2dc2b513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dW_FBqoUjyIWkOhDcvl9nA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Horse Racing Neck &amp; Neck. <a class="ae jg" href="http://www.publicdomainpictures.net/" rel="noopener ugc nofollow" target="_blank">http://www.publicdomainpictures.net/</a></figcaption></figure><p id="e5f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就在本周，AWS宣布为他们的Lambda服务发布Go。这非常令人兴奋，因为Go跨越了Java和Node之间的一个很大的缝隙。JS在类型安全、编程模型和性能方面的优势。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="b77c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">围绕Lambda和无服务器/FaaS计算的社区已经创建了库和框架来使用Node.js“填充”Go应用程序，但现在正式提供了支持。</p><h1 id="17a5" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">测试代码:斐波那契数列</h1><p id="c2fd" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们准备了两个非常简单的Lambda函数。两者都计算30个数字的斐波纳契数列。就是这样。是的，这是一个非常简单的测试，但这是重点。我明确地不想通过一些第三方库来整合任何web框架或数据库交互性。这些类型的基准都很棒，也非常相关，但是这一个是基本的。</p><p id="85d3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="lo">注意:正如评论中指出的，最初的Node.js代码使用递归来计算斐波那契数列，而Go代码没有。</em></p><p id="1883" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="lo">这会影响调用堆栈，这可能不是一个公平的比较。有了这些优秀的众包知识，我在适用的地方更新了这篇文章。在</em> <a class="ae jg" href="https://gist.github.com/tnolet/9432f1f39890a22bfb9195e5adeb3eca" rel="noopener ugc nofollow" target="_blank"> <em class="lo">中找到老Node.js代码这个要诀</em> </a> <em class="lo">。</em></p><p id="3cda" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">节点代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lp kk l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Node.js code</figcaption></figure><p id="d4be" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Go代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lp kk l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Go code</figcaption></figure><p id="0c42" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这两个函数都不接受输入，只是将斐波那契数列记录到标准输出中。打印30个数字后，输出是字符串“done ”,并以AWS API Gateway理解的格式传递。</p><h1 id="2bf6" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">测试设置</h1><p id="84ff" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我用128MB内存的完全标准的资源配置文件部署了这两个功能。每个函数都有一个API网关，没有身份验证，不会给请求/响应周期增加任何开销。对两个端点的快速冒烟测试HTTP调用显示一切都在工作，并且已经可以注意到大约340毫秒的响应时间差异。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lq"><img src="../Images/5cd057d2dd9644d88f2766eccdd5764a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1T_I0zrSqSNIl7ddXrq2Q.png"/></div></div></figure><p id="18ee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，这些请求没有考虑Lambda容器的任何“预热”。为此，我们使用<a class="ae jg" href="https://github.com/alexfernandez/loadtest" rel="noopener ugc nofollow" target="_blank"> loadtest </a>运行了一个更长的测试，使用五个并发工作器以每秒10个请求的速度发送了总共1000个请求。我们打开了keepalive。</p><pre class="kf kg kh ki fq lr ls lt lu aw lv dt"><span id="b6d7" class="lw km hu ls b fv lx ly l lz ma">$ loadtest -c 5 -k -n 1000 --rps 10 https://&lt;api-endpoint&gt;</span></pre><h1 id="a2f9" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">测试结果:斐波那契</h1><p id="fd91" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">在这项计算密集型测试中，Node.js和Go之间的差异几乎为零。有趣的是，递归版本向我们展示了Node中的递归调用对总体性能的影响。Node.js递归函数的执行持续时间几乎是Go函数的10倍。</p><p id="0473" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="lo">调整递归Node.js代码后文本更新</em></p><pre class="kf kg kh ki fq lr ls lt lu aw lv dt"><span id="b8f9" class="lw km hu ls b fv lx ly l lz ma"><strong class="ls hv">Max requests:</strong>        1000<br/><strong class="ls hv">Concurrency level:</strong>   5<br/><strong class="ls hv">Agent:</strong>               keepalive<br/><strong class="ls hv">Requests per second:</strong> 10</span><span id="9c7f" class="lw km hu ls b fv mb ly l lz ma">                  <strong class="ls hv">Node.js     Node.js (rec.)  Go</strong><br/><strong class="ls hv">Mean latency:</strong>     76.9 ms     407.8 ms       75.3 ms<br/><strong class="ls hv"> 50% </strong>             73          392            67  <br/><strong class="ls hv"> 90% </strong>             95          492            91 <br/><strong class="ls hv"> 95%</strong>             101          526           109<br/><strong class="ls hv"> 99%</strong>             201          709           226<br/><strong class="ls hv">100%</strong>             630          814           562 (longest request)</span></pre><p id="bfc4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于递归版本(标有rec。)AWS Cloudwatch metrics给出了类似的图，其中Node.js代码几乎慢了10倍。但是，如前所述，非递归版本不是这种情况。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/c13d4e2422c26e937edfee8c0c7405cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlVJcain7MH6u-8XyvFMmQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Node.js execution duration</figcaption></figure><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/1beb26b029b6805872914a568a3f1f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZqw5KZX7hlgu43YZvEOew.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Go execution duration</figcaption></figure><h1 id="3527" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">测试代码:S3和迪纳摩互动</h1><p id="b916" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">正如评论中提到的，斐波那契数列作为一个开始是不错的，但并不真正代表真实世界的场景。所以我举了一个额外的例子。这个λ函数</p><ol class=""><li id="a34f" class="me mf hu jj b jk jl jo jp js mg jw mh ka mi ke mj mk ml mm dt translated">从S3抓取了一个大约50kb的图像。</li><li id="c9d5" class="me mf hu jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">将其LastModified时间戳写入DynamoDB表。</li></ol><p id="91ea" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这类似于上传网站或一般文件处理的典型场景。测试设置与斐波那契测试完全相同，只是增加了S3桶和发电机表。两个版本分别为每种语言使用标准的AWS SDK。Dynamo表的写入容量高达1000个单位，以提供足够的吞吐量。</p><p id="d508" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> Node.js </strong></p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lp kk l"/></div></figure><p id="ba75" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> Go </strong>代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lp kk l"/></div></figure><h1 id="6fe1" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">测试结果:S3和迪纳摩互动</h1><p id="0c6d" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">这是一个比前一个测试更清晰的结果，只是在99%的百分位数上，两个测试有些相等，但仍然相差很远。低于该阈值的所有值都支持Go。这是拥有高容量AWS功能的用户在切换到Go时可以真正省钱的地方，因为他们的账单可以有效地减少约40%。</p><pre class="kf kg kh ki fq lr ls lt lu aw lv dt"><span id="c81b" class="lw km hu ls b fv lx ly l lz ma"><strong class="ls hv">Max requests:</strong>        1000<br/><strong class="ls hv">Concurrency level:</strong>   5<br/><strong class="ls hv">Agent:</strong>               keepalive<br/><strong class="ls hv">Requests per second:</strong> 10</span><span id="673e" class="lw km hu ls b fv mb ly l lz ma"><strong class="ls hv">                 Node.js    Go</strong><br/><strong class="ls hv">Mean latency:</strong>    252.2 ms   109.7 ms<br/><strong class="ls hv"> 50% </strong>            203        91<br/><strong class="ls hv"> 90% </strong>            384        151<br/><strong class="ls hv"> 95%</strong>             478        197<br/><strong class="ls hv"> 99%</strong>             894        435<br/><strong class="ls hv">100%</strong>            8103       1133(longest request)</span></pre><p id="37cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="lo">注:在给io增加一个阅读器后更新。按照注释部分的注释，在Go代码中使用Reader主体。这实际上对结果没有影响，可能是由于过度的S3缓存。不是期望，但是嘿，是什么？</em></p><h1 id="8bcd" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">动态与编译</h1><p id="9ec2" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">在任何AWS营销广告中不明显的是，你实际上为AWS Lambda提供了预编译的Go二进制文件。AWS不会为您编译Go源文件，这会产生一些后果。</p><p id="b432" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，AWS Lambda实际上并没有“真正”运行Go代码。相反，它运行一个二进制程序，监听一个特定的端口，并以特定的网络格式传递一条消息。这实际上非常好，因为它为AWS在未来添加其他编译语言如Rust或C++开辟了可能性，建立在他们当前的Go引擎上。</p><p id="a90b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其次，从一个不太积极的方面来说，拥有预编译的二进制文件意味着您不能使用相当优秀的内置代码编辑器。AWS最近收购的Cloud9提供的这个迷你IDE是同类产品中的佼佼者，它确实让Lambda服务页面感觉有点像JsFiddle或CodePen，但对于后端代码来说，只需按一下按钮就可以在生产中运行。我是IntelliJ / WebStorm的忠实用户，但Cloud9的东西真的真的很好。👍</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/0ca6a081298956840c9d5977c3e3d9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOAp2PdIpsnesG__ogvKvg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">AWS Lambda built in code editor</figcaption></figure><h1 id="e30b" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">结论</h1><p id="367f" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">对AWS Lambda的Go支持为那些在Lambda上运行工作负载的人带来了非常显著的成本节约和性能优势。令人兴奋的事情将会发生！</p></div><div class="ab cl mt mu hc mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hn ho hp hq hr"><p id="334a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这篇文章，请用<strong class="jj hv">鼓掌</strong>来表达你的欣赏👏下面！</p><p id="9527" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">蒂姆是https://vamp . io(T1)的产品倡导者，这是为现代云平台发布的智能&amp;无压力应用程序。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><a href="https://vamp.io?utm_campaign=govsnode&amp;utm_source=Hackernoon"><div class="fe ff na"><img src="../Images/fc3b7e1bae2c0b682c2e691cba4010dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*cLdRV_zlWZUKcIS427bXjw.png"/></div></a></figure></div></div>    
</body>
</html>