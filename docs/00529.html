<html>
<head>
<title>pA Definitive Guide to JavaScript Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript原型权威指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-definitive-guide-to-javascript-prototypes-2c263788021e?source=collection_archive---------2-----------------------#2018-01-17">https://medium.com/hackernoon/a-definitive-guide-to-javascript-prototypes-2c263788021e?source=collection_archive---------2-----------------------#2018-01-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="21eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有小代码片段和简单的解释。</p><h1 id="1240" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">介绍</h1><p id="e4ce" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">许多开发人员和工程师对JavaScript原型感到困惑和陌生。</p><p id="df3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天，是时候一劳永逸地去神秘化和掌握原型了。这样做可以让我们在JavaScript中不可避免地遇到和使用原型时，有信心处理它们。</p><h2 id="20fd" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated">部分</h2><p id="839f" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">本指南分为以下几个部分。</p><ul class=""><li id="8e6c" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo lm ln lo lp dt translated">创建函数的效果</li><li id="b1a7" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">将函数作为构造函数调用</li><li id="ab1c" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">原型遗传的演示</li><li id="e58b" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">原型链的遍历</li><li id="e7f1" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">原型链的组件</li><li id="cbc5" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">函数的原型</li><li id="f0fd" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">没有构造函数的原型</li><li id="999d" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">一个原型为什么叫原型？</li></ul><h2 id="42d7" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated">如何阅读本指南的提示</h2><p id="8f88" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">每一节都建立在前一节的基础上。因此，不要跳过某些章节，尤其是当你第一次阅读本指南的时候。</p><p id="5d85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有代码片段都是相关的，并且是跨部分累积的。代码片段应该可以很好地与最新版本的JavaScript兼容。</p><p id="f3bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你浏览本指南的速度太快，你可能不会有太大的收获。试着仔细阅读本指南，你可能会对什么是原型以及如何使用它们深信不疑。</p><h1 id="0994" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">是时候一劳永逸地去神秘化和掌握原型了。</h1></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="10a5" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">创建函数的效果</h1><p id="1a2e" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">创建函数有两个效果。</p><ol class=""><li id="28bb" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo mh ln lo lp dt translated">函数本身将被创建。<br/>注意，函数也是一个对象，因此它可以有额外的属性。</li><li id="8cef" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo mh ln lo lp dt translated">第二个对象将被创建并作为<code class="eh mi mj mk ml b">&lt;Function&gt;.prototype</code>附加到函数上。</li></ol><p id="7fb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了演示这些效果，创建一个名为<code class="eh mi mj mk ml b">Person</code>的函数，并观察它自动带有一个<code class="eh mi mj mk ml b">Person.prototype</code>对象。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="745d" class="kt jq hu ml b fv mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="cc25" class="kt jq hu ml b fv my mv l mw mx">typeof Person.prototype; // "object"</span></pre></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="e0fe" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">将函数作为构造函数调用</h1><p id="b3b3" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">当我们用<code class="eh mi mj mk ml b">new</code>关键字调用<code class="eh mi mj mk ml b">Person</code>函数时，即作为一个构造函数，一个新的对象<code class="eh mi mj mk ml b">this</code>被隐式创建，<code class="eh mi mj mk ml b">this.name</code>被设置，最后，<code class="eh mi mj mk ml b">this</code>被隐式返回。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="42e3" class="kt jq hu ml b fv mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="1ed5" class="kt jq hu ml b fv my mv l mw mx">const alex = new Person("Alex");<br/>typeof alex; // "object"<br/>alex.name; // "Alex"</span></pre></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="378f" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">原型遗传的演示</h1><p id="7ee9" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">重要的是，对象<code class="eh mi mj mk ml b">alex</code>和从<code class="eh mi mj mk ml b">Person</code>构造的任何其他对象将获得对<code class="eh mi mj mk ml b">Person.prototype</code>的间接访问。</p><p id="d639" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们给<code class="eh mi mj mk ml b">Person.prototype</code>增加一个<code class="eh mi mj mk ml b">greet</code>功能。注意，现有对象<code class="eh mi mj mk ml b">alex</code>现在可以<code class="eh mi mj mk ml b">greet</code>了，新创建的对象<code class="eh mi mj mk ml b">tom</code>也可以这样做。这种形式的代码重用被称为原型继承。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="2897" class="kt jq hu ml b fv mu mv l mw mx">Person.prototype.greet = function() {<br/>  console.log(`Hi ${this.name}`);<br/>}</span><span id="ebf2" class="kt jq hu ml b fv my mv l mw mx">alex.hasOwnProperty("greet"); // false<br/>alex.greet(); // "Hi Alex"</span><span id="855c" class="kt jq hu ml b fv my mv l mw mx">const tom = new Person("Tom");<br/>tom.greet(); // "Hi Tom"</span></pre><p id="a905" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管从<code class="eh mi mj mk ml b">Person</code>构造的对象<code class="eh mi mj mk ml b">alex</code>本身没有<code class="eh mi mj mk ml b">greet</code>属性，但它能够访问<code class="eh mi mj mk ml b">Person.prototype</code>并因此调用<code class="eh mi mj mk ml b">Person.prototype.greet</code>，而<code class="eh mi mj mk ml b">this</code>被隐式设置为<code class="eh mi mj mk ml b">alex</code>，这导致“Hi Alex”被记录到控制台。</p><p id="dd32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个对象<code class="eh mi mj mk ml b">tom</code>以类似的方式获得对同一个 <code class="eh mi mj mk ml b">Person.prototype</code>对象的访问。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="f4af" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">原型链的遍历</h1><p id="0e3c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">当遍历算法在对象上找不到所需的属性时，它会查询对象的原型。如果找到原型的属性，遍历就会停止。否则，它将查询原型的原型，依此类推，直到找到属性或到达原型链的末端。</p><p id="9ab2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在每次遍历中，如果对象<a class="ae ks" href="https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">不知道如何做，它会将做某事的责任委托给它的原型</a>。<code class="eh mi mj mk ml b">alex</code>不知道如何<code class="eh mi mj mk ml b">greet</code>，所以<code class="eh mi mj mk ml b">alex</code>向<code class="eh mi mj mk ml b">Person.prototype</code>求助如何<code class="eh mi mj mk ml b">greet</code>。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="1379" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">原型链的组件</h1><p id="dc32" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们用<code class="eh mi mj mk ml b">Object.getPrototypeOf</code>来检查<code class="eh mi mj mk ml b">alex</code>的整个原型链。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="656b" class="kt jq hu ml b fv mu mv l mw mx">Object.getPrototypeOf(alex) === Person.prototype; // true</span></pre><p id="a619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面那行告诉我们<code class="eh mi mj mk ml b">alex</code>的原型是<code class="eh mi mj mk ml b">Person.prototype</code>。因此，如果JavaScript在<code class="eh mi mj mk ml b">alex</code>上找不到想要的属性，它将检查<code class="eh mi mj mk ml b">Person.prototpe</code>。</p><p id="2155" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，<code class="eh mi mj mk ml b">alex</code>的原型链从<code class="eh mi mj mk ml b">Person.prototype</code>开始。</p><p id="fe15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果JavaScript在<code class="eh mi mj mk ml b">Person.prototype</code>上还是找不到想要的属性，就会查看<code class="eh mi mj mk ml b">Person.prototype</code>的原型，也就是<code class="eh mi mj mk ml b">Object.prototype</code>。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="b87b" class="kt jq hu ml b fv mu mv l mw mx">Object.getPrototypeOf(Person.prototype) === Object.prototype; // true</span></pre><p id="4a91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么<code class="eh mi mj mk ml b">Object.prototype</code>是<code class="eh mi mj mk ml b">Person.prototype</code>的原型？</p><p id="4e86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设<code class="eh mi mj mk ml b">Person.prototype</code>是一个对象，由内置的<code class="eh mi mj mk ml b">Object</code>构造函数构造而成(是否如此是一个实现细节)。</p><p id="0dbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以观察到一个与我们目前所学一致的模式。</p><ol class=""><li id="8441" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo mh ln lo lp dt translated"><code class="eh mi mj mk ml b">alex</code>由<code class="eh mi mj mk ml b">Person</code>构造而成。<br/><code class="eh mi mj mk ml b">alex</code>的原型是<code class="eh mi mj mk ml b">Person.prototype</code>。</li><li id="7068" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo mh ln lo lp dt translated"><code class="eh mi mj mk ml b">Person.prototype</code>由<code class="eh mi mj mk ml b">Object</code>建成。<br/><code class="eh mi mj mk ml b">Person.prototype</code>的原型是<code class="eh mi mj mk ml b">Object.prototype</code>。</li></ol><p id="2a37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以先用<code class="eh mi mj mk ml b">Object</code>替换<code class="eh mi mj mk ml b">Person</code>，然后用<code class="eh mi mj mk ml b">Person.prototype</code>替换<code class="eh mi mj mk ml b">alex</code>，从语句1转到语句2。</p><p id="f914" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重述一下，我们已经看到<code class="eh mi mj mk ml b">alex</code>的原型是<code class="eh mi mj mk ml b">Person.prototype</code>，<code class="eh mi mj mk ml b">Person.prototype</code>的原型是<code class="eh mi mj mk ml b">Object.prototype</code>。因此，<code class="eh mi mj mk ml b">alex</code>的原型链包含<code class="eh mi mj mk ml b">Person.prototype</code>后跟<code class="eh mi mj mk ml b">Object.prototype</code>。</p><p id="9f3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mi mj mk ml b">Object.prototype</code>是<code class="eh mi mj mk ml b">alex</code>原型链中的最终原型吗？是的，因为<code class="eh mi mj mk ml b">Object.prototype</code>没有原型(它是空的)。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="4cd4" class="kt jq hu ml b fv mu mv l mw mx">Object.getPrototypeOf(Object.prototype) === null; // true</span></pre><p id="3eae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使<code class="eh mi mj mk ml b">Object.prototype</code>是一个对象，但它的原型不是<code class="eh mi mj mk ml b">Object.prototype</code>，否则我们就会有一个无限的原型链。</p><p id="4e29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JavaScript中几乎所有其他对象都在原型链的末尾有<code class="eh mi mj mk ml b">Object.prototype</code>。我们已经看到对象<code class="eh mi mj mk ml b">alex</code>是如何从<code class="eh mi mj mk ml b">Person</code>构造而来的。该属性也适用于从内置<code class="eh mi mj mk ml b">Object</code>构造函数和对象文字语法创建的普通对象。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="2961" class="kt jq hu ml b fv mu mv l mw mx">const constructedObject = new Object();<br/>const objectLiteral = {};</span><span id="a3f5" class="kt jq hu ml b fv my mv l mw mx">Object.getPrototypeOf(constructedObject) === Object.prototype; // true<br/>Object.getPrototypeOf(objectLiteral) === Object.prototype; // true</span></pre><p id="261d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，几乎所有的对象在其原型链的末端都有<code class="eh mi mj mk ml b">Object.prototype</code>，这具有实际意义，因为它们将可以访问<code class="eh mi mj mk ml b">Object.prototype</code>提供的公共实用程序，如<code class="eh mi mj mk ml b">toString</code>和<code class="eh mi mj mk ml b">valueOf</code>。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="8745" class="kt jq hu ml b fv mu mv l mw mx">alex.toString(); // "[object Object]"<br/>alex.valueOf(); // Person { name: "Alex" }</span></pre></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="b7c6" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">函数的原型</h1><p id="4696" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">前面，我们看到<code class="eh mi mj mk ml b">alex</code>有一个<code class="eh mi mj mk ml b">name</code>属性，可以使用<code class="eh mi mj mk ml b">alex.name</code>来访问。语法没有说更多关于<code class="eh mi mj mk ml b">alex</code>的东西，但是我们通常会给它添加更多的含义。我们认为<code class="eh mi mj mk ml b">alex.name</code>不仅仅是碰巧在<code class="eh mi mj mk ml b">alex.name</code>可以访问的任意名字，而是指<strong class="it hv">亚历克斯的名字</strong>。</p><p id="fe6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那<code class="eh mi mj mk ml b">Person.prototype</code>呢？是指<code class="eh mi mj mk ml b">Person</code> <strong class="it hv">的原型</strong>？</p><p id="1823" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没有。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="2723" class="kt jq hu ml b fv mu mv l mw mx">Object.getPrototypeOf(Person) !== Person.prototype; // true</span></pre><p id="2507" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果<code class="eh mi mj mk ml b">Person.prototype</code>不是指<code class="eh mi mj mk ml b">Person</code>的原型，那么它指的是谁的原型？</p><p id="f415" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，<code class="eh mi mj mk ml b">Person.prototype</code>会成为由<code class="eh mi mj mk ml b">Person</code>构造的对象的原型。我们已经看到了<code class="eh mi mj mk ml b">alex</code>的这种行为。</p><p id="e1f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">把<code class="eh mi mj mk ml b">Person.prototype</code>想象成圣诞老人存放在你家的礼物可能会有所帮助，但那份礼物是给你的孩子的，不是你的。</p><p id="5234" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么<code class="eh mi mj mk ml b">Person</code>的实际原型是什么？是<code class="eh mi mj mk ml b">Function.prototype</code>。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="6a98" class="kt jq hu ml b fv mu mv l mw mx">Object.getPrototypeOf(Person) === Function.prototype; // true</span></pre><p id="36af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是因为<code class="eh mi mj mk ml b">Person</code>是一个<code class="eh mi mj mk ml b">Function</code>，因此它有一个<code class="eh mi mj mk ml b">Function.prototype</code>的原型。</p><p id="af20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mi mj mk ml b">Function.prototype</code>提供<code class="eh mi mj mk ml b">call</code>、<code class="eh mi mj mk ml b">bind</code>、<code class="eh mi mj mk ml b">apply</code>等常用工具，可通过<code class="eh mi mj mk ml b">Person</code>等功能访问。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="e1da" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">没有构造函数的原型</h1><p id="d5be" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我们也可以创建没有构造函数的原型链。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="370b" class="kt jq hu ml b fv mu mv l mw mx">const greeter = {<br/>  greet() {<br/>    console.log(`Hi ${this.name}`);<br/>  }<br/>};</span><span id="d251" class="kt jq hu ml b fv my mv l mw mx">const bob = Object.create(greeter);<br/>bob.name = "Bob";<br/>bob.greet(); // "Hi Bob"</span><span id="b0ec" class="kt jq hu ml b fv my mv l mw mx">Object.getPrototypeOf(bob) === greeter; // true</span></pre><p id="d3d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，<code class="eh mi mj mk ml b">Object.create</code>创建了一个以<code class="eh mi mj mk ml b">greeter</code>为原型的新对象。该对象随后被分配给<code class="eh mi mj mk ml b">bob</code>。虽然<code class="eh mi mj mk ml b">bob</code>没有自己的<code class="eh mi mj mk ml b">greet</code>功能，但它可以访问其原型<code class="eh mi mj mk ml b">greeter</code>上的<code class="eh mi mj mk ml b">greet</code>功能。</p><p id="ef63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh mi mj mk ml b">Object.create</code>创建一个具有已定义原型的新对象比处理构造函数和<code class="eh mi mj mk ml b">&lt;Constructor&gt;.prototype</code>对象更简单。</p><p id="7919" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mi mj mk ml b">Object.create</code>的使用可以结合工厂功能。与构造函数不同，工厂函数显式返回一个对象，并且不用<code class="eh mi mj mk ml b">new</code>调用。这里有一个例子。</p><pre class="mm mn mo mp fq mq ml mr ms aw mt dt"><span id="7c18" class="kt jq hu ml b fv mu mv l mw mx">function createPerson(name, prototype) {<br/>  const person = Object.create(prototype);<br/>  person.name = name;<br/>  return person;<br/>}</span><span id="1124" class="kt jq hu ml b fv my mv l mw mx">const ada = createPerson("Ada", greeter);<br/>ada.greet(); // "Hi Ada"</span></pre><p id="8a09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">鉴于工厂函数和<code class="eh mi mj mk ml b">Object.create</code>的简单性和简洁性，它们往往是比构造函数和<code class="eh mi mj mk ml b">&lt;Constructor&gt;.prototype</code>对象更受欢迎的方法。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="7844" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">一个原型为什么叫原型？</h1><p id="924a" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">“因为有人想出来的”不是一个满意的答案。</p><p id="ea41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">单词<a class="ae ks" href="https://hackernoon.com/tagged/prototype" rel="noopener ugc nofollow" target="_blank"> prototype </a>在JavaScript文献中经常被忽略。大多数人把它当作一个技术术语，并不解释为什么它被恰当地命名为“原型”。知道为什么原型被称为原型可以给我们一个更好的心理模型，无论何时我们遇到它。</p><p id="9e12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，很难找到这个问题的确切答案。以下是我对这个问题的看法。</p><p id="2bed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">现实生活中的原型</strong>主要是指</p><ol class=""><li id="013e" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo mh ln lo lp dt translated">一个产品，</li><li id="ac1c" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo mh ln lo lp dt translated">尽管功能有限，但是</li><li id="af35" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo mh ln lo lp dt translated">产品的最终版本将共享其原型的一些特征。</li></ol><p id="2a0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用“对象”替换“产品”一词后，我们看到JavaScript原型指的是</p><ol class=""><li id="5970" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo mh ln lo lp dt translated">一个物体，</li><li id="4a0f" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo mh ln lo lp dt translated">尽管功能有限，但是</li><li id="75f6" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo mh ln lo lp dt translated">对象的最终版本将共享其原型的一些特征。</li></ol><p id="42ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一点强调了与传统的基于类的继承相比，原型继承的独特之处。原型是一个可以独立使用的对象。然而，传统的类不是对象，因此不能像对象一样使用。</p><p id="0a4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，尽管后来的JavaScript版本有一个<code class="eh mi mj mk ml b">class</code>关键字，但它仍然使用原型继承。</p><p id="3752" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第2点是有效的，因为与使用它作为原型的对象相比，原型通常具有较少的属性。比如<code class="eh mi mj mk ml b">alex</code>和<code class="eh mi mj mk ml b">Person.prototype</code>都能够<code class="eh mi mj mk ml b">greet</code>(虽然<code class="eh mi mj mk ml b">alex</code>是借助<code class="eh mi mj mk ml b">Person.prototype</code>做到的)，但是<code class="eh mi mj mk ml b">alex</code>多了一个<code class="eh mi mj mk ml b">name</code>。</p><p id="0f71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至于第三点，由于原型继承，JavaScript对象确实共享其原型的一些特征。</p><p id="99cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于对象是在原型链中链接的，如果您更改了原型，链接到该原型的现有和未来对象的行为可能会受到影响。</p><p id="ef6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，请注意不要更改内置原型，除非您尝试聚合填充标准特征。如果每个人都擅自更改内置原型，就会出现冲突和代码崩溃。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="b9c0" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">摘要</h1><p id="f51e" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">您已经看到了什么是原型，JavaScript如何遍历原型链来访问原型属性，以及代码如何在我们称之为原型继承的过程中被重用。您还看到了如何使用原型，不管有没有构造函数。</p><p id="e547" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管原型的掌握让许多人感到困惑，但我希望这本权威指南能够帮助您掌握JavaScript中的原型，从而成为一名更好的软件开发人员和工程师。</p><h2 id="0fe2" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated">祝贺你一路走到这里！</h2><h2 id="ca78" class="kt jq hu bd jr ku kv kw jv kx ky kz jz jc la lb kd jg lc ld kh jk le lf kl lg dt translated">如果你觉得这个指南有用，把它发给你可能从中受益的同事和朋友。</h2></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="3f9f" class="jp jq hu bd jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki mg kk kl km dt translated">为了进一步阅读</h1><ol class=""><li id="3d06" class="lh li hu it b iu kn iy ko jc mz jg na jk nb jo mh ln lo lp dt translated">Eric Elliott撰写的关于JavaScript继承的常见误解</li><li id="cfee" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo mh ln lo lp dt translated"><a class="ae ks" href="https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes" rel="noopener ugc nofollow" target="_blank">你不知道的JS: <em class="nc">这个</em> &amp;物体原型</a>由凯尔·辛普森制作</li></ol><figure class="mm mn mo mp fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>