<html>
<head>
<title>Debugging Node without restarting processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试节点而不重新启动进程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/debugging-node-without-restarting-processes-bd5d5c98f200?source=collection_archive---------10-----------------------#2018-01-17">https://medium.com/hackernoon/debugging-node-without-restarting-processes-bd5d5c98f200?source=collection_archive---------10-----------------------#2018-01-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3de4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我通常是一名前端开发人员，但我不时会发现自己在编写或维护一些后端代码。我在将上下文切换到Node时遇到的最大缺点之一是缺少Chrome开发工具。没有它们确实凸显了我在日常的web开发中对它们的依赖。幸运的是，有启用它们的选项，而且最近它们变得更加稳定和可用。Node有一个内置的调试模式，允许你连接到DevTools，还有一个名为<a class="ae jp" href="https://github.com/node-inspector/node-inspector" rel="noopener ugc nofollow" target="_blank"> node-inspector </a>的包可以自动连接。</p><p id="2ddb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得注意的是节点版本&lt; 8 use a now-legacy Debugger API. Node 8 introduces the Inspector API, which better integrates with existing developer tools.</p><p id="f1fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">There’s one common theme that I’ve encountered when using these methods: they must be invoked when starting the node process. The other day, I found myself with a process in an odd state that I’ve had trouble reproducing, and I didn’t want to risk losing it by restarting the process to enable the inspector.</p><p id="5ff6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">However, I found a solution — no less, a solution from <a class="ae jp" href="https://nodejs.org/en/docs/guides/debugging-getting-started/" rel="noopener ugc nofollow" target="_blank">官方节点文档</a>。</p><blockquote class="jq jr js"><p id="1dbd" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">在没有inspect的情况下启动的Node.js进程也可以通过SIGUSR1(在Linux和OS X上)发出信号来开始监听调试消息。</p></blockquote><p id="1753" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这只适用于基于unix的操作系统(抱歉，Windows用户)，但它在这种情况下救了我的命。unix中的<code class="eh jx jy jz ka b">kill</code>命令可能被命名为不祥之兆，但它也可以用于向正在运行的进程发送任意信号。<code class="eh jx jy jz ka b">man kill</code>告诉我可以使用语法<code class="eh jx jy jz ka b">kill -signal_name pid</code>这样做。信号名称列表可以用<code class="eh jx jy jz ka b">kill -l</code>枚举，如下所示。</p><pre class="kb kc kd ke fq kf ka kg kh aw ki dt"><span id="1a16" class="kj kk hu ka b fv kl km l kn ko">$ kill -l<br/>hup int quit ill trap abrt emt fpe kill bus segv sys pipe alrm term urg<br/>stop tstp cont chld ttin ttou io xcpu xfsz vtalrm prof winch info usr1 usr2</span></pre><p id="7a8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">默认情况下，<code class="eh jx jy jz ka b">kill</code>发送一个<code class="eh jx jy jz ka b">int</code>，或者一个<code class="eh jx jy jz ka b">int</code> errupt信号，相当于在终端窗口中点击<code class="eh jx jy jz ka b">ctrl-c</code>。处理信号有很大的深度，我不会深入探讨(我鼓励你去探索它们！)，但接近列表末尾的是<code class="eh jx jy jz ka b">usr1</code>。这是节点文档引用的<code class="eh jx jy jz ka b">SIGUSR1</code>,所以现在我只需要一个pid或流程id，就可以将它发送到。我可以通过使用<code class="eh jx jy jz ka b">ps</code>和<code class="eh jx jy jz ka b">grep</code>来缩小在我的系统上运行的所有处理的列表</p><pre class="kb kc kd ke fq kf ka kg kh aw ki dt"><span id="61dd" class="kj kk hu ka b fv kl km l kn ko">$ ps | grep node<br/>9670 ttys000 0:01.04 node /snip/.bin/concurrently npm run watch:server npm run watch:client<br/>9673 ttys000 0:00.46 node /snip/.bin/concurrently npm run watch:server-files npm run watch:dist<br/>9674 ttys000 0:33.02 node /snip/.bin/webpack — watch<br/>9677 ttys000 0:00.36 node /snip/.bin/concurrently npm run build:snip — — watch<br/>9678 ttys000 0:01.65 node /snip/.bin/nodemon — delay 2 — watch dist ./dist/src/server.js<br/>9713 ttys000 0:01.00 /usr/local/bin/node ./dist/src/server.js<br/>9736 ttys003 0:00.00 grep — color=auto node</span></pre><p id="b511" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的输出有点嘈杂，因为复杂的构建工具链会产生许多进程。但是我看到了最下面右边的进程:<code class="eh jx jy jz ka b">node ./dist/src/server.js</code>，pid为<code class="eh jx jy jz ka b">9713</code>。</p><p id="4612" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我知道信号名是<code class="eh jx jy jz ka b">usr1</code>，pid是<code class="eh jx jy jz ka b">9713</code>，所以我需要运行。</p><pre class="kb kc kd ke fq kf ka kg kh aw ki dt"><span id="4b2a" class="kj kk hu ka b fv kl km l kn ko">$ kill -usr1 9713</span></pre><p id="9e52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它运行时没有输出，但是我检查了节点进程的日志</p><pre class="kb kc kd ke fq kf ka kg kh aw ki dt"><span id="c3e9" class="kj kk hu ka b fv kl km l kn ko">Debugger listening on ws://127.0.0.1:9229/ad014904-c9be-4288–82da-bdd47be8283b<br/>For help see <a class="ae jp" href="https://nodejs.org/en/docs/inspector" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/docs/inspector</a></span></pre><p id="1a78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我可以打开<code class="eh jx jy jz ka b">chrome://inspect</code>，并立即看到我的检查目标。</p><figure class="kb kc kd ke fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff kp"><img src="../Images/0de1213c53106dde4b65168898ec5288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*soQHfOEF7G9FGZgqy5vZzQ.png"/></div></div></figure><p id="0414" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我点击“inspect ”,在我的节点进程的上下文中，我得到了一个Chrome DevTools窗口！我可以使用profiler来审计性能，使用source选项卡来添加断点和检查正在运行的代码，并使用控制台来查看日志或修改当前范围内的变量，就像在web上一样。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="b3bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我也在<a class="ae jp" href="http://twitter.com/cvitullo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上发布技术信息，在<a class="ae jp" href="https://www.reactiflux.com/" rel="noopener ugc nofollow" target="_blank">React flux</a>上回答关于React的问题。我还主持了节点开发者的姐妹服务器<a class="ae jp" href="https://discord.gg/vUsrbjd" rel="noopener ugc nofollow" target="_blank"> Nodeiflux </a>。</p></div></div>    
</body>
</html>