<html>
<head>
<title>Algorithms Explained: Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释的算法:递归</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/algorithms-explained-recursion-54831247dd85?source=collection_archive---------13-----------------------#2018-01-17">https://medium.com/hackernoon/algorithms-explained-recursion-54831247dd85?source=collection_archive---------13-----------------------#2018-01-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="50b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您刚开始编程，您可能听说过递归这个词。您甚至可能遇到这样的问题，上面写着“寻找递归解决方案来解决X”等。</p><p id="1d9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我进一步说之前，我想说的是，编写递归解决方案在开始时很困难。不要指望它第一次就能起作用。编写递归解决方案涉及一种全新的思维方式，实际上可能会让新来的人感到很不舒服，但是坚持下去，你会想你怎么会发现它如此困难。</p><p id="f0f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么什么是递归呢？<em class="jp">递归</em>解是将问题的解表示为对<em class="jp">同一个</em>问题的<em class="jp">简化</em>版本的运算。</p><p id="f814" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能没有什么意义，也很难解释它是如何工作的，让我们看一个简单的例子:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3350" class="jz ka hu jv b fv kb kc l kd ke">def reduce(x):<br/>    return reduce(x-1)</span></pre><p id="4890" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么这里发生了什么？我们有一个叫做reduce的函数，它接受一个参数'<strong class="it hv"> <em class="jp"> x </em> </strong> <em class="jp"> ' </em>(一个整数)，我们希望它将其减少到'<strong class="it hv"> 0 </strong>。听起来很简单，所以让我们在传递5作为参数时运行它，看看会发生什么:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="4033" class="jz ka hu jv b fv kb kc l kd ke">&gt;&gt;&gt; reduce(5)<br/>RuntimeError: maximum recursion depth exceeded</span></pre><p id="141a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">错误？好吧，让我们仔细看看这里发生了什么:</p><p id="b685" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">减(5) </em>谓<em class="jp">减(4) </em>谓<em class="jp">减(3) </em> ……因此，我们最初的调用<em class="jp"> reduce(5) </em>是对<em class="jp"> reduce() </em>无数次调用中的第一次。每次调用<em class="jp"> reduce() </em>时，Python都会实例化一个数据结构来表示对函数的特定调用。这种数据结构被称为<em class="jp">堆栈帧。</em>堆栈帧占用内存。我们的程序试图创建无限数量的堆栈帧，这将需要无限量的内存，我们没有，所以我们的程序崩溃了。</p><p id="d9a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了解决这个问题，我们需要添加一些被称为<em class="jp">基本情况</em>的东西。这只是我们添加的一个检查，以便我们的函数知道何时停止调用它自己。基本情况通常是原始问题的最简单版本，也是我们一直都知道答案的问题。</p><p id="e9bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过添加一个基本案例来修正我们的错误。对于这个函数，我们希望它在我们达到0时停止。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="868e" class="jz ka hu jv b fv kb kc l kd ke">def reduce(x):<br/>    if x == 0:<br/>        return 0<br/>    return reduce(x-1)</span></pre><p id="4879" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们运行程序时，我们会得到:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="fd31" class="jz ka hu jv b fv kb kc l kd ke">&gt;&gt;&gt; reduce(5)<br/>0</span></pre><p id="f15d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了，它起作用了！让我们再看看这次发生了什么。我们称之为减少(5 ),也称之为减少(4)……它调用reduce(0)。好了，停在这里，我们已经击中了我们的基本情况。现在，函数将会做的是将0返回到之前的reduce(1)调用，该调用将0返回到reduce(2)…其返回0以减少(5 ),这返回我们的答案。给你，你的第一个递归解！</p><p id="335b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一个更实际的例子。让我们写一个递归的解决方案来寻找N！(或N阶乘):</p><p id="0a89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">N阶乘定义为:N！= N * (N-1) * (N-2)…… * 2 * 1。</p><p id="643a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，4！= 4 * 3 * 2 * 1</p><p id="8088" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们这个例子的基本情况是N = 0 = 0！被定义为1。所以让我们写我们的函数:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="dbc3" class="jz ka hu jv b fv kb kc l kd ke">def factorial(n):<br/>    if n == 0:<br/>        return 1<br/>    return n * factorial(n-1)</span></pre><p id="a0f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，让我们看看实际情况。我们将调用我们的函数并为n传入4:</p><p id="9f6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">factorial(4)调用factorial (3) …..它调用factorial(0 ),这是我们的基本情况，所以我们将1返回到factorial(1)的前一个调用，它获取1并乘以1，计算结果为1，然后将其传递回factorial(2 ),它获取1并乘以2，计算结果为2，然后将其传递回factorial(3 ),再乘以3 *2得到6，然后将其传递回factorial(4 ),再乘以4 * 6，计算结果为24，返回我们的答案。</p><p id="6f97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些都是非常简单的例子，并不是非常有用，但是能够发现何时可以实现递归解决方案，然后实现该解决方案是一项技能，它将使你成为一名更好的程序员。对于某些问题，递归可能提供一个直观、简单和优雅的解决方案。</p><p id="0735" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，您可以实现递归解决方案来查找树结构中的节点数，计算树中的叶节点数，甚至返回二叉查找树是否是AVL平衡的。这些解决方案往往非常简短和优雅，并且远离了您可能已经采用的长时间迭代方法。</p><p id="822f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我所说的，递归并不容易，但坚持下去，它会点击，看起来如此简单，你会奇怪你怎么会觉得它如此困难。</p><figure class="jq jr js jt fq kg fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/a89c5e442de0e6e29a8ad0ee43175110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*LzCCm9koQ6RWyaWGkk2o-A.png"/></div></figure><p id="1fdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您对更多类似的教程感兴趣，请前往<a class="ae kj" href="https://www.pyler.io" rel="noopener ugc nofollow" target="_blank"> www.pyler.io </a>网站，在那里您可以找到许多很棒的Python课程，这些课程将带您从初级到高级！</p><p id="a31d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们目前对<a class="ae kj" href="https://www.pyler.io/courses/intro-to-python" rel="noopener ugc nofollow" target="_blank">Python</a>入门课程有20%的优惠(现在只有€39.99英镑)，你将有一位导师指导你完成课程，如果你感到困难，他会伸出援助之手！</p><p id="4f45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，当您注册任何课程时，都可以免费获得一本“Slither into Python ”!</p><figure class="jq jr js jt fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff kk"><img src="../Images/65d0581c2635e776dcbcc8d43ad3ce72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGc5Ti30ybISgEchnUEd4A.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">‘Slither into Python: An introduction to the Python programming language’</figcaption></figure></div></div>    
</body>
</html>