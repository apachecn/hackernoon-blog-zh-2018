<html>
<head>
<title>Front-end framework attack: Riotjs product customiser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端框架攻击:Riotjs产品定制者</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/frontend-framework-attack-riotjs-product-customiser-a2922112137b?source=collection_archive---------9-----------------------#2018-01-18">https://medium.com/hackernoon/frontend-framework-attack-riotjs-product-customiser-a2922112137b?source=collection_archive---------9-----------------------#2018-01-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="994c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">这是挑战的第一周，我享受了使用riotjs构建产品定制器的乐趣。当我谈论我如何发现它的时候跟着读。</h2></div><p id="dc2e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">感觉不耐烦——这里是</em> <a class="ae kg" href="http://paulbird.co/riotjs-rioter-customiser/" rel="noopener ugc nofollow" target="_blank"> <em class="kf">演示</em> </a> <em class="kf">和</em> <a class="ae kg" href="https://github.com/birdyboy18/riotjs-rioter-customiser" rel="noopener ugc nofollow" target="_blank"> <em class="kf">文件</em> </a> <em class="kf">(如果你想跟着代码走也有用)</em></p><p id="6cbd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是我的第一个选择:</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div class="fe ff kh"><img src="../Images/b243f2f4a141a31b8deb066f3e703725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/1*xAMZWwrGGtXtRGDD3pgAmQ.gif"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">picking riotjs and product customiser</figcaption></figure><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/e6dd738c742e0eaedfdff3469c538ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmspV-0ehCGDGTOqeBd39w.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">And what I built</figcaption></figure><h1 id="829b" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">学习骚乱</h1><p id="8583" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">这实际上是一个非常好的开始，因为它引入的概念对我来说并不陌生。Riot.js自诩为“简单优雅的基于组件的UI库”</p><p id="8599" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是真的，一个包含所有html、js逻辑和css的文件在同一个地方使得编辑和编写变得非常容易；然后你就可以像普通的html标签一样，在你的html中使用新制作的标签。这与大多数现代js <a class="ae kg" href="https://hackernoon.com/tagged/frameworks" rel="noopener ugc nofollow" target="_blank">框架</a>目前的工作方式并没有太大的不同。</p><p id="5866" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它有一个超级简单的api，模板语法很容易，传递数据很简单，可观察的API是一个很大的帮助，知道它是如何更新的，这一切都导致了一个非常简单的项目构建。</p><p id="6566" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我确实遇到了一些小问题，但是我以后会处理的。我确信这是由于我自己知识的缺乏，而不是图书馆的任何问题。我也不是这方面的专家，所以首先也是最重要的是，寻找答案的最好地方是医生们自己。</p><h1 id="edb4" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">安装</h1><p id="c8b2" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">我肯定要做的第一件事是设置，这样我就可以使用最新的javascript语法。我开始安装webpack和riot.js可能使用的任何所需的加载程序，幸运的是，文档站点简要介绍了如何安装webpack和es6。</p><p id="afe6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">值得注意的是，我不必这样设置。事实上，让每个标签成为一个单独的脚本非常容易，添加riot.js编译器脚本并让它在浏览器中处理其余的部分。这个团队做得很好。这已经使它成为模板/wordpress站点风格下降的一个很好的选择。这是我在第一篇</em>  <em class="kf">中最初的调查标准之一。</em></p><p id="533e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，一个典型的npm安装。<code class="eh lv lw lx ly b">npm i -D webpack babel-core babel-loader babel-preset-env riot riot-compiler riot-tag-loader</code></p><p id="795f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后是一个相当标准的webpack配置。你可以随意更改。标签加载器在那里很重要，这样webpack就知道如何处理riot标签。</p><p id="5fd2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> webpack.config.js </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="3f1f" class="md kz hu ly b fv me mf l mg mh">module.exports = {<br/>  entry: './src/js/app.js',<br/>  output: {<br/>    filename: './assets/js/main.js',<br/>  },<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.tag$/,<br/>        loader: 'riot-tag-loader',<br/>        enforce: 'pre',<br/>        query: {<br/>          type: 'es6'<br/>        }<br/>    }, {<br/>        test: /\.(js|tag)$/,<br/>        exclude: /node_modules/,<br/>        use: {<br/>          loader: 'babel-loader',<br/>          options: {<br/>            presets: ['babel-preset-env']<br/>          }<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="5e3f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了让它工作，我所做的就是在终端中运行<code class="eh lv lw lx ly b">webpack --watch</code>,这就是js编译。</p><p id="1f3f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">HTML/CSS<br/>HTML也很简单。我包含了一个名为<a class="ae kg" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> tailwind </a>的css库，它使用了实用程序类，因为我想拥有一些可以开始使用的样式。我最后也写了自己的css，但是很少。这真的不需要太多。只是一个小实验/webapp。</p><p id="4cfc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我使用npm的node <a class="ae kg" href="https://www.npmjs.com/package/http-server" rel="noopener ugc nofollow" target="_blank"> http-server </a>模块在本地提供这个服务，我使用这个模块来满足任何静态文件服务器的需求。这就是我想要的，我不需要热模块重装。这就足够了，也达到了它的目的。</p><p id="e725" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总的来说，很简单。</p></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><h1 id="b9a4" class="ky kz hu bd la lb mp ld le lf mq lh li ja mr jb lk jd ms je lm jg mt jh lo lp dt translated">开始暴乱</h1><p id="4549" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">要开始渲染riot标签，非常简单，只需导入全局riot实例，以及您想要渲染到应用程序中的任何riot标签。在app.js中，您应该这样写。</p><p id="f0e2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> app.js </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="a3df" class="md kz hu ly b fv me mf l mg mh">import riot from 'riot'<br/>import HelloWorld from './components/HelloWorld.tag'</span><span id="db41" class="md kz hu ly b fv mu mf l mg mh">riot.mount('*')</span></pre><p id="caf4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们使用了通配符，这意味着呈现它在页面上找到的所有标签。您也可以选择只呈现一个标记，方法是将它改为标记名<code class="eh lv lw lx ly b">riot.mount('hello-world')</code></p><p id="09d9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">组件/HelloWorld.tag </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="30a7" class="md kz hu ly b fv me mf l mg mh">&lt;hello-world&gt;<br/>  &lt;p&gt;Hello World&lt;/p&gt;</span><span id="a3ea" class="md kz hu ly b fv mu mf l mg mh">  &lt;script&gt;<br/>    console.log('Hello from hello world tag')<br/>  &lt;/script&gt;</span><span id="0374" class="md kz hu ly b fv mu mf l mg mh">&lt;/hello-world&gt;</span></pre><p id="1ed1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面你会看到创建一个标签，真的很简单；当你创建一个标签时，首先声明html，然后声明脚本标签。您也可以通过使用样式标签将css添加到这个文件中，但是我仍然喜欢将它们全部包含在一个css文件中。</p><p id="8822" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你感兴趣的话，防暴文档会更详细地介绍这一点。</p><p id="db6f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，您将编辑html以在html中包含riot/custom标记，以及一个脚本链接以包含您编译的js包。</p><p id="2df5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> HTML </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="2f9f" class="md kz hu ly b fv me mf l mg mh">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Riot | Riot Test&lt;/title&gt;<br/>    &lt;link href="https://cdn.jsdelivr.net/npm/tailwindcss/dist/preflight.min.css" rel="stylesheet"&gt;<br/>    &lt;!-- Any of your own CSS would go here --&gt;<br/>    &lt;link rel="stylesheet" href="assets/css/style.css"&gt;<br/>    &lt;link href="https://cdn.jsdelivr.net/npm/tailwindcss/dist/utilities.min.css" rel="stylesheet"&gt;<br/>  &lt;/head&gt;<br/>  &lt;body class="font-sans"&gt;<br/>    &lt;div class="container mx-auto"&gt;<br/>      &lt;hello-world&gt;&lt;/hello-world&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="assets/js/main.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="8db2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在屏幕上，你应该有一个写着“Hello World”的页面和一个控制台日志声明。那很容易，是啊。让我们使信息动态化。</p><p id="b671" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你放在自定义标签上的任何不属于<a class="ae kg" href="http://riotjs.com/api/#reserved-words" rel="noopener ugc nofollow" target="_blank">保留属性</a>的属性都将被传递到你附加到词汇‘this’的范围内，在一个名为<code class="eh lv lw lx ly b">opts</code>的键下。修改标签我们现在可以这样做。</p><p id="11bc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">组件/HelloWorld.tag </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="7b7e" class="md kz hu ly b fv me mf l mg mh">&lt;hello-world&gt;<br/>  &lt;p&gt;{this.opts.message}&lt;/p&gt;</span><span id="40d6" class="md kz hu ly b fv mu mf l mg mh">&lt;script&gt;<br/>    console.log(`${this.opts.message}`)<br/>  &lt;/script&gt;</span><span id="058f" class="md kz hu ly b fv mu mf l mg mh">&lt;/hello-world&gt;</span></pre><p id="6a4b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> HTML </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="81cf" class="md kz hu ly b fv me mf l mg mh">&lt;hello-world message="Hello from above"&gt;&lt;/hello-world&gt;</span></pre><p id="cf47" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以看到，突然之间传递数据变得很容易。你会发现这种单向数据流的范例也存在于React和Vue中。</p><p id="6107" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Riot还允许您在挂载标签时传入一个javascript对象，这将对根标签可用(因为您可以嵌套标签)。这将对标签实例上的<code class="eh lv lw lx ly b">opts</code>键可用。对象不仅仅是一个key:value，它也可以是一个函数，这意味着你可以将整个类和函数传递到你的标签中，这使得它非常强大。我们可以用它将数据传递给我们的标签。</p><p id="4131" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> app.js </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="285c" class="md kz hu ly b fv me mf l mg mh">import riot from 'riot'<br/>import HelloWorld from './components/HelloWorld.tag'</span><span id="e370" class="md kz hu ly b fv mu mf l mg mh">riot.mount('*', { message: "Hello from initial data"})</span></pre><p id="0bdd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我们需要修改我们的标签实例和html来使用它。</p><p id="bc0b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> HTML </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="b50e" class="md kz hu ly b fv me mf l mg mh">&lt;hello-world&gt;&lt;/hello-world&gt;</span></pre><p id="1970" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里，我们已经删除了消息属性，初始数据现在将被处理和传递。如果hello world嵌套在父标记中，情况会有所不同。这一次我们不需要修改标签中的任何内容。这是因为所有这些数据将被传递给<code class="eh lv lw lx ly b">opts</code>到父标签的任何直接后代。</p><p id="f12f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们将制作一个名为<code class="eh lv lw lx ly b">&lt;hello-container&gt;&lt;/hello-container&gt;</code>的新标签来演示如何将数据向下传递给顶级标签的后代标签。</p><p id="2a28" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> app.js </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="a56e" class="md kz hu ly b fv me mf l mg mh">import riot from 'riot'<br/>import HelloWorld from './components/HelloWorld.tag'<br/>import HelloContainer from './components/HelloContainer.tag'</span><span id="8b8e" class="md kz hu ly b fv mu mf l mg mh">riot.mount('*', { message: 'Hello from above'})</span></pre><p id="b252" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">components/hello container . tag</strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="3817" class="md kz hu ly b fv me mf l mg mh">&lt;hello-container&gt;<br/>  &lt;hello-world message={this.opts.message}&gt;&lt;/hello-world&gt;<br/>&lt;/hello-container&gt;</span></pre><p id="ed13" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里的<code class="eh lv lw lx ly b">hello-container</code>嵌套了我们的<code class="eh lv lw lx ly b">hello-world</code>标签。这就是标签所需要的，但是这一次，我们已经将消息从父标签/容器传递到嵌套的hello world标签。然后可以像以前一样通过<code class="eh lv lw lx ly b">this.opts.message</code>访问。</p><h1 id="7141" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated"><strong class="ak">制作定制器</strong></h1><p id="5c5b" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">既然已经介绍了如何制作和使用标签的基础知识。是时候开始定制了。这是我制作的，向我的好朋友兼室友<a class="ae kg" href="https://twitter.com/HughesMoose" rel="noopener ugc nofollow" target="_blank">马修·休斯</a>大声说，感谢他为我制作了这些资产。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/e6dd738c742e0eaedfdff3469c538ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmspV-0ehCGDGTOqeBd39w.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Finished result of the riot js customiser</figcaption></figure><p id="cc6e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个想法是，点击侧边栏中的任何一个选项都会改变暴徒的穿着。虽然很琐碎，但它演示了如何在各种标签之间传递数据，以及riot如何让我们轻松地做到这一点。</p><p id="7142" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先是制作侧边栏标签和父标签。它们如下。我们一会儿会做这些。</p><ul class=""><li id="82c6" class="mv mw hu jl b jm jn jp jq js mx jw my ka mz ke na nb nc nd dt translated"><code class="eh lv lw lx ly b">product-customiser</code></li><li id="fb51" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke na nb nc nd dt translated"><code class="eh lv lw lx ly b">&lt;sidebar&gt;&lt;/sidebar&gt;</code></li><li id="00e9" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke na nb nc nd dt translated"><code class="eh lv lw lx ly b">&lt;colour-list&gt;&lt;/colour-list&gt;</code></li><li id="64b1" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke na nb nc nd dt translated"><code class="eh lv lw lx ly b">&lt;colour&gt;&lt;/colour&gt;</code></li></ul><p id="c3d3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> app.js </strong></p><pre class="ki kj kk kl fq lz ly ma mb aw mc dt"><span id="94e6" class="md kz hu ly b fv me mf l mg mh">import riot from 'riot'<br/>import ProductCustomier from './components/ProductCustomiser.tag'<br/>import sidebar from './components/sidebar.tag'<br/>import ColourList from './components/ColourList.tag'<br/>import Colour from './components/Colour.tag'</span><span id="9c23" class="md kz hu ly b fv mu mf l mg mh">const initialState = {<br/>  options: {<br/>    head: [<br/>      {<br/>        name: 'Spotty Bandana',<br/>        thumbnail: 'bandana',<br/>        layerSrc: 'bandana',<br/>        hex: '#D92222'<br/>      }<br/>    ],<br/>  }<br/>}</span><span id="482d" class="md kz hu ly b fv mu mf l mg mh">riot.mount('product-customiser', initialState);</span></pre><p id="fd54" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用上面的数据结构，我们可以为每个头部，躯干和腿部层选择这些选项，并将这些选项作为一个数组放在里面。如果你想看完成的源文件，你可以看看它最后是如何构造的，以及我添加了多少选项，它和上面的一样。这里的文件是<a class="ae kg" href="https://github.com/birdyboy18/riotjs-rioter-customiser/blob/master/src/js/app.js" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="38e9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">为了让你更容易理解，我也不用和Medium的换行做斗争，我将主要发布代码片段的图片，而不是输入它们。此外，语法突出显示。</em></p><p id="4a8d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">components/product customizer . tag</strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nj"><img src="../Images/0d58b1e7fa1480c1188ad3ab88cf0344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dV_w5x1FVku-muoMFLk5Aw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Pass the options from our initial data from riot.mount</figcaption></figure><p id="e839" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">组件/侧栏.标签</strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nk"><img src="../Images/f2a14ebcca176366432dfb68a33db74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhV8fonz1g822klH6E9FgA.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">sidebar tag with nested colour-list tag being passed our options again to colours</figcaption></figure><p id="7b2e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于每个组，我们将头部、躯干和腿部的选项数组传递给颜色列表标签。然后，我们使用riot.js循环语法为每个条目渲染一个颜色标签。我们还传入一个名为layerName的属性，我们稍后会用到它。</p><p id="ad1c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">components/colour list . tag</strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nl"><img src="../Images/e0f628eed749a1d39e9b81df5f31979a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JYK5oznyWSqk97ag7AnoZw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Here the colour list tag takes the passed array for each option grouping and then renders a tag for each one.</figcaption></figure><p id="bc31" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当使用循环渲染标签时，它会自动将对象中的任何数据传递给标签实例，范围为<code class="eh lv lw lx ly b">this</code>。举个简单的例子，layerSrc将是<code class="eh lv lw lx ly b">this.layerSrc</code>，而不是像你想的那样放在<code class="eh lv lw lx ly b">this.opts.layerSrc</code>下。有关循环的参考，请查看<a class="ae kg" href="http://riotjs.com/guide/#loops" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="3efb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，使用传递下来的数据为每一个渲染颜色。</p><p id="4eab" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">组件/颜色.标签</strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nm"><img src="../Images/326149271d5eb68ccdc77e894b0dfc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7rbHisTQIEhCyvjaDLINQ.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Here we use the data to set a background using css</figcaption></figure><p id="68eb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在riot中，你可以使用一个转换成字符串的对象来设置样式。在这里，如果由于任何原因背景缩略图不存在，我们使用十六进制值来设置背景颜色，而不是图像。</p><p id="fd85" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既然我们已经成功地传递了我们的数据，我们需要它做一些事情。最好是当你点击它，让我们快速附加一个事件，建立应用程序的另一部分，然后回到这里。</p><p id="28f8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">成分/颜色.标签</strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nn"><img src="../Images/69dca5cea04c7f86b5d48d70e2d6b10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6AGodaUxcpe4FUW4pvXwg.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Added a changeLayer function to the onlick binding</figcaption></figure><p id="8690" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，我们需要建立我所说的更衣室标签。为了能够改变我们的暴徒的样子，这些图像都被放入一个包含div。</p><p id="5fa2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它的工作原理是有一个基础图像，然后每个图像层被导出为大小完全相同的透明png。这些位置绝对在基础的上面。然后当我们想改变头部、躯干或腿部时；我们可以使用该标签中绑定的标签属性来交换图像。让我展示给你看。</p><p id="dd2c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">组件/更衣室标签</strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff no"><img src="../Images/57984fb38d0526852fc2a91ba508c657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqeTX3i1dLDvVbvDwqpuXw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Here we pass active layers down from the opts</figcaption></figure><p id="3fed" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里，层图像源是从传递给标签的opts设置的。这些数据从app.js添加到根initialState，并按前面提到的方式传递给每个标记。</p><p id="7498" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">组件/产品定制者.标签</strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff np"><img src="../Images/aeeb4bd6e3ce20b35b952b8febebafb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFaW1ZD63vsF93poTVkpKA.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">We include the new changing room tag and pass in activeLayers</figcaption></figure><p id="3a45" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另外，不要忘记你需要导入新的<code class="eh lv lw lx ly b">changing-room</code>标签来让riot选择它。我们还将activeLayers传递到我们的侧边栏，因为我们以后会需要它们。</p><p id="418a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，这是我们初始状态的新部分。</p><p id="3591" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> app.js </strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nq"><img src="../Images/00288b4a33499156be7e88b8970a783c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2M3raGwkJN5LrHth5TIXOA.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">adding the new tag, and new activeLayers object</figcaption></figure><p id="b7cd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里的键指的是它所属的层，而值实际上就是我们想要获取的文件名。你会看到这些在<code class="eh lv lw lx ly b">ChangingRoom.tag</code>的代码中是匹配的。这些组成了图像目录中的文件名。如果成功的话，你的屏幕上会出现一个冷冷的戴夫。如果您正在跟进，但不确定资产/图像目录的结构。快速浏览一下<a class="ae kg" href="https://github.com/birdyboy18/riotjs-rioter-customiser" rel="noopener ugc nofollow" target="_blank"> github </a>上的源文件。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nr"><img src="../Images/bd3933142df757939c2d70e2e9c5050d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qaMq1MX4k0c-jQ4QC8XK5w.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Someone get this guy some clothes</figcaption></figure><p id="6b78" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要为Dave更改一件衣服，只需更改任一层的值。我们有问题吗？我们的组件/标签不知道彼此的存在。</p><p id="712d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这其实很好。如果他们这样做了，他们会耦合得太紧，而实际上我们希望他们不要关心彼此。这有很多好处，比如可读性、可维护性等等。</p></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><h1 id="6a90" class="ky kz hu bd la lb mp ld le lf mq lh li ja mr jb lk jd ms je lm jg mt jh lo lp dt translated">用可观察的方式集中我们的状态</h1><p id="45da" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">我将向您展示我是如何实现我提出的用于标签间对话的最终解决方案的，我将谈论我在经历时打嗝的地方。</p><p id="50d8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"><em class="kf">Hiccup 1</em><br/></strong><em class="kf">我第一次使用可观察的作为一个非常容易的事件总线，但是状态很快就不同步了。这是因为更新在状态改变之前就被调用了，但是在下一次点击时它会更新。它对图层的改变很有效，但是当我想给颜色标签添加活动状态时，它总是在后面。</em></p><p id="e93e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可观察是一种模式，其中代码可以监听并运行自定义事件的函数。这是一个非常强大的模式，我们将在React Redux范式的思想的帮助下使用它。</p><p id="4adc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我想让国家始终保持同步。这意味着我要开自己的商店。我大致了解了<a class="ae kg" href="https://redux.js.org/docs/introduction/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的工作原理，并实现了一个简单的例子。然而，我的版本没有使用dispatch或subscribe。它使用了riot和直接变异状态提供的本地on和trigger方法。代码并不多。</p><p id="344b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> Store.js </strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ns"><img src="../Images/b7169bc8e5d299aa82b90e75394dbc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmT1GAKAteZh4NYn8W58Aw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">All the code needed to create our a store class</figcaption></figure><p id="d71f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过将任何函数或类作为参数传递给<code class="eh lv lw lx ly b">Riot.observable</code>，你可以很容易地将它扩展为riot observable。这扩展了它，使它拥有所有与<code class="eh lv lw lx ly b">Riot.observable</code>相同的方法。这意味着现在我们的商店可以使用可观察的on和trigger方法等等。查看<a class="ae kg" href="http://riotjs.com/api/observable/" rel="noopener ugc nofollow" target="_blank"> API </a>了解它能做的一切。</p><p id="d028" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"><em class="kf">Hiccup 2<br/></em></strong><em class="kf">首先我采用了一种更面向对象的方法，尝试扩展Riot Observable并在构造函数中调用super on‘this’。出于某种原因，它附加了方法，但没有跟踪订户。因此我这样做了，在这里我调用Riot.observable，将类的词法this传递给它。</em></p><p id="fb58" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">商店可以采取一个初始状态，并在自己身上注册一个将调用<code class="eh lv lw lx ly b">handleAction</code>的事件。这意味着我们可以调用<code class="eh lv lw lx ly b">store.trigger(‘ACTION’, payload)</code>，<code class="eh lv lw lx ly b">handleAction</code>将运行。在这一点上，它的行为类似于redux中的reducer，但都是硬编码的。它将匹配动作，然后在触发更新事件之前改变状态。</p><p id="2316" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们为getState设置了一个自定义的getter，我不需要这样做，可以直接调用State，但我喜欢这种感觉，它更加隐含了我正在做的事情。</p><p id="a306" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那是一家商店。现在，我们只需要实例化它，并将其提供给我们的初始状态，并将其传递给我们的标签。</p><p id="e4ac" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> app.js </strong></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nt"><img src="../Images/7cda0a4d11aef7effac07fd4bba413c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5XIGqtGK02xgn0aNWC6bQ.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">make a store, feed it our data and pass it to the mount method</figcaption></figure><p id="212e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在您可以访问它并将其用作<code class="eh lv lw lx ly b">this.opts.store</code>。随着商店在标签上可用，你可以用它来触发改变，回到<code class="eh lv lw lx ly b">Color.tag</code>中的<code class="eh lv lw lx ly b">changeLayer</code>函数。你可以让它触发一个动作。然后改变它的状态。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nu"><img src="../Images/b62bb618b63735fbdd65fa88a889680a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxwDXcWABqHkU8fW43elVw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Here changeLayer now triggers an action in our store</figcaption></figure><p id="4fde" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的商店将知道如何对此做出反应，并改变状态。</p><p id="fecc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面我声明layername和activelayers的代码片段中，你可以看到我们可以从父节点获取opts，记住这是我们之前添加的。从父标签获取opts是我们已经使用过的方法，每个标签都可以访问它的父标签，直到根标签。</p><p id="eac9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">理论上，我可以通过向上遍历来访问商店，但是向下遍历更容易跟踪任意调用的<code class="eh lv lw lx ly b">this.parent.parent</code>等等。</p><p id="6695" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们知道了图层名，我们用它来知道我们想要改变哪个图层的源图像并把它发送过来。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ns"><img src="../Images/b7169bc8e5d299aa82b90e75394dbc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmT1GAKAteZh4NYn8W58Aw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">In the store you can see that the change layer action takes a payload that we use to change state</figcaption></figure><p id="7833" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“更改层”动作从有效负载中提取层名称，将其用作匹配关键字，并将其src设置为有效负载中提供的新src。在我们渲染的每个colourlist标签上，我们添加了一个名为layername — <code class="eh lv lw lx ly b">layername=’head’. </code>的属性，用于从活动层中选择正确的层并对其进行更改。一旦完成，它就会发出change事件，通知任何侦听器状态刚刚发生了变化。</p><p id="a607" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在可以监听标记中的change事件，并调用标记更新方法。</p><p id="e53d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">了解this.update()如何工作</strong></p><p id="1321" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关于更新，有两件重要的事情需要记住。首先，当用户交互调用事件处理程序时，它会自动更新。这意味着当我们调用颜色标签中的<code class="eh lv lw lx ly b">changeLayer</code>时，它将自动调用更新来重新评估该标签中的所有表达式。</p><p id="d6cb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其次，当它在一个标签上调用更新时，它也会在所有子标签上调用更新。知道这些很好，因为我们可以利用它们。为了更深入地了解你可以用update做什么，<a class="ae kg" href="http://riotjs.com/api/#updating" rel="noopener ugc nofollow" target="_blank">文档</a>提供了适量的细节。</p><p id="64f5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们知道了它是如何工作的，让我们在<code class="eh lv lw lx ly b">changing-room</code>标签中设置商店来监听变化。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nv"><img src="../Images/bd7701db4456e1343b467adbef26c01f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63ezRpLZKvxFvwq2QBlCEw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Here we listen for a change on our store re-update our expressions and call update</figcaption></figure><p id="dd04" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个标签现在知道每当我们的状态更新时该做什么。很好，现在状态保持同步，代码知道它何时被更新。我觉得这可以改进，所以这导致了下一个问题。</p><p id="a9c8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="kf">打嗝3 <br/> </em> </strong> <em class="kf">我想变得懒惰，不必记得传下我的店铺，也不必记得订阅。请记住，对父标签的更新会调用对所有子标签的更新。我想做的是在react land中被称为状态容器的东西。父包装标签是</em> <code class="eh lv lw lx ly b"><em class="kf">product-customiser</em></code> <em class="kf">我开始从存储中传递所有状态，然后监听变化，简单地重新分配状态并调用update。不幸的是，我不能让这个工作。我仍然不知道为什么它不如实。</em></p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nw"><img src="../Images/e93cd3b1552449aa00be5015faeebf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KlX--W8C2-ZOdWV_zlZ7rA.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Using product-customiser as a state container</figcaption></figure><p id="212b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">新代码现在使用了一个状态对象，我会重新分配、调用和更新这个对象，希望所有东西都能更新。我实际上发现这不起作用。更新是在子标签上调用的，但它似乎从不认为表达式已经改变。</p><p id="2a70" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管上面说的很好，但对于一个更大的应用程序来说，每次都重新呈现状态是不必要的，除了不能让它工作之外，我不想回到传递商店。需要满足一个快乐的中间立场。</p></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><h1 id="3cab" class="ky kz hu bd la lb mp ld le lf mq lh li ja mr jb lk jd ms je lm jg mt jh lo lp dt translated">混合起来</h1><p id="08f4" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">最终的解决方案非常简单，也是我认为最好的结果。我基本上希望能够在所有标签上引用我们的商店，而不需要传递下去。</p><p id="547b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">解决办法，暴动<a class="ae kg" href="http://riotjs.com/api/#mixins" rel="noopener ugc nofollow" target="_blank">混血儿</a>。mixin是一种模式，它允许你扩展一个对象，并向它添加定制的函数和属性，我们在前面使用riot observable间接实现了这一点。mixin允许你添加我们自己的方法。</p><p id="40af" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将创建一个接受我们的存储的函数，将它传递给对象和init方法，当标记被创建时，这个方法将被调用。然后我们告诉它将传递的存储附加到所有标签上，作为<code class="eh lv lw lx ly b">this.store</code>。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nx"><img src="../Images/3d57776502fbc8b36b4b1e0b3632c7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oug8oMlluoRBhpsqHgWgKw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">The storeMixin code</figcaption></figure><p id="b0de" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要开始使用mixin，我们需要使用riot.mixin方法，并向它传递我们刚刚创建的storeMixin函数。请记住，如果您想使用它，您需要导入它。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ny"><img src="../Images/c0309c4dd7ced54a8e0d80dc34443b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuXK6c_EMOrf0axabeAi-g.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Globally setting a mixin</figcaption></figure><p id="5685" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以像这里一样设置一个全局的mixin，也可以通过命名空间注册一个共享的mixin。然后你可以在任何你想使用的标签中调用<code class="eh lv lw lx ly b">this.mixin('myMixin')</code>。</p><p id="f0e9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用共享mixin的一个特别好的用例是，如果你想拥有多个商店。然后，你可以访问你只关心的标签中的商店，而不是拥有一个巨大的商店。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nz"><img src="../Images/976c75f938fa8a6caf7bd4e3bdd597fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXvxsARKMnmq1Iw_DLrNGQ.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Now we can simply call this.store and not have to worry about passing the store down to our tags</figcaption></figure><p id="d195" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在每个标签都可以访问存储，所有的东西都可以通过它运行，状态也可以保持同步。</p><p id="3a8a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在完成的源文件中，我仍然监听产品定制者的变化并更新状态，这确实更新了传递给标签的状态。似乎必须手动重新分配会使riot意识不到发生了变化。因为更新调用仍然在那里进行，所以您可以省略子标签的变更回调中的 <code class="eh lv lw lx ly b"><em class="kf">this.update()</em></code> <em class="kf">。</em></p><p id="d63c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，现在需要做的就是更新颜色标签以使用新的存储引用，并使用它来计算活动状态。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff oa"><img src="../Images/07aaf2fae7a6c52a0a321729783d3e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22W32dONf7soKKWxCsWi5A.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Here isActive is re-calculated on change, update not needed because it’s called in product-customiser</figcaption></figure><p id="3742" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，您还可以根据isActive类的值来添加它。</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ob"><img src="../Images/d2eaa633a7f140cbe533a527899c04b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SENAPJRJAzh4W0g1r-0EyA.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">add an isActive class if isActive is true or false</figcaption></figure><p id="99b2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你一直积极跟进，你应该希望有一个完整的衣服戴夫准备采取任何暴乱。这里是完成的<a class="ae kg" href="http://paulbird.co/riotjs-rioter-customiser/" rel="noopener ugc nofollow" target="_blank">演示</a>和<a class="ae kg" href="https://github.com/birdyboy18/riotjs-rioter-customiser" rel="noopener ugc nofollow" target="_blank">源代码</a></p></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><h1 id="b01d" class="ky kz hu bd la lb mp ld le lf mq lh li ja mr jb lk jd ms je lm jg mt jh lo lp dt translated">结论</h1><p id="9612" class="pw-post-body-paragraph jj jk hu jl b jm lq iv jo jp lr iy jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">我真的很喜欢学习Riot.js，这是一个非常整洁的小库。它的最小和小的API表面使得学习如何使用它非常快。事实上，它在如何做事上不是非常固执己见，这是我使用它的一个最喜欢的部分。尽管我以前从未使用过Redux，但我能够利用riot的observable API很快理解并实现它。这是我想做的，而不是因为暴乱告诉我要这么做。</p><p id="0dd2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">事实上，所有的逻辑都包含在一个标签文件中，我认为这很棒，把它直接放到html中，它就可以工作了，这太棒了。这种模式和Store模式相结合，使得为模板制作高级小部件和更高级的js功能变得非常有利可图。结合数据传递，您可以相对容易地从CMS中引导所需的数据。</p><p id="8fc6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我觉得mixins对我来说真的是锦上添花。我认为使用它来使商店对任何标签都可用是非常强大的，虽然不是一个不常见的概念，但真的很酷。老实说，我以前从来没有把mixins作为一种模式使用过，所以陷进去感觉很好。</p><p id="7013" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我唯一的批评是，我想更深入地了解更新是如何工作的，因为我觉得状态容器方法确实应该工作。我认为如果文档告诉你它如何知道触发更新，以及除了已经提到的更新之外可能存在的任何警告，那会更好。</p><p id="4ba2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Riot不会强迫你进入一个范式，很容易学会。它不需要使用ES6语法，如果需要，可以在浏览器中快速运行。这使得它成为遗留javascript项目的一个完美竞争者，这也是我在对各种js库的整个调查中想要考虑的事情之一。</p><p id="3e88" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">标签可以很容易地解耦，这意味着我们仍然可以让页面的不同部分相互交流，即使使用服务器呈现的模板。</p><p id="5b79" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总的来说，我已经认为这是一个很好的嵌入式方法的竞争者。仅此而已。</p><p id="b085" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你已经读到这里，感谢你一直关注我。我希望这对你有所帮助，哪怕是一点点。我很想知道你的想法，所以请留言；我写的不多(可能显而易见？).下周我将在一个新的图书馆里建立一个新的项目，所以请留意。再次感谢。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="oc od l"/></div></figure></div></div>    
</body>
</html>