<html>
<head>
<title>Graphcool framework analysis and its use case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Graphcool框架分析及其用例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphcool-framework-analysis-and-its-use-case-319173a9aea4?source=collection_archive---------10-----------------------#2018-01-18">https://medium.com/hackernoon/graphcool-framework-analysis-and-its-use-case-319173a9aea4?source=collection_archive---------10-----------------------#2018-01-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/047353a8a620d68eb0c4d7024ed167e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8UtQaD0ydDb6laNoVg7_g.png"/></div></div></figure><h1 id="4a4e" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Graphcool框架简介</h1><p id="f175" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Graphcool是一个用于生产就绪的无服务器GraphQL后端<a class="ae ky" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a>和发布的框架。它<a class="ae ky" href="https://blog.graph.cool/introducing-the-graphcool-framework-d9edab2a7816" rel="noopener ugc nofollow" target="_blank">在2017年10月成为开源</a>。Graphcool包括GraphQL数据库映射、实时订阅和灵活的权限系统。</p><h2 id="c9f1" class="kz jd hu bd je la lb lc ji ld le lf jm kl lg lh jq kp li lj ju kt lk ll jy lm dt translated">GraphQL和Graphcool背景</h2><p id="3f77" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Graphcool基于GraphQL，我们稍微讨论一下。</p><p id="fc5c" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">GraphQL是一种查询语言规范，由脸书于2015年推出。GraphQL提供了比REST更灵活的后端通信可能性。使用REST，您可以获得许多端点来处理资源，但是GraphQL只有一个端点，而您的需求在查询本身中描述。</p><p id="20d7" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">GraphQL的名字表明它以图形的形式表示数据。(GraphQL的主要思想，实际上包含在它的名字中，是以图形形式表示数据)这里是一个<a class="ae ky" href="https://hackernoon.com/tagged/facebook" rel="noopener ugc nofollow" target="_blank">脸书</a>的例子。假设您想要检索一条包含所有评论和作者信息的消息。</p><ul class=""><li id="d1b0" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx lx ly lz ma dt translated">使用REST API，您需要发送几个查询来获取消息、它的注释和作者的数据。</li><li id="3ab5" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">使用GraphQL API，您可以通过一个后端回复来检索这些数据，因为您可以确定在查询中需要哪些数据。</li></ul><p id="ef48" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">点击了解更多关于GraphQL <a class="ae ky" href="https://medium.freecodecamp.org/so-whats-this-graphql-thing-i-keep-hearing-about-baf4d36c20cf" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/7fd834cf0cf23263e607aa90da521692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xm_UmjVduRYBpWj3HYxh_g.png"/></div></div></figure><p id="f15c" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">为了让客户理解他或她可以从GraphQL后端查询哪些数据，使用了用GraphQL模式定义语言编写的模式。scheme是一个数据模型，它描述了应用程序中的数据类型以及它们之间的关系。GraphQL模式定义是表示GraphQL模式的最短方式。</p><p id="d8e7" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">语法是由官方的GraphQL规范定义的。模式定义有时被称为IDL(接口定义语言)或SDL(模式定义语言)。博客中应用程序的GraphQL方案可以这样表示。</p><p id="2893" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">GraphQL只是一个规范，所以为了使用它，您将需要一个规范实现的服务。您可以创建自己的服务或使用GraphQL后端即服务(BaaS)，如Graphcool。</p><p id="6dcd" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">Graphcool负责保存您的数据，并为您的应用程序提供一个GraphQL端点。你只需要确定Graphcool方案，它就会自动生成数据查询和编辑的函数。</p><p id="875d" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">如果您的应用程序需要实时更新，您可以使用GraphQL订阅。Graphcool还为业务逻辑提供数据存储、第三方认证集成和服务器功能，因此它是一个真正通用的应用程序解决方案。</p><h2 id="7334" class="kz jd hu bd je la lb lc ji ld le lf jm kl lg lh jq kp li lj ju kt lk ll jy lm dt translated">Graphcool用法</h2><p id="f713" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">基于Graphcool的开发方式有两种:本地和基于云的。</p><p id="c77a" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">Graphcool Cloud现在已经上线2年了，为项目启动提供了几种可能性。</p><ol class=""><li id="2a8f" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx ml ly lz ma dt translated">共享集群使用按需购买模式，并允许根据您的需求自动扩展。</li><li id="7338" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx ml ly lz ma dt translated">私有集群类似于共享集群，但是基于您自己的基础设施和AWS帐户。</li></ol><p id="11ab" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">得益于Graphcool框架，Graphcool可以在个人电脑上启动。因此，开发过程加快了，包括自主开发和CI管道集成。今天我们将报道当地的发展。</p><h1 id="c3c6" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Graphcool APIs</h1><p id="535e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Graphcool为您的数据模型提供自动生成的CRUD API。它还提供实时API，使用GraphQL订阅和专用API进行文件管理。Graphcool的主要优势是基于您为服务选择的数据模型自动生成CRUD API。</p><p id="3685" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">这个API提供了过滤、排序和分页的特性。</p><p id="2472" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">每个Graphcool服务都提供了基于GraphQL订阅的实时API，它允许对系统事件做出及时的反应。请记住，默认情况下，每个Graphcool服务都提供了两个不同的API接口:</p><ol class=""><li id="9f57" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx ml ly lz ma dt translated">简单API负责直观的CRUD操作和数据建模。</li><li id="9056" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx ml ly lz ma dt translated">中继API符合中继方案的要求。</li></ol><p id="64b9" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">两个API都转向同一个数据库！</p><h2 id="d26a" class="kz jd hu bd je la lb lc ji ld le lf jm kl lg lh jq kp li lj ju kt lk ll jy lm dt translated">Graphcool查询结构</h2><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/f57aa1d33820765cd277887b9a1fa5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1bE_o6mgNW3YPBXbK6L5Q.png"/></div></div></figure><p id="0101" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">这就是对所有相同类型条目的查询及其响应的样子。该查询由查询名称(在本例中为all)和您希望检索的字段列表组成。响应以对象数组的形式返回，对象的键是查询中指定的字段。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/abc04e7623ad1545e56b6602991d3f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DL-_OU9pB3IGbfCqw4VWNw.png"/></div></div></figure><p id="c17e" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">这样，您可以通过节点ID获得某个条目。指定模型类型，括号中是所需的节点ID，并列出字段。响应将包含必要类型的对象。</p><p id="5d63" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">也可以通过唯一字段获取某个节点。我们通过唯一字段进行搜索，而不是节点的ID。</p><p id="f45e" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">以下是数据组织的论据:</p><ul class=""><li id="0dd0" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx lx ly lz ma dt translated">字段排序。排序依据:<field> _ASC/ <field> _DESC。指定字段和排序顺序。</field></field></li><li id="c295" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">过滤。</li><li id="2fa5" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">传呼。</li></ul><p id="654f" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">这些论点可以结合起来。</p><p id="b798" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">目前，这些参数的使用有一些限制:</p><ul class=""><li id="4c5a" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx lx ly lz ma dt translated">无法通过几个字段或相关字段请求响应。</li><li id="2418" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">返回数据对象的最大数量是1000。</li></ul><h2 id="90a5" class="kz jd hu bd je la lb lc ji ld le lf jm kl lg lh jq kp li lj ju kt lk ll jy lm dt translated">Graphcool过滤</h2><p id="0199" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">过滤值得特别注意。Graphcool可以通过所需节点本身以及相关节点过滤数据。逻辑运算符和/或扩大过滤的可能性。Graphcool可以使用in/lt/LTE/gt/GTE/contains/starts with/ends with运算符及其否定。</p><p id="2438" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">对于每种字段类型，都有特定的过滤器，文本类型示例允许您查看大多数过滤器。当然也有局限性。数组和JSON过滤还没实现。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/049eb025439032416be3eec8741092b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5nvdkogNQ_-71ujKpR9Iw.png"/></div></div></figure><h2 id="dcd8" class="kz jd hu bd je la lb lc ji ld le lf jm kl lg lh jq kp li lj ju kt lk ll jy lm dt translated">创建、更新和删除节点</h2><p id="15be" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">为特定类型创建的每个新节点都会被分配一个新的ID。必须指定所有没有默认值的必填字段，其他字段是可选参数。查询响应可以包含新创建的节点的所有字段，包括ID字段。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/994b3fc579f88d546b43fc83d4e3f7b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nywRzeHXVXKocinXk_DqVA.png"/></div></div></figure><p id="d08d" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">更新节点的操作类似，但是查询数据应该包括节点ID。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/5583aed6c9fc08d3ed8a29bc91421c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWFVRJ7iPv0Y-FMoF-b-GQ.png"/></div></div></figure><p id="b26e" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">嵌套突变可能用于创建和更新节点。因此，一个查询允许您创建或更新所有相关节点。目前，最大嵌套级别是3。如果需要更高的嵌套级别，则需要创建新的查询。</p><p id="1567" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">要删除节点，您需要指定节点ID。遗憾的是，目前不支持嵌套和级联删除。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/d60588cef633ce11d64bad01c95c4990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcgT3O3PAe7nTwya7OLX9g.png"/></div></div></figure><h1 id="b790" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Graphcool模板</h1><p id="6d77" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Graphcool支持一个模板系统来加速开发。客户端可以立即使用通过控制台添加的新模板。</p><p id="e6b3" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">模板通常不需要任何修改，但是，可以很容易地进行任何必要的调整来适应您的方案。模板的源代码被添加到您的工作目录中。目前，官方模板的列表并不长，以下是其中的一些:</p><ul class=""><li id="344e" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx lx ly lz ma dt translated">电子邮件的认证模板-密码，谷歌，脸书，认证0</li><li id="d1ad" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">消息模板:mailgun、ses、push(推送通知)或twilio(短信)。</li></ul><p id="8b25" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">还有非官方的模板。</p><h1 id="ab52" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Graphcool认证</h1><p id="3495" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">基于令牌的模板用于Graphcool中的身份验证。为您的应用程序启用了rootToken的使用。</p><p id="527e" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">使用授权系统，可以很容易地创建权限规则并将其与身份验证集成。Graphcool提供了一个非常灵活的基于功能的认证系统。</p><p id="d592" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">使用Graphcool，您可以识别需要认证的API操作。执行操作的HTTP-query应该在其授权头中拥有有效的身份验证令牌。否则，查询将因无效权限而中止。</p><h1 id="df1f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Graphcool权限</h1><p id="9908" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">graphcool.yml中描述了权限。在权限块中，您可以列出需要哪些类型的权限。可以对操作和操作之间的关系进行限制。</p><p id="c9d4" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">要设置限制，您需要定义哪个操作限于某个节点。接下来，确定操作适用的用户类型(授权或未授权)。您可以选择将应用限制的某些节点字段，并标识特定的限制规则。</p><p id="8cd2" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">权限基于过滤系统。只需为每个字段指定必要的值。使用Graphcool，这样的查询将获得当前用户的user_id和正在检查的当前帐户的数据。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/7a857673052a8bca742f5fe8275f807a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNPXywE0dtAKB3mO0y6xBg.png"/></div></div></figure><h1 id="36d0" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Graphcool的利与弊</h1><p id="87e6" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们来总结一下Graphcool的优缺点。</p><p id="ae8e" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">显然，有一些缺点:</p><ul class=""><li id="2c75" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx lx ly lz ma dt translated">Graphcool生成的MySQL schema相当具体。这些表之间没有关系。这些关系包含在具有相关节点id的表中。在MySQL容器初始化时，Graphcool为元数据(项目ID和主要数据、用户特性、关系、webhooks、一些用户数据)创建一个数据库。在部署应用程序时，会创建一个单独的数据库，并使用生成的ID进行命名。它包含在graphcool.yml中指定的表。除了包含所述节点的表之外，还有用于节点关系的表。</li></ul><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/36172d474ce3058b9de434b50dc2f7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGDvk-YVOfKQ_2OgkdBmiw.png"/></div></div></figure><ul class=""><li id="357d" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx lx ly lz ma dt translated">由于缺少关系，级联删除是不可能的。</li><li id="21fc" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">这个项目对于开源来说是相当新的，文档也有很多不尽如人意的地方。</li><li id="0b30" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">IDE中没有支持语法的插件。唯一值得庆幸的是Intellij IDEA插件支持GraphQL。</li></ul><p id="737a" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">现在是优势的时候了:</p><ul class=""><li id="a0dd" class="ls lt hu kc b kd ln kh lo kl lu kp lv kt lw kx lx ly lz ma dt translated">发展速度极高。只需定义方案，剩下的工作由Graphcool来完成。</li><li id="6823" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">Graphcool可以利用用JavaScript和TypeScript编写的解析器，从而扩大了它的潜力。</li><li id="775a" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">有一个强大的过滤功能，让您不费吹灰之力就能获得必要的返回数据。</li><li id="e4c3" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">Graphcool可以处理云存储中的文件。</li><li id="aacc" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">模板提高了开发速度，并提供了尝试过的解决方案。</li><li id="adb7" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">学习曲线低。了解如何使用GraphQL创建方案，就可以开始工作了。</li></ul><p id="eb53" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">由于Graphcool是基于GraphQL的，所以它们共享了大多数优点和缺点。在某些方面，Graphcool正在变得更好，但仍有很长的路要走。</p><h1 id="592d" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">项目利用</h1><p id="8319" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在我们的研究过程中，我们决定在一个实际项目中使用PostgraphQL来实现这个框架，以比较这些技术。</p><p id="bfe8" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">创建了项目的主要节点和CRUD操作，实现了授权和高级共享系统(根据用户角色和组共享基础设施对象)。开发后端花了3天时间。</p><p id="8473" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">由于Graphcool拥有开箱即用的嵌套突变和灵活的过滤系统，因此不需要创建定制的解析器，一切都只使用框架的功能来实现。</p><h1 id="dbb1" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">Graphcool vs Postgraphql</h1><ul class=""><li id="e40c" class="ls lt hu kc b kd ke kh ki kl mn kp mo kt mp kx lx ly lz ma dt translated">自定义端点。Graphcool几乎没有限制，允许使用JS。PostgraphQL受到数据库的限制。</li><li id="f126" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">CreateOrUpdate。Postgres里有Upsert，但是在PostgraphQL里不能用。在Graphcool中，它是开箱即用的。</li><li id="32e1" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">嵌套突变。PostgraphQL不创建或更新相关节点，它只能通过单独的查询来完成。</li><li id="ca2f" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">原始SQL查询。目前，Graphcool不能为GraphQL方案映射数据库方案。</li><li id="e921" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">过滤。Graphcool提供了广泛的设置，可以比较行、日期、数组，而PostgraphQL只能比较键或值。</li><li id="80d1" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">自动化。Graphcool拥有createdAt/updatedAt字段、关系操作的自动触发器。同样的操作需要在PostgraphQL中手工执行。</li><li id="0e93" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">计算字段。到目前为止，Graphcool不支持计算字段。它们只能通过单独的解析器来支持。</li><li id="5c36" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">级联删除。由于数据库的特殊性，Graphcool不支持级联删除。</li><li id="f803" class="ls lt hu kc b kd mb kh mc kl md kp me kt mf kx lx ly lz ma dt translated">数据聚合。Graphcool不支持根据您的需求聚合数据的内部数据库功能。</li></ul><h1 id="e1df" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">结论</h1><p id="e1ed" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如你所见，Graphcool是一个有趣而强大的框架。然而，由于它最近才成为开源的，它仍然有一些问题正在通过开发者和用户的合作得到解决。</p><p id="0e3d" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">这项工作将继续确保其他数据库的支持、数据聚合和级联删除。</p><p id="e282" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">作为一名开发人员，我认为Graphcool最适合中小型项目和快速原型开发，因为它提供了许多开箱即用的功能(嵌套变异、灵活的过滤系统、模板、JS/TS上编写的自定义变异)，并且不需要深入的SQL知识。</p><h1 id="8c25" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">最后的话</h1><p id="8ef9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我需要提到的是，我是这篇文章的合著者。原文链接可点击此处<a class="ae ky" href="https://freshcodeit.com/blog/2017/12/26/graphcool-framework-analysis-and-practical-cases/" rel="noopener ugc nofollow" target="_blank">https://freshcodeit . com/blog/2017/12/26/graph cool-framework-analysis-and-practical-cases/</a>。</p><p id="d355" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">请务必点击此链接查看FreshCode IT公司网站【https://freshcodeit.com/<a class="ae ky" href="https://freshcodeit.com/" rel="noopener ugc nofollow" target="_blank"/>，在他们的博客上可以找到很多精彩的文章。</p><p id="e7c7" class="pw-post-body-paragraph ka kb hu kc b kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt lr kv kw kx hn dt translated">感谢阅读。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure></div></div>    
</body>
</html>