<html>
<head>
<title>Processing forms on AMP pages with Amazon API Gateway and AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Amazon API Gateway和AWS Lambda处理AMP页面上的表单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/processing-forms-on-amp-pages-with-amazon-api-gateway-and-aws-lambda-18c185a464d4?source=collection_archive---------20-----------------------#2018-01-18">https://medium.com/hackernoon/processing-forms-on-amp-pages-with-amazon-api-gateway-and-aws-lambda-18c185a464d4?source=collection_archive---------20-----------------------#2018-01-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a588" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">了解如何使用Python和Amazon services for serverless应用程序在AMP页面上实现和处理表单。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/f3aeaa18211562ae76f27580b8ec681f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v6-wvViiy2zo_6t9.png"/></div></div></figure><h1 id="72f8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">AMP是什么？</h1><p id="905b" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">AMP或加速移动页面是谷歌试图缓解移动用户在他们的设备上打开大而重的网站时的挫折感。AMP的三个主要组件是:</p><ol class=""><li id="802e" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm dt translated">AMP HTML—HTML 5组件的子集，可提供可靠的性能和更快的网页加载速度。</li><li id="ee1a" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">AMP JS——一个实现最佳实践以更快地呈现页面的库，例如，异步加载外部资源，在加载任何东西之前加载字体，等等。</li><li id="4bb8" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">AMP Cache——一组基于代理的cdn，用于获取您的AMP页面，将它们与所有必要的资源一起缓存，并通过HTTP/2提供给用户。这种缓存最臭名昭著的例子当然是Google AMP缓存。</li></ol><p id="0c44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，所有这些性能改进都是有代价的。没有外部样式表(除了白名单字体提供者)，没有内联样式(无论如何这不是一个好主意)。脚本只允许作为AMP组件的一部分或在iframes中，并且只有在它们是非阻塞的情况下。</p><h1 id="fd82" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为什么这很重要？</h1><p id="8be3" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">目前，AMP被视为主要用于新闻文章和博客文章的移动解决方案，没有证据表明实施它会影响搜索排名。然而，谷歌已经开始在搜索结果中区分AMP页面，并且很有可能在某个时候开始将AMP页面放在更高的位置。其他搜索引擎也看到了这项技术的潜力。比如Bing从2016年9月开始支持。</p><h1 id="201a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">简单页面</h1><p id="88f4" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">让我们从一个最小的放大器代码开始:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="aae8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还没有太多的进展，但是让我们看看这个页面与一般的HTML页面有什么不同。要将页面转换为AMP，您需要用(或者，如果您不喜欢那些花哨的Unicode符号)替换标签，并包含标准的样板代码来加载AMP脚本，正确设置页面的视窗和基本样式。</p><p id="ac58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你所有的自定义CSS代码必须位于head中的<style amp-custom="">标签中。&lt;/root&gt;</style></p><p id="42e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比方说，现在我们想添加一个简单的MailChimp表单来收集订阅者的电子邮件。你可能会想，很简单，去Mailchimp，抓取一些嵌入的表单代码，然后把它添加到你的页面上。嗯，不是。AMP中被阻止的一个东西是带有后动作的常规表单。好消息是您可以使用POST表单和action-xhr异步发送请求，坏消息是它需要某些Mailchimp没有提供的CORS头:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lu"><img src="../Images/73a867ba4441cd0b6e83ee368007d0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7HRKfiQU_VhjFk5k.png"/></div></div></figure><p id="36a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着您需要一个定制的后端来处理表单输入并将其发送到MailChimp。如果你的站点只是一个静态文件的集合，例如，用Jekyll创建并托管在Github Pages或Amazon S3上，那么你就进退两难了:是托管一个为你的页面提供服务并处理表单数据的服务器，还是创建一个只将你的数据传递给MailChimp并发送正确响应的后端。在本文中，我们将探索第二种方法。</p><h1 id="74fa" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">过帐表单</h1><p id="7f53" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">让我们从向页面添加一个表单开始。第一步是在head中加载amp-form组件。根据放大器规格，这是必需的:</p><blockquote class="lv lw lx"><p id="23b6" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated"><em class="hu">使用&lt;表单&gt;时必须加载amp-form扩展，否则您的文档将无效！</em></p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="6dca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以添加表单本身:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="221c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与常规表单标签的唯一区别是，如果<code class="eh mc md me mf b">method</code>是POST，则需要action-xhr。您还可以添加带有submit-success和submit-error类的div，根据响应状态代码(submit-success为200，submit-error为其他所有内容)来显示这些div。当与amp-mustache模板组件结合使用时，这是向用户呈现状态信息的一种非常方便的方式。让我们看看结果代码:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="e5ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将异步提交表单；如果响应的状态代码为200，它将显示div和类submit-success，并用响应正文中的email字段替换{{email}}。如果响应有任何其他代码(即发生了错误)，它将显示submit-error div并用响应正文中的errorMessage字段替换{{errorMessage}}。</p><h1 id="cb9a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">后端</h1><p id="883f" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">为了处理请求，我们将结合使用Amazon API Gateway和Python中的Lambda函数。它们允许运行代码，而不需要设置任何服务器或基础设施，并让您在几分钟内获得后端工作。</p><p id="b00f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的重要一点是，action-xhr将数据作为多部分/形式数据提交，API Gateway本身不支持这一点，并且需要在Lambda函数中进行一些解析。API网关的设置相当简单，我们需要它在“代理”模式下工作，也就是把所有的请求数据传递给Lambda，并从Lambda传递所有的响应数据。这是必要的，不仅因为API Gateway不支持多部分表单数据，还因为amp-form需要依赖于请求中的查询字符串的响应CORS标头，稍后将详细介绍这一点。</p><h1 id="e868" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">λ函数</h1><p id="3dd8" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">让我们创建一个处理表单数据的函数。登录你的AWS账户，选择Lambda服务，点击“创建函数”。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mg"><img src="../Images/0857fc25fc3948732aa098419647074b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f3qF6RaXKGXjjsZR.png"/></div></div></figure><p id="7256" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在蓝图中选择“从头开始创作”</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mg"><img src="../Images/ab349d6a160d42769a834f6a312f82b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J46TO1qHeaVtM7uT.png"/></div></div></figure><p id="c7ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在“基本信息”部分，为您的函数选择一个名称，并为Lambda配置执行角色。角色描述本身证明了文章的合理性，因此如果您不确定如何配置它，对于我们当前的目的，您可以选择“创建新角色”，填写名称，并将“简单微服务权限”添加到“策略模板”中。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mg"><img src="../Images/b3b5bfa7bec2bccaec98eb939defa1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qeE7_khd4kjWOJXe.png"/></div></div></figure><p id="8636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">单击“创建函数”，在下一个屏幕上将“运行时”设置为Python 3.6。暂时保留功能代码。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mh"><img src="../Images/eb94c68b1a7bdfd15ed5dde9a4311eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0OEhla7SfKG8DUEn.png"/></div></div></figure><p id="4597" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们看看默认的功能代码:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="156d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当Lambda函数在代理模式下与API Gateway一起使用时，事件字典包含以下形式的请求信息:</p><pre class="jq jr js jt fq mi mf mj mk aw ml dt"><span id="5ff5" class="mm kc hu mf b fv mn mo l mp mq">{ <br/>    "resource": "/", <br/>    "path": "/", <br/>    "httpMethod": "POST", <br/>    "headers": { ... }, <br/>    "queryStringParameters": { ... }, <br/>    "pathParameters": "", <br/>    "stageVariables": "", <br/>    "requestContext": { ... }, <br/>    "body": "...", <br/>    "isBase64Encoded": true/false <br/>}</span></pre><p id="cee3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有字段都是不言自明的，我们只对头、queryStringParameters和主体感兴趣。为了理解我们到底需要如何解析请求，让我们看看请求是如何发送的:</p><p id="69e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">标题:</p><pre class="jq jr js jt fq mi mf mj mk aw ml dt"><span id="4564" class="mm kc hu mf b fv mn mo l mp mq">accept:application/json <br/>content-length:157 <br/>content-type:multipart/form-data; <br/>boundary=----WebKitFormBoundaryYoEf5GGRCRaKj2oT origin:http://127.0.0.1:8000</span></pre><p id="55dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查询字符串参数:</p><pre class="jq jr js jt fq mi mf mj mk aw ml dt"><span id="ae25" class="mm kc hu mf b fv mn mo l mp mq">__amp_source_origin:http://127.0.0.1:8000</span></pre><p id="c454" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请求有效负载:</p><pre class="jq jr js jt fq mi mf mj mk aw ml dt"><span id="91cb" class="mm kc hu mf b fv mn mo l mp mq">------WebKitFormBoundaryYoEf5GGRCRaKj2oT <br/>Content-Disposition: form-data; name="email" </span><span id="4278" class="mm kc hu mf b fv mr mo l mp mq">test@example.com <br/>------WebKitFormBoundaryYoEf5GGRCRaKj2oT--</span></pre><p id="03ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里没有什么真正有趣的，这是一个标准的多部分/表单数据请求。为了解析它，我们需要使用旧的cgi模块。使用它，我们可以解析内容类型头以获得边界，然后解析正文本身:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="d067" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，form_data包含一个字典，其中包含通过表单提交的所有数据。字典中的每个值都是一个字节字符串数组。在我们的例子中，form_data应该是这样的:</p><pre class="jq jr js jt fq mi mf mj mk aw ml dt"><span id="685a" class="mm kc hu mf b fv mn mo l mp mq">{'email': [b'test@example.com']}</span></pre><p id="8b59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很好，现在我们知道如何解析请求并获得必要的值。但是如何将响应发送回去呢？让我们先弄清楚我们需要发送什么。</p><p id="9258" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">AMP对于它期望在你的服务器上发生的事情非常明确。为了满足安全需求，你应该做什么和不应该做什么，这里有一个很长的描述。出于本文的目的，我们将只关注它的一个方面，它在响应中期望的头:</p><ul class=""><li id="0386" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo mt lk ll lm dt translated">访问控制允许来源:。标头必须设置为与请求中的原始标头相同的值。当您执行允许来源的检查时，请记住，请求不仅会来自您的域，还会来自AMP缓存域</li><li id="4979" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo mt lk ll lm dt translated">AMP-访问-控制-允许-来源-来源:。标头必须包含查询字符串参数__amp_source_origin中传递的值</li><li id="bad6" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo mt lk ll lm dt translated">访问控制公开头:AMP访问控制允许来源来源。该报头的唯一目的是允许设置AMP-Access-Control-Allow-Source-Origin</li></ul><p id="cfb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">加上标准CORS接头:</p><ul class=""><li id="6c78" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo mt lk ll lm dt translated">访问控制允许凭证:真</li><li id="749f" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo mt lk ll lm dt translated">访问控制允许头:内容类型、X-Amz日期、授权、X-Api密钥、X-Amz安全令牌</li><li id="f56d" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo mt lk ll lm dt translated">访问控制允许方法:POST</li></ul><p id="25de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后是内容类型头。从示例请求头可以看出，它需要application/json</p><h1 id="59b0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">在Lambda中创建响应</h1><p id="a2db" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">首先，我们需要为依赖于请求数据的头获取正确的值:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="6a6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以创建响应。API Gateway希望Lambda函数的输出是包含以下键的字典:</p><ul class=""><li id="5e18" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo mt lk ll lm dt translated">statusCode —符合<a class="ae ms" href="https://tools.ietf.org/html/rfc7231#section-6" rel="noopener ugc nofollow" target="_blank"> RFC7231 </a>的HTTP状态代码</li><li id="2021" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo mt lk ll lm dt translated">body —字符串化的JSON，响应的主体</li><li id="ed06" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo mt lk ll lm dt translated">标题—包含响应标题的字典</li></ul><p id="8f05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总结一下，下面是返回响应的代码:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="3821" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们把它们放在一起:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><h1 id="1296" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">API网关</h1><p id="8d91" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">最后一步是配置API网关服务来代理对Lambda函数的请求。转到AWS控制台中的API网关服务，然后单击“开始”。选择“新API”并给它一个描述性的名称。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mu"><img src="../Images/8d6a5d0aaa028e17916ab38120eef51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Grt6be2_fpQAixl2.png"/></div></div></figure><p id="964b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在点击“动作”，然后“创建方法”。在下拉列表中选择POST，然后单击复选标记进行确认。将“集成类型”设置为“Lambda函数”，选中“使用Lambda代理集成”，选择您的函数所在的地区，并输入函数名称。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mv"><img src="../Images/7b0a5df2ffbdbe03b614161ed5da912f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wtgj1ogK8m3yy6kP.png"/></div></div></figure><p id="47b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">单击“保存”保存设置，然后单击“确定”为该功能创建触发器。现在选择“Actions”→“Deploy API”，选择“New Stage”，给它一个名称(例如，“dev”、“test”或“prod”)，然后按“Deploy”。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mw"><img src="../Images/111a33231cd9fb9464475d231e1eb3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ZYe_3T_j7jwtVDh.png"/></div></div></figure><p id="3c17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您将看到现在需要粘贴到HTML代码表单中action-xhr参数中的阶段URL。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mx"><img src="../Images/70b158e9796896f6338256bb8cb1229e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lnoGKRZOENvjgBJf.png"/></div></div></figure><h1 id="82db" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="4007" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">当前的趋势是为移动用户提供轻便快捷的网络体验，这种趋势可能会持续下去，AMP也是如此。有人可能会说AMP过于严格，过于以谷歌为导向，但是越来越多的出版商采用这项技术来保持他们的SEO处于良好状态。随着技术的成熟，更容易获得的组件将会出现。然而，现在，开发人员需要有一种在不损害性能的情况下克服这些限制的方法。创建这样的中间人来“代理”对不提供AMP组件和不支持所需CORS设置的服务的请求，是保持您的AMP页面交互和有用的重要步骤。</p><p id="1651" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然AMP文档很好，也很简单，但是我们觉得它缺少实现的例子。本文的目的是为希望以最简单的方式在AWS基础设施上实现AMP页面后端的开发人员提供一个概述和一个起点。</p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="fceb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ly">最初发表于</em><a class="ae ms" href="https://cruxlab.com/blog/processing-forms-amp" rel="noopener ugc nofollow" target="_blank"><em class="ly">【cruxlab.com】</em></a><em class="ly">。</em></p></div></div>    
</body>
</html>