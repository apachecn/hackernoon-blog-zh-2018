<html>
<head>
<title>Making Functional Programming Click</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让函数式编程点击</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-functional-programming-click-836d4715baf2?source=collection_archive---------2-----------------------#2018-01-19">https://medium.com/hackernoon/making-functional-programming-click-836d4715baf2?source=collection_archive---------2-----------------------#2018-01-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/d02f4cb489831abb4ddb5a0fbba51529.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*lwQknGi7ohn_KuDYQl9W8Q.jpeg"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">if only composing functions was this easy</figcaption></figure><p id="c195" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我已经尝试过很多次函数式编程了。如果我说我完全理解它，那我是在撒谎，但至少我认为我现在已经足够理解，可以用一种有意义的方式去思考它了。</p><p id="d311" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">试图“得到”FP的麻烦在于实际上并没有一个想法；实际上有两个大的想法需要你去思考，最好不要把它们不必要的混淆起来。第一个是关于函数，第二个是关于类型。在这篇文章中，我想向你展示这两个想法，并希望说明为什么它们在孤立中是重要的，然后如何将它们结合在一起。</p><p id="b331" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将使用javascript来说明这些例子，因为它恰好可以很好地按照我们需要的方式使用函数。然而，不要被推迟，它们是概念，并不局限于一种语言。如果你讨厌javascript，那么让我向你保证，我不会使用它的任何疯狂的部分，你也可以将这些概念应用到其他地方。</p><h1 id="e7f5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">功能:通用积木</h1><p id="105e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在FP中，函数的概念有几个方面是<em class="ka">微小的</em>差别，但是这些差别有一些真正大的含义，正如我们将会看到的。取一个像<strong class="je hv">n，</strong>这样的函数，它给出了数组中的第n个元素:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="9c76" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你有两个参数，<strong class="je hv"> n </strong>和<strong class="je hv"> arr </strong>，当被调用时，它们将返回指定索引处的元素，但是在函数式编程中，我们需要稍微改变一下，以获得第一个重要的见解:一个函数应该只接受<em class="ka">一个参数</em>。这是一种单投入单产出的交易。</p><p id="a512" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">等等，这怎么可能呢？加法至少需要两个数。答案是，如果你需要不止一个参数，你只需返回另一个函数等待下一个参数。当你得到了你需要的一切，你返回结果。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="b094" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几乎是一样的，但是我们在一点一点地提供论点。<strong class="je hv">第n(3)</strong>现在本身就是一个函数，等待数组部分被指定。这个概念有一个完全没有语义的名字“currying”。</p><p id="4492" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于包括我在内的大多数人来说，你使用新的<strong class="je hv">n</strong>函数的方式感觉很奇怪，因为你必须有一系列带括号的表达式，看起来与实际的函数调用有点脱节。这就是为什么大多数像<a class="ae lk" href="http://ramdajs.com" rel="noopener ugc nofollow" target="_blank"> ramda </a>或<a class="ae lk" href="http://lodash.com" rel="noopener ugc nofollow" target="_blank"> lodash </a>这样的函数库都提供了一个名为<strong class="je hv"> curry </strong>的函数，它可以将普通函数转换成两个世界中最好的函数，在这里你可以普通地调用它，也可以一部分一部分地调用它。例如:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="e7f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以把<strong class="je hv">叫做第n(3)(power)</strong>和<strong class="je hv">叫做第n(3，power)</strong>，效果是一样的。我添加的第三个功能<strong class="je hv">可以让你很好地理解为什么这个概念实际上有意义:第n个</strong>是curried，这意味着我们可以用它构建一个更具体的版本，只需要让我们随着时间的推移把论点分开。这种建立参数的方法被称为<em class="ka">部分应用</em>，而以这种方式产生的函数被称为<em class="ka">部分应用</em>。所以无论我们给<strong class="je hv">第三个</strong>什么样的数组，我们总是会得到元素3。</p><blockquote class="ll lm ln"><p id="8eb7" class="jc jd ka je b jf jg jh ji jj jk jl jm lo jo jp jq lp js jt ju lq jw jx jy jz hn dt translated">这个小金块可以单独用于您的日常编程，以提高代码重用。通常，你只需要想一想最好的方法来安排这些论证，让它尽可能的一般化。规则通常是<strong class="je hv"> <em class="hu">把数据作为最后一个参数</em> </strong>。这就是你要处理的数组，你要操作的字符串，对象，数字，数组，等等。</p></blockquote><p id="be7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再用一个小工具，我们就能真正把不起眼的功能变成编程的通用构建块。该工具称为<strong class="je hv"> compose </strong>。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="858b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能开始看起来很复杂，但和我在一起，我们会分解它。<strong class="je hv"> compose </strong>取2个函数<strong class="je hv"> f </strong>和<strong class="je hv"> g，</strong>和一个变量<strong class="je hv">x</strong>它<strong class="je hv"> </strong>然后运行<strong class="je hv">g(x)</strong>，其结果直接被<strong class="je hv"> f()消耗。</strong>将<strong class="je hv">第三路1 </strong>的混凝土<strong class="je hv"> x </strong>进入<strong class="je hv">第n(2)</strong>生产<em class="ka"> 4 </em>，再由<strong class="je hv">add(1)</strong>生产<em class="ka"> 5 </em>消耗。</p><p id="19fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">缀</strong>犹如一条组装线。如果你放了什么东西进去，它就会被我们的某个功能拾取，经过变换，然后被传递给下一个功能，再次进行变换。我第一次思考这个问题时被一件事给误导了，那就是从右到左的<strong class="je hv"><em class="ka"/></strong>天性使然；因此<strong class="je hv">composite</strong>中的第一个参数实际上是最后一个运行的操作。如果你看看实现，这是有意义的，但它肯定是一个棘手的问题。</p><p id="46e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然这是相当随意的，你也可以把它翻转过来。在函数式编程中，这个函数被称为<strong class="je hv">管道</strong>，它实际上和指定从左到右的转换一样简单。事实上，一些语言实际上有一个用于这种事情的第一类操作符(<a class="ae lk" href="https://alvinalexander.com/blog/post/linux-unix/linux-unix-command-mashups" rel="noopener ugc nofollow" target="_blank"> unix </a>，<a class="ae lk" href="https://www.datacamp.com/community/tutorials/pipe-r-tutorial" rel="noopener ugc nofollow" target="_blank"> R </a>，<a class="ae lk" href="https://github.com/jarsen/Pipes" rel="noopener ugc nofollow" target="_blank"> Swift </a>，<a class="ae lk" href="http://theburningmonk.com/2011/09/fsharp-pipe-forward-and-pipe-backward/" rel="noopener ugc nofollow" target="_blank"> F# </a>，<a class="ae lk" href="http://pfultz2.com/blog/2014/09/05/pipable-functions/" rel="noopener ugc nofollow" target="_blank">c++重载</a>，<a class="ae lk" href="https://github.com/tc39/proposal-pipeline-operator" rel="noopener ugc nofollow" target="_blank">JavaScript提案</a>)。</p><p id="e779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无论哪种方式，像curry一样，许多<a class="ae lk" href="http://ramda.com" rel="noopener ugc nofollow" target="_blank">函数库</a>实现了<strong class="je hv"> compose </strong>和<strong class="je hv"> pipe </strong>，通常以一种让你指定任意数量的函数的方式，所以我们从现在开始就使用它们。让我们再看一个更接近现实生活的例子。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">These are real colour names. I didn’t make these up</figcaption></figure><p id="8ea4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经定义了几个更有用的通用函数，它们与<strong class="je hv"> compose配合得很好。</strong>大多数实际上只是将方法转换成普通的函数(<strong class="je hv"> map，join </strong>)，或者采用某种语法，比如读取对象属性并将其转换成函数(<strong class="je hv"> property </strong>)。</p><p id="062f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们新编写的<strong class="je hv"> namedColorToHex </strong>函数隐式地接收一个“x”值，这是我们的颜色名称。这被输入到<strong class="je hv">属性</strong>中，给出了“蓝色泻湖”数组。该数组被提供给<strong class="je hv"> map </strong>，该函数采用一个变换函数和一个数组，并将变换应用于数组中的每个元素。<strong class="je hv">映射</strong>这里部分应用了<strong class="je hv"> toHex </strong>函数，所以输出的是每个数的十六进制表示的数组。<strong class="je hv"> join </strong>把我们的新数组变成一个字符串，最后<strong class="je hv">前缀</strong>在前面弹出一个“#”把它变成一个合适的十六进制颜色。</p><p id="2918" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像伟大的巴赫和莫特扎特一样，他们用同样的88个钢琴键编织出精湛的作品，我们用<strong class="je hv">作曲</strong>和一堆<em class="ka">通用函数</em>来编写一个程序，不过是把不同的乐高积木粘在一起。没有循环，没有特殊语法，没有中间变量。只是描述如何转换数据。如果到目前为止你已经跟上了一切，那么恭喜你！现在，您已经理解了函数式编程的两大理念中的第一个。</p><p id="2d78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗯，差不多了。我前面提到过，FP中的函数有几种不同的方式。另一个主要的方法是你的函数应该是“纯”的。这意味着:</p><ul class=""><li id="3140" class="lr ls hu je b jf jg jj jk jn lt jr lu jv lv jz lw lx ly lz dt translated">你不用任何没有给你的参数来计算(没有全局状态)</li><li id="b81a" class="lr ls hu je b jf ma jj mb jn mc jr md jv me jz lw lx ly lz dt translated">你不会修改任何给你的东西，你总是只是归还一个新的副本(没有突变)</li></ul><p id="b332" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">思考这个问题的一个好方法是:<em class="ka">如果我把这个输入给一个函数，我会得到相同的输出吗？如果答案是否定的，那么它可能不是一个纯粹的函数。</em></p><p id="7945" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，这对于错误意味着什么？API调用？随机数生成？这是下一个伟大的想法。</p><h1 id="22b2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">(代数)类型</h1><p id="c82b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你来自面向对象编程，那么你可能知道接口是什么；基本上是一种应该在对象上实现什么的蓝图。这个概念在函数式编程中也很重要，但是方式稍有不同。</p><p id="2af8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数组对象上有一个函数叫做<strong class="je hv"> map </strong>，如上所述，它对每个元素运行一个函数并返回一个新数组。数组是值的一种<em class="ka">容器</em>，而<strong class="je hv">映射</strong>函数让我们不用从数组中取出这些值就可以得到它们。但是，如果您可以将<strong class="je hv">映射到其他类型，比如object，会怎么样呢？那意味着什么？</strong></p><p id="1c83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在对象中的每个关键元素上运行一个函数，改变值但保留结构。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">For when you want to shout your favourite fruit at someone</figcaption></figure><p id="78e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很合理；现在我们可以映射一个对象。现在，这是完全违反规则的，但是如果你继续将<strong class="je hv"> map </strong>添加到对象原型中，那么我们就有了一个数组和对象之间的公共接口！</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">The first rule of fight club is never modify the prototype of an object you don’t own</figcaption></figure><p id="b5cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有了一个新的、更通用的概念，即<em class="ka">可映射</em>——它对<strong class="je hv">映射</strong>有了一个合理的定义。函数式编程(<a class="ae lk" href="https://en.wikipedia.org/wiki/Functor" rel="noopener ugc nofollow" target="_blank">和数学</a>)将这种可映射的想法称为<em class="ka">函子。函子只是值的容器，你在容器上工作而不是直接在值上工作。</em></p><p id="e9f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望你的脑子里充满了其他可能的函子。答案是很多事情——只要处理得当，每个函子都可以有自己有趣的小领域。</p><p id="f25d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们花点时间想象一个容器，在这个容器中，<em class="ka">中的内容可能是一个正常值，但也可能是null/undefined/垃圾值。我们可能希望从这个特殊的容器中得到的是，如果它存在，那么<strong class="je hv">映射</strong>值，但是如果它不存在，那么不要导致错误。当然，我们应该能够打开容器，得到有意义的东西——正常值，或者“什么都没有”——并做出相应的响应。</em></p><p id="40a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将构建这个仿函数——通常称为<strong class="je hv">或者</strong>——但是为了避免暴露一些棘手的javascript细节，我将使用一个名为<a class="ae lk" href="https://github.com/fantasyland/daggy" rel="noopener ugc nofollow" target="_blank"> daggy </a>的库。从github页面:</p><blockquote class="mf"><p id="e56e" class="mg mh hu bd mi mj mk ml mm mn mo jz ek translated">用于创建标记构造函数的库，也称为“联合类型”或“求和类型”</p></blockquote><p id="f5a8" class="pw-post-body-paragraph jc jd hu je b jf mp jh ji jj mq jl jm jn mr jp jq jr ms jt ju jv mt jx jy jz hn dt translated">不要担心那到底是什么意思，让我们边做边学。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="9b72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们要让这个坏男孩崩溃。首先，我们使用daggy为一个<strong class="je hv">或者</strong>构造一个“sum”构造函数——这是封装可能的空值的东西。我们将其命名为Maybe，它可以是一个具有“x”值的“<strong class="je hv"> Just </strong>，也可以是一个没有值的“<strong class="je hv"> Nothing </strong>”。</p><p id="4bd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们为我们的<strong class="je hv"> Maybe </strong>实现一个<strong class="je hv"> map </strong>函数，其中我们使用一个名为<strong class="je hv"> cata </strong>的daggy函数(如<a class="ae lk" href="https://en.wikipedia.org/wiki/Catamorphism" rel="noopener ugc nofollow" target="_blank"> catamorphism </a>中所示)对类型进行某种切换/case。如果是<strong class="je hv">只是</strong>类型，我们运行我们提供给<strong class="je hv">的函数映射</strong>上的“x”值，并把它放回一个新的<strong class="je hv">中。就</strong>。如果它是一个什么都没有的东西，那么我们可能只需要返回另一个。没事。</p><p id="70cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们制作一个<em class="ka">有效的东西</em>和一个<em class="ka">无效的东西</em>，并在它们上面运行相同的<strong class="je hv">映射</strong>。我们看到<strong class="je hv">映射</strong>在两者上运行都没有错误，正如我们所料，我们可能在<em class="ka"> validThing </em>和<strong class="je hv">上看到一个转换后的值。无效的那个上什么都没有。</strong></p><p id="6751" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我们现在有两个问题。首先，这不是一个真实的例子——谁实际上没有创造任何价值？第二:即使它是现实的，我们的价值仍然被困在<strong class="je hv">或者</strong>里面！我们需要一种方法把它表现出来，所以让我们重温一下之前的合成颜色的例子，看看我们是否能让它更加防错。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="9eef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">分解一下，第一个变化是我们有了一个<strong class="je hv"> extractMaybe </strong>函数。它为<strong class="je hv">没有</strong>的情况取一个函数，为<strong class="je hv">只有</strong>的情况取一个函数，而<strong class="je hv">可能是</strong>对象。因此，当它运行时，它将查看<strong class="je hv"> M </strong>是否只是的一个<strong class="je hv">，如果是的话，它将返回提取的值，并对其进行<strong class="je hv">成功Fn </strong>运行。如果不是，那么它将返回<strong class="je hv"> nothingFn </strong>的结果。</strong></p><p id="9267" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们有了另一个新的函数叫做<strong class="je hv"> safeProperty </strong>。这将检查对象是否真的有我们试图获取的属性，如果有，则返回值的<strong class="je hv">和</strong>，如果没有，则返回<strong class="je hv"> Nothing </strong>。</p><p id="8ce1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们定义了一个总是返回其参数的函数(我们很快就会知道为什么)，以及一个名为<strong class="je hv"> defaultColor </strong>的新变量。</p><p id="4550" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们修改了<strong class="je hv"> namedColorToHex </strong>函数，使用<strong class="je hv"> safeProperty </strong>代替<strong class="je hv"> property </strong>(记住compose goes<em class="ka">right-to-left</em>，或者在本例中，<em class="ka"> down-to-up </em> ) <strong class="je hv">，</strong>，这意味着我们从另一端得到了<strong class="je hv">可能是</strong>。正因为如此，我们需要使用<strong class="je hv">映射</strong>函数定义在<strong class="je hv">也许</strong>上来改变这个值，记住，如果这个值是<strong class="je hv"> Nothing </strong>什么都不会发生！所以我们将所有其他转换包装在一个映射中，最后我们可以调用<strong class="je hv"> extractMaybe </strong>来提取值。Nothing情况返回一个函数，它给我们提供了<strong class="je hv"> defaultColor </strong>，而<strong class="je hv"> Just </strong>情况给我们提供了通过<strong class="je hv"> identity </strong>函数运行的值，这就是……嗯，就是这个值！</p><p id="c588" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我第一次碰到这种代码时的反应是一种惊愕；我非常习惯于使用这些try/catch块、空检查和非线性代码来处理错误，这些代码会将所有东西都分成if/else块。现在有一个函数包装了错误处理，甚至更好的方式是让我们以线性方式推理代码。条件的处理只是转换链中的又一步！</p><h2 id="d3b6" class="mu kc hu bd kd mv mw mx kh my mz na kl jn nb nc kp jr nd ne kt jv nf ng kx nh dt translated">集装箱中的集装箱</h2><p id="f799" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">想象一下，如果你必须深入一个物体。如果你每次都使用safeProperty，你将会以<strong class="je hv">可能</strong>在<strong class="je hv">可能</strong>中结束。示例:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="575e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能会失去控制；不知不觉就在跑<em class="ka"> map(map(map(xyz)))，</em>这是不可持续的。我们需要一种方法把那些<strong class="je hv">的可能</strong>变成一个单一的<strong class="je hv">的可能。</strong>幸运的是，FP远远领先于我们。</p><blockquote class="ll lm ln"><p id="c61c" class="jc jd ka je b jf jg jh ji jj jk jl jm lo jo jp jq lp js jt ju lq jw jx jy jz hn dt translated">旁注:翻转函数参数的想法很常见。如果你在家玩，为什么不试着写一个名为<strong class="je hv"> flip </strong>的函数，它接受一个带两个参数的函数，并返回该函数的翻转版本。</p></blockquote><p id="2695" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在函数式编程中，这种思想叫了几个名字，有时叫flatMap，有时叫chain，但我认为最清楚的是<strong class="je hv"> flatMap </strong>。基本上就是说，在返回另一个容器的容器中运行一个函数，然后将这两个容器合并成一个。那种两个想法对——先<strong class="je hv">贴图</strong>，再<strong class="je hv">展平</strong>。以一个数组为例，<strong class="je hv"> flatten </strong>只会说如果我有一个数字数组，那么就把它变成一个数字数组。让我们实现<strong class="je hv"> flatMap </strong> for Maybe。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="2e8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非常简单，虽然我应该说这不是你可能称之为坚如磐石的实现！所以现在如果我们知道我们正在运行一个返回<strong class="je hv">也许是</strong>的函数，那么我们只需<strong class="je hv">平面映射</strong>而不是<strong class="je hv">映射</strong>，瞧！不再有集装箱中的集装箱。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="e163" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在某种程度上，我们通过为<strong class="je hv">或许是</strong>类型配备一些像<strong class="je hv"> map </strong>和<strong class="je hv"> flatMap </strong>这样的接口，让它成为一个更强大的工具。这种类型我们称之为<a class="ae lk" href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="noopener ugc nofollow" target="_blank">代数数据类型</a>。当你遵循一定的规律时，这种类型有一些非常有趣的性质。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="b6a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以为一个类型配备很多接口。这不是没有原因的代数——你可以写方程，关于这些不同的接口如何根据彼此来写。例如，我们将<strong class="je hv"> flatMap </strong>写成<strong class="je hv"> map </strong>，然后<strong class="je hv">展平</strong>(有时也称为<strong class="je hv"> join </strong>)。但是你实际上可以先写flatten函数，从<strong class="je hv"> flatten </strong>和<strong class="je hv"> map </strong>构造<strong class="je hv"> flatMap </strong>。如果你写<strong class="je hv"> lte </strong>(小于或等于)，你可以自动导出每隔一个的比较函数。</p><h1 id="7a60" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="5d13" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">所以我们已经看到了我认为的函数式编程的两大思想——函数组合和类型。最重要的是，我们已经看到了如何将它们结合在一起。如果你一直跟进到现在，你已经有足够的理解走出去学习所有这些晦涩难懂的术语，更深入地了解代数数据类型的规律和关系，以及如何在函数组合方面编写一个完整的程序。</p><p id="126d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你有兴趣了解更多，我认为布莱恩·朗斯多夫的《函数式编程基本指南》 是一本很棒的书。它在更深但仍可理解的层次上介绍了本文中的所有内容。他在网上也有很多精彩的演讲，可以帮助你掌握FP的一些更具体的方面。</p><p id="4b47" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使用这种方法制作完整的javascript应用程序，我在<a class="ae lk" href="http://wearereasonablepeople.nl/" rel="noopener ugc nofollow" target="_blank">wearereasonablepeople</a><a class="ae lk" href="https://github.com/Avaq/" rel="noopener ugc nofollow" target="_blank">Aldwin Vlasblom</a>的同事编写了一个名为<a class="ae lk" href="https://github.com/fluture-js/Fluture" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Fluture </strong> </a>的惊人的库，它让你能够以函数式风格处理异步，并提供了一种替代承诺和可观察性的方式，用它编程感觉很棒。</p></div></div>    
</body>
</html>