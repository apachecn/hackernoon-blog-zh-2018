<html>
<head>
<title>Serverless WebSockets with AWS Lambda &amp; Fanout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带AWS Lambda和扇出的无服务器WebSockets</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-websockets-with-aws-lambda-fanout-15384bd30354?source=collection_archive---------0-----------------------#2018-01-20">https://medium.com/hackernoon/serverless-websockets-with-aws-lambda-fanout-15384bd30354?source=collection_archive---------0-----------------------#2018-01-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="17ba" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">向无服务器后端添加实时数据推送的基础</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/9e07fc7a421974bbe6088490729923d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ev24RDk6QZ5pvV5ow9H8sg.gif"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek"><a class="ae jv" href="http://www.jvsystems.co.nz/?lightbox=dataItem-imvyifat" rel="noopener ugc nofollow" target="_blank">JVSystems</a></figcaption></figure><h1 id="dd1e" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">无服务器</h1><p id="38a1" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated"><strong class="kq hv">无服务器</strong>是开发人员世界中最常见的误称之一。与其名字相反，无服务器计算实际上使用服务器，但好处是你可以少担心<strong class="kq hv"><em class="lk"/></strong>的维护、规模和配置。这是因为无服务器是一种云计算执行模型，其中云提供商动态管理机器和计算资源的分配。您基本上是将代码部署到一个没有可见进程、操作系统、服务器或虚拟机的环境中。从定价的角度来看，通常会根据实际消耗的资源量向您收费，而不是根据预先购买的容量。</p><p id="f48a" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated"><strong class="kq hv">优点</strong></p><ul class=""><li id="c1e2" class="lq lr hu kq b kr ll ku lm kx ls lb lt lf lu lj lv lw lx ly dt translated">降低架构复杂性</li><li id="5011" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">简化的打包和部署</li><li id="a21f" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">降低规模成本</li><li id="fcc1" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">消除对系统管理员的需求</li><li id="2a69" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">适用于微服务架构</li><li id="00f2" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">降低运营成本</li><li id="1837" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">通常通过更快的发布缩短上市时间</li></ul><p id="0e01" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated"><strong class="kq hv">缺点</strong></p><ul class=""><li id="af58" class="lq lr hu kq b kr ll ku lm kx ls lb lt lf lu lj lv lw lx ly dt translated">性能问题—由于通勤资源的分配方式，延迟通常会更高</li><li id="3457" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">供应商锁定(难以转移到新的供应商)</li><li id="4ce0" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">对于长期运行的应用程序效率不高</li><li id="2eeb" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">多租户问题，服务提供商可能在同一台服务器上为几个不同的客户运行软件</li><li id="3c4b" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">难以在本地测试功能</li><li id="06fe" class="lq lr hu kq b kr lz ku ma kx mb lb mc lf md lj lv lw lx ly dt translated">不同的FaaS实现提供了不同的登录函数的方法</li></ul><h1 id="1d8e" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">自动气象站λ</h1><p id="6955" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">亚马逊采用AWS Lambda的形式来应对无服务器。AWS Lambda让您无需供应或管理服务器即可运行代码，而您只需为实际使用付费。使用Lambda，您可以为几乎任何类型的应用程序或后端服务运行代码——Lambda会自动运行和扩展您的应用程序代码。此外，您可以将代码设置为从其他AWS服务自动触发，或者直接从任何web或移动应用程序调用它。</p><h1 id="8d9c" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">Websockets</h1><p id="df06" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">WebSocket为客户机和服务器之间的消息交换提供了一个长期的连接。对于全双工通信，消息可以向任一方向流动。客户端使用WebSocket客户端库创建到服务器的WebSocket连接。WebSocket库通常在每种语言中都可用，当然浏览器使用WebSocket JavaScript对象来支持它。连接协商使用类似HTTP的交换，成功的协商用状态代码101表示。发送协商响应后，连接保持打开，用于交换二进制或unicode字符串格式的消息帧。对等体也可以交换关闭帧来执行干净关闭。</p><h1 id="c3d4" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">构建AWS物联网Websockets</h1><p id="398a" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">功能即服务后端，如<a class="ae jv" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>，并不是为自己处理长期连接而设计的。这是因为函数调用是短暂的。Lambda旨在与<a class="ae jv" href="https://aws.amazon.com/iot/" rel="noopener ugc nofollow" target="_blank"> AWS IoT </a>等服务集成，以处理这些类型的连接。AWS物联网核心支持MQTT(本机或通过WebSockets)，这是一种轻量级通信协议，专门设计用于容忍间歇性连接。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff me"><img src="../Images/c0c6a5b0da106da8a70409ead1ee16f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7E34GI5o4JqrMqbXkmL3Gw.png"/></div></div><figcaption class="jr js fg fe ff jt ju bd b be z ek"><a class="ae jv" href="https://aws.amazon.com/iot-core/" rel="noopener ugc nofollow" target="_blank">AWS IoT Core Site</a></figcaption></figure><p id="e3c8" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">然而，这种方法本身并不能让您访问原始的协议元素——也不能让您构建一个纯Lambda驱动的API(如果这是您想要的用例的话)。如果您想要这种访问，那么您需要采取不同的方法。</p><h1 id="bde8" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">用扇出构建Lambda驱动的WebSockets</h1><p id="2ebf" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">你也可以通过集成像<a class="ae jv" href="https://fanout.io/" rel="noopener ugc nofollow" target="_blank"> Fanout </a>这样的服务来构建定制的基于Lambda的WebSockets，这是一种介于消息代理和反向代理之间的服务，能够为应用和API提供实时数据推送。有了这些服务，我们可以构建一个支持普通WebSockets的Lambda驱动的API。</p><p id="6bb6" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">这种方法使用了通用实时中介协议<a class="ae jv" href="https://docs.fanout.io/docs/grip" rel="noopener ugc nofollow" target="_blank"> GRIP </a>，使得web服务能够将实时推送行为委托给代理组件。</p><p id="f938" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">这个FaaS GRIP库使得将长期连接管理委托给Fanout变得很容易，这样后端功能只需要在有连接活动时被调用。另一个好处是后端功能不必在每次连接期间都运行。</p><p id="64bc" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">以下逐步分解旨在作为快速配置参考。您可以检查Github库的<a class="ae jv" href="https://github.com/fanout/node-faas-grip" rel="noopener ugc nofollow" target="_blank">节点</a>和<a class="ae jv" href="https://github.com/fanout/python-faas-grip" rel="noopener ugc nofollow" target="_blank"> Python </a>集成。</p><h2 id="04bd" class="mj jx hu bd jy mk ml mm kc mn mo mp kg kx mq mr ki lb ms mt kk lf mu mv km mw dt translated">1.初始配置</h2><p id="76af" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">您将首先配置您的<a class="ae jv" href="http://docs.fanout.io" rel="noopener ugc nofollow" target="_blank">扇出云</a>域/环境，并在<a class="ae jv" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>中设置一个API和资源，以使用Lambda代理集成指向您的Lambda函数。</p><h2 id="a165" class="mj jx hu bd jy mk ml mm kc mn mo mp kg kx mq mr ki lb ms mt kk lf mu mv km mw dt translated">2.使用Websockets</h2><p id="6af3" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">每当一个HTTP请求或WebSocket连接到您的Fanout云域时，您的Lambda函数将能够控制它。为此，Fanout将传入的WebSocket连接活动转换成一系列对后端的HTTP请求。</p><h2 id="5e7b" class="mj jx hu bd jy mk ml mm kc mn mo mp kg kx mq mr ki lb ms mt kk lf mu mv km mw dt translated">3.你有实时</h2><p id="476a" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">你现在有了一个由Lambda函数驱动的实时WebSockets！</p><h1 id="04a1" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">一个例子</h1><p id="df33" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">这个Node.js代码实现了一个WebSocket echo服务。我建议查看完整的<a class="ae jv" href="https://github.com/fanout/node-faas-grip" rel="noopener ugc nofollow" target="_blank"> FaaS GRIP库</a>以获得一步一步的分解，以及关于实现<a class="ae jv" href="https://github.com/fanout/node-faas-grip#http-long-polling" rel="noopener ugc nofollow" target="_blank"> HTTP长轮询</a>和<a class="ae jv" href="https://github.com/fanout/node-faas-grip#http-streaming" rel="noopener ugc nofollow" target="_blank"> HTTP流</a>的说明。</p><pre class="jk jl jm jn fq mx my mz na aw nb dt"><span id="fe53" class="mj jx hu my b fv nc nd l ne nf"><strong class="my hv">var</strong> grip <strong class="my hv">=</strong> require('grip');<br/><strong class="my hv">var</strong> faas_grip <strong class="my hv">=</strong> require('faas-grip');<br/><br/>exports.handler <strong class="my hv">=</strong> <strong class="my hv">function</strong> (event, context, callback) {<br/>    <strong class="my hv">var</strong> ws;<br/>    <strong class="my hv">try</strong> {<br/>        ws <strong class="my hv">=</strong> faas_grip.lambdaGetWebSocket(event);<br/>    } <strong class="my hv">catch</strong> (err) {<br/>        callback(<strong class="my hv">null</strong>, {<br/>            statusCode: 400,<br/>            headers: {'Content-Type': 'text/plain'},<br/>            body: 'Not a WebSocket-over-HTTP request\n'<br/>        });<br/>        <strong class="my hv">return</strong>;<br/>    }<br/><br/>    <em class="lk">// if this is a new connection, accept it</em><br/>    <strong class="my hv">if</strong> (ws.isOpening()) {<br/>        ws.accept();<br/>    }<br/><br/>    <em class="lk">// here we loop over any messages</em><br/>    <strong class="my hv">while</strong> (ws.canRecv()) {<br/>        <strong class="my hv">var</strong> message <strong class="my hv">=</strong> ws.recv();<br/><br/>        <em class="lk">// if return value is null, then the connection is closed</em><br/>        <strong class="my hv">if</strong> (message <strong class="my hv">==</strong> <strong class="my hv">null</strong>) {<br/>            ws.close();<br/>            <strong class="my hv">break</strong>;<br/>        }<br/><br/>        <em class="lk">// echo the message</em><br/>        ws.send(message);<br/>    }<br/><br/>    callback(<strong class="my hv">null</strong>, ws.toResponse());<br/>};</span></pre><p id="c725" class="pw-post-body-paragraph ko kp hu kq b kr ll iv kt ku lm iy kw kx ln kz la lb lo ld le lf lp lh li lj hn dt translated">总体而言，如果您不希望完全控制原始协议元素，那么您可能会发现尝试Lambda/AWS物联网配置会更容易。如果您需要更多的WebSocket可见性和控制，那么Lambda+Fanout集成可能是您的最佳选择。</p></div></div>    
</body>
</html>