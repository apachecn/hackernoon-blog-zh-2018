<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/hackernoon/breaking-the-rules-with-metaprogramming-5e3384141a8d?source=collection_archive---------1-----------------------#2018-01-20">https://medium.com/hackernoon/breaking-the-rules-with-metaprogramming-5e3384141a8d?source=collection_archive---------1-----------------------#2018-01-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/d1c7519a372b3ac327e5b2d76d8df1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VQVzZYMMMnaNz-OutD6Ew.jpeg"/></div></div></figure></div><div class="ab cl id ie hc if" role="separator"><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii"/></div><div class="hn ho hp hq hr"><h1 id="3ba7" class="ik il im bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji dt translated">打破理智编程的规则</h1><p id="59b5" class="pw-post-body-paragraph jj jk im jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">不久前，我和我的一个同事进行了一次半理性的讨论，讨论元编程的用途以及如果被滥用的可怕危险。他谈到了一个Python类，在他曾经工作过的一个曾经流行的社交网站的生产中使用，这个类是以这样一种方式编写的，它将根据初始化的次数返回两个非常不同的值。这意味着任何小的重构都有可能破坏软件的关键部分，几乎没有调试的迹象。</p><p id="287e" class="pw-post-body-paragraph jj jk im jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg hn dt translated">这个故事启发了我<strong class="jl kh">去探索在一篇文章中我们可以打破多少惯例和规则</strong>，这正是我们在JavaScript的一点帮助下要做的事情，<a class="ae kn" href="https://charlieharvey.org.uk/page/javascript_the_weird_parts" rel="noopener ugc nofollow" target="_blank">当今所有元和不合逻辑的优秀编程之王</a>但是当然元编程和元类本身并不是“bug ”,并且在许多语言中都可以很容易地使用，但是我们在这里的目标是做完全相反的事情，所以不要指望这篇文章是对元编程的很好的介绍。</p></div><div class="ab cl id ie hc if" role="separator"><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii"/></div><div class="hn ho hp hq hr"><h2 id="f914" class="ko il im bd in kp kq kr ir ks kt ku iv ju kv kw iz jy kx ky jd kc kz la jh lb dt translated">打破确定性</h2><p id="7480" class="pw-post-body-paragraph jj jk im jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">让我们从字符串连接开始我们的错误之旅。如果我们假设下面的伪陈述成立:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="1625" class="ko il im lh b fv ll lm l ln lo">x == "hello"</span></pre><p id="a69d" class="pw-post-body-paragraph jj jk im jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg hn dt translated">您可能期望下面的结果会是<code class="eh lp lq lr lh b">hellohello</code></p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="b153" class="ko il im lh b fv ll lm l ln lo">concat(x + x) == "hellohello"</span></pre><p id="5d49" class="pw-post-body-paragraph jj jk im jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg hn dt translated">但是这篇文章是关于打破规则的，所以让我们通过使用<code class="eh lp lq lr lh b">Object#toString</code>来减少这种确定性，并将其分配给一个函数，该函数在每次调用时使用<a class="ae kn" href="https://github.com/chancejs/chancejs" rel="noopener ugc nofollow" target="_blank"> chancejs </a>返回一个随机单词:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="26f1" class="ko il im lh b fv ll lm l ln lo">const x = { toString: () =&gt; chance.word() };</span></pre><p id="e7f6" class="pw-post-body-paragraph jj jk im jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg hn dt translated">现在，下面的陈述在某个时间点可能是正确的:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="4bfc" class="ko il im lh b fv ll lm l ln lo">(x + ' is ' + x) === "suwni is onu"</span></pre><p id="e00d" class="pw-post-body-paragraph jj jk im jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg hn dt translated">尝试运行几次以下命令:</p><figure class="lc ld le lf fq hw"><div class="bz el l di"><div class="ls lt l"/></div></figure><h2 id="6816" class="ko il im bd in kp kq kr ir ks kt ku iv ju kv kw iz jy kx ky jd kc kz la jh lb dt translated">破解基本算法</h2><p id="6749" class="pw-post-body-paragraph jj jk im jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">从自身中扣除一个常数时，合理的预期是结果为零:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d8d5" class="ko il im lh b fv ll lm l ln lo">x - x = 0</span></pre><p id="693f" class="pw-post-body-paragraph jj jk im jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg hn dt translated">但是我们可以打破这个规则，如果:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="39f7" class="ko il im lh b fv ll lm l ln lo">x - x = 0.2353256</span></pre><p id="100c" class="pw-post-body-paragraph jj jk im jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg hn dt translated">紧接着它等于另一个值。在JavaScript中，我们可以滥用<code class="eh lp lq lr lh b">Object#valueOf</code>来按需返回一个原语/数字，这本身就是最近在<a class="ae kn" href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true" rel="noopener ugc nofollow" target="_blank">这个StackOverflow问题</a>中流行的。利用这种方法和<code class="eh lp lq lr lh b">Math#random</code>，我们不仅可以打破一致性，还可以打破期望值:</p><figure class="lc ld le lf fq hw"><div class="bz el l di"><div class="lu lt l"/></div></figure><h2 id="de7e" class="ko il im bd in kp kq kr ir ks kt ku iv ju kv kw iz jy kx ky jd kc kz la jh lb dt translated">记录任务</h2><p id="034a" class="pw-post-body-paragraph jj jk im jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><code class="eh lp lq lr lh b">x.y = 2</code>和<code class="eh lp lq lr lh b">x.y = 14</code>，让我们在setters的帮助下跟踪<code class="eh lp lq lr lh b">x.y</code>。每当修改属性时都会调用Setters:</p><figure class="lc ld le lf fq hw"><div class="bz el l di"><div class="lv lt l"/></div></figure><h2 id="3145" class="ko il im bd in kp kq kr ir ks kt ku iv ju kv kw iz jy kx ky jd kc kz la jh lb dt translated">泛光灯对象</h2><p id="de94" class="pw-post-body-paragraph jj jk im jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们能拥有一个拥有所有属性的对象吗？不完全是，但是我们可以有一个基于函数的延迟加载值的函数。ES6给了我们<a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>,让我们成为超级元！除了getters和setters之外，代理还可以拦截与给定目标/对象的大多数可能的交互。在这种情况下，我们希望拦截对象上的任何gets，注意，如果我们要使用getters，我们需要知道在创建时定义的属性，用代理，不要太多:</p><figure class="lc ld le lf fq hw"><div class="bz el l di"><div class="lw lt l"/></div></figure></div><div class="ab cl id ie hc if" role="separator"><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii"/></div><div class="hn ho hp hq hr"><blockquote class="lx"><p id="0791" class="ly lz im bd ma mb mc md me mf mg kg ek translated">上面的例子显然不是元编程的真实用例，而是滥用了它的某些属性。有许多很好的用例，我肯定会鼓励读者带着一点怀疑的态度接受我们有趣的实验，并自己探索上面提出的想法。</p></blockquote></div><div class="ab cl id ie hc if" role="separator"><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii ij"/><span class="ig bw bk ih ii"/></div><div class="hn ho hp hq hr"><h1 id="16a1" class="ik il im bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji dt translated">设x - x为零</h1><p id="ccdf" class="pw-post-body-paragraph jj jk im jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">使用您最喜欢的编程语言(假定它受支持)进行元编程有许多很好的用例<a class="ae kn" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> expressjs </a>使用getters来延迟解析查询，您可以在创建后使用代理等特性延迟包装属性，但是用我经验丰富的同事的明智的话来说，不要使用元类，并且尽可能避免上面给出的例子，除非您正在开发像您的代码一样疯狂的东西。</p></div></div>    
</body>
</html>