<html>
<head>
<title>Project Euler # 43 in JavaScript — Sub-String Divisiblity in Pandigital Numbers.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的欧拉项目# 43——泛数字中的子字符串除法。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/project-euler-43-in-javascript-1cc41be56aa2?source=collection_archive---------5-----------------------#2018-01-20">https://medium.com/hackernoon/project-euler-43-in-javascript-1cc41be56aa2?source=collection_archive---------5-----------------------#2018-01-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b37a6d34baf7b2f6de41e2d70eaf8205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vuc-eP0ROaxN1QlZZ3BIw.png"/></div></div></figure><div class=""/><p id="8819" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我从projecteuler.net获得了第43名。我将在这里讲述我是如何得出这个解决方案的。公平的警告，但是，我不是一个数学家。我勉强算是个像样的程序员，但绝对不是数学家。当我在做这个问题时，很明显，我的数学能力不足绝对是解决这类问题的绊脚石。因此，出于这个原因，我的大多数解决方案绝对是“蛮力”方法。不管怎样，现在问题来了:</p><p id="5992" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数字1406357289是一个0到9的泛数字，因为它是由0到9的每个数字按一定顺序组成的，但它也有一个相当有趣的子串整除性质。</p><p id="c7d4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">设<em class="ka"> d </em> 1为第一位，<em class="ka"> d </em> 2为第二位，依此类推。这样，我们注意到以下几点:</p><ul class=""><li id="c13b" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><em class="ka">d</em>2<em class="ka">d</em>3<em class="ka">d</em>4 = 406能被2整除</li><li id="6f5e" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><em class="ka">d</em>3<em class="ka">d</em>4<em class="ka">d</em>5 = 063能被3整除</li><li id="dee0" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><em class="ka">d</em>4<em class="ka">d</em>5<em class="ka">d</em>6 = 635能被5整除</li><li id="f4c7" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><em class="ka">d</em>5<em class="ka">d</em>6<em class="ka">d</em>7 = 357能被7整除</li><li id="b39c" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><em class="ka">d</em>6<em class="ka">d</em>7<em class="ka">d</em>8 = 572能被11整除</li><li id="d92b" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><em class="ka">d</em>7<em class="ka">d</em>8<em class="ka">d</em>9 = 728能被13整除</li><li id="7fc1" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><em class="ka">d</em>8<em class="ka">d</em>9<em class="ka">d</em>10 = 289能被17整除</li></ul><p id="369e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">求所有0到9的泛数字的和。</p><p id="bf1a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我是这样想的。不管是好是坏，我认为这是一个问题，不是一个长的10位数，我真正看到的是一系列的3位数。在下面的例子中，第一组[460]需要能被2整除才能满足标准。那么第二组[603]将需要被3整除，以便满足标准，等等。</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b37a6d34baf7b2f6de41e2d70eaf8205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vuc-eP0ROaxN1QlZZ3BIw.png"/></div></div></figure><p id="becd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的想法是，我可以简单地抓取100到999之间的所有数字，并测试每个数字，看它是否能被2、3、5、7等整除。但是后来我意识到我需要修改我的搜索，因为仅仅得到100到999之间的数字并不是我所需要的。我还需要以0开头的数字。</p><p id="cb29" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下面的例子为例:</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kt"><img src="../Images/d892f8c67467204da94e7361dd196599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaDjW5aOjqI72LhURGNIyg.png"/></div></div></figure><p id="389d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我得到了100到999之间的所有数字，比如说，258。没有理由修改这个数字。如果2是a，5是b，8是c，我也不需要bca和cba的组合，因为简单地继续涨到999也会把那两个都抢到。但是，它不会抓取其中的一些:</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ku"><img src="../Images/928ca408523de81ca81cac74608d374f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuShIwQEw6Jnj9yhL7bl_A.png"/></div></div></figure><p id="7c0f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我现在抓取的数字是300，我现在的方法不会得到003或者030。或者，如果我在205，我不会得到052，但我会得到502。然后我意识到泛数字号码不重复任何数字。所以在中间的例子中，我不需要300，003或030，因为它重复了两次0。在下面的例子中，我需要052，但是502已经是我的方法的一部分，所以也不需要修改。在这些例子中，我需要的字母组合只有“abc”和“bca ”,但是如果中间的数字是0，就只有“bca”。下面是我的那部分代码的样子:</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="de55" class="la lb if kw b fv lc ld l le lf">let numbersToTest = [];<br/>for(i = 100; i &lt; 999;  i += 1) {<br/>    let str = i.toString();<br/>    let split = str.split("");<br/>    let a = parseInt(split[0]);<br/>    let b = parseInt(split[1]);<br/>    let c = parseInt(split[2]);<br/>    let combo1 = [a,b,c];<br/>    let combo3 = [0,a,c];<br/>    if(a != b &amp;&amp;<br/>       a != c &amp;&amp;<br/>       b != c){<br/>    numbersToTest.push(combo1);<br/>  }<br/>    if(b == 0 &amp;&amp;<br/>      a !== c &amp;&amp;<br/>      c !== 0){<br/>      numbersToTest.push(combo3);<br/>    }<br/>  }</span></pre><p id="a7e5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我所做的是在数字100到999之间循环。我把它变成一个字符串，分割它，然后把每个数组元素转换回一个数字。然后我有combo1和combo2。如果b为0，我按combo3，如果b不为0，我按combo1。我也不希望a、b或c彼此相等，以避免重复，所以如果它们中的任何一个彼此相等，它们根本不会被推动。最后，我得到了所有3位数字组合，它们只有100到999之间的唯一数字组合。</p><p id="74fe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我意识到在每个组合中我需要测试两种不同的东西。首先，我需要弄清楚它是否能被一个给定的数整除，比如2、3、5、7、11、13或17。</p><p id="c67d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，再看看这张图表:</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b37a6d34baf7b2f6de41e2d70eaf8205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vuc-eP0ROaxN1QlZZ3BIw.png"/></div></div></figure><p id="07b6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我现在有3个一组的，我最终会把它们放在一起，创建一个10位数。然而，在这里的第一组[460]中，该组的第二位和第三位等于下一组的第一位和第二位[603]，以此类推。</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9822b4c2054e99d32e0b287a3573feeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Cx9jWvJU_9H81O5YTaJiA.png"/></div></div></figure><p id="9441" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，当我遍历每组3个数字时，我需要测试它是否能被某个数字整除，还要看看这些数字是否与前一组中的数字匹配。如果它不能被我要找的数字整除，或者这些数字不匹配，我将丢弃它。</p><p id="0e6f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我要做的是，从一个全是“x”的数组开始，然后，当我循环遍历我的数字数组来测试这个组是否能被2整除时，我将这三个数字放入我的“x”数组中，并用数组中的一个数字替换x。在我看来，它应该是这样的:</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lg"><img src="../Images/d3bb63666b4bc8e67153a4b27848dba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JptAMil4KZdbvYdJnApukA.png"/></div></div></figure><p id="fbb3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我应该有一个和以前一样的数组，但是只有x和能被2整除的3位数占据了数组中的第2、第3和第4个空间。我的代码看起来像这样:</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="e7b0" class="la lb if kw b fv lc ld l le lf">let testArr2 = [];<br/>  for (var i = 0; i &lt; numbersToTest.length; i++) {<br/>    let testArr1 = ["x","x","x","x","x","x","x","x","x","x"];<br/>    let numbersJoin = numbersToTest[i].join("");<br/>    let number = parseInt(numbersJoin);<br/>    if (number % 2 == 0) {<br/>      testArr1[1] = numbersToTest[i][0];<br/>      testArr1[2] = numbersToTest[i][1];<br/>      testArr1[3] = numbersToTest[i][2];<br/>      testArr2.push(testArr1);<br/>    }  <br/>  }</span></pre><p id="ceb4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，testArr2保存的数据看起来像上图中带有数字和x的奇怪数组。接下来，我想做同样的事情，但是数字可以被3整除，看起来像这样:</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lg"><img src="../Images/90ec745dfac65e1244d85f26862d0023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BsyZ8PJuPAZ1uAJDF8leqA.png"/></div></div></figure><p id="7d42" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有JavaScript……</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="1a22" class="la lb if kw b fv lc ld l le lf">let testArr3 = [];<br/>  for (var i = 0; i &lt; numbersToTest.length; i++) {<br/>    let testArr1 = ["x","x","x","x","x","x","x","x","x","x"];<br/>    let numbersJoin = numbersToTest[i].join("");<br/>    let number = parseInt(numbersJoin);<br/>    if (number % 3 == 0) {<br/>      testArr1[2] = numbersToTest[i][0];<br/>      testArr1[3] = numbersToTest[i][1];<br/>      testArr1[4] = numbersToTest[i][2];<br/>      testArr3.push(testArr1);<br/>    }  <br/>  }</span></pre><p id="8843" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我完成了所有的组，我将拥有所有这些带有x的数组，以及一组3个数字。然后，我必须再检查一遍，看看哪些组互相匹配。以下是我对能被5、7、11、13和17整除的数字的其他循环:</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="5d84" class="la lb if kw b fv lc ld l le lf">let testArr4 = [];<br/>  for (var i = 0; i &lt; numbersToTest.length; i++) {<br/>    let testArr1 = ["x","x","x","x","x","x","x","x","x","x"];<br/>    let numbersJoin = numbersToTest[i].join("");<br/>    let number = parseInt(numbersJoin);<br/>    if (number % 5 == 0) {<br/>      testArr1[3] = numbersToTest[i][0];<br/>      testArr1[4] = numbersToTest[i][1];<br/>      testArr1[5] = numbersToTest[i][2];<br/>      testArr4.push(testArr1);<br/>    }  <br/>  }<br/>  let testArr5 = [];<br/>  for (var i = 0; i &lt; numbersToTest.length; i++) {<br/>    let testArr1 = ["x","x","x","x","x","x","x","x","x","x"];<br/>    let numbersJoin = numbersToTest[i].join("");<br/>    let number = parseInt(numbersJoin);<br/>    if (number % 7 == 0) {<br/>      testArr1[4] = numbersToTest[i][0];<br/>      testArr1[5] = numbersToTest[i][1];<br/>      testArr1[6] = numbersToTest[i][2];<br/>      testArr5.push(testArr1);<br/>    }  <br/>  }<br/>  let testArr6 = [];<br/>  for (var i = 0; i &lt; numbersToTest.length; i++) {<br/>    let testArr1 = ["x","x","x","x","x","x","x","x","x","x"];<br/>    let numbersJoin = numbersToTest[i].join("");<br/>    let number = parseInt(numbersJoin);<br/>    if (number % 11 == 0) {<br/>      testArr1[5] = numbersToTest[i][0];<br/>      testArr1[6] = numbersToTest[i][1];<br/>      testArr1[7] = numbersToTest[i][2];<br/>      testArr6.push(testArr1);<br/>    }  <br/>  }<br/>  let testArr7 = [];<br/>  for (var i = 0; i &lt; numbersToTest.length; i++) {<br/>    let testArr1 = ["x","x","x","x","x","x","x","x","x","x"];<br/>    let numbersJoin = numbersToTest[i].join("");<br/>    let number = parseInt(numbersJoin);<br/>    if (number % 13 == 0) {<br/>      testArr1[6] = numbersToTest[i][0];<br/>      testArr1[7] = numbersToTest[i][1];<br/>      testArr1[8] = numbersToTest[i][2];<br/>      testArr7.push(testArr1);<br/>    }  <br/>  }<br/>  let testArr8 = [];<br/>  for (var i = 0; i &lt; numbersToTest.length; i++) {<br/>    let testArr1 = ["x","x","x","x","x","x","x","x","x","x"];<br/>    let numbersJoin = numbersToTest[i].join("");<br/>    let number = parseInt(numbersJoin);<br/>    if (number % 17 == 0) {<br/>      testArr1[7] = numbersToTest[i][0];<br/>      testArr1[8] = numbersToTest[i][1];<br/>      testArr1[9] = numbersToTest[i][2];<br/>      testArr8.push(testArr1);<br/>    }  <br/>  }</span></pre><p id="aebf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我想的是我可以像这样循环遍历每个数组:</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lh"><img src="../Images/3c762d89fde0d6d1c7a6e528fdbdba8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwOzj1_WsGUjjue88hisNQ.png"/></div></div></figure><p id="3e90" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将检查数组1的索引2和3，以及数组2的索引2和3是否匹配。如果有匹配，我创建一个新数组，包括数组1的第一个数字和数组2的最后一个数字。然后，我会做同样的事情，比较新的数组和被5整除的数组，就像这样:</p><figure class="kp kq kr ks fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff li"><img src="../Images/44613501436d4f65c01a2d27d2bcb299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZEDZ9JkYOMxto5yTPl49g.png"/></div></div></figure><p id="28f7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每循环一次，我都会在我神奇的数字集合上加一个数字。下面是实际的JavaScript代码，使用嵌套的for循环进行匹配。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="333a" class="la lb if kw b fv lc ld l le lf">let finalArr9 = [];<br/>  for (var i = 0; i &lt; testArr2.length; i++) {<br/>    for (var k = 0; k &lt; testArr3.length; k++) {<br/>      let tempArr = ["x","x","x","x","x","x","x","x","x","x"];<br/>      if(testArr2[i][2] == testArr3[k][2] &amp;&amp;<br/>         testArr2[i][3] == testArr3[k][3]){<br/>           tempArr[1] = testArr2[i][1];<br/>           tempArr[2] = testArr2[i][2];<br/>           tempArr[3] = testArr2[i][3];<br/>           tempArr[4] = testArr3[k][4];<br/>           finalArr9.push(tempArr);<br/>         }<br/>    }<br/>  }<br/>  let finalArr10 = [];<br/>  for (var i = 0; i &lt; finalArr9.length; i++) {<br/>    for (var k = 0; k &lt; testArr4.length; k++) {<br/>      let tempArr = ["x","x","x","x","x","x","x","x","x","x"];<br/>      if(finalArr9[i][3] == testArr4[k][3] &amp;&amp;<br/>         finalArr9[i][4] == testArr4[k][4]){<br/>           tempArr[1] = finalArr9[i][1];<br/>           tempArr[2] = finalArr9[i][2];<br/>           tempArr[3] = finalArr9[i][3];<br/>           tempArr[4] = finalArr9[i][4];<br/>           tempArr[5] = testArr4[k][5];<br/>           finalArr10.push(tempArr);<br/>         }<br/>    }<br/>  }<br/>  let finalArr11 = [];<br/>  for (var i = 0; i &lt; finalArr10.length; i++) {<br/>    for (var k = 0; k &lt; testArr5.length; k++) {<br/>      let tempArr = ["x","x","x","x","x","x","x","x","x","x"];<br/>      if(finalArr10[i][4] == testArr5[k][4] &amp;&amp;<br/>         finalArr10[i][5] == testArr5[k][5]){<br/>           tempArr[1] = finalArr10[i][1];<br/>           tempArr[2] = finalArr10[i][2];<br/>           tempArr[3] = finalArr10[i][3];<br/>           tempArr[4] = finalArr10[i][4];<br/>           tempArr[5] = finalArr10[i][5];<br/>           tempArr[6] = testArr5[k][6];<br/>           finalArr11.push(tempArr);<br/>         }<br/>    }<br/>  }<br/>  let finalArr12 = [];<br/>  for (var i = 0; i &lt; finalArr11.length; i++) {<br/>    for (var k = 0; k &lt; testArr6.length; k++) {<br/>      let tempArr = ["x","x","x","x","x","x","x","x","x","x"];<br/>      if(finalArr11[i][5] == testArr6[k][5] &amp;&amp;<br/>         finalArr11[i][6] == testArr6[k][6]){<br/>           tempArr[1] = finalArr11[i][1];<br/>           tempArr[2] = finalArr11[i][2];<br/>           tempArr[3] = finalArr11[i][3];<br/>           tempArr[4] = finalArr11[i][4];<br/>           tempArr[5] = finalArr11[i][5];<br/>           tempArr[6] = finalArr11[i][6];<br/>           tempArr[7] = testArr6[k][7];<br/>           finalArr12.push(tempArr);<br/>         }<br/>    }<br/>  }<br/>  let finalArr13 = [];<br/>  for (var i = 0; i &lt; finalArr12.length; i++) {<br/>    for (var k = 0; k &lt; testArr7.length; k++) {<br/>      let tempArr = ["x","x","x","x","x","x","x","x","x","x"];<br/>      if(finalArr12[i][6] == testArr7[k][6] &amp;&amp;<br/>         finalArr12[i][7] == testArr7[k][7]){<br/>           tempArr[1] = finalArr12[i][1];<br/>           tempArr[2] = finalArr12[i][2];<br/>           tempArr[3] = finalArr12[i][3];<br/>           tempArr[4] = finalArr12[i][4];<br/>           tempArr[5] = finalArr12[i][5];<br/>           tempArr[6] = finalArr12[i][6];<br/>           tempArr[7] = finalArr12[i][7];<br/>           tempArr[8] = testArr7[k][8];<br/>           finalArr13.push(tempArr);<br/>         }<br/>    }<br/>  }<br/>  let finalArr14 = [];<br/>  for (var i = 0; i &lt; finalArr13.length; i++) {<br/>    for (var k = 0; k &lt; testArr8.length; k++) {<br/>      let tempArr = ["x","x","x","x","x","x","x","x","x","x"];<br/>      if(finalArr13[i][7] == testArr8[k][7] &amp;&amp;<br/>         finalArr13[i][8] == testArr8[k][8]){<br/>           tempArr[1] = finalArr13[i][1];<br/>           tempArr[2] = finalArr13[i][2];<br/>           tempArr[3] = finalArr13[i][3];<br/>           tempArr[4] = finalArr13[i][4];<br/>           tempArr[5] = finalArr13[i][5];<br/>           tempArr[6] = finalArr13[i][6];<br/>           tempArr[7] = finalArr13[i][7];<br/>           tempArr[8] = finalArr13[i][8];<br/>           tempArr[9] = testArr8[k][9];<br/>           finalArr14.push(tempArr);<br/>         }<br/>    }<br/>  }</span></pre><p id="0e7a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一点上，我应该有我的所有数组，完全充满了数字，除了第一个数字，所以我循环通过我的所有新数组，我发现0-9中的哪一个数字丢失了，并将该数字添加到数组的索引1。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="f522" class="la lb if kw b fv lc ld l le lf">let finalArr15 = [];<br/>  for (var i = 0; i &lt; finalArr14.length; i++) {<br/>    let tempArr = ["x","x","x","x","x","x","x","x","x","x"];<br/>    tempArr[1] = finalArr14[i][1];<br/>    tempArr[2] = finalArr14[i][2];<br/>    tempArr[3] = finalArr14[i][3];<br/>    tempArr[4] = finalArr14[i][4];<br/>    tempArr[5] = finalArr14[i][5];<br/>    tempArr[6] = finalArr14[i][6];<br/>    tempArr[7] = finalArr14[i][7];<br/>    tempArr[8] = finalArr14[i][8];<br/>    tempArr[9] = finalArr14[i][9];<br/>    if (finalArr14[i].includes(0)==false){<br/>      tempArr[0] = 0;<br/>    }<br/>    else if (finalArr14[i].includes(1)==false){<br/>      tempArr[0] = 1;<br/>    }<br/>    else if (finalArr14[i].includes(2)==false){<br/>      tempArr[0] = 2;<br/>    }<br/>    else if (finalArr14[i].includes(3)==false){<br/>      tempArr[0] = 3;<br/>    }<br/>    else if (finalArr14[i].includes(4)==false){<br/>      tempArr[0] = 4;<br/>    }<br/>    else if (finalArr14[i].includes(5)==false){<br/>      tempArr[0] = 5;<br/>    }<br/>    else if (finalArr14[i].includes(6)==false){<br/>      tempArr[0] = 6;<br/>    }<br/>    else if (finalArr14[i].includes(7)==false){<br/>      tempArr[0] = 7;<br/>    }<br/>    else if (finalArr14[i].includes(8)==false){<br/>      tempArr[0] = 8;<br/>    }<br/>    else if (finalArr14[i].includes(9)==false){<br/>      tempArr[0] = 9;<br/>    }<br/>    if(tempArr[0] !== 0){<br/>    finalArr15.push(tempArr);<br/>  }<br/>  }</span></pre><p id="2309" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果你这样做，我希望你没有，因为我知道这是垃圾，但无论如何。就像我说的，我绝对不是一个伟大的数学家。但是，不管怎样。如果你像我一样做，你会得到一大堆复制品。所以，我把它们都循环了一遍，如果它们包含一个数字两次，我就不用它了。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="ed0e" class="la lb if kw b fv lc ld l le lf">let finalArr16 = [];<br/>  for (var i = 0; i &lt; finalArr15.length; i++) {<br/>    if(<br/>      finalArr15[i].includes(0) == true &amp;&amp;<br/>      finalArr15[i].includes(1) == true &amp;&amp;<br/>      finalArr15[i].includes(2) == true &amp;&amp;<br/>      finalArr15[i].includes(3) == true &amp;&amp;<br/>      finalArr15[i].includes(4) == true &amp;&amp;<br/>      finalArr15[i].includes(5) == true &amp;&amp;<br/>      finalArr15[i].includes(6) == true &amp;&amp;<br/>      finalArr15[i].includes(7) == true &amp;&amp;<br/>      finalArr15[i].includes(8) == true &amp;&amp;<br/>      finalArr15[i].includes(9) == true <br/>    ){<br/>      finalArr16.push(finalArr15[i]);<br/>    }<br/>    <br/>  }</span></pre><p id="56bb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在所有这些之后，你最终只有六个匹配:</p><ol class=""><li id="8729" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz lj kh ki kj dt">[4, 1, 0, 6, 3, 5, 7, 2, 8, 9]</li><li id="cd1b" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz lj kh ki kj dt">[4, 1, 3, 0, 9, 5, 2, 8, 6, 7]</li><li id="48cc" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz lj kh ki kj dt">[4, 1, 6, 0, 3, 5, 7, 2, 8, 9]</li><li id="db51" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz lj kh ki kj dt">[1, 4, 0, 6, 3, 5, 7, 2, 8, 9]</li><li id="0bfb" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz lj kh ki kj dt">[1, 4, 3, 0, 9, 5, 2, 8, 6, 7]</li><li id="2da3" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz lj kh ki kj dt">[1, 4, 6, 0, 3, 5, 7, 2, 8, 9]</li></ol><p id="d819" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，只需将数组转换回数字，并将它们相加。</p><p id="29eb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我知道这不是最好的解决方案，但是，对于一个非数学家来说，我认为我做得还不错。我要去给自己一点鼓励，喝一杯冰镇沙士，吃半品脱冰淇淋。</p></div></div>    
</body>
</html>