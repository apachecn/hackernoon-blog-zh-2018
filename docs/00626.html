<html>
<head>
<title>Introducing Formplug v1, a form forwarding service for AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Formplug v1，这是一种用于AWS Lambda的表单转发服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-formplug-v1-a-form-forwarding-service-for-aws-lambda-2c125dfe608e?source=collection_archive---------7-----------------------#2018-01-20">https://medium.com/hackernoon/introducing-formplug-v1-a-form-forwarding-service-for-aws-lambda-2c125dfe608e?source=collection_archive---------7-----------------------#2018-01-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/f6259d2a09b688134417f2b6a43c03b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59esfFd4Ha3GOkjXTubQBA.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Using graphics from <a class="ae ih" href="https://experience.sap.com/designservices/approach/scenes" rel="noopener ugc nofollow" target="_blank">SAP Scenes Pack</a></figcaption></figure><div class=""/><p id="9e3c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">据估计，每天大约有2690亿封电子邮件被发送到T2。当你读到前面那句话的时候，已经有超过1000万笔汇款被寄出。即使在2018年，在电子邮件诞生40多年后，它仍然是<a class="ae ih" href="https://hackernoon.com/tagged/internet" rel="noopener ugc nofollow" target="_blank">互联网</a>上最可靠和最通用的沟通方式之一。</p><p id="607f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇博文中，我将提供一个最新发布的Formplug的技术演示，这是一个我一直在开发的开源表单转发服务。通过电子邮件接收表单提交变得非常简单。通常，您会在无法执行服务器端代码的环境中使用Formplug，例如Github页面。</p><h2 id="040e" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><a class="ae ih" href="https://github.com/danielireson/formplug-serverless" rel="noopener ugc nofollow" target="_blank">在GitHub上查看项目</a></h2><h2 id="87fa" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><a class="ae ih" href="https://danielireson.github.io/formplug-serverless/" rel="noopener ugc nofollow" target="_blank">尝试演示</a></h2><figure class="lb lc ld le fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff la"><img src="../Images/207768ea35c3238c57610a550a53426c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YF6GIpZEvQAjRb9GUg3M6w.png"/></div></div></figure><h1 id="6e16" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">它是如何工作的</h1><p id="a392" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">将Formplug服务部署到AWS后，您将获得一个API网关端点URL。这应该设置为您希望通过电子邮件接收的任何表单的表单操作。然后可以使用以下划线为前缀的隐藏表单输入来自定义行为。例如，要设置接收者，您可以使用恰当命名的<code class="eh mb mc md me b">_to</code>输入。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="c447" class="kf kg ik me b fv mj mk l ml mm">&lt;form action="https://apigatewayurl.com" method="post"&gt;<br/>    &lt;input type="hidden" name="_to" value="johndoe@example.com"&gt;<br/>    &lt;input type="text" name="message"&gt;<br/>    &lt;input type="submit" value="send"&gt;<br/>&lt;/form&gt;</span></pre><p id="11e5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在其他功能中，有对加密电子邮件地址，垃圾邮件预防和URL重定向的支持。参见<a class="ae ih" href="https://github.com/danielireson/formplug-serverless" rel="noopener ugc nofollow" target="_blank">自述文件</a>了解全部配置选项。</p><h1 id="5b0f" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">体系结构</h1><p id="52d1" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">AWS环境中的Lambda可以被认为是一个基于预定义事件调用的函数。</p><p id="7c82" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Formplug由两个Lambdas组成:</p><ol class=""><li id="4c61" class="mn mo ik jj b jk jl jo jp js mp jw mq ka mr ke ms mt mu mv dt translated">一个<em class="mw">接收</em> Lambda —用于解析表单提交。</li><li id="2dab" class="mn mo ik jj b jk mx jo my js mz jw na ka nb ke ms mt mu mv dt translated">a<em class="mw">send</em>Lambda——用于创建和发送电子邮件。</li></ol><p id="5696" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<em class="mw"> receive </em> Lambda的情况下，事件是从提交到我们的API网关端点(在第一次部署时生成的公共URL)的表单中生成的。在<em class="mw">发送</em>λ的情况下，事件由来自<em class="mw">接收</em>λ的API调用生成。</p><figure class="lb lc ld le fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nc"><img src="../Images/4bc99bcae23c824dc7ae1c884dac4ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ew1bjIENZVZxYyLubZaZAA.png"/></div></div></figure><h2 id="11b9" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">配置</h2><p id="dab6" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">这两个Lambdas都在<code class="eh mb mc md me b">serverless.yml</code>配置文件中定义，它描述了所需的AWS基础设施。基础设施将在部署时使用<a class="ae ih" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>自动实例化。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="d618" class="kf kg ik me b fv mj mk l ml mm">functions:<br/>  receive:<br/>    handler: src/receive/handler.handle<br/>    events:<br/>      - http:<br/>          path: /<br/>          method: post<br/>          request:<br/>            parameters:<br/>              querystrings:<br/>                format: true<br/>  send:<br/>    handler: src/send/handler.handle</span></pre><p id="7f89" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于每个Lambda，我们将导出的<a class="ae ih" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>函数定义为处理程序。这将在每次Lambda的事件被触发时被调用。处理程序本身只是一个带三个参数的箭头函数，第一个参数是<code class="eh mb mc md me b">event</code>，它在我们的<em class="mw">接收</em>处理程序中保存表单数据本身。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="faed" class="kf kg ik me b fv mj mk l ml mm">module.exports.handle = (event, context, callback) =&gt; {</span><span id="9c50" class="kf kg ik me b fv nd mk l ml mm">}</span></pre><p id="7c23" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每当一个表单被发送到我们的端点时，这个函数就会被调用。为了返回一个响应，我们需要使用提供的<code class="eh mb mc md me b">callback</code>参数。这是一个<a class="ae ih" href="http://fredkschott.com/post/2014/03/understanding-error-first-callbacks-in-node-js/" rel="noopener ugc nofollow" target="_blank">错误优先的回调</a>，所以我们应该将<code class="eh mb mc md me b">null</code>作为成功形成的响应的第一个参数传递。第二个参数应该是包含状态代码和响应正文的对象。回调默认为<code class="eh mb mc md me b">application/json</code>内容类型。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="9e16" class="kf kg ik me b fv mj mk l ml mm">callback(null, {statusCode: 200, body: 'Email sent'})</span></pre><h1 id="3e04" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">验证表单提交</h1><p id="1148" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">在Formplug <em class="mw"> receive </em>处理程序的顶部，创建了一个新的<code class="eh mb mc md me b">request</code>实例，并将<code class="eh mb mc md me b">event</code>传递给构造函数。<code class="eh mb mc md me b">Request</code>类负责验证。在<code class="eh mb mc md me b">Request</code>构造函数中定义的是需要从<code class="eh mb mc md me b">event</code>中提取的所有内容。这主要只是要转发的电子邮件和表单输入的收件人。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="8a90" class="kf kg ik me b fv mj mk l ml mm">class Request {<br/>  constructor (event) {<br/>    this.singleEmailFields = ['_to']<br/>    this.delimeteredEmailFields = ['_cc', '_bcc', '_replyTo']<br/>    this.recipients = {<br/>      to: '',<br/>      cc: [],<br/>      bcc: [],<br/>      replyTo: []<br/>    }</span><span id="9226" class="kf kg ik me b fv nd mk l ml mm">    this.responseFormat = 'html'<br/>    this.redirectUrl = null</span><span id="4989" class="kf kg ik me b fv nd mk l ml mm">    this.pathParameters = event.pathParameters || {}<br/>    this.queryStringParameters = event.queryStringParameters || {}<br/>    this.userParameters = querystring.parse(event.body)<br/>  }<br/>}</span></pre><p id="0599" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们<a class="ae ih" href="http://www.daedtech.com/beware-the-bloated-constructor/" rel="noopener ugc nofollow" target="_blank">在构造函数中不做任何真正的工作</a>。还要注意我们如何使用<a class="ae ih" href="https://nodejs.org/api/querystring.html" rel="noopener ugc nofollow" target="_blank"> Node.js querystring模块</a>来设置<code class="eh mb mc md me b">userParamters</code>。这将包含编码为<code class="eh mb mc md me b">application/x-www-form-urlencoded</code>的表单数据的请求主体转换成一个JavaScript对象。</p><h2 id="5a5a" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">使用承诺验证</h2><p id="dc6e" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">在<code class="eh mb mc md me b">Request</code>上有一个<code class="eh mb mc md me b">validate</code>方法负责解析事件。它利用了顺序链接承诺的能力，以便一个承诺的解析成为下一个承诺的成功处理程序参数。链式承诺序列中的每个成功处理程序用于验证表单提交的不同方面。被拒绝的承诺会上升到它们的顶级父级，因此我们可以在处理程序中定义一个由所有验证方法共享的<code class="eh mb mc md me b">catch</code>方法。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="2adb" class="kf kg ik me b fv mj mk l ml mm">validate () {<br/>  return Promise.resolve()<br/>    .then(() =&gt; this._validateResponseFormat())<br/>    .then(() =&gt; this._validateNoHoneyPot())<br/>    .then(() =&gt; this._validateSingleEmails())<br/>    .then(() =&gt; this._validateDelimiteredEmails())<br/>    .then(() =&gt; this._validateToRecipient())<br/>    .then(() =&gt; this._validateRedirect())<br/>}</span></pre><p id="6217" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您想知道这些特定的验证方法看起来像什么，让我们看看负责设置<code class="eh mb mc md me b">_to</code>接收者的<code class="eh mb mc md me b">_validateSingleEmails</code>。它检查<code class="eh mb mc md me b">userParameters</code>中是否提供了任何<code class="eh mb mc md me b">singleEmailFields</code>，如果验证成功，则解析承诺，如果有错误，则拒绝承诺。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="005b" class="kf kg ik me b fv mj mk l ml mm">_validateSingleEmails () {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    this.singleEmailFields<br/>      .filter((field) =&gt; field in this.userParameters)<br/>      .forEach((field) =&gt; {<br/>        let input = this.userParameters[field]<br/>        if (!this._parseEmail(input, field)) {<br/>          let msg = `Invalid email in '${field}' field`<br/>          let err = new HttpError().unprocessableEntity(msg)<br/>          return reject(err)<br/>        }<br/>      })</span><span id="fc99" class="kf kg ik me b fv nd mk l ml mm">    return resolve()<br/>  })<br/>}</span></pre><h2 id="52ca" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">HTTP错误被拒绝</h2><p id="5c66" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">不是在承诺中直接拒绝一个JavaScript错误，而是从一个<code class="eh mb mc md me b">HttpError</code>方法中生成一个错误。创建这个类是为了提供一个友好的API来生成常见的HTTP响应错误。该类包含每个受支持的错误响应的公共方法。下面是一个只有<a class="ae ih" href="https://httpstatuses.com/422" rel="noopener ugc nofollow" target="_blank"> 422不可处理实体</a>响应的类的例子。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="986f" class="kf kg ik me b fv mj mk l ml mm">class HttpError {<br/>  unprocessableEntity (message) {<br/>    return this._buildError(422, message)<br/>  }</span><span id="fda4" class="kf kg ik me b fv nd mk l ml mm">  _buildError (statusCode, message) {<br/>    const error = new Error(message)<br/>    error.statusCode = statusCode<br/>    return error<br/>  }<br/>}</span></pre><p id="0d12" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可能会认为不值得像这样构建错误处理，因为需要更多的前期工作。当您考虑到<em class="mw">接收</em>处理器可以变得多干净时，好处就变得更加明显了。我们可以拒绝来自承诺链中任何地方的<code class="eh mb mc md me b">HttpError</code>错误，并在顶级的<code class="eh mb mc md me b">catch</code>方法中捕获它。在这一点上，然后可以构建适当的响应以显示给用户。</p><h1 id="c940" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">生成响应</h1><p id="9090" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">要生成响应，并不像向<code class="eh mb mc md me b">callback</code>提供状态代码和消息那么简单。JSON和HTML内容类型都受支持，它们都需要设置不同的头，并具有不同的主体格式。还支持通过<code class="eh mb mc md me b">_redirect</code>表单输入重定向响应，这同样有不同的要求。</p><p id="ac3e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">已经创建了一个类，它可以构建不同的响应对象，这些对象可以传递给<code class="eh mb mc md me b">callback</code>。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="dfe6" class="kf kg ik me b fv mj mk l ml mm">class Response {<br/>  constructor (statusCode, message) {<br/>    this.statusCode = statusCode<br/>    this.message = message<br/>  }</span><span id="9174" class="kf kg ik me b fv nd mk l ml mm">  buildJson () {<br/>    return {<br/>      statusCode: this.statusCode,<br/>      headers: {<br/>        'Access-Control-Allow-Origin': '*',<br/>        'Content-Type': 'application/json'<br/>      },<br/>      body: JSON.stringify({<br/>        statusCode: this.statusCode,<br/>        message: this.message<br/>      })<br/>    }<br/>  }</span><span id="5df5" class="kf kg ik me b fv nd mk l ml mm">  buildHtml (template) {<br/>    return {<br/>      statusCode: this.statusCode,<br/>      headers: {<br/>        'Content-Type': 'text/html'<br/>      },<br/>      body: template.replace('{{ message }}', this.message)<br/>    }<br/>  }</span><span id="e376" class="kf kg ik me b fv nd mk l ml mm">  buildRedirect (redirectUrl) {<br/>    return {<br/>      statusCode: this.statusCode,<br/>      headers: {<br/>        'Content-Type': 'text/plain',<br/>        'Location': redirectUrl<br/>      },<br/>      body: this.message<br/>    }<br/>  }<br/>}</span></pre><p id="15e6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要使用上面的类，首先要通过传入状态代码和消息来创建它的一个实例，因为这在所有响应类型中都很常见。然后根据期望的响应调用三个公共方法中的一个。</p><p id="c3d0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，要构建一个JSON响应，您需要执行以下操作。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="6ffc" class="kf kg ik me b fv mj mk l ml mm">const statusCode = 200<br/>const message = 'Form submission successfully made'<br/>const response = new Response(statusCode, message)<br/>callback(null, response.buildJson())</span></pre><p id="d21b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">默认情况下，HTML响应由显示，并带有一条通用的成功消息。</p><figure class="lb lc ld le fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ne"><img src="../Images/dc2d867358557786ba0c2e1972595047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlaiQ6lezJC0hqSx3QF65Q.png"/></div></div></figure><p id="8db4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个页面是通过加载一个本地HTML模板文件并对一个<code class="eh mb mc md me b">{{ message }}</code>变量进行查找和替换而生成的。使用<a class="ae ih" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank"> Node.js fs模块</a>将模板加载到处理程序中。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="9cc3" class="kf kg ik me b fv mj mk l ml mm">const path = path.resolve(__dirname, 'template.html')<br/>const template = fs.readFileSync().toString()</span><span id="730c" class="kf kg ik me b fv nd mk l ml mm">const message = 'Form submission successfully made'<br/>const html = template.replace('{{ message }}', message)</span></pre><h2 id="3912" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">确定响应类型</h2><p id="4046" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated"><code class="eh mb mc md me b">Response</code>类负责构建响应，但是它不知道什么是合适的响应。响应的选择由一系列条件语句决定，这些条件语句查看先前在<em class="mw">接收</em>处理程序中创建的经过验证的<code class="eh mb mc md me b">request</code>。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="d0ce" class="kf kg ik me b fv mj mk l ml mm">if (request.redirectUrl) {<br/>  callback(null, response.buildRedirect(request.redirectUrl))<br/>  return<br/>}<br/>if (request.responseFormat === 'json') {<br/>  callback(null, response.buildJson())<br/>  return<br/>}<br/>if (request.responseFormat === 'html') {<br/>  const path = path.resolve(__dirname, 'template.html')<br/>  const template = fs.readFileSync(path).toString()<br/>  callback(null, response.buildHtml(template))<br/>  return<br/>}</span></pre><p id="b4b1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你不知道，你可以在JavaScript中通过不指定返回值来返回<code class="eh mb mc md me b">undefined</code>。在上面的代码块中，我们用它来停止脚本执行，这样<code class="eh mb mc md me b">callback</code>就只被调用一次。</p><h1 id="84c9" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">构建接收处理程序</h1><p id="dc24" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">再次基于顺序链接<a class="ae ih" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> JavaScript承诺</a>的能力，<em class="mw">接收</em>处理程序采用以下格式。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="188b" class="kf kg ik me b fv mj mk l ml mm">module.exports.handle = (event, context, callback) =&gt; {<br/>  const request = new Request(event)</span><span id="9be5" class="kf kg ik me b fv nd mk l ml mm">  request.validate()<br/>    .then(function () {<br/>      // send email<br/>    })<br/>    .then(function () {<br/>      // build success response<br/>    })<br/>    .catch(function (error) {<br/>      // build error response<br/>    })<br/>    .then(function (response) {<br/>      // response callback<br/>    })<br/>}</span></pre><p id="b452" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用<code class="eh mb mc md me b">Response</code>构建的对象被传递给<code class="eh mb mc md me b">callback</code>，以便在这个顶级承诺链的最终成功处理程序中返回一个HTTP响应。这个响应对象可能是从前面的<code class="eh mb mc md me b">then()</code>或<code class="eh mb mc md me b">catch()</code>方法中解析出来的。用实现代码替换上面的注释，我们得到了最终的处理程序。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="465f" class="kf kg ik me b fv mj mk l ml mm">module.exports.handle = (event, context, callback) =&gt; {<br/>  const request = new Request(event)<br/>  request.validate()<br/>    .then(function () {<br/>      const payload = {<br/>         recipients: request.recipients, <br/>         userParameters: request.userParameters<br/>      }<br/>      return aws.invokeLambda('formplug', 'dev', 'send', payload)<br/>    })<br/>    .then(function () {<br/>      const statusCode = request.redirectUrl ? 302 : 200<br/>      const message = 'Form submission successfully made'<br/>      const respnse = new Response(statusCode, message)<br/>      return Promise.resolve(response)<br/>    })<br/>    .catch(function (error) {<br/>      const response = new Response(error.statusCode, error.message)<br/>      return Promise.resolve(response)<br/>    })<br/>    .then(function (response) {<br/>      if (request.redirectUrl) {<br/>        callback(null, response.buildRedirect(request.redirectUrl))<br/>        return<br/>      }<br/>      if (request.responseFormat === 'json') {<br/>        callback(null, response.buildJson())<br/>        return<br/>      }<br/>      if (request.responseFormat === 'html') {<br/>        const path = path.resolve(__dirname, 'template.html')<br/>        const template = fs.readFileSync(path).toString()<br/>        callback(null, response.buildHtml(template))<br/>        return<br/>      }<br/>    })<br/>}</span></pre><h2 id="54af" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">调用发送Lambda</h2><p id="c9c4" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">没有讨论电子邮件实际上是如何发送的。使用<em class="mw"> send </em> Lambda中的<a class="ae ih" href="https://aws.amazon.com/ses/" rel="noopener ugc nofollow" target="_blank">Amazon Simple Email Service(SES)</a>发送电子邮件，该服务在<em class="mw"> receive </em> Lambda中的第一个promise success处理程序中调用。它由包含接收者和表单输入的有效负载调用。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="7512" class="kf kg ik me b fv mj mk l ml mm">const payload = {<br/> recipients: request.recipients, <br/> userParameters: request.userParameters<br/>}</span><span id="ca05" class="kf kg ik me b fv nd mk l ml mm">return aws.invokeLambda('formplug', 'dev', 'send', payload)</span></pre><p id="700a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Lambda是使用NPM上可用的<a class="ae ih" href="https://www.npmjs.com/package/aws-sdk" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>调用的。尽管看起来我们好像是在直接调用AWS SDK，但事实并非如此。我们实际上是在包装类的<a class="ae ih" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例</a>实例上调用一个方法。它提供了库的代理，在一个更简单的API中只公开相关的方法。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="46f9" class="kf kg ik me b fv mj mk l ml mm">const aws = require('aws-sdk')</span><span id="715e" class="kf kg ik me b fv nd mk l ml mm">class AwsService {<br/>  constructor (aws) {<br/>    this.aws = aws<br/>  }</span><span id="ee66" class="kf kg ik me b fv nd mk l ml mm">  invokeLambda (serviceName, stage, functionName, payload) {<br/>    let event = {<br/>      FunctionName: `${serviceName}-${stage}-${functionName}`,<br/>      InvocationType: 'Event',<br/>      Payload: JSON.stringify(payload)<br/>    }<br/>    return new this.aws.Lambda().invoke(event).promise()<br/>  }</span><span id="0a6a" class="kf kg ik me b fv nd mk l ml mm">  sendEmail (email) {<br/>    return new this.aws.SES().sendEmail(email).promise()<br/>  }<br/>}</span><span id="9de0" class="kf kg ik me b fv nd mk l ml mm">module.exports = new AwsService(aws)</span></pre><h1 id="73d1" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">发送电子邮件</h1><p id="4051" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated"><em class="mw"> send </em> Lambda首先创建一个<code class="eh mb mc md me b">Email</code>的实例，然后调用前面描述的<code class="eh mb mc md me b">AwsService</code>类上的<code class="eh mb mc md me b">sendEmail</code>方法。在这个处理程序中，<code class="eh mb mc md me b">event</code>参数只是来自<code class="eh mb mc md me b">receive</code> Lambda的有效载荷。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="995c" class="kf kg ik me b fv mj mk l ml mm">module.exports.handle = (event, context, callback) =&gt; {<br/>  const email = new Email(config.SENDER_ARN, config.MSG_SUBJECT)<br/>  email.build(event.recipients, event.userParameters)<br/>    .then(function (email) {<br/>      return aws.sendEmail(email)<br/>    })<br/>    .catch(function (error) {<br/>      callback(error)<br/>    })<br/>}</span></pre><p id="16e5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">配置变量从本地JSON文件加载。<code class="eh mb mc md me b">SENDER_ARN</code>变量是发送邮件地址的<a class="ae ih" href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" rel="noopener ugc nofollow" target="_blank"> Amazon资源名称</a>(SES只从验证过的邮件地址发送邮件)。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="471d" class="kf kg ik me b fv mj mk l ml mm">const config = require('./config.json')</span></pre><p id="494f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mb mc md me b">Email</code>类上的<code class="eh mb mc md me b">build</code>方法创建一个SES兼容的对象，并将其传递给AWS SDK。它首先检查<code class="eh mb mc md me b">SENDER_ARN</code>是否有效，然后返回SES对象。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="3d03" class="kf kg ik me b fv mj mk l ml mm">build (recipients, userParameters) {<br/>  return this._validateArn()<br/>    .then(() =&gt; {<br/>      let email = {<br/>        Source: this._buildSenderSource(),<br/>        ReplyToAddresses: recipients.replyTo,<br/>        Destination: {<br/>          ToAddresses: [recipients.to],<br/>          CcAddresses: recipients.cc,<br/>          BccAddresses: recipients.bcc<br/>        },<br/>        Message: {<br/>          Subject: {<br/>            Data: this.subject<br/>          },<br/>          Body: {<br/>            Text: {<br/>              Data: this._buildMessage(userParameters)<br/>            }<br/>          }<br/>        }<br/>      }</span><span id="283a" class="kf kg ik me b fv nd mk l ml mm">      return Promise.resolve(email)<br/>    })<br/>}</span></pre><p id="e53b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">邮件正文是通过循环作为<code class="eh mb mc md me b">event</code>的一部分发送的用户参数构建的。以下划线为前缀的Formplug配置变量将被忽略。</p><pre class="lb lc ld le fq mf me mg mh aw mi dt"><span id="867b" class="kf kg ik me b fv mj mk l ml mm">_buildMessage (userParameters) {<br/>  return Object.keys(userParameters)<br/>    .filter(function (param) {<br/>      // don't send private variables<br/>      return param.substring(0, 1) !== '_'<br/>    })<br/>    .reduce(function (message, param) {<br/>      // uppercase the field names and add each parameter value<br/>      message += param.toUpperCase()<br/>      message += ': ' <br/>      message += userParameters[param]<br/>      message += '\r\n'<br/>      return message<br/>    }, '')<br/>}</span></pre><h1 id="6a78" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">包扎</h1><p id="42fc" class="pw-post-body-paragraph jh ji ik jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">我希望您对这个高级代码库演练感兴趣。要了解更多信息和部署说明，您应该查看Github 上的<a class="ae ih" href="https://github.com/danielireson/formplug-serverless" rel="noopener ugc nofollow" target="_blank">库。如果您有任何意见或建议，请在下面留下您的回复，我会很乐意回复您。</a></p><h2 id="3ff1" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><a class="ae ih" href="https://github.com/danielireson/formplug-serverless" rel="noopener ugc nofollow" target="_blank">在GitHub上查看项目</a></h2><h2 id="2fde" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><a class="ae ih" href="https://danielireson.github.io/formplug-serverless/" rel="noopener ugc nofollow" target="_blank">尝试演示</a></h2><div class="ht hu fm fo hv nf"><a href="https://github.com/danielireson/formplug-serverless" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd il fv z el nk eo ep nl er et ij dt translated">Daniel reson/form plug-无服务器</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">用于AWS Lambda的表单插件-无服务器表单转发服务</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ib nf"/></div></div></a></div><p id="e7f2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这篇博文，你可能也会喜欢之前的媒体教程，在那里我使用AWS Lambda和S3构建了一个无服务器的URL缩短器。</p><div class="ht hu fm fo hv nf"><a href="https://medium.freecodecamp.org/how-to-build-a-serverless-url-shortener-using-aws-lambda-and-s3-4fbdf70cbf5c" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd il fv z el nk eo ep nl er et ij dt translated">如何使用AWS Lambda和S3构建一个无服务器的URL缩短器</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">在这篇文章中，我们将使用亚马逊网络服务(AWS) Lambda和S3构建一个无服务器的URL缩短器。同时…</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">medium.freecodecamp.org</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ib nf"/></div></div></a></div><figure class="lb lc ld le fq hw"><div class="bz el l di"><div class="nv nw l"/></div></figure></div></div>    
</body>
</html>