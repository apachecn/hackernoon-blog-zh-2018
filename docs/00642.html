<html>
<head>
<title>Algorithms Explained: Quicksort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法解释:快速排序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/algorithms-explained-quicksort-324305b8757b?source=collection_archive---------8-----------------------#2018-01-21">https://medium.com/hackernoon/algorithms-explained-quicksort-324305b8757b?source=collection_archive---------8-----------------------#2018-01-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5cb0ffd1365fbf5dbf3b67ad217cb8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAoyEDNF_3p_2LCUgW-O1Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Algorithms Explained: Quicksort</figcaption></figure><p id="3f6f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">今天我们来看一个非常重要的排序算法:<em class="ke">快速排序</em>。快速排序是一种<em class="ke">递归</em>排序算法，采用了<em class="ke">分治</em>策略。</p><p id="d3eb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我不会解释递归是如何工作的，因为我已经在这里写了一篇文章。</p><p id="9b38" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为这是一个分治算法，我们想得到一个未排序的整数列表，把问题分成两个更简单的问题，然后再把每个问题分解…诸如此类。</p><p id="42dc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了实现这一点，我将首先介绍quicksorts的核心操作:分区。它的工作原理如下:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="5ec8" class="ko kp hu kk b fv kq kr l ks kt">&gt;&gt;&gt; A = [6, 3, 17, 11, 4, 44, 76, 23, 12, 30]<br/>&gt;&gt;&gt; partition(A, 0, len(A)-1)<br/>&gt;&gt;&gt; print(A)<br/>[6, 3, 17, 11, 4, 23, 12, 30, 76, 44]</span></pre><p id="12b9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么这里发生了什么，它是如何工作的？我们需要选择一些数字作为我们的<em class="ke">支点</em>。我们的分区函数有3个参数，列表中的<em class="ke">元素</em>、列表中的<em class="ke">元素</em>和<em class="ke">枢轴</em>。我们在这里试图实现的是，当我们划分列表时，枢轴左边的所有内容都小于枢轴<em class="ke">而右边的所有内容都大于枢轴</em>。对于上面看到的第一个分区，<em class="ke"> 30是我们的枢纽</em>。分割后，我们看到一些元素改变了位置，但是30左边的都比它小，右边的都比它大。</p><p id="13d2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么这对我们意味着什么呢？这意味着30现在在列表<em class="ke">中处于正确的</em>位置<strong class="ji hv">和</strong>我们现在有两个更容易排序的列表。所有这些都是就地完成的，所以我们不会创建新的列表。</p><p id="aada" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看看代码:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="238f" class="ko kp hu kk b fv kq kr l ks kt">def partition(A, p, r):</span><span id="ced1" class="ko kp hu kk b fv ku kr l ks kt">   q = j = p</span><span id="aecf" class="ko kp hu kk b fv ku kr l ks kt">   while j &lt; r:<br/>     if A[j] &lt;= A[r]:<br/>       A[q], A[j] = A[j], A[q]<br/>         q += 1</span><span id="6871" class="ko kp hu kk b fv ku kr l ks kt">     j += 1</span><span id="ceae" class="ko kp hu kk b fv ku kr l ks kt">   A[q], A[r] = A[r], A[q]</span><span id="2da5" class="ko kp hu kk b fv ku kr l ks kt">   return q</span></pre><p id="0091" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">末尾的return q对于我们的分区来说是不必要的，但是对于整个列表的排序来说是必不可少的。上面的代码遍历列表<em class="ke"> A </em>并维护索引<em class="ke"> p，q，j，r </em>。</p><p id="4713" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ke"> p </em>是固定的，是列表中的第一个元素。<em class="ke"> r </em>是<em class="ke">枢轴</em>，也是列表中的最后一个元素。已知范围<em class="ke"> A[p:q-1] </em>中的元素小于或等于主元，并且从<em class="ke"> A[q-1:r-1] </em>开始的所有元素都大于主元。唯一改变的指数是<em class="ke"> q </em>和<em class="ke"> j </em>。在每一步，我们将<em class="ke">A【j】</em>与<em class="ke">A【r】</em>进行比较。如果它大于支点，那么它就在正确的位置，所以我们增加<em class="ke"> j </em>并移动到下一个元素。如果<em class="ke"> A[j] </em>小于<em class="ke"> A[r] </em>我们就把<em class="ke"> A[q] </em>换成<em class="ke"> A[j】。</em>在这次交换之后，我们增加了<em class="ke"> q </em>，从而扩展了已知小于或等于支点的元素的范围。我们还增加<em class="ke"> j </em>来移动到下一个要处理的元素。</p><p id="4b4d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在进入<em class="ke">快速分类</em>部分。记住它是一个<em class="ke">递归算法</em>，所以它会不断调用<em class="ke"> partition() </em>，直到没有任何东西剩下来进行分区。</p><p id="6198" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看看代码:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="43ce" class="ko kp hu kk b fv kq kr l ks kt">def quicksort(A, p, r):</span><span id="8c64" class="ko kp hu kk b fv ku kr l ks kt">   if r &lt;= p:<br/>     return</span><span id="93ba" class="ko kp hu kk b fv ku kr l ks kt">   q = partition(A, p, r)<br/>   quicksort(A, p, q-1)<br/>   quicksort(A, q+1, r)</span><span id="f376" class="ko kp hu kk b fv ku kr l ks kt">   return A</span></pre><p id="cee2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就这么简单。我们在这里所做的就是检查枢纽的索引是否小于或等于我们想要划分的列表的开始的索引。如果是，我们返回，因为传递的任何列表都不需要进一步划分。</p><p id="6598" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">否则，我们将列表<em class="ke">划分为</em>，并在两个新的<em class="ke">子列表</em>上再次调用<em class="ke">快速排序</em>。</p><p id="cc96" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">快速排序最适用于完全混乱的大型列表。它在几乎已排序的列表上表现很差。或者用Big-O表示法，最好的情况(加扰的)是O(n log(n))，最坏的情况(几乎或完全有序的列表)是O( n^2).</p><p id="13bf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个主题在我们的新书“Slither into Python”中有更详细的介绍，你现在可以预订€5.99版，这是我们为初学者编写的Python编程语言入门书，旨在仅用22章将你从一个完全的初学者变成一个有能力的熟练程序员，涵盖了一系列主题。点击查看<a class="ae kv" href="https://www.pyler.io/books" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/da8196febda67a5e3a936d18d56ed39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjvHjryTsqnYojTTDByuIg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Slither into Python available to pre-order for 66% off.</figcaption></figure></div></div>    
</body>
</html>