<html>
<head>
<title>Programming with JS: Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JS编程:链表</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/programming-with-js-linked-lists-4d776aa96d44?source=collection_archive---------16-----------------------#2018-01-21">https://medium.com/hackernoon/programming-with-js-linked-lists-4d776aa96d44?source=collection_archive---------16-----------------------#2018-01-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/eb487ec2824ad964121d3f0790b24001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVAq6TPIOi1eAy0f7HxPbw.jpeg"/></div></div></figure><p id="24b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一系列文章中，我们将从JavaScript的角度来看不同概念、算法和数据结构的基础。由于计算机科学在现代开发中的不适用性，它长期以来一直是被JS开发人员忽视的话题。</p><p id="9184" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经解决了开箱即用的基本问题，我们永远也不需要实现我们自己的基本算法。然而，对这些概念的正确理解确实能提高我们。不是我们对JavaScript的了解，而是我们对软件开发的一般理解。</p><p id="0f15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我们将看看链表——它们是用来做什么的，以及我们如何实现它。</p><h1 id="533a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">一些理论知识</h1><p id="5cab" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">首先，什么是链表。这是一种存储不同值的数据结构，通常被比作数组。它们都有相同的目的——存储一些数据，但区别在于它们实际存储数据的方式。</p><p id="edcc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数组通常有固定的大小和定义好的数据类型。这允许它获取连续的内存片段，用来存储我们给它的值。</p><p id="5635" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，链表没有固定的大小。我们一个接一个地添加元素，每个元素负责指向下一个。因此，我们传递的值将驻留在内存中的不同位置，并依赖于列表中的项目来指向下一个。</p><p id="204b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个区别是两种数据结构中操作的性能。数组访问元素的时间是固定的。这意味着获取数组的第一个元素与获取第100个元素是一样的。这是因为元素在内存中的存储方式。</p><p id="5b45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，在链表中，访问一个元素需要你遍历列表中的条目，如果你找到了，就检查每一个条目。在最坏的情况下，你将不得不遍历整个列表，这比数组要慢得多。</p><p id="91ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们应用于这种结构的另一个常见操作是添加和删除元素。由于它们的静态性质，这里的数组往往很慢。它们拥有固定数量的内存，添加一个新项通常需要复制整个数组，同时分配更多的内存。现在，想象一下在数组中间的特定位置添加一个元素，这会导致什么样的洗牌。删除一个元素是可行的，但是实际上你只是使这个值无效。仍然为阵列保留内存。</p><p id="fc7d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，链表更有效。在列表中的任何地方添加元素只需要改变指针。移除也是一个快速操作，这也将释放为特定元素分配的内存。如果没有对它的引用，它将被垃圾回收。</p><h1 id="55ce" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">实现一个链表</h1><p id="597b" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在我们开始实现之前，有一些事情需要注意。有多种类型的链表和多种实现它们的方法。</p><p id="7ad5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将实现最基本的<strong class="je hv">链表</strong>。它将由节点组成，每个笔记都有一个指向下一个的指针。列表中的最后一个节点将指向null，这在我们遍历它并想知道何时停止时很有用。</p><p id="7d99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们开始之前，我想说可能有比我在这里展示的更好的实现。为了这篇文章的缘故，链表的逻辑和它的操作将被尽可能彻底地描述。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="1030" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">length属性用于跟踪列表的大小，而不必在每次需要时都遍历它。头是列表中的第一项，当我们遍历数据结构时，我们将把它作为一个起点。</p><p id="e83e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要实现的第一个逻辑是<code class="eh lj lk ll lm b">add</code>方法。每当我们试图向列表中添加一个项目时，它将遍历列表，找到其中的最后一个节点，并在它之后添加新的项目。这里唯一的特例是当列表仍然为空时。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="c1f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里一个可能的陷阱是忘记增加长度属性，这将导致每次都设置一个新的头指针。</p><p id="3c9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我提到过链表在添加元素时有多快，但是这种添加方法会迫使我们每次在链表中添加另一个节点时都要循环一次。</p><p id="57d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一种方法是将元素作为第一项添加到列表中，将其作为新的head添加，并使其指向前一个head元素。无论数据结构的大小如何，该功能将总是需要相同数量的步骤。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="8ed2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在可以向链表添加元素了，万岁！当然，有时我们在追加节点时会犯错误，我们希望通过删除一个元素来修复它们。一旦你明白了这一点，这也是非常直接的。</p><p id="54eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将根据元素的值删除元素。所以首先我们需要找到我们想要删除的元素，它可能在列表的中间。如果我们只是删除它或者将它设置为null，那么它将会中断与它后面的元素的链接，所以我们必须考虑其他的东西。</p><p id="803b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们要做的是遍历列表，检查每个元素是否是我们要寻找的。同时，我们还将跟踪我们已经测试过的前一个元素。</p><p id="369c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，当我们找到我们正在寻找的节点时，我们将设置前一个节点的下一个指针指向当前节点的下一个指针。这样，我们要删除的节点将没有对它的引用，并将被垃圾回收。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="89ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">需要注意的是要移除的节点是头部的情况。还要记住改变长度属性。</p><p id="5754" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您需要查找具有特定值的节点是否在列表中，您可以使用我们在<code class="eh lj lk ll lm b">remove</code>方法中编写的逻辑。</p><h1 id="454f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">其他种类的链表</h1><p id="7097" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated"><strong class="je hv">双向链表</strong>是一种类似于普通链表的数据结构，区别在于每个节点都有一个指针指向下一个节点<strong class="je hv">和前一个节点</strong>。当我们想后退而不仅仅是前进列表时，这很有用。</p><p id="9f6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">循环链表</strong>是一个最后一个节点的next指针指向链表第一个节点的链表，这样就创建了一个循环结构。这可能是有用的，因为它允许我们遍历整个列表，即使我们没有从一开始就这样做，但它也可能相当棘手。</p><h1 id="42e8" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">下一步是什么？</h1><p id="c584" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我希望这篇文章能帮助你理解链表数据结构的基础。你可以帮我按住拍手键，把这篇文章分享给朋友！</p></div></div>    
</body>
</html>