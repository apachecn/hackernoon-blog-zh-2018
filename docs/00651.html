<html>
<head>
<title>Ethereum Smart Contracts — Lifecycle, Multiple Contracts &amp; Message sender</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊智能合同—生命周期、多份合同和消息发送者</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ethereum-smart-contracts-lifecycle-multiple-contracts-message-sender-e9195ceff3ec?source=collection_archive---------17-----------------------#2018-01-21">https://medium.com/hackernoon/ethereum-smart-contracts-lifecycle-multiple-contracts-message-sender-e9195ceff3ec?source=collection_archive---------17-----------------------#2018-01-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0ef43d2f656a7f333713d8e404ba96b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVUqpYJQiPSctGtnVTCo7A.png"/></div></div></figure><p id="5b08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">许多人发现智能合约生命周期的更大图景不够清晰。在这篇短文中，我将尝试用一种简单的方式解释以太坊生态系统或智能合约的新手如何能够清楚地理解它。<br/>我相信<a class="ae ka" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>的开发者对面向对象的概念很熟悉。因此，我将以此为类比来解释以太坊智能合约的生命周期。</p><h1 id="79b8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">生命周期</h1><p id="bf14" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">首先，我们可以把契约看作是面向对象术语中的一个类，它是对象的模板。一个契约可以多次部署到一个网络上，每个实例都有一个不同的地址，以后可以用这个地址与该契约的特定实例进行交互。因此，契约的每一个部署都可以被看作是面向对象概念中的一个对象实例。为了进一步澄清，每个实例都是独立的，有自己的状态(持久数据)。</p><p id="fbea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当将协定部署到网络时，会调用协定的构造函数，这是唯一一次调用该构造函数。所以你在构造函数中做的任何初始化，只会执行一次，而且是在部署的时候。在契约创建结束时，可以获得一个地址，该地址可用于在特定契约实例的生命周期内与其进行交互。您可以在契约中保留条款，通过调用封装了自毁的方法来销毁契约。这种终止映射到面向对象概念中对象的析构函数。</p><h1 id="0994" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">多重合同</h1><p id="de92" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您的解决方案需要多个协定来执行其任务，则有必要单独部署每个协定。合同A与合同B通信的唯一方式是知道合同B的地址。这两个合同都是网络中的一等公民，尽管它们相互依赖。如果契约A需要与契约B的不同实例进行交互，那么每当调用相关函数时，传递契约B的实例地址是明智的。相反，如果协定总是与协定B的单个实例通信，则将协定B的实例地址作为构造函数参数传递给协定A并将其保存为状态变量会更容易。</p><h1 id="8f3a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">消息发送者</h1><p id="22e1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果契约A中的方法<strong class="je hv"> <em class="le"> fooA </em> </strong>，调用契约B中的方法<strong class="je hv"> <em class="le"> fooB </em> </strong>，在<strong class="je hv"> <em class="le"> fooB </em> </strong>、<strong class="je hv"> <em class="le"> msg.sender </em> </strong>的上下文中，将契约A的地址作为值。如果你想识别绝对消息发起者，那么你必须在<strong class="je hv"> <em class="le"> fooB </em> </strong>的上下文中使用<strong class="je hv"> <em class="le"> tx.origin </em> </strong>。如果您从<strong class="je hv"> <em class="le"> fooA </em> </strong>调用<strong class="je hv"> <em class="le"> fooA1 </em> </strong>契约A内的另一个方法，那么<strong class="je hv"> <em class="le"> msg.sender </em> </strong>仍然是发起交易的原始发送方，而不是契约A的地址。</p><h1 id="c067" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">示例项目</h1><p id="6f6a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/fidenz-chim/multiple_contract_test" rel="noopener ugc nofollow" target="_blank"> multiple_contract_test </a>是一个示例项目，说明了上面所描述的内容。请浏览README.md了解更多详细信息。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure></div></div>    
</body>
</html>