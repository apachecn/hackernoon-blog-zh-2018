<html>
<head>
<title>Functional Programming in JavaScript with Hyperapp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hyperapp在JavaScript中的函数式编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-programming-in-javascript-with-hyperapp-f1594fac697c?source=collection_archive---------22-----------------------#2018-01-21">https://medium.com/hackernoon/functional-programming-in-javascript-with-hyperapp-f1594fac697c?source=collection_archive---------22-----------------------#2018-01-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3300" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">鉴于我在Vue和React上相当长的历史，我觉得这么说有点叛逆，但我认为我有了一个新的前端框架。Hyperapp是我希望Elm成为的一切——易于构建代码，高度组织化，状态处理完美无缺。也就是说，它还不像前面提到的框架那样可以投入生产，但是一旦投入生产，我可以预见它将会非常庞大。</p><p id="de07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从零开始构建Hyperapp应用程序——使用仍在出现的工具，我通常会更深入。我将为Hyperapp做同样的事情。</p><h1 id="2c83" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">入门指南</h1><p id="4f62" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">几周前，我在GitHub上看到几篇关于Hyperapp发布1.0版本，超过1万颗星的文章。我简单看了一下他们文档中的计数器“hello world”。我真的很喜欢它看起来如此干净和简单，我想尝试一下！</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="02a1" class="lb jq hu kx b fv lc ld l le lf">const { h, app } = hyperapp</span><span id="8f88" class="lb jq hu kx b fv lg ld l le lf">const state = {<br/>  count: 0<br/>}</span><span id="a338" class="lb jq hu kx b fv lg ld l le lf">const actions = {<br/>  down: value =&gt; state =&gt; ({ count: state.count - value }),<br/>  up: value =&gt; state =&gt; ({ count: state.count + value })<br/>}</span><span id="dfbd" class="lb jq hu kx b fv lg ld l le lf">const view = (state, actions) =&gt;<br/>  h("div", {}, [<br/>    h("h1", {}, state.count),<br/>    h("button", { onclick: () =&gt; actions.down(1) }, "–"),<br/>    h("button", { onclick: () =&gt; actions.up(1) }, "+")<br/>  ])</span><span id="2deb" class="lb jq hu kx b fv lg ld l le lf">window.main = app(state, actions, view, document.body)</span></pre><p id="16f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你也可以使用JSX而不是调用<code class="eh lh li lj kx b">h</code>函数来创建元素。我就是这么做的，因为我已经习惯了！我浏览了Hyperapp的Codepen 上的例子。我最终使用了一个<a class="ae lk" href="https://github.com/selfup/hyperapp-one" rel="noopener ugc nofollow" target="_blank">样板文件</a>，这样我就不必为传输JSX而设置webpack或者处理设置。这太棒了，我使用它没有任何问题，而且它有一个我喜欢使用的文件结构。</p><figure class="ks kt ku kv fq lm fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/03a94960ded47d401d1fde3581c4595f.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/0*KfkmP8Y5KPiOG3Er.png"/></div></figure><p id="a432" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Hyperapp使用了受Elm启发的架构——它有视图、模型和更新。它也遵循功能哲学，类似于Elm。这意味着状态是不可变的，动作没有副作用。状态管理感觉更像Redux，而不是标准的React，因为状态是集中的，而不是特定于组件的。此外，你必须使用<a class="ae lk" href="https://en.wikipedia.org/wiki/Thunk" rel="noopener ugc nofollow" target="_blank"> thunks </a>来构建不纯的函数。架构和设置工作起来很流畅，我没有遇到任何问题。</p><p id="4ee4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于我过去曾与Elm、React、Redux、Vue和Vuex一起工作过，所以在阅读了文档(这是最少的)并查看了代码示例之后，我认识到了这些模式并对继续进行最终项目感到满意。</p><h1 id="6d27" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">最终项目</h1><p id="eca7" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我想从API中构建一些东西——这在Redux中可能是一个相对混乱的过程。我心中没有一个，所以我浏览了这个列表，试图找到一个。我最终使用了<a class="ae lk" href="https://favqs.com/api" rel="noopener ugc nofollow" target="_blank">FavQs API</a>——我有了一个想法，制作一个报价的旋转列表，可以搜索不同报价上的标签。这将允许我与政府有更多的互动。</p><p id="4508" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我写的第一个代码是国家的模型。我为项目中需要的属性设置了初始属性:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="1416" class="lb jq hu kx b fv lc ld l le lf">export default {<br/>  quotes: [],<br/>  term: '',<br/>  index: 0<br/>}</span></pre><p id="56a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，像TypeScript或Flow这样的东西本来可以很好地强制输入。我相信它们可以很容易地集成到hyperapp项目中。</p><p id="d8fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">报价是从API返回的报价数组，如果用户指定了搜索项，那么这个搜索项就是搜索项，然后索引就是用户正在查看的报价的当前索引。</p><p id="227b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我有一个配置文件，其中定义了一些贯穿始终的常量:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="e47a" class="lb jq hu kx b fv lc ld l le lf">export const API_URL = 'https://favqs.com/api/quotes/'<br/>export const COLORS = ['#DBEBFF', '#FFBBDD', '#e6f9ff', '#BBBBFF', '#F7FFFD', '#fff8e1']<br/>export const FONT_COLORS = ['#62D0FF', '#FF62B0', '#33ccff', '#5757FF', '#03EBA6', '#ffb300']</span></pre><p id="6c53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还创建了一个服务文件，保存了我的搜索请求:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9b75" class="lb jq hu kx b fv lc ld l le lf">import axios from 'axios'<br/>import { API_URL } from './constants'</span><span id="ac59" class="lb jq hu kx b fv lg ld l le lf">const getRequest = url =&gt; {<br/>  return axios.get(url, {<br/>    headers: {'Authorization': `Token token="XXXXXXXX"`}<br/>  }).catch(<br/>    err =&gt; console.log(err)<br/>  )<br/>}</span><span id="8e84" class="lb jq hu kx b fv lg ld l le lf">export default {<br/>  getAll: _ =&gt; getRequest(API_URL),<br/>  getQuery: query =&gt; getRequest(API_URL + `?filter=${query}&amp;type=tag`)<br/>}</span></pre><p id="2cf5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上述文件是框架不可知的，但我想把它们包含在上下文中。</p><p id="e6c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">潜在的最重要的文件保存了操作:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="69af" class="lb jq hu kx b fv lc ld l le lf">import request from '../config/request'</span><span id="db44" class="lb jq hu kx b fv lg ld l le lf">export default {<br/>  getQuotes: quotes =&gt; (state, actions) =&gt; request.getAll().then(<br/>    actions.setQuotes),<br/>  submitSearch: quotes =&gt; (state, actions) =&gt; request.getQuery(<br/>    state.term).then(actions.setQuotes),<br/>  setQuotes: res =&gt; ({ quotes: res.data.quotes.filter(<br/>    quote =&gt; quote.body &amp;&amp; quote.body.length &lt; 150) }),<br/>  updateSearch: ({ term }) =&gt; ({ term }),<br/>  next: e =&gt; ({ index, quotes }) =&gt; ({ index: index + 1 }),<br/>  prev: e =&gt; ({ index, quotes }) =&gt; ({ index: index - 1 })<br/>}</span></pre><p id="c580" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对<code class="eh lh li lj kx b">getQuotes</code>和<code class="eh lh li lj kx b">submitSearch</code>使用了thunks这意味着我只是从一个函数而不是一个值来操作一个函数。这允许嵌套函数中有不纯的函数，特别是因为来自API的数据比函数式编程要求的更不可预测。因为Axios请求需要一点时间来执行，所以在从API获取数据之后，直到调用<code class="eh lh li lj kx b">setQuotes</code>方法，状态才真正更新。其他动作都比较直接！事件处理程序首先处理事件，然后处理当前状态——我确实觉得这有点“神奇”,但总体来说，操作体验非常流畅。</p><p id="6916" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我创建了视图。主要视图如下所示:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="bdc6" class="lb jq hu kx b fv lc ld l le lf">import { h, app } from 'hyperapp'<br/>import Search from './Search'<br/>import Quote from './Quote'<br/>import { COLORS, FONT_COLORS } from '../config/constants'</span><span id="0ff1" class="lb jq hu kx b fv lg ld l le lf">const quote = (quotes, index) =&gt; quotes[index]<br/>const color = index =&gt; COLORS[index % COLORS.length]<br/>const fontColor = index =&gt; FONT_COLORS[index % FONT_COLORS.length]</span><span id="cf38" class="lb jq hu kx b fv lg ld l le lf">export default ({ quotes, index }, { getQuotes, updateSearch, submitSearch, next, prev }) =&gt;<br/>  &lt;div<br/>    oncreate={getQuotes}<br/>    className={ quotes ? 'body' : 'body hidden' }<br/>    style={{ 'backgroundColor': color(index), 'color': fontColor(index) }}<br/>  &gt;<br/>    &lt;div className='centered-content'&gt;<br/>      &lt;div className='container'&gt;<br/>        { index &gt; 0 &amp;&amp;<br/>        &lt;div<br/>          onclick={prev}<br/>          className='direction left'<br/>          style={{ 'color': fontColor(index) }}&gt;<br/>            &amp;lt;<br/>        &lt;/div&gt; }<br/>        { quotes.length &gt; 0 &amp;&amp; &lt;Quote quote={quote(quotes, index)} /&gt; }<br/>        { index &lt; quotes.length - 1 &amp;&amp;<br/>        &lt;div<br/>          onclick={next}<br/>          className='direction right'<br/>          style={{ 'color': fontColor(index) }}&gt;<br/>            &amp;gt;<br/>        &lt;/div&gt; }<br/>        &lt;Search<br/>          updateSearch={updateSearch}<br/>          submitSearch={submitSearch}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;</span></pre><p id="185b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它看起来与React中的功能组件基本相同！事件处理程序是小写的，但是JSX是相同的。生命周期方法也有一点不同。我通常会在React中使用<code class="eh lh li lj kx b">componentDidMount</code>方法来发出API请求，但是这里我使用了<code class="eh lh li lj kx b">oncreate</code>属性。它们本质上做同样的事情，但是语法不同。我也没有看到订阅的文档，这在Elm中很重要。它们允许您使用Websockets并添加全局事件侦听器。不过，GitHub的一些问题提到了它们，所以我认为它们已经实现了，但还没有出现在文档中。</p><p id="73ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还有两个“子组件”，引用的一个非常简单:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="4462" class="lb jq hu kx b fv lc ld l le lf">import { h, app } from 'hyperapp'</span><span id="d58d" class="lb jq hu kx b fv lg ld l le lf">export default ({ quote }) =&gt;<br/>  &lt;div className='quote'&gt;<br/>    &lt;h1&gt;{quote.body}&lt;/h1&gt;<br/>    &lt;h4&gt;{quote.author}&lt;/h4&gt;<br/>  &lt;/div&gt;</span></pre><p id="d738" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">搜索的那个也是:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="28ff" class="lb jq hu kx b fv lc ld l le lf">import { h, app } from 'hyperapp'</span><span id="0fb2" class="lb jq hu kx b fv lg ld l le lf">export default ({ updateSearch, submitSearch }) =&gt;<br/>  &lt;div className='search'&gt;<br/>    &lt;input<br/>      onkeyup={<br/>        e =&gt; {<br/>          e.keyCode === 13 ? submitSearch() : updateSearch({ term: e.target.value })<br/>        }<br/>      }<br/>      placeholder='Search quote tags...'<br/>    /&gt;<br/>  &lt;/div&gt;</span></pre><p id="3a8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，<code class="eh lh li lj kx b">index.js</code>组合了来自其他文件的元素，以便可以在动作和视图中使用状态。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="a43f" class="lb jq hu kx b fv lc ld l le lf">import { app } from 'hyperapp'<br/>import actions from './actions'<br/>import state from './state'<br/>import view from './components/View'</span><span id="7322" class="lb jq hu kx b fv lg ld l le lf">app(state, actions, view, document.querySelector('.hyperapp-root'))</span></pre><p id="8a41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种绑定本质上与Elm组合元素的方式相同！</p><p id="1f43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我喜欢把我的代码分成多个文件，我认为这真的是可伸缩的。我可以肯定地看到自己在未来用HyperApp建立更大的东西。</p><figure class="ks kt ku kv fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="fe ff lp"><img src="../Images/1f14710a0deae000a298ec3a66b348cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*szh8YuR9-D6O29Sx.png"/></div></div></figure><h1 id="e6ce" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">后续步骤</h1><p id="162b" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">再说一次，Hyperapp是我最近学到的最喜欢的工具之一——可能仅次于Golang。我发现这是我过去使用的工具的近乎完美的结合。它也是一个微型库，而且超级高效，尤其是与Angular相比，这是令人兴奋的，这是我上周学到的！它的API是如此的简洁，而且它将函数式编程执行得如此之好。我肯定会推荐把它作为一个onramp来学习，来和Redux反应。我会100%再次使用HyperApp，我发现它很简单，我真的很喜欢代码的优雅。我真的希望社区不断扩大，文档不断改进，并且实现一个像Redux/Elm一样的回放特性。另外，我对Hyperapp有很好的体验，我已经打算再次使用它了！</p><p id="8b85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lk" href="https://www.alispit.tel/hyperapp-quote-app/" rel="noopener ugc nofollow" target="_blank"> App </a> <br/> <a class="ae lk" href="https://github.com/aspittel/hyperapp-quote-app" rel="noopener ugc nofollow" target="_blank">代码</a></p><p id="4a53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我的一部分</strong> <a class="ae lk" rel="noopener" href="/on-learning-new-things/learning-new-things-f4db7f16724"> <strong class="it hv">关于学习新事物</strong> </a> <strong class="it hv">系列</strong></p><p id="d5c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他类似文章:</p><ul class=""><li id="487e" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated"><a class="ae lk" href="https://dev.to/aspittel/how-i-finally-built-an-app-in-elm-a80" rel="noopener ugc nofollow" target="_blank">学习榆树</a></li><li id="fed3" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated"><a class="ae lk" href="https://dev.to/aspittel/learning-angular-5-as-a-react-and-vue-developer-5dp3" rel="noopener ugc nofollow" target="_blank">学习角度5 </a></li></ul></div></div>    
</body>
</html>