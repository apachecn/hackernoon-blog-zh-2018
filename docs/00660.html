<html>
<head>
<title>A brief tour of Python 3.7 data classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.7数据类简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-brief-tour-of-python-3-7-data-classes-22ee5e046517?source=collection_archive---------0-----------------------#2018-01-22">https://medium.com/hackernoon/a-brief-tour-of-python-3-7-data-classes-22ee5e046517?source=collection_archive---------0-----------------------#2018-01-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4136" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python 3.7中的一个全新特性是“数据类”。数据类是为存储多个属性的类自动生成模板代码的一种方式。</p><p id="4be4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们还带来了使用Python 3的新类型提示的好处。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/f8900ac221590b8ef8959af336a55c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*tYHJMm6YN_yOXUSKOZrOLw.png"/></div></figure><p id="a7be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Python 3.7中，数据类出现在标准库中新的<code class="eh jx jy jz ka b">dataclasses</code>模块中，你需要两个重要的东西。</p><ol class=""><li id="eeb9" class="kb kc hu it b iu iv iy iz jc kd jg ke jk kf jo kg kh ki kj dt translated"><code class="eh jx jy jz ka b">dataclass</code>装饰器，用于装饰数据类</li><li id="75b0" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">用于配置字段的<code class="eh jx jy jz ka b">field</code>方法</li></ol><h1 id="ef57" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">默认魔术方法</h1><p id="915d" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">在默认设置中，任何数据类都会为您实现<code class="eh jx jy jz ka b">__init__</code>、<code class="eh jx jy jz ka b">__repr__</code>、<code class="eh jx jy jz ka b">__str__</code>和<code class="eh jx jy jz ka b">__eq__</code>。</p><p id="1fdc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">__init__</code>方法将有<strong class="it hv">关键字参数</strong>，它们具有在类上指定的相同类型的注释。</p><p id="9ed8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">__eq__</code>方法将按顺序比较所有数据类属性。</p><p id="b9c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有字段都在类的顶部声明，类型提示是<strong class="it hv">必需的</strong>。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="2f8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个<code class="eh jx jy jz ka b">__init__</code>方法将有一个<code class="eh jx jy jz ka b">(field_a: int, field_b: str) -&gt; None</code>的签名。您只需输入<code class="eh jx jy jz ka b">print(inspect.signature(example.__init__))</code>就可以看到这一点</p><h1 id="7ed2" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">类型提示</h1><p id="7577" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">非常重要的是，类型提示仅仅是提示。因此给出错误的类型不会发出警告或尝试转换。</p><p id="4c05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为类型提示是<strong class="it hv">必需的</strong>(否则该字段将被忽略)，如果您没有特定的类型，请使用来自<code class="eh jx jy jz ka b">typing</code>模块的<code class="eh jx jy jz ka b">Any</code>类型。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><h1 id="9b47" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">易变性</h1><p id="9c98" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">dataclass decorator有一个<code class="eh jx jy jz ka b">frozen</code>参数，默认为False。如果指定，字段将被"<em class="lu">冻结</em>"，即只读，如果<code class="eh jx jy jz ka b">eq</code>被设置为True，这是默认设置，那么<code class="eh jx jy jz ka b">__hash__</code>魔术将被实现，对象实例将是可散列的，因此您可以将它们用作字典键或在集合中使用。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><h1 id="d510" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">自定义字段</h1><p id="4102" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">数据类中的核心类型是<code class="eh jx jy jz ka b">Field</code>类型，它属于一个数据类。</p><p id="1611" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">默认情况下，只需设置一个class属性就会在类中实例化一个字段，如前面的示例所示。</p><p id="a795" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您需要定制行为，您可以使用<code class="eh jx jy jz ka b">dataclasses</code>模块内的现场工厂。</p><p id="6bce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">字段()的参数是:</p><ul class=""><li id="00f2" class="kb kc hu it b iu iv iy iz jc kd jg ke jk kf jo lv kh ki kj dt translated"><code class="eh jx jy jz ka b">default</code>:如果提供，这将是该字段的默认值。这是必需的，因为字段调用本身替换了缺省值的正常位置。</li><li id="9765" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo lv kh ki kj dt translated"><code class="eh jx jy jz ka b">default_factory</code>:0参数callable，当该字段需要默认值时调用。</li><li id="7eae" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo lv kh ki kj dt translated"><code class="eh jx jy jz ka b">init</code>:作为参数包含在生成的__init__方法中。</li><li id="4c1a" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo lv kh ki kj dt translated"><code class="eh jx jy jz ka b">repr</code>:包含在生成的__repr__方法返回的字符串中。</li><li id="9181" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo lv kh ki kj dt translated"><code class="eh jx jy jz ka b">compare</code>:包含在生成的等式和比较方法中(__eq__，__gt__，等)。</li><li id="bf35" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo lv kh ki kj dt translated"><code class="eh jx jy jz ka b">hash</code>:包含在生成的__hash__方法中。</li></ul><p id="1fb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lu">还有一个说法，元数据还没有使用。</em></p><p id="f310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与关键字参数类似，具有默认值的字段必须最后声明。</p><p id="4823" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">演示默认工厂参数，</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><h1 id="f01a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">初始化后处理</h1><p id="488e" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">您可以声明一个<code class="eh jx jy jz ka b">__post_init__ </code>方法，它将在自动生成的<code class="eh jx jy jz ka b">__init__</code>之后运行。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><h1 id="a42a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">遗产</h1><p id="376e" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">继承正如你所期望的那样工作。对于继承的<strong class="it hv">和</strong>基类定义，您需要在<code class="eh jx jy jz ka b">dataclass</code>中包装类。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="ae22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，因为不能在默认字段之后声明非默认字段，所以不能在基类和子类之间混合默认和非默认字段。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="7ca4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个例子引出了<code class="eh jx jy jz ka b">TypeError: non-default argument ‘field_a’ follows default argument</code></p><p id="2b04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很烦人，可能会阻止人们过多地使用继承或默认字段。</p><p id="2a98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总而言之，这是一个很棒的特性，一旦Python 3.7发布，我可能会停止使用attrs。</p><h2 id="92be" class="lw kq hu bd kr lx ly lz kv ma mb mc kz jc md me ld jg mf mg lh jk mh mi ll mj dt translated">还卡在Python 2上？</h2><p id="a870" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated"><a class="ae mk" href="https://www.pluralsight.com/courses/python-2-to-python-3" rel="noopener ugc nofollow" target="_blank">查看我在Pluralsight上关于从Python 2迁移到3的新课程。</a></p></div></div>    
</body>
</html>