<html>
<head>
<title>Do more with less! Using render props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事半功倍！使用渲染道具</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/do-more-with-less-using-render-props-de5bcdfbe74c?source=collection_archive---------2-----------------------#2018-01-22">https://medium.com/hackernoon/do-more-with-less-using-render-props-de5bcdfbe74c?source=collection_archive---------2-----------------------#2018-01-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><h1 id="7bd9" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">继续之前！什么是渲染道具？</h1><p id="5878" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果你没有读过迈克尔·杰克逊关于<a class="ae ky" href="https://hackernoon.com/tagged/render" rel="noopener ugc nofollow" target="_blank">渲染</a>道具的精彩帖子，(不，不是唱歌的那篇)，你必须在继续这篇文章之前试一试。</p><div class="kz la fm fo lb lc"><a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab ej"><div class="le ab lf cl cj lg"><h2 class="bd hv fv z el lh eo ep li er et ht dt translated">使用渲染道具！</h2><div class="lj l"><h3 class="bd b fv z el lh eo ep li er et ek translated">渲染道具是在React中合成状态的强大方法。</h3></div><div class="lk l"><p class="bd b gc z el lh eo ep li er et ek translated">cdb.reacttraining.com</p></div></div></div></a></div><p id="3069" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">如果你懒得阅读，我可以给你一个视频(也包括在文章中)</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="d1cd" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">无耻地引用MJ的文章:</p><blockquote class="lw"><p id="6ffa" class="lx ly hu bd lz ma mb mc md me mf kx ek translated">渲染属性是一个功能属性，组件使用它来知道渲染什么。</p><p id="afd6" class="lx ly hu bd lz ma mb mc md me mf kx ek translated">更一般地说，这个想法是这样的:不是“混合”或装饰一个组件来共享行为，<strong class="ak">只是用一个函数道具来呈现一个常规组件，它可以用这个函数道具来与你共享一些状态</strong>。</p></blockquote><p id="b1f3" class="pw-post-body-paragraph ka kb hu kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx hn dt translated">如果你想了解更多信息，在<a class="ae ky" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>文档中甚至有一个关于渲染道具的<a class="ae ky" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">页面</a>。</p><blockquote class="lw"><p id="b150" class="lx ly hu bd lz ma mb mc md me mf kx ek translated">术语<a class="ae ky" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">“渲染道具”</a>指的是一种简单的技术，使用一个其值为函数的道具在React组件之间共享代码。</p></blockquote><h1 id="528f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn ml jp jq jr mm jt ju jv mn jx jy jz dt translated">如何使用渲染道具解决问题？</h1><p id="25e5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们来谈生意吧！在本文的这一部分，我将回顾应用程序中的两种常见情况(<strong class="kc hv">使用简单易懂的例子</strong>)，它们可以适应您的任何需求！</p><p id="5d4c" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">最终你会明白渲染道具模式是如何让我们的生活变得更简单的。</p><h2 id="5484" class="mo jd hu bd je mp mq mr ji ms mt mu jm kl mv mw jq kp mx my ju kt mz na jy nb dt translated">列表上的重复数据提取</h2><p id="4506" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我敢肯定，我们都有这样的用例，你有一个从你的API获取数据的列表或表格，当它获取时，你用一个漂亮的动画显示一个加载指示器，当它最终完成它的工作时，你呈现列表。</p><p id="956a" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">想象一下那个列表是汽车的。那会怎样？也许是这样的:</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nc lv l"/></div></figure><p id="fe05" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">现在想象一下，这在一个有10个或更多列表的应用程序中传播。总是输入加载样板文件会很累，对吗？现在添加分页、排序和过滤，你可能会很快发疯。</p><p id="afe2" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">渲染道具是来帮忙的。使用该模式，我们可以快速创建一个简单的列表组件，它可以获取一个url并为我们处理列表的加载状态。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nc lv l"/></div></figure><p id="a8cf" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">真的就这么简单。如果你所有的列表都有通用的JSX模板，你甚至可以把它添加到这个组件中，去掉另一种形式的重复。只要看一下代码，你就可以很容易地判断出你可以修改它来满足你的任何需求。</p><p id="bf9a" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">添加分页、排序、过滤甚至刷新按钮都是简单的功能。发疯吧！</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nc lv l"/></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">easy to just DO IT with render props</figcaption></figure><p id="ba7d" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">现在，我们所要做的只是在我们的应用程序中使用我们的组件，我们就可以开始了。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nc lv l"/></div></figure><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nh lv l"/></div></figure><p id="df84" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">看看下面的CodeSandbox，看看它是如何完成的，也许还可以摆弄一下。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="ni lv l"/></div></figure><h2 id="a216" class="mo jd hu bd je mp mq mr ji ms mt mu jm kl mv mw jq kp mx my ju kt mz na jy nb dt translated">重复的表单发布到服务器</h2><p id="0d67" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这里有一个稍微复杂一点的例子。表单是大多数应用程序的基础。正确处理表单以确保一切按预期运行是很重要的。</p><p id="9b62" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">让我们想象一个场景，你的应用程序中有大约10个表单。它们都向服务器发布，当它们发布时，提交按钮显示一个加载指示器或消息，它被禁用，完成后你想运行一些代码。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nj lv l"/></div></figure><p id="8414" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">正常情况下会是什么样子？我将使用 <a class="ae ky" href="https://github.com/jaredpalmer/formik" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> Formik </strong> </a> <strong class="kc hv">进行表单处理。</strong></p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nc lv l"/></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">Form without render props</figcaption></figure><p id="ecd5" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">通过查看代码，我们可以很容易地指出最大的重复点是对服务器的<strong class="kc hv"> POST </strong> <strong class="kc hv"> fetch请求</strong>和错误处理。表单域和验证总是会改变，但是你可以有一个应用程序，它总是用表单数据发布到服务器。</p><p id="de3f" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">现在，让我们做一些工作，并应用渲染道具来重用所有这些有趣的逻辑。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nc lv l"/></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">AjaxForm Component using render props</figcaption></figure><p id="44ae" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">通过创建AjaxForm render prop组件，我们已经抽象出了重复的要点，并使我们的生活变得更加简单。</p><p id="8e2a" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">它接受任何url，甚至给你一个<strong class="kc hv"> onSuccess </strong>回调。现在，向应用程序添加表单提交的漫长而重复的过程已经一去不复返了。</p><p id="bd54" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">检查下面的CodeSandbox以查看示例</p><p id="0192" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">注意:它不会提交到任何地方(只有示例url给出)，但你可以看到它是如何工作的，请随时修改它。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="ni lv l"/></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">CodeSandbox for AjaxForm</figcaption></figure><h1 id="feeb" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">不要直接使用这些组件</h1><blockquote class="lw"><p id="5112" class="lx ly hu bd lz ma mb mc md me mf kx ek translated">过早优化是万恶之源</p></blockquote><p id="90ec" class="pw-post-body-paragraph ka kb hu kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx hn dt translated">在使用(或构建)这些组件之前，你应该首先确保你的应用需求在不久的将来不会改变。抵制尽早重构的冲动，因为您的需求可能会发生变化，如果发生变化，您将不断地对这些组件进行更改。有这么多的变化，你最终可能会得到一段难以管理的代码。</p><p id="e8a1" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">我的建议是:</p><ul class=""><li id="188a" class="nk nl hu kc b kd ll kh lm kl nm kp nn kt no kx np nq nr ns dt translated">概述你的要求</li><li id="2c69" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated">像平常一样对它们编码</li><li id="8186" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated">注册可能重构的点</li><li id="f83f" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated">确保需求不会发生巨大的变化</li><li id="2629" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated">重构吧！</li></ul><h2 id="e328" class="mo jd hu bd je mp mq mr ji ms mt mu jm kl mv mw jq kp mx my ju kt mz na jy nb dt translated">制作适合您的应用和需求的组件。不要满足于这些抽象简单的例子。</h2><h1 id="19f2" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">挑战</h1><p id="a978" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果你想实践这个简洁的小模式，我有一些挑战给你:</p><ul class=""><li id="99cb" class="nk nl hu kc b kd ll kh lm kl nm kp nn kt no kx np nq nr ns dt translated">向列表呈现属性组件添加分页支持</li><li id="691e" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated">向列表渲染属性组件添加排序支持</li><li id="8fa5" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated">将ErrorBoundary合并到List render prop组件中以处理异常。</li></ul><h1 id="00d8" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">野外渲染道具的例子</h1><p id="b3c9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这些包利用了这种模式:</p><ul class=""><li id="df73" class="nk nl hu kc b kd ll kh lm kl nm kp nn kt no kx np nq nr ns dt translated"><a class="ae ky" href="https://github.com/jaredpalmer/formik" rel="noopener ugc nofollow" target="_blank">福米克</a></li><li id="2e14" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated"><a class="ae ky" href="https://github.com/jaredpalmer/react-fns" rel="noopener ugc nofollow" target="_blank">反应-fns </a></li><li id="0cb7" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated"><a class="ae ky" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank">反应路由器</a></li><li id="5f51" class="nk nl hu kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns dt translated"><a class="ae ky" href="https://github.com/chenglou/react-motion" rel="noopener ugc nofollow" target="_blank">反应动作</a></li></ul><h1 id="f732" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">我一定要用这种模式吗？</h1><p id="29ec" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">不喜欢？没事的。可以看一下<a class="ae ky" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>。</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="ny lv l"/></div></figure><h1 id="6f60" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">关门前</h1><p id="91e0" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我很感谢你花时间阅读这篇文章，我想带着一个问题离开(你可以在评论中回答)。</p><blockquote class="nz oa ob"><p id="5f3d" class="ka kb oc kc b kd ll kf kg kh lm kj kk od ln kn ko oe lo kr ks of lp kv kw kx hn dt translated">你看到自己使用这种模式了吗？为什么或为什么不？</p></blockquote><p id="d62a" class="pw-post-body-paragraph ka kb hu kc b kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx hn dt translated">谢谢你</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="ni lv l"/></div></figure></div></div>    
</body>
</html>