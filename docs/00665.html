<html>
<head>
<title>Top 10 Kubernetes tips and tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10大Kubernetes技巧和窍门</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/top-10-kubernetes-tips-and-tricks-27528c2d0222?source=collection_archive---------5-----------------------#2018-01-22">https://medium.com/hackernoon/top-10-kubernetes-tips-and-tricks-27528c2d0222?source=collection_archive---------5-----------------------#2018-01-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4032" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在大多数情况下，这些都没有特定的顺序。这些只是我在使用Kubernetes一年后所学到的最好的技巧。</p><h1 id="f188" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #1 Bash为我完成我的kubectl命令</strong></h1><p id="8e7b" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这可能是最简单的做法，但也是使用Kubernetes时最有帮助的事情之一。要添加自动完成功能(如果使用bash ),只需运行以下命令:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="cc68" class="lb jq hu kx b fv lc ld l le lf">echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc</span></pre><p id="c015" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这会将自动完成功能添加到您的。bashrc，这样无论你什么时候打开一个shell，它都会启用它。我发现自动完成对于像<br/> — <em class="lg">全名称空间</em>这样的长东西来说是最好的</p><h1 id="3e09" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #2为名称空间添加默认内存限制和cpu限制</strong></h1><p id="6015" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">人们会犯错，这是常有的事。如果有人编写了一个应用程序，比方说，每秒钟打开一个到数据库的连接，但从不关闭它，那么我们现在在集群上的一个应用程序中有一个内存泄漏。如果它们部署到没有限制设置的群集，可能会使节点崩溃。</p><p id="5be6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了防止这种情况，Kubernetes允许在每个名称空间的基础上设置默认限制。要做到这一点，只需为有限范围创建一个yaml并将其应用到名称空间即可。下面是一个yaml示例:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="aa1c" class="lb jq hu kx b fv lc ld l le lf">apiVersion: v1 <!-- --> <br/> kind: LimitRange <!-- --> <br/> metadata: <!-- --> <br/>   name: mem-limit-range <!-- --> <br/> spec: <!-- --> <br/>   limits: <!-- --> <br/>   - default: <!-- --> <br/>       memory: 512Mi <!-- --> <br/>     defaultRequest: <!-- --> <br/>       memory: 256Mi <!-- --> <br/>     type: Container</span></pre><p id="6f88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用它创建一个yaml，并将其应用于您想要的任何名称空间。例如名称空间<em class="lg">限制——例如</em>。在应用它之后，部署到该名称空间的任何没有设置限制的容器都将获得512Mi的限制。</p><h1 id="322a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">你能清理一下我的docker图片吗</h1><p id="1932" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">默认情况下，kubelet已经这样做了。如果在启动kubelet时没有设置标志，当var/lib/docker达到90%容量时，它将开始垃圾收集。这一切都很好，但是没有为inode阈值设置默认值(在Kubernetes 1.7之前)。</p><p id="a99f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以让var/lib/docker只使用50%的磁盘空间，但是您的inodes可能会被全部使用。这会给你的工人带来很多问题。<br/>如果您运行的是1.4–1.6版本的kubelet，那么您必须为您的kubelet添加一个标志。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="40be" class="lb jq hu kx b fv lc ld l le lf">--eviction-hard<br/>=memory.available&lt;100Mi,nodefs.available&lt;10%,nodefs.inodesFree&lt;5%</span></pre><p id="d530" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些是运行1.7或更高版本时的默认值。默认情况下，1.6不监视inode的使用情况，所以添加这个标志可以解决这个问题。</p><h1 id="1210" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #4迷你库…小巧但功能强大，适合本地使用</strong></h1><p id="3bc2" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Minikube是让Kubernetes集群在本地运行的最简单的方法。只需按照这些说明进行操作。下载所有的东西。</p><p id="f75c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦安装好一切，就像运行一样简单:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9a39" class="lb jq hu kx b fv lc ld l le lf">minikube start</span></pre><p id="3dac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该命令完成后，您将在本地拥有一个正在运行的kubernetes集群。</p><p id="d5fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您想要在本地构建应用程序并在本地运行它时，技巧就来了。如果您没有运行其他命令，那么当您进行docker构建时，映像仍然会在您的计算机上构建。</p><p id="0d75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要让您的docker构建将映像推送到本地kubernetes集群，您需要用这个命令告诉docker机器:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="abdb" class="lb jq hu kx b fv lc ld l le lf">eval $(minikube docker-env)</span></pre><p id="d5cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这应该让您开始在本地kubernetes集群上构建应用程序。</p><h1 id="7882" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #5不要随便给任何人kubectl访问权限</strong></h1><p id="0607" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这可能是显而易见的，但是当多个团队部署到一个集群时……这就是Kubernetes的目的，不要只是给每个人一个通用的kubectl。我的建议是基于名称空间分离团队，然后使用RBAC策略只允许访问该名称空间。</p><p id="b721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能会对以pod为基础的访问、读取、创建和删除变得非常疯狂，这只是其中的几个例子。但是首先要做的事情之一是只允许管理员访问机密，这将区分谁可以管理集群，谁可以部署到集群。</p><p id="f4dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望稍后在另一篇博客中对此进行更深入的探讨。</p><h1 id="7232" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #6吊舱破坏预算是你的朋友。</strong></h1><p id="edc4" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">有人如何保证kubernetes集群的应用程序不会停机？</p><p id="dd0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">pod disruption budget<br/>pod disruption budget<br/>pod disruption budget</p><p id="2cb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">集群将被更新。节点会被抽干，东西会被移动，这是既定的。PDB的(PodDisruptionBudget)应该放在拥有1个以上实例的每个部署上。可以使用应用于集群的简单yaml来创建PDB，并使用标签选择器来确定特定PDB覆盖的内容。</p><p id="a060" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:PDB只考虑自愿中断，像硬件故障这样的情况不会考虑PDB。</p><p id="7ad7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PDB的一个例子如下:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="c9cf" class="lb jq hu kx b fv lc ld l le lf">apiVersion: policy/v1beta1 <!-- --> <br/> kind: PodDisruptionBudget <!-- --> <br/> metadata: <!-- --> <br/>   name: app-a-pdb <!-- --> <br/> spec: <!-- --> <br/>   minAvailable: 2 <!-- --> <br/>   selector: <!-- --> <br/>       matchLabels: <!-- --> <br/>         app: app-a</span></pre><p id="d553" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最值得关注的两件事是matchLabels和minAvailable部分。kubernetes通过matchLabels来查看部署是否与PDB相关联。例如:如果我有一个标签为app: app-a的部署和一个标签为app: app-b的部署，那么示例PDB将仅适用于第一个部署。</p><p id="2320" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">minAvailable是kubernetes在做类似节点流失的事情时所查看的内容。假设app-a正在节点1上运行，如果在节点1上开始消耗，它只会驱逐app-a，因为当前至少有2个在运行。</p><p id="f8e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这使您可以控制在任何给定时间需要运行多少实例。</p><h1 id="b5f2" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #7您的应用程序是否活跃并准备好了？</strong></h1><p id="9ca8" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">在Kubernetes中，您可以定义kubelet用来确定您的pod和应用程序是否健康的探针。</p><p id="d837" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有两种类型来确定这些事情，就绪性探测和活性探测。</p><p id="c2dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">准备就绪探测用于确定容器何时准备好接收流量。<br/>活性探测器用于确定容器是否健康或需要重启。</p><p id="dd37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些配置只需添加到部署yaml中，并且可以定制超时、重试和延迟。关于如何使用它们的更深入的解释，请阅读<a class="ae lh" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" rel="noopener ugc nofollow" target="_blank">本</a>。</p><h1 id="822e" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #8标签太阳底下的一切。</strong></h1><p id="b32c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">标签是Kubernetes的主要基础之一。它允许对象与其他对象松散耦合，还允许您基于标签进行查询。你甚至可以使用Kubernetes go客户端，根据标签观察事件。</p><p id="29b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用标签几乎可以做任何事情，但是同一个集群中的多个环境就是一个很好的例子。<br/>假设您为开发和qa使用同一个集群。这意味着你可能同时在<em class="lg"> qa </em>和<em class="lg"> dev </em>中运行app-a。要实现这一点，最简单的方法是服务对象，一个服务对象在app: app-a和environment: dev上选择标签，另一个服务对象在app: app-a上选择标签，但用qa切换dev。</p><p id="ac48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这为您提供了两个相同的应用程序，每个应用程序有不同的端点，允许同时进行测试。</p><h1 id="583a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #9收拾自己的烂摊子。</strong></h1><p id="d2d0" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Kubernetes是一个非常非常强大的系统，但像任何系统一样，它最终会陷入困境。kubelet必须完成你告诉它的每一项检查，同时完成自己的检查。</p><p id="a401" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，拥有一个不连接任何东西的服务不会使系统陷入困境，当然，kubernetes是为规模化而构建的。但是如果将一项服务扩大到数百万项，kubelet就会突然陷入困境。</p><p id="4a98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您出于任何原因删除了一个部署(或任何相关的东西),请确保您清理了所有其他东西，简单明了。</p><h1 id="22f9" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak"> #10你到底去不去老弟？</strong></h1><p id="6b91" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我把我最喜欢的留到了最后。去学围棋吧。Kubernetes建立在GO之上，所有的插件都建立在GO之上，他们甚至为GO编写了一个客户端。</p><p id="e2e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">client-go可以用来做各种有趣的事情。你可以根据自己的喜好用它来扩展kubernetes。想想数据收集、部署引擎或简单的清理应用程序。</p><p id="7310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">学习使用GO的客户端并在Kubernetes中使用它可能是我能给任何使用Kubernetes集群的人的最大建议。</p></div></div>    
</body>
</html>