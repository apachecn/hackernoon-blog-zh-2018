<html>
<head>
<title>Npm globals as local dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Npm全局作为本地依赖项</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/avoiding-the-npm-global-flag-in-package-json-based-projects-5a1e7a50706?source=collection_archive---------21-----------------------#2018-01-22">https://medium.com/hackernoon/avoiding-the-npm-global-flag-in-package-json-based-projects-5a1e7a50706?source=collection_archive---------21-----------------------#2018-01-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9c8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了方便起见，许多基于npm的开发工具<a class="ae jp" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">指导用户在全球范围内安装。如果该工具用于启动/创建一个项目，这是有意义的，但是许多这样的模块也用于一个现有的项目。这些应该作为本地(项目)依赖项安装，这有几个优点:</a></p><ul class=""><li id="67d1" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">使用中的版本与其他依赖项一起管理，使团队保持一致。这对于用于发布的构建工具尤其重要。遵循这一实践可以提高构建的可再现性，从而使<a class="ae jp" href="https://hackernoon.com/tagged/deployment" rel="noopener ugc nofollow" target="_blank">部署</a>和故障排除更加容易和可靠。</li><li id="8cce" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">新开发人员开始工作所需的步骤数量减少了，因为所有必要的工具都与其他项目依赖项一起安装。</li><li id="f7ee" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">一个模块的多个版本可以在同一台计算机上使用，例如，当处理多个使用该工具但不能同时升级的项目时。</li></ul><p id="f133" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种做法的一个小障碍是本地依赖项不能直接执行，因为它们的二进制文件存在于项目文件夹中。一种解决方法是将项目<code class="eh ke kf kg kh b">node_modules/.bin</code>文件夹添加到PATH中，但是不要这样做。首先，需要使用该命令的每个开发人员都需要这样做。</p><p id="ce85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个选择是给<em class="ki"> package.json </em>添加一个脚本来充当runner。例如，要使<code class="eh ke kf kg kh b">exp</code>在您的项目中作为命令可用，作为项目依赖项安装(使用<code class="eh ke kf kg kh b">--dev</code>)并添加脚本条目作为您的模块的运行程序:</p><pre class="kj kk kl km fq kn kh ko kp aw kq dt"><span id="fcc5" class="kr ks hu kh b fv kt ku l kv kw"># in package.json:<br/>"scripts": {<br/>  "exp": "exp"<br/>  ...<br/>}</span></pre><p id="bf3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ke kf kg kh b">exp</code>模块现在将在安装步骤中与其他模块一起安装，并且由于参数转发，开发人员可以使用npm运行任何子命令:</p><pre class="kj kk kl km fq kn kh ko kp aw kq dt"><span id="c09b" class="kr ks hu kh b fv kt ku l kv kw">$ npm run exp -- build:ios<br/>$ npm run exp -- build:status<br/>$ npm run exp -- publish</span></pre><p id="91fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果使用yarn，则不需要添加脚本条目。Yarn自动搜索<code class="eh ke kf kg kh b">node_modules/.bin</code>中的二进制文件，如果存在就使用它们。也不需要<code class="eh ke kf kg kh b">--</code>进行参数转发:</p><pre class="kj kk kl km fq kn kh ko kp aw kq dt"><span id="4159" class="kr ks hu kh b fv kt ku l kv kw">$ yarn exp build:ios<br/>$ yarn exp build:status<br/>$ yarn exp publish</span></pre><p id="5832" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加脚本条目作为常用命令的快捷方式可能仍然有用:</p><pre class="kj kk kl km fq kn kh ko kp aw kq dt"><span id="52e4" class="kr ks hu kh b fv kt ku l kv kw"># in package.json:<br/>"scripts": {<br/>  "publish: "exp publish"<br/>  ...<br/>}</span><span id="bb35" class="kr ks hu kh b fv kx ku l kv kw"># usage<br/>$ npm run publish<br/>$ yarn publish</span></pre><p id="b5bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如<a class="ky kz gr" href="https://medium.com/u/d79769cd010a?source=post_page-----5a1e7a50706--------------------------------" rel="noopener" target="_blank">凯文·基普</a>指出的，另一个选项现在是可用的，<a class="ae jp" href="http://blog.npmjs.org/post/162869356040/introducing-npx-an-npm-package-runner" rel="noopener ugc nofollow" target="_blank"> npx </a>，从npm 5.2.0开始，它与npm一起安装。用<code class="eh ke kf kg kh b">$ npx</code>而不是<code class="eh ke kf kg kh b">$ npm</code>调用命令将自动检查并运行本地依赖关系(如果存在的话):</p><pre class="kj kk kl km fq kn kh ko kp aw kq dt"><span id="24ae" class="kr ks hu kh b fv kt ku l kv kw">$ npm install --save-dev exp<br/>$ npx exp publish</span></pre><p id="df1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像yarn一样，本地依赖优于相同模块的全局版本。然而，Npx走得更远，它自动安装调用的软件包，这些软件包既不是本地安装的，也不是全局安装的。在我看来，这个特性不可避免地会引起一些混乱、意外和错误，这是令人遗憾的。</p><p id="29d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很高兴看到这种将所有东西都安装为本地依赖项的做法最终被社区所接受和支持。鉴于这些优势，我期待这成为标准做法。它需要一段时间才能流行起来，所以如果你是一个项目维护者，你的项目是指导用户全局安装，请考虑改变指令，使用通过npx或yarn调用的本地依赖。</p><figure class="kj kk kl km fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure></div></div>    
</body>
</html>