<html>
<head>
<title>hDebugging Memory Leaks in Node.js Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">hde bugging node . js应用程序中的内存泄漏</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/debugging-memory-leaks-in-node-js-applications-84125c0530d2?source=collection_archive---------22-----------------------#2018-01-22">https://medium.com/hackernoon/debugging-memory-leaks-in-node-js-applications-84125c0530d2?source=collection_archive---------22-----------------------#2018-01-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b245" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:我之前在<a class="ae jp" href="https://topt.al/cEQY" rel="noopener ugc nofollow" target="_blank">的博客</a>上发表了这篇文章。</p><p id="f06a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我曾经开过一辆内部搭载V8双涡轮增压发动机的奥迪，性能简直不可思议。凌晨3点，我在芝加哥附近的IL-80高速公路上以大约140英里的时速行驶，当时路上没有人。从那时起，术语“V8”就与我的高性能联系在一起。</p><p id="1af5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> Node.js </a>是一个基于Chrome的V8 <a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>引擎构建的平台，用于轻松构建快速且可扩展的网络应用。</p><p id="ee08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管奥迪的V8引擎非常强劲，但你仍然受到油箱容量的限制。Google的V8也是如此——node . js背后的JavaScript引擎。它的性能令人难以置信，这也是Node.js <a class="ae jp" href="https://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js" rel="noopener ugc nofollow" target="_blank">在许多用例</a>中运行良好的原因，但你总是会受到堆大小的限制。当需要在Node.js应用程序中处理更多请求时，有两种选择:垂直伸缩或水平伸缩。水平扩展意味着您必须运行更多的并发应用程序实例。如果做得好，你最终可以满足更多的请求。垂直伸缩意味着您必须提高应用程序的内存使用和性能，或者增加应用程序实例的可用资源。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/b27366211e1c2348fcf07d72fbe3a01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*3x30h2A8RSJXSQHY.jpg"/></div></figure><p id="38e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调试Node.js应用程序中的内存泄漏</p><p id="1e54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近，我被要求为我的一个顶级客户开发Node.js应用程序，以解决内存泄漏问题。该应用程序是一个API服务器，旨在每分钟能够处理数十万个请求。最初的应用程序占用了将近600MB的内存，因此我们决定采用热API端点并重新实现它们。当您需要服务于许多请求时，开销会变得非常昂贵。</p><p id="3490" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于新的API，我们选择了restify与原生MongoDB驱动程序和Kue进行后台作业。听起来像是一个非常轻量级的堆栈，对吗？不完全是。在高峰负载期间，一个新的应用程序实例可能会消耗高达270MB的RAM。因此，我每个1X Heroku Dyno有两个应用程序实例的梦想破灭了。</p><h1 id="9e25" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">Node.js内存泄漏调试工具</h1><h2 id="8043" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">记忆手表</h2><p id="74bc" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">如果您搜索“如何找到节点中的泄漏”，您可能会找到的第一个工具是<strong class="it hv"> memwatch </strong>。原来的包很久以前就被放弃了，不再维护。然而，你可以很容易地在GitHub的库的<a class="ae jp" href="https://github.com/lloyd/node-memwatch/network" rel="noopener ugc nofollow" target="_blank">分支列表中找到它的新版本。这个模块很有用，因为如果它发现堆在连续5次垃圾收集后增长，它可以发出泄漏事件。</a></p><h2 id="e92c" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">堆转储</h2><p id="77c8" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">这是一个伟大的工具，允许<a class="ae jp" href="https://www.toptal.com/node-js-development" rel="noopener ugc nofollow" target="_blank"> Node.js开发者</a>获取堆快照，并在以后用Chrome开发者工具检查它们。</p><h2 id="f893" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">节点检查器</h2><p id="b35a" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">甚至是heapdump更有用的替代方法，因为它允许您连接到正在运行的应用程序，进行堆转储，甚至动态地调试和重新编译它。</p><h1 id="f3f9" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">带着“节点检查器”兜一圈</h1><p id="1537" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">不幸的是，您将无法连接到在Heroku上运行的生产应用程序，因为它不允许向正在运行的进程发送信号。然而，Heroku并不是唯一的托管平台。</p><p id="1535" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了体验node-inspector的运行，我们将使用restify编写一个简单的Node.js应用程序，并在其中放置一点内存泄漏源。这里所有的实验都是用Node.js v0.12.7做的，这个版本是针对V8 v3.28.71.19编译的。</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="ea22" class="kw jz hu lq b fv lu lv l lw lx">var restify = require('restify');<br/><br/>var server = restify.createServer();<br/><br/>var tasks = [];<br/><br/>server.pre(function(req, res, next) {<br/>  tasks.push(function() {<br/>    return req.headers;<br/>  });<br/><br/>  // Synchronously get user from session, maybe jwt token<br/>  req.user = {<br/>    id: 1,<br/>    username: 'Leaky Master',<br/>  };<br/><br/>  return next();<br/>});<br/><br/>server.get('/', function(req, res, next) {<br/>  res.send('Hi ' + req.user.username);<br/>  return next();<br/>});<br/><br/>server.listen(3000, function() {<br/>  console.log('%s listening at %s', server.name, server.url);<br/>});</span></pre><p id="4090" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的应用程序非常简单，有一个非常明显的漏洞。数组<em class="ly">任务</em>会随着应用程序的生命周期而增长，导致它变慢并最终崩溃。问题是我们不仅泄漏了闭包，还泄漏了整个请求对象。</p><p id="1d6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">V8中的GC采用stop-the-world策略，因此这意味着内存中的对象越多，收集垃圾的时间就越长。在下面的日志中，您可以清楚地看到，在应用程序生命周期的开始，收集垃圾平均需要20毫秒，但是在几十万个请求之后，大约需要230毫秒。由于GC的原因，试图访问我们的应用程序的人将不得不等待<strong class="it hv">230毫秒</strong>更长时间。您还可以看到，每隔几秒钟就调用一次GC，这意味着每隔几秒钟用户就会遇到访问我们应用程序的问题。延迟将会增加，直到应用程序崩溃。</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="f1ee" class="kw jz hu lq b fv lu lv l lw lx">[28093] 7644 ms: Mark-sweep 10.9 (48.5) -&gt; 10.9 (48.5) MB, 25.0 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested]. [28093] 7717 ms: Mark-sweep 10.9 (48.5) -&gt; 10.9 (48.5) MB, 18.0 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested]. [28093] 7866 ms: Mark-sweep 11.0 (48.5) -&gt; 10.9 (48.5) MB, 23.2 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested]. [28093] 8001 ms: Mark-sweep 11.0 (48.5) -&gt; 10.9 (48.5) MB, 18.4 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested]. ... <br/>[28093] 633891 ms: Mark-sweep 235.7 (290.5) -&gt; 235.7 (290.5) MB, 357.3 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested]. [28093] 635672 ms: Mark-sweep 235.7 (290.5) -&gt; 235.7 (290.5) MB, 331.5 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested]. [28093] 637508 ms: Mark-sweep 235.7 (290.5) -&gt; 235.7 (290.5) MB, 357.2 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].</span></pre><p id="e056" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<em class="ly">–trace _ GC</em>标志启动Node.js应用程序时，会打印这些日志行:</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="66ee" class="kw jz hu lq b fv lu lv l lw lx">node --trace_gc app.js</span></pre><p id="e93d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们已经用这个标志启动了Node.js应用程序。在将应用程序与node-inspector连接之前，我们需要将SIGUSR1信号发送给正在运行的进程。如果在集群中运行Node.js，请确保连接到一个从属进程。</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="bcff" class="kw jz hu lq b fv lu lv l lw lx">kill -SIGUSR1 $pid # Replace $pid with the actual process ID</span></pre><p id="bee8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这样做，我们使Node.js应用程序(准确地说是V8)进入调试模式。在这种模式下，应用程序使用<a class="ae jp" href="https://code.google.com/p/v8-wiki/wiki/DebuggerProtocol" rel="noopener ugc nofollow" target="_blank"> V8调试协议</a>自动打开端口5858。</p><p id="ecfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的下一步是运行node-inspector，它将连接到正在运行的应用程序的调试接口，并在端口8080上打开另一个web接口。</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="c2f5" class="kw jz hu lq b fv lu lv l lw lx">$ node-inspector Node Inspector v0.12.2 Visit http://127.0.0.1:8080/?ws=127.0.0.1:8080&amp;port=5858 to start debugging.</span></pre><p id="1445" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果应用程序在生产环境中运行，并且您有防火墙，我们可以通过隧道将远程端口8080连接到本地主机:</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="053b" class="kw jz hu lq b fv lu lv l lw lx">ssh -L 8080:localhost:8080 admin@example.com</span></pre><p id="8959" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，你可以打开你的Chrome浏览器，完全访问远程生产应用程序附带的Chrome开发工具。不幸的是，Chrome开发者工具无法在其他浏览器上运行。</p><h1 id="53a3" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">我们去找个漏洞！</h1><p id="7b54" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">V8中的内存泄漏并不是我们从C/C++应用程序中了解到的真正的内存泄漏。在JavaScript中，变量不会凭空消失，它们只是被“遗忘”了。我们的目标是找到这些被遗忘的变量，提醒他们多比是自由的。</p><p id="e5e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Chrome开发者工具中，我们可以访问多个分析器。我们对<strong class="it hv">记录堆分配</strong>特别感兴趣，它随着时间的推移运行并拍摄多个堆快照。这让我们清楚地看到哪些物体正在泄漏。</p><p id="203b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开始记录堆分配，让我们使用Apache Benchmark在主页上模拟50个并发用户。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/d3a3d15ef234b4ae5f8c5d38e8ffc40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*yNknsPLa3bkrli4A.jpg"/></div></figure><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="da70" class="kw jz hu lq b fv lu lv l lw lx">ab -c 50 -n 1000000 -k <a class="ae jp" href="http://example.com/" rel="noopener ugc nofollow" target="_blank">http://example.com/</a></span></pre><p id="78ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在拍摄新快照之前，V8会执行标记-清除垃圾收集，因此我们肯定知道快照中没有旧垃圾。</p><h1 id="4316" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">快速修补漏洞</h1><p id="6bc4" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">在经过<strong class="it hv"> 3分钟</strong>的时间收集堆分配快照后，我们得到如下结果:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/a198bd1877923bf3a69d7bc2799fadf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*rU292IKSF2odA0wG.jpg"/></div></figure><p id="7f40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以清楚地看到，在堆中有一些巨大的数组、大量的传入消息、ReadableState、ServerResponse和域对象。让我们试着分析一下泄漏的来源。</p><p id="8b62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在图表上选择从20秒到40秒的堆差异时，我们将只看到从启动探查器起20秒后添加的对象。这样，您可以排除所有正常数据。</p><p id="9081" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意系统中每种类型有多少个对象，我们将过滤器从20秒扩展到1分钟。我们可以看到，已经相当庞大的阵列还在继续增长。在“(数组)”下面我们可以看到有很多距离相等的对象”(对象属性)。那些对象是我们内存泄漏的来源。</p><p id="9baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还可以看到“(闭包)”对象也在快速增长。</p><p id="3f44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看字符串可能也很方便。在字符串列表下面有很多“嗨，漏大师”的短语。那些也可能给我们一些线索。</p><p id="d999" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的例子中，我们知道字符串“Hi Leaky Master”只能在“GET /”路径下组装。</p><p id="d024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你打开retainers path，你会看到这个字符串通过<em class="ly"> req </em>被引用，然后上下文被创建，所有这些都被添加到一个巨大的闭包数组中。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/f9f5170aed1a435cc1a4f6f3cc8d460e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*PKaRtvI6258BO83y.jpg"/></div></figure><p id="a950" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以在这一点上，我们知道我们有某种巨大的闭包数组。让我们实际上在sources选项卡下为我们所有的闭包实时命名。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/6e0d290c2db214fe630870b6b00a8759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*6xMFRuUBHcXhNuBS.jpg"/></div></figure><p id="cd0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们编辑完代码后，我们可以按CTRL+S保存并重新编译代码！</p><p id="c03b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们记录另一个<strong class="it hv">堆分配快照</strong>，看看哪些闭包占用了内存。</p><p id="1a12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很明显<em class="ly">somethodofclojure()</em>是我们的反派。现在我们可以看到<em class="ly"> SomeKindOfClojure() </em>闭包被添加到全局空间中的某个名为<em class="ly"> tasks </em>的数组中。</p><p id="fb70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很容易看出这个数组就是没用。我们可以把它注释掉。但是我们如何释放已经被占用的内存呢？非常简单，我们只需将一个空数组分配给任务<em class="ly">和任务</em>，在下一次请求时，它将被覆盖，内存将在下一次GC事件后被释放。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/ba7e505d1a26e6a9c529e3c706d9a7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*7T7fDI1XTa_32Xva.jpg"/></div></figure><p id="ed48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">多比自由了！</p><h1 id="38bd" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">V8中的垃圾生活</h1><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/b06439807daadc9c33d164e89fe523f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*O_cY2za5upTf95tt.jpg"/></div></figure><p id="1c83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，V8 JS没有内存泄漏，只有被遗忘的变量。</p><p id="4c73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">V8堆被分成几个不同的空间:</p><ul class=""><li id="e7a5" class="ma mb hu it b iu iv iy iz jc mc jg md jk me jo mf mg mh mi dt translated"><strong class="it hv">新空间</strong>:这个空间比较小，大小在1MB到8MB之间。大多数对象都分配在这里。</li><li id="f888" class="ma mb hu it b iu mj iy mk jc ml jg mm jk mn jo mf mg mh mi dt translated"><strong class="it hv">旧指针空间</strong>:包含可能指向其他对象的对象。如果对象在新空间中存在足够长的时间，它将被提升到旧的指针空间。</li><li id="c63f" class="ma mb hu it b iu mj iy mk jc ml jg mm jk mn jo mf mg mh mi dt translated"><strong class="it hv">旧数据空间</strong>:仅包含原始数据，如字符串、装箱数和未装箱双精度数组。在新空间中经历了足够长时间的GC的对象也被移动到这里。</li><li id="4d20" class="ma mb hu it b iu mj iy mk jc ml jg mm jk mn jo mf mg mh mi dt translated"><strong class="it hv">大对象空间</strong>:在这个空间中创建太大而不适合其他空间的对象。每个对象在内存中都有自己的区域</li><li id="49a1" class="ma mb hu it b iu mj iy mk jc ml jg mm jk mn jo mf mg mh mi dt translated"><strong class="it hv">代码空间</strong>:包含JIT编译器生成的汇编代码。</li><li id="8ca8" class="ma mb hu it b iu mj iy mk jc ml jg mm jk mn jo mf mg mh mi dt translated"><strong class="it hv">单元空间、属性单元空间、映射空间</strong>:该空间包含<code class="eh mo mp mq lq b">Cell</code>、<code class="eh mo mp mq lq b">PropertyCell</code>和<code class="eh mo mp mq lq b">Map</code> s，用于简化垃圾收集。</li></ul><p id="9070" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个空间都由页面组成。页面是操作系统用mmap分配的内存区域。除了大对象空间中的页面之外，每个页面的大小始终是1MB。</p><p id="3795" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">V8有两个内置的垃圾收集机制:清除、标记-清除和标记-压缩。</p><p id="3b6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">清除是一种非常快速的垃圾收集技术，它对<strong class="it hv">新空间</strong>中的对象进行操作。Scavenge是<a class="ae jp" href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm" rel="noopener ugc nofollow" target="_blank">切尼算法</a>的实现。这个想法很简单，<strong class="it hv">新空间</strong>被分成两个相等的半空间:To-Space和From-Space。当To空间已满时，会发生清除GC。它只是简单地交换空间，将所有活的物体复制到目标空间，或者将它们提升到旧空间，如果它们在两个拾荒者中幸存的话，然后从空间中完全清除。清道夫的速度非常快，但是他们的开销是保持双倍大小的堆，并且不断地在内存中复制对象。使用清道夫的原因是因为大多数对象在年轻时就死亡了。</p><p id="aa88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Mark-Sweep &amp; Mark-Compact是V8中使用的另一种垃圾收集器。另一个名字是完全垃圾收集器。它标记所有活动节点，然后清除所有不活动节点并整理内存碎片。</p><h1 id="9395" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">GC性能和调试技巧</h1><p id="4e6d" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">虽然对于web应用程序来说，高性能可能不是一个大问题，但是您仍然希望不惜一切代价避免泄漏。在完全GC的标记阶段，应用程序实际上是暂停的，直到垃圾收集完成。这意味着堆中的对象越多，执行GC的时间就越长，用户等待的时间也就越长。</p><h2 id="2cc4" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">总是给闭包和函数起名字</h2><p id="9a38" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">当所有的闭包和函数都有名字时，检查堆栈跟踪和堆就容易多了。</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="c791" class="kw jz hu lq b fv lu lv l lw lx">db.query('GIVE THEM ALL', function GiveThemAllAName(error, data) {<br/>    ...<br/>})</span></pre><h2 id="2769" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">避免热函数中的大对象</h2><p id="0b3b" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">理想情况下，您希望避免热函数中的大对象，以便所有数据都适合新空间<strong class="it hv"/>。所有CPU和内存限制的操作都应该在后台执行。还要避免热函数的去优化触发，优化的热函数比非优化的热函数使用更少的内存。</p><h2 id="dc68" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">热功能应该被优化</h2><p id="5be2" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">运行速度更快但消耗内存更少的热函数导致GC运行的频率更低。V8提供了一些有用的调试工具来发现非优化函数或去优化函数。</p><h2 id="85a7" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">避免热函数中IC的多态性</h2><p id="297f" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">内联缓存(IC)用于加速一些代码块的执行，或者通过缓存对象属性访问<code class="eh mo mp mq lq b">obj.key</code>或者一些简单的函数。</p><pre class="jr js jt ju fq lp lq lr ls aw lt dt"><span id="f9d1" class="kw jz hu lq b fv lu lv l lw lx">function x(a, b) {<br/>  return a + b;<br/>}<br/><br/>x(1, 2); // monomorphic<br/>x(1, “string”); // polymorphic, level 2<br/>x(3.14, 1); // polymorphic, level 3</span></pre><p id="de62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一次运行<em class="ly"> x(a，b) </em>时，V8创建一个单态ic。当您第二次调用<code class="eh mo mp mq lq b">x</code>时，V8删除旧的ic并创建一个新的多态IC，它支持整数和字符串两种类型的操作数。当您第三次调用ic时，V8重复相同的过程，并创建另一个3级多态IC。</p><p id="a9d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，有一个限制。在IC等级达到5(可以用<em class="ly">–max _ inlining _ levels</em>标志改变)后，函数变成巨型函数，不再被认为是可优化的。</p><p id="82bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以直观地理解，单态函数运行速度最快，内存占用也较小。</p><h2 id="66b2" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">不要将大文件添加到内存中</h2><p id="f60f" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">这是显而易见的，众所周知的。如果您有大文件要处理，例如一个大的CSV文件，请逐行读取并分块处理，而不是将整个文件加载到内存中。在极少数情况下，一行csv会大于1mb，因此您可以将其放入新的空间。</p><h2 id="0b1c" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">不要阻塞主服务器线程</h2><p id="06a9" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">如果你有一些热的API需要一些时间来处理，比如一个调整图像大小的API，把它移到一个单独的线程或者变成一个后台作业。CPU密集型操作会阻塞主线程，迫使所有其他客户等待并继续发送请求。未处理的请求数据会堆积在内存中，从而迫使完整的GC花费更长的时间来完成。</p><h2 id="b3e9" class="kw jz hu bd ka kx ky kz ke la lb lc ki jc ld le km jg lf lg kq jk lh li ku lj dt translated">不要创建不必要的数据</h2><p id="fca9" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">我曾经有过一次restify的怪异经历。如果您向一个无效的URL发送几十万个请求，那么应用程序内存将迅速增长到几百兆字节，直到几秒钟后一个完整的GC启动，这时一切将恢复正常。原来，对于每个无效的URL，restify都会生成一个新的错误对象，其中包含长堆栈跟踪。这迫使新创建的对象被分配到<strong class="it hv">大对象空间</strong>，而不是<strong class="it hv">新空间</strong>。</p><p id="6f9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">访问这些数据在开发过程中非常有用，但在生产中显然不是必需的。因此，规则很简单——除非确实需要，否则不要生成数据。</p><p id="ab16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，但肯定不是最不重要的，是了解你的工具。有各种调试器、泄漏导管和使用图生成器。所有这些工具都可以帮助你使你的软件更快更有效。</p><h1 id="06b8" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">结论</h1><p id="8d93" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">理解V8的垃圾收集和代码优化器是应用程序性能的关键。V8将JavaScript编译为本机汇编，在某些情况下，编写良好的代码可以获得与GCC编译的应用程序相当的性能。</p><p id="3f67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想知道，我的Toptal客户端的新API应用程序，尽管还有改进的空间，但工作得非常好！</p><p id="050b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Joyent最近发布了Node.js的新版本，它使用了最新版本的V8。一些为Node.js v0.12.x编写的应用程序可能与新的v4.x版本不兼容。然而，在Node.js的新版本中，应用程序将体验到巨大的性能和内存使用改进</p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="3fb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ly">最初发表于</em><a class="ae jp" href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications" rel="noopener ugc nofollow" target="_blank"><em class="ly">www.toptal.com</em></a><em class="ly">。</em></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>