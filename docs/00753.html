<html>
<head>
<title>Diamond kata via property-based TDD in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过JavaScript中基于属性的TDD实现钻石形</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/diamond-kata-via-property-based-tdd-in-javascript-5fa99acd3e62?source=collection_archive---------13-----------------------#2018-01-24">https://medium.com/hackernoon/diamond-kata-via-property-based-tdd-in-javascript-5fa99acd3e62?source=collection_archive---------13-----------------------#2018-01-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f3405ebdeba94b7e48bda8a8836cbc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rL0yzvyFg-E1IVcTYSLTtA.png"/></div></div></figure><p id="3b60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在之前的文章中，我已经介绍了基于属性的测试背后的基本思想。在这里，我将使用这种技术来TDD钻石形。</p><p id="96c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该帖子受到了大量的启发(即公然抄袭)。所以一定要去和做同样练习的Nat Pryce和Mark Seemann打招呼[1][2](参考资料底部的链接)。幸运的是，我将使用JavaScript和<a class="ae ka" href="https://github.com/jsverify/jsverify" rel="noopener ugc nofollow" target="_blank"> JSVerify </a>。这样我就可以把自己藏在“但是我使用了不同的堆栈”的借口后面。</p><p id="5422" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，我会尽量减少代码片段。如果你对更多细节感兴趣，请随时查看<a class="ae ka" href="https://github.com/3v0k4/diamond-kata" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><h2 id="8d06" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">钻石形</h2><p id="3d4b" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">以及Seb Rose 描述的<a class="ae ka" href="http://claysnow.co.uk/recycling-tests-in-tdd/" rel="noopener ugc nofollow" target="_blank">，问题陈述如下:</a></p><blockquote class="lb lc ld"><p id="775c" class="jc jd le je b jf jg jh ji jj jk jl jm lf jo jp jq lg js jt ju lh jw jx jy jz hn dt translated">给定一个字母，打印一个以“A”开始的菱形，所提供的字母在最宽处。</p></blockquote><p id="b195" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几个例子是</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="8f68" class="kb kc hu ln b fv lr ls l lt lu">Input: A<br/>Output: A<br/><br/>Input: B<br/>Output:   A<br/>         B B<br/>          A<br/><br/>Input: C<br/>Output:   A<br/>         B B<br/>        C   C<br/>         B B<br/>          A</span></pre><h2 id="69b3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">准备，开始，摇滚</h2><p id="6227" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">在<code class="eh lv lw lx ln b">init</code>提交中，我想检查接线。这就是为什么我使用一个总是返回<code class="eh lv lw lx ln b">5</code>的生成器来检查<code class="eh lv lw lx ln b">isFive</code>属性。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="fcc4" class="kb kc hu ln b fv lr ls l lt lu">// index.test.js</span><span id="285a" class="kb kc hu ln b fv ly ls l lt lu">const jsc = require('jsverify')<br/>const mocha = require('mocha')<br/>const isFive = require('./index')</span><span id="cf12" class="kb kc hu ln b fv ly ls l lt lu">describe('TODO', () =&gt; {<br/>  jsc.property('TODO', jsc.constant(5), isFive)<br/>})<br/></span><span id="991b" class="kb kc hu ln b fv ly ls l lt lu">// index.js</span><span id="1dee" class="kb kc hu ln b fv ly ls l lt lu">const isFive = number =&gt; number === 5<br/>module.exports = isFive</span></pre><p id="d4b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这当然是绿色的</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="b7ae" class="kb kc hu ln b fv lr ls l lt lu">$ mocha index.test.js</span><span id="6399" class="kb kc hu ln b fv ly ls l lt lu">TODO<br/>    ✓ TODO</span><span id="dfe5" class="kb kc hu ln b fv ly ls l lt lu">1 passing (12ms)</span><span id="56eb" class="kb kc hu ln b fv ly ls l lt lu">✨  Done in 0.52s.</span></pre><h2 id="1297" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">发电机</h2><p id="d4b7" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">一切正常，因此我可以创建钻石形的发电机。特别是，我需要生成<code class="eh lv lw lx ln b">A..Z</code>范围内的字符。</p><p id="0654" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我不确定使用什么，我决定检查一下<code class="eh lv lw lx ln b">jsc.asciichar</code>生成器返回什么</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="087c" class="kb kc hu ln b fv lr ls l lt lu">const debug = x =&gt; {<br/>  console.log(x)<br/>  return true<br/>}<br/><br/>describe('diamond', () =&gt; {<br/>  jsc.property('TODO', jsc.asciichar, debug)<br/>})</span></pre><p id="ffcc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意<code class="eh lv lw lx ln b">return true</code>。这样,“property”<code class="eh lv lw lx ln b">debug</code>永远不会失败，我可以检查所有生成的asciichar。因为默认情况下，JSVerify通过从生成器生成100个输入来检查属性100次，我明白了</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="d6c7" class="kb kc hu ln b fv lr ls l lt lu">$ mocha index.test.js</span><span id="9b16" class="kb kc hu ln b fv ly ls l lt lu">diamond<br/>T<br/>K<br/>.<br/>E</span><span id="d2fe" class="kb kc hu ln b fv ly ls l lt lu">B<br/>&lt;<br/>// ... up to 100 asciichars</span><span id="9b2e" class="kb kc hu ln b fv ly ls l lt lu">    ✓ TODO</span><span id="33f7" class="kb kc hu ln b fv ly ls l lt lu">1 passing (16ms)</span><span id="c2ca" class="kb kc hu ln b fv ly ls l lt lu">✨  Done in 0.52s.</span></pre><p id="ad4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不完全正确，事实上，我只需要在<code class="eh lv lw lx ln b">A..Z</code>范围内生成字符。不幸的是，JSVerify没有提供任何满足该约束的现成生成器。因此，我创建了一个自定义的</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="d58b" class="kb kc hu ln b fv lr ls l lt lu">const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')<br/>const char = jsc.suchthat(jsc.asciichar, c =&gt; alphabet.includes(c))<br/><br/>describe('diamond', () =&gt; {<br/>  jsc.property('TODO', char, debug)<br/>})</span></pre><p id="2e8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这次我们得到了正确的值</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="6d12" class="kb kc hu ln b fv lr ls l lt lu">$ mocha index.test.js</span><span id="0371" class="kb kc hu ln b fv ly ls l lt lu">diamond<br/>B<br/>L<br/>X<br/>B<br/>Q<br/>V<br/>X<br/>B<br/>J<br/>S<br/>C<br/>P<br/>I<br/>// ... up to 100 chars in A..Z</span><span id="6161" class="kb kc hu ln b fv ly ls l lt lu">    ✓ TODO</span><span id="27ab" class="kb kc hu ln b fv ly ls l lt lu">1 passing (19ms)</span><span id="7e83" class="kb kc hu ln b fv ly ls l lt lu">✨  Done in 0.52s.</span></pre><p id="1c32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我本可以将支票移到房产内部</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="dbc1" class="kb kc hu ln b fv lr ls l lt lu">const property = c =&gt; {<br/>  if (!alphabet.includes(c)) return true<br/>  // ... test the property<br/>}</span><span id="0910" class="kb kc hu ln b fv ly ls l lt lu">describe('diamond', () =&gt; {<br/>  jsc.property('TODO', jsc.asciichar, property)<br/>})</span></pre><p id="d87a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我会犯一个错误。事实上，在这种情况下，JSVerify会用随机的<code class="eh lv lw lx ln b">jsc.asciichar</code>调用<code class="eh lv lw lx ln b">property</code> 100次，因此，只有一部分生成的输入会通过<code class="eh lv lw lx ln b">if</code>。换句话说，我会失去测试覆盖率。</p><h2 id="c83f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:钻石不是空的</h2><p id="474b" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">开始练习的属性只是检查菱形对于任何字符的长度不为0。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="9545" class="kb kc hu ln b fv lr ls l lt lu">jsc.property('is not empty', char, c =&gt; make(c).length !== 0)</span></pre><p id="6dd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用它来变绿</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="98ba" class="kb kc hu ln b fv lr ls l lt lu">const make = char =&gt; 'whatever'</span></pre><p id="58b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来自REPL</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="61cd" class="kb kc hu ln b fv lr ls l lt lu">make(c) // for any c<br/>// =&gt; 'whatever'</span></pre><h2 id="9077" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:第一行包含一个</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="2104" class="kb kc hu ln b fv lr ls l lt lu">jsc.property(<br/>  'first row contains A',<br/>  char,<br/>  c =&gt; firstRow(make(c)).trim() === 'A'<br/>)</span></pre><p id="f838" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用它来变绿</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="bc80" class="kb kc hu ln b fv lr ls l lt lu">const make = char =&gt; '        A       ' // padding is asymmetric</span></pre><p id="05be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来自REPL</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="cc60" class="kb kc hu ln b fv lr ls l lt lu">make(c) // for any c<br/>// =&gt; '        A       '</span></pre><h2 id="c2aa" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:最后一行包含一个</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="72bc" class="kb kc hu ln b fv lr ls l lt lu">jsc.property(<br/>  'last row contains A',<br/>  char,<br/>  c =&gt; lastRow(make(c)).trim() === 'A'<br/>)</span></pre><p id="f04a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">已经是绿色的了。</p><h2 id="2493" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:第一行具有对称轮廓</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="c4ac" class="kb kc hu ln b fv lr ls l lt lu">const firstRowHasSymmetricalContour = diamond =&gt; {<br/>  const leadingElements = leading('A', firstRow(diamond)).length<br/>  const trailingElements = trailing('A', firstRow(diamond)).length<br/>  return leadingElements === trailingElements<br/>}</span><span id="870c" class="kb kc hu ln b fv ly ls l lt lu">jsc.property(<br/>  ‘first row has symmetrical contour’,<br/>  char,<br/>  c =&gt; firstRowHasSymmetricalContour(make(c))<br/>)</span></pre><p id="80cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用它来变绿</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="2a12" class="kb kc hu ln b fv lr ls l lt lu">const make = char =&gt; '       A       ' // padding is symmetric</span></pre><p id="7a5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来自REPL</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="cb21" class="kb kc hu ln b fv lr ls l lt lu">make(c) // for any c<br/>// =&gt; '       A       '</span></pre><h2 id="3028" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:行具有对称的轮廓</h2><p id="b5fa" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">不仅第一排有对称的轮廓。让我们修改属性，以便检查所有的行</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="7faa" class="kb kc hu ln b fv lr ls l lt lu">const rowsHaveSymmetricalContour = diamond =&gt;<br/>  diamond<br/>  .split('\n')<br/>  .map(rowHasSymmetricalContour)<br/>  .reduce((acc, x) =&gt; acc &amp;&amp; x) // [].every would be better here</span><span id="44d7" class="kb kc hu ln b fv ly ls l lt lu">jsc.property(<br/>  'rows have symmetrical contour',<br/>  char,<br/>  c =&gt; rowsHaveSymmetricalContour(make(c))<br/>)</span></pre><p id="a77e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">已经是绿色的了。</p><h2 id="53ea" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:行包含正确的字母</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="3960" class="kb kc hu ln b fv lr ls l lt lu">const rowsContainsCorrectLetters = (char, diamond) =&gt; {<br/>  const pre = alphabetUntilBefore(char)<br/>  const post = pre.slice().reverse()<br/>  const expected = pre.concat([char]).concat(post)<br/>  const actual = diamond.split('\n').map(row =&gt; row.trim())<br/>  return expected.join() === actual.join()<br/>}</span><span id="13a1" class="kb kc hu ln b fv ly ls l lt lu">jsc.property(<br/>  ‘rows contains the correct letters’,<br/>  char,<br/>  c =&gt; rowsContainsCorrectLetters(c, make(c))<br/>)</span></pre><p id="47af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用它来变绿</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="1a59" class="kb kc hu ln b fv lr ls l lt lu">const make = char =&gt; {<br/>  const pre = alphabetUntilBefore(char)<br/>  const post = pre.slice().reverse()<br/>  const chars = pre.concat([char]).concat(post)<br/>  return chars.join('\n')<br/>}</span></pre><p id="aa45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">测试和生产代码之间的重复是一个不好的味道。但是我决定把它留在那里。</p><p id="e4cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来自REPL</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="9dfc" class="kb kc hu ln b fv lr ls l lt lu">make('C')<br/>// =&gt; 'A\nB\nC\nB\nA'</span></pre><h2 id="474e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:行的宽度与高度相同</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="9aae" class="kb kc hu ln b fv lr ls l lt lu">const rowsAreAsWideAsHigh = diamond =&gt; {<br/>  const height = rows(diamond).length<br/>  return all(rows(diamond).map(hasLength(height)))<br/>}</span><span id="28dd" class="kb kc hu ln b fv ly ls l lt lu">jsc.property(<br/>  'rows are as wide as high',<br/>  char,<br/>  c =&gt; rowsAreAsWideAsHigh(make(c))<br/>)</span></pre><p id="ac30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用它来变绿</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="7418" class="kb kc hu ln b fv lr ls l lt lu">const makeRow = width =&gt; char =&gt; {<br/>  if (char === 'A') {<br/>    const padding = ' '.repeat(width / 2)<br/>    return `${padding}A${padding}`<br/>  } else {<br/>    return char.repeat(width)<br/>  }<br/>}</span><span id="b35c" class="kb kc hu ln b fv ly ls l lt lu">const make = char =&gt; {<br/>  const pre = alphabetUntilBefore(char)<br/>  const post = pre.slice().reverse()<br/>  const chars = pre.concat([char]).concat(post)<br/>  return chars.map(makeRow(chars.length)).join('\n')<br/>}</span></pre><p id="8117" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有来自REPL的</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="f84b" class="kb kc hu ln b fv lr ls l lt lu">make('C')<br/>// =&gt; '  A  \nBBBBB\nCCCCC\nBBBBB\n  A  '</span></pre><h2 id="05d1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:除了顶部和底部的行有两个相同的字母</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="73f5" class="kb kc hu ln b fv lr ls l lt lu">jsc.property(<br/>  'rows except top and bottom have two identical letters',<br/>  char,<br/>  c =&gt; internalRowsHaveTwoIdenticalLetters(make(c))<br/>)</span></pre><p id="bb60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用它来变绿</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="166a" class="kb kc hu ln b fv lr ls l lt lu">const makeRow = width =&gt; char =&gt; {<br/>  if (char === 'A') {<br/>   const padding = ' '.repeat(width / 2)<br/>   return `${padding}A${padding}`<br/>  } else {<br/>    const padding = ' '.repeat(width - 2)<br/>    return `${char}${padding}${char}`<br/>  }<br/>}</span><span id="f700" class="kb kc hu ln b fv ly ls l lt lu">const make = char =&gt; {<br/>  const pre = alphabetUntilBefore(char)<br/>  const post = pre.slice().reverse()<br/>  const chars = pre.concat([char]).concat(post)<br/>  return chars.map(makeRow(chars.length)).join('\n')<br/>}</span></pre><p id="a910" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有来自REPL的</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="c9c3" class="kb kc hu ln b fv lr ls l lt lu">make('C')<br/>// =&gt; '  A  \nB   B\nC   C\nB   B\n  A  '</span></pre><h2 id="d745" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:行具有正确的内部空间量</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="99dd" class="kb kc hu ln b fv lr ls l lt lu">jsc.property(<br/>  'rows have the correct amount of internal spaces',<br/>  char,<br/>  c =&gt; rowsHaveCorrectAmountOfInternalSpaces(make(c))<br/>)</span></pre><p id="ac7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用它来变绿</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="8fef" class="kb kc hu ln b fv lr ls l lt lu">const internalPaddingFor = char =&gt; {<br/>  const index = alphabet.indexOf(char)<br/>  return Math.max((index * 2) - 1, 0)<br/>}</span><span id="3565" class="kb kc hu ln b fv ly ls l lt lu">const makeRow = width =&gt; char =&gt; {<br/>   if (char === 'A') {<br/>     const padding = ' '.repeat(width / 2)<br/>     return `${padding}A${padding}`<br/>   } else {<br/>     const internalSpaces = internalPaddingFor(char)<br/>     const internalPadding = ' '.repeat(internalSpaces)<br/>     const externalSpaces = width - 2 - internalSpaces<br/>     const externalPadding = ' '.repeat(externalSpaces / 2)<br/>     return `${externalPadding}${char}${internalPadding}${char}${externalPadding}`<br/>   }<br/>}</span><span id="84b4" class="kb kc hu ln b fv ly ls l lt lu">const make = char =&gt; {<br/>  const pre = alphabetUntilBefore(char)<br/>  const post = pre.slice().reverse()<br/>  const chars = pre.concat([char]).concat(post)<br/>  return chars.map(makeRow(chars.length)).join('\n')<br/>}</span></pre><p id="b765" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有来自REPL的</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="22e8" class="kb kc hu ln b fv lr ls l lt lu">make('C')<br/>'  A  \n B B \nC   C\n B B \n  A  '</span></pre><p id="46e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，<code class="eh lv lw lx ln b">rowsHaveCorrectAmountOfInternalSpaces</code>在测试中使用了以下内容</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="796c" class="kb kc hu ln b fv lr ls l lt lu">const index = alphabet.indexOf(char)<br/>return Math.max((index * 2) - 1, 0)</span></pre><p id="be74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不喜欢这种重复。因此，我决定测试外部空间(而不是内部空间)。</p><h2 id="092a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">属性:行具有正确数量的外部空格</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="8e35" class="kb kc hu ln b fv lr ls l lt lu">jsc.property(<br/>  'rows have the correct amount of external spaces',<br/>  char,<br/>  c =&gt; rowsHaveCorrectAmountOfExternalSpaces(make(c))<br/>)</span></pre><p id="5df6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这次<code class="eh lv lw lx ln b">rowsHaveCorrectAmountOfExternalSpaces</code>在内部使用了不同的计算方法:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="0eb6" class="kb kc hu ln b fv lr ls l lt lu">const index = alphabet.indexOf(char)<br/>return ((width - 1) / 2 - index) * 2</span></pre><p id="7388" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着我已经删除了重复。此外，测试已经是绿色的，因为内部空间的生产代码也考虑到了外部空间。</p><h2 id="de54" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">和..我们完了</h2><p id="c831" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">如上所示，上次REPL测试给了我们</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="86cd" class="kb kc hu ln b fv lr ls l lt lu">make('C')<br/>// =&gt; '  A  \n B B \nC   C\n B B \n  A  '</span></pre><p id="61aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="a9ad" class="kb kc hu ln b fv lr ls l lt lu">  A  <br/> B B<br/>C   C<br/> B B<br/>  A  </span></pre><p id="3a23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些都是我发现的特性:</p><ul class=""><li id="72da" class="lz ma hu je b jf jg jj jk jn mb jr mc jv md jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">is not empty</code></li><li id="6e9c" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">first row contains A</code></li><li id="58f9" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">last row contains A</code></li><li id="2082" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">rows have symmetrical contour</code></li><li id="75eb" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">rows contain the correct letters</code></li><li id="eac5" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">rows are as wide as high</code></li><li id="c873" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">rows except top and bottom have two identical letters</code></li><li id="727d" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated"><code class="eh lv lw lx ln b">rows have the correct amount of external spaces</code></li></ul><h2 id="6175" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">结尾部分</h2><p id="79f0" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">我注意到的第一件事是基于属性的TDD让你思考起来有多困难。事实上，想出这个形的例子真的很容易。但是不变量就不一样了。</p><p id="b477" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同时，知道你的问题空间有什么性质，也就意味着对它有了深入的了解。对于基于属性的TDD，有必要在编写实际的产品代码之前发现它们。</p><p id="6138" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不仅如此，我发现自己写了一个和以前冲突的属性。事实上，使它变成绿色的代码，也使一些现有的代码变成红色。钻石形是一个简单的练习，但这在我们日常工作中经常发生。</p><p id="94e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，我已经从一般属性开始建立了自己的方式，然后是专门化的(即<code class="eh lv lw lx ln b">diamond is not empty</code>到<code class="eh lv lw lx ln b">rows have the correct amount of external spaces</code>)。这与基于实例的TDD的情况相反:从特定到一般[3]。</p><p id="eff2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，我不能和基于例子的TDD相比，因为我没有那样尝试过形。如果你对此感兴趣，请查阅参考资料。</p><h2 id="3813" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">参考</h2><ol class=""><li id="2042" class="lz ma hu je b jf kw jj kx jn mn jr mo jv mp jz mq mf mg mh dt translated"><a class="ae ka" href="http://blog.ploeh.dk/2015/01/10/diamond-kata-with-fscheck/" rel="noopener ugc nofollow" target="_blank">带FsCheck的钻石形</a>作者马克·西曼</li><li id="2b64" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz mq mf mg mh dt translated"><a class="ae ka" href="http://natpryce.com/articles/000807.html" rel="noopener ugc nofollow" target="_blank">钻石卡塔—仅基于属性测试的TDD</a></li><li id="b71e" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz mq mf mg mh dt translated"><a class="ae ka" href="http://natpryce.com/articles/000809.html" rel="noopener ugc nofollow" target="_blank">钻石形——对渐进式发展的思考</a>作者:纳特·普莱斯</li></ol><h2 id="8f7f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">更多指针</h2><ul class=""><li id="8e6a" class="lz ma hu je b jf kw jj kx jn mn jr mo jv mp jz me mf mg mh dt translated"><a class="ae ka" href="http://natpryce.com/articles/000802.html" rel="noopener ugc nofollow" target="_blank">Nat pry ce在SPA 2013 </a>举办的基于酒店的TDD</li></ul></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="e3ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从我个人的电子邮件中获取最新内容。用你的想法回复。让我们互相学习。订阅我的<a class="ae ka" href="https://odone.io#newsletter" rel="noopener ugc nofollow" target="_blank"> PinkLetter </a>！</p></div></div>    
</body>
</html>