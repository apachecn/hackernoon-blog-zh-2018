<html>
<head>
<title>Be a Happier Programmer with sed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用sed做一个更快乐的程序员</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/be-a-happier-programmer-with-sed-cc540e0b58d3?source=collection_archive---------26-----------------------#2018-01-24">https://medium.com/hackernoon/be-a-happier-programmer-with-sed-cc540e0b58d3?source=collection_archive---------26-----------------------#2018-01-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="557c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，我承认这个标题有点争议。然而，在这个经典的命令行工具为我节省了几个小时的重复工作之后，我觉得有必要说一下。</p><h2 id="51a6" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">理想的用例</h2><p id="2d0c" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在早期的TypeScript中，字符串枚举是不存在的。然而，有几种不同的解决方法可以实现类似的目标。我的公司在内部使用的变体包括创建一个具有许多返回字符串值的静态getters的类。举个例子，</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="c666" class="jp jq hu ku b fv ky kz l la lb">export class BillingMethod {<br/>  static get Cash() { return 'cash'; }<br/>  static get Check() { return 'check'; }<br/>  static get CreditCard() { return 'credit card'; }<br/>}</span><span id="234c" class="jp jq hu ku b fv lc kz l la lb">// Usage:<br/>const billingMethod = BillingMethod.Cash;</span></pre><p id="f8d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个方法提供了传统枚举的大部分好处，但是它错过了枚举的最大优势:为数据结构提供适当的类型支持。上述每个getter函数都返回一个字符串，而不是一个自定义类型。</p><p id="fe0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当TypeScript 2.4宣布<a class="ae ld" href="https://blogs.msdn.microsoft.com/typescript/2017/06/27/announcing-typescript-2-4/" rel="noopener ugc nofollow" target="_blank">字符串枚举支持</a>时，很明显重构对于在我们的应用程序中实现正确的类型是必要的。但是我们如何将数百个导出的类替换为它们的枚举对应类呢？</p><p id="d43f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答案当然是sed。通过一个简单的脚本，我们可以将原始的、模仿的enum变成真实的enum:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="c2da" class="jp jq hu ku b fv ky kz l la lb">sed \<br/> -i \<br/> -e 's/class/enum/' \<br/> -e 's/static get //' \<br/> -e 's/() { return/ =/' \<br/> -e 's/; }/,/' \<br/> ./billing-method.ts</span></pre><p id="5968" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">产出:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="64c5" class="jp jq hu ku b fv ky kz l la lb">export enum BillingMethod {<br/>  Cash = 'cash',<br/>  Check = 'check',<br/>  CreditCard = 'credit card',<br/>}</span></pre><p id="a339" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过将目的地更改为<code class="eh le lf lg ku b">./constants/*.ts</code>将脚本应用于TypeScript文件的文件夹，我们已经成功地重构了应用程序中的每个枚举。</p><h2 id="e217" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">分解它</h2><p id="344c" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">如果我们只是快速浏览一下，Sed的语法看起来难以理解。然而，只需要大约十五分钟的实验，就可以把它变成最强大的重构工具之一。</p><p id="2e83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是上述程序中使用的关键词的概要:</p><ul class=""><li id="fd10" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">sed</code>:可执行程序的名称(流编辑器的简称)。</li><li id="5116" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">\</code>:换行字符。上面的脚本可以全部写在一行中——用反斜杠将它分开可以提供更好的可读性。</li><li id="3f95" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">-i</code>:“在文件中”的简称。如果提供了这个标志，sed将用您的编辑替换它所解析的文件的内容。通过关闭此选项，我们可以在编辑实际影响生产代码之前查看它的“预览”。</li><li id="2a06" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">-e</code>:“表达式”的简称，提供了我们的编辑操作。因为我们想要多次编辑同一个文件，所以我们使用<code class="eh le lf lg ku b">-e</code>来提供多次编辑。</li><li id="0f1b" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">'s/class/enum/'</code>:编辑的肉，传入<code class="eh le lf lg ku b">-e</code>标志。解释为:<code class="eh le lf lg ku b">'s/&lt;replace this content&gt;/&lt;with this content&gt;/'</code>。请注意，您可以将内容指定为纯文本(正如我在这里所做的那样)，也可以指定为正则表达式。</li><li id="0b4f" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">./billing-method.ts</code>:我们正在编辑的文件。这也可以是一个目录。例如，<code class="eh le lf lg ku b">./constants/*.ts</code>编辑<code class="eh le lf lg ku b">constants/</code>目录中的所有类型脚本文件。</li></ul><p id="3535" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们来看看每个表情:</p><ul class=""><li id="f379" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">‘s/class/enum/’</code>:将<code class="eh le lf lg ku b">class</code>替换为<code class="eh le lf lg ku b">enum</code></li><li id="65a6" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">‘s/static get //’</code>:移除<code class="eh le lf lg ku b">static get</code></li><li id="4d61" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">‘s/() { return/ =/’</code>:将<code class="eh le lf lg ku b">() { return</code>更换为<code class="eh le lf lg ku b">=</code>(间隔适当)</li><li id="75d1" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><code class="eh le lf lg ku b">'s/; }/,/'</code>:将<code class="eh le lf lg ku b">; }</code>替换为<code class="eh le lf lg ku b">,</code></li></ul><p id="2512" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当sed的语法被分解时，它既简单又富于表现力。尽管这是一个简单的用例，但它可以应用于各种各样的代码重构。</p><p id="9c83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这个工具能为你节省和我一样多的时间。</p><h2 id="3e06" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">进一步阅读</h2><ul class=""><li id="0032" class="lh li hu it b iu kk iy kl jc lv jg lw jk lx jo lm ln lo lp dt translated"><a class="ae ld" href="https://www.gnu.org/software/sed/manual/sed.html" rel="noopener ugc nofollow" target="_blank"> GNU手册</a></li><li id="0d9c" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated"><a class="ae ld" href="https://explainshell.com/explain?cmd=sed+-i+-e+%E2%80%98s%2Fclass%2Fenum%2F%E2%80%99+.%2Fbilling-method.ts" rel="noopener ugc nofollow" target="_blank">互动sed细分</a></li></ul></div></div>    
</body>
</html>