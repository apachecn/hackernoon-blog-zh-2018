<html>
<head>
<title>AWS Lambda — should you have few monolithic functions or many single-purposed functions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda——应该有几个单一的函数还是许多单一用途的函数？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/aws-lambda-should-you-have-few-monolithic-functions-or-many-single-purposed-functions-8c3872d4338f?source=collection_archive---------2-----------------------#2018-01-25">https://medium.com/hackernoon/aws-lambda-should-you-have-few-monolithic-functions-or-many-single-purposed-functions-8c3872d4338f?source=collection_archive---------2-----------------------#2018-01-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f2ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个有趣的时刻(38:50)发生在蒂姆·布雷在re:invent 2017的会议期间(<a class="ae jp" href="https://www.youtube.com/watch?v=sMaqd5J69Ns" rel="noopener ugc nofollow" target="_blank"> SRV306 </a>),当他问观众我们是否应该有许多简单、单一目的的功能，或者更少的单片功能时，房间几乎分成了两半。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="ecee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在坚实的原则，尤其是单一责任原则(SRP)下长大，这一刻挑战了我的信念，即在无服务器世界中遵循SRP是显而易见的。</p><p id="60c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这促使我们对双方的观点进行了更仔细的研究。</p><p id="4d98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jx">充分披露，我在这场辩论中有失偏颇。如果你发现我的思维有缺陷，或者只是不同意我的观点，请在评论中指出来。</em></p></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><p id="9f63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">2018年1月28日更新:</strong>正如<a class="kf kg gr" href="https://medium.com/u/9115bfdd0f81?source=post_page-----8c3872d4338f--------------------------------" rel="noopener" target="_blank"> Quentin Ventura </a>在评论中指出的，我如何组织我的代码库对读者来说并不明显，所以不清楚我讨论这两种方法的背景，所以我在这里列出来。</p><p id="2f6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用<code class="eh kh ki kj kk b">Serverless</code>框架，一个服务的所有功能将被组织到同一个repo中，因此repo中的代码共享是通过共享模块完成的。</p><p id="68ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于每个repo，都有一个<code class="eh kh ki kj kk b">serverless.yml</code>,它用相关的事件源配置所有的功能，等等。当我们运行<code class="eh kh ki kj kk b">sls deploy</code>时，所有的功能都部署在一起。</p><p id="752a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个repo还会有一个<code class="eh kh ki kj kk b">build.sh</code>脚本，它封装了不同的构建步骤，使CI/CD变得简单，并使构建步骤可在本地执行，并且独立于CI工具——不同的CI工具对yml文件有自己的要求，但它们会是一个简单的单行程序来调用我们自己的<code class="eh kh ki kj kk b">build.sh</code>脚本。</p><p id="8c6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，典型的回购应该是这样的:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kl"><img src="../Images/5119b2cf56e5eff648f6d0bb2f24d41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iwrq3CwM0CQfBOgZUEu7mg.png"/></div></div></figure></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><h2 id="d318" class="ks kt hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">什么是单片函数？</h2><p id="28b7" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">我所说的“整体函数”是指具有基于调用事件的内部分支逻辑的函数，它可以做几件事情中的一件。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff ls"><img src="../Images/078e6af6b95107f82ad76fe6e26290a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lIL-txZJ5iBrg9DDf6-nww.png"/></div></div></figure><p id="1394" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，您可以让一个函数处理几个HTTP端点和方法，并根据<code class="eh kh ki kj kk b">path</code>和<code class="eh kh ki kj kk b">method</code>执行不同的操作。</p><pre class="jq jr js jt fq lt kk lu lv aw lw dt"><span id="8be5" class="ks kt hu kk b fv lx ly l lz ma">module.exports.handler = (event, context, cb) =&gt; {<br/>  const path = event.path;<br/>  const method = event.httpMethod;<br/>  if (path === '/user' &amp;&amp; method === 'GET') {<br/>    .. // get user<br/>  } else if (path === '/user' &amp;&amp; method === 'DELETE') {<br/>    .. // delete user<br/>  } else if (path === '/user' &amp;&amp; method === 'POST') {<br/>    .. // create user<br/>  } else if ... // other endpoints &amp; methods<br/>}</span></pre><h2 id="0c83" class="ks kt hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">真正的问题是什么？</h2><p id="2f34" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">如果不首先理解问题以及解决方案中最需要的品质，就无法理性地思考和比较解决方案。</p><p id="f9cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我听到这样的抱怨时:</p><blockquote class="mb mc md"><p id="f349" class="ir is jx it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated">拥有如此多的功能很难管理</p></blockquote><p id="4f40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我马上想知道<strong class="it hv">管理</strong>需要什么？是为了找到你要找的特定功能吗？是为了发现自己有什么功能吗？这在你有10个函数或者100个函数的时候会成为问题吗？还是说，只有当开发人员的数量超过了您能够跟踪的数量时，它才会成为一个问题？</p><p id="3a00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据我自己的经验，我们正在处理的问题与我们拥有什么功能关系不大，而是通过这些功能我们拥有什么特性和能力。</p><p id="de76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">毕竟，Lambda函数就像Docker容器或EC2服务器一样，只是提供您需要的一些业务特性或功能的管道。</p><p id="7bb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你不会问<em class="jx">“我们有</em> <code class="eh kh ki kj kk b"><em class="jx">get-user-by-facebook-id</em></code> <em class="jx">功能吗？”因为你需要知道这个函数被调用了什么，甚至不知道这个函数是否存在，是否被Lambda函数捕获。相反，你可能会问<em class="jx">“我们有Lambda函数可以根据用户的facebook ID找到他/她吗？”</em>。</em></p><p id="e8e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，真正的问题是，<em class="jx">假设我们有一个由许多特性和功能组成的复杂系统，由许多开发团队维护，我们如何将这些特性和功能组织到Lambda函数中，使其朝着</em>优化..</p><ul class=""><li id="c0ec" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated"><strong class="it hv">可发现性</strong>:我如何发现我们的系统中已经存在哪些特性和功能，以及通过哪些功能？</li><li id="cacb" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated"><strong class="it hv">调试</strong>:如何快速识别并定位调试问题所需的代码？例如，系统X的日志中有错误，我在哪里可以找到开始调试系统的相关代码？</li><li id="6ed0" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated"><strong class="it hv">扩展团队</strong>:我如何最小化摩擦，并允许我发展工程团队？</li></ul><p id="228c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些是对我来说最重要的品质。有了这些知识，我可以比较这两种方法，看看哪一种<strong class="it hv">最适合我</strong><strong class="it hv"/>。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff mv"><img src="../Images/23a0dac1244fe1b8ba58bbf64b8c299c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OG159w6MLTOQnLL6ei18lw.png"/></div></div></figure><p id="05ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能关心不同的质量，例如，您可能不关心团队的扩展，但是您确实担心运行无服务器架构的成本。不管是什么，我认为明确这些设计目标总是有帮助的，并确保他们被分享和理解(甚至可能被同意！)被你的团队。</p><h1 id="d601" class="mw kt hu bd ku mx my mz ky na nb nc lc nd ne nf lf ng nh ni li nj nk nl ll nm dt translated">可发现性</h1><p id="840c" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">Simon Wardley认为，可发现性绝不是一个新问题，它在政府和私营部门都相当普遍，大多数组织缺乏一种系统的方式让团队共享和发现彼此的工作。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nn jw l"/></div></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff no"><img src="../Images/7c8b8f5de1de365ccc05947799c9bc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*xqxvFs3jRv_gc9eePzWf2g.png"/></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">courtesy of Simon Wardley’s posts on Twitter</figcaption></figure><p id="2e56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如前所述，这里重要的是通过你的功能找出哪些功能可用的能力，而不是有哪些功能。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nt"><img src="../Images/3b72d1650c9e451b7643c6b988deadaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FC_6slSGi3GyQP_5zMLLw.png"/></div></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">Ask not what functions you have, what your functions can do.</figcaption></figure><p id="1a88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我经常听到的关于单一函数的一个论点是，它减少了函数的数量，使它们更容易管理。</p><p id="1b30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从表面上看，这似乎有道理。但是我想得越多，我就越觉得如果我们试图用手来管理Lambda函数，而不是使用现有的工具，函数的数量只会阻碍我们管理Lambda函数的能力。</p><p id="d189" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">毕竟，如果我们能够在一个有几十万本书的巨大物理空间中根据内容来定位书籍(<em class="jx">“为我找到关于X主题的书籍”</em>)，那么在有这么多工具可供我们使用的情况下，我们怎么可能努力找到Lambda函数呢？</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nu"><img src="../Images/5964a3adbd00f8ff130d06145f86131f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9R8YbGTO_zVQH3Owjbrig.png"/></div></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">Libraries, yup, they still exist!</figcaption></figure><p id="b2ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过一个简单的命名约定，就像<code class="eh kh ki kj kk b">Serverless</code>框架实施的那样，我们可以通过前缀快速找到相关的函数。</p><p id="a451" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，如果我想找到我们的用户API的所有函数，我可以通过搜索<code class="eh kh ki kj kk b">user-api</code>来实现。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nv"><img src="../Images/b7c5e51f026539f2db112d3583fccab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNLVK6_Jq7MVZd69Yn3NDg.png"/></div></div></figure><p id="a4f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过标记，我们还可以跨多个维度对功能进行分类，例如环境、功能名称、事件源的类型、作者的姓名等等。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nw"><img src="../Images/babade4bd0cc540a6713bc9538719812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ck-QETFR0AMVV0OgHP2usQ.png"/></div></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">By default, the Serverless framework adds the STAGE tag to all of your functions. You can also add your own tags as well, see <a class="ae jp" href="https://serverless.com/framework/docs/providers/aws/guide/functions/#tags" rel="noopener ugc nofollow" target="_blank">documentation</a> on how to add tags.</figcaption></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nx"><img src="../Images/e3a66de210d9d5933d589a2f45aa542e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAtLpmlp2yjQ4cT3JwUKWQ.png"/></div></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">The Lambda management console also gives you a handy dropdown list of the available values when you try to search by a tag.</figcaption></figure><p id="c818" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你对你要找的东西有一个粗略的想法，那么功能的数量不会成为你发现那里有什么的障碍。</p><p id="7280" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，user-api的功能对于单一用途的函数来说是显而易见的，我可以从相关的函数中看出我有基本的CRUD功能，因为每个功能都有相应的函数。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff ny"><img src="../Images/fa77fbd9691ab0e244f923af2fb1f219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C22Wu2wC8uROThTfwyn7iQ.png"/></div></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">I can see what capabilities I have as part of the suite of functions that make up the user-api feature.</figcaption></figure><p id="1615" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，对于一个单一的函数来说，这并不是显而易见的，我必须自己查看代码，或者咨询函数的作者，对我来说，这很难被发现。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nz"><img src="../Images/1b14ecf4d39bd70f35e535e98e391f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9wXc2rndRZm2hO0ggevtA.png"/></div></div></figure><p id="539a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正因为如此，我将根据可发现性来标记整体方法。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff oa"><img src="../Images/b6d246c86a8e8a6d90445cde56ad7bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXYf0mExyAPrzHuA3wMz2A.png"/></div></div></figure><p id="7efa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">拥有更多的功能，意味着如果你只是想探索有哪些功能，而不是寻找任何特定的功能，你可以浏览更多的页面。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff ob"><img src="../Images/48b5ad5fc0e3c10fb7cd5eea841a04fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Xjwc62Up78CfUs3qwYECg.png"/></div></div></figure><p id="7d9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然，根据我的经验，由于无服务器框架实施的命名约定，所有的函数都很好地通过名字前缀聚集在一起，但是实际上，看到每组函数能做什么比不得不<em class="jx">猜测</em>一个单一函数内部发生了什么更好。</p><p id="11de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，我想当你有成千上万的功能时，滚动浏览所有的内容是一件痛苦的事情。因此，我将把单一用途的函数稍微降低一点。我认为在这种复杂程度下，即使你通过在每个函数中加入更多的功能来减少函数的数量，你仍然会因为看一眼就不知道这些单块函数的真正功能而遭受更多的痛苦。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff oa"><img src="../Images/c4b81fa96e34fb6a928cc372501e1841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGGFxDFUXcRHNDjopc23eA.png"/></div></div></figure><h1 id="04e4" class="mw kt hu bd ku mx my mz ky na nb nc lc nd ne nf lf ng nh ni li nj nk nl ll nm dt translated">排除故障</h1><p id="67be" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">就调试而言，这里的相关问题是，函数越少，是否越容易快速识别和定位调试问题所需的代码。</p><p id="fe38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据我的经验，从日志中的HTTP错误或错误堆栈跟踪到相关函数的痕迹，无论函数做一件事还是许多不同的事，repo都是一样的。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff oc"><img src="../Images/60dcb85ee20f2e7b5b5fe0a8a57c7664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qV9A5t6nXBmulssjGXzfRw.png"/></div></div></figure><p id="9b8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不同的是，你如何在回购协议中找到你正在调查的问题的相关代码。</p><p id="728f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个整体功能有更多的分支，通常做更多的事情，可以理解需要更多的认知努力来理解和遵循与手头问题相关的代码。</p><p id="3877" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我也会稍微降低单片函数的价值。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff od"><img src="../Images/5e63dddd2f34543a0ccb99afd26e2bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BfnhHIlQx0KEqnFIxQa4A.png"/></div></div></figure><h1 id="2f3c" class="mw kt hu bd ku mx my mz ky na nb nc lc nd ne nf lf ng nh ni li nj nk nl ll nm dt translated">缩放比例</h1><p id="7441" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">关于微服务的早期论点之一是，它使扩展变得更容易，但事实并非如此——如果你知道如何扩展系统，那么你可以像扩展微服务一样轻松地扩展一个整体。</p><p id="cfb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我这么说是因为我曾经为拥有100万日活跃用户的游戏构建了完整的后端系统。Supercell是我现在的雇主T1的母公司，也是最卖座游戏如T2部落冲突T3和T4皇家冲突T5的创造者，他们的游戏有超过1亿的每日活跃用户，他们的游戏后台系统也是独一无二的。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff oe"><img src="../Images/db6e7e492b565d26c08c7322528c69cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*uXFIo5_szcKnh0kd6m3Vxg.png"/></div></figure><p id="3c68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，我们从亚马逊、网飞和谷歌等科技巨头那里学到的是，面向服务的架构风格更容易在不同的维度——我们的工程团队——进行扩展。</p><p id="862e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种架构风格允许我们围绕特性和功能在系统内创建边界。这样做还允许我们的工程团队扩展他们构建的复杂性，因为他们可以更容易地在其他人之前已经创建的工作之上进行构建。</p><p id="22f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以谷歌的<a class="ae jp" href="https://cloud.google.com/datastore/docs/concepts/overview" rel="noopener ugc nofollow" target="_blank">云数据仓库</a>为例，从事这项服务的工程师们能够通过建立在许多服务层之上来生产高度复杂的服务，每一层都提供强大的抽象层。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff of"><img src="../Images/e932a2cb0b43a3c95cf2405aed68ec66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyUwWcGZkfpw4tzlrS8muQ.png"/></div></div><figcaption class="np nq fg fe ff nr ns bd b be z ek"><a class="ae jp" href="http://bit.ly/2CQx3C4" rel="noopener ugc nofollow" target="_blank">http://bit.ly/2CQx3C4</a></figcaption></figure><p id="69ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些服务边界给了我们更大的分工，这允许更多的工程师在系统上工作，给他们相对独立的工作区域。这样，它们就不会经常因为合并冲突、集成问题等等而相互绊倒。</p><p id="cde3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">迈克尔·尼加德最近也写了一篇很好的文章，解释了界限和隔离的好处，它如何帮助减少共享心智模型的开销。</p><blockquote class="mb mc md"><p id="db70" class="ir is jx it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated">“如果你有一个很高的一致性惩罚和太多的人，那么团队作为一个整体移动得更慢…这是关于<strong class="it hv">减少</strong> <strong class="it hv">共享心智模型</strong>的开销。”迈克尔·尼加德</p></blockquote><p id="94d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">拥有许多单一用途的功能也许是这种任务划分的顶峰，当你转向单一功能时，你会失去一些东西。尽管在实践中，你可能不会最终让这么多的开发人员在同一个项目上工作，以至于你感到痛苦，除非你真的把他们和那些单一的功能打包在一起！</p><p id="ca91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，将一个函数限制为只做一件事也有助于限制函数的复杂程度。为了让事情变得更复杂，你可以通过其他方式将这些简单的函数组合在一起，比如用AWS <em class="jx">步骤函数</em>。</p><p id="b594" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再一次，我要把单体函数记下来，因为它们失去了一些分工，并且提高了函数的复杂度上限。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff oa"><img src="../Images/4237bae108b7c12eb06ba82384401f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNu9RlaxpUhdyTRwyLzozQ.png"/></div></div></figure></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><p id="b223" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">2018年9月2日更新:</strong>鉴于一些人问及单芯片与单用途功能背景下的冷启动，我有以下想法。</p><p id="bb97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如<a class="kf kg gr" href="https://medium.com/u/3aacb5d290d2?source=post_page-----8c3872d4338f--------------------------------" rel="noopener" target="_blank"> Kostas Bariotis </a>所问:</p><blockquote class="mb mc md"><p id="100e" class="ir is jx it b iu iv iw ix iy iz ja jb me jd je jf mf jh ji jj mg jl jm jn jo hn dt translated">单体函数也有被频繁使用的好处，因此它们不太可能处于冷状态，而不经常使用的单一用途函数可能总是处于冷状态，你不这样认为吗？</p></blockquote><p id="1d5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这似乎是一个公平的假设，但冷启动的实际行为是一个更微妙的讨论，可能会根据请求的速率产生截然不同的结果。查看我的另一篇文章<a class="ae jp" href="https://hackernoon.com/im-afraid-you-re-thinking-about-aws-lambda-cold-starts-all-wrong-7d907f278a4f" rel="noopener ugc nofollow" target="_blank">更详细地探讨了这种行为。</a></p><h2 id="b648" class="ks kt hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">整合成整体功能的效果(对所经历的冷启动次数而言)随着负载而迅速减弱</h2><p id="dbe2" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">为了简单起见，让我们考虑<em class="jx">“当你上升到X req/s时，你将经历的冷启动次数”</em>。假设:</p><ul class=""><li id="6db6" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">上升是逐渐的，所以没有大的峰值(这会触发更多的冷启动)</li><li id="3a5a" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">每个请求的持续时间很短，比如说100毫秒</li></ul><p id="fe02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在小范围内，假设每个端点1个请求/秒，总共10个端点(即<strong class="it hv"> 1个单片功能</strong>对<strong class="it hv"> 10个专用功能</strong>)，我们总共会有10个请求/秒。考虑到100ms的执行时间，这刚好在一个并发功能能够处理的范围内。</p><p id="9605" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要达到每个端点1个请求/秒，您将经历:</p><ul class=""><li id="ce6a" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">单片:1个冷启动</li><li id="8584" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">单一用途:10次冷启动</li></ul><p id="991a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着负载的增加，每个端点达到100 req/s，这相当于总共1000 req/s。要处理这一负载，您需要至少100个单片功能的并发执行(每个req 100毫秒，因此每个并发执行的吞吐量为10 req/s，因此并发执行数= 1000 / 10 = 100)。要达到这一并发级别，您将经历:</p><ul class=""><li id="65b2" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">单片:100次冷启动</li></ul><p id="71bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，每个端点100个请求/秒=每个单一目的函数的10个并发执行。为了达到这种并发水平，您还将经历:</p><ul class=""><li id="f6ff" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">单一目的:10个并发执行* 10个功能= 100次冷启动</li></ul><p id="175a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，<strong class="it hv">单片功能并不能帮助你减少冷启动次数，即使是在中等负荷下</strong>。</p><p id="f439" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，当负载较低时，您可以通过预热您的功能来做一些简单的事情来减轻冷启动(如<a class="ae jp" href="https://hackernoon.com/im-afraid-you-re-thinking-about-aws-lambda-cold-starts-all-wrong-7d907f278a4f" rel="noopener ugc nofollow" target="_blank">其他帖子</a>中所述)。你甚至可以使用<a class="ae jp" href="https://github.com/FidelLimited/serverless-plugin-warmup" rel="noopener ugc nofollow" target="_blank">无服务器插件预热</a>来帮你做这件事，它甚至提供了在部署后进行预热运行的选项。</p><p id="c9cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，当您有适度的并发时，这种实践就不再有效了。在这一点上，单片功能将导致与单一用途功能一样多的冷启动。</p><h2 id="a3d3" class="ks kt hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">整合到单片功能中会增加初始化时间，从而延长冷启动的持续时间</h2><p id="de85" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">通过将更多的“动作”打包到一个函数中，我们还增加了在该函数的冷启动期间需要初始化的模块的数量，因此结果是很可能经历<strong class="it hv">更长的冷启动</strong>(基本上，在冷启动的<code class="eh kh ki kj kk b">Bootstrap runtime</code>阶段(见下文),在导出的处理函数之外的任何东西都被初始化。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff og"><img src="../Images/61b23e8269c70edb7c8fab35be556863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NN8gZSRhXZ8Ru9xdV-rIGw.png"/></div></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">from Ajay Nair’s talk at re:invent 2017 — <a class="ae jp" href="https://www.youtube.com/watch?v=oQFORsso2go" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=oQFORsso2go</a></figcaption></figure><p id="0881" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下，在我在这篇文章中用来说明这一点的虚构的<code class="eh kh ki kj kk b">user-api</code>的单片版本中，我们的处理程序模块需要<code class="eh kh ki kj kk b">require</code>所有端点使用的所有依赖项。</p><pre class="jq jr js jt fq lt kk lu lv aw lw dt"><span id="74e6" class="ks kt hu kk b fv lx ly l lz ma">const depA = require('lodash');<br/>const depB = require('facebook-node-sdk');<br/>const depC = require('aws-sdk');<br/>...</span></pre><p id="2da4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而在<code class="eh kh ki kj kk b">user-api</code>的专用版本中，只有<code class="eh kh ki kj kk b">get-user-by-facebook-id</code>端点的处理函数需要在冷启动期间产生初始化<code class="eh kh ki kj kk b">facebook-node-sdk</code>依赖的额外开销。</p><p id="d383" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还必须考虑同一个项目中的任何其他模块，以及它们的依赖项，以及在这些模块初始化期间将运行的任何代码，等等。</p><h2 id="8879" class="ks kt hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">优化冷启动的错误位置</h2><p id="9492" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">因此，与人们的直觉相反，除了基本预热已经可以实现的以外，单片功能不会为冷启动提供任何好处，并且很可能延长冷启动的持续时间。</p><p id="f52c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为冷启动对你的影响<a class="ae jp" href="https://read.acloud.guru/does-coding-language-memory-or-package-size-affect-cold-starts-of-aws-lambda-a15e26d12c76" rel="noopener ugc nofollow" target="_blank">取决于语言、内存和你在代码中做了多少初始化</a>。我认为，如果你担心冷启动，那么你最好切换到另一种语言(即Go、Node.js或Python ),并努力优化你的代码，这样冷启动时间会更短。</p><p id="f245" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，请记住，这是AWS和其他提供商正在积极努力的事情，我怀疑这种情况将在未来通过该平台得到极大的改善。</p><p id="0153" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总而言之，我认为改变部署单元(一个大功能对许多小功能)不是解决冷启动的正确方法。</p></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><h1 id="fc79" class="mw kt hu bd ku mx oh mz ky na oi nc lc nd oj nf lf ng ok ni li nj ol nl ll nm dt translated">结论</h1><p id="05fa" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">如您所见，<strong class="it hv">基于对我来说很重要的</strong><strong class="it hv"/>标准，拥有许多单一用途的函数显然是更好的选择。</p><p id="0039" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像其他人一样，我天生就有一套由我的经历形成的倾向和偏见，这很可能并不反映你的倾向和偏见。我不是要求你同意我的观点，而是简单地欣赏解决对你和你的组织重要的事情的过程，以及如何着手找到适合你的方法。</p><p id="ddbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，如果你不同意我的想法和我为我的选择标准提出的论点——可发现性、调试和扩展团队以及系统的复杂性——那么请通过评论让我知道。</p></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="ab fr cl om"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗨，我的名字是<strong class="it hv">崔琰</strong>。我是一个<a class="ae jp" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> AWS无服务器英雄</strong> </a>和<a class="ae jp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过<a class="ae jp" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae jp" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae jp" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看我的新课程，<a class="ae jp" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里拿到你的副本。</p></div><div class="ab cl jy jz hc ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hn ho hp hq hr"><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff on"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="it hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还可以用代码<strong class="it hv"> ytcui </strong>获得<strong class="it hv">票面价格6折</strong>。</p><p id="2e68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击获取您的副本<a class="ae jp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>