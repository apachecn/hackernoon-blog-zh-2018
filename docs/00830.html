<html>
<head>
<title>The Little Guide for OOP in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中面向对象的小指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-little-guide-for-poo-in-js-3cfff83ad095?source=collection_archive---------7-----------------------#2018-01-26">https://medium.com/hackernoon/the-little-guide-for-poo-in-js-3cfff83ad095?source=collection_archive---------7-----------------------#2018-01-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b847" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本指南中，我将尝试解释es6 JavaScript在<strong class="it hv">面向对象范例中的新特性。</strong></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/c303e35d2b93997fb5fd6423c9cfca31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*XlnVJQ392USdQuQcdyvJ4w.png"/></div></figure><p id="9c84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，</p><h1 id="c0db" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">什么是编程范例？</h1><p id="c08d" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">范型是某事物的一个例子或模型，因此，在这种情况下，是创建计算机程序所遵循的一种模式。</p><h1 id="c371" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">什么是<strong class="ak">面向对象？</strong></h1><p id="7c13" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">显然，你意识到这是一种编程模式，但像exist这种选择，我们还有很多其他选择，如函数式编程、反应式编程等。</p><h1 id="fa2d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">这种范式的特点是什么？</h1><p id="a7c6" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">我们在这个范例中所做的是以一种更接近现实的方式编程，我们根据类、对象、方法、属性等来编程。，尤其是集成了诸如:抽象、伪装、模块化、隐私、多态、继承等术语。</p><blockquote class="la lb lc"><p id="e0b5" class="ir is ld it b iu iv iw ix iy iz ja jb le jd je jf lf jh ji jj lg jl jm jn jo hn dt translated">JavaScript的问题在于它并不是一种便便语言，为什么呢？因为在JavaScript中all是一个对象，所以我们可以使用著名的<strong class="it hv">原型来解决这个问题。</strong></p></blockquote><p id="c497" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在ES5中，我们可以使用工厂模式做下一个示例:</p><pre class="jq jr js jt fq lh li lj lk aw ll dt"><span id="6fc0" class="lm jy hu li b fv ln lo l lp lq">console.log('*** PERSON ***');</span><span id="e699" class="lm jy hu li b fv lr lo l lp lq">function Person (name) {<br/> this.name = name;<br/>}<br/><em class="ld">// We define our properties/methods</em><br/>Person.prototype = {<br/>   eyes: 2,<br/>   mouth: 1,<br/>   sleep: function () {<br/>    return 'zzz';<br/>   }<br/>};<br/><em class="ld">// We create a person</em><br/>const p1 = new Person('Nick');<br/>// and we can do:<br/>console.log(<br/>  `name: ${p1.name}`,<br/>  `eyes: ${p1.eyes}`,<br/>  `mouth: ${p1.mouth}`,<br/>   p1.sleep()<br/>);</span><span id="720f" class="lm jy hu li b fv lr lo l lp lq">console.log('*** EMPLOYEE ***')</span><span id="86ed" class="lm jy hu li b fv lr lo l lp lq"><em class="ld">// But now, if we have a employee 'class' we can inheritance person's properties.</em><br/>function Employee (name, salary) {<br/>  this.name = name;<br/>  this.salary = salary;<br/>}<br/><em class="ld">// Prototype Inheritance</em><br/>Employee.prototype = Object.create(Person.prototype);<br/>Employee.prototype.constructor = Employee;<em class="ld"> // Set his own constructor<br/>// So now, we just can do the same thing<br/>// We create a employee</em><br/>const em1 = new Employee('John', 3000);<br/><em class="ld">// and we can do:</em><br/>console.log(<br/>  `name: ${em1.name}`,<br/>  `salary: ${em1.salary} USD`,<br/>  `eyes: ${em1.eyes}`,<br/>  `mouth: ${em1.mouth}`,<br/>   em1.sleep()<br/>);</span></pre><p id="b304" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，在ES6中，我们可以用一种简单的方式完成所有这些，但我们必须记住，这只是语法上的好处:</p><p id="1d3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ES6 syntac的最后一个例子。</p><pre class="jq jr js jt fq lh li lj lk aw ll dt"><span id="5dc0" class="lm jy hu li b fv ln lo l lp lq">class Person {<br/>  constructor (name) {<br/>    this.name = name;<br/>    this.eyes = 2;<br/>    this.mouth = 1;<br/>  }<br/>  sleep () {<br/>    return 'zzz';<br/>  }<br/>}</span><span id="154e" class="lm jy hu li b fv lr lo l lp lq">class Employee extends Person {<br/>  constructor (name, salary) {<br/>    super(name);<br/>    this.salary = salary;<br/>  }<br/>}</span><span id="851e" class="lm jy hu li b fv lr lo l lp lq">const p1 = new Person('Nick');<br/>// and we can do:<br/>console.log(<br/>  `name: ${p1.name}`,<br/>  `eyes: ${p1.eyes}`,<br/>  `mouth: ${p1.mouth}`,<br/>   p1.sleep()<br/>);</span><span id="e941" class="lm jy hu li b fv lr lo l lp lq"><em class="ld">// We create a employee</em><br/>const em1 = new Employee('John', 3000);<br/><em class="ld">// and we can do:</em><br/>console.log(<br/>  `name: ${em1.name}`,<br/>  `salary: ${em1.salary} USD`,<br/>  `eyes: ${em1.eyes}`,<br/>  `mouth: ${em1.mouth}`,<br/>   em1.sleep()<br/>);</span></pre><p id="daa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，使用<strong class="it hv">扩展</strong>关键字，我们只需说:‘好吧，我想继承Person类属性’。但是在幕后，这和我们在es5例子中使用原型做的是一样的。</p><h2 id="197b" class="lm jy hu bd jz ls lt lu kd lv lw lx kh jc ly lz kl jg ma mb kp jk mc md kt me dt translated">静态方法:</h2><pre class="jq jr js jt fq lh li lj lk aw ll dt"><span id="12fd" class="lm jy hu li b fv ln lo l lp lq">class Dog {<br/>  static whatIs() {<br/>   return 'A dog is a beatiful animal';<br/>  }<br/>}</span><span id="b8d6" class="lm jy hu li b fv lr lo l lp lq">// So, with static we can access to methods without the need to instantiate a new object of the class.<br/>console.log( Dog.whatIs() );</span></pre><h2 id="3b15" class="lm jy hu bd jz ls lt lu kd lv lw lx kh jc ly lz kl jg ma mb kp jk mc md kt me dt translated">私有方法</h2><p id="293a" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">在JavaScript中，我们没有像Java和C#那样的private关键字，重要的是，在JavaScript中，我们有一个用于<em class="ld">‘private’</em>值的约定，该约定是<strong class="it hv">在单词前使用下划线，</strong>让我向您展示:</p><pre class="jq jr js jt fq lh li lj lk aw ll dt"><span id="a6f3" class="lm jy hu li b fv ln lo l lp lq">class Person {<br/> constructor (name, phone) { <br/>   this.name = name;<br/>   this._phone = phone;<br/> }<br/>}<br/>const p1 = new Person('John', 544342212);<br/>// But 'phone' is not a private propertie because we can do this:<br/>console.log(p1._phone);</span></pre><p id="b719" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而在ES6中，我们有一个名为WeakMap的对象，它允许我们创建私有属性，让我们看看:</p><pre class="jq jr js jt fq lh li lj lk aw ll dt"><span id="f788" class="lm jy hu li b fv ln lo l lp lq"><em class="ld">// Don't use private like variable name because is a reserved word</em><br/>const secret = new WeakMap();<br/>class Person {<br/>  constructor (name, phone) {<br/>    this.name = name;<br/>    secret.set(this, {_phonenumber: phone});<br/>  }<br/>}<br/>const p1 = new Person('John', 544342212);<br/><em class="ld">// Now the phonenumber is a private propertie.</em><br/>console.log(p1._phone); <em class="ld">// Print's undefined</em></span></pre><h2 id="8f8f" class="lm jy hu bd jz ls lt lu kd lv lw lx kh jc ly lz kl jg ma mb kp jk mc md kt me dt translated">Getters和Setters</h2><p id="3b5d" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">当我们有私有方法时，通常会创建一个返回私有值的公共方法，所以我们必须返回一个值并设置定义一个新值。</p><pre class="jq jr js jt fq lh li lj lk aw ll dt"><span id="353b" class="lm jy hu li b fv ln lo l lp lq">const secret = new WeakMap();<br/>class Person {<br/>  constructor (name, phone) {<br/>    this.name = name;<br/>    secret.set(this, {_phonenumber: phone});<br/>  }<br/>  get phoneNumber() {<br/>    return secret.get(this)._phonenumber;<br/>  }<br/>  set phoneNumber(newNumber) {<br/>    secret.get(this)._phonenumber = newNumber;<br/>  }<br/>}<br/>const p1 = new Person('John', 544342212);<br/><em class="ld">// Now we can access to the phone by using the getter: </em><br/>console.log(p1.phoneNumber); <em class="ld">// Print's the number<br/>// Set a new number<br/></em>p1.phoneNumber = 432232323;<em class="ld"><br/></em>console.log(p1.phoneNumber)<em class="ld">; // We get the new number</em></span></pre><h2 id="73f6" class="lm jy hu bd jz ls lt lu kd lv lw lx kh jc ly lz kl jg ma mb kp jk mc md kt me dt translated">多态性</h2><p id="7aed" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">是对象在执行过程中引用其类的一个实例或其任何后代类的一个实例的能力。后代类可以重定义一个方法。</p><pre class="jq jr js jt fq lh li lj lk aw ll dt"><span id="4006" class="lm jy hu li b fv ln lo l lp lq">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  me() {<br/>    return `My name is ${this.name}`;<br/>  }<br/>}<br/>const axel = new Person('Axel');<br/>console.log(axel.me());<br/>  // -&gt;  'My name is Axel'<br/>class Employee extends Person {<br/>  constructor (name, salary) {<br/>    super(name);<br/>    this.salary = salary;<br/>  }<br/>  me() {<br/>    return `My name is ${this.name} and my salary is ${this.salary}`;<br/>  } <br/>}</span><span id="a4e0" class="lm jy hu li b fv lr lo l lp lq">const nick = new Employee('Nick', 3000);<br/>console.log(nick.me());<br/>  // -&gt;  'My name is Nick and my salary is 3000'</span></pre><h2 id="16ce" class="lm jy hu bd jz ls lt lu kd lv lw lx kh jc ly lz kl jg ma mb kp jk mc md kt me dt translated">一些概念:</h2><p id="4e80" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated"><strong class="it hv">类:</strong>创建新的类/模型。<br/> <strong class="it hv">方法:</strong>函数在一个类里面。<br/> <strong class="it hv">构造函数:</strong>类实例化时初始化对象的方法。<br/> <strong class="it hv">扩展:</strong>用于设置继承。<br/> <strong class="it hv"> super: </strong>调用父节点设置继承属性的方法。构造函数。supe必须在构造函数方法的第一行。<br/> <strong class="it hv"> get: </strong>方法返回值。<br/> <strong class="it hv"> set: </strong>方法重新定义一个新的现有值。<br/> <strong class="it hv">新增:</strong>通过类构造器方法创建对象。</p><p id="3972" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以去我的<a class="ae mf" href="https://github.com/germancutraro" rel="noopener ugc nofollow" target="_blank"> Github </a>找JavaScript例子。</p><p id="a18b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">谢谢你😊！</p></div></div>    
</body>
</html>