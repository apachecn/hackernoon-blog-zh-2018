<html>
<head>
<title>How To Script An Automatic Token Airdrop for 40k subscribers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为40k用户编写自动令牌空投脚本</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-script-an-automatic-token-airdrop-for-40k-subscribers-e40c8b1a02c6?source=collection_archive---------1-----------------------#2018-01-28">https://medium.com/hackernoon/how-to-script-an-automatic-token-airdrop-for-40k-subscribers-e40c8b1a02c6?source=collection_archive---------1-----------------------#2018-01-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/7ad94f05300968b77dc9c22d07b8c039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBFViHlWjtWl-xQnByOeDg.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/photos/DiTiYQx0mh4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dose Media</a> on <a class="ae ih" href="https://unsplash.com/search/photos/robot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="11a4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我很高兴地宣布，我最近加入了<a class="ae ih" href="http://polymath.network" rel="noopener ugc nofollow" target="_blank">博学者</a>团队，成为一名可靠性工程师，负责开发基于<a class="ae ih" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>的证券代币的新标准。🎆🎆🎆</p><p id="1328" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章/教程中，我将介绍编写node.js脚本的过程，该脚本执行自动令牌分发/空投到以太坊地址列表。我将使用我们为Polymath令牌分发过程编写的代码——这是一个非常标准的ERC20令牌——并检查我构建的用于处理令牌自动分发的脚本。</p><p id="ab85" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最初，我计划通过Infura运行这个脚本，这样我就不必在本地运行一个完整的节点。这需要离线签署交易，我是通过使用最新版本的web3中几个方便的功能来完成的。不幸的是，尽管这在testrpc和Ropsten上很管用，但在Mainnet上却是一场灾难。交易并没有增加，这是非常缓慢，昂贵和不可靠的。<br/>如果你无论如何都想检查一下，<a class="ae ih" href="https://github.com/PolymathNetwork/polymath-token-distribution/commit/5f1d15bdc9050366a94430956ec74ffda3c93bb8" rel="noopener ugc nofollow" target="_blank">你可以参考这个早期提交</a>。</p><h1 id="aa1d" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">令牌和令牌分发合同</h1><p id="778e" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我在Polymath的首要任务之一是帮助团队敲定令牌和令牌分发智能合同，我们将在未来几天使用这些合同来发布<a class="ae ih" href="https://hackernoon.com/tagged/poly" rel="noopener ugc nofollow" target="_blank"> POLY </a>令牌，并向订阅该平台的4万人进行空投。</p><p id="704a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我不打算详细介绍这些合同的代码，但是你可以看看它们，因为它们已经在<a class="ae ih" href="https://github.com/PolymathNetwork/polymath-token-distribution" rel="noopener ugc nofollow" target="_blank"> Polymath的Github库</a>上公开了。</p><p id="f2be" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一些关于<code class="eh li lj lk ll b"><strong class="jj il">PolyToken.sol</strong></code> <strong class="jj il"> </strong>和<code class="eh li lj lk ll b"><strong class="jj il">PolyDistribution.sol</strong></code>智能合约的值得一提的事情，这将有助于理解本教程的其余部分:</p><ul class=""><li id="396c" class="lm ln ik jj b jk jl jo jp js lo jw lp ka lq ke lr ls lt lu dt translated"><code class="eh li lj lk ll b"><strong class="jj il">PolyToken.sol</strong></code>是保利令牌的合约。这是一个非常标准的ERC20令牌合同，供应固定。</li><li id="eb62" class="lm ln ik jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated"><code class="eh li lj lk ll b"><strong class="jj il">PolyDistribution.sol</strong></code>是处理令牌初始分发的合同。我们将预售投资者、顾问、创始人等的代币分配分开。因为空投的过程是非常不同的。在我们的例子中，我们将使用1000万个代币(从发行的10亿个代币中)进行空投，向40，000人分发250个代币。本教程中最重要的函数是<code class="eh li lj lk ll b">airdropTokens()</code>，让我们回顾一下:</li></ul><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="c147" class="mi kg ik ll b fv mj mk l ml mm"><strong class="ll il">function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin</strong> {<br/>    require(now &gt;= startTime);<br/>    uint airdropped;<br/>    for(uint i = 0; i&lt; _recipient.length; i++)<br/>    {<br/>        if (!airdrops[_recipient[i]]) {<br/>          airdrops[_recipient[i]] = true;<br/>          require(POLY.transfer(_recipient[i], 250 * decimalFactor));<br/>          airdropped = airdropped.add(250 * decimalFactor);<br/>        }<br/>    }<br/>    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);<br/>    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);<br/>    grandTotalClaimed = grandTotalClaimed.add(airdropped);<br/>  }</span></pre><p id="ac25" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh li lj lk ll b">airdropTokens()</code>基本上做的是分发(调用ERC20的<code class="eh li lj lk ll b">transfer()</code>函数)250个POLY令牌——它们是常规的ERC20令牌——到一个地址数组。对于我们收到的每个地址，只要他们还没有收到分配，我们就转移250个聚给他们。该过程完成后，我们更新可用的供应，并跟踪已经分发了多少令牌。</p><p id="224d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本教程<strong class="jj il">中，我们将只关注为空投接收者分发令牌</strong>。如上所述，这些代币的分配和转让没有授权期或悬崖期。其他类型的分配则不同，在转让/出售之前，需要满足一些特殊条件。</p><p id="a48d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mn">如果您有兴趣了解其余的分配是如何完成的，您可以查看</em> <code class="eh li lj lk ll b"><strong class="jj il"><em class="mn">PolyDistribution.sol</em></strong></code> <strong class="jj il"> <em class="mn">中的</em> <code class="eh li lj lk ll b"><em class="mn">setAllocation()</em></code> <em class="mn">和</em> <code class="eh li lj lk ll b"><em class="mn"> transferTokens()</em></code> <em class="mn">函数。</em>T19】</strong></p><h1 id="60ae" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">令牌分发事件</h1><p id="d876" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">当令牌分发日期到来时，我们团队需要做的是将令牌分发到注册空投的每个帐户。这些数据是在过去几个月里从comapny的网站上收集的，其中包含注册空投并在KYC验证过程中成功验证的每个帐户的地址。我们为空投过程收集的数据存储在一个只有一列的CSV文件中:每个用户的以太坊地址。</p><p id="6829" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mn">注意，该脚本可以很容易地修改，不仅包含用户的地址，还包含应该传送多少令牌。在这种情况下，由于我们决定给每个人250个POLY，这是没有必要的，我们选择在distribution smart合同中硬编码这个数字。</em></p><p id="9621" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从理论上讲，空投非常简单。我们需要做的就是为我们收集的每个地址调用ERC20令牌的<code class="eh li lj lk ll b">transfer()</code>函数。</p><p id="5583" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们只有少数几个订阅者，可以通过手动执行<code class="eh li lj lk ll b">transfer() </code>功能来完成上述操作，但当它启动时，可能会有成千上万的人想要获得他们的令牌，一个接一个地完成上述操作将非常耗时。</p><h1 id="442e" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">通过Node.js脚本自动化令牌分发过程。</h1><p id="1dd2" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">解释了令牌和分发契约的工作原理后，让我们深入研究JS代码。为了实现令牌分发过程的自动化，我们需要做一些事情:</p><ol class=""><li id="8201" class="lm ln ik jj b jk jl jo jp js lo jw lp ka lq ke mo ls lt lu dt translated">我们必须读取CSV文件，并处理它以删除空白或无效的条目。我们假设一些数据将会丢失或者一些地址可能是错误的，所以我们将确保在将它们发送到区块链之前将它们删除。</li><li id="f0a4" class="lm ln ik jj b jk lv jo lw js lx jw ly ka lz ke mo ls lt lu dt translated">我们将把地址打包到多个数组中，每个数组包含80个地址。为什么是80？经过几次测试，考虑到运送代币的油费，这是一个理想的数字。根据您试图对每个条目做什么，每个事务可能会花费更多或更少的gas，您应该相应地打包条目，以便事务不会耗尽gas并回滚。</li><li id="c695" class="lm ln ik jj b jk lv jo lw js lx jw ly ka lz ke mo ls lt lu dt translated">一旦我们有了数组集合，我们将把它们传递给智能契约上的<code class="eh li lj lk ll b">airdropTokens()</code>函数，该函数将遍历数组并调用每个订户的<code class="eh li lj lk ll b">transfer()</code>方法来发送他们的令牌。</li><li id="ac4f" class="lm ln ik jj b jk lv jo lw js lx jw ly ka lz ke mo ls lt lu dt translated">之后，我们将运行另一个进程来获取由发行合同生成的所有<code class="eh li lj lk ll b">Transfer</code>事件，这样我们就可以检查发行是否顺利。(我们将对分发的令牌进行求和，这应该与我们文件中的数据相匹配)。</li></ol><p id="8fbd" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj il">让我们从设置项目开始:</strong></p><p id="6036" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想跳过整个教程，只运行脚本，你可以在这里找到<a class="ae ih" href="https://github.com/PolymathNetwork/polymath-token-distribution" rel="noopener ugc nofollow" target="_blank">完整的源代码</a>。</p><h2 id="1a1e" class="mi kg ik bd kh mp mq mr kl ms mt mu kp js mv mw kt jw mx my kx ka mz na lb nb dt translated">建立</h2><p id="3249" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">运行以下命令来设置一个全新的项目并安装所需的依赖项:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="3fec" class="mi kg ik ll b fv mj mk l ml mm">$ mkdir distributionTutorial<br/>$ npm init<br/>$ truffle init<br/>$ npm install web3 fast-csv truffle-contract ethereumjs-testrpc  --save</span></pre><p id="a153" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于这个项目，我们将使用一些库和框架:</p><ul class=""><li id="b6db" class="lm ln ik jj b jk jl jo jp js lo jw lp ka lq ke lr ls lt lu dt translated">Truffle: 它允许我们轻松地从JavaScript编译、迁移和交互我们的合同。</li><li id="d207" class="lm ln ik jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated"><strong class="jj il"> Fast-csv: </strong>读取并处理csv文件中的数据。</li></ul><p id="d111" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您还应该安装奇偶校验，并在Ropsten(或您喜欢的任何testnet / mainnet)上同步它。以下命令对我来说非常有效:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="84ff" class="mi kg ik ll b fv mj mk l ml mm">parity — chain ropsten — rpcapi “eth,net,web3,personal,parity” — unlock &lt;THE ACCOUNT YOU WANT TO UNLOCK&gt; — password $HOME/password.file</span></pre><p id="8684" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，将Polymath Distribution智能合同复制到项目的<code class="eh li lj lk ll b">contracts</code>文件夹中。这些文件可以在这里找到:<a class="ae ih" href="https://github.com/PolymathNetwork/polymath-token-distribution/tree/master/contracts" rel="noopener ugc nofollow" target="_blank">https://github . com/polymath network/polymath-token-distribution/tree/master/contracts</a></p><p id="bbf7" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">打开truffle.js并用以下代码替换其内容:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="95bb" class="mi kg ik ll b fv mj mk l ml mm">module.exports = {<br/>  networks: {<br/>   development: {<br/>      host: 'localhost',<br/>      port: 8545,<br/>      network_id: '*', // Match any network id<br/>      gas: 3500000,<br/>    }, <br/>   ropsten: {<br/>      host: 'localhost',<br/>      port: 8545,<br/>      network_id: '3', // Match any network id<br/>      gas: 3500000,<br/>      gasPrice: 50000000000<br/>    },<br/>  },<br/>  solc: {<br/>    optimizer: {<br/>      enabled: true,<br/>      runs: 200,<br/>    },<br/>  },<br/>};</span></pre><p id="a312" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以上将允许我们运行<code class="eh li lj lk ll b">truffle migrate --network ropsten</code>来将合同部署到Ropsten testnet。在能够将合同部署到Ropsten之前，我们需要为truffle创建部署脚本。用下面的代码在<code class="eh li lj lk ll b">migrations</code>文件夹中创建一个名为<code class="eh li lj lk ll b">2_deploy_contracts.js</code>的新文件:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="88e0" class="mi kg ik ll b fv mj mk l ml mm">var PolyToken = artifacts.require('./PolyToken.sol');<br/>var PolyDistribution = artifacts.require('./PolyDistribution.sol');</span><span id="c316" class="mi kg ik ll b fv nc mk l ml mm">module.exports = async (deployer, network) =&gt; {<br/>  let _now = Date.now();<br/>  let _fromNow = 60 * 5 * 1000; // Start distribution in 1 hour<br/>  let _startTime = (_now + _fromNow) / 1000;<br/>  await deployer.deploy(PolyDistribution, _startTime);<br/>  console.log(`<br/>    ---------------------------------------------------------------<br/>    --------- POLYMATH (POLY) TOKEN SUCCESSFULLY DEPLOYED ---------<br/>    ---------------------------------------------------------------<br/>    - Contract address: ${PolyDistribution.address}<br/>    - Distribution starts in: ${_fromNow/1000/60} minutes<br/>    - Local Time: ${new Date(_now + _fromNow)}<br/>    ---------------------------------------------------------------<br/>  `);<br/>};</span></pre><p id="280e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的代码将在您执行<code class="eh li lj lk ll b">truffle migrate --network ropsten</code>时运行。它将把PolyDistribution契约部署到Ropsten(它还处理POLY Token契约的部署)，将<code class="eh li lj lk ll b">_startTime</code>设置为五分钟。确保<code class="eh li lj lk ll b">_startTime</code>变量设置正确，并且一旦到达<code class="eh li lj lk ll b">_startTime</code>就尝试空投，否则执行将失败。我们使用<code class="eh li lj lk ll b">_startTime</code>来防止人们在代币分发活动开始前提取代币。</p><p id="30fb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">继续运行<code class="eh li lj lk ll b">truffle migrate --network ropsten</code>如果一切顺利，您应该会在控制台上看到类似如下的输出:</p><figure class="ma mb mc md fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nd"><img src="../Images/e74e225c3d442d7405788f85aca29a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plignHhyVj0ZcEuAXiTTMw.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">The tx hashes and contract address will be different for you.</figcaption></figure><p id="05b8" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您看不到此输出或出现错误，请确保您正在运行奇偶校验，并且完全同步。此外，确保您的帐户中有足够的乙醚用于部署Ropsten testnet上的合同。</p><p id="20ad" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">记下我们刚刚部署的Poly分布契约的地址，我们稍后将使用它。</p><h2 id="7106" class="mi kg ik bd kh mp mq mr kl ms mt mu kp js mv mw kt jw mx my kx ka mz na lb nb dt translated">读取CSV文件</h2><p id="4a5c" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">让我们开始编写脚本，该脚本将把POLY令牌自动分配给注册了airdrop的地址。</p><p id="047b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，创建一个名为<code class="eh li lj lk ll b">scripts</code>的新文件夹，并在该文件夹中创建一个名为<code class="eh li lj lk ll b">csv_allocation.js</code>的新文件。该文件将包含运行分配过程的所有代码。</p><p id="55ad" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们继续阅读和处理CSV文件的代码之前，让我们将文件添加到项目中。我们需要一个名为<code class="eh li lj lk ll b">airdrop.csv</code>的1列CSV文件，其中包含每个将接收令牌的地址的条目。创建该文件并将其添加到<code class="eh li lj lk ll b">scripts/data</code>文件夹。</p><figure class="ma mb mc md fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ne"><img src="../Images/5a3329ee93782028611fa8b7aaf7fec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWGkekiOohJxe67G60RMLQ.png"/></div></div></figure><p id="3c1b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想轻松地测试airdrop，你可以用你控制的“随机”地址自己生成这个文件。一个简单的方法是运行testrpc并指定想要创建多少个帐户，如下所示:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="fd59" class="mi kg ik ll b fv mj mk l ml mm">testrpc -m "word1 word2 word3..." -a 300</span></pre><p id="62c8" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的命令将根据您提供的助记符生成300个帐户。将地址复制到<code class="eh li lj lk ll b">airdrop.csv</code>。</p><p id="52da" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回到我们的<code class="eh li lj lk ll b"> csv_allocation.js</code>脚本，让我们添加必要的代码，以便能够读取<code class="eh li lj lk ll b">airdrop.csv</code>。<code class="eh li lj lk ll b">csv_allocation.js</code>增加如下代码:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="6a51" class="mi kg ik ll b fv mj mk l ml mm">var fs = require('fs');<br/>var csv = require('fast-csv');<br/>var BigNumber = require('bignumber.js');</span><span id="9872" class="mi kg ik ll b fv nc mk l ml mm">let polyDistributionAddress = process.argv.slice(2)[0];<br/>let BATCH_SIZE = process.argv.slice(2)[1];<br/>if(!BATCH_SIZE) BATCH_SIZE = 80;<br/>let distribData = new Array();<br/>let allocData = new Array();</span><span id="eba0" class="mi kg ik ll b fv nc mk l ml mm">function readFile() {<br/>  var stream = fs.createReadStream("scripts/data/airdrop.csv");</span><span id="db23" class="mi kg ik ll b fv nc mk l ml mm">let index = 0;<br/>let batch = 0;</span><span id="bd04" class="mi kg ik ll b fv nc mk l ml mm">console.log(`<br/>    --------------------------------------------<br/>    --------- Parsing distrib.csv file ---------<br/>    --------------------------------------------</span><span id="22cf" class="mi kg ik ll b fv nc mk l ml mm">******** Removing beneficiaries without address data<br/>  `);</span><span id="e7c7" class="mi kg ik ll b fv nc mk l ml mm">var csvStream = csv()<br/>      .on("data", function(data){<br/>          let isAddress = web3.utils.isAddress(data[0]);<br/>          if(isAddress &amp;&amp; data[0]!=null &amp;&amp; data[0]!='' ){<br/>            allocData.push(data[0]);</span><span id="c664" class="mi kg ik ll b fv nc mk l ml mm">index++;<br/>            if(index &gt;= BATCH_SIZE)<br/>            {<br/>              distribData.push(allocData);<br/>              allocData = [];<br/>              index = 0;<br/>            }</span><span id="061c" class="mi kg ik ll b fv nc mk l ml mm">}<br/>      })<br/>      .on("end", function(){<br/>           //Add last remainder batch<br/>           distribData.push(allocData);<br/>           allocData = [];<br/>           setAllocation();<br/>      });</span><span id="181f" class="mi kg ik ll b fv nc mk l ml mm">  stream.pipe(csvStream);<br/>}</span><span id="43b1" class="mi kg ik ll b fv nc mk l ml mm">if(polyDistributionAddress){<br/>  console.log("Processing airdrop. Batch size is",BATCH_SIZE, "accounts per transaction");<br/>  readFile();<br/>}else{<br/>  console.log("Please run the script by providing the address of the PolyDistribution contract");<br/>}</span></pre><p id="80a4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您现在可以通过执行以下操作来运行脚本:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="076e" class="mi kg ik ll b fv mj mk l ml mm">$ node scripts/csv_allocation.js 0x0... 80<br/>// Where 0x0... is the address of the PolyDistribution contract we previously deployed to Ropsten.<br/>// 80 is the batch size we want to process. (How many accounts per array we want to process and send to the airdropTokens function) Can be omitted, defaults to 80.</span></pre><p id="b6e3" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj il">查看代码:</strong></p><p id="ea36" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们导入允许我们读取文件和处理CSV文件的库。</p><p id="17d2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，如果你看最后几行代码，你会看到我们正在访问运行脚本时传递的参数，如果有聚二甲基硅氧烷契约的地址，我们调用<code class="eh li lj lk ll b">readFile()</code>函数。</p><p id="d878" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh li lj lk ll b">readFile()</code>函数的作用是访问<code class="eh li lj lk ll b">airdrop.csv</code>文件并逐行读取。在每一行，我们确保该值不为null或空，我们还使用web3的<code class="eh li lj lk ll b">isAddress()</code>函数来验证传递的地址是否有效。如果地址没问题，我们将其添加到一个数组中，该数组保存了我们将用来构建每个Ethereum事务的处理数据。<br/>一旦数据被完全处理完毕，我们到达文件的末尾，我们就调用一个函数，该函数将获取80个地址的数组并对其进行处理。</p><p id="cc46" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mn">请注意，该功能非常简单，可以进一步改进以检测超过POLY供应量的令牌量、重复地址等。所有这些情况仍然在合同方面得到处理，但是如果我们能节省一些对Ethereum的事务调用，那就太好了。</em></p><h2 id="7caa" class="mi kg ik bd kh mp mq mr kl ms mt mu kp js mv mw kt jw mx my kx ka mz na lb nb dt translated">处理令牌分发</h2><p id="713c" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在我们已经将数据处理成了一个数组——我们应该有一个名为<code class="eh li lj lk ll b">distribData</code>的数组，它包含几个数组，每个数组最多有80个地址——我们将为每个数组调用智能合同中的<code class="eh li lj lk ll b">airdropTokens()</code>函数。</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="92cb" class="mi kg ik ll b fv mj mk l ml mm">const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));</span><span id="2efa" class="mi kg ik ll b fv nc mk l ml mm"><strong class="ll il">async function setAllocation() {</strong></span><span id="a990" class="mi kg ik ll b fv nc mk l ml mm">console.log(`<br/>    --------------------------------------------<br/>    ---------Performing allocations ------------<br/>    --------------------------------------------<br/>  `);</span><span id="839e" class="mi kg ik ll b fv nc mk l ml mm">let accounts = await web3.eth.getAccounts();</span><span id="6f4c" class="mi kg ik ll b fv nc mk l ml mm">let polyDistribution = await PolyDistribution.at(polyDistributionAddress);</span><span id="15fa" class="mi kg ik ll b fv nc mk l ml mm">  for(var i = 0;i&lt; distribData.length;i++){</span><span id="a7b4" class="mi kg ik ll b fv nc mk l ml mm">try{<br/>      let gPrice = 50000000000;<br/>      console.log("Attempting to allocate 250 POLYs to accounts:",distribData[i],"\n\n");<br/>      let r = await polyDistribution.airdropTokens(distribData[i],{from:accounts[0], gas:4500000, gasPrice:gPrice});<br/>      console.log("---------- ---------- ---------- ----------");<br/>      console.log("Allocation + transfer was successful.", r.receipt.gasUsed, "gas used. Spent:",r.receipt.gasUsed * gPrice,"wei");<br/>      console.log("---------- ---------- ---------- ----------\n\n")<br/>    } catch (err){<br/>      console.log("ERROR:",err);<br/>    }</span><span id="4824" class="mi kg ik ll b fv nc mk l ml mm"> }<br/>}</span></pre><p id="c7b8" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们仔细看看这个函数。JS脚本中的<code class="eh li lj lk ll b">setAllocation()</code>只需遍历填充了来自csv文件的已处理数据的<code class="eh li lj lk ll b">distribData</code>数组，然后对于每个条目数组，我们继续对智能契约执行<code class="eh li lj lk ll b">airdropTokens()</code>，传递数组。</p><p id="74cb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于我们处理的每一批地址，我们检索事件日志并打印花费了多少汽油，以确保处理成功。</p><p id="96e0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mn">每批应消耗的气体量大致相同。如果有一个批次的汽油成本更低，这意味着该批次中的一些地址没有被转移令牌，可能是因为它们以前已经被转移了令牌。</em></p><h2 id="4f5d" class="mi kg ik bd kh mp mq mr kl ms mt mu kp js mv mw kt jw mx my kx ka mz na lb nb dt translated">从ERC20令牌读取转移事件以验证交易</h2><p id="5ef7" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">收工前我们可以做的最后一件事是访问ERC20 POLY token Transfer()函数的事件日志，这样我们可以快速检查有多少帐户获得了令牌。</p><p id="9886" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh li lj lk ll b">setAllocation()</code>功能的末尾增加以下几行:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="f136" class="mi kg ik ll b fv mj mk l ml mm">console.log("Distribution script finished successfully.")<br/>  console.log("Waiting 2 minutes for transactions to be mined...")<br/>  await delay(90000);<br/>  console.log("Retrieving logs to inform total amount of tokens distributed so far. This may take a while...")</span><span id="dfbd" class="mi kg ik ll b fv nc mk l ml mm">let polytokenAddress = await polyDistribution.POLY({from:accounts[0]});<br/>  let polyToken = await PolyToken.at(polytokenAddress);</span><span id="b798" class="mi kg ik ll b fv nc mk l ml mm">var sumAccounts = 0;<br/>  var sumTokens = 0;</span><span id="c98f" class="mi kg ik ll b fv nc mk l ml mm">var events = await polyToken.Transfer({from: polyDistribution.address},{fromBlock: 0, toBlock: 'latest'});<br/>  events.get(function(error, log) {<br/>      event_data = log;<br/>      //console.log(log);<br/>      for (var i=0; i&lt;event_data.length;i++){<br/>          //let tokens = event_data[i].args.value.times(10 ** -18).toString(10);<br/>          //let addressB = event_data[i].args.to;<br/>          sumTokens += event_data[i].args.value.times(10 ** -18).toNumber();<br/>          sumAccounts +=1;<br/>          //console.log(`Distributed ${tokens} POLY to address ${addressB}`);</span><span id="6889" class="mi kg ik ll b fv nc mk l ml mm">}<br/>      console.log(`A total of ${sumTokens} POLY tokens have been distributed to ${sumAccounts} accounts so far.`);<br/>  });</span></pre><p id="4694" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的代码添加了一个超时，因此我们给事务一些时间来完成挖掘，然后我们得到POLY令牌的<code class="eh li lj lk ll b">Transfer()</code>事件，通过作为PolyDistribution契约的<code class="eh li lj lk ll b">from</code>字段过滤事件。</p><p id="52c1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们对事件进行计数，并计算分发了多少令牌。我们可以用这些数据与原始文件进行比较。我们还可以列出每个获得令牌的地址，或者添加一个比较CSV文件和事件日志数据的函数，如果我们想更有趣的话。</p><h2 id="6207" class="mi kg ik bd kh mp mq mr kl ms mt mu kp js mv mw kt jw mx my kx ka mz na lb nb dt translated">执行脚本</h2><p id="6e34" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">就是这样！让我们试试这个剧本。运行以下命令:</p><pre class="ma mb mc md fq me ll mf mg aw mh dt"><span id="4fe6" class="mi kg ik ll b fv mj mk l ml mm">$ node scripts/csv_allocation.js 0x0...<br/>// Replace 0x0... with the address of the PolyDistribution contract you deployed to Ropsten</span></pre><p id="8b52" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果一切顺利，您应该会在控制台上看到如下内容:</p><figure class="ma mb mc md fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nf"><img src="../Images/2b11364281fdca2805754e9b015542cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCN8WuCfz6nCWLVSmshdZw.png"/></div></div></figure><p id="b61f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你去<a class="ae ih" href="http://ropsten.etherscan.com" rel="noopener ugc nofollow" target="_blank">以太网扫描</a>并输入你部署的多分销合同的地址，你应该看到这样的内容:</p><figure class="ma mb mc md fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ng"><img src="../Images/5c68c2916b61c5a5718304d6ef2ed557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGTYjPzSLe-0x9wQGj2gSA.png"/></div></div></figure><p id="1927" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您可以在CSV文件中看到每个帐户的<code class="eh li lj lk ll b">Transfer()</code>事件，那么恭喜您！<br/>您已经成功完成空投！</p></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><p id="3218" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢你通读这篇教程，我希望你能像我写这篇教程一样喜欢阅读它。敬请关注更多与我在区块链构建下一代令牌化证券平台的冒险经历相关的文章、教程和故事！</p><p id="b6e2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你正在做你自己的空投，需要建议，请在下面的评论区联系我，或者发邮件给我，我会尽我所能尽快回复。</p><figure class="ma mb mc md fq hw"><div class="bz el l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>