<html>
<head>
<title>AWS Lambda — how best to manage shared code and shared infrastructure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda——如何最好地管理共享代码和共享基础设施</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/aws-lambda-how-best-to-manage-shared-code-and-shared-infrastructure-827bed395eb7?source=collection_archive---------3-----------------------#2018-01-28">https://medium.com/hackernoon/aws-lambda-how-best-to-manage-shared-code-and-shared-infrastructure-827bed395eb7?source=collection_archive---------3-----------------------#2018-01-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="af91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jp" href="https://hackernoon.com/aws-lambda-should-you-have-few-monolithic-functions-or-many-single-purposed-functions-8c3872d4338f" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我讨论了在迁移到无服务器模式时遵循<em class="jq">单一责任原则</em> (SRP)的利弊。</p><p id="d022" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Twitter和Medium上同时出现的一个问题是<em class="jq">“你如何处理共享代码？”</em>。每当我在用户组或会议上谈论AWS Lambda时，这都是一个常见问题，旁边还有<em class="jq">“如何处理明显不属于任何特定服务的共享基础设施？”</em></p><p id="6fe1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以下面是我对这两个问题的想法。</p><p id="9fbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再说一次，我并不是想以这种或那种方式说服你，我也不认为有一个“正确的”答案对每个人都适用。这只是我大声说出来，并与你分享我的内部思维过程，并希望让你对你自己的架构提出同样的问题。</p><p id="b397" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和以往一样，如果你不同意我的评估或者发现我的想法有缺陷，请通过下面的评论区告诉我。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="4945" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你用所有这些小Lambda函数构建你的系统时，毫无疑问会有你想要在你的Lambda函数之间共享和重用的业务逻辑或实用程序代码。</p><p id="821f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你有一组高度内聚的函数并被组织到同一个repo中时——就像我们在Yubl应用程序中创建的用于实现<a class="ae jp" href="https://youtu.be/pptsgV4bKv8?t=485" rel="noopener ugc nofollow" target="_blank">时间线特性的函数——那么共享代码就很容易，你只需通过repo中的一个模块就可以做到。</a></p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff jy"><img src="../Images/9788f20ec18ef6b6038bc3b656e6d1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rebh6b2SxBHvcVL2HoOAw.png"/></div></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">The functions in this diagram form a cohesive unit that work together to implement a feature.</figcaption></figure><p id="250d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，要在跨服务边界的函数之间更普遍地共享代码，可以通过共享库来实现，也许可以作为私有NPM包发布，这样它们只对您的团队可用。</p><p id="7f80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，您可以通过将业务逻辑封装到服务中来共享它们，在选择使用哪种方法时，您应该考虑几个因素。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/2849510f46e23c31fc576c0307574197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AExjL9lMtO62GRCnKtST9Q.png"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">The serverless architecture that powered Yubl.</figcaption></figure><h1 id="a4a1" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">共享图书馆与服务</h1><h2 id="f82b" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated"><strong class="ak">能见度</strong></h2><p id="e244" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">当你依赖一个共享库时，这种依赖是显式声明的，在Node.js的情况下，这种依赖是在<code class="eh mg mh mi mj b">package.json</code>中声明的。</p><p id="e5c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你依赖于一个服务时，这种依赖性通常根本没有被声明，可能只有通过日志记录才能发现，也可能通过使用<em class="jq"> AWS X-Ray </em>服务进行明确的跟踪尝试才能发现。</p><h2 id="7b4a" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">部署</h2><p id="7714" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">在部署这些共享代码的更新时，使用共享库，您可以发布一个新版本，但您仍然需要依赖共享库的使用者来更新。</p><p id="4f88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而对于服务，作为服务的所有者，您有权决定何时部署更新，您甚至可以使用canary deployment或feature flags之类的技术，以可控和安全的方式推出更新。</p><h2 id="1080" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">版本控制</h2><p id="9ac9" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">对于库，根据用户的升级和部署时间表，您将同时拥有多个活动版本(如上所述)。事实上，真的没有办法完全避免它，即使尽最大努力协调更新，也会有一段时间同时有多个版本活动。</p><p id="63fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了服务，您就有了更多的控制权，您可以选择同时运行多个版本。这可以通过canary部署来完成，或者通过将API的版本放在URL中来并行运行多个版本，就像人们经常做的那样。</p><p id="a81b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有多种方法来版本化一个API，但是我没有发现任何一种是令人满意的。Sebastien Lambla 在这个话题上做了一个<a class="ae jp" href="https://serialseb.com/speaker/versions-are-evil/" rel="noopener ugc nofollow" target="_blank">式的精彩演讲</a>，讲述了其中的几种方法以及为什么它们都不好，所以如果你想了解更多关于API版本控制的危险，可以看看他的演讲。</p><h2 id="646b" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">向后兼容性</h2><p id="34dd" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">有了共享库，您可以使用<a class="ae jp" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>来传达更新的向后兼容性——其中主要版本更新意味着重大变化。如果您在您的版本中遵循语义版本化，那么可以用一种受控的、良好沟通的方式打破向后兼容性。</p><p id="37e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大多数包管理器<a class="ae jp" href="https://docs.npmjs.com/getting-started/semantic-versioning" rel="noopener ugc nofollow" target="_blank">支持语义版本</a>，允许用户决定自动更新是否应该增加到下一个主要版本或次要版本。</p><p id="c136" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于一项服务，如果你推出一个突破性的改变，那么它将打破任何依赖于你的服务的人。这就是它再次与版本化联系起来的地方，正如我已经说过的，没有一种常用的方法让我感到满意。在过去，我和我的团队进行过多次这样的讨论，他们总是以“总是保持向后兼容性”作为一般规则的决定而结束，除非环境要求我们必须打破规则，做一些特殊的事情。</p><h2 id="1c81" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">隔离</h2><p id="9f33" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">对于一个共享库，你通常会暴露出比你需要的更多的内容，尤其是在内部使用的时候。即使您已经仔细考虑了什么应该是库的公共API的一部分，消费者也总有办法通过反射来获取这些内部API。</p><p id="ca20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了服务，你会更加考虑通过服务的公共API公开什么。您必须这样做，因为您通过服务的公共API共享的任何东西都是一个显式的设计决策，需要付出努力。</p><p id="8eca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该服务的内部工作方式对消费者也是隐藏的，消费者没有直接(且容易)的方法来访问它们，因此我们共享代码的消费者意外依赖内部实现细节的风险较小。这里可能发生的最糟糕的事情是，如果你的API的消费者开始依赖那些(意外泄露的)实现细节作为特性…</p><h2 id="003e" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">失败</h2><p id="20a5" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">当一个库失败时，你的代码也失败了，这通常很明显，你可以得到出错的堆栈跟踪。</p><p id="d9ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于一个服务，它可能会失败，或者可能只是在您停止等待响应之前没有及时响应。作为一名消费者，你通常无法区分服务中断和速度缓慢。当这种情况发生时，如果您尝试执行的操作会修改状态，并且该操作<strong class="it hv">不是等幂</strong>，重试也会变得棘手。</p><p id="2ab5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">部分故障也很难处理，通常需要像<a class="ae jp" href="https://read.acloud.guru/how-the-saga-pattern-manages-failures-with-aws-lambda-and-step-functions-bc8f7129f900" rel="noopener ugc nofollow" target="_blank"> Saga模式</a>这样的复杂模式，以便回滚已经在事务中引入的状态更改。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff mk"><img src="../Images/59b2d6a06aa3e0aceeb7e262cb39df08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMwcZSmbjtGr4Cvd0aHOqQ.png"/></div></div></figure><h2 id="f2e3" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">潜伏</h2><p id="1777" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">最后，这可能是最明显的，调用服务会引入网络延迟，这明显高于调用库中的方法或函数。</p><h1 id="ca4d" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">管理共享基础架构</h1><p id="f259" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">我经常遇到的另一个问题是<em class="jq">“如何管理共享的AWS资源，比如DynamoDB表和Kinesis流？”</em>。</p><p id="3206" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你使用的是<code class="eh mg mh mi mj b">Serverless</code>框架，那么你可以直接在你的<code class="eh mg mh mi mj b">serverless.yml</code>文件中管理它们，并把它们作为额外的<em class="jq"> CloudFormation </em>资源添加进来，如下所示。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff ml"><img src="../Images/938b0647b8737be589a8f4ecd7bd3234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JDncuArgyUx04GrPXBBzw.png"/></div></div></figure><p id="a511" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这实际上是我在视频课程<a class="ae jp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">生产就绪无服务器</a>中采用的方法，但这是因为我带领学生构建的演示应用程序是一个具有良好定义的开始和结束状态的项目。</p><p id="3130" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是当你在构建一个会随着时间不断发展的产品时，在这样的项目中起作用的东西就不一定起作用了。在构建产品的背景下，这种方法存在一些问题。</p><h2 id="0136" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated"><code class="eh mg mh mi mj b">"sls remove" </code>可以删除用户数据</h2><p id="8bba" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">由于这些资源被绑定到<code class="eh mg mh mi mj b">Serverless</code>(框架)项目的<em class="jq"> CloudFormation </em>堆栈，如果您决定使用<code class="eh mg mh mi mj b">sls remove</code>命令删除这些功能，那么您也将删除这些资源，以及这些资源中的任何用户数据。</p><p id="ae42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使你没有故意运行<code class="eh mg mh mi mj b">sls remove</code>来反对生产，一想到有人可能有一天会不小心这么做就够令人担忧的了。</p><p id="2636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果发生这种情况，失去功能是一回事，经历系统停机是另一回事，失去所有生产用户数据和功能，并可能发现自己处于无法轻松恢复的境地…</p><p id="7b11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以——也应该——锁定IAM权限，这样开发人员就不会在生产中意外删除这些资源，这大大减少了这些意外。</p><p id="7276" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还应该利用DynamoDB提供的新的<a class="ae jp" href="https://aws.amazon.com/dynamodb/backup-restore/" rel="noopener ugc nofollow" target="_blank">备份功能</a>。</p><p id="be85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于Kinesis流，您应该使用Kinesis Firehose在S3备份源事件。这样，您甚至不必自己编写任何备份代码！</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff mm"><img src="../Images/2779422f601a71515caa893f375657ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrOKSUvfUofdSmEkzeu0sg.png"/></div></div></figure><p id="2328" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，即使有所有可用的备份选项，我仍然对将这些存储用户数据的资源与使用它们的计算层(即Lambda函数)的创建和删除联系起来感到不安。</p><h2 id="f45a" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">所有权往往不明确</h2><p id="44db" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">在<code class="eh mg mh mi mj b">serverless.yml</code>中管理共享基础设施的第二个问题是，当这些资源的所有权不明确时，您该怎么办？</p><p id="422c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于是<em class="jq">共享</em>资源，并不总是清楚哪个项目应该负责管理其<code class="eh mg mh mi mj b">serverless.yml</code>中的这些资源。</p><p id="30c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，Kinesis流可以消耗来自Lambda函数的事件，运行在EC2或您自己的数据中心的应用程序。由于它使用轮询模型，您可以使用Lambda函数处理Kinesis事件，或者在EC2和您自己的数据中心上运行消费者应用程序。</p><p id="fc8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们(Kinesis streams)作为一种方式存在，让你通知其他人在你的系统中发生的事件，现代分布式系统的设计是异构的，以允许更大的灵活性和在不同情况下选择正确权衡的能力。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff mn"><img src="../Images/69c11dfe26fc965c358cff73390d78fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1dgLm-etNYhydX9w6n6XA.png"/></div></div></figure><p id="f12c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使没有多生产者和多消费者Kinesis流的复杂情况，基本问题<em class="jq">“消费者还是生产者应该拥有流”</em>通常足以阻止我们，因为这里似乎没有(至少对我来说没有)明显的赢家。</p><h2 id="4134" class="ln kq hu bd kr lo lp lq kv lr ls lt kz jc lu lv ld jg lw lx lh jk ly lz ll ma dt translated">单独管理共享的AWS资源</h2><p id="75a3" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">我见过的一个更好的方法——也是我自己采用的——是在一个单独的存储库中管理这些共享的AWS资源，根据团队中可用的专业知识，使用<em class="jq"> Terraform </em>或<em class="jq"> CloudFormation </em>模板。</p><p id="ce18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这似乎是许多公司在他们的无服务器架构成熟到共享基础设施开始出现时采用的方法。</p><p id="118e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，就其本身而言，它甚至可能不是一种好的方式，因为它会给你的工作流程带来其他问题。</p><p id="630a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比如说。如果这些共享的资源由一个单独的基础设施团队管理，那么它会在您的开发和基础设施团队之间产生瓶颈和摩擦。</p><p id="cca2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，出于我提到的原因，相比之下，我仍然认为这比用你的<code class="eh mg mh mi mj b">serverless.yml</code>管理那些共享的AWS资源要好。</p><p id="3434" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你知道管理共享基础设施的其他方法，请在评论中告诉我，或者你可以通过twitter与我联系。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/5837aaab20de469e394bd79f724b3d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/0*gFirhm9mznsiJDP0.png"/></div></figure><p id="e838" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗨，我的名字是崔琰。我是一个<a class="ae jp" href="https://aws.amazon.com/developer/community/heroes/yan-cui/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> AWS无服务器英雄</strong> </a>和<a class="ae jp" href="https://bit.ly/production-ready-serverless?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">量产无服务器</strong> </a>的作者。</p><p id="b89f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您是否正在为无服务器而苦恼，或者需要最佳实践方面的指导？您希望有人审查您的架构并帮助您避免代价高昂的错误吗？别担心，我是来帮忙的。<a class="ae jp" href="https://theburningmonk.com/hire-me/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">说吧！</strong> </a></p><p id="b3ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这篇文章，为什么不跟随我并获得更多呢？</p><p id="5960" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我也很感激你对帕特里翁的支持。作为回报，你可以通过私人Slack频道和1-2-1辅导从我这里获得直接帮助。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><a href="https://www.patreon.com/bePatron?u=905909"><div class="fe ff mp"><img src="../Images/1c914d0136a01277b980b4bc89ea12bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/0*AsE_kuL4a6Gv7p9d.png"/></div></a></figure><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff mq"><img src="../Images/b790be843c9d3708a9f8cdeca8159dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2RKJFk982ysoXGiS.png"/></div></div></figure><p id="2861" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看我的新课程，<a class="ae jp" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">AWS步骤功能完整指南</strong> </a>。</p><p id="94ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="201c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击获取您的副本<a class="ae jp" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="fe ff mq"><img src="../Images/b37de55aacbf2a6485b680159f90e7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UtWGXb-MH75hsTPT.png"/></div></div></figure><p id="65f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="it hv">最佳实践</strong>、本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="d86d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码<strong class="it hv"> ytcui </strong>还可以获得<strong class="it hv">票面价格6折</strong>。</p><p id="62cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击获取您的副本<a class="ae jp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>