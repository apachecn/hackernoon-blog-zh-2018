<html>
<head>
<title>How Using NOLOCK Can Block Your Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NOLOCK如何阻止您的查询</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-using-nolock-can-block-your-queries-adc8611105ff?source=collection_archive---------11-----------------------#2018-01-29">https://medium.com/hackernoon/how-using-nolock-can-block-your-queries-adc8611105ff?source=collection_archive---------11-----------------------#2018-01-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/68b2aa3facd2dee9777442f8e806b22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8SS8CBjVNiXrdWkz.jpg"/></div></div></figure><p id="438f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:下面描述的问题适用于所有的选择查询，而不仅仅是那些带有NOLOCK提示的查询。它适用于NOLOCK查询的事实让我大吃一惊，因此有了这个标题。</p><p id="ae42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很多人不喜欢SQL Server中的<a class="ae kb" href="https://hackernoon.com/tagged/nolock" rel="noopener ugc nofollow" target="_blank"> NOLOCK </a>(即read uncommitted隔离级别)，因为它会返回不准确的数据。我已经看到很多警告开发人员不要检索未提交的读取的论点，因为它们会返回<a class="ae kb" href="https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/transaction-isolation-levels" rel="noopener ugc nofollow" target="_blank">脏数据、幻影读取和不可重复读取</a>。</p><p id="01eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我知道所有这些问题，但是有一个问题我直到最近才听说:<strong class="je hv"> NOLOCK可以阻止其他查询运行。</strong></p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="kg kh l"/></div><figcaption class="ki kj fg fe ff kk kl bd b be z ek"><em class="km">You can also watch this week’s </em><a class="ae kb" href="https://www.youtube.com/watch?v=3G1sgS4fFoQ" rel="noopener ugc nofollow" target="_blank"><em class="km">post on YouTube</em></a></figcaption></figure><p id="6d5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们后退一步，理解为什么我过去经常使用NOLOCK。我使用NOLOCK的一个相当典型的例子是当我想让一个查询整夜运行以返回一些大型数据集时。我可以接受数据中的一些不一致(来自脏读取等……)。我主要关心的是，我不希望长时间运行的查询妨碍其他进程。</p><p id="b3ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我一直认为NOLOCK是这种情况下的完美解决方案，因为它从不锁定它读取的数据——结果可能不完美，但至少查询不会对服务器上的任何其他进程产生负面影响。</p><p id="fc7b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我对NOLOCK理解错误的地方:<strong class="je hv">虽然NOLOCK <em class="ka">不会</em>锁定行级数据，但它<em class="ka">会</em>取出一个模式稳定性锁。</strong></p><p id="9b2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个<a class="ae kb" href="https://technet.microsoft.com/en-us/library/ms175519%28v=sql.105%29.aspx?f=255&amp;MSPPError=-2147217396" rel="noopener ugc nofollow" target="_blank">模式稳定性(Sch-S)锁</a>防止表的结构在查询执行时改变。所有SELECT语句，包括那些处于read uncommitted/NOLOCK隔离级别的语句，都会取出一个Sch-S锁。这是有意义的，因为我们不希望开始从表中读取数据，然后在数据检索的中途更改列结构。</p><p id="03ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，这也意味着可能会有一些操作被Sch-S锁阻塞。例如，在这种情况下，任何请求模式修改(Sch-M)锁的命令都会被阻塞。</p><p id="b9a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">什么命令请求Sch-M锁？</p><p id="7619" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">比如索引重建或sp_recompile表。这些是在我的夜间维护工作中运行的命令类型，我首先试图通过使用NOLOCK来避免伤害它们！</p><p id="a9c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重申一下，我曾经认为使用NOLOCK提示是在长时间运行的查询中防止阻塞的好方法。然而，结果是我的NOLOCK查询实际上阻塞了我的夜间索引作业(在这个例子中所有的SELECT查询都阻塞了，但是我发现NOLOCK特别容易引起误解)，这导致其他SELECT语句也被阻塞了！</p><p id="f9b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看看实际情况。这里我有一个查询，它创建一个数据库table，然后用NOLOCK运行一个长时间运行的查询:</p><pre class="kc kd ke kf fq kn ko kp kq aw kr dt"><span id="6fd8" class="ks kt hu ko b fv ku kv l kw kx">DROP DATABASE IF EXISTS [Sandbox] <br/>GO <br/>CREATE DATABASE [Sandbox] <br/>GO <br/>USE [Sandbox] <br/>GO <br/>DROP TABLE IF EXISTS dbo.Test <br/>CREATE TABLE dbo.Test <br/>( <br/>  c0 int IDENTITY PRIMARY KEY, <br/>  c1 varchar(700) default REPLICATE(‘a’,700) <br/>) <br/>CREATE NONCLUSTERED INDEX IX_Id ON dbo.Test (c1); <br/>GO</span><span id="ab0f" class="ks kt hu ko b fv ky kv l kw kx">INSERT INTO dbo.Test DEFAULT VALUES; <br/>GO 1000</span><span id="b52d" class="ks kt hu ko b fv ky kv l kw kx">-- Read a billion records <br/>SELECT * <br/>FROM dbo.Test t1 (NOLOCK) <br/>CROSS JOIN dbo.Test t2 (NOLOCK) <br/>CROSS JOIN dbo.Test t3 (NOLOCK)</span></pre><p id="c25a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，在读取十亿行的同时，我们可以通过查看sys.dm_tran_locks来验证查询是否获取了Sch-S锁:</p><pre class="kc kd ke kf fq kn ko kp kq aw kr dt"><span id="638a" class="ks kt hu ko b fv ku kv l kw kx">SELECT * <br/>FROM sys.dm_tran_locks <br/>WHERE resource_type = ‘OBJECT’</span></pre><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kz"><img src="../Images/bbfa44653dc205ff3f9da00831cca2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LrM-7E-PEL_mHAIU.png"/></div></div></figure><p id="8f35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当它运行时，如果我们试图重建一个索引，重建会被阻塞(显示为等待):</p><pre class="kc kd ke kf fq kn ko kp kq aw kr dt"><span id="377d" class="ks kt hu ko b fv ku kv l kw kx">USE [Sandbox] <br/>GO</span><span id="1706" class="ks kt hu ko b fv ky kv l kw kx">ALTER INDEX IX_Id ON dbo.Test REBUILD</span></pre><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff la"><img src="../Images/c5e5bdbfb88d768495e60a94021f0bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b_bGkkgee-8551oO.png"/></div></div></figure><p id="ffad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的索引重建查询将保持阻塞状态，直到我们的十亿行NOLOCK SELECT查询运行完毕(或者被终止)。这意味着我打算完全不引人注目的查询现在阻止了我的夜间索引维护作业的运行。</p><p id="f84b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更糟糕的是，任何其他试图在重建查询之后运行的查询(或者任何其他请求Sch-M锁的命令)也将被阻塞！如果我尝试运行一个简单的COUNT(*)查询:</p><pre class="kc kd ke kf fq kn ko kp kq aw kr dt"><span id="3bbc" class="ks kt hu ko b fv ku kv l kw kx">USE [Sandbox] <br/>GO</span><span id="e9ce" class="ks kt hu ko b fv ky kv l kw kx">SELECT COUNT(*) FROM dbo.Test</span></pre><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lb"><img src="../Images/b5dc6eaca17fe178cfdf5c9322fb073a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XzG45OTUB-xvoWki.png"/></div></div></figure><p id="34fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">屏蔽了！这意味着，不仅我的初始NOLOCK查询导致我的索引重建维护作业等待，重建维护作业放置的Sch-M锁也导致该表上的任何后续查询被阻塞并被迫等待。我刚刚用一个阻塞NOLOCK语句破坏了我的维护工作和后续查询的及时性！</p><h1 id="fae0" class="lc kt hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">解决方法</h1><p id="deca" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated">不幸的是，这是一个棘手的问题，没有放之四海而皆准的解决办法。</p><h1 id="8a7b" class="lc kt hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">解决方案1:不要运行长时间运行的查询</h1><p id="1b91" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated">我<em class="ka">可以</em>避免在晚上运行长时间的查询，因为它们可能会影响我的索引维护工作。这将防止那些索引维护作业和后续查询被延迟，但这意味着我最初的十亿行选择查询将不得不提前运行，从而在一天中可能更忙的时候对服务器<a class="ae kb" href="https://hackernoon.com/tagged/performance" rel="noopener ugc nofollow" target="_blank">性能</a>产生负面影响。</p><h1 id="da42" class="lc kt hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">解决方案2:使用低优先级等待</h1><p id="85f6" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated">从2014年开始，我可以使用WAIT_AT_LOW_PRIORITY选项集进行在线索引重建:</p><pre class="kc kd ke kf fq kn ko kp kq aw kr dt"><span id="b831" class="ks kt hu ko b fv ku kv l kw kx">ALTER INDEX IX_Id ON dbo.Test REBUILD <br/>WITH ( <br/>  ONLINE = ON (<br/>    WAIT_AT_LOW_PRIORITY (<br/>      MAX_DURATION = 1 MINUTES , <br/>      ABORT_AFTER_WAIT = BLOCKERS)))</span></pre><p id="ed9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该查询基本上给当前正在运行的任何阻塞SELECT查询1分钟的时间来完成执行，否则该查询将杀死它们，然后执行索引重建。或者，我们也可以设置ABORT_AFTER_WAIT = SELF，重建查询会自行终止，允许NOLOCK billion row SELECT完成运行，并且不会阻止任何其他查询的运行。</p><p id="3bb0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这不是一个很好的解决方案，因为这意味着要么长时间运行的查询被终止，要么索引重建被终止。</p><h1 id="fea8" class="lc kt hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">解决方案#3:如果没有Sch-S，则重新构建，否则重新组织</h1><p id="48c9" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated">可以编写一个尝试重建索引的编程解决方案，但是如果知道必须等待Sch-M锁，就退回到重新组织。</p><p id="e951" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我已经创建了下面的boiler板作为起点，但是你可以用它做的事情没有限制(例如，创建一个WHILE循环来每x秒检查一次锁，创建一个脚本应该停止尝试重新构建而只是重新组织的超时，等等)</p><pre class="kc kd ke kf fq kn ko kp kq aw kr dt"><span id="1f83" class="ks kt hu ko b fv ku kv l kw kx">-- Idea for how to rebuild/reorganize based on a schema stability lock.<br/>-- More of a starting point than fully functional code.<br/>-- Not fully tested, you have been warned!<br/>DECLARE <br/> <a class="ae kb" href="http://twitter.com/TableName" rel="noopener ugc nofollow" target="_blank">@TableName</a> varchar(128) = 'Test',<br/> <a class="ae kb" href="http://twitter.com/HasSchemaStabilityLo" rel="noopener ugc nofollow" target="_blank">@HasSchemaStabilityLo</a>ck bit = 0<br/> <br/>SELECT TOP 1 <a class="ae kb" href="http://twitter.com/HasSchemaStabilityLo" rel="noopener ugc nofollow" target="_blank">@HasSchemaStabilityLo</a>ck = <br/> CASE WHEN l.request_mode IS NOT NULL THEN 1 ELSE 0 END<br/> FROM<br/>  sys.dm_tran_locks as l<br/> WHERE<br/>  l.resource_type = 'OBJECT'<br/>  AND l.request_mode = 'Sch-S'<br/>  AND l.request_type = 'LOCK'<br/>  AND l.request_status = 'GRANT'<br/>  AND OBJECT_NAME(l.resource_associated_entity_id) = <a class="ae kb" href="http://twitter.com/TableName" rel="noopener ugc nofollow" target="_blank">@TableName</a><br/> <br/>IF <a class="ae kb" href="http://twitter.com/HasSchemaStabilityLo" rel="noopener ugc nofollow" target="_blank">@HasSchemaStabilityLo</a>ck = 0<br/>BEGIN<br/> -- Perform a rebuild<br/> ALTER INDEX IX_Id ON dbo.Test REBUILD<br/> PRINT 'Index rebuilt'<br/>END<br/>ELSE<br/>BEGIN<br/> -- Perform a REORG<br/> ALTER INDEX IX_Id ON dbo.Test REORGANIZE<br/> PRINT 'Index reorganized'<br/>END</span></pre><p id="e262" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个解决方案是我最喜欢的，因为:</p><ol class=""><li id="fbe6" class="me mf hu je b jf jg jj jk jn mg jr mh jv mi jz mj mk ml mm dt translated">特别长时间运行的查询不会被终止(所有花费在处理上的时间不会浪费)</li><li id="b7ad" class="me mf hu je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">Sch-M锁尝试通过REBUILD不会阻止其他选择查询</li><li id="8532" class="me mf hu je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">索引维护仍然会发生，即使最终是重组而不是重建</li></ol><p id="b7ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">感谢阅读。你可能也会喜欢</em> <a class="ae kb" href="https://twitter.com/bertwagner" rel="noopener ugc nofollow" target="_blank"> <em class="ka">在推特上关注我。</em> </a></p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ms kh l"/></div></figure><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ms kh l"/></div></figure></div></div>    
</body>
</html>