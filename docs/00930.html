<html>
<head>
<title>Building a Seamless Image and Video Experience for the Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为网络构建无缝的图像和视频体验</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-seamless-image-and-video-experience-for-the-web-62d7406f3ef2?source=collection_archive---------18-----------------------#2018-01-29">https://medium.com/hackernoon/building-a-seamless-image-and-video-experience-for-the-web-62d7406f3ef2?source=collection_archive---------18-----------------------#2018-01-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9c40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jp" href="https://geniusteacher.in" rel="noopener ugc nofollow" target="_blank"> Genius </a>，我们将现实世界的事件和行动与学术概念联系起来的独特方法使数学、科学和英语对孩子们极具吸引力！我们通过<a class="ae jp" href="https://developers.google.com/web/progressive-web-apps/" rel="noopener ugc nofollow" target="_blank">渐进式网络应用(PWA) </a>、Android和iOS提供的引人入胜的解释和有趣的评估，大量使用了静态图像、动画图像和视频。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/2f4a586f55fb9b3c5c6853781f4c7789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9Nu5GNeOn0Ay5q0zRBXpA.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">A Genius way of learning</figcaption></figure><h1 id="5d6b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">当前的需要</h1><p id="4570" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">曾经有一段时间，用户有足够的耐心等待媒体加载。现在，0.5秒或更长的图像加载时间是不可接受的。参差不齐的体验不能让用户满意，违背了伟大产品的宗旨。尽管世界各地的互联网连接正在显著改善，但延迟和带宽波动仍然十分普遍。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/31d397dc3fb46a5dd4ae70e06b76d4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*OY59qRzy_AjcYuThb1WBaA.gif"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">A typical Joe, not impressed with your service</figcaption></figure><p id="7a5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章将帮助你为最坏的情况做准备，并尽可能快地使你的媒体可用。通过优化3个主要因素，提供了出色的流畅体验:</p><ol class=""><li id="d5e0" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated"><strong class="it hv">资产下载期间的用户体验</strong>。</li><li id="02e5" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><strong class="it hv">减少下载时间。</strong></li><li id="de1a" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><strong class="it hv">浏览器缓存</strong>实现近乎即时的加载。</li></ol><p id="c97c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多文章有助于解决这样或那样的问题。这篇文章几乎完整地总结了在参差不齐的网络上运行流畅的富媒体web应用的解决方案。它是为理解web开发基础的用户设计的——HTML、CSS、HTTP请求和常见的浏览器行为。</p><p id="aa7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Genius，我们大量使用Typescript、React和Node.js。我们的pwa、内部仪表盘、工具和服务器应用程序都是用它们构建的。自然，解决方案也在我们的专业领域中呈现。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h1 id="9304" class="kg kh hu bd ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld dt translated">用户体验</h1><p id="52e9" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">保持用户参与。给他们看一些融入即将到来的东西。以下是我们在Genius部署的几种方法，让我们的体验变得更好。</p><h2 id="05b7" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">动画加载区域</h2><p id="ad34" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">一个简单的矩形，用两种颜色制作动画，在提供一种“有事发生”的心理感觉方面大有帮助。它创造了一个事件，潜意识地记录下来，并欺骗它相信，“让我等着，看看会出现什么。”</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/311939ac65d495bfb1f6ce0549845b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/1*IdEliwJXbNtBWfBWlgl02Q.gif"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">An animating box of subconscious trickery</figcaption></figure><p id="ba2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用普通CSS很容易实现这样一个简单的功能。</p><p id="e1b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，为背景色定义一组关键帧。</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="35c6" class="mk kh hu na b fv ne nf l ng nh"><a class="ae jp" href="http://twitter.com/keyframes" rel="noopener ugc nofollow" target="_blank">@keyframes</a> loading {<br/>  0% { background-color: #e0e0e0; }<br/>  50% { background-color: #eeeeee; }<br/>  100% { background-color: #e0e0e0; }<br/>}</span></pre><p id="1d03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在CSS类中制作动画。</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="788c" class="mk kh hu na b fv ne nf l ng nh">.img-container {<br/>  background-color: #ffffff;<br/>  animation: loading 1.3s ease-in-out infinite;<br/>  -webkit-animation: loading 1.3s ease-in-out infinite;<br/>}</span></pre><p id="6551" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用图像容器中的类，它将有<code class="eh ni nj nk na b">&lt;img&gt;</code>标签。</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="6a9d" class="mk kh hu na b fv ne nf l ng nh">&lt;div class="img-container" style="height: 500px; width: 650px;"&gt;<br/>    &lt;img src="stove.jpg"&gt;<br/>&lt;/div&gt;</span></pre><h2 id="b1c0" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">渐进加载</h2><p id="87b0" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">JPEG有两种类型——<strong class="it hv">基线</strong>和<strong class="it hv">渐进</strong>。渐进式首先显示完整的低质量图像，并在数据到达时提高精度。这也导致更小的图像(细节如下)。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/3774a079c35a0a29ae05a726b7c2a8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*hQD3H8mmgq-JQvhz.jpg"/></div></figure><p id="552e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多在线工具<a class="ae jp" href="https://www.jpeg.io/" rel="noopener ugc nofollow" target="_blank">来构建渐进图像。在Genius，我们构建了一个Node.js包(用Typescript编写),用于解析和打包我们的内容和媒体。它使用</a><a class="ae jp" href="https://github.com/lovell/sharp" rel="noopener ugc nofollow" target="_blank">洛弗尔富勒的夏普</a>来调整大小，使所有JPEG渐进。</p><p id="5e75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">渐进式JPEG会带来更好的体验吗？答案是不确定的。这可能会导致更多的参与，但研究表明，由于认知负荷的增加，这可能会导致用户幸福感的下降。</p><p id="96c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Genius，我们最终使用了progressive来保持用户参与，并保持JPEG的最小尺寸(下面将详细介绍)。</p><h2 id="07cd" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">视频海报图像</h2><p id="4316" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">视频的<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-poster" rel="noopener ugc nofollow" target="_blank">海报图像</a>是视频下载时吸引用户的第一个机会。从<a class="ae jp" href="https://hackernoon.com/tagged/user-experience" rel="noopener ugc nofollow" target="_blank">用户体验</a>的角度来说，不放海报是个馊主意。这有助于保持用户潜意识的参与。</p><p id="d44e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">海报图像通过视频元素<code class="eh ni nj nk na b">&lt;video&gt;</code>上的属性<code class="eh ni nj nk na b">poster</code>提供。</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="e6f0" class="mk kh hu na b fv ne nf l ng nh">&lt;video poster="poster.jpg" controls&gt;<br/>  &lt;source src="movie.mp4" type="video/mp4"&gt;<br/>&lt;/video&gt;</span></pre></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h1 id="90de" class="kg kh hu bd ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld dt translated">减少下载时间</h1><p id="cc7c" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">为了缩短任何资源的下载时间，我们可以优化3个主要因素:</p><ol class=""><li id="bd73" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated"><strong class="it hv">资产大小</strong>:降低图像和视频的分辨率，使用正确的编码格式进一步降低尺寸。</li><li id="0802" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><strong class="it hv"> HTTP协议</strong> : HTTP/2把HTTP/1.x留在尘埃里。</li><li id="bd07" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><strong class="it hv">请求队列</strong>:请求队列中未完成的条目不再需要，增加了需要的资产的加载时间。</li></ol><h2 id="2ed8" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated"><strong class="ak">缩减资产</strong></h2><p id="2ef0" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">最好的情况是在保持可接受的质量的同时，以最佳的格式和压缩提供最小分辨率的图像/视频。人们通常认为，除非你是一家注重质量的“照相馆”，否则就不能提供高分辨率、高质量的图像。主要有两种方法:</p><ol class=""><li id="5c07" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">让浏览器从一组图像/视频中做出决定的客户端HTML</li><li id="045b" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">服务器以URL中指定的分辨率发送精确调整大小的图像</li></ol><h2 id="c6fa" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated"><strong class="ak">客户端HTML </strong></h2><p id="65a6" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">使用带有HTML <code class="eh ni nj nk na b"><a class="ae jp" href="https://www.w3schools.com/tags/tag_picture.asp" rel="noopener ugc nofollow" target="_blank">&lt;picture&gt;</a></code>和<code class="eh ni nj nk na b"><a class="ae jp" href="https://www.w3schools.com/tags/tag_source.asp" rel="noopener ugc nofollow" target="_blank">&lt;source&gt;</a></code>标签的<a class="ae jp" href="https://www.w3schools.com/css/css_rwd_mediaqueries.asp" rel="noopener ugc nofollow" target="_blank"> CSS媒体查询</a>使得让浏览器决定加载哪个图像变得非常简单。你所要做的就是创建多个版本的图像并保存在服务器上。这里有一个例子:</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="ed34" class="mk kh hu na b fv ne nf l ng nh">&lt;picture&gt;<br/>  &lt;source media="(min-width: 451px)" srcset="picture-660x414.jpg"&gt;<br/>  &lt;source media="(max-width: 450px)" srcset="picture-330x207.jpg"&gt;<br/>  &lt;img src="picture-330x207.jpg"&gt;<br/>&lt;/picture&gt;</span></pre><p id="60a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于<code class="eh ni nj nk na b">&lt;picture&gt;</code>和<code class="eh ni nj nk na b">&lt;source&gt;</code>标签相对较新，为了与旧浏览器兼容，我们还包含了<code class="eh ni nj nk na b">&lt;img&gt;</code>标签。</p><p id="e370" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您打开开发人员控制台，您将看到不同的请求。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nm"><img src="../Images/1e3e1faceb336df7a248e536259f972f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yR01sJrbLhWYhr52ykpC3A.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">900 x 521 resolution is loaded on desktop</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nn"><img src="../Images/a5d9645a316645340ddb3fac7ab13af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2mZEtnebJ1etYLwdqzgVg.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">450 x 261 resolution is loaded on mobile devices</figcaption></figure><p id="6363" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于视频，用<code class="eh ni nj nk na b">&lt;video&gt;</code>元素替换<code class="eh ni nj nk na b">&lt;picture&gt;</code>元素将加载相应分辨率的视频。你必须以不同的分辨率对视频进行编码，并将其存储在你的系统中。在Genius，我们使用FFmpeg来自动化我们所有的视频任务。</p><h2 id="9668" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated"><strong class="ak">服务器端调整大小和缓存</strong></h2><p id="2495" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">这是通过在URL中发送图像的预期宽度/高度来实现的。服务器根据每个请求调整目标文件的大小，或者从缓存(如果存在的话)中提供服务。这是一个相对更复杂的解决方案，因为(I)需要在客户机上计算预期的宽度/高度，以便为<code class="eh ni nj nk na b">src</code>属性创建URL，以及(ii)服务器需要理解这些参数，以便(iii)调整图像的大小并缓存图像。</p><p id="4eb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很多CDN(内容交付网络)服务像<a class="ae jp" href="https://support.cloudflare.com/hc/en-us/articles/200168106-Does-Cloudflare-offer-image-optimization-features-" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>、<a class="ae jp" href="https://www.akamai.com/uk/en/products/web-performance/image-manager.jsp" rel="noopener ugc nofollow" target="_blank"> Akamai </a>等。附带图像大小调整功能。甚至像<a class="ae jp" href="http://nginx.org/en/docs/http/ngx_http_image_filter_module.html" rel="noopener ugc nofollow" target="_blank"> Nginx这样针对静态内容交付优化的软件也支持</a>它。对于Node.js，我们用<a class="ae jp" href="https://github.com/jimmynicol/image-resizer" rel="noopener ugc nofollow" target="_blank"> image-resizer </a>(基于<a class="ae jp" href="https://github.com/lovell/sharp" rel="noopener ugc nofollow" target="_blank"> Sharp </a>)进行了实验，发现它相当<a class="ae jp" href="http://sharp.dimens.io/en/stable/performance/" rel="noopener ugc nofollow" target="_blank">快</a>。</p><h2 id="9441" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">WebP而不是JPG和巴布亚新几内亚</h2><p id="a90d" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">对于相同的质量，WebP产生的图像比JPG和PNG小20-35%。唯一的警告是，它只在Chrome、Opera和Chrome的变种上受支持。因此，需要注意提供正确的文件(此处极好地概括了<a class="ae jp" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/automating-image-optimization/#how-do-i-serve-webp" rel="noopener ugc nofollow" target="_blank">)。</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff no"><img src="../Images/aafc53894dd2e2da8f612c43820334c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FzIvr-gqmq0p3oSdQJAAA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">WebP gives huge savings over JPG and PNG</figcaption></figure><p id="4e75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的内部工具使用<a class="ae jp" href="http://sharp.pixelplumbing.com/en/stable/api-output/#webp" rel="noopener ugc nofollow" target="_blank"> Sharp </a>来创建所有图像的WebP变体。例如，对于<code class="eh ni nj nk na b">picture.jpg</code>，我们创建一个优化的JPEG，<code class="eh ni nj nk na b">picture.jpg</code>和一个WebP，<code class="eh ni nj nk na b">picture.jpg.webp</code>。我们有一个Nginx反向代理，它通过HTTP请求的<code class="eh ni nj nk na b">Accept</code>报头检测<code class="eh ni nj nk na b">webp</code>支持(在字符串中寻找<code class="eh ni nj nk na b">webp</code>)并提供正确的web图像。</p><h2 id="d4ae" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated"><strong class="ak"> JPEG、PNG和SVG优化</strong></h2><p id="7f86" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我们遵循一个简单的两步规则来决定图像类型，并使用<a class="ae jp" href="https://github.com/lovell/sharp" rel="noopener ugc nofollow" target="_blank"> Sharp </a>来优化它们。</p><ol class=""><li id="5467" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">如果是现实世界的照片或者接近现实世界的照片，就用JPEG。</li><li id="b23e" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">如果颜色和曲线的数量有限，请使用PNG/SVG(徽标和图标)</li></ol><p id="a294" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">渐进式JPEG <br/> </strong>除了更好的用户体验，将JPEG编码为渐进式也会导致图像尺寸变小。只有当源图像超过10 KB时，这种情况才会出现。对于小于10 KB的文件，首选基准JPEG。查看<a class="ae jp" href="https://yuiblog.com/blog/2008/12/05/imageopt-4/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>做一个基础实验。</p><h2 id="129b" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">没有gif。用MP4。</h2><p id="287d" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">图形交换格式(GIF)是在互联网的石器时代创建的，甚至不是为动画设计的。GIF规范<a class="ae jp" href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt" rel="noopener ugc nofollow" target="_blank">明确指出:</a></p><blockquote class="np nq nr"><p id="3c8e" class="ir is ns it b iu iv iw ix iy iz ja jb nt jd je jf nu jh ji jj nv jl jm jn jo hn dt translated">图形交换格式并不打算作为一个动画平台，即使它能以一种有限的方式完成。</p></blockquote><p id="135c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/automating-image-optimization/" rel="noopener ugc nofollow" target="_blank">根据谷歌</a>，</p><blockquote class="np nq nr"><p id="3ad6" class="ir is ns it b iu iv iw ix iy iz ja jb nt jd je jf nu jh ji jj nv jl jm jn jo hn dt translated">将相同的文件作为MP4视频传输通常可以减少80%或更多的文件大小。gif不仅经常浪费大量带宽，而且加载时间更长，颜色更少，用户体验通常也不尽如人意。</p></blockquote><p id="2ba3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Genius，我们从工具中调用<a class="ae jp" href="https://www.ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> FFmpeg </a>将GIF转换成MP4。我们已经看到700 KB的GIF变成了170 KB的MP4。下面是一个将<code class="eh ni nj nk na b">animated.gif</code>转换为<code class="eh ni nj nk na b">video.mp4</code>的命令(灵感来自<a class="ae jp" href="https://rigor.com/blog/2015/12/optimizing-animated-gifs-with-html5-video" rel="noopener ugc nofollow" target="_blank">这篇博客</a>)。</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="800a" class="mk kh hu na b fv ne nf l ng nh">ffmpeg -i animated.gif -movflags faststart -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" video.mp4</span></pre><h2 id="475d" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">使用HTTP/2</h2><p id="2c0e" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">HTTP/2是一个新的用于HTTP请求的协议。这是一种二进制、完全多路复用的协议，支持报头压缩。换句话说，它可以使用1个TCP连接并行加载多个文件。这使得在HTTP/2上加载资产非常快，并且因为压缩了头，所以消耗的带宽更少。这篇<a class="ae jp" href="https://css-tricks.com/http2-real-world-performance-test-analysis/" rel="noopener ugc nofollow" target="_blank">css-tricks.com的博客</a>有详细的性能分析。</p><p id="8791" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Genius，我们使用AWS <a class="ae jp" href="https://aws.amazon.com/elasticloadbalancing/" rel="noopener ugc nofollow" target="_blank">弹性负载平衡器</a>和<a class="ae jp" href="https://aws.amazon.com/cloudfront/" rel="noopener ugc nofollow" target="_blank"> CloudFront </a>作为我们的端点。默认情况下，这两种服务都使用HTTP/2。</p><h2 id="5ee5" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">清除请求队列中未完成的条目</h2><p id="c581" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">当网络变得断断续续时，我们的单页应用程序(SPAs)出现了不良行为。通过前面屏幕上的<code class="eh ni nj nk na b">&lt;img&gt;</code>和<code class="eh ni nj nk na b">&lt;video&gt;</code>元素请求的资产仍然保留在网络下载队列中，即使相应的元素已从HTML中删除。这反过来延迟了需要在当前视图中显示的资产的下载。</p><p id="fe67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">清除<code class="eh ni nj nk na b">&lt;img&gt;</code>元素上的<code class="eh ni nj nk na b">src</code>属性会立即取消请求。下面是Typescript中实现此功能的React组件。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="nw nx l"/></div></figure><p id="52ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<code class="eh ni nj nk na b">&lt;video&gt;</code>元素，从<code class="eh ni nj nk na b">source</code>元素中移除<code class="eh ni nj nk na b">src</code>属性，并在挂载的<code class="eh ni nj nk na b">&lt;video&gt;</code>元素上调用<code class="eh ni nj nk na b">load</code>。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="nw nx l"/></div></figure><p id="b759" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样，一旦从HTML中删除了元素，浏览器就会取消下载请求，并将<code class="eh ni nj nk na b">(canceled)</code>设置为这些请求的状态。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ny"><img src="../Images/fc2c60e346af5c6c7302f119fb6dbee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXAJDYW_KMM3gpc2CmYdVA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Canceled network requests</figcaption></figure></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h1 id="27a1" class="kg kh hu bd ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld dt translated">浏览器缓存</h1><p id="65be" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">正确缓存资源可以帮助浏览器在再次获取相同资源时完全避免网络调用。有两种类型的缓存——一种是将资产持久存储在永久存储器上(持久),另一种是基于内存的(非持久),因此是特定于应用程序会话的。</p><p id="81bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">高级浏览器中有4种类型的缓存。请求会按以下顺序遇到它们。</p><ol class=""><li id="57c8" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">内存缓存——顾名思义，它在内存中缓存资产。</li><li id="fdbb" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><a class="ae jp" href="https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker" rel="noopener ugc nofollow" target="_blank">服务工作者缓存</a> —服务工作者使用的永久缓存(使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存API </a>)。</li><li id="8c18" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><a class="ae jp" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" rel="noopener ugc nofollow" target="_blank"> HTTP缓存</a> —根据HTTP请求中设置的<code class="eh ni nj nk na b">cache-control</code>头持久保存响应。</li><li id="965b" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">HTTP/2 Cache —在内存中缓存由HTTP/2推送的资产。</li></ol><p id="32f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由Yoav Weiss撰写的一篇有趣的文章“四个缓存的故事”解释了这四个缓存是如何协同工作的。</p><h2 id="741e" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">HTML预加载</h2><p id="6b72" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">HTML <code class="eh ni nj nk na b">preload</code>是一个声明性的获取，强制浏览器在使用资源之前请求它。它可以用于将资产预加载到HTTP和内存缓存中，这些资产在不久的将来会被用到。例如，当有人阅读博客的第一页时，我们可以预加载第二页的图像。</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="4d68" class="mk kh hu na b fv ne nf l ng nh">&lt;link rel="preload" as="image" href="sunlight-trees.jpg"&gt;</span></pre><p id="36a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有与<code class="eh ni nj nk na b">preload</code>不同的<code class="eh ni nj nk na b">prefetch</code>声明。这里有一篇来自艾迪·奥斯马尼的很棒的<a class="ae jp" rel="noopener" href="/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">文章，深入描述了<code class="eh ni nj nk na b">prefetch</code>和<code class="eh ni nj nk na b">preload</code>。</a></p><p id="5b2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一点我们没有意识到。不像<code class="eh ni nj nk na b">preload</code>可以加载资产为<code class="eh ni nj nk na b">image</code>、<code class="eh ni nj nk na b">font</code>、<code class="eh ni nj nk na b">script</code>,<code class="eh ni nj nk na b">prefetch</code>声明不能加载资源类型的资产。简单地说，上面块中的<code class="eh ni nj nk na b">preload</code>声明将设置<code class="eh ni nj nk na b">Accept</code>头，就好像请求是由<code class="eh ni nj nk na b">&lt;img&gt;</code>元素发出的一样。<code class="eh ni nj nk na b">prefetch</code>不支持<code class="eh ni nj nk na b">as="image"</code>属性，总是将<code class="eh ni nj nk na b">Accept</code>头设置为<code class="eh ni nj nk na b">*/*</code>。这使得<code class="eh ni nj nk na b">prefetch</code>不受欢迎，因为当它在HTML中使用时，浏览器无论如何都会重新获取资源。</p><h2 id="f652" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated"><strong class="ak"> HTTP缓存</strong></h2><p id="521e" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">浏览器<a class="ae jp" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" rel="noopener ugc nofollow" target="_blank"> HTTP缓存</a>主要有3种模式，由<code class="eh ni nj nk na b"><a class="ae jp" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching/#cache-control" rel="noopener ugc nofollow" target="_blank">Cache-Control</a></code> HTTP头控制。</p><ol class=""><li id="d293" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">不缓存-不存储响应。通过设置响应HTTP头<code class="eh ni nj nk na b">Cache-Control: no-store</code>实现。</li><li id="c530" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">每次都要重新验证—存储响应，但在使用响应之前要经过服务器验证。设置响应HTTP头<code class="eh ni nj nk na b">Cache-Control: no-cache</code>和<code class="eh ni nj nk na b"><a class="ae jp" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching/#validating_cached_responses_with_etags" rel="noopener ugc nofollow" target="_blank">ETag</a></code> <a class="ae jp" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching/#validating_cached_responses_with_etags" rel="noopener ugc nofollow" target="_blank">头</a>，唯一标识交付的资源。如果<code class="eh ni nj nk na b">ETag</code>与服务器上的最新文件不匹配，服务器返回新文件，否则返回HTTP状态304。</li><li id="99d9" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">不要在指定的时间内重新验证—存储响应，直到指定的时间到期时才询问服务器。通过设置<code class="eh ni nj nk na b">Cache-Control: public, max-age:&lt;seconds&gt;</code>实现。秒指定时间(最大值为31536000 (1年))，直到客户端将提供缓存的响应，而不是向服务器请求新的响应。</li></ol><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nz"><img src="../Images/e7536f2cf284948d2965ed3606117c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*eQngeXZh8xnEjbFZ.jpg"/></div></figure><p id="cc52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当对应于URL的资产将来可能改变时，使用第二种模式。例如，如果图像URL包含的只是文件名<code class="eh ni nj nk na b"><a class="ae jp" href="https://example.com/pic.jpg" rel="noopener ugc nofollow" target="_blank">https://example.com/pic.jpg</a></code>。</p><p id="d539" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您可以为每个资源生成唯一的URL时，请使用第三种模式。例如，通过在名称<code class="eh ni nj nk na b"><a class="ae jp" href="https://example.com/pic.jpg" rel="noopener ugc nofollow" target="_blank">https://example.com/pic-6a8sd6d82.jpg</a></code>中散列图像内容。</p><p id="70c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Genius，我们所有的图像名称都包含hash。因此，我们总是使用第三种模式。一旦我们发送了图像，客户端不会询问服务器，除非缓存被删除或者一年过去了。这在提供无缝体验的同时，节省了用户和服务器带宽。</p><h2 id="0f94" class="mk kh hu bd ki ml mm mn km mo mp mq kq jc mr ms ku jg mt mu ky jk mv mw lc mx dt translated">服务工作者缓存</h2><p id="d430" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">服务人员<a class="ae jp" href="https://developers.google.com/web/fundamentals/primers/service-workers/" rel="noopener ugc nofollow" target="_blank">是网络开发的新潮流，用于构建丰富的离线体验等等。服务人员在后台运行脚本，与网页分开。我们感兴趣的特性是能够拦截来自web应用程序的请求，并提供来自缓存的响应，作为开发人员，我们为应用程序管理缓存。</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff oa"><img src="../Images/f1fce5433dca40e70b7be3d16dd03278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uRt9oFRra1Pp86_-.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Asset caching strategy. Taken from the <a class="ae jp" href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/" rel="noopener ugc nofollow" target="_blank">offline cookbook</a>.</figcaption></figure><p id="ef66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建一个服务人员会变得非常复杂。为了让生活变得简单，谷歌的好人们开发了<a class="ae jp" href="https://developers.google.com/web/tools/workbox/" rel="noopener ugc nofollow" target="_blank">工具箱</a>，它只需要一个安装服务工人和管理缓存的配置。例如，为了缓存对<code class="eh ni nj nk na b"><a class="ae jp" href="https://example.com/image/," rel="noopener ugc nofollow" target="_blank">https://example.com/image/</a></code>的所有请求，我们最多在1周内缓存不超过20个图像，我们所要做的就是像这样编写一个配置。</p><pre class="jr js jt ju fq mz na nb nc aw nd dt"><span id="9e8c" class="mk kh hu na b fv ne nf l ng nh">workboxSW.router.registerRoute(<br/>  '<a class="ae jp" href="https://httpbin.org/image/(.*)'," rel="noopener ugc nofollow" target="_blank">https://example.com/image/(.*)',</a><br/>  workboxSW.strategies.cacheFirst({<br/>    cacheName: 'images',<br/>    cacheExpiration: {<br/>      maxEntries: 50,<br/>      maxAgeSeconds: 7 * 24 * 60 * 60,<br/>    },<br/>    cacheableResponse: {statuses: [0, 200]},<br/>  })<br/>);</span></pre><p id="b637" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看这个详细的<a class="ae jp" href="https://workbox-samples.glitch.me/examples/workbox-sw/" rel="noopener ugc nofollow" target="_blank">例子</a>。</p><h1 id="2447" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结束了</h1><p id="09bd" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">唷！这是很多信息。恭喜你读到最后。如果你发现有任何方面的缺失，请在下面的评论中提出来，这样这个文档就可以得到改进，变得更加有用。谢谢！</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ob nx l"/></div></figure></div></div>    
</body>
</html>