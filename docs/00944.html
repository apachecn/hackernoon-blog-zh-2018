<html>
<head>
<title>Building a website with React and Bulma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与React和布尔玛一起建立网站</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-website-with-react-and-bulma-d655214bff2a?source=collection_archive---------2-----------------------#2018-01-30">https://medium.com/hackernoon/building-a-website-with-react-and-bulma-d655214bff2a?source=collection_archive---------2-----------------------#2018-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="b7c0" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">React博客系列:第一部分</h2></div><p id="ab13" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章是关于用React创建博客的每周系列文章的第一部分，也是本系列其他文章的基础。</p><h2 id="fc14" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">React博客系列</h2><p id="f828" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><strong class="jl hv">第一部分:</strong>用React和布尔玛<br/> <a class="ae lf" rel="noopener" href="/@aaron.klaser/building-a-blog-with-react-and-contentful-fd538f68f6fb"> <strong class="jl hv">建立一个网站第二部分:</strong>用React和Contentful建立一个博客</a> <br/> <a class="ae lf" rel="noopener" href="/@aaron.klaser/import-your-medium-feed-into-react-ceadbaf785c7"> <strong class="jl hv">第三部分:</strong>将你的媒体提要导入React </a> <br/> <a class="ae lf" rel="noopener" href="/@aaron.klaser/adding-redux-to-a-react-blog-97f5fea606c2"> <strong class="jl hv">第四部分:</strong>向React博客添加一个Redux</a><br/><a class="ae lf" href="https://hackernoon.com/replacing-redux-thunks-with-redux-sagas-4aa306854925" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">第五部分:</strong>用Redux Sagas替换Redux Thunks</a></p></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="32d5" class="lo kg hu bd kh lp lq lr kl ls lt lu kp ja lv jb ks jd lw je kv jg lx jh ky ly dt translated">设置</h1><p id="dbb4" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">所以让我们安装<strong class="jl hv">反应</strong></p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="839f" class="kf kg hu me b fv mi mj l mk ml">npm install -g create-react-app aaronklaser<br/>cd aaronklaser<br/>npm start</span></pre><p id="522c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，让我们安装一些我们知道会需要的东西:</p><p id="cc32" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">反应头盔<br/>布尔玛<br/>布尔玛扩展<br/>瞬间<br/>样式组件</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="1674" class="kf kg hu me b fv mi mj l mk ml">npm install bulma bulma-extensions moment react-helmet styled-components --save</span></pre><h2 id="597b" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">安装程序对使用Sass做出反应</h2><p id="47bf" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">这可能不是完全必要的，因为我们将主要使用样式化的组件，但这将使导入布尔玛更加容易。</p><p id="7f23" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，对于棘手的部分，我们需要设置Sass，但我不想从创建-反应-应用程序弹出。我跟着这个<a class="ae lf" href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-a-css-preprocessor-sass-less-etc" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="91f0" class="kf kg hu me b fv mi mj l mk ml">npm install --save node-sass-chokidar</span></pre><p id="17cc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将创造。我们的css文件。scss文件，我对它不是很感兴趣，但是现在让我们开始吧。我们希望忽略git中的css文件，所以将<code class="eh mm mn mo me b">src/**/*.css</code>添加到我们的。gitignore文件。</p><p id="4fcc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">安装npm-run-all，这样我们就可以在npm start中包含我们的scss构建</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="8c1e" class="kf kg hu me b fv mi mj l mk ml">npm install --save npm-run-all</span></pre><p id="54b6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在npm脚本的package.json中，添加build-css和watch-css、build-js和watch-js，修改build并开始使用我们所有的新scss内容。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="996f" class="kf kg hu me b fv mi mj l mk ml">"scripts": {<br/>  "build-css": "<!-- -->node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/<!-- -->",<br/>  "watch-css": "<!-- -->npm run build-css &amp;&amp; node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/ --watch --recursive<!-- -->",<br/>  "start-js": "react-scripts start",<br/>  "start": "npm-run-all -p watch-css start-js",<br/>  "build-js": "react-scripts build",<br/>  "build": "npm-run-all build-css build-js",  <br/>  "test": "react-scripts test --env=jsdom",<br/>  "eject": "react-scripts eject"<br/>}</span></pre><p id="f3d1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:在build-css和watch-css中都包含<code class="eh mm mn mo me b">--include-path ./src --include-path ./node-modules</code>是很重要的。这允许我们的代码在节点模块文件夹中找到像布尔玛这样的库。</p><h2 id="d020" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">添加布尔玛和布尔玛扩展</h2><p id="37ca" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们将在索引组件中包括布尔玛和任何布尔玛配置。首先将<code class="eh mm mn mo me b">index.css</code>重命名为<code class="eh mm mn mo me b">index.scss</code>，然后使用<code class="eh mm mn mo me b">npm start</code>重启你的应用</p><p id="203d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果什么都没有发生，并且您的项目现在包括index.scss <strong class="jl hv">和</strong> index.css，那么这意味着一切都正常工作。</p><p id="46a9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，在index.scss中导入bulma。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="3387" class="kf kg hu me b fv mi mj l mk ml">@import 'bulma/bulma';<br/>@import 'bulma-extensions/extensions';</span></pre><p id="ff6e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，我要做一些额外的步骤，包括一个额外的颜色，因为布尔玛不包括紫色在其默认的颜色，我想要紫色。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="2212" class="kf kg hu me b fv mi mj l mk ml"><em class="lg">// 1. Import the initial variables<br/></em>@import "bulma/sass/utilities/initial-variables";<br/>@import "bulma/sass/utilities/functions";</span><span id="b794" class="kf kg hu me b fv mp mj l mk ml"><em class="lg">// 2. Setup your Custom Colors<br/></em>$purple: hsl(275,87%,45%);<br/>$purple-invert: findColorInvert($purple);</span><span id="70f3" class="kf kg hu me b fv mp mj l mk ml"><em class="lg">// 3. Add new color variables to the color map.<br/></em>@import "bulma/sass/utilities/derived-variables.sass";</span><span id="a9c3" class="kf kg hu me b fv mp mj l mk ml">$addColors: (<br/>  "purple":($purple, $purple-invert),<br/>);</span><span id="c326" class="kf kg hu me b fv mp mj l mk ml">$colors: map-merge($colors, $addColors);</span><span id="0a6f" class="kf kg hu me b fv mp mj l mk ml">@import 'bulma/bulma';<br/>@import 'bulma-extensions/extensions';</span></pre><p id="1503" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一切都应该启动了，你的标准create-react-app主页上的字体应该看起来不同了。</p><p id="58e2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们已经完成了所有的设置，让我们使用布尔玛来设置一些基本的布局项目。</p><h1 id="9077" class="lo kg hu bd kh lp mq lr kl ls mr lu kp ja ms jb ks jd mt je kv jg mu jh ky ly dt translated">基本布局和页眉</h1><p id="fab7" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">让我花几分钟时间来谈谈我的文件结构，因为它与您可能习惯看到的略有不同。</p><h2 id="ba5a" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">分形文件结构</h2><p id="b644" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我第一次发现<a class="ae lf" href="https://hackernoon.com/fractal-a-react-app-structure-for-infinite-scale-4dab943092af" rel="noopener ugc nofollow" target="_blank">分形文件结构的想法是在Hackernoon </a>的一篇文章上。当我第一次读这篇文章的时候，我的想法不是很清楚，但是有一件事突然出现在我眼前，我想我明白了。我可能完全错了，但尽管如此，在过去的几个月里，我的方法一直很有效。这是ReDucks模式的一种扩展，除了用文件创建一种键值或父子对象结构。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="b24f" class="kf kg hu me b fv mi mj l mk ml">src<br/>|- index.js<br/>|- App.js<br/>|- app<br/>   |- Layout.js<br/>   |- layout<br/>      |- Header.js<br/>      |- Content.js<br/>      |- Footer.js<br/>|- User.js<br/>|- user<br/>   |- Profile.js<br/>   |- PasswordReset.js<br/>   |- Address.js<br/>|- components<br/>   |- SharedCompOne.js<br/>   |- SharedCompTwo.js</span></pre><p id="50d5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以你可以看到我们开始按模块或特性对代码进行分组，但是我们不会为每个组件创建十亿个文件夹。相反，我们将组件保存在它们的父文件夹中，对每个组件名称使用<strong class="jl hv">Pascal case</strong>，对组件子文件夹使用<strong class="jl hv">camel case</strong>。这里唯一真正的例外是App.js在技术上是index的子代，但我不确定这算不算🤔。</p><p id="6ca8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这样做的好处是，我们可以清楚地看到，页眉、内容和页脚都是应用程序组件中使用的布局组件中使用的组件。如果文件结构像这样更扁平:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="34be" class="kf kg hu me b fv mi mj l mk ml">/* This is NOT fractal */</span><span id="081d" class="kf kg hu me b fv mp mj l mk ml">src<br/>|- index.js<br/>|- App.js<br/>|- layout<br/>   |- Layout.js<br/>   |- Header.js<br/>   |- Content.js<br/>   |- Footer.js</span></pre><p id="c550" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们没有任何真正的迹象表明组件的层次结构，或者Layout.js甚至在哪些组件上使用，因为分形模式向您显示了谁在哪里使用了哪些组件。这是一个清晰的父子结构，布局甚至可以包含一个共享文件夹，用于只在布局子元素中共享的组件。</p><p id="f9bd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还记得我之前提到的键值结构吗？正是这个想法让这一切在我脑海中闪现。如果你举我的第一个例子，你会这样想:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="0c66" class="kf kg hu me b fv mi mj l mk ml">src: {<br/>  Index.js,<br/>  App.js: {<br/>    Layout.js: {<br/>      Header.js<br/>      Content.js<br/>      Footer.js<br/>    }<br/>  }<br/>  User.js: {<br/>    Profile.js<br/>    PasswordReset.js<br/>    Address.js<br/>  }<br/>  components: {<br/>    SharedCompOne.js<br/>    SharedCompTwo.js<br/>  }<br/>}</span></pre><p id="b437" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的网站开始看起来像JSON数据…有点像，但是你明白了。“密钥”始终是一个组件。js文件。“value”是一个带有其关键字名称的always文件夹，它包含所有子组件。</p><p id="4643" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这真正开始发光的地方是在你的商店，我把它和我的表示层(app)分开。我们现在可以开始像构建数据结构一样构建我们的存储。这对NoSQL来说真的很好。</p><p id="e9dd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">稍后我们将对此进行更深入的探讨。</p><h2 id="4702" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">让我们从应用程序开始</h2><ol class=""><li id="3e45" class="mv mw hu jl b jm la jp lb js mx jw my ka mz ke na nb nc nd dt translated">在根目录下创建一个名为app的文件夹，并在其中创建一个名为Layout.js的文件</li><li id="da73" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke na nb nc nd dt translated">在app文件夹中，创建名为layout的文件夹</li><li id="da75" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke na nb nc nd dt translated">在布局文件夹中，创建4个文件:Site.js、Header.js、Content.js和Footer.js</li></ol><p id="2919" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> App.js </strong>会调用布局组件，之后会包含我们的Redux Store。</p><p id="5b54" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> Layout.js </strong>将包含<strong class="jl hv"> Site.js </strong>和<strong class="jl hv"> Content.js </strong>，它们只是站点和内容的<em class="lg">样式组件</em>包装器，这样我们就可以正确设置flexbox，以及<strong class="jl hv"> Header.js </strong>和<strong class="jl hv"> Footer.js </strong>组件。</p><p id="1447" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了我们双方的方便，这里把这5个文件放在一个单一的要点中。</p><figure class="lz ma mb mc fq nj"><div class="bz el l di"><div class="nk nl l"/></div></figure><h1 id="b12e" class="lo kg hu bd kh lp mq lr kl ls mr lu kp ja ms jb ks jd mt je kv jg mu jh ky ly dt translated">设置到某些页面的传送</h1><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="6a00" class="kf kg hu me b fv mi mj l mk ml">npm install react-router-dom</span></pre><p id="566f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们正在建立一个简单的网站/博客，所以我们将使用BrowserRouter。你可以探索其他的选择，但这不是讨论的主题；)</p><p id="ad24" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh mm mn mo me b">src/index.js</code>中，我们的应用程序的基础是用路由器包装应用程序。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="6c0e" class="kf kg hu me b fv mi mj l mk ml">import ReactDOM from 'react-dom'<br/>import registerServiceWorker from './registerServiceWorker'<br/>import { <!-- -->BrowserRouter<!-- --> as Router } from 'react-router-dom'<br/>import App from './App'<br/>import './index.css'</span><span id="128e" class="kf kg hu me b fv mp mj l mk ml">ReactDOM.render((<br/>  &lt;Router&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Router&gt;<br/>), document.getElementById('root'))</span><span id="fe74" class="kf kg hu me b fv mp mj l mk ml">registerServiceWorker()</span></pre><p id="ec94" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后在应用程序文件夹中，让我们创建两个简单的页面<code class="eh mm mn mo me b">Home.js</code>和<code class="eh mm mn mo me b">Blog.js</code></p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="e27d" class="kf kg hu me b fv mi mj l mk ml">import React from 'react'</span><span id="5ca6" class="kf kg hu me b fv mp mj l mk ml">const Home = () =&gt; (<br/>  &lt;p&gt;This is the Home Page&lt;/p&gt;<br/>)<br/>export default Home</span></pre><p id="512d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="f31a" class="kf kg hu me b fv mi mj l mk ml">import React from 'react'</span><span id="4539" class="kf kg hu me b fv mp mj l mk ml">const Blog = () =&gt; (<br/>  &lt;p&gt;This is the Blog Page&lt;/p&gt;<br/>)<br/>export default Blog</span></pre><p id="0e71" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们也有一些页面要路由，让我们设置一个路由器组件。现在，我们不打算尝试用它做任何新奇的事情，只是简单、直接的开关和路由。</p><p id="f2c0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的布局文件夹中添加一个名为<code class="eh mm mn mo me b">Router.js</code>的新文件。这个路由器将存在于我们的<code class="eh mm mn mo me b">Layout.js</code>文件的<strong class="jl hv">内容</strong>中。这将容纳我们的基本顶层页面。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="7f4a" class="kf kg hu me b fv mi mj l mk ml">&lt;Content&gt;<br/>  &lt;Router /&gt;<br/>&lt;/Content&gt;</span></pre><p id="2d9e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以在页面中创建附加的路由器组件，以添加更深层次的嵌套路由。我们未来的命名惯例将是它们的父组件名称和路由器。比如BlogRouter.js或者HomeRoute.js. <strong class="jl hv">还记得</strong>吗，它们会生活在一个叫blog的文件夹里。</p><p id="7c90" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的路由器组件中，我们需要在交换机组件及其内部，使用路由组件列出我们的路由。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="e6f7" class="kf kg hu me b fv mi mj l mk ml">import React from 'react'<br/>import { Switch, Route } from 'react-router-dom'<br/>import Home from './../Home'<br/>import Blog from './../Blog'</span><span id="ea5b" class="kf kg hu me b fv mp mj l mk ml">const Router = () =&gt; (<br/>  &lt;Switch&gt;<br/>    &lt;Route exact path='/' component={Home}/&gt;<br/>    &lt;Route path='/blog' component={Blog}/&gt;<br/>  &lt;/Switch&gt;<br/>)</span><span id="a6dc" class="kf kg hu me b fv mp mj l mk ml">export default Router</span></pre><p id="9333" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，让我们设置我们的标题来调用这些路线。</p><p id="39ee" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，让我们只对我们有路由的两个页面进行更改。我们将修改我们在博客和图标标题导航项目上的<code class="eh mm mn mo me b">&lt;a&gt;</code>。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="033f" class="kf kg hu me b fv mi mj l mk ml">&lt;NavLink<br/>  className="navbar-item"<br/>  to="/"<br/>  activeClassName="is-active"<br/>&gt;<br/>  &lt;img <br/>    style={{<br/>      borderTopLeftRadius: '50%',<br/>      borderTopRightRadius: '50%',<br/>      borderBottomLeftRadius: '50%',<br/>      borderBottomRightRadius: '50%',<br/>      marginRight: 15<br/>    }}<br/>    src="https://media-exp2.licdn.com/mpr/mpr/shrinknp_400_400/AAEAAQAAAAAAAAU3AAAAJGE1MzYxNzYzLTE1NTUtNDEyYi04MzRjLTgzZjNkOGU0MGIzNg.jpg"<br/>    width="30px" <br/>    alt="" <br/>  /&gt;<br/>  &lt;span&gt;AaronKlaser.com&lt;/span&gt;<br/>&lt;/NavLink&gt;</span></pre><p id="1466" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="d26e" class="kf kg hu me b fv mi mj l mk ml">&lt;NavLink<br/>  className="navbar-item"<br/>  to="/blog"<br/>  activeClassName="is-active"<br/>&gt;<br/>  &lt;span className="icon has-text-primary" style={{ marginRight: 5 }}<br/>    &lt;i className="fas fa-code"&gt;&lt;/i&gt;<br/>  &lt;/span&gt;<br/>  Code Blog<br/>&lt;/NavLink&gt;</span></pre><p id="2054" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，我们添加了<code class="eh mm mn mo me b">activeClassName=”is-active”</code>这是因为它是布尔玛导航活动类。NavLink很酷的一点是它总是检查你在哪个页面上，如果你的路线与那个<code class="eh mm mn mo me b">NavLink to</code>匹配，它会自动添加<strong class="jl hv">处于活动状态。如果你不想添加一个活动类，只需要简单的链接组件。</strong></p><h1 id="a572" class="lo kg hu bd kh lp mq lr kl ls mr lu kp ja ms jb ks jd mt je kv jg mu jh ky ly dt translated">结论</h1><p id="a900" class="pw-post-body-paragraph jj jk hu jl b jm la iv jo jp lb iy jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">这是应用程序的基本框架。</p><p id="c764" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回顾</p><ul class=""><li id="e45c" class="mv mw hu jl b jm jn jp jq js nm jw nn ka no ke np nb nc nd dt translated">使用create-react-app设置React站点</li><li id="ba45" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke np nb nc nd dt translated">设置React以构建SassI</li><li id="6e13" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke np nb nc nd dt translated">安装布尔玛</li><li id="4c6d" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke np nb nc nd dt translated">我们学习了分形文件结构</li><li id="d4f7" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke np nb nc nd dt translated">创建了站点布局</li><li id="9cc5" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke np nb nc nd dt translated">设置路由</li><li id="a06d" class="mv mw hu jl b jm ne jp nf js ng jw nh ka ni ke np nb nc nd dt translated">添加了一些要路由到的页面</li></ul><blockquote class="nq nr ns"><p id="72ca" class="jj jk lg jl b jm jn iv jo jp jq iy jr nt jt ju jv nu jx jy jz nv kb kc kd ke hn dt translated"><strong class="jl hv">下一个</strong>——<a class="ae lf" rel="noopener" href="/@aaron.klaser/building-a-blog-with-react-and-contentful-fd538f68f6fb">用反应和满足建立一个博客</a></p></blockquote><p id="6a21" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更多即将推出！我会相应地更新这个帖子。</p></div></div>    
</body>
</html>