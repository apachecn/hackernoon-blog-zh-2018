<html>
<head>
<title>More functional: A story in refactoring a 2d vector library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多功能:重构二维向量库的故事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/more-functional-refactoring-a-vector-library-4bf3d6b88612?source=collection_archive---------19-----------------------#2018-01-30">https://medium.com/hackernoon/more-functional-refactoring-a-vector-library-4bf3d6b88612?source=collection_archive---------19-----------------------#2018-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4997f415108496fbaad4a19ae9fda233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFkU0ArzrfjMChMuB9nVig.png"/></div></div></figure><p id="4c71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章是关于我如何用函数式编程风格重写我的库<a class="ae ka" href="https://github.com/francisrstokes/vec-la" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> vec-la </strong> </a>。<strong class="je hv"> vec-la </strong>是一个小型2d <a class="ae ka" href="https://en.wikipedia.org/wiki/Linear_Algebra" rel="noopener ugc nofollow" target="_blank">线性代数</a>库，它将<a class="ae ka" href="https://en.wikipedia.org/wiki/Euclidean_Vector" rel="noopener ugc nofollow" target="_blank">向量</a>和<a class="ae ka" href="https://en.wikipedia.org/wiki/Matrix_(mathematics)" rel="noopener ugc nofollow" target="_blank">矩阵</a>建模为<em class="kb">普通javascript数组</em>。这篇文章<em class="kb">并不是关于</em>数学和线性代数的——你不需要知道那么多就能从中获得一些价值。</p><h2 id="e1de" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">速成班:什么是向量？</h2><p id="607b" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">如果你不知道，向量基本上是一个有序的数字集合。一个<em class="kb"> 2D </em>向量只是两个数的有序集合。如果你熟悉像(2，3)这样的坐标，那么你会直观地知道什么是矢量。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/56a86e570fc8f97a6ca5ee14e53fbb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*F2OFvgRUJE5ZtEP8wlna0g.png"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Vectors can be visualised as arrows on the plane</figcaption></figure><p id="1131" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是向量也可以看做空间中的箭头；它有一个方向(箭头指向的地方)和一个量级(箭头有多长)。这很重要，因为这意味着向量不仅仅可以表示空间中的点，还可以表示一个方向上的速度。</p><p id="1e39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在许多方面，向量就像正常的数字。你可以增加、减少和缩放它们，但是你也可以做其他很酷的事情，比如旋转和反射它们。这就是<em class="kb"> vec-la </em>的意义所在——它为你提供了以编程方式操纵这些数学对象的工具。</p><p id="1a27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我主要使用<strong class="je hv"> vec-la </strong>来构建<a class="ae ka" href="http://codepen.io/fstokesman" rel="noopener ugc nofollow" target="_blank">程序动画</a>和游戏，尽管向量和矩阵的用例非常广泛。</p><h2 id="2290" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">目标</h2><p id="2d9c" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">所有这些都解决了，原始项目和重构的主要目标都是脱离许多其他库采用的方法；基于类的向量模型，其中操作是使向量变异的<strong class="je hv">方法</strong>。</p><p id="7939" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">避免状态突变是近几年来越来越普遍的想法。尤其是Redux让这一点成为了javascript社区的焦点。</p><p id="6664" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相反，vec-la使用<a class="ae ka" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>总是返回一个新的副本。为了说明这些差异，让我比较另一个(更流行的)库，<a class="ae ka" href="http://victorjs.org/" rel="noopener ugc nofollow" target="_blank"> victor.js </a>。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Creating vectors</figcaption></figure><p id="f3c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在正常情况下，Victor需要创建一个专门的对象，但是它也公开了一个从数组创建的API:</p><pre class="ld le lf lg fq ln lo lp lq aw lr dt"><span id="da70" class="kc kd hu lo b fv ls lt l lu lv">Victor.fromArray([15, 22])</span></pre><p id="ae25" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然实际上比用新的。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Adding vectors</figcaption></figure><p id="6661" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<strong class="je hv">添加</strong>，可以看到<em class="kb">突变</em>的想法进来了。将<em class="kb"> vic1 </em>加到<em class="kb"> vic2 </em>的结果实际存储在<em class="kb"> vic1 </em>中。如果你想在之后继续使用<em class="kb"> vic1 </em>的话，这是很烦人的。<em class="kb"> vec-la </em>总是会返回一个新的向量，所以你永远不会有担心<strong class="je hv"> vec1 </strong>和<strong class="je hv"> vec2 </strong>会发生什么的心理负担。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Scaling vectors</figcaption></figure><p id="3b3f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="kb"> victor </em>中乘法也是如此——它使你正在处理的向量发生变异。这通常会导致意想不到的和难以发现的错误。要了解原因，请参考以下代码:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek"><strong class="ak">a</strong> and <strong class="ak">b</strong> are actually the same object now</figcaption></figure><p id="7f64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Victor也不支持其他一些比vec-la 更高级的功能，比如使用矩阵。如果你不知道矩阵是什么，这里有一个简单但不精确的解释:</p><blockquote class="lw lx ly"><p id="460a" class="jc jd kb je b jf jg jh ji jj jk jl jm lz jo jp jq ma js jt ju mb jw jx jy jz hn dt translated">矩阵是排列成表格的一组数字。有一种特殊的方法可以把这些数字和一个向量或矩阵结合起来，得到一个新的向量或矩阵。这种运算叫做矩阵乘法。我发现把矩阵想象成一种转换函数的定义是很有帮助的。</p></blockquote><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Matrices like this are not what you might call “readable”</figcaption></figure><p id="fffc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">手工编写矩阵既麻烦又难以阅读，因此有一个API使用一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank"><em class="kb">fluent</em></a><a class="ae ka" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">builder模式</a>来简化创建:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Behold! A matrix that actually describes what it’s effect will be</figcaption></figure><h2 id="2fa2" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">功能上的提升</h2><p id="7e67" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">你可能已经说过<em class="kb"> vec-la </em>非常实用。</p><ul class=""><li id="4a3f" class="mc md hu je b jf jg jj jk jn me jr mf jv mg jz mh mi mj mk dt translated">它与函数一起工作，而不是方法</li><li id="1cc1" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">它从不改变论点</li><li id="2fe6" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">接受或返回向量的函数很容易组合在一起——它们组成</li></ul><p id="2ec7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是它也有一些缺点:</p><ul class=""><li id="88a5" class="mc md hu je b jf jg jj jk jn me jr mf jv mg jz mh mi mj mk dt translated">这些功能不是可定制的</li><li id="f4d9" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">他们经常以“错误的”顺序对待论点</li><li id="55f4" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated"><strong class="je hv"><em class="kb">matrix builder</em></strong>将一个特殊的对象引入到混合数组中，它不是一个简单的数组</li></ul><p id="5323" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不了解currying和参数顺序，可以看看我的文章<a class="ae ka" href="https://hackernoon.com/making-functional-programming-click-836d4715baf2" rel="noopener ugc nofollow" target="_blank"> <em class="kb">制作函数式编程点击</em> </a> <em class="kb">。在那里，我会深入讨论这些概念的细节。</em></p><p id="d564" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看看如何解决这些缺点。</p><h2 id="f0d5" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">这些功能不是可定制的</h2><p id="2c11" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">这是一个相当简单的解决方法，但是实际上需要与确定参数顺序结合起来。正如我在刚才提到的文章中所说:</p><blockquote class="lw lx ly"><p id="f14f" class="jc jd kb je b jf jg jh ji jj jk jl jm lz jo jp jq ma js jt ju mb jw jx jy jz hn dt translated">规则通常是<strong class="je hv">把数据作为最后一个参数</strong></p></blockquote><p id="1a3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数情况下，这些数据是你想要操作的向量。让我们用<strong class="je hv">比例</strong>函数来看问题:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="3297" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该函数将向量<strong class="je hv"> v </strong>和比例因子<strong class="je hv"> sc </strong>作为参数。由于这种顺序，您不能以有用的方式部分应用该功能；更有可能的是，你想用相同的<em class="kb">缩放因子来缩放<em class="kb">不同的</em>向量，而不是用不同的</em>缩放因子来缩放<em class="kb">相同的</em> <em class="kb">向量</em>。如果你交换参数，你可以得到一个更有意义的函数。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="84a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">图书馆里还有几个这样的函数。<strong class="je hv">变换</strong>取一个向量和一个矩阵，并根据矩阵变换向量。假设你有一个由向量数组定义的形状。如果你想变换每个点，你可以这样做:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="5008" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们转换参数，我们可以创建一个部分应用的变换函数，它将始终使用我们的矩阵:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="fe94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这更具表现力和可重用性。如果你有另一个形状或点，你可以用同样的函数来变换它。在我们被迫创建一个可以隐式访问矩阵的箭头函数之前。</p><p id="7618" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为最后一个例子(还有很多)，有一个方便的函数叫做<strong class="je hv">rotatepointround</strong>，它接受一个要旋转的向量，一个用作旋转原点(控制点)的向量，以及一个角度。如果你想围绕同一点旋转一组向量相同的角度，更好的顺序是角度，旋转原点，向量。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="3788" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很有可能你在想反例和例外，因为它们确实存在。在这种情况下，我们可以使用一种叫做组合子的东西来动态地重新排列论点。组合子是任何以一个函数作为输入，产生一个函数作为输出的函数。</p><p id="ede8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们有一个向量和一个矩阵数组。我们想要生成一个向量数组，其中一个向量由所有不同的矩阵转换而来。在这种情况下，我们要翻转transform的参数。我们可以编写一个通用组合子来实现这一点，而不是编写一个特殊的自定义函数:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="137d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个不太常见的用例，但是有一个像<strong class="je hv"> flip2 </strong>这样的功能，当它出现时就很容易管理。像<strong class="je hv">库里</strong>一样，你会在所有主要的功能库中找到<strong class="je hv"> flip </strong>的实现，比如ramda或者sanctuary。</p><h2 id="bc0b" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">matrixBuilder()问题</h2><p id="4e62" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">我们已经解决了前两个问题，如果我们需要处理不寻常的情况，还保留了运行时参数重排的可能性。但是仍然存在矩阵生成器的问题。</p><p id="f7e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新库中的所有函数都支持函数组合，但流畅的界面却不支持；你要一直调用方法，直到矩阵准备好，然后调用<em class="kb"> get() </em>释放矩阵值。(如果不知道什么是函数构成，看我之前提到的文章)</p><p id="d0a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看一下原始的matrixBuilder代码。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="fc2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> vMatrixBuilder </strong>函数接受一个矩阵(或者什么都不接受，这意味着<em class="kb">单位矩阵</em>)并返回一个带有旋转、缩放等方法的对象。从这些方法中的每一个，它返回一个新的matrixBuilder，这个新的matrix builder由旧的矩阵和一个执行给定操作的新矩阵组成。</p><p id="f7d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作曲这个词应该马上就会出现在你面前。事实证明，有一种方法可以获得两个矩阵，并对其中的数字进行复杂的求和，然后得到一个新的矩阵，对两个矩阵的信息进行编码。</p><p id="314f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们称之为运算矩阵组合，疯狂的是，这与函数组合完全相同(当然这并不疯狂——数学往往是一个经过深思熟虑的概括过程，因此这些类型的重叠经常发生)。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="8d99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能是整篇文章中最吓人的一段代码。我展示了<strong class="je hv"> mCompose </strong>函数，只是为了说明有某种方法可以组成矩阵，但是理解并不重要(从这个实现来看，基本上是不可能的)。<a class="ae ka" href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab" rel="noopener ugc nofollow" target="_blank">如果你想知道所有的数学原理，我推荐3blue1browns的“线性代数的本质”系列</a>。</p><p id="0743" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其余部分的工作方式与<strong class="je hv"> matrixBuilder </strong>完全相同——它通过将<strong class="je hv"> mCompose </strong>部分应用于特定矩阵来创建矩阵。就像<strong class="je hv"> matrixBuilder一样，</strong>你需要用一个矩阵来开始整个事情，在这两种情况下它通常是单位矩阵。毫不奇怪，单位矩阵就像编程中的<strong class="je hv">单位</strong>函数——当你把它应用于矩阵或向量时，你得到的和你输入的一样。</p><p id="9f8f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们可以通过纯粹的函数组合来表达矩阵的构建，并且我们不局限于某个特定API公开的那种方法。</p><h2 id="82ae" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">摘要</h2><p id="58f8" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">以这种方式重新构建库可以提高与其他库的互操作性——尤其是像ramda这样的函数库，我喜欢使用它。要查看所有这些结合在一起的示例，请查看codepen上的这个程序动画。</p><p id="4be2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我承认matrix builder在概念上是一个更简单的界面，但是它牺牲了T2的灵活性和T4的通用性来实现这个界面。我认为图书馆和方法都有它们的位置。</p><p id="e731" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在github上既可以看到新的<a class="ae ka" href="https://github.com/francisrstokes/vec-la-fp" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> vec-la-fp </strong> </a>，也可以看到原来的<a class="ae ka" href="https://github.com/francisrstokes/vec-la" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">vec</strong></a><strong class="je hv">-la</strong>。它们都有大约150行的实际代码，所以这是一个非常容易理解的项目。</p><p id="9626" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，请在这里或twitter上给我留言，让我知道。</p><p id="9cc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我正在开始一个名为“探索ramda”的系列，在这里我将写关于使用ramda库在javascript中结合函数式风格的文章，所以如果你感兴趣的话，请在medium上关注我。</p></div></div>    
</body>
</html>