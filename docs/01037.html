<html>
<head>
<title>Writing Unit Tests for REST API in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写REST API的单元测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-unit-tests-for-rest-api-in-python-web-application-2e675a601a53?source=collection_archive---------3-----------------------#2018-02-01">https://medium.com/hackernoon/writing-unit-tests-for-rest-api-in-python-web-application-2e675a601a53?source=collection_archive---------3-----------------------#2018-02-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e28da3f23a8143ffd80a9bdecf7bc7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5o31ntZjbTlYz1RZTltEg.png"/></div></div></figure><p id="de06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一点背景:在过去的几个月里，我一直在开源组织<a class="ae ka" href="https://github.com/fossasia" rel="noopener ugc nofollow" target="_blank"> FOSSASIA </a>中做贡献，在那里我从事一个名为<a class="ae ka" href="https://github.com/fossasia/badgeyay" rel="noopener ugc nofollow" target="_blank"> BadgeYaY </a>的项目。这是一个徽章生成器，具有简单的web用户界面，可以添加数据并生成PDF格式的可打印徽章。</p><p id="8878" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/fossasia/badgeyay" rel="noopener ugc nofollow" target="_blank"> Badgeyay </a>后端现在转移到<a class="ae ka" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST-API </a>上，为了测试REST-API中使用的函数，我们需要一些测试技术来测试API中使用的每一个函数。出于我们的目的，我们选择了流行的<a class="ae ka" href="https://docs.python.org/2/library/unittest.html" rel="noopener ugc nofollow" target="_blank">单元测试</a> Python测试套件。</p><p id="7b35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇博客中，我将讨论我是如何编写单元测试来测试<a class="ae ka" href="https://github.com/fossasia/badgeyay" rel="noopener ugc nofollow" target="_blank"> Badgeyay </a> REST-API的。</p><p id="97c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们了解什么是单元测试，以及我们为什么选择它。然后我们将继续为<a class="ae ka" href="https://github.com/fossasia/badgeyay" rel="noopener ugc nofollow" target="_blank"> Badgeyay </a>编写API测试。这些测试有一个通用的结构，因此我提到的代码可以在其他REST API测试场景中工作，通常只需很少或不需要修改。</p><p id="1cee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们开始一步一步地了解API测试。</p><p id="3c8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">什么是单元测试？</p><p id="7ba6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">单元测试是一个Python单元测试框架，它支持测试自动化、测试设置和关闭代码的共享、测试集合的聚合以及测试与报告框架的独立性。<a class="ae ka" href="https://docs.python.org/2/library/unittest.html#module-unittest" rel="noopener ugc nofollow" target="_blank">单元测试</a>模块提供了一些类，使得支持一组测试的这些质量变得容易。</p><p id="bbf7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为什么要进行单元测试？</p><p id="68a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们从单元测试中得到两个主要的好处，第一个好处占了大部分的价值:</p><ul class=""><li id="5d27" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">引导您的设计松散耦合，并充分充实。如果进行测试驱动的开发，它将你写的代码限制在需要的范围内，并帮助你逐步发展这些代码。</li><li id="a997" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">为代码的重因子和小变化提供快速的自动化回归。</li><li id="5a33" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">单元测试也给你关于系统的小部分如何工作的活文档。</li></ul><p id="ea90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们应该总是努力编写全面的测试，很好地覆盖工作代码。</p><p id="f7e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们看一下我是如何编写单元测试来测试<a class="ae ka" href="https://github.com/fossasia/badgeyay" rel="noopener ugc nofollow" target="_blank"> Badgeyay </a>的REST-API后端代码的。使用单元测试python包和<a class="ae ka" href="http://docs.python-requests.org/" rel="noopener ugc nofollow" target="_blank">请求</a>模块，我们可以在测试自动化中测试REST API。</p><p id="6b95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是我在一个拉请求中为其编写单元测试的代码片段。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="3311" class="ky kz hu ku b fv la lb l lc ld">def output(response_type, message, download_link):<br/>    if download_link == ‘’:<br/>       response = [<br/>        {<br/>             ‘type’: response_type,<br/>             ‘message’: message<br/>         }<br/>     ]<br/>     else:<br/>     response = [<br/>      {<br/>              ‘type’: response_type,<br/>              ‘message’: message,<br/>              ‘download_link’: download_link<br/>       }<br/>     ]<br/>     return jsonify({‘response’: response})</span></pre><p id="e3a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了测试这个函数，我基本上创建了一个模拟对象，它可以以可控的方式模拟真实对象的行为，所以在这种情况下，模拟对象可以模拟输出函数的行为，并返回类似JSON响应的<em class="le">信息</em>，而不会影响真实的REST API。现在，下一个挑战是解析JSON响应，并将响应JSON的特定值提供给Python自动化脚本。因此Python将JSON作为字典对象读取，这确实简化了JSON的解析和使用方式。</p><p id="43df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而这里的内容是<a class="ae ka" href="https://github.com/fossasia/badgeyay/blob/development/backend/app/tests/test_basic.py" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="le">back end/tests/test _ basic . py</em></strong></a>文件。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="bac0" class="ky kz hu ku b fv la lb l lc ld">#!/usr/bin/env python3</span><span id="2d3e" class="ky kz hu ku b fv lf lb l lc ld">“””Tests for Basic Functions”””<br/>import sys<br/>import json<br/>import unittest</span><span id="94c2" class="ky kz hu ku b fv lf lb l lc ld">sys.path.append(“../..”)<br/>from app.main import *<br/></span><span id="78d0" class="ky kz hu ku b fv lf lb l lc ld">class TestFunctions(unittest.TestCase):<br/> “””Test case for the client methods.”””<br/>    def setup(self):<br/>        app.app.config[‘TESTING’] = True<br/>        self.app = app.app.test_client()<br/>        # Test of Output function<br/>        <br/>        def test_output(self):<br/>            with app.test_request_context():<br/>            # mock object<br/>            out = output(‘error’, ‘Test Error’, ‘local_host’)<br/>            # Passing the mock object<br/>            response = [<br/>              {<br/>                     ‘type’: ‘error’,<br/>                     ‘message’: ‘Test Error’,<br/>                     ‘download_link’: ‘local_host’<br/>               }<br/>            ]<br/>            data = json.loads(out.get_data(as_text=True)<br/>            # Assert response<br/>            self.assertEqual(data[‘response’], response)<br/></span><span id="6064" class="ky kz hu ku b fv lf lb l lc ld">if __name__ == ‘__main__’:<br/>      unittest.main()</span></pre><p id="981f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们可以通过运行<a class="ae ka" href="http://pythontesting.net/framework/nose/nose-introduction/" rel="noopener ugc nofollow" target="_blank"> <em class="le"> nosetests </em> </a>来验证一切正常。</p><figure class="kp kq kr ks fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lg"><img src="../Images/5d4f942e669c8dac2ef8f435f69a5b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u8XJMj4PJke0AIYi."/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Screen-shot of Test Passing</figcaption></figure><p id="edb5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我如何在<a class="ae ka" href="https://github.com/fossasia/badgeyay" rel="noopener ugc nofollow" target="_blank"> BadgeYaY </a>存储库中编写单元测试的。</p><p id="efea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至此，我已经结束了关于在Python Web应用程序中为REST API编写单元测试的讨论。我写这篇文章是为了解决BadgeYaY项目中的这个问题。如果你喜欢这篇文章，可以考虑看看我在GitHub 上的其他作品🙂。</p><p id="9e45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来源:<a class="ae ka" href="https://docs.python.org/2/library/unittest.html" rel="noopener ugc nofollow" target="_blank">单元测试框架</a></p></div></div>    
</body>
</html>