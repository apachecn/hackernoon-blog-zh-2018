<html>
<head>
<title>Converting Shaders from Shadertoy to ThreeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将着色器从Shadertoy转化为ThreeJS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/converting-shaders-from-shadertoy-to-threejs-fe17480ed5c6?source=collection_archive---------7-----------------------#2018-02-01">https://medium.com/hackernoon/converting-shaders-from-shadertoy-to-threejs-fe17480ed5c6?source=collection_archive---------7-----------------------#2018-02-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f9db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">马库斯·纽伊和T2·德克·克劳斯</p><p id="7793" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如何将着色器从Shadertoy转移到ThreeJS ( <a class="ae jr" rel="noopener" href="/@markus.neuy/postprocessing-shader-mit-shadertoy-und-threejs-8164600c6c76">德意志版</a>)。</p></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><h1 id="8610" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">介绍</h1><p id="6d57" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">作为阳狮Pixelpark创新实验室研究的一部分，我们研究了如何在网络技术中使用低级语言。明显的选择似乎是<a class="ae jr" href="http://asmjs.org/" rel="noopener ugc nofollow" target="_blank"> asm.js </a>或<a class="ae jr" href="http://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>。</p><p id="cb1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是您也可以使用WebGL着色器来解决面向机器的问题。着色器是用类似于C/C++的语言编程的，虽然它们主要不是为了解决一般问题，但它们可以用于更多的事情，而不仅仅是渲染图像和3D场景。<br/>第二个动机源于可以通过着色器实现的视觉效果。2002年，威斯康星大学麦迪逊分校的一群学生发布了<a class="ae jr" href="https://research.cs.wisc.edu/graphics/Gallery/NPRQuake/whatIsIt.html" rel="noopener ugc nofollow" target="_blank"> NPRQuake </a>(“非真实感渲染之锤”)，这是知名游戏Quake通过在渲染管道中注入代码的变体。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff lc"><img src="../Images/2de7bf1d8503ae66889e783e9cfc2334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNJT8HoRzmiJRYG5AXdigQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">NPRQuake Screenshot</figcaption></figure><p id="8d60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种变化的美学质量是惊人的；我们立即意识到这种效果可能会改变项目的游戏规则。虽然在2002年，这种变化只能通过为OpenGL编写驱动程序来实现，但现在在2018年，可以通过着色器来实现——甚至在web浏览器中。</p><p id="3e35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，当我们最近参与一个艺术项目时，我们决定尝试一下着色器。</p></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><h1 id="100a" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">着色器代码的可用性</h1><p id="ed34" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">如果你真的不习惯编程着色器，那么显而易见的选择是搜索免费提供的示例并使用它们(仔细查看所涉及的许可证)。另一个例子是<a class="ae jr" href="https://www.shadertoy.com" rel="noopener ugc nofollow" target="_blank"> Shadertoy </a>和<a class="ae jr" href="https://shaderfrog.com" rel="noopener ugc nofollow" target="_blank"> ShaderFrog </a>。</p><p id="b749" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为在我们决定用来自ThreeJS中Shadertoy的后处理着色器来发布我们的发现之前，我们已经成功地与ThreeJS一起工作了。</p></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><h1 id="4a82" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">ThreeJS中的着色器</h1><p id="ff4a" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">ThreeJS可用于利用改变整个渲染图像的后处理着色器以及可改变3D对象材质的材质着色器。这两种类型都需要顶点和片段着色器部分；顶点着色器可以更改顶点在3D中的位置，而片段着色器通常会替换渲染图像的颜色。</p><p id="dbc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这张图片展示了四种可能的变化。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff ls"><img src="../Images/c06fb8df266008615034b29247122e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxA07f0uBxz1A59TVbAzgA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Types of shaders</figcaption></figure><p id="cbc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在左上角，后处理着色器向渲染图像添加颜色渐变。在它的右边，一个顶点着色器减少了渲染区域。下面的两幅图像显示了材质着色器；左边的只改变颜色，而右边的改变顶点的位置。由于着色器始终由顶点和片段部分组成，最后一个示例也更改了颜色。</p></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><h1 id="3bfd" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">Shadertoy</h1><h2 id="9aa4" class="lt ka hu bd kb lu lv lw kf lx ly lz kj jc ma mb kn jg mc md kr jk me mf kv mg dt translated">Shadertoy的小例子</h2><p id="a67c" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">2014年，我们研究了如何将着色器从Shadertoy转移到ThreeJS，首批结果发布在<a class="ae jr" href="https://stackoverflow.com/a/37508079/573216" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上。我们发现以下模式很有用:</p><ul class=""><li id="65f2" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">添加<a class="ae jr" href="https://www.shadertoy.com/howto" rel="noopener ugc nofollow" target="_blank">阴影具体变量</a>如<strong class="it hv"> iGlobalTime </strong>等。</li><li id="3dd6" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">将<strong class="it hv"> mainImage(out vec4 z，in vec2 w) </strong>重命名为<strong class="it hv"> main() </strong></li><li id="1a34" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">将<strong class="it hv"> z </strong>重命名为<strong class="it hv"> gl_FragColor </strong></li></ul><p id="9963" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过遵循这种模式，你可以将一个简单的着色器转换成三个着色器。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/9e002720b83d3be11f61479f3da56ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*MK8ceNmptv2XiAfz2XOUsw.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek"><a class="ae jr" href="https://jsfiddle.net/dirkk0/zt9dhvqx/" rel="noopener ugc nofollow" target="_blank">Trivial Shader</a></figcaption></figure></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><h2 id="933d" class="lt ka hu bd kb lu lv lw kf lx ly lz kj jc ma mb kn jg mc md kr jk me mf kv mg dt translated">来自Shadertoy的重要示例</h2><p id="683a" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">对于一个更复杂的着色器，你需要做更多的事情，正如我们现在将要概述的。对于一个重要的例子，我们选择了<strong class="it hv">噪声轮廓</strong>由<a class="ae jr" href="https://www.shadertoy.com/user/candycat" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> candycat </strong> </a>，因为你遇到了一些问题。你可以在这里找到:<a class="ae jr" href="https://www.shadertoy.com/view/MscSzf" rel="noopener ugc nofollow" target="_blank">https://www.shadertoy.com/view/MscSzf</a></p><p id="cc15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此示例还使用着色器语言创建了一个完整的场景。但是在ThreeJS中，你通常想要控制3D对象，所以我们决定在ThreeJS中创建场景，同时仍然利用着色器来改变它。</p><h2 id="79b7" class="lt ka hu bd kb lu lv lw kf lx ly lz kj jc ma mb kn jg mc md kr jk me mf kv mg dt translated">了解着色器的结构</h2><p id="877b" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">我们首先试图掌握着色器的结构；这可以通过Shadertoy的编辑器来实现。因为可以实时看到对代码的编辑，所以我们可以做一些小的改变来理解它是如何工作的。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/404d4d7b67064b239da235c510e81fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ezzmy6MXtbOQ-WM4hNw6Vg.jpeg"/></div></div></figure><p id="bc41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在实际代码下方，我们看到该代码基于一个名为<strong class="it hv"> iChannel0 </strong>的通道，其中<strong class="it hv"> B </strong>表示一个缓冲区。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/198fe6ae24c597b8ca31f8b97c90bc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nas4WgOhvdADzGRBlJoQxA.jpeg"/></div></div></figure><p id="21a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要查看这个缓冲区的运行情况，我们注释掉第37行并添加以下内容:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="67e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果应该是:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/418bb04663a21829e94dae25b27ef719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6J9dAiWH9DE29n4Qoccew.jpeg"/></div></div></figure><p id="3db7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个简单的改变导致显示前一个缓冲区的颜色，而不是这个缓冲区的结果。</p><p id="71cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过检查之前的缓冲区— <strong class="it hv"> Buf B </strong> —我们看到这个也使用了<strong class="it hv"> iChannel0 </strong>，所以我们仍然没有看到原始的场景创建代码。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/bc548e22dd947cec2ca8c347d3bfd138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNBdJa6Sy7Ore654T9gaZg.jpeg"/></div></div></figure><p id="9687" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">利用和以前一样的技巧，我们注释掉第29行，并添加一行来计算uv和实际颜色，如下所示:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="c1d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这应该留给我们:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/a08870710a099d3ac568a782df6543e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJ6cuO61GHP6Tmx0YTVdjg.jpeg"/></div></div></figure><p id="66c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这看起来更像是一个普通的场景。此外，<strong class="it hv"> Buf A </strong>没有使用另一个缓冲区，所以我们正在查看原始场景创建代码。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/375c1bac0e6d82bd4b856e04e59b1eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bILlWsiPBnSynfTCxMfwQw.jpeg"/></div></div></figure></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><h1 id="7a49" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">三个j的重建</h1><p id="a573" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">完整的免责声明:下面的代码绝不是“最佳”代码，而只是以最直接的方式解决问题的一种方法。</p><h2 id="8c92" class="lt ka hu bd kb lu lv lw kf lx ly lz kj jc ma mb kn jg mc md kr jk me mf kv mg dt translated">创建场景</h2><p id="a978" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">我们首先创建一个稍微简单点的场景，只有一个球体和一个平面。此外，我们想使用ThreeJS的<strong class="it hv"> MeshNormalMaterial </strong>。</p><p id="6567" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里显示了一个可能的结果:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mz"><img src="../Images/d0eb8eda97b36a416141e547be1dee50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhWgv6flgALbhVIrtAsvkA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Shader in ThreeJS step 0</figcaption></figure><p id="7f12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码包含在一个名为<em class="na">index.html</em>的HTML文件中:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="fa58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要关注ThreeJS库的依赖性，并且我们还在<em class="na"> index.js </em>中添加了我们自己的代码:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="9c1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段JavaScript代码创建了一个渲染器、一个摄像机、一个动态观察控件以及一个带有<strong class="it hv"> MeshNormalMaterial </strong>的平面和球体。它还负责窗口大小的改变和渲染。</p><p id="11d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从Shadertoy移植场景的第0步到此结束。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mz"><img src="../Images/d0eb8eda97b36a416141e547be1dee50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhWgv6flgALbhVIrtAsvkA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Shader in ThreeJS step 0</figcaption></figure><h2 id="f770" class="lt ka hu bd kb lu lv lw kf lx ly lz kj jc ma mb kn jg mc md kr jk me mf kv mg dt translated">重新创建第一个着色器过程</h2><p id="a840" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">在下一步中，我们尝试在缓冲区中重新创建第一个着色器渲染步骤；这基本上是将着色器代码复制到ThreeJS。</p><p id="4b3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果应该是这样的:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff nb"><img src="../Images/0009779853dc2df8e5f6094877b21e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSc-sk8UmDL_LooTsqrY_g.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Shadertoy withou the last pass</figcaption></figure><p id="154a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现这一点，我们为ThreeJS使用了<a class="ae jr" href="https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/EffectComposer.js" rel="noopener ugc nofollow" target="_blank"> EffectComposer </a>，它提供了一种使用后处理着色器的简单方法。</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="e1b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将创建一个EffectComposer实例，该实例添加一个正常渲染过程和一个附加着色器过程。我们复制变量<strong class="it hv">顶点</strong>和<strong class="it hv">片段</strong>中的着色器代码。着色器定义还定义了EffectComposer使用的名为<strong class="it hv"> tDiffuse </strong>的<strong class="it hv">统一</strong>。它包含来自上一个渲染过程的图像，该图像将在当前过程中被更改。</p><p id="dffa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这个新的渲染步骤，我们显示这个过程而不是原始场景。因此，我们需要添加一些代码来调整大小，因此我们添加:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="4f05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要定义常量<strong class="it hv">顶点</strong>和<strong class="it hv">片段</strong>。我们不能使用Shadertoy的顶点着色器，所以我们需要定义自己的:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="7ca6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过，我们确实使用了Shadertoy的片段着色器，并将其添加到<strong class="it hv">片段</strong>:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="9860" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这基本上创建了着色器，但我们仍然需要解决以下问题:</p><ul class=""><li id="05d0" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">顶点着色器坐标尚未用于片段着色器<br/> -片段着色器使用了<strong class="it hv">纹理</strong>，这在当前WebGL上下文中是未知的</li><li id="4265" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated"><strong class="it hv"> mainImage </strong>必须改名为<strong class="it hv"> main </strong></li><li id="fe96" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">iResolution还没有设置。</li></ul><p id="d709" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以着色器还没有工作。</p><p id="b3c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决第一个问题产生了这个定义:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="2758" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以用向量<strong class="it hv"> vUv </strong>代替<strong class="it hv">frag coord/ire resolution . xy</strong>。这导致:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="2249" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们简单地用<strong class="it hv">纹理2D </strong>替换每一次出现的<strong class="it hv">纹理</strong>。</p><p id="8c5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，我们将<strong class="it hv">主图像</strong>更改为<strong class="it hv">主图像</strong>，不带参数:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="c646" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> main </strong>也应该返回<strong class="it hv"> gl_FragColor </strong>而不是定义着色器颜色的<strong class="it hv"> fragColor </strong>。</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="3ec0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们需要将iResolution添加到制服中。我们通过定义一个存储宽度和高度的ThreeJS向量来实现这一点:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="68e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以将分辨率添加到制服中:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="c48f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要增强我们的<strong class="it hv">调整</strong>功能:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="6ce4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重要的是，我们使用实际渲染过程的制服。原作已被EffectComposer深度克隆；改变变量<strong class="it hv">分辨率</strong>不会有任何影响。</p><p id="0121" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们确实定义了两个制服，所以我们需要将它们引入我们的片段着色器，所以我们定义它们:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="4612" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就结束了这个着色器过程，如果一切顺利，我们会看到:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mz"><img src="../Images/64bde953a36c703857e30c4e3fae653d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j87FoanxX-saNyCaZBPRsQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Shader Pass 1 without shadows</figcaption></figure><p id="b021" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从蓝色线条中我们可以看出，它通常是有效的，但粉色部分仍然缺失。让我们改变这一点。</p><h2 id="b7fc" class="lt ka hu bd kb lu lv lw kf lx ly lz kj jc ma mb kn jg mc md kr jk me mf kv mg dt translated">用阴影解决问题</h2><p id="fc30" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">粉红色的部分不见了，因为Shadertoy中的着色器秘密地将阴影渲染到最初不可见的alpha通道，如下图所示:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/96cc49ae5a373a2b0f03991d6a1e684a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gb0vOyGMV9EgKU5pjKK-gQ.jpeg"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Shadows in Shadertoy</figcaption></figure><p id="edb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有几种方法可以解决这个问题——我们使用了直接的方法，通过添加一种保持阴影的材料。这些必须在额外的渲染过程中处理。</p><p id="8e51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以让我们用三个j来创建阴影:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="79d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">阴影需要光线，在这种情况下，需要有方向性的光线:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="e36b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个<strong class="it hv">网状材料</strong>可以容纳阴影。</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="aa1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而新的渲染目标保存它们。</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="17c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，需要一个<strong class="it hv"> resize </strong>函数:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="f0b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以将阴影转移到新的渲染目标，并为着色器做准备:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="2362" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些线设置材质，渲染场景，将阴影设置为均匀，并将材质改回<strong class="it hv"> MeshNormalMaterial </strong>。</p><p id="7726" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，着色器需要了解阴影，以便能够处理它们，因此我们更改了制服:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="afff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">片段着色器也是如此:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="e1c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们用我们的影子代替前面的线。</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="70f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果应该看起来像Shadertoy上的第二步。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mz"><img src="../Images/7783024411286d118f27db9011592f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMM3FjyoxZvq0JqhubW6zA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Shader step 1</figcaption></figure><p id="f4bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们只差第二个着色器通道就可以完成了。</p><h2 id="53f0" class="lt ka hu bd kb lu lv lw kf lx ly lz kj jc ma mb kn jg mc md kr jk me mf kv mg dt translated">最终着色器阶段</h2><p id="e332" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">对于最终的着色器过程，我们添加了另一个EffectComposer实例。</p><p id="eceb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们定义另一个着色器:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="7853" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们为之前的渲染过程停用<strong class="it hv"> renderToScreen </strong>:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="f70c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次，引入了更多的变量；<strong class="it hv"> iTime </strong>随时间改变变量<strong class="it hv"> iChannel1 </strong>添加噪声。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/f4e5fe3e601ce12084f06a7eda711059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hU6yKO-bgv43pXXO9T_uw.jpeg"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Shadertoy Noise and iTime</figcaption></figure><p id="7c55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用三个时钟来计时。</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="c1da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每一次变化，我们都会更新iTime:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="68be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们给制服添加了时间和噪音:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="0ab0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">噪波只是一个噪波纹理(例如Shadertoy中的一个)，我们将三个j加载到<strong class="it hv"> tNoise </strong>中。</p><p id="19cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们需要调整片段着色器以适应新的变量，因此我们应用了以下措施:</p><ul class=""><li id="ca5e" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">将<strong class="it hv">主图像</strong>更改为<strong class="it hv">主图像</strong></li><li id="f33d" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">定义制服并调整变量</li><li id="99bb" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">定义<strong class="it hv"> vUv </strong>坐标</li><li id="247f" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">将返回的结果更改为<strong class="it hv"> gl_FragColor </strong></li><li id="4c06" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">将<strong class="it hv">纹理</strong>替换为<strong class="it hv">纹理2D </strong></li></ul><p id="2a75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这给了我们:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="3f7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这些更改之后，着色器仍然无法编译，因为该着色器需要特定的WebGL扩展。谢天谢地，这很容易用三个j来补充:</p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="6c5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这给了我们以下结果:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mz"><img src="../Images/c38fb3f8f11cabfa50644cd76b996a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYYiOx6-76my-WZbUAOznQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Final Shader</figcaption></figure><p id="730e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这非常接近原始的阴影图:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff mw"><img src="../Images/404d4d7b67064b239da235c510e81fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ezzmy6MXtbOQ-WM4hNw6Vg.jpeg"/></div></div></figure><h1 id="22f9" class="jz ka hu bd kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw dt translated">结论</h1><p id="9c17" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">通过以下步骤，我们成功地将复杂的Shadertoy着色器转移到ThreeJS:</p><ul class=""><li id="e687" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">了解特定着色器的结构</li><li id="6759" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">实现着色器过程</li><li id="369e" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">解决可能的GLSL不兼容问题</li><li id="c202" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">创建可选的着色器过程和/或材质</li><li id="b094" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">激活可选扩展</li></ul><p id="2c7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们预计这些挑战将随着即将到来的ThreeJS中的WebGL2支持而得到缓解，因为可能的GLSL不兼容性应该会消失。</p><p id="3e20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整源代码<a class="ae jr" href="https://github.com/dirkk0/Shadertoy2Threejs" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/b529be3245147c1199526759d6a23af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/1*eZwg5fu9IHfrCP6URqEfAg.gif"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">The final result</figcaption></figure><h1 id="511a" class="jz ka hu bd kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw dt translated">有用的链接和资源</h1><ul class=""><li id="885e" class="mh mi hu it b iu kx iy ky jc ni jg nj jk nk jo mm mn mo mp dt translated">Shadertoy着色器:<a class="ae jr" href="https://www.shadertoy.com/view/MscSzf](https://www.shadertoy.com/view/MscSzf)" rel="noopener ugc nofollow" target="_blank">https://www.shadertoy.com/view/MscSzf</a></li><li id="e5a7" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">webgl 2基本面:<a class="ae jr" href="https://webgl2fundamentals.org/](https://webgl2fundamentals.org/)" rel="noopener ugc nofollow" target="_blank">https://webgl2fundamentals.org</a></li><li id="39f1" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">three js:<a class="ae jr" href="https://threejs.org/](https://threejs.org/)" rel="noopener ugc nofollow" target="_blank">https://three js . org/](https://three js . org/</a></li><li id="ed66" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">三个例子:<a class="ae jr" href="https://github.com/mrdoob/three.js/tree/dev/examples](https://github.com/mrdoob/three.js/tree/dev/examples)" rel="noopener ugc nofollow" target="_blank">https://github.com/mrdoob/three.js/tree/dev/examples</a></li><li id="34c2" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">Web GL-Extensions:<a class="ae jr" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getExtension](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getExtension)" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/WebGLRenderingContext/get extension</a>和【https://github.com/mrdoob/three.js/issues/7379】T2</li><li id="d3a7" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">作曲:https://github.com/hughsk/three-effectcomposer<a class="ae jr" href="https://github.com/hughsk/three-effectcomposer](https://github.com/hughsk/three-effectcomposer)" rel="noopener ugc nofollow" target="_blank"/></li><li id="f1f4" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">另一个EffectComposer方法:<a class="ae jr" href="https://github.com/spite/Wagner](https://github.com/spite/Wagner)" rel="noopener ugc nofollow" target="_blank">https://github.com/spite/Wagner</a></li><li id="956f" class="mh mi hu it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp dt translated">WebGL快速参考卡:<a class="ae jr" href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf](https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf)" rel="noopener ugc nofollow" target="_blank">https://www . khronos . org/files/web GL/web GL-Reference-Card-1 _ 0 . pdf</a></li></ul></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><h1 id="47cd" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">信用</h1><p id="8858" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">这项研究的一部分由EFRE资助。NRW项目。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff nl"><img src="../Images/96ebc8b4a535362e4eb17ca686ca9d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhpTmQdzj7ABAUk1XSJscQ.jpeg"/></div></div></figure></div></div>    
</body>
</html>