<html>
<head>
<title>Serverless — Beyond the over simplistic todo apps into the world of reality (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器——超越过于简单的todo应用程序，进入现实世界(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-part-1-e75b4a5e59e6?source=collection_archive---------10-----------------------#2018-02-02">https://medium.com/hackernoon/serverless-part-1-e75b4a5e59e6?source=collection_archive---------10-----------------------#2018-02-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b315" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了为所有新技术如此方便地演示的低劣的todo应用程序，我想知道<strong class="it hv"/>的无服务器<strong class="it hv">世界真的</strong>会是什么样子。</p><p id="1dc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是使用<a class="ae jp" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>构建真实世界示例的第1部分和第3部分中的第1部分<strong class="it hv">以及如何将您新的无限可扩展解决方案货币化。</strong></p><p id="0f95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一部分，我将讨论如何使用<a class="ae jp" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>(框架)来构建一个基于桶事件的ffmpeg包装器。我的<a class="ae jp" href="https://github.com/kvaggelakos/serverless-ffmpeg" rel="noopener ugc nofollow" target="_blank">开源无服务器ffmpeg的代码可以在这里找到</a>。</p><h1 id="7e5d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">介绍</h1><p id="fa45" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><strong class="it hv">我们想要做的:</strong> <br/>每当一个媒体文件被上传到s3存储桶时，我们想要使用ffmpeg将它后处理成各种格式。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff kt"><img src="../Images/e7fc29bbf6d81be59a6300914be7c44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIJPOjdWyOItQcIq1ofh5A.png"/></div></div></figure><p id="44f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">为什么是无服务器:<br/> </strong>无服务器允许我们在一个文件被添加/删除到一个桶中时触发一个函数，非常适合我们的后处理动作。我们也为我们处理的时间付费，不多也不少。最后但同样重要的是，我们可以批处理，不用担心一次上传多少文件。</p><h1 id="d0e2" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">代码</h1><h2 id="37fb" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">1.无服务器. yml</h2><p id="2a5d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这是一个文件，它把所有的东西都捆绑在一起，如果你曾经构建过比todo应用更大的东西，你知道这将是一个瓶颈——确实如此。然而！您可以做一些有趣的事情来使它变得更好，比如引用另一个文件(见下面的注释)或者使用<a class="ae jp" href="https://serverless.com/framework/docs/providers/aws/guide/variables/#reference-variables-in-javascript-files" rel="noopener ugc nofollow" target="_blank"> javascript来生成yml </a>的部分。</p><p id="3e76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几个注意事项:</p><ol class=""><li id="a13c" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">如你所见，我使用了类似于:<code class="eh mc md me mf b">${file(./config.yml):source_bucket}</code>的东西从另一个yaml文件中获取值。这是将serverless.yml的复杂性抽象化的一种方式，并专注于对部署可能很重要的几个参数。</li><li id="175b" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第29行，我们定义了将传递给ffmpeg二进制文件的参数。它们在lambda函数中作为env变量传递！(您将在接下来的章节中看到)</li><li id="c2a8" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第30–60行用于访问应用程序所需的存储桶。</li><li id="b977" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第67行定义了事件处理程序，有趣的是它还创建了桶</li></ol><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="ml mm l"/></div><figcaption class="mn mo fg fe ff mp mq bd b be z ek">serverless.yml for serverless-ffmpeg</figcaption></figure><h2 id="08f9" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">2.webpack配置</h2><p id="e3e1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们需要webpack很好地捆绑我们的javascript，并使用es6/7特性来编写一些现代的JS(而不是绑定到lambda允许我们使用的节点6.10)。让我们看一下webpack config + babelrc文件来实现这一点。</p><ol class=""><li id="c064" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">在第8行，我们使用<code class="eh mc md me mf b">slsw.lib.entries</code>来根据我们在无服务器中的函数自动生成条目。感谢无服务器webpack库的智能。</li><li id="282f" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">在第23–24行，我们复制了将在我们的应用程序中使用的二进制文件。我们在这里这样做的原因是因为我们需要二进制文件具有可执行权限(+x)。</li></ol><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="ml mm l"/></div></figure><h2 id="76e5" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">3.处理程序代码</h2><p id="9484" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这就是无服务器的起点！正如我们在<code class="eh mc md me mf b">serverless.yml</code>中所指定的，我们想要一个名为<code class="eh mc md me mf b">main</code>的函数从我们的<code class="eh mc md me mf b">handler.js</code>文件中运行，只要在我们的源桶中有一个对象创建事件。</p><ol class=""><li id="557f" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">第7行调用一个函数来提取新上传的文件在source bucket中的位置。</li><li id="6f90" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">多亏了我们漂亮的webpack配置，我们现在可以使用await/async，这就是我们在将最近上传的文件从源桶下载到lambda进程时所做的。</li><li id="9a15" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第14行我们运行ffmpeg函数，依次调用二进制文件(见下一节)。</li><li id="ef88" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第15行我们将结果上传到目标桶中。</li><li id="6709" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第23行展示了我们如何使用预定义的参数作为环境变量。</li></ol><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="ml mm l"/></div></figure><h2 id="2bab" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">4.ffmpeg应用程序代码</h2><p id="2471" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们来看看应用程序代码中一些有趣的部分，看看这些是如何联系在一起的。</p><ol class=""><li id="16ed" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">第4行确保我们的lambda根在路径env变量中，这样我们就可以用直接位于项目根中的<code class="eh mc md me mf b">spawn</code>调用二进制文件！</li><li id="fa8e" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第21行我们正在合并传递给ffmpeg进程的参数。</li><li id="f135" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第29行我们用我们的参数调用spawn并连接一些事件处理程序</li><li id="9b21" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第34–35行我们确保捕获stdout和stderr，如果没有它们，我们真的不知道会发生什么，如果有什么出错的话。</li></ol><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="ml mm l"/></div></figure><h2 id="b633" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">4.当然是单元测试！</h2><p id="1559" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">作为任何真实应用程序的一部分，单元测试都很重要。但是我们如何测试无服务器功能呢？我们可以对它们的一部分进行单元测试！但是我们如何对调用二进制代码做事情进行单元测试呢？我们设置了测试基础设施来支持这一点！</p><p id="b1f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现这一目标，我们需要<a class="ae jp" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"> ava </a> (ava太棒了！)，它可以让我们快速入门一个极简的配置(如何正确配置见这个<a class="ae jp" href="https://github.com/kvaggelakos/serverless-ffmpeg/blob/master/package.json#L43" rel="noopener ugc nofollow" target="_blank"> package.json </a>)。</p><ol class=""><li id="af55" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">导入ava和一些助手处理文件。</li><li id="9c5b" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第8行运行我们的ffprobe函数，该函数返回一个json结果(<a class="ae jp" href="https://github.com/kvaggelakos/serverless-ffmpeg/blob/master/src/ffmpeg.js#L9" rel="noopener ugc nofollow" target="_blank">参见它的代码以了解如何</a>)</li><li id="bdcf" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第16行对一个测试文件运行ffmpeg，并期望一个文件在测试结束时存在</li><li id="dd80" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">第26行测试后清理</li></ol><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="ml mm l"/></div></figure><h2 id="2d17" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">部署</h2><p id="0cad" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">无服务器的一大优点是部署和拆卸非常容易。由于无服务器框架在云模板中完成所有工作，因此既快速又简单。不再问“我在哪里运行了什么命令”。</p><p id="03c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了部署整个堆栈，我们运行:<code class="eh mc md me mf b">sls deploy -v</code>。这将显示cloudformation状态的输出，以便我们可以确保所有资源都是按照它们应该的方式创建的。</p><p id="5e23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！</p><h2 id="85a5" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">结果呢</h2><p id="569b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">你可以看看这个小视频，看看它最终是如何工作的。</p><div class="mr ms fm fo mt mu"><a href="https://asciinema.org/a/154418" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd hv fv z el mz eo ep na er et ht dt translated">无服务器-ffmpeg</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">由kvaggelakos录制</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">asciinema.org</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ld mu"/></div></div></a></div><h2 id="fbf1" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated">结论</h2><p id="d869" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我希望您喜欢这个快速深入了解无服务器和真实世界的例子！在接下来的部分中，我们将会看到更多有趣的真实世界场景，以及如何将它们货币化，所以不要走开！</p><p id="b73d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我们在这部分遇到的几个现实生活中的问题:</strong></p><ol class=""><li id="781d" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">我们希望添加webpack，让我们的时间物有所值</li><li id="092c" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">我们需要使用一个webpack插件，并保持这个二进制文件的权限，以实际工作(连同无服务器框架)</li><li id="fd5a" class="lt lu hu it b iu mg iy mh jc mi jg mj jk mk jo ly lz ma mb dt translated">如果我们将事件附加到一个桶上，就会创建一个桶！我知道这看起来很随意。但规则不是我定的。</li></ol><p id="c6d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在接下来的部分，我将揭示更多的生活场景和解决的问题。</p><p id="8643" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有任何问题或意见，请在这里发表，我会尽力帮助你。</p><h1 id="c025" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">附录</h1><h2 id="d96b" class="lf jr hu bd js lg lh li jw lj lk ll ka jc lm ln ke jg lo lp ki jk lq lr km ls dt translated"><a class="ae jp" href="https://github.com/serverless/plugins" rel="noopener ugc nofollow" target="_blank">无服务器插件</a>——找到它们，使用它们</h2><p id="1093" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当我开始的时候，有一件事对我来说并不明显，那就是插件对于无服务器框架有多重要。我们将在这一部分使用的两个插件是(更多插件在第2部分和第3部分):</p><p id="d7c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/serverless-heaven/serverless-webpack" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">server less-web pack</strong></a><strong class="it hv"><br/></strong>因为截至今日<a class="ae jp" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> aws </a> lambda支持node 6.10，不完全支持es6。我们想要那种花哨的es6/7和其他一些不错的包装功能。</p><p id="89af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/sinofseven/serverless-s3-remover" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">server less-S3-remover</strong></a><strong class="it hv"><br/></strong>您会很快意识到，在测试过程中，您会多次使用无服务器框架部署和拆除堆栈。如果您正在使用存储桶，这可以帮助我们在销毁堆栈时删除存储桶和其中的内容。(<strong class="it hv">警告:你会对这个</strong>失去满足感)</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="nj mm l"/></div></figure></div></div>    
</body>
</html>