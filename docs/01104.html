<html>
<head>
<title>An Introduction to GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/an-introduction-to-graphql-2c3f7d8fb4e0?source=collection_archive---------2-----------------------#2018-02-03">https://medium.com/hackernoon/an-introduction-to-graphql-2c3f7d8fb4e0?source=collection_archive---------2-----------------------#2018-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir"><p id="c6fb" class="is it hu bd iu iv iw ix iy iz ja jb ek translated">对学习JavaScript感兴趣？在jshandbook.com的<a class="ae jc" href="https://jshandbook.com/" rel="noopener ugc nofollow" target="_blank">获得我的免费电子书</a></p></blockquote><p id="b4fa" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz jb hn dt translated">GraphQL是API的新前沿(<em class="ka">应用编程接口</em>)。</p><p id="f1e9" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">它是一种用于API的查询语言，以及一组用于执行查询的服务器端运行时(用各种后端语言实现)。</p><p id="bdf8" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">它不依赖于特定的技术，但是你可以用任何语言来实现它。</p><p id="ae78" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">这是一种<strong class="jf hv">直接与REST </strong> ( <em class="ka">具象状态转移</em>)API竞争的方法论，很像REST最初与<strong class="jf hv"> SOAP </strong>竞争。</p><p id="4f49" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">GraphQL是在脸书开发的<strong class="jf hv">，就像最近震撼世界的许多技术一样，比如<a class="ae jc" href="https://flaviocopes.com/react-beginners-guide" rel="noopener ugc nofollow" target="_blank"> React </a>和React Native，它是在2015年</strong>公开发布的<strong class="jf hv">——尽管脸书之前在内部使用了几年。</strong></p><p id="7030" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">除了脸书，许多大公司都在采用GraphQL，包括GitHub，Pinterest，Twitter，Sky，New York Times，Shopify，Yelp和其他许多公司。</p><h1 id="d5cd" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">GraphQL原则</h1><p id="8683" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated"><strong class="jf hv"> GraphQL公开了一个端点</strong>。</p><p id="dff3" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">您通过使用特殊查询语言语法向端点发送一个查询。那个查询是一个字符串。</p><p id="c64b" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">服务器通过提供JSON对象来响应查询。</p><p id="8ce7" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">让我们看看这样一个查询的第一个例子。这个查询获得了一个名字为<code class="eh lj lk ll lm b">id=1</code>的人的名字:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="886b" class="lv kh hu lm b fv lw lx l ly lz">GET /graphql?query={ person(id: "1") { name } }</span></pre><p id="6332" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">或者只是</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="2cdf" class="lv kh hu lm b fv lw lx l ly lz">{ person(id: "1") { name } }</span></pre><p id="9dc9" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">我们将得到这个JSON响应:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="2326" class="lv kh hu lm b fv lw lx l ly lz">{ "name": "Tony" }</span></pre><p id="2393" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">让我们增加一点复杂性:通过从<code class="eh lj lk ll lm b">address</code>对象中提取，我们得到了这个人的名字，以及这个人居住的城市。我们不关心地址的其他细节，服务器也不会将它们返回给我们。</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="1a68" class="lv kh hu lm b fv lw lx l ly lz">GET /graphql?query={ person(id: "1") { name, address { city } } }</span></pre><p id="5019" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">或者</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="5d32" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  person(id: "1") { <br/>    name <br/>    address { <br/>      city <br/>    } <br/>  } <br/>}</span><span id="1909" class="lv kh hu lm b fv ma lx l ly lz">{ <br/>  "name": "Tony", <br/>  "address": { <br/>    "city": "York" <br/>  } <br/>}</span></pre><p id="9ef2" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">如您所见，我们得到的数据基本上与我们发送的请求相同，充满了值。</p><h1 id="940e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">GraphQL与REST</h1><p id="d0cc" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">由于REST是构建API的一种非常流行的方法，或者我可以说是通用的方法，所以可以假定您对它很熟悉，所以让我们来看看GraphQL和REST之间的区别。</p><h1 id="ca08" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">休息是一个概念</h1><p id="6096" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">REST是一个事实上的架构标准，但是它实际上没有规范和大量的非官方定义。GraphQL有一个<a class="ae jc" href="http://facebook.github.io/graphql/" rel="noopener ugc nofollow" target="_blank">规范</a>草案，它是一种<a class="ae jc" href="http://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank">查询语言</a>而不是一种架构，有一套围绕它构建的定义良好的工具(以及一个蓬勃发展的生态系统)。</p><p id="a8c7" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">REST构建在现有架构之上，最常见的场景是HTTP，而GraphQL正在构建自己的一套约定。这可能是一个优势，也可能不是，因为REST通过在HTTP层进行缓存而免费惠及了<em class="ka"/>。</p><h1 id="e470" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">单一端点</h1><p id="2d41" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">GraphQL只有一个端点，您可以在那里发送所有的查询。使用REST方法，您可以创建多个端点，并使用HTTP <strong class="jf hv">动词</strong>来区分读操作(GET)和写操作(POST、PUT、DELETE)。GraphQL不使用HTTP动词来确定请求类型。</p><h1 id="4349" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">根据您的需求量身定制</h1><p id="a064" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">使用REST，您通常不能选择服务器返回给您什么，除非服务器使用<a class="ae jc" href="http://jsonapi.org/format/#fetching-sparse-fieldsets" rel="noopener ugc nofollow" target="_blank">稀疏字段集</a>实现部分响应，并且客户端使用该特性。API维护者不能实施这样的过滤。</p><p id="678c" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">API通常会返回比您所需要的更多的信息，除非您也控制API服务器，并且针对每个不同的请求定制您的响应。</p><p id="5d81" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">使用<a class="ae jc" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>时，您显式地只请求您需要的信息，而不是从完整的默认响应中“选择退出”,而是强制选择您想要的字段。</p><p id="ed72" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">这有助于节省服务器上的资源，因为您很可能需要更少的处理，也节省了网络，因为要传输的负载更小。</p><h1 id="c384" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">GraphQL使得监控字段使用变得容易</h1><p id="b108" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">对于REST，除非强制使用稀疏字段集，否则没有办法确定一个字段是否被客户端使用，所以当涉及到重构或弃用时，不可能确定实际的用法。</p><p id="60bb" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">GraphQL使得跟踪客户机使用哪些字段成为可能。</p><h1 id="7ec0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">访问嵌套的数据资源</h1><p id="4cbe" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">GraphQL允许生成少得多的网络调用。</p><p id="004a" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">让我们来做一个例子:你需要访问一个人的朋友的名字。如果您的REST API公开了一个<code class="eh lj lk ll lm b">/person</code>端点，该端点返回一个包含朋友列表的person对象，那么您通常首先通过执行<code class="eh lj lk ll lm b">GET /person/1</code>来获取person信息，该信息包含其朋友的ID列表。</p><p id="c160" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">除非一个人的朋友列表已经包含了朋友的名字，否则有100个朋友时，你需要向<code class="eh lj lk ll lm b">/person</code>端点发出101个HTTP请求，这是一个巨大的时间开销，也是一个资源密集型操作。</p><p id="5797" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">使用GraphQL，您只需要一个请求，即询问一个人的朋友的名字。</p><h1 id="8e1c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">类型</h1><p id="1688" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">REST API是基于JSON的，它不能提供类型控制。<strong class="jf hv"> GraphQL有一个类型系统</strong>。</p><h1 id="8efc" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">哪个更好？</h1><p id="cdaa" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">世界各地的组织都在质疑他们的API技术选择，他们试图找出从REST迁移到GraphQL是否最符合他们的需求。</p><p id="b1d9" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">当您需要公开复杂的数据表示时，或者当客户端可能只需要数据的一个子集时，或者当它们定期执行嵌套查询以获取所需数据时，GraphQL是一个完美的选择。</p><p id="a3f5" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">就像编程语言一样，没有唯一的赢家，这完全取决于你的需求。</p><h1 id="3a4a" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">GraphQL查询</h1><p id="5f66" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">在本文中，您将了解GraphQL查询是如何组成的。</p><p id="3373" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">我将介绍的概念是</p><ul class=""><li id="1b17" class="mb mc hu jf b jg kb jk kc jo md js me jw mf jb mg mh mi mj dt translated">字段和参数</li><li id="d826" class="mb mc hu jf b jg mk jk ml jo mm js mn jw mo jb mg mh mi mj dt translated">别名</li><li id="5feb" class="mb mc hu jf b jg mk jk ml jo mm js mn jw mo jb mg mh mi mj dt translated">碎片</li></ul><h1 id="1ed8" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">字段和参数</h1><p id="01c9" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">以这个简单的GraphQL查询为例:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="d5ed" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  person(id: "1") { <br/>    name <br/>  } <br/>}</span></pre><p id="2ced" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">在这个查询中，您可以看到2个字段和1个参数。</p><p id="3b5b" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">字段<code class="eh lj lk ll lm b">person</code>返回一个<em class="ka">对象</em>，其中有另一个字段，一个<em class="ka">字符串</em>。</p><p id="92d8" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">参数允许我们指定我们想要引用哪个人。我们传递一个<code class="eh lj lk ll lm b">id</code>，但是我们也可以传递一个<code class="eh lj lk ll lm b">name</code>参数，如果我们与之对话的API可以选择通过名字找到一个人。</p><p id="97c9" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">参数不限于任何特定的字段，我们可以在<code class="eh lj lk ll lm b">person</code>中有一个<code class="eh lj lk ll lm b">friends</code>字段，列出那个人的朋友，它可以有一个<code class="eh lj lk ll lm b">limit</code>参数，指定我们希望API返回多少:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="4584" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  person(id: "1") { <br/>    name<br/>    friends(limit: 100) <br/>  } <br/>}</span></pre><h1 id="644c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">别名</h1><p id="0655" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">您可以要求API返回具有不同名称的字段，例如:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="5eb7" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  owner: person(id: "1") { <br/>    fullname: name <br/>  } <br/>}</span></pre><p id="898c" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">会回来的</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="e128" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  "data": {<br/>    "owner": { <br/>      "fullname": "Tony" <br/>    } <br/>  } <br/>}</span></pre><p id="18b8" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">除了为您的客户机代码创建更多的特别命名之外，如果您需要在同一个查询中<strong class="jf hv">引用同一个端点两次</strong>，这个特性是唯一可以使查询工作的东西:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="f31c" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  owner: person(id: "1") { <br/>    fullname: name <br/>  } <br/>  first_employee: person(id: "2") { <br/>    fullname: name <br/>  } <br/>}</span></pre><h1 id="a8ab" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">碎片</h1><p id="f6b9" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">在上面的查询中，我们复制了人员结构。片段允许我们指定一次结构(对许多字段非常有用):</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="cbea" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  owner: person(id: "1") {<br/>    ...personFields <br/>  } <br/>  first_employee: person(id: "2") {<br/>    ...personFields<br/>  }<br/>} </span><span id="5880" class="lv kh hu lm b fv ma lx l ly lz">fragment personFields on person {<br/>  fullname: name <br/>}</span></pre><h1 id="a3e4" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">GraphQL变量</h1><p id="e87d" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">更复杂的GraphQL查询需要使用<strong class="jf hv">变量</strong>，这是一种动态指定查询中使用的值的方式。</p><p id="fecf" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">在这种情况下，我们将人员id作为字符串添加到查询中:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="8e1f" class="lv kh hu lm b fv lw lx l ly lz">{ <br/>  owner: person(id: "1") { <br/>    fullname: name<br/>  } <br/>}</span></pre><p id="3878" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">id很可能会在我们的程序中动态改变，所以我们需要一种方法来传递它，并且<strong class="jf hv">不使用字符串插值</strong>。</p><p id="a388" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">对于变量，相同的查询可以写成</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="35c0" class="lv kh hu lm b fv lw lx l ly lz">query GetOwner($id: String) { <br/>  owner: person(id: $id) { <br/>    fullname: name <br/>  } <br/>} </span><span id="2d19" class="lv kh hu lm b fv ma lx l ly lz">{ <br/>  "id": "1"<br/>}</span></pre><p id="3d63" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">在这个代码片段中，我们为我们的查询指定了名称<code class="eh lj lk ll lm b">GetOwner</code>。把它想象成命名函数，而之前你有一个匿名函数。当应用程序中有大量查询时，命名查询非常有用。</p><p id="276d" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">带有变量的查询定义看起来像一个函数定义，它以同样的方式工作。</p><h1 id="fcb9" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">使变量成为必需</h1><p id="8418" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">向类型追加一个<code class="eh lj lk ll lm b">!</code>:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="89c3" class="lv kh hu lm b fv lw lx l ly lz">query GetOwner($id: String!)</span></pre><p id="3910" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">而不是<code class="eh lj lk ll lm b">$id: String</code>将使$id变量成为必需的。</p><h1 id="08e4" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">为变量指定默认值</h1><p id="a633" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">您可以使用以下语法指定默认值:</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="8e83" class="lv kh hu lm b fv lw lx l ly lz">query GetOwner($id: String = "1")</span></pre><h1 id="b681" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">GraphQL指令</h1><p id="041e" class="pw-post-body-paragraph jd je hu jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz jb hn dt translated">指令允许您在变量为真或假时包含或排除字段。</p><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="237c" class="lv kh hu lm b fv lw lx l ly lz">query GetPerson($id: String, $getAddress: Boolean) { <br/>  person(id: $id) { <br/>    fullname: name, <br/>    address: @include(if: $getAddress) { <br/>      city <br/>      street <br/>      country <br/>    } <br/>  } <br/>}</span><span id="9ea3" class="lv kh hu lm b fv ma lx l ly lz">{ <br/>  "id": "1", <br/>  "getAddress": false<br/>}</span></pre><p id="2912" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">在这种情况下，如果我们传递的变量<code class="eh lj lk ll lm b">getAddress</code>为真，我们也会得到地址字段，否则不会。</p><p id="0b23" class="pw-post-body-paragraph jd je hu jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz jb hn dt translated">我们有两个可用的指令:<code class="eh lj lk ll lm b">include</code>，我们刚刚看到的(如果为真，则包含在内)，和<code class="eh lj lk ll lm b">skip</code>，相反(如果为真，则跳过)</p><h1 id="9795" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">@include(if: Boolean)</h1><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="98d6" class="lv kh hu lm b fv lw lx l ly lz">query GetPerson($id: String, $getAddress: Boolean) { <br/>  person(id: $id) { <br/>    fullname: name, <br/>    address: @include(if: $getAddress) { <br/>      city <br/>      street <br/>      country <br/>    } <br/>  } <br/>} </span><span id="509b" class="lv kh hu lm b fv ma lx l ly lz">{<br/>  "id": "1", <br/>  "getAddress": false <br/>}</span></pre><h1 id="aba7" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">@skip(if: Boolean)</h1><pre class="ln lo lp lq fq lr lm ls lt aw lu dt"><span id="e523" class="lv kh hu lm b fv lw lx l ly lz">query GetPerson($id: String, $excludeAddress: Boolean) { <br/>  person(id: $id) { <br/>    fullname: name, <br/>    address: @skip(if: $excludeAddress) { <br/>      city <br/>      street <br/>      country <br/>    } <br/>  } <br/>}</span><span id="51fc" class="lv kh hu lm b fv ma lx l ly lz">{ <br/>  "id": "1", <br/>  "excludeAddress": false <br/>}<!-- --> </span></pre></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><blockquote class="ir"><p id="23ea" class="is it hu bd iu iv mw mx my mz na jb ek translated">对学习JavaScript感兴趣？在jshandbook.com的<a class="ae jc" href="https://jshandbook.com/" rel="noopener ugc nofollow" target="_blank">获得我的免费电子书</a></p></blockquote><figure class="nb nc nd ne nf ng"><div class="bz el l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>