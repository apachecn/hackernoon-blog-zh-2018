<html>
<head>
<title>Spectre &amp; Meltdown Processor Vulnerabilities: A Technical Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spectre &amp; Meltdown处理器漏洞:技术介绍</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/spectre-meltdown-processor-vulnerabilities-a-technical-introduction-e3d09d6699a6?source=collection_archive---------16-----------------------#2018-02-03">https://medium.com/hackernoon/spectre-meltdown-processor-vulnerabilities-a-technical-introduction-e3d09d6699a6?source=collection_archive---------16-----------------------#2018-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4e1e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">《幽灵和熔毁》的重要技术方面</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/c01caf0c0abef608749c56d3a3d3ce4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*QQUFzcgKC5J1EzpY9Kn3dQ.png"/></div></figure><p id="5705" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在之前的一篇<a class="ae kn" rel="noopener" href="/revissolutions/spectre-meltdown-processor-vulnerabilities-what-you-need-to-know-587ebb37f2dc">帖子</a>中，我们讨论了最近披露的名为Spectre(<a class="ae kn" href="https://nvd.nist.gov/vuln/detail/CVE-2017-5753" rel="noopener ugc nofollow" target="_blank">CVE-2017–5753</a>、<a class="ae kn" href="https://nvd.nist.gov/vuln/detail/CVE-2017-5715" rel="noopener ugc nofollow" target="_blank">CVE-2017–5715</a>)&amp;Meltdown(<a class="ae kn" href="https://nvd.nist.gov/vuln/detail/CVE-2017-5754" rel="noopener ugc nofollow" target="_blank">CVE-2017–5754</a>)的处理器攻击。虽然我们知道我们的大多数读者是技术用户，他们只是想在安全性方面做得更好(并且对技术不感兴趣)，但我们也知道我们的一些读者喜欢深入一点技术领域。在本帖中，我们将重点介绍《幽灵党》和《熔毁》中的一些关键技术。</p><p id="d54f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">虽然这是一篇技术博客文章，但这并不意味着教授攻击。相反，它强调了攻击提出的一些关键技术原则。这篇博客是基于<a class="ae kn" href="https://spectreattack.com/" rel="noopener ugc nofollow" target="_blank">技术文章</a>，应该参考这些文章以全面了解这些攻击。</p><h1 id="8efd" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">关键术语</h1><p id="22ca" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">在我们讨论Spectre和Meltdown中到底发生了什么之前，我们必须了解一些关键术语:</p><h2 id="d86a" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">侧槽</h2><p id="5fc5" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">信息安全中的侧信道是系统的一个功能或特征，它会泄露非预期的信息。</p><p id="6de6" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">物理世界中的一个例子:你家中灯光的可见性是一个侧面通道，用于识别是否有人在你的房子里，而无需实际观察房子里的人。或者，如果每天同一时间有一盏灯亮着，而没有其他灯亮着，这是一个识别居住者可能不在城里的辅助通道。因此，一个辅助渠道寻找被披露的信息，并试图利用它。侧信道不一定是特定系统中的技术弱点。</p><p id="f014" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这在技术上的一个例子是:注意计算机的温度差异来推断系统正在做什么。<a class="ae kn" href="https://www.wired.com/2015/03/stealing-data-computers-using-heat/" rel="noopener ugc nofollow" target="_blank"> Wired </a>在实践中有一篇关于这方面的好文章。</p><h2 id="b261" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">隐蔽通道</h2><p id="d638" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">秘密渠道比旁门左道更具侵略性。虽然侧信道只是被简单地“观察”，但隐蔽信道通常会改变它攻击的系统。这种改变产生了将数据从特权上下文转移到不应该访问该数据的上下文的能力。</p><p id="d76f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">现实世界中的一个例子:一个对手通过在你的墙上隐藏麦克风来窃听一所房子。他们改变了房子，现在可以偷听特权对话。</p><p id="41f8" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">技术上的一个例子是:一个恶意程序通过修改合法数据包的IP标识字段来泄露数据。然后，攻击者从网络上嗅探这些数据包。通过将数据封装在合法数据包的IP标识字段中，恶意程序可能能够绕过系统监控。</p><p id="169a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在这两种情况下，隐蔽通道引起系统的“变化”，而侧通道是被动的。(请注意，按照通俗的说法，这些术语有时可以互换使用，只是为了表示一种无意的信息泄露方法)。</p><h2 id="8647" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">核心</h2><p id="9f88" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">操作系统有一部分被称为“内核”。它被加载到受保护的内存空间中，并控制程序和系统底层硬件之间的交互。</p><h2 id="632f" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">虚拟内存</h2><p id="19de" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">计算机将一个进程的内存与其他进程的内存隔离开来。但是每个程序都认为它可以访问系统的所有内存。中央处理器(CPU)为每个进程提供一个虚拟内存空间，并维护一个将虚拟内存转换为物理内存的“页表”。</p><h2 id="fc41" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">物理内存</h2><p id="8759" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">这些是基于硬件的内存模块，物理上位于您的计算机中，容纳构成随机存取存储器(RAM)的实际位。CPU将虚拟内存映射到物理内存。</p><h2 id="d3d3" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">流水线、无序/推测性执行、瞬时指令</h2><p id="cefd" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">现代CPU的架构设计导致了Spectre和Meltdown漏洞。具体来说，指令流水线。程序用人类可读的语言(如Python、Ruby、JavaScript)编写，然后<a class="ae kn" href="https://en.wikipedia.org/wiki/Compiler" rel="noopener ugc nofollow" target="_blank">将</a>编译成<a class="ae kn" href="https://en.wikipedia.org/wiki/Machine_code" rel="noopener ugc nofollow" target="_blank">机器代码</a>，这些代码可以被CPU执行。</p><p id="3192" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了提高效率，现代CPU实现了指令流水线。这意味着处理器试图让CPU的每一部分都被某种东西占据。因此，当CPU的一部分正在获取数据时，CPU可能会继续执行下一条指令，即使这取决于获取数据的结果。这导致指令的无序执行。CPU对下一步将执行什么指令做出最佳猜测。这也称为推测性执行。</p><p id="3d60" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果CPU采用不正确的逻辑路径，推测执行的结果将被忽略。这些被忽略的指令被称为“瞬时指令”。虽然这些瞬态指令不会改变实际的程序流程，但是在这些瞬态指令的推测性执行期间，CPU的“微体系结构状态”会发生变化。具体来说，CPU缓存会受到影响。</p><h2 id="b8db" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">CPU缓存</h2><p id="5c3c" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">为了进一步加快访问速度，CPU维护片上缓存，用于存储频繁访问的内存的值。</p><h2 id="c679" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">竞争条件</h2><p id="57d6" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">信息安全中的竞争条件是一种漏洞，它要求攻击系统成为“第一个”响应数据请求的系统，或者在数据消失之前第一个访问数据的系统。竞争条件的一个很好的技术示例是MySQL 中的<a class="ae kn" href="https://support.alertlogic.com/hc/en-us/articles/115004516766-09-01-2017-MySQL-Database-Race-Condition-my-copystat-Privilege-Escalation" rel="noopener ugc nofollow" target="_blank"> 2017漏洞。实质上，如果攻击者能够向系统写入文件，他们就可以覆盖在特权MySQL操作期间生成的临时文件。如果他们在文件创建之后、操作完成之前替换了临时文件，他们可以在MySQL中将权限提升到。</a></p><h2 id="0aa2" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">用户空间与内核空间的内存空间</h2><p id="fa16" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">最后，明确区分内核空间内存和用户空间内存非常重要。用户空间虚拟内存保存运行程序(即进程)的内存。用户空间虚拟内存被映射到物理内存的特定部分。</p><p id="1c92" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">内核有自己的虚拟内存空间<strong class="jt hv">，但是这个内核空间虚拟内存被映射到整个物理内存</strong>(我们将在讨论Meltdown时看到其后果)。</p><p id="ef59" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">CPU维护一个页表，其中包含内核空间和用户空间内存的映射。这个页表将虚拟内存转换为物理内存。重要的是要记住，内核空间内存被映射到所有物理内存，其中也包含用户空间内存。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/cbcd13898fbf42bd8501f7f11810281f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*VfV67TYt-1SL81mvIbmm9g.png"/></div><figcaption class="ma mb fg fe ff mc md bd b be z ek">Virtual memory page table layout, Source: <a class="ae kn" href="https://meltdownattack.com/meltdown.pdf" rel="noopener ugc nofollow" target="_blank">Meltdown paper</a></figcaption></figure><p id="aadf" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当在用户空间操作和内核空间操作之间切换时，CPU指示使用的虚拟内存是用户空间虚拟内存还是内核空间虚拟内存。它通过设置或取消设置“管理位”来实现这一点。这将当前CPU操作的内存访问限制在虚拟内存的特定页面。</p><p id="67e8" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">定义好所有这些术语后，让我们看看Spectre和Meltdown如何利用现代CPU架构设计。</p><h1 id="1da6" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">孤立不受尊重</h1><p id="9243" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">这两个漏洞所利用的关键设计缺陷是，放置在缓存中的<strong class="jt hv">内存没有受到保护，其他进程不能访问原始的、未缓存的内存。</strong></p><p id="95d3" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">利用所有这些漏洞，恶意程序会将数据写入CPU缓存，然后通过旁路攻击读取这些数据。这种旁路攻击依赖于恶意程序在CPU缓存被覆盖之前读取它的竞争条件。</p><h1 id="5e38" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">幽灵</h1><p id="5d29" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">Spectre的后果是一个对抗性的程序可以读取其他程序的进程内存。</p><p id="7829" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">正如我们上面提到的，现代CPU使用推测性执行来提高处理效率。CPU对推测性执行采取最佳猜测方法。通过观察最近的执行模式，CPU在运行中“训练”自己更频繁地遵循某些逻辑路径。</p><p id="af65" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Spectre利用了这种设计，并训练CPU遵循期望的推测路径。Spectre有两种变体:条件分支预测失误利用和间接分支利用。</p><h2 id="feb4" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">条件分支预测失误利用</h2><p id="3eaf" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">编程的一个强大方面是编写条件逻辑的能力。即“如果这个那么那个”。这被翻译成机器码级别的“条件分支”逻辑。为了利用Spectre，恶意程序重复执行具有相同结果<code class="eh me mf mg mh b">true</code>或<code class="eh me mf mg mh b">false</code>的条件测试。</p><p id="4f8f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">条件分支操作的伪代码:</p><pre class="jk jl jm jn fq mi mh mj mk aw ml dt"><span id="6906" class="ll kp hu mh b fv mm mn l mo mp">x = 6<br/>if x equals 6<br/>   print 'x equals 6'</span></pre><p id="1c24" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果我们重复执行上述动作，CPU将训练自己在推测执行期间遵循<code class="eh me mf mg mh b">true</code>路径，即使在后面的操作中结果不是真的。</p><p id="2090" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">现在，让我们假设在稍后的推测分支操作中，我们试图访问特权内存</p><pre class="jk jl jm jn fq mi mh mj mk aw ml dt"><span id="8244" class="ll kp hu mh b fv mm mn l mo mp">x = 2<br/>if x equals 6<br/>   y = my_array[x * 256]  ; memory outside of the current program</span></pre><p id="eb9f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">条件测试将失败。<strong class="jt hv">但如果我们对CPU进行了适当的训练，在它测试失败之前，CPU会执行</strong><em class="mq"/><code class="eh me mf mg mh b"><strong class="jt hv">true</strong></code><strong class="jt hv"><em class="mq"/>条件分支</strong> <em class="mq">的瞬态指令。</em>处理器将在程序内存空间之外的内存中<code class="eh me mf mg mh b">my_array</code>之前512字节的数组<code class="eh me mf mg mh b">my_array[x * 256]</code>的内存地址查找值。</p><p id="2149" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果条件分支实际上评估为真，这将导致抛出内存访问冲突错误，程序将崩溃。但是如果条件评估为<code class="eh me mf mg mh b">false</code>，则不抛出错误，并且忽略瞬态指令的结果，但是瞬态指令的结果(在<code class="eh me mf mg mh b">my_array[x * 256]</code>的值)现在位于CPU缓存中。</p><h2 id="be4f" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">间接分支剥削</h2><p id="c2f9" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">间接分支机器代码指令使CPU评估存储器中其他地方的机器代码指令，而不是继续指令的顺序处理。</p><p id="ea64" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">示例机器代码操作跳转到存储器地址<code class="eh me mf mg mh b">0x12345678</code>执行指令:</p><pre class="jk jl jm jn fq mi mh mj mk aw ml dt"><span id="9e33" class="ll kp hu mh b fv mm mn l mo mp">jmp 0x12345678</span></pre><p id="45e2" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果恶意程序可以训练CPU对执行已知计算的代码进行推测性跳转，该计算可以改变CPU缓存的微体系结构状态。</p><p id="7d21" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">条件分支预测失误利用和间接分支利用之间的关键相似之处在于，这两种方法都训练CPU采用推测性逻辑路径，从而导致利用程序所需的执行。它最终会被忽略，但在这种丢弃发生之前，它会改变CPU缓存。</p><p id="f201" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">两者的关键区别在于机器码的位置。条件分支预测失误利用的代码位于恶意程序的内存空间中。另一方面，间接分支利用的代码位于内存中的其他位置，但仍然执行所需的计算，从而改变CPU缓存。</p><h2 id="3281" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">从CPU缓存中收集数据</h2><p id="d052" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">然后，CPU缓存被恶意程序用作辅助通道。在条件分支错误预测利用或间接分支利用之后，恶意程序执行基于时间的旁路攻击，以推断对高速缓存进行了什么改变，随后获知存储在这些高速缓存中的特权信息。这些攻击在其他研究中有记录，不在这篇博文的讨论范围之内。</p><p id="e7e5" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">因此，作为一个完整的攻击进程，Spectre使用CPU缓存创建一个隐蔽通道，将数据从用户空间内存中的一个进程移动到用户空间内存中的一个恶意程序。最终，Spectre将特权信息透露给了一个恶意程序。</p><p id="9330" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">与两个Spectre漏洞不同，Meltdown攻击只有一个变种。它也使用CPU缓存作为隐蔽通道，但在攻击的技术实现方式上有一些重要的不同。</p><h1 id="3213" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">灾难</h1><p id="7cf5" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">Meltdown的后果是恶意程序可以读取内核空间内存。由于内核空间内存映射到所有物理内存，这意味着恶意程序可以读取所有内核空间内存和所有用户空间内存。</p><p id="395f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Meltdown是一种针对CPU逻辑电路的攻击，因此它主要局限于基于英特尔的处理器。Meltdown不需要针对特定软件环境定制的代码。相比之下，使用Spectre，攻击必须针对受害者系统的软件环境进行定制，但它们可以在运行英特尔和非英特尔架构的系统上工作。</p><p id="0eec" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">此外，Meltdown攻击滥用了一个权限提升漏洞:英特尔CPU允许用户空间进程的瞬时指令访问内核空间内存。</p><h2 id="e61e" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">剥削</h2><p id="c375" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">Meltdown没有训练CPU采用特定的逻辑分支，而是直接尝试访问特权内核空间内存页面。当用户空间进程试图访问特权内核空间内存时，CPU会抛出一个访问冲突异常错误。恶意程序“<a class="ae kn" href="https://en.wikipedia.org/wiki/Exception_handling" rel="noopener ugc nofollow" target="_blank">捕捉到</a>访问违规异常。通过捕捉这个异常，恶意程序不会崩溃。但是，CPU仍然执行瞬态指令，内核空间内存放在CPU缓存中。</p><p id="a2e5" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">然后，恶意程序执行Spectre用来读取CPU高速缓存的相同的旁路攻击。</p><p id="85c1" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">对于这两类攻击，有不同的缓解步骤。</p><h1 id="cc59" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">减轻</h1><p id="a3f4" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">让我们看看幽灵和熔毁的技术解决方案。</p><h2 id="ec69" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">熔化migitagion</h2><p id="6c97" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">熔毁是两者中较容易缓解的。一些补丁已经缓解了熔毁。</p><p id="b3d6" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Meltdown依赖于对内核空间内存的访问，因为该内存已经被指定为特权内存，所以CPU在执行推测性指令时只需尊重这种隔离。</p><p id="9939" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">2017年6月，在这些漏洞被披露之前，Linux内核实施了一个名为内核地址隔离的补丁，以有效地删除侧通道(KAISER)，以防止通过侧通道泄露随机内核空间内存。KAISER将内核空间页表和用户空间页表完全分开。使用KAISER，内核空间页表仅在执行内核操作时可用。</p><p id="526d" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Meltdown的目标是从随机内核空间内存访问转变为系统内核空间内存访问。由于恶意程序运行在用户空间内存中，并且不再能够访问内核空间页表，KAISER补丁无意中缓解了崩溃。Mac和微软都在实现他们自己版本的KAISER，通常被称为内核表页隔离(KPTI)。</p><h2 id="5b06" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">幽灵缓解</h2><p id="cd23" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">不幸的是，Spectre很可能会“困扰”我们很长一段时间。这是因为攻击发生在同一个内存空间(即用户空间内存)，并且在推测性执行期间很难隔离内存访问。</p><p id="e898" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">研究人员提出了几个可能的缓解步骤:1)暂停潜在敏感的推测性执行路径，直到早期逻辑得到解决，2)在进程之间切换时刷新分支预测模型。第一种解决方案会“严重降低性能”，我们已经看到在撰写本文时提供的补丁下，基准性能下降了2%-14%。第二种解决方案目前在研究中被认为是一种假设，作者承认它可能不会减轻所有的幽灵病例。</p><h2 id="9661" class="ll kp hu bd kq lm ln lo ku lp lq lr ky ka ls lt la ke lu lv lc ki lw lx le ly dt translated">结论</h2><p id="002d" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">这些绝不是容易理解的漏洞。他们深入研究CPU的核心工作，模糊了软件和硬件之间的界限。除了了解这里写的所有内容，要执行攻击，您还必须了解以前的文献，这些文献详细介绍了如何对CPU缓存执行侧通道攻击，我们认为这是理所当然的。(这主要是因为我不完全理解如何在比理论更深的层次上实现它们)。</p><p id="1a8c" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我希望这能帮助您理解这些漏洞的更深层次的技术方面。我自己也在不断学习，所以如果你注意到技术上的错误，请留下评论！</p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="3560" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="mq">此帖出自</em> <a class="my mz gr" href="https://medium.com/u/c9fabda04fb1?source=post_page-----e3d09d6699a6--------------------------------" rel="noopener" target="_blank"> <em class="mq">以赛亚·萨居</em> </a> <em class="mq">对</em> <a class="ae kn" href="https://www.revissolutions.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mq">的修正解</em> </a> <em class="mq">。如果你喜欢这个帖子一定要鼓掌，查看他在</em> <a class="ae kn" href="https://medium.com/revissolutions" rel="noopener"> <em class="mq">修正解决方案博客</em> </a> <em class="mq">上的其他帖子，并关注推特</em><a class="ae kn" href="https://twitter.com/isaiahsarju" rel="noopener ugc nofollow" target="_blank"><em class="mq">@ isaiahsarju</em></a><em class="mq">、</em><a class="ae kn" href="https://twitter.com/revissolution" rel="noopener ugc nofollow" target="_blank"><em class="mq">@修正解决方案</em> </a></p></div></div>    
</body>
</html>