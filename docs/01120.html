<html>
<head>
<title>Concurrency: how it can help you and how you can use GOLANG to reach it easily</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发性:它如何帮助您，以及您如何使用GOLANG轻松实现它</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/concurrency-how-it-can-help-you-and-how-you-can-use-golang-to-reach-it-easily-ae3e070b3d2c?source=collection_archive---------18-----------------------#2018-02-03">https://medium.com/hackernoon/concurrency-how-it-can-help-you-and-how-you-can-use-golang-to-reach-it-easily-ae3e070b3d2c?source=collection_archive---------18-----------------------#2018-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d4e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能知道，并发和并行是不同的术语。并发意味着一个应用程序同时(并发地)在多个任务上取得进展；并行性是指应用程序将其任务分解为更小的子任务，这些子任务可以并行处理，例如同时在多个CPU上处理。</p><p id="53f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们想象一个简单的例子，其中有一个应用程序正在处理多个任务，应用并发性会有很大帮助:<br/>一所大学开始使用一个新的数据库作为他们测试的问题来源。因为这个数据库比其他数据库有更多的问题，他们在检查答案是否正确以计算每个学生的最终分数时遇到了问题。由于数据太多，缓存没有意义，也不可能保存在内存中。<br/> <br/>嗯，性能变低是因为他们必须获得所有答案，并在计算最终分数之前检查每个答案的正确选择，这使得脚本消耗了大量的运行时间。<br/>这个问题可以通过使用并发来轻松解决。在一项任务中应用它会使它取得进展，而不必等待其他任务。然后，当一个任务在DB上搜索答案时，另一个任务已经在检查答案是否正确，另一个任务可以聚合答案以持久存储数据。</p><p id="ad49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">现在，让我们使用Golang </strong> : <br/> git克隆<a class="ae jp" href="mailto:git@gitlab.com" rel="noopener ugc nofollow" target="_blank">git@gitlab.com</a>:shod ocan/Golang-blocking-channels-example . git来实现一个伟大的解决方案</p><blockquote class="jq jr js"><p id="fc2e" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">在本例中，我们将使用数据存储(来自Google控制台平台)，但是您可以使用任何支持光标的数据库。</p></blockquote><p id="9bd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要生成您的数据:<em class="jt"><br/>CD utils<br/>export PROJECT _ ID = { GOOGLE _ PROJECT _ ID }<br/>go运行utils.go </em></p><p id="28fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，检查目录<em class="jt">中没有阻塞通道的脚本。</em></p><p id="97a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查300个学生的3000个答案用了882秒。</p><p id="75c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在使用阻塞通道检查目录<em class="jt">。仅仅通过把它改成管道就把这个数字减少到了849。好的，还没什么大不了的，但是使用管道，我们可以对步骤进行巨大的修改，使代码变慢。</em></p><p id="ee4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查您的主要任务，并将其替换为:</p><figure class="jx jy jz ka fq kb"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="f585" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，现在您运行10个calcGrade和2个calcGrade。这些任务很慢，因为它们需要读取或写入数据库。然而，就因为这个改变，现在我们的脚本需要230秒来处理所有3000个答案。你可以更深入地检查每一步，看看是什么让你慢下来，让它变得更快。</p><p id="d81e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很好，对吧？现在，让我们了解一下所使用的go工具以及它们是如何工作的。</p><p id="8308" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">阻塞通道</strong>:我觉得是golang为并发任务提供的最有力的武器。Go blocking channels的工作原理是让你的任务以一种干净优雅的方式互相交流。这是唯一的单向通信，生产者被阻止发布更多的消息，直到消费者可以处理它。允许你不要浪费你的时间从数据库中读取数据，而任务什么过程可以保持读者的速度导致我们的软件消耗不必要的资源。</p><p id="2af9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:<br/>检查<em class="jt">成绩。开始。</em>检查答案是否正确后，我们累积成绩，以便更少地请求更新数据库中的学生成绩。</p><figure class="jx jy jz ka fq kb"><div class="bz el l di"><div class="kc kd l"/></div></figure><blockquote class="jq jr js"><p id="6407" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">当使用频道时，我们应该总是关闭频道，这样消费者可以知道它停止收听的时间。</p></blockquote><p id="423b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">阻塞通道缓冲区</strong>:有时你从数据库中读取数据包以减少请求。在这种情况下，如果我的生成器手头已经有一包数据，那么阻止它是没有意义的。我们可以使用缓冲区让他发布数据包，并在消费者使用实际数据之前开始获取新数据。</p><figure class="jx jy jz ka fq kb"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="c65b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">等待组</strong>:这是一个允许你运行多个异步任务并等待它们执行的工具。我用它来合并通道，确保只有当所有输入通道都关闭时，聚合通道才会关闭。这不是不可能做到的，但golang让它变得如此简单和优雅，以至于我真的不得不展示它。</p><figure class="jx jy jz ka fq kb"><div class="bz el l di"><div class="kc kd l"/></div></figure><p id="9992" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我甚至不需要谈论优点，例子清楚地表明了这一点。Golang让它变得更简单，让代码变得可理解、可测试和优雅。</p></div></div>    
</body>
</html>