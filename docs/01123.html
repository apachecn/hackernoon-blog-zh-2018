<html>
<head>
<title>Why should we aim for 100% code coverage?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们应该以100%的代码覆盖率为目标？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-should-we-aim-for-100-code-coverage-57ab2480c391?source=collection_archive---------21-----------------------#2018-02-03">https://medium.com/hackernoon/why-should-we-aim-for-100-code-coverage-57ab2480c391?source=collection_archive---------21-----------------------#2018-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="cdd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我从未从事过代码覆盖率为100%<a class="ae jp" href="https://hackernoon.com/tagged/code-coverage" rel="noopener ugc nofollow" target="_blank"/>的<a class="ae jp" href="https://hackernoon.com/tagged/project" rel="noopener ugc nofollow" target="_blank">项目</a>。我已经参与了几个高覆盖率的项目，并且测试套件给了团队信心。但是即使在那些项目中，有时我们在产品中会有一个讨厌的bug，这个bug可以通过一个简单的测试很容易地检测出来。</p><p id="7a8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个棘手的问题，通常开发人员不太关心这个问题，或者认为不值得花这个钱，或者甚至认为它没有那么有用。我在这里收集了一些支持全面保险的观点。</p><h1 id="cd39" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">什么不是100%的覆盖率</h1><p id="0007" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">绝对不是程序没有bug的说法。它只是一个数据点，表明所有行都被覆盖。如果我们有程序的某些部分没有被覆盖，我们确实知道如果某些东西改变了，我们将需要执行一些手动验证。我们也不会确信我们的改变不会破坏任何东西。</p><p id="bf68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，我们也可能对被覆盖的代码缺乏信心。我们可能会有大量的测试，并且害怕将某些东西投入生产。事实是，我们的测试只是覆盖了一组预定义的组合和用例。这可以通过<a class="ae jp" href="https://www.pivotaltracker.com/blog/generative-testing/" rel="noopener ugc nofollow" target="_blank">生成测试</a>来缓解，但是最终我们还是有可能错过一些东西。</p><h1 id="b7d7" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">那么我们有什么收获呢？</h1><p id="76ab" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们必须认识到，一个新的补丁不会破坏我们认为已经正确的场景。这个争论更多的是关于测试而不是全面覆盖。但是有了全保，你知道损坏已经在工作的东西的可能性就小了。</p><p id="f488" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请务必考虑到，有时代码会在没有人类干预的情况下被破解。想象一下一个复杂的合并以某种方式改变了一些逻辑。覆盖这些代码可以更好地保证我们没事。</p><p id="bf0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我在解决bug问题，并且我有一个异常的bug时，我总是试图改变代码中的一些行，运行测试套件，并检查测试是否有问题。当它出现的时候，那真是太好了。因为如果我已经有了那条线的测试，我知道几件事:</p><ul class=""><li id="cebc" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">我已经准备了一个带上下文的测试</li><li id="d2d1" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">我可以很容易地复制那个bug的环境/场景</li></ul><p id="6bdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我还没有一个测试<em class="lh">接近</em>那个问题，我可能会面临一个挑战，去构建产生这个问题的特定环境。这在使用第三方服务/组件或复杂代码的代码中很常见。创建测试环境非常困难，而我们忽略了这一点。</p><p id="23ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这些正是我们真正需要创建测试的场景。我们都接触过使用PayPal处理支付的代码，它很难测试并使用回调等。有虫子的时候呢？我们有麻烦了。</p><p id="c02e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果某样东西很难测试，它就很难维护。</p><p id="61b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">难以维持意味着生产力和信心的低下。根据我的经验，覆盖率高但不是100%的项目会遗漏以下内容:</p><ul class=""><li id="36b7" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">难以测试的复杂场景</li><li id="c31e" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">简单而基本的代码并不重要</li></ul><h1 id="1833" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">99%还不够吗？</h1><p id="2790" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">不，请考虑一下<a class="ae jp" href="https://en.wikipedia.org/wiki/Broken_windows_theory" rel="noopener ugc nofollow" target="_blank">破窗理论</a>。如果99%是好的，那98%不也是好的吗？特别是当我们刚刚得到一个测试起来很复杂的集成时。我们怎么知道那丢失的1%是不是无害的？回到上一个示例，缺失的覆盖范围将是:</p><ol class=""><li id="5022" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo li kz la lb dt translated">难以测试的代码，这是它应该被测试的主要原因</li><li id="1d81" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo li kz la lb dt translated">不那么重要的代码</li></ol><p id="6225" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据我的经验，代码<em class="lh">并不重要</em>实际上很容易测试。测试<em class="lh">只是因为</em>允许我们有最大的阈值。呆在那里。</p><h1 id="34d6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">改变代码意味着改变测试</h1><p id="0fe8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">但是如果我们涵盖了一切，这意味着每次我们需要改变代码时，我们也需要改变测试——如果你这么说的话……是的，这很麻烦。</p><p id="5cd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我要换一种说法:<strong class="it hv">从改变测试</strong>开始。为新的现实重构测试，看到失败测试的红色标记，然后才转到代码，为绿色标记工作。我相信这是最好的做法。但我也认为有时只是改变一行…而那行可能会影响几个测试。然而，我确实相信利大于弊。</p><h1 id="9c48" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">轻松检测不可及的代码</h1><p id="738e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">有了完全覆盖，我们将很容易检测出不再被使用的代码，因为这些代码将被标记为未被覆盖。让我们不要看一些方法，而要考虑重构一些没有使用的东西的含义。</p><p id="63f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有ide可以检测不可及的代码并警告开发人员。但是，即使有了这些工具，我也看到了存储库中不必要的代码。这可能是因为开发人员分心或者自动合并。</p><h1 id="8137" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">跟踪统计数据</h1><p id="da1e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">更多的测试意味着更慢的测试套件和更长的反馈循环来知道是否一切正常。我相信我们应该随着时间的推移跟踪测试套件的整体速度，并且应该支持纯单元测试。将逻辑拆分为纯函数和有副作用的函数在这里确实有所帮助。</p><p id="bfd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们有了这些统计数据，我们就可以了解每个开发人员每年在测试套件中增加了多少时间，并进行推断。我们可以看看我们现在的工作方式是否会让测试套件在一两年后变得更长。如果它令人担忧，我们可以立即开始改善我们的工作方式。</p><h1 id="4c49" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">代码示例</h1><p id="32c8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我收集了几个场景的代码示例，这些场景可能会让我们放弃完全覆盖。(<em class="lh">很抱歉提供了外部参考，在介质</em>上格式化这里的所有示例并不容易)。</p><h1 id="3b52" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">摘要</h1><p id="7254" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">拥有100%的cove覆盖率有很多好处，但这可能意味着更多的工作，并且会加重开发过程。我确实相信一个测试完全覆盖变化的补丁有更高的质量，我们应该以此为目标。这可能很难，我们可能需要学习新的工作方式，我们可能需要质疑自己的信念。</p><p id="7a1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我确信它会让我们成为更好的软件工匠。</p></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><p id="68bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lh">原载于2018年2月3日</em><a class="ae jp" href="https://engineering-management.space/post/100-percent-test-coverage/" rel="noopener ugc nofollow" target="_blank"><em class="lh">engineering-management . space</em></a><em class="lh">。</em></p><figure class="lq lr ls lt fq lu"><div class="bz el l di"><div class="lv lw l"/></div></figure></div></div>    
</body>
</html>