<html>
<head>
<title>Beginner Bites: A taste of Rust, a safe, concurrent and practical language!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者咬:铁锈的味道，一个安全，并发和实用的语言！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-taste-of-rust-6d8fc60e050?source=collection_archive---------1-----------------------#2018-02-04">https://medium.com/hackernoon/a-taste-of-rust-6d8fc60e050?source=collection_archive---------1-----------------------#2018-02-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/e92732265c7a3e7f07206e4a236b50ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzJ958Ph7aIXrNeATZRebQ.png"/></div></div></figure><div class=""/><p id="b85b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt ka translated">今天我们将体验铁锈的味道。我将提供链接，让你设置，然后你将解决Rust中的第一个项目欧拉问题。您将看到一些语法，并了解什么是宏。我希望向您展示这种语言是健壮的，易于使用的，并且速度快得令人眼花缭乱！它还拥有<a class="ae kj" href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig">无畏并发</strong> </a>，我们将在另一篇文章中讨论，但这是一个巨大的卖点。</p><p id="bc87" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会问为什么生锈？这真的取决于你是谁！大学用JavaScript和Python武装了我，让我从事基于网络的项目。最近，我需要更接近金属来实现更快的代码执行。Rust与上面提到的语言非常不同，因为它没有垃圾收集器，并且是静态类型的。如果您遇到问题，编译器错误消息通常足够大，可以表现得像一个专家对程序员，否则社区是欢迎的和有帮助的。</p><p id="3fe0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看这些在生产中使用铁锈的公司。</p><p id="0990" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我假设您熟悉在终端或命令提示符下执行命令，并且知道一些编程术语(比如什么是函数)。</p><p id="3f1c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">先说第一个<a class="ae kj" href="https://projecteuler.net/problem=1" rel="noopener ugc nofollow" target="_blank">项目欧拉问题</a>。问题要我们求所有1000以下的3或5的倍数之和。在我们解决这个问题之前，我们将设置并安装Rust。我们将创建一个项目，并讨论宏和函数之间的区别。您将看到如何编写单元测试以及生成漂亮的文档。最后，我们将使用一个循环来解决这个问题，然后在函数上使用一个迭代器。这将是一个爆炸🚀。</p><figure class="kk kl km kn fq hw"><div class="bz el l di"><div class="ko kp l"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">I also made this video which you may like!</figcaption></figure><h1 id="8d10" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">安装和设置Rust</h1><p id="cbf1" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">许多人非常努力地让安装过程变得很棒，所以我将指出那些资源。如果你已经安装了Rust并且喜欢你的设置，请随意跳过这一部分。不然咱们就锈了！</p><p id="7269" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kj" href="https://www.rustup.rs/" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig"> Rustup </strong> </a>是一个“用于系统编程Rust的工具链安装程序”。基本上，它为您处理一切，并会让您快速启动和运行。前往<a class="ae kj" href="https://www.rustup.rs/" rel="noopener ugc nofollow" target="_blank">https://www.rustup.rs/</a>并遵循您平台的说明。</p><p id="839f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rustup有一些漂亮的特性。您可以通过运行以下命令<code class="eh lx ly lz ma b">rustup component add rust-docs</code>来添加离线文档。要访问您的离线rust文档，请在您的终端或命令行中键入:<code class="eh lx ly lz ma b">rustup doc</code>。将打开一个浏览器，显示:</p><ul class=""><li id="ece8" class="mb mc if je b jf jg jj jk jn md jr me jv mf jz mg mh mi mj dt translated">生锈的书架</li><li id="2252" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">API文档</li><li id="4b7b" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">扩展错误文档(用于调查编译器错误)</li></ul><p id="1662" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rust书架棒极了，是所有Rust用户的好去处。这些资源的在线链接<a class="ae kj" href="https://www.rust-lang.org/en-US/documentation.html" rel="noopener ugc nofollow" target="_blank">这里</a>！当你在荒野中，在没有wifi的情况下写作Rust时，这些资源可以拯救你的生命🏕️.</p><p id="0ec2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kj" href="https://areweideyet.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig">我们(我)德了吗？</strong> </a> <strong class="je ig"> </strong>列出了代码编辑器对Rust的支持。截至发稿，<a class="ae kj" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>和<a class="ae kj" href="https://intellij-rust.github.io/" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA </a>支持度最好。VSCode是一个非常棒的免费选项，也是我所使用的。</p><p id="b070" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，也有其他职位，涵盖完整的设置。我推荐<a class="ae kj" href="http://www.shadercat.com/setting-up-a-rust-development-environment-on-windows-10/" rel="noopener ugc nofollow" target="_blank"> ShaderCat的岗位</a>或者<a class="ae kj" href="http://asquera.de/blog/2017-03-03/setting-up-a-rust-devenv/" rel="noopener ugc nofollow" target="_blank"> Asquera的岗位</a>。社区正在努力改善开发者体验，这些帖子可能会很快过时。搜索Rust Language Server (RLS)可能会提供更多关于设置IDE的最新说明。</p><p id="4894" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，你可以在记事本中编码…编译器是有帮助的，我尊重你的决定。</p><h2 id="c224" class="mp kv if bd kw mq mr ms la mt mu mv le jn mw mx li jr my mz lm jv na nb lq nc dt translated">货物</h2><blockquote class="nd ne nf"><p id="c026" class="jc jd ng je b jf jg jh ji jj jk jl jm nh jo jp jq ni js jt ju nj jw jx jy jz hn dt translated">"货物是锈包经理."~ <a class="ae kj" href="https://doc.rust-lang.org/cargo/" rel="noopener ugc nofollow" target="_blank">货书</a></p></blockquote><p id="16c4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Cargo之于Rust，就像NPM之于JavaScript，或者pip之于Python，或者RubyGems之于Ruby……差不多吧？</p><p id="0e3a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Cargo建立项目、安装依赖项、构建项目、运行测试、生成文档并将你的库上传到<a class="ae kj" href="https://crates.io/" rel="noopener ugc nofollow" target="_blank"> crates.io </a>。这是开始研究我们的项目欧拉问题的最佳时机。要检查安装的所有东西是否在您的终端上正确运行<code class="eh lx ly lz ma b">cargo version</code>:</p><figure class="kk kl km kn fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nk"><img src="../Images/cb00bab843102586322f0e02d0684bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bcEWNrLwGUDrwD6X44sPQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Your version number does not need to match.</figcaption></figure><p id="1f94" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用命令<code class="eh lx ly lz ma b">cargo new euler_sum --bin</code>为自己构建一个新项目。</p><figure class="kk kl km kn fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nl"><img src="../Images/ae47dc60f8ddb8deead863fc80a7d5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlg_ZMTMtrEYGyyrdE1QPw.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Use `cargo help` to learn more</figcaption></figure><p id="072c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该命令告诉货物在一个新的文件夹中设置一个名为“euler_sum”的新应用程序。默认情况下，货物创建一个库，所以我们使用<code class="eh lx ly lz ma b">--bin</code>告诉Rust创建一个应用程序(“bin”是二进制的缩写)。使用<code class="eh lx ly lz ma b">cd euler_sum</code>将您的目录更改为应用程序文件夹。这是您应该找到的:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="7893" class="mp kv if ma b fv nq nr l ns nt">.<br/>├── Cargo.toml<br/>└── src<br/>    └── main.rs</span><span id="5b06" class="mp kv if ma b fv nu nr l ns nt">1 directory, 2 files</span></pre><p id="0825" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">货物. toml文件是您的项目<em class="ng">清单</em>或元数据。如果你熟悉JavaScript，它类似于<code class="eh lx ly lz ma b">package.json</code>文件。您可以在这里列出您的依赖关系。更多信息请参见《货物手册》<a class="ae kj" href="https://doc.rust-lang.org/cargo/reference/manifest.html" rel="noopener ugc nofollow" target="_blank">中的</a>，您也可以通过<code class="eh lx ly lz ma b">cargo help</code>了解货物选项。</p><p id="0362" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">main.rs</code>包含一个微小的铁锈程序:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="48ab" class="mp kv if ma b fv nq nr l ns nt">fn main() {<br/>    println!("Hello, world!");<br/>}</span></pre><p id="b358" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用<code class="eh lx ly lz ma b">cargo run</code>运行代码(在带有货物. toml文件的文件夹中)。</p><figure class="kk kl km kn fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nv"><img src="../Images/330af0fa5219eabcde57108e15c8cdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*he2AOeCYb4n5n7EVcwZ66g.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek"><strong class="bd nw">STOP</strong> AND <strong class="bd nw">CELEBRATE</strong>! You’ve run your first Rust program!!!!🎉🎉🎉</figcaption></figure><p id="cdb3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">fn</code>是声明函数的方式。所有的应用项目都需要一个<code class="eh lx ly lz ma b">main</code>函数作为你程序的入口。这个函数没有参数，也不会返回任何东西。</p><p id="ea96" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">函数的主体包含这个词:<code class="eh lx ly lz ma b">println!</code>。这被称为宏。它看起来像一个函数，但它以<code class="eh lx ly lz ma b">!</code>结尾。Rust使用宏来做非常强大的事情，库经常使用它们来变得非常聪明。让我们快速了解它们与函数有何不同。</p><h2 id="24f4" class="mp kv if bd kw mq mr ms la mt mu mv le jn mw mx li jr my mz lm jv na nb lq nc dt translated">宏迂回</h2><p id="6686" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">宏允许您根据模式生成代码！如果您需要复制粘贴代码并做一些小的修改，您可以编写一个宏来为您编写代码。当您编译项目时，宏首先被展开(编写)，然后代码被编译，就像您编写了宏生成的内容一样。基本上，宏为您编写代码。让我们看看<code class="eh lx ly lz ma b">println!</code>宏是如何扩展的。运行以下命令:</p><p id="5004" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">$ rustc src/main.rs --pretty=expanded -Z unstable-options</code></p><p id="efbd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是我的输出:</p><figure class="kk kl km kn fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nx"><img src="../Images/87e37f87305b88b357ad3e5f51f6879d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciuZvFlBl1uhFwgrO9IvOQ.png"/></div></div></figure><blockquote class="ny"><p id="2e9d" class="nz oa if bd ob oc od oe of og oh jz ek translated">“宏为您编写代码”</p></blockquote><p id="0204" class="pw-post-body-paragraph jc jd if je b jf oi jh ji jj oj jl jm jn ok jp jq jr ol jt ju jv om jx jy jz hn dt translated">注意<code class="eh lx ly lz ma b">println!</code>已经聪明地生成了代码来打印“你好，世界！”去候机楼。因为宏能够模式匹配，不同的代码是基于不同的输入生成的！因此您也可以使用<code class="eh lx ly lz ma b">println!</code>来格式化字符串:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="2e3d" class="mp kv if ma b fv nq nr l ns nt">println!("Hello, {}!", "lovely humanoid");<br/>// prints -&gt; Hello, lovely humanoid!</span><span id="c7db" class="mp kv if ma b fv nu nr l ns nt">println!("Hello, {name}! Want {thing}?", name="Rust", thing="hugs");<br/>// -&gt; Hello, Rust! Want hugs?</span><span id="e6fe" class="mp kv if ma b fv nu nr l ns nt">println!("{num:&gt;0width$}", num=42, width=4);<br/>// -&gt; 0042</span></pre><p id="0bcb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">模式匹配的另一个好处是，如果你弄乱了宏的参数，编译器会出错。如果你写<code class="eh lx ly lz ma b">println!("{}");</code>，编译器会很有帮助的说出<code class="eh lx ly lz ma b">error: 1 positional argument in format string, but no arguments were given</code>以及一个很酷的图。你一定要试试。</p><h2 id="8c0e" class="mp kv if bd kw mq mr ms la mt mu mv le jn mw mx li jr my mz lm jv na nb lq nc dt translated">练习绕道🤔</h2><ul class=""><li id="5bb9" class="mb mc if je b jf ls jj lt jn on jr oo jv op jz mg mh mi mj dt translated">上面的<code class="eh lx ly lz ma b">println!</code>宏扩展到什么？答案可能会让你大吃一惊。代码比预期的多还是少？</li><li id="61c3" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">研究更多的字符串格式选项<a class="ae kj" href="https://rustbyexample.com/hello/print.html" rel="noopener ugc nofollow" target="_blank">这里</a> (Rust by Example)和<a class="ae kj" href="https://doc.rust-lang.org/std/fmt/" rel="noopener ugc nofollow" target="_blank">这里</a> (docs)。</li><li id="6b2f" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">猜一猜，然后找出下面的代码输出:</li></ul><p id="6fc3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">println!("{0} {1}'s {0} {1}, no matter how small!", "a", "person");</code></p><h2 id="ba00" class="mp kv if bd kw mq mr ms la mt mu mv le jn mw mx li jr my mz lm jv na nb lq nc dt translated">编写测试</h2><p id="72a4" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">因为我们都希望我们的代码是测试驱动的和类型驱动的，所以你显然渴望知道如何编写测试！这里我们需要的只是一个简单的单元测试。如果您正在编写一个库，您也可以编写doctests。</p><p id="1905" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个测试仅仅是一个用属性注释的函数。</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="9792" class="mp kv if ma b fv nq nr l ns nt">#[test]<br/>fn simple_test() {<br/>  assert_eq!(solution(10), 23);<br/>}</span></pre><p id="86cc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">#[test]</code>属性告诉Rust这是一个测试函数。因此，该功能在<code class="eh lx ly lz ma b">cargo test</code>运行时运行。如果两个参数不相等，就会出现恐慌，从而导致测试失败。您也可以使用只接受一个参数的<code class="eh lx ly lz ma b">assert!</code>，检查参数的值是否为<code class="eh lx ly lz ma b">true</code>。</p><p id="e7e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<code class="eh lx ly lz ma b">cargo test</code>运行测试。(它应该出错，因为我们还没有定义<code class="eh lx ly lz ma b">solution</code>函数。)如果你想看到测试通过，用<code class="eh lx ly lz ma b">assert!(true);</code>替换<code class="eh lx ly lz ma b">assert_eq!(solution(10), 23);</code>。</p><h2 id="0e7c" class="mp kv if bd kw mq mr ms la mt mu mv le jn mw mx li jr my mz lm jv na nb lq nc dt translated">生成文档</h2><p id="9415" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">是时候开始编码工程欧拉问题了。我们将在一个名为<code class="eh lx ly lz ma b">solution</code>的函数中编写解决方案。</p><p id="c416" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从<code class="eh lx ly lz ma b">solution</code>功能的<strong class="je ig"> <em class="ng">类型</em> </strong>开始:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="cc00" class="mp kv if ma b fv nq nr l ns nt">pub fn solution(max: u64) -&gt; u64 {<br/>  unimplemented!<br/>}</span></pre><p id="e676" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个<code class="eh lx ly lz ma b">pub</code> lic函数，它接受类型为<code class="eh lx ly lz ma b">u64</code>的参数<code class="eh lx ly lz ma b">max</code>并返回一个<code class="eh lx ly lz ma b">u64</code>。<code class="eh lx ly lz ma b">u64</code>是一种数值类型，称为无符号整数。这些整数适合64位，并且只能是正数。这立刻告诉我们，我们不能把负数传入这个函数，函数永远不会返回负数。</p><p id="f065" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只是为了好玩，让我们生成一些文档。</p><p id="841e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rust注释可以是行首的双斜线<code class="eh lx ly lz ma b">//</code>，也可以是<code class="eh lx ly lz ma b">/* multiline comment */</code>。这些不会生成文档。声明前的三斜线<code class="eh lx ly lz ma b">///</code>确实会生成文档:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="22ac" class="mp kv if ma b fv nq nr l ns nt">/// `solution` function solves the first Project Euler problem<br/>pub fn solution(max: u64) -&gt; u64 {<br/>  // A boring comment<br/>  unimplemented!()<br/>}</span></pre><p id="3a1d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您添加这个代码并运行cargo命令<code class="eh lx ly lz ma b">cargo doc --open</code>，您的浏览器将打开新生成的文档！文档支持markdown，这意味着您可以添加标题和链接。<a class="ae kj" href="https://doc.rust-lang.org/beta/rustdoc/what-is-rustdoc.html" rel="noopener ugc nofollow" target="_blank">在这里阅读更多关于文档生成的信息</a>！</p><h2 id="56a2" class="mp kv if bd kw mq mr ms la mt mu mv le jn mw mx li jr my mz lm jv na nb lq nc dt translated">问题的粗略解决方法</h2><p id="1950" class="pw-post-body-paragraph jc jd if je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">下面的代码对你来说应该有点熟悉。在继续读下去之前，试着理解正在发生的事情。我们将使它变得更简单，但这是一个很好的起点。</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="0e2b" class="mp kv if ma b fv nq nr l ns nt">pub fn solution(max: u64) -&gt; u64 {<br/>  let mut result = 0;<br/>  let mut i = 0;<br/>  loop {<br/>    if i &gt;= max {<br/>      break;<br/>    }<br/>    if i % 3 == 0 || i % 5 == 0 {<br/>      result += i;<br/>    }<br/>    i += 1;<br/>  }<br/>  return result;<br/>}</span></pre><p id="7eb8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了<code class="eh lx ly lz ma b">mut</code>之外，大部分内容应该是不言自明的。<code class="eh lx ly lz ma b">mut</code>是告诉Rust什么时候变量应该是可变的一种方式。这里我们说<code class="eh lx ly lz ma b">result</code>和<code class="eh lx ly lz ma b">i</code>需要可变。如果没有<code class="eh lx ly lz ma b">mut</code>，当试图执行<code class="eh lx ly lz ma b">result += i</code>或<code class="eh lx ly lz ma b">i += 1</code>时，我们会得到一个错误。删除<code class="eh lx ly lz ma b">mut</code>并亲自查看错误。在Rust中，变量默认是不可变的，除非是显式可变的。Rust函数还必须显式声明它们是否会变异传入的参数。函数行为在类型签名中是显式的。</p><p id="4809" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有很多东西我们可以清理。首先，命令式代码非常冗长。不使用<code class="eh lx ly lz ma b">loop</code>和<code class="eh lx ly lz ma b">break</code>，我们可以在<a class="ae kj" href="https://doc.rust-lang.org/std/ops/struct.Range.html" rel="noopener ugc nofollow" target="_blank">范围</a>内使用<code class="eh lx ly lz ma b">for</code>循环，如下所示:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="4674" class="mp kv if ma b fv nq nr l ns nt">pub fn solution(max: u64) -&gt; u64 {<br/>  let mut result = 0;<br/>  for i in 0..max {<br/>    if i % 3 == 0 || i % 5 == 0 {<br/>      result += i;<br/>    }<br/>  }<br/>  return result;<br/>}</span></pre><p id="5fb8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们不再需要管理变量<code class="eh lx ly lz ma b">i</code>。<code class="eh lx ly lz ma b">0..max</code>是范围，<code class="eh lx ly lz ma b">for</code>循环在范围内迭代。一个<code class="eh lx ly lz ma b">for</code>循环可以迭代任何实现<code class="eh lx ly lz ma b">Iterator</code>特征的类型。我们不会在这里讨论特征，但是现在把它看作一个接口(尽管它有更多的含义)。因为范围实现了迭代器，所以您可以使用类似于<code class="eh lx ly lz ma b">map</code>、<code class="eh lx ly lz ma b">filter</code>和<code class="eh lx ly lz ma b">fold</code>的迭代器方法。</p><p id="97ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Filter允许您基于谓词或返回布尔值的函数来过滤元素。因此，我们可以将<code class="eh lx ly lz ma b">if</code>条件移到一个过滤器中，以便只获得我们想要的<code class="eh lx ly lz ma b">i</code>值:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="4cdc" class="mp kv if ma b fv nq nr l ns nt">pub fn solution(max: u64) -&gt; u64 {<br/>  let mut result = 0;<br/>  for i in (0..max).filter(|n| n % 3 == 0 || n % 5 == 0) {<br/>    result += i;<br/>  }<br/>  return result;<br/>}</span></pre><p id="28ad" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个搞笑的语法是什么？</p><p id="98f2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">|n| n % 3 == 0 || n % 5 == 0</code></p><p id="d3e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个终结。这是一个匿名函数，可以传递给另一个函数。<code class="eh lx ly lz ma b">|n|</code>为自变量/s，其余为函数体。同样精确的闭包也可以这样写(用一个显式函数体和<code class="eh lx ly lz ma b">return</code>语句):</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="6f4b" class="mp kv if ma b fv nq nr l ns nt">|n| {<br/>  return n % 3 == 0 || n % 5 == 0;<br/>}</span></pre><p id="c910" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Rust中，如果你的<code class="eh lx ly lz ma b">return</code>语句在一个函数的最后一行，你可以省略<code class="eh lx ly lz ma b">return</code>和分号来隐式返回。使用这个技巧，我们可以从函数中删除<code class="eh lx ly lz ma b">return</code>:</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="87a4" class="mp kv if ma b fv nq nr l ns nt">pub fn solution(max: u64) -&gt; u64 {<br/>  let mut result = 0;<br/>  for i in (0..max).filter(|n| n % 3 == 0 || n % 5 == 0) {<br/>    result += i;<br/>  }<br/>  // Implicit return below:<br/>  result<br/>}</span></pre><p id="5c19" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有一件烦人的事。我们有一个可变的<code class="eh lx ly lz ma b">result</code>变量。在一个更大的程序中，这个变量可能会在其他地方意外变异，需要单独管理。对迭代器中的值求和不需要另一个变量，可以使用迭代器方法来完成！您可以使用<code class="eh lx ly lz ma b">fold</code>或<code class="eh lx ly lz ma b">sum</code>方法。</p><pre class="kk kl km kn fq nm ma nn no aw np dt"><span id="7c45" class="mp kv if ma b fv nq nr l ns nt">pub fn solution(max: u64) -&gt; u64 {<br/>  (0..max).filter(|n| n % 3 == 0 || n % 5 == 0).sum()<br/>}</span></pre><p id="97c4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里阅读更多关于迭代器的内容！有许多迭代器方法，它们有时可以单独用来解决问题。我们也可以很容易地用一个库，如<a class="ae kj" href="https://github.com/rayon-rs/rayon" rel="noopener ugc nofollow" target="_blank"> Rayon </a>引入fork-join并行。</p><p id="240f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从<code class="eh lx ly lz ma b">main</code>函数调用您的新<code class="eh lx ly lz ma b">solution</code>函数，并打印出您的答案。用<code class="eh lx ly lz ma b">cargo run</code>运行程序。</p><p id="0788" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">🎈祝贺您完成Rust中的第一个项目欧拉问题🎈。我希望你喜欢这次旋风之旅！在未来，我希望更深入地研究特征(尤其是迭代器特征)、宏、并发和函数式编程。也许我已经说服你继续探索这种思维扩展语言。为什么不继续用Rust中的<a class="ae kj" rel="noopener" href="/@spyr1014/sorting-in-rust-selection-insertion-and-counting-sort-2c4d3575e364">简单排序算法对Rust进行采样？</a></p><p id="667c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这个帖子，请用👏！我喜欢反馈，请在Twitter上给我留言或留言。我也喜欢想法，所以如果你希望Rust上有一篇博文，我很乐意为你写。</p><p id="671f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在推特上关注我:<a class="ae kj" href="https://twitter.com/spyr1014" rel="noopener ugc nofollow" target="_blank"> @spyr1014 </a></p><p id="d045" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢您的阅读！❤</p><h1 id="2853" class="ku kv if bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">参考</h1><ul class=""><li id="6461" class="mb mc if je b jf ls jj lt jn on jr oo jv op jz mg mh mi mj dt translated">无畏并发-<a class="ae kj" href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" rel="noopener ugc nofollow" target="_blank">https://blog . rust-lang . org/2015/04/10/Fearless-Concurrency . html</a></li><li id="3a79" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">https://www.rustup.rs/<a class="ae kj" href="https://www.rustup.rs/" rel="noopener ugc nofollow" target="_blank"/></li><li id="a41a" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">vs code-【https://code.visualstudio.com/ T4】</li><li id="8b79" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">我们结束了吗？-<a class="ae kj" href="https://areweideyet.com/" rel="noopener ugc nofollow" target="_blank">https://areweideyet.com/</a></li><li id="d08c" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">IntelliJ IDEA-<a class="ae kj" href="https://intellij-rust.github.io/" rel="noopener ugc nofollow" target="_blank">https://intellij-rust.github.io/</a></li><li id="1651" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">Rust文档链接-<a class="ae kj" href="https://www.rust-lang.org/en-US/documentation.html" rel="noopener ugc nofollow" target="_blank">https://www.rust-lang.org/en-US/documentation.html</a></li><li id="da8b" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">rustdoc—<a class="ae kj" href="https://doc.rust-lang.org/beta/rustdoc/what-is-rustdoc.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/beta/rustdoc/what-is-rustdoc.html</a></li><li id="29bc" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">货物手册(Cargo . toml)-<a class="ae kj" href="https://doc.rust-lang.org/cargo/reference/manifest.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/cargo/reference/manifest.html</a></li><li id="b403" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">迭代器:<a class="ae kj" href="https://doc.rust-lang.org/std/iter/index.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/std/iter/index.html</a></li></ul></div></div>    
</body>
</html>