<html>
<head>
<title>Working with the Docker build cache to autoscale our Jenkins nodes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker构建缓存自动扩展我们的Jenkins节点</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/working-with-the-docker-build-cache-to-autoscale-our-jenkins-nodes-37b63a3dd2a?source=collection_archive---------4-----------------------#2018-02-04">https://medium.com/hackernoon/working-with-the-docker-build-cache-to-autoscale-our-jenkins-nodes-37b63a3dd2a?source=collection_archive---------4-----------------------#2018-02-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4cd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个相当标准的<a class="ae jp" href="https://hackernoon.com/tagged/jenkins" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>设置，一个主节点和一大堆辅助节点，大部分工作步骤都外包出去了。</p><p id="ca8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些辅助节点整晚无所事事，因此我们认为最好在晚上缩减它们，然后在早上备份，这样我们就可以用节省下来的资金在白天需要时运行更多辅助节点。</p><p id="ab08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在我们的詹金斯基础设施上运行各种工作，但最常见的工作是在每次推进PR和合并到master时构建和测试我们的monolith。</p><p id="0052" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这基本上包括对分支进行git签出(签入主节点上的现有工作区，这样我们就不必进行完整的初始签出)，构建一个<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>映像，其中包含所有的依赖项和运行作业时的代码库版本，然后在结果容器中运行测试(在任何一个辅助节点上，这样我们就可以并行运行大量作业，文件使用Jenkins stashes在节点之间传输)。</p><p id="2126" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从头构建这个Docker映像大约需要10分钟，我们依靠这些节点上的Docker映像缓存来减少构建时间，方法是将通常使缓存无效的步骤(复制更新的代码库)放在Docker文件的末尾。</p><p id="b077" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">docker文件看起来像这样:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="91e4" class="jz ka hu jv b fv kb kc l kd ke">FROM ubuntu:14.04</span><span id="22cf" class="jz ka hu jv b fv kf kc l kd ke"># Things like apt-get installs, these take a decent amount of time<br/>&lt;some bash commands&gt;</span><span id="0689" class="jz ka hu jv b fv kf kc l kd ke"># These live in our main codebase along side the code and basically never change<br/>&lt;copy in some config files&gt;</span><span id="7acd" class="jz ka hu jv b fv kf kc l kd ke"># There's a fair few of these, they take a while but rarely change<br/>&lt;copy some requirements.txt files&gt;<br/>&lt;some pip installs&gt;</span><span id="1ab9" class="jz ka hu jv b fv kf kc l kd ke"># This is where we expect the cache to be invalidated and copy'ing in the files doesn't take long<br/>&lt;copy in the version of the codebase that's being built&gt;</span></pre><p id="f645" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果我们希望自动扩展辅助节点，我们需要确保它们在作业开始运行之前拥有映像缓存。</p><p id="1e91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一种尝试是在节点启动时，从我们的注册表中的Cloudformation userdata中下载一份映像副本。</p><p id="688d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这失败了，因为Docker不会使用从注册表中提取的图像作为构建缓存的一部分。</p><p id="a3c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这被认为是https://github.com/moby/moby/issues/20316的一个特点<a class="ae jp" href="https://github.com/moby/moby/issues/20316" rel="noopener ugc nofollow" target="_blank"/></p><p id="014d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二次尝试是用将我们的存储库克隆到<code class="eh kg kh ki jv b">/tmp</code>中来代替提取Docker映像，然后在节点第一次出现时从该版本的代码库构建Docker映像。这将为我们提供来自代码库最新版本的Docker映像副本，以及我们加速后续构建所需的构建缓存。</p><p id="077d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这失败了，在Jenkins作业的第一次运行期间，当我们复制配置文件时，缓存在第一个<code class="eh kg kh ki jv b">COPY</code>步骤中无效，即使它们的内容没有改变。</p><p id="f082" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这有点令人困惑，因为我认为Docker只在文件已经更改的情况下才在第<code class="eh kg kh ki jv b">COPY</code>行使缓存无效，而实际上并没有。一些调查显示，Docker在考虑文件是否被更改时也使用文件的<code class="eh kg kh ki jv b">mtime</code>值。</p><p id="7b69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/moby/moby/issues/4351#issuecomment-76222745" rel="noopener ugc nofollow" target="_blank">https://github . com/Moby/Moby/issues/4351 # issue comment-76222745</a></p><p id="2dad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，发生的情况是，在Jenkins作业中，git签出代码库创建的文件与我们在节点创建时签出代码库到<code class="eh kg kh ki jv b">/tmp</code>中的文件具有不同的<code class="eh kg kh ki jv b">mtimes</code>，因此Docker认为我们在早期复制的配置文件被更改，并在我们希望的时间之前使缓存失效。</p><p id="c1b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们以前没有看到这个问题，因为我们在主节点上将作业的git签出部分签入到从不删除的工作区中，所以在初始签出后，这些文件从未被触及，Docker也从未认为早期的<code class="eh kg kh ki jv b">COPY</code>步骤已经失效。</p><p id="5029" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以用一个简单的例子来复制这种行为:</p><p id="451b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个包含两个文件的项目，一个Dockerfile文件和一个文本文件</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="7083" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ ls<br/>Dockerfile  test</span></pre><p id="a767" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">docker文件只是复制到我们的文件中</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="a7e5" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ cat Dockerfile<br/>from ubuntu:16.04<br/>COPY test /srv/test</span></pre><p id="939b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们记下测试文件的<code class="eh kg kh ki jv b">mtime</code>，以便稍后使用</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="49f7" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ stat test<br/>  File: ‘test’<br/>  Size: 0          Blocks: 0          IO Block: 4096   regular empty file<br/>Device: 801h/2049d Inode: 140134      Links: 1<br/>Access: (0664/-rw-rw-r--)  Uid: ( 1000/ vagrant)   Gid: ( 1000/ vagrant)<br/>Access: 2017-12-31 18:03:33.995881878 +0000<br/>Modify: 2017-12-31 18:03:33.995881878 +0000<br/>Change: 2017-12-31 18:03:33.995881878 +0000<br/> Birth: -</span></pre><p id="ee69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，如果我们建造它</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="c57d" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ sudo docker build .<br/>Sending build context to Docker daemon 13.82 kB<br/>Sending build context to Docker daemon<br/>Step 0 : FROM ubuntu:16.04<br/>16.04: Pulling from ubuntu<br/>Step 1 : COPY test /srv/test<br/> ---&gt; 3be8d8c094bf</span></pre><p id="2cdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们没有缓存这个步骤，所以Docker只是运行它。</p><p id="ca38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们修改测试</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8275" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ echo 'hello' &gt; test<br/>vagrant@vagrant-ubuntu-trusty-64:~$ sudo docker build .<br/>Sending build context to Docker daemon 14.34 kB<br/>Sending build context to Docker daemon<br/>Step 0 : FROM ubuntu:16.04<br/> ---&gt; c1ea3b5d13dd<br/>Step 1 : COPY test /srv/test<br/> ---&gt; 75bb69e528c3<br/>Removing intermediate container 6771d1e1f191<br/>Successfully built 75bb69e528c3</span></pre><p id="4eda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker获得更改并使缓存层失效，这并不奇怪。</p><p id="33b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果<code class="eh kg kh ki jv b">test</code>来自git回购呢？</p><p id="ca1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将这两个文件捆绑到一个git repo中，将它们向上推，然后将repo下拉到一个单独的文件夹中</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8507" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ mkdir git<br/>vagrant@vagrant-ubuntu-trusty-64:~$ cd git/<br/>vagrant@vagrant-ubuntu-trusty-64:~/git$ git pull <a class="ae jp" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:AaronKalair/test.git</span></pre><p id="3751" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker使用我们用早期的<code class="eh kg kh ki jv b">docker build</code>为文件创建的缓存吗？</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="bc2b" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~/git/test$ sudo docker build .<br/>Sending build context to Docker daemon 47.62 kB<br/>Sending build context to Docker daemon<br/>Step 0 : FROM ubuntu:16.04<br/> ---&gt; c1ea3b5d13dd<br/>Step 1 : COPY test /srv/test<br/> ---&gt; f4fe0a287838<br/>Removing intermediate container 20c77a3dee81<br/>Successfully built f4fe0a287838</span></pre><p id="88cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没有。</p><p id="108a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">文件是一样的吗？</p><p id="9972" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">git克隆的那个</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="404d" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~/git/test$ md5sum test<br/>a10edbbb8f28f8e98ee6b649ea2556f4  test</span></pre><p id="33f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原文</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="6a52" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ md5sum test<br/>a10edbbb8f28f8e98ee6b649ea2556f4  test</span></pre><p id="664d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是的，一模一样。</p><p id="74ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那<code class="eh kg kh ki jv b">mtime</code>呢？</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ccf0" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~/git/test$ stat test<br/>  File: ‘test’<br/>  Size: 7          Blocks: 8          IO Block: 4096   regular file<br/>Device: 801h/2049d Inode: 262341      Links: 1<br/>Access: (0775/-rwxrwxr-x)  Uid: ( 1000/ vagrant)   Gid: ( 1000/ vagrant)<br/>Access: 2017-12-31 19:37:05.348272796 +0000<br/>Modify: 2017-12-31 19:37:05.348272796 +0000<br/>Change: 2017-12-31 19:37:05.348272796 +0000<br/> Birth: -</span></pre><p id="77ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不，它改变了(最初是<code class="eh kg kh ki jv b">18:03</code>)，git pull将修改、访问和更改时间设置为克隆的时间。</p><p id="a894" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">git拉取会影响现有的文件吗？</p><p id="4641" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们将另一个文件添加到项目中，将它向上推…</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="5b26" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ touch test_test<br/>vagrant@vagrant-ubuntu-trusty-64:~$ git add test_test<br/>vagrant@vagrant-ubuntu-trusty-64:~$ git commit<br/>vagrant@vagrant-ubuntu-trusty-64:~$ git push origin master</span></pre><p id="f417" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后把它拉回到另一个git收银台…</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="0304" class="jz ka hu jv b fv kb kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~$ cd git/test/<br/>vagrant@vagrant-ubuntu-trusty-64:~/git/test$ git pull</span><span id="7c2f" class="jz ka hu jv b fv kf kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~/git/test$ stat test<br/>  File: ‘test’<br/>  Size: 7          Blocks: 8          IO Block: 4096   regular file<br/>Device: 801h/2049d Inode: 262341      Links: 1<br/>Access: (0775/-rwxrwxr-x)  Uid: ( 1000/ vagrant)   Gid: ( 1000/ vagrant)<br/>Access: 2017-12-31 19:40:05.032278718 +0000<br/>Modify: 2017-12-31 19:37:05.348272796 +0000<br/>Change: 2017-12-31 19:37:05.348272796 +0000<br/> Birth: -</span><span id="c3a5" class="jz ka hu jv b fv kf kc l kd ke">vagrant@vagrant-ubuntu-trusty-64:~/git/test$ stat test_test<br/>  File: ‘test_test’<br/>  Size: 0          Blocks: 0          IO Block: 4096   regular empty file<br/>Device: 801h/2049d Inode: 262359      Links: 1<br/>Access: (0664/-rw-rw-r--)  Uid: ( 1000/ vagrant)   Gid: ( 1000/ vagrant)<br/>Access: 2017-12-31 20:36:22.916378925 +0000<br/>Modify: 2017-12-31 20:36:22.916378925 +0000<br/>Change: 2017-12-31 20:36:22.916378925 +0000<br/> Birth: -</span></pre><p id="f32f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现有的测试文件保持不变，新文件出现，所有时间戳都设置为<code class="eh kg kh ki jv b">git pull</code>的时间</p><p id="ec8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，这解释了我们看到的行为，以及为什么我们以前从未遇到过这个问题，但如果不解决缓存问题，我们仍然无法自动扩展我们的辅助Jenkins节点。</p><p id="49f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，成功的第三次尝试是:</p><p id="8893" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在主docker文件的开头创建一个我们在<code class="eh kg kh ki jv b">FROM</code>中使用的基本映像，该文件已经运行了昂贵的步骤，并在节点启动时将其下载到节点。</p><p id="a7ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将有效地复制构建缓存中的昂贵步骤。</p><p id="5679" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们有一个从docker文件开始的每夜构建，如下所示:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="163d" class="jz ka hu jv b fv kb kc l kd ke"># NIGHTLY IMAGE</span><span id="06bd" class="jz ka hu jv b fv kf kc l kd ke">FROM ubuntu:14.04</span><span id="6e4f" class="jz ka hu jv b fv kf kc l kd ke">&lt;some bash commands&gt;<br/>&lt;copy in some config files&gt;<br/>&lt;copy some requirements.txt files&gt;<br/>&lt;some pip installs&gt;</span></pre><p id="aab9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的Jenkins作业现在使用一个docker文件，看起来像:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="0dd2" class="jz ka hu jv b fv kb kc l kd ke">FROM NIGHTLY_IMAGE</span><span id="6796" class="jz ka hu jv b fv kf kc l kd ke">&lt;copy in some config files&gt;<br/>&lt;copy some requirements.txt files&gt;<br/>&lt;some pip installs&gt;<br/>&lt;copy in the version of the codebase that's being built&gt;</span></pre><p id="dad4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们想要缓存的所有昂贵的命令(初始bash命令和pip安装)都在夜间映像中，当它被创建时，我们将它拉至一个实例，Jenkins在<code class="eh kg kh ki jv b">FROM</code>行中使用它。</p><p id="f948" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Jenkins在工作中使用的Dockerfile中重复的<code class="eh kg kh ki jv b">pip installs</code>确保了如果在下一个每夜构建之前需求发生了变化，这些变化会反映在构建的映像中。</p><p id="f2b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果每夜映像构建使用不同<code class="eh kg kh ki jv b">mtimes</code>的文件版本，那么作为已经有需求的<code class="eh kg kh ki jv b">pip install</code>也没关系，只需要几秒钟。</p><p id="9581" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每夜映像是在每天凌晨2点作为Jenkins作业构建的，cron作业是助手，自动缩放操作确保他们每天都有最新的每夜映像。</p><p id="ac66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了它，我们现在花更少的钱，在需要的时候有更多的Jenkins容量！</p><p id="1dc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在推特上关注我<a class="ae jp" href="http://twitter.com/AaronKalair" rel="noopener ugc nofollow" target="_blank"> @AaronKalair </a></p><figure class="jq jr js jt fq kj"><div class="bz el l di"><div class="kk kl l"/></div></figure></div></div>    
</body>
</html>