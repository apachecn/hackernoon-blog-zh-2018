<html>
<head>
<title>Clojure Macros — Lessons from unspoken symbols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure宏——未言符号的教训</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/clojure-macros-lessons-from-unspoken-symbols-c4945d8ed8bf?source=collection_archive---------7-----------------------#2018-02-04">https://medium.com/hackernoon/clojure-macros-lessons-from-unspoken-symbols-c4945d8ed8bf?source=collection_archive---------7-----------------------#2018-02-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="badf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="jp jq gr" href="https://medium.com/u/5b9405a30408?source=post_page-----c4945d8ed8bf--------------------------------" rel="noopener" target="_blank"> Swym </a>，我们使用<a class="ae jr" href="https://hackernoon.com/tagged/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure </a>做很多事情。不变的是，我们最终会遇到宏被认为是必要的用例。在这篇文章中，我试着总结我一路上学到的经验(阅读错误)。</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff js"><img src="../Images/95dbf205302fa548980e6df3658a5139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oP4TK_TMR85wbfPL.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Source — <a class="ae jr" href="https://www.videoblocks.com/video/hacker-text-terminal-fake-data-scroll-computer-terminal-display-computing-random-text-generations-scrolling-down-the-page-vxglayqceimdkqwzw" rel="noopener ugc nofollow" target="_blank">https://www.videoblocks.com/video/hacker-text-terminal-fake-data-scroll-computer-terminal-display-computing-random-text-generations-scrolling-down-the-page-vxglayqceimdkqwzw</a></figcaption></figure><p id="675e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我首先使用宏<code class="eh ki kj kk kl b"><em class="km">defmacro</em></code>创建了一个简单的宏。</p><p id="fbd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意——代码输出被注释掉，因此任何人都可以毫无问题地复制粘贴到repl，但是语法高亮显示并不显示它被注释掉。</p><h2 id="d806" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">不是真正的宏</h2><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="369f" class="kn ko hu kl b fv lm ln l lo lp">(defmacro not-really-macro [a] (do (println a) a))<br/>;#'user/not-really-macro<br/><br/>(macroexpand `(not-really-macro "test"))<br/>;test<br/>;"test"<br/><br/>(not-really-macro "test")<br/>;test<br/>;"test"</span></pre><p id="06bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ki kj kk kl b"><em class="km">not-really-macro</em></code>只是一个println代码，只要你调用它就会执行。所以不是真正的宏观。继续前进</p><p id="7f6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第0课——不是所有用</strong> <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">defmacro</em></strong></code> <strong class="it hv">定义的都可以称为宏。</strong></p><h2 id="2ff3" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">也许是一个宏</h2><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="8ec3" class="kn ko hu kl b fv lm ln l lo lp">;; without list, using syntax quoting<br/>(defmacro wrong-macro [a] `(do (println a) a))<br/><br/>(macroexpand `(wrong-macro "test"))<br/>;(do (clojure.core/println user/a) user/a)<br/><br/>(wrong-macro "test")<br/>;CompilerException java.lang.RuntimeException: No such var: user/a, ...</span></pre><p id="ff02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果成功的话可能是个宏。错误很明显，在<em class="km">用户</em>名称空间中没有定义<em class="km"> a </em>。这很奇怪，因为我认为它来自宏的输入参数，对吗？嗯，如果我转换名称空间并尝试扩展会怎么样</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="3688" class="kn ko hu kl b fv lm ln l lo lp">(ns outerspace)<br/>;nil<br/>;in outerspace now<br/><br/>(macroexpand `(user/wrong-macro "test"))<br/>;(do (clojure.core/println user/a) user/a)</span></pre><p id="52f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很有趣。<code class="eh ki kj kk kl b"><em class="km">a</em></code>的命名空间没变。所以宏展开并没有获得传递的参数。</p><h2 id="b6ed" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">进入未引用状态—变量捕获</h2><p id="372b" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">由于我<em class="km">引用了</em>代码，我需要<code class="eh ki kj kk kl b"><em class="km">unquote</em></code>来访问<code class="eh ki kj kk kl b"><em class="km">quote</em></code>外的<a class="ae jr" href="https://hackernoon.com/tagged/symbols" rel="noopener ugc nofollow" target="_blank">符号</a>。</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="66c5" class="kn ko hu kl b fv lm ln l lo lp">(in-ns 'user)<br/>(defmacro ok-macro [a] `(do (println ~a) ~a))<br/>;#'user/ok-macro<br/><br/>(macroexpand `(ok-macro "test"))<br/>;(do (clojure.core/println "test") "test")<br/><br/>(ok-macro "test")<br/>;"test"<br/>;test</span></pre><p id="2338" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一双<strong class="it hv">呜呜</strong>！瞬间，无论是宏观扩张还是实际产出都是正确的。</p><p id="7929" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第1课—在<em class="km">引用</em>代码时，使用<em class="km">取消引用</em>访问外部引用。</strong></p><h2 id="3d67" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">更多的不引用——比喻性的和“字面上的”</h2><p id="4526" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">于是，就有了clojure函数<code class="eh ki kj kk kl b"><em class="km">quote</em></code>、<code class="eh ki kj kk kl b"><em class="km">unquote</em></code>和<code class="eh ki kj kk kl b"><em class="km">unquote-splicing</em></code>。试图在宏中使用它们，</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="ffe0" class="kn ko hu kl b fv lm ln l lo lp">(defmacro forcequote-macro [a] (quote (do (println ~a) ~a)))<br/>;#'user/forcequote-macro<br/><br/>(macroexpand `(forcequote-macro "test"))<br/>;(do (println (clojure.core/unquote a)) (clojure.core/unquote a))<br/><br/>(forcequote-macro "test")<br/>;CompilerException java.lang.RuntimeException: Unable to resolve symbol: a in this context...</span></pre><p id="e0be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">啊？为什么不呢？</p><p id="719d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第二课——“不是<em class="km">引用</em>的字面捷径。</strong></p><p id="2edf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了证实第二课是真的，</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="d346" class="kn ko hu kl b fv lm ln l lo lp">(= 'a (quote a))<br/>;true<br/><br/>(= `a (quote a))<br/>;false</span></pre><p id="098e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">成功！算是吧。</p><p id="309f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第3课—‘是<em class="km">引用</em>的文字捷径。</strong></p><p id="f69c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，为<code class="eh ki kj kk kl b"><em class="km">unquote</em></code>做同样的事情。</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="7319" class="kn ko hu kl b fv lm ln l lo lp">(defmacro forceunquote-macro [a] `(do (println (unquote a)) (unquote a)))<br/>;#'user/forceunquote-macro<br/><br/>(macroexpand `(forceunquote-macro "test"))<br/>;(do (clojure.core/println (clojure.core/unquote user/a)) (clojure.core/unquote user/a))<br/><br/>(forceunquote-macro "test")<br/>;CompilerException java.lang.RuntimeException: No such var: user/a, compiling...</span></pre><p id="73a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，这种“疯狂”似乎有一种模式(或者我这么称呼它)。</p><p id="9784" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第4课— ~不是<em class="km">的字面捷径。</em></p><p id="eb9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，当引用调用时，取消引用和引用不起作用，这意味着识别宏中使用的符号已经太晚了。必须使用文字，这是毫无疑问的。</p><h2 id="ef85" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">符号生成</h2><p id="c4dc" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">如果问题出在符号上，为什么不在宏中按需生成一个符号并引用它呢？开始了</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="0a56" class="kn ko hu kl b fv lm ln l lo lp">;; gensym<br/>(defmacro sym-gen-macro [a]<br/>  (let [dyn-a (gensym a)]<br/>    `(let [~dyn-a ~a]<br/>       (println ~dyn-a)<br/>       ~dyn-a)))<br/>;#'user/sym-gen-macro<br/><br/>(macroexpand `(sym-gen-macro "test"))<br/>;(let* [test1663 "test"] (clojure.core/println test1663) test1663)<br/><br/>(sym-gen-macro "test")<br/>;test<br/>;"test"</span></pre><p id="669a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了营救，宏起作用了！但这似乎不对。这是可行的，但代价是什么。每次调用宏时，都会创建一个新的符号，并且引用被更新为<em class="km"> let </em>中的<em class="km"> a </em>。所以不，绝对不是。</p><p id="3342" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第五课— </strong> <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">gensym</em></strong></code> <strong class="it hv">无法解决你的不引用问题。</strong></p><h2 id="0ca4" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">使用源</h2><p id="192e" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">在确认无法摆脱这些神秘的文字之后，我们转向了拼接。在使用整个要传递的参数时非常强大</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="cb70" class="kn ko hu kl b fv lm ln l lo lp">(defmacro expand-body [&amp; body]<br/>   `(println ~@body))<br/>;#'user/expand-body<br/><br/>(macroexpand `(expand-body "test1" "test2"))<br/>;(clojure.core/println "test1" "test2")<br/><br/>(expand-body "test1" "test2")<br/>;test1 test2<br/>;nil</span></pre><p id="7956" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">工作得很好，现在找到窍门了。现在我尝试使用这里给出的定义<a class="ae jr" href="https://clojuredocs.org/clojure.core/unquote-splicing" rel="noopener ugc nofollow" target="_blank"/>。如果没有文字，它不会像预期的那样工作，但我会感到一种粗鲁但有趣的震惊。</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="a063" class="kn ko hu kl b fv lm ln l lo lp">(source unquote)<br/>;(def unquote)<br/>;nil<br/><br/>(source unquote-splicing)<br/>;(def unquote-splicing)<br/>;nil<br/><br/>(source macroexpand))<br/>;(defn macroexpand<br/>;  "Repeatedly calls macroexpand-1 on form until it no longer<br/>;  represents a macro form, then returns it.  Note neither<br/>;  macroexpand-1 nor macroexpand expand macros in subforms."<br/>;  {:added "1.0"<br/>;   :static true}<br/>;  [form]<br/>;    (let [ex (macroexpand-1 form)]<br/>;      (if (identical? ex form)<br/>;        form<br/>;        (macroexpand ex))))<br/>;nil<br/><br/>(source quote)<br/>;Source not found<br/>;nil</span></pre><p id="e8f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如你所见，<em class="km">不引用</em>和<em class="km">不引用拼接</em>是<code class="eh ki kj kk kl b"><em class="km">def</em></code> <em class="km"> ' </em> s只是符号，不像其他的<code class="eh ki kj kk kl b"><em class="km">defn</em></code>s。所以，我当然不能用它们代替文字，咄。</p><p id="0aa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第六课——不是所有的字面量都有对应的 <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">defn</em></strong></code> <strong class="it hv">。</strong></p><p id="2f4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第7课—使用~@获取宏内部展开的参数列表</strong></p><p id="e787" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">额外的 —试试<code class="eh ki kj kk kl b">(source defn)</code>，这是一本有趣的读物。</p><h2 id="f222" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">进入内部循环—创建内部参数</h2><p id="640d" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">我尝试添加一个新的符号，它将被添加到输入字符串的前面。</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="24b5" class="kn ko hu kl b fv lm ln l lo lp">(defmacro innersym-macro [a]<br/>  `(let [dyn-a# (str "Prepend-" ~a)]<br/>     (println dyn-a#)<br/>     dyn-a#))<br/>;#'user/innersym-macro<br/><br/>(macroexpand `(innersym-macro "test"))<br/>;(let* [dyn-a__1749__auto__ (clojure.core/str "Prepend-" "test")] (clojure.core/println dyn-a__1749__auto__) dyn-a__1749__auto__)<br/><br/>(innersym-macro "test")<br/>;Prepend-test<br/>;"Prepend-test"</span></pre><p id="3fda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这简直太棒了。</p><p id="a21d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第8课—使用# —在<em class="km">引号</em> -d代码块内创建符号，也称为<em class="km"> autogensym </em>。</strong></p><h2 id="96e1" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">请给我来点破坏性的。拜托了。</h2><p id="80e4" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">得寸进尺，我试着去破坏内层参数。</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="7c3e" class="kn ko hu kl b fv lm ln l lo lp">(defmacro innerdestructure-macro [a]<br/>  `(let [{:keys [prepend#] :as aprepender#} {:prepend "Prependtext" :append "Appendtext"}<br/>         dyn-a# (str prepend# ~a (:append aprepender#))]<br/>     (println dyn-a#)<br/>     dyn-a#))<br/>;#'user/innerdestructure-macro<br/><br/>(macroexpand `(innerdestructure-macro "test"))<br/>;(let* [map__1853 {:prepend "Prependtext", :append "Appendtext"} map__1853 (if (clojure.core/seq? map__1853) (clojure.lang.PersistentHashMap/create (clojure.core/seq map__1853)) map__1853) aprepender__1844__auto__ map__1853 prepend__1843__auto__ (clojure.core/get map__1853 :prepend__1843__auto__) dyn-a__1845__auto__ (clojure.core/str prepend__1843__auto__ "test" (:append aprepender__1844__auto__))] (clojure.core/println dyn-a__1845__auto__) dyn-a__1845__auto__)<br/><br/>(innerdestructure-macro "test")<br/>;testAppendtext<br/>;"testAppendtext"</span></pre><p id="7114" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">析构不起作用，因为<code class="eh ki kj kk kl b"><em class="km">prepend#</em></code>被当作零处理，但是直接的get键工作得很好。</p><p id="b369" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第九课——析构在第一级引用代码块中不起作用</strong></p><h2 id="f943" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">利用实习生</h2><p id="e7f9" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">现在，使用到目前为止学到的令人敬畏的宏技能，我冒险在执行宏时在名称空间内创建动态符号。</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="d98f" class="kn ko hu kl b fv lm ln l lo lp">(defmacro interning-macro [a]<br/>  `(let [{:keys [prepend#] :as aprepender#} {:prepend "Prependtext" :append "Appendtext"}<br/>         dyn-a# (str prepend# ~a (:append aprepender#))]<br/>     (intern<br/>      *ns*<br/>      '~'ooh-fn<br/>      (fn [oohargs#]<br/>        (println oohargs# dyn-a#)<br/>        oohargs#))))<br/>;#'user/interning-macro<br/><br/>(macroexpand `(interning-macro "test"))<br/>;(let* [map__1995 {:prepend "Prependtext", :append "Appendtext"} map__1995 (if (clojure.core/seq? map__1995) (clojure.lang.PersistentHashMap/create (clojure.core/seq map__1995)) map__1995) aprepender__1985__auto__ map__1995 prepend__1984__auto__ (clojure.core/get map__1995 :prepend__1984__auto__) dyn-a__1986__auto__ (clojure.core/str prepend__1984__auto__ "test" (:append aprepender__1985__auto__))] (clojure.core/intern clojure.core/*ns* (quote ooh-fn) (clojure.core/fn [oohargs__1987__auto__] (clojure.core/println oohargs__1987__auto__ dyn-a__1986__auto__) oohargs__1987__auto__)))<br/><br/>(ns outerspacestar)<br/>(user/interning-macro "star")<br/>;#'outerspacestar/ooh-fn<br/><br/>(ns outerspaceplanet)<br/>(user/interning-macro "planet")<br/>;#'outerspaceplanet/ooh-fn<br/><br/>(in-ns 'user)<br/>(outerspacestar/ooh-fn {:a 10})<br/>;{:a 10} starAppendtext<br/>;{:a 10}<br/><br/>(outerspaceplanet/ooh-fn {:b 20})<br/>;{:b 20} planetAppendtext<br/>;{:b 20}</span></pre><p id="cae5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太棒了。当宏被实例化时有一些内部引用。这对于创建配置变化的可重复模块非常方便。这里面有很多教训</p><p id="6b43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第10课— </strong> <code class="eh ki kj kk kl b"><strong class="it hv">*ns*</strong></code> <strong class="it hv"> —指代码正在执行的当前名称空间。</strong></p><p id="5c45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第十一课— </strong> <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">(intern somens '~'symname &lt;&lt;symdefinition&gt;&gt;)</em></strong></code> <strong class="it hv">相当于在那个<em class="km"> somens </em> namespace <em class="km">里面加了</em></strong> <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">(def symname symdefinition)</em></strong></code> <strong class="it hv"> <em class="km"> </em>。 </strong></p><p id="95da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第十二课— </strong> <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">(def x (fn []))</em> = <em class="km">(defn x [])</em></strong></code> <strong class="it hv">。</strong></p><p id="c562" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">额外的</strong> —如果你还没有检查<a class="ae jr" href="https://clojure.org/reference/protocols" rel="noopener ugc nofollow" target="_blank">协议</a>，请在某个时候检查。</p><h2 id="b4fd" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">命名空间内部实习生命名空间内部宏内部</h2><p id="3b27" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">现在，就我的理解来说，在宏生成的当前命名空间的内部加载一个命名空间怎么样</p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="a1a5" class="kn ko hu kl b fv lm ln l lo lp">(defn resolvable-fn1 []<br/>  (println "resolved1"))<br/>;#'user/resolvable-fn1<br/><br/>(defn resolvable-fn2 []<br/>  (println "resolved2"))<br/>;#'user/resolvable-fn2<br/><br/>(defmacro interning-resolve-macro [a]<br/>  `(let [{:keys [prepend#] :as aprepender#} {:prepend "Prependtext" :append "Appendtext"}<br/>         dyn-a# (str prepend# ~a (:append aprepender#))]<br/>     (intern<br/>      *ns*<br/>      '~'resolvens-fn<br/>      (fn [rargs#]<br/>        ((ns-resolve (symbol "user") (symbol "resolvable-fn1")))<br/>        ((ns-resolve '~'user '~'resolvable-fn2))<br/>        (println rargs# dyn-a#)<br/>        rargs#))))<br/>#'user/interning-resolve-macro<br/><br/>(macroexpand `(interning-resolve-macro "test"))<br/>;(let* [map__2276 {:prepend "Prependtext", :append "Appendtext"} map__2276 (if (clojure.core/seq? map__2276) (clojure.lang.PersistentHashMap/create (clojure.core/seq map__2276)) map__2276) aprepender__2266__auto__ map__2276 prepend__2265__auto__ (clojure.core/get map__2276 :prepend__2265__auto__) dyn-a__2267__auto__ (clojure.core/str prepend__2265__auto__ "test" (:append aprepender__2266__auto__))] (clojure.core/intern clojure.core/*ns* (quote resolvens-fn) (clojure.core/fn [rargs__2268__auto__] ((clojure.core/ns-resolve (clojure.core/symbol "user") (clojure.core/symbol "resolvable-fn1"))) ((clojure.core/ns-resolve (quote user) (quote resolvable-fn2))) (clojure.core/println rargs__2268__auto__ dyn-a__2267__auto__) rargs__2268__auto__)))<br/><br/>(ns outerspacestar)<br/>(user/interning-resolve-macro "star")<br/>#'outerspacestar/resolvens-fn<br/><br/>(ns outerspaceplanet)<br/>(user/interning-resolve-macro "planet")<br/>#'outerspaceplanet/resolvens-fn<br/><br/>(in-ns 'user)<br/>(outerspacestar/resolvens-fn {:a 100})<br/>;resolved1<br/>;resolved2<br/>;{:a 100} starAppendtext<br/>;{:a 100}<br/><br/>(outerspaceplanet/resolvens-fn {:b 200})<br/>;resolved1<br/>;resolved2<br/>;{:b 200} planetAppendtext<br/>;{:b 200}</span></pre><p id="016d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了前面提到的神奇之处，解析符号可以用有趣的方式来获得成功的结果。</p><p id="8350" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第十三课—</strong><code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">(symbol "xyz")</em></strong></code><strong class="it hv"><em class="km">=</em></strong><code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">'xyz</em></strong></code><strong class="it hv">。</strong></p><p id="9033" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第十四课—在宏观世界—</strong><code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">(symbol "xyz")</em></strong></code><strong class="it hv"><em class="km">=</em></strong><code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">'~'xyz</em></strong></code><strong class="it hv"><em class="km">。</em> </strong></p><p id="257d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第15课—在调用</strong> <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">ns-resolve</em></strong></code> <strong class="it hv">之前，需要加载ns。所以在使用</strong> <code class="eh ki kj kk kl b"><strong class="it hv">ns-resolve</strong></code> <strong class="it hv">之前最好先做一个</strong> <code class="eh ki kj kk kl b"><strong class="it hv"><em class="km">(require 'nssymbol)</em></strong></code> <strong class="it hv">。</strong></p><p id="89f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一口气看到所有这些动态符号有点混乱。让我试试<code class="eh ki kj kk kl b"><em class="km">macroexpand-1</em></code> <em class="km">。</em></p><pre class="jt ju jv jw fq li kl lj lk aw ll dt"><span id="13cb" class="kn ko hu kl b fv lm ln l lo lp">(macroexpand-1 `(interning-resolve-macro "test"))<br/><br/>;(clojure.core/let [{:as aprepender__2266__auto__, :keys [prepend__2265__auto__]} {:prepend "Prependtext", :append "Appendtext"} dyn-a__2267__auto__ (clojure.core/str prepend__2265__auto__ "test" (:append aprepender__2266__auto__))] (clojure.core/intern clojure.core/*ns* (quote resolvens-fn) (clojure.core/fn [rargs__2268__auto__] ((clojure.core/ns-resolve (clojure.core/symbol "user") (clojure.core/symbol "resolvable-fn1"))) ((clojure.core/ns-resolve (quote user) (quote resolvable-fn2))) (clojure.core/println rargs__2268__auto__ dyn-a__2267__auto__) rargs__2268__auto__)))</span></pre><p id="6c0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更整洁。</p><p id="7389" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第16课— </strong> <code class="eh ki kj kk kl b"><strong class="it hv">macroexpand-1</strong></code> <strong class="it hv">进行1级扩展，macroexpand进行各级扩展，每级扩展。单身。宏观。</strong></p><h2 id="159b" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">推断</h2><p id="a506" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">从经验教训中总结出的一些良好做法</p><ol class=""><li id="5e96" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated">在引用的块内保持析构到一个极限，以避免混淆。</li><li id="b5fb" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">将核心功能放在宏之外，放在宏之外。不需要在每次加载宏时都创建这些函数</li><li id="61de" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">对于在名称空间上初始化一群实习生的重量级宏，将实习生和实际实例化的数量保持在一个合理的限度内。这个数字越大，启动时间可能会变得越慢。</li><li id="52c2" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">另一方面，如果启动时间增加，看看强制加载宏的<em class="km">需求</em>，并帮助减少到唯一强制的启动名称空间。</li><li id="392a" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">如果你正在做大量的实习ns世代，可能是时候给<a class="ae jr" href="https://clojure.org/reference/protocols" rel="noopener ugc nofollow" target="_blank">协议</a>看一看，看看那是否工作得更好。有一点点可能你会喜欢:)</li></ol><p id="836e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">宏在很多方面都很强大，允许数据变成代码、可执行文件等等。但是(当然有“但是”)围绕它的文档有点神秘，而且(因为没有更好的词)不简单。希望从这篇文章中得到的教训能帮助那些未入门的人揭开一些神秘的面纱。</p><p id="5889" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我确信我遗漏了一两点，所以请在下面的评论区随时纠正我。此外，请在下面分享您使用Clojure宏的经验，我们很乐意了解它们！</p><p id="310c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="km">参考资料和有用链接</em> </strong></p><ol class=""><li id="8895" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated"><a class="ae jr" href="https://www.braveclojure.com/writing-macros/" rel="noopener ugc nofollow" target="_blank">https://www.braveclojure.com/writing-macros/</a>—面对宏音乐(即来自宏的错误)时深刻而有用</li><li id="2e39" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><a class="ae jr" href="https://stackoverflow.com/questions/3667403/what-is-the-difference-between-defn-and-defmacro" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/3667403/defn-and-def macro的区别是什么</a></li><li id="23f9" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><a class="ae jr" href="http://stackoverflow.com/questions/4571042/can-someone-explain-clojures-unquote-splice-in-simple-terms" rel="noopener ugc nofollow" target="_blank">http://stack overflow . com/questions/4571042/can-someone-explain-clojures-un quote-splice-in-simple-terms</a></li><li id="7ac6" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><a class="ae jr" href="https://clojure.org/reference/special_forms" rel="noopener ugc nofollow" target="_blank">https://clojure.org/reference/special_forms</a></li><li id="4d5a" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><a class="ae jr" href="https://clojure.org/reference/protocols" rel="noopener ugc nofollow" target="_blank">https://clojure.org/reference/protocols</a></li><li id="5aa5" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated"><a class="ae jr" href="https://www.braveclojure.com/multimethods-records-protocols/" rel="noopener ugc nofollow" target="_blank">https://www . braveclojure . com/multi methods-records-protocol/</a>——又一篇来自brave clojure的文章，里面充满了clo jure的美好！</li></ol><figure class="jt ju jv jw fq jx"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>