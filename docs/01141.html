<html>
<head>
<title>The Little Guide of Linked List in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的链表小指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-little-guide-of-linked-list-in-javascript-9daf89b63b54?source=collection_archive---------0-----------------------#2018-02-05">https://medium.com/hackernoon/the-little-guide-of-linked-list-in-javascript-9daf89b63b54?source=collection_archive---------0-----------------------#2018-02-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b23a5d0a3ed649e36bb46587f9e0ea3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtNwAS8s-em-K2LVkscqkg.jpeg"/></div></div></figure><h1 id="7ed7" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">什么是数据结构？</h1><blockquote class="ka kb kc"><p id="da15" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">数据结构是一种组织存储在计算机中的数据的方式，以便可以有效地使用它。</p></blockquote><p id="e9eb" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">一个<em class="kf">链表</em>，顾名思义，是一个节点的链表，由列表中第一个节点的头和最后一个节点的尾来表示。每个节点都有一个指向前一个和下一个节点的引用/指针。</p><p id="b74b" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">链表数据结构有两种类型，第一种是单链表，这种类型的节点有指向下一个节点的指针，但没有指向上一个节点的指针。</p><p id="4448" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">在这篇文章中，我们将探索<em class="kf">双向链表，即节点有一个下一个和上一个指针(头节点有一个下一个指针，但没有上一个，尾节点有一个上一个指针，但没有下一个)。</em></p><h2 id="0395" class="lf jd hu bd je lg lh li ji lj lk ll jm lc lm ln jq ld lo lp ju le lq lr jy ls dt translated">优势:</h2><p id="cf0c" class="pw-post-body-paragraph kd ke hu kg b kh lt kj kk kl lu kn ko lc lv kr ks ld lw kv kw le lx kz la lb hn dt translated">尽管链表类似于数组，但它并不局限于声明的元素数量。此外，与在内存或磁盘上连续存储数据的数组不同，链表可以轻松地<strong class="kg hv">插入或删除</strong>元素，而无需重新分配或重组整个结构，因为数据项不需要连续存储。</p><h2 id="6582" class="lf jd hu bd je lg lh li ji lj lk ll jm lc lm ln jq ld lo lp ju le lq lr jy ls dt translated">链表的缺点:</h2><p id="89c7" class="pw-post-body-paragraph kd ke hu kg b kh lt kj kk kl lu kn ko lc lv kr ks ld lw kv kw le lx kz la lb hn dt translated">1)不允许随机访问。我们必须从第一个节点开始按顺序访问节点。因此，我们不能在链表上做二分搜索法。<strong class="kg hv">所以搜索元素的速度很慢。</strong></p><p id="c64b" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">2)列表的每个元素都需要用于链接的额外存储空间。</p><p id="8cb4" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated"><strong class="kg hv">链表</strong>数据结构常用于实现其他数据结构。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/4d362f2e890af60128234420c5f9db9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDqhnIMkmexHS7z7YgjYPA.png"/></div></figure><p id="43f7" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">在这篇文章中，我们将有一种方法来处理<em class="kf">链表</em>数据结构。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/f73ce8d3d1543d96b8f4586b611b2365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOKmkucFHN_gmTMUtyC2sQ.png"/></div></div></figure><p id="e394" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">所以我们要创建两个构造函数:</p><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="e0f2" class="lf jd hu mf b fv mj mk l ml mm">function LinkedList() {<br/>  this.head = null;<br/>  this.tail = null;<br/>}</span><span id="8f36" class="lf jd hu mf b fv mn mk l ml mm">function Node(value, next, prev) {<br/>  this.value = value;<br/>  this.next = next;<br/>  this.prev = prev;<br/>}</span></pre><p id="c72b" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">如你所见，我们在构造函数中表示图像样本。我们的<em class="kf"> LinkedList函数</em>有<code class="eh mo mp mq mf b">head</code>和<code class="eh mo mp mq mf b">tail</code>，为什么<strong class="kg hv">为空？</strong>因为在开始时没有任何节点。</p><p id="a3b8" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">所以，现在我们要创建我们的<em class="kf"> addToTail </em>方法。</p><h1 id="5f6f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">创建头部节点</h1><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="b142" class="lf jd hu mf b fv mj mk l ml mm">LinkedList.prototype.addToHead = function(value) {<br/>  const newNode = new Node(value, this.head, null);<br/>  if (this.head) this.head.prev = newNode;<br/>  else this.tail = newNode; <br/>  this.head = newNode;<br/>};</span></pre><p id="b692" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">正如你看到的，我们在LinkedList原型中创建了这个方法，<strong class="kg hv">为什么？</strong>这项技术很有用，因为我们将创建许多对象，如果我们没有在原型中创建我们的方法，我们将为每个对象复制所有方法，这意味着可能有害的内存开销。</p><h2 id="dd39" class="lf jd hu bd je lg lh li ji lj lk ll jm lc lm ln jq ld lo lp ju le lq lr jy ls dt translated">让我们回顾一下每一行</h2><p id="7b5d" class="pw-post-body-paragraph kd ke hu kg b kh lt kj kk kl lu kn ko lc lv kr ks ld lw kv kw le lx kz la lb hn dt translated">这将在变量newNode中存储一个新的节点对象。<code class="eh mo mp mq mf b">value</code>将是我们在addToHead方法中传递的值，<code class="eh mo mp mq mf b">this.head</code>最初为空，因此<code class="eh mo mp mq mf b">next</code>属性为空，<code class="eh mo mp mq mf b">prev</code>属性也将为空，因为我们在第三个参数中传递了它。</p><p id="fb93" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated"><code class="eh mo mp mq mf b">if (this.head) this.head.prev = newNode;</code>好的，这一行意味着如果存在一个<em class="kf">头</em>节点，它们的prev值将是newNode(即新的头)。如果没有节点，我们创建的实际节点将是头部，也是尾部，正如我们在第<strong class="kg hv">第三个</strong>图像示例中看到的。</p><p id="0fb5" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">例如，如果我们现在创建两个节点:</p><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="c476" class="lf jd hu mf b fv mj mk l ml mm">const list = new LinkedList();<br/>list.addToHead(100);<br/>list.addToHead(200);<br/>console.log(list);</span></pre><p id="35ac" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">我们将得到以下输出:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/418a66cc614e0a9683bd961c53403003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZhu5ad18g7T05yJCk9BwA.png"/></div></div></figure><p id="0c47" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">头节点的<code class="eh mo mp mq mf b">value</code>为200，<code class="eh mo mp mq mf b">next</code>属性是尾对象(列表中的下一个)，没有<em class="kf">前一个</em>对象，因为<em class="kf">头</em>是第一个。</p><p id="932e" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">现在，想象一下:</p><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="126d" class="lf jd hu mf b fv mj mk l ml mm">const otherlist = new LinkedList();<br/>otherlist.addToHead(100);<br/>otherlist.addToHead(200);<br/>otherlist.addToHead(300);<br/>console.log(otherlist);</span></pre><p id="e5c4" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">输出将是:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/41915d5ee5dfec5a84614c238fdb4eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdOuxXmCHyoQvhKjWKrXzg.png"/></div></div></figure><p id="7aac" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">或者类似这样的东西:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/d7c4a7d0a2981e74540dfaedd1c9ab22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vMrgnKUU2ujVS7CEx52kw.png"/></div></div></figure><p id="b4b8" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">因此，如果您希望它访问中间节点，您可以这样做:</p><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="b38f" class="lf jd hu mf b fv mj mk l ml mm">console.log(`Middle node value: ${otherlist.head.next.value}`);</span></pre><p id="35b0" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">记住<em class="kf"> addToHead </em>方法将节点添加到开始，然后你唯一需要做的就是在你的控制台中分解对象！</p><p id="aad0" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">试试吧！</p><p id="e9a0" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">所以，现在我们要创建我们的<em class="kf"> addToTail </em>方法。</p><h1 id="60b7" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">创建尾节点</h1><p id="4aba" class="pw-post-body-paragraph kd ke hu kg b kh lt kj kk kl lu kn ko lc lv kr ks ld lw kv kw le lx kz la lb hn dt translated">实际上，这个方法与我们在addToHead示例中所做的非常相似。</p><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="28cf" class="lf jd hu mf b fv mj mk l ml mm">LinkedList.prototype.addToTail = function(value) {<br/>  const newNode = new Node(value, null, this.tail);<br/>  if (this.tail) this.tail.next = newNode;<br/>  else this.head = newNode;<br/>  this.tail = newNode;<br/>}</span></pre><p id="aff3" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">使用与上一个例子相同的逻辑，本质是相似的，只是使用了相反的逻辑。</p><p id="a294" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">所以现在，如果我们做和在addToHead方法中一样的例子:</p><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="3136" class="lf jd hu mf b fv mj mk l ml mm">const list = new LinkedList();<br/>list.addToTail(100);<br/>list.addToTail(200);<br/>list.addToTail(300);<br/>console.log(list);</span></pre><p id="063a" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">现在，最后添加的将是尾部(最后一个),不像另一个方法，最后一个写入被添加为第一个节点(头)。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/ce0496698dd49d000bd0eb1fd1c14c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dnqNtqn2bho1cYzSOxX5A.png"/></div></div></figure><p id="da6f" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">或者像这样:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/317245ec792ddbfefe4ead0a1d453095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGVUe6bDdtlyfOrAkEnV5A.png"/></div></div></figure><h2 id="5c4d" class="lf jd hu bd je lg lh li ji lj lk ll jm lc lm ln jq ld lo lp ju le lq lr jy ls dt translated">测试两种方法:</h2><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="46f8" class="lf jd hu mf b fv mj mk l ml mm">const list = new LinkedList();<br/>list.addToHead(1);<br/>list.addToTail(2);<br/>console.log(list);</span></pre><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/b38a57c1f7f84293ae6f362e1cdfa3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfImNuVt-EDSEakFofkiSw.png"/></div></div></figure><h1 id="7775" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">删除节点</h1><h2 id="dbe0" class="lf jd hu bd je lg lh li ji lj lk ll jm lc lm ln jq ld lo lp ju le lq lr jy ls dt translated">想象我们有这样的节点:</h2><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="5070" class="lf jd hu mf b fv mj mk l ml mm">const list = new LinkedList();<br/>list.addToHead(200);<br/>list.addToHead(100); <em class="kf">// remember this is the head now!</em><br/>list.addToTail(300);<br/>console.log(list);</span></pre><h2 id="4f13" class="lf jd hu bd je lg lh li ji lj lk ll jm lc lm ln jq ld lo lp ju le lq lr jy ls dt translated">删除头节点方法:</h2><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="a816" class="lf jd hu mf b fv mj mk l ml mm">LinkedList.prototype.removeHead = function() {<br/>  if (!this.head) return null;<br/>  let value = this.head.value;<br/>  this.head = this.head.next;<br/>  <br/>  if (this.head) this.head.prev = null;<br/>  else this.tail = null;<br/>  <br/>  return value;<br/>}</span></pre><p id="e7d6" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">让我们看看，第一行将验证是否有任何头，如果没有返回null。然后，我们保存<em class="kf">头节点</em>的<em class="kf">值</em>，并使用下面这条线设置新的头节点:<code class="eh mo mp mq mf b">this.head = this.head.next;</code>因此，在这一点上，我们有:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/9313e92b2de6e39e3e2c50d679a9fad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOTi8gW0VwW82dF-HO4IIA.png"/></div></div></figure><p id="9002" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">在最后几行代码中，我们将<em class="kf"> prev </em>重置为空，因为新的head不能有prev值(因为是第一个节点)。</p><p id="41a5" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">返回移除值。</p><h2 id="e715" class="lf jd hu bd je lg lh li ji lj lk ll jm lc lm ln jq ld lo lp ju le lq lr jy ls dt translated">删除尾节点方法:</h2><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="41a8" class="lf jd hu mf b fv mj mk l ml mm">LinkedList.prototype.removeTail = function() {<br/>  if (!this.tail) return null;<br/>  let value = this.tail.value;<br/>  this.tail = this.tail.prev;<br/>  <br/>  if (this.tail) this.tail.next = null;<br/>  else this.head = null;<br/>  <br/>  return value;<br/>}</span></pre><p id="a1be" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">对此方法应用相同的逻辑，因为它是相同的，但效果相反。</p><h1 id="9aee" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">搜索节点:</h1><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="4ba2" class="lf jd hu mf b fv mj mk l ml mm">LinkedList.prototype.search = function(searchValue) {<br/>  let currentNode = this.head;<br/>  <br/>  while(currentNode) {<br/>    if (currentNode.value === searchValue) return currentNode;<br/>    currentNode = currentNode.next; <br/>  }<br/>  return null;<br/>}</span></pre><p id="03a6" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">所以在这里，我们在<em class="kf">当前节点</em>变量中保存<code class="eh mo mp mq mf b">this.head</code>的值，然后<em class="kf">当</em>当前节点不<em class="kf">未定义</em>时，我们比较是否存在<em class="kf">节点</em>与我们传递的<em class="kf">值</em>，如果不存在，我们返回<em class="kf">空值</em>。</p><p id="f7e2" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">所以，如果我们有这个:</p><pre class="lz ma mb mc fq me mf mg mh aw mi dt"><span id="63dc" class="lf jd hu mf b fv mj mk l ml mm">const list = new LinkedList();</span><span id="ee49" class="lf jd hu mf b fv mn mk l ml mm">list.addToHead(1);<br/>list.addToTail(2);</span><span id="ed8f" class="lf jd hu mf b fv mn mk l ml mm">console.log(list.search(1)); <em class="kf">// true</em><br/>console.log(list.search(2)); <em class="kf">// true</em><br/>console.log(list.search(3000)); <em class="kf">// false</em></span></pre><p id="8a9a" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">输出将是:</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/f0aa672f31dc564f7ea555d7869f91fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUiqO2S98dx3iNh7VKbd-w.png"/></div></div></figure></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="255b" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">我希望你喜欢它！</p><p id="6f5e" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated"><strong class="kg hv">完整代码:</strong><a class="ae ng" href="https://github.com/germancutraro/LinkedList-Data-Structure" rel="noopener ugc nofollow" target="_blank">https://github.com/germancutraro/LinkedList-Data-Structure</a></p><p id="587f" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated"><strong class="kg hv">你有我的</strong><a class="ae ng" href="https://github.com/germancutraro" rel="noopener ugc nofollow" target="_blank"><strong class="kg hv"><em class="kf">Github</em></strong></a><strong class="kg hv">如果你愿意跟随我，我将不胜感激！</strong></p><p id="c8e1" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">感谢<strong class="kg hv"/><a class="ae ng" href="https://www.sololearn.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kg hv">solo learn</strong></a>一款梦幻般的app！</p><p id="5779" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated"><strong class="kg hv">学习数据结构和算法的绝佳课程:</strong> <br/> ◾ <a class="ae ng" href="https://www.udemy.com/learning-data-structures-in-javascript-from-scratch/" rel="noopener ugc nofollow" target="_blank">从零开始学习JavaScript中的数据结构</a> <br/> ◾ <a class="ae ng" href="https://www.udemy.com/coding-interview-bootcamp-algorithms-and-data-structure/" rel="noopener ugc nofollow" target="_blank">编码面试训练营:算法+数据结构</a></p><p id="b82a" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">谢谢你😊</p></div></div>    
</body>
</html>