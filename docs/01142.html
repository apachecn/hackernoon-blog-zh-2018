<html>
<head>
<title>Building a Blog with React and Contentful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用反应和满足来建立一个博客</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-blog-with-react-and-contentful-fd538f68f6fb?source=collection_archive---------1-----------------------#2018-02-05">https://medium.com/hackernoon/building-a-blog-with-react-and-contentful-fd538f68f6fb?source=collection_archive---------1-----------------------#2018-02-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c624" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">React博客系列:第二部分</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/b95aaa3913635967a489e69023e2ca2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwkZf1DkMliObkYnv-8xQg.jpeg"/></div></div></figure><p id="df8d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">本文是关于用React创建博客的每周系列文章的第二部分，是第一部分中创建的代码的扩展。</p><h2 id="fc14" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated"><strong class="ak">React博客系列</strong></h2><p id="f828" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated"><a class="ae lr" rel="noopener" href="/front-end-hacking/building-a-website-with-react-and-bulma-d655214bff2a"> <strong class="jx hv">第一部分:</strong>用React和布尔玛</a> <br/> <strong class="jx hv">建立一个网站第二部分:</strong>用React和Contentful <br/> <a class="ae lr" rel="noopener" href="/@aaron.klaser/import-your-medium-feed-into-react-ceadbaf785c7"> <strong class="jx hv">建立一个博客第三部分:</strong>将你的媒体提要导入React </a> <br/> <a class="ae lr" rel="noopener" href="/@aaron.klaser/adding-redux-to-a-react-blog-97f5fea606c2"> <strong class="jx hv">第四部分:</strong>向React博客添加一个Redux</a><br/><a class="ae lr" href="https://hackernoon.com/replacing-redux-thunks-with-redux-sagas-4aa306854925" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">第五部分:</strong>用Redux Sagas替换Redux Thunks</a><br/></p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><p id="f8f1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这将介绍在React应用程序中设置Contentful并将其数据显示为博客提要的基础知识。</p><blockquote class="ma mb mc"><p id="4300" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated">这个<strong class="jx hv">不</strong>包括Redux…还没有；)</p></blockquote><h1 id="7189" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">满足的</h1><h2 id="2e27" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">注册Contentful</h2><p id="99a3" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">点击这里<a class="ae lr" href="https://www.contentful.com/sign-up/" rel="noopener ugc nofollow" target="_blank">报名这里</a></p><p id="724e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当你开始心满意足地四处闲逛时，你可能会有一种奇怪的失败感，也许是daja vue，或者只是因为它看起来和Wordpress Admin一模一样？</p><p id="2be1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> Contentful </strong>非常干净，易于导航，看起来和感觉<em class="ls">很像Wordpress</em>。尽管不愿意承认，但我喜欢它，这是一件令人惊奇的事情，因为我不喜欢Wordpress。公平地说，我不讨厌Wordpress的UX，我讨厌它是因为它太慢了，而且是建立在看起来像是拼凑起来的PHP之上的，让我们面对现实吧，没有人真正喜欢PHP。甚至不是PHP的创造者。</p><h2 id="ec68" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">这个概念</h2><p id="15fd" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">Contentful是内容管理即服务(CaaS ),它取代了将你的网站连接到某个蹩脚的Apachy服务器上的可怕的MySQL数据库的需要，在那里你必须安装phpMyAdmin并花费数小时试图找出cPanel。</p><h2 id="1aeb" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">数据</h2><p id="58bc" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">你的数据有两部分，结构和数据。它基本上是一个非常好的web表单，可以转换成简单的json。你必须首先在<strong class="jx hv"> <em class="ls">内容模型</em> </strong>中设置你的表单，然后你可以跳转到<strong class="jx hv"> <em class="ls">内容</em> </strong>并填写你的表单，每个表单都成为通过rest端点发送的数据模型数组中的一项。</p><h2 id="6bb2" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">让我们从制作一个博客模型开始</h2><p id="ef4a" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">添加三个字段:标题、路径和内容</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/56a56d3128b9b54b31d69ad744920aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dve-ROdX2dh05r3JvMmIdA.png"/></div></div></figure><p id="5351" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">JSON预览将如下所示</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ms"><img src="../Images/2e31d5767aaf77cc3a92dcf348ab227b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHh569ElP5Vqe2zY8bZvmQ.png"/></div></div></figure><p id="91a7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，让我们为应用程序创建一篇博客文章，并将其显示在我们的博客页面上。</p><p id="880e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">转到Content，点击右上角的Add Blog并填写表单。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mt"><img src="../Images/392c5700ff009b8767372241d84537e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMF1xgESel_skoa58hqjDQ.png"/></div></div></figure><p id="cddb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在你有了你的第一篇博文！</p><h1 id="af1e" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">获取Api令牌</h1><p id="2eda" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">您将需要一个<strong class="jx hv">空间Id </strong>和访问令牌来检索您的数据。转到<strong class="jx hv">Api</strong>选项卡，点击<strong class="jx hv">添加Api密钥。</strong></p><p id="96c8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你想取什么名字就取什么名字，然后保存起来。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mu"><img src="../Images/0eacd93cd5207cf226edce252a89a664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpFSVNj3KfZfVz8f4NnX9g.png"/></div></div></figure><h1 id="5ee9" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">在反应中建立满足</h1><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="89a5" class="kr ks hu mw b fv na nb l nc nd">npm install contentful</span></pre><p id="bce2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们看看能否连接并获取数据。</p><p id="b51d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh ne nf ng mw b">src/index.js</code>上，让我们导入Contentful，设置一个简单的客户端，然后获取条目。现在让我们记录我们得到的东西，如果幸运的话，我们应该会看到我们的测试博客帖子。这是暂时的。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="96fe" class="kr ks hu mw b fv na nb l nc nd">import React from 'react';<br/>import ReactDOM from 'react-dom'<br/>import registerServiceWorker from './registerServiceWorker'<br/>import { BrowserRouter as Router } from 'react-router-dom'<br/><strong class="mw hv">import * as contentful from 'contentful'</strong><br/>import App from './App'<br/>import './index.css'</span><span id="7fb5" class="kr ks hu mw b fv nh nb l nc nd"><strong class="mw hv">var client = contentful.createClient({<br/>  space: 'qu10m4oq2u62',<br/>  accessToken: 'f4a9f68de290d53552b107eb503f3a073bc4c632f5bdd50efacc61498a0c592a' })</strong></span><span id="f29c" class="kr ks hu mw b fv nh nb l nc nd"><strong class="mw hv">client.getEntries().then(entries =&gt; {<br/>  entries.items.forEach(entry =&gt; {<br/>    if(entry.fields) {<br/>      console.log(entry.fields)<br/>    }<br/>  })<br/>})</strong></span><span id="8845" class="kr ks hu mw b fv nh nb l nc nd">ReactDOM.render((<br/>  &lt;Router&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Router&gt;<br/>), document.getElementById('root'))<br/>registerServiceWorker()</span></pre><p id="d008" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">运行您的应用程序并打开您的控制台。你应该看到一个干净的小物体充满了我们的数据。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/6c2d92064e18a5bade3c4dfa55736d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*lUUs01bR903AX0nKOGA5ng.png"/></div></figure><p id="2dda" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">是不是很神奇？这就像是有史以来最简单的设置！</p><p id="6af8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是现在让我们把它做好…好吧，在没有Redux :P的情况下尽可能多的做</p><h1 id="12db" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">设置您的博客页面</h1><p id="3fea" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">复制所有你感兴趣的东西，并从你的索引中删除。</p><p id="47da" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">走向你的<code class="eh ne nf ng mw b">Blog.js</code>，把它从一个愚蠢的组件变成一个聪明的反应。组件类。</p><p id="9c32" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，我们将需要包含一个空post数组的状态。</p><p id="42d9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">粘贴内容丰富的createClient对象。</p><p id="df69" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，使用<strong class="jx hv"> React </strong>生命周期钩子<strong class="jx hv"> componentDidMount </strong>，我们需要调用一个<strong class="jx hv"> fetchPosts </strong>函数，该函数将调用一个<strong class="jx hv"> setPosts </strong>函数</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="97ca" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/>import * as contentful from 'contentful'</span><span id="fadb" class="kr ks hu mw b fv nh nb l nc nd">class Blog extends React.Component {</span><span id="af68" class="kr ks hu mw b fv nh nb l nc nd">  state = {<br/>    posts: []<br/>  }</span><span id="1cb4" class="kr ks hu mw b fv nh nb l nc nd">  client = contentful.createClient({<br/>    space: 'qu10m4oq2u62',<br/>    accessToken: 'f4a9f68de290d53552b107eb503f3a073bc4c632f5bdd50efacc61498a0c592a'<br/>  })</span><span id="001c" class="kr ks hu mw b fv nh nb l nc nd">  componentDidMount() {<br/>    this.fetchPosts().then(this.setPosts);<br/>  }</span><span id="2bef" class="kr ks hu mw b fv nh nb l nc nd">  fetchPosts = () =&gt; this.client.getEntries()</span><span id="96f3" class="kr ks hu mw b fv nh nb l nc nd">  setPosts = response =&gt; {<br/>    this.setState({<br/>      posts: response.items<br/>    })<br/>  }</span><span id="a673" class="kr ks hu mw b fv nh nb l nc nd">  render() {<br/>    return (<br/>      &lt;p&gt;This is the Blog Page&lt;/p&gt;<br/>    )<br/>  }<br/>}</span><span id="f469" class="kr ks hu mw b fv nh nb l nc nd">export default Blog</span></pre><p id="a6e1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您在<strong class="jx hv">fetch post</strong>函数中插入控制台日志，您会看到我们正在从<strong class="jx hv"> Contentful </strong>中获取数据。</p><p id="646e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们正在获取数据，并且我们是以React方式(w/o Redux)获取的，让我们更新render函数来显示数据。稍后我们将把它们移到它们自己的漂亮组件中，但是现在让我们把它放在一些pre标签中。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="bd87" class="kr ks hu mw b fv na nb l nc nd">render() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;This is the Blog Page&lt;/p&gt;<br/>      &lt;br/&gt;<br/>      { this.state.posts.map(({fields}, i) =&gt;<br/>        &lt;pre key={i}&gt;{JSON.stringify(fields, null, 2)}&lt;/pre&gt;<br/>      )}<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="f854" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">耶！！！</p><h1 id="9fba" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">添加新的博客文章</h1><p id="c909" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">回到<strong class="jx hv">内容丰富的</strong>，点击<strong class="jx hv">内容&gt;添加博客</strong>，然后填写信息。你知道该怎么做。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/8147018107b5212dd41e9607f12d955d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpnwgEbCKxibdPq5jdzJQA.png"/></div></div></figure><p id="6d9e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">点击<strong class="jx hv">发布</strong>回到你的应用程序，刷新浏览器和<em class="ls"> BLAMMO </em>！！这是你的第二封信。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nj"><img src="../Images/a15c09b1f88883ae6a127d0dbc7ebdf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9tjrm62lOjvbgCkkxmdvA.png"/></div></div></figure><h1 id="8237" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">设计博客订阅源的样式</h1><p id="b678" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">我们需要设置一个博客项目组件。我们的博客页面将包含一个博客条目列表，这些条目组成了“<strong class="jx hv"> <em class="ls">提要</em> </strong>”。</p><p id="d3b4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae lr" rel="noopener" href="/front-end-hacking/building-a-website-with-react-and-bulma-d655214bff2a">记住我们使用的是分形文件结构</a>并且<code class="eh ne nf ng mw b">BlogItem.js</code>将是<code class="eh ne nf ng mw b">Blog.js</code>的子文件。由于<code class="eh ne nf ng mw b">Blog.js</code>在<strong class="jx hv"> app </strong>文件夹中，我们将在<strong class="jx hv"> app </strong>文件夹中创建一个名为<strong class="jx hv"> <em class="ls"> blog </em> </strong>的文件夹，然后在我们新创建的<strong class="jx hv"> blog </strong>文件夹中创建我们的<code class="eh ne nf ng mw b">BlogItem.js</code>。</p><p id="ad28" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你正在记分，并且正确地遵循<a class="ae lr" rel="noopener" href="/front-end-hacking/building-a-website-with-react-and-bulma-d655214bff2a"> <strong class="jx hv">分形文件结构</strong> </a>，我们当前的文件结构应该看起来像这样。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nk"><img src="../Images/afdaeeb45773cd751c59949a95b6e0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0AytRP9bSnUiGOI4dN4Rw.png"/></div></div></figure><h2 id="451d" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">创建博客组件</h2><p id="a143" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">在<code class="eh ne nf ng mw b">BlogItem.js</code>中，用<strong class="jx hv">布尔玛</strong>框创建简单组件。我们将通过道具，现在将是一个领域的传播从心满意足。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="5d53" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'</span><span id="44ac" class="kr ks hu mw b fv nh nb l nc nd">const BlogItem = (props) =&gt; (<br/>  &lt;div className="box content"&gt;<br/>    &lt;h1&gt;{props.title}&lt;/h1&gt;<br/>    &lt;p&gt;{props.content}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="a4a2" class="kr ks hu mw b fv nh nb l nc nd">export default BlogItem</span></pre><p id="a9a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，回到<strong class="jx hv"> Blog.js </strong>中，我们需要在render中更新我们的posts地图，以返回我们的<strong class="jx hv"> BlogItem </strong>组件，并将字段作为属性传播。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="b946" class="kr ks hu mw b fv na nb l nc nd">render() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;This is the Blog Page&lt;/p&gt;<br/>      &lt;br/&gt;<br/>      { this.state.posts.map(({fields}, i) =&gt;<br/>        <strong class="mw hv">&lt;BlogItem key={i} {...fields} /&gt;</strong><br/>      )}<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="20db" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">刷新一下，就可以了。但是……那种看起来<em class="ls">可怕的</em>。</p><h2 id="164f" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">样式博客页面</h2><p id="2ab7" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">让我们将<code class="eh ne nf ng mw b">&lt;p&gt;This is the Blog Page&lt;/p&gt;</code>替换为<strong class="jx hv">布尔玛英雄</strong>作为我们的页眉。因为我们可能会在大多数页面的顶部这样做，所以让我们将其创建为一个全局可重用组件。</p><p id="5340" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我们的应用程序文件夹中，创建一个名为components的新文件夹。根据我们的分形逻辑，这意味着这些组件都将作为应用程序的子组件存在。</p><blockquote class="ma mb mc"><p id="1c5f" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="hu">剧透预警</em> </strong>:如果你还没想通，<code class="eh ne nf ng mw b">App.js</code>和它的子文件夹(<code class="eh ne nf ng mw b">app</code>)，会包含我们所有的展现逻辑。目前，我们所做的每一件事都将成为<strong class="jx hv">应用</strong>的产物。<a class="ae lr" rel="noopener" href="/@aaron.klaser/adding-redux-to-a-react-blog-97f5fea606c2">稍后当我们重构使用<strong class="jx hv"> Redux </strong> </a>，<strong class="jx hv"> App </strong>会得到一个名为<code class="eh ne nf ng mw b">Store.js</code>的兄弟，以及它的子文件夹(<code class="eh ne nf ng mw b">store</code>)，它会包含我们所有的<strong class="jx hv">数据服务</strong>和<strong class="jx hv">状态</strong>。</p></blockquote><p id="5e8b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<strong class="jx hv">组件</strong>文件夹中创建两个文件，<code class="eh ne nf ng mw b">PageHeader.js</code>和<code class="eh ne nf ng mw b">PageContent.js</code></p><p id="ac32" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">PageHeader 将成为我们的布尔玛英雄的一个组件。我们将不包括字幕内容。这样，我们可以做css样式或包含链接，并将其作为儿童道具传递。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="98c2" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'</span><span id="ebe5" class="kr ks hu mw b fv nh nb l nc nd">const PageHeader = (props) =&gt; (<br/>  &lt;section className={`hero ${props.color}`}&gt;<br/>    &lt;div className="hero-body"&gt;<br/>      &lt;div className="container"&gt;<br/>        &lt;h1 className="title"&gt;<br/>          {props.title}<br/>        &lt;/h1&gt;<br/>        &lt;h2 className="subtitle"&gt;<br/>          {props.children}<br/>        &lt;/h2&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/section&gt;<br/>)</span><span id="36ed" class="kr ks hu mw b fv nh nb l nc nd">export default PageHeader</span></pre><p id="2755" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我们的<code class="eh ne nf ng mw b">Blog.js</code>中，将<code class="eh ne nf ng mw b">&lt;p&gt;This is the Blog Page&lt;/p&gt;</code>替换为</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="5a30" class="kr ks hu mw b fv na nb l nc nd">&lt;PageHeader color="is-info" title="Code Blog"&gt;<br/>  Your standard &lt;strong&gt;JavaScript&lt;/strong&gt; programming blog, albeit, probably not very good, but I will at least try to keep it entertaining. This blog is a chronological mix of random posts on Angular, React, Functional Programming, and my &lt;strong&gt;project walkthroughs&lt;/strong&gt;.<br/>&lt;/PageHeader&gt;</span></pre><p id="91dc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">PageContent 将是一个样式化的组件，用来限制我们的页面的最大宽度，并添加填充等等。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="66d9" class="kr ks hu mw b fv na nb l nc nd">import styled from 'styled-components'</span><span id="c075" class="kr ks hu mw b fv nh nb l nc nd">const PageContent = styled.div`<br/>  margin: 0 auto;<br/>  max-width: 960px;<br/>  padding: 1.5rem;<br/>`<br/>export default PageContent</span></pre><p id="2800" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">啊…现在好多了。</p><h1 id="083d" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">更好更真实的博客帖子</h1><p id="c4c1" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">回到Contentful，让我们在博客内容模型中添加一些字段</p><p id="eaac" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们将添加三个新字段:</p><ul class=""><li id="4c2b" class="nl nm hu jx b jy jz kb kc ke nn ki no km np kq nq nr ns nt dt translated"><strong class="jx hv">图标:</strong>设置外观为<strong class="jx hv">单线</strong></li><li id="355e" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated"><strong class="jx hv">状态</strong>:仅值“进行中”有效，非必需。将外观设置为<strong class="jx hv">下拉菜单</strong></li><li id="a49f" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated"><strong class="jx hv">日期</strong>:仅将外观设置为<strong class="jx hv">日期</strong></li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nz"><img src="../Images/42f6fa54048e9917fc5932ef26381211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKU27POFIvRbc9H0fDOQyA.png"/></div></div></figure><p id="ed9a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在跳到你的第一篇和第二篇博文，填入一些数据。</p><p id="a2c1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">图标可以是一个链接到图标的url，也可以是base64，只要它能正常进入<strong class="jx hv"> src </strong>属性。</p><blockquote class="ma mb mc"><p id="ddcb" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><em class="hu">内容应该设置为</em><strong class="jx hv"><em class="hu">Markdown</em></strong><em class="hu">这样当你填充页面内容的时候就可以用</em><strong class="jx hv"><em class="hu">Markdown</em></strong><em class="hu">样式了！</em></p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oa"><img src="../Images/10c05d9daa979dd8de765069fc5de8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjF3NBXuUmOHvwl0ic6gkw.png"/></div></div></figure><p id="59a3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对两个帖子都这样做，<strong class="jx hv">保存</strong>，然后刷新你的。这可能会看起来很糟糕…</p><p id="00a4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">是的！</p><h1 id="454e" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">渲染降价</h1><p id="4677" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">所以让我们从解决房间里的大象开始。我们需要作出反应渲染为html的降价，它需要看起来…漂亮。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="5ab0" class="kr ks hu mw b fv na nb l nc nd">npm install react-markdown</span></pre><p id="a809" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh ne nf ng mw b">BlogItem.js</code>中，用react-markdown替换内容&lt; p &gt;。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="71cc" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/><strong class="mw hv">import * as Markdown from 'react-markdown'</strong></span><span id="5b0b" class="kr ks hu mw b fv nh nb l nc nd">const BlogItem = (props) =&gt; (<br/>  &lt;div className="box content"&gt;<br/>    &lt;h1&gt;{props.title}&lt;/h1&gt;<br/>    <strong class="mw hv">&lt;Markdown source={props.content} /&gt;</strong><br/>  &lt;/div&gt;<br/>)</span><span id="0aa4" class="kr ks hu mw b fv nh nb l nc nd">export default BlogItem</span></pre><p id="ac67" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">嘣！</p><p id="ec16" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">好多了，但是我会从<strong class="jx hv">内容丰富的</strong>中的的<strong class="jx hv">降价中删除H1的标题，并将你的<strong class="jx hv">内容丰富的</strong>博客文章重新命名为H1的标题。当我们在接下来添加图标和其他东西时，你就会明白为什么了。</strong></p><h2 id="49f1" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">添加图标</h2><p id="9af5" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">这只是简单的<strong class="jx hv">布尔玛</strong>。打开你的<code class="eh ne nf ng mw b">BlogItem.js</code>，我们将从<strong class="jx hv">布尔玛的</strong>网站上窃取<strong class="jx hv">盒子媒体</strong>示例。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="e9c4" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/>import { Link } from 'react-router-dom'<br/>import * as Markdown from 'react-markdown'<br/>import moment from 'moment'</span><span id="e5a2" class="kr ks hu mw b fv nh nb l nc nd">const BlogItem = (props) =&gt; (<br/>  &lt;div className="box"&gt;<br/>    &lt;article className="media"&gt;<br/>      &lt;div className="media-left"&gt;<br/>        &lt;figure className="image is-64x64"&gt;<br/>          &lt;img src={props.icon} alt="Image" /&gt;<br/>        &lt;/figure&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="media-content"&gt;<br/>        &lt;div className="content"&gt;<br/>    <br/>          &lt;h1&gt;{props.title}&lt;/h1&gt;<br/>          &lt;Markdown source={props.content.split(" ").splice(0,150).join(" ").concat('...')} /&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="level"&gt;<br/>          &lt;div className="level-left"&gt;<br/>            &lt;Link className="level-item button is-small is-link is-outlined" to={props.path}&gt;Read More&lt;/Link&gt;<br/>          &lt;/div&gt;<br/>        &lt;div className="level-right"&gt;<br/>          &lt;p className="level-item has-text-link is-size-7"&gt;</span><span id="1d92" class="kr ks hu mw b fv nh nb l nc nd">            {moment(props.date).calendar(null, {<br/>              sameDay: '[Today]',<br/>              lastDay: '[Yesterday]',<br/>              lastWeek: '[Last] dddd',<br/>              sameElse: 'MMM Do YYYY'<br/>            })}<br/>          &lt;/p&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/article&gt;<br/>&lt;/div&gt;<br/>)</span><span id="22e1" class="kr ks hu mw b fv nh nb l nc nd">export default BlogItem</span></pre><p id="92b3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">是的，就是这样，但它有点忙，公平地说，我认为这与整页博客文章有一些重叠</p><h1 id="d8b1" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">创建BlogPost页面并清理BlogItem</h1><p id="6879" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">嗯……如果你没记错的话，在我们的上一篇文章中，路由使用了一个静态的<code class="eh ne nf ng mw b">&lt;Switch&gt;</code>组件。但是我们不想对我们的每一篇博客文章都进行硬编码，那样会破坏使用Contentful作为CMS的目的。</p><p id="ef60" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对我们来说幸运的是，<strong class="jx hv"> react-router-dom </strong>已经提前计划好了，并允许我们有路径参数。在<code class="eh ne nf ng mw b">Router.js</code>中添加新路线</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="4a87" class="kr ks hu mw b fv na nb l nc nd">&lt;Switch&gt;<br/>  &lt;Route exact path='/' component={Home}/&gt;<br/>  &lt;Route <strong class="mw hv">exact</strong> path='/blog' component={Blog}/&gt;<br/>  <strong class="mw hv">&lt;Route path='/blog/:blogPost' component={BlogPost}/&gt;</strong><br/>&lt;/Switch&gt;</span></pre><blockquote class="ma mb mc"><p id="e602" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="hu">重要:</em> </strong> <em class="hu">这一条花了我一分钟才图出我们的但是你</em> <strong class="jx hv"> <em class="hu">能</em> </strong> <em class="hu"> </em> <strong class="jx hv"> <em class="hu">不能</em> </strong> <em class="hu">在参数名里包含一个</em> <strong class="jx hv"> <em class="hu">破折号</em> </strong> <em class="hu"> (-)。我最初有</em> <code class="eh ne nf ng mw b"><em class="hu">:blog-post</em></code> <em class="hu">并且不明白为什么它看起来工作正常，但是它</em> <strong class="jx hv"> <em class="hu">不是</em> </strong> <em class="hu">。</em></p><p id="9ddd" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><em class="hu">另外需要注意的是，需要在</em> <strong class="jx hv"> <em class="hu">博客路径</em> </strong> <em class="hu">中添加</em> <strong class="jx hv"> <em class="hu">确切的</em> </strong> <em class="hu">，否则会先匹配</em> <code class="eh ne nf ng mw b"><em class="hu">/blog</em></code> <em class="hu">路线。</em></p></blockquote><p id="815f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">更新我们的<code class="eh ne nf ng mw b">BlogItem.js</code>中的<code class="eh ne nf ng mw b">&lt;Link …&gt;</code>，将/blog/放在我们的路径前面</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="5bf3" class="kr ks hu mw b fv na nb l nc nd">&lt;Link className="level-item button is-small is-link is-outlined"<br/>  <strong class="mw hv">to={{<br/>    pathname: `/blog/${props.path}`,<br/>    state: { props }<br/>  }}</strong><br/>&gt;<br/>  Read More<br/>&lt;/Link&gt;</span></pre><p id="b895" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是在测试之前，我们需要创建一个BlogPost页面。现在，让我们只做一些简单的<pre>显示，这样我们可以确保我们将数据发送到博客文章中</pre></p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="3cba" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'</span><span id="e2a7" class="kr ks hu mw b fv nh nb l nc nd">const BlogPost = (props) =&gt; (<br/>  &lt;h1&gt;Blog Post&lt;/h1&gt;  <br/>  &lt;pre&gt;{JSON.stringify(props, null, 2)}&lt;/pre&gt;<br/>)</span><span id="76a2" class="kr ks hu mw b fv nh nb l nc nd">export default BlogPost</span></pre><p id="976c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，当我们从博客页面导航到我们的博客文章时，我们应该在我们的<code class="eh ne nf ng mw b">&lt;pre&gt;</code>中看到一个巨大的对象，并且历史对象包含我们的状态，也就是我们的博客文章。</p><h2 id="ac51" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">设置博客页面</h2><p id="a48d" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">好吧，在你读到这里并愤怒地说我完全不知道自己在做什么之前，这不是最好的方式，这样的对象分解方式也不是最佳实践。这将在我的下一个教程中全部转移到Redux，这将是一个更干净的解决方案。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="3210" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/>import { Link } from 'react-router-dom'<br/>import moment from 'moment'<br/>import * as Markdown from 'react-markdown'<br/>import PageContent from './../components/PageContent'</span><span id="d292" class="kr ks hu mw b fv nh nb l nc nd">const BlogPost = ({ location: { state: { props } }}) =&gt; {</span><span id="40f5" class="kr ks hu mw b fv nh nb l nc nd">  return (<br/>    &lt;PageContent&gt;<br/>      &lt;nav className="level"&gt;<br/>        &lt;div className="level-left"&gt;<br/>          &lt;Link className="level-item button is-small is-link is-outlined" to="/blog"&gt;Back to Blog&lt;/Link&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="level-right"&gt;<br/>          &lt;p className="level-item has-text-link is-size-7"&gt;    {moment(props.date).calendar(null, {<br/>  sameDay: '[Today]',<br/>  lastDay: '[Yesterday]',<br/>  lastWeek: '[Last] dddd',<br/>  sameElse: 'MMM Do YYYY'<br/>})}<br/>          &lt;/p&gt;<br/>        &lt;/div&gt;<br/>      &lt;/nav&gt;<br/>      &lt;article className="media"&gt;<br/>        &lt;div className="media-left"&gt;<br/>          &lt;figure className="image is-64x64"&gt;<br/>            &lt;img src={props.icon} alt="Image" /&gt;<br/>          &lt;/figure&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="media-content"&gt;<br/>          &lt;div className="content"&gt;<br/>            &lt;h1&gt;{props.title}&lt;/h1&gt;<br/>            &lt;Markdown source={props.content} /&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/article&gt;<br/>    &lt;/PageContent&gt;<br/>  )<br/>}</span><span id="b768" class="kr ks hu mw b fv nh nb l nc nd">export default BlogPost</span></pre><h2 id="c85f" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">清理重叠部分</h2><p id="99bc" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">现在我们可以查看我们的<code class="eh ne nf ng mw b">BlogItem.js</code>和<code class="eh ne nf ng mw b">BlogPost.js</code>并找出重叠的代码，使它们成为漂亮的小组件。</p><p id="4d53" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们的两个页面都包含带有图标和底部的内容部分以及日期部分，但是，按钮和日期部分在两个页面上的不同位置。</p><p id="a707" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们首先为我们的新组件创建一个文件夹。这些是<strong class="jx hv">博客</strong>的共享组件，所以在博客文件夹中创建一个<code class="eh ne nf ng mw b">shared</code>文件夹，然后创建两个文件<code class="eh ne nf ng mw b">BlogContent.js</code>和<code class="eh ne nf ng mw b">BlogNav.js</code></p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="83a0" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/>import { Link } from 'react-router-dom'<br/>import moment from 'moment'</span><span id="76da" class="kr ks hu mw b fv nh nb l nc nd">const BlogNav = ({ to, date }) =&gt; (<br/>  &lt;nav className="level"&gt;<br/>    &lt;div className="level-left"&gt;<br/>      &lt;Link className="level-item button is-small is-link is-outlined" to={to}&gt;Back to Blog&lt;/Link&gt;<br/>    &lt;/div&gt;<br/>    &lt;div className="level-right"&gt;<br/>      &lt;p className="level-item has-text-link is-size-7"&gt;<br/>        {moment(date).calendar(null, {<br/>          sameDay: '[Today]',<br/>          lastDay: '[Yesterday]',<br/>          lastWeek: '[Last] dddd',<br/>          sameElse: 'MMM Do YYYY'<br/>        })}<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/nav&gt;<br/>)</span><span id="3e2b" class="kr ks hu mw b fv nh nb l nc nd">export default BlogNav</span></pre><p id="6ffa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">和</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="0d07" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/>import * as Markdown from 'react-markdown'</span><span id="4d1b" class="kr ks hu mw b fv nh nb l nc nd">const BlogContent = (props) =&gt; (<br/>  &lt;article className="media"&gt;<br/>    &lt;div className="media-left"&gt;<br/>      &lt;figure className="image is-64x64"&gt;<br/>        &lt;img src={props.icon} alt="Image" /&gt;<br/>      &lt;/figure&gt;<br/>    &lt;/div&gt;<br/>    &lt;div className="media-content"&gt;<br/>      &lt;div className="content"&gt;<br/>        &lt;h1&gt;{props.title}&lt;/h1&gt;<br/>        &lt;Markdown<br/>          source={<br/>            props.limit<br/>            ? props.content.split(" ").splice(0,props.limit).join(" ").concat('...')<br/>            : props.content<br/>          }<br/>        /&gt;<br/>      &lt;/div&gt;<br/>      { props.children }<br/>    &lt;/div&gt;<br/>  &lt;/article&gt;<br/>)</span><span id="b982" class="kr ks hu mw b fv nh nb l nc nd">export default BlogContent</span></pre><p id="5de8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh ne nf ng mw b">BlogContent.js</code>中，我们不会总是使用<code class="eh ne nf ng mw b"><strong class="jx hv">props.children</strong></code>，但是我们想把它放在那里，这样我们就可以把导航放在<code class="eh ne nf ng mw b">BlogItems.js</code>的那个位置。你会看到…</p><p id="df54" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，让我们更新我们的<code class="eh ne nf ng mw b">BlogItem.js</code>和<code class="eh ne nf ng mw b">BlogPost.js</code>。这会让你大吃一惊的。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="cd40" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/>import BlogNav from './shared/BlogNav'<br/>import BlogContent from './shared/BlogContent'</span><span id="f6c2" class="kr ks hu mw b fv nh nb l nc nd">const BlogItem = (props) =&gt; (<br/>  &lt;div className="box"&gt;<br/>    &lt;BlogContent limit={150} {...props }&gt;<br/>      &lt;BlogNav date={props.date} to={{<br/>        pathname: `/blog/${props.path}`,<br/>        state: { props }<br/>      }} /&gt;<br/>    &lt;/BlogContent&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="ec81" class="kr ks hu mw b fv nh nb l nc nd">export default BlogItem</span></pre><blockquote class="ma mb mc"><p id="1865" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><em class="hu">注意我们是如何在这个代码片段中包装</em><strong class="jx hv"><em class="hu">BlogNav</em></strong><em class="hu">的，但在下一个代码片段中却没有。这就是</em> <strong class="jx hv"> <em class="hu">道具</em> </strong> <em class="hu">的用处。</em></p></blockquote><p id="e99b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">和</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="4b7d" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'<br/>import PageContent from './../components/PageContent'<br/>import BlogNav from './shared/BlogNav'<br/>import BlogContent from './shared/BlogContent'</span><span id="14c3" class="kr ks hu mw b fv nh nb l nc nd">const BlogPost = ({ location: { state: { props } }}) =&gt; (<br/>  &lt;PageContent&gt;<br/>    &lt;BlogNav date={props.date} to="/blog" /&gt;<br/>    &lt;BlogContent {...props } /&gt;<br/>  &lt;/PageContent&gt;<br/>)</span><span id="e698" class="kr ks hu mw b fv nh nb l nc nd">export default BlogPost</span></pre><p id="65d3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那就<strong class="jx hv"> <em class="ls">这样</em> </strong>好多了！</p><h1 id="9dc2" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">状态标签</h1><p id="882d" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">在我的例子中，我包含了一个状态标签，这样我可以将我的帖子标记为进行中或已存档或其他</p><p id="8731" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你还不知道，但我确实计划在其他地方使用它，所以我们将把它添加到<code class="eh ne nf ng mw b">src/components</code>文件夹中。创建一个名为<code class="eh ne nf ng mw b">StatusTag.js</code>的文件。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="9bcd" class="kr ks hu mw b fv na nb l nc nd">import React from 'react'</span><span id="277f" class="kr ks hu mw b fv nh nb l nc nd">const StatusTag = ({status}) =&gt; {<br/>  switch(status) {<br/>    case 'IN_PROGRESS':<br/>      return (&lt;span className="tag is-small is-warning" style={{ marginRight: 20 }}&gt;In Progress&lt;/span&gt;)<br/>    case 'ARCHIVED':<br/>      return (&lt;span className="tag is-small is-danger" style={{ marginRight: 20 }}&gt;Archived&lt;/span&gt;)<br/>    default:<br/>      return (&lt;span&gt;&lt;/span&gt;)<br/>  }<br/>}</span><span id="d042" class="kr ks hu mw b fv nh nb l nc nd">export default StatusTag</span></pre><p id="4653" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">回到我们的<code class="eh ne nf ng mw b">BlogNav.js</code>，让我们在日期旁边添加StatusTag。还有别忘了导入。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="a5de" class="kr ks hu mw b fv na nb l nc nd"><strong class="mw hv">import StatusTag from './../../components/StatusTag'</strong></span><span id="cf2c" class="kr ks hu mw b fv nh nb l nc nd">const BlogNav = ({ to, date, <strong class="mw hv">status</strong> }) =&gt; (<br/>  &lt;nav className="level"&gt;<br/>    &lt;div className="level-left"&gt;<br/>      &lt;Link className="level-item button is-small is-link is-outlined" to={to}&gt;Back to Blog&lt;/Link&gt;<br/>    &lt;/div&gt;<br/>    &lt;div className="level-right"&gt;<br/>      <strong class="mw hv">&lt;StatusTag status={status} /&gt;</strong><br/>      &lt;p className="level-item has-text-link is-size-7"&gt;<br/>        {moment(date).calendar(null, {<br/>          sameDay: '[Today]',<br/>          lastDay: '[Yesterday]',<br/>          lastWeek: '[Last] dddd',<br/>          sameElse: 'MMM Do YYYY'<br/>        })}<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/nav&gt;<br/>)</span></pre><p id="2e83" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们需要更新使用<code class="eh ne nf ng mw b">&lt;BlogNav … &gt;</code>组件的地方。</p><pre class="jk jl jm jn fq mv mw mx my aw mz dt"><span id="b3bc" class="kr ks hu mw b fv na nb l nc nd">&lt;BlogNav date={props.date} <strong class="mw hv">status={props.status}</strong> to="/blog" /&gt;</span></pre><p id="babf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们有了一个漂亮的小标签，这样我们可以让我们的读者知道我们仍在研究这篇文章。</p><h1 id="a01e" class="mg ks hu bd kt mh mi mj kx mk ml mm lb ja mn jb le jd mo je lh jg mp jh lk mq dt translated">让我们回顾一下</h1><ul class=""><li id="3574" class="nl nm hu jx b jy lm kb ln ke ob ki oc km od kq nq nr ns nt dt translated">我们学习了Contentful并注册了一个账户</li><li id="b2dc" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">创建内容丰富的内容</li><li id="0905" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">将Contentful连接到我们的应用程序</li><li id="c958" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">创建了博客订阅源页面</li><li id="079a" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">创建了博客订阅源项目</li><li id="ca5f" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">创建了一个博客文章页面</li><li id="333a" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">将我们的内容更新为现实内容</li><li id="fb82" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">设置React将Markdown呈现为Html</li><li id="eddc" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">重构我们的代码，使其更加简洁</li><li id="5e33" class="nl nm hu jx b jy nu kb nv ke nw ki nx km ny kq nq nr ns nt dt translated">添加了博客状态标签</li></ul><p id="02fa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，我们有了基本的博客，如果你想的话，你可以从今天开始使用</p><blockquote class="ma mb mc"><p id="a94e" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><strong class="jx hv">下一步</strong> — <a class="ae lr" href="https://medium.com/p/ceadbaf785c7/edit" rel="noopener">将您的培养基进料导入React </a></p></blockquote></div></div>    
</body>
</html>