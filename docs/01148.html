<html>
<head>
<title>How to continuously deploy your Laravel application on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在AWS上持续部署您的Laravel应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-continuously-deploy-your-laravel-application-on-aws-7fc0f39c558e?source=collection_archive---------7-----------------------#2018-02-05">https://medium.com/hackernoon/how-to-continuously-deploy-your-laravel-application-on-aws-7fc0f39c558e?source=collection_archive---------7-----------------------#2018-02-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d4b23a9ece18c1623adc86943b0a14dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YycpUVzoFYnLi_OvlYVQtw.png"/></div></div></figure><p id="2a1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使是很小的事情，自动化也有非常强大的力量。我们有时认为自动化就像简单的数学计算一样，即每天节省给定次数的分钟/秒，但复合效应要大得多。</p><p id="0440" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于您将为您的部署设置更多的自动化，您将遇到并解决比每周节省几分钟更重要的问题。</p><p id="eabf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自动化一劳永逸地解决了文档化的问题。您的部署过程将变成<em class="ka">基础设施即代码</em>和<em class="ka">配置即代码</em>，这些是最好的文档。如果您使用声明式框架，如CloudFormation和Terraform，您将有效地在代码中提交漂亮的HCL、YAML或JSON文件和docker文件，分别描述您的基础设施和配置的状态。</p><p id="3368" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自动化迫使你加强安全性。您会发现，您以前的手动过程依赖于比所需权限更多的凭证或密钥，并且您仍然没有像您说的那样创建部署密钥。您将不会允许您的自动化脚本进行这样的许可访问，因此您将最终为它设置适当的凭证和权限，这将使您的基础结构更加安全。</p><p id="3f49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自动化是你有效发展技术团队的唯一途径。自动化程度越高，流程就越标准。你将会用诸如Docker、Terraform、Kubernetes、Consul等广为人知的技术以及它们的设计模式来取代你的零散脚本。这意味着您可以快速构建它们并将其移交给新的开发人员。你可以忘记它们，几个月后再来处理，大脑不会冻结。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="ce8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ki" href="https://hackernoon.com/tagged/laravel" rel="noopener ugc nofollow" target="_blank"> Laravel </a>的上下文中，我已经发布了<a class="ae ki" href="https://hackernoon.com/laravel-on-aws-a-reference-architecture-a680755130d0" rel="noopener ugc nofollow" target="_blank">一个用于<a class="ae ki" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>的参考架构</a>，也作为开源<em class="ka">基础设施即代码</em>堆栈发布，我想在这里用持续部署(下面的CD)来扩充它。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="4e81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有许多方法可以在AWS上实现CD，下面是一个首选的解决方案。我们将使用CodeBuild来构建Docker映像，使用CodeCommit来检测源代码更改，最后使用CodePipeline来编排构建并交换ECS上的生产容器。<br/>我们遇到的第一个问题是，CodePipeline只与GitHub、CodeCommit或S3集成。我建议使用CodeCommit作为入口点，这样您就可以处理两个工作流:<br/> a .直接从开发人员机器上用<code class="eh kp kq kr ks b">git push</code>触发重新部署(对于预生产或修补程序)<br/> b. <a class="ae ki" rel="noopener" href="/@jay_proulx/aws-codecommit-from-atlassian-bitbucket-and-bitbucket-pipelines-for-ci-offloading-4f1131695802">通过让您的CI在测试通过时触发<em class="ka"> git push </em>进行CodeCommit，与任何CI </a> (Bitbucket Pipelines、GitLab CI、CodeShip等)集成。</p><p id="4571" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">这是我用来在AWS上部署客户的Laravel应用程序的程序。希望这能对你的部署有所帮助。如果您的用例更复杂，我会提供持续的支持包，从指导您的开发人员到亲手在AWS上构建应用程序。在hi@getlionel.com给我打电话</em></p><p id="59fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 1。设置代码提交并推送您的Laravel代码</strong></p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kt ko l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">It could not be simpler to get a Git repository on AWS!</figcaption></figure><p id="3980" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是创建存储库所需的全部内容。你可以在这里找到<a class="ae ki" href="https://gist.github.com/li0nel/e60f1650122621013f5cfbfae3ffde3d" rel="noopener ugc nofollow" target="_blank">完整的CloudFormation模板，它将有效地授权代码管道访问存储库。</a></p><p id="f511" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同时，运行这些命令登录到存储库并发布您的Laravel项目:</p><pre class="kj kk kl km fq ky ks kz la aw lb dt"><span id="ac93" class="lc ld hu ks b fv le lf l lg lh"><em class="ka">$ git remote add codecommit CODE_COMMIT_URL</em></span></pre><p id="8aa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过将AWS命令行凭据帮助器添加到Git config:</p><pre class="kj kk kl km fq ky ks kz la aw lb dt"><span id="f82b" class="lc ld hu ks b fv le lf l lg lh"><em class="ka">$ git config --global credential.helper ‘!aws codecommit credential-helper $@’</em></span><span id="3510" class="lc ld hu ks b fv li lf l lg lh"><em class="ka">$ git config --global credential.UseHttpPath true</em></span></pre><p id="1430" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您可以将代码提交到CodeCommit。</p><pre class="kj kk kl km fq ky ks kz la aw lb dt"><span id="6ca1" class="lc ld hu ks b fv le lf l lg lh"><em class="ka">git push codecommit YOUR_BRANCH:master</em></span></pre><blockquote class="lj lk ll"><p id="a593" class="jc jd ka je b jf jg jh ji jj jk jl jm lm jo jp jq ln js jt ju lo jw jx jy jz hn dt translated">如果您使用的是OSX，后续的git推送可能会失败，因为OSX会缓存AWS凭据帮助器生成的短期凭据。您需要搜索您的钥匙串并删除git-codecommit-*的任何条目。<br/>此后，在手动推送git后，当OSX提示时，记得拒绝访问OSX钥匙链。</p></blockquote><p id="f1cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。安装代码构建</strong></p><p id="d610" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的CodeBuild项目中，我们定义了在CodeBuild克隆了我们的存储库之后要运行的命令。命令类似于您在<em class="ka">bit bucket-pipelines . yml</em>或<em class="ka"> gitlab-ci.yml </em>中编写的内容:假设您可以定义您的环境(操作系统和预安装的工具)，并且您位于项目的根目录中。<br/>这里我们用的是Ubuntu 14.04，安装了Docker、Python和Compose。我们将安装node、npm和gulp来编译我们的前端资产。</p><p id="ced9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">预构建步骤构建Docker存储库URL，我们将使用它来标记我们的图像。构建命令是一个简单的<code class="eh kp kq kr ks b">docker build</code>，构建后命令是一个或多个<code class="eh kp kq kr ks b">docker push</code>。暂时忽略最后一个后期构建命令。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kt ko l"/></div></figure><p id="b95b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3。设置代码管道并触发ECS零停机重新部署</strong></p><p id="720e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里是我们连接所有点的地方。到目前为止，我们已经有了一个CodeCommit存储库、一个CodeBuild项目，并且我们的ECS集群运行良好。我们使用一个代码管道项目来连接它们。在您的AWS控制台中，它将如下所示:</p><figure class="kj kk kl km fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/974a20548e7459c3734aa18f2eb6ec18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgOucKm6vGzhk07Xg8sNVQ.png"/></div></div></figure><p id="0527" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对CodeCommit的<code class="eh kp kq kr ks b">master</code>分支的每次提交都会触发我们的代码管道项目。我们定义的CodeBuild命令将构建我们的Docker映像，并将它们推送到我们的ECR注册表，最后，管道的最后一步将重新部署我们的应用程序。</p><blockquote class="lj lk ll"><p id="7f41" class="jc jd ka je b jf jg jh ji jj jk jl jm lm jo jp jq ln js jt ju lo jw jx jy jz hn dt translated">我们通过重新定义ECS任务定义的Docker图像URL来重新部署我们的应用程序</p></blockquote><p id="edf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于<em class="ka">部署</em>步骤，CodePipeline依赖于一个<em class="ka">图像定义文件</em>。它是我们在CodeBuild的后构建阶段创建的JSON文件，描述了应该如何更新我们的ECS集群的任务定义。如果群集有足够的容量，ECS将启动新容器，等待报告它们运行状况良好，然后关闭旧容器，有效地实现零停机部署。</p><p id="49bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的多容器应用程序来说，这个JSON文件看起来像这样，它可以很容易地用<code class="eh kp kq kr ks b">bash</code>和<code class="eh kp kq kr ks b">printf</code>来构建:</p><pre class="kj kk kl km fq ky ks kz la aw lb dt"><span id="6488" class="lc ld hu ks b fv le lf l lg lh">[<br/>    {<br/>        "name": "laravel",<br/>        "imageUri": "YOUR_ECR_URL_FOR_LARAVEL:COMMIT_ID"<br/>    },<br/>    {<br/>        "name": "nginx",<br/>        "imageUri": "YOUR_ECR_URL_FOR_NGINX:COMMIT_ID"<br/>    }<br/>]</span></pre><p id="5162" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，这就是为什么我们用不同的标签标记新构建的Docker映像:ECS现在可以获取TaskDefinition更新，并强制将新映像拖到我们的容器实例中。</p><p id="de0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ECS将使用ECS服务的<code class="eh kp kq kr ks b">MinimumHealthyPercent</code>和<code class="eh kp kq kr ks b">MaximumPercent</code>设置以及当前的额外集群容量(内存和CPU)来协调重新部署。如果您的TaskDefinition的一个新实例有额外的容量，而您的应用程序还没有达到允许的<code class="eh kp kq kr ks b">MaximumPercent</code>，那么ECS将启动您的TaskDefinition的另一个实例，并按此顺序删除旧的实例。在另一种情况下，它可能会以相反的顺序交换它们，造成停机。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kt ko l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">The CodePipeline CloudFormation template</figcaption></figure><p id="52a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望它能帮助您在部署中建立更多的自动化。我还期待着下个ECS特性的发布，预计在这个月发布:通过将您的微服务注册到Route53的DNS自动服务发现。如果你是第一个实现它的人，请在下面评论！</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="3b89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">莱昂内尔是总部位于伦敦的初创公司Wi5的首席技术官，也是面向未来的工程文化课程<a class="ae ki" href="https://hackernoon.com/why-the-platform-model-is-broken-a51478b1b4ee" rel="noopener ugc nofollow" target="_blank"><em class="ka"/></a><em class="ka">的作者。你可以在</em><a class="ae ki" href="https://getlionel.com" rel="noopener ugc nofollow" target="_blank"><em class="ka"/></a>上联系他</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure></div></div>    
</body>
</html>