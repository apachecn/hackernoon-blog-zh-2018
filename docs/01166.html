<html>
<head>
<title>The Science of Software Estimation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件评估的科学</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/science-of-software-estimation-99abdf5d263?source=collection_archive---------25-----------------------#2018-02-05">https://medium.com/hackernoon/science-of-software-estimation-99abdf5d263?source=collection_archive---------25-----------------------#2018-02-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/10c0d34e46c9f0be14c4d5f0f28097c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZAHZ7GvucYj1KFHSiPEpw.jpeg"/></div></div></figure><div class=""/><p id="c8ef" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">估算软件开发的工作量是一件棘手的事情，经常会成为团队中的争论点。我见过团队花一整天的时间来计划2周的冲刺，解决每项任务的每个细节。在几次冲刺之后，他们对他们团队的“速度”有了一些感觉，并且可以预测他们的团队在一次冲刺中能交付多少工作。我也看到过这样的团队，开发人员随意地聚在一起，承担主要功能，给出粗略的日期，并且远远超过他们的截止日期。</p><p id="ec0b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不能提出一个通用的评估过程，因为它高度依赖于业务的性质、团队规模、文化等。坦白地说，我甚至不知道最佳流程是什么样的。相反，我将分享一些适用于任何开发团队的常见陷阱和最佳实践。这对于开发者和产品所有者都是有用的读物。</p><h1 id="92c7" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">这不仅仅是关于代码</h1><p id="0b5a" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当被要求对提议的变更进行快速评估时，开发人员通常会这样想:</p><ul class=""><li id="69ad" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">在脑海中勾勒出代码库的画面(模型、它们之间的关系等)。)</li><li id="54f0" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">衡量代码库的哪些部分需要更改</li><li id="dc8a" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">把做出改变所需的时间加起来，然后脱口而出</li></ul><p id="64fe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是有缺陷的，因为它只考虑了<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>所需的时间。测试、部署、文档编制和监控所需的工作呢？即使对于中等大小的特性，花在这些方面的时间也常常超过编程时间。我建议在评估之前考虑以下事情:</p><ul class=""><li id="5a34" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">测试这种变化有多容易/多难</li><li id="1e74" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">我们需要努力记录和交流变化吗</li><li id="b172" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">它是否需要任何基础架构工作，如数据迁移、启动新的应用程序/数据库、设置监控/警报</li><li id="857d" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">它需要迭代来实现预期的业务成果吗？例如，你的应用程序中只有搜索功能是不够的，我们至少需要几次迭代才能让它适合大多数查询</li></ul><h1 id="04a2" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">估计未知数=玩轮盘赌</h1><p id="a099" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当我们知道需要做什么的时候，我们有高估不熟悉领域的工作和低估努力的自然倾向。虽然这是自然的，但不是最佳的。它在未知领域失败的方式是，整个估计函数变成不熟悉程度乘以感知工作量。没有更好的方法来解决这个问题吗？</p><p id="4838" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最理想的回答是，“我现在不知道，但我可以花几个小时给你一个合理的估计”。对这个问题的快速研究可以让你对这个景观有一个很好的了解。比如有哪些可用的APIs库/工具，它们是否适合您的问题。此时，你不需要知道每一个细节，但足以承诺一种方法，并在此基础上评估工作。</p><p id="55ea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">稍后，您可能会遇到未知的未知，可能需要更改解决方案。但这仍将是一个比仅仅基于不熟悉的情况更好的估计。你花的研究时间也没有浪费，因为当你开始做这项工作时，你必须做一些版本的研究。</p><h1 id="74c0" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">双赢往往存在</h1><p id="e744" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我见过开发人员和产品所有者完全围绕时间进行谈判。如果谈话深入一点，他们会讨论为什么要花这么长时间，会有很多好处。通常，您会意识到一些好的用例需要花费80%的时间，并且可以与核心功能分离。那是双赢的。</p><p id="95fe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对产品所有者来说，这也有一个无形的好处。当你倾听为什么这需要时间时，你就建立了开发人员的同情心。当你为问题提供聪明的解决方案时，你在他们(极客)的世界里赢得了尊重。这导致更多的开发人员参与进来，并愿意不遗余力地为您构建正确的东西&amp;产品。</p><h1 id="bbda" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">分解，分离，但不要过度</h1><p id="e2d3" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">假设您想在应用程序中构建某种实时提要。现在，您需要一种将内容从服务器推送到客户端(websocket等)的方法。)和此提要的快速访问存储(可能是Redis缓存)。现在，您应该将这两种工作分离开来，能够独立思考它们并独立评估工作量。</p><blockquote class="ls"><p id="6e82" class="lt lu if bd lv lw lx ly lz ma mb jz ek translated">如果你没有足够的分离，它就会变成一个大杂烩，一个混乱思维的滋生地。需要明确您将如何解决问题。需要哪些x、y、z元素，以及它们将如何很好地配合使用。没有这种清晰度，我们只是在黑暗中拍摄。对你的解决方案有错误是可以的，但你至少需要一个有效的理论来做出合理的估计。</p></blockquote><p id="f108" class="pw-post-body-paragraph jc jd if je b jf mc jh ji jj md jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">现在不要走到另一个极端，浪费时间在尽可能低的粒度上分解东西。这是估算精度边际改善所花费的大量时间。经验法则是，如果团队中的大多数人只看到任务的一行描述，就知道需要构建什么以及如何构建，那么就可以在这个粒度级别上进行评估。</p><p id="ce71" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到噪音的性质，有些人通常会质疑评估本身的益处。我认为，作为一个企业/产品所有者，知道我的团队在产品中构建X、Y、Z需要多长时间是非常重要的。这是设计战略的关键投入。</p><p id="bf52" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我所有的建议。下次您进行评估时，请停下来，想想其中的一些技巧。在评论区分享你的想法，如果你喜欢阅读，请关注我的博客。</p><p id="831c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://blog.amirathi.com/author/amirrathi/" rel="noopener ugc nofollow" target="_blank">查看阿米特·拉提的所有帖子</a></p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><p id="e829" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mo">原载于2018年2月5日</em><a class="ae ka" href="https://blog.amirathi.com/2018/02/05/science-of-software-estimation/" rel="noopener ugc nofollow" target="_blank"><em class="mo">【blog.amirathi.com】</em></a><em class="mo">。</em></p><figure class="mp mq mr ms fq hw"><div class="bz el l di"><div class="mt mu l"/></div></figure></div></div>    
</body>
</html>