<html>
<head>
<title>Java libraries with Kotlin. The case of dependency injection frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin的Java库。依赖注入框架的例子</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/java-libraries-with-kotlin-the-case-of-dependency-injection-frameworks-3366f1d6cf48?source=collection_archive---------14-----------------------#2018-02-06">https://medium.com/hackernoon/java-libraries-with-kotlin-the-case-of-dependency-injection-frameworks-3366f1d6cf48?source=collection_archive---------14-----------------------#2018-02-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/3b31b70d66a3a84583e796b4d72f1342.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*UkCzrXrdLows5zin4pTwWA.jpeg"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek"><a class="ae jc" href="https://www.flickr.com/photos/the-money-pit/5900474232" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/the-money-pit/5900474232</a></figcaption></figure><p id="d966" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">科特林为我们打开了一个新的世界。在<a class="ae jc" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>世界中，开发人员编写的代码比以前少了。Kotlin与Java的互操作性使得它很容易集成到现有的和新的应用程序中，同时仍然可以自由使用我们最喜欢的Java库。</p><p id="8740" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">然而，由于这些库是用Java编写的，在Kotlin中使用它们通常会产生类似Java的语法。这并不意味着我们需要重新发明轮子，写一个库的Kotlin版本(这是我现在经常看到的)。但也许我们可以在它周围写一些科特林层。</p><p id="f68c" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">一个很好的例子是<a class="ae jc" href="https://github.com/nhaarman/mockito-kotlin" rel="noopener ugc nofollow" target="_blank">科特林·莫克托</a>由<a class="kb kc gr" href="https://medium.com/u/fceb7a60a849?source=post_page-----3366f1d6cf48--------------------------------" rel="noopener" target="_blank">尼克·哈尔曼</a>创作，它去除了科特林中使用莫克托的丑陋——这是非常需要的</p><p id="effb" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">通常情况并不像莫奇托那样糟糕，所以我们继续前进。但是我们不应该！我们应该深呼吸，看看我们是否能改善它。</p><p id="f24e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">说到依赖注入，我并不是Dagger的最大粉丝，因为设置它需要大量的样板代码。此外，它不太适合测试。对我来说，测试首先是依赖注入的原因之一。所以我喜欢<a class="ae jc" href="https://github.com/stephanenicolas/toothpick" rel="noopener ugc nofollow" target="_blank">牙签</a>的做法。最初是开源英雄<a class="ae jc" href="https://github.com/stephanenicolas" rel="noopener ugc nofollow" target="_blank">夏羽·尼古拉斯</a>和他的同事<a class="kb kc gr" href="https://medium.com/u/fd44c33f845d?source=post_page-----3366f1d6cf48--------------------------------" rel="noopener" target="_blank">丹尼尔·莫利内罗·雷古拉</a>在Groupon(一款拥有数千万下载量的应用程序)的一个项目，它在一段时间前被认为是一种依赖注入的新方法，避免了Dagger 1+2的许多样板文件。它的优势之一是测试，它是在考虑测试的情况下构建的。</p><p id="79ca" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">但是在Kotlin项目中使用它让我意识到我需要改进它，因为我的眼睛受伤了。</p><p id="3430" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">让我们看看如何将一些类绑定到一个模块:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="bc4c" class="km kn hu ki b fv ko kp l kq kr">val module = Module()<br/>module.<strong class="ki hv">bind</strong>(Repository::class.<em class="ks">java</em>).<strong class="ki hv">to</strong>(DbRepository::class.<em class="ks">java</em>)    module.<strong class="ki hv">bind</strong>(Scheduler::class.<em class="ks">java</em>).<strong class="ki hv">toInstance</strong>(DefaultScheduler())<br/>module.<strong class="ki hv">bind</strong>(Api::class.<em class="ks">java</em>).<strong class="ki hv">toProviderInstance</strong>(ApiProvider())</span></pre><p id="2432" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">牙签可以将一个类绑定到另一个类或者一个现有的实例，或者一个可以在运行时创建所需类的提供者类。</p><p id="6372" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">让我们先用科特林把它变得更好一点:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="b164" class="km kn hu ki b fv ko kp l kq kr">val module = Module().<em class="ks">apply </em>{<br/>    bind(Repository::class.<em class="ks">java</em>).to(DataBaseRepository::class.<em class="ks">java</em>)<br/>    bind(Scheduler::class.<em class="ks">java</em>).toInstance(DefaultScheduler())<br/>    bind(Api::class.<em class="ks">java</em>).toProviderInstance(ApiProvider())<br/>}</span></pre><p id="0dc0" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">一些应该困扰我们的事情:</p><p id="9702" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><code class="eh kt ku kv ki b">to</code>是一个现有的扩展函数，用于创建<code class="eh kt ku kv ki b">Pair</code>的实例。同一个名字，在这里很容易搞砸，甚至没有注意到。你的绑定可能没有绑定任何东西，只是创建了一个未使用的<code class="eh kt ku kv ki b">Pair</code>实例</p><p id="48c6" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">所以我们需要这样写，以确保得到正确的<code class="eh kt ku kv ki b">to</code>函数:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="dc47" class="km kn hu ki b fv ko kp l kq kr">bind(Repository::class.<em class="ks">java</em>).`to`(DataBaseRepository::class.<em class="ks">java</em>)</span></pre><p id="bf2d" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">很快我们就处于丑陋代码的中心；)</p><p id="0f48" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">所以让我们一步一步来改进。</p><p id="a64a" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">首先:最好不要传递类型，而是使用泛型:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="5a45" class="km kn hu ki b fv ko kp l kq kr">bind&lt;Repository&gt;().`to`(DataBaseRepository::class.<em class="ks">java</em>)</span></pre><p id="1d35" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">为了调用最初的<code class="eh kt ku kv ki b">bind()</code>方法，我们需要java <code class="eh kt ku kv ki b">Class</code>实例。在Kotlin中，如果我们将类型标记为具体化(仅对声明为inline的函数有效，这是有意义的),就有可能从泛型类型中获得这一点</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="2de5" class="km kn hu ki b fv ko kp l kq kr">inline fun &lt;reified T&gt; Module.bind()<br/>      : Binding&lt;T&gt; = bind(T::class.<em class="ks">java)</em></span></pre><p id="1900" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这样，我们在模块中添加了一个新的绑定作为扩展函数。</p><p id="6160" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">但是现在我们有一个空的方法调用。我们应该用它来调用下一个方法。所以让我们建立一个东西，我们可以这样称呼它:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="3b3b" class="km kn hu ki b fv ko kp l kq kr"><em class="ks">bindClass</em>&lt;Repository&gt;(DataBaseRepository::class.<em class="ks">java</em>)</span></pre><p id="8f43" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">也没那么难:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="6577" class="km kn hu ki b fv ko kp l kq kr">import kotlin.to as toPair</span><span id="ab64" class="km kn hu ki b fv kw kp l kq kr">inline fun &lt;reified T&gt; Module.bindClass(target: Class&lt;out T&gt;)<br/>     : Binding&lt;T&gt; = <strong class="ki hv"><em class="ks">bind</em>&lt;T&gt;().<em class="ks">apply </em>{ to(target) }</strong></span></pre><p id="c7bf" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">因此，我们调用刚刚创建的另一个绑定方法，并使用apply在其上添加对()的调用。<br/>导入将kotlin的名称改为function，因此这里不存在冲突。</p><p id="9f0a" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">现在我们还是传Java类版本。我们需要吗？我不这么认为。所以应该是:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="2493" class="km kn hu ki b fv ko kp l kq kr"><em class="ks">bindClass</em>&lt;Repository&gt;(DataBaseRepository::class)</span></pre><p id="dc72" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">实现非常相似。我们只需要拿一个KClass:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="d16b" class="km kn hu ki b fv ko kp l kq kr">inline fun &lt;reified T&gt; Module.bindClass(target: <strong class="ki hv">KClass&lt;out Any&gt;</strong>)<br/>     : Binding&lt;T&gt; = <em class="ks">bind</em>&lt;T&gt;().<em class="ks">apply </em>{ <strong class="ki hv">to(target.<em class="ks">java </em>as Class&lt;T&gt;)</strong> }</span></pre><p id="af53" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">所以这在传递类名时很有效。</p><p id="9651" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">当查看其他变体时，传递一个lambda不是很好吗？</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="391b" class="km kn hu ki b fv ko kp l kq kr"><em class="ks">bindInstance</em>&lt;Scheduler&gt; <strong class="ki hv">{ </strong>DefaultScheduler() <strong class="ki hv">}</strong></span></pre><p id="2684" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这很容易。如果函数的最后一个参数是lambda，则可以使用此语法:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="ec63" class="km kn hu ki b fv ko kp l kq kr">inline fun &lt;reified T&gt; Module.bindInstance(target: <strong class="ki hv">() -&gt; T</strong>)<br/>     : Binding&lt;T&gt; = <em class="ks">bind</em>&lt;T&gt;().<em class="ks">apply </em>{ <strong class="ki hv">toInstance(target())</strong> }</span></pre><p id="cdbd" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这让我想到了下一个想法。当我们使用提供商时，我们正在编写大量样板文件:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="1bbd" class="km kn hu ki b fv ko kp l kq kr">class ApiProvider : Provider&lt;Api&gt; {<br/>    override fun get(): Api {<br/>        return RestApi()<br/>    }<br/>}</span><span id="33f6" class="km kn hu ki b fv kw kp l kq kr">bind(Api::class.<em class="ks">java</em>).toProviderInstance(ApiProvider())</span></pre><p id="77fd" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我们能在这里通过一个lambda吗？</p><p id="c954" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">大概吧！但是让我们一步一步来:</p><p id="9f80" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">应用我们上面所做的将会引导我们:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="c896" class="km kn hu ki b fv ko kp l kq kr"><em class="ks">bindProviderInstance&lt;Api&gt;(ApiProvider())</em></span></pre><p id="ca73" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">实际上，这里可以省略泛型，因为提供者已经定义了泛型，这是<a class="ae jc" href="https://en.wikipedia.org/wiki/Type_inference" rel="noopener ugc nofollow" target="_blank">类型推断</a>的惊人特性。</p><p id="ff54" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">但是我们想要的不是编写提供者，而是像这样编写一个lambda:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="6b96" class="km kn hu ki b fv ko kp l kq kr"><em class="ks">bindProviderInstance</em>&lt;Api&gt;<strong class="ki hv">{ </strong>RestApi() <strong class="ki hv">}</strong></span></pre><p id="f0dd" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">其背后的代码应该是:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="e0f3" class="km kn hu ki b fv ko kp l kq kr">inline fun &lt;reified T&gt; Module.bindProviderInstance(target: <strong class="ki hv">() -&gt; T</strong>)<br/>: Binding&lt;T&gt; = <em class="ks">bind</em>&lt;T&gt;().<em class="ks">apply </em>{ <br/>      toProviderInstance(target.<strong class="ki hv"><em class="ks">asProvider</em>(</strong>)) }</span></pre><p id="ddd3" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">其中<code class="eh kt ku kv ki b">asProvider()</code>是另一个隐藏创建提供者样板文件的扩展方法:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="3e8a" class="km kn hu ki b fv ko kp l kq kr">fun &lt;T&gt; <strong class="ki hv">(() -&gt; T)</strong>.<strong class="ki hv">asProvider</strong>(): Provider&lt;T&gt; {<br/>    return object : Provider&lt;T&gt; {<br/>        override fun get(): T {<br/>            return <strong class="ki hv">invoke</strong>()<br/>        }<br/>    }<br/>}</span></pre><p id="17c7" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">让我们先看看Java风格的所有变化:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="7813" class="km kn hu ki b fv ko kp l kq kr">class ApiProvider : Provider&lt;Api&gt; {<br/>    override fun get(): Api {<br/>        return RestApi()<br/>    }<br/>}<br/>val module = Module()<br/>module.<strong class="ki hv">bind</strong>(Repository::class.<em class="ks">java</em>).<strong class="ki hv">to</strong>(DbRepository::class.<em class="ks">java</em>)    module.<strong class="ki hv">bind</strong>(Scheduler::class.<em class="ks">java</em>).<strong class="ki hv">toInstance</strong>(DefaultScheduler())<br/>module.<strong class="ki hv">bind</strong>(Api::class.<em class="ks">java</em>).<strong class="ki hv">toProviderInstance</strong>(ApiProvider())</span></pre><p id="fe46" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">现在我们的新风格</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="248e" class="km kn hu ki b fv ko kp l kq kr">val module = Module().<em class="ks">apply </em>{<br/>    bind&lt;Repository&gt;(DataBaseRepository::class)<br/>    bindInstance&lt;Scheduler&gt;(DefaultScheduler())<br/>    bindProviderInstance&lt;Api&gt;{ RestApi() }<br/>}</span></pre><p id="58bb" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">虽然<code class="eh kt ku kv ki b">apply()</code>在这里很好，但它经常暗示我们也在开发一个Java类。所以让我们改进一下:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="8926" class="km kn hu ki b fv ko kp l kq kr">val module = module<em class="ks"> </em>{<br/>    bind&lt;Repository&gt;(DataBaseRepository::class)<br/>    bindInstance&lt;Scheduler&gt;(DefaultScheduler())<br/>    bindProviderInstance&lt;Api&gt;{ RestApi() }<br/>}</span></pre><p id="fbdc" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这个定义也很简单。采用在模块上下文中运行的lambda并返回模块的函数模块:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="d2f1" class="km kn hu ki b fv ko kp l kq kr">fun module(bindings: <strong class="ki hv">Module.() -&gt; Binding&lt;*&gt;</strong>) <br/>     <strong class="ki hv">: Module</strong> = Module().<em class="ks">apply </em>{ bindings() }</span></pre><p id="eea0" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如果您只有一个模块，让我们将它放在范围内:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="b118" class="km kn hu ki b fv ko kp l kq kr">val scope = simpleScope(SCOPE)<em class="ks"> </em>{<br/>    bind&lt;Repository&gt;(DataBaseRepository::class)<br/>    bindInstance&lt;Scheduler&gt;(DefaultScheduler())<br/>    bindProviderInstance&lt;Api&gt;{ RestApi() }<br/>}</span></pre><p id="f885" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">其中:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="80c5" class="km kn hu ki b fv ko kp l kq kr">fun simpleScope(scopeName: Any, bindings: Module.() -&gt; Binding&lt;*&gt;?)<br/>   <strong class="ki hv">: Scope</strong> = <strong class="ki hv">openScope(scopeName)</strong>.<em class="ks">apply </em>{ <br/>                                    Module().<em class="ks">apply </em>{ bindings() }}</span></pre><p id="b566" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">所以为Kotlin改进一个为Java设计的API是非常容易的</p><p id="c5d6" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">因为分享是关爱。请随意从<a class="ae jc" href="https://github.com/sporttotal-tv/toothpick-kotlin-extensions" rel="noopener ugc nofollow" target="_blank">这里</a>直接导入所有这些内容。</p><p id="1c2b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">就像我在之前的帖子里说的:如果有什么事情困扰着你，那就去改善它！<a class="ae jc" href="https://twitter.com/hashtag/lifelong?src=hash" rel="noopener ugc nofollow" target="_blank">#终身</a><a class="ae jc" href="https://twitter.com/hashtag/learner?src=hash" rel="noopener ugc nofollow" target="_blank">#学习者</a></p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="kx ky l"/></div></figure></div></div>    
</body>
</html>