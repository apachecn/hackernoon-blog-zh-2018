<html>
<head>
<title>.NET Minimalist Property Based Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。基于. NET极简属性的库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/net-minimalist-property-based-library-cedc1e30a45f?source=collection_archive---------26-----------------------#2018-02-08">https://medium.com/hackernoon/net-minimalist-property-based-library-cedc1e30a45f?source=collection_archive---------26-----------------------#2018-02-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5371" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的不同帖子中，我们探讨了为什么测试对我们如此重要。此外，我们还看了ScalaCheck，它是Scala编程语言的一个基于属性的测试框架。</p><p id="25b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们是探险家，我们已经开始了一个新的冒险，创建一个小的，但功能和易于使用的基于属性的库。基于NET的语言。</p><h1 id="ca4d" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">动机</h1><p id="11d8" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我们想要一个与我们当前的测试框架一起工作的库，在我们的例子中，就是xUnit。通过快速浏览NuGet，我们可以找到一些与我们目标相同的框架，但是它们需要学习整个框架。此外，为了使用它，您可能需要放弃您最喜欢的测试框架。由此产生了许多其他问题，例如为您的IDE提供一个测试运行程序，等等。</p><p id="820c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的库并不打算改变我们今天所做的任何事情，而是允许我们在常规测试中使用基于属性的测试。</p><h1 id="4407" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">核心概念</h1><p id="2056" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">最重要的部分是我们所谓的<strong class="it hv"> <em class="ks"> Gen &lt; T &gt; </em> </strong>，它代表了一种生成T类型的<strong class="it hv"> <em class="ks">有界</em> </strong>数据的方法</p><p id="8b36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最简单的生成器可以通过以下方式创建:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="4fb6" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">var </strong>gen = Gen&lt;<strong class="ky hv">int</strong>&gt;.Empty();</span><span id="ad5a" class="lc jq hu ky b fv lh le l lf lg">Assert.Empty(gen.Generate());</span></pre><p id="ddaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们使用的是<strong class="it hv"> <em class="ks"> xUnit。断言</em> </strong>所以我们根本没有引入任何断言API。</p><p id="81f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们看看创建生成器的其他一些方法。</p><h2 id="725e" class="lc jq hu bd jr li lj lk jv ll lm ln jz jc lo lp kd jg lq lr kh jk ls lt kl lu dt translated">单一项目生成器</h2><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="b5d4" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">var</strong> once = Gen&lt;<strong class="ky hv">int</strong>&gt;.Once(5)</span><span id="0fed" class="lc jq hu ky b fv lh le l lf lg">Assert.Single(Gen&lt;<strong class="ky hv">int</strong>&gt;.Once(5).Generate());</span></pre><h2 id="51a5" class="lc jq hu bd jr li lj lk jv ll lm ln jz jc lo lp kd jg lq lr kh jk ls lt kl lu dt translated">重复生成器</h2><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="37ab" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">var </strong>repeat = Gen&lt;<strong class="ky hv">int</strong>&gt;.Repeat(5, 20);<br/><br/>Assert.True(repeat.Generate().Count() == 20);<br/>Assert.True(repeat.Generate().ToList().TrueForAll(x =&gt; x == 5));</span></pre><p id="24c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们说的是我们要生成<strong class="it hv"> <em class="ks"> 5 </em> </strong>多达<strong class="it hv"> <em class="ks"> 20 </em> </strong>次的值。</p><p id="bc5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的是，调用<code class="eh lv lw lx ky b">.Generate()</code>将总是返回相同的数据集。</p><h2 id="7bda" class="lc jq hu bd jr li lj lk jv ll lm ln jz jc lo lp kd jg lq lr kh jk ls lt kl lu dt translated">可枚举生成器</h2><p id="cdb6" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">一个更有趣的生成器是从<strong class="it hv"><em class="ks">IEnumerable&lt;T&gt;</em></strong>创建的。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2a7a" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">var </strong>enumerableGen = Gen&lt;<strong class="ky hv">int</strong>&gt;.FromEnumerable(Enumerable.Range(1, 100));<br/><br/>Assert.True(enumerableGen.Generate().Count() == 100);</span></pre><p id="936c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过执行以下操作可以生成一个简单的版本:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="878a" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">var </strong>enumerableGen = Enumerable.Range(1, 100).ToGen();<br/><br/>Assert.True(enumerableGen.Generate().Count() == 100);</span></pre><p id="0833" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">发电机本身不能做太多。但是，我们的想法是将它们用作值生成器，以便测试它们的一些属性。</p><h2 id="436c" class="lc jq hu bd jr li lj lk jv ll lm ln jz jc lo lp kd jg lq lr kh jk ls lt kl lu dt translated">生产者</h2><p id="21b4" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">很多时候我们需要一种更健壮的方法来生成数据。一部<strong class="it hv"> <em class="ks">制片人</em> </strong>的本意正是如此。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="41c7" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">public interface </strong>IProducer&lt;<strong class="ky hv">out </strong>T&gt; : IEnumerable&lt;T&gt;<br/>{<br/>  <br/>}</span></pre><p id="b3ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以看到，<strong class="it hv"> <em class="ks"> IProducer </em> </strong>只是一种生成同类型<strong class="it hv"><em class="ks"/></strong>值序列的方式。</p><p id="5a7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用于生成<strong class="it hv"> <em class="ks"> int </em> </strong> s的简单<strong class="it hv"> <em class="ks">生产者</em> </strong>可以是:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="bdfc" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">public class </strong>IntProducer : IProducer&lt;<strong class="ky hv">int</strong>&gt;<br/>{<br/>    <strong class="ky hv">public </strong>IEnumerator&lt;<strong class="ky hv">int</strong>&gt; GetEnumerator()<br/>    {<br/>        <strong class="ky hv">while </strong>(<strong class="ky hv">true</strong>)<br/>        {<br/>            <strong class="ky hv">yield return new </strong>Random().Next();<br/>        }<br/>    }<br/><br/>    IEnumerator IEnumerable.GetEnumerator()<br/>    {<br/>        <strong class="ky hv">return </strong>GetEnumerator();<br/>    }<br/>}</span></pre><p id="ed2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的是<strong class="it hv"> <em class="ks"> IntProducer </em> </strong>会生成一个<strong class="it hv"><em class="ks"/></strong>无界的<strong class="it hv"> <em class="ks"> int </em> </strong> s的集合，我们需要从<strong class="it hv"> <em class="ks"> Producer </em> </strong>中获取一个生成器(<strong class="it hv"><em class="ks">Gen&lt;T&gt;</em></strong>)，这样我们就可以对其进行强制绑定。</p><p id="3de1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我们可以使用以下方法:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="24f4" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">var</strong> intGenerator = (<strong class="ky hv">new </strong>IntProducer()).ChooseFrom()</span></pre><p id="0938" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过将<code class="eh lv lw lx ky b">.ChooseFrom(howMany)</code>应用于任何<strong class="it hv"> <em class="ks">生产者</em> </strong>，我们创建了一个<strong class="it hv"><em class="ks">Gen&lt;&gt;</em></strong><em class="ks"/>，它将<strong class="it hv"> <em class="ks">生产者</em> </strong>强制上界。</p><p id="30fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个例子可能是<strong class="it hv"><em class="ks">string producer</em></strong>:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5e65" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">public class </strong>StringProducer : IProducer&lt;<strong class="ky hv">string</strong>&gt;<br/>{<br/>    <strong class="ky hv">public </strong>IEnumerator&lt;<strong class="ky hv">string</strong>&gt; GetEnumerator()<br/>    {<br/>        <strong class="ky hv">while </strong>(<strong class="ky hv">true</strong>)<br/>        {<br/>            <strong class="ky hv">yield return new </strong>Random().Next().ToString();<br/>        }<br/>    }<br/><br/>    IEnumerator IEnumerable.GetEnumerator()<br/>    {<br/>        <strong class="ky hv">return </strong>GetEnumerator();<br/>    }<br/>}</span></pre><p id="eff2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，我们可以从它得到一个<strong class="it hv"><em class="ks">Gen&lt;T&gt;</em></strong>通过做:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="966e" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">var</strong> stringGenerator = (<strong class="ky hv">new </strong>StringProducer()).ChooseFrom(20)</span></pre><p id="032a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还包含了一种通过使用<strong class="it hv"> <em class="ks"> TupleProducer &lt; T，K &gt; </em> </strong>来生成<strong class="it hv"> <em class="ks"> (T，K) </em> </strong>形式的元组的方法。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="d7e5" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">public class </strong>TupleProducer&lt;T, K&gt; : IProducer&lt;(T, K)&gt;<br/>{<br/>    <strong class="ky hv">private readonly </strong>IProducer&lt;T&gt; <strong class="ky hv">_tProducer</strong>;<br/>    <strong class="ky hv">private readonly </strong>IProducer&lt;K&gt; <strong class="ky hv">_kproducer</strong>;<br/><br/>    <strong class="ky hv">public </strong>TupleProducer(IProducer&lt;T&gt; tProducer, IProducer&lt;K&gt; kproducer)<br/>    {<br/>        <strong class="ky hv">_tProducer </strong>= tProducer;<br/>        <strong class="ky hv">_kproducer </strong>= kproducer;<br/>    }<br/>    <br/>    <strong class="ky hv">public </strong>IEnumerator&lt;(T, K)&gt; GetEnumerator()<br/>    {<br/>        <strong class="ky hv">var </strong>tenum = <strong class="ky hv">_tProducer</strong>.GetEnumerator();<br/>        <strong class="ky hv">var </strong>kenum = <strong class="ky hv">_kproducer</strong>.GetEnumerator();<br/><br/>        <strong class="ky hv">while </strong>(tenum.MoveNext() &amp;&amp; kenum.MoveNext())<br/>        {<br/>            <strong class="ky hv">yield return </strong>(tenum.<strong class="ky hv">Current</strong>, kenum.<strong class="ky hv">Current</strong>);<br/>        }<br/>    }<br/><br/>    IEnumerator IEnumerable.GetEnumerator()<br/>    {<br/>        <strong class="ky hv">return </strong>GetEnumerator();<br/>    }<br/>}</span></pre><p id="8dc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，我们可以使用<code class="eh lv lw lx ky b">.ChooseFrom</code>从它那里得到一个生成器。</p><h2 id="5d2b" class="lc jq hu bd jr li lj lk jv ll lm ln jz jc lo lp kd jg lq lr kh jk ls lt kl lu dt translated">ForAll &amp; Any</h2><p id="67d3" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">一旦我们创建了一个生成器，我们就可以使用<code class="eh lv lw lx ky b">.ForAll</code>和<code class="eh lv lw lx ky b">.Any</code>作为存在量化来证明一个属性对于所生成的值是成立的。</p><p id="9ca5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过测试以下函数来看一些例子:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="406e" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">T</strong> id&lt;<strong class="ky hv">T</strong>&gt;(<strong class="ky hv">T</strong> x) =&gt; x;</span><span id="30c6" class="lc jq hu ky b fv lh le l lf lg"><strong class="ky hv">int </strong>sqrt(<strong class="ky hv">int </strong>x) =&gt; x * x;</span><span id="72df" class="lc jq hu ky b fv lh le l lf lg"><strong class="ky hv">string </strong>concat(<strong class="ky hv">string </strong>a, <strong class="ky hv">string </strong>b) =&gt; a + b;</span></pre><p id="8c74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意这是完全有效的<strong class="it hv"> C# </strong>代码，这里我们只使用方法体语法，在更传统的<strong class="it hv"> C# </strong>中等价的将是:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="958c" class="lc jq hu ky b fv ld le l lf lg"><strong class="ky hv">T</strong> id&lt;<strong class="ky hv">T</strong>&gt;(<strong class="ky hv">T</strong> x) { </span><span id="922d" class="lc jq hu ky b fv lh le l lf lg">   <strong class="ky hv">return</strong> x;<br/>}<br/>...</span></pre><p id="3fa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们继续测试这些功能。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7d01" class="lc jq hu ky b fv ld le l lf lg">[Fact]<br/><strong class="ky hv">public void </strong>Identity()<br/>{<br/>    Assert.True(<br/>       (<strong class="ky hv">new </strong>IntProducer())<br/>         .ChooseFrom()<br/>         .ForAll(x =&gt; id(x) == x));<br/>}</span></pre><p id="77bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lv lw lx ky b">.ForAll</code>收到我们要陈述的关于价值观的陈述。</p><p id="d6eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<strong class="it hv"> <em class="ks">恒等式</em> </strong>的情况下，我们要证明<code class="eh lv lw lx ky b">for all x, id(x) == x</code>。</p><p id="a967" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ks">将为生成器上的每个单个值评估属性。</em></p><p id="f7cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们来测试一下<strong class="it hv"> <em class="ks"> sqrt: </em> </strong></p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8d45" class="lc jq hu ky b fv ld le l lf lg">[Fact]<br/><strong class="ky hv">public void </strong>SomeSquares()<br/>{<br/>    Assert.True(<br/>      Gen&lt;<strong class="ky hv">int</strong>&gt;<br/>         .FromEnumerable(Enumerable.Range(1, 100))<br/>         .Any(x =&gt; sqrt(x) == x));<br/>}</span></pre><p id="03b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，属性<code class="eh lv lw lx ky b">sqrt(x) == x</code>仅对值<strong class="it hv"> <em class="ks"> 1 </em> </strong>有效。因为我们使用的是<code class="eh lv lw lx ky b">.Any</code>，所以这个测试也是一个通过测试。当我们使用<code class="eh lv lw lx ky b">.Any</code>时，属性至少保持一个值就足够了。</p><p id="b3af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后可以测试<strong class="it hv"> <em class="ks"> concat </em> </strong>。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="55d1" class="lc jq hu ky b fv ld le l lf lg">[Fact]<br/><strong class="ky hv">public void </strong>Concat()<br/>{<br/>   <strong class="ky hv">var </strong>stringProducer = <strong class="ky hv">new </strong>StringProducer(); <br/>   <strong class="ky hv">var </strong>producer = <strong class="ky hv">new </strong>TupleProducer&lt;<strong class="ky hv">string</strong>, <strong class="ky hv">string</strong>&gt;(stringProducer, stringProducer);<br/><br/>   producer<br/>       .ChooseFrom()<br/>       .ForAll(t =&gt; <br/>          concat(t.<strong class="ky hv">Item1</strong>, t.<strong class="ky hv">Item2</strong>).StartsWith(t.<strong class="ky hv">Item1</strong>) <br/>          &amp;&amp; <br/>          concat(t.<strong class="ky hv">Item1</strong>, t.<strong class="ky hv">Item2</strong>).EndsWith(t.<strong class="ky hv">Item2</strong>))<br/>       .Should()<br/>       .BeTrue();<br/>}</span></pre><p id="6259" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个非常有趣，因为我们一起使用了<strong class="it hv"> <em class="ks">字符串生成器</em> </strong>和<strong class="it hv"> <em class="ks">字符串生成器</em> </strong>。</p><p id="25a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们生成随机字符串，将它们连接在一起，并证明属性:<code class="eh lv lw lx ky b">for all a, b that are string, a + b == a* &amp;&amp; a + b == *b</code>。我们的库将选择由<strong class="it hv"> <em class="ks"> StringProducer </em> </strong>产生的100个字符串(有界集合或<strong class="it hv"> <em class="ks"> Gen &lt; T &gt; </em> </strong>)，并测试该属性对它们都成立。</p><p id="03c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ks">注意我们是通过</em><strong class="it hv"><em class="ks">fluent assertion</em></strong><em class="ks"/><strong class="it hv"><em class="ks">API</em></strong><em class="ks">来做断言，而不是简单的</em> <strong class="it hv"> <em class="ks">断言</em> </strong> <em class="ks">。然而，这只是为了表明我们的库并不局限于一种测试框架或断言风格。</em></p><h1 id="25f6" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结局</h1><p id="40f2" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">尽管这是一个非常小的库，但它很好地完成了它的工作，并允许我们为<em class="ks">带来一个简化的基于属性的测试。网</em>。</p><p id="d9f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以从NuGet Gallery获得它，从今天开始使用它。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2a96" class="lc jq hu ky b fv ld le l lf lg">PM&gt; Install-Package NetChecker -Version 1.0.0</span></pre><p id="c404" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae ly" href="https://github.com/anicolaspp/NetChecker" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="ks"> GitHub NetChecker项目</em> </strong> </a> <strong class="it hv"> <em class="ks">上随时欢迎投稿。</em> </strong></p></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><p id="d23e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ks">如果你想了解更多关于基于属性的测试，你可以阅读</em> <a class="ae ly" href="https://hackernoon.com/exploring-property-based-testing-with-scalacheck-simple-examples-bcdc34600810" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="ks">用ScalaCheck探索基于属性的测试(简单例子)</em> </strong> </a></p></div></div>    
</body>
</html>