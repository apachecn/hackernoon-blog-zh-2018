<html>
<head>
<title>The Decision Hypothesis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">决策假设</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-decision-hypothesis-aa512e0113?source=collection_archive---------5-----------------------#2018-02-09">https://medium.com/hackernoon/the-decision-hypothesis-aa512e0113?source=collection_archive---------5-----------------------#2018-02-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c909" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">神话中的人月暗示了几十年前的软件决策文档</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/ab206a7dd4dedf42017249f786b73493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9SYp2OY3n7VY7qqf3wzLw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A Qumran Cave Scroll (iStock)</figcaption></figure><p id="9fec" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">几周前，我重读了小佛瑞德·P·布鲁克斯的《神话人月》( T1 )( MM-M)。这是我多年来在软件开发领域的第三次阅读。</p><p id="a8c3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">MM-M是我们年轻工艺中创作卓越的戏剧性作品。我认为这是一种继续隐藏令人愉快的发现的<em class="kw">体质</em>。任何练习<a class="ae kv" rel="noopener" href="/hackernoon/software-is-unlike-construction-c0284ee4b723">软件开发</a>的人读了MM-M都会受益，但是，读一遍是不够的！无数次阅读会带来许多快乐和智慧。这项工作强调了持续至今的45年的观察结果。</p><p id="562a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这篇文章将描述MM-M中松散的发现，这可能暗示我们如何记录<em class="kw">软件开发决策的<em class="kw">为什么</em>。它还将分析我们团队不一致部署的一项技术，以捕获软件决策。</em></p><h1 id="7c5b" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">第十章:纪录片假设</h1><p id="4fb3" class="pw-post-body-paragraph jz ka hu kb b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">在《MM-M》中，弗雷德在短短的四页中假设学术劳动应用于实际应用。</p><blockquote class="lu lv lw"><p id="508c" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">在一堆文件中，少量的文档成为每个项目团队的关键支点…</p></blockquote><p id="4ba4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">弗雷德接着分三个部分简洁地描述了一个计算机产品所需的文档、大学部门所需的文档和软件项目所需的文档。</p><p id="ece6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">他以<strong class="kb hv">为什么的话题结束。</strong></p><blockquote class="lu lv lw"><p id="7844" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">首先，把决定写下来是必要的…其次，文档会把决定传达给其他人…最后，…文档提供了…一个数据库和清单。</p></blockquote><p id="517a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">通过引用，Fred建立了开发人员应该努力的文档的思想和基础。虽然他可能已经有了目标文档，例如时间表和需求，但是就代码而言，这如何应用于软件项目呢？</p><h1 id="3e0b" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">决策. md</h1><p id="182e" class="pw-post-body-paragraph jz ka hu kb b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">几年前，我们的团队进行了一次讨论，以决定如何传达团队决策的<strong class="kb hv">为什么</strong>的机制。我们想出了一种记录决策的方法。该文档将关注代码方向、构造用法、结构和风格，以解释这些决策的结论。</p><p id="7aa2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们的指导原则是<strong class="kb hv">文档是代码</strong>。如果<strong class="kb hv"> </strong>我们必须文档化，<em class="kw">在版本控制系统</em>或<em class="kw"> </em>中尽可能靠近软件工作空间<em class="kw">的地方做。</em></p><p id="6e4f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后我们发现了这个帖子；每个<a class="ae kv" href="https://akazlou.com/posts-output/2015-11-09-every-project-should-have-decisions/" rel="noopener ugc nofollow" target="_blank">项目都应该有一个由<a class="ma mb gr" href="https://medium.com/u/93bb84d49d5c?source=post_page-----aa512e0113--------------------------------" rel="noopener" target="_blank"> Aliaksandr Kazlou </a>制定的决策文件</a>。这篇文章介绍了版本控制的概念。这是一篇精彩的文章，我怀疑作者也是MM-M的粉丝。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/0f816aa73b752207936b23a353c38dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*r4S3KoPhzioNvfXF-mFdAQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">It’s evident in our <code class="eh mc md me mf b">DECISIONS.md</code> that <strong class="bd mh">code</strong> <strong class="bd mh">organization</strong> and <strong class="bd mh">dependency management</strong> are dominant.</figcaption></figure><p id="eac5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所以，我们按照我们的方式去跟随和采纳。下面我分享一小段我们的。</p><pre class="jk jl jm jn fq mi mf mj mk aw ml dt"><span id="fcd2" class="mm ky hu mf b fv mn mo l mp mq"># DECISIONS.md</span><span id="68e6" class="mm ky hu mf b fv mr mo l mp mq">...</span><span id="2191" class="mm ky hu mf b fv mr mo l mp mq">## Logging</span><span id="c5db" class="mm ky hu mf b fv mr mo l mp mq">As a platform team, we have decided to utilize Timber [<a class="ae kv" href="https://github.com/JakeWharton/timber" rel="noopener ugc nofollow" target="_blank">https://github.com/JakeWharton/timber</a>] for all logging calls within the application. This is due to a few reasons. Our biggest gain is the removal of an overbearing <strong class="mf hv">Log</strong> wrapper we had to maintain. We wanted to get rid of its complexity.</span><span id="ab5d" class="mm ky hu mf b fv mr mo l mp mq">Some other reasons for utilization of Timber are as follows:</span><span id="a911" class="mm ky hu mf b fv mr mo l mp mq"><strong class="mf hv">* </strong>Automatic tagging.<br/><strong class="mf hv">* </strong>Easy extensibility.<br/><strong class="mf hv">* </strong>Better usability in unit testing.</span><span id="b174" class="mm ky hu mf b fv mr mo l mp mq">...</span></pre><p id="8f71" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">一旦被采用，我们就遇到了<code class="eh mc md me mf b">DECISIONS.md</code>的及时性问题，因为它需要持续的维护。我们还观察到两个事实。首先，软件开发决策是无情和持久的。它们的强度可以变化，但总是存在。第二，我们很难让开发者拥有像《T2》这样的代码，让它保持及时。</p><h1 id="ff48" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">许多人都失去了朱利叶斯·韦尔豪森的作品</h1><p id="e453" class="pw-post-body-paragraph jz ka hu kb b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">这篇文章的灵感来自于团队、MM-M、启动和维护的许多项目以及Aliaksandr在<code class="eh mc md me mf b">DECISIONS.md</code>上的文章。然而，最终我决定写这篇文章，因为我最近和一位高级开发人员共进午餐。午餐让我明白了一切。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/cf11c5b799a3c140c5a1141a78407bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*xShobZ7anLd3whWKf-pssA.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Software decisions vary during a project but prefer to be constant over time.</figcaption></figure><p id="405f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们讨论了我们整体回购中的拉式请求趋势，这似乎与<code class="eh mc md me mf b">@VisibleForTesting</code>的特定用途和react evix<code class="eh mc md me mf b">Subject</code>等其他用途不一致。此外，在为我们的Kotlin生产迁移做准备时，团队没有做出一致使用<code class="eh mc md me mf b">@Nullable</code>和<code class="eh mc md me mf b">@NonNull</code>的决定。当然，技术细节是不必要的，这些问题只是一周的味道。</p><p id="a750" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我们吃饭的时候，许多开发人员基于理想主义的开发哲学贡献和改进我们的代码，但是如果我们朝着相同的方向前进，没有什么哲学是错误的。向Fred“使眼色”会暗示<em class="kw">零碎的或补充的假设</em>在代码贡献方面总是完全有效的。</p><p id="5adf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">果不其然，我们的午餐得出的结论是，我们必须提出决策，并且这些问题的沟通非常重要。我们要展开一场讨论，一场有数据的辩论，然后更新<code class="eh mc md me mf b">DECISIONS.md</code>文档。否则，随着时间的推移，测试和生产代码的完整性可能会因违反概念完整性而降低。</p><h1 id="dca5" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">Fred以自我文档总结道</h1><p id="2703" class="pw-post-body-paragraph jz ka hu kb b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">在MM-M中，显而易见，Fred很难处理独立的文档。他支持它的价值，但是思考为什么开发者没有做好。最后，他以某种我认为务实的方式给出了方向。</p><blockquote class="lu lv lw"><p id="379c" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">大多数文档都没有给出足够的概述。描述了树木，评论了树皮和树叶，但没有森林的地图。要写一篇有用的散文描述，先退后一步，慢慢来…</p></blockquote><p id="b246" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">关于书面语言与弗雷德最突出的对比如下。</p><blockquote class="lu lv lw"><p id="1829" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">英语，或任何其他人类语言，自然不是这种定义的精确工具。因此，手工书写者必须竭尽全力，用自己的语言来达到所需的精确度。</p></blockquote><p id="006b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，</p><blockquote class="lu lv lw"><p id="7aed" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">用英语散文，你可以展示结构原则，分阶段或层次描述结构，并给出例子。人们可以很容易地标出例外并强调对比。最重要的是，人们可以解释为什么<strong class="kb hv"><em class="hu"/></strong><em class="hu">。</em></p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/15dfb1576a6c7085a1104d08fe67ebaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*ENQPNiDWcKpsoPdRM_PD-g.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Developers do not like to document. Mundane external processes hurt developer happiness. [ 1 ]</figcaption></figure><p id="bf4a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Fred终于崩溃了，写了一章关于将文档与代码结合起来。</p><blockquote class="lu lv lw"><p id="2a71" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">然而，我们在编程文档方面的实践违背了我们自己的教导。我们通常试图维护一个机器可读形式的程序和一组独立的人类可读文档，包括散文和流程图。</p><p id="1dcc" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">结果事实上证实了我们的教导，即分开文件是愚蠢的。众所周知，程序文档质量很差，维护更差。程序中所做的更改不会及时、准确、不变地出现在文件中。</p><p id="e1a0" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">我认为，解决办法是合并文件，将文档合并到源程序中。这是对正确维护的一个强有力的激励，也是对程序用户来说文档总是方便的一个保证。这样的程序被称为<strong class="kb hv">自文档</strong>。</p></blockquote><p id="2c9e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Fred接近解决方案，但是他没有将代码作为文档来完成后续工作。看起来人类语言和机器语言互相排斥，就像两块磁铁被压在同一个磁极上。当它们靠近时，需要更多的能量来保持连接。</p><p id="6b1b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">四十五年后，<em class="kw">测试是关于规范</em>的文档。然而，它们也不能解释为什么代码会这样存在。有一个很高的值来保持<em class="kw"> why </em>使得系统能够枢转并存活。因此，一些文档在工作空间中有其位置。</p><h1 id="d4e3" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">代码无法向人类解释原因</h1><p id="1cfc" class="pw-post-body-paragraph jz ka hu kb b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">每个项目都会有大量的软件决策，这些决策需要不同强度的持续关注。建议是<em class="kw">在一个地方连续、仔细地记录</em>重要的软件开发决策。试试类似<code class="eh mc md me mf b">DECISIONS.md</code>的技巧。</p><p id="c839" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这份文件可以通过鼓励新的辩论和将决议集中到高度透明的文件修订上来为团队服务。这个过程将开发者舒适地聚焦在一个中立的真实点上——一个不完美的电子仲裁者。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/28f8cf4bc381c5cf4a1292196d73f58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*5N9F_1GCM9vUjYFtOOH0oQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Decreasing code <strong class="bd mh">complexity</strong> and increasing code <strong class="bd mh">consistency</strong> appears to be the whys.</figcaption></figure><p id="c787" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，我们必须解释软件决策的<strong class="kb hv">原因</strong>,因为代码有一种愚蠢的能力来传达它的起源。部落知识、走廊谈话、团队动态变化和消失。版本控制被改变，历史被打破。所有剩下的是许多贡献者在短时间内将这些片段绘制在一起。</p><blockquote class="ms"><p id="396c" class="mt mu hu bd mv mw mx my mz na nb ku ek translated">决策假设:</p><p id="aefe" class="mt mu hu bd mv mw mx my mz na nb ku ek translated">在不断的软件决策中，那些复杂性和一致性成为每个软件系统生存的关键支点。决定文件是揭示真相的关键。</p></blockquote></div><div class="ab cl nc nd hc ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hn ho hp hq hr"><h2 id="1839" class="mm ky hu bd kz nj nk nl ld nm nn no lh ki np nq lj km nr ns ll kq nt nu ln nv dt translated">参考</h2><p id="0158" class="pw-post-body-paragraph jz ka hu kb b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">[ 1 ]丹尼尔·格拉齐奥丁、费边·法格霍尔姆、王晓凤和佩卡·亚伯拉罕森。<a class="ae kv" href="https://arxiv.org/pdf/1703.04993.pdf" rel="noopener ugc nofollow" target="_blank">关于软件开发者的不快</a>。</p><h2 id="bba5" class="mm ky hu bd kz nj nk nl ld nm nn no lh ki np nq lj km nr ns ll kq nt nu ln nv dt translated">作者的笔记</h2><p id="7cf9" class="pw-post-body-paragraph jz ka hu kb b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated"><em class="kw">在MM-M中，第十章:纪录片假设</em> <em class="kw">聚焦于经理演员。通过结合对第6章:传递信息和第15章:另一面的思考，Creative liberty将谈话重新聚焦在软件团队和他们的文档上。</em></p><p id="fb36" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kw"> Fred的“文件假说”讨论了预算、组织结构图和时间表等文件。太多的软件工程团队，这些文档被认为是禁忌直接分发给他们。然而，这些文档是</em> <strong class="kb hv"> <em class="kw">数据和决策</em> </strong> <em class="kw">部分或全部控制所有软件项目的可变输入——时间、范围、开发人员和质量。</em></p><blockquote class="lu lv lw"><p id="7324" class="jz ka kw kb b kc kd iv ke kf kg iy kh lx kj kk kl ly kn ko kp lz kr ks kt ku hn dt translated">[摘自第3章:手术团队] …米尔斯在编程转型中的概念“从私人艺术到公共实践”，使所有团队成员都能看到所有的<strong class="kb hv"> </strong>计算机运行，并将所有程序和<strong class="kb hv">数据视为团队财产</strong>，而非私有财产。</p></blockquote><p id="cbdf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">由于软件开发团队总是受到约束，所以代码一致性、复杂性以及为什么组织以他们的方式构建事物都有相似之处。我们应该质疑为什么驱动软件项目的某些文档是隐藏的，这可能是为了让团队讨论并鼓励不同的变量，以便更好的软件能够蓬勃发展。然而，这不是我最初思考的目标。感谢 <a class="ma mb gr" href="https://medium.com/u/d8a8e3247b67?source=post_page-----aa512e0113--------------------------------" rel="noopener" target="_blank"> <em class="kw">哈齐姆·萨利赫</em> </a> <em class="kw">指出了这一点，并总结说，关于这一迷人的探索，可以写很多书。</em></p><p id="fbde" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kw">最后，感谢</em><a class="ma mb gr" href="https://medium.com/u/4e5a0d0c55e?source=post_page-----aa512e0113--------------------------------" rel="noopener" target="_blank"><em class="kw">James Shvarts</em></a><em class="kw">的启发。有一样东西永远不会消失，那就是价格过高的三明治店。</em></p></div></div>    
</body>
</html>