<html>
<head>
<title>Setup your own private Proof-of-Authority Ethereum network with Geth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Geth设置您自己的私人权威认证以太坊网络</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/setup-your-own-private-proof-of-authority-ethereum-network-with-geth-9a0a3750cda8?source=collection_archive---------0-----------------------#2018-02-11">https://medium.com/hackernoon/setup-your-own-private-proof-of-authority-ethereum-network-with-geth-9a0a3750cda8?source=collection_archive---------0-----------------------#2018-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f1abc47c1e62588fba3b64275122dc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DQn4a4Ni5QwzclsUgSJqQ.jpeg"/></div></div></figure><p id="7a1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2018年2月。</p><p id="1196" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">更新</strong>:</p><ol class=""><li id="ca45" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">geth 1.8是在本指南发布后几天发布的，幸运的是它没有破坏任何东西。这篇文章是有效的，并且在geth 1.7.3和geth 1.8上都经过了测试。厉害了:)</li><li id="c131" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">我后知后觉<em class="kp"/>每个区块的气限是<a class="ae kj" href="https://github.com/ethereum/go-ethereum/issues/2185" rel="noopener ugc nofollow" target="_blank">动态</a>。因此，我更新了第2.3节，提供了更多关于这种特殊情况的信息。在我的私人网络中，大部分时间都是空闲的，我根本不知道要减少多少限制！</li><li id="5a49" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">Clique要求<code class="eh kq kr ks kt b">int(N/2+1)</code>封口机(其中N是起源文件中定义的封口机数量——在<code class="eh kq kr ks kt b">extraData</code>字段中)在线才能运行。</li><li id="f378" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">感谢<a class="ku kv gr" href="https://medium.com/u/e7ef0de8aa9c?source=post_page-----9a0a3750cda8--------------------------------" rel="noopener" target="_blank"> Ivica Aracic </a>指出clique PoA <strong class="je hv">确实与<strong class="je hv">单节点</strong>一起工作。出于任何原因，我错过了这一点，我为混乱道歉。对于单个节点，我们只需要(A)创建只有一个密封器的genesis文件(只有一个地址在<code class="eh kq kr ks kt b">extraData</code> ) (B)创建一个帐户(C) init geth (D)运行geth，解锁帐户和矿。那么不需要bootnode。</strong></li><li id="248c" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">对于geth 1.8，如果您得到错误“指定了无效的主机”，请尝试将选项<code class="eh kq kr ks kt b">--rpcvhosts value</code>添加到geth命令中。参见<code class="eh kq kr ks kt b">geth --help</code></li></ol><p id="29c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">目标</strong>:一步一步的指导你使用<em class="kp">权威证明</em>共识引擎(也叫<em class="kp">团</em>)建立一个本地私有<a class="ae kj" href="https://hackernoon.com/tagged/ethereum" rel="noopener ugc nofollow" target="_blank">以太坊</a>网络。</p><p id="6e1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">l:我们将在同一台机器上设置两个节点，在本地主机上创建一个对等网络。除了这两个节点之外，还将设置一个bootnode(发现服务)。</p><p id="8964" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我花了相当多的时间和大量的研究和搜索，终于有了一个可靠的以太坊开发环境来测试我的智能合约和DApps。</p><p id="50b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我决定分享我是如何使用Geth的clique consensus引擎建立一个权威证明网络的。这是我感谢社区的方式，回报并希望让任何愿意探索以太坊宇宙的人的生活变得更容易。</p><h1 id="006c" class="kw kx hu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">操作系统和软件</h1><p id="8c4c" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">我的操作系统是Ubuntu 16.04 LTS(这个tuto是在一个新的虚拟机上完成的)。</p><p id="3dff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于以太坊客户端，我使用的是<a class="ae kj" href="https://github.com/ethereum/go-ethereum" rel="noopener ugc nofollow" target="_blank"> Geth </a>(以太坊协议的Go实现)。我相信Geth很容易安装，有很多很棒的教程，所以我不打算在这里介绍任何安装。我目前运行的是Geth 1.7.3-stable:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="35f0" class="mh kx hu kt b fv mi mj l mk ml">$ geth version<br/>Geth<br/>Version: 1.7.3-stable<br/>Git Commit: 4bb3c89d44e372e6a9ab85a8be0c9345265c763a<br/>Architecture: amd64<br/>Protocol Versions: [63 62]</span></pre><p id="1174" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并得到1 . 8 . 1-稳定</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="16ff" class="mh kx hu kt b fv mi mj l mk ml">$ geth version<br/>Geth<br/>Version: 1.8.1-stable<br/>Git Commit: 1e67410e88d2685bc54611a7c9f75c327b553ccc<br/>Architecture: amd64<br/>Protocol Versions: [63 62]</span></pre><p id="6143" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我强烈建议查看Geth <a class="ae kj" href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options" rel="noopener ugc nofollow" target="_blank">命令行接口</a>文档。你会需要它的。很多。</p><h1 id="cf88" class="kw kx hu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">1.我们开始吧</h1><h2 id="e68b" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">1.0概述</h2><p id="c8b2" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">让我们从结尾开始…为了清楚起见，这是你完成第一章后应该得到的内容。</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="c818" class="mh kx hu kt b fv mi mj l mk ml">devnet$ tree -L 2<br/>.<br/>├── accounts.txt<br/>├── boot.key<br/>├── genesis.json<br/>├── node1<br/>│   ├── geth<br/>│   ├── keystore<br/>│   └── password.txt<br/>└── node2<br/>    ├── geth<br/>    ├── keystore<br/>    └── password.txt</span></pre><h2 id="b5c4" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">1.1创建工作空间</h2><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="a7a4" class="mh kx hu kt b fv mi mj l mk ml">$ mkdir devnet<br/>$ cd devnet<br/>devnet$ mkdir node1 node2</span></pre><h2 id="fe34" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">1.2创建您的帐户</h2><p id="a2f1" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">这些账户(也称为钱包)持有一个私钥-公钥对，这是与任何<a class="ae kj" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>进行交互所必需的。任何挖掘节点(严格地说，我们的节点不是在挖掘，而是在投票)都需要能够签署事务(使用它们的私钥)并在网络上标识自己(地址来自公钥)。因此，我们至少需要两个帐户，每个节点一个。</p><p id="ad93" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Geth行话中，投票节点被称为缩放器。</p><p id="596e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于节点1:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="463e" class="mh kx hu kt b fv mi mj l mk ml">devnet$ geth --datadir node1/ account new<br/>Your new account is locked with a password. Please give a password. Do not forget this password.<br/>Passphrase: pwdnode1 (for example)<br/>Repeat passphrase: pwdnode1<br/>Address: {87366ef81db496edd0ea2055ca605e8686eec1e6}</span></pre><p id="ac98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于节点2:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="3a7e" class="mh kx hu kt b fv mi mj l mk ml">devnet$ geth --datadir node2/ account new<br/>Your new account is locked with a password. Please give a password. Do not forget this password.<br/>Passphrase: pwdnode2 (for example)<br/>Repeat passphrase: pwdnode2<br/>Address: {08a58f09194e403d02a1928a7bf78646cfc260b0}</span></pre><p id="d5ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将创建包含您的帐户文件的<code class="eh kq kr ks kt b">keystore/</code>文件夹。请注意，<code class="eh kq kr ks kt b">keystore/</code>中文件名的最后一部分是您帐户的地址(也打印在上面的终端中)。</p><p id="a1ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我建议从终端屏幕上复制这两个地址，并保存在一个文本文件中。这将减轻一些复制粘贴工作。但是记住你可以从<code class="eh kq kr ks kt b">keystore/</code>的<code class="eh kq kr ks kt b">UTC-datetime-address</code>文件中读取这些地址。</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="9b67" class="mh kx hu kt b fv mi mj l mk ml">devnet$ echo '87366ef81db496edd0ea2055ca605e8686eec1e6' &gt;&gt; accounts.txt<br/>devnet$ echo '08a58f09194e403d02a1928a7bf78646cfc260b0' &gt;&gt; accounts.txt</span></pre><p id="5c5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于每个节点，我建议将您的密码保存在一个文件中。这将为以后的一些过程(如解锁您的帐户)提供便利</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="2b77" class="mh kx hu kt b fv mi mj l mk ml">devnet$ echo 'pwdnode1' &gt; node1/password.txt<br/>devnet$ echo 'pwdnode2' &gt; node2/password.txt</span></pre><h2 id="5948" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">1.3创建您的Genesis文件</h2><p id="67be" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">源文件是用于初始化区块链的文件。第一个程序块叫做创世纪程序块，是根据<code class="eh kq kr ks kt b">genesis.json</code>文件中的参数制作的。</p><p id="f187" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Geth附带了一堆可执行文件，比如<code class="eh kq kr ks kt b">puppeth</code>或者<code class="eh kq kr ks kt b">bootnode</code>。您可以在<a class="ae kj" href="https://github.com/ethereum/go-ethereum/tree/master/cmd" rel="noopener ugc nofollow" target="_blank"> Geth github </a>上找到完整的列表。Puppeth消除了从头创建一个genesis文件的痛苦(并且做了更多)。启动puppeth:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="d5df" class="mh kx hu kt b fv mi mj l mk ml">devnet$ puppeth</span></pre><p id="cbde" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并愉快地回答问题(每个值都可以在以后手动更新，所以不要在第一次试验中花费太多时间来设计它)。</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="9520" class="mh kx hu kt b fv mi mj l mk ml">Please specify a network name to administer (no spaces, please)<br/>&gt; devnet<br/>What would you like to do? (default = stats)<br/> 1. Show network stats<br/> 2. Configure new genesis<br/> 3. Track new remote server<br/> 4. Deploy network components<br/>&gt; 2</span><span id="34bd" class="mh kx hu kt b fv mz mj l mk ml">Which consensus engine to use? (default = clique)<br/> 1. Ethash - proof-of-work<br/> 2. Clique - proof-of-authority<br/>&gt; 2</span><span id="d034" class="mh kx hu kt b fv mz mj l mk ml">How many seconds should blocks take? (default = 15)<br/>&gt; 5 // for example</span><span id="410d" class="mh kx hu kt b fv mz mj l mk ml">Which accounts are allowed to seal? (mandatory at least one)<br/>&gt; 0x87366ef81db496edd0ea2055ca605e8686eec1e6 //copy paste from account.txt :)<br/>&gt; 0x08a58f09194e403d02a1928a7bf78646cfc260b0</span><span id="091e" class="mh kx hu kt b fv mz mj l mk ml">Which accounts should be pre-funded? (advisable at least one)<br/>&gt; 0x87366ef81db496edd0ea2055ca605e8686eec1e6 // free ethers !<br/>&gt; 0x08a58f09194e403d02a1928a7bf78646cfc260b0</span><span id="a1c2" class="mh kx hu kt b fv mz mj l mk ml">Specify your chain/network ID if you want an explicit one (default = random)<br/>&gt; 1515 // for example. Do not use anything from 1 to 10</span><span id="cbd3" class="mh kx hu kt b fv mz mj l mk ml">Anything fun to embed into the genesis block? (max 32 bytes)<br/>&gt;</span><span id="a97a" class="mh kx hu kt b fv mz mj l mk ml">What would you like to do? (default = stats)<br/> 1. Show network stats<br/> 2. Manage existing genesis<br/> 3. Track new remote server<br/> 4. Deploy network components<br/>&gt; 2</span><span id="18c1" class="mh kx hu kt b fv mz mj l mk ml">1. Modify existing fork rules<br/> 2. Export genesis configuration<br/>&gt; 2</span><span id="5a7b" class="mh kx hu kt b fv mz mj l mk ml">Which file to save the genesis into? (default = devnet.json)<br/>&gt; genesis.json<br/>INFO [01-23|15:16:17] Exported existing genesis block</span><span id="8958" class="mh kx hu kt b fv mz mj l mk ml">What would you like to do? (default = stats)<br/> 1. Show network stats<br/> 2. Manage existing genesis<br/> 3. Track new remote server<br/> 4. Deploy network components<br/>&gt; ^C // ctrl+C to quit puppeth</span></pre><p id="32e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="kp">侧注</em> </strong>:出自<a class="ae kj" href="https://github.com/ethereum/EIPs/issues/225" rel="noopener ugc nofollow" target="_blank">嫡系PoA EIP#225 </a></p><blockquote class="na nb nc"><p id="e392" class="jc jd kp je b jf jg jh ji jj jk jl jm nd jo jp jq ne js jt ju nf jw jx jy jz hn dt translated">PoA没有采矿奖励</p></blockquote><p id="6f6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我强烈建议你在genesis文件中给一堆地址分配一些ether(以wei为单位定义),否则你会在没有任何ether的情况下放弃，从而无法支付你的交易。您可以将<code class="eh kq kr ks kt b">gasPrice</code>设为0，但这有时会导致节点出现不受欢迎的行为，这些行为可能会被发现(比如不广播未决事务，这取决于网络上其他节点的配置)。不过，我鼓励您尝试每个参数:)</p><h2 id="72a5" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">1.4初始化您的节点</h2><p id="e88c" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">现在我们有了<code class="eh kq kr ks kt b">genesis.json</code>文件，让我们来伪造创世块吧！每个节点<strong class="je hv">必须用<strong class="je hv">相同的</strong>起源文件</strong>初始化。</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="b475" class="mh kx hu kt b fv mi mj l mk ml">devnet$ geth --datadir node1/ init genesis.json<br/>devnet$ geth --datadir node2/ init genesis.json</span></pre><p id="693c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">tada！完成了。</p><p id="c27f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="kp">旁注</em> </strong>:你的节点在加入以太坊主网或者Ropsten testnet，或者Rinkeby testnet的时候是怎么知道genesis参数的？它们已经在<code class="eh kq kr ks kt b">params/config.go</code>的<a class="ae kj" href="https://github.com/ethereum/go-ethereum/blob/master/params/config.go" rel="noopener ugc nofollow" target="_blank">源代码</a>中定义好了。</p><h2 id="5563" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">1.5创建启动节点</h2><p id="20f9" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">bootnode唯一的目的是帮助节点发现彼此(记住，以太坊区块链是一个对等网络)。节点可以有动态IP，关闭后再打开。bootnode通常运行在静态IP上，因此就像一个酒馆，节点知道它们会在那里找到自己的伙伴。</p><p id="4d4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">初始化启动节点:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="3bd9" class="mh kx hu kt b fv mi mj l mk ml">devnet$ bootnode -genkey boot.key</span></pre><p id="c652" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这创建了一个名为<code class="eh kq kr ks kt b">enode</code>的值，唯一地标识您的bootnode(稍后会有更多的介绍)，我们将这个enode存储在<code class="eh kq kr ks kt b">boot.key</code>文件中。</p><h2 id="a94d" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">1.6中途庆祝</h2><p id="c400" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">恭喜你。第一章做完了:)试试</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="aa13" class="mh kx hu kt b fv mi mj l mk ml">devnet$ tree -L 2</span></pre><p id="7a97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并将输出与第1.0节进行比较。希望你能得到同样的树。</p><p id="46d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至此，设置已经完成，我们已经准备好让区块链上线了。</p><h1 id="0112" class="kw kx hu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">2.让它活起来</h1><h2 id="4e86" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">2.1启动bootnode服务</h2><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="6037" class="mh kx hu kt b fv mi mj l mk ml">devnet$ bootnode -nodekey boot.key -verbosity 9 -addr :30310<br/>INFO [02-07|22:44:09] UDP listener up                          self=enode://3ec4fef2d726c2c01f16f0a0030f15dd5a81e274067af2b2157cafbf76aa79fa9c0be52c6664e80cc5b08162ede53279bd70ee10d024fe86613b0b09e1106c40@[::]:30310</span></pre><p id="46b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我喜欢让我的bootnode变得冗长，因为当节点在网络上打乒乓时看起来很好(意味着它正在工作！).</p><p id="5163" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以随意使用任何您喜欢的端口，但请避免使用主流端口(如HTTP的80端口)。<code class="eh kq kr ks kt b">30303</code>用于公共以太网。</p><h2 id="2ed6" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">2.2启动节点</h2><p id="dc43" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">大时代！最后(但通常麻烦也会随之而来)。</p><p id="8a52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一切尽在一个巨大的命令中！我将介绍一些选项，但请做好您的功课并参考<a class="ae kj" href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="910a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开始节点1</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="ebd4" class="mh kx hu kt b fv mi mj l mk ml">devnet$ geth --datadir node1/ --syncmode 'full' --port 30311 --rpc --rpcaddr 'localhost' --rpcport 8501 --rpcapi 'personal,db,eth,net,web3,txpool,miner' --bootnodes 'enode://3ec4fef2d726c2c01f16f0a0030f15dd5a81e274067af2b2157cafbf76aa79fa9c0be52c6664e80cc5b08162ede53279bd70ee10d024fe86613b0b09e1106c40@127.0.0.1:30310' --networkid 1515 --gasprice '1' -unlock '0x87366ef81db496edd0ea2055ca605e8686eec1e6' --password node1/password.txt --mine</span></pre><ul class=""><li id="7d74" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--syncmode 'full'</code>有助于防止错误<a class="ae kj" href="https://github.com/ethereum/go-ethereum/issues/14945" rel="noopener ugc nofollow" target="_blank">丢弃不良传播块</a>。</li><li id="ba9b" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--port 30311</code>是node1的enode端口，它必须不同于bootnode端口(如果您按照我的命令操作，那就是<code class="eh kq kr ks kt b">30310</code>),因为我们在本地主机上。在真实的网络中(每台机器一个节点)，使用相同的端口。</li><li id="cc58" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--rpcapi</code>允许通过RPC调用使用列出的模块(参见第3.3节的示例)。更多信息见<a class="ae kj" href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs" rel="noopener ugc nofollow" target="_blank">Geth管理API</a>。请注意黑客攻击，因为如果没有防火墙保护您的节点，每个人都可以调用您的RPC方法。</li><li id="fa39" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--bootnodes</code>告诉你的节点在什么地址找到你的引导节点。用bootnode IP替换<code class="eh kq kr ks kt b">[::]</code>。不允许使用域名！只有IP。<a class="ae kj" href="https://github.com/ethereum/wiki/wiki/enode-url-format" rel="noopener ugc nofollow" target="_blank">检查enode URL格式</a>。</li><li id="9f77" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--networkId</code>如<code class="eh kq kr ks kt b">genesis.json</code>文件中所定义。请使用相同的id！</li><li id="9a22" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--gasprice '1'</code>我不喜欢在自己的网络上付费:)小心gasprice。如果您的交易没有被广播到网络，而是只有接收交易的节点在处理它们，这意味着您发送的交易的gasprice不被网络上的其他节点接受(太低)。不会返回任何错误。如果有两个节点，只有一个节点会处理事务。这是偷偷摸摸的，会使你的网络吞吐量降低2倍。</li><li id="3de3" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--unlock</code></li><li id="8b56" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz ng kg kh ki dt translated"><code class="eh kq kr ks kt b">--targetgaslimit value</code>参见2.3节中的<strong class="je hv">更新</strong>。</li></ul><p id="ef3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">节点2也是如此(更新特定于该节点的参数)</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="8617" class="mh kx hu kt b fv mi mj l mk ml">devnet$ geth --datadir node2/ --syncmode 'full' --port 30312 --rpc --rpcaddr 'localhost' --rpcport 8502 --rpcapi 'personal,db,eth,net,web3,txpool,miner' --bootnodes 'enode://3ec4fef2d726c2c01f16f0a0030f15dd5a81e274067af2b2157cafbf76aa79fa9c0be52c6664e80cc5b08162ede53279bd70ee10d024fe86613b0b09e1106c40@127.0.0.1:30310' --networkid 1515 --gasprice '0' --unlock '0x08a58f09194e403d02a1928a7bf78646cfc260b0' --password node2/password.txt --mine</span></pre><p id="b661" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，bootnode应该对来自node1(端口30311)和node2(端口30312)的连接进行流式传输，如上面的终端窗口所示。Node1(中端)和node2(下端)应该是高高兴兴的挖矿签名区块了。这里我有一个1秒的周期(在genesis文件中定义),因此快速块创建。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/8460cfb6b665453b99e8af4031949308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLjJkNTRxbqnGhzW8Fdt4w.png"/></div></div></figure><h2 id="07a1" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">2.3更新您的genesis文件</h2><p id="ae58" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">我相信你会想要修改你的genesis文件中的一些值。去吧！但是，为了使这些更改生效，我们必须初始化一个新的区块链。以下是我目前正在使用的genesis文件:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="5166" class="mh kx hu kt b fv mi mj l mk ml">{<br/>    "config": {<br/>        "chainId": 1515,<br/>        "homesteadBlock": 1,<br/>        "eip150Block": 2,<br/>        "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",<br/>        "eip155Block": 3,<br/>        "eip158Block": 3,<br/>        "byzantiumBlock": 4,<br/>        "clique": {<br/>            "period": 1,<br/>            "epoch": 30000<br/>        }<br/>    },<br/>    "nonce": "0x0",<br/>    "timestamp": "0x5a722c92",<br/>    "extraData": "0x000000000000000000000000000000000000000000000000000000000000000008a58f09194e403d02a1928a7bf78646cfc260b087366ef81db496edd0ea2055ca605e8686eec1e60000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",<br/>    "gasLimit": "0x59A5380",<br/>    "difficulty": "0x1",<br/>    "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",<br/>    "coinbase": "0x0000000000000000000000000000000000000000",<br/>    "alloc": {<br/>        "08a58f09194e403d02a1928a7bf78646cfc260b0": {<br/>            "balance": "0x200000000000000000000000000000000000000000000000000000000000000"<br/>        },<br/>        "87366ef81db496edd0ea2055ca605e8686eec1e6": {<br/>            "balance": "0x200000000000000000000000000000000000000000000000000000000000000"<br/>        },<br/>        "F464A67CA59606f0fFE159092FF2F474d69FD675": {<br/>            "balance": "0x200000000000000000000000000000000000000000000000000000000000000"<br/>        }<br/>    },<br/>    "number": "0x0",<br/>    "gasUsed": "0x0",<br/>    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"<br/>}</span></pre><p id="85a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我已经清理了puppeth在创建文件时包含的空地址(在1.3节)。我还添加了第三个地址，该地址在创建genesis块时得到资助。然后，我将<code class="eh kq kr ks kt b">period</code>从15秒更改为1，以便更快地挖掘这些块(注意，一个空块重1024字节——这里我的<code class="eh kq kr ks kt b">chaindata/</code>文件夹每秒增加1024字节(如果块不为空，则增加更多)。最后，我增加了<code class="eh kq kr ks kt b">gasLimit</code>,以允许每个块有更多的事务(确切地说，计算)。</p><p id="0a12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">更新</strong>:genesis文件中定义的<code class="eh kq kr ks kt b">gasLimit</code>只适用于genesis块！新区块的<code class="eh kq kr ks kt b">gasLimit</code>是<a class="ae kj" href="https://github.com/ethereum/go-ethereum/issues/2185" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">动态</strong> </a>的，这意味着它的值随着时间而变化，这取决于母(先前)区块中使用了多少天然气。新<code class="eh kq kr ks kt b">gasLimit</code>的计算在函数<code class="eh kq kr ks kt b">CalcGasLimit</code> ( <a class="ae kj" href="https://github.com/ethereum/go-ethereum/blob/master/core/block_validator.go#L106" rel="noopener ugc nofollow" target="_blank"> github源</a>)中完成。如果您想要一个恒定的气体极限，运行geth时使用<a class="ae kj" href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options" rel="noopener ugc nofollow" target="_blank">选项</a> <code class="eh kq kr ks kt b">--targetgaslimit intValue</code>。我建议将它设置为等于genesis文件中的<code class="eh kq kr ks kt b">gasLimit</code>(命令选项是一个整数，而genesis值是十六进制的)，这样您就可以获得一个不随时间变化的恒定气体限制。给定上面带有<code class="eh kq kr ks kt b">"gasLimit":"0x59A5380"</code>的genesis文件，我用<code class="eh kq kr ks kt b">--targetgaslimit 94000000</code>运行我的节点，以获得所有块的恒定气体限制。</p><p id="b10d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">字段<code class="eh kq kr ks kt b">extraData</code>包含允许密封的地址(这就是为什么puppeth很好拥有的原因)。</p><p id="bc7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我调查了改变<code class="eh kq kr ks kt b">period</code>和<code class="eh kq kr ks kt b">gasLimit</code>对区块链每秒可以处理的事务数量(事务速率)的影响。但那将是另一篇文章。点击这里。</p><p id="431c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你对你的创世纪文件满意的时候。如果您的节点正在运行，请终止它们(在终端中按ctrl+C)。然后删除<code class="eh kq kr ks kt b">node1/</code>中的文件夹<code class="eh kq kr ks kt b">geth/</code>和<code class="eh kq kr ks kt b">node2/</code>中的<code class="eh kq kr ks kt b">geht/</code>。只删除<code class="eh kq kr ks kt b">geth/</code>文件夹！</p><p id="cbee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后初始化您的节点。来自第1.4节:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="fec0" class="mh kx hu kt b fv mi mj l mk ml">devnet$ geth --datadir node1/ init genesis.json<br/>devnet$ geth --datadir node2/ init genesis.json</span></pre><p id="a2d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并使用2.2节中的命令再次启动节点</p><h1 id="f598" class="kw kx hu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">3.与您的节点互动</h1><p id="c7c9" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">很好，您的网络现已上线:)但如何连接并开始探索呢？</p><h2 id="4cf2" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">3.1打开一个Geth Javascript控制台</h2><p id="80bc" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">最简单也可能更直接的处理节点的方法可能是将一个<a class="ae kj" href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console" rel="noopener ugc nofollow" target="_blank"> Geth javascript控制台</a>附加到一个节点上。</p><h2 id="db5a" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">3.1.1通过IPC</h2><p id="0f95" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">IPC(<a class="ae kj" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">I</strong>enter-<strong class="je hv">P</strong>process<strong class="je hv">C</strong>communication</a>)只在本地工作:你应该和你的节点在同一台机器上。打开一个额外的终端并连接到您的节点。要连接到节点1:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="ee69" class="mh kx hu kt b fv mi mj l mk ml">$ cd devnet<br/>devnet$ geth attach node1/geth.ipc<br/>Welcome to the Geth JavaScript console!</span><span id="3534" class="mh kx hu kt b fv mz mj l mk ml">instance: Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9<br/>coinbase: 0x87366ef81db496edd0ea2055ca605e8686eec1e6<br/>at block: 901 (Sat, 10 Feb 2018 21:15:30 CET)<br/> datadir: /home/salanfe/privateNetworks/devnet/node1<br/> modules: admin:1.0 clique:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><span id="e28e" class="mh kx hu kt b fv mz mj l mk ml">&gt;</span></pre><p id="91d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">文件<code class="eh kq kr ks kt b">geth.ipc</code>仅在节点运行时创建。所以，如果你的node1关闭了，就不要指望能找到它。</p><p id="c4be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">RPC可以无限制地访问终端中列出的所有模块:<code class="eh kq kr ks kt b">admin: 1.0 clique:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</code></p><h2 id="a380" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">通过RPC</h2><p id="8632" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">RPC(<a class="ae kj" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">R</strong>emote<strong class="je hv">P</strong>procedure<strong class="je hv">C</strong>all</a>)作为HTTP请求在互联网上工作。因此，当您向外界开放RPC时要小心，因为每个人都可以访问您的节点。因此，RPC在默认情况下是禁用的，启用时，它不会提供对所有模块的访问。在本指南中，我们使用命令<code class="eh kq kr ks kt b">--rpc</code>允许Geth节点上的RPC，并允许访问模块<code class="eh kq kr ks kt b">personal,db,eth,net,web3,txpool,miner</code>(来自2.2节)。使用RPC连接到节点1:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="31c3" class="mh kx hu kt b fv mi mj l mk ml">$ cd devnet<br/>devnet$ geth attach 'http://localhost:8501'<br/>Welcome to the Geth JavaScript console!</span><span id="bcdf" class="mh kx hu kt b fv mz mj l mk ml">instance: Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9<br/>coinbase: 0x87366ef81db496edd0ea2055ca605e8686eec1e6<br/>at block: 945 (Sat, 10 Feb 2018 21:16:14 CET)<br/> modules: eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><span id="6cfb" class="mh kx hu kt b fv mz mj l mk ml">&gt;</span></pre><h2 id="0b8e" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">3.1.3使用Geth Javascript控制台</h2><p id="d926" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">下面是一些方法的例子</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="0df7" class="mh kx hu kt b fv mi mj l mk ml">&gt; net.version<br/>"1515"<br/>&gt; eth.blockNumber<br/>1910<br/>&gt; eth.coinbase<br/>"0x87366ef81db496edd0ea2055ca605e8686eec1e6"<br/>&gt; eth.sendTransaction({'from':eth.coinbase, 'to':'0x08a58f09194e403d02a1928a7bf78646cfc260b0', 'value':web3.toWei(3, 'ether')})<br/>"0x299a99baa1b39bdee5f02e3c660e19e744f81c2e886b5fc24aa83f92fe100d3f"<br/>&gt; eth.getTransactionReceipt("0x299a99baa1b39bdee5f02e3c660e19e744f81c2e886b5fc24aa83f92fe100d3f")<br/>{<br/>  blockHash: "0x212fb593980bd42fcaf3f6d1e6db2dd86d3764df8cac2d90408f481ae7830de8",<br/>  blockNumber: 2079,<br/>  contractAddress: null,<br/>  cumulativeGasUsed: 21000,<br/>  from: "0x87366ef81db496edd0ea2055ca605e8686eec1e6",<br/>  gasUsed: 21000,<br/>  logs: [],<br/>  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",<br/>  status: "0x1",<br/>  to: "0x08a58f09194e403d02a1928a7bf78646cfc260b0",<br/>  transactionHash: "0x299a99baa1b39bdee5f02e3c660e19e744f81c2e886b5fc24aa83f92fe100d3f",<br/>  transactionIndex: 0<br/>}<br/>&gt; exit // to quit the Geth javascript console</span></pre><p id="0e17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有关方法的完整列表，请参见<a class="ae kj" href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs" rel="noopener ugc nofollow" target="_blank">管理API</a>和<a class="ae kj" href="https://github.com/ethereum/wiki/wiki/JSON-RPC" rel="noopener ugc nofollow" target="_blank"> JSON RPC API </a>。</p><h2 id="8198" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">3.2使用喷雾</h2><p id="0c7b" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated"><a class="ae kj" href="https://github.com/ethereum/mist" rel="noopener ugc nofollow" target="_blank"> Mist浏览器</a>提供了一个图形用户界面，用于部署智能合同并与之交互，以及管理账户。要通过IPC将Mist连接到您的本地专用网络，只需执行以下操作:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="7562" class="mh kx hu kt b fv mi mj l mk ml">devnet$ mist --rpc node1/geth.ipc</span></pre><p id="eb19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和通过RPC(确保RPC已启用)</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="d116" class="mh kx hu kt b fv mi mj l mk ml">$ mist --rpc 'http://localhost:8501'</span></pre><p id="c0bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想用<a class="ae kj" href="https://github.com/ethereum/mist/releases" rel="noopener ugc nofollow" target="_blank">以太坊钱包</a>代替mist，程序完全一样。只需在上面的命令中用<code class="eh kq kr ks kt b">ethereumwallet</code>代替mist。</p><h2 id="7bd4" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">3.3使用您最喜欢的编程语言进行RPC调用</h2><p id="bee5" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">在3.1节中，我们看到了如何手工与Geth API交互。现在让我们用我们的电脑做它最擅长的事情:自动化。</p><p id="2106" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，向节点发送JSON-RPC请求的参考是<a class="ae kj" href="https://github.com/ethereum/web3.js/" rel="noopener ugc nofollow" target="_blank"> web3.js </a> javascript库。我相信互联网上有很多关于如何使用web3.js库的教程和例子。因此我不会在这里隐藏任何东西。</p><p id="1bfb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JSON-RPC API目前也在java中用<a class="ae kj" href="https://github.com/web3j/web3j" rel="noopener ugc nofollow" target="_blank"> web3.j </a>库实现，在python中用<a class="ae kj" href="https://github.com/ethereum/web3.py" rel="noopener ugc nofollow" target="_blank"> web3.py </a>库实现。这些库提供了使用以太坊区块链的高级方法，就像web3.js一样</p><p id="0a4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，也可以直接向您的节点发送原始的<a class="ae kj" href="http://www.jsonrpc.org/specification" rel="noopener ugc nofollow" target="_blank"> JSON-RPC </a>请求。我认为这是值得一试的，因为它提供了对那些高级库如何在幕后工作的有价值的理解。</p><p id="58d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个使用python 3向我的节点发送原始JSON-RPC请求的简单示例:</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="b1e2" class="mh kx hu kt b fv mi mj l mk ml">$ python<br/>Python 3.6.4 |Anaconda custom (64-bit)| (default, Jan 16 2018, 18:10:19) <br/>[GCC 7.2.0] on linux<br/>Type "help", "copyright", "credits" or "license" for more information.<br/>&gt;&gt;&gt; import requests<br/>&gt;&gt;&gt; import json<br/>&gt;&gt;&gt; session = requests.Session()<br/>&gt;&gt;&gt; method = 'eth_getTransactionCount'<br/>&gt;&gt;&gt; params = ["0x627306090abaB3A6e1400e9345bC60c78a8BEf57","latest"]<br/>&gt;&gt;&gt; PAYLOAD = {"jsonrpc":"2.0",<br/>...            "method":method,<br/>...            "params":params,<br/>...            "id":67}<br/>&gt;&gt;&gt; PAYLOAD = json.dumps(PAYLOAD)<br/>&gt;&gt;&gt; headers = {'Content-type': 'application/json'}<br/>&gt;&gt;&gt; response = session.post('<a class="ae kj" href="http://127.0.0.1:8501'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8501'</a>, data=PAYLOAD, headers=headers)<br/>&gt;&gt;&gt; response.content<br/>b'{"jsonrpc":"2.0","id":67,"result":"0x0"}\n'<br/>&gt;&gt;&gt; json.loads(response.content)['result']<br/>'0x0'</span></pre><p id="cb9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此处记录了<code class="eh kq kr ks kt b">geth_transactionCount</code>方法<a class="ae kj" href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactioncount" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a19c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">“帐户”<a class="ae kj" href="https://github.com/ethereum/wiki/wiki/Glossary" rel="noopener ugc nofollow" target="_blank">现时值</a>是一个交易计数器，与工作证明的现时值无关。账户随机数为零意味着地址<code class="eh kq kr ks kt b">0x627306090abaB3A6e1400e9345bC60c78a8BEf57</code>从未在网络上进行任何交易:<code class="eh kq kr ks kt b">0x0</code>是零的十六进制表示。</p><h2 id="9908" class="mh kx hu bd ky mm mn mo lc mp mq mr lg jn ms mt lk jr mu mv lo jv mw mx ls my dt translated">3.4在您的专用网络上使用Truffle部署和测试您的智能合约</h2><p id="87a1" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">像<a class="ae kj" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank">松露</a>(或者<a class="ae kj" href="https://github.com/iurimatias/embark-framework" rel="noopener ugc nofollow" target="_blank"> Embark </a>、<a class="ae kj" href="https://github.com/ethereum/populus" rel="noopener ugc nofollow" target="_blank"> Populus </a>)这样的开发框架是开发和测试智能合约的好工具。</p><p id="1e94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您使用初始化工作区时</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="0d80" class="mh kx hu kt b fv mi mj l mk ml">$ truffle init</span></pre><p id="07aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Truffle创建了一系列文件和文件夹来帮助你开始。我通常这样编辑<code class="eh kq kr ks kt b">truffle.js</code>文件</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="39cb" class="mh kx hu kt b fv mi mj l mk ml">module.exports = {<br/>    // See &lt;<a class="ae kj" href="http://truffleframework.com/docs/advanced/configuration" rel="noopener ugc nofollow" target="_blank">http://truffleframework.com/docs/advanced/configuration</a>&gt;<br/>    // to customize your Truffle configuration!<br/>    networks: {<br/>        devnet: {<br/>            host: '127.0.0.1',<br/>            port: 8501,<br/>            network_id: '*'<br/>        },<br/>        ganache: {<br/>            host: '127.0.0.1',<br/>            port: 7545,<br/>            network_id: '*'<br/>        }<br/>    }<br/>};</span></pre><p id="30bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后使用命令</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="9c7e" class="mh kx hu kt b fv mi mj l mk ml">$ truffle deploy --network devnet</span></pre><p id="6862" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">部署您在<code class="eh kq kr ks kt b">migrations/X_deploy.js</code>中定义的智能合约。或者在<code class="eh kq kr ks kt b">test/</code>运行你的测试</p><pre class="lz ma mb mc fq md kt me mf aw mg dt"><span id="cac4" class="mh kx hu kt b fv mi mj l mk ml">$ truffle test --network devnet</span></pre><p id="d997" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常以太坊区块链模拟器<a class="ae kj" href="http://truffleframework.com/ganache/" rel="noopener ugc nofollow" target="_blank"> Ganache </a>对于运行你的测试来说绰绰有余。然而，我喜欢使用我的私人区块链在真实节点上进行最终测试，而不仅仅是在模拟器上。对于Ganache，我认为抽象层太大，它的优点是什么，但也是一个危险，因为它不需要了解真实节点的复杂性(交易池、gasPrice、gasLimit、节点之间的广播交易、挖掘或投票、计算时间、共识引擎等)。).</p><h1 id="5cd3" class="kw kx hu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">下一步是什么？</h1><p id="82da" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">这就是本指南的基本内容。如果你理解这里的一切，我相信你已经走上了很好的轨道，你有一个坚实的基础，在这个基础上你可以充满信心地继续你的旅程。</p><p id="f3f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以通过获取一个web3库或者制作你自己定制的JSON-RPC包装器来开始开发Dapps。</p><p id="5ede" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae kj" rel="noopener" href="/@ethervolution/ethereum-create-raw-json-rpc-requests-with-python-for-deploying-and-transacting-with-a-smart-7ceafd6790d9">这篇文章</a>中，我探索了如何使用python来部署和处理一个仅使用原始HTTP请求的智能契约。</p><div class="ni nj fm fo nk nl"><a rel="noopener follow" target="_blank" href="/@ethervolution/ethereum-create-raw-json-rpc-requests-with-python-for-deploying-and-transacting-with-a-smart-7ceafd6790d9"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd hv fv z el nq eo ep nr er et ht dt translated">以太坊:用Python创建原始的JSON-RPC请求，用于部署和处理智能…</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">2018年2月。</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ja nl"/></div></div></a></div><h1 id="a132" class="kw kx hu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">最后的话</h1><p id="9f46" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">如果你坚持到最后，恭喜你。我希望这个指南是全面的，对你的旅程有所帮助。我欢迎任何改进本指南的反馈！</p><p id="3dc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非常感谢社区提供的所有文档、教程、问答网站和指南。</p><p id="5d7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">黑客快乐！</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>