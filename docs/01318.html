<html>
<head>
<title>“Guys, we’re doing pagination wrong…”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“伙计们，我们的分页做错了…”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/guys-were-doing-pagination-wrong-f6c18a91b232?source=collection_archive---------1-----------------------#2018-02-11">https://medium.com/hackernoon/guys-were-doing-pagination-wrong-f6c18a91b232?source=collection_archive---------1-----------------------#2018-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6a27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的职业生涯中，由于对分页在几个项目中的实现方式不满，我不得不多次抱怨这些话。</p><p id="9ad0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管如此，当我偶尔不得不问<em class="jp">“为什么这个API没有分页?”时，这种不满与我的感受相比不算什么..?"</em></p><p id="2ebf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，从我通常的无服务器漫谈中休息一下，让我们来谈谈分页:-)</p><h2 id="f218" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">单向和双向分页</h2><p id="cad7" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">一般来说，我看到两种常见的分页类型:</p><ul class=""><li id="7f43" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">简单、单向地浏览静态结果集，这些结果太长或效率太低，无法一次返回，例如twitter关注者列表或Google搜索结果列表</li><li id="6b5f" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">通过某种提要或流进行双向分页，在收到第一页结果后可以添加新的结果，例如您的twitter时间表或通知</li></ul><h2 id="9950" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">避免抽象泄漏</h2><p id="3a40" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">我看到的一个常见错误是，分页API要求调用者提供用来对结果进行排序的“键”,这就产生了一个泄漏的抽象。然后，调用者必须理解服务用来对其结果进行分页的底层机制——例如，通过时间戳或字母顺序。</p><p id="7a52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">DynamoDB的<a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html" rel="noopener ugc nofollow" target="_blank">查询</a> API就是一个很好的例子。要浏览查询结果，调用者必须在后续请求中指定<a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-ExclusiveStartKey" rel="noopener ugc nofollow" target="_blank"> ExclusiveStartKey </a>。然而，服务也在响应中返回了<a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-response-LastEvaluatedKey" rel="noopener ugc nofollow" target="_blank"> LastEvaluatedKey </a>。</p><p id="42aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，在实践中，您几乎可以<em class="jp">将<em class="jp"> LastEvaluatedKey </em>视为一个令牌或光标，您只需在下一个请求中传递它。除此之外，它不仅仅是一个标记，它还是<em class="jp"> DynamoDB </em>表中一个实际的排序键，而且属性名已经给出了实现细节。</em></p><p id="54d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就其本身而言，这不是什么大事。然而，不幸的是，它通常会产生连锁效应，鼓励应用程序开发人员在这个实现细节的基础上构建他们的应用程序级分页。除了这一次，他们没有在响应中返回<em class="jp"> LastEvaluatedKey </em>，客户端现在负责跟踪这条信息。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff lf"><img src="../Images/f973e6de35251026dc841751a715d380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvG89gO7172tXpYzUz1WyQ.png"/></div></div></figure><p id="c82d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜您，您的数据库用来支持分页的底层机制现在已经泄露到您的前端了！</p><h2 id="8cc0" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">使分页意图明确且一致</h2><p id="8c13" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">我看到的另一个常见趋势是，您必须一遍又一遍地向分页API发送相同的请求参数，例如:</p><ul class=""><li id="c5c0" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">每页的最大结果数</li><li id="d520" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">分页的方向(如果是双向的)</li><li id="bed5" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">原始查询(在<em class="jp"> DynamoDB </em>的情况下，这包括多个属性，如<em class="jp"> FilterExpression </em>、<em class="jp"> KeyConditionExpression </em>、<em class="jp"> ProjectionExpression </em>和<em class="jp"> IndexName </em></li></ul><p id="cce0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不认为这是一个错误，因为有时这是设计使然，但更多时候，我认为这是缺乏设计的结果。</p><p id="2ae0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我遇到的所有分页API中，预期的行为总是为一个查询获取下一组结果，而不是中途开始一个不同的查询。这是没有意义的，你甚至不能称之为分页，更像是导航！我的意思是，<em class="jp">您上一次启动DynamoDB查询，然后不得不在结果分页的中途更改任何请求参数是什么时候？</em></p><p id="187a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，从先前接收的页面改变分页的方向<em class="jp">是有正当理由的。当我们在本文后面讨论双向分页时会有更多的介绍。</em></p><h2 id="f047" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">用光标进行单向分页</h2><p id="cd9a" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">对于单向分页，我的首选方法是使用简单的游标。这里重要的细节是<strong class="it hv">让</strong> <code class="eh lr ls lt lu b"><strong class="it hv">cursor</strong></code> <strong class="it hv">变得毫无意义</strong>。</p><p id="cdcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就客户端而言，当有更多结果要获取时，它只是服务器在响应<em class="jp">中返回的一个blob。客户端不应该能够从它那里得到任何实现细节，并且它唯一能够<em class="jp">让</em>对这个<code class="eh lr ls lt lu b">cursor</code>做的事情就是在下一个请求中发送它。</em></p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff lv"><img src="../Images/11e54b0e4733c325c506f32ddc733587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ewXFuhjNVfn-bcGny0gg4w.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">fig. 1 — flow of request &amp; responses for a series of paginated requests</figcaption></figure><blockquote class="ma mb mc"><p id="4e63" class="ir is jp it b iu iv iw ix iy iz ja jb md jd je jf me jh ji jj mf jl jm jn jo hn dt translated">但是API如何知道从哪里开始获取下一个页面呢？</p></blockquote><p id="ffa9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个简单的方法是:</p><ol class=""><li id="04a7" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo mg kw kx ky dt translated">创建一个JSON对象来捕获获取下一页所需的数据——例如，如果您使用DynamoDB，那么这可以是下一页的请求对象(包括<code class="eh lr ls lt lu b">ExclusiveStartKey</code>)</li><li id="a038" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">base64编码JSON字符串</li><li id="17cb" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">将base64 blob作为<code class="eh lr ls lt lu b">cursor</code>返回</li></ol><p id="58e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们接收到获取下一页的请求时，我们可以应用相反的过程来取回我们之前创建的请求对象。</p><blockquote class="ma mb mc"><p id="40a4" class="ir is jp it b iu iv iw ix iy iz ja jb md jd je jf me jh ji jj mf jl jm jn jo hn dt translated">这难道不会泄露更多的信息吗——例如，您正在使用DynamoDB、表名、模式等。—如果有人对你的blob进行64位解码呢？</p></blockquote><p id="523a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，这就是为什么你也可以选择先加密JSON。您也不必使用DynamoDB <a class="ae le" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html" rel="noopener ugc nofollow" target="_blank">查询</a>请求作为基础。</p><p id="fb48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意在<code class="eh lr ls lt lu b">fig. 1</code>和<code class="eh lr ls lt lu b">fig. 2</code>中，客户端只在后续请求中发送<code class="eh lr ls lt lu b">cursor</code>？</p><p id="c461" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">这是设计好的</strong>。</p><p id="bd83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我前面提到的，客户端已经在第一个请求中告诉了我们查询，分页机制应该<em class="jp">只</em>提供获取结果的后续页面的方法。</p><p id="aa40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对我来说，这意味着它不应该<em class="jp">为</em>提供任何其他行为(这个词又出现了，<a class="ae le" href="http://theburningmonk.com/2015/04/random-thoughts-on-api" rel="noopener ugc nofollow" target="_blank">在这里阅读</a>以了解<strong class="it hv">启示</strong>的思想如何应用于API设计)，因此不需要除了之前响应中的<code class="eh lr ls lt lu b">cursor</code>之外的任何其他信息。</p><p id="5cee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这反过来意味着我们需要在<code class="eh lr ls lt lu b">cursor</code>中捕获原始查询或意图，这样我们就可以构造相应的DynamoDB请求。或者，我们可以在<code class="eh lr ls lt lu b">cursor</code>中捕获实际的DynamoDB请求，这看起来是一个简单、实用的解决方案。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff mh"><img src="../Images/0a4626053e072636be34631590d68779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGooWuQoZeEonwl3lJpLHw.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">fig. 2 — interaction between client, API and DynamoDB</figcaption></figure><h2 id="fef1" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">使用光标进行双向分页</h2><p id="ad44" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">使用双向分页，您需要能够及时向前翻页(当新的推文添加到您的时间线时)以及向后翻页(获取旧的推文)。所以一个简单的字符串<code class="eh lr ls lt lu b">cursor</code>已经不够了，取而代之的是我们需要两个光标，每个方向一个，例如…</p><pre class="lg lh li lj fq mi lu mj mk aw ml dt"><span id="1308" class="jq jr hu lu b fv mm mn l mo mp">{<br/>  "before": "ThlNjc5MjUwNDMzMA...",<br/>  "after": "ADfaU5ODFmMWRiYQ..." <br/>}</span></pre><p id="12e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，当向前翻页时，即使现在没有更多的结果，我们仍然必须返回一个游标，因为新的结果可以在以后添加到提要中。因此，我们还应该在响应中包含一对布尔标志。</p><pre class="lg lh li lj fq mi lu mj mk aw ml dt"><span id="3fd0" class="jq jr hu lu b fv mm mn l mo mp">{<br/>  "before": "ThlNjc5MjUwNDMzMA...",<br/>  "hasBefore": true,<br/>  "after": "ADfaU5ODFmMWRiYQ...",<br/>  "hasAfter": true<br/>}</span></pre><p id="8c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当客户端及时向前翻页并接收到作为<code class="eh lr ls lt lu b">false</code>的<code class="eh lr ls lt lu b">hasAfter</code>时，它知道现在没有更多可用的结果。因此，它可以主动停止<em class="jp"/>获取下一页结果，并且更加被动，仅周期性地轮询新结果。</p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="d9ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看一个简单的例子，想象一下，如果你在你的时间线中获取推文，API将首先返回最新的推文。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff mx"><img src="../Images/445e6fd8bcf8eeb4610e25d5a46e6af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IbwvqAOLhq7BHjQ_wJTGlQ.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">fig. 3 — paginate backward in time to fetch older data</figcaption></figure><ol class=""><li id="68ae" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo mg kw kx ky dt translated">客户端发出第一个请求</li><li id="92ba" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">API用一个<code class="eh lr ls lt lu b">cursor</code>对象响应，<code class="eh lr ls lt lu b">hasAfter</code>是<code class="eh lr ls lt lu b">false</code>,因为API已经用最新的结果响应，但是<code class="eh lr ls lt lu b">hasBefore</code>是<code class="eh lr ls lt lu b">true</code>,因为有旧的结果可用</li><li id="516f" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">客户端发出第二个请求，并在请求中只传递<em class="jp">和</em>光标<code class="eh lr ls lt lu b">before</code>，使其意图清晰明确</li><li id="9d22" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">API用另一个<code class="eh lr ls lt lu b">cursor</code>对象来响应，这次<code class="eh lr ls lt lu b">hasBefore</code>和<code class="eh lr ls lt lu b">hasAfter</code>都是<code class="eh lr ls lt lu b">true</code>，因为我们就在这个结果流的中间</li><li id="e314" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">客户端发出第三个也是最后一个请求，再次只传递从上一个响应接收到的<code class="eh lr ls lt lu b">before</code>光标</li><li id="c259" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">API用一个<code class="eh lr ls lt lu b">cursor</code>对象响应，其中<code class="eh lr ls lt lu b">hasBefore</code>是<code class="eh lr ls lt lu b">false</code>，因为我们现在已经收到了最早的可用结果</li></ol></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="1a6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好，现在让我们来看另一个例子，这次我们将向前翻页。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff my"><img src="../Images/5183e2ea82238a036166bf124a939ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKOneX23fkQnJmQ1KsjNmw.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">fig. 4 — paginate forward in time to fetch newer data</figcaption></figure><ol class=""><li id="6c0b" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo mg kw kx ky dt translated">客户端发出第一个请求</li><li id="e9cf" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">API用一个<code class="eh lr ls lt lu b">cursor</code>对象响应，<code class="eh lr ls lt lu b">hasAfter</code>是<code class="eh lr ls lt lu b">false</code>，因为API已经用最新的结果响应，但是<code class="eh lr ls lt lu b">hasBefore</code>是<code class="eh lr ls lt lu b">true</code>，因为有旧的结果可用</li><li id="4f06" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">一段时间过去了，有了更多的结果</li><li id="c325" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">客户端发出第二个请求，并在请求中只传递光标<code class="eh lr ls lt lu b">after</code>，使其意图清晰明确</li><li id="dcb2" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo mg kw kx ky dt translated">API仅用<em class="jp">响应</em>客户端尚未收到的较新的结果，并且<code class="eh lr ls lt lu b">cursor.hasAfter</code>是<code class="eh lr ls lt lu b">false</code>，因为这些是此时此刻可用的最新结果；如果客户机从这个响应向后翻页(在时间上),那么它将收到与来自API的第一个响应相同的结果</li></ol></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="a995" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们回到我前面提到的关于偶尔需要在分页中途改变方向的问题。</p><p id="e3c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要分页的原因是因为它通常不切实际，效率低下，并且在某些情况下不可能返回一个查询的所有可用结果——例如，在撰写本文时，Katy Perry有1.08亿Twitter粉丝，试图在一个请求-响应周期中检索她的所有粉丝会使服务器和客户端应用程序崩溃。</p><p id="5880" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了限制在一个请求-响应周期中可以返回多少数据，我们还需要<strong class="it hv">为客户端应用程序缓存多少数据设置一个上限，以保护用户体验并防止客户端应用程序崩溃</strong>。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff mz"><img src="../Images/94d921da3a51daab773e993c6fbf0279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rn8eb4u1mfjn5cZkTvC1_w.png"/></div></div></figure><p id="de4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，在某种程度上，当用户不断滚动旧的推文时，客户端需要开始丢弃已经获取的数据，否则就会面临内存不足的风险。这意味着，当用户向上滚动以查看最新的tweets时，客户端将需要重新获取已经被丢弃的页面，从而反转分页的原始方向。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff na"><img src="../Images/d58200f7ab2e72aa8bf1deabf250a93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CG7Dgtak_LS28DCY-VfBbA.png"/></div></div></figure><p id="9480" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，上面概述的方案足够灵活，允许您这样做。结果的每一页都有一个相关联的<code class="eh lr ls lt lu b">cursor</code>,允许您从任一方向获取下一页。因此，如果您需要重新获取被删除的页面，只需用您缓存的最新页面的<code class="eh lr ls lt lu b">after</code>光标发出分页请求即可。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff nb"><img src="../Images/b87a0b09cde08129cc235f1caa4653f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hfgqnW7uqx-alPYzrHGLg.png"/></div></div></figure><h2 id="93e6" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">处理“差距”</h2><p id="df03" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">继续以Twitter为例。如果你在一段时间后打开Twitter移动应用程序，你会看到已经被缓存的推文，但应用程序也意识到已经过了很长时间，从缓存的数据一直分页到最新数据是不可行的。</p><p id="d52a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，客户端将通过非分页请求获取最新的tweets。当你向下滚动时，客户端<em class="jp">可以按照<code class="eh lr ls lt lu b">fig. 3</code>自动获取旧页面，并逐渐填补空白，直到它与缓存的数据结合。</em></p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff nc"><img src="../Images/bda0fbc4e11d351b3775088f80faa8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17eDruSKp5bjfsER9qaJhw.png"/></div></div></figure><p id="9ca5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着时间的推移，Twitter移动应用的行为已经发生了变化，我看到的另一个策略是在时间轴中为丢失的推文放置一个可视(可点击)标记。这使得用户开始翻阅旧推文以填补空白成为一个明确的动作。</p><p id="b0e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你有了它，一个简单有效的实现单向和双向分页API的方法，希望你觉得它有用！</p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><figure class="lg lh li lj fq lk fe ff paragraph-image"><div class="ab fr cl nd"><img src="../Images/8b4e4721bb1973db389b5b533d727ad1.png" data-original-src="https://miro.medium.com/v2/format:webp/0*b_1R345KzKSaI8sg.png"/></div></figure><p id="f870" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗨，我的名字是<strong class="it hv">崔琰</strong>。我是一个<a class="ae le" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> AWS无服务器英雄</strong> </a>和<a class="ae le" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过<a class="ae le" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae le" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae le" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看我的新课程，<a class="ae le" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击获取您的副本<a class="ae le" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff ne"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="it hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、金丝雀部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码<strong class="it hv"> ytcui </strong>还可以获得<strong class="it hv">票面价格6折</strong>。</p><p id="2e68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击获取您的副本<a class="ae le" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>