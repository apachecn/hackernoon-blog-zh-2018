<html>
<head>
<title>How Immutable Data Structures (E.g. Immutable.js) are Optimized</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优化不可变数据结构(例如，不可变. js)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56?source=collection_archive---------3-----------------------#2018-02-11">https://medium.com/hackernoon/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56?source=collection_archive---------3-----------------------#2018-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d599127273be0e5f8e242c126a03c0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EH8fUs0efZRMgJ9C.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="http://leonov.net" rel="noopener ugc nofollow" target="_blank">http://leonov.net</a></figcaption></figure><p id="6b12" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近我一直在用T4 JavaScript T5学习T2函数编程。由于函数式代码的优雅，我开始真正喜欢函数式编程。</p><p id="f14c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不变性是函数式编程的基石之一。以下是使用不可变对象的一些优点。</p><ul class=""><li id="6bde" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">不可变对象更容易构造、测试和使用</li><li id="dac5" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">真正不可变的对象总是线程安全的</li><li id="193e" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">它们有助于避免<a class="ae jg" href="http://enterprisecraftsmanship.com/2017/04/10/temporal-coupling-and-immutability/" rel="noopener ugc nofollow" target="_blank">时间耦合</a></li><li id="45be" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">他们的使用是无副作用的</li></ul><p id="6e9f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想了解更多关于为什么你应该使用不可变对象的知识，这篇文章是一篇很好的文章。</p><p id="dcec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是当谈到不变性时，首先想到的问题是性能。举个例子，假设我们有一个整数数组。我们需要改变数组中的一个整数。现在，如果我们想保持不变，而不是改变数组的位置，我们需要保持原来的数组完好无损，并返回一个新的数组与改变的整数。为此，我们需要创建一个新的数组并复制旧的元素。这比就地改变阵列要昂贵得多。</p><p id="ab2c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将讨论一种用于优化不可变数据结构的方法，称为“结构共享”。首先，让我们学习什么是持久数据结构。</p><h1 id="d587" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">持久数据结构</h1><p id="8f57" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">这就是维基百科引入持久数据结构的方式，</p><blockquote class="lw lx ly"><p id="f1c0" class="jh ji lz jj b jk jl jm jn jo jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd ke hn dt translated">在<a class="ae jg" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank">计算</a>中，<strong class="jj hv">持久数据结构</strong>是一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，当它被修改时，总是保存它自己的前一个版本。这种数据结构实际上是<a class="ae jg" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">不可变的</a>，因为它们的操作不会(明显地)就地更新结构，而是总是产生新的更新结构。</p></blockquote><p id="d9e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">持久数据结构通常用在函数式编程中，因为这增强了不变性。几乎所有的函数式编程语言都有持久数据结构的实现。<a class="ae jg" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>是一个实现持久数据结构的JavaScript库。</p><p id="e5c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些实现经过了大量优化，以提高性能。结构共享是用于优化的技术之一。</p><h1 id="2139" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">努力</h1><p id="a14e" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">首先，如果你不熟悉Trie数据结构，我们需要先了解什么是Trie。Trie是一种特殊的树数据结构。看看维基百科上的下图。</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/b194b30b399ca42267fefd2c7ef9a924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oaidXCwPponpPudyGbvkA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">wikipedia</figcaption></figure><p id="720e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这与二叉树不同，因为没有节点专门存储与该节点相关联的键。节点在树中的位置定义了它所关联的键。某个节点下的所有节点都有一个公共前缀。值往往只与叶(以及一些内部节点，如果它们有意义的话)相关联。尝试通常用于存储字典。从这个例子中我们可以看到，我们可以很容易地验证单词并获得部分单词的建议。请参考<a class="ae jg" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank">此处</a>了解试炼详情。</p><h1 id="6411" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">使用Trie来表示数组</h1><p id="a8c1" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">现在我们知道了Trie是什么，让我们看看如何用Trie来表示一个数组。以下面的数组为例，</p><p id="bd7b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">[“红”、“绿”、“蓝”、“黄”、“粉”、“紫”、“黑”、“白”]</p><p id="56dc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看看如何用Trie来表示它。</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/08c12e77dc00cef341af85b36d84fd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-XNc8Q1vS4vVie_0_vF8w.png"/></div></div></figure><p id="2c59" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不错吧。</p><p id="c051" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以现在你会问我如何得到索引1的元素。如果按照路径“001”(0表示左节点，1表示右节点。从根节点开始，你可以找到索引为1的元素(绿色)。每个叶节点都有一个唯一的地址。使用这些，我们可以索引元素。</p><p id="7bcf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们看看为什么我们把数组表示为一个Trie。假设我们需要将这个数组的最后一个元素从“白色”改为“棕色”。我们希望以持续的方式完成这项工作。因此，改变原始数据结构不是一个解决方案。让我们来看看下图。</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/b3660790c87acdfc1d58ae8ed3f2528f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8P_6AOp6CypxDlvu3O8IA.png"/></div></div></figure><p id="31b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以看到旧的根仍然在那里，您可以使用它来访问旧的数组。添加新元素后的数组是具有新根的结构。通过重用旧的结构，我们用新元素创建了一个新的数组。如果我们有一个传统的数组，我们必须复制所有的元素。</p><h1 id="0fe3" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">使用Trie来表示散列图或对象(JavaScript)</h1><p id="3223" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">我们已经了解了如何将数字索引数据结构表示为一个Trie，并使用结构共享来优化它作为一个持久数据结构。接下来让我们看看如何用非数字键来表示一个对象。</p><p id="f56c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这很简单。在散列映射中，我们为每个键获取一个数字散列，并使用它来创建一个数据结构。我们可以在这里使用相同的想法。</p><pre class="me mf mg mh fq mk ml mm mn aw mo dt"><span id="2d72" class="mp ku hu ml b fv mq mr l ms mt">hash('a') = 97</span></pre><p id="27cb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们把一个字符串的哈希值作为它的字符ASCII值的总和。然后我们得到的是97。我们可以使用这个值和模运算来创建一个Trie来表示数据结构。如果你想了解更多关于哈希表的工作原理，请参考<a class="ae jg" href="https://dzone.com/articles/how-hashmap-works-in-java" rel="noopener ugc nofollow" target="_blank">这里的</a>。使用Trie数据结构，我们可以以更有效的方式持久地处理对数据结构的修改。</p><h1 id="b9af" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">分支因子</h1><p id="79a5" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">考虑到分支因素，为了简单起见，我们在示例中使用了双向分支。但是对于一个大的数组，这将意味着一个非常深的树。深树提供了大量的共享，因此减少了内存的使用，但是随着树越来越深，修改的时间也增加了。应该有一个平衡。<a class="ae jg" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> Clojure </a>(一种函数式编程语言)使用32路分支。这提供了良好的平衡。十亿个元素的Clojure数组只有6个节点深。你需要350亿个节点来达到8个节点的深度。</p><h1 id="b630" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">修改的时间复杂性</h1><p id="1977" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">传统上，如果你想创建一个新的数组并改变一个元素，需要O(n)时间。但是通过尝试的表示和使用结构共享，它可以降低到O(log(branch _ factor)n)。由于分支因子是一个常数，这意味着O(log n)。</p><h1 id="62d5" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">结论</h1><p id="207e" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">在本文中，我们已经学习了如何使用带有try的结构共享来实现高效的持久数据结构。欲了解更多信息，请查看参考资料。</p><p id="e69e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">参考文献:</strong></p><ul class=""><li id="34c4" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">不可变. js文档<a class="ae jg" href="https://facebook.github.io/immutable-js/docs/#/" rel="noopener ugc nofollow" target="_blank">https://facebook.github.io/immutable-js/docs/#/</a></li><li id="bd00" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">clo jure persistent vectors<a class="ae jg" href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" rel="noopener ugc nofollow" target="_blank">http://hypi rion . com/musings/understanding-persistent-vector-pt-1</a></li></ul><h2 id="2c33" class="mp ku hu bd kv mu mv mw kz mx my mz ld js na nb lh jw nc nd ll ka ne nf lp ng dt translated">在你走之前！</h2><p id="ec28" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">如果你喜欢这篇文章，欢迎鼓掌！！！</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>