<html>
<head>
<title>Using AWS Lambda functions for micro jobs with no startup delay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对没有启动延迟的微作业使用AWS Lambda函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-aws-lambda-functions-for-micro-jobs-1b9ff56c0f2?source=collection_archive---------6-----------------------#2018-02-11">https://medium.com/hackernoon/using-aws-lambda-functions-for-micro-jobs-1b9ff56c0f2?source=collection_archive---------6-----------------------#2018-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="0e12" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">背景</h1><ul class=""><li id="7b99" class="jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">过去:处理僵化的裸机服务器。最小粒度:-</li><li id="32db" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">最近—使用Kubernetes或其他工具建立了一个自动扩展环境。基于传入的请求向上和向下扩展。最小粒度:一台虚拟机</li><li id="fba9" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">今天——使用Lambda或Google函数，我们可以在几秒钟内扩展到10，000个cpu，然后缩小到零。最小粒度:一个内核，128MB内存</li></ul><p id="798c" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">对于AWS Lambda和谷歌云功能，有两个问题。他们有<strong class="jr hv">高启动时间</strong>，接近10ms，他们有<strong class="jr hv">最小100ms时间粒度</strong>。</p><p id="367c" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">这意味着如果我想为我的需要12毫秒的http请求提供服务，首先我将面临近10毫秒的延迟，只是为了启动该功能，然后两个平台将向我收取100毫秒的时间，即使我只需要12毫秒。这使得云功能不适合正常使用。</p><p id="9dda" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">这里将消除这两个问题。</p><h1 id="bf8f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">解决办法</h1><p id="dc40" class="pw-post-body-paragraph km kn hu jr b js jt kp kq ju jv ks kt jw ld kv kw jy le ky kz ka lf lb lc kc hn dt translated">我们的想法是调用一个Lambda函数，但不是让它做一个请求，我们将<strong class="jr hv">保持它在</strong>附近，以亚微秒延迟服务更多请求。因为它将服务于许多请求，我们可能也不关心100秒的时间粒度。</p><p id="3fc5" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">方法很简单。但是您需要了解一点gRPC和双向连接。两者都是非常简单的概念。</p><p id="9595" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">我们创建了一个http服务器和一个gRPC服务器。当我们有流量时，我们调用一个或多个Lambda函数。</p><p id="b662" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">这些Lambda函数创建了到gRPC服务器的双向连接，gRPC服务器与http服务器一起运行。</p><p id="ef70" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">现在http server通过grpc将负载转发给Lambda函数，并返回结果。</p><p id="35cc" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">我们只需要一种机制来调用足够的Lambda函数来处理我们的流量。</p><p id="24c3" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">我写了一个框架来帮助解决这个问题:<a class="ae lg" href="https://github.com/kavehmz/jobber" rel="noopener ugc nofollow" target="_blank">https://github.com/kavehmz/jobber</a></p><p id="37c8" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">解决方案并不依赖于这些，但我选择gRPC作为RPC框架，protobuf作为数据交换格式，并着手实现它。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/5e550e6208c576e3a00c4936d4704a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hCBcDNB9DVT8DmLEiEmYA.png"/></div></div></figure><h1 id="4170" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">数据交换格式</h1><p id="0095" class="pw-post-body-paragraph km kn hu jr b js jt kp kq ju jv ks kt jw ld kv kw jy le ky kz ka lf lb lc kc hn dt translated">Protobuf是一种简单的<a class="ae lg" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">格式</a>。</p><p id="84e7" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">有效载荷定义在<code class="eh lt lu lv lw b">payload/payload.proto</code>。</p><p id="da4f" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">如果你要编码/解码你的数据，什么是足够的，否则编辑<code class="eh lt lu lv lw b">payload.proto</code>并重新生成go文件。</p><h1 id="df28" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">λ调度程序</h1><p id="9938" class="pw-post-body-paragraph km kn hu jr b js jt kp kq ju jv ks kt jw ld kv kw jy le ky kz ka lf lb lc kc hn dt translated">要调用Lambda函数，您需要将调度程序传递给<code class="eh lt lu lv lw b">NewJobber</code>。</p><p id="69cc" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">我实现了两个调度程序。</p><ul class=""><li id="f503" class="jp jq hu jr b js ko ju kr jw lx jy ly ka lz kc kd ke kf kg dt translated">戈鲁丁。Goroutine:一个虚拟调度程序，它只是为了测试的目的而存在。</li><li id="775d" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">awslambda。LambdaScheduler:一个简单的调度程序，它可以调用lambda函数来发送任务给它。</li></ul><pre class="li lj lk ll fq ma lw mb mc aw md dt"><span id="3c3a" class="me is hu lw b fv mf mg l mh mi">s := grpc.NewServer()<br/>	taskMachine = jobber.NewJobber(jobber.Scheduler(&amp;goroutine.Goroutine{GrpcHost: "localhost:50051"}))<br/>	taskMachine.RegisterGRPC(s)</span></pre><p id="fb22" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">调度程序需要实现以下接口:</p><pre class="li lj lk ll fq ma lw mb mc aw md dt"><span id="8541" class="me is hu lw b fv mf mg l mh mi">interface {<br/>	// Inbound is called before a new task is added.<br/>	Inbound()<br/>	// Done is called when a task is done<br/>	Done()<br/>	// Timedout is called when no response was received on time for a task<br/>	Timedout()<br/>}</span></pre><h1 id="10ed" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">试运转</h1><p id="82fb" class="pw-post-body-paragraph km kn hu jr b js jt kp kq ju jv ks kt jw ld kv kw jy le ky kz ka lf lb lc kc hn dt translated">包括一个虚拟测试案例和一个使用lamba调度器的例子。</p><p id="292e" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">要了解它是如何工作的，只需简单地做以下事情</p><p id="b6b8" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">在一个终端中运行示例</p><pre class="li lj lk ll fq ma lw mb mc aw md dt"><span id="9462" class="me is hu lw b fv mf mg l mh mi">$go run example/goroutine/main.go <br/>2018/02/11 14:48:57 Start listening gRPC at 50051<br/>2018/02/11 14:49:17 minion: job inbound 0 0<br/>2018/02/11 14:49:17 worker[1]: Hi, I was invoked and I am trying to connect to accept jobs<br/>2018/02/11 14:49:17 worker[1]: I Joined the workforce<br/>2018/02/11 14:49:17 server: A new minion joined to help<br/>2018/02/11 14:49:17 server: got a job<br/>2018/02/11 14:49:17 worker[1]: received a task from server data:"This is the payload I will send to Lambda." <br/>2018/02/11 14:49:18 worker[1]: task is done<br/>2018/02/11 14:49:18 server: received the response<br/>2018/02/11 14:49:18 server: send the response<br/>2018/02/11 14:49:18 server: send the response back to client<br/>2018/02/11 14:49:18 minion: job done<br/>2018/02/11 14:49:18 Example: received data:"2018-02-11 14:49:18.623911211 +0100 CET m=+21.589500545"  &lt;nil&gt;</span></pre><p id="0df1" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">在另一个终端发送请求</p><pre class="li lj lk ll fq ma lw mb mc aw md dt"><span id="0699" class="me is hu lw b fv mf mg l mh mi">$ curl 'http://localhost:8000/'<br/>2018-02-11 14:49:18.623911211 +0100 CET m=+21.589500545</span></pre><p id="e210" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">在代码中，您的请求发送到http服务器。您的处理程序将调用Do并等待响应。管理Lambda函数以及发送和接收消息由jobber完成</p><pre class="li lj lk ll fq ma lw mb mc aw md dt"><span id="2124" class="me is hu lw b fv mf mg l mh mi">resp, err := myJobber.Do(&amp;payload.Task{Data: "This is the payload I will send to Lambda."})<br/>if err != nil {<br/>	resp = &amp;payload.Result{Data: "Because of error result was returned as nil"}<br/>}<br/>log.Println("Example: Recevied", resp, err)<br/>fmt.Fprint(w, resp.Data)</span></pre><h1 id="5629" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">测试λ</h1><p id="eb6f" class="pw-post-body-paragraph km kn hu jr b js jt kp kq ju jv ks kt jw ld kv kw jy le ky kz ka lf lb lc kc hn dt translated">如果你熟悉Lambda函数，设置一个很容易。</p><p id="8523" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">但是请注意，lambda函数需要连接回批发商所依赖的grpc服务器。因此，他们必须在同一个网络(VPC)，或以某种方式，他们需要访问您的grpc端口。</p><p id="47e0" class="pw-post-body-paragraph km kn hu jr b js ko kp kq ju kr ks kt jw ku kv kw jy kx ky kz ka la lb lc kc hn dt translated">在<code class="eh lt lu lv lw b">example/lambda</code>你可以看到一个例子，在<code class="eh lt lu lv lw b">example/aws_func</code>你可以看到一个简单的Lambda函数。</p></div></div>    
</body>
</html>