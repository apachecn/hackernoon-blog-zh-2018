<html>
<head>
<title>A technical deep dive on Meltdown and does it work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于熔毁的技术深度探讨，它有用吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-technical-deep-dive-on-meltdown-and-does-it-work-5c395579b2a1?source=collection_archive---------15-----------------------#2018-02-11">https://medium.com/hackernoon/a-technical-deep-dive-on-meltdown-and-does-it-work-5c395579b2a1?source=collection_archive---------15-----------------------#2018-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6138" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Meltdown无疑席卷了互联网。攻击看起来非常简单和优雅，然而<a class="ae jp" href="https://meltdownattack.com/meltdown.pdf" rel="noopener ugc nofollow" target="_blank">白皮书</a>遗漏了特定漏洞的关键细节。它主要依赖于缓存计时旁路和访问全局映射内核页面的推测性执行的组合。</p><p id="e4e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种深入探讨假设您对CPU架构和操作系统内核行为有所了解。首先阅读<a class="ae jp" href="https://www.moesif.com/blog/technical/cpu-arch/What-Is-The-Actual-Vulnerability-Behind-Meltdown/#background-on-memory-paging" rel="noopener ugc nofollow" target="_blank">背景章节</a>了解分页和内存保护的入门知识。</p><h1 id="6967" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">攻击的简化版本:</h1><ol class=""><li id="122d" class="ko kp hu it b iu kq iy kr jc ks jg kt jk ku jo kv kw kx ky dt translated">推测性内存读取内核映射(管理程序)页面，然后对值执行计算。</li><li id="60e8" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">基于计算结果，有条件地从存储器向某个其他非缓存位置发出加载。</li><li id="6899" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">虽然当出错异常退出时，第二次加载将从流水线中被核爆，但是它已经向L2发出了加载请求，并且除了确保未完成的存储器请求仍然像预取一样将线带入高速缓存层次结构之外。</li><li id="6ccd" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">最后，一个单独的进程可以向这些相同的内存位置发出加载，并测量这些加载的时间。高速缓存命中将比高速缓存未命中快得多，高速缓存未命中可用于表示二进制1(即命中)和二进制0(即未命中)。</li></ol><p id="915d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第1和第2部分。与指令的推测性执行有关，而第3部分和第4部分使微体系结构状态(即在高速缓存中或不在高速缓存中)能够提交给体系结构状态。</p><h1 id="de8f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">攻击可信吗？</h1><p id="9ca7" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Meltdown白皮书中没有规定的是，什么样的特定x86指令序列或CPU状态可以支持推测性地执行内存访问，并允许向量或整数单元消耗该值。或L2元。在现代英特尔CPU中，当发生错误(如页面错误)时，管道不会被挤压/核化，直到违规指令退役。然而，在加载甚至在L1D中查找或转到内存之前，在所谓的地址生成(AGU)阶段和TLB查找阶段完成了对页面保护、分段限制和规范检查的内存权限检查。以下是更多相关信息。</p><h1 id="d6a5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">执行内存权限检查</h1><p id="3ec3" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">英特尔CPU执行<em class="lh">物理标记的</em> L1D$和L1I$需要将线性(虚拟)地址转换为物理地址，然后L1D$才能通过<em class="lh">标记匹配</em>来确定它在缓存中是命中还是未命中。这意味着CPU将尝试在(翻译后备缓冲区)TLB缓存中查找翻译。TLB将这些转换与页表或页目录许可一起缓存(访问页所需的特权也与物理地址转换一起存储在页表中)。</p><p id="8949" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TLB条目可能包含以下内容:</p><ul class=""><li id="5eca" class="ko kp hu it b iu iv iy iz jc li jg lj jk lk jo ll kw kx ky dt translated">有效的</li><li id="3fd0" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">物理地址减去页面偏移量。</li><li id="d08b" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">读/写</li><li id="ea7d" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">用户/主管</li><li id="6ff2" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">进入</li><li id="0fb4" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">肮脏的</li><li id="98e5" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">Memtype</li></ul><p id="d065" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，即使推测加载已经知道访问该页所需的权限，也要与当前特权级别(CPL)和所需的op特权进行比较，因此可以阻止任何算术单元消耗推测加载。</p><p id="4ad9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此类权限检查包括:</p><ul class=""><li id="55c5" class="ko kp hu it b iu iv iy iz jc li jg lj jk lk jo ll kw kx ky dt translated">分段限制检查</li><li id="3059" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">写入故障</li><li id="18cb" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">用户/主管故障</li><li id="eb1f" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo ll kw kx ky dt translated">页面不存在故障</li></ul><p id="d20c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是许多x86 CPUs实际上被<em class="lh">设计</em>去做的事情。当op失效时，负载将被拒绝，直到软件/uCode处理完故障。负载将在去往整数/向量单元的途中被清零。换句话说，用户/管理员保护故障类似于页面不存在故障或其他页面转换问题，这意味着从L1D$中读出的行应该立即丢弃，并且uOp简单地进入<em class="lh">等待</em>状态。</p><p id="2dc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">防止整数/浮点单元消耗故障负载不仅有利于防止这种泄漏，而且实际上可以提高性能。即，如果L2$未命中L1D$，则故障加载不会用坏数据训练预取器、分配缓冲区来跟踪内存排序或分配填充缓冲区来从其获取数据。这些是现代CPU中有限的资源，不应该被那些不太好的负载消耗掉。</p><p id="8b63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，如果加载错过了TLB，必须执行页面遍历，如果在遍历期间发生故障，一些英特尔CPU甚至会终止PMH中的页面遍历(页面错过处理程序)。页遍历执行了大量的指针追踪，并且必须消耗宝贵的加载周期，所以如果它以后被丢弃的话，取消它是有意义的。此外，PMH有限状态机通常只能同时处理几个页面遍历。</p><p id="7be2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，从性能角度来看，中止L1D Load uOp实际上是一件好事。媒体文章称英特尔下滑是因为他们试图以较低的安全性为代价获取尽可能多的性能，这是不真实的，除非他们想声称推测和缓存的基本概念被认为是折衷。</p><h1 id="435a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">修复</h1><p id="b508" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">虽然这并不意味着熔毁漏洞不存在。这个故事不仅仅是白皮书和大多数新闻帖子所讨论的。大多数帖子声称，只有投机性内存访问和高速缓存计时攻击的<em class="lh">行为</em>才能造成攻击，现在英特尔必须彻底重新设计其CPU或消除投机性执行。</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lm"><img src="../Images/ec840d93acd72a29f021fc1e5207db01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFHwncSahJ2_eeW3SoZUDg.png"/></div></div></figure><p id="1199" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，错误修复可能是一些门的改变，在L1D$管道中添加正确的拒绝逻辑，以掩盖加载命中。英特尔CPU肯定已经获得了这些信息，因为在确定L1D$缓存命中之前，必须完成地址生成和TLB查找阶段。</p><p id="edc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">导致漏洞的所有场景都是未知的。是某些CPU设计错过了对这种架构行为的验证吗？是绕过这些检查的特殊x86指令序列，还是设置CPU状态以确保实际执行加载的一些附加步骤？Project Zero认为，只有在L1D$中出现故障负载时，攻击才会发生。也许英特尔在未命中路径上有逻辑，但在命中路径上有逻辑错误？如果某些英特尔OoO设计对崩溃免疫，我不会感到惊讶，因为这是一个特定的CPU设计和验证问题，而不是一般的CPU架构问题。</p><p id="2ea8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，x86在内存执行单元中有许多不同的流程。例如，某些指令(如MOVNTDQA)在L1D$中的内存顺序和流程与标准的可缓存加载不同。Haswell事务同步扩展和锁增加了验证正确性的复杂性。指令提取通过与D端加载不同的路径进行。验证状态空间非常大。算上所有的旁路网络，你就能看到有多少不同的地方需要验证故障检查。</p><p id="eb30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一点是肯定的，缓存和投机不会很快消失。如果是逻辑上的bug，对于未来的英特尔CPU来说可能是一个简单的修复。</p><h1 id="2244" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么今天这种攻击更容易了？</h1><p id="a72e" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">假设有一条指令即使在有错误的情况下也能使加载命中并消耗，或者我在上面的catch中是错误的，为什么它现在才发生而不是几十年前才被发现。</p><ol class=""><li id="a6fa" class="ko kp hu it b iu iv iy iz jc li jg lj jk lk jo kv kw kx ky dt translated">今天的CPU有更深的管道<em class="lh">咳</em>普雷斯科特<em class="lh">咳</em>这在推测性内存访问和那些出错访问的实际核/挤压之间提供了更宽的窗口。出错指令不被处理，直到该指令退出/提交给处理器架构状态。只有在退役时，管道才会被拆除。长流水线允许在出错指令的执行和它的退出之间有一个大的窗口，允许其他推测性指令跑在前面。</li><li id="dd73" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">与高速缓存命中/整数运算等仅针对CPU的快速运算相比，高速缓存层次结构更大，内存结构速度更慢，这在高速缓存命中和高速缓存未命中/内存之间提供了更大的周期时间差，从而支持更强大的高速缓存计时攻击。今天的大型多核服务器CPU使用精心制作的网状结构来连接数十或数百个内核，这一点被夸大了。</li><li id="5ec9" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">x86 CLFLUSH和PREFETx等细粒度缓存控制的性能增强特性为缓存计时攻击提供了更多控制。</li><li id="171a" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">更广泛的处理器，可同时支持并行整数、浮点和内存操作。人们可以将长浮点操作(如divide或sqrt)放在出错指令之前，以保持内核忙碌，但仍然保持整数和内存管道不受攻击。由于出错的指令在退役之前不会核化流水线，所以它必须等到指令序列中任何更早的指令被提交，包括长时间运行的浮点运算。</li><li id="5f32" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">虚拟化和PaaS。许多网络规模的公司现在都在运行工作负载云提供商，如AWS和Azure。在云计算出现之前，财富500强公司会在自己的硬件上运行自己的可信应用。因此，不同公司的应用程序在物理上是分离的，这与今天不同。虽然Meltdown是否允许来宾操作系统侵入虚拟机管理程序或主机操作系统尚不清楚，但已知的是许多虚拟化技术比成熟的VT-x更轻量级。例如，Heroku、AWS Beanstalk或Azure Web应用程序中的多个应用程序以及Docker容器都在同一个虚拟机中运行。公司不再为每个应用程序配置单独的虚拟机。这可能允许恶意应用程序读取特定虚拟机的内核内存。在90年代，随着Pentium Pro/Pentium III的出现，OoO执行成为主流，共享资源不再是一个问题。</li><li id="d9c7" class="ko kp hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">在x86分页条目中使用全局位和用户/管理员位，这使得内核内存空间能够映射到每个用户进程(但受到保护，不会执行Ring3代码),从而降低TLB的压力，并减缓上下文切换到独立内核进程的速度。这种性能优化从20世纪90年代就开始了</li></ol><h1 id="8ca7" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">这是x86特有的吗？</h1><p id="9f0a" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">首先，缓存计时攻击和推测性执行并不是英特尔或x86 CPUs所特有的。大多数现代CPU在你的手表或微波炉的几个嵌入式微处理器之外实现多级缓存和大量的推测。</p><p id="1cba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是英特尔或x86的特定问题，而是一般CPU架构的基本问题。现在有人声称，特定的OoO ARM CPUs，如iPhones和智能手机中的CPU，也存在这一缺陷。乱序执行自从被Tomasulo算法引入以来已经完成。与此同时，缓存计时攻击几十年来一直为人所知，因为众所周知，数据可能会在不应该的时候被加载到缓存中。然而，缓存计时攻击传统上被用来寻找内核内存的位置，而不是实际读取它的能力。这更像是一种竞争条件和窗口，具体取决于微体系结构。一些CPU的管道比其他CPU浅，导致核爆发生得更快。像x86这样的现代桌面/服务器CPU具有从CLFLUSH到PREFETCHTx的更精细的功能，这些功能可以作为附加工具来使连接更加健壮。</p><h1 id="5633" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">内存分页的背景</h1><p id="3dc1" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">自从在386和Windows 3.0中引入分页以来，操作系统就一直使用这一功能来将一个进程的内存空间与另一个进程的内存空间隔离开来。一个进程将被映射到它自己独立的虚拟地址空间，该空间独立于另一个正在运行的进程的地址空间。这些虚拟地址空间由物理内存支持(页面可以换出到磁盘，但这超出了本文的范围)。</p><p id="0c63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，假设<em class="lh">进程1 </em>需要4KB内存，因此操作系统分配了4KB的虚拟内存空间，其字节可寻址范围从0x0到0xFFF。该范围由从位置0x1000开始的物理内存支持。这意味着进程1的<code class="eh ly lz ma mb b">[0x0-0xFFF]</code>被“安装”在物理位置<code class="eh ly lz ma mb b">[0x1000-0x1FFF]</code>。如果有另一个进程正在运行，它也需要4KB，因此操作系统将为这个<em class="lh">进程2 </em>映射第二个虚拟地址空间，范围为0x0到0xFFF。这个虚拟内存空间也需要物理内存的支持。由于进程1已经在使用0x1000-0x1FFF，操作系统将决定为进程2分配下一块物理内存[0x2000-0x2FFF]。</p><p id="6fbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种设置下，如果进程1从内存向线性地址0x0发出加载请求，操作系统会将其转换为物理位置0x1000。而如果进程2从内存向线性地址0x0发出加载，操作系统会将其转换为物理位置0x2000。注意这里需要一个翻译。这是页表的工作。</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff mc"><img src="../Images/7bb8f71b02b6ce8a99cadf10886b9a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3kL_U8iivQeHE0UBXs7vw.png"/></div></div></figure><p id="6604" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一系列映射内存被称为一个<em class="lh">页面</em>。CPU架构有一个定义的页面大小，如4KB。分页允许内存在物理内存空间中分段。在上面的例子中，我们假设页面大小为4KB，因此每个进程只映射一个页面。现在，让我们假设<em class="lh">进程1 </em>执行一个malloc()并强制内核映射第二个4KB的区域。由于物理内存的下一页[0x 2000–0x 2 fff]已经被<em class="lh">进程2 </em>使用，操作系统需要分配一个空闲的物理内存块[0x 3000–0x 3 fff]给<em class="lh">进程1 </em>(注意:现代操作系统使用延迟/惰性内存分配，这意味着虚拟内存可以在被任何物理内存支持之前创建，直到页面被实际访问，但这超出了本文的范围。请参阅x86页面访问/脏位了解详情)。</p><p id="2001" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">地址空间<em class="lh">看起来</em>与进程相邻，但实际上是跨物理内存空间的碎片:</p><h1 id="80df" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">流程1</h1><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff md"><img src="../Images/f8899ffa569505701676fbae4d062d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWfvGZZZCz8jEY2-4M5q9w.png"/></div></div></figure><h1 id="76b2" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">流程2</h1><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff md"><img src="../Images/5ff4f0549a0ca037e123771cf8d1161a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvrIQKVOi0JvI-5xKTHZLQ.png"/></div></div></figure><p id="47a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在此之前还有一个额外的转换步骤，使用x86分段将逻辑地址转换为线性地址。然而，今天大多数操作系统不使用传统意义上的分段，所以我们现在忽略它。</p><h1 id="dafa" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">内存保护</h1><p id="7bd4" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">除了创建虚拟地址空间，分页也是一种保护形式。上述翻译存储在一个名为<em class="lh">页表</em>的结构中。每个4KB页面可以有特定的属性和访问权限，与翻译数据本身一起存储。例如，可以将页面定义为只读。如果对内存的只读页面执行内存存储，则CPU会触发一个故障。</p><p id="972e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">直接来自x86参考手册，下面的<em class="lh">非穷举</em>属性位列表(其行为类似于布尔真/假)与每个页表条目一起存储:</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff me"><img src="../Images/70eb2416cad80b73b9fafbea5cc26c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1y-2n6uzzU1e9F7Ma42GOA.png"/></div></div></figure><h1 id="ae24" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">最小化上下文切换成本</h1><p id="023e" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我们展示了每个进程如何拥有自己的虚拟地址映射。内核进程和其他进程一样，也有一个虚拟内存映射。</p><p id="106c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当CPU将上下文从一个进程切换到另一个进程时，切换成本很高，因为许多体系结构状态需要保存到内存中，以便挂起的旧进程在再次开始执行时可以使用保存的状态继续执行。</p><p id="cfaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，许多系统调用需要由内核来执行，如I/O、中断等。这意味着CPU会不断地在用户进程和内核进程之间切换，以处理这些系统调用。</p><p id="81d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了最小化这个成本，内核工程师和计算机架构师将内核页面映射到用户虚拟内存空间中，以避免上下文切换。这是通过<em class="lh">用户/管理员</em>访问权限位完成的。操作系统映射内核空间，但只将其指定为<em class="lh">管理员</em>(也称为Ring0)访问，因此任何用户代码都不能访问这些页面。因此，这些页面对于任何在用户权限级别运行的代码来说都是不可见的</p><p id="8a4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<em class="lh">用户模式</em>下运行时，如果CPU发现指令访问需要管理员权限的页面，则触发页面错误。在x86中，页面访问权限是能够触发<a class="ae jp" href="https://en.wikipedia.org/wiki/Page_fault" rel="noopener ugc nofollow" target="_blank"> #PF(页面错误)</a>的分页相关原因之一。</p><h1 id="5d4c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">全球位</h1><p id="19b3" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我们展示了每个进程如何拥有自己的虚拟地址映射。内核进程和其他进程一样，也有一个虚拟内存映射。大多数翻译都是进程私有的。这确保了<em class="lh">进程1 </em>不能访问<em class="lh">进程2 </em>的数据，因为从<em class="lh">进程1 </em>到【0x 2000–0x 2 fff】物理内存没有任何映射。然而，许多系统调用由许多进程共享，以处理发出I/O调用、中断等的进程。</p><p id="f28d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，这意味着每个进程将复制内核映射，这给缓存这些翻译带来了压力，并增加了进程间上下文切换的成本。全局位使这些特定的转换(即内核内存空间)在所有进程中可见。</p><h1 id="4960" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结束语</h1><p id="998f" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">探究安全问题总是很有趣的。与20世纪90年代不同，现在的系统被认为是安全的，并且随着加密、生物识别验证、移动支付和数字医疗的发展，系统变得更加重要。对于今天的消费者和企业来说，大臀位比90年代更可怕。同时，我们也需要继续讨论新的报告。</p><p id="8c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">引发熔毁漏洞的步骤已被各方证明。然而，导致崩溃的可能不仅仅是<em class="lh">投机和缓存计时攻击的行为</em>,也不是CPU架构的根本故障，而是一个逃过验证的逻辑错误。这意味着，猜测和缓存不会很快消失，英特尔也不会需要一个全新的架构来修复崩溃。相反，未来x86 CPUs中唯一需要的变化是对组合逻辑进行一些小的门更改，这些更改会影响确定L1D$(或任何临时缓冲区)中的命中是否是好的。</p></div></div>    
</body>
</html>