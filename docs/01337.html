<html>
<head>
<title>5 speed improvements in Python 3.7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.7中的5项速度改进</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/5-speed-improvements-in-python-3-7-1b39d1581d86?source=collection_archive---------1-----------------------#2018-02-12">https://medium.com/hackernoon/5-speed-improvements-in-python-3-7-1b39d1581d86?source=collection_archive---------1-----------------------#2018-02-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir"><p id="2fcf" class="is it hu bd iu iv iw ix iy iz ja jb ek translated">Python 3.7处于测试阶段！是时候做测试了…有没有快一点？</p></blockquote><p id="6d45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jb hn dt translated">以下是Python 3.7相对于3.6的主要速度提升</p><blockquote class="jz ka kb"><p id="4b67" class="jc jd kc je b jf kd jh ji jj ke jl jm kf kg jp jq kh ki jt ju kj kk jx jy jb hn dt translated">警告:这篇文章中的一些主题非常详细，超出了我通常写博客的水平。如果您不知道其中的一些术语或含义，只需下载并探究示例即可——继续阅读和体验！</p></blockquote><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/8ce5148d850362fe346eb06c12b70f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*J8ky4CoIvtus_RoM7JiGdg.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Time for some go faster stripes..</figcaption></figure><h1 id="d632" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">1.调用方法更快(也许)</h1><p id="f605" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated"><a class="ae ma" href="https://bugs.python.org/issue26110" rel="noopener ugc nofollow" target="_blank">这个改动</a>的标题是“加速方法调用1.2x”，有点误导..</p><p id="d287" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">有很多方法可以改变CPython，要么修改操作码的<strong class="je hv">执行</strong>，要么添加新的<strong class="je hv">操作码</strong>。添加新的操作码需要大量的讨论和测试，这一变化引入了新的操作码。操作码由CPython中的<em class="kc">编译</em>过程选择。一旦你的代码被转换成一个抽象语法树，编译器会探索每一个分支并把它转换成操作码。代码的执行会在一个循环中遍历大量switch语句中的操作码，并为每个操作码调用不同的C函数。</p><p id="9973" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">供参考，<strong class="je hv"> Python 3.6 </strong>有3个调用函数的操作码。所有这些都是在Python 3.6中添加或修改的。</p><ul class=""><li id="0839" class="mb mc hu je b jf kd jj ke jn md jr me jv mf jb mg mh mi mj dt translated">用于调用只有位置参数的函数:<code class="eh mk ml mm mn b">CALL_FUNCTION</code>，</li><li id="0667" class="mb mc hu je b jf mo jj mp jn mq jr mr jv ms jb mg mh mi mj dt translated">用于调用位置和关键字函数:<code class="eh mk ml mm mn b">CALL_FUNCTION_KW</code>，</li><li id="81a1" class="mb mc hu je b jf mo jj mp jn mq jr mr jv ms jb mg mh mi mj dt translated">用于调用变量位置或关键字函数:<code class="eh mk ml mm mn b">CALL_FUNCTION_EX</code></li></ul><p id="6773" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">Python 3.7增加了两个新的操作码，<code class="eh mk ml mm mn b"><a class="ae ma" href="https://github.com/python/cpython/blob/master/Python/ceval.c#L3021-L3105" rel="noopener ugc nofollow" target="_blank">LOAD_METHOD</a></code> <a class="ae ma" href="https://github.com/python/cpython/blob/master/Python/ceval.c#L3021-L3105" rel="noopener ugc nofollow" target="_blank">和</a> <code class="eh mk ml mm mn b"><a class="ae ma" href="https://github.com/python/cpython/blob/master/Python/ceval.c#L3021-L3105" rel="noopener ugc nofollow" target="_blank">CALL_METHOD</a></code>，当编译器看到<code class="eh mk ml mm mn b">x.method(...)</code>时，就会使用这些新的操作码。</p><p id="baf6" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">举个例子，用不同的签名调用3个函数:</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="d340" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">在Python 3.6和Python 3.7上运行，我们可以看到结果代码或性能没有变化。</p><p id="3e8c" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">另一个使用<strong class="je hv">绑定</strong>方法的例子(即那些属于一个类的实例的方法)，</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="3051" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">这一结果表明:</p><ul class=""><li id="f45c" class="mb mc hu je b jf kd jj ke jn md jr me jv mf jb mg mh mi mj dt translated">新的<code class="eh mk ml mm mn b">LOAD_METHOD</code>操作码取代了将绑定方法作为属性加载，并作为普通函数调用它们。记住，对于实例方法来说，<code class="eh mk ml mm mn b">LOAD_METHOD</code>和<code class="eh mk ml mm mn b">CALL_METHOD</code>比<code class="eh mk ml mm mn b">CALL_FUNCTION</code>要快。</li><li id="de0c" class="mb mc hu je b jf mo jj mp jn mq jr mr jv ms jb mg mh mi mj dt translated">带有关键字参数的绑定方法与Python 3.6中的相同，不会有任何性能变化。</li><li id="4bfd" class="mb mc hu je b jf mo jj mp jn mq jr mr jv ms jb mg mh mi mj dt translated">没有参数的绑定方法现在更快了</li></ul><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="fe ff mv"><img src="../Images/2a4e22bcba9782fb82f956c4965962e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9bjpYdpnSasTiuucsPcGA.png"/></div></div></figure><p id="2c74" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated"><code class="eh mk ml mm mn b">LOAD_METHOD</code>取代了<code class="eh mk ml mm mn b">LOAD_ATTR</code>，本质上是获取对象实例上的BoundMethod实例。<code class="eh mk ml mm mn b"><a class="ae ma" href="https://github.com/python/cpython/blob/master/Objects/object.c#L1074-L1155" rel="noopener ugc nofollow" target="_blank">LOAD_METHOD</a></code> <a class="ae ma" href="https://github.com/python/cpython/blob/master/Objects/object.c#L1074-L1155" rel="noopener ugc nofollow" target="_blank">是<code class="eh mk ml mm mn b">LOAD_ATTR</code>中</a>逻辑的一个副本，但是当方法没有被覆盖并且它有位置参数时会得到更好的优化。</p><p id="eaf2" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">从这里出来，你可能会有一些问题</p><h2 id="1406" class="na ky hu bd kz nb nc nd ld ne nf ng lh jn nh ni ll jr nj nk lp jv nl nm lt nn dt translated">所以如果我把我的函数放到一个类里，会不会让它们更快？</h2><p id="8790" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated">不会，因为这种速度提升是为了消除与物体相关的减速</p><h2 id="8622" class="na ky hu bd kz nb nc nd ld ne nf ng lh jn nh ni ll jr nj nk lp jv nl nm lt nn dt translated">关键字和变量参数为什么会得到特殊对待？</h2><p id="2769" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated">关键字参数需要在执行循环中进行特殊处理，因为在C(编写CPython的语言)中没有对应的参数，一些额外的代码必须编译2个元组才能传递给方法。</p><p id="38a8" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">可变参数，无论是位置参数还是关键字参数，都需要特殊处理。</p><h2 id="f9ab" class="na ky hu bd kz nb nc nd ld ne nf ng lh jn nh ni ll jr nj nk lp jv nl nm lt nn dt translated">这么多的警告，我喜欢关键字参数，我会看到任何不同吗？</h2><p id="c6c7" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated">这种改变应该鼓励你在类设计中遵循DRY(不要重复自己)原则，并添加私有方法来减少多个公共方法之间的逻辑重复。在3.7之前，对性能的影响是一个很重要的考虑因素，在需要速度的地方，复制+粘贴代码是一种公认的做法。</p><p id="f2d3" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">将来，我们可能会看到更多的<a class="ae ma" href="https://bugs.python.org/issue26110#msg258211" rel="noopener ugc nofollow" target="_blank">场景经历类似的处理</a>。</p><h1 id="da6a" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">2.对于某些字符，str.find()更快</h1><p id="639d" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated">当使用<code class="eh mk ml mm mn b">str.find(x)</code>扫描字符串时，一些unicode字符出现了一个不幸的问题，看到了高达<strong class="je hv">25倍的速度下降。</strong></p><pre class="km kn ko kp fq no mn np nq aw nr dt"><span id="e7f9" class="na ky hu mn b fv ns nt l nu nv">$ ./python -m perf timeit -s 's = "一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒专且丕世丗丘丙业丛东丝丞丟丠両丢丣两严並丧丨丩个丫丬中丮丯丰丱串丳临丵丶丷丸丹为主丼丽举丿乀乁乂乃乄久乆乇么义乊之乌乍乐乑乒乓乔乕乖乗乘乙乚乛乜九乞也习乡乢乣乤乥书乧乨乩乪乫乬乭乮乯买乱乲乳乴乵乶乷乸乹乺乻乼乽乾乿亀亁亂亃亄亅了亇予争 亊事二亍于亏亐云互亓五井亖亗亘亙亚些亜亝亞亟亠亡亢亣交亥亦产亨亩亪享京亭亮亯亰亱亲亳亴亵亶亷亸亹人亻亼亽亾亿什仁仂仃仄仅仆仇仈仉今介仌仍从仏仐仑仒仓仔仕他仗付仙仚仛仜 仝仞仟仠仡仢代令以仦仧仨仩仪仫们仭仮仯仰仱仲仳仴仵件价仸仹仺任仼份仾仿"*100' -- 's.find("乎")'<br/><br/>Unpatched:  Median +- std dev: 761 us +- 108 us<br/>Patched:    Median +- std dev: 117 us +- 9 us</span></pre><p id="63ed" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">在Python 3.7中，预期的Unicode码位大小不再是硬编码的，方法是优化的长字符(大多数是不常见的)。</p><p id="3be7" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">这些仍然较慢，但现在比ASCII字符慢3倍，而不是25倍！</p><h1 id="c6d6" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">3.os.fwalk快2倍</h1><p id="4b41" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated"><code class="eh mk ml mm mn b">os</code>模块中的<code class="eh mk ml mm mn b">fwalk</code>函数(仅在Python 3中)是一个目录树生成器。</p><p id="aed2" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">它的行为和walk()完全一样，除了它产生一个4元组响应<code class="eh mk ml mm mn b">(dirpath, dirnames, filenames, dirfd)</code></p><p id="292f" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated"><a class="ae ma" href="https://github.com/python/cpython/commit/ea720fe7e99d68924deab38de955fe97f87e2b29" rel="noopener ugc nofollow" target="_blank">的变化是修改</a>的实现来使用<code class="eh mk ml mm mn b">scandir</code>方法而不是<code class="eh mk ml mm mn b">listdir</code>，后者是操作系统优化的，速度更快。</p><h1 id="1a1e" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">4.正则表达式更快*</h1><p id="c9a5" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated">在正则表达式模块(<code class="eh mk ml mm mn b">re</code>)中有一个方法<code class="eh mk ml mm mn b">compile</code>，它编译一个正则表达式字符串和一组可选的标志。这些标志可以是传递给正则表达式库的正则表达式标志。</p><p id="9b2d" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">Python 3.6中做了一个改变，当传递整数标志时，这个调用会变慢。Python 3.7“修复”了速度变慢的问题，但仍然没有Python 3.5快</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="fe ff nw"><img src="../Images/9479d39db75d39bfa87dead38a628cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x90QYoIY1RFNV4hO8b2B2Q.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">* Faster than 3.6</figcaption></figure><h1 id="23b8" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">5.对于不区分大小写的匹配，正则表达式更快</h1><p id="ec94" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated">每次更改更改日志</p><blockquote class="jz ka kb"><p id="1f64" class="jc jd kc je b jf kd jh ji jj ke jl jm kf kg jp jq kh ki jt ju kj kk jx jy jb hn dt translated">匹配和搜索不区分大小写的正则表达式比匹配和搜索区分大小写的正则表达式慢得多。不区分大小写要求将输入字符串中的每个字符都转换成小写，并禁用一些优化。但是只有2669个大小写字符(ASCII模式下52个)。对于模式中的所有其他字符，我们可以使用区分大小写的匹配。</p></blockquote><p id="a726" class="pw-post-body-paragraph jc jd hu je b jf kd jh ji jj ke jl jm jn kg jp jq jr ki jt ju jv kk jx jy jb hn dt translated">速度的提高是显著的，如果你在匹配ASCII字符，你可以看到匹配时间提高了20倍，因为它现在在查找而不是在每个字符上运行<code class="eh mk ml mm mn b">lower()</code>。</p><h2 id="9f13" class="na ky hu bd kz nb nc nd ld ne nf ng lh jn nh ni ll jr nj nk lp jv nl nm lt nn dt translated">还卡在Python 2上？</h2><p id="a870" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jb hn dt translated"><a class="ae ma" href="https://www.pluralsight.com/courses/python-2-to-python-3" rel="noopener ugc nofollow" target="_blank">查看我在Pluralsight上关于从Python 2迁移到3的新课程。</a></p></div></div>    
</body>
</html>