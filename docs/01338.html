<html>
<head>
<title>5 Practical Ways To Share Code: From NPM To Lerna, Git Submodules and Bit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5种实用的代码共享方式:从NPM到Lerna、Git子模块和Bit</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/5-practical-ways-to-share-code-from-npm-to-lerna-and-bit-732f2a4db512?source=collection_archive---------2-----------------------#2018-02-12">https://medium.com/hackernoon/5-practical-ways-to-share-code-from-npm-to-lerna-and-bit-732f2a4db512?source=collection_archive---------2-----------------------#2018-02-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ab78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在多个存储库、monorepos和微服务之间，关于在项目之间共享公共<a class="ae jp" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank">代码</a>的讨论越来越激烈。</p><p id="befc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在项目和存储库之间共享公共代码是更好的模块化和更快开发的关键因素，但这也是<a class="ae jp" rel="noopener" href="/@jeffwhelpley/the-problem-with-shared-code-124a20fc3d3b">复杂的</a>。我已经在之前<a class="ae jp" href="https://medium.com/p/85c51b2d0049/edit" rel="noopener">写过了，分享了我们作为一个团队的经验。</a></p><p id="8db0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是2018年在这些回购和项目之间共享代码的5种方法的实用概述。请记住，归根结底，这真的是关于人与人之间的交流、文化以及将<a class="ae jp" href="https://addyosmani.com/first/" rel="noopener ugc nofollow" target="_blank">模块化牢记在心</a>。</p><h1 id="a4fd" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">1.少量</h1><figure class="ko kp kq kr fq ks"><div class="bz el l di"><div class="kt ku l"/></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek">Bit 5 min demo: share and manage code modules anywhere</figcaption></figure><p id="2034" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Bit</strong></a><strong class="it hv">(</strong><a class="ae jp" href="https://github.com/teambit/bit" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">GitHub</strong></a><strong class="it hv">)</strong>是一个流行的JS工具，管理<strong class="it hv"/>源代码变更和共享组件的依赖性。这是一个强大的团队共享代码的方式，并保持不同应用程序和项目之间的同步。</p><p id="ddf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Bit能够从一个回购到另一个回购隔离和共享代码，同时保持对变更和更新的普遍控制，这使它成为一种非常可扩展的方式，以增加团队的代码共享，并减少开销。</p><p id="9f90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Bit让你无缝地隔离和共享来自任何repo的模块，同时它会自动定义它们的环境和依赖树。结果几乎是即时发布来自任何repo的组件，没有任何重构。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><a href="https://bit.dev"><div class="fe ff kz"><img src="../Images/15ee5bce92eb0df66442b0673c55eb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us5tsKlh8qsxIYhoMtpTSw.png"/></div></a><figcaption class="kv kw fg fe ff kx ky bd b be z ek">UI components as Bit modules: instantly share and reuse anywhere</figcaption></figure><p id="525c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您可以使用NPM/Yarn在其他项目中安装组件，或者使用Bit从消费项目本身导入和开发代码。当进行更改时，Bit会帮助您更新版本并合并更改。</p><p id="d4d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个<a class="ae jp" href="https://github.com/teambit/bit" rel="noopener ugc nofollow" target="_blank">开源项目</a>和一个<a class="ae jp" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank">组件平台</a>，它们一起帮助团队将可重用的代码单元转化为共享组件。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><a href="https://bitsrc.io/components"><div class="fe ff lc"><img src="../Images/6455938bac633b44260395b5efa88679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uvhKCvXM3IyNlSZVrBvMRQ.gif"/></div></a></figure><p id="c232" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Bit的平台(<a class="ae jp" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> bit.dev </a>)还为您共享的组件提供可发现性和协作，这些组件被组织在平台中的可视集合中，具有每个组件的测试、构建、可视渲染等功能。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><a href="https://bit.dev"><div class="fe ff lc"><img src="../Images/461f34a59ad3dd4eebcdc55f883345e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kg9Avc-5WQb2G2PQxHRPIg.gif"/></div></a></figure><p id="cad1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个示例<a class="ae jp" href="https://github.com/itaymendel/movie-app" rel="noopener ugc nofollow" target="_blank"> React项目</a>和一个<a class="ae jp" href="https://bitsrc.io/bit/movie-app" rel="noopener ugc nofollow" target="_blank">匹配组件集合</a>。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><a href="https://bit.dev"><div class="fe ff lc"><img src="../Images/0e595be52edb8451f580c639c0a7b877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Gxjhw2nGfLKMDnEPan28lQ.gif"/></div></a></figure><div class="ld le fm fo lf lg"><a href="https://bit.dev" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">将可重用的代码组件作为团队成员共享</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">轻松地在项目和应用程序之间共享可重用组件，以更快地作为一个团队进行构建。合作开发…</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">bit.dev</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu la lg"/></div></div></a></div><div class="ld le fm fo lf lg"><a href="https://github.com/teambit/bit" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">团队位/位</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">与您的团队轻松共享项目间的代码。-团队位/位</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">github.com</p></div></div><div class="lp l"><div class="lv l lr ls lt lp lu la lg"/></div></div></a></div><h1 id="bbf4" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">2.有/没有Lerna的NPM</h1><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/5da7a16cee409a056c8d2c8908969183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*c2O5IDMtX1FWCFGNYdbQHQ.png"/></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek">Sindre Sorhus with 1000 NPM packages</figcaption></figure><p id="c1ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>是发生在<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>身上的一件神奇的事情，为围绕可重用模块和库的代码重用和协作打开了大门。尽管对这个生态系统有诸多抱怨，但我们无法想象没有它的生活。</p><p id="344c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能对NPM了如指掌，让我们来关注一些限制以及如何克服它们。一开始就做出明智的选择可以节省以后的时间。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff lx"><img src="../Images/f7c29cca234e7ee560e9215c93d7f965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juDVlPkfmsV-mZw4pqVBQw.png"/></div></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek"><a class="mc md gr" href="https://medium.com/u/a3a8af6addc1?source=post_page-----732f2a4db512--------------------------------" rel="noopener" target="_blank">Dan Abramov</a> favors many modules</figcaption></figure><p id="8893" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，很难为许多包建立和维护许多存储库。由于这个原因，一些项目被构建为多包存储库，也称为“monorepos”。像Bit和Lerna(见下文)这样的工具可以帮助你把项目变成多包回购，你可以在这里了解更多<a class="ae jp" href="https://blog.bitsrc.io/monorepo-architecture-simplified-with-bit-and-npm-b1354be62870" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c07a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也导致许多团队选择共享库作为共享许多小组件的解决方案(见下文)，因为很难为每个组件都准备一个包。</p><p id="2ec2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二，当其他人发布一个包时，您开发它的能力受到限制，这通常会导致对包的回购的拉式请求。像<a class="ae jp" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> Bit </a>这样的工具有助于缓解这个问题，因为它让您可以将组件直接带入任何回购，进行更改并共享新版本。</p><p id="5f3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第三，随着您的扩展，会出现一个可发现性问题。很难从许多小软件包中找到和选择，这导致了wiki网站和冗长的文档。Rollup的作者<a class="mc md gr" href="https://medium.com/u/a11f7c00cbbe?source=post_page-----732f2a4db512--------------------------------" rel="noopener" target="_blank"> Rich Harris </a> <a class="ae jp" rel="noopener" href="/@Rich_Harris/small-modules-it-s-not-quite-that-simple-3ca532d65de4">写道</a>:</p><blockquote class="me mf mg"><p id="e5ba" class="ir is mh it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">“许多博客帖子——不要说了，整个网站——都是为了减少在npm上找到所需内容的难度而创建的……”</p><p id="e2df" class="ir is mh it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><em class="hu"> " </em>由你来评价这个库:它有测试吗？你能理解源代码吗？是否积极维护？文档是否易于查找和查阅？<em class="hu"/></p></blockquote><h2 id="f06a" class="ml jr hu bd js mm mn mo jw mp mq mr ka jc ms mt ke jg mu mv ki jk mw mx km my dt translated">莱尔纳</h2><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/5323205a908795ef21b3b4b792c1bb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*obV0EGRGtftMYtM4_DTTQA.png"/></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek">The Hydra from Lerna: Looking at its tail, I think it’s about to fall down</figcaption></figure><p id="e01e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将不同的包保存在不同的存储库中会很快失去控制，并且使得跨项目更新变更变得非常困难。</p><p id="5409" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Lerna </strong> </a>帮助你在一个库中保存和配置多个包。它可以帮助减轻不同包的不同回购协议的痛苦，并帮助从整体上构建和测试项目。这样，您就不必为不同的包保存和维护单独的repos。</p><p id="5341" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要了解更多关于monorepo的信息，请查看:</p><div class="ld le fm fo lf lg"><a href="https://blog.bitsrc.io/monorepo-architecture-simplified-with-bit-and-npm-b1354be62870" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">Monorepos变得更简单</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">如何利用位+ NPM简化monorepo架构，有和没有Lerna和朋友。</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">blog.bitsrc.io</p></div></div><div class="lp l"><div class="na l lr ls lt lp lu la lg"/></div></div></a></div><h1 id="dd16" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">3.共享和公共库</h1><p id="0838" class="pw-post-body-paragraph ir is hu it b iu nb iw ix iy nc ja jb jc nd je jf jg ne ji jj jk nf jm jn jo hn dt translated"><a class="ae jp" href="https://blog.bitsrc.io/11-react-component-libraries-you-should-know-178eb1dd6aa4" rel="noopener ugc nofollow" target="_blank">共享库</a>的优势在于你将所有的共享代码保存在一个repo中，这比多个微包更容易维护和分发。然而，与Lerna monorepos不同，它们将作为一个包装被消费。</p><p id="edac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将所有共享代码保存在一个repo中会迫使用户将整个库添加到他们的项目中，这些库具有冗余代码、依赖性、复杂性和重量，所有这些都使用单个组件。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff fg"><img src="../Images/38f1270aee32e8e1b6fd621bb9d56a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pGVKa3pT3yU4IA121MpUuA.png"/></div></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek">A React MaterialUI button component — do I really need a whole library?</figcaption></figure><p id="c444" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也使得更新和修改的过程变得非常麻烦，因为每次更改都需要项目的所有者更新包。这可能<a class="ae jp" href="https://hackernoon.com/how-we-started-sharing-components-as-a-team-d863657afaca" rel="noopener ugc nofollow" target="_blank">损害这些库在组织内的采用</a>。库内不同组件的可发现性也是一个问题。</p><p id="9968" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些问题导致Lodash等社区长期努力工作，以便将他们的组件作为单独的包发布到NPM。谷歌的<a class="ae jp" href="https://www.webcomponents.org/" rel="noopener ugc nofollow" target="_blank">聚合物项目</a>(由<a class="mc md gr" href="https://medium.com/u/443b43fab64?source=post_page-----732f2a4db512--------------------------------" rel="noopener" target="_blank"> Eric Bidelman </a>和其他OSS向导)也在超过100个不同的存储库中保存了超过100个网络元素。</p><p id="1794" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Lerna可用于将库中的组件分离到repo中的包中。位可用于共享现有库中的组件。</p><div class="ld le fm fo lf lg"><a href="https://blog.bitsrc.io/do-we-really-use-reusable-components-959a252a0a98" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">我们如何真正使用可重用组件？</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">我和30个团队讨论过他们的可重用组件。以下是我学到的东西。</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">blog.bitsrc.io</p></div></div><div class="lp l"><div class="ng l lr ls lt lp lu la lg"/></div></div></a></div><div class="ld le fm fo lf lg"><a href="https://blog.bitsrc.io/shared-components-best-practices-for-2019-c259cdc3b623" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">2019年共享组件最佳实践</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">与Bit和friends一起开发和管理团队和项目之间共享组件的成功实践。</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">blog.bitsrc.io</p></div></div><div class="lp l"><div class="nh l lr ls lt lp lu la lg"/></div></div></a></div><h1 id="4fd6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">4.Git子模块</h1><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/0dd997fa0d7afeccbefa6fb6b79ed586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*EV6vMxe-a6guNDT448cYdg.png"/></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek">Lessons learned in the trenches?</figcaption></figure><p id="b037" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">子模块实际上是其父存储库目录树中的独立存储库。父模块与子模块之间的唯一联系是子模块检出SHA的记录值，它存储在父模块的提交中。记录的SHA中的变化不会自动反映在子模块中。</p><p id="b92d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，子模块有很多很多问题。只要在谷歌上运行一个快速的“git子模块”搜索，你不会喜欢结果的。在主要问题中，您可以发现一个简单的事实，即子模块不管理模块之间的依赖关系。较小的问题包括这样的事实，即<strong class="it hv"> </strong> git子模块不能很好地与父目录一起工作，因为对父目录的“拉”不会自动反映在子模块中。</p><p id="9ca5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，git在解决冲突时不会保存指向子模块的指针。这意味着如果您不手动更新指针，您将在合并更改时丢失已解决的冲突。当您提交子模块时，git将在父模块中为您留下一个分离的头，因为它引用的是一个旧的“头”,而不是当前的“头”。你猜怎么着？当您推送父模块或子模块时，其他父模块不会被导出。</p><p id="64aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有各种工具围绕子模块特性提供额外的自动化，例如<a class="ae jp" href="https://codeburst.io/4-git-submodules-alternatives-you-should-know-592095859b0" rel="noopener" target="_blank"> git-subtree、gitslave、braid和giternal </a>。但是到今天为止，管理跨项目和repos的源代码变更和模块依赖性的唯一工具是JS中的<a class="ae jp" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank">位</a>。</p><h1 id="0ef1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">5.复制粘贴代码</h1><blockquote class="me mf mg"><p id="8439" class="ir is mh it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">因为让我们面对现实吧，未来的我曾经为我做过什么？</p></blockquote><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff nj"><img src="../Images/59ad5b2c48600759559f33d4edf97c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dw74IhuKKn24urhu7k0mbw.png"/></div></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek">When your teammate yells YOLO and goes rouge</figcaption></figure><p id="2023" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">老实说，这可能是地球上代码“重用”最常用的实践。我倾向于认为，在大多数情况下，这是由于缺乏“廉价”的有效替代方案和有些混乱的交付周期。</p><p id="1b5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题是，代码复制一点也不便宜。远非如此。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="fe ff nk"><img src="../Images/e52aec78e7113a2e43765b0c7b4a0880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jp03biZSsb5To7-WOlWMBA.png"/></div></div><figcaption class="kv kw fg fe ff kx ky bd b be z ek">A classic problem for future me.</figcaption></figure><p id="3321" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重复是您代码库中不断增长的债务。您将很快失去控制，使维护成为一场噩梦，交付周期变得更长。很多问题只有交付生产后才会发现。</p><p id="df8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近的一项研究发现，GitHub <a class="ae jp" href="https://www.theregister.co.uk/2017/11/21/github_duplicate_code/" rel="noopener ugc nofollow" target="_blank">上一半的代码是重复的</a>。我们的研究发现，像<code class="eh nl nm nn no b">is-string</code>这样的Javascript函数仅在10k GitHub repos中就被复制了超过1000次，重复了100个不同的实现。</p><p id="ab24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想想如果更多的人共享代码，而不是复制或重新实现代码，会有什么样的新特性。想想您的组织的维护成本和长交付周期。</p><h1 id="286b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">共享代码是关于人的</h1><p id="f393" class="pw-post-body-paragraph ir is hu it b iu nb iw ix iy nc ja jb jc nd je jf jg ne ji jj jk nf jm jn jo hn dt translated">每个项目和每个开发人员都有自己的一套关注点、工具和工作流程。然而，共享代码是真正模块化的关键，这在今天的生态系统中越来越受欢迎，并提供了巨大的优势。</p><p id="79ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们选择构建<a class="ae jp" href="https://github.com/teambit/bit" rel="noopener ugc nofollow" target="_blank">位</a>。无论您选择什么方法和工具，重要的是鼓励培养共享和协作的文化。</p><p id="d2aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">毕竟项目之间的分享是从人与人之间的分享开始的。</p></div><div class="ab cl np nq hc nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hn ho hp hq hr"><h1 id="146f" class="jq jr hu bd js jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn dt translated">了解更多信息</h1><div class="ld le fm fo lf lg"><a href="https://blog.bitsrc.io/5-tools-for-faster-development-in-react-676f134050f2" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">在React中加快开发的5个工具</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">加速React应用程序开发的5个工具，侧重于组件。</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">blog.bitsrc.io</p></div></div><div class="lp l"><div class="ob l lr ls lt lp lu la lg"/></div></div></a></div><div class="ld le fm fo lf lg"><a href="https://blog.bitsrc.io/monorepo-architecture-simplified-with-bit-and-npm-b1354be62870" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">比特和NPM让Monorepos变得更简单</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">如何利用比特+ NPM去单一回购没有开销？</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">blog.bitsrc.io</p></div></div><div class="lp l"><div class="na l lr ls lt lp lu la lg"/></div></div></a></div><div class="ld le fm fo lf lg"><a href="https://blog.bitsrc.io/simplify-complex-ui-by-implementing-the-atomic-design-in-react-with-bit-f4ad116ec8db" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd hv fv z el ll eo ep lm er et ht dt translated">使用React和Bit的原子设计:简化复杂的UI</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">使用带有React + Bit的原子设计来简化复杂的UI。</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">blog.bitsrc.io</p></div></div><div class="lp l"><div class="oc l lr ls lt lp lu la lg"/></div></div></a></div></div></div>    
</body>
</html>