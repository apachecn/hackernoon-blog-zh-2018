<html>
<head>
<title>The Untapped Potential of ‘Nested‘ Ternaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“嵌套”三角形未开发的潜力</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-untapped-potential-of-nested-ternaries-2cb98079b634?source=collection_archive---------18-----------------------#2018-02-12">https://medium.com/hackernoon/the-untapped-potential-of-nested-ternaries-2cb98079b634?source=collection_archive---------18-----------------------#2018-02-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a8fb" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我们一直在错误地使用这些东西！</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/6da6a9915a99562c13e024d5072744dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QxBiEzf4P-nkxpgsgi8z2Q.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by Talles Alves (<a class="ae jz" href="https://unsplash.com/photos/HNiOq7eg8ck" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/HNiOq7eg8ck</a>)</figcaption></figure><p id="eb17" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">很快，我将向您展示JavaScript中尚未开发的“嵌套”术语的潜力。(在嵌套的周围使用引号<em class="kw">也将被解释)。不过先说一下<em class="kw">模式匹配</em>！</em></p><p id="5c17" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">模式匹配出现在许多<a class="ae jz" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言中，包括Scala和Haskell。它用于识别模式，并为我们提供了一个清晰、简洁的方法来确定我们的代码将如何分支。</p><p id="9c30" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这里有一个Scala中模式匹配的例子，来自Bruce Tate的优秀<a class="ae jz" href="https://pragprog.com/book/btlang/seven-languages-in-seven-weeks" rel="noopener ugc nofollow" target="_blank">七周七种语言</a>:</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="c71a" class="lc ld hu ky b fv le lf l lg lh">def doChore(chore: String): String = chore match {<br/> case “clean dishes” =&gt; “scrub, dry”<br/> case “cook dinner” =&gt; “chop, sizzle”<br/> case _ =&gt; “whine, complain”<br/>}</span><span id="e369" class="lc ld hu ky b fv li lf l lg lh">doChore(“clean dishes”) // -&gt; "scrub, dry"<br/>doChore(“mow lawn”) // -&gt; "whine, complain"</span></pre><p id="170a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">遵循逻辑很简单。我们只需扫描列表中的第一个匹配项，并在那里找到要返回的值。如果我们到达列表的末尾，还没有遇到我们要找的案例，那么在末尾我们会找到我们的返回值，一个我们没有考虑的所有案例的集合。</p><p id="82dd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">下面是Haskell中计算阶乘的模式匹配:</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="15a4" class="lc ld hu ky b fv le lf l lg lh">factorial :: Integer -&gt; Integer<br/>factorial 0 = 1<br/>factorial x = x * factorial (x - 1)</span><span id="6ad5" class="lc ld hu ky b fv li lf l lg lh">-- factorial 0 -&gt; 1<br/>-- factorial 1 -&gt; 1<br/>-- factorial 17 -&gt; 355687428096000</span></pre><p id="2d82" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">有趣的是，Prolog中的斐波那契数列:</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="995c" class="lc ld hu ky b fv le lf l lg lh">fib(0, 1).<br/>fib(B, C) :- fib(A, B), C is A + B.</span><span id="6f4c" class="lc ld hu ky b fv li lf l lg lh">% fib(0, X) -&gt; X = 1.<br/>% fib(1, X) -&gt; X = 1, X = 2.<br/>% fib(144, X) -&gt; X = 233.</span></pre><p id="b6a9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们不能在<a class="ae jz" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中使用模式匹配作为控制结构，但是如果你仔细看，<code class="eh lj lk ll ky b">case "clean dishes"</code>(来自我们的Scala示例)开始看起来有点像布尔测试，我们确实有。继续眯着眼，这段JavaScript代码看起来有点像模式匹配:</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="6503" class="lc ld hu ky b fv le lf l lg lh">let <strong class="ky hv">result</strong>;</span><span id="d51f" class="lc ld hu ky b fv li lf l lg lh"><strong class="ky hv">if</strong> (operator === ‘+’) {<br/>  result = left + right;<br/>} <strong class="ky hv">else if</strong> (operator === ‘*’) {<br/>  result = left * right;<br/>} <strong class="ky hv">else if</strong> (operator === ‘-’) {<br/>  result = left - right;<br/>} <strong class="ky hv">else</strong> {<br/>  result = left / right;<br/>}</span></pre><p id="f68d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是我们可以做得更好！这段代码的一些问题:</p><ul class=""><li id="698e" class="lm ln hu kc b kd ke kg kh kj lo kn lp kr lq kv lr ls lt lu dt translated">尽管我们知道<code class="eh lj lk ll ky b">const</code>是首选，但我们还是使用了<code class="eh lj lk ll ky b">let</code>。</li><li id="793d" class="lm ln hu kc b kd lv kg lw kj lx kn ly kr lz kv lr ls lt lu dt translated">我们正在改变一个在我们的块范围之外声明的变量的值。</li><li id="1275" class="lm ln hu kc b kd lv kg lw kj lx kn ly kr lz kv lr ls lt lu dt translated">我们通过多次键入我们的任务<code class="eh lj lk ll ky b">result =</code>来重复我们自己。</li></ul><p id="f880" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们看看我们能用嵌套的三元组做些什么，好吗？</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="81f9" class="lc ld hu ky b fv le lf l lg lh">const <strong class="ky hv">result</strong> =<br/>  operator === ‘+’ ? left + right<br/>  : operator === ‘*’ ? left * right<br/>  : operator === ‘-’ ? left — right<br/>  : left / right;</span></pre><p id="fa0b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">嘿，那还不算太糟！让我们回顾一下我们所说的模式匹配:</p><blockquote class="ma mb mc"><p id="2385" class="ka kb kw kc b kd ke iv kf kg kh iy ki md kk kl km me ko kp kq mf ks kt ku kv hn dt translated">遵循逻辑很简单。我们只需扫描列表中的第一个匹配项，并在那里找到要返回的值。如果我们到达列表的末尾，还没有遇到我们要找的案例，那么在末尾我们会找到我们的返回值，一个我们没有考虑的所有案例的集合。</p></blockquote><p id="de11" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">看起来我们已经有了一个工具，它的功能很像JavaScript中已经存在的模式匹配！</p><p id="0eb8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">注意我们为什么能够做到这一点是很重要的——我们格式化了我们的“嵌套”三元组，使得每一行都有一个条件和一个结果，并在结尾包含所有内容。因此，我们可以读写它，就好像它<strong class="kc hv">根本没有嵌套</strong>。因此引用。😉没有必要担心记住每个嵌套的上下文。一旦你排除了某条线适用于你正在考虑的情况，你可以放心地忘记它。</p><p id="aea4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在JavaScript中避免嵌套术语通常被认为是最佳实践，但这是因为我们通常编写如下所示的代码:</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="ecc5" class="lc ld hu ky b fv le lf l lg lh"><strong class="ky hv">var</strong> thing <strong class="ky hv">=</strong> foo ? bar : baz <strong class="ky hv">===</strong> qux ? quxx : foobar;</span></pre><p id="2c03" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果你认为这看起来令人困惑，那是因为它是！<a class="ae jz" href="https://eslint.org/docs/rules/no-nested-ternary" rel="noopener ugc nofollow" target="_blank"> ESLint </a>建议解决方案是编写这样的代码:</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="6a4f" class="lc ld hu ky b fv le lf l lg lh"><strong class="ky hv">var</strong> thing;</span><span id="6362" class="lc ld hu ky b fv li lf l lg lh"><strong class="ky hv">if</strong> (foo) {<br/>  thing <strong class="ky hv">=</strong> bar;<br/>} <strong class="ky hv">else</strong> <strong class="ky hv">if</strong> (baz <strong class="ky hv">===</strong> qux) {<br/>  thing <strong class="ky hv">=</strong> quxx;<br/>} <strong class="ky hv">else</strong> {<br/>  thing <strong class="ky hv">=</strong> foobar;<br/>}</span></pre><p id="4bfb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但希望现在你意识到有更好的选择:</p><pre class="jk jl jm jn fq kx ky kz la aw lb dt"><span id="a90c" class="lc ld hu ky b fv le lf l lg lh"><strong class="ky hv">var</strong> thing =<br/>  foo ? bar<br/>  : baz === qux ? quxx<br/>  : foobar;</span></pre><p id="1e10" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">可以在推特上关注我<a class="ae jz" href="https://twitter.com/okaybenji" rel="noopener ugc nofollow" target="_blank"> @okaybenji </a></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mg mh l"/></div></figure></div></div>    
</body>
</html>