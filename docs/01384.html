<html>
<head>
<title>Applicative Parsing I: Building the Foundation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用解析I:构建基础</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/applicative-parsing-i-building-the-foundation-23e8a9c2fb5d?source=collection_archive---------48-----------------------#2018-02-12">https://medium.com/hackernoon/applicative-parsing-i-building-the-foundation-23e8a9c2fb5d?source=collection_archive---------48-----------------------#2018-02-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c54ac09306112bde11e9a997a6036490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgvir5UCs8r6c-ruaa7gvg.png"/></div></div></figure><p id="06ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://mmhaskell.com/blog/2018/2/5/parsing-primer-gherkin-syntax" rel="noopener ugc nofollow" target="_blank">上周</a>我们复习了小黄瓜语法的基础知识，为解析做好了准备。在本文和下一篇文章中，我们将使用<a class="ae ka" href="https://hackage.haskell.org/package/regex-applicative-0.3.3/docs/Text-Regex-Applicative.html#t:RE" rel="noopener ugc nofollow" target="_blank">应用解析</a>库来解析该语法。本周，我们将集中讨论这个库的基础知识，并建立一个可以使用的组合元词汇。我们将大量使用<code class="eh kb kc kd ke b">Applicative</code> typeclass。如果您需要对此进行复习，请查看<a class="ae ka" href="https://mmhaskell.com/blog/2017/2/6/applicatives-one-step-further" rel="noopener ugc nofollow" target="_blank">本文</a>。当我们开始编码的时候，你也可以跟随<a class="ae ka" href="https://github.com/jhb563/GherkinParsing" rel="noopener ugc nofollow" target="_blank"> Github上的例子！这里的大部分代码都在</a><a class="ae ka" href="https://github.com/jhb563/GherkinParsing/blob/master/src/Parser.hs" rel="noopener ugc nofollow" target="_blank"> Parser.hs </a>中。</p><p id="61bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在接下来的几周，我们还将看到其他几个解析库。如果您想了解更多信息，请下载我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产检查表</a>。它总结了许多其他有用的库来编写更高级别的Haskell。</p><p id="f752" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你从未开始写哈斯克尔，现在是你的机会了！获取我们的免费<a class="ae ka" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>并学习开始的基础知识！</p><h1 id="66b3" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">入门指南</h1><p id="0f93" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">因此，为了开始解析，让我们对我们的输入格式做一些笔记。首先，我们将把我们的输入特征文档当作一个字符串。我们将删除所有空行，然后修剪每一行的前导和尾随空格。</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="8cd5" class="lq kg hu ke b fv lr ls l lt lu">parseFeatureFromFile :: FilePath -&gt; IO Feature<br/>parseFeatureFromFile inputFile = do<br/>  fileContents &lt;- lines &lt;$&gt; readFile inputFile<br/>  let nonEmptyLines = filter (not . isEmpty) fileContents<br/>  let trimmedLines = map trim nonEmptyLines<br/>  let finalString = unlines trimmedLines<br/>  case parseFeature finalString of<br/>    ...</span><span id="9f0e" class="lq kg hu ke b fv lv ls l lt lu">…<br/>isEmpty :: String -&gt; Bool<br/>isEmpty = all isSpace</span><span id="8794" class="lq kg hu ke b fv lv ls l lt lu">trim :: String -&gt; String<br/>trim input = reverse flippedTrimmed<br/>  where<br/>    trimStart = dropWhile isSpace input<br/>    flipped = reverse trimStart<br/>    flippedTrimmed = dropWhile isSpace flipped</span></pre><p id="c298" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的语法来说，这意味着一些事情。首先，我们不关心缩进。第二，我们忽略了额外的线路。这意味着我们的解析器可能允许某些我们不想要的格式。但这没关系，因为我们试图让事情变得简单。</p><h1 id="9c4f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">稀土类型</h1><p id="9c5e" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">对于基于应用的解析，我们将使用的主要数据类型被称为<code class="eh kb kc kd ke b">RE</code>，用于正则表达式。这表示一个解析器，它由两种类型参数化:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="2239" class="lq kg hu ke b fv lr ls l lt lu">data RE s a = ...</span></pre><p id="2d4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类型指的是我们将要解析的基本单元。因为我们将输入解析为单个的<code class="eh kb kc kd ke b">String</code>，这将是<code class="eh kb kc kd ke b">Char</code>。那么<code class="eh kb kc kd ke b">a</code>类型就是解析元素的结果。这因解析器而异。我们可以使用的最基本的组合子是<code class="eh kb kc kd ke b">sym</code>。这将解析您选择的单个符号:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="9be3" class="lq kg hu ke b fv lr ls l lt lu">sym :: s - &gt; RE s s</span><span id="9b73" class="lq kg hu ke b fv lv ls l lt lu">parseLowercaseA :: RE Char Char<br/>parseLowercaseA = sym ‘a’</span></pre><p id="26a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使用一个<code class="eh kb kc kd ke b">RE</code>解析器，我们调用<code class="eh kb kc kd ke b">match</code>函数或者它的中缀等价函数<code class="eh kb kc kd ke b">=~</code>。如果我们可以匹配整个输入字符串，这些将返回一个<code class="eh kb kc kd ke b">Just</code>值，否则返回<code class="eh kb kc kd ke b">Nothing</code>:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="8b94" class="lq kg hu ke b fv lr ls l lt lu">&gt;&gt; match parseLowercaseA “a”<br/>Just ‘a’<br/>&gt;&gt; “b” =~ parseLowercaseA<br/>Nothing<br/>&gt;&gt; “ab” =~ parseLowercaseA<br/>Nothing -- (Needs to parse entire input)</span></pre><h1 id="189e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">谓词和字符串</h1><p id="07c2" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">自然，我们会想要一些更复杂的功能。我们可以使用<code class="eh kb kc kd ke b">psym</code>解析任何符合特定谓词的字符，而不是解析单个输入字符。因此，如果我们想读取任何不是换行符的字符，我们可以这样做:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="9e75" class="lq kg hu ke b fv lr ls l lt lu">parseNonNewline :: RE Char Char<br/>parseNonNewline = psym (/= ‘\n’)</span></pre><p id="d77f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">string</code>组合子允许我们匹配特定的完整字符串，然后返回它:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="885b" class="lq kg hu ke b fv lr ls l lt lu">readFeatureWord :: RE Char String<br/>readFeatureWord = string “Feature”</span></pre><p id="abbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用它来解析关键字，尽管我们最终常常会丢弃“结果”。</p><h1 id="5f87" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">应用组合子</h1><p id="bad3" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">现在<code class="eh kb kc kd ke b">RE</code>型适用。这意味着我们可以对它应用各种应用组合子。其中之一是<code class="eh kb kc kd ke b">many</code>，它允许我们多次应用同一个解析器。这里有一个我们会经常用到的组合子。它允许我们读取所有内容，直到一个新行，并返回结果字符串:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="2c5f" class="lq kg hu ke b fv lr ls l lt lu">readUntilEndOfLine :: RE Char String<br/>readUntilEndOfLine = many (psym (/= '\n'))</span></pre><p id="583c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除此之外，我们还想利用适用的<code class="eh kb kc kd ke b">&lt;*&gt;</code>操作符来组合不同的解析器。我们也可以通过使用<code class="eh kb kc kd ke b">&lt;$&gt;</code>在这些之上应用一个纯函数(或构造函数)。假设我们有一个存储两个字符的数据类型。下面是我们如何为它构建一个解析器:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="2c86" class="lq kg hu ke b fv lr ls l lt lu">data TwoChars = TwoChars Char Char</span><span id="7c97" class="lq kg hu ke b fv lv ls l lt lu">parseTwoChars :: RE Char TwoChars<br/>parseTwoChars = TwoChars &lt;$&gt; parseNonNewline &lt;*&gt; parseNonNewline</span><span id="1530" class="lq kg hu ke b fv lv ls l lt lu">...</span><span id="29a4" class="lq kg hu ke b fv lv ls l lt lu">&gt;&gt; match parseTwoChars “ab”<br/>Just (TwoChars ‘a’ ‘b’)</span></pre><p id="96ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以使用<code class="eh kb kc kd ke b">&lt;*</code>和<code class="eh kb kc kd ke b">*&gt;</code>，它们是主应用操作符的表亲。第一个将被解析，但是<strong class="je hv">忽略</strong>右边的解析结果。第二个丢弃左侧结果。</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="83fe" class="lq kg hu ke b fv lr ls l lt lu">parseFirst :: RE Char Char<br/>parseFirst = parseNonNewline &lt;* parseNonNewline</span><span id="cd33" class="lq kg hu ke b fv lv ls l lt lu">parseSecond :: RE Char Char<br/>parseSecond = parseNonNewline *&gt; parseNonnewline</span><span id="cd83" class="lq kg hu ke b fv lv ls l lt lu">…</span><span id="0dd9" class="lq kg hu ke b fv lv ls l lt lu">&gt;&gt; match parseFirst “ab”<br/>Just ‘a’<br/>&gt;&gt; match parseSecond “ab”<br/>Just ‘b’<br/>&gt;&gt; match parseFirst “a”<br/>Nothing</span></pre><p id="4486" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意最后一个失败了，因为解析器需要两个输入！我们一会儿会回到这个失败的概念。但是现在我们知道了这项技术，我们可以编写一些其他有用的解析器:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="8d7b" class="lq kg hu ke b fv lr ls l lt lu">readThroughEndOfLine :: RE Char String<br/>readThroughEndOfLine = readUntilEndOfLine &lt;* sym '\n'</span><span id="4bf7" class="lq kg hu ke b fv lv ls l lt lu">readThroughBar :: RE Char String<br/>readThroughBar = readUntilBar &lt;* sym '|'</span><span id="3169" class="lq kg hu ke b fv lv ls l lt lu">readUntilBar :: RE Char String<br/>readUntilBar = many (psym (\c -&gt; c /= '|' &amp;&amp; c /= '\n'))</span></pre><p id="5421" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个将解析该行的其余部分，然后使用换行符本身。其他解析器完成同样的任务，除了竖线字符。下周我们解析<code class="eh kb kc kd ke b">Examples</code>部分时会用到这些。</p><h1 id="5de1" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">备选方案:处理解析失败</h1><p id="db6e" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">我们在上面介绍了解析器“失败”的概念。当然，我们需要能够在解析器失败时提供替代方案！否则，我们的语言结构将非常有限。幸运的是，<code class="eh kb kc kd ke b">RE</code>类型也实现了<code class="eh kb kc kd ke b">Alternative</code>。这意味着当一个解析器失败时，我们可以使用<code class="eh kb kc kd ke b">&lt;|&gt;</code>操作符来确定另一个解析器。让我们来看看实际情况:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="f8a2" class="lq kg hu ke b fv lr ls l lt lu">parseFeatureTitle :: RE Char String<br/>parseFeatureTitle = string “Feature: “ *&gt; readThroughEndOfLine</span><span id="5a1d" class="lq kg hu ke b fv lv ls l lt lu">parseScenarioTitle :: RE Char String<br/>parseScenarioTitle = string “Scenario: “ *&gt; readThroughEndOfLine</span><span id="c374" class="lq kg hu ke b fv lv ls l lt lu">parseEither :: RE Char String<br/>parseEither = parseFeatureTitle &lt;|&gt; parseScenarioTitle</span><span id="d2b6" class="lq kg hu ke b fv lv ls l lt lu">…</span><span id="68ab" class="lq kg hu ke b fv lv ls l lt lu">&gt;&gt; match parseFeatureTitle “Feature: Login\n”<br/>Just “Login”<br/>&gt;&gt; match parseFeatureTitle “Scenario: Login\n”<br/>Nothing<br/>&gt;&gt; match parseEither “Scenario: Login\n”<br/>Just “Login”</span></pre><p id="73dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，如果所有选项都失败了，那么我们仍然会有一个失败的解析器！</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="fc6f" class="lq kg hu ke b fv lr ls l lt lu">&gt;&gt; match parseEither “Random: Login\n”<br/>Nothing</span></pre><p id="73b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将需要这个来为我们的解析系统引入某种程度的选择。例如，由用户决定他们是否想要包含一个<code class="eh kb kc kd ke b">Background</code>作为他们特性的一部分。因此，我们需要能够读取背景，如果它在那里，或者继续分析一个场景。</p><h1 id="6335" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="f052" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">这就结束了我们对应用解析的基本组合子的介绍。下周，我们将把我们在这里开发的所有部分用于小黄瓜语法本身。到目前为止，一切似乎都很小。但是我们将会看到，一旦我们有了基本的部分，我们实际上可以非常快速地建立我们的结果！</p><p id="5d4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想看到更多对重要的Haskell任务有用的库，看看我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>。它将向您介绍一些用于解析的库、数据库、API等等！</p><p id="babc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您是Haskell的新手，现在是开始的最佳时机！下载我们免费的<a class="ae ka" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>！它将帮助你下载正确的工具并开始学习这门语言。</p></div></div>    
</body>
</html>