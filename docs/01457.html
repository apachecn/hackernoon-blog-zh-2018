<html>
<head>
<title>Adding Redux to a React Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向React博客添加Redux</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/adding-redux-to-a-react-blog-97f5fea606c2?source=collection_archive---------3-----------------------#2018-02-15">https://medium.com/hackernoon/adding-redux-to-a-react-blog-97f5fea606c2?source=collection_archive---------3-----------------------#2018-02-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="77b3" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">React博客系列:第四部分</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/e166256f3ae408bf7209111f564eed3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VeM-5lsAtrrJ4jXH96h5kg.png"/></div></div></figure><p id="7b87" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">本文是用React创建博客的每周系列的第四部分，是前几部分创建的代码的扩展。</p><h2 id="fc14" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">React博客系列</h2><p id="f828" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated"><a class="ae lr" rel="noopener" href="/front-end-hacking/building-a-website-with-react-and-bulma-d655214bff2a"> <strong class="jx hv">第一部分:</strong>用React和布尔玛</a> <br/> <a class="ae lr" rel="noopener" href="/@aaron.klaser/building-a-blog-with-react-and-contentful-fd538f68f6fb"> <strong class="jx hv">建立一个网站第二部分:</strong>用React和Contentful建立一个博客</a> <br/> <a class="ae lr" rel="noopener" href="/@aaron.klaser/import-your-medium-feed-into-react-ceadbaf785c7"> <strong class="jx hv">第三部分:</strong>将你的媒体提要导入React </a> <br/> <strong class="jx hv">第四部分:</strong>向React博客添加一个Redux<br/><a class="ae lr" href="https://hackernoon.com/replacing-redux-thunks-with-redux-sagas-4aa306854925" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">第五部分:</strong>用Redux Sagas替换Redux Thunks</a><br/></p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><p id="483b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这就是你们一直在等待的时刻。——<strong class="jx hv"><em class="ls">Redux！！！</em> </strong></p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="4739" class="kr ks hu mb b fv mf mg l mh mi">npm install react-redux <!-- -->redux-thunk redux-immutable-state-invariant</span></pre><blockquote class="mj mk ml"><p id="f9d1" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated"><strong class="jx hv">注意:</strong>你也可以安装redux作为一个开发依赖项。传闻是<strong class="jx hv">纱</strong>解决了这个问题，但你也可以手动安装到依赖。<code class="eh mp mq mr mb b">npm install redux --save-dev</code></p></blockquote><h1 id="c9e9" class="ms ks hu bd kt mt mu mv kx mw mx my lb ja mz jb le jd na je lh jg nb jh lk nc dt translated">添加商店</h1><p id="77e7" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">因此，这可能是一个不受欢迎的观点，因为我知道每个人都有一个努力的ReDucks，但这不是正确的方法。当您将存储文件与组件放在一起时，您正在将表示层与应用程序业务层和状态结合起来。如果有新的东西来取代Redux，你不必从我们所有的文件夹中删除文件，只需删除整个存储。但是我们将在商店中分离我们的文件类型。</p><h2 id="c96d" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">分形概念</h2><p id="96fa" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">记住我们使用的是分形文件结构键值概念。在商店中，我们将遵循这种模式，<strong class="jx hv">key = public actions(thunks)</strong>和<strong class="jx hv">value = private(type reducers和actions)，</strong>这意味着我们的应用程序永远不会与我们文件夹中的文件进行对话。它们将<strong class="jx hv">只与thunk </strong>(键，公共动作)对话，后者将与其文件夹中的文件(值，私有类)对话。在大多数情况下，我们的<strong class="jx hv"> thunk </strong>会从某个地方获取数据，并将其发送到我们的商店。</p><p id="85c5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">困惑了吗？我想是的。</p><p id="d07f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面是一个用户存储文件结构的例子。我们的组件将只与<strong class="jx hv"> User.js </strong>对话，而后者将与用户文件夹中的文件对话。随着时间的推移，这将更有意义。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="13c5" class="kr ks hu mb b fv mf mg l mh mi">src <br/>- app <br/>  - ... app code ...<br/>- store<br/>  - User.js<br/>  - user<br/>    - actions<br/>    - reducer<br/>    - types</span></pre><h2 id="75c0" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">建立</h2><p id="f81b" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">在<code class="eh mp mq mr mb b">src</code>文件夹中添加一个名为<strong class="jx hv">的文件夹存储</strong>。</p><p id="2f60" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后添加三个文件:<strong class="jx hv"> index.js </strong>、<strong class="jx hv"> initialState.js </strong>和<strong class="jx hv"> rootReducer.js </strong></p><p id="629f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">设置index.js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="6894" class="kr ks hu mb b fv mf mg l mh mi">import { createStore, applyMiddleware } from 'redux'<br/>import { rootReducer } from './rootReducer'<br/>import reduxImmutableStateInvariant from 'redux-immutable-state-invariant'<br/>import thunk from 'redux-thunk'</span><span id="5b1e" class="kr ks hu mb b fv nd mg l mh mi">export function configureStore(initialState) {<br/>  return createStore(<br/>    rootReducer,<br/>    initialState,<br/>    applyMiddleware(<br/>      thunk,<br/>      reduxImmutableStateInvariant()<br/>    )<br/>  )<br/>}</span></pre><p id="4ee2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Setup initialState.js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="008a" class="kr ks hu mb b fv mf mg l mh mi">export default {</span><span id="5498" class="kr ks hu mb b fv nd mg l mh mi">}</span></pre><p id="295b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">安装rootReducer.js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="2337" class="kr ks hu mb b fv mf mg l mh mi">import { combineReducers } from 'redux'</span><span id="b311" class="kr ks hu mb b fv nd mg l mh mi">export const rootReducer = combineReducers({</span><span id="f271" class="kr ks hu mb b fv nd mg l mh mi">})</span></pre><p id="8bb2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要连接到应用程序，请打开<strong class="jx hv"> src文件夹</strong>中的应用程序<code class="eh mp mq mr mb b">index.js</code>，然后存储并打包应用程序。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="5b40" class="kr ks hu mb b fv mf mg l mh mi">import React from 'react';<br/>import ReactDOM from 'react-dom'<br/>import registerServiceWorker from './registerServiceWorker'<br/>import { BrowserRouter as Router } from 'react-router-dom'<br/>import App from './App'</span><span id="ba1b" class="kr ks hu mb b fv nd mg l mh mi"><strong class="mb hv"><em class="ls">// Redux Store<br/></em>import { Provider } from 'react-redux'<br/>import { configureStore } from './src/store'</strong></span><span id="8647" class="kr ks hu mb b fv nd mg l mh mi">import './index.css'</span><span id="6fe6" class="kr ks hu mb b fv nd mg l mh mi"><strong class="mb hv">const store = configureStore()</strong></span><span id="ff7c" class="kr ks hu mb b fv nd mg l mh mi">ReactDOM.render((<br/>  <strong class="mb hv">&lt;Provider store={store}&gt;</strong><br/>    &lt;Router&gt;<br/>      &lt;App /&gt;<br/>    &lt;/Router&gt;<br/>  <strong class="mb hv">&lt;/Provider&gt;</strong><br/>), document.getElementById('root'))<br/>registerServiceWorker()</span></pre><p id="2f40" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">ConfigureStore是我们商店的<strong class="jx hv"> index.js </strong>，在设置期间，我们目前没有传递任何初始状态。</p><p id="1ec6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">此外，如果您需要应用程序检索任何初始数据，将在我们将存储设置为configureStore后调用它。</p><h1 id="31b6" class="ms ks hu bd kt mt mu mv kx mw mx my lb ja mz jb le jd na je lh jg nb jh lk nc dt translated">Redux博客商店</h1><p id="415b" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">现在简单的部分已经过去了，让我们卷起自己，创造一些奇迹。</p><p id="aabb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我们的商店文件夹中创建一个名为<strong class="jx hv"> Blog.js </strong>的文件和一个名为<strong class="jx hv"> blog </strong>的文件夹。在博客文件夹中创建三个填充:<strong class="jx hv"> actions.js </strong>、<strong class="jx hv"> reducer.js </strong>和<strong class="jx hv"> types.js </strong></p><p id="6e7c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">先说我们的类型。这些是我们的操作调用调度使用的常量。首先，我们只需要一个加载我们的博客数据到我们的商店。</p><p id="a1d3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mp mq mr mb b">store/blog/types.js</code>添加</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="1127" class="kr ks hu mb b fv mf mg l mh mi"><em class="ls">/**<br/>* Blog Types<br/>*/</em></span><span id="f40b" class="kr ks hu mb b fv nd mg l mh mi">export const LOAD_BLOG_SUCCESS = 'LOAD_BLOG_SUCCESS'</span></pre><p id="b2c6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我们继续之前，让我们添加一个blog对象，用一个空的posts数组作为blog的初始状态。这将在设置我们的减速器时通过。它还允许应用程序在没有数据的情况下加载，而不会抛出空异常。</p><p id="e420" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mp mq mr mb b">store/initialState.js</code>中添加</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="2048" class="kr ks hu mb b fv mf mg l mh mi">export default {<br/>  blog: {<br/>    posts: []<br/>  }<br/>}</span></pre><p id="dbd8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，让我们设置我们的减速器。这是更新我们状态的东西，也是我们数据存储的地方。这些操作将调用它们，并通过一个switch语句来查找该操作所调用的类型。</p><p id="9613" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mp mq mr mb b">store/blog/reducer.js</code>添加</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="3580" class="kr ks hu mb b fv mf mg l mh mi"><em class="ls">/**<br/>* Blog Reducer<br/>*/</em><br/>import initialState from '../../store/initialState'<br/>import * as types from './types'</span><span id="10f2" class="kr ks hu mb b fv nd mg l mh mi">export default function blogReducer(state = initialState.blog, action) {<br/>  switch (action.type) {<br/>    case types.LOAD_BLOG_POSTS_SUCCESS:<br/>      return {<br/>        ...state,<br/>        posts: action.posts<br/>      } <br/>    default:<br/>      return state<br/>  }<br/>}</span></pre><p id="29a0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，我们需要设置一个动作来分派该类型，并将其数据设置为有效负载(posts)。</p><p id="3594" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mp mq mr mb b">store/blog/actions.js</code>添加</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="64ee" class="kr ks hu mb b fv mf mg l mh mi"><em class="ls">/**<br/>* Blog Actions<br/>*/</em><br/>import * as types from './types'</span><span id="99ba" class="kr ks hu mb b fv nd mg l mh mi">export function loadBlogSuccess(post) {<br/>  return { type: types.LOAD_BLOG_SUCCESS, post}<br/>}</span></pre><p id="c3e8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，我们需要将它包含在我们的rootReduce中。rootReducer将所有存储的Reducer组合成一个巨大的reducer，它创建了一个全局状态，可以在应用程序的任何地方访问。</p><p id="886d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mp mq mr mb b">store/rootReducer.js</code>中添加</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="7542" class="kr ks hu mb b fv mf mg l mh mi">import { combineReducers } from 'redux'<br/><strong class="mb hv">import blog from './blog/reducer'</strong></span><span id="08c1" class="kr ks hu mb b fv nd mg l mh mi">export const rootReducer = combineReducers({<br/><strong class="mb hv">  blog</strong><br/>})</span></pre><blockquote class="mj mk ml"><p id="0d7e" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated"><strong class="jx hv">注意</strong>我们没有将它作为blogReducer导入，因为无论你在combineReduces中如何称呼它，都是你在应用程序的其余部分如何访问它。<strong class="jx hv">导出缺省值</strong>是当我们导入缺省函数时，允许我们命名任何我们想要的东西。我们可以把它作为blogReducer导入，然后由combineReducers函数完成。#CodeIsArt</p></blockquote><h1 id="342b" class="ms ks hu bd kt mt mu mv kx mw mx my lb ja mz jb le jd na je lh jg nb jh lk nc dt translated">测试Redux是否正常工作</h1><p id="dcd0" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">现在我们的代码正在工作。它还没有做任何事情，因为它实际上没有做任何我们可以看到的事情，但它正在工作<strong class="jx hv"> <em class="ls">和</em> </strong>我可以证明这一点。</p><p id="3b47" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先你需要chrome的Redux开发工具扩展。<a class="ae lr" href="https://github.com/zalmoxisus/redux-devtools-extension" rel="noopener ugc nofollow" target="_blank">https://github.com/zalmoxisus/redux-devtools-extension</a></p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="5639" class="kr ks hu mb b fv mf mg l mh mi">npm install --save-dev redux-devtools-extension</span></pre><p id="9d0f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那我们需要把它连接起来。在<code class="eh mp mq mr mb b">store/index.js</code>中，我们将删除<strong class="jx hv"> initialState </strong>，因为我们将在每个商店的reducers中设置它们，我们将用<strong class="jx hv"> composeWithDevTools </strong>函数包装我们的中间件。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="da9c" class="kr ks hu mb b fv mf mg l mh mi">import { createStore, applyMiddleware } from 'redux'<br/>import { rootReducer } from './rootReducer'<br/>import reduxImmutableStateInvariant from 'redux-immutable-state-invariant'<br/>import thunk from 'redux-thunk'<br/><strong class="mb hv">import { composeWithDevTools } from 'redux-devtools-extension';</strong></span><span id="0992" class="kr ks hu mb b fv nd mg l mh mi">export function configureStore() {<br/>  return createStore(<br/>    rootReducer,<br/>    <strong class="mb hv">composeWithDevTools(</strong><br/>      applyMiddleware(<br/>        thunk,<br/>        reduxImmutableStateInvariant()<br/>      )<br/>    <strong class="mb hv">)</strong><br/>  )<br/>}</span></pre><p id="5ad8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后在chrome中安装扩展，打开chrome inspector(我一般是在页面上右键点击inspector)。在顶部导航你现在应该有Redux选项。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ne"><img src="../Images/d5fb39c1ee3e99ebf082df5dc7f97c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFY2Ze0-4ljZjKwH_mbjBA.png"/></div></div></figure><p id="436f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">单击它并刷新您的应用程序。当应用程序加载时，Redux选项卡有时必须打开才能工作，这是因为连接是在<strong class="jx hv"> createStore(…) </strong>功能中的站点加载上建立的。</p><p id="6443" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，你应该看到你的Redux状态和历史。它默认为<strong class="jx hv"> Diff </strong>，因此单击<strong class="jx hv">状态</strong>选项卡，您应该会看到您的默认对象</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/7bb6d0804e2f5f6bec7f3b4651a2b51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YabeRhQBzYOx1laLGJ8tw.png"/></div></div></figure><p id="3af5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">很酷，对吧！</p><h1 id="157b" class="ms ks hu bd kt mt mu mv kx mw mx my lb ja mz jb le jd na je lh jg nb jh lk nc dt translated">将博客数据放入博客存储中</h1><p id="811d" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">请记住<strong class="jx hv"> Blog.js </strong>文件中是我店的<strong class="jx hv">公共行为</strong> (the thunk) <strong class="jx hv"> </strong>。当站点加载时，我们将在这里放置thunks并检索我们的数据。</p><p id="d68e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们可以重用来自<code class="eh mp mq mr mb b">app/Blog.js</code>的一些逻辑，因为它不再需要调用Contentful。我们认为那会发生。</p><p id="fcc4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们设置我们的thunk。打开<code class="eh mp mq mr mb b">store/Blog.js</code>并添加</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="aadb" class="kr ks hu mb b fv mf mg l mh mi">import * as contentful from 'contentful'<br/>import * as actions from './blog/actions'</span><span id="ff09" class="kr ks hu mb b fv nd mg l mh mi">const client = contentful.createClient({<br/>  space: 'qu10m4oq2u62',<br/>  accessToken: 'f4a9f68de290d53552b107eb503f3a073bc4c632f5bdd50efacc61498a0c592a'<br/>})</span><span id="01ec" class="kr ks hu mb b fv nd mg l mh mi">const error = err =&gt; console.log(err)</span><span id="b9cd" class="kr ks hu mb b fv nd mg l mh mi">export function loadBlog() {<br/>  return dispatch =&gt;<br/>    client.getEntries()<br/>      .then(({items}) =&gt; {<br/>        dispatch(actions.loadBlogSuccess(items))<br/>      })<br/>      .catch(error)<br/>}</span></pre><blockquote class="mj mk ml"><p id="228e" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">thunk自动将分派传递给我们的函数，这是第一个参数所做的。</p></blockquote><p id="9ce6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这段代码将调用Contentful，并将数据发送到loadBlogSuccess操作，该操作将数据存储在posts下的博客状态中。</p><p id="bde5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是它不会自动发生，我们需要在网站加载时调用这个函数。</p><p id="c576" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们将通过在我们的<strong class="jx hv">根</strong>T3】文件中添加一行来做到这一点</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="77a8" class="kr ks hu mb b fv mf mg l mh mi">...</span><span id="ec7f" class="kr ks hu mb b fv nd mg l mh mi"><em class="ls">// Redux Store<br/></em>import { Provider } from 'react-redux'<br/>import { configureStore } from './store'<br/><strong class="mb hv">import { loadBlog } from './store/Blog'</strong></span><span id="32d5" class="kr ks hu mb b fv nd mg l mh mi">import './index.css'</span><span id="b984" class="kr ks hu mb b fv nd mg l mh mi">const store = configureStore()<br/><strong class="mb hv">store.dispatch(loadBlog())</strong></span><span id="545c" class="kr ks hu mb b fv nd mg l mh mi">ReactDOM.render((</span><span id="2334" class="kr ks hu mb b fv nd mg l mh mi">...</span></pre><p id="88af" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们告诉商店，一旦它被创建，就分派<strong class="jx hv"> loadBlog() </strong>函数。</p><p id="6219" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当您刷新应用程序并检查Redux dev工具时，您现在应该会在<strong class="jx hv">博客&gt;帖子</strong>中看到一些数据</p><h1 id="6c31" class="ms ks hu bd kt mt mu mv kx mw mx my lb ja mz jb le jd na je lh jg nb jh lk nc dt translated">在组件中使用存储</h1><p id="1fe8" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">这是一个非常简单的步骤。Redux给了我们一个可以使用的函数mapStateToProps，正如你可能猜到的，它将我们的redux状态映射到我们的页面属性。然后我们将mapStateToProps和Blog.js“连接”到Redux。</p><p id="f0a1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">神奇的是，打开app/Blog.js并删除我们的旧代码以获得帖子并添加/更新8行代码。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="ac90" class="kr ks hu mb b fv mf mg l mh mi">import React from 'react'<br/><strong class="mb hv">import { connect } from 'react-redux'</strong><br/>import * as contentful from 'contentful'<br/>import BlogItem from './blog/BlogItem'<br/>import PageHeader from './components/PageHeader'<br/>import PageContent from './components/PageContent'</span><span id="cc0f" class="kr ks hu mb b fv nd mg l mh mi">class Blog extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;PageHeader color="is-info" title="Code Blog"&gt;<br/>          Your standard &lt;strong&gt;JavaScript&lt;/strong&gt; programming blog, albeit, probably not very good, but I will at least try to keep it entertaining. This blog is a chronological mix of random posts on Angular, React, Functional Programming, and my &lt;strong&gt;project walkthroughs&lt;/strong&gt;.<br/>        &lt;/PageHeader&gt;<br/>        &lt;PageContent&gt;<br/>          { <strong class="mb hv">this.props.blog.posts.map</strong>(({fields}, i) =&gt;<br/>            &lt;BlogItem key={i} {...fields} /&gt;<br/>          )}<br/>        &lt;/PageContent&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="5f3f" class="kr ks hu mb b fv nd mg l mh mi"><strong class="mb hv">function mapStateToProps(state, ownProps) {<br/>  return {<br/>    blog: state.blog<br/>  }<br/>}</strong></span><span id="7c78" class="kr ks hu mb b fv nd mg l mh mi">export default <strong class="mb hv">connect(mapStateToProps)(Blog)</strong></span></pre><p id="d906" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Blammo！Redux！</p><h1 id="12ec" class="ms ks hu bd kt mt mu mv kx mw mx my lb ja mz jb le jd na je lh jg nb jh lk nc dt translated">正确使用博客状态</h1><p id="ee40" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">我将是第一个承认当我第一次开始使用Redux的时候，我是把它作为一个数据存储来使用的，它远不止于此。它是你的应用程序的状态，它去了哪里，去了哪里，在做什么，它知道什么…只用它来存储数据是对它的存在的侮辱。例如，我们的应用程序现在运行得很好，因为Contentful很棒，速度很快，我们只有很少的数据，但如果我们有很多数据或很慢的连接呢？我们不想为用户加载一个空白的剧本。</p><p id="ace6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们为加载创建一个博客状态，也就是说，当它从Contentful获取数据时，我们可以显示一个加载图标。</p><p id="56a9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">store/initialState.js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="0295" class="kr ks hu mb b fv mf mg l mh mi">export default {<br/>  blog: {<br/>    <strong class="mb hv">loading: false,</strong><br/>    posts: []<br/>  }<br/>}</span></pre><p id="bb24" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">store/博客/types.js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="0c9e" class="kr ks hu mb b fv mf mg l mh mi"><em class="ls">/**<br/>* Blog Types<br/>*/<br/></em>export const BLOG_LOADING = 'BLOG_LOADING'<br/>export const LOAD_BLOG_SUCCESS = 'LOAD_BLOG_SUCCESS'</span></pre><p id="3ebf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">store/blog/reduce . js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="72af" class="kr ks hu mb b fv mf mg l mh mi"><em class="ls">/**<br/>* Blog Reducer<br/>*/<br/></em>import initialState from '../../store/initialState'<br/>import * as types from './types'</span><span id="4b42" class="kr ks hu mb b fv nd mg l mh mi">export default function blogReducer(state = initialState.blog, action) {<br/>  switch (action.type) {<br/>    case types.BLOG_LOADING:<br/>      return {<br/>        ...state,<br/>        loading: action.isLoading<br/>      }<br/>    case types.LOAD_BLOG_SUCCESS:<br/>      return {<br/>        ...state,<br/>        posts: action.posts,<br/>        loading: false<br/>      }<br/>   default:<br/>     return state<br/>  }<br/>}</span></pre><blockquote class="mj mk ml"><p id="b131" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">是的。State只包含posts和loading，但我们仍然将它展开。如果你在记分数，你可能早就注意到了。这是一个很好的实践，因为我们每次都在设置一个新的状态对象。购买总是传播状态首先，我们得到所有以前的值，不要忘记任何，然后新的字段简单的覆盖以前的值。喜欢<code class="eh mp mq mr mb b"><strong class="jx hv">Object.assign({}, previouseState, { …newStateValues})</strong></code></p></blockquote><p id="dffc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">商店/博客/行动. js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="6e0b" class="kr ks hu mb b fv mf mg l mh mi"><em class="ls">/**<br/>* Blog Actions<br/>*/<br/></em>import * as types from './types'</span><span id="285b" class="kr ks hu mb b fv nd mg l mh mi"><strong class="mb hv">export function blogLoading(</strong>isLoading = true<strong class="mb hv">) {<br/>  return { type: types.BLOG_LOADING, isLoading}<br/>}</strong></span><span id="a4f6" class="kr ks hu mb b fv nd mg l mh mi">export function loadBlogSuccess(posts) {<br/>  return { type: types.LOAD_BLOG_SUCCESS, posts}<br/>}</span></pre><blockquote class="mj mk ml"><p id="a040" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">我们将<strong class="jx hv"> isloading </strong>设置为默认值true，所以我们通常不会在调度博客加载时传递任何数据。<strong class="jx hv">但是</strong>，通过让它让我们<strong class="jx hv">可以</strong>传入类似false的东西，意味着我们不需要创建一个动作来将loading设置为false，比如说加载是否有错误。</p></blockquote><p id="1ffd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">store/博客. js</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="6a07" class="kr ks hu mb b fv mf mg l mh mi">import * as contentful from 'contentful'<br/>import * as actions from './blog/actions'</span><span id="d107" class="kr ks hu mb b fv nd mg l mh mi">const client = contentful.createClient({<br/>  space: 'qu10m4oq2u62',<br/>  accessToken: 'f4a9f68de290d53552b107eb503f3a073bc4c632f5bdd50efacc61498a0c592a'<br/>})</span><span id="648c" class="kr ks hu mb b fv nd mg l mh mi">export function loadBlog() {<br/>  return dispatch =&gt; <strong class="mb hv">{</strong><br/>    <strong class="mb hv">dispatch(actions.blogLoading())<br/></strong>    <strong class="mb hv">return </strong>client.getEntries()<br/>      .then(({items}) =&gt; {<br/>        dispatch(actions.loadBlogSuccess(items))<br/>      })<br/>      .catch(<strong class="mb hv">error =&gt; {<br/>        console.log(error)<br/>        dispatch(actions.blogLoading(false))<br/>      }</strong>)<br/>  <strong class="mb hv">}</strong><br/>}</span></pre><blockquote class="mj mk ml"><p id="edb6" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">所以我们需要做一些重新安排，我们稍后会清理它，但是我们需要能够调用dispatch来调用我们对<strong class="jx hv"> blogLoading </strong>的操作。</p></blockquote><p id="30d1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，您应该可以在Redux开发工具中看到一些额外的动作。</p><h2 id="9e08" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">更新视图以添加装载图标</h2><p id="7a47" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">回到<code class="eh mp mq mr mb b">app/Blog.js</code>让我们设置一些占位符文本，以确保我们的逻辑工作。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="d29b" class="kr ks hu mb b fv mf mg l mh mi">&lt;div&gt;<br/>  &lt;PageHeader color="is-info" title="Code Blog"&gt;<br/>Your standard &lt;strong&gt;JavaScript&lt;/strong&gt; programming blog, albeit, probably not very good, but I will at least try to keep it entertaining. This blog is a chronological mix of random posts on Angular, React, Functional Programming, and my &lt;strong&gt;project walkthroughs&lt;/strong&gt;.<br/>  &lt;/PageHeader&gt;<br/>  <strong class="mb hv">{ this.props.blog.loading<br/>    ? &lt;div&gt;Loading&lt;/div&gt;<br/>    :</strong> &lt;PageContent&gt;<br/>        { this.props.blog.posts.map(({fields}, i) =&gt;<br/>          &lt;BlogItem key={i} {...fields} /&gt;<br/>        )}<br/>      &lt;/PageContent&gt;<br/> <strong class="mb hv">}</strong><br/>&lt;/div&gt;</span></pre><p id="3361" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们用三元运算符包装前面的代码来处理if语句。这意味着，如果loading为真，我们将显示loading div，否则我们将显示内容dev。</p><blockquote class="mj mk ml"><p id="9136" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">如果你和我一样，Contentful只是太快了，你看不到它。我们可以在getEntries成功承诺上包装调度，并设置一个超时。<code class="eh mp mq mr mb b">setTimeout(() =&gt; dispatch(actions.loadBlogSuccess(items)), 5000)</code></p><p id="6590" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">现在，您应该能够看到加载div。</p><p id="d01b" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated"><strong class="jx hv">或</strong>，可以在Redux Dev工具中实现历史跳转功能。我会让你自己去发现那颗小宝石。)</p></blockquote><p id="9627" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，在<code class="eh mp mq mr mb b">app/components</code>中创建<strong class="jx hv"> Loader.js </strong>，这将是我们的spinner的样式组件。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="fda7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在回到我们的<code class="eh mp mq mr mb b">app/Blog.js</code>让我们添加旋转器。将<code class="eh mp mq mr mb b">&lt;div&gt;Loading&lt;/div&gt;</code>替换为</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="7c57" class="kr ks hu mb b fv mf mg l mh mi">&lt;Loader className="has-text-primary"&gt;&lt;/Loader&gt;</span></pre><p id="68d5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">别忘了导入加载器<code class="eh mp mq mr mb b">import { Loader } from ‘./components/Loader’</code></p><p id="88f1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">加载器默认为白色，所以你需要硬编码颜色或者使用<strong class="jx hv">布尔玛</strong>我们可以给它一个类<strong class="jx hv"> has-text-$color </strong>(类似has-text-primary) <strong class="jx hv">。</strong></p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="2308" class="ms ks hu bd kt mt ni mv kx mw nj my lb ja nk jb le jd nl je lh jg nm jh lk nc dt translated">我发现了一个bug:(</h1><p id="92be" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">回到<a class="ae lr" rel="noopener" href="/front-end-hacking/building-a-blog-with-react-and-contentful-fd538f68f6fb">用React和Contentful创建博客的清理阶段</a>，我忘记在博客条目导航中更改“阅读更多”和“返回博客”的文本。</p><p id="77a3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用<code class="eh mp mq mr mb b">to</code>道具，在<code class="eh mp mq mr mb b">&lt;Link&gt;</code>中使用一个简单的三进制操作符就可以很容易地解决这个问题。</p><p id="41ff" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mp mq mr mb b">app/blog/shared/BlogNav.js</code>可以链接到这个</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="169c" class="kr ks hu mb b fv mf mg l mh mi">&lt;Link className="level-item button is-small is-link is-outlined" to={to}&gt;<br/>  <strong class="mb hv">{ to === '/blog' ? 'Back to Blog' : 'Read More'}</strong><br/>&lt;/Link&gt;</span></pre></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="3e73" class="ms ks hu bd kt mt ni mv kx mw nj my lb ja nk jb le jd nl je lh jg nm jh lk nc dt translated">将商店添加到媒体页面</h1><p id="0129" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">现在我们可以为我们的媒体页面做完全相同的事情。我不会向你展示每一个步骤，因为这不是我们学习的方式，但我会为你列出它们。</p><p id="46da" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">步骤1: </strong>创建类型<br/> <strong class="jx hv">步骤2: </strong>将状态添加到初始状态<br/> <strong class="jx hv">步骤3: </strong>设置还原器<br/> <strong class="jx hv">步骤4: </strong>设置操作<br/> <strong class="jx hv">步骤5: </strong>将还原器添加到根还原器<br/> <strong class="jx hv">步骤6 </strong>:设置我们的thunk <em class="ls">(提示如下)</em></p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="1c6a" class="kr ks hu mb b fv mf mg l mh mi">import * as actions from './medium/actions'<br/>import axios from 'axios'</span><span id="3064" class="kr ks hu mb b fv nd mg l mh mi">const fetchPosts = () =&gt; axios.get(`https://cors.now.sh/https://us-central1-aaronklaser-1.cloudfunctions.net/medium?username=@aaron.klaser`)</span><span id="94c8" class="kr ks hu mb b fv nd mg l mh mi">const setPosts = ({data}) =&gt; Object.values(data.payload.references.Post).map(<br/>  ({ id, title, createdAt, virtuals, uniqueSlug }) =&gt; Object.assign({},{<br/>    title,<br/>    createdAt,<br/>    subtitle: virtuals.subtitle,<br/>    image: virtuals.previewImage.imageId ? `https://cdn-images-1.medium.com/max/800/${virtuals.previewImage.imageId}` : null,<br/>    url: `https://medium.com/@aaron.klaser/${uniqueSlug}`<br/>  })<br/>)</span><span id="a24c" class="kr ks hu mb b fv nd mg l mh mi">export const loadMedium = () =&gt; async dispatch =&gt; {<br/>  dispatch(actions.mediumLoading())<br/>  const data = await fetchPosts()<br/>  return dispatch(actions.loadMediumSuccess(setPosts(data)))<br/>}</span></pre><p id="0542" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">第7步:</strong>向组件添加状态</p><p id="8d4c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">测试它，继续生活。你现在是Redux大师了！</p><h1 id="fdc1" class="ms ks hu bd kt mt mu mv kx mw mx my lb ja mz jb le jd na je lh jg nb jh lk nc dt translated">让我们回顾一下</h1><ul class=""><li id="1cf1" class="nn no hu jx b jy lm kb ln ke np ki nq km nr kq ns nt nu nv dt translated">将Redux和朋友添加到您的项目中。</li><li id="4d76" class="nn no hu jx b jy nw kb nx ke ny ki nz km oa kq ns nt nu nv dt translated">使用分形文件结构设置商店</li><li id="fbd9" class="nn no hu jx b jy nw kb nx ke ny ki nz km oa kq ns nt nu nv dt translated">设置商店的类型缩减器和加载数据的操作</li><li id="05d5" class="nn no hu jx b jy nw kb nx ke ny ki nz km oa kq ns nt nu nv dt translated">设置商店的thunk，这是我们的公共操作类</li><li id="06c5" class="nn no hu jx b jy nw kb nx ke ny ki nz km oa kq ns nt nu nv dt translated">将商店添加到页面组件中</li><li id="6344" class="nn no hu jx b jy nw kb nx ke ny ki nz km oa kq ns nt nu nv dt translated">添加了加载状态和加载动画</li><li id="045d" class="nn no hu jx b jy nw kb nx ke ny ki nz km oa kq ns nt nu nv dt translated">修正了一个预览错误</li><li id="e13b" class="nn no hu jx b jy nw kb nx ke ny ki nz km oa kq ns nt nu nv dt translated">将商店添加到介质页面</li></ul><blockquote class="mj mk ml"><p id="0059" class="jv jw ls jx b jy jz iv ka kb kc iy kd mm kf kg kh mn kj kk kl mo kn ko kp kq hn dt translated">接下来— <a class="ae lr" href="https://hackernoon.com/replacing-redux-thunks-with-redux-sagas-4aa306854925" rel="noopener ugc nofollow" target="_blank">用Redux Sagas替换Redux Thunks</a></p></blockquote></div></div>    
</body>
</html>