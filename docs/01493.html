<html>
<head>
<title>The one-stop guide to (easy) cross-platform Python freezing: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(简单的)跨平台Python冻结一站式指南:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-one-stop-guide-to-easy-cross-platform-python-freezing-part-1-c53e66556a0a?source=collection_archive---------1-----------------------#2018-02-16">https://medium.com/hackernoon/the-one-stop-guide-to-easy-cross-platform-python-freezing-part-1-c53e66556a0a?source=collection_archive---------1-----------------------#2018-02-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/44ae3cb812a363cadf33307fb1c3eb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klxctdYKT_DcsLxVncqdJA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image taken from Sqreen.io</figcaption></figure><p id="1983" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我成为MusicBrainz Picard的维护者已经快一年了，这是一款跨平台多语言的桌面应用程序，允许你通过这个<a class="ae ke" href="http://musicbrainz.org" rel="noopener ugc nofollow" target="_blank">非常酷的服务MusicBrainz </a>来标记你的音乐文件。</p><p id="bbd6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我认为Picard是一个相当大的python应用，大约有35k SLoC。对于这样规模的python应用程序，挑战来了。去年我面临的最大挑战之一是在我为我的GSoC项目将Picard移植到Python 3/PyQt5之后，为它支持的所有三个平台打包Picard，Linux、macOS和Windows。你可以在这里阅读更多关于<a class="ae ke" href="https://hackernoon.com/500-commits-of-summer-my-story-of-foss-and-gsoc-40bb8b325f65" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><blockquote class="kf kg kh"><p id="b4d3" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">“冻结”您的代码就是创建一个可执行文件分发给最终用户，其中包含您的所有应用程序代码以及Python解释器。</p><p id="b9ec" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">以这种方式发布的好处是，即使用户没有安装所需的Python版本(或任何版本)，您的应用程序也会“正常工作”。在Windows上，甚至在许多Linux发行版和OS X上，还没有安装正确的Python版本。</p><p id="558d" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">-<a class="ae ke" href="http://docs.python-guide.org/en/latest/shipping/freezing/" rel="noopener ugc nofollow" target="_blank">Python的搭便车指南</a></p></blockquote><h2 id="104e" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">测试我的选择</h2><p id="7036" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">我们现有的设置分别使用py2exe和py2app来冻结Windows和macOS的Picard。因为它们不完全支持Python 3和PyQt5，所以我在寻找一个新的冻结工具。在用<a class="ae ke" href="https://anthony-tuininga.github.io/cx_Freeze/" rel="noopener ugc nofollow" target="_blank"> cx_Freeze </a>测试了waters之后，我最终选定了<a class="ae ke" href="http://pyinstaller.org" rel="noopener ugc nofollow" target="_blank"> PyInstaller </a>。</p><h2 id="a809" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">py installer——一个快乐的惊喜</h2><p id="7571" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">关于PyInstaller，我想说的一件事是——冻结我的python应用程序是如此容易，而我只需付出最少的努力，就能获得神话般的依赖，这让我感到非常惊讶。它支持Python 2和3以及所有3个桌面操作系统，甚至允许您为每个操作系统创建可移植的一体化二进制文件。多酷啊！</p><p id="da01" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我打算让您稍微了解一下PyInstaller是多么强大和简单，以及如何与<a class="ae ke" href="https://ci.appveyor.com" rel="noopener ugc nofollow" target="_blank"> AppVeyor </a>和<a class="ae ke" href="http://travis-ci.org" rel="noopener ugc nofollow" target="_blank"> TravisCI </a>结合使用，您甚至无需访问其中任何一个就可以为Windows和macOS打包python应用程序。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><h1 id="c66c" class="mb kn hu bd ko mc md me ks mf mg mh kw mi mj mk kz ml mm mn lc mo mp mq lf mr dt translated">入门指南</h1><p id="fb06" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">在博客的这一部分，我们将创建一个PyInstaller规范文件并冻结我们的包。在下一部分中，我们将研究TravisCI和AppVeyor的持续交付。</p><h2 id="c095" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">安装PyInstaller</h2><p id="31fd" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">你需要做的就是<code class="eh ms mt mu mv b">pip install pyinstaller</code>。就这么简单。您可以在全局范围内安装它，也可以安装在您的项目所在的虚拟环境中。后者显然是更可取的。这将让你主要访问2个脚本，我们将在本教程的其余部分使用— <code class="eh ms mt mu mv b">pyinstaller</code>和<code class="eh ms mt mu mv b">pyi-makespec</code>。</p><h2 id="04aa" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">项目信息和结构</h2><p id="865e" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">让我们从一个非常基本的结构开始介绍PyInstaller，然后根据我们的需要进行调整。</p><pre class="mw mx my mz fq na mv nb nc aw nd dt"><span id="caba" class="km kn hu mv b fv ne nf l ng nh">package_dir<br/>├── package<br/>│   ├── submodule_bar<br/>│   ├── submodule_foo<br/>│   ├── __init__.py<br/>│   └── main.py<br/>├── entry_point.py<br/>└── setup.py</span></pre><p id="b899" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以上假设您有一个名为<code class="eh ms mt mu mv b">entry_point.py</code>的入口点脚本，它启动您的应用程序。参见<a class="ae ke" href="http://python-packaging.readthedocs.io/en/latest/index.html#" rel="noopener ugc nofollow" target="_blank"> python-packaging </a>获取如何打包应用程序的帮助。</p><p id="b39e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在神奇的部分来了。要冻结你的应用程序，你只需</p><p id="b4b1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh ms mt mu mv b">pyinstaller entry_point.py -n foobar</code></p><p id="76ca" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就这么简单！PyInstaller将自动计算出所有的依赖项，包括所有需要加载的动态库，并使用名为<code class="eh ms mt mu mv b"><strong class="ji hv">foobar</strong></code>的冻结应用创建一个<code class="eh ms mt mu mv b">dist</code>目录。</p><p id="e40b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">输出应该如下所示</p><pre class="mw mx my mz fq na mv nb nc aw nd dt"><span id="2054" class="km kn hu mv b fv ne nf l ng nh">package_dir<br/>├── dist<br/>│   └── foobar<br/>│       ├── ...<br/>│       ├── ...<br/>│       ├── ...<br/>│       └── foobar<br/>├── package<br/>│   ├── submodule_bar<br/>│   ├── submodule_foo<br/>│   ├── __init__.py<br/>│   └── main.py<br/>├── entry_point.py<br/>├── foobar.spec<br/>└── setup.py</span></pre><p id="e929" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可以通过启动<code class="eh ms mt mu mv b">dist/foobar/foobar</code>来执行你的app(当然在Windows和macOS上分别会是<code class="eh ms mt mu mv b">foobar.exe</code>或者<code class="eh ms mt mu mv b">foobar.app</code>)。</p><h2 id="f35c" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">便携应用，这是什么魔力？</h2><p id="5795" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">现在让我们更进一步。如果您希望将整个应用程序与其所有依赖项捆绑成一个可移植的可执行文件，该怎么办？很简单，只需将<code class="eh ms mt mu mv b">--onefile</code>标志传递给PyInstaller。</p><p id="0281" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh ms mt mu mv b">pyinstaller entry_point.py -n foobar --onefile</code></p><p id="4d20" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">PyInstaller将在名为<code class="eh ms mt mu mv b">foobar</code>的dist文件夹中输出一个可移植的可执行文件，这个文件很容易启动。同样，PyInstaller将自动查找并捆绑该文件中的所有依赖项！</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><h1 id="777a" class="mb kn hu bd ko mc md me ks mf mg mh kw mi mj mk kz ml mm mn lc mo mp mq lf mr dt translated">不会这么简单吧？可以吗？如果我需要…</h1><h2 id="e709" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">捆绑库</h2><p id="d46b" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">PyInstaller支持许多现成的主要框架和库。这包括—</p><p id="5579" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Babel，Django，IPython，matplotlib，numpy，pillow，PyGTK，PyQt4，PyQt5，scipy，sphinx，SQLAlchemy，wxPython和<a class="ae ke" href="https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages" rel="noopener ugc nofollow" target="_blank">等等。</a></p><p id="019d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你的应用程序依赖于以上任何一个库，你不需要担心包含依赖库、dll、隐藏导入、包或其他任何东西的麻烦。PyInstaller为您打理一切。它递归地检查你的代码，找出所有的依赖关系。</p><h2 id="8853" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">添加和捆绑资源</h2><p id="465b" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">资源可以是任何东西，图像、图标、文本数据、翻译字符串。捆绑和访问您的资源有一个非常简单的方法。为了简单起见，让我们假设您所有的资源都在一个名为<code class="eh ms mt mu mv b">resources</code>的目录中，如下所示</p><pre class="mw mx my mz fq na mv nb nc aw nd dt"><span id="2a31" class="km kn hu mv b fv ne nf l ng nh">package_dir<br/>├── package<br/>│   ├── submodule_bar<br/>│   ├── submodule_foo<br/>│   ├── __init__.py<br/>│   └── main.py<br/>├── resources<br/>│   ├── bar.dat<br/>│   └── foo.png<br/>├── entry_point.py<br/>└── setup.py</span></pre><p id="8381" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ki">捆绑资源</em> </strong></p><p id="5425" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">运行<code class="eh ms mt mu mv b">pyi-makespec entry_point.py -n foobar --onefile</code>。<code class="eh ms mt mu mv b">pyi-makespec</code>脚本接受与<code class="eh ms mt mu mv b">pyinstaller</code>相同的参数，但是它没有实际运行PyInstaller，而是创建了一个<code class="eh ms mt mu mv b">foobar.spec</code>规格文件供您定制，然后可以用<code class="eh ms mt mu mv b">pyinstaller foobar.spec</code>调用。</p><p id="77eb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您的<code class="eh ms mt mu mv b">foobar.spec</code>文件应该是这样的——</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><p id="c77d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">spec文件只是一个python脚本，尽管上面显示了一些特殊的调用。要添加资源，您只需创建一个数组，其中包含元组列表——</p><ul class=""><li id="8735" class="nk nl hu ji b jj jk jn jo jr nm jv nn jz no kd np nq nr ns dt translated">第一个字符串指定当前系统中的一个或多个文件。</li><li id="29ee" class="nk nl hu ji b jj nt jn nu jr nv jv nw jz nx kd np nq nr ns dt translated">第二个指定运行时包含文件的<em class="ki">文件夹</em>的名称。</li></ul><p id="cbe6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一个简单的脚本可以做到这一点</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><p id="abbd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您将把上面的代码添加到规范文件中，它现在看起来应该是这样的—</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><p id="63bd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ki">注意</em> <code class="eh ms mt mu mv b"><em class="ki">a.datas</em></code> <em class="ki">中对</em> <code class="eh ms mt mu mv b"><em class="ki">get_resources()</em></code> <em class="ki">的调用。</em></p><p id="ea38" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ki">访问捆绑资源</em> </strong></p><p id="a4c7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">引用自<a class="ae ke" href="http://pyinstaller.readthedocs.io/en/stable/runtime-information.html" rel="noopener ugc nofollow" target="_blank"> PyInstaller wiki </a> —</p><blockquote class="kf kg kh"><p id="a1d9" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">您可能需要在运行时了解应用程序是从源代码运行，还是被“冻结”(捆绑)。例如，您可能有通常基于模块的<code class="eh ms mt mu mv b">__file__</code>属性找到的数据文件。当代码被捆绑时，这是行不通的。</p><p id="66e8" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">PyInstaller引导加载程序将名称<code class="eh ms mt mu mv b">frozen</code>添加到<code class="eh ms mt mu mv b">sys</code>模块中。所以测试“我们被捆绑了吗？”</p></blockquote><p id="6618" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">总之，这是你需要做的，以访问你捆绑的任何资源—</p><p id="dc54" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">将以下两个变量添加到您的实用程序部分—</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><p id="2803" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后，您可以在您的<code class="eh ms mt mu mv b">entry_point.py</code>中使用它，如下所示—</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><p id="ef2a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您现在可以在<code class="eh ms mt mu mv b">main.py</code>中加载您的资源，如下所示——</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><h2 id="1a6c" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">捆绑二进制文件</h2><p id="3c10" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">PyInstaller应该通过检查python模块自动捆绑任何<code class="eh ms mt mu mv b">.so</code>或<code class="eh ms mt mu mv b">.dll</code>文件。但是如果<a class="ae ke" href="http://pyinstaller.readthedocs.io/en/stable/spec-files.html#adding-binary-files" rel="noopener ugc nofollow" target="_blank">做不到，那么</a>很容易添加它们。</p><p id="eb32" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">捆绑应用程序依赖的二进制文件或库与捆绑数据文件的方式非常相似。</p><p id="dd7b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">假设以下目录结构—</p><pre class="mw mx my mz fq na mv nb nc aw nd dt"><span id="f928" class="km kn hu mv b fv ne nf l ng nh">package_dir<br/>├── bin<br/>│   ├── bar.so<br/>│   ├── bar.dll<br/>│   └── bar.dylib<br/>├── package<br/>│   ├── submodule_bar<br/>│   ├── submodule_foo<br/>│   ├── __init__.py<br/>│   └── main.py<br/>├── resources<br/>│   ├── bar.dat<br/>│   └── foo.png<br/>├── entry_point.py<br/>└── setup.py</span></pre><p id="0320" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">假设你的应用程序依赖于一个共享库<code class="eh ms mt mu mv b">bar</code>，你有适用于所有3个操作系统的二进制文件。</p><p id="c434" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可能会把它们包括在内，如下所示</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><p id="2e66" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可能会问，引用PyInstaller Wiki的话，将文件添加为数据文件或二进制文件有什么区别</p><blockquote class="kf kg kh"><p id="b979" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">二进制文件指的是dll、动态库、共享目标文件等，PyInstaller将在其中搜索进一步的二进制依赖项。图像和pdf等文件应放入<code class="eh ms mt mu mv b">datas</code></p></blockquote><p id="9391" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，请确保添加任何dll或So文件作为二进制文件，而不是数据文件。</p><h2 id="e0ad" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">冻结图形用户界面应用程序</h2><p id="2562" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">你可能想要将<code class="eh ms mt mu mv b">--windowed</code>标志传递给<code class="eh ms mt mu mv b">pyinstaller</code>，以确保在打开应用程序时没有控制台。</p><h2 id="2ce6" class="km kn hu bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">冻结macOS应用程序</h2><p id="d20d" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">如果你正在冻结一个单文件窗口的macOS应用程序，你会想要添加一个额外的调用到你的规范文件中，就像这样</p><figure class="mw mx my mz fq iv"><div class="bz el l di"><div class="ni nj l"/></div></figure><p id="7d59" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有关这些选项的更多信息，请参见<a class="ae ke" href="http://pyinstaller.readthedocs.io/en/stable/spec-files.html#spec-file-options-for-a-mac-os-x-bundle" rel="noopener ugc nofollow" target="_blank"> PyInstaller-Wiki </a>。</p><blockquote class="kf kg kh"><p id="2e10" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">注意:对于简单的情况，您也可以通过传递给<code class="eh ms mt mu mv b">pyisntaller</code>或<code class="eh ms mt mu mv b">pyi-makespec</code>脚本的标志来完成上述所有任务。更多信息见<a class="ae ke" href="http://pyinstaller.readthedocs.io/en/stable/spec-files.html" rel="noopener ugc nofollow" target="_blank">使用规格文件</a>。</p></blockquote><h1 id="940d" class="mb kn hu bd ko mc ny me ks mf nz mh kw mi oa mk kz ml ob mn lc mo oc mq lf mr dt translated">下一步是什么？</h1><p id="d171" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">以上食谱对于所有的一般用例应该是绰绰有余的。我希望以上提供了如何使用PyInstaller的基本指南。对于更高级的用例，您可以仔细阅读<a class="ae ke" href="http://pyinstaller.readthedocs.io/en/stable/spec-files.html#" rel="noopener ugc nofollow" target="_blank"> PyInstaller Wiki。</a></p><p id="6722" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你想看到上面的指南在起作用，你可以看看<a class="ae ke" href="https://github.com/metabrainz/picard" rel="noopener ugc nofollow" target="_blank"> Picard github回购</a>。</p><p id="810e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本博客的下一部分，我们将学习如何使用AppVeyor和TravisCI以及PyInstaller来捆绑我们的应用程序。</p><h1 id="f18f" class="mb kn hu bd ko mc ny me ks mf nz mh kw mi oa mk kz ml ob mn lc mo oc mq lf mr dt translated">哈利普，我卡住了！</h1><p id="cd88" class="pw-post-body-paragraph jg jh hu ji b jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd hn dt translated">如果你发现自己无法理解指南的任何部分，或者有一个非常特殊的用例，请在下面留下评论，如果可以的话，我很乐意帮助你:)</p></div></div>    
</body>
</html>