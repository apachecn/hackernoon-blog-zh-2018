<html>
<head>
<title>A Closer Look At Ethereum Signatures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">近距离观察以太坊签名</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-closer-look-at-ethereum-signatures-5784c14abecc?source=collection_archive---------2-----------------------#2018-02-16">https://medium.com/hackernoon/a-closer-look-at-ethereum-signatures-5784c14abecc?source=collection_archive---------2-----------------------#2018-02-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ac8626e9130657714e8f146bada0e849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CYWej-AlPEwXk6HL."/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/@ssdriscoll?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Steve driscoll</a> on <a class="ae ih" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="5e57" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">非对称加密是上个世纪最重要的计算机科学发明之一。它也是区块链所有技术的核心。在本帖中，我们将深入了解以太坊如何使用<a class="ae ih" href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography" rel="noopener ugc nofollow" target="_blank">椭圆曲线数字签名算法(ECDSA) </a>来验证消息的来源和完整性。</p><p id="e035" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">ECDSA等加密技术对于安全扩展现有的区块链也是必不可少的。我们已经在<a class="ae ih" href="https://hackernoon.com/understanding-decentralized-exchanges-51b70ed3fe67" rel="noopener ugc nofollow" target="_blank">我过去分析分散式交流的帖子</a>中看到了这一点，其中DEX在它的链外通信中使用签名。随着区块链生态系统的成熟，我预计我们将会看到现有低级区块链基础设施的更多第2层和第3层扩展。</p><h2 id="f62e" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><strong class="ak">私钥和公钥</strong></h2><p id="a5de" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">像任何其他区块链系统一样，以太坊有一个私钥和一个公钥。这些密钥是在您创建新的区块链“帐户”时生成的。保持私钥的安全是非常重要的，因为它的任何副本都允许访问分类帐。安全存储私钥的硬件钱包已经成为一种基本的最佳实践。</p><p id="8b90" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">账户的概念有点用词不当，因为在严格的技术术语中，只有密钥和与这些密钥对应的资金分类账。以太坊或<a class="ae ih" href="https://hackernoon.com/tagged/bitcoin" rel="noopener ugc nofollow" target="_blank">比特币</a>地址本质上是公钥的散列版本。</p><h2 id="5605" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><strong class="ak"> ECDSA </strong></h2><p id="7314" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">椭圆曲线加密(ECC)和ECDSA是非对称加密的一种特殊形式。它们在区块链技术中被广泛使用有三个原因:</p><ul class=""><li id="1b88" class="lf lg ik jj b jk jl jo jp js lh jw li ka lj ke lk ll lm ln dt translated">与许多其他算法相比，它们的计算性能是经济的</li><li id="a5e0" class="lf lg ik jj b jk lo jo lp js lq jw lr ka ls ke lk ll lm ln dt translated">生成的密钥相对较短</li><li id="dfaa" class="lf lg ik jj b jk lo jo lp js lq jw lr ka ls ke lk ll lm ln dt translated">比特币开创了它，所以大多数新的区块链项目都复制了它</li></ul><p id="9e2a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">ECDSA使用有限域上椭圆曲线的代数结构。在不涉及数学的情况下，他们需要一组常数来定义这条曲线。大多数区块链使用的常数在<a class="ae ih" href="http://www.secg.org/sec2-v2.pdf" rel="noopener ugc nofollow" target="_blank"> secp256k1标准</a>中设定。</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/ef1f663e1c0ca25c727af5c971984a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*O8g1ldH8j2gUm1TfQdY31w.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Example shape of an Elliptic Curve</figcaption></figure><p id="b973" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在区块链之前，这种椭圆曲线标准并不普遍。其实大部分<a class="ae ih" href="http://blog.enuma.io/update/2016/11/01/a-tale-of-two-curves-hardware-signing-for-ethereum.html" rel="noopener ugc nofollow" target="_blank">主流硬件厂商都不支持这个曲线</a>的硬件加密。据传，选择secp256k1是因为它最不可能被美国国家安全局植入<a class="ae ih" href="https://www.wired.com/2013/09/nsa-backdoor/" rel="noopener ugc nofollow" target="_blank">盗窃后门。</a></p><h2 id="81a4" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><strong class="ak">如何签约</strong></h2><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ly"><img src="../Images/01ff3876c87d8687deef71dc7edc4ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tj7YkvKNweRXILRsSD8eA.png"/></div></div></figure><p id="9df7" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在区块链系统中，任何密钥持有者都可以用他们的私钥对一段数据进行签名。这导致了签名。获得签名的任何人都可以使用它来:</p><ol class=""><li id="fc6c" class="lf lg ik jj b jk jl jo jp js lh jw li ka lj ke lz ll lm ln dt translated">恢复作者的公钥(帐户地址)</li><li id="4066" class="lf lg ik jj b jk lo jo lp js lq jw lr ka ls ke lz ll lm ln dt translated">验证消息是否与作者签名的消息相同</li></ol><p id="3758" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们来看看以太坊中用于签名的确切函数:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="bca0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第一行创建我们想要签名的消息的SHA3散列。这将产生以下32字节(256位)的哈希:</p><p id="be1b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mc">0x 592 fa 743889 fc 7 f 92 AC 3a 37 bb 1 f 5 ba 1 daf 2 a 5 c 84741 ca 0 e 0061d 243 a2 e 6707 ba</em></p><p id="31e4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，第2行使用以太坊的JSON RPC告诉以太坊钱包(它控制私钥)在给定的帐户上签署消息，产生一个签名。最后一行是对JSON RPC输出进行解码，这样我们就可以获得签名值V、R和s(V是为了应对某种攻击<a class="ae ih" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md" rel="noopener ugc nofollow" target="_blank">而添加的)。</a></p><p id="a96f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">智能合约和以太坊客户端都能够验证ECDSA签名。智能合同中的ECDSA验证允许区块链之外的防篡改通信。有许多项目，例如$ZRX，依赖于此进行链外通信。</p><p id="9f4d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<a class="ae ih" href="http://solidity.readthedocs.io" rel="noopener ugc nofollow" target="_blank">可靠性</a>中，可以使用以下代码验证签名的消息:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="d1cf" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该代码将返回用于签署消息的以太坊地址(公钥)。对消息哈希或签名的任何更改都会导致与源地址不同的地址。</p><p id="b4e7" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有时看一下这些函数的内部是很好的，这样我们可以更深入地理解。以下两个部分遵循流行的Meta Mask钱包中使用的代码和Go-Ethereum智能合约代码的内部内容。</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h2 id="eb4b" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><strong class="ak">附录A:元掩码内的签名代码</strong></h2><p id="5a4c" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><a class="ae ih" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Meta Mask </a>是一个Chrome扩展，创建了一个用户友好的交易体验。用户可以发送/接收以太网，签署信息，并与智能合同互动。它还配备了一个可怕的3D多边形狐狸，随着你的光标输入。</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/52c119780d268a53d926eab6c5ba2403.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*qyTmXrNHqLCwzLmG3zPvNw.png"/></div></figure><p id="bd6b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">元掩码中的私钥存储在浏览器的本地存储中。Meta Mask使用一个<a class="ae ih" href="https://github.com/danfinlay/browser-passworder" rel="noopener ugc nofollow" target="_blank">外部库用密码加密私有密钥信息</a>。(使用AES-GCM)。</p><p id="8063" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们使用元掩码对消息进行签名时，会弹出一个窗口，显示要签名的消息和帐户:</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/9837f8e671534d7d8047ad45b0efa426.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ppoKzV57KFzkSsN6hb-tKw.png"/></div></figure><p id="82ae" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们检查底层代码时，我们会通过以下库——其中大部分由元掩码开发人员控制。</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/e895ee2672f9465dda8b8473857f3847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rexYiPmSDv2DNqUeUQRBHg.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Some of the NPM packages used in signing a message</figcaption></figure><p id="494b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">欢迎来到现代Javascript的奇妙世界！</p><p id="a599" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">与签名最相关的以太坊JS代码如下:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="67cb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有很多数据结构转换正在进行，但在最后的函数中我们可以看到R，S，V签名是如何通过调用<em class="mc"> secp256k1.sign() </em>函数获得的。这就引出了下面这段<a class="ae ih" href="https://github.com/indutny/elliptic" rel="noopener ugc nofollow" target="_blank">椭圆库</a>中的基本代码:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h2 id="4763" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><strong class="ak">附录B:智能合约/ Go-Ethereum内的签名代码</strong></h2><p id="4ff6" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">让我们仔细看看前面提到的从签名中恢复公钥的契约代码:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="c76a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Solidity提供的<em class="mc"> ecrecover() </em>函数其实有点特别。这是智能合约中为数不多的“原生合约”之一。这些是可以调用的内部代码智能协定。下面是在<a class="ae ih" href="http://solidity.readthedocs.io/en/develop/assembly.html" rel="noopener ugc nofollow" target="_blank"> Solidity EVM汇编器</a>中调用<em class="mc"> ecrecover() </em>的另一种方法:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="8c36" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mc"> call() </em>函数在固定地址<em class="mc"> 3000 </em>执行契约。然后，它执行以下代码(在go-ethereum实现的情况下):</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="cc1d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这最终调用下面的C代码来恢复公钥(使用<em class="mc"> pubkey </em>指针):</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ma mb l"/></div></figure><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="mn mb l"/></div></figure></div></div>    
</body>
</html>