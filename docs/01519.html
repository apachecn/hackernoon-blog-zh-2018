<html>
<head>
<title>How to Debug Any Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何调试任何问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-debug-any-problem-ac6f8a867fae?source=collection_archive---------1-----------------------#2018-02-17">https://medium.com/hackernoon/how-to-debug-any-problem-ac6f8a867fae?source=collection_archive---------1-----------------------#2018-02-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9dc0284e57752d43fd1cf2e39d6eb40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oR8VXKjnEoPasREjfo0sRQ.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek"><a class="ae ih" href="https://www.pexels.com/photo/nature-red-dew-color-33544/" rel="noopener ugc nofollow" target="_blank">pexels</a></figcaption></figure><div class=""/><p id="ba64" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">快速有效地发现和解决新的和已建立的系统中的错误的能力是你可以培养的最有价值的<a class="ae ih" href="https://hackernoon.com/tagged/engineering" rel="noopener ugc nofollow" target="_blank">工程</a>技能之一。由于这项技能能够快速开发和维护高质量的工程系统，因此它是许多技术公司的基础，也是他们最看重和最受欢迎的技能之一。然而，这种技能很少在<a class="ae ih" href="https://hackernoon.com/tagged/coding" rel="noopener ugc nofollow" target="_blank">编码</a>面试中被评估，并且经常很少被理解和记录。</p><p id="ac0f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在许多不同类型的系统中调试并解决了许多困难的问题，包括大规模复杂的计算机处理器、多线程服务器和应用程序，以及陷入困境的个人、家庭和组织。在所有领域中，查找和修复bug的最佳过程本质上是相同的。令人惊讶的是，许多软件工程师对过程没有清晰的理解。我打算现在就解决这个赤字问题。这是我关于调试的论文。</p><h1 id="3af9" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第一步:确定什么在起作用</h1><p id="3359" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">当某样东西没有按预期工作时，很容易认为一切都坏了。花时间去寻找在问题领域中起作用的东西。这将有助于限定问题的范围，并在你的脑海中创建一个清晰的边缘画面。</p><h1 id="8fff" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤2:精确地确定什么不起作用</h1><p id="a54c" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在确定什么可行的过程中，您将对一组不可行的操作或行为进行分类。花时间充实这份清单。清楚地知道系统是如何不按预期运行的。尽管这些最初的步骤看起来毫无意义，因为问题是“显而易见的”，但经常过早地解决问题会导致浪费时间和精力，并导致部分或非最佳的解决方案。</p><h1 id="380d" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第三步:简化问题</h1><p id="8883" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在复杂情况下发现的问题行为可能很难重现或归纳，尤其是当存在不确定性或统计效应时。任何试图在保留有问题的行为的同时简化测试用例的尝试都是值得花时间的。</p><p id="734a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，如果有问题的行为发生在处理非常大的数据集时，您可能希望用越来越小的数据集来重现该问题。当然，如果问题与大型数据集有关，这个例子就不可能了。在这种情况下，创建一个简单但仍然很大的数据集可能更有意义。</p><p id="8338" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过逐步减少出现问题的情况，你不仅能更清楚地知道什么有效，什么无效，而且你还能自然地开始构建可能导致问题的假设。</p><p id="3d0d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">简单的测试用例有助于与他人精确地交流bug，快速测试变更是否影响bug，并且也可能成为您的抗回归测试的一部分(参见步骤7)。由于简单的测试用例通常可以快速运行，它们也支持假设测试(参见步骤5)。</p><h1 id="b063" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第四步:提出假设</h1><p id="5e6f" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">你可能会在几分钟、几小时、几天甚至几周的工作后到达这一点。无论您是如何到达这里的，或者花了多长时间，您现在都将拥有数据，并且您将了解到一些关于问题显现方式的信息。这种知识使你能够对可能导致问题的原因形成假设。这些理论是关于系统内部(甚至外部)的什么过程可能导致观察到的问题行为。</p><h1 id="0e03" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤5:使用分而治之的方法测试假设</h1><p id="be2f" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">依次考虑每个假设，深入系统，找到你认为可能出错的子单元。然后运行您的小测试用例，并查看该子单元前后的内部行为。如果你在这个子单元之前发现了一个问题，那么你的假设可能是错误的，你至少知道你需要进一步调查系统的输入。另一方面，如果系统那部分的输入看起来是正确的，但输出看起来是不正确的，那么你的假设就有了支持，你就可以更进一步放大。</p><p id="b5f2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这一点上，如果您不完全清楚bug是什么，那么在这个被识别的子单元上循环回到步骤1。</p><p id="0100" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这一点上，可以非常天真地应用分而治之:将系统任意分成两半，在每一半中寻找问题，然后递归地放大非功能性的那一半。我不推荐这种方法，因为它通常非常慢而且麻烦。</p><p id="9012" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一方面，如上所述，使用<em class="li">假设驱动的</em>分治法可以节省大量时间和精力。就在假设被破坏的子单元之前，您仍然检查行为是否如预期的那样，但是，如果那里的事情是正常的，您就直接进入该子单元的输出。这使得可以非常快速地放大bug。</p><p id="3d29" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只有当你清楚错误是什么的时候，才能进行下一步。</p><h1 id="2d91" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第六步:想想这类bug的其他版本</h1><p id="626b" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">有时错误是由简单的打字错误或一次性的误解引起的，这些类型的错误可以被孤立地修复。然而，更常见的是，bug代表了一个更大的问题类别。</p><p id="6a17" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在花费时间和精力完成这一步之后，你通常会对系统和问题的相关部分有一个非常清晰的认识。你将成为这个bug的世界级专家。因此，现在是利用所有这些知识的时候了。一个月后，你将不再对这个特定的问题有清晰的认识。</p><p id="e1af" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，现在就花时间充分利用你的投资。思考并记录bug的总体类别，并确定系统是否可能表现出潜在问题的其他表现形式，无论这些特定的表现形式是否已经向用户表现出来。</p><p id="c8ec" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们不想在恶性肿瘤上贴个创可贴，把病人送回家。</p><h1 id="0d68" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤7:生成抗回归测试</h1><p id="7fcd" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">即使你不使用测试驱动开发来设计系统，我也推荐你使用测试驱动的bug修复。</p><p id="bcf0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">确保编写尽可能多地测试bug类的单元级和/或系统级测试。确保您预期会失败的测试确实失败了。这个bug存在的主要原因是没有测试来捕捉它。这意味着测试套件中有一个漏洞。我经常说，如果一个东西没有经过测试，那么它就是坏的。这是因为你必须假设它要么现在坏了，要么在未来的某个时刻会坏，然后第一个发现它坏了的人会是客户。</p><p id="72a9" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既然你现在有一个破碎的系统，现在是一个开发测试并确保它们失败的绝佳机会。这些机会不会经常出现，所以在它们可用的时候抓住它们。</p><p id="64b3" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我喜欢称回归测试为<em class="li">反</em>-回归测试，因为它们防止产品回归到更早的、崩溃的状态。在发布产品的新版本之前，运行测试套件中的所有测试。</p><h1 id="d602" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤8:修复错误</h1><p id="2782" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果你一直很勤奋，修正这些错误现在会变得非常容易；这只是一种形式。</p><p id="728c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种错误修复可以非常平静和自信地进行。修复被包装在一个高质量的软件工程过程中，一个通知和测试它的过程。相比之下，我曾目睹工程师们在天平的另一端工作，他们几乎是随机地修改代码，希望这样就能解决整个问题。这种方法更有可能引入新的错误，而不是修复现有的错误。</p><p id="307e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在修复错误时，您可能会注意到其他问题。在这种情况下，还要返回到前面的步骤，如步骤6。</p><h1 id="bd78" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤9:检查测试现在是否工作</h1><p id="cf55" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">所有新的测试现在都应该通过了。如果它们没有通过，那么您需要返回到前面的步骤并解决问题。</p><h1 id="f1cd" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤10:检查原始的简单案例</h1><p id="c9a1" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">此时，应该可以运行您在步骤3中开发的简单测试用例，并且它们应该可以正常工作。如果没有，则返回到前面的步骤来解决问题。</p><h1 id="daf1" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第11步:检查原始问题</h1><p id="a428" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">您现在应该能够执行最初报告为有问题的行为，并且应该不会再看到问题。如果您确实看到了问题，请返回到之前的步骤来解决它。</p><h1 id="646d" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤12:记录修复</h1><p id="3f10" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">你刚刚完成了一系列高质量的工程演习。这是传奇的素材。很可能你是唯一知道你的英雄行为的人。把它们写下来，这样它们就可以成为工程知识的一部分。记录代码，记录测试计划，记录测试套件，写一个wiki页面或者一篇博客文章。做一些事情来捕捉你已经开发的智慧，并让它为他人所用。你的文档也将教育和指导他人。你将为其他工程师树立一个好榜样，一个如何有效利用资源的榜样，也是如何以一种令人深感满足和滋养灵魂的方式执行具有挑战性的工程工作的榜样。</p><h1 id="ec47" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">步骤13:注意任何其他可能的错误类别</h1><p id="525c" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在您将注意力集中在解决这个特定问题的过程中，您可能已经注意到了其他潜在的bug类别，以及其他明显的bug类别。对于表现为功能失调行为的问题，或者您确定潜伏未被检测到的问题，提交错误报告。对于其他可能不存在但也可能目前没有测试的错误类别，采取任何必要的措施将测试工作引向它们。例如，您可能会更新一个测试计划想法文档。</p><h1 id="2279" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第十四步:释放</h1><p id="f414" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">发布你的补丁，无论是内部的还是外部的，确保每个人都知道你做了什么。简明扼要地总结问题和解决方案，并包含指向您创建的文档的链接。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lj"><img src="../Images/7f539c085cc8844d84609f3326ae8729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zr0dAx65hHcfirrmq5zEDg.png"/></div></div></figure><h1 id="cee2" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="a607" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">你刚刚完成了一些了不起的高质量工程。拍拍自己的背，去做一些其他出色的事情。</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lo lp l"/></div></figure></div></div>    
</body>
</html>