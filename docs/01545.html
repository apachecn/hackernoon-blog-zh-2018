<html>
<head>
<title>How to Build Twitter’s Real-time Likes Feature with Node.js and Pusher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js和Pusher构建Twitter的实时赞功能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-build-twitters-real-time-likes-feature-with-node-js-and-pusher-fd8f97bee7cb?source=collection_archive---------8-----------------------#2018-02-18">https://medium.com/hackernoon/how-to-build-twitters-real-time-likes-feature-with-node-js-and-pusher-fd8f97bee7cb?source=collection_archive---------8-----------------------#2018-02-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d7d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你使用Twitter，你可能已经注意到一个已经存在一段时间的漂亮的小功能:实时推文统计。这基本上意味着，随着世界各地的人喜欢或转发一条推文，你可以看到该推文的喜欢或转发数量增加(或减少)，而不必刷新页面。酷吧。</p><p id="d7b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我将带您在一个简单的Node.js应用程序中实现您自己的实时帖子统计(我们将仅限于赞)。下面是该应用的运行演示(请原谅我平淡无奇的用户界面):</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/1e5c336d7978623437db2159b8bbcbab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Qp-TgomZNoFB_SPbpizRYw.gif"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Liking a post in one window immediately reflects in the other</figcaption></figure><h2 id="c517" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">设置项目</h2><p id="abad" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">本教程假设您已经安装了Node.js(版本6或更高)和MongoDB(版本3.2或更高)。我们将使用Express，一个流行的轻量级Node.js框架。让我们使用<a class="ae lf" href="https://expressjs.com/en/starter/generator.html" rel="noopener ugc nofollow" target="_blank">快速应用生成器</a>快速设置我们的应用:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="a4ad" class="kf kg hu lh b fv ll lm l ln lo"># if you don't already have it installed<br/>npm install express-generator -g</span><span id="f822" class="kf kg hu lh b fv lp lm l ln lo"># create a new express app with view engine set to Handlebars (hbs)<br/>express --view=hbs poster<br/>cd poster &amp;&amp; npm install</span></pre><p id="0d48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将添加我们需要的依赖项:</p><p id="b56d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lq lr ls lh b">npm install --save dotenv faker mongoose pusher</code></p><p id="82e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是每个模块的用途。</p><ul class=""><li id="79a6" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">我们使用MongoDB作为我们的数据存储，所以我们将使用<strong class="it hv">mongose</strong>将我们的MongoDB文档映射到模型(JavaScript对象)。</li><li id="f39a" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><strong class="it hv"> Faker </strong>将帮助我们为我们的应用程序生成虚假数据，因为我们只想展示喜欢功能。</li><li id="76fe" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">我们需要<strong class="it hv">推送器</strong>与推送器的API对话。</li><li id="b242" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">最后，<strong class="it hv"> dotenv </strong>是一个小软件包，它帮助我们从一个<code class="eh lq lr ls lh b">.env</code>文件中加载我们的私有配置变量(比如我们的Pusher应用凭证)。</li></ul><h2 id="ba1d" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">基本数据和视图</h2><p id="17ec" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">首先，让我们定义我们的数据结构。我们将把这个演示的范围限制在两个实体上:<strong class="it hv">用户</strong>和<strong class="it hv">帖子</strong>。对于用户来说。我们将只存储他们的名字。对于帖子，我们将存储:</p><ul class=""><li id="9bee" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">正文</li><li id="78d9" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">张贴的日期</li><li id="38b9" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">发布它的用户(作者)，以及</li><li id="3cf1" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">它获得的赞数</li></ul><p id="d0f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们需要的关于用户的唯一细节是他们的名字，所以我们不会建立一个用户模型；我们将直接从我们的Post模型中引用用户名。所以，让我们创建一个文件，<code class="eh lq lr ls lh b">models/post.js</code>:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="6aae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们将编写一个小脚本来将一些假数据放入我们的数据库。在<code class="eh lq lr ls lh b">bin</code>目录下创建一个名为<code class="eh lq lr ls lh b">seed.js</code>的文件，内容如下:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="aeed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用node运行种子(记住首先通过运行<code class="eh lq lr ls lh b">sudo mongod</code>来启动MongoDB服务器):</p><p id="6946" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lq lr ls lh b">node bin/seed.js</code></p><p id="6561" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们为我们的主页设置路线和视图。</p><p id="ee48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们要做的第一件事是添加我们的MongoDB连接设置，这样当我们的应用程序启动时就创建了连接。在靠近<code class="eh lq lr ls lh b">app.js</code>顶部的地方添加这一行:</p><p id="ff87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lq lr ls lh b">require('mongoose').connect('mongodb://localhost/poster');</code></p><p id="69ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们从数据库中检索所有帖子并将它们传递给视图。将<code class="eh lq lr ls lh b">routes/index.js</code>中的代码替换为:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="3a4b" class="kf kg hu lh b fv ll lm l ln lo">let router = require('express').Router();<br/>let Post = require('./../models/post');</span><span id="fea4" class="kf kg hu lh b fv lp lm l ln lo">router.get('/', (<em class="mj">req</em>, <em class="mj">res</em>, <em class="mj">next</em>) =&gt; {<br/>  Post.find().exec((<em class="mj">err</em>, <em class="mj">posts</em>) =&gt; {<br/>    <em class="mj">res</em>.render('index', { posts: <em class="mj">posts </em>});<br/>  });<br/>});</span><span id="627e" class="kf kg hu lh b fv lp lm l ln lo">module.exports = router;</span></pre><p id="e21c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们渲染帖子的视图(<code class="eh lq lr ls lh b">views/index.hbs</code>)。我们将使用Bootstrap进行一些快速的造型。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="601b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些注意事项:</p><ul class=""><li id="9248" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">我们将一个<strong class="it hv"> data-post-id </strong>属性<strong class="it hv"> </strong>附加到每个Like按钮上，这样我们可以很容易地识别它指向哪个帖子。这很快就会有用的。</li><li id="7367" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">我们给每个<code class="eh lq lr ls lh b">likes_count</code>字段一个包含文章ID的<code class="eh lq lr ls lh b">id</code>，所以我们可以直接引用只有文章ID的正确的<code class="eh lq lr ls lh b">likes_count</code>。</li><li id="6c1d" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">我们在Like按钮上有一个点击处理程序(<code class="eh lq lr ls lh b"><strong class="it hv">actOnPost</strong></code>)。我们将在这里切换按钮文本(喜欢→不喜欢)并增加<code class="eh lq lr ls lh b">likes_count</code>。(如果是“不像”按钮，则相反)。我们一会儿会实现它。</li></ul><h2 id="87a4" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">喜欢和不喜欢逻辑</h2><p id="795e" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">当用户点击“喜欢”时，我们希望发生以下情况:</p><ol class=""><li id="6670" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo mk lz ma mb dt translated">按钮上的文本从“喜欢”变为“不喜欢”。</li><li id="ee39" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mk lz ma mb dt translated">帖子旁边显示的赞数会增加1。</li><li id="e933" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mk lz ma mb dt translated">向服务器发出一个AJAX请求，将数据库中的<code class="eh lq lr ls lh b">likes_count</code>加1。</li><li id="0f98" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mk lz ma mb dt translated">在页面打开的所有其他标签页/窗口中，帖子旁边显示的赞数增加1。(这就是Pusher的用武之地。)</li></ol><p id="8723" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于不喜欢:</p><ol class=""><li id="5742" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo mk lz ma mb dt translated">按钮上的文字从“不像”变成“像”。</li><li id="a53f" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mk lz ma mb dt translated">帖子旁边显示的赞数会减少1。</li><li id="00d1" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mk lz ma mb dt translated">向服务器发出一个AJAX请求，将数据库中的<code class="eh lq lr ls lh b">likes_count</code>减1。</li><li id="d377" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mk lz ma mb dt translated">在页面打开的所有其他标签页/窗口中，帖子旁边显示的赞数会减少1。(再次通过Pusher。)</li></ol><p id="df11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将喜欢和不喜欢都归类为可以在帖子上执行的<strong class="it hv">操作</strong>，这样我们就可以一起处理它们。</p><p id="4a4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们为<code class="eh lq lr ls lh b">actOnPost</code>方法添加一些JavaScript到我们的主页。我们将引入<a class="ae lf" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>来实现简单的HTTP请求。将以下内容添加到您的<code class="eh lq lr ls lh b">views/index.hbs</code>中:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="4112" class="kf kg hu lh b fv ll lm l ln lo">&lt;<strong class="lh hv">script </strong>src=<strong class="lh hv">"https://unpkg.com/axios/dist/axios.min.js"</strong>&gt;&lt;/<strong class="lh hv">script</strong>&gt;</span><span id="6e73" class="kf kg hu lh b fv lp lm l ln lo">&lt;<strong class="lh hv">script</strong>&gt;<br/>  var <em class="mj">updatePostStats </em>= {<br/>    Like: function (<em class="mj">postId</em>) {<br/>      document.querySelector('#likes-count-' + <em class="mj">postId</em>).textContent++;<br/>    },<br/>    Unlike: function(<em class="mj">postId</em>) {<br/>      document.querySelector('#likes-count-' + <em class="mj">postId</em>).textContent--;<br/>    }<br/>  };</span><span id="028c" class="kf kg hu lh b fv lp lm l ln lo">  var <em class="mj">toggleButtonText </em>= {<br/>    Like: function(<em class="mj">button</em>) {<br/>      <em class="mj">button</em>.textContent = "Unlike";<br/>    },<br/>    Unlike: function(<em class="mj">button</em>) {<br/>      <em class="mj">button</em>.textContent = "Like";<br/>    }<br/>  };</span><span id="e043" class="kf kg hu lh b fv lp lm l ln lo">  var actOnPost = function (<em class="mj">event</em>) {<br/>    var postId = <em class="mj">event</em>.target.dataset.postId;<br/>    var action = <em class="mj">event</em>.target.textContent.trim();<br/>    <em class="mj">toggleButtonText</em>[action](<em class="mj">event</em>.target);<br/>    <em class="mj">updatePostStats</em>[action](postId);<br/>    axios.post('/posts/' + postId + '/act', { action: action });<br/>  };</span><span id="70e7" class="kf kg hu lh b fv lp lm l ln lo">&lt;/<strong class="lh hv">script</strong>&gt;</span></pre><p id="a891" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们在<code class="eh lq lr ls lh b">routes/index.js:</code>中定义<strong class="it hv">行为</strong>路线</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="52e9" class="kf kg hu lh b fv ll lm l ln lo">router.post('/posts/:id/act', (<em class="mj">req</em>, <em class="mj">res</em>, <em class="mj">next</em>) =&gt; {<br/>  const action = <em class="mj">req</em>.body.action;<br/>  const counter = action === 'Like' ? 1 : -1;<br/>  Post.update({_id: <em class="mj">req</em>.params.id}, {$inc: {likes_count: counter}}, {}, (<em class="mj">err</em>, <em class="mj">numberAffected</em>) =&gt; {<br/>    <em class="mj">res</em>.send('');<br/>  });<br/>});</span></pre><p id="0d95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我们使用MongoDB内置的<code class="eh lq lr ls lh b">$inc</code>操作符来更改likes_count的更新操作。</p><h2 id="967e" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">用推送器通知其他客户</h2><p id="2d97" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在这一点上，我们已经有了我们通常喜欢和不喜欢的特征。现在是时候通知其他客户端发生这样的行为了。</p><p id="39ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来设置我们的推动器集成。<a class="ae lf" href="https://pusher.com/signup" rel="noopener ugc nofollow" target="_blank">如果您还没有免费的推销者帐户</a>，请创建一个。然后访问<a class="ae lf" href="http://dashboard.pusher.com" rel="noopener ugc nofollow" target="_blank">您的仪表盘</a>并创建一个新应用程序，记下您的应用程序凭证。因为我们使用dotenv包，所以我们可以将Pusher凭证放在项目根目录下的. env文件中:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="3221" class="kf kg hu lh b fv ll lm l ln lo">PUSHER_APP_ID=WWWWWWWWW<br/>PUSHER_APP_KEY=XXXXXXXXX<br/>PUSHER_APP_SECRET=YYYYYYYY<br/>PUSHER_APP_CLUSTER=ZZZZZZZZ</span></pre><p id="10f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将上面的存根替换为您Pusher仪表盘中的应用凭据。然后将下面一行添加到app.js的顶部:</p><p id="70d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lq lr ls lh b">require('dotenv').config();</code></p><p id="6975" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将修改我们的路由处理程序，以便每当一个动作更新数据库中的<code class="eh lq lr ls lh b">likes_count</code>时触发Pusher消息。我们将初始化Pusher客户端的一个实例，并通过调用<code class="eh lq lr ls lh b">pusher.trigger</code>用它来发送消息。</p><p id="74a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">触发方法有四个参数:</p><ul class=""><li id="2dd8" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">发送此消息的<strong class="it hv">通道</strong>的名称</li><li id="bd86" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><strong class="it hv">消息的名称</strong></li><li id="a3bf" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><strong class="it hv">有效载荷</strong>(您希望随消息发送的任何数据)</li><li id="aee5" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><strong class="it hv">插座ID </strong>。如果提供了该ID，Pusher将向除具有该ID的客户之外的每个客户发送该消息。这很有用，因此我们可以排除导致该操作的客户端，使其不再收到通知。</li></ul><p id="ac7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们希望我们的有效载荷在类似动作的情况下看起来的样子:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="26d1" class="kf kg hu lh b fv ll lm l ln lo">{<br/>  "action": "Like",<br/>  "postId": 1234<br/>}</span></pre><p id="3212" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，让我们将这个逻辑添加到我们的路由处理程序中:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="19d3" class="kf kg hu lh b fv ll lm l ln lo">let Pusher = require('pusher');</span><span id="2250" class="kf kg hu lh b fv lp lm l ln lo">let pusher = new Pusher({<br/>  appId: process.env.PUSHER_APP_ID,<br/>  key: process.env.PUSHER_APP_KEY,<br/>  secret: process.env.PUSHER_APP_SECRET,<br/>  cluster: process.env.PUSHER_APP_CLUSTER<br/>});</span><span id="f875" class="kf kg hu lh b fv lp lm l ln lo">router.post('/posts/:id/act', (<em class="mj">req</em>, <em class="mj">res</em>, <em class="mj">next</em>) =&gt; {<br/>  const action = <em class="mj">req</em>.body.action;<br/>  const counter = action === 'Like' ? 1 : -1;<br/>  Post.update({_id: <em class="mj">req</em>.params.id}, {$inc: {likes_count: counter}}, {}, (<em class="mj">err</em>, <em class="mj">numberAffected</em>) =&gt; {<br/>    pusher.trigger('post-events', 'postAction', { action: action, postId: <em class="mj">req</em>.params.id }, <em class="mj">req</em>.body.socketId);<br/>    <em class="mj">res</em>.send('');<br/>  });<br/>});</span></pre><p id="156d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在客户端(<code class="eh lq lr ls lh b">index.hbs</code>)我们需要处理两件事:</p><ul class=""><li id="71dc" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">为每位客户订阅<code class="eh lq lr ls lh b">post-events</code>频道</li><li id="c5d2" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">。将客户机的套接字ID添加到我们的<code class="eh lq lr ls lh b">act</code> API请求中，这样服务器就可以用它来排除客户机</li></ul><p id="5592" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将引入Pusher SDK:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="5a25" class="kf kg hu lh b fv ll lm l ln lo">&lt;<strong class="lh hv">script </strong>src=<strong class="lh hv">"https://js.pusher.com/4.1/pusher.min.js"</strong>&gt;&lt;/<strong class="lh hv">script</strong>&gt;</span><span id="f584" class="kf kg hu lh b fv lp lm l ln lo">&lt;<strong class="lh hv">script</strong>&gt;<br/>  var <em class="mj">pusher </em>= new Pusher('your-app-id', {<br/>    cluster: 'your-app-cluster'<br/>  });<br/>  var <em class="mj">socketId</em>;<br/> <br/>  // retrieve the socket ID on successful connection<br/>  <em class="mj">pusher</em>.connection.bind('connected', function() {<br/>    <em class="mj">socketId </em>= <em class="mj">pusher</em>.connection.socket_id;<br/>  });</span><span id="8223" class="kf kg hu lh b fv lp lm l ln lo">  var <em class="mj">channel </em>= <em class="mj">pusher</em>.subscribe('post-events');<br/>  <em class="mj">channel</em>.bind('postAction', function(<em class="mj">data</em>) {<br/>    // log message data to console - for debugging purposes<br/>    <em class="mj">console</em>.log(<em class="mj">data</em>);<br/>    var action = <em class="mj">data</em>.action;<br/>    updatePostStats[action](<em class="mj">data</em>.postId);<br/>  });</span><span id="ffc4" class="kf kg hu lh b fv lp lm l ln lo">&lt;/<strong class="lh hv">script</strong>&gt;</span></pre><p id="0ec4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">全部完成！运行以下命令启动您的应用:</p><p id="1432" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lq lr ls lh b">npm start</code></p><p id="a1a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果你在浏览器的两个(或更多)标签中打开<a class="ae lf" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，你应该会看到喜欢一个标签中的帖子会立即反映在另一个标签中。此外，由于我们前面放置了console.log语句，您将看到记录了该事件:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/3e98e714a2d650d2ef059f317105ab60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*nzsRe61eAvu3wG83JSYIQA.png"/></div></figure><h2 id="4196" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">结论</h2><p id="1b1a" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在本文中，我们看到了Pusher的发布-订阅消息传递系统如何简单地实现特定帖子活动的实时视图。当然，这只是一个起点；我期待着看到你建造的所有伟大的东西。你可以在Github 上查看完整应用<a class="ae lf" href="https://github.com/shalvah/poster" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="2473" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mj">本文原载作者于</em> <a class="ae lf" href="https://blog.pusher.com/build-twitters-realtime-likes-feature-node-js-pusher/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">推手的博客</em> </a> <em class="mj">。</em></p></div></div>    
</body>
</html>