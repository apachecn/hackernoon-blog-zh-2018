<html>
<head>
<title>Selectors in Redux are a MUST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux中的选择器是必须的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/selectors-in-redux-are-a-must-d6b0637c79b7?source=collection_archive---------2-----------------------#2018-02-19">https://medium.com/hackernoon/selectors-in-redux-are-a-must-d6b0637c79b7?source=collection_archive---------2-----------------------#2018-02-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5de61e2e9071e5faa1ded69ae8536d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66igYNJcTtoZDXD2h73PCA.png"/></div></div></figure><p id="4c61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近，我对Redux的选择器可以解决多少问题感到震惊。这就是我成为超级粉丝的原因，看到这种模式被视为高级模式，我很难过。它们易于理解，同时，在Redux的状态级别上支持低耦合/高内聚的代码。</p><p id="3fbf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几个月前我开始了解选择者。事实上，我开始为一个项目开发一个疯狂的搜索页面:除了普通的文本查询，用户还可以选择许多过滤器。事实上，过滤器有各种各样的形式:有些是一组复选框，有些是复选框的嵌套树，有些树可以用文本框来过滤。不仅如此，它们使用AND和OR的组合产生非常复杂的查询。不仅如此，它们之间还相互影响。“不仅如此”的清单还要长得多。</p><p id="e55c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开始时，我被所有这些复杂性淹没了。最终，我一步一步走向光明。在这个旅程中，选择者救了我的命，成了我最好的朋友。</p><p id="2784" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来是这个项目中的一个故事，讲述了我是如何认识选择者的，以及他们为什么这么棒。</p><h2 id="b169" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">保持状态平坦</h2><p id="ddeb" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">开始时，我有一个类似这样的商店形状</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="24ed" class="ka kb hu lf b fv lj lk l ll lm">store = {<br/>  filters: {<br/>    locations: []<br/>    ...<br/>  }<br/>}</span></pre><p id="3b8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ln lo lp lf b">locations</code>可能在哪里</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="5648" class="ka kb hu lf b fv lj lk l ll lm">locations = [{<br/>  id: 1<br/>  value: 'Europe'<br/>  checked: false<br/>  children: [{<br/>    id: 2<br/>    value: 'Central Europe'<br/>    checked: false<br/>    children: [{<br/>      id: 3<br/>      value: 'Italy'<br/>      checked: false<br/>    }],<br/>  }]}, ...]</span></pre><p id="aa77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看起来够糟吗？嗯，想象一下进行不可变更新来检查id为<code class="eh ln lo lp lf b">3</code>的节点的痛苦。在普通的JavaScript中，看起来像这样</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="0ca7" class="ka kb hu lf b fv lj lk l ll lm">newLocations = [ <br/>  ...locations.slice(1)<br/>  {<br/>    ...locations[0]<br/>    children: [<br/>      ...locations[0].children.slice(1)<br/>      {<br/>        ...locations[0].children[0]<br/>        children: [<br/>          ...locations[0].children[0].children.slice(1)<br/>          {<br/>            ...locations[0].children[0].children[0]<br/>            checked: true<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>]</span></pre><p id="2a15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，我可以使用像<a class="ae lq" href="https://github.com/debitoor/dot-prop-immutable" rel="noopener ugc nofollow" target="_blank"> dot-prop </a>这样的库，但是那就像是把代码的味道扫到了地毯下面。</p><p id="1ba0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更好的表述可能是</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="ff36" class="ka kb hu lf b fv lj lk l ll lm">locationsById = {<br/>  1: {<br/>    id: 1<br/>    value: 'Europe'<br/>    checked: true<br/>    children: [2, 3]<br/>  }<br/>  2: {<br/>    id: 2<br/>    value: 'Central Europe'<br/>    checked: true<br/>    children: [3]<br/>  },<br/>  3: {  <br/>    id: 3<br/>    value: 'Italy'<br/>    checked: true<br/>}, ...}</span></pre><p id="b32b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还是我最后遇到的那个</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="72a4" class="ka kb hu lf b fv lj lk l ll lm">locationsByPath = {<br/>  '1': {<br/>    id: 1<br/>    value: 'Europe'<br/>    checked: true<br/>  }<br/>  '1/2': {<br/>    id: 2<br/>    value: 'Central Europe'<br/>    checked: true<br/>  }<br/>  '1/2/3': {  <br/>    id: 3<br/>    value: 'Italy'<br/>    checked: true<br/>}, ...}</span></pre><p id="a62b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">路径中编码了树的层次结构(例如<code class="eh ln lo lp lf b">1/2</code>是<code class="eh ln lo lp lf b">1</code>的子节点和<code class="eh ln lo lp lf b">1/2/3</code>的父节点)。</p><p id="8b51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<code class="eh ln lo lp lf b">locationsByPath</code>的更新，看起来更好</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="a0da" class="ka kb hu lf b fv lj lk l ll lm">newLocationsByPath = {<br/>  ...locations<br/>  '1/2/3': {<br/>    ...locationsByPath['1/2/3']<br/>    checked: false<br/>  }<br/>}</span></pre><h2 id="fd2e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">分离关注点</h2><p id="84f7" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">在制作这个功能时，我注意到一些事情:<code class="eh ln lo lp lf b">locationsByPath</code>知道得太多了。事实上，它既有领域知识(即<code class="eh ln lo lp lf b">id</code>、<code class="eh ln lo lp lf b">value</code>和层次)，也有UI数据(即<code class="eh ln lo lp lf b">checked</code>)。</p><p id="8f3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是错误的，因为大多数时候域和UI数据有不同的需求和生命周期。例如，在我的例子中，一旦过滤器被加载到存储中，它们就不会被更新。相反，每当复选框的状态改变时，<code class="eh ln lo lp lf b">checked</code>属性就会被切换。因此，我决定将两者分开:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="c10c" class="ka kb hu lf b fv lj lk l ll lm">locationsByPath = {<br/>  1: {<br/>    id: 1<br/>    value: 'Europe'<br/>  }<br/>  '1/2': {<br/>    id: 2<br/>    value: 'Central Europe'<br/>  }<br/>  '1/2/3': {  <br/>    id: 3<br/>    value: 'Italy'<br/>}, ...}</span><span id="12e7" class="ka kb hu lf b fv lr lk l ll lm">checkedLocationsPaths: ['1', '1/2', '1/2/3']</span></pre><p id="95ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，这使得检查节点变得非常容易</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="08dd" class="ka kb hu lf b fv lj lk l ll lm">checkedLocationsPaths.includes('1/2/3') ?<br/>  checkedLocationsPaths :<br/>  checkedLocationsPaths.concat('1/2/3')</span></pre><p id="b06b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有，<code class="eh ln lo lp lf b">checkedLocationsPaths</code>和<code class="eh ln lo lp lf b">locationsByPath</code>现在是独立的。这意味着，它们可以遵循不同的生命周期。例如，<code class="eh ln lo lp lf b">checkedLocationsPaths</code>可以在加载<code class="eh ln lo lp lf b">locationsByPath</code>之前出现在商店中。</p><p id="3666" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，重构到扁平状态让我的工作变得更容易，但是对于组件却更难。事实上，组件处理初始嵌套形状要容易得多:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="9ef9" class="ka kb hu lf b fv lj lk l ll lm">const Component = ({ value, checked, children }) =&gt;<br/>  &lt;div&gt;<br/>    &lt;input type='checkbox' value={value} checked={checked} /&gt;</span><span id="57da" class="ka kb hu lf b fv lr lk l ll lm">{children.map(({ value, checked, children }) =&gt;<br/>      &lt;Component<br/>        value={value}<br/>        checked={checked}<br/>        children={children}/&gt;<br/>    }<br/>  &lt;/div&gt;</span></pre><p id="96ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我可以给组件添加一些逻辑来处理扁平状态。但这是合适的地方吗？我不这么认为。事实上，这样做意味着将组件与状态的形状相耦合。此外，我相信真正愚蠢的组件。</p><h2 id="e9fd" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">救援选择器</h2><p id="b63c" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">Reducers负责将状态写入特定的形状。因此，最好有一个尽可能靠近他们的东西来处理阅读部分。这就是选择器发挥作用的地方。</p><p id="3779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不想听我的话，听听丹·阿布拉莫夫的。</p><figure class="la lb lc ld fq iv"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="aa4e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，将<code class="eh ln lo lp lf b">initialState</code>、写入面和读取面放在同一个位置是非常正确的:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="a786" class="ka kb hu lf b fv lj lk l ll lm">// reducer.js</span><span id="baba" class="ka kb hu lf b fv lr lk l ll lm">initialState = {<br/>  locationsByPath: {}<br/>  checkedLocationsPaths: []<br/>  ...<br/>}</span><span id="4bdd" class="ka kb hu lf b fv lr lk l ll lm">// write side<br/>const filters = (state = initialState, action) =&gt; {<br/>  if (action.type === 'LOAD_LOCATIONS') {<br/>    return { ...state, locations: action.locations };<br/>  } else if (action.type === 'CHECK_LOCATION') {<br/>    const checkedLocationsPaths =<br/>      state.checkedLocationsPaths.includes('1/2/3') ?<br/>        state.checkedLocationsPaths :<br/>        state.checkedLocationsPaths.concat('1/2/3')<br/>    return { ...state, checkedLocationsPaths }<br/>  }<br/>  ...<br/>}</span><span id="d275" class="ka kb hu lf b fv lr lk l ll lm">// read side</span><span id="faf5" class="ka kb hu lf b fv lr lk l ll lm">// nests locations<br/>const nest = locationsByPath =&gt; ...</span><span id="e8b6" class="ka kb hu lf b fv lr lk l ll lm">// adds `checked: true` where appropriate<br/>const withChecks = (locationsByPath, checks) =&gt; ...</span><span id="c8e8" class="ka kb hu lf b fv lr lk l ll lm">const getNestedLocationsWithChecks = state =&gt; {<br/>  const {<br/>    locationsByPath,<br/>    checkedLocationsPaths,<br/>  } = state;</span><span id="dec6" class="ka kb hu lf b fv lr lk l ll lm">  return nest(<br/>    withChecks(locationsByPath, checkedLocationsPaths)<br/>  );<br/>}</span></pre><p id="cb33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们通过一个例子来看看选择器是如何工作的</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="717c" class="ka kb hu lf b fv lj lk l ll lm">locationsByPath = {<br/>  1: {<br/>    id: 1,<br/>    value: 'Europe',<br/>  }, <br/>  '1/2': {<br/>    id: 2,<br/>    value: 'Central Europe'<br/>  },<br/>  '1/2/3': {  <br/>    id: 3,<br/>    value: 'Italy', <br/>}, ...}</span><span id="ee6b" class="ka kb hu lf b fv lr lk l ll lm">checkedLocationsPaths: ['1', '1/2', '1/2/3']</span><span id="68ec" class="ka kb hu lf b fv lr lk l ll lm">state = {<br/>  locationsByPath,<br/>  checkedLocationsPaths<br/>}</span><span id="0c58" class="ka kb hu lf b fv lr lk l ll lm">nestedLocationsWithChecks(state)<br/>=&gt; [{<br/>  id: 1,<br/>  value: 'Europe',<br/>  checked: true,<br/>  children: [{<br/>    id: 2,<br/>    value: 'Central Europe'<br/>    checked: true,<br/>    children: [{<br/>      id: 3,<br/>      value: 'Italy', <br/>      checked: true,<br/>    }]<br/>  }]},<br/>...]</span></pre><p id="2629" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其中<code class="eh ln lo lp lf b">nestedLocationsWithChecks(state)</code>准备好从先前部分传递到<code class="eh ln lo lp lf b">Component</code>。</p><p id="e36a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">换句话说，一方面，应用程序以平面状态工作。这样更便于数据管理。另一方面，应用程序处理嵌套数据。这对于UI来说更方便。</p><p id="1f2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更重要的是，它们可以独立发展，因为选择器作为一个<a class="ae lq" href="http://www.markhneedham.com/blog/2009/07/07/domain-driven-design-anti-corruption-layer/" rel="noopener ugc nofollow" target="_blank">反腐败层</a>工作，并防止泄漏结构耦合。</p><h2 id="3d44" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">使选择器冒泡</h2><p id="fa10" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">在上一节中，我从上到下，首先重构状态，然后向下重构组件。</p><p id="5fe7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在了解选择器之前，让我们通过重构我写的一些代码来看看相反的情况。</p><p id="cabe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在应用程序中有一个页面，一些文章按类别分组显示(即文章只属于一个类别)。除了最后一个类别(如果为空，则应隐藏)之外，所有类别都必须始终呈现。</p><p id="6e01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ln lo lp lf b">categoriesFrom</code>执行分组并翻译当前区域的标题。<code class="eh ln lo lp lf b">Component</code>分别渲染每个类别。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="f406" class="ka kb hu lf b fv lj lk l ll lm">const categoriesFrom = resources =&gt; {<br/>  const byCategory = [<br/>    { id: 1, name: I18n.t('cat1'), resources: resources.cat1 },<br/>    { id: 2, name: I18n.t('cat2'), resources: resources.cat2 },<br/>    { id: 3, name: I18n.t('cat3'), resources: resources.cat3 },<br/>    { id: 4, name: I18n.t('cat4'), resources: resources.cat4 },<br/>  ];</span><span id="09dc" class="ka kb hu lf b fv lr lk l ll lm">  if (resources.cat5.length !== 0) {<br/>    const name = I18n.t('cat5')<br/>    return byCategory<br/>      .concat({ id: 5, name, resources: resources.cat5 })<br/>  } else {<br/>    return byCategory<br/>  }<br/>}</span><span id="e891" class="ka kb hu lf b fv lr lk l ll lm">const Component = ({ resources }) =&gt;<br/>  categoriesFor(resources).map(category =&gt; <br/>    &lt;Category key={category.id} category={category} /&gt;)<br/>  )</span></pre><p id="b702" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ln lo lp lf b">Component</code>太聪明，耦合到状态形状(如<code class="eh ln lo lp lf b">resources.cat1</code>)。</p><p id="f747" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们把这个逻辑上升到一个选择器:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="3e31" class="ka kb hu lf b fv lj lk l ll lm">// reducer.js</span><span id="9e1b" class="ka kb hu lf b fv lr lk l ll lm">// selector<br/>const getResources = state =&gt; state.resources;</span><span id="41bc" class="ka kb hu lf b fv lr lk l ll lm">// selector<br/>const getResourcesGroupedByCategory = state =&gt; {<br/>  const resources = getResources(state);</span><span id="9e25" class="ka kb hu lf b fv lr lk l ll lm">  const byCategory = [<br/>    { id: 1, name: I18n.t('cat1'), resources: resources.cat1 },<br/>    { id: 2, name: I18n.t('cat2'), resources: resources.cat2 },<br/>    { id: 3, name: I18n.t('cat3'), resources: resources.cat3 },<br/>    { id: 4, name: I18n.t('cat4'), resources: resources.cat4 },<br/>  ];</span><span id="126c" class="ka kb hu lf b fv lr lk l ll lm">  if (resources.cat5.length !== 0) {<br/>    const name = I18n.t('cat5')<br/>    return byCategory<br/>      .concat({ id: 5, name, resources: resources.cat5 })<br/>  } else {<br/>    return byCategory<br/>  }<br/>}</span><span id="1737" class="ka kb hu lf b fv lr lk l ll lm">// Component.jsx</span><span id="a989" class="ka kb hu lf b fv lr lk l ll lm">const Component = ({ resources }) =&gt;<br/>  resources.map(category =&gt; <br/>    &lt;Category key={category.id} category={category} /&gt;)<br/>  )</span><span id="3ab8" class="ka kb hu lf b fv lr lk l ll lm">connect({ resources: getResources(state) })(Component)</span></pre><p id="1c0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">听说过哑元件吗？有了选择器，你就有了dumber components:它们只是析构<code class="eh ln lo lp lf b">props</code>并呈现它们，没有任何额外的逻辑。</p><h2 id="8487" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">结尾部分</h2><p id="7acb" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">一般来说，状态的形状是只有还原者才应该知道的。代码从存储中泄露出来的那一刻起，就变成了结构上的耦合。</p><p id="f09b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为缩减器决定了形状，因为它们写下了形状。用选择器让“读”发生在它们附近只是常识。</p><p id="77c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据经验，做<code class="eh ln lo lp lf b">state.</code>是一个错误。唯一允许这样做的地方是选择器内部。但前提是选择器位于负责这部分状态的缩减器中。</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="e330" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想看更多很酷的JavaScript东西吗？<a class="ae lq" rel="noopener" href="/@riccardoodone/fp-in-vanilla-javascript-a-rookies-intro-e32ad13484f4">看看函数式编程如何让你的生活更轻松</a>。</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="0fb4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从我个人的电子邮件中获取最新内容。用你的想法回复。让我们互相学习。订阅我的<a class="ae lq" href="https://odone.io#newsletter" rel="noopener ugc nofollow" target="_blank"> PinkLetter </a>！</p></div></div>    
</body>
</html>