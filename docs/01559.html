<html>
<head>
<title>Lessons Learned Implementing Redux on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android上实施Redux的经验教训</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lessons-learned-implementing-redux-on-android-cba1bed40c41?source=collection_archive---------8-----------------------#2018-02-19">https://medium.com/hackernoon/lessons-learned-implementing-redux-on-android-cba1bed40c41?source=collection_archive---------8-----------------------#2018-02-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="da9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当许多人想到Redux架构时，他们会想到web。这并不奇怪，因为它起源于那里，并在那里广受欢迎。其核心是一个简单的应用程序架构，描述了一个组织和操作状态的系统。这意味着它可以应用于任何类型的应用程序开发，包括移动应用程序。</p><p id="9874" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于那些不熟悉的人来说，Redux架构以严格的单向数据流为中心。应用程序中的所有数据通过组件单向流动。在高层次上，Redux旨在确保确定性视图渲染以及确定性状态转换和再现。这里的确定性指的是知道在任何给定的时间点，您的应用程序状态总是有效的，并且可以转换为另一个可预测的有效状态的能力。然后，您的UI组件会根据给定的状态进行更新。</p><p id="3d17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux架构围绕三个主要组件展开:</p><h1 id="b3e6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">1.商店</h1><p id="2045" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这只是一个保存应用程序状态的状态容器。它保存了一个不可变的引用，表示应用程序的整个状态，并且只能通过向它发送一个动作来更新。</p><h1 id="6358" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">2.行动</h1><p id="3f71" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">动作包含要发送到商店的信息。它们代表了我们希望我们的状态如何改变。例如，考虑以下操作:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="af13" class="lc jr hu ky b fv ld le l lf lg">data class AddTodoAction(val text: String)</span></pre><p id="66e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将被分派到给定的存储以更新应用程序状态:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="a54a" class="lc jr hu ky b fv ld le l lf lg">store.dispatch(AddTodoAction("Write blog post"))</span></pre><h1 id="9f10" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">3.还原剂</h1><p id="f152" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">因为动作和存储更新本身都没有状态，所以我们需要一个专门做这件事的组件。这就是减速器的用武之地。他们只是采取一个行动和状态，并发出一个新的状态。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="80a7" class="lc jr hu ky b fv ld le l lf lg">fun reduce(oldState: AppState, action: Action) : AppState {<br/>    return when (action) {<br/>        is AddToDoAction -&gt; {<br/>            oldState.copy(todo = ...)<br/>        }<br/>        else -&gt; oldState<br/>    }<br/>}</span></pre><p id="a509" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经了解了组件，让我们看看它们是如何组合在一起的。Redux流程非常简单。您的应用程序会在视图图层上渲染应用程序状态的内容。用户交互<em class="lh">分派</em>动作，这些动作被转发给Reducers，后者操作并发出新的应用状态。</p><figure class="kt ku kv kw fq lj fe ff paragraph-image"><div class="fe ff li"><img src="../Images/4fbfb2a99ea5ad5c5382498f86a05284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*cntBtPADjE2ykLSP.png"/></div></figure><p id="0e3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近着手在一个相当大的项目中实现Redux架构，所以我想就我在这个过程中学到的一些经验给出一个观点。</p><h1 id="4a4c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">1.不要在你的应用中有多个商店</h1><p id="9eea" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">一开始，在你的应用中拥有多个商店似乎是个不错的主意，尤其是当你的目标是关注点分离的时候。然而，每个存储及其数据流可以被认为是一个闭环系统，使得它们之间的状态很难同步。尝试这样做通常需要您尝试调度状态更改以响应其他状态更改，这可能会导致无限循环。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5a94" class="lc jr hu ky b fv ld le l lf lg">mainStore.dispatch(FetchGridItemsAction())<br/>...</span><span id="c84e" class="lc jr hu ky b fv lm le l lf lg">override fun onNewState(newState: MainState) {<br/>    // FIXME: You should never dispatch an event in response to a state change.<br/>    // This can potentially create an infinite loop.<br/>    homeStore.dispatch(UpdateHomeGridAction(newState.gridState));<br/>    ...<br/>}</span></pre><p id="33f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以这种方式拥有多个商店会使您的架构非常僵化，从长远来看很难改变。在需求随时可能变化的环境中，这尤其成问题。</p><p id="273d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更好的方法是维护一个包含多个子状态的全局应用程序状态。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="64ed" class="lc jr hu ky b fv ld le l lf lg">data class AppState(val LoginState,<br/>                    val HomeScreenState,<br/>                    val GridState )</span></pre><h1 id="cf2f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">2.让你的应用程序状态尽可能的平坦</h1><p id="6d1f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">深度嵌套的状态导致了大量的样板代码，并且很难更新，因为一切都是不可变的，并且需要您为每个状态更新创建一个新的应用程序状态。虽然让状态数据模型与UI的层次结构相匹配看起来很直观，但这使得更新状态的深层嵌套部分变得非常困难。例如，考虑以下数据模型类:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="cce6" class="lc jr hu ky b fv ld le l lf lg">data class State(val sections: List&lt;Section&gt;)</span><span id="b36a" class="lc jr hu ky b fv lm le l lf lg">open class Section(val articles: List&lt;Article&gt;)<br/>class Home(articles: List&lt;Article&gt;) : Section(articles)<br/>class Discover(articles: List&lt;Article&gt;) : Section(articles)</span><span id="abc0" class="lc jr hu ky b fv lm le l lf lg">class Article</span></pre><p id="4c5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实例化和更新状态对象将如下所示:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="32ca" class="lc jr hu ky b fv ld le l lf lg">val state = State(sections = listOf(<br/>                  Home(listOf(article1, article2)),<br/>                  Discover(listOf(article1, article2))))</span></pre><p id="f864" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使使用Kotlin出色的复制机制，更新深度嵌套的属性(如本文中的文章)也会非常繁琐:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6c31" class="lc jr hu ky b fv ld le l lf lg">val newHome = Home(listOf(newArticle, state.sections[0].articles[1]))<br/>state.copy(sections = listOf(newHome, state.sections[1]))</span></pre><p id="4ce3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的解决方案是尽可能避免嵌套。对于包含集合的状态对象来说尤其如此。</p><blockquote class="ln lo lp"><p id="2239" class="ir is lh it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">你的应用程序状态不需要匹配你的用户界面的层次结构。</p></blockquote><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6085" class="lc jr hu ky b fv ld le l lf lg">val state = State(sections = listOf(<br/>                 Home(refs=listOf(0, 1),<br/>                 Discover(refs=listOf(0, 1))),<br/>                 articles = listOf(article1, article2))</span></pre><h1 id="8c89" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">3.你可以拥有动作创作者和中间件的健康组合</h1><p id="87b1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">动作创建者基本上是动作的工厂类。它们允许您在分派动作之前封装您可能想要做的事情，例如发出网络请求或访问共享偏好设置等，并在完成任务后返回一个动作:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="4a84" class="lc jr hu ky b fv ld le l lf lg">class TodoActionCreator {<br/>    fun createAddTodoAction(content: String): Action {<br/>        ... // do stuff<br/>        return AddTodoAction(transformedContent)<br/>    }<br/>}</span></pre><p id="4219" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，中间件很像Reducers，除了它们不创建新的应用程序状态。相反，它们执行任务并选择将动作转发给Reducers，丢弃它们，或者一起分派新的动作。中间件的一个重要用途是在流程中处理动作时记录动作:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="0551" class="lc jr hu ky b fv ld le l lf lg">class LoggerMiddleware {<br/>    fun interact(store: Store, action Action) {<br/>        logDebug { action.toString() }<br/>    }<br/>}</span></pre><p id="e569" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">中间件最适用于您希望在整个应用程序中全局地做一些事情的情况。日志、分析和持久性等东西是中间件的绝佳候选。然而，倾向于特定于用例的动作，比如API调用，通常应该委托给动作创建者。</p><h1 id="82e7" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">4.减速器应该是纯函数</h1><p id="8de5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Redux架构鼓励使用函数式方法来组合纯函数。纯函数是本质上确定的基本函数。这意味着如果用相同的输入调用，给定函数的输出将总是产生相同的结果。这是因为纯函数没有内部状态，不会留下副作用。</p><p id="8d6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">减速器应体现这一理念。它们应该总是接受一个状态和一个动作，然后返回一个新的状态。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="61be" class="lc jr hu ky b fv ld le l lf lg">class Reducer {<br/>    fun reduce(state: State, action: Action) : State {<br/>        ...<br/>    }<br/>}</span></pre><p id="bd3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还原器正确还原状态所需的任何附加信息都应该在操作中传递，还原器应该考虑状态的不变性并总是返回一个新状态。</p><blockquote class="ln lo lp"><p id="2218" class="ir is lh it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated"><em class="hu">如果你需要一个副作用来响应一个动作，考虑使用一个中间件来代替。</em></p></blockquote><h1 id="fb5d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">5.单元测试拯救生命和头发</h1><p id="a3dd" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在我看来，单元测试是Redux架构真正闪光的地方。因为归约器是没有内部状态的纯函数，所以它们在本质上是确定性的。对于给定的输入状态和动作，它们总是返回相同的输出状态。这使得它们非常容易测试。</p><p id="65e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，假设状态和动作是轻量级的数据对象，您不需要对测试进行任何模拟。简单地构造你的状态和动作的实例。测试一个减速器看起来像这样:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f366" class="lc jr hu ky b fv ld le l lf lg">val reducer = MyReducer()<br/>val state = MyState(...)<br/>val action = MyAction(...)</span><span id="df0a" class="lc jr hu ky b fv lm le l lf lg">val newState = reducer.reduce(state, action)</span><span id="75c4" class="lc jr hu ky b fv lm le l lf lg">assert(newState …)</span></pre><p id="6ea1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您需要通常从外部API或数据存储等不同位置获取的数据。您可以通过为您的操作创建一个“哑”构造函数以及一个提供您需要的数据的智能构造函数/工厂来保持您的reducer测试简单。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8f83" class="lc jr hu ky b fv ld le l lf lg">class MyAction(val data1: String, val data2: String) {</span><span id="e709" class="lc jr hu ky b fv lm le l lf lg">  companion object {<br/>    fun create(apiResponse: Response, datastore: Datastore): MyAction {<br/>      val data1 = apiResponse…<br/>      val data2 = datastore…<br/>      return MyAction(data1, data2)<br/>    }<br/>  }</span><span id="93d7" class="lc jr hu ky b fv lm le l lf lg">}</span></pre><p id="9205" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，您的减速器仍然非常容易测试。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="42aa" class="lc jr hu ky b fv ld le l lf lg">val action = MyAction(data1 = "data1", data2 = "data2)<br/>val newState = reducer.reduce(state, action)</span></pre><p id="32d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以单独测试工厂，在那里您可能想要使用模拟。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3f04" class="lc jr hu ky b fv ld le l lf lg">val response = mock&lt;Response&gt;()<br/>val datastore = mock&lt;Datastore&gt;()<br/>...<br/>val action = MyAction.create(response, datastore)</span><span id="afce" class="lc jr hu ky b fv lm le l lf lg">assert(action.data1 …)</span></pre><h1 id="d293" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">6.用科特林就行</h1><p id="17e2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Redux架构当然有很多关于构造组件的仪式。虽然这些有助于随着项目的增长保持事情的清晰和一致，但是您对语言的选择可能决定了您能够管理样板文件的程度。</p><p id="4b44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数据类、when语句、多个顶级类和高阶函数等特性极大地提高了代码的清晰度。例如，当试图匹配减速器中的动作时，可以选择使用<code class="eh lt lu lv ky b">instanceof</code>检查；</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="e6d6" class="lc jr hu ky b fv ld le l lf lg">if (action instanceof AddTodoAction) {<br/>    return reduceAddTodoAction(oldState, action);<br/>} else if (action instanceof RemoveTodoAction) {<br/>    return reduceRemoveTodoAction(oldState, action);<br/>} else if (...) {<br/>    ...<br/>}<br/>return oldState;</span></pre><p id="c36a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能会很快变得非常笨拙。另一种选择是在开关中使用字符串常量作为动作以及字符串匹配，但这并没有好到哪里去。Kotlin <code class="eh lt lu lv ky b">when</code>语句给出了一个不错的解决方案。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="b483" class="lc jr hu ky b fv ld le l lf lg">return when (action) {<br/>    is AddTodoAction -&gt; reduceAddTodoAction(oldState, action)<br/>    is RemoveTodoAction -&gt; reduceRemoveTodoAction(oldState, action)<br/>    else -&gt; oldState<br/>}</span></pre><h1 id="90b2" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="37e2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">虽然Redux可能起源于网络，但它的架构背后有许多非常好的想法，我们可以从中学习并将其引入Android。虽然我们的平台、语言和<a class="ae jp" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>可能不同，但我们有很多相同的基本问题，比如努力将我们的观点和业务逻辑之间的关注点完全分离。</p><p id="5488" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux绝不是一个完美的银弹，但在一天结束时；没有建筑是真正的。它仍然相对较新，但显示出很大的前景，我们很高兴看到它在Android上成熟。如果你对Redux感兴趣，我推荐你去看看Evan Tatarka的<a class="ae jp" href="https://github.com/evant/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>库或<a class="ae jp" href="https://github.com/ReKotlin/ReKotlin" rel="noopener ugc nofollow" target="_blank"> ReKotlin </a>，这是一个ReSwift的端口。</p><blockquote class="ln lo lp"><p id="04a9" class="ir is lh it b iu iv iw ix iy iz ja jb lq jd je jf lr jh ji jj ls jl jm jn jo hn dt translated">最初发表于<a class="ae jp" href="https://blog.pusher.com/lessons-learned-implementing-redux-on-android/" rel="noopener ugc nofollow" target="_blank">推手博客</a>。</p></blockquote><figure class="kt ku kv kw fq lj"><div class="bz el l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>