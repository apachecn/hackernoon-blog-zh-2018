<html>
<head>
<title>How I Reindex Millions Elasticsearch Documents Using AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AWS Lambda重新索引数百万个弹性搜索文档</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/overcoming-5-minute-execution-limit-in-aws-lambda-551d77315cac?source=collection_archive---------17-----------------------#2018-02-19">https://medium.com/hackernoon/overcoming-5-minute-execution-limit-in-aws-lambda-551d77315cac?source=collection_archive---------17-----------------------#2018-02-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9b62be0db064f687b5935ee60ff9f72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MklREPUT_m7QWLBXkbb8uw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="cc16" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">或者如何克服5分钟Lambda执行限制</h2></div><p id="9027" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">所以去年12月，我以一种无服务器的方式重写了我们的索引微服务。在这个过程中，我不得不将Elasticsearch从2.3版本迁移到6.1版本。</p><p id="8ec5" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">倒不是我急着升级，恰恰相反。但是有一天，弹性云宣布2.3版本即将寿终正寝。</p><p id="835c" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">你可以想象，跳过几个主要版本会带来突破性的变化，所以从头开始重写微服务是有道理的——这一次是以无服务器的方式。</p><h2 id="83db" class="kq kr if bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">问题、背景、解决方案</h2><p id="cd7d" class="pw-post-body-paragraph ju jv if jw b jx ll jg jz ka lm jj kc kd ln kf kg kh lo kj kk kl lp kn ko kp hn dt translated">从基于队列的(SQS)索引转移到事件驱动的(SNS)索引是一件非常有趣的事情，但是我将在另一篇文章中讨论。</p><p id="66bd" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">首先，你什么时候把数据库里的数据重新索引到Elasticsearch？</p><ol class=""><li id="0ee0" class="lq lr if jw b jx jy ka kb kd ls kh lt kl lu kp lv lw lx ly dt translated">更改索引映射。你添加一个新字段，改变一个旧字段的类型。</li><li id="7fcf" class="lq lr if jw b jx lz ka ma kd mb kh mc kl md kp lv lw lx ly dt translated">ES集群中断。发生这种情况时，没有新数据写入搜索索引</li></ol><p id="dc41" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在这两种情况下，您都需要从数据库中获取大量文档，并尽快将所有内容刷新到Elasticsearch。</p><p id="f866" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">让我们看看当你有一个有状态的长时间运行的微服务时重新索引的老方法。</p><figure class="mf mg mh mi fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff me"><img src="../Images/6a8f439ca549931026a86a79a823c67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFvFF0xnfJMhsvDW4hlgqA.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">The old way: long-running microservice</figcaption></figure><p id="55d7" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">问题出在“循环”中，这可能需要几个小时来迭代所有文档。兰巴只跑了5分钟。你没有国家。</p><p id="6cf4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">一件好事是SQS支持Lambda。但是今天，<a class="ae mn" href="https://www.reddit.com/r/aws/comments/7a5anz/we_are_the_aws_lambda_serverless_team_ask_the/dp79f6d/" rel="noopener ugc nofollow" target="_blank">还在路线图上</a>。那么，如果我们暂时将状态保存在数据库本身中会怎么样呢？不是真正的无服务器方式，但一切都是一个权衡。</p><p id="2ea1" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">顺便说一下，我用<a class="ae mn" href="https://mermaidjs.github.io/mermaid-live-editor/" rel="noopener ugc nofollow" target="_blank">美人鱼</a>生成了上面的序列图。</p><h2 id="6f2a" class="kq kr if bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">递归Lambdas</h2><p id="bb95" class="pw-post-body-paragraph ju jv if jw b jx ll jg jz ka lm jj kc kd ln kf kg kh lo kj kk kl lp kn ko kp hn dt translated">最后，我创建了一个集合来记录重新索引的进度。更像是一份工作清单，包括:</p><ul class=""><li id="f53c" class="lq lr if jw b jx jy ka kb kd ls kh lt kl lu kp mo lw lx ly dt translated">查询选择器:打开MongoDB游标的起点</li><li id="9711" class="lq lr if jw b jx lz ka ma kd mb kh mc kl md kp mo lw lx ly dt translated">进度:成功和失败的操作数</li><li id="b343" class="lq lr if jw b jx lz ka ma kd mb kh mc kl md kp mo lw lx ly dt translated"><strong class="jw ig">最后一个重新索引文档的ID</strong>:这个很重要</li></ul><p id="5df3" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">想法是启动1 Lambda来重新索引第一批文档，比如说10 000个。</p><p id="ce92" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">它创建一个id为的作业，将数据放入es并递归调用自己。</p><p id="5e3e" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">下一次迭代通过作业id知道查询选择器，并且<strong class="jw ig">追加最后一个重新索引的文档的</strong> ID。所以可以从最后执行的地方开始。</p><p id="ab75" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">这听起来很复杂，所以让我们重温一下流程。</p><figure class="mf mg mh mi fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mp"><img src="../Images/d0896d5c370d94be3454039c5a23f88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hm1vh85H6SgG18ul5EV-lA.png"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">The new way: recursive Lambda function</figcaption></figure><p id="9c0e" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">一些技巧使这成为可能:</p><ul class=""><li id="bdc0" class="lq lr if jw b jx jy ka kb kd ls kh lt kl lu kp mo lw lx ly dt translated">按<code class="eh mq mr ms mt b">_id</code>对你的查询进行排序:这是一个索引字段，排序起来很便宜。根据具体情况，日期字段可能更合适</li><li id="3292" class="lq lr if jw b jx lz ka ma kd mb kh mc kl md kp mo lw lx ly dt translated">排序查询允许可预测的迭代:每下一次执行查询由<code class="eh mq mr ms mt b">selector</code> + <code class="eh mq mr ms mt b">{_id: {$gte: lastDocumentId}}</code>。关于分页的更多信息，请参见文章<a class="ae mn" href="https://hackernoon.com/guys-were-doing-pagination-wrong-f6c18a91b232" rel="noopener ugc nofollow" target="_blank">我们做错了分页</a></li><li id="9e97" class="lq lr if jw b jx lz ka ma kd mb kh mc kl md kp mo lw lx ly dt translated">在重索引期间禁用ES索引刷新；但不要忘记重新启用它<em class="mu">(默认为1s) </em></li></ul><pre class="mf mg mh mi fq mv mt mw mx aw my dt"><span id="6798" class="kq kr if mt b fv mz na l nb nc">PUT /index_name/_settings<br/>{ “index” : { “refresh_interval” : “-1” } }</span></pre><h2 id="4c06" class="kq kr if bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">视窗网际网路名称服务</h2><p id="4b2a" class="pw-post-body-paragraph ju jv if jw b jx ll jg jz ka lm jj kc kd ln kf kg kh lo kj kk kl lp kn ko kp hn dt translated">因此，这看起来可能很麻烦，但这是旧的索引微服务中唯一不明显的要迁移的部分。</p><p id="906a" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">这提供了一个重新思考实现的机会，可以在大约15分钟内重新索引数百万个文档。</p><p id="6e39" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">因为你经常得到一个新的Lambda容器，所以有一点机会捕捉内存泄漏，这在以前是一个问题。</p><p id="9046" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">不要忘了AWS X射线，它与Lambda配合得很好。在对Mongo / S3 / ES的调用中发现了如此多的性能瓶颈。</p><p id="87a9" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">最后，你得到了所有无服务器的额外津贴，尽情享受吧！</p></div></div>    
</body>
</html>