<html>
<head>
<title>Building mrbuffer: a text editor for a 31 year old computer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建mrbuffer:一个用于31岁计算机的文本编辑器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-mrbuffer-a-text-editor-for-a-31-year-old-computer-59d5ea450507?source=collection_archive---------26-----------------------#2018-02-19">https://medium.com/hackernoon/building-mrbuffer-a-text-editor-for-a-31-year-old-computer-59d5ea450507?source=collection_archive---------26-----------------------#2018-02-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bfde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">苹果IIgs于1986年9月15日问世。它配备了一个2.8 MHz WDC 65816 CPU(与SNES和那个时代的其他类似计算机相同，是一个具有24位寻址的16位CPU)，256k或1MB RAM(可升级到8 MB)，以及一个Ensoniq 8位立体声合成器(这是Apple II系列的bit-speaker的一个受欢迎的升级)。作为参考，最初的Apple II系列是围绕6502 CPU (8位，16位寻址)构建的，在IIe和II+中最多有1 MB的RAM。然而，直到1988年，苹果公司才发布了新电脑的操作系统，能够有意义地利用新的硬件。GS/OS 是用原生16位代码编写的，更重要的是，旨在通过其新的闪亮GUI使用。</p><p id="158c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章是关于我如何从头到尾为IIgs构建了一个<a class="ae jp" href="https://github.com/mach-kernel/mrbuffer" rel="noopener ugc nofollow" target="_blank">微型“文本编辑器”</a>。</p><p id="d432" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PS: <a class="ae jp" href="http://www.intel-assembler.it/portale/5/65816_guide/opcode_reference.asp" rel="noopener ugc nofollow" target="_blank">这个操作码引用可能在阅读时有用</a>！</p><h1 id="0edc" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">我们要做什么？</h1><p id="bc10" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在这个项目开始时，我提出了一些要求。我的文本编辑器应该:</p><ul class=""><li id="03a6" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">可以从GS/OS启动，不管它实际上是否在操作系统的窗口中运行。</li><li id="290c" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">不要占用超过256k的RAM，以便它可以在任何<em class="lh">iig上运行。</em></li><li id="18cf" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">在本机16位模式下运行。</li></ul><p id="4aed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你对这个处理器不熟悉，那么最后一个bulletpoint就让人摸不着头脑。等到IIgs发布的时候，已经有太多的软件可以兼容最初的Apple II(使用6502)。65816有一个可以切换的“仿真模式”,通过选择性地将累加器和变址寄存器的宽度“减半”,有效地将816变成6502。</p><p id="b96a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GS/OS是一个16位的“一次一个进程”操作系统。对我来说，这意味着我的文本编辑器将是系统加载完成后唯一运行的程序。OS将保留在RAM中，但是为了不破坏OS代码，我将不得不放弃写入某些内存位置。GS/OS将引导我的程序，然后将计算机的完全控制权交给它。要退出应用程序，我必须跳转到操作系统的入口点(在本地模式下为<code class="eh li lj lk ll b">jsl</code>),在那里它将接管。</p><p id="af58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就编程环境而言，我们的选择看起来有些暗淡:</p><ul class=""><li id="bd48" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><a class="ae jp" href="https://github.com/byteworksinc/ORCA-C" rel="noopener ugc nofollow" target="_blank"> ORCA/C </a>，ANSI C编译器，但必须运行在裸机或仿真器上。</li><li id="a982" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><a class="ae jp" href="https://github.com/cc65/cc65" rel="noopener ugc nofollow" target="_blank"> cc65 </a>，ANSI C编译器，但只针对6502。</li><li id="d1e2" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Merlin_(assembler)" rel="noopener ugc nofollow" target="_blank"> Merlin16 </a>，65816汇编器，但必须在裸机或仿真器上运行。</li><li id="6e0a" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">Merlin32 ，一个Merlin16宏兼容汇编程序，可以在任何现代计算机上运行，可以从源代码构建它。</li></ul><p id="bf83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我拥有一个物理的IIgs，但是希望能够从一台现代计算机上轻松地开发。此外，在模拟器的中构建<em class="lh">也很麻烦，并且不容易用构建脚本自动完成(也就是说，花时间去破解模拟器以便编写UI动作并不是一个好的选择)，所以唯一可行的选择是使用Merlin32。此外，我将东西真正部署到物理计算机的唯一方法是将CF卡插入我的台式机，这是这里唯一一台带有多读卡器的计算机。在决定使用Merlin32之后，第一件事就是弄清楚如何用我的程序编写磁盘映像，以便仿真器可以加载它。我不得不<a class="ae jp" href="https://github.com/mach-kernel/cadius" rel="noopener ugc nofollow" target="_blank">为BrutalDeluxe软盘映像工具编写POSIX文件API绑定</a>,因为它只能在Windows上运行(这是一种基本错误),而且它是唯一可以轻松编写脚本的工具。明智地使用<code class="eh li lj lk ll b">#pragma once</code>和一些<code class="eh li lj lk ll b">stat()</code>让我在几个小时内制作了Apple II磁盘映像。</em></p><h1 id="02d6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">COUT之旅</h1><p id="e88b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在困难的项目中不失去理智的唯一方法是尽可能以面向目标的方式编写软件。任何编辑器都必须能够实现的<em class="lh">最基本的</em>功能是在屏幕上显示字符串。在大多数编程语言中，您可以调用<code class="eh li lj lk ll b">print()</code>的某种变体来完成这项任务。在Apple II世界中，我们没有这种启示，尽管这有点像谎言，因为Apple II ROM包含一系列实现<code class="eh li lj lk ll b">COUT</code>、<code class="eh li lj lk ll b">RDKEY</code>和许多其他实用程序的工具箱函数。工具箱实用程序的工作流程很简单:你用一些数据准备寄存器(在<code class="eh li lj lk ll b">COUT</code>的情况下，一个字符被加载到<code class="eh li lj lk ll b">A</code>寄存器，称为累加器)，从你的程序<code class="eh li lj lk ll b">jsr</code>到例程，它执行一些任意的任务，然后调用<code class="eh li lj lk ll b">rts</code>将控制返回给你的代码。这似乎正是我们想要的，那么我们为什么不能使用它呢？</p><p id="aa8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是时候了解一下Apple IIgs的内存架构了。</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/42269d5b290dfe083f139efa6df64e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*NhUcy3EA5CVgweKk.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Apple IIgs Hardware Reference (APDA Draft)</figcaption></figure><p id="7314" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GS/OS可执行文件存储在OMF中，一种可重定位的可执行格式。如果你已经为Linux和/或Windows写了软件，那么这是类似于你的<code class="eh li lj lk ll b">ELF</code>或<code class="eh li lj lk ll b">PE32</code>可执行格式的东西，但是对于GS操作系统。观察每个内存块流动<code class="eh li lj lk ll b">$FFFF-&gt;$0000</code>，但是更明确地说，内存被分成64k的块。为什么这是值得注意的？请记住，65816可以完全模拟6502，后者最多只能寻址64k (2 ⁶)的RAM。Apple IIe和IIc使用6502，但支持超过1M的内存配置，这是由于硬件实现了存储体切换(因此在任何给定时间，总内存中的64k“窗口”都是可见的)。由于65816 CPU支持24位地址，它可以只使用一个额外的字节来表示存储体编号，如下图所示。</p><p id="d4a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">存储体<code class="eh li lj lk ll b">$00</code>是特殊的(<a class="ae jp" href="https://retrocomputing.stackexchange.com/questions/52/how-do-i-use-shadowed-memory-to-render-super-hi-res-quickly" rel="noopener ugc nofollow" target="_blank">也是因为其他硬件特征在这里得到了最好的解释</a>，因为它包含ROM和一系列用于I/O的地址。</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/b7423a2bcc808e5775f9b512db30acac.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*RY-E4Dxs7gYR0KuX.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Apple IIgs Hardware Reference (APDA Draft)</figcaption></figure><p id="36db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到我们的GS/OS代码是可重定位的，<em class="lh">无法保证</em><em class="lh"/>程序将始终如一地加载到相同的位置(考虑到您的最终用户可能拥有的各种aux内存配置，情况更是如此)。换句话说，操作系统可以在自由的内置或辅助RAM中任意加载你的代码。回想一下，我们之前说过在加载一个字符后使用<code class="eh li lj lk ll b">jsr</code>(带有一个16位的例程位置的立即地址参数)来调用工具箱的<code class="eh li lj lk ll b">COUT</code>。在后台，<code class="eh li lj lk ll b">jsr</code>指令将下一条指令的内存位置(即<code class="eh li lj lk ll b">PC+1</code>)放入堆栈，然后跳转到您指定的立即参数地址。<code class="eh li lj lk ll b">rts</code>指令(你用来从例程中退出的指令)通过将值<code class="eh li lj lk ll b">jsr</code>推入堆栈来知道返回哪里。该值是一个16位地址，这意味着除非你的程序在bank 0中，否则整个练习将不会工作。</p><p id="adc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们刚刚讨论完65816如何支持24位寻址，因此指定存储体应该不是问题，对吗？这是真的，但是还有一个问题。为了保持与现有Apple II软件的兼容性，原始Apple II ROM必须与IIgs一起发货，以便为Apple II编写的软件仍然可以运行。也就是说，如果原始的Apple II程序使用<code class="eh li lj lk ll b">COUT</code>例程，它们也需要在IIgs上使用相同的例程，而不管6502仿真模式。因此，这些ROM函数是用6502汇编编写的，而不是用本机65816汇编编写的，这就产生了两个问题。假设我们用<code class="eh li lj lk ll b">COUT</code>例程的24位“长”地址调用了一个<code class="eh li lj lk ll b">jsl $00FDED</code>。计算机<em class="lh">将到达</em>正确的指令——考虑到指令的兼容性和与65816的重叠——它将运行它们。然而，在本地模式下，我们的寄存器大小不同(寻址模式可能不同！)，所以代码会以一种意想不到的方式执行，并导致GS崩溃到monitor(ROM包含一个在崩溃期间调用的小汇编器/监视器)。然后，即使计算机成功执行这些指令(并显示字符)，用于退出例程的<code class="eh li lj lk ll b">jsr</code>也只会从堆栈中取出两个字节(即16位，而不是24位地址)，因此如果越过了存储体边界，您将<em class="lh">永远不会</em>回到您的代码。我们需要一个来自<code class="eh li lj lk ll b">COUT</code>的原生IIgs(我不相信它存在于40个字符的视频页面(？)).</p><h1 id="b050" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">显示字符</h1><p id="4798" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以，我们仍然有展示一个角色的任务。看起来我们要亲自动手写程序了。上面的bank 0地图有标记为I/O的地址<code class="eh li lj lk ll b">$CFFF-&gt;$C000</code>。在IIgs上，这具体表示允许您:</p><ul class=""><li id="f9e3" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">阅读键盘</li><li id="14da" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">软开关模式设置为:文本，高分辨率，或SHR“超高分辨率”视频页面</li><li id="1aab" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">调用扬声器上的<code class="eh li lj lk ll b">lda</code>产生滴答声</li><li id="b63d" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">读取游戏控制器</li></ul><p id="9377" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">前两点对我们很有价值，因为我们需要读取用户输入并确保我们处于正确的视频模式。我们将首先弄清楚如何切换软开关，因为我们可以在做我们需要做的事情以显示字符之前，通过将字符代码加载到寄存器(即，作为类似<code class="eh li lj lk ll b">lda</code>的指令的立即值参数)来测试我们的视频是否工作。我们需要做什么？让我们离开I/O部分，找出视频页面在哪里。</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/42470329e15270b658ff385a0a3ad0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*uDFgPMS77zJSSjGT.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Apple IIgs Hardware Reference (APDA Draft)</figcaption></figure><p id="83d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上表中列出的16位地址都是仅在存储体0上可用的<em class="lh">。如果我们将值(在本例中是字符代码)写入文本页面，它们将出现在显示屏上。65816的24位寻址允许我们写入任何24位地址，这意味着我们可以将存储体编号添加到上述地址，以获得<code class="eh li lj lk ll b">$000400</code>并执行写入。默认情况下(或者在我的测试中似乎如此)，GS/OS以80字符视频模式加载程序，因此我们需要在打印前切换视频软开关。我们将在后面的章节中讨论这个问题。现在，假设我们已经打开了相应的开关。然后，显示一个字符所需的代码如下所示:</em></p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="c5f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这样做有一个问题。我们使用了<code class="eh li lj lk ll b">A</code>寄存器来存储我们的字符，然后使用带有24位长地址的<code class="eh li lj lk ll b">stal</code>命令来存储40个字符的文本页面的第一个位置。本机模式下65816的<code class="eh li lj lk ll b">A</code>寄存器为16位，即两个字节大。一个字符只有一个字节，因此我们在这种情况下的写操作将两个字符写入页面(取决于执行写操作时<code class="eh li lj lk ll b">A</code>寄存器的另一半中剩余的内容)。用<code class="eh li lj lk ll b">ldal #”AB”</code>可以一次操作两个字符，但是一次读一个键，同时必须写两个字符将是一个令人恼火的练习。回想一下，我们讨论过一个6502仿真模式，它涉及到告诉65816使用较小的寄存器。<em class="lh">也可以在不退出本地模式的情况下</em>改变寄存器的大小。这意味着我们可以将<code class="eh li lj lk ll b">A</code>的大小改为8位，这样<code class="eh li lj lk ll b">stal</code>就可以执行8位写操作(或一个字符)。拼图的这一部分已经完成，但是为了弄清楚如何让这个代码做我们想要它做的事情，我们需要理解处理器状态寄存器。</p><h1 id="ce41" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">处理器状态寄存器和软交换机</h1><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/5ea5e0a96f2bdb38beb3edd96876f95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*WiNTf1B3CDj9A1pz.png"/></div></figure><p id="e0cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于汇编程序员来说，这是一个非常棒的地方。看看你只用8位就能表达的所有信息！类似于<code class="eh li lj lk ll b">bcc</code>(如果进位清零则分支)的指令利用该寄存器进行分支逻辑。其他指令如<code class="eh li lj lk ll b">cmp</code>设置这些位来给你一些关于你所执行的操作的信息。在<code class="eh li lj lk ll b">cmp</code>的情况下，如果<code class="eh li lj lk ll b">A</code>大于另一个操作数，则进位位被置位。<code class="eh li lj lk ll b">E</code>位是模拟位，但是在本教程中我们不会涉及它，因为这个编辑器仍然是16位的。</p><p id="04a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的例子中，我们需要将“存储器/累加器选择”设置为<code class="eh li lj lk ll b">1</code>,这样它就是8位宽。为此，我们可以通过以下方式写入该寄存器。如果不明显，下面指令中使用的十六进制数为8位，代表寄存器的整个宽度。此外，65816是little-endian，所以在比较这个数字和寄存器时要记住这一点！</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="1726" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要返回全宽:</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="0dee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回想一下，我们之前提到过I/O模块中的软开关用于更改视频模式。我们仍然需要将GS设置为40个字符的视频模式，让我们开始吧。软开关可以通过对开关地址执行<code class="eh li lj lk ll b">lda</code>或<code class="eh li lj lk ll b">sta</code>来切换。有关I/O模块中的所有开关，请参考Apple IIgs硬件参考。在我们的例子中，你可以想象某种视频控制器在这些地址监听一个信号来做一些事情。我们只是通过对它执行内存访问操作来“拨动”开关。</p><p id="598b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您<em class="lh">必须</em>处于8位累加器模式才能工作。例如，<code class="eh li lj lk ll b">$C00C</code>禁用80 char硬件，而<code class="eh li lj lk ll b">$C00D</code>启用它。如果您向<code class="eh li lj lk ll b">$C00C</code>写入一个16位值，它也将覆盖<code class="eh li lj lk ll b">$C00D</code>，因此将其关闭，然后立即再次打开。问我怎么知道的！</p><p id="6027" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们结合我们目前所拥有的一切，并添加软交换切换代码，以制作一个简单而命令式的hello world程序。现在，我们已经组装了开始构建文本编辑器所需的几乎所有组件。</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff md"><img src="../Images/a68eb230c901ebdf97167cb220eea9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*ZNQoZnqWa4MV7Tbd.png"/></div></figure><h1 id="1cb5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">阅读键盘</h1><p id="f15e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们剩下的挑战是找出如何捕捉用户输入。查阅<a class="ae jp" href="http://www.goldstarsoftware.com/applesite/Documentation/AppleIIgsHardwareReferenceManual.PDF" rel="noopener ugc nofollow" target="_blank"> IIgs硬件参考</a>后，我们获得了一些有用的I/O位置:</p><ul class=""><li id="ee32" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><code class="eh li lj lk ll b">$C000</code>包含被按下键的字符代码和<em class="lh">选通位</em></li><li id="b3b6" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><code class="eh li lj lk ll b">$C010</code>包含任意键按下标志和<em class="lh">频闪复位</em>软开关</li></ul><p id="7691" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回想一下，我们之前提到过一个字符代码可以放在一个字节(或8位)内。现在想象一下，我刚刚按了F键，马上表演了一个<code class="eh li lj lk ll b">ldal $00C000</code>。<code class="eh li lj lk ll b">A</code>寄存器看起来像这样:</p><pre class="ln lo lp lq fq me ll mf mg aw mh dt"><span id="2843" class="mi jr hu ll b fv mj mk l ml mm">| Strobe (7) | 6 | 5 | 4 | 3 | 2 | 1 | 0 |<br/>|------------|---|---|---|---|---|---|---|<br/>| 1          | 1 | 1 | 0 | 0 | 1 | 1 | 0 |</span></pre><p id="8681" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">位0–6代表字符代码<code class="eh li lj lk ll b">$C6</code>，位7是选通脉冲。这个选通位到底是什么，为什么在那里？键盘控制器设置选通脉冲，为程序员提供一种理解何时发生按键事件的机制。有些人可能会说“我不需要一个选通位来做这件事，难道我不能只检查看看值是否改变吗？”如果用户有意输入同一个字符两次呢？此外，如果您希望使用这种方法，您将不得不浪费一个额外的字节来存储先前输入的值。选通位为这个问题提供了一个更好的解决方案，此外，我们通过清除它来控制整个反馈循环，然后告诉键盘控制器可以轮询另一个keydown事件，并再次修改在<code class="eh li lj lk ll b">$C000</code>可用的数据。当选通位被置位时，键盘控制器将<em class="lh">而不是</em>覆盖该位置！</p><p id="964e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">逻辑最好写在纸上，所以我们来想一个小的事件循环:</p><pre class="ln lo lp lq fq me ll mf mg aw mh dt"><span id="5c33" class="mi jr hu ll b fv mj mk l ml mm">- Read character data from $C000<br/>- Determine if the strobe bit is set <br/>  - If yes, branch and handle input<br/>  - If not, proceed<br/>- Read $C010, thereby toggling a softswitch causing the strobe bit to clear</span></pre><p id="ebdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，将此逻辑转换为65816:</p><p id="3a1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ll b">bit</code>指令将处理器状态寄存器的<code class="eh li lj lk ll b">n</code>位设置为累加器中数据的高位。对我们来说，这意味着我们可以立即使用<code class="eh li lj lk ll b">bmi</code>指令(“如果减则转移”)，只有当<code class="eh li lj lk ll b">n</code>位为高(即设置为<code class="eh li lj lk ll b">1</code>)时才转移。</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="ec88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">汇编编程在开始时可能会令人望而生畏:你没有任何东西可以和过去的助记指令一起工作。当然，你的汇编器可能支持宏(可以代替汇编代码块的标签)，但是除此之外，你并没有得到任何组织代码的便利。在C语言中，我们可以把逻辑分成函数。在汇编中，最接近的类似便利是我们前面讨论过的<code class="eh li lj lk ll b">jsr</code> <code class="eh li lj lk ll b">rts</code> &amp; <code class="eh li lj lk ll b">jsl</code> <code class="eh li lj lk ll b">rtl</code>子程序指令。同样，也没有循环结构；正如我们上面所演示的，通过某种比较来防止跳转到其他地址，从而形成循环。下面的C代码是按照与上面的程序集相同的精神实现的:</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="89c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的<code class="eh li lj lk ll b">if</code>子句可能看起来有点难懂，但是我们所做的就是在<code class="eh li lj lk ll b">gs_char</code>的解引用值和左移7次的数字<code class="eh li lj lk ll b">1</code>之间执行按位<code class="eh li lj lk ll b">AND</code>，这样二进制<code class="eh li lj lk ll b">1</code>就变成了<code class="eh li lj lk ll b">10000000</code>。</p><p id="6c75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">成功！我们已经收集了为Apple IIgs制作一个非常基本的文本编辑器所需的所有知识。</p><h1 id="572b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">文本编辑器里有什么？</h1><p id="c164" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">最重要的是，我只希望我的文本编辑器中包含以下内容:</p><ul class=""><li id="5322" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">仅支持40个字符的文本页面</li><li id="b6bb" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">无滚动(即没有带偏移的文本缓冲区来同步到文本页面，文本页面<em class="lh">是我们的存储)</em></li><li id="b1ca" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">箭头键可用于擦除缓冲区和改变当前字符的位置</li><li id="2511" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">显示屏的右下角将以格式(XX，YY)显示列和行输出</li><li id="2358" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">“点击”第0列或第39列(最大值)将ping扬声器</li></ul><p id="4ad3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了说明第二点，您使用的现代文本编辑器能够使文件加载更多的文本，以适合您的显示器。接下来，当前加载的文件的所有文本必须驻留在某个地方，即使你只是在查看它的某个部分。在IIgs上，这意味着为所有文本保留一些单独的空间，但是这需要做更多的工作。出于本教程的目的，这意味着我们允许用户在内存中存储的最大文本量将是40个字符的页面可以在屏幕上显示的最大文本量。</p><p id="cedb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们用一个完整的特性集和一些变量来装饰我们之前的笔和纸事件循环:</p><p id="9722" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">寄存器中的变量</strong></p><ul class=""><li id="9fbe" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><code class="eh li lj lk ll b">X</code>、列</li><li id="b251" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><code class="eh li lj lk ll b">Y</code>、行</li><li id="a9c0" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><code class="eh li lj lk ll b">A</code>，从当前键下来的字符</li></ul><p id="1325" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">熟悉65816的人会注意到我们没有“通用”寄存器。还剩下两个寄存器:直接页面和堆栈指针寄存器。前者允许您使用具有较小地址的指令作为立即值，因此如果您不使用该模式，技术上您可以将该寄存器用于其他目的。我们不能改变堆栈指针寄存器，因为我们想要使用堆栈，此外，堆栈是一个<em class="lh">更惯用的</em>工具，用于保存和恢复寄存器值，以便您可以释放它们用于破坏性操作。指令如<code class="eh li lj lk ll b">pha</code>将<code class="eh li lj lk ll b">A</code>推入堆栈，而<code class="eh li lj lk ll b">pla</code>将<code class="eh li lj lk ll b">A</code>从堆栈中拉出。当我们构建行和字符计数机制时，您将看到一个这样的例子。</p><p id="4d2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">核心事件循环</strong></p><pre class="ln lo lp lq fq me ll mf mg aw mh dt"><span id="5099" class="mi jr hu ll b fv mj mk l ml mm">- Read character data from $C000<br/>- Determine if the strobe bit is set <br/>  - If yes, branch and handle input (via a subroutine)<br/>    - Is the key up, down, left, right, return, or backspace?<br/>      - If yes, handle those cases<br/>    - Otherwise, for any arbitrary key<br/>      - Write the character to the text page<br/>      - Increment column and row appropriately<br/>    - rts<br/>  - If not, proceed<br/>- Invoke subroutine to display current character<br/>- Read $C010, thereby toggling a softswitch causing the strobe bit to clear<br/>- Jump to character reading address to repeat</span></pre><h1 id="7a5e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">开始实施</h1><p id="a26c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">第一件事是告诉我们的汇编程序Merlin32，我们想制作一个GS/OS可以识别的可重定位OMF可执行文件。<code class="eh li lj lk ll b">rel</code>和<code class="eh li lj lk ll b">typ</code>不是65816指令，而是只有Merlin32可以解析的助记符。我们在这里使用它们来设置文件名和类型(<code class="eh li lj lk ll b">$B3</code>用于<code class="eh li lj lk ll b">OMF16</code>)。</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="5f96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后两条指令负责将数据组寄存器设置为与程序组寄存器具有相同的值(通过将前者推入堆栈并将该值拉入后者寄存器)。还记得我们说过<code class="eh li lj lk ll b">OMF</code>是<em class="lh">可重定位的</em>吗？假设我们在汇编源代码中的某个地方存储了一个字符串。我们可以通过按顺序使用<code class="eh li lj lk ll b">db [byte]</code>指令来做到这一点，用字节来表示组成我们字符串的字符。方便的是，Merlin32允许我们添加标签，所以我们可以用一个标签引用这个数组，以便稍后在我们的程序中使用(例如，<code class="eh li lj lk ll b">lda</code> s来读取字符串)。如果我们不将数据库寄存器指向程序所在的同一个数据库，我们将不得不使用更大的24位地址来引用我们的字符串，而不是16位地址。8位数据库寄存器被附加到您作为立即值提供的16位地址的<em class="lh">高端</em>，形成一个24位地址。如果大量引用该字符串，可以节省几个字节的文件大小！</p><p id="82ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回到正题，让我们添加开关切换代码和核心事件循环:</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="a2d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以通过用<code class="eh li lj lk ll b">brk</code>实现<code class="eh li lj lk ll b">keydown</code>例程并注释掉还未实现的<code class="eh li lj lk ll b">jsr drawpos</code>来验证您是否正确读取了键。我们希望将断点放在例程中，因为只有当一个键被实际按下时，我们才分支到例程。否则，您将没有可靠的测试方法(因为在我们知道是我们导致了输入之前，<em class="lh">什么是</em> $00C000并不重要)。无论如何，计算机会将其作为一个<em class="lh">断点</em>进行处理，并显示您在下面看到的监视器。查看A的<em class="lh">最右边的</em>字节，查看您刚刚按下的字符代码。</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mn"><img src="../Images/af6206da37913f0660c375c894d87300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/0*NO4zSJmEdI7OJuzI.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Magic!</figcaption></figure><p id="266e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这确实是<code class="eh li lj lk ll b">mrbuffer</code>的核心事件循环。你可能注意到还没有<code class="eh li lj lk ll b">drawchar</code>例程。请记住，我们将它作为keydown例程的一部分来处理(因为如果某些键被按下，就不需要重新绘制)。我们最终会谈到它，但是让我们先解决这个问题。</p><h1 id="c949" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">实现按键程序</h1><p id="56d8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们重申一下我们的任务目标:</p><pre class="ln lo lp lq fq me ll mf mg aw mh dt"><span id="e18b" class="mi jr hu ll b fv mj mk l ml mm">- Is the key up, down, left, right, return, or backspace?<br/>  - If yes, handle those cases<br/>- Otherwise, for any arbitrary key<br/>  - Write the character to the text page<br/>  - Increment column and row appropriately</span></pre><p id="b5de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，这里有一个ASCII表，使生活更容易。注意，在最高有效(“MSD”)报头下只有3个比特；回想一下，最高位是选通位(因此此处省略)。令人尴尬的是，我更依赖上面的<code class="eh li lj lk ll b">brk</code>方法来识别字符，因为我很懒:</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/07c26ee32fc0303ef77c22d5d0dd2619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/0*LZbbC_rhW7CW7_ys.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Scanlon — IIgs Assembly Language Programming</figcaption></figure><p id="de50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看起来我们很容易就能逃出去了。我们可以将一些<code class="eh li lj lk ll b">cmp</code>链接在一起，并在它们后面跟随<code class="eh li lj lk ll b">beq</code>和上、下、左、右、返回和退格字符代码的直接值。</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="ca5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想这里没有什么需要解释的了，所以我们继续。</p><h1 id="dc51" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">(再次)显示字符</h1><p id="306d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">从上面引用<code class="eh li lj lk ll b">Table 2-8</code>我们可以看到，40列的文字页面开始于<code class="eh li lj lk ll b">$0400</code>，结束于<code class="eh li lj lk ll b">$07FF</code>。我们之前的命令式hello world程序通过在每个超过<code class="eh li lj lk ll b">$0400</code>的连续地址上写一个字符，将“OHAI”打印到屏幕上。从表面上看，假设如果你一直进行到<code class="eh li lj lk ll b">$07FF</code>，你会绕到剩余的行，直到显示满，这并不是不合理的。然而，这是不正确的。让我们来看看40个字符的文本页面的映射:</p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mt"><img src="../Images/4a0ad6f23ab8b8380f9d030fd43f7b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-tEzSrjwGeDABkmK.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Apple IIgs Hardware Reference (APDA Draft)</figcaption></figure><p id="c6d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">观察行的值。代表完整行的下一个连续地址位于<code class="eh li lj lk ll b">$0428</code>，但该行不是行1，而是行8！通过编写一个从第一行开始向页面写入41个字符的程序来尝试一下。您将看到最后一个字符出现在显示屏的下方！此外，行8紧接着行16。最靠近第16行末尾的下一行是第1行，但是第1行不连续跟随。第16行在<code class="eh li lj lk ll b">$478</code>结束，但是第1行在<code class="eh li lj lk ll b">$480</code>开始，在两行之间留下两个字节的空间。不幸的是，对这个设计决策感到恼火既不能解决我们必须实现一个工作解决方案的事实，<a class="ae jp" href="https://retrocomputing.stackexchange.com/a/2541" rel="noopener ugc nofollow" target="_blank">也不能解决事情以这种方式实现的实际原因</a>。</p><p id="f94c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以选择使用两种解决方案中的一种，这两种方案都涉及分别存储在X和Y寄存器中的列、行数据:</p><ul class=""><li id="226d" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">定义一个指针(和一个更新它的例程)指向随着行的改变而改变的基本内存地址。</li><li id="fc37" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">为每一行制作一个大的<code class="eh li lj lk ll b">cmp</code>表。</li></ul><p id="c622" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然前者可能更简洁，但边缘情况会很烦人(例如两个字节的洞)，而且可能会造成大量的<code class="eh li lj lk ll b">cmp</code>意大利面。当文档不能进行OCR时，最好的办法是使用一些必要的和可靠的东西。</p><p id="9773" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们已经处理了行和列的增量逻辑，并且寄存器包含正确的值(不要担心，我们将在下一节中讨论)。我们的解决方案如下所示:</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="9c9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我承认，这不是最好的解决方案，但它确实工作可靠。酷！我们现在可以任意写入缓冲区的任何地方。</p><h1 id="031b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">管理行和列标记</h1><p id="3fb0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果我们能够理解有效值是什么样的，就更容易理解手头的任务:</p><ul class=""><li id="07d1" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated"><code class="eh li lj lk ll b">X</code>:0-39(40个字符的行)</li><li id="9bd5" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated"><code class="eh li lj lk ll b">Y</code> : 0-22(共23行)</li></ul><p id="5050" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不，这不是一个错误，页面中总共有24行可用，但我想保留最后一行来显示一个小的<code class="eh li lj lk ll b">(col,row)</code>输出，这样用户就可以知道他们在一行上写了多少个字符，或者，如果我愿意，我可以使用这个空间在底部添加热键定义(如<code class="eh li lj lk ll b">nano</code>)。</p><p id="617a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码显示的实现这个的例程是<code class="eh li lj lk ll b">up</code>、<code class="eh li lj lk ll b">down</code>、<code class="eh li lj lk ll b">left</code>、<code class="eh li lj lk ll b">colinc</code>、<code class="eh li lj lk ll b">return</code>和<code class="eh li lj lk ll b">backspace</code>。我们可以通过使用<code class="eh li lj lk ll b">cpx</code>(与X比较)和<code class="eh li lj lk ll b">cpy</code>(与Y比较)来实现所有这些功能，并为边界设置即时值，以防止设置无效值。由于我们正在检查<code class="eh li lj lk ll b">X</code>和<code class="eh li lj lk ll b">Y</code>寄存器，这也是ping扬声器的最佳位置。在本教程中，我们不会探究如何实现<code class="eh li lj lk ll b">ping</code>子例程，因为它值得单独编写。如果你跟着做，只需删除它(如果你删除它，你可以简化下面的逻辑相当数量！)</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="8911" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为常规的按键总是增加列，而且右箭头键也会这样做，所以使用相同的分支是有意义的，这样我们的增加逻辑是一致的。如果该列位于位置<code class="eh li lj lk ll b">39</code>，我们随后将该列重置为<code class="eh li lj lk ll b">0</code>，并使用来自<code class="eh li lj lk ll b">down</code>的逻辑推进该行(如果可能)。<code class="eh li lj lk ll b">right</code>分支故意位于<code class="eh li lj lk ll b">colinc</code>旁边，以便我可以跳过下一条比较指令<code class="eh li lj lk ll b">jmp</code>(因为刚刚执行了一条指令)。此外，这是为了方便，我不希望扬声器啁啾，除非keydown明确发生与右箭头键。类似地，退格命令用空格字符替换<code class="eh li lj lk ll b">A</code>的最后一个值，然后在检查是否可以递减并执行递减后，调用<code class="eh li lj lk ll b">drawchar</code>例程本身<em class="lh">(即，因为在清除当前值之前，如果可能的话，您希望删除前一个字符)。</em></p><p id="5e2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你还会注意到我们正在对<code class="eh li lj lk ll b">finkey</code>标签做一个<code class="eh li lj lk ll b">jmp</code>；这些分支是最初的<code class="eh li lj lk ll b">keydown</code>子例程的一部分，所以我们需要跳回到那个例程的末尾，以便它可以清除选通脉冲位，然后调用它的<code class="eh li lj lk ll b">rts</code>，并将控制传递回核心事件循环。我确信这里有更好的解决方案，我计划在以后的文章中探索一些。</p><h1 id="f50a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">显示行和列标记</h1><p id="fa1a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">听起来，这似乎是一个需要解决的相当简单的问题。让我们用C语言获得一个数字的字符值，以展示第一印象的简单性:</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="30ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">任务完成。实际上，当你有了<code class="eh li lj lk ll b">printf()</code>并且你想做的只是展示的时候，为什么还要做这个练习呢？</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="32e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可惜我们这里没有<code class="eh li lj lk ll b">printf()</code>，也没有表现力。我们完全可以用<code class="eh li lj lk ll b">txa</code>加载<code class="eh li lj lk ll b">A</code>的值<code class="eh li lj lk ll b">X</code>，但是这个<em class="lh">不是</em>一个有效的字符代码！它只是一个数字！此外，只有数字<code class="eh li lj lk ll b">0-9</code>是字符代码(因为您可以在字符串中组合字符来显示基数为10的数字)，所以第一个例子可能会有点误导，似乎您可以像<code class="eh li lj lk ll b">57</code>一样添加任意偏移量并获得一个两字节的字符串，您<em class="lh">不能</em>这样做，您<em class="lh">必须</em>组合它们。</p><p id="70d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们假设<code class="eh li lj lk ll b">X</code>的值为15，代表第15列。我们需要一种方法将这个数字映射成两个一字节的字符代码。参考上面的ASCII表，我们可以做一些类似于第一个C示例的事情，在这里我们将我们想要的数字的编号添加到代表字符“0”的基址。在这种情况下，基址是<code class="eh li lj lk ll b">$B0</code>，因此<code class="eh li lj lk ll b">$B0+0</code>是“0”，<code class="eh li lj lk ll b">$B0+1</code>是“1”，依此类推。因为我们的行号和列号从不超过99，所以我们只需要考虑十进制整数的“1”和“10”位。</p><p id="8440" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单来说，我们可以这样做:</p><ul class=""><li id="3560" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">从存储在<code class="eh li lj lk ll b">X</code>或<code class="eh li lj lk ll b">Y</code>中的数字开始计数循环，直到10</li><li id="53da" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">减去10，每减一次，就增加一个计数器(“十位”)</li><li id="136d" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">前一个操作的余数是“1”的位置</li><li id="b6e2" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">将每个添加到<code class="eh li lj lk ll b">$B0</code>中，并按照从最低有效位到最高有效位的顺序显示</li></ul><p id="bbb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们只有3个可用的寄存器，并且我们使用所有3个寄存器(<code class="eh li lj lk ll b">A</code>、<code class="eh li lj lk ll b">X</code>和<code class="eh li lj lk ll b">Y</code>)来存储有意义的数据，所以我们有一个小问题。如果我们不能使用寄存器，我们将如何计数？这就是我前面提到的堆栈的用处发挥作用的地方:如果我们需要修改寄存器，我们可以在修改它们之前通过将它们的内容推送到堆栈来“保存”它们以前的值(使用指令<code class="eh li lj lk ll b">pha</code> <code class="eh li lj lk ll b">phx</code> <code class="eh li lj lk ll b">phy</code>)。</p><p id="541f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现上述内容，我们只需要两个寄存器。这个算法可能看起来有点奇怪，但它是有意义的，因为我们可以直接将<code class="eh li lj lk ll b">X</code>(列号)或<code class="eh li lj lk ll b">Y</code>(行号)转移到<code class="eh li lj lk ll b">A</code>，然后在计数<code class="eh li lj lk ll b">X</code>的同时从<code class="eh li lj lk ll b">A</code>中减去。然后，我们可以将“0”字符的基本偏移量添加到<code class="eh li lj lk ll b">A</code>中，然后将<code class="eh li lj lk ll b">A</code>的值写入文本页面。然后，只需将<code class="eh li lj lk ll b">X</code>转移到<code class="eh li lj lk ll b">A</code>，再次添加基础偏移，并显示。</p><p id="ad99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单来说，因为我们将对行和列值都使用这个逻辑，所以最好将这个逻辑放在它自己的子例程中。</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="839c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在使用这个子例程之前，请确保您调用了<code class="eh li lj lk ll b">phx</code> <code class="eh li lj lk ll b">pha</code>来保存当前列和keydown char的值，因为我们通过减少<code class="eh li lj lk ll b">A</code>来修改它，并在开头用0覆盖<code class="eh li lj lk ll b">X</code>(如果我们有一个像2这样的数字，这也很好，因为它在十位表示0)。为什么子程序不这样做？让我们看一下绘制角色位置的整个实现，以便理解:</p><figure class="ln lo lp lq fq lr"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="7a46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于我们在从列到行的过程中用新的数字覆盖了<code class="eh li lj lk ll b">A</code>,如果只是为了替换它而恢复它，那将是一种浪费。类似地，我们不需要将<code class="eh li lj lk ll b">Y</code>放到堆栈中，因为我们只需要<code class="eh li lj lk ll b">X</code>来计数。一旦我们完成了要做的工作，我们可以在最后恢复状态。</p><p id="84e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ll b">stal</code>位置代表位于第24行末尾的最后7个字符(即屏幕的最右下角)。我们画出括号，一个逗号，计算10的个数，然后把字符放到它们在屏幕上的位置。最后，我们将状态和<code class="eh li lj lk ll b">rts</code>恢复到核心事件循环，继续运行程序。</p><p id="e175" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你！您现在知道如何通过组合所有这些基本元素在Apple IIgs上实现一个非常非常基本的文本编辑器了！</p><h1 id="806a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结束了</h1><p id="8d49" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这里还有很多工作要做。例如，我还没有实现戒烟，所以期待更多的技术文章从我们今天停止的地方开始。汇编编程和围绕旧计算机架构的怪癖工作非常考验耐心，但却是有益的学习经历。我从对GS或Apple II家族一无所知开始，奇怪的是，我变得更有动力，因为这是一项我无法真正通过“Google &amp; StackOverflow”完成的任务，这感觉很新鲜，因为我比平时更努力地推动自己。我花在做这些研究和实施这个项目上的总时间是大约一个月的奇怪的间隔夜和周末。我希望有人在那里试图完成类似的事情发现这篇文章是有用的。</p><p id="02a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还要感谢# a2中央IRC频道和“苹果IIgs爱好者”脸书小组，他们愿意回答我的问题。有一个相当大的社区真的很喜欢这台电脑:人们正在自制以太网适配器，制作TCP/IP协议栈，软盘仿真器，以及各种新的定制硬件和软件来保持这些机器的活力。我对此感到非常惊讶，在我的任务结束时，我明白了为什么。它不运行《孤岛危机》或《我的密码》,但这些游戏有些“老派的酷”,你会发现自己时不时会不经意地用它们做一些<em class="lh">的事情。这是我一生中使用电脑最有收获的经历之一。感谢您的阅读。</em></p><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mu"><img src="../Images/e7e85d7e862b57237ae5235492cdf2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EPh1fRH_s9nL2TqtefibMw.gif"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Hello world!</figcaption></figure><figure class="ln lo lp lq fq lr fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mv"><img src="../Images/8fdb7a253473afb528bcf08a13ab7eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_PgIC4jEWsWkmZmSmFaIA.jpeg"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">On my ROM03!</figcaption></figure></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="6752" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lh">原载于</em> <a class="ae jp" href="https://davidstancu.me" rel="noopener ugc nofollow" target="_blank"> <em class="lh">我的博客</em> </a> <em class="lh">。</em></p></div></div>    
</body>
</html>