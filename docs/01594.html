<html>
<head>
<title>Applicative Parsing II: Putting the Pieces Together</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用解析II:将碎片放在一起</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/applicative-parsing-ii-putting-the-pieces-together-fe998dbe4587?source=collection_archive---------43-----------------------#2018-02-19">https://medium.com/hackernoon/applicative-parsing-ii-putting-the-pieces-together-fe998dbe4587?source=collection_archive---------43-----------------------#2018-02-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/bb3c1c284c507bdc772aa72b34cc4e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*x3v9LclkMi2SlDf5dEFQ-w.png"/></div></figure><p id="a451" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上周的文章中，我们介绍了<a class="ae jw" href="https://hackage.haskell.org/package/regex-applicative" rel="noopener ugc nofollow" target="_blank">应用解析库</a>。我们学习了<code class="eh jx jy jz ka b">RE</code>类型以及像<code class="eh jx jy jz ka b">sym</code>和<code class="eh jx jy jz ka b">string</code>这样的基本组合子。我们看到了如何将这些功能与类似<code class="eh jx jy jz ka b">many</code>和<code class="eh jx jy jz ka b">&lt;*&gt;</code>的应用功能结合起来，将字符串解析成数据结构。本周，我们将把这些片段放在一个实际的解析器中，用于我们的小黄瓜语法。要了解代码示例，请查看Github资源库上的<a class="ae jw" href="https://github.com/jhb563/GherkinParsing/blob/master/src/Parser.hs" rel="noopener ugc nofollow" target="_blank"> Parser.hs </a>。</p><p id="2ec2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从下周开始，我们将探索一些其他的解析库，从<a class="ae jw" href="https://hackage.haskell.org/package/attoparsec" rel="noopener ugc nofollow" target="_blank"> Attoparsec </a>开始。想了解更多关于这些库和其他库的信息，请下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">产品清单！它总结了从数据库到Web APIs的许多库。</a></p><p id="80c8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您从未编写过Haskell，那就开始吧！下载我们免费的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单！</a>。</p><h1 id="b1d0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">值分析器</h1><p id="15a0" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">为了与上一篇文章中的方法保持一致，我们将从较小的语法元素开始。然后，我们可以使用这些来轻松地建立更大的。为此，让我们为我们的<code class="eh jx jy jz ka b">Value</code>类型构建一个解析器，这是我们语法中最基本的数据结构。让我们回忆一下那看起来像什么:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="8ebd" class="lm kc hu ka b fv ln lo l lp lq">data Value =<br/>ValueNull |<br/>ValueBool Bool |<br/>ValueString String |<br/>ValueNumber Scientific</span></pre><p id="799d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">由于我们有不同的构造函数，我们将为每个构造函数创建一个解析器。然后我们可以将它们与替代语法结合起来:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="7b3d" class="lm kc hu ka b fv ln lo l lp lq">valueParser :: RE Char Value<br/>valueParser =<br/>  nullParser &lt;|&gt;<br/>  boolParser &lt;|&gt;<br/>  numberParser &lt;|&gt;<br/>  stringParser</span></pre><p id="6a02" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们的空值和布尔值解析器很容易。对于其中的每一个，我们将给出一些不同的选项，关于我们可以用什么字符串来表示这些元素。然后，与更大的解析器一样，我们将把它们与<code class="eh jx jy jz ka b">&lt;|&gt;</code>结合起来。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="7075" class="lm kc hu ka b fv ln lo l lp lq">nullParser :: RE Char Value<br/>nullParser =<br/>  (string “null” &lt;|&gt;<br/>  string “NULL” &lt;|&gt;<br/>  string “Null”) *&gt; pure ValueNull</span><span id="6a79" class="lm kc hu ka b fv lr lo l lp lq">boolParser :: RE Char Value<br/>boolParser =<br/>  trueParser *&gt; pure (ValueBool True) &lt;|&gt; <br/>  falseParser *&gt; pure (ValueBool False)<br/>  where<br/>    trueParser = string “True” &lt;|&gt; string “true” &lt;|&gt; string “TRUE”<br/>    falseParser = string “False” &lt;|&gt; string “false” &lt;|&gt; string “FALSE”</span></pre><p id="2804" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意，在这两种情况下，我们都用<code class="eh jx jy jz ka b">*&gt;</code>丢弃了实际的字符串，然后返回我们的构造函数。我们必须用<code class="eh jx jy jz ka b">pure</code>包装期望的结果。</p><h1 id="2752" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">数字和字符串值</h1><p id="44b0" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">数字和字符串稍微复杂一些，因为我们不能依赖硬编码的格式。对于数字，我们将考虑整数、小数和负数。我们暂时忽略科学符号。整数很容易解析，因为我们有很多字符都是数字。我们使用<code class="eh jx jy jz ka b">some</code>而不是<code class="eh jx jy jz ka b">many</code>来强调至少有一个:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="dadb" class="lm kc hu ka b fv ln lo l lp lq">numberParser :: RE Char Value<br/>numberPaser = …<br/>  where<br/>    integerParser = some (psym isNumber)</span></pre><p id="1096" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">十进制解析器会读取一些数字，然后是一个小数点，然后是更多的数字。我们坚持小数点后至少有一个数字。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="f307" class="lm kc hu ka b fv ln lo l lp lq">numberParser :: RE Char Value<br/>numberPaser = …<br/>  where<br/>    integerParser = some (psym isNumber)<br/>    decimalParser = <br/>      many (psym isNumber) &lt;*&gt; sym ‘.’ &lt;*&gt; some (psym isNumber)</span></pre><p id="d9eb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，对于负数，我们将读取一个负符号，然后是另一个解析器:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5c3d" class="lm kc hu ka b fv ln lo l lp lq">numberParser :: RE Char Value<br/>numberPaser = …<br/>  where<br/>    integerParser = some (psym isNumber)<br/>    decimalParser = <br/>      many (psym isNumber) &lt;*&gt; sym ‘.’ &lt;*&gt; some (psym isNumber)<br/>    negativeParser = sym ‘-’ &lt;*&gt; (decimalParser &lt;|&gt; integerParser)</span></pre><p id="b548" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，我们不能原样组合这些解析器！现在，它们都返回不同的结果！整数分析器返回单个字符串。十进制解析器返回两个字符串和十进制字符，依此类推。通常，我们希望将每个解析器的结果组合成一个字符串，然后将它们传递给<code class="eh jx jy jz ka b">read</code>函数。这需要在最后两个解析器上映射几个函数:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="8cb8" class="lm kc hu ka b fv ln lo l lp lq">numberParser :: RE Char Value<br/>numberPaser = …<br/>  where<br/>    integerParser = some (psym isNumber)<br/>    decimalParser = combineDecimal &lt;$&gt; <br/>      many (psym isNumber) &lt;*&gt; sym ‘.’ &lt;*&gt; some (psym isNumber)<br/>    negativeParser = (:) &lt;$&gt; <br/>      sym ‘-’ &lt;*&gt; (decimalParser &lt;|&gt; integerParser)</span><span id="58de" class="lm kc hu ka b fv lr lo l lp lq">    combineDecimal :: String -&gt; Char -&gt; String -&gt; String<br/>    combineDecimal base point decimal = base ++ (point : decimal)</span></pre><p id="e609" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们所有的数字解析器都返回字符串，所以我们可以安全地组合它们。我们将把<code class="eh jx jy jz ka b">ValueNumber</code>构造函数映射到我们从字符串中读取的值上。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="38dc" class="lm kc hu ka b fv ln lo l lp lq">numberParser :: RE Char Value<br/>numberPaser = (ValueNumber . read) &lt;$&gt;<br/>  (negativeParser &lt;|&gt; decimalParser &lt;|&gt; integerParser)<br/>  where<br/>    ...</span></pre><p id="7bfe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意顺序很重要！如果我们把整数解析器放在第一位，我们就有麻烦了！如果遇到小数点，整数解析器会贪婪地成功，解析小数点之前的一切。我们要么丢失小数点后的所有信息，要么更糟，出现解析失败。</p><p id="52e1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们需要做的最后一件事是读取一个字符串。我们需要读取示例单元格中的所有内容，直到碰到一个竖线，然后忽略任何空白。幸运的是，我们有合适的组合子，我们甚至已经写了一个<code class="eh jx jy jz ka b">trim</code>函数！</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="87de" class="lm kc hu ka b fv ln lo l lp lq">stringParser :: RE Char Value<br/>stringParser = (ValueString . trim) &lt;$&gt; readUntilBar</span></pre><p id="e6c7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">而现在我们的<code class="eh jx jy jz ka b">valueParser</code>会按预期工作！</p><h1 id="fd05" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构建示例表</h1><p id="c51c" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">既然我们可以解析单个值，那么让我们来看看如何解析完整的示例表。我们可以使用我们自己的值解析器来解析一整行值！第一步是读取行首的竖线。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="b7c7" class="lm kc hu ka b fv ln lo l lp lq">exampleLineParser :: RE Char [Value]<br/>exampleLineParser = sym ‘|’ *&gt; ...</span></pre><p id="4943" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我们将为每个单元格构建一个解析器。它将读取空白，然后是值，然后向上读取下一个条。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="7907" class="lm kc hu ka b fv ln lo l lp lq">exampleLineParser :: RE Char [Value]<br/>exampleLineParser = sym ‘|’ *&gt; ...<br/>  where<br/>    cellParser = <br/>      many isNonNewlineSpace *&gt; valueParser &lt;* readThroughBar</span><span id="696c" class="lm kc hu ka b fv lr lo l lp lq">isNonNewlineSpace :: RE Char Char<br/>isNonNewlineSpace = psym (\c -&gt; isSpace c &amp;&amp; c /= ‘\n’)</span></pre><p id="229c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们阅读其中的<code class="eh jx jy jz ka b">many</code>，并通过阅读换行符来结束:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="6bbe" class="lm kc hu ka b fv ln lo l lp lq">exampleLineParser :: RE Char [Value]<br/>exampleLineParser = <br/>  sym ‘|’ *&gt; many cellParser &lt;* readThroughEndOfLine<br/>  where<br/>    cellParser = <br/>      many isNonNewlineSpace *&gt; valueParser &lt;* readThroughBar</span></pre><p id="3c56" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们需要一个类似的解析器来读取示例的标题列。这将具有与值单元格相同的结构，只是它将读取正常的字母字符串而不是值。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e43d" class="lm kc hu ka b fv ln lo l lp lq">exampleColumnTitleLineParser :: RE Char [String]<br/>exampleColumnTitleLineParser = sym ‘|’ *&gt; many cellParser &lt;* readThroughEndOfLine<br/>  where<br/>    cellParser = <br/>      many isNonNewlineSpace *&gt; many (psym isAlpha) &lt;* readThroughBar</span></pre><p id="1bf0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们可以开始构建完整的示例解析器了。我们需要读取字符串、列标题，然后是值行。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="bc0d" class="lm kc hu ka b fv ln lo l lp lq">exampleTableParser :: RE Char ExampleTable<br/>exampleTableParser =<br/>  (string “Examples:” *&gt; readThroughEndOfLine) *&gt;<br/>  exampleColumnTitleLineParser &lt;*&gt;<br/>  many exampleLineParser</span></pre><p id="c67e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还没完成。我们需要对这些结果应用一个函数来产生最终的<code class="eh jx jy jz ka b">ExampleTable</code>。诀窍是我们想把示例键和它们的值对应起来。我们可以用一个简单的函数来完成这个任务。它将使用<code class="eh jx jy jz ka b">map</code>返回每个值列表上的zip键:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5628" class="lm kc hu ka b fv ln lo l lp lq">exampleTableParser :: RE Char ExampleTable<br/>exampleTableParser = buildExampleTable &lt;$&gt;<br/>  (string “Examples:” *&gt; readThroughEndOfLine) *&gt;<br/>  exampleColumnTitleLineParser &lt;*&gt;<br/>  many exampleLineParser<br/>  where<br/>    buildExampleTable :: [String] -&gt; [[Value]] -&gt; ExampleTable<br/>    buildExampleTable keys valueLists = ExampleTable keys (map (zip keys) valueLists)</span></pre><h1 id="bd3b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">声明</h1><p id="771f" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">现在我们可以解析给定场景的示例，我们需要解析Gherkin语句。首先，让我们制作一个通用解析器，它将关键字作为参数。然后，我们的完整解析器将尝试每个不同的语句关键字:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5d16" class="lm kc hu ka b fv ln lo l lp lq">parseStatementLine :: String -&gt; RE Char Statement<br/>parseStatementLine signal = …</span><span id="5937" class="lm kc hu ka b fv lr lo l lp lq">parseStatement :: RE Char Statement<br/>parseStatement =<br/>  parseStatementLine “Given” &lt;|&gt;<br/>  parseStatementLine “When” &lt;|&gt;<br/>  parseStatementLine “Then” &lt;|&gt;<br/>  parseStatementLine “And”</span></pre><p id="6923" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们将去掉信号词并解析语句行本身。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5580" class="lm kc hu ka b fv ln lo l lp lq">parseStatementLine :: String -&gt; RE Char Statement<br/>parseStatementLine signal = string signal *&gt; sym ' ' *&gt; ...</span></pre><p id="04d8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">解析语句是很棘手的。我们希望解析括号内的键，并将它们作为键分开。但是我们也希望它们成为语句字符串的一部分。为此，我们将创建两个辅助解析器。首先，<code class="eh jx jy jz ka b">nonBrackets</code>将通过括号(或换行符)解析字符串中的所有内容。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="16f1" class="lm kc hu ka b fv ln lo l lp lq">nonBrackets :: RE Char String<br/>nonBrackets = many (psym (\c -&gt; c /= ‘\n’ &amp;&amp; c /= ‘&lt;’))</span></pre><p id="cc76" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还需要一个解析器来解析括号并返回里面的关键字:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="910f" class="lm kc hu ka b fv ln lo l lp lq">insideBrackets :: RE Char String<br/>insideBrackets = sym ‘&lt;’ *&gt; many (psym (/= ‘&gt;’)) &lt;* sym ‘&gt;’</span></pre><p id="7d97" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在来读一个语句，我们从非括号开始，用括号中的键交替。让我们观察一下，我们以无括号开始和结束，因为它们可以是空的。因此，我们可以用一列非括号/括号对来表示一行，后面跟着最后一个非括号部分。为了组成一对，我们使用由<code class="eh jx jy jz ka b">TupleSections</code>启用的<code class="eh jx jy jz ka b">(,)</code>构造函数将解析器结果组合成一个元组:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="39c7" class="lm kc hu ka b fv ln lo l lp lq">parseStatementLine :: String -&gt; RE Char Statement<br/>parseStatementLine signal = string signal *&gt; sym ‘ ‘ *&gt;<br/>  many ((,) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets) &lt;*&gt; nonBrackets</span></pre><p id="86d2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从这里开始，我们需要一个递归函数来构建最终的语句字符串和键列表。我们用<code class="eh jx jy jz ka b">buildStatement</code>来做这个。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="f2ce" class="lm kc hu ka b fv ln lo l lp lq">parseStatementLine :: String -&gt; RE Char Statement<br/>parseStatementLine signal = string signal *&gt; sym ‘ ‘ *&gt;<br/>  (buildStatement &lt;$&gt; <br/>    many ((,) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets) &lt;*&gt; nonBrackets)<br/>  where<br/>    buildStatement :: <br/>      [(String, String)] -&gt; String -&gt; (String, [String])<br/>    buildStatement [] last = (last, [])<br/>    buildStatement ((str, key) : rest) rem =<br/>      let (str', keys) = buildStatement rest rem<br/>      in (str &lt;&gt; "&lt;" &lt;&gt; key &lt;&gt; "&gt;" &lt;&gt; str', key : keys)</span></pre><p id="a177" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们最不需要的是一个final helper，它将把<code class="eh jx jy jz ka b">buildStatement</code>的结果转换成<code class="eh jx jy jz ka b">Statement</code>。我们就叫这个<code class="eh jx jy jz ka b">finalizeStatement</code>，然后就完事了！</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e493" class="lm kc hu ka b fv ln lo l lp lq">parseStatementLine :: String -&gt; RE Char Statement<br/>parseStatementLine signal = string signal *&gt; sym ‘ ‘ *&gt;<br/>  (finalizeStatement . buildStatement &lt;$&gt; <br/>    many ((,) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets) &lt;*&gt; nonBrackets)<br/>  where<br/>    buildStatement :: <br/>      [(String, String)] -&gt; String -&gt; (String, [String])<br/>    buildStatement [] last = (last, [])<br/>    buildStatement ((str, key) : rest) rem =<br/>      let (str', keys) = buildStatement rest rem<br/>      in (str &lt;&gt; "&lt;" &lt;&gt; key &lt;&gt; "&gt;" &lt;&gt; str', key : keys)</span><span id="5a00" class="lm kc hu ka b fv lr lo l lp lq">    finalizeStatement :: (String, [String]) -&gt; Statement<br/>    finalizeStatement (regex, variables) = Statement regex variables</span></pre><h1 id="99e7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">情节</h1><p id="23b2" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">既然我们已经准备好了所有的部分，那么为场景编写解析器就很容易了！首先，我们通过读取关键字获得标题，然后是该行的其余部分:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="fb4c" class="lm kc hu ka b fv ln lo l lp lq">scenarioParser :: RE Char Scenario<br/>scenarioParser = string “Scenario: “ *&gt; readThroughEndOfLine ...</span></pre><p id="493b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">之后我们看了很多语句，然后是例表。由于示例表可能不存在，我们将提供一个纯空表作为替代。我们可以通过映射<code class="eh jx jy jz ka b">Scenario</code>构造函数将所有东西包装在一起。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="9b67" class="lm kc hu ka b fv ln lo l lp lq">scenarioParser :: RE Char Scenario<br/>scenarioParser = Scenario &lt;$&gt;<br/>  (string “Scenario: “ *&gt; readThroughEndOfLine) &lt;*&gt;<br/>  many (statementParser &lt;* sym ‘\n’) &lt;*&gt;<br/>  (exampleTableParser &lt;|&gt; pure (ExampleTable [] []))</span></pre><p id="5ac5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还可以制作一个非常相似的“后台”解析器。所有的变化是，我们阅读字符串“背景”而不是一个标题。因为我们将标题硬编码为“背景”，所以我们可以将它包含在构造函数中，并将其映射到解析器上。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e796" class="lm kc hu ka b fv ln lo l lp lq">backgroundParser :: RE Char Scenario<br/>backgroundParser = Scenario “Background” &lt;$&gt;<br/>  (string “Background:” *&gt; readThroughEndOfLine) *&gt;<br/> many (statementParser &lt;* sym ‘\n’) &lt;*&gt;<br/>  (exampleTableParser &lt;|&gt; pure (ExampleTable [] []))</span></pre><h1 id="931b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">最后一个功能</h1><p id="4f55" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">我们快完成了！我们剩下的就是写<code class="eh jx jy jz ka b">featureParser</code>本身了！与场景一样，我们将从关键字和标题行开始:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="3898" class="lm kc hu ka b fv ln lo l lp lq">featureParser :: RE Char Feature<br/>featureParser = Feature &lt;$&gt;<br/>  (string “Feature: “ *&gt; readThroughEndOfLine) &lt;*&gt;<br/>  ...</span></pre><p id="7a81" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们将使用<code class="eh jx jy jz ka b">optional</code>组合子来解析<code class="eh jx jy jz ka b">Background</code>(如果它存在),如果不存在则返回<code class="eh jx jy jz ka b">Nothing</code>。然后，我们将结束解析许多场景！</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="23f6" class="lm kc hu ka b fv ln lo l lp lq">featureParser :: RE Char Feature<br/>featureParser = Feature &lt;$&gt;<br/>  (string “Feature: “ *&gt; readThroughEndOfLine) &lt;*&gt;<br/>  (optional backgroundParser) &lt;*&gt;<br/>  (many scenarioParser)</span></pre><p id="ef0d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意，这里我们忽略了我们作为原始语法的一部分提出的特性的“描述”。因为没有相应的关键字，所以使用应用解析来处理它是很痛苦的。当我们从下周开始研究一元方法时，我们会发现这并不困难。</p><h1 id="2e07" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="25eb" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">这就结束了我们对应用解析的探索。我们可以看到Haskell非常适合解析。这种语言的功能性意味着很容易从像我们的第一个解析器这样的小构件开始。然后我们可以逐渐把它们组合起来，做成更大的东西。将我们的头脑包裹在所有不同的操作符和组合符中可能有点棘手。但是一旦你理解了这些让我们组合我们的解析器的方式，它们就很有意义并且易于使用。</p><p id="f070" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了加深你对有用的Haskell库的了解，下载我们免费的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！它会告诉你许多任务的库，从数据库到机器学习！</p><p id="752a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你以前从未写过一行Haskell，不要害怕！下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>了解更多！</p></div></div>    
</body>
</html>