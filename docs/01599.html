<html>
<head>
<title>Running a scalable &amp; reliable GraphQL endpoint with Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无服务器运行可扩展且可靠的GraphQL端点</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/running-a-scalable-reliable-graphql-endpoint-with-serverless-24c3bb5acb43?source=collection_archive---------3-----------------------#2018-02-20">https://medium.com/hackernoon/running-a-scalable-reliable-graphql-endpoint-with-serverless-24c3bb5acb43?source=collection_archive---------3-----------------------#2018-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ffbe" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">第2部分:AppSync后端:AWS托管的GraphQL服务</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/0d92436a2212f6ef911ea412db043f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1KwFeH3ahexWaHVFIFuow.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">AWS AppSync architecture</figcaption></figure><blockquote class="jz ka kb"><p id="7ec9" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">第1部分</strong> : <a class="ae kz" href="https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless/" rel="noopener ugc nofollow" target="_blank">简介:带API网关的GraphQL端点+ AWS Lambda </a> <br/> <strong class="kf hv">第2部分</strong> : AppSync后端:<a class="ae kz" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>托管GraphQL服务(本帖)<br/> <strong class="kf hv">第3部分</strong> : <a class="ae kz" href="https://hackernoon.com/running-a-scalable-reliable-graphql-endpoint-with-serverless-db16e42dc266" rel="noopener ugc nofollow" target="_blank"> AppSync前端:AWS托管GraphQL服务</a> <br/> <strong class="kf hv">第4部分</strong> : <a class="ae kz" href="https://hackernoon.com/serverless-appsync-plugin-top-10-new-features-3faaf6789480" rel="noopener ugc nofollow" target="_blank">无服务器AppSync插件:新特性</a>(最新！！！)</p></blockquote><blockquote class="la"><p id="2751" class="lb lc hu bd ld le lf lg lh li lj ky ek translated">“使用无服务器后端为您的GraphQL端点提供支持彻底解决了扩展性和可用性问题，并为您提供了安全保障。甚至没有那么多代码或配置”。-第一部分</p></blockquote><h1 id="d2fd" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">介绍</h1><p id="5c75" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">在系列的这一部分中，我们将学习如何使用在re: Invent 2017 上发布的名为<strong class="kf hv"> <em class="ke"> AppSync </em> </strong> <a class="ae kz" href="https://aws.amazon.com/blogs/aws/introducing-amazon-appsync/" rel="noopener ugc nofollow" target="_blank">的新AWS服务来构建</a><a class="ae kz" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>端点。我将使用AppSync与DynamoDB、ElasticSearch和AWS Lambda集成来创建一个迷你Twitter应用程序 的后端，并向您展示如何使用<em class="ke">new</em><a class="ae kz" href="https://github.com/sid88in/serverless-appsync-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="kf hv">server less-AppSync-Plugin</strong></a><strong class="kf hv">来配置和部署App sync。</strong></p><p id="560f" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">我们开始吧！🏃</p><blockquote class="jz ka kb"><p id="0983" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><em class="hu">注:如果你是Serverless或GraphQL的新手，我会建议你拿起一杯咖啡，浏览一下本系列的</em> <a class="ae kz" href="https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hv"> <em class="hu">第1部分</em></strong></a><strong class="kf hv"><em class="hu"/></strong><em class="hu">，然后再回来。</em></p></blockquote><h1 id="9367" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">AppSync是什么？</h1><p id="8513" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">AWS AppSync是一个完全托管的无服务器<a class="ae kz" href="http://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务，用于实时数据查询、同步、通信和离线编程功能。这篇博客涵盖了创建GraphQL API本身，本系列的下一部分将关注AppSync客户端及其特性<em class="ke"> ( </em> <a class="ae kz" href="https://twitter.com/sidg_sid" rel="noopener ugc nofollow" target="_blank"> <em class="ke">)敬请关注</em> </a> <em class="ke">！</em>🔈<em class="ke">)。</em></p><p id="4b05" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">"<em class="ke">事实证明，</em><a class="ae kz" href="https://dev-blog.apollodata.com/apollo-client-2-0-beyond-graphql-apis-888807b53afe" rel="noopener ugc nofollow" target="_blank"><em class="ke">Apollo Client 2.0</em></a><em class="ke">的模块化架构对于希望定制其GraphQL客户端的开发人员来说是一个巨大的胜利，因为这正是AWS团队能够构建</em> <a class="ae kz" href="https://github.com/awslabs/aws-mobile-appsync-sdk-js/blob/254930e3de1211c20bbac3efadf571008826bc32/packages/aws-appsync/src/client.js" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> AppSync客户端</em> </a> <em class="ke">的方式！</em>”——作者<a class="mn mo gr" href="https://medium.com/u/c827782c6410?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">佩吉·雷兹斯</a></p><blockquote class="jz ka kb"><p id="783d" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><em class="hu">注:这篇</em> <a class="ae kz" href="https://hackernoon.com/aws-appsync-up-and-running-560a42d96ba7?gi=6808eedc7c55" rel="noopener ugc nofollow" target="_blank"> <em class="hu">帖子</em> </a> <em class="hu">作者</em><a class="mn mo gr" href="https://medium.com/u/695782484bda?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank"><em class="hu">Nader Dabit</em></a><em class="hu">是一本AppSync初级读本的绝佳读物。</em></p></blockquote><h1 id="5b70" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">AppSync与GraphQL + Lambda</h1><blockquote class="la"><p id="d905" class="lb lc hu bd ld le mp mq mr ms mt ky ek translated">如果Serverless + Lambda + GraphQL工作得如此之好，那么为什么还要费心探索其他解决方案呢？</p><p id="8753" class="lb lc hu bd ld le mp mq mr ms mt ky ek translated">B <!-- -->因为AppSync有一个GraphQL + Lambda没有的很酷的功能。即:实时订阅。</p></blockquote><p id="deb9" class="pw-post-body-paragraph kc kd hu kf b kg mu iv ki kj mv iy kl me mw ko kp mg mx ks kt mi my kw kx ky hn dt translated">两者各有优势。但是哪一个适合你的应用呢？</p><p id="ab9d" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated"><strong class="kf hv"> <em class="ke">当你想对端点做什么有更多的控制时，使用Lambda </em> </strong>。例如，也许你想用你最喜欢的Lambda服务器来处理客户端请求；或者，您可能需要一个更封闭的系统，并且不想使用AWS身份验证系统。</p><p id="2a2e" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">当您需要支持数百万人的实时更新时，请使用AppSync  。这比<a class="ae kz" href="https://serverless.com/blog/realtime-updates-using-lambda-websockets-iot/" rel="noopener ugc nofollow" target="_blank">用Lambda和IoT </a>实现实时更新要容易得多。当然，它带有完全AWS管理的GraphQL服务和企业级安全特性。</p><h1 id="a8be" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">如何在生产中开始使用AppSync？</h1><p id="d605" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">我很高兴你问了！</p><p id="847b" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">使用AppSync后，您可能会很快意识到连接整个后端组件(包括GraphQL模式、解析器映射模板和数据源)非常耗时且容易出错(稍后我会进一步解释)。</p><p id="65b6" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">在生产环境中，您可能需要一段代码或配置来使您的部署完全自动化，并且快速和可伸缩。</p><blockquote class="la"><p id="07da" class="lb lc hu bd ld le mp mq mr ms mt ky ek translated">出于同样的原因，我很高兴地宣布全新的<a class="ae kz" href="https://github.com/sid88in/serverless-appsync-plugin" rel="noopener ugc nofollow" target="_blank">无服务器AppSync插件</a>，它允许您通过无服务器CLI部署AppSync组件，现在是开源的🎉</p><p id="b368" class="lb lc hu bd ld le mp mq mr ms mt ky ek translated">我写这篇博客背后的动机是分享我对AppSync的了解，并提供一种更流畅、更灵活的方式来在几秒钟内将GraphQL端点投入生产。</p></blockquote><blockquote class="jz ka kb"><p id="0ee1" class="kc kd ke kf b kg mu iv ki kj mv iy kl km mw ko kp kq mx ks kt ku my kw kx ky hn dt translated"><em class="hu">注:本博客涉及的示例可在</em><a class="ae kz" href="https://github.com/serverless/serverless-graphql/tree/master/app-backend/appsync" rel="noopener ugc nofollow" target="_blank"><em class="hu">GitHub</em></a><em class="hu">上获得。</em></p></blockquote><h1 id="3c74" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">让我们用AppSync插件构建一个GraphQL端点</h1><p id="c325" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">在此之前，让我解释一下AppSync的四个 构建模块:</p><ol class=""><li id="ebf7" class="mz na hu kf b kg kh kj kk me nb mg nc mi nd ky ne nf ng nh dt translated"><strong class="kf hv"> GraphQL模式</strong> <br/>迷你推特应用的完整模式<a class="ae kz" href="https://github.com/serverless/serverless-graphql/blob/master/app-backend/appsync/dynamo-elasticsearch-lambda/schema.graphql" rel="noopener ugc nofollow" target="_blank">在这里</a>可以找到。它包括各种类型和字段来检索用户和tweet信息。</li><li id="7b65" class="mz na hu kf b kg ni kj nj me nk mg nl mi nm ky ne nf ng nh dt translated"><strong class="kf hv"> GraphQL解析器(映射模板)</strong> <br/>使用<em class="ke"> </em>请求和响应<a class="ae kz" href="https://github.com/serverless/serverless-graphql/tree/master/app-backend/appsync/dynamo-elasticsearch-lambda/mapping-templates" rel="noopener ugc nofollow" target="_blank">映射模板</a>(用<a class="ae kz" href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-programming-guide.html" rel="noopener ugc nofollow" target="_blank">速度模板语言</a>编写)解析模式中的每个字段。这些模板解析传入的请求并解释来自数据库的响应。</li><li id="1dff" class="mz na hu kf b kg ni kj nj me nk mg nl mi nm ky ne nf ng nh dt translated"><strong class="kf hv">数据来源<br/> </strong>你得到了DynamoDB、ElasticSearch和Lambda的内置支持。事实上，Lambda提供了添加RDS、REST API、MongoDB、Druid等的灵活性。</li><li id="07f2" class="mz na hu kf b kg ni kj nj me nk mg nl mi nm ky ne nf ng nh dt translated"><strong class="kf hv">认证和IAM权限<br/> </strong>您可以使用API密钥认证您的API，认知用户池以及使用IAM权限提供细粒度的访问控制。</li></ol><h2 id="0708" class="nn ll hu bd lm no np nq lq nr ns nt lu me nu nv lw mg nw nx ly mi ny nz ma oa dt translated">AppSync SDK剖析:</h2><p id="1a1a" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">要创建端点，您基本上有两个选择:1)手动将所有组件连接在一起，并在AppSync UI中生成API，这<strong class="kf hv">耗时且容易出错</strong>或者2)使用AWS-SDK编写代码，这<strong class="kf hv">会给整个过程增加更多复杂性</strong>。</p><p id="9a76" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">下面是启动和运行端点所需的一系列步骤:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ob"><img src="../Images/0aa4c6cc3049bbfc6cb9a3dbdb79f8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYf2Thad4RguD2qtPVChcg.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Anatomy of the AppSync SDK</figcaption></figure><h2 id="88fa" class="nn ll hu bd lm no np nq lq nr ns nt lu me nu nv lw mg nw nx ly mi ny nz ma oa dt translated">拯救世界的无服务器AppSync插件</h2><p id="52c5" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">现在，看看这个😏</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="d1fa" class="nn ll hu od b fv oh oi l oj ok">plugins:<br/>  - serverless-appsync-plugin</span><span id="9b15" class="nn ll hu od b fv ol oi l oj ok">provider:<br/>  name: aws<br/>  runtime: nodejs6.10<br/><br/>custom:<br/>  appSync:<br/>    name: # Your GraphQL API Name<br/>    authenticationType: <strong class="od hv">AMAZON_COGNITO_USER_POOLS | API KEY</strong><br/>    mappingTemplates:<br/>      - dataSource: <strong class="od hv">myDynamoDB | myElasticSearch | myLambda</strong><br/>        type: # GraphQL Type<br/>        field: # Schema Field<br/>        request: # Request Mapping Template<br/>        response: # Response Mapping Template<br/>    schema: schema.graphql # Input GraphQL Schema<br/>    dataSources:<br/>      - type: <strong class="od hv">AMAZON_DYNAMODB | AMAZON_ELASTICSEARCH | AWS_LAMBDA</strong><br/>        name: <strong class="od hv">myDynamoDB | myElasticSearch | myLambda</strong><br/>        config:<br/>          <strong class="od hv">tableName</strong> | <strong class="od hv">endpoint</strong> | <strong class="od hv">lambdaFunctionArn</strong><br/>          serviceRoleArn: <em class="ke">IAM ROLE</em></span></pre><p id="121c" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">无服务器AppSync插件允许您将所有<em class="ke"> </em> <strong class="kf hv"> <em class="ke">六步</em> </strong>配置为您的<a class="ae kz" href="https://github.com/serverless/serverless-graphql/blob/master/app-backend/appsync/dynamo-elasticsearch-lambda/serverless.yml#L31" rel="noopener ugc nofollow" target="_blank"><em class="ke">server less . yml</em></a>中的一个配置。您基本上可以使用这三个命令来部署、更新或删除AppSync组件:</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="f002" class="nn ll hu od b fv oh oi l oj ok"><strong class="od hv">serverless deploy-appsync<br/>serverless update-appsync<br/>serverless delete-appsync</strong></span></pre><blockquote class="jz ka kb"><p id="be74" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv"> <em class="hu">注</em> </strong> <em class="hu">:插件中的所有配置不言而喻，但如有任何疑问或想投稿，</em> <a class="ae kz" href="https://twitter.com/sidg_sid" rel="noopener ugc nofollow" target="_blank"> <em class="hu">欢迎随时联系我</em> </a> <em class="hu">。</em></p></blockquote><h2 id="e16b" class="nn ll hu bd lm no np nq lq nr ns nt lu me nu nv lw mg nw nx ly mi ny nz ma oa dt translated">最后，它看起来是这样的:</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff om"><img src="../Images/4cccb0ded3748f7bc2426a55fc79e6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3qy2JmWiwN4lDHbi5uYcQQ.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">AppSync Deployment with Serverless Plugin</figcaption></figure><h1 id="26ca" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">迷你Twitter应用架构</h1><p id="d678" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">现在，你可能会想“迷你Twitter应用有什么大惊小怪的？它是如何工作的？我还是不明白！”。好吧，让我解释一下:</p><p id="bb52" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">这个应用程序包括一个反应前端以及一个AppSync客户端集成。您可以使用<a class="ae kz" href="https://github.com/aws/aws-amplify" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>和Cognito用户池进一步简化用户认证流程(我将在我的<strong class="kf hv">下一篇</strong>博文中详细介绍前端架构)。</p><p id="27a3" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">对于应用后端，使用<em class="ke">无服务器AppSync插件</em>创建GraphQL API。这个API连接到DynamoDB(获取用户信息)、ElasticSearch(检索用户推文)和Lambda(从Twitter REST API获取任何额外的用户信息)。</p><blockquote class="jz ka kb"><p id="6496" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">注意:请按照<a class="ae kz" href="https://github.com/serverless/serverless-graphql#setup-for-production-deploy-resources-to-aws" rel="noopener ugc nofollow" target="_blank">这些说明</a>在您的本地环境中运行应用程序。</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff on"><img src="../Images/8f336b87328d4354ea03d8e552c255fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1zPnnRPP5LV1vixEC53tw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Mini Twitter App Architecture</figcaption></figure><p id="c6a5" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">让我们看一些解析器映射模板:</p><blockquote class="jz ka kb"><p id="d0c4" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><em class="hu">例1:</em>get userinfo(handle:String！)<em class="hu"> vs. </em> meInfo</p></blockquote><p id="85e2" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">为<em class="ke"> getUserInfo </em>请求映射模板:</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="ef70" class="nn ll hu od b fv oh oi l oj ok">{<br/>    "version" : "2017-02-28",<br/>    "operation" : "<strong class="od hv">Query</strong>",<br/>    "query" : {<br/>        "expression": "handle = :<strong class="od hv">handle</strong>",<br/>        "expressionValues" : {<br/>            ":handle" : {<br/>                "S" : "${<strong class="od hv">context.arguments.handle</strong>}"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="36ef" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">为<em class="ke"> meInfo </em>请求映射模板:</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="939a" class="nn ll hu od b fv oh oi l oj ok">{<br/>    "version" : "2017-02-28",<br/>    "operation" : "<strong class="od hv">Query</strong>",<br/>    "query" : {<br/>        "expression": "handle = :<strong class="od hv">handle</strong>",<br/>        "expressionValues" : {<br/>            ":handle" : {<br/>                "S" : "${<strong class="od hv">context.identity.username</strong>}"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="68a9" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">在本例中，请求模板使用DynamoDB查询操作从Users表中获取数据。在<em class="ke"> meInfo </em>中，用户的句柄来自包含其身份信息的上下文变量(在客户端通过JWT令牌解析)。<a class="ae kz" href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html" rel="noopener ugc nofollow" target="_blank">本文</a>解释了更多关于AppSync中上下文变量和util函数的功能。</p><p id="cdad" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">两个字段的响应映射模板:</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="fae8" class="nn ll hu od b fv oh oi l oj ok">$util.toJson(<strong class="od hv">$context.result.items[0]</strong>)</span></pre><blockquote class="jz ka kb"><p id="09cc" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><em class="hu">例2: </em>收藏夹_计数</p></blockquote><p id="0d18" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">在这种情况下，我们希望从Twitter本身获取用户最喜欢的计数的值。AWS Lambda通过查询REST API ( <a class="ae kz" href="https://github.com/serverless/serverless-graphql/blob/master/app-backend/appsync/dynamo-elasticsearch-lambda/handler.js#L6" rel="noopener ugc nofollow" target="_blank">参考</a>)提供了灵活性</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="881a" class="nn ll hu od b fv oh oi l oj ok"><strong class="od hv">exports</strong>.graphqlHandler = (event, context, callback) =&gt; {<br/>  <strong class="od hv">switch </strong>(event.<strong class="od hv">field</strong>) {<br/>    <strong class="od hv">case 'favourites_count'</strong>: {<br/>      <strong class="od hv">const </strong>handle = event.<strong class="od hv">arguments</strong>.<strong class="od hv">handle<br/>        </strong>? event.<strong class="od hv">arguments</strong>.<strong class="od hv">handle<br/>        </strong>: event.<strong class="od hv">handle</strong>;<br/><br/>      <em class="ke">getFavouritesCount</em>(handle).then(result =&gt; {<br/>        callback(<strong class="od hv">null</strong>, result);<br/>      });<br/><br/>      <strong class="od hv">break</strong>;<br/>    }<br/>  }<br/>};</span></pre><blockquote class="jz ka kb"><p id="55ca" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><em class="hu">例三:</em> <strong class="kf hv">推文</strong>(限定:Int！，nextToken: String)</p></blockquote><p id="3b18" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">ElasticSearch提供了搜索引擎的强大功能。在这种情况下，我们将ES中的所有tweet编入索引，下面的请求映射模板对用户的tweet进行分页:</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="5c0c" class="nn ll hu od b fv oh oi l oj ok">{<br/>    "version":"2017-02-28",<br/>    "operation":"GET",<br/>    "path":"/user/twitter/_search",<br/>    "params":{<br/>        "body":{<br/>            "from": <strong class="od hv">$context.arguments.nextToken</strong>,<br/>            "size": <strong class="od hv">$context.arguments.limit</strong>,<br/>            "query" : {<br/>                "bool" : {<br/>                    "must" : [<br/>                        {<br/>                        "match" : <br/>                           { "handle" : <strong class="od hv">$context.source.handle</strong> }<br/>                        }<br/>                    ]<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="8e3b" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">响应映射模板:</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="5b2a" class="nn ll hu od b fv oh oi l oj ok">{<br/>  #set($hitcount = <strong class="od hv">$context.result.hits.total</strong>)<br/>    #set($tweetList = [])<br/>    #set($counter = 0)<br/>  #if($hitcount &gt; 0)<br/>        #foreach($entry in <strong class="od hv">$context.result.hits.hits</strong>)<br/>          #set( $element = ${tweetList.add(<br/>          { <br/>            "tweet" : "$entry.get('_source')['tweet']",<br/>            "tweet_id": "$entry.get('_id')",<br/>            "created_at": $entry.get('_source')['created_at']<br/>          })})<br/>          #set ($counter = $counter + 1)<br/>      #end<br/>          "items" : $util.toJson($tweetList),<br/>          "nextToken" : "$counter"<br/>   #end<br/>}</span></pre><p id="ccd3" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated"><strong class="kf hv">样本GraphQL查询</strong>:</p><pre class="jk jl jm jn fq oc od oe of aw og dt"><span id="7a20" class="nn ll hu od b fv oh oi l oj ok"><strong class="od hv">query</strong> {<br/>  <strong class="od hv">meInfo</strong>{                           <em class="ke"># DynamoDB</em><br/>    name                            <br/>    description                     <br/>    <strong class="od hv">favourites_count                </strong><em class="ke">#</em><strong class="od hv"><em class="ke"> </em></strong><em class="ke">Lambda</em><br/>    <strong class="od hv">tweets</strong>(limit:4, nextToken:"3"){ <em class="ke"># ElasticSearch</em><br/>      items{<br/>        tweet<br/>        tweet_id<br/>        created_at<br/>      }<br/>      nextToken<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl oo op hc oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="hn ho hp hq hr"><blockquote class="la"><p id="1c15" class="lb lc hu bd ld le mp mq mr ms mt ky ek translated">最后但同样重要的是…</p><p id="2352" class="lb lc hu bd ld le mp mq mr ms mt ky ek translated">最精彩的部分？要让订阅在后端工作，您只需用4行代码扩展您的GraphQL模式:</p></blockquote><pre class="ov ow ox oy oz oc od oe of aw og dt"><span id="5731" class="nn ll hu od b fv oh oi l oj ok">type Subscription {<br/>  addTweet: Tweet<br/>  @aws_subscribe(mutations: [“createTweet”]<br/>}</span></pre><p id="cd95" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">这段代码建立了一个<strong class="kf hv">订阅</strong>来监听每一个新的<a class="ae kz" href="https://github.com/serverless/serverless-graphql/blob/master/app-backend/appsync/dynamo-elasticsearch-lambda/schema.graphql#L4" rel="noopener ugc nofollow" target="_blank"><em class="ke">create tweet</em></a><strong class="kf hv"/>变异，一旦你的客户决定订阅这个订阅，它将会得到实时更新(在下一篇文章中会有更多相关内容😏)</p><h1 id="ce06" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">AppSync限制</h1><ol class=""><li id="d9f3" class="mz na hu kf b kg mc kj md me pa mg pb mi pc ky ne nf ng nh dt translated"><strong class="kf hv">陡峭的学习曲线<br/> </strong>使用AppSync需要很好地理解<a class="ae kz" href="http://velocity.apache.org/engine/1.7/vtl-reference.html" rel="noopener ugc nofollow" target="_blank"> VTL </a>。对于初学者，我会完全推荐<a class="ae kz" href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-programming-guide.html" rel="noopener ugc nofollow" target="_blank">这本指南</a>。但是，好消息是AWS提供了一系列的<a class="ae kz" href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html" rel="noopener ugc nofollow" target="_blank">助手和实用程序</a>来让我们的生活变得更加轻松。</li><li id="ed9f" class="mz na hu kf b kg ni kj nj me nk mg nl mi nm ky ne nf ng nh dt translated"><strong class="kf hv">缺少GraphQL信息对象<br/> </strong> AppSync目前没有在上下文变量中提供<a class="ae kz" href="https://blog.graph.cool/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a" rel="noopener ugc nofollow" target="_blank">信息对象</a>，这限制了它与其他开源GraphQL框架(如<a class="ae kz" href="https://github.com/graphcool/prisma" rel="noopener ugc nofollow" target="_blank"> Prisma </a>)集成的功能。</li><li id="06a3" class="mz na hu kf b kg ni kj nj me nk mg nl mi nm ky ne nf ng nh dt translated"><strong class="kf hv">缺少对DynamoDB批处理操作的支持<br/> </strong>截至目前，AppSync并不支持所有DynamoDB API，例如BatchGetItem或BatchPutItem</li></ol><p id="3995" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">AppSync正在积极地添加功能来简化无服务器的GraphQL体验，我很期待。</p><h1 id="3a48" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">接下来呢？</h1><p id="a641" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">在本系列的下一部分，我将详细解释迷你Twitter应用的前端组件，包括<strong class="kf hv"> AppSync客户端</strong>、<strong class="kf hv"> AWS Amplify </strong>、<strong class="kf hv"> React组件</strong>、<strong class="kf hv">突变</strong>乐观响应<strong class="kf hv">和<strong class="kf hv">离线支持</strong>、<strong class="kf hv">订阅</strong>、<strong class="kf hv">冲突解决</strong>等<em class="ke"> ( </em> <a class="ae kz" href="https://twitter.com/sidg_sid" rel="noopener ugc nofollow" target="_blank"> <em class="ke">敬请关注</em>🔈<em class="ke">)。</em></a></strong></p><p id="b133" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated"><em class="ke">该应用程序将看起来像这样:</em></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pd"><img src="../Images/bdc1664bef3760b39b44e603197804f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OWU4aeSN9BMBUwgd36q6Ng.gif"/></div></div></figure><h1 id="bc5c" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja mk jb lw jd ml je ly jg mm jh ma mb dt translated">特别感谢</h1><p id="e7f7" class="pw-post-body-paragraph kc kd hu kf b kg mc iv ki kj md iy kl me mf ko kp mg mh ks kt mi mj kw kx ky hn dt translated">首先，非常感谢<a class="mn mo gr" href="https://medium.com/u/ff3f225e7f5c?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank"> Nik Graf </a>在这个项目上的合作，她是一位优秀的导师，并帮助进行代码审查和实现。</p><p id="90a1" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">感谢<a class="mn mo gr" href="https://medium.com/u/a770eb52909c?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">菲利普</a>、<a class="ae kz" href="https://twitter.com/superpatell" rel="noopener ugc nofollow" target="_blank">乔恩</a>和<a class="ae kz" href="https://twitter.com/lolcoolkat" rel="noopener ugc nofollow" target="_blank"> LolCoolKat </a>为AppSync插件所做的努力。</p><p id="d15c" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">AWS移动团队(<a class="mn mo gr" href="https://medium.com/u/5342f0b850db?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">理查德</a>、<a class="mn mo gr" href="https://medium.com/u/1acf799d46d3?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">罗汉</a>、<a class="mn mo gr" href="https://medium.com/u/695782484bda?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">纳德</a>、<a class="ae kz" href="https://twitter.com/menyao" rel="noopener ugc nofollow" target="_blank">曼努埃尔</a>和<a class="mn mo gr" href="https://medium.com/u/a9d19754c17e?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">迈克尔</a>)帮助解决问题并密切合作解决问题和错误。</p><p id="b807" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">最后但同样重要的是，感谢每一个正在阅读这篇文章或鼓励我写更多的人。<strong class="kf hv">你的支持驱使我做出更多贡献</strong>😃 😍</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="pe pf l"/></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="pe pf l"/></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pg"><img src="../Images/61a6a0bb4602e701b700a6a192c31d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6P4Jfs24wHMWNs6_pih8g.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae kz" href="https://www.meetup.com/Serverless/events/245690042" rel="noopener ugc nofollow" target="_blank">Serverless and GraphQL Meetup</a> at Glassdoor, San Francisco attended by <a class="mn mo gr" href="https://medium.com/u/122d169c63c0?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">Graphcool</a>, <a class="mn mo gr" href="https://medium.com/u/10625560e1ed?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">Serverless</a>, <a class="mn mo gr" href="https://medium.com/u/47b3b199a712?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">Danielle</a>, <a class="mn mo gr" href="https://medium.com/u/ff3f225e7f5c?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">Nik</a>, <a class="mn mo gr" href="https://medium.com/u/1acf799d46d3?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">Rohan</a>, <a class="mn mo gr" href="https://medium.com/u/a9d19754c17e?source=post_page-----24c3bb5acb43--------------------------------" rel="noopener" target="_blank">Michael</a></figcaption></figure><p id="d91d" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">我想用我最喜欢的一句话来结束我的博客—</p><p id="4fbc" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl me kn ko kp mg kr ks kt mi kv kw kx ky hn dt translated">重要的是不要停止提问。好奇心有它存在的理由。”— 阿尔伯特·爱因斯坦</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ph pf l"/></div></figure></div></div>    
</body>
</html>