<html>
<head>
<title>Objection + Knex = Painless PostgreSQL in your Node App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Objection + Knex =您的节点应用程序中的无痛PostgreSQL</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/objection-knex-painless-postgresql-in-your-node-app-6c21e2703ac6?source=collection_archive---------9-----------------------#2018-02-20">https://medium.com/hackernoon/objection-knex-painless-postgresql-in-your-node-app-6c21e2703ac6?source=collection_archive---------9-----------------------#2018-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="60dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">众所周知，我是一个完全的PostgreSQL迷——我很少看到使用不同数据库的用例，尤其是在支持数组和JSON字段的情况下。我也喜欢简单API的Node和Express(没有auth)。过去，Node和Express中的SQL支持并不完善。我一直听说<a class="ae jp" href="https://vincit.github.io/objection.js" rel="noopener ugc nofollow" target="_blank">异议</a>的好处，所以我决定尝试一下！</p><p id="a509" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Objection构建在<a class="ae jp" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex </a>之上，使用新的ES7类特性为Node构建了一个不错的ORM查询语言。ORMs允许您使用您的应用程序正在使用的任何编程语言来查询数据库，而不是使用数据库的natie语言进行查询(这里我们将使用JavaScript而不是SQL来与我们的数据库进行交互)。由于异议仍然是新的，我将一步一步地检查我的所有代码。</p><h1 id="c1ee" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">学习过程</h1><p id="8571" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于这个项目，我完全依赖于文档。Knex文档非常棒，Objection GitHub上的<a class="ae jp" href="https://github.com/Vincit/objection.js/tree/master/examples/express-es6" rel="noopener ugc nofollow" target="_blank">示例</a>也非常有用。由于我制作了如此多的Express应用程序，鉴于我向我的学生广泛教授Express，在浏览了这些资源后，我对继续这个项目感到非常舒服。</p><h1 id="553d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">最终项目</h1><p id="7fe9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我一直很难想出这个博客的应用程序创意！于是，我建了一个app idea app！模型相对简单:<code class="eh kt ku kv kw b">ideas</code>和<code class="eh kt ku kv kw b">comments</code>，但是它们仍然展示了异议的最大用例之一:数据之间的关系。<code class="eh kt ku kv kw b">ideas</code>将是附加了“孩子”注释的“父母”。本质上，用户将能够对各种应用的想法发表评论。</p><h2 id="4645" class="kx jr hu bd js ky kz la jw lb lc ld ka jc le lf ke jg lg lh ki jk li lj km lk dt translated">Knex初始化</h2><p id="f785" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">首先，我初始化了Knex，它将使用<code class="eh kt ku kv kw b">pg</code>、我们的迁移和种子来促进我们的数据库连接。在我的<a class="ae jp" href="https://github.com/aspittel/app-ideas/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">索引文件</a>中设置了典型的Express API样板文件，并在我的<a class="ae jp" href="https://github.com/aspittel/app-ideas/blob/master/package.json" rel="noopener ugc nofollow" target="_blank"> package.json </a>中安装了需求之后，我在我的项目的根目录中运行了<code class="eh kt ku kv kw b">knex init</code>。这创建了一个<code class="eh kt ku kv kw b">knexfile.js</code>,其中包含一个样板文件，带有到数据库的示例连接。我决定删除<code class="eh kt ku kv kw b">production</code>、<code class="eh kt ku kv kw b">development</code>和<code class="eh kt ku kv kw b">staging</code>选项，只在我的<code class="eh kt ku kv kw b">.env</code>文件中指定一个数据库连接字符串。<code class="eh kt ku kv kw b">knexfile</code>最后看起来像:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="bf8d" class="kx jr hu kw b fv lt lu l lv lw">require('dotenv').config()</span><span id="cecd" class="kx jr hu kw b fv lx lu l lv lw">const pg = require('pg')<br/>pg.defaults.ssl = true</span><span id="2f60" class="kx jr hu kw b fv lx lu l lv lw">module.exports = {<br/>  client: 'pg',<br/>  connection: process.env.DATABASE_URL<br/>}</span></pre><p id="3a6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只有在Heroku或其他需要SSL连接的提供商上使用数据库时，才需要<code class="eh kt ku kv kw b">ssl</code>配置。<code class="eh kt ku kv kw b">dotenv</code>允许我们从<code class="eh kt ku kv kw b">.env</code>文件中检索环境变量！该变量是标准的PostgreSQL连接字符串:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="211d" class="kx jr hu kw b fv lt lu l lv lw">DATABASE_URL=postgres://username:password@host:port/db_name</span></pre><p id="2ab0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在我的电脑上用<code class="eh kt ku kv kw b">psql</code>创建了数据库，我用<a class="ae jp" href="https://elements.heroku.com/addons/heroku-postgresql" rel="noopener ugc nofollow" target="_blank"> Heroku插件</a>创建了生产数据库。</p><h2 id="131f" class="kx jr hu bd js ky kz la jw lb lc ld ka jc le lf ke jg lg lh ki jk li lj km lk dt translated">迁移</h2><p id="c4ea" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">迁移是对ORM中指定的数据库模式的更改，所以我们将直接用JavaScript定义数据库的表和列，而不是使用SQL。</p><p id="92ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从那里，我生成了我的迁移:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="3394" class="kx jr hu kw b fv lt lu l lv lw">$ knex migrate:make create_ideas<br/>$ knex migrate:make create_comments</span></pre><p id="04f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个迁移命令都在<code class="eh kt ku kv kw b">migrations</code>文件夹中创建了自己单独的文件。Knex还为每个迁移添加了一个时间戳，以便迁移名称是惟一的并且按顺序运行，例如:migrations/20180218215453 _ create _ ideas . js。不过，这些可以结合起来。</p><p id="6e31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">迁移是通过以下方式生成的:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="0efc" class="kx jr hu kw b fv lt lu l lv lw">exports.up = function (knex, Promise) {<br/>}</span><span id="32a6" class="kx jr hu kw b fv lx lu l lv lw">exports.down = function (knex, Promise) {<br/>}</span></pre><p id="aaf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">迁移本身在<code class="eh kt ku kv kw b">exports.up</code>函数体内进行，然后与迁移相反的事情在<code class="eh kt ku kv kw b">exports.down</code>内进行。<code class="eh kt ku kv kw b">exports.down</code>允许我们撤销不再需要的迁移。对于<code class="eh kt ku kv kw b">create_ideas</code>迁移，我添加了以下内容:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="95d8" class="kx jr hu kw b fv lt lu l lv lw">exports.up = function (knex, Promise) {<br/>  return Promise.all([<br/>    knex.schema.createTable('ideas', table =&gt; {<br/>      table.increments('id').primary()<br/>      table.string('idea')<br/>      table.string('creator')<br/>    })<br/>  ])<br/>}</span><span id="4017" class="kx jr hu kw b fv lx lu l lv lw">exports.down = function (knex, Promise) {<br/>  return Promise.all([<br/>    knex.schema.dropTable('ideas')<br/>  ])<br/>}</span></pre><p id="9732" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据它的文档，Knex迁移函数应该“总是返回一个承诺”。我们可以使用<code class="eh kt ku kv kw b">Promise.all()</code>来返回一组要解决的承诺。即使在这种情况下每个函数只有一个动作，我也可以添加更多由<code class="eh kt ku kv kw b">,</code>分隔的动作。<code class="eh kt ku kv kw b">exports.up</code>包含了<code class="eh kt ku kv kw b">ideas</code>表的表创建逻辑，包括一个自动递增的主键<code class="eh kt ku kv kw b">table.increments('id').primary()</code>。它还有另外两个名为<code class="eh kt ku kv kw b">idea</code>和<code class="eh kt ku kv kw b">creator</code>的字符串列。为了撤销迁移，我们将删除<code class="eh kt ku kv kw b">ideas</code>表，如<code class="eh kt ku kv kw b">exports.down</code>函数中所指定的。</p><p id="f4c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建<code class="eh kt ku kv kw b">comments</code>文件的第二次迁移是类似的:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="8748" class="kx jr hu kw b fv lt lu l lv lw">exports.up = function (knex, Promise) {<br/>  return Promise.all([<br/>    knex.schema.createTable('comments', table =&gt; {<br/>      table.increments('id').primary()<br/>      table.string('comment')<br/>      table.string('creator')<br/>      table.integer('ideas_id').references('ideas.id')<br/>    })<br/>  ])<br/>}</span><span id="a24f" class="kx jr hu kw b fv lx lu l lv lw">exports.down = function (knex, Promise) {<br/>  return Promise.all([<br/>    knex.schema.dropTable('comments')<br/>  ])<br/>}</span></pre><p id="256d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个迁移看起来与<code class="eh kt ku kv kw b">ideas</code>非常相似，唯一的区别是外键:<code class="eh kt ku kv kw b">table.integer('ideas_id').references('ideas.id')</code>。在文档中有许多方法可以做到这一点；然而，异议文档是这样做的，所以我也这样做了。Knex强制使用列名<code class="eh kt ku kv kw b">ideas_id</code>,而不是没有意义的<code class="eh kt ku kv kw b">idea_id</code>。我确信有一种方法可以绕过命名规定；但是，我并没有花多大力气去查！</p><p id="532d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我使用以下命令运行迁移:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="4df6" class="kx jr hu kw b fv lt lu l lv lw">$ knex migrate:latest</span></pre><p id="a23c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管该命令暗示它只运行最新的迁移，但它会运行所有尚未运行的迁移。</p><h2 id="6171" class="kx jr hu bd js ky kz la jw lb lc ld ka jc le lf ke jg lg lh ki jk li lj km lk dt translated">数据库播种</h2><p id="e619" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Knex也有一些内置的功能来帮助我们播种，或者添加初始测试数据到我们的数据库中。</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="caae" class="kx jr hu kw b fv lt lu l lv lw">$ knex seed:make ideas</span></pre><p id="b3c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的命令创建了一个包含一个<code class="eh kt ku kv kw b">ideas.js</code>文件的<code class="eh kt ku kv kw b">seeds</code>目录。该文件还包含以下代码:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="ed4f" class="kx jr hu kw b fv lt lu l lv lw">exports.seed = function (knex, Promise) {<br/>}</span></pre><p id="30e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我补充了以下内容:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="ca01" class="kx jr hu kw b fv lt lu l lv lw">exports.seed = function (knex, Promise) {<br/>  return knex('ideas').del().then(() =&gt; {<br/>    return knex('ideas').insert([<br/>        {creator: 'Ali', idea: 'A To Do List app!'},<br/>        {creator: 'Ali', idea: 'A Blog!'},<br/>        {creator: 'Ali', idea: 'A calculator'}<br/>    ])<br/>  })<br/>}</span></pre><p id="845c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这清除了<code class="eh kt ku kv kw b">ideas</code>表，所以表中没有任何数据，然后它向数据库中插入三条记录。它使用JSON键和值来创建这些行。我只植入了<code class="eh kt ku kv kw b">ideas</code>表，但是你也可以植入<code class="eh kt ku kv kw b">comments</code>表！</p><p id="abc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我运行以下命令来更新数据库:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="454d" class="kx jr hu kw b fv lt lu l lv lw">$ knex seed:run</span></pre><h2 id="d6c3" class="kx jr hu bd js ky kz la jw lb lc ld ka jc le lf ke jg lg lh ki jk li lj km lk dt translated">模型</h2><p id="ab55" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">到目前为止，我们一直使用Knex与我们的数据库进行交互。现在，我们将使用Objection创建一些模型，以便处理我们的数据库表之间的关系，并使我们的查询更加明确！我创建了一个<code class="eh kt ku kv kw b">models</code>文件夹，里面有一个<code class="eh kt ku kv kw b">schema.js</code>文件。无论如何，您都可以构建这个模型——一个好方法是将每个模型放在不同的文件中。不过，为了演示起见，我把所有东西都放在一起了！</p><p id="f000" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们处理一些高层的管理事务:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="1ed9" class="kx jr hu kw b fv lt lu l lv lw">const Knex = require('knex')<br/>const connection = require('../knexfile')<br/>const { Model } = require('objection')</span><span id="167e" class="kx jr hu kw b fv lx lu l lv lw">const knexConnection = Knex(connection)</span><span id="d97e" class="kx jr hu kw b fv lx lu l lv lw">Model.knex(knexConnection)</span></pre><p id="24a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些代码行使用前面的<code class="eh kt ku kv kw b">knexfile</code>将我们连接到数据库。我们也对我们的数据库连接提出异议。</p><p id="11d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们为我们的<code class="eh kt ku kv kw b">Comment</code>数据创建模型。这些模型将允许我们与从数据库中检索的数据进行干净的交互。</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="13fc" class="kx jr hu kw b fv lt lu l lv lw">class Comment extends Model {<br/>  static get tableName () {<br/>    return 'comments'<br/>  }</span><span id="84ae" class="kx jr hu kw b fv lx lu l lv lw">  static get relationMappings () {<br/>    return {<br/>      idea: {<br/>        relation: Model.BelongsToOneRelation,<br/>        modelClass: Idea,<br/>        join: {<br/>          from: 'comments.ideas_id',<br/>          to: 'ideas.id'<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="4af2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来分析一下。静态getter方法<code class="eh kt ku kv kw b">tableName</code>返回名称<code class="eh kt ku kv kw b">comments</code>:我们希望我们的<code class="eh kt ku kv kw b">Comment</code>类建模的数据库表的名称！我们还有第二个静态getter方法，它定义了<code class="eh kt ku kv kw b">Comment</code>模型与其他模型的关系。在这种情况下，外部对象<code class="eh kt ku kv kw b">idea</code>的关键是我们将如何引用父类。子对象中的<code class="eh kt ku kv kw b">relation</code>键具有值<code class="eh kt ku kv kw b">Model.BelongsToOneRelation</code>，这表示每个评论将有一个父想法。<code class="eh kt ku kv kw b">modelClass</code>表示<code class="eh kt ku kv kw b">idea</code>来自于<code class="eh kt ku kv kw b">Idea</code>模型，然后<code class="eh kt ku kv kw b">join</code>指定数据库表和列名来执行SQL连接，在本例中，是从<code class="eh kt ku kv kw b">comments</code>表中的<code class="eh kt ku kv kw b">ideas_id</code>列到<code class="eh kt ku kv kw b">ideas</code>表中的<code class="eh kt ku kv kw b">id</code>列。ES6中增加了<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static" rel="noopener ugc nofollow" target="_blank">静态</a>和<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" rel="noopener ugc nofollow" target="_blank">获取</a>！</p><p id="62f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Idea类看起来几乎完全相同，尽管关系是颠倒的！</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="e0e3" class="kx jr hu kw b fv lt lu l lv lw">class Idea extends Model {<br/>  static get tableName () {<br/>    return 'ideas'<br/>  }</span><span id="9675" class="kx jr hu kw b fv lx lu l lv lw">  static get relationMappings () {<br/>    return {<br/>      comments: {<br/>        relation: Model.HasManyRelation,<br/>        modelClass: Comment,<br/>        join: {<br/>          from: 'ideas.id',<br/>          to: 'comments.ideas_id'<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span><span id="0ffd" class="kx jr hu kw b fv lx lu l lv lw">module.exports = { Idea, Comment }</span></pre><p id="72ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，我们的关系是<code class="eh kt ku kv kw b">Model.HasManyRelation</code>,因为一个想法可以有多个评论！我还导出了模型，以便它们可以在我们的其他文件中使用。</p><h2 id="a714" class="kx jr hu bd js ky kz la jw lb lc ld ka jc le lf ke jg lg lh ki jk li lj km lk dt translated">询问</h2><p id="e899" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我处理的最后一个文件是<code class="eh kt ku kv kw b">controllers/ideas.js</code>。我通常将我所有的“控制器”功能——决定每条路线呈现什么的路由功能——分离到一个或多个文件中，如果有很多文件的话！本周，我构建了一个API，我将在未来为它构建一个前端。</p><p id="a80f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，一些进口:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="6857" class="kx jr hu kw b fv lt lu l lv lw">const express = require('express')</span><span id="362b" class="kx jr hu kw b fv lx lu l lv lw">const { Idea, Comment } = require('../models/schema')</span><span id="7c32" class="kx jr hu kw b fv lx lu l lv lw">const router = express.Router()</span></pre><p id="f754" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一下第一个方法，一个get请求返回所有的<code class="eh kt ku kv kw b">ideas</code>:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="ddac" class="kx jr hu kw b fv lt lu l lv lw">router.get('/', async (req, res) =&gt; {<br/>  const ideas = await Idea.query()<br/>  res.json(ideas)<br/>})</span></pre><p id="f91a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，我们使用<code class="eh kt ku kv kw b">async</code>让arrow函数回调异步处理请求和响应，然后我们可以“暂停”函数体，直到来自我们的<code class="eh kt ku kv kw b">Idea.query()</code>的承诺解决。该查询将使用我们的<code class="eh kt ku kv kw b">res.json(ideas)</code>方法返回一个包含我们的<code class="eh kt ku kv kw b">ideas</code>表中所有项目的JavaScript对象。如果我们导航到本地的<code class="eh kt ku kv kw b">localhost:3000/ideas</code>或生产中的<code class="eh kt ku kv kw b">https://application-ideas.herokuapp.com/ideas</code>,我们会看到:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="45c8" class="kx jr hu kw b fv lt lu l lv lw">[<br/>    {<br/>        "id": 1,<br/>        "idea": "A To Do List app!",<br/>        "creator": "Ali"<br/>    },<br/>    {<br/>        "id": 2,<br/>        "idea": "A Blog!",<br/>        "creator": "Ali"<br/>    },<br/>    {<br/>        "id": 3,<br/>        "idea": "A calculator",<br/>        "creator": "Ali"<br/>    }<br/>]</span></pre><p id="76f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:异议文档使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> async和await </a>来处理JavaScript中的<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>；然而，我们可以重写上面的函数，使其看起来像下面这样，这也同样有效！</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="503d" class="kx jr hu kw b fv lt lu l lv lw">router.get('/', (req, res) =&gt; {<br/>  Idea.query().then(ideas =&gt; {<br/>    res.json(ideas)<br/>  })<br/>})</span></pre><p id="bab8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会以段落的形式介绍其他路线，而是将带注释的代码放在下面:</p><pre class="ll lm ln lo fq lp kw lq lr aw ls dt"><span id="dc40" class="kx jr hu kw b fv lt lu l lv lw">router.get('/:id', async (req, res) =&gt; {<br/>  // gets one idea, found by id.<br/>  //Also fetches the related comments using the .eager method<br/>  const idea = await Idea.query().findById(req.params.id).eager('comments')<br/>  res.json(idea)<br/>})</span><span id="86aa" class="kx jr hu kw b fv lx lu l lv lw">router.post('/', async (req, res) =&gt; {<br/>  // creates a new idea from the request body<br/>  // only allows the idea and creator fields for safety<br/>  const newIdea = req.body</span><span id="5d96" class="kx jr hu kw b fv lx lu l lv lw">  const idea = await Idea.query()<br/>                         .allowInsert('[idea, creator]')<br/>                         .insert(newIdea)</span><span id="04ed" class="kx jr hu kw b fv lx lu l lv lw">  res.send(idea)<br/>})</span><span id="68ba" class="kx jr hu kw b fv lx lu l lv lw">router.post('/:id/comments', async (req, res) =&gt; {<br/>  // creates a new comment that is a child of an idea, again sanitizes fields.<br/>  const idea = await Idea.query().findById(req.params.id)</span><span id="cac5" class="kx jr hu kw b fv lx lu l lv lw">  await idea.$relatedQuery('comments')<br/>            .allowInsert('[comment, creator]')<br/>            .insert(req.body)</span><span id="d5f7" class="kx jr hu kw b fv lx lu l lv lw">  res.send(idea)<br/>})</span><span id="1c58" class="kx jr hu kw b fv lx lu l lv lw">router.delete('/:id', async (req, res) =&gt; {<br/>  // deletes an idea<br/>  await Idea.query().deleteById(req.params.id)</span><span id="bec6" class="kx jr hu kw b fv lx lu l lv lw">  res.redirect('/ideas')<br/>})</span><span id="0da6" class="kx jr hu kw b fv lx lu l lv lw">router.delete('/:id/comments/:commentId', async (req, res) =&gt; {<br/>  // deletes a comment<br/>  await Comment.query().deleteById(req.params.commentId)</span><span id="f8ed" class="kx jr hu kw b fv lx lu l lv lw">  res.redirect(`/ideas/${req.params.id}`)<br/>})</span><span id="2066" class="kx jr hu kw b fv lx lu l lv lw">module.exports = router</span></pre><p id="b2fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于异议，您可以做更多的事情，比如<a class="ae jp" href="http://vincit.github.io/objection.js/#raw-queries" rel="noopener ugc nofollow" target="_blank">原始查询</a>，与<a class="ae jp" href="http://vincit.github.io/objection.js/#json-queries" rel="noopener ugc nofollow" target="_blank"> JSON字段的交互</a>，以及<a class="ae jp" href="http://vincit.github.io/objection.js/#validation" rel="noopener ugc nofollow" target="_blank">验证</a>。</p><h1 id="80d5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">后续步骤</h1><p id="bc3c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我和Objection和Knex一起工作真的很开心！老实说，从配置的角度来看，它非常类似于使用Mongoose和MongoDB，但是它使得层次结构和相关数据更容易处理！我肯定会在未来的Express应用程序中继续使用这些库！如果您经常使用Node，这绝对是一个必须尝试的方法！</p><p id="ef2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/aspittel/app-ideas" rel="noopener ugc nofollow" target="_blank">全代码</a> <br/> <a class="ae jp" href="https://application-ideas.herokuapp.com/ideas" rel="noopener ugc nofollow" target="_blank">已部署App </a> <br/> <a class="ae jp" href="http://vincit.github.io/objection.js" rel="noopener ugc nofollow" target="_blank">异议文档</a> <br/> <a class="ae jp" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex文档</a></p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="4eb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mf">如果你喜欢这篇文章，请</em> <a class="ae jp" href="https://tinyletter.com/ali_writes_code" rel="noopener ugc nofollow" target="_blank"> <em class="mf">订阅</em> </a> <em class="mf">我的每周简讯，在那里你会收到本周我最喜欢的链接和我的最新文章。</em></p></div></div>    
</body>
</html>