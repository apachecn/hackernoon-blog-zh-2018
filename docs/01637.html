<html>
<head>
<title>Accessing Nested Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中访问嵌套对象</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/accessing-nested-objects-in-javascript-f02f1bd6387f?source=collection_archive---------1-----------------------#2018-02-21">https://medium.com/hackernoon/accessing-nested-objects-in-javascript-f02f1bd6387f?source=collection_archive---------1-----------------------#2018-02-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/994546f80689ce68f3111338c73ebaf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iMj9w69n5RD9c7R5.jpg"/></div></div></figure><p id="72d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">tldr；</strong> <em class="ka">以超级酷的方式安全访问JavaScript中的嵌套对象。</em></p><p id="ec4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JavaScript很神奇，我们都知道。但是JavaScript中的一些东西真的很奇怪，让我们摸不着头脑。其中之一就是当您试图访问一个嵌套对象时会遇到这个错误，</p><p id="438e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ka">无法读取未定义</em> </strong>的属性‘foo’</p><p id="aaa2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数情况下，当我们使用JavaScript时，我们会处理嵌套对象，并且经常需要安全地访问最内层的嵌套值。</p><p id="c35e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们以这个嵌套对象为例。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f60b" class="kk kl hu kg b fv km kn l ko kp">const user = {<br/>    id: 101,<br/>    email: 'jack@dev.com',<br/>    personalInfo: {<br/>        name: 'Jack',<br/>        address: {<br/>            line1: 'westwish st',<br/>            line2: 'washmasher',<br/>            city: 'wallas',<br/>            state: 'WX'<br/>        }<br/>    }<br/>}</span></pre><p id="a66f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要访问我们用户的名字，我们要写</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e589" class="kk kl hu kg b fv km kn l ko kp">const name = user.personalInfo.name;<br/>const userCity = user.personalInfo.address.city;</span></pre><p id="8513" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这既简单又直接。</p><p id="1f28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，由于某种原因，如果我们的用户的个人信息不可用，对象结构将是这样的，</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c827" class="kk kl hu kg b fv km kn l ko kp">const user = {<br/>    id: 101,<br/>    email: 'jack@dev.com'<br/>}</span></pre><p id="20a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在如果你尝试访问这个名字，你会被抛出<em class="ka">无法读取未定义</em>的属性‘name’。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="406d" class="kk kl hu kg b fv km kn l ko kp">const name = user.personalInfo.name; // Cannot read property 'name' of undefined</span></pre><p id="df6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是因为我们试图从一个不存在的对象访问<code class="eh kq kr ks kg b">name</code>键。</p><p id="92b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数开发人员处理这种情况的通常方式是，</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e27d" class="kk kl hu kg b fv km kn l ko kp">const name = user &amp;&amp; user.personalInfo ? user.personalInfo.name : null;<br/>// undefined error will NOT be thrown as we check for existence before access</span></pre><p id="07b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你的嵌套结构很简单，这是可以的，但是如果你的数据嵌套了5或6层，那么你的代码看起来会很乱，</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="182a" class="kk kl hu kg b fv km kn l ko kp">let city;<br/>if (<br/>    data &amp;&amp; data.user &amp;&amp; data.user.personalInfo &amp;&amp;<br/>    data.user.personalInfo.addressDetails &amp;&amp;<br/>    data.user.personalInfo.addressDetails.primaryAddress<br/>   ) {<br/>    city = data.user.personalInfo.addressDetails.primaryAddress;<br/>}</span></pre><p id="d932" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一些技巧可以处理这种混乱的对象结构。</p><h1 id="0b63" class="kt kl hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">奥利弗·斯蒂尔的嵌套对象访问模式</h1><p id="9922" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">这是我个人最喜欢的，因为它让代码看起来<em class="ka">干净</em>和<em class="ka">简单</em>。我不久前从stackoverflow中挑选了这种风格，一旦你理解了它是如何工作的，它就非常吸引人。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c71b" class="kk kl hu kg b fv km kn l ko kp">const name = ((user || {}).personalInfo || {}).name;</span></pre><p id="2934" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用这种符号，你永远不会遇到<em class="ka">无法读取未定义</em>的属性‘name’。你基本上检查用户是否存在，如果不存在，你创建一个空的对象。这样，下一级键<strong class="je hv">将总是从一个已存在的对象或一个空对象</strong>中被访问，而不是从未定义的对象中被访问。</p><p id="406f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，<strong class="je hv">你不能用这个技巧访问嵌套数组</strong></p><h1 id="fb22" class="kt kl hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">使用Array Reduce访问嵌套对象</h1><p id="318b" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">Array reduce方法非常强大，可以用来安全地访问嵌套对象。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="7974" class="kk kl hu kg b fv km kn l ko kp">const getNestedObject = (nestedObj, pathArr) =&gt; {<br/>    return pathArr.reduce((obj, key) =&gt;<br/>        (obj &amp;&amp; obj[key] !== 'undefined') ? obj[key] : undefined, nestedObj);<br/>}</span><span id="be92" class="kk kl hu kg b fv lv kn l ko kp">// pass in your object structure as array elements<br/>const name = getNestedObject(user, ['personalInfo', 'name']);</span><span id="f7a8" class="kk kl hu kg b fv lv kn l ko kp">// to access nested array, just pass in array index as an element the path array.<br/>const city = getNestedObject(user, ['personalInfo', 'addresses', 0, 'city']);<br/>// this will return the city from the first address item.</span></pre><h1 id="7b71" class="kt kl hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">类型</h1><p id="db1c" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">如果你认为以上方法有点太主流，那么你应该试试我写的<a class="ae lw" href="https://github.com/flexdinesh/typy" rel="noopener ugc nofollow" target="_blank"> Typy </a>库。除了安全地访问嵌套对象，它还做了许多更棒的事情。🎉</p><p id="fdfb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它以npm包的形式提供— <a class="ae lw" href="https://www.npmjs.com/package/typy" rel="noopener ugc nofollow" target="_blank">类型</a></p><p id="4820" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您使用<strong class="je hv"> Typy </strong>，您的代码将如下所示:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e8ac" class="kk kl hu kg b fv km kn l ko kp">import t from 'typy';</span><span id="6345" class="kk kl hu kg b fv lv kn l ko kp">const name = t(user, 'personalInfo.name').safeObject;<br/>const city = t(user, 'personalInfo.addresses[0].city').safeObject;<br/>// address is an array</span></pre><p id="9b2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有一些像Lodash和Ramda这样的库可以做到这一点。但是在轻量级的前端项目中，特别是如果您只需要这些库中的一两个方法，选择一个替代的轻量级库是个好主意，或者更好的是，编写您自己的库。</p><p id="ea0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Happy安全访问JavaScript中的嵌套对象’！💥</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure></div></div>    
</body>
</html>