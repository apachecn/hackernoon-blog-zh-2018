<html>
<head>
<title>Building a Node.js Powered API with Express, Mongoose &amp; MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express、Mongoose和MongoDB构建Node.js驱动的API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-node-js-powered-api-with-express-mongoose-mongodb-19b14fd4b51e?source=collection_archive---------5-----------------------#2018-02-22">https://medium.com/hackernoon/building-a-node-js-powered-api-with-express-mongoose-mongodb-19b14fd4b51e?source=collection_archive---------5-----------------------#2018-02-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/435ce4761223958c3d840eac06bf56a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zCYKPAR4IiaO3aWM.jpeg"/></div></div></figure><p id="f127" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一名在<a class="ae ka" href="https://getstream.io" rel="noopener ugc nofollow" target="_blank"> Stream </a>工作的开发人员，我最喜欢的工作之一就是构建示例应用程序。这是一种吸引潜在和现有客户并与之互动的方式，也是展示我们每天使用和构建的有趣技术的方式。我构建的应用程序范围很广，从概述如何执行基本操作的小代码片段，如在流中将项目标记为“已读”，到基于大型微服务的应用程序，这些应用程序通常需要健壮的后端架构，如<a class="ae ka" href="https://github.com/GetStream/Winds" rel="noopener ugc nofollow" target="_blank"> Winds </a>。</p><p id="9230" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">去年，我写了一篇关于<a class="ae ka" rel="noopener" href="/@nparsons08/in-depth-guide-on-building-a-rest-api-with-node-js-restify-mongodb-a8e92efbb50f">如何用Restify </a>构建RESTful API的文章。现在<a class="ae ka" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>和<a class="ae ka" href="http://restify.com/" rel="noopener ugc nofollow" target="_blank"> Restify </a>在每秒请求数方面几乎与<a class="ae ka" href="https://raygun.com/blog/node-js-performance-2017/" rel="noopener ugc nofollow" target="_blank">并驾齐驱</a>，我想向您展示我如何用<em class="kb"> Express </em>构建我的API可能会很有趣(只是为了加入一点友好的竞争/扮演魔鬼操纵者的拥护者😉).</p><h2 id="1f2a" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">构建您的API</h2><p id="14b0" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">您选择构建API的方式是您将做出的最重要的决定之一。你必须确保它的智能、灵活和易用——这是<strong class="je hv">必须</strong>做的事情。如果它不容易使用，其他开发人员将不会理解你在构建什么，也不会知道如何在它的基础上构建。建之前先思考(我知道。计划糟透了。尤其是当你兴奋地想要开始的时候，但是这是值得的。</p><p id="912a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">├── build.sh <br/> ├──区<br/>│├──…<br/>├──package . JSON<br/>├──src<br/>│├──config<br/>│└──index . js<br/>│├──控制器<br/>│├──<br/>│├──型号<br/>│├──<br/>│├──package . JSON<br/>│├──型号<br/>。</p><p id="ad8f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有源代码都存储在<strong class="je hv"> /src </strong>中。它从ES6+到ES5向下编译到<strong class="je hv"> /dist </strong>目录中，以便在服务器上执行。你可能会问自己，为什么要多花一步去写一些将要被编译下来的东西？好问题。ES6+标准提供了一些非常棒的附加功能，比如箭头函数、修改的作用域、析构、rest/spread参数处理，以及更多的！</p><p id="a817" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看看发生在<strong class="je hv"> build.sh </strong>文件中的编译:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="9d5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是你需要能够用一种超级棒的语言来写，同时在所有通常的地方仍然被支持的全部！也就是说，上面的代码可能看起来像是乱码，所以让我们来分解一下🤓：</p><ol class=""><li id="96ab" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated">#!/bin/bash</li></ol><ul class=""><li id="742c" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz lr lo lp lq dt translated">表示这是一个可执行的bash文件</li></ul><p id="5c86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.rm -rf距离和mkdir距离</p><ul class=""><li id="e890" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz lr lo lp lq dt translated">删除<strong class="je hv"> /dist </strong>目录(如果存在的话)(清理)。</li><li id="e6b9" class="li lj hu je b jf ls jj lt jn lu jr lv jv lw jz lr lo lp lq dt translated">创建一个新的<strong class="je hv"> /dist </strong>目录。</li></ul><p id="ee98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3.npx babel src —输出方向—忽略节点模块</p><ul class=""><li id="6958" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz lr lo lp lq dt translated">将每个文件编译到ES5，并将文件移动到<strong class="je hv"> /dist </strong>目录，除了<strong class="je hv"> node_modules </strong>(那些已经被编译)。</li></ul><p id="c062" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">4.cp src/package.json dist</p><ul class=""><li id="5386" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz lr lo lp lq dt translated">按照设计，npx不迁移json文件，所以我们需要使用<strong class="je hv"> cp </strong>命令自己复制它。</li></ul><p id="5442" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">5.cd分配和纱线安装—生产—模块—文件夹节点_模块</p><p id="95d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">进入<strong class="je hv"> /dist </strong>目录，使用<a class="ae ka" href="https://yarnpkg.com/en/" rel="noopener ugc nofollow" target="_blank">线</a>安装npm模块</p><p id="1fcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行构建就像从终端运行以下命令一样简单:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="326d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="kb">注意:</em> </strong> <em class="kb">你需要确保build.sh文件是可执行的……<br/></em><br/>或者如果你像我一样喜欢自动化<em class="kb">一切</em>，你可以创建一个npm脚本，如下所示:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="a309" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可以通过在终端上运行以下命令来执行:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><h2 id="7a67" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">主文件</h2><p id="3845" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">下面的文件<strong class="je hv"> server.js </strong>，包含了最重要的逻辑，位于我们代码库的顶层。开始部分导入所有必要的npm模块，随后是我们的<strong class="je hv">配置</strong>和<strong class="je hv">记录器实用程序</strong>。</p><p id="2a30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们利用Express <strong class="je hv"> use </strong>方法来调用我们导入的几个中间件库(<a class="ae ka" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"> cors </a>、<a class="ae ka" href="https://www.npmjs.com/package/compression" rel="noopener ugc nofollow" target="_blank"> compression </a>和我们的<a class="ae ka" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> body-parser </a>)。**请注意* *，我们还为附加功能(例如电子邮件、日志、jwt身份验证等)提供了其他几个中间件库。).最后但同样重要的是，在一点初始化之后，我们动态地包含所有路由，并将<strong class="je hv"> API </strong>上下文传递给路由进行绑定。</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="85d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="kb">注:</em> </strong> <em class="kb">客户日志模块可用于大多数日志服务(</em><a class="ae ka" href="https://papertrailapp.com/" rel="noopener ugc nofollow" target="_blank"><em class="kb">paper trail</em></a><em class="kb">、</em><a class="ae ka" href="https://www.loggly.com/" rel="noopener ugc nofollow" target="_blank"><em class="kb">Loggly</em></a><em class="kb">等)。).对于这个演示，以及其他项目，我喜欢使用Papertrail。如果您使用Papertrail以外的东西，可能需要调整设置和ENV变量。</em></p><h2 id="fb54" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">按指定路线发送</h2><p id="99cf" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">为了保持整洁有序，所有路由逻辑(例如GET /users)都保存在自己的路由文件中，该文件位于<strong class="je hv"> /routes </strong>目录下。</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="7932" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您所看到的，上面的route文件的内容保存了对控制器的所有引用，用于<strong class="je hv">获取</strong>、<strong class="je hv">发布</strong>、<strong class="je hv">放置</strong>和<strong class="je hv">删除</strong>操作。这是因为我们导入并引用了<strong class="je hv">用户</strong> <strong class="je hv">控制器</strong>，通过<em class="kb">传递每个</em> API调用所需的参数和/或数据。</p><h2 id="7a04" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">控制器</h2><p id="bbb4" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">管制员包括与他们将要处理的数据相关联的数据库模型，从路线接收数据，然后就如何处理数据做出明智的决定。最后，控制器通过与数据库对话的模型进行通信，并返回一个带有有效负载的状态代码。</p><p id="0cab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你是一个视觉型的人，一个生产实例应该看起来像这样:</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lx"><img src="../Images/479712fa2a57b9bdfc85e1246ab9df98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YVpHqqvbP-lnWDf1.png"/></div></div></figure><p id="e9e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例用户控制器的代码如下所示:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><h2 id="3c49" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">猫鼬模型(MongoDB)</h2><p id="11a2" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated"><a class="ae ka" href="http://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>是Node.js和<a class="ae ka" href="http://mbsy.co/mongodb/228644" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>的精彩ODM(对象数据建模)库。如果你熟悉Node.js的参考ORM(对象资源映射)和库，比如<a class="ae ka" href="http://docs.sequelizejs.com/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>和<a class="ae ka" href="http://bookshelfjs.org/" rel="noopener ugc nofollow" target="_blank"> Bookshelf </a>，Mongoose相当简单。Mongoose的最大好处是构造MongoDB模式非常容易——不需要为定制的业务逻辑操心。</p><p id="acf6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更令人兴奋的是许多好东西，如中间件、<a class="ae ka" href="http://plugins.mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">插件、</a>、对象填充和模式验证，或者内置，或者安装一个<a class="ae ka" href="https://yarnpkg.com/en/" rel="noopener ugc nofollow" target="_blank"> yarn </a>(我爱yarn)或一个<a class="ae ka" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>。这个项目在使用MongoDB的开发人员中变得如此受欢迎，这真的很了不起。</p><p id="9bcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当涉及到猫鼬模型时，我倾向于保持事物有点扁平(或者至少最多3个深度嵌套的对象)以避免混淆。这里有一个用户模型的例子，它直接来自于当前正在开发的项目:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="5647" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="kb">注:</em> </strong> <em class="kb">说到托管和运行MongoDB，我喜欢用</em><a class="ae ka" href="http://mbsy.co/mongodb/228644" rel="noopener ugc nofollow" target="_blank"><em class="kb">MongoDB Atlas</em></a><em class="kb">。它是由MongoDB的制作者自己提供的数据库即服务。如果不想使用免费的MongoDB Atlas实例，欢迎使用本地版本。另外，如果你想监控你的数据，</em><a class="ae ka" href="https://www.mongodb.com/products/compass" rel="noopener ugc nofollow" target="_blank"><em class="kb">MongoDB Compass</em></a><em class="kb">是一个绝佳的选择！</em></p><h2 id="7bee" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">公用事业</h2><p id="53c7" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">自定义实用程序可以用于多种用途——基本上是您想要的任何用途。我通常保留它们来分离关注点和保持代码的整洁。一些例子包括建立数据库连接、发送电子邮件、登录到外部服务，甚至与基于HTTP的流服务通信。</p><p id="0637" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我经常被问到什么时候把一些东西变成实用工具的问题，我的回答总是一样的…当你发现自己<strong class="je hv"> 1) </strong>重用代码或者<strong class="je hv"> 2) </strong>在感觉不合适的地方把第三方服务塞进代码。</p><p id="37f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个我写的实用程序的例子，叫做<a class="ae ka" href="https://getstream.io/personalization/" rel="noopener ugc nofollow" target="_blank">流个性化REST API </a>。这种集成用了大约十几行代码就完成了:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="516c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在可以从任何文件中调用上面的代码，如下所示:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><h2 id="5423" class="kc kd hu bd ke kf kg kh ki kj kk kl km jn kn ko kp jr kq kr ks jv kt ku kv kw dt translated">最后的想法</h2><p id="740d" class="pw-post-body-paragraph jc jd hu je b jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv lb jx jy jz hn dt translated">API是现代应用程序的构建模块。它们控制着应用程序如何与另一个应用程序以及数据库进行通信。而我们有其他风格的API结构(<a class="ae ka" href="https://graphql.org" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>等)。)，RESTful APIs继续发挥自己的作用，不会很快消失。</p><p id="df20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您有兴趣查看用Node.js、Express、Mongoose和MongoDB构建的REST API的完整框架，请访问这个<a class="ae ka" href="https://github.com/GetStream/node-express-mongo-api" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="b53c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一如既往，如果你有任何问题，请不要犹豫，通过<a class="ae ka" href="https://twitter.com/nickparsons" rel="noopener ugc nofollow" target="_blank">推特</a>或下面的评论联系我。谢谢大家！</p></div></div>    
</body>
</html>