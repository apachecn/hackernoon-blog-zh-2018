<html>
<head>
<title>Going Serverless with Amazon Web Services (AWS) — The Traditional Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用亚马逊网络服务(AWS)实现无服务器化——传统方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/going-serverless-with-amazon-web-services-aws-the-traditional-approach-fb45a7cc5dc2?source=collection_archive---------17-----------------------#2018-02-22">https://medium.com/hackernoon/going-serverless-with-amazon-web-services-aws-the-traditional-approach-fb45a7cc5dc2?source=collection_archive---------17-----------------------#2018-02-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="592a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">这是亚马逊网络服务(AWS)无服务器博客系列的第一篇博客</p><p id="1973" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">1.传统方法<em class="hu">🚶</em></p><p id="857b" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae jt" rel="noopener" href="/@cwidanage/going-serverless-with-amazon-web-services-aws-the-modern-approach-245fa9203f47"> 2。现代方法<em class="hu">🚴</em> </a></p></blockquote><p id="64bb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在这篇博客中，我将利用AWS无服务器组件，从头开始开发一个非常基本的示例无服务器应用程序。在继续之前，让我们看一下几个术语。</p><h1 id="de29" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">云计算</h1><blockquote class="kv"><p id="71e2" class="kw kx hu bd ky kz la lb lc ld le js ek translated">没有云，只是别人的电脑！</p></blockquote><p id="f652" class="pw-post-body-paragraph iu iv hu ix b iy lf ja jb jc lg je jf ju lh ji jj jv li jm jn jw lj jq jr js hn dt translated">这个说法(<em class="iw">玩笑</em>)在一定程度上是真的。但是云计算提供了更多的优势，这些优势是其他人的电脑所无法预料的，</p><ol class=""><li id="c360" class="lk ll hu ix b iy iz jc jd ju lm jv ln jw lo js lp lq lr ls dt translated">自助式资源调配:无论何时您需要资源，只需点击几下鼠标</li><li id="d26d" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js lp lq lr ls dt translated">弹性:扩大或缩小您的资源规模节省资金和时间</li><li id="1ce6" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js lp lq lr ls dt translated">按使用付费</li><li id="cded" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js lp lq lr ls dt translated">工作负载弹性:您不必担心冗余。大多数时候，服务供应商会替你承担这个负担！</li></ol><p id="8823" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">简而言之，当谈到云计算时，你不必担心基础设施。继续担心<strong class="ix hv">资源供应</strong>，<strong class="ix hv">您的应用程序逻辑</strong> &amp; <strong class="ix hv">代码</strong>。</p><h1 id="5212" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">无服务器计算</h1><p id="8252" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">无服务器计算可以被视为云计算的一种新变体或新执行模式，在这种模式下，后端和处理单元即服务(BaaS和FaaS)。</p><p id="7c8e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们举一个AWS世界的例子。使用传统云计算，当我们想要进行处理时，我们必须调配EC2实例，并保持该实例全天候运行。同时，无论我们是否使用它，我们都必须为这个实例付费。除此之外，我们必须应用安全补丁，自己更新操作系统，以使我们的实例远离安全威胁。但是随着无服务器系列的新处理单元Lambda的引入，事情发生了巨大的变化。有了lambda，我们只需担心我们的代码，忘记负载平衡、安全补丁甚至高可用性。</p><p id="2983" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">所以在无服务器计算中，我们甚至不用担心资源供应，我们只需要担心我们的<strong class="ix hv">代码</strong> &amp; <strong class="ix hv">应用逻辑</strong>。</p><h1 id="2b97" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">让我们通过一个示例用例来实现无服务器</h1><h2 id="dd3c" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">联系我们表单的后端</h2><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff mr"><img src="../Images/fde3034d63755c08b0c4ddb76462139c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtrQxvoUJFkRLfKWpfGvkQ.png"/></div></div></figure><p id="df14" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">静态网站可以托管在google drive甚至github等服务上，不需要任何成本。但是当我们想要添加一个简单但必要的动态组件时，这个优势就变得无用了，比如网站的<em class="iw">联系我们</em>表单。要么我们必须在后端运行一个服务器来收集<em class="iw">联系我们</em>数据，要么我们必须购买一个服务来简化我们联系我们表单的后端。不管我们的网站有多少流量，也不管有多少人愿意联系我们，这两种选择每个月都要花费我们固定的费用。</p><p id="6fe3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们需要在后端有以下组件，以支持上述场景。</p><ul class=""><li id="c2a9" class="lk ll hu ix b iy iz jc jd ju lm jv ln jw lo js nd lq lr ls dt translated">从联系我们页面接受AJAX调用的REST端点。</li><li id="5cfd" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated">处理单元验证和接受传入的请求。</li><li id="84f6" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated">保存响应的数据库。</li></ul><p id="0f39" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为了解决上述需求，我将选择以下AWS服务来实现我的后端无服务器联系我们。</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff ne"><img src="../Images/282e593bd12cb3561e403c7575a0df20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJgdA401hVk3TxpgXZ9Vxw.png"/></div></div></figure><p id="cf7a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">由于示例用例的简单性，我们甚至可以放弃Amazon Lambda，直接将API Gateway接受的REST有效负载持久化到DynamoDB。但是为了完整性，让我们假设我们必须在请求有效负载上执行<strong class="ix hv">复杂的</strong>验证。(API gateway也可以配置为对有效负载执行简单的验证，但是让我们假设我的验证需求比APIG的功能要复杂得多😸)</p><p id="3b87" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在这篇博文中，让我向你展示传统的、最慢的和最困难的实现这个解决方案的方式。</p><h1 id="27bb" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">🚶传统方法—使用AWS控制台</h1><h2 id="66bc" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">步骤1 —创建DynamoDB表</h2><p id="fffc" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">您可以通过单击<strong class="ix hv">服务</strong>T12】DynamoDB开始创建表格</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff nf"><img src="../Images/a6309541cb1c7b0a0c6bc738345cc7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ytd1q4TzdJtXFMkSnaDe2Q.gif"/></div></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Creating the DynamoDB table</figcaption></figure><p id="4b9e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然后，AWS将带您到DynamoDB仪表板，在那里您将看到一个创建表的选项。</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/a5be8f365d13c0a77bada5cf6bb087c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*bj3NFyjGUWi3luebBa8kRw.png"/></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Table name &amp; Partition key are mandatory fields</figcaption></figure><h2 id="9beb" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">选择分区键和排序键</h2><p id="5395" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">在DynamoDB中，当我们创建一个新表时，我们可以配置我们期望从表中获得的读/写吞吐量。在AWS DynamoDB世界中，我们用读/写容量单位来度量这个吞吐量。</p><blockquote class="ir is it"><p id="4885" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">一个<strong class="ix hv">读取容量单位</strong>表示对于大小最大为4 KB的项目，每秒一次非常一致的读取，或者每秒两次最终一致的读取。</p><p id="6cc0" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">一个<strong class="ix hv">写容量单位</strong>表示对于大小不超过1 KB的项目每秒写一次。</p></blockquote><p id="3690" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">让我们假设DynamoDB的一个分区最多能够提供3000个读容量单位或1000个写容量单位。然后，如果我们请求每个表有5000个读容量单位和1000个写容量单位，AWS后端将根据下面的公式创建DynamoDB分区。(这只是基于DynamoDB规范的假设，实际创建的分区对用户是不可见的)</p><figure class="ms mt mu mv fq mw"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="dbfc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这类似于拥有3个可以容纳数据的存储桶。每当我们向表中写入一个条目时，DynamoDB会根据我们选择的分区键将其存储在上述3个分区中的一个分区中。<strong class="ix hv">分区键的目标是仔细选择它，以便我们的数据在分区之间均匀分布。</strong></p><p id="0c31" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在分区内，条目将根据我们在配置时选择的<em class="iw">排序键</em>进行排序。</p><p id="e3e0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">因此，在我的示例用例中，我将选择<em class="iw"> email </em>作为我的分区键，这对每个人来说都是唯一的。在分区中，我将按日期对条目进行排序。然而，在DynamoDB中，拥有一个<em class="iw">排序键</em>是可选的。我将让我的表的读/写容量单位保持默认值(5 &amp; 5)。因此，在AWS服务器中将只创建一个分区来支持我的<em class="iw"> contact_us </em>表。</p><p id="4bd1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">设置好所有必要的参数后，点击<strong class="ix hv">创建</strong>开始表格创建过程。</p><h2 id="46f9" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">步骤2 —编写AWS Lambda代码</h2><p id="b0a1" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">让我们通过点击<strong class="ix hv">服务导航到Lambda控制台Lambda创建功能</strong></p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff nf"><img src="../Images/b18370c8cde396f8fe5ec046d6062d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gEhWYAxFI9KGiTPDjzBIGg.gif"/></div></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Creating a lambda Function</figcaption></figure><p id="3fe7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为了创建一个lambda，我们需要给出一个惟一的名称并指定一个运行时环境。因为lambda将代表您访问您的其他AWS资源，所以您需要为Lambda分配一个角色，该角色具有足够的权限来访问相关的AWS资源。</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff nn"><img src="../Images/f9648ed4664129fb1153e7cd4c70ad6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R57Qj2rOddrDBLcYvbNorg.png"/></div></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Name, Runtime &amp; Role are mandatory to create a lambda</figcaption></figure><p id="1d8f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最佳实践是分配一个角色，这样我们只为lambda函数分配必要的权限。</p><p id="b13a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在我的例子中，这个函数只需要在DynamoDB上执行一个<em class="iw"> putItem </em>操作的权限。</p><h2 id="d1cd" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">为Lambda函数创建角色</h2><p id="1aff" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">通过遵循<a class="ae jt" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>，您可以轻松创建具有以下权限的角色(或使用现有角色)。</p><ul class=""><li id="cd79" class="lk ll hu ix b iy iz jc jd ju lm jv ln jw lo js nd lq lr ls dt translated">dynamodb:PutItem</li><li id="e66a" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated">日志:创建日志组</li><li id="d65a" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated">日志:创建日志流</li><li id="1527" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated">日志:上传事件</li></ul><h2 id="71d3" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">编写Lambda代码</h2><p id="175a" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">最初，我将编写没有任何验证或额外逻辑的函数。因为我最初不打算使用任何第三方库，所以我可以直接在AWS lambda控制台中编写代码。</p><blockquote class="ir is it"><p id="53da" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> Lambda </strong>服务已经为<strong class="ix hv"> Node.js </strong>预装了<strong class="ix hv"> AWS SDK </strong></p></blockquote><figure class="ms mt mu mv fq mw"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="2541" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，让我们假设我想在持久化请求之前对其进行一些验证。(如开始所述，这就是在这个简单用例中使用lambda的全部目的，而不是直接从API Gateway调用DynamoDB)。</p><p id="0096" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">因为lambda控制台的内置IDE不支持添加第三方库，所以现在我必须在我的计算机上本地编写我的lambda函数，并通过lambda控制台将代码上传为zip文件(捆绑了必要的依赖项)。</p><h2 id="78f3" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">在本地创建Lambda包</h2><p id="f503" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">我将从初始化一个新的nodejs项目开始，并通过节点包管理器添加必要的依赖项。</p><figure class="ms mt mu mv fq mw"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="6ecb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">即使在这种情况下，也没有必要将AWS-SDK作为依赖项添加到我的节点项目中。我使用<a class="ae jt" href="https://validatejs.org/" rel="noopener ugc nofollow" target="_blank"> validate.js </a>以最小的努力验证传入请求中的字段。</p><p id="d055" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，我的代码如下所示，包括请求验证。</p><figure class="ms mt mu mv fq mw"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="27ed" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我的本地目录结构如下所示。</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div class="fe ff no"><img src="../Images/6653509f5ec0c53a661fcf56b1287223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*sDfyz002EM15jU3IngnrLA.png"/></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Directory structure of Lambda Node project</figcaption></figure><p id="319f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为了将它部署为lambda代码，我必须创建一个包含该文件夹中所有内容的zip文件，并通过Lambda控制台上传。为了做到这一点，我现有的lambda函数的<em class="iw">代码输入类型</em>应该从<strong class="ix hv"> <em class="iw">编辑代码内联</em> </strong> <em class="iw"> </em>切换到<strong class="ix hv"> <em class="iw">上传一个. ZIP文件</em> </strong>。</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div class="fe ff np"><img src="../Images/5e60770b6b393bd031e777e24d95160c.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*HIXpPMqI2hr9bafnFHdtNA.png"/></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Switching the Code Entry type of lambda function</figcaption></figure><p id="3d1b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">说到这一点，我们有了一个全功能的后端，剩下的唯一任务就是通过API公开这个后端，这样我的Lambda函数就可以从<em class="iw"> Contact Us </em> HTML表单外部触发。</p><p id="b70c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">让我们继续创建一个API网关资源来触发这个lambda函数。</p><h2 id="e73a" class="md jy hu bd jz me mf mg kd mh mi mj kh ju mk ml kl jv mm mn kp jw mo mp kt mq dt translated">步骤3 —创建API网关触发器</h2><p id="a25d" class="pw-post-body-paragraph iu iv hu ix b iy ly ja jb jc lz je jf ju ma ji jj jv mb jm jn jw mc jq jr js hn dt translated">您可以轻松地从Lambda控制台创建API，而不必导航到API网关控制台。</p><p id="e468" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然而，在我的例子中，应该对生成的API做一些调整，为此，我必须通过单击新创建的API快速跳转到API网关控制台。</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff nq"><img src="../Images/d3f27167c18ad006280b8884fb2f4b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*A-a7kYf24GRGDm6mdZBigw.gif"/></div></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Tweaking generated API</figcaption></figure><p id="c486" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在这里，我关闭了lambda代理集成(你可以在这里阅读lambda集成类型<a class="ae jt" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-lambda-integration.html" rel="noopener ugc nofollow" target="_blank"/>)并为我的API端点启用了CORS。</p><p id="8ba7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在应用这些更改之后，我必须重新部署我的API来应用这些更改。</p><figure class="ms mt mu mv fq mw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff nq"><img src="../Images/93d52ca058f26af7472b96550abc5343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VpJzEYz3PqMVUaAtoTwo2w.gif"/></div></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Deploying API</figcaption></figure><p id="64ac" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，您可以使用您选择的任何HTTP客户端测试您的API，并将这个后端与您的HTML联系我们表单集成。</p><p id="f468" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这是开发无服务器应用程序的传统方法，我希望你已经意识到，有了无服务器计算，你可以忘记<strong class="ix hv">资源供应</strong>，只关注<strong class="ix hv">代码</strong> &amp; <strong class="ix hv">应用程序逻辑</strong>。</p><p id="870f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在下一篇博客文章中，让我们看看如何用现代方法开发一个无服务器应用程序，其中我们忘记了<strong class="ix hv">资源供应</strong>和<strong class="ix hv">代码(是的！</strong>😇<strong class="ix hv"> ) </strong>而只关注<strong class="ix hv">应用逻辑</strong>。</p></div><div class="ab cl nr ns hc nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="hn ho hp hq hr"><h1 id="cf96" class="jx jy hu bd jz ka ny kc kd ke nz kg kh ki oa kk kl km ob ko kp kq oc ks kt ku dt translated">行动呼吁</h1><ul class=""><li id="ad6b" class="lk ll hu ix b iy ly jc lz ju od jv oe jw of js nd lq lr ls dt translated"><strong class="ix hv">拍手。</strong>欣赏并让别人发现这篇文章。</li><li id="28e6" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated"><strong class="ix hv">评论。</strong>分享一下你对这篇文章的看法。</li><li id="3daa" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated"><strong class="ix hv">跟我来。</strong><a class="ae jt" rel="noopener" href="/@cwidanage">Chathura wid anage</a><strong class="ix hv"/>接收类似文章的更新。</li><li id="5b87" class="lk ll hu ix b iy lt jc lu ju lv jv lw jw lx js nd lq lr ls dt translated"><strong class="ix hv">保持联系。</strong> <a class="ae jt" href="https://www.linkedin.com/in/cwidanage/" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae jt" href="https://twitter.com/cwidanage" rel="noopener ugc nofollow" target="_blank">推特</a></li></ul></div></div>    
</body>
</html>