<html>
<head>
<title>How to implement 2D isometric view in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Unity中实现2D等距视图</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-implement-2d-isometric-view-in-unity-7717d4914eee?source=collection_archive---------6-----------------------#2018-02-23">https://medium.com/hackernoon/how-to-implement-2d-isometric-view-in-unity-7717d4914eee?source=collection_archive---------6-----------------------#2018-02-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0c3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的<strong class="it hv">push&amp;Pully</strong>游戏有一些等距视图。如果你还是不知道这个游戏，让我给你看一个截图:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/49072173992fa5dbef8d6daf79ec4241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBCzQo1F7Dx19hxmhOnLgA.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Main game area (not the final sprites)</figcaption></figure><p id="d9c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如你所见，这个视图介于自上而下和特定角度之间。更像是前置等轴相机。但是2D的Unity只有一台“普通”或正交的相机。(据我所知)你无法向摄像机表明你想要的是一个等距图。所以我们必须用代码来解决这个问题。</p><h1 id="d4a2" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">绘图对象如何工作</h1><p id="ddea" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">首先要理解的是，我们<a class="ae li" href="https://hackernoon.com/generating-a-level-from-an-image-in-unity3d-225b51a68172" rel="noopener ugc nofollow" target="_blank">在运行时从文件</a>中读取级别定义后生成级别。所以我们必须画出每个物体，顺序很重要。作为2D游戏的一般规则，你画的最后一个物体会显示在前面的物体之上。</p><h2 id="7fb5" class="lj kg hu bd kh lk ll lm kl ln lo lp kp jc lq lr kt jg ls lt kx jk lu lv lb lw dt translated">统一之道:分层</h2><p id="9685" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">在Unity中，你可以为你的对象定义<strong class="it hv">层</strong>。您还可以设置图层的绘制顺序。例如，你可以为你的角色定义一层，为敌人定义另一层。你可以设置它，这样如果两者重叠，敌人将永远在角色的后面。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/f08b15b11171e6d84ae476ff4b6bbb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*LqwgwkBVdM_w9pCqpmOp7w.png"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Unity layer magic</figcaption></figure><p id="c263" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使你在同一层中有多个对象(想象不同的敌人或方块)，Unity在层中有一个称为<strong class="it hv">顺序的属性，可以解决冲突。假设你实例化了3个块，在某个时候它们重叠了。然后unity将通过使用层中的顺序属性来解决这个问题:编号较大的层将始终位于顶部。不管你按什么顺序画。</strong></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/9402c3bff5d560fd0b831d73ecef64c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*sEMcsyrlg-ir4yC5D4rTaA.png"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Objects in the same layer with different order in layer</figcaption></figure><p id="8fcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是当不同的层相互重叠时会发生什么呢？如果你有一个预置(非Unity人员的通用“类”),你会用相同的层和层中的顺序实例化很多次(比如我们的块),那该怎么办？</p><h1 id="4bdb" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">重叠解决方案</h1><p id="578d" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">有两种可能的方法来解决这个问题。最简单的方法是改变每个物体的z坐标来匹配谁应该在上面。在Unity中，即使你在2D工作，你仍然在每个物体中有3个坐标。z坐标定义了一个物体离相机有多远或多近。更改z坐标可以有效地将一个对象放在另一个对象的上面。</p><p id="e999" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我真的不喜欢这种方法，因为感觉有点乱。我也不确定我的碰撞系统是否能正常工作。所以我决定研究其他方法，我发现了Unity的另一个很好的特性:<strong class="it hv">对组进行排序。</strong></p><h2 id="1390" class="lj kg hu bd kh lk ll lm kl ln lo lp kp jc lq lr kt jg ls lt kx jk lu lv lb lw dt translated">什么是排序组？</h2><p id="5244" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">想象你有一个由不同部分组成的精灵:一个头，一个身体，几条胳膊和腿。你想把所有东西都搬到一起，但是你该怎么做呢？你是否将它们放在同一层，并尝试获得正确的顺序？如果它与另一个同样由零件组成的精灵重叠会发生什么？</p><blockquote class="lz ma mb"><p id="6e81" class="ir is mc it b iu iv iw ix iy iz ja jb md jd je jf me jh ji jj mf jl jm jn jo hn dt translated">我将用取自Unity手册的<a class="ae li" href="https://docs.unity3d.com/Manual/SortingGroup.html" rel="noopener ugc nofollow" target="_blank">图片来解释这一部分，因为它们非常适合解释这一部分(我没有多图片精灵)。</a></p></blockquote><p id="f8c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了避免这些问题，Unity有一个叫做排序组的组件。这有两个属性:层和层中的顺序。就像精灵渲染器中的其他渲染一样。但是有了这个分类组，你可以把精灵的每一个部分都归在一个组里，所以即使它们在同一层里，在层属性里有不同的顺序也没关系。当渲染你的精灵时，排序组将有优先权。</p><p id="cf8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是用不用的区别:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mg"><img src="../Images/5833c3b5f00c60c4db064962cca95ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FT4r1qjFPhhaLKTqjHtEtg.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Check how the left image overlaps</figcaption></figure><h1 id="692e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">为我们的等距视图应用排序组</h1><p id="3b76" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我采用的解决方案是在<strong class="it hv">所有</strong>我的sprite对象中使用排序组。</p><p id="42d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用的每个对象都有排序组组件。它们都在同一个排序组图层中(在我的例子中，我使用了默认图层，因为这无关紧要)。一个脚本根据子画面的位置控制那个(排序组)层的顺序。</p><p id="17eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们显然需要动态的，因为玩家和敌人都在移动。我们需要在最后时刻更新层中的顺序，所以我们将在所有内容都更新后在<em class="mc"> LateUpdate </em>中完成。</p><p id="40a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以在此处看到该脚本的示例:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="8959" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">topMaxPosition 只是一个属性，指示你的精灵可能在的最高位置。我需要从我的观点中减去它的原因是，我的视图需要屏幕底部的对象(接近y = 0)在顶部。因此，我们需要“反转”我们的y位置，以便在排序顺序中使用它。</p><p id="c293" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是实际运行的代码:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/89212a07a2db49e820c05b53b92304fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/1*zwyC7zkhU-yW1WxEetDpOg.gif"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Pushy walking easily between layers of blocks</figcaption></figure><p id="bcb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你所看到的，所有的积木都被正确放置，我们的玩家可以在它们之间行走。需要的时候积木会留下来。</p><h1 id="d330" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">那都是乡亲们！</h1><p id="6136" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我希望这篇文章可以帮助那些试图实现类似于我们等距视图的东西的人。如果你有任何疑问，请随时评论。</p><p id="d381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下周见！</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><a href="http://eepurl.com/dh-0I1"><div class="fe ff mk"><img src="../Images/db2dc5b9f5ecafe565afcc9d53874a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Brzxc5tgtSWFpJPKHG6fyA.png"/></div></a></figure></div></div>    
</body>
</html>