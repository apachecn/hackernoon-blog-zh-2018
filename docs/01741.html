<html>
<head>
<title>Writing a self-sufficient AWS Lambda Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自给自足的AWS Lambda函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-a-self-sufficient-aws-lambda-function-da6c0586f48c?source=collection_archive---------9-----------------------#2018-02-24">https://medium.com/hackernoon/writing-a-self-sufficient-aws-lambda-function-da6c0586f48c?source=collection_archive---------9-----------------------#2018-02-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c591" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你已经浏览了<a class="ae jp" href="https://globenewswire.com/news-release/2018/02/06/1333797/0/en/SLAppForge-Announces-Sigma-a-Cloud-IDE-for-Serverless-Computing.html" rel="noopener ugc nofollow" target="_blank"> SLAppForge的新闻文章</a>和博客，你可能已经知道来自<a class="ae jp" href="http://srilanka.travel" rel="noopener ugc nofollow" target="_blank">斯里兰卡</a>的<a class="ae jp" href="http://slappforge.com" rel="noopener ugc nofollow" target="_blank">一群工程师</a>正在努力使无服务器开发者的生活变得更加容易。</p><p id="6a98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们在试验各种AWS服务时，我们尝试了很多疯狂的事情，让适马IDE成为其他无服务器开发者最好的朋友。</p><p id="6c0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你已经使用AWS控制台编写了lambda函数，你可能已经注意到，在AWS控制台中有一个内置的IDE，你可以在浏览器中编写解释语言并立即部署。在NodeJs的情况下，当您想要使用第三方库时，这个功能就变得没有用了。(我们已经在适马解决了这个问题😎).因此，在我们使用适马之前，剩下的唯一选择是，在您的本地机器上编写代码，并将其上传为带有所需依赖项(node_modules)的ZIP文件。</p><p id="fa60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，下面这段代码可以在一定程度上解决这个问题。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="a0f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这段代码中，第一步是将代码本身作为字符串读取，并查找所需的依赖项！</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff jx"><img src="../Images/69c246e12f0e5b7966cf2a08731f0a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqKEpV6vnkkuHgDljiap3w.jpeg"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Snake eating itself 🤢</figcaption></figure><blockquote class="ki kj kk"><p id="76fd" class="ir is kl it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated">如果你还不知道，对于每个lambda函数，你会在lambda容器的/tmp 位置得到一个<strong class="it hv">512 MB的非持久空间。</strong></p></blockquote><p id="6848" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步是，在所有已识别的依赖项上执行<em class="kl"> npm install </em>，以生成所需的<strong class="it hv"> node_modules </strong>文件夹。</p><p id="777b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于，<em class="kl"> /tmp </em>是Lambda容器中唯一可写的文件夹，我们必须如下使用<a class="ae jp" href="https://docs.npmjs.com/misc/config#prefix" rel="noopener ugc nofollow" target="_blank">前缀</a>标志。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="99ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同时，您必须将Lambda容器的HOME环境变量设置为/tmp。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff kp"><img src="../Images/3df887b3e3dc3ed935de698fb5ee2b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsq5fqMb_qE1vwc0p377iQ.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Setting environment variables in Lambda</figcaption></figure><p id="08c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下载完所有依赖项后，我们将<em class="kl"> require </em>函数的引用改为我们自己的引用，这样就将<em class="kl"> /tmp/node_modules/ </em>追加到所有依赖项中。</p><p id="15ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当您第一次为这个特定的lambda生成容器时，它会将所需的节点模块下载到<em class="kl"> /tmp/node_modules </em>目录。这将在第一次运行中花费相当多的时间(无论如何，冷启动时间在lambda中是个问题，但是这种方法花费的时间甚至更多)，从第二次开始(仅仅对于这个特定的容器)，执行时间将是正常的😊。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/1259c9804014f8c5150c9a45c758a1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/1*G6e8l9o-3DfZbGzzx8ha7A.gif"/></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">First Run (Cold Start) — Billed Duration: 1100 ms</figcaption></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/de43e767922472c46b5b868630456279.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/1*NQSXE3vvxo18BEmY-ac7Nw.gif"/></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">A warm run 🔥 — Billed Duration: 300 ms</figcaption></figure><p id="fdbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显然这不是一个生产就绪的解决方案，但这可能为解决<a class="ae jp" href="https://sigma.slappforge.com/" rel="noopener ugc nofollow" target="_blank">适马</a>的燃眉之急铺平道路(希望如此)。一旦我们将该功能添加到<a class="ae jp" href="https://sigma.slappforge.com/" rel="noopener ugc nofollow" target="_blank"> Sigma </a> 🧐.中，我们会让您知道我们解决了什么问题你一定会喜欢这个功能的。敬请期待&amp;希望你喜欢！</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><h2 id="e3a9" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">更新(2018/02/24)</h2><p id="a90f" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">非常感谢埃里克抓住这个机会😊</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ly jw l"/></div></figure><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ly jw l"/></div></figure><p id="d2e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于这个建议，我们可以如下摆脱最初的代码解析循环。这段代码在需要的时候动态加载依赖项，仍然保持我们的lambda函数自给自足！！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="1839" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，对于这个特殊的例子，您几乎不会注意到冷启动时间和运行时间的差异。</p><p id="2acb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在下面的例子中这是显而易见的。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><h2 id="0308" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">两种方法的区别</h2><p id="4f0a" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">这两种方法在启动时和运行时表现不同。</p><p id="2e3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第一种方法中，由于函数预加载(下载)了所有需要的依赖项，运行时会经历一个类似的环境，就好像你已经将lambda函数上传为一个ZIP文件(带有<em class="kl"> node_modules </em>目录)。</p><p id="1e16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第二种方法中，启动会更快，运行时间会花一些时间(只有在第一次，它遇到一个独特的依赖关系)，因为它必须下载依赖关系。</p><h2 id="fcbf" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">更新(2018/04/26)</h2><p id="0d57" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">基于上述概念，实现了适马IDE的测试框架。有关更多信息，</p><div class="lz ma fm fo mb mc"><a href="https://hackernoon.com/how-we-streamlined-serverless-testing-8f5e0bbdc7e5" rel="noopener  ugc nofollow" target="_blank"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">我们如何简化无服务器测试</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">如果这不是你第一次听说无服务器和AWS Lambda，你可能已经看过橙色测试…</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">hackernoon.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq kc mc"/></div></div></a></div><h1 id="386b" class="mr kz hu bd la ms mt mu le mv mw mx li my mz na ll nb nc nd lo ne nf ng lr nh dt translated">行动呼吁</h1><ul class=""><li id="ad6b" class="ni nj hu it b iu lt iy lu jc nk jg nl jk nm jo nn no np nq dt translated"><strong class="it hv">拍手。</strong>欣赏并让别人发现这篇文章。</li><li id="28e6" class="ni nj hu it b iu nr iy ns jc nt jg nu jk nv jo nn no np nq dt translated"><strong class="it hv">评论。</strong>分享你对这篇文章的看法。</li><li id="3daa" class="ni nj hu it b iu nr iy ns jc nt jg nu jk nv jo nn no np nq dt translated">跟我来。<a class="ae jp" rel="noopener" href="/@cwidanage">chat hura wid anage</a><strong class="it hv"/>接收类似文章的更新。</li><li id="5b87" class="ni nj hu it b iu nr iy ns jc nt jg nu jk nv jo nn no np nq dt translated">保持联系。 <a class="ae jp" href="https://www.linkedin.com/in/cwidanage/" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae jp" href="https://twitter.com/cwidanage" rel="noopener ugc nofollow" target="_blank">推特</a></li></ul></div></div>    
</body>
</html>