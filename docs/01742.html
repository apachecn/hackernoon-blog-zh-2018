<html>
<head>
<title>Java Optional is Complicated</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java可选是复杂的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/java-optional-is-complicated-d6dc5c061e57?source=collection_archive---------10-----------------------#2018-02-24">https://medium.com/hackernoon/java-optional-is-complicated-d6dc5c061e57?source=collection_archive---------10-----------------------#2018-02-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3a9e82ebe39bdc2cc1d59cd7f304d808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5DTaFb7WXWJzFNZDM6_bg.png"/></div></div></figure><p id="9d28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很久很久以来，我都没有用Java写代码，因为如果需要JVM，那么Scala就是我的选择。然而，这种情况时常会发生变化，尤其是当我不得不在Java商店工作的时候。</p><p id="7c54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<em class="ka"> Java </em>语言的新进展，我会说<em class="ka"> Java </em>比几年前更容易使用。函数式编程有很大的发展，这可以在最新版本的Java中看到。</p><p id="ebda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在做了很多努力来整合所有这些特性之后，有一些仍然是不完整的。</p><p id="592b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看<strong class="je hv"> <em class="ka">可选</em> </strong>以及如何使用它，以及它与<strong class="je hv"> <em class="ka"> Scala </em>相比如何。<em class="ka">选项</em>选项</strong>。</p><p id="8bec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ka">可选</em> </strong>背后的主要思想是避免空值和避免NullPointerException。然而，它感觉我们在<em class="ka"> Java </em>中发现的那个实际上促进了空值的使用。让我们看看怎么做。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="8dd7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当我们向它发送一个null时，这个就会抛出<strong class="je hv"><em class="ka">NullPointerException</em></strong><em class="ka"/>。相反，我们需要使用<code class="eh kh ki kj kk b">.ofNullable</code>方法。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="a53d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">主要思想不是避免这些异常吗？那为什么我们会有两种截然不同的工作方式，并且会有如此不同的结果。</p><p id="f9a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="ka"> Scala </em>中，我们只需要做:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="588d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我将类型保持在最高级别，因此每个人实际上都可以为null。</p><p id="e3e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重点是<code class="eh kh ki kj kk b">Option.apply(somethingNull)</code>，它和<code class="eh kh ki kj kk b">Option(somethingNull)</code>一样，会处理空值并为我们创建适当的结果，而不会抛出NullPointerException，这正是我们想要避免的问题。</p><p id="b7b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了我们自己的缘故，<em class="ka"> Java </em> <strong class="je hv"> <em class="ka">可选</em> </strong>有权利<code class="eh kh ki kj kk b">.map</code>和<code class="eh kh ki kj kk b">.flatMap</code>，它们在<em class="ka"> Scala </em>或任何其他语言中工作。然而，<em class="ka"> Java </em>使得这些方法的签名方式比它们的<em class="ka"> Scala </em>的对应物更加复杂。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="5745" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">换句话说，这与<em class="ka"> Scala </em>中的以下内容相同:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="19bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我保留了相同的泛型类型名。</p><p id="ebf2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kh ki kj kk b">.flatMap </code>最差。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="422c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="ka"> Scala </em>中我们写道:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="ee04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这两种语言中，我们都可以使用<code class="eh kh ki kj kk b">.get()</code>从<strong class="je hv"> <em class="ka">可选的</em> </strong>中提取值，但是，这种操作是不鼓励的，因为在这两种语言中这可能会以异常结束。为了避免这一点，<em class="ka"> Java </em>和<em class="ka"> Scala </em>采取了不同的方法。</p><p id="bab7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="ka"> Java </em>中，如果包装的值是<code class="eh kh ki kj kk b">null</code>，我们需要使用<code class="eh kh ki kj kk b">.orElse</code>来提供默认值。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="c2f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="ka"> Scala </em>中我们使用<code class="eh kh ki kj kk b">.getOrElse</code></p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="75e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们所见，这两种方法是相似的，尽管<em class="ka"> Scala </em>更简洁地描述了如何创建<strong class="je hv"><em class="ka"/></strong>可选值以及如何避免空值问题。</p><p id="1be9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有一点<em class="ka"> Java </em>短，<strong class="je hv"> <em class="ka"> Java可选不可折叠</em> </strong>。</p><p id="a8f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每次我们把一个值放入一个可选值中，我们都会想知道里面有什么样的值。它是null还是只是一个常规值？</p><p id="0855" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka"> Java </em>，再次选择了冗长、不太方便的路径。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="2ed1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为<em class="ka"> Scala </em>选项是可折叠的，我们可以用一种更优雅的方式来做这件事。让我们看看怎么做。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="f1b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka"> Scala </em>中的<code class="eh kh ki kj kk b">.fold</code>签名如下:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="1cd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">注意</em> <code class="eh kh ki kj kk b"><em class="ka">ifEmpty: =&gt; B</em></code> <em class="ka">与Java中的</em> <code class="eh kh ki kj kk b"><em class="ka">Supplier&lt;B&gt;</em></code> <em class="ka">相同。</em></p><p id="82cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么问题是他们为什么没有给<em class="ka"> Java </em> <strong class="je hv"> <em class="ka">可选</em> </strong>？</p><p id="3721" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">仅出于教育目的，让我们自己在<em class="ka"> Java </em>中创建一个<strong class="je hv"><em class="ka">foldable optional</em></strong>，看看实现<code class="eh kh ki kj kk b">.fold</code>有多容易。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="9d5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们在这里看到的，<code class="eh kh ki kj kk b">.fold</code>的实现不能再简单了，因为我们在<em class="ka"> Java </em>中有有限的工具箱；尽管如此，非常直截了当。</p><h2 id="5985" class="kl km hu bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">结论</h2><p id="b94d" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">尽管Java语言在过去几年里一直在发展，但它仍然远远落后于其他语言，比如Scala，尤其是在函数方面。令人印象深刻的是,<em class="ka"> Scala </em>如何在整个库中保持相同的API，并保持一致。甚至开源库和项目都使用相同的标准。另一方面，<em class="ka"> Java </em>正在朝着更好的<em class="ka"> Java </em>(如果真的存在的话)迈出正确的步伐，但是还有很长的路要走。与此同时，我们必须继续使用手头的工具来做我们的日常工作，所以让我们在使用好的同时继续增强它。</p></div></div>    
</body>
</html>