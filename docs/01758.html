<html>
<head>
<title>I created an AI that beats me at tic-tac-toe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我创造了一个能在井字游戏中打败我的人工智能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/i-created-an-ai-that-beats-me-at-tic-tac-toe-3ea6ba22cd71?source=collection_archive---------1-----------------------#2018-02-25">https://medium.com/hackernoon/i-created-an-ai-that-beats-me-at-tic-tac-toe-3ea6ba22cd71?source=collection_archive---------1-----------------------#2018-02-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8239" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">在井字游戏中尽情输吧:</em>【https://www.aaronccwong.com/tic-tac-toe】T2</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff jr"><img src="../Images/2ec48fb5babc284c9570fdc94a93a09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*HHUIYu43qqo1b1BNCZl0tQ.png"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Shamelessly taken from Wikipedia.</figcaption></figure><p id="8ce9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我上一年级的时候，我认为自己是世界上最好的井字游戏玩家。我打败了我的朋友，他刚刚教过我怎么玩。对我来说不幸的是，这种天才的感觉没有持续很久。我亲爱的朋友，他的名字我已经不记得了，开始发起钳形攻势。游戏开始看起来有点像:</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff kd"><img src="../Images/e632767d82e1e8b5b49e033748d30201.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*5e2ut_hHa39lNetviTZHUw.png"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Yeah. Sucks for O.</figcaption></figure><p id="59a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我崩溃了。我回家练习，直到我能从一英里外看到那些技巧。当时我并没有意识到，我实际上是在搜索一棵<strong class="it hv">博弈树</strong>，看看我正在走的这步棋是否会带来有利的结果。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="a282" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你:那么……什么是博弈树？</p><p id="9585" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我:哦。它只是一个博弈的<strong class="it hv">状态空间</strong>，其中每个节点都是博弈的一个状态，每个边都是有效的移动。</p><p id="a43c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你:…</p><p id="91df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我:不好意思。<em class="jp">状态空间是通过任何动作序列从</em> <strong class="it hv"> <em class="jp">初始状态</em> </strong> <em class="jp">可达到的状态集合。至少罗素和诺维格是这么定义的。任何游戏的初始状态都是游戏开始时棋盘的状态。井字游戏的初始状态只是一个3x 3的网格，其中没有X或O。然后每当玩家移动一步，游戏就进入一个新的状态。例如，上图中O丢失的地方显示了5个状态。每走一步，就达到一个新的境界。所有可达状态的集合就是状态空间。任何需要打破游戏规则才能达到的状态都不被认为是可达到的状态。因此，具有两个X标记而没有O标记的井字游戏棋盘不是可到达的状态。</em></p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/cb687eb0893142af8b98ac346a7a7e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:162/format:webp/1*iUmC08PG1BtHWpyLzMKVLQ.png"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Not a valid state.</figcaption></figure><p id="3dae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你:这与你创造了一个在井字游戏中打败你的人工智能有什么关系？</p><p id="1283" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我:那容易。我只是让电脑模拟了每回合开始时每一步可能的结果。完成模拟后，它会选择能带来最佳结果的行动。这相当于在博弈树中搜索具有最佳可能结果状态的叶子。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff km"><img src="../Images/07c97db6d228f70c6b49910c28671b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*rYAvsr8eLhMaRdpfNppNsQ.png"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Partial game tree for tic-tac-toe. Credits to Professor Eppstein of UC Irvine.</figcaption></figure></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="707a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个自然产生的问题是，这在成本上是否可行。我们可以进行包络计算，看看有没有那么多的状态。假设计算机先走。那么有9种可能的移动。对于它选择的9步棋中的任何一步，它都必须模拟另一个玩家对此的反应。对此有8种可能的选择。然后它切换回计算机，在剩下7个选项的情况下再次移动。这种情况一直持续到没有剩余的移动。因此，在第一步，计算机需要浏览9！= 362，880个州。在计算机的下一步行动中，还有7个可能的地方需要标记，因此计算机需要检查7个地方！= 5040个州。如果我们假设游戏一直持续到计算机只剩下一个可能的走法，那么计算机需要看完9！+ 7!+ 5!+ 3!+ 1!=总共368，047个状态。作为比较，国际象棋博弈树有大约10个⁵⁴节点。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="fd1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们知道我们可以只看博弈树来寻找最佳可能的移动，并且搜索博弈树是可行的，那么什么算法在这里最有效呢？最小最大算法似乎是一个自然的候选。</p><p id="ad18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在任何回合的两人零和游戏中，你总是试图达到对你来说最好的结果，在大多数情况下就是赢。这相当于另一个玩家达到了最坏的可能结果。同样，如果其他玩家达到了对自己来说最好的结果，这是你输了之后最差的结果。因此，如果我们让U:State <strong class="it hv"> → </strong> ℝ作为效用函数，那么你的目标将是在游戏结束时最大化你的效用，而你的对手的目标将是通过最大化她的效用来最小化你的效用。</p><p id="9156" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们面对的是一个理性的对手，极大极小算法会在给定玩家的回合中，将每一步棋的最大可能效用显示出来。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/51bd666f912e608bca610baa6c404e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*Y80DcB6zTCFltJYDgh8iVQ.png"/></div></figure><p id="150b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了更清楚地解释极大极小算法在做什么，看看上面的图片。假设赢给我们的效用是100，输给我们的效用是-100，平局给我们的效用是0。我们可以玩右上角的游戏并获胜，给我们100的效用，但是让我们把另外两种情况当作一个思考练习。</p><p id="a067" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们选择中间一排的空位。那么轮到O的时候，既然我们是假设它是一个理性的对手，那么O就会选择发挥我们效用最小化的位置。如果O打右上角，我们的效用是0，如果O打左下角，那么O赢了，所以我们的效用是-100。因此，我们知道O将会选择左下角，所以我们知道如果我们选择中间一行，那么我们的效用将会是-100。</p><p id="7d93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，如果我们不打中间一行而是打左下角而不是中间一行，那么O将有两个移动可供选择。如果O打中间一排，那么我们可以通过打最后一个空位来获胜。o不想这样。o发现如果她改打右上角，那就是平局，所以我们得到的效用是0。由于这使我们的效用最小化，O将改为打右上角。因此，如果我们玩左下角的游戏，那么我们知道这个游戏将以平局结束，我们将得到0的效用。</p><p id="eca5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从这个分析可以清楚地看出，在这三步棋中，打右上角会给我们带来最大的效用。因此，作为一个理性的代理人，这是我们选择的行动。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="8bc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让<code class="eh ko kp kq kr b">UTILITY(state)</code>返回当前状态的效用。设<code class="eh ko kp kq kr b">ACTIONS(state)</code>是当前状态下所有有效移动的列表。让<code class="eh ko kp kq kr b">RESULT(state, action)</code>成为在当前状态下做出给定动作后的结果状态。则极大极小算法由下式给出</p><pre class="js jt ju jv fq ks kr kt ku aw kv dt"><span id="6a23" class="kw kx hu kr b fv ky kz l la lb">MINIMAX(s)<br/>    For every a ∊ Actions(s)<br/>        if MIN-VALUE(RESULT(s, a)) &gt; UTILITY(RESULT(s, best))<br/>            best = a<br/>    return best</span><span id="c5b9" class="kw kx hu kr b fv lc kz l la lb">MIN-VALUE(s)<br/>    If GAME-OVER(s)<br/>        return UTILITY(s)<br/>    For every a ∊ Actions(s)<br/>        sim-utility = MAX-VALUE(RESULT(s, a))<br/>        if sim-utility &lt; worst<br/>            worst = sim-utility<br/>    return worst</span><span id="ca75" class="kw kx hu kr b fv lc kz l la lb">MAX-VALUE(s)<br/>    If GAME-OVER(s)<br/>        return UTILITY(s)<br/>    For every a ∊ Actions(s)<br/>        sim-utility = MIN-VALUE(RESULT(s, a))<br/>        if sim-utility &gt; best<br/>            best = sim-utility<br/>    return best</span></pre><p id="6b3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要查看这个算法的JavaScript版本，请查看这里:<a class="ae jq" href="https://github.com/AaronCCWong/portfolio/blob/master/src/util/tictactoe/ComputerPlayer.js#L15" rel="noopener ugc nofollow" target="_blank">https://github . com/AaronCCWong/portfolio/blob/master/src/util/tictactoe/computer player . js # L15</a></p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="eced" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ko kp kq kr b">MINIMAX</code>很明显是深度优先搜索的一个应用。它的运行时间为<code class="eh ko kp kq kr b">O(b^n)</code>，其中<code class="eh ko kp kq kr b">b</code>是给定回合中有效移动的最大数量，而<code class="eh ko kp kq kr b">n</code>是树的最大深度。</p><p id="bfb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这都是假设我们在和一个理性的对手比赛。如果对手玩次优怎么办？不难看出，在这种情况下<code class="eh ko kp kq kr b">MINIMAX</code>不会做得更糟，因为对手会采取一种不会让我们达到最小效用的行动。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="e239" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">敏锐的读者会意识到，这种算法并不能创造出一个永远获胜的人工智能。然而，它确实创造了一个无与伦比的井字游戏玩家。也就是说，你最多只能打成平手。如果像我一样，你走得太快，你甚至可能会输。</p><p id="e796" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">在这里随意去输井字游戏:</em><a class="ae jq" href="https://www.aaronccwong.com/tic-tac-toe" rel="noopener ugc nofollow" target="_blank">https://www.aaronccwong.com/tic-tac-toe</a></p><p id="1599" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">点击此处查看原文:</em><a class="ae jq" href="https://blog.aaronccwong.com/2018/i-created-an-ai-that-beats-me-at-tic-tac-toe/" rel="noopener ugc nofollow" target="_blank">https://blog . aaronccwong . com/2018/I-created-an-ai-that-beats-me-at-TIC-tac-toe/</a></p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="cec1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">免责声明:如果你声称战胜了它，不要害怕在下面的评论中列出你为赢得胜利而采取的行动。电脑每次都会做出相同的动作，这样我们就可以验证你确实是井字游戏大师。通过教我们如何打败它，你也将为人类提供一个伟大的服务。</p></div></div>    
</body>
</html>