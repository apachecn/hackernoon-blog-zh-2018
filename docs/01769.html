<html>
<head>
<title>The dramatic impersonation : a developer horror tale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戏剧性的模仿:一个开发者的恐怖故事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-dramatic-impersonation-a-developer-horror-tale-c794b1ab5c20?source=collection_archive---------12-----------------------#2018-02-25">https://medium.com/hackernoon/the-dramatic-impersonation-a-developer-horror-tale-c794b1ab5c20?source=collection_archive---------12-----------------------#2018-02-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1cec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个职业团体都有其神秘的恐怖故事…</p><p id="f4cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我要讲的故事是一个资深开发人员在一个沉闷的冬天傍晚告诉实习生的故事，寒冷的霓虹灯在一个空旷的空间投下阴影。更严重的是，这种软件闹剧很容易让你的公司名誉扫地，让你丢掉饭碗。</p><p id="e9d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一切都始于一个良好的老ASP.Net一样的项目，使用防弹开箱即用的形式认证。密码存储在网络隔离数据库中，始终谨慎实施最佳安全实践，登录页面是精心手工制作的，认证流程可抵御定时攻击，网站由安全专家定期测试。坚如磐石我们告诉你！</p><p id="b9e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，这种情况一直持续到今天早上正常发布补丁的时候，有报道称用户在浏览应用程序时使用了错误的身份。身份交换，什么？这就像你在浏览你的脸书页面时，点击一个随机的通知图标后，你最终会冒充你前任的资料，访问他们所有的帖子，图片，即时聊天，一切！！那真的很糟糕，不是吗？很难想象还有比这更糟糕的事情…不可能？这种事绝不会发生，你一直这样告诉自己。嗯，那是绝对可能的，甚至超级容易复制，怎么复制？我们开始吃吧，好吗？</p><h1 id="ac40" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">美味的老饼干</h1><p id="19f5" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">在深入研究这个用例的更多细节之前，让我们重新介绍一下网络安全的支柱之一。授权。饼干。</p><p id="c74b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然给出的所有例子都来自微软的stem，但是所有的原则在不同的现代框架中都是一样的，我相信我们可以用不同的栈很容易地模拟这个用例。</p><p id="1f04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">授权。cookie是与用户身份相关的一些属性的字典，这些属性在服务器端使用私钥(在配置文件中设置的机器密钥)进行加密</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ks"><img src="../Images/cd951c0c39b7dfaa8d2ae18917926791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z6j-FEDvDJ5O7DaY.png"/></div></div></figure><p id="f8d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后在HTTP响应头中传递给客户端。</p><p id="8dab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一般来说。cookie在登录流成功后被附加到HTTP响应中，然后被存储在客户端浏览器中的特定域中。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff le"><img src="../Images/0df0079a2b9085b787fd050b88cca642.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*HzgBsPOHC7PjLdQ-.png"/></div></figure><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff lf"><img src="../Images/541601d4148f2d52f531dc9f8c938698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-7bkchENxFpYhCfF.png"/></div></div></figure><p id="f66a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个令牌在一段给定的时间内(通常是可配置的)保持有效，并在HTTP头中与每个请求一起传递。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/004c9a4c3b3e76d613b6253de500a9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*lzxzDnWnj1vXBxXA.png"/></div></figure><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff lh"><img src="../Images/fc6c94abf7b61dcb1852622250228293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tWmBIejmoKB4UWyq.png"/></div></div></figure><p id="cd47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个cookie由web应用程序解密，web应用程序检查它的有效性并访问封装的信息(通常是一些关于身份的信息)，然后执行所有的授权过滤。</p><p id="7f69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当cookie过期时，web服务器自然会拒绝该请求。大多数网站都实现了某种cookie滑动过期技术，如果用户保持活动状态，就会重新发布一个新的cookie。</p><p id="c359" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果在ASP.Net进行配置，一旦初始cookie过期一半，就会发布一个新的cookie。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff li"><img src="../Images/59e92a7997e1faf693846b5bb6fbfe11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*Bs6xQ9S75QbEbDJ3.png"/></div></figure><h1 id="ac64" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">致命的拉动式请求</h1><p id="9307" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们假设您的web应用程序包含一些静态内容——图像、用户文档、营销材料——这些内容以前是可以公开访问的，由于一些业务原因，我们的开发伙伴被要求将这些内容仅限于经过身份验证的用户。</p><p id="d9e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在ASP.Net/IIS中有许多方法可以实现这一点，一种方法是删除ASP.Net URL授权HTTP模块中的前提条件</p><pre class="kt ku kv kw fq lj lk ll lm aw ln dt"><span id="eeca" class="lo jq hu lk b fv lp lq l lr ls">&lt;add name="UrlAuthorization" type="System.Web.Security.UrlAuthorizationModule" preCondition="managedHandler" /&gt;</span></pre><p id="3867" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lt" href="https://docs.microsoft.com/en-us/iis/manage/configuring-security/understanding-iis-url-authorization" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/IIS/manage/configuring-security/understanding-IIS-URL-authorization</a></p><p id="70cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并明确告诉ASP.Net将静态内容限制为唯一经过身份验证的用户</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/d7f4827ae6c100f1bdd55187992f1e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/0*EV2dSM84MroER7An.png"/></div></figure><p id="0e27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从这一点开始，对Images文件夹中的资源的每个请求都将通过标准的HTTP授权管道…包括cookie设置过程。</p><h1 id="adcf" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">刺客反向代理</h1><p id="e9ff" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">那又怎样？你是对的，在这个阶段，在静态内容之上拥有授权层并不是一场闹剧，也不符合业务需求。</p><p id="d1e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，这还不是一场大屠杀，但我们越来越接近了…最后一击将来自最后一块拼图…我们的负载平衡器</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/5e89f991b058311ba0dd32e0ba570408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/0*yHxUzCkWspXBROG4.png"/></div></figure><p id="dff1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们假设我们的负载平衡器/反向代理被适当地配置来解释我们的HTTP响应的缓存控制头，并为我们的客户机提供适当的缓存资源。</p><p id="1c46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一种非常常见的行为，可以通过减少DMZ中的流量来提高应用程序的性能。</p><p id="899c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">缓存控制属性有3种主要模式:</p><ul class=""><li id="9e13" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">public:给定URL处的资源允许被缓存并提供给所有用户</li><li id="d292" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">private:给定URL处的资源按用户进行缓存</li><li id="e4b4" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">无缓存:资源将一直从web服务器获取</li></ul><p id="5b0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的静态内容是静态的，自然有资格被缓存，我们已经设置了我们的应用程序为静态资源放置正确的头。</p><p id="62b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">IIS可以通过多种方式将cache-control标头放在HTTP响应上。</p><p id="a82b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lt" href="https://docs.microsoft.com/en-us/iis/configuration/system.webserver/staticcontent/clientcache" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/IIS/configuration/system . web server/static content/client cache</a></p><p id="a607" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，HTTP缓存不仅仅发生在web服务器/负载平衡器级别，客户端的浏览器同样会解释缓存标签，并且仅在必要时获取资源。</p><p id="2111" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更多关于HTTP缓存的信息请见<a class="ae lt" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" rel="noopener ugc nofollow" target="_blank">这篇优秀的文章</a></p><h1 id="b4cd" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">《致命一击》</h1><p id="cd6f" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在，我们已经为大规模灾难准备好了一切，我们只需要等待正确的配置，这是不可避免的:</p><ol class=""><li id="00f5" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mk mc md me dt translated">经过身份验证的用户Bob在应用程序中导航</li><li id="0ba9" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">在某个阶段，Bob发送一个获取特定静态资源<strong class="it hv"> A </strong>的请求。他的半过期cookie通常放在他的HTTP头中</li><li id="f756" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">web服务器识别出cookie必须被更新，并将新的cookie附加到响应中</li><li id="3162" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">让我们假设反向代理在缓存中不再有静态资源，因为已经设置了常规的缓存过期时间，所以它将保存HTTP响应，以备另一个客户端(包括Bob的cookie)使用</li><li id="6527" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">另一个用户Alice同样在应用程序中导航，她已经收到了静态资源<strong class="it hv"> A </strong>以及它的缓存属性(缓存控制、ETag等等)。Alice的浏览器可能暂时不会请求资源A，但是…</li><li id="e8a3" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">几分钟后，Alice请求包含资源A的页面，请求到达反向代理，反向代理返回缓存的响应和Bob的cookie。</li><li id="17ba" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">Alice的浏览器接收新的cookie，如果它的到期时间比Alice的更晚，那么它将为该域全局更新cookie。</li><li id="d606" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">从现在开始，Alice向应用程序发出的每个请求都将有效地返回Bob的数据。</li><li id="f271" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">Alice抓取了应用程序的截图，优雅地提供了Bob的敏感信息，并将所有内容发布到了互联网上……准备好与您的老板共度一个不那么有趣的时刻吧。</li></ol><h1 id="8b7f" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">每个人最后都会死？</h1><p id="2164" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我发誓在这篇文章的编辑过程中没有一个开发者受到伤害！</p><p id="c4a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然大部分是虚构的，但这篇文章概述了现代软件体系结构中复杂的事物。孤立地看，不同的层可能会根据它们的规格表现，但是放在一起，如果您看不到系统的全貌，也不了解您正在使用的框架的关键概念，您可能会最终构建一个脚手架来吊死自己。</p><p id="e1dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这当然很难，而且构建应用程序(主要是面向web公众的服务)会变得很棘手，因为其中有许多不同的活动部分。</p><p id="f390" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然这个例子很极端，但我希望它能告诉我们，事情的发展会多么迅速地摧毁最好的设计。这超越了好的或坏的团队，最佳实践或定制的东西，坏的事情会发生，我们将始终谦虚地面对这一点。</p></div></div>    
</body>
</html>