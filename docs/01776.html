<html>
<head>
<title>Finally Functional Programming in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最后是Java中的函数式编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/finally-functional-programming-in-java-ad4d388fb92e?source=collection_archive---------2-----------------------#2018-02-26">https://medium.com/hackernoon/finally-functional-programming-in-java-ad4d388fb92e?source=collection_archive---------2-----------------------#2018-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/6afad7afe0bf541a452882c4519653ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*KLO-1UMtj6I6YlsRi1ZLXQ.png"/></div></figure><p id="3296" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在许多帖子中，我们探讨了不同语言的函数式编程概念，其中<strong class="ja hv"><em class="jw">【F #】</em></strong>和<strong class="ja hv"> <em class="jw"> Scala </em> </strong>是讨论的焦点。然而，因为我一直在我的工作场所上做一些<strong class="ja hv"> <em class="jw"> Java </em> </strong>，探索这些相同的概念似乎很有趣，也让我大开眼界，因为距离我上次认真使用<strong class="ja hv"> <em class="jw"> Java </em> </strong>已经有很长时间了。</p><h2 id="9aa2" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">高阶函数</h2><p id="4df0" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">如这里所解释的<a class="ae kx" href="https://hackernoon.com/higher-order-functions-what-are-they-be74111659e8" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> <em class="jw">高阶函数，它们是什么？</em></strong></a><strong class="ja hv"><em class="jw"/></strong>高阶函数是简单函数，可以接收函数作为参数，并可以返回另一个函数作为结果。</p><p id="0a92" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在现代的<strong class="ja hv"> <em class="jw"> Java </em> </strong>中，我们可以轻松做到这一点。语法并不是最好的，因为没有类型推理，我们必须显式声明函数类型，在<strong class="ja hv"> <em class="jw"> Java </em> </strong>中意味着某种<strong class="ja hv"> <em class="jw">接口</em> </strong>。让我们看看怎么做。</p><p id="5ae5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，假设我们有一个对象集合，这是一个狗的集合，我们有一个作用于每只狗的函数。我们希望能够在每个对象(狗)上调用这个函数。</p><p id="5a41" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们看看如何创建这样一个函数。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="782f" class="jx jy hu ld b fv lh li l lj lk">@FunctionalInterface<br/>interface DogAge <em class="jw">{<br/>    </em>Integer apply<em class="jw">(</em>Dog dog<em class="jw">)</em>;<br/><em class="jw">}</em></span><span id="70fd" class="jx jy hu ld b fv ll li l lj lk">List<em class="jw">&lt;</em>Integer<em class="jw">&gt; </em>getAges<em class="jw">(</em>List<em class="jw">&lt;</em>Dog<em class="jw">&gt; </em>dogs, DogAge f<em class="jw">) {<br/>    <br/>    </em>List<em class="jw">&lt;</em>Integer<em class="jw">&gt; </em>ages = new ArrayList<em class="jw">&lt;&gt;()</em>;<br/>    <br/>    for <em class="jw">(</em>Dog dog : dogs<em class="jw">) {<br/>        </em>ages.add<em class="jw">(</em>f.apply<em class="jw">(</em>dog<em class="jw">))</em>;<br/>    <em class="jw">}<br/>    <br/>    </em>return ages;<br/><em class="jw">}</em></span></pre><p id="997d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们定义了一个接口，给定一只狗，它从中提取一些整数值。然后，我们定义一个函数<strong class="ja hv"> <em class="jw"> getAges </em> </strong>将传递的函数(<strong class="ja hv"> <em class="jw">接口</em> </strong>)应用到每只狗。</p><p id="e7c2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们必须创建我们想要应用于每只狗的实际函数。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="ce05" class="jx jy hu ld b fv lh li l lj lk">DogAge f = dog -&gt; dog.getAge<em class="jw">()</em>;<br/><br/><em class="jw">getAges(</em>dogs, f<em class="jw">)</em>;</span></pre><p id="3fc4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意，我们不需要像在旧的<strong class="ja hv"> <em class="jw"> Java </em> </strong>中那样定义<strong class="ja hv"> <em class="jw"> DogAge </em> </strong>实现。那会是下面的方式，但是拜托，不要再用了。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="6a4e" class="jx jy hu ld b fv lh li l lj lk">DogAge dontUseMe = new DogAge<em class="jw">() {<br/>    </em>@Override<br/>    public Integer apply<em class="jw">(</em>Dog dog<em class="jw">) {<br/>        </em>return dog.getAge<em class="jw">()</em>;<br/>    <em class="jw">}<br/>}</em>;</span></pre><p id="d90d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">前者实际上是编译器看到第一个时生成的。</p><p id="f698" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以更深入一步，做以下事情。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="f99d" class="jx jy hu ld b fv lh li l lj lk"><em class="jw">getAges(</em>dogs, dog -&gt; dog.getAge<em class="jw">())</em>;</span></pre><p id="4765" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，我们将函数直接传递给<strong class="ja hv"> <em class="jw"> getAges </em> </strong>方法。</p><p id="e614" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不知何故，<strong class="ja hv"> <em class="jw"> getAges </em> </strong>是一个<em class="jw">高阶函数</em>，因为它可以接收函数作为参数。Java通过接收一个<strong class="ja hv"> <em class="jw">接口</em> </strong>来保持签名的怪异，但我猜这将在语言的未来版本中得到改进。</p><p id="2018" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了有个比较点，我们先定义一下<strong class="ja hv"> <em class="jw"> Scala </em> </strong>中的<strong class="ja hv"> <em class="jw"> getAges </em> </strong>，看看有什么区别。此外，我们将立即更改函数的名称，使其更加通用。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="120f" class="jx jy hu ld b fv lh li l lj lk">def extractStringFromDogs(dogs: List[Dog], f: Dog =&gt; String) = <br/>    dogs.map(f)</span></pre><p id="d673" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在<strong class="ja hv"> <em class="jw"> Java </em> </strong>中，我们可以做到。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="219a" class="jx jy hu ld b fv lh li l lj lk">@FunctionalInterface<br/>interface DogMapper <em class="jw">{<br/>    </em>String apply<em class="jw">(</em>Dog dog<em class="jw">)</em>;<br/><em class="jw">}</em></span><span id="dc08" class="jx jy hu ld b fv ll li l lj lk">List&lt;String&gt; extractStringFromDogs(List&lt;Dog&gt; dogs, DogMapper f) {         </span><span id="44e7" class="jx jy hu ld b fv ll li l lj lk">    return dogs.stream().map(dog -&gt; f.apply(dog)).collect(Collectors.toList);<br/>}</span></pre><p id="bb75" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">碰巧在<strong class="ja hv"> <em class="jw"> Java </em> </strong>中已经有一个结构解决了同样的问题。那就是<strong class="ja hv"> <em class="jw">功能&lt; A，B &gt; </em> </strong>。换句话说，我们可以做。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="6c1e" class="jx jy hu ld b fv lh li l lj lk">List&lt;String&gt; extractStringFromDogs(List&lt;Dog&gt; dogs, Function&lt;Dog, String&gt; f) {</span><span id="f331" class="jx jy hu ld b fv ll li l lj lk">    return dogs.stream().map(dog -&gt; f.apply(dog)).collect(Collectors.toList);<br/>}</span><span id="84c1" class="jx jy hu ld b fv ll li l lj lk">extractStringFromDogs(dogs, dog -&gt; dog.getName());</span></pre><p id="e278" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，如何定义实际返回其他函数的函数呢？</p><p id="46a9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在<strong class="ja hv"> <em class="jw"> Scala </em> </strong>中，我们可以做如下操作。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="99b0" class="jx jy hu ld b fv lh li l lj lk">scala&gt; def sum(): (Int, Int) =&gt; Int = (a, b) =&gt; a + b<br/><strong class="ld hv">sum</strong>: <strong class="ld hv">()(Int, Int) =&gt; Int</strong></span><span id="9a86" class="jx jy hu ld b fv ll li l lj lk">scala&gt; sum()<br/><strong class="ld hv">res1</strong>: <strong class="ld hv">(Int, Int) =&gt; Int</strong> = $$Lambda$1067/2036949810@715f45c6</span><span id="55d3" class="jx jy hu ld b fv ll li l lj lk">scala&gt; sum()(4,5)<br/><strong class="ld hv">res2</strong>: <strong class="ld hv">Int</strong> = 9</span><span id="ea9f" class="jx jy hu ld b fv ll li l lj lk">scala&gt; res1(2, 3)<br/><strong class="ld hv">res3</strong>: <strong class="ld hv">Int</strong> = 5</span></pre><p id="44d8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，<strong class="ja hv"> <em class="jw"> sum </em> </strong>返回一个函数，可以存储并在另一个时间求值。这是函数式语言非常强大和重要的构造。我们能在Java中做同样的事情吗？</p><p id="931b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们首先为这个特殊的问题定义我们自己的函数类型(<strong class="ja hv"> <em class="jw">函数接口</em> </strong>)。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="7b7c" class="jx jy hu ld b fv lh li l lj lk">@FunctionalInterface<br/>interface TakeTwo <em class="jw">{<br/>    </em>Integer apply<em class="jw">(</em>Integer a, Integer b<em class="jw">)</em>;<br/><em class="jw">}</em></span></pre><p id="9bcd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们所见，<strong class="ja hv"> <em class="jw"> TakeTwo </em> </strong>在语义上与我们在<strong class="ja hv"> <em class="jw"> Scala </em> </strong>中定义的相同。</p><p id="dd39" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们可以再次定义<strong class="ja hv"><em class="jw"/></strong>求和方法。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="3230" class="jx jy hu ld b fv lh li l lj lk">TakeTwo sum<em class="jw">() {<br/>    </em>return <em class="jw">(</em>a, b<em class="jw">) </em>-&gt; a + b;<br/><em class="jw">}</em></span><span id="c769" class="jx jy hu ld b fv ll li l lj lk">TakeTwo mySum = <em class="jw">sum()</em>;<br/><br/>Integer finalSum = mySum.apply<em class="jw">(</em>5, 6<em class="jw">)</em>;</span></pre><p id="e116" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这和我们在<strong class="ja hv"> <em class="jw"> Scala </em> </strong>中做的完全一样，只是在<strong class="ja hv"> <em class="jw"> Scala </em> </strong>中，语法简洁，不需要定义一个<strong class="ja hv"> <em class="jw">函数接口</em> </strong>作为函数类型使用。是的，达到了同样的结果。</p><p id="38c6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样，我们实际上不必自己定义<strong class="ja hv"> <em class="jw"> TakeTwo </em> </strong>，因为在<strong class="ja hv"> <em class="jw"> Java </em> </strong>中已经定义了一个等价的接口，名为<strong class="ja hv"> <em class="jw"> BiFunction </em> </strong>。通过使用它，我们可以用下面的方式写出<strong class="ja hv"> <em class="jw"> sum </em> </strong>。</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="811a" class="jx jy hu ld b fv lh li l lj lk">BiFunction<em class="jw">&lt;</em>Integer, Integer, Integer<em class="jw">&gt; </em>sum<em class="jw">() {<br/>    </em>return <em class="jw">(</em>a, b<em class="jw">) </em>-&gt; a + b;<br/><em class="jw">}</em></span></pre><h2 id="0a11" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">更多的功能界面。</h2><p id="139e" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">为了支持函数式编程的努力，<strong class="ja hv"> <em class="jw"> Java </em> </strong>融合了很多这些<strong class="ja hv"> <em class="jw">函数接口</em> </strong>。其中一些是:</p><h2 id="4694" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">消费者</h2><p id="b116" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated"><em class="jw"> Java: </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="60a2" class="jx jy hu ld b fv lh li l lj lk">public interface Consumer<em class="jw">&lt;</em>T<em class="jw">&gt; {<br/>    </em>void accept<em class="jw">(</em>T t<em class="jw">)</em>;<br/>    ....<br/>}</span></pre><p id="56b4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw"> Scala </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="8d60" class="jx jy hu ld b fv lh li l lj lk">T =&gt; Unit</span></pre><h2 id="10aa" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">述语</h2><p id="f4f2" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated"><em class="jw"> Java </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="3e84" class="jx jy hu ld b fv lh li l lj lk">public interface Predicate<em class="jw">&lt;</em>T<em class="jw">&gt; {<br/>    </em>boolean test<em class="jw">(</em>T t<em class="jw">)</em>;<br/>    ...<br/>}</span></pre><p id="a9f9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw"> Scala </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="3b18" class="jx jy hu ld b fv lh li l lj lk">T =&gt; boolean</span></pre><h2 id="39dd" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">供应者</h2><p id="2bfd" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated"><em class="jw"> Java </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="531c" class="jx jy hu ld b fv lh li l lj lk">public interface Supplier<em class="jw">&lt;</em>T<em class="jw">&gt; {<br/>    </em>T get<em class="jw">()</em>;<br/><em class="jw">}</em></span></pre><p id="2fed" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw"> Scala </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="00ea" class="jx jy hu ld b fv lh li l lj lk">:=&gt; T</span></pre><h2 id="1838" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">功能</h2><p id="7982" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated"><em class="jw"> Java </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="f4e6" class="jx jy hu ld b fv lh li l lj lk">public interface Function<em class="jw">&lt;</em>T, R<em class="jw">&gt; {<br/>    </em>R apply<em class="jw">(</em>T t<em class="jw">)</em>;<br/>    ...<br/>}</span></pre><p id="aa05" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw"> Scala </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="e934" class="jx jy hu ld b fv lh li l lj lk">T =&gt; R</span></pre><h2 id="e48a" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">双功能</h2><p id="21ad" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated"><em class="jw"> Java </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="a4eb" class="jx jy hu ld b fv lh li l lj lk">public interface BiFunction<em class="jw">&lt;</em>T, U, R<em class="jw">&gt; {<br/>     </em>R apply<em class="jw">(</em>T t, U u<em class="jw">)</em>;<br/>     ...<br/>}</span></pre><p id="eba3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw"> Scala </em></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="0b8d" class="jx jy hu ld b fv lh li l lj lk">(T, U) =&gt; R</span></pre><p id="cfed" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这些只是在新的<strong class="ja hv"><em class="jw"/></strong>和它们在<strong class="ja hv"> <em class="jw"> Scala </em> </strong>中的对应物中可以找到的几种函数类型(<strong class="ja hv"> <em class="jw">函数接口</em> </strong>)。注意，在<strong class="ja hv"> <em class="jw"> Scala </em> </strong>中，我们不需要为它们定义任何接口，我们只需要这些函数就可以了，我们可以随心所欲地定义它们。</p><h2 id="04fd" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">结论</h2><p id="121d" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">不知何故，<strong class="ja hv"> <em class="jw"> Java </em> </strong>肯定是在向函数式编程发展，尽管语法不是最方便的，但结果是一样的。</p><p id="dfdf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> <em class="jw"> Scala </em> </strong>语法，另一方面，要精确得多，更好地展示了意图，不需要创建接口作为函数类型。</p><p id="38b8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我只希望<strong class="ja hv"> <em class="jw"> Java </em> </strong>继续发展，同时减少冗长并增加新的功能结构，因为最终，我们，工程师，是从中获得真正利益的人。</p></div></div>    
</body>
</html>