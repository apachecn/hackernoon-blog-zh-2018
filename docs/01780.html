<html>
<head>
<title>The 3 essential rules of really-reusable JavaScript components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">真正可重用的JavaScript组件的3个基本规则</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-3-essential-rules-of-really-reusable-javascript-components-123a54d092a5?source=collection_archive---------6-----------------------#2018-02-26">https://medium.com/hackernoon/the-3-essential-rules-of-really-reusable-javascript-components-123a54d092a5?source=collection_archive---------6-----------------------#2018-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bacfa9576ab6b9492a100e3c945ed70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Z70IQqVoyfZ9P9_hSBtVg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">How can I reuse this supposedly reusable component in the page I’m building?</figcaption></figure><p id="0609" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以你用的是基于组件的框架比如React JS，Vue JS，还是最新的Angular？React在几年前普及了组件的概念，作为重用代码和更有效地构建web应用程序的一种方式。</p><blockquote class="ke kf kg"><p id="2ef9" class="jg jh kh ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">当我向VueJS介绍这个团队时，这位43岁的同事持怀疑态度，他说:“这在理论上很棒，但根据我的经验，这些花哨的“可重复使用”的东西从来不会被重复使用。</p></blockquote><p id="0e4d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">随着项目的进行，事实证明他基本上是对的。这种基于组件的接口新范式的出现留下了许多未解之谜:</p><p id="b233" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你如何定义一个组件的范围？如何决定一个组件中应该包含哪些内容，哪些内容应该留给单独的组件？你把款式放在哪里？<br/>在什么情况下，拥有两个独立但更简单的组件比一个过于复杂的通用组件更好？</p><blockquote class="kl"><p id="486d" class="km kn hu bd ko kp kq kr ks kt ku kd ek translated">TL，DR，可重用组件的3个基本规则:<br/> -尽可能少的组件<br/> -组件应该“足够通用”，理想情况下，应该在构建时从应用程序页面中有机提取<br/> -两个简单的组件比一个通用的复杂组件要好</p></blockquote><p id="4108" class="pw-post-body-paragraph jg jh hu ji b jj kv jl jm jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd hn dt translated"><em class="kh">注意:本文中的大多数例子都使用了React，但是基本思想适用于任何基于JS组件的框架，比如Vue或Angular。</em></p><h1 id="1b02" class="la lb hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">制造尽可能少的组件</h1><h2 id="dc93" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">问题:组件树中有太多的层。</h2><p id="1e1a" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">对于我的第一个React应用程序，我犯了一个错误，把简单的功能分成了太多的组件。我几乎为每个“div”层都做了一个组件…这意味着在组件树中传递道具浪费了很多时间。这很乏味，如果你在一层中忘记了一个道具，应用程序就会崩溃。每当您想要更改链中组件的签名时，或者每当prop类型更改时，您都需要在每一层进行更改。<br/>当你把你的应用分成比绝对必要的更多的组件时，会对开发速度产生负面影响，也会对性能产生负面影响:更多的函数调用，更多的文件需要解析和捆绑(见<a class="ae mr" href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/" rel="noopener ugc nofollow" target="_blank">小模块的成本</a>)。</p><h2 id="1f72" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">解决方案:仅在绝对必要时将页面或块划分为多个组件。</h2><p id="e24d" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在GitHub上看别人的React代码，让我意识到自己哪里做错了。</p><p id="8879" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kh">例子:一个带有链接列表的菜单。</em></p><p id="b622" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">过去，我会自发地创建两个组件:一个MenuGroup组件和一个MenuItem组件。</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="a665" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这会有用的。但是，如果Menu link不是动态的，最好避免制作一个MenuItem组件，而是在一个菜单组件中描述整个菜单，并使用硬编码的数据:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="c859" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要减少组件数量，请避免制作只添加样式的组件。与其有一个BlueButton组件，不如只使用一个html标签“Button”并添加一个“.”。“班蓝来了。</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="cd1e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一般来说，如果你希望一个组件是可重用的，那么就尽可能少的设计它。我将可重用的样式放在不同的文件夹中，然后在需要时将它们导入组件。作为一般规则，如果有自定义逻辑，则只制作单独的组件。我不会做一个BlueButton，但可以做一个AddItemToCartButton。</p><h1 id="0f1d" class="la lb hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">组件应该“足够通用”</h1><h2 id="13e0" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">问题:简单还是通用？</h2><p id="6f34" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在只涵盖少数用例的简单组件和可以在许多情况下使用但有很多道具且更复杂的通用组件之间有一个权衡。</p><h2 id="6259" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">解决方案:只有在必要时才使用外部组件库。</h2><p id="bd24" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">代码重用或重新发明轮子就这么多了？对我来说，像<a class="ae mr" href="https://react-bootstrap.github.io/getting-started/introduction" rel="noopener ugc nofollow" target="_blank"> React-bootstrap </a>这样的库的目的不是作为你项目中的一个插件。我只是看看他们的代码，看看他们是如何解决我在构建自己的定制组件时面临的一些问题的。比如如何制作一个无限滚动组件，或者一个拖拽&amp; drop来上传文件。我将复制核心思想，通常不超过10行代码，然后围绕它构建自己的组件，消除大量臃肿和不必要的复杂性。</p><p id="bb98" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">来自外部库的通用组件的问题是，它们必须覆盖许多与您的项目无关的用例，这使得您的代码库臃肿且难以阅读。它们通常包含样式，这使得它们很难被插入到你的页面中。</p><p id="aa7b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">根据经验，理解外部库中组件的API是如何工作的，包括其不可避免的怪癖，通常比自己制作组件需要更长的时间。</p><p id="d39d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">同样，如果你希望一个组件是通用的，那么就尽量少用样式。</p><h2 id="ee76" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">用老虎机代替道具</h2><p id="1a53" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">只要有可能，就用老虎机代替道具。在Vue JS中，这意味着使用命名槽。在React中，你只有一个默认槽，建议使用高阶组件(即decorators)来添加功能，而不是道具。</p><p id="ac45" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kh">举例:与其把称号当道具收下，不如放在槽里:</em></p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="ee1a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从长远来看，这将使组件更具可读性，并使访问子组件的样式更加容易。</p><h2 id="f8c1" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">当使一个组件可重用时，将它直接连接到全局状态。</h2><p id="737c" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">如果组件应该在不同的上下文中使用，那么只需将从直接父组件继承的数据放入props中。只要有可能，就使用“react-redux”连接方法直接从全局状态获取数据。这样，如果一些数据只在这个组件中需要，您就不需要将它传递给整个组件树。</p><p id="2211" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kh">示例:显示当前用户信息的块可以从全局状态获取数据，而不是从其父状态接收数据。</em></p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><h1 id="3d4a" class="la lb hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">两个简单的组件比一个通用的复杂组件要好</h1><h2 id="c249" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">问题是:复制比破解更容易，而重用却不容易</h2><p id="9070" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">通常情况下，团队成员复制组件文件，修改它以适应他正在处理的页面，并以不同的名称保存文件，比“按原样”使用组件更快。一个组件只有在你看到其他团队成员在使用它，并且他们真的节省了使用该组件的时间时，才证明了它的可重用性。如果您或您的同事正在考虑“我如何才能让这个组件适合那个页面？”，你做错了。</p><blockquote class="ke kf kg"><p id="5a8f" class="jg jh kh ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">自顶向下的方法包括首先构建(或下载)组件库，然后尝试将它放入您应该构建的页面中。</p></blockquote><figure class="ms mt mu mv fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/2a5598b860a6ed449547a2d512a67696.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*-2A9MQWVvOePX53VvAejmA.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">This component won’t fit in that page.</figcaption></figure><h2 id="fa08" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated">解决方案是:使用自下而上的方法。首先构建页面，然后从应用程序中有机地提取组件。</h2><p id="dd0b" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">代码重用很好，但是开发速度更重要。可以从复制现有组件开始。这两个部分有时可以在以后合并。</p><blockquote class="kl"><p id="2bfe" class="km kn hu bd ko kp kq kr ks kt ku kd ek translated">这里有一个简单的开发工作流程，强调了上面概述的3条规则:<br/> 1)首先在单个组件中构建第一个页面<br/> 2)在单个组件中构建第二个页面<br/> 3)如果且仅当两个页面之间有公共组件，将它们通用化并提取到一个单独的文件夹中。</p></blockquote><p id="8ff4" class="pw-post-body-paragraph jg jh hu ji b jj kv jl jm jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd hn dt translated">通过这种方式，随着时间的推移，将会出现一个定制组件库，为您的应用程序量身定制。</p><p id="f120" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你觉得这篇文章有帮助，一定要看看<a class="ae mr" rel="noopener" href="/front-end-hacking/react-without-webpack-a-dream-come-true-6cf24a1ff766">React Without web pack:fast Developer Workflow</a>，它解释了如何在开发过程中避免构建步骤。</p></div></div>    
</body>
</html>