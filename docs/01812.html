<html>
<head>
<title>Introducing Wrek — A Miniature Erlang Graph Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Wrek——一个微型Erlang图形引擎</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-wrek-a-miniature-erlang-graph-engine-79196e7ea457?source=collection_archive---------38-----------------------#2018-02-26">https://medium.com/hackernoon/introducing-wrek-a-miniature-erlang-graph-engine-79196e7ea457?source=collection_archive---------38-----------------------#2018-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a1dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由<a class="ae jp" href="https://github.com/rkallos" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">理查德·卡洛</strong>T3】</a></p><p id="57e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/rkallos/wrek" rel="noopener ugc nofollow" target="_blank"> Wrek </a>是我为并发执行任务依赖图编写的Erlang库。它的预期目的是运行一组预定义的任务，这些任务之间有一个偏序。在这篇文章中，我解释了我为什么写wrek，它可以用来做什么，以及如何使用它。</p><h1 id="4167" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">动机</h1><p id="c32b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">雷克的出现是两种截然不同的力量的结果。首先，我对图论的业余爱好使我试图在任何可能的地方看到图形，为这个库奠定了概念基础。其次，我意识到我在Adgear工作的一个项目将受益于这样一个库，这促使我最终开始编写Wrek。</p><h1 id="a849" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">概念的</h1><p id="3d38" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">图是计算中普遍存在的数据结构。当我在学校了解到图算法时，我惊讶于它的广泛应用。图在编译器和构建系统中扮演着重要的角色。各种图形算法构成了我们在互联网上相互交流的基础。</p><p id="8dad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的日常生活往往充满了清单。我们有任务清单、购物清单、食谱、清单、说明书等等。有一天，我意识到这些名单有些是骗人的。其中一些列表实际上是隐藏在列表外衣下的图表；这些列表是<a class="ae jp" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图</a>的<a class="ae jp" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">拓扑排序</a>。两个更明显的例子是待办事项清单和食谱。你不能寄一封还没写的信，也不能煮一壶水就做意大利面。</p><p id="61fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦这些鬼鬼祟祟的图表被发现，我就花了一些时间思考如何从对待各种列表中获益，就像它们实际上是Dag一样。这些清单和Dag之间最明显的相似之处是待办事项清单和食谱。这些非常相似的<a class="ae jp" href="https://en.wikipedia.org/wiki/Dependency_graph" rel="noopener ugc nofollow" target="_blank">依赖图</a>。与列表表示不同，这些依赖图显示了哪些顶点(单个任务)可以并发执行。有时这是显而易见的(例如:我可以在等水烧开的时候切菜！当第一批饼干在烤箱里的时候，我可以开始准备第二份烤饼干了！)，但是我希望将列表重新表示为依赖图的行为可以暴露更多并发的机会。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="42d5" class="lc jr hu ky b fv ld le l lf lg">                Boil water -- Add pasta -- Cook pasta --.<br/>                                                         \<br/>  Purée tomatoes --.                                      \<br/>                    \                                      \<br/>  Chop vegetables -- Combine in saucepan -- Simmer sauce -- Combine pasta and sauce -- Serve<br/>                    /<br/>      Add spices --'</span></pre><p id="bbf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上图中顶点之间的边表示偏序。之间没有路径的顶点可以同时执行。图中顶点之间的关系反映了厨房里的真实情况。我们可以边煨调味汁边煮意大利面。我们是先切蔬菜还是先切西红柿泥并不重要；如果我们要做调味酱的话，它们都需要做。</p><p id="2b12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管我尽了最大努力，我在厨房里仍然是一个灾难。作为改变这一不方便的事实的一种方法，我认为尝试用有向图来表示食谱会很有趣，并带有额外的数据，如每一步预计需要多长时间。这件事在我的“将来某一天的项目”清单上放了很长时间，只有当我开始思考我在$JOB工作的一个项目时，我才会想起它。</p><h1 id="1757" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">实际的</h1><p id="3de0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我去年在Adgear完成的一个项目是，移除我们每台已经达到极限的边缘服务器上正在进行的昂贵计算，并用一个在单台机器上执行昂贵计算的系统取而代之，然后分发结果。这个系统在没人碰它的时候工作，但它的程序相当于树枝和胶带；cron作业和shell脚本。这个系统使用起来仍然很痛苦，在CPU资源匮乏的机器上进行昂贵计算的例子越来越多。此时，开始编写一个更健壮的系统是有意义的。</p><p id="32a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些昂贵的计算被很好地分解成要执行的步骤列表。获取这些数据，进行转换，再进行一些转换，将一些数据发送到这组服务器，将另一些数据发送到另一组服务器。Shell脚本非常擅长编码这些管道，所以在实现时这是一个可以接受的选择。过了一会儿，我明白了，这些步骤列表并不是真正的列表；它们是依赖图。我试图通过添加一些后台作业和waitpid来揭示shell脚本中潜在的并发性，但是最终决定改用Erlang并从OTP提供的所有功能中获益会更有意义。</p><h1 id="c4b4" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">让我们开始吧</h1><p id="5c43" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">(不好意思。我无法抗拒。)</p><p id="3179" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Wrek接受像上面的意大利面条食谱这样的依赖图作为输入，并执行每个顶点。只要能够执行，并发执行动作的本质对于任何可以由依赖图表示的问题都是通用的。依赖图的结构，以及图的每个顶点所涉及的任务都是根据用户的愿望而特定的。遵循与检察官办公室相同的通用/专用划分；这类问题的一般部分由<code class="eh li lj lk ky b">wrek</code>和<code class="eh li lj lk ky b">wrek_vert</code>模块解决。特定部分由用户以描述图中每个顶点的Erlang图的形式提供，以及一组实现<code class="eh li lj lk ky b">wrek_vert</code> <strong class="it hv"> </strong>行为的回调模块。</p><p id="cc79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">wrek_vert</code> <strong class="it hv"> </strong>行为由一个回调<code class="eh li lj lk ky b">run/2</code>组成，其中第一个参数是要发送给回调函数的参数列表，第二个参数是可以提供其他顶点生成的信息的进程的ID。这个回调函数的预期结果是</p><p id="e82e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">{ok, Any :: any()}</code> <strong class="it hv"> </strong>或<strong class="it hv"> </strong> <code class="eh li lj lk ky b">{error, Reason :: any()}</code>。如果回调函数成功，<code class="eh li lj lk ky b">Any</code>将被wrek获取，并可供其他<code class="eh li lj lk ky b">wrek_vert</code>进程使用。如果回调函数崩溃或返回一个错误，整个图形将被关闭。</p><h1 id="6d76" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">做二郎面</h1><p id="0a47" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">按照上面这个虚构的例子，让我们开始使用wrek制作意大利面。当然，我们的程序不会真的做出意大利面，但是它的输出应该会愚弄一些人。</p><p id="306e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看上面的图表，每一步似乎做三件事之一:</p><ol class=""><li id="353c" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">添加配料</li><li id="1401" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">在容器中混合配料</li><li id="9acd" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">对容器中的配料做些什么</li></ol><p id="7e35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们继续为每个动作写一些<code class="eh li lj lk ky b">wrek_vert</code>。如果你不喜欢使用文本编辑器，完整的代码可以在这里找到。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c22f" class="lc jr hu ky b fv ld le l lf lg">-module(cook_add).</span><span id="3e0d" class="lc jr hu ky b fv lz le l lf lg">-behaviour(wrek_vert).<br/>-export([run/2]).</span><span id="3fd6" class="lc jr hu ky b fv lz le l lf lg">run([Ingredient, Quantity], _Pid) -&gt;<br/> io:format(“adding ~s. amount: ~s.~n”, [Ingredient, Quantity]),<br/> {ok, #{added =&gt; [{Ingredient, Quantity}]}}.</span></pre><p id="8dfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">cook_add</code>到此为止。它打印一条消息，然后生成一个添加了一个键的map，该键的值是一个只有一对的proplist。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3e9a" class="lc jr hu ky b fv ld le l lf lg">-module(cook_heat).</span><span id="312c" class="lc jr hu ky b fv lz le l lf lg">-behaviour(wrek_vert).<br/>-export([run/2]).</span><span id="9f00" class="lc jr hu ky b fv lz le l lf lg">run([Verb, Noun], _Pid) -&gt;<br/>    io:format("~ping ~p.~n", [Verb, Noun]),<br/>    {ok, #{}}.</span></pre><p id="2169" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">cook_heat</code>也挺短的。也很抽象。它可以用来打印任何关于<strong class="it hv"> </strong> <code class="eh li lj lk ky b">Verb</code>的信息，而不仅仅是烹饪原料！</p><p id="9223" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的最后一个回调模块稍微长一点，因为它做的比打印消息多一点。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="610a" class="lc jr hu ky b fv ld le l lf lg">-module(cook_combine).</span><span id="3083" class="lc jr hu ky b fv lz le l lf lg">-behaviour(wrek_vert).<br/>-export([run/2]).</span><span id="15ad" class="lc jr hu ky b fv lz le l lf lg">run([Ingredients, Vessel], Pid) -&gt;<br/>    Fun = fun(Step, Acc) -&gt;<br/>              Stuff = wrek_vert:get(Pid, Step, added),<br/>              io:format("combining ~p with ~p in ~p.~n", [Stuff, Acc, Vessel]),<br/>              Stuff ++ Acc<br/>          end,<br/>    Stuff = lists:foldl(Fun, [], Ingredients),<br/>    io:format("~p now contains: ~p.~n", [Vessel, Stuff]),<br/>    {ok, #{added =&gt; Stuff}}.</span></pre><p id="5241" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh li lj lk ky b">Ingredients</code>应该是顶点名称的列表。我们最后使用父进程的Pid作为<code class="eh li lj lk ky b">wrek_vert:get/3</code>的参数。这让我们消费由<code class="eh li lj lk ky b">cook_add</code> <strong class="it hv"> </strong>回调模块产生的数据。在组合所有东西之后，我们返回一个新的成分集合。</p><p id="8f87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧！我们差不多已经描述完了问题的具体部分！最后一步是根据这些回调模块和我们要传递给它们的参数来表示我们的依赖图。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="9248" class="lc jr hu ky b fv ld le l lf lg">-module(wrek_example).</span><span id="553c" class="lc jr hu ky b fv lz le l lf lg">-export([make_pasta/0]).</span><span id="3a97" class="lc jr hu ky b fv lz le l lf lg">make_pasta() -&gt;<br/>    application:ensure_all_started(wrek),<br/>    Graph = #{<br/>      tomatoes =&gt; #{<br/>        module =&gt; cook_add,<br/>        args =&gt; ["pureed tomatoes", "1 can"],<br/>        deps =&gt; []<br/>       },<br/>      vegetables =&gt; #{<br/>        module =&gt; cook_add,<br/>        args =&gt; ["chopped vegetables", "lots"],<br/>        deps =&gt; []<br/>       },<br/>      spices =&gt; #{<br/>        module =&gt; cook_add,<br/>        args =&gt; ["spices", "to taste"],<br/>        deps =&gt; []<br/>       },<br/>      saucepan =&gt; #{<br/>        module =&gt; cook_combine,<br/>        args =&gt; [[tomatoes, vegetables, spices], saucepan],<br/>        deps =&gt; [tomatoes, vegetables, spices]<br/>       },<br/>      simmer_sauce =&gt; #{<br/>        module =&gt; cook_heat,<br/>        args =&gt; [simmer, sauce],<br/>        deps =&gt; [saucepan]<br/>       },<br/>      boil_water =&gt; #{<br/>        module =&gt; cook_heat,<br/>        args =&gt; [boil, water],<br/>        deps =&gt; []<br/>       },<br/>      add_pasta =&gt; #{<br/>        module =&gt; cook_add,<br/>        args =&gt; ["pasta", "1 handful"],<br/>        deps =&gt; [boil_water]<br/>       },<br/>      cook_pasta =&gt; #{<br/>        module =&gt; cook_heat,<br/>        args =&gt; [cook, pasta],<br/>        deps =&gt; [add_pasta]<br/>       },<br/>      mix_pasta_with_sauce =&gt; #{<br/>        module =&gt; cook_combine,<br/>        args =&gt; [[saucepan, add_pasta], saucepan],<br/>        deps =&gt; [simmer_sauce, cook_pasta]<br/>       }<br/>     },<br/>    wrek:start(Graph).</span></pre><p id="cb19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">真是满眼都是！我们在这里所做的是创建一个Erlang映射，它的键表示我们原始依赖图中顶点的名称，它的值是指定回调模块、传递给回调模块的参数以及顶点可能具有的任何依赖关系的映射。我祝贺那些注意到我们从不过滤意大利面的人；我承认在厨房里是个灾难。我保证我吸取了教训。</p><p id="5e9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，我们完成编码了！让我们做一个贝壳，做一些意大利面吧！</p></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="756e" class="jq jr hu bd js jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn dt translated">在<a class="ae jp" href="http://www2.erlang-solutions.com/l/23452/2018-02-26/5bm6dr" rel="noopener ugc nofollow" target="_blank"> codesync.global </a>上阅读这篇博文的其余部分</h1><figure class="kt ku kv kw fq mn fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mm"><img src="../Images/0540daea6bee9bbed40a59748d6510e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*stGiv42Uzlav10rt.jpeg"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Code BEAM SF 2018: 15–16 March 2018</figcaption></figure><p id="5b0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">加入CodeBEAM SF的AdGear开发人员Richard Kallos，他将在这里发表关于<strong class="it hv"> wrek </strong>的演讲。</p><p id="dd76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lh">最初发布于</em><a class="ae jp" href="http://www2.erlang-solutions.com/l/23452/2018-02-26/5bm6dr" rel="noopener ugc nofollow" target="_blank"><em class="lh">codesync . global</em></a><em class="lh">。</em></p></div></div>    
</body>
</html>