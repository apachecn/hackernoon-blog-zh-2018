<html>
<head>
<title>Point-free gotchas in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的无要点陷阱</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/point-free-gotchas-in-javascript-d5c1f8fa5391?source=collection_archive---------39-----------------------#2018-02-26">https://medium.com/hackernoon/point-free-gotchas-in-javascript-d5c1f8fa5391?source=collection_archive---------39-----------------------#2018-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="637c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我是函数式<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的忠实粉丝，我喜欢它的简洁，它更适合我的思维方式。我也喜欢尽可能少冗余的干净代码。话虽如此，无要点(有时也称为心照不宣)风格吸引我也就不足为奇了。在过去的几天里，我在<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中应用这种风格时遇到了几个问题，并决定把它们写下来。</p><h1 id="d9c5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">什么是无点风格</h1><p id="91e7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">正如维基百科所说:</p><blockquote class="kt ku kv"><p id="e7b5" class="ir is kw it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><em class="hu">【无点】是一种编程范式，其中函数定义不标识它们所操作的自变量(或“点”)。</em></p></blockquote><p id="bb16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这乍一看似乎很奇怪，但是让我们用一个简单的例子。假设我们有一个函数，它获取一个字符串，并返回首字母大写的字符串。接下来，我们有一系列我们都想资本化的字符串。这是<code class="eh la lb lc ld b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map</a></code> <a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">功能</a>的一个简单用例:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="4afa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意第二个<code class="eh la lb lc ld b">map</code>用法，它没有说明参数的名称，也没有创建新函数。这样做的原因是<code class="eh la lb lc ld b">map</code>调用它的第一个参数作为一个带三个参数的函数:</p><ul class=""><li id="59ba" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">要处理的数组项(这是唯一的强制参数)，</li><li id="7b47" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">该项目的索引，</li><li id="2ce9" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">正在处理的整个数组</li></ul><p id="f2dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Out <code class="eh la lb lc ld b">capitalise</code>函数碰巧也把要处理的项目作为它的第一个(也是唯一的)参数，所以在这种情况下，它在使用时是自由的。</p><p id="3860" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种样式有更多的用途，我们将在阅读本文时看到它们。</p><h1 id="be53" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">问题1:函数接受的参数比预期的多</h1><p id="c231" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">第一个问题来自于这样一个事实，即您可以用任意多的参数在JavaScript中调用一个函数——无论是太少还是太多。</p><p id="8dc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您提供的参数太少，那些没有提供的参数将被设置为默认值(即<code class="eh la lb lc ld b">undefined</code>，除非另有说明)。</p><p id="8929" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您提供了太多的参数，该函数会忽略多余的参数(除非它使用了<code class="eh la lb lc ld b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">arguments</a></code> <a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">对象</a>)。</p><p id="c5e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能对你来说并不陌生，但是在无点的情况下，它会导致一些意想不到的结果。</p><p id="58e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们举一个最简单的例子:编写一个函数，它接受一个字符串数组并返回项目的数值。为了举例，我们假设输入是正确的。很简单，有<code class="eh la lb lc ld b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat" rel="noopener ugc nofollow" target="_blank">Number.parseFloat</a></code>来表示:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="7619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们所看到的，无点数版本非常有效。</p><p id="adea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，如果有人告诉我们数字总是整数，我们不需要把它们解析成浮点数，那会怎么样呢？然后我们会把<code class="eh la lb lc ld b">Number.parseFloat</code>换成<code class="eh la lb lc ld b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt" rel="noopener ugc nofollow" target="_blank">Number.parseInt</a></code>，对吗？</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="b396" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇，那是什么？无点版本突然表现得很奇怪。</p><p id="3abe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原因是<code class="eh la lb lc ld b">Number.parseFloat</code>只接受一个参数——要解析的字符串——<code class="eh la lb lc ld b">Number.parseInt</code>接受一个额外的可选参数——要输出的数字的基数(例如十六进制字符串为16)。因此，在这样的地图中使用时，实际情况是这样的:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="df17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们看到的,<code class="eh la lb lc ld b">Number.parseInt</code>的基数参数是使用当前项目的索引设置的。这解释了<code class="eh la lb lc ld b">11</code>输入的<code class="eh la lb lc ld b">3</code>输出为二进制的3 = 11。</p><p id="b8c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是JavaScript中无指针可能产生的第一类问题:函数接受的参数比预期的多。</p><p id="15cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了对您知道其签名并且知道不会改变的函数使用免点之外，没有什么简单的方法来保护您自己，否则您的代码可能会意外中断。</p><h1 id="a176" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">问题2:意外的<code class="eh la lb lc ld b">this</code></h1><p id="51f4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这是我不久前参加的一次求职面试中出现的一个问题:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="a9f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题是修复错误。</p><p id="ad6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们可能会期望<code class="eh la lb lc ld b">"Hello"</code>被输出(我知道我做到了)。然而，<code class="eh la lb lc ld b">undefined</code>被输出到控制台。</p><p id="2414" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原因是<code class="eh la lb lc ld b">setTimeout</code>执行回调函数的方式。<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank">回调在不同的执行上下文</a>中执行，如果<code class="eh la lb lc ld b">this</code>没有被显式设置，它将被设置为<code class="eh la lb lc ld b">global</code>对象。由于<code class="eh la lb lc ld b">global</code>(如果在浏览器中运行，则为<code class="eh la lb lc ld b">window</code>)没有<code class="eh la lb lc ld b">message</code>成员，我们的示例打印了<code class="eh la lb lc ld b">undefied</code>。</p><p id="1cc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有两种方法可以解决这个问题:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="6c99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个使用闭包来隐式地将<code class="eh la lb lc ld b">getMessage</code>调用的<code class="eh la lb lc ld b">this</code>设置为适当的值。</p><p id="1744" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二种(无指针)使用<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="noopener ugc nofollow" target="_blank">绑定方法</a>显式设置<code class="eh la lb lc ld b">this</code> <em class="kw">的值</em>。</p><p id="f830" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有另一个看起来不错的代码示例——简单的常规模式使用:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="ee8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这最终抛出一个<code class="eh la lb lc ld b">TypeError</code>说:</p><blockquote class="kt ku kv"><p id="94c1" class="ir is kw it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><code class="eh la lb lc ld b"><em class="hu">Method RegExp.prototype.test called on incompatible receiver undefined</em></code></p></blockquote><p id="f919" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者在Safari中更有用一点:</p><blockquote class="kt ku kv"><p id="f29e" class="ir is kw it b iu iv iw ix iy iz ja jb kx jd je jf ky jh ji jj kz jl jm jn jo hn dt translated"><code class="eh la lb lc ld b"><em class="hu">RegExp.prototype.test requires that |this| be an Object</em></code></p></blockquote><p id="3820" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，问题是<code class="eh la lb lc ld b">this</code>有一个意外的值(在本例中是<code class="eh la lb lc ld b">undefined</code>)。解决方案与前一种情况相同:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="e502" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里要指出的是，如果你想无指针调用的函数使用了<code class="eh la lb lc ld b">this</code>，你应该非常清楚它被设置为你所期望的。</p><h1 id="6fec" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="3016" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">尽管无点式风格在其他(函数式)语言中很有用，但在JavaScript中，它经常带来一些问题，这些问题可能不值得它带来的简洁性。当被调用的函数在我的控制之下时，我有时仍然使用它。不过，有了这些经历之后，我会更加小心。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lz lk l"/></div></figure></div></div>    
</body>
</html>