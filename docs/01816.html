<html>
<head>
<title>Attoparsec: The Clarity of Do-Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">attoparsec:Do语法的清晰性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/attoparsec-the-clarity-of-do-syntax-95bf47846855?source=collection_archive---------42-----------------------#2018-02-26">https://medium.com/hackernoon/attoparsec-the-clarity-of-do-syntax-95bf47846855?source=collection_archive---------42-----------------------#2018-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/570e9a3bafe1fd30084002beed6c9712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*mKwmI0OBzs2M0FaZf-W7jQ.jpeg"/></div></figure><p id="26b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上周的文章<a class="ae jw" href="https://www.mmhaskell.com/blog/2018/2/19/applicative-parsing-ii-putting-the-pieces-together" rel="noopener ugc nofollow" target="_blank">中，我们完成了对</a><a class="ae jw" href="https://hackage.haskell.org/package/regex-applicative" rel="noopener ugc nofollow" target="_blank">应用解析</a>库的研究。我们把所有较小的组合子放在一起，解析我们的小黄瓜语法。本周，我们将看看一个新的库:<a class="ae jw" href="https://hackage.haskell.org/package/attoparsec" rel="noopener ugc nofollow" target="_blank"> Attoparsec </a>。这个库使用一元的方法，而不是试图使用一个纯粹的应用结构做所有的事情。这种方法更常见。这使得语法更容易阅读和理解。这也将使我们更容易添加某些功能。</p><p id="bce5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要了解本文的代码，请看一下Github上的<code class="eh jx jy jz ka b"><a class="ae jw" href="https://github.com/jhb563/GherkinParsing/tree/attoparsec" rel="noopener ugc nofollow" target="_blank">attoparsec</a></code>分支！关于有用库的一些更好的想法，下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">产品清单</a>！它包括从数据结构到机器学习的各种库资料！</p><p id="c19d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你是Haskell的新手，一定要下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>！它将告诉您开始Haskell之旅所需的所有步骤！</p><h1 id="ab8b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">分析器类型</h1><p id="353e" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">在应用解析中，我们所有的解析器都有类型<code class="eh jx jy jz ka b">RE Char</code>。这个类型属于<code class="eh jx jy jz ka b">Applicative</code>类型类，但不是<code class="eh jx jy jz ka b">Monad</code>。对于Attoparsec，我们将使用<code class="eh jx jy jz ka b">Parser</code>类型，一个完整的单子。所以一般来说，我们将编写以下类型的解析器:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="81a2" class="lm kc hu ka b fv ln lo l lp lq">featureParser :: Parser Feature<br/>scenarioParser :: Parser Scenario<br/>statementParser :: Parser Statement<br/>exampleTableParser :: Parser ExampleTable<br/>valueParser :: Parser Value</span></pre><h1 id="5cfe" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">解析值</h1><p id="97c7" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">我们首先应该意识到的是，我们的解析器仍然是一个<code class="eh jx jy jz ka b">Applicative</code>！所以不是一切都需要改变！我们仍然可以使用像<code class="eh jx jy jz ka b">*&gt;</code>和<code class="eh jx jy jz ka b">&lt;|&gt;</code>这样的操作符。事实上，我们可以让我们的值解析代码几乎完全一样！例如，<code class="eh jx jy jz ka b">valueParser</code>、<code class="eh jx jy jz ka b">nullParser</code>和<code class="eh jx jy jz ka b">boolParser</code>表达式可以保持不变:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="db47" class="lm kc hu ka b fv ln lo l lp lq">valueParser :: Parser Value<br/>valueParser =<br/>  nullParser &lt;|&gt;<br/>  boolParser &lt;|&gt;<br/>  numberParser &lt;|&gt;<br/>  stringParser</span><span id="71b0" class="lm kc hu ka b fv lr lo l lp lq">nullParser :: Parser Value<br/>nullParser =<br/>  (string "null" &lt;|&gt;<br/>  string "NULL" &lt;|&gt;<br/>  string "Null") *&gt; pure ValueNull</span><span id="684d" class="lm kc hu ka b fv lr lo l lp lq">boolParser :: Parser Value<br/>boolParser = (trueParser *&gt; pure (ValueBool True)) &lt;|&gt; (falseParser *&gt; pure (ValueBool False))<br/>  where<br/>    trueParser = string "True" &lt;|&gt; string "true" &lt;|&gt; string "TRUE"<br/>    falseParser = string "False" &lt;|&gt; string "false" &lt;|&gt; string "FALSE"</span></pre><p id="cc79" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们愿意，我们可以在不改变它们的结构的情况下使它们更“一元”。例如，我们可以用<code class="eh jx jy jz ka b">return</code>代替<code class="eh jx jy jz ka b">pure</code>(因为它们是相同的)。我们也可以用<code class="eh jx jy jz ka b">&gt;&gt;</code>代替<code class="eh jx jy jz ka b">*&gt;</code>来执行一元操作，同时丢弃一个结果。我们的数值解析器有一点变化，但是变得更简单了！Attoparsec的作者提供了一个方便的解析器来读取科学数字:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="742f" class="lm kc hu ka b fv ln lo l lp lq">numberParser :: Parser Value<br/>numberParser = ValueNumber &lt;$&gt; scientific</span></pre><p id="8ab8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后对于字符串值，我们将使用<code class="eh jx jy jz ka b">takeTill</code>组合符读取所有字符，直到出现竖线或换行符。然后，我们将应用一些文本函数来删除空白，并将其返回给一个<code class="eh jx jy jz ka b">String</code>。(我们使用的<code class="eh jx jy jz ka b">Parser</code>单子将事物解析为<code class="eh jx jy jz ka b">Text</code>而不是<code class="eh jx jy jz ka b">String</code>。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="7cef" class="lm kc hu ka b fv ln lo l lp lq">stringParser :: Parser Value<br/>stringParser = (ValueString . unpack . strip) &lt;$&gt; <br/>  takeTill (\c -&gt; c == '|' || c == '\n')</span></pre><h1 id="2829" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">解析示例</h1><p id="d2e8" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">当我们解析示例表时，我们将通过使用do-syntax切换到一种更为单一的方法。首先，我们建立一个<code class="eh jx jy jz ka b">cellParser</code>来读取单元格内的值。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="dc1d" class="lm kc hu ka b fv ln lo l lp lq">cellParser = do<br/>  skipWhile nonNewlineSpace<br/>  val &lt;- valueParser<br/>  skipWhile (not . barOrNewline)<br/>  char '|'<br/>  return val</span></pre><p id="2021" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们语句中的每一行都是指解析过程中的一个步骤。所以首先我们跳过所有的前导空格。然后我们解析我们的值。然后我们跳过剩余的空格，解析最后一个竖线来结束单元格。然后我们将返回解析后的值。</p><p id="a96f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">与应用语法相比，跟踪这里发生的事情要容易得多。不难看出我们丢弃了输入的哪些部分，使用了哪些部分。如果我们不在do-syntax中用<code class="eh jx jy jz ka b">&lt;-</code>赋值，我们就丢弃这个值。如果我们找回它，我们会用它。为了完成<code class="eh jx jy jz ka b">exampleLineParser</code>，我们解析初始栏，获取许多值，关闭该行，然后返回它们:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="a110" class="lm kc hu ka b fv ln lo l lp lq">exampleLineParser :: Parser [Value]<br/>exampleLineParser = do<br/>  char '|'<br/>  cells &lt;- many cellParser<br/>  char '\n'<br/>  return cells<br/>  where<br/>    cellParser = ...</span></pre><p id="3e16" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">读取表的键几乎是相同的。所改变的只是我们的<code class="eh jx jy jz ka b">cellParser</code>用<code class="eh jx jy jz ka b">many letter</code>代替了<code class="eh jx jy jz ka b">valueParser</code>。所以现在我们可以把这些片段放在一起，为我们的<code class="eh jx jy jz ka b">exampleTableParser</code>:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e6a9" class="lm kc hu ka b fv ln lo l lp lq">exampleTableParser :: Parser ExampleTable<br/>exampleTableParser = do<br/>  string "Examples:"<br/>  consumeLine<br/>  keys &lt;- exampleColumnTitleLineParser<br/>  valueLists &lt;- many exampleLineParser<br/>  return $ ExampleTable keys (map (zip keys) valueLists)</span></pre><p id="59b6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们阅读信号字符串“Examples:”后，使用该行。然后我们得到我们的键和值，并用它们建立表。同样，这比在应用语法中映射像<code class="eh jx jy jz ka b">buildExampleTable</code>这样的函数要简单得多。</p><h1 id="dcf9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">声明</h1><p id="f9a1" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated"><code class="eh jx jy jz ka b">Statement</code>解析器是我们可以提高代码清晰度的另一个领域。我们将再次定义两个助手解析器。这些函数将分别获取括号外的部分和括号内的部分:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5895" class="lm kc hu ka b fv ln lo l lp lq">nonBrackets :: Parser String<br/>nonBrackets = many (satisfy (\c -&gt; c /= '\n' &amp;&amp; c /= '&lt;'))</span><span id="be3b" class="lm kc hu ka b fv lr lo l lp lq">insideBrackets :: Parser String<br/>insideBrackets = do<br/>  char '&lt;'<br/>  key &lt;- many letter<br/>  char '&gt;'<br/>  return key</span></pre><p id="a933" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，当我们把这些放在一起时，我们可以更清楚地看到do语法中概述的过程的步骤。首先我们解析“信号”这个词，然后是一个空格。然后我们得到“成对”的无括号和有括号的部分。最后，我们将得到最后一个不带括号的部分:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="df25" class="lm kc hu ka b fv ln lo l lp lq">parseStatementLine :: Text -&gt; Parser Statement<br/>parseStatementLine signal = do<br/>  string signal<br/>  char ' '<br/>  pairs &lt;- many ((,) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets)<br/>  finalString &lt;- nonBrackets<br/>  ...</span></pre><p id="e182" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们可以定义我们的助手函数<code class="eh jx jy jz ka b">buildStatement</code>并在do-syntax中在它自己的行上调用它。然后我们将返回结果<code class="eh jx jy jz ka b">Statement</code>。这比跟踪我们将哪些函数映射到解析器的哪些部分要容易理解得多:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="73c2" class="lm kc hu ka b fv ln lo l lp lq">parseStatementLine :: Text -&gt; Parser Statement<br/>parseStatementLine signal = do<br/>  string signal<br/>  char ' '<br/>  pairs &lt;- many ((,) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets)<br/>  finalString &lt;- nonBrackets<br/>  let (fullString, keys) = buildStatement pairs finalString<br/>  return $ Statement fullString keys<br/>  where<br/>    buildStatement <br/>      :: [(String, String)] -&gt; String -&gt; (String, [String])<br/>    buildStatement [] last = (last, [])<br/>    buildStatement ((str, key) : rest) rem =<br/>      let (str', keys) = buildStatement rest rem<br/>      in (str &lt;&gt; "&lt;" &lt;&gt; key &lt;&gt; "&gt;" &lt;&gt; str', key : keys)</span></pre><h1 id="053a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">场景和功能</h1><p id="4dfb" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">与应用解析一样，现在我们可以直接完成所有工作。为了解析一个场景，我们读取关键字，使用该行来读取标题，并读取语句和示例:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="2cc2" class="lm kc hu ka b fv ln lo l lp lq">scenarioParser :: Parser Scenario<br/>scenarioParser = do<br/>  string "Scenario: "<br/>  title &lt;- consumeLine<br/>  statements &lt;- many (parseStatement &lt;* char '\n')<br/>  examples &lt;- (exampleTableParser &lt;|&gt; return (ExampleTable [] []))<br/>  return $ Scenario title statements examples</span></pre><p id="bd18" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样，如果没有例子，我们提供一个空的<code class="eh jx jy jz ka b">ExampleTable</code>作为替代。背景的解析器看起来非常相似。唯一的区别是我们忽略了该行的结果，而是使用<code class="eh jx jy jz ka b">Background</code>作为标题字符串。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="139b" class="lm kc hu ka b fv ln lo l lp lq">backgroundParser :: Parser Scenario<br/>backgroundParser = do<br/>  string "Background:"<br/>  consumeLine<br/>  statements &lt;- many (parseStatement &lt;* char '\n')<br/>  examples &lt;- (exampleTableParser &lt;|&gt; return (ExampleTable [] []))<br/>  return $ Scenario "Background" statements examples</span></pre><p id="79c1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我们将把所有这些放在一起作为一个特性。我们阅读标题，获取背景(如果存在)，并阅读我们的场景:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="4f25" class="lm kc hu ka b fv ln lo l lp lq">featureParser :: Parser Feature<br/>featureParser = do<br/>  string "Feature: "<br/>  title &lt;- consumeLine<br/>  maybeBackground &lt;- optional backgroundParser<br/>  scenarios &lt;- many scenarioParser<br/>  return $ Feature title maybeBackground scenarios</span></pre><h1 id="e56a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">功能描述</h1><p id="d58d" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">我们现在要添加的一个额外特性是，我们可以更容易地解析特性的“描述”。我们在应用解析中省略了它们，因为实现起来很痛苦。当使用一元方法时，它变得简单得多。不过，我们必须采取的第一步是为我们特性的所有主要元素创建一个解析器。这种方法看起来像这样:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e207" class="lm kc hu ka b fv ln lo l lp lq">featureParser :: Parser Feature<br/>featureParser = do<br/>  string "Feature: "<br/>  title &lt;- consumeLine<br/>  (description, maybeBackground, scenarios) &lt;- parseRestOfFeature<br/>  return $ Feature title description maybeBackground scenarios</span><span id="cffc" class="lm kc hu ka b fv lr lo l lp lq">parseRestOfFeature :: Parser ([String], Maybe Scenario, [Scenario])<br/>parseRestOfFeature = ...</span></pre><p id="aea0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们将使用一个递归函数，一次读取一行描述，并添加到一个不断增长的列表中。诀窍是我们将使用Attoparsec提供的<code class="eh jx jy jz ka b">choice</code>组合子。</p><p id="b9f4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将创建两个解析器。第一种假设没有进一步的描述。它试图解析背景和场景列表。第二个读取一行描述，将其添加到我们的增长列表中，并递归:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="bbaf" class="lm kc hu ka b fv ln lo l lp lq">parseRestOfFeature :: Parser ([String], Maybe Scenario, [Scenario])<br/>parseRestOfFeature = parseRestOfFeatureTail []<br/>  where<br/>    parseRestOfFeatureTail prevDesc = do<br/>      (fullDesc, maybeBG, scenarios) &lt;- choice [noDescriptionLine prevDesc, descriptionLine prevDesc]<br/>      return (fullDesc, maybeBG, scenarios)</span></pre><p id="0fb4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以我们先试着运行这个<code class="eh jx jy jz ka b">noDescriptionLineParser</code>。它将尝试读取背景，然后像我们一直做的那样读取场景。如果成功了，我们就知道我们完成了。我们传递的参数是完整的描述:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5f90" class="lm kc hu ka b fv ln lo l lp lq">where<br/>  noDescriptionLine prevDesc = do<br/>    maybeBackground &lt;- optional backgroundParser<br/>    scenarios &lt;- some scenarioParser<br/>    return (prevDesc, maybeBackground, scenarios)</span></pre><p id="47b6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果这个解析器失败了，我们知道这意味着下一行实际上是描述的一部分。所以我们将编写一个解析器来使用一整行，然后递归:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="cbde" class="lm kc hu ka b fv ln lo l lp lq">descriptionLine prevDesc = do<br/>  nextLine &lt;- consumeLine<br/>  parseRestOfFeatureTail (prevDesc ++ [nextLine])</span></pre><p id="eddc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们完成了！我们可以解析描述！</p><h1 id="242a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="fabe" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">这就结束了我们对<a class="ae jw" href="https://hackage.haskell.org/package/attoparsec" rel="noopener ugc nofollow" target="_blank"> Attoparsec </a>的探索。下周回来，我们将通过了解<a class="ae jw" href="https://hackage.haskell.org/package/megaparsec" rel="noopener ugc nofollow" target="_blank">巨型炸弹</a>来结束这个系列。我们会发现，除了一些小的例外，它在语法上与Attoparsec非常相似。我们将看到如何使用一元解析的一些额外功能来丰富我们的语法。</p><p id="6658" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要了解更多关于很酷的Haskell库的信息，请务必查看我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！它会告诉你一些关于各种领域的库的信息，比如数据库和web APIs。</p><p id="66da" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你从来没有写过Haskell，下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>！它将为您提供开始Haskell之旅所需的所有资源！</p></div></div>    
</body>
</html>