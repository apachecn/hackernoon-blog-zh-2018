<html>
<head>
<title>Basics of MVP — The Android Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVP的基础Android方式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/basics-of-mvp-the-android-way-f75da407019d?source=collection_archive---------1-----------------------#2018-02-27">https://medium.com/hackernoon/basics-of-mvp-the-android-way-f75da407019d?source=collection_archive---------1-----------------------#2018-02-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f0a978bd37ca8d1f74db5e2e3a3f1979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXR9E-qtnO9s-bsFVwQqyQ.jpeg"/></div></div></figure><p id="fad6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我想分享一些关于这篇文章的动机。我开发Android应用程序已经快两年了，从来没有觉得需要遵循任何架构模式。有一天，我正在浏览YouTube上的Google IO 2017视频，偶然发现了一些架构模式。我试图挖掘一点，但很困惑。各种问题蹦出来；不知道该怎么办。</p><p id="6ad0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在工作中得到一个项目，代码被弄乱了，单个活动中有4500行代码。我害怕改变那些垃圾中的任何东西。与此同时，我开始意识到<a class="ae ka" href="https://hackernoon.com/tagged/mvp" rel="noopener ugc nofollow" target="_blank"> MVP </a>的好处。我克服了这种恐惧，迈出了信念的一大步(我喜欢《刺客信条》)。进行得相当顺利。但那不是我决定写它的时候。我正在修复一个个人项目的一些问题，差不多4个月后我看到了代码，你猜怎么着，它对我来说似乎很糟糕。我简直不敢相信，在MVP呈现的辉煌架构面前，我完全意识到自己写的代码似乎很模糊。被MVP的名声迷住了，我决定写一写它。</p><p id="8ecd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以不浪费更多的时间，我将尽我所知回答我开始使用MVP时的问题。</p><h1 id="5175" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">1.为什么要使用MVP或者任何架构模式？</h1><p id="0c42" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Android平台的美妙之处在于它是非个人化的。Android允许你以自己喜欢的方式设计应用程序。平台的这种性质为创建优秀的应用程序提供了强大的动力，但正如人们所说:</p><blockquote class="le"><p id="4a79" class="lf lg hu bd lh li lj lk ll lm ln jz ek translated">“权力越大，责任越大”——本叔叔</p></blockquote><p id="1590" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">随着应用程序的增长，代码库也在扩大；维护和添加新的特性变得很乏味，而且使用一些架构模式的需求也很强烈。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/f167c6bbdd04e1e674adb57c0d8d33df.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*sSYvffaSTAPDf1gMTXEkHg.gif"/></div></figure><p id="04df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，当复杂性的乌云笼罩在周围时，该怎么办呢？<strong class="je hv"> MVP来拯救。</strong> MVP旨在改善业务逻辑中<a class="ae ka" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">关注点</strong> </a>的分离。<em class="ly">好吧，我认为这是为了涵盖基础知识，你在这里陈述这些技术术语是在自以为是。</em>用最简单的话来说，关注点分离可以解释为，将代码分解成有意义的块，这些块能够并且应该独立执行。</p><p id="c96c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实现MVP也提高了代码的可测试性。拥有大量代码的大型应用程序无法进行有效的手动测试。编写<a class="ae ka" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试</a>有时会很痛苦，看起来是额外的工作，但是如果完成了，它们会解决多个问题。首先，单元测试使应用程序更加健壮。您会对代码的功能以及它在不同输入下的行为有更多的了解。第二，单元测试作为开发人员加入项目的用户手册。他们给他们一步一步的说明应用程序做什么。单元测试本身就是一个很大的话题，所以我不会在这里讨论。</p><h1 id="5242" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak"> 2。如何实现MVP？</strong></h1><p id="75ad" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><em class="ly">好吧，看了很多你关于MVP的闲聊，但是如何使用它呢？如何实施？</em>当谈到用Java编程语言为Android应用程序实现MVP时，我必须说除了一个没有秘密的咒语，那就是<strong class="je hv">接口。接口的技术细节，比如它是在类中实现的，因为Java不支持多重继承，它不能被实例化。</strong></p><p id="148e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Java编程语言中，接口是一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Abstract_type" rel="noopener ugc nofollow" target="_blank">抽象类型</a>，这是一个用来指定一个类必须具有的行为的概念。可以说是一套规则，任何同意使用它的阶级都必须遵守规定的规则。接口按照定义坚持遵循一个深思熟虑的结构。当我们使用MVP时，我们需要清楚地定义任何组件和接口的作用，因为它们总是证明对测试有好处，因为你不总是需要提供每件事情的完整实现。</p><p id="0d6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以为了实现MVP，需要知道分别是什么<strong class="je hv"> M </strong> odel、<strong class="je hv">V</strong>view和<strong class="je hv">P</strong>presenter。</p><h2 id="c8d9" class="lz kc hu bd kd ma mb mc kh md me mf kl jn mg mh kp jr mi mj kt jv mk ml kx mm dt translated">视角</h2><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/d6c0d9b9dd7d6095ee05e970e230200b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*SHE3ZJh3dbSBR_TpeVi_8w.gif"/></div><figcaption class="mn mo fg fe ff mp mq bd b be z ek">The secret being disclosed.</figcaption></figure><p id="7095" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们考虑一下视角。视图到底是什么？和安卓的View类有关系吗？让我说清楚一点，MVP的观点和安卓平台的<a class="ae ka" href="https://developer.android.com/reference/android/view/View.html" rel="noopener ugc nofollow" target="_blank">观点</a>阶层无关。<strong class="je hv"> View只是一个java类，负责在用户界面(UI)中进行修改。</strong>例如，<a class="ae ka" href="https://developer.android.com/reference/android/widget/TextView.html" rel="noopener ugc nofollow" target="_blank">文本视图</a>的文本变化，<a class="ae ka" href="https://developer.android.com/reference/android/widget/EditText.html" rel="noopener ugc nofollow" target="_blank">编辑文本</a>的文本大小变化，<a class="ae ka" href="https://developer.android.com/reference/android/widget/Button.html" rel="noopener ugc nofollow" target="_blank">按钮</a>的颜色变化或任何其他与用户界面相关的变化。在Android中，可以改变视觉呈现的活动、片段或任何其他组件被称为视图。<em class="ly">唷！那是个秘密。</em></p><p id="e4bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们在讨论实现，我必须说，为了遵循MVP的可维护性和可测试性原则，必须定义一个视图接口。该接口包含与可视化表示中的变化相关联的方法声明。活动或片段应该实现这个接口来定义完整的功能。使用这种方法允许在任何需要的地方传递一个抽象的实现，并且很容易被模仿。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/26d10698ac70f6176e1f2f7885512e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*cvuwWePkNjDCebuDwrJr8w.png"/></div></figure><p id="6322" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">人们常说，视图越简单，实现越好，也就是说，视图应该尽可能地少用逻辑。每一个逻辑处理都应该在Presenter中完成。尽管它可以包含用于可视显示的逻辑。</p><p id="20e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最好记住，每当有人引用一个视图时，他们都试图指向实现视图接口的活动或片段。</p><h2 id="8ec5" class="lz kc hu bd kd ma mb mc kh md me mf kl jn mg mh kp jr mi mj kt jv mk ml kx mm dt translated">模型</h2><p id="cb04" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><em class="ly">那么什么是模型呢？顾名思义，和某种结构有关系吗？</em>同样，<strong class="je hv">模型是负责获取应用程序中数据的组件。这些方法是在一个单独的接口中声明的，该接口是在牢记MVP原则的可维护性和可测试性的基础上定义的。</strong> <em class="ly">是的！就是这样。</em></p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/3f5048549a3f530072c23cef6f34b468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKycV_vZvwi9CjTcXW8RlQ.png"/></div></div><figcaption class="mn mo fg fe ff mp mq bd b be z ek">Model is responsible for data management</figcaption></figure><p id="7a9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了对什么是模型有一个具体的概念，有必要了解应用程序开发的常见数据访问模式。如果我们从更广的层面来看，一个应用程序从一些REST API获取数据，并存储在持久存储中，以便在没有网络连接的情况下轻松访问。无论有没有网络，应用程序都必须提供一致的体验。因此，为了提供一致的体验，模型必须包括获取、插入、修改或删除数据的方法，这些方法应该在两种网络场景中保持通用，即无论网络状态如何，应用程序都可以使用模型的方法获取相关数据。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/1fab491b2cc6600b8ad55070f7d20055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DP76BYmd-P-LMYdjFI5izQ.png"/></div></div><figcaption class="mn mo fg fe ff mp mq bd b be z ek">Model’s description</figcaption></figure><p id="32b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该模型分为不同的部分。这些部分可能根据所需的实现而有所不同，但基本上包括本地数据库处理、网络API处理(用于从web服务获取数据)和首选项管理。这些单独的部分管理获取数据并返回给演示者的逻辑。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/3162112e8033a9482158801f2441e3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRhxDQoCBRBZEpkoHLtFcA.png"/></div></div></figure><p id="1353" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">API管理器、数据库管理器和偏好管理器包含用于向展示者提供数据以及从展示者获取数据并存储它的逻辑。为其中的每一个定义了单独的接口，并且实现了这些接口。创建这些接口是为了避免传递这些类的具体实现，从而扩大测试范围。</p><h2 id="3b1b" class="lz kc hu bd kd ma mb mc kh md me mf kl jn mg mh kp jr mi mj kt jv mk ml kx mm dt translated">提出者</h2><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/509248c4b108d116dc483b619bbe0a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLD7mV5g5z_BZzuE05txZg.png"/></div></div></figure><p id="15b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们将注意力转移到三者中最重要的一个，即演讲者。它是将所有其他组件连接在一起的那个。这是一个拥有完整应用程序工作逻辑的类。作为视图的活动或片段应该将数据传递给呈现者，而处理数据是呈现者的责任。视图通过调用它的函数与Presenter交互。这些功能在一个单独的接口中声明，并且在Presenter中实现。演示者基本上有三个重要的功能:</p><ol class=""><li id="cb49" class="mw mx hu je b jf jg jj jk jn my jr mz jv na jz nb nc nd ne dt translated">对提供的数据执行任何可行的逻辑操作。</li><li id="8b00" class="mw mx hu je b jf nf jj ng jn nh jr ni jv nj jz nb nc nd ne dt translated">通过模型从数据库或首选项中存储或获取数据。</li><li id="9ef0" class="mw mx hu je b jf nf jj ng jn nh jr ni jv nj jz nb nc nd ne dt translated">改变视图的状态。</li></ol><p id="cace" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">演示者不应包含任何Android特定组件，如<a class="ae ka" href="https://finoittech.greytip.in/login.do" rel="noopener ugc nofollow" target="_blank">上下文</a>、活动、片段等。他们使测试变得困难。</p><p id="ad4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是MVP的实现方式，但是实现方式会根据编码方式和需求而有所不同。</p><h1 id="0d7c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">3.如何创建模型、视图和演示者？</h1><p id="ab6e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><em class="ly">“这有些道理。但是这些MVP是怎么产生的呢？”迄今为止，MVP的抽象概念一直存在，认为这些概念的创造将为其增添更多活力。自然，这些组件中的任何一个都不是预先存在于Android框架中的。如果放点心思，View就是和Activity、Fragments密切相关的组件，这些都是Android的核心组件。</em></p><p id="5b01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">活动创建演示者。演示者将视图和模型作为完成工作的论据。</p><h1 id="9e33" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">4.需要多少组模型视图和演示者？</h1><p id="e138" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好吧，这有点道理，但是我需要多少模型、视图或演示者呢？我宁愿说这取决于功能。当你深入研究时，你会对这些东西有更多的了解。</p><p id="3b20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我不得不提出一个模糊的想法，我会说，对于每一个不同的活动，你应该让一组观点和演讲者和模型对所有人保持不变。</p><figure class="lu lv lw lx fq iv fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/a5d51f5afb9db4f245ad1b0e7025f474.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/1*kRJ3buv6d1vvGRI74Dw9RQ.gif"/></div></figure><p id="0a5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些是我开始时主要问题的答案。我想表达的是，MVP是一种架构模式，它的实现根据需求而变化。我希望这能增加你对MVP的理解。这里有一些帮助我更好地了解MVP的参考资料。</p><div class="nl nm fm fo nn no"><a href="https://github.com/googlesamples/android-architecture" rel="noopener  ugc nofollow" target="_blank"><div class="np ab ej"><div class="nq ab nr cl cj ns"><h2 class="bd hv fv z el nt eo ep nu er et ht dt translated">googlesamples/android架构</h2><div class="nv l"><h3 class="bd b fv z el nt eo ep nu er et ek translated">android-architecture -讨论和展示不同架构工具和模式的示例集…</h3></div><div class="nw l"><p class="bd b gc z el nt eo ep nu er et ek translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ja no"/></div></div></a></div><figure class="lu lv lw lx fq iv"><div class="bz el l di"><div class="od oe l"/></div></figure></div></div>    
</body>
</html>