<html>
<head>
<title>Replacing Redux Thunks with Redux Sagas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用冗余的传奇代替冗余的思想</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/replacing-redux-thunks-with-redux-sagas-4aa306854925?source=collection_archive---------4-----------------------#2018-02-27">https://medium.com/hackernoon/replacing-redux-thunks-with-redux-sagas-4aa306854925?source=collection_archive---------4-----------------------#2018-02-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e099" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">React博客系列:第五部分</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/4e66691aa668401a60ef7d108953cb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GC9G3YWGrTD85yV5N0STg.png"/></div></div></figure><p id="c13a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">本文是用React创建博客的每周系列的第五部分，是前几部分创建的代码的扩展。</p><h2 id="861d" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">React博客系列</h2><p id="f828" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated"><a class="ae lr" rel="noopener" href="/front-end-hacking/building-a-website-with-react-and-bulma-d655214bff2a"> <strong class="jx hv">第一部分:</strong>用React和布尔玛</a> <br/> <a class="ae lr" rel="noopener" href="/@aaron.klaser/building-a-blog-with-react-and-contentful-fd538f68f6fb"> <strong class="jx hv">建立一个网站第二部分:</strong>用React和Contentful建立一个博客</a> <br/> <a class="ae lr" rel="noopener" href="/@aaron.klaser/import-your-medium-feed-into-react-ceadbaf785c7"> <strong class="jx hv">第三部分:</strong>将你的媒体提要导入React </a> <br/> <a class="ae lr" rel="noopener" href="/@aaron.klaser/adding-redux-to-a-react-blog-97f5fea606c2"> <strong class="jx hv">第四部分:</strong>向React博客添加一个Redux</a><br/><strong class="jx hv">第五部分:</strong>用Redux Sagas替换Redux Thunks<br/></p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><blockquote class="ma mb mc"><p id="12a8" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated">首先，让我从这个问题开始说起，我绝不是这方面的专家。实际上，我只是在过去的两个星期里才开始使用Sagas。如果你和我一样，当你读到这里的时候，你会不断地问自己，为什么会有人想用这个，这太过分了，你是绝对正确的。对于我正在做的事情来说，这有点矫枉过正了，但是说到底，传奇更好，更具可伸缩性，也更容易进行单元测试，这一点我们将在第六部分中看到。如果你不喜欢我的解释或例子，我理解。除了我在这里要用到的，还有更多关于传奇的东西。这里是Redux Saga文档的链接。祝你好运！— <a class="mg mh gr" href="https://medium.com/u/1ef30430402c?source=post_page-----4aa306854925--------------------------------" rel="noopener" target="_blank">亚伦·克拉泽</a></p></blockquote><h1 id="28a7" class="mi ks hu bd kt mj mk ml kx mm mn mo lb ja mp jb le jd mq je lh jg mr jh lk ms dt translated">Redux Saga是什么？</h1><p id="ef14" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">Sagas是一个redux中间件，处理在您的应用程序中触发的<em class="ls">异步动作</em>，通常称为<strong class="jx hv">副作用</strong>。在他们进入并控制局面之前，他们一直在等待着被派遣的特定行动。</p><p id="9e29" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">saga被实现为<strong class="jx hv">生成器函数</strong>，其<em class="ls">向redux-saga中间件产生</em>对象。</p><h2 id="ac56" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">等等，什么是生成器函数？</h2><p id="af21" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">！@#$ing魔法，那是什么！</p><p id="e5f9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是，我从Mozilla<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv"/></a>那里偷来了一个更好的解释。</p><p id="7f9e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">生成器是可以退出并在以后重新进入的功能。它们的上下文(变量绑定)将在重入时被保存。</p><p id="885e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">调用生成器函数不会立即执行其主体；而是返回函数的一个<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" rel="noopener ugc nofollow" target="_blank">迭代器</a>对象。当迭代器的<code class="eh mt mu mv mw b">next()</code>方法被调用时，生成器函数的主体被执行，直到第一个<code class="eh mt mu mv mw b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="noopener ugc nofollow" target="_blank">yield</a></code>表达式(用<code class="eh mt mu mv mw b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*" rel="noopener ugc nofollow" target="_blank">yield*</a></code>指定从迭代器返回的值)委托给另一个生成器函数。<code class="eh mt mu mv mw b">next()</code>方法返回一个对象，该对象的<code class="eh mt mu mv mw b">value</code>属性包含生成的值，而<code class="eh mt mu mv mw b">done</code>属性指示生成器是否以布尔值的形式生成了它的最后一个值。用一个参数调用<code class="eh mt mu mv mw b">next()</code>方法将恢复生成器函数的执行，用来自<code class="eh mt mu mv mw b">next()</code>的参数替换执行暂停的<code class="eh mt mu mv mw b">yield</code>表达式。</p><p id="b0ee" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">生成器中的<code class="eh mt mu mv mw b">return</code>语句，当被执行时，将使生成器<code class="eh mt mu mv mw b">done</code>。如果一个值被<code class="eh mt mu mv mw b">return</code> ed，它将作为<code class="eh mt mu mv mw b">value</code>被传回。已经返回的生成器不会再生成任何值。</p><h2 id="1c67" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">好吧，回到传说</h2><p id="ca12" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">我说到哪里了？啊，是的……saga是作为生成器函数实现的，它为redux-saga中间件产生对象。产生的对象是一种由中间件解释的指令。当一个承诺让给中间件时，中间件将暂停该传奇，直到该承诺完成。一旦承诺被兑现，中间件将继续这个传奇，执行代码直到下一次让步。</p><p id="45ee" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Redux Saga中间件在幕后为我们做了许多生成器魔术，让位于诸如put、all、call和takeLatest之类的Saga函数。</p><p id="61fb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所发生的是，中间件检查每个产生的效果的类型，然后决定如何实现该效果。如果效果类型是一个<code class="eh mt mu mv mw b">PUT</code>，那么它将向商店发送一个动作。如果效果是一个<code class="eh mt mu mv mw b">CALL</code>，那么它将调用给定的函数。效果创建和效果执行的分离使得使用<code class="eh mt mu mv mw b">next()</code>以一种令人惊讶的简单方式测试我们的生成器成为可能</p><blockquote class="ma mb mc"><p id="5ddd" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated">简而言之，<strong class="jx hv">发生器</strong>是像音乐轨道一样的暂停功能，而<br/> <strong class="jx hv"> Sagas </strong>是按下轨道上暂停播放和停止按钮的DJ。</p></blockquote><p id="0cc4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">聊够了，让我们开始吧！</p><h1 id="60c6" class="mi ks hu bd kt mj mk ml kx mm mn mo lb ja mp jb le jd mq je lh jg mr jh lk ms dt translated">安装Saga</h1><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="2df3" class="kr ks hu mw b fv nb nc l nd ne">npm install redux-saga</span></pre><p id="2b51" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后在<code class="eh mt mu mv mw b">store/index.js</code>我们来连线一下佐贺。Saga是一个redux中间件，所以我们将把它注入到我们的redux applyMuiddleware函数中，但是我们必须首先创建它。</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="f97f" class="kr ks hu mw b fv nb nc l nd ne">import { createStore, applyMiddleware } from 'redux'<br/>import { rootReducer } from './rootReducer'<br/>import reduxImmutableStateInvariant from 'redux-immutable-state-invariant'<br/>import thunk from 'redux-thunk'<br/>import { composeWithDevTools } from 'redux-devtools-extension';<br/><strong class="mw hv">import createSagaMiddleware from 'redux-saga'</strong></span><span id="0630" class="kr ks hu mw b fv nf nc l nd ne"><strong class="mw hv">const sagaMiddleware = createSagaMiddleware()</strong></span><span id="3d55" class="kr ks hu mw b fv nf nc l nd ne">export function configureStore() {<br/>  return createStore(<br/>    rootReducer,<br/>    composeWithDevTools(<br/>      applyMiddleware(<br/>        <strong class="mw hv">sagaMiddleware,</strong><br/>        thunk,<br/>        reduxImmutableStateInvariant()<br/>      )<br/>    )<br/>  )<br/>}</span></pre><p id="c573" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">到目前为止，这没有任何作用。我们将需要初始化的传奇，需要一些设置，然后我们才能这样做。我们将彻底改变目前的thunk设置。</p><h1 id="5bac" class="mi ks hu bd kt mj mk ml kx mm mn mo lb ja mp jb le jd mq je lh jg mr jh lk ms dt translated">创建我们的Saga助手</h1><p id="c931" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">我们将使用三个助手:</p><ol class=""><li id="40e2" class="ng nh hu jx b jy jz kb kc ke ni ki nj km nk kq nl nm nn no dt translated"><strong class="jx hv">createAsyncTypes</strong>helper，它将生成一个带有挂起、成功和错误的类型对象。</li><li id="42d8" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nl nm nn no dt translated"><strong class="jx hv"> createActions </strong> helper，它将为我们生成我们的操作。</li><li id="b5a0" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nl nm nn no dt translated"><strong class="jx hv">创建一个Reducer </strong>助手，我们将使用它来替换我们的switch语句。</li></ol><p id="b890" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mt mu mv mw b">store</code>文件夹中创建一个名为<strong class="jx hv"> Utilities.js </strong>的文件</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="094c" class="kr ks hu mw b fv nb nc l nd ne"><em class="ls">///////////////////<br/>// ActionHelpers //<br/>///////////////////<br/></em>const asyncTypes = {<br/>  PENDING: 'PENDING',<br/>  SUCCESS: 'SUCCESS',<br/>  ERROR: 'ERROR'<br/>}</span><span id="8a59" class="kr ks hu mw b fv nf nc l nd ne">export const <strong class="mw hv">createAsyncTypes</strong> = typeString =&gt;<br/>  Object.values(asyncTypes).reduce((acc, curr) =&gt; {<br/>    acc[curr] = `${typeString}_${curr}`<br/>    return acc<br/>  }, {})</span><span id="7b7c" class="kr ks hu mw b fv nf nc l nd ne">export const <strong class="mw hv">createAction</strong> = <br/>  (type, payload = {}) =&gt; <br/>    ({ type, ...payload })</span><span id="4ae7" class="kr ks hu mw b fv nf nc l nd ne"><em class="ls">///////////////////<br/>// createReducer //<br/>///////////////////<br/></em>export const <strong class="mw hv">createReducer</strong> = <br/>  (initialState, handlers) =&gt;<br/>    (state = initialState, action) =&gt;<br/>      handlers.hasOwnProperty(action.type)<br/>      ? handlers[action.type](state, action)<br/>      : state</span></pre><p id="8885" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我可能会在未来重新审视这些，我还不是100%赞成<strong class="jx hv"> createReducers </strong>方法，但目前它是有效的，而且非常干净</p><h1 id="0990" class="mi ks hu bd kt mj mk ml kx mm mn mo lb ja mp jb le jd mq je lh jg mr jh lk ms dt translated">从沉思走向传奇</h1><h2 id="1b76" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">更新博客类型</h2><p id="755d" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">打开<code class="eh mt mu mv mw b">store/blog/types.js</code></p><p id="585c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">之前，我们只有两种类型，我们使用BLOG_LOADING来设置完成和错误的加载状态，使用LOAD_BLOG_SUCCESS来加载成功的数据。</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="2331" class="kr ks hu mw b fv nb nc l nd ne"><strong class="mw hv">--- BEFORE ---</strong></span><span id="fa96" class="kr ks hu mw b fv nf nc l nd ne"><em class="ls">/**</em><br/><em class="ls">* Blog Types</em><br/><em class="ls">*/</em><br/>export const BLOG_LOADING = 'BLOG_LOADING'<br/>export const LOAD_BLOG_SUCCESS = 'LOAD_BLOG_SUCCESS'</span></pre><p id="ee64" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是现在，我们将调用我们的新帮助来创建AsyncTypes，这将自动创建我们的三个类型；挂起(加载)、成功(加载数据)、错误(加载完成)。</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="8986" class="kr ks hu mw b fv nb nc l nd ne"><strong class="mw hv">--- After ---</strong></span><span id="d2f4" class="kr ks hu mw b fv nf nc l nd ne"><em class="ls">/**</em><br/><em class="ls">* Blog Types</em><br/><em class="ls">*/<br/></em><strong class="mw hv">import</strong> { createAsyncTypes } from './../Utilities'<br/><br/><em class="ls">//Using ASYNC as a convention to know that I'll have three types.</em><br/><strong class="mw hv">export</strong> <strong class="mw hv">const</strong> GET_BLOG_ASYNC <strong class="mw hv">=</strong> createAsyncTypes('GET_BLOG')</span></pre><p id="0a24" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">过一会儿这就更有意义了。</p><h2 id="9158" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">更新博客缩减器</h2><p id="7f92" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">打开<code class="eh mt mu mv mw b">store\blog\reducer.js</code></p><p id="4a16" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有两种方法可以做到这一点，我们可以简单地更新switch用例中的类型，使用我们刚刚创建的新类型名，就像这样。</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="58c1" class="kr ks hu mw b fv nb nc l nd ne">switch (action.type) {<br/>  case types.<strong class="mw hv">GET_BLOG_ASYNC.PENDING</strong>:<br/>    return {<br/>      ...state,<br/>      loading: true<br/>    }<br/>  case types.<strong class="mw hv">GET_BLOG_ASYNC.SUCCESS</strong>:<br/>    return {<br/>      ...state,<br/>      posts: action.posts,<br/>      loading: false<br/>    }<br/>  case types.<strong class="mw hv">GET_BLOG_ASYNC.ERROR</strong>:<br/>    return {<br/>      ...state,<br/>      loading: false<br/>    }<br/>  default:<br/>    return state<br/>}</span></pre><p id="668d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是我们的<strong class="jx hv"> createAsyncTypes </strong> types助手所做的一个例子。它生成了一个具有3个值的类型对象，使用convention _ASYNC我们知道<strong class="jx hv"> GET_BLOG_ASYNC </strong>将<strong class="jx hv"> </strong>包含挂起、成功和错误。</p><p id="ef2f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们通过使用createReducer helper并向它传递一个对象而不是一个switch语句来使它变得更加智能。</p><p id="dbf4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">删除所有内容并粘贴到这里</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="8b5a" class="kr ks hu mw b fv nb nc l nd ne"><em class="ls">/**<br/>* Blog Reducer<br/>*/<br/></em>import initialState from './../initialState'<br/>import { createReducer } from './../Utilities'<br/>import * as types from './types'</span><span id="a109" class="kr ks hu mw b fv nf nc l nd ne">export default createReducer(initialState.blog, {<br/>  [types.GET_BLOG_ASYNC.PENDING](state) {<br/>    return {<br/>      ...state,<br/>      loading: true<br/>    }<br/>  },<br/>  [types.GET_BLOG_ASYNC.SUCCESS](state, action) {<br/>    return {<br/>      ...state,<br/>      posts: action.posts,<br/>      loading: false<br/>    }<br/>  },<br/>  [types.GET_BLOG_ASYNC.ERROR](state) {<br/>    return {<br/>      ...state,<br/>      loading: false<br/>    }<br/>  }<br/>})</span></pre><p id="c948" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">是的，我知道你的想法，我也同意。这看起来确实比switch语句更令人困惑，但却同样清晰。实际上，我花了一分钟才明白这个对象到底在做什么，因为我以前从来没有这样写过。它创建了一个每个都等于的对象和一个匿名函数，但是它用方括号来设置键。</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="6075" class="kr ks hu mw b fv nb nc l nd ne">obj = {<br/>  key: fn,<br/>  [key]fn<br/>}</span></pre><p id="63aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">或者您可以使用箭头函数，您将需要一个冒号箭头和对象周围的括号。</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="8ee4" class="kr ks hu mw b fv nb nc l nd ne">export default createReducer(initialState.blog, {<br/>  [types.GET_BLOG_ASYNC.PENDING]<strong class="mw hv">:</strong>(state)<strong class="mw hv"> =&gt; (</strong>{<br/>    ...state,<br/>    loading: true<br/>  }<strong class="mw hv">)</strong>,<br/>  [types.GET_BLOG_ASYNC.SUCCESS]:(state, action) =&gt; ({<br/>    ...state,<br/>    posts: action.posts,<br/>    loading: false<br/>  }),<br/>  [types.GET_BLOG_ASYNC.ERROR]:(state) =&gt; ({<br/>    ...state,<br/>    loading: false<br/>  })<br/>})</span></pre><p id="0742" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">无论你选择哪种方式都是好的，让我说我还没有100%同意<em class="ls">和</em>，但我认为这有助于在未来创造一个异步减速器创造者；)</p><h2 id="6da2" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">创造我们的第一个传奇</h2><p id="6f08" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">在我们的<code class="eh mt mu mv mw b">store\blog</code>文件夹中创建一个名为<strong class="jx hv"> sagas.js </strong>的文件</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="756b" class="kr ks hu mw b fv nb nc l nd ne"><em class="ls">/**<br/>* Blog Sagas<br/>*/<br/></em>import * as contentful from 'contentful'<br/>import { all, call, put, takeLatest } from 'redux-saga/effects'<br/>import { actions } from './../Blog'<br/>import * as types from './types'</span><span id="c927" class="kr ks hu mw b fv nf nc l nd ne">const client = contentful.createClient({<br/>  space: 'qu10m4oq2u62',<br/>  accessToken: 'f4a9f68de290d53552b107eb503f3a073bc4c632f5bdd50efacc61498a0c592a'<br/>})</span><span id="2891" class="kr ks hu mw b fv nf nc l nd ne">const fetchPosts = () =&gt; client.getEntries()</span><span id="5192" class="kr ks hu mw b fv nf nc l nd ne">function* getBlogPosts() {<br/>  try {<br/>    const posts = yield call(fetchPosts)<br/>    yield put(actions.success(posts.items))<br/>  } catch (e) {<br/>    console.log(e)<br/>    yield put(actions.error(e))<br/>  }<br/>}</span><span id="1f69" class="kr ks hu mw b fv nf nc l nd ne">export default function* () {<br/>  yield all([<br/>    takeLatest(types.GET_BLOG_ASYNC.PENDING, getBlogposts)<br/>  ])<br/>}</span></pre><p id="5a84" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那么，这是在做什么？好吧，让我们从显而易见的开始。</p><p id="e9c9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">客户</strong>是我与我的心满意足的联系</p><p id="8cbf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> fetchPosts </strong>调用我们的to Contentful来检索我的帖子并作为承诺返回它们</p><p id="6971" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">getBlogPosts是我们真实的传奇故事。它首先产生对fetchPosts的调用，saga magic启动并暂停该函数，等待Contentful返回数据。然后，一旦数据被成功返回，而不是返回一个承诺，它实际上将数据返回给<code class="eh mt mu mv mw b">const posts</code>并在后台调用<code class="eh mt mu mv mw b">next()</code>，后者告诉函数再次播放。然后它调用<code class="eh mt mu mv mw b">yield put</code>,后者神奇地分派带有post项的动作。如果<code class="eh mt mu mv mw b">fetchPosts()</code>失败，抛出一个异常来触发catch。</p><p id="68fb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">导出默认函数* </strong>是连接到Redux Saga中间件的动作观察器。这类似于触发动作，除了不是调用动作和将动作分派给reducer，而是saga观察要调用的动作，然后截取并调用saga。takeLatest告诉Redux Saga停止任何以前正在运行的Saga任务，如果还在运行，则运行一个新任务。</p><p id="efd1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh mt mu mv mw b">takeLatest(types.GET_BLOG_ASYNC.PENDING, getBlogPosts)</code>表示当<strong class="jx hv">类型动作时。GET _博客_异步。挂起</strong>被调用，停止任何之前调用的可能没有完成的getBlogPosts任务，调用一个新的<strong class="jx hv"> getBlogPosts() </strong>函数。</p><p id="9429" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh mt mu mv mw b">yield all</code>函数是一种容纳博客传奇所有观察者的容器。如果我们有更多的动作，我们可以创造更多的传奇和创造更多的观察者来调用这些传奇，这些额外的观察者将加入到所有的功能中。</p><p id="2c62" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，我们导出默认函数，这将创建gets注入到绑定到rootSaga中的sagaMiddleware.run函数。</p><h2 id="584c" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">建立根传奇</h2><p id="5f8f" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">我们需要将所有的sagas添加到sagaMiddleware中，这样我们就可以在应用加载时启动所有的观察器。</p><p id="ebc7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<code class="eh mt mu mv mw b">store</code>文件夹中，创建一个名为<strong class="jx hv"> rootSaga.js </strong>的文件</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="91b9" class="kr ks hu mw b fv nb nc l nd ne">import blog from './blog/sagas'</span><span id="1728" class="kr ks hu mw b fv nf nc l nd ne">const sagas = [<br/>  blog<br/>]</span><span id="24f7" class="kr ks hu mw b fv nf nc l nd ne">export const initSagas = (sagaMiddleware) =&gt;<br/>  sagas.forEach(sagaMiddleware.run.bind(sagaMiddleware))</span></pre><p id="5d63" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，我们只有一个传奇。如果我们用Saga的设置了Medium store，那么我们将导入Medium并将其传递给sagas数组。</p><blockquote class="ma mb mc"><p id="66b0" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><strong class="jx hv">注意:</strong>我们不需要从我们的<strong class="jx hv"> blog/saga.js </strong>文件中导入每一个函数，只需要t个动作观察器，我们将它们封装在一个all函数中，就像你的传奇故事的一个减速器。</p></blockquote><h2 id="2675" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">行动，博客的新面貌</h2><p id="eccc" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">现在，我们有了一些可以观察我们行为的传奇，我们需要更新我们现在的数据行为。</p><p id="d59a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你一直在阅读，你知道我遵循<a class="ae lr" href="https://hackernoon.com/building-a-website-with-react-and-bulma-d655214bff2a" rel="noopener ugc nofollow" target="_blank">分形文件结构</a>，在<strong class="jx hv">商店的情况下</strong>意味着<code class="eh mt mu mv mw b">store/Blog.js</code>是我的公共应用程序面向代码，而<code class="eh mt mu mv mw b">store/blog</code>文件夹中的所有东西都是商店的私有。应用程序不会调用传奇，而是调用动作。<code class="eh mt mu mv mw b">store/Blog.js</code>目前包含我们的thunks，但这些不再是必要的，所以我们可以删除它们，并用应用程序将调用的触发我们的传奇的动作来替换它们。然后我们可以从我们的<code class="eh mt mu mv mw b">store/blog</code>文件夹中删除<code class="eh mt mu mv mw b">actions.js</code>文件。</p><p id="708e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里是<code class="eh mt mu mv mw b">Blog.js</code>文件的前后</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="ef4b" class="kr ks hu mw b fv nb nc l nd ne"><strong class="mw hv">--- Before ---</strong></span><span id="ed62" class="kr ks hu mw b fv nf nc l nd ne">import * as contentful from 'contentful'<br/>import * as actions from './blog/actions'</span><span id="8a3c" class="kr ks hu mw b fv nf nc l nd ne">const client = contentful.createClient({<br/>  space: 'qu10m4oq2u62',<br/>  accessToken: 'f4a9f68de290d53552b107eb503f3a073bc4c632f5bdd50efacc61498a0c592a'<br/>})</span><span id="eb1e" class="kr ks hu mw b fv nf nc l nd ne"><br/>export function loadBlog() {<br/>  return dispatch =&gt; {<br/>    dispatch(actions.blogLoading())<br/>    return client.getEntries()<br/>      .then(({items}) =&gt; {<br/>        dispatch(actions.loadBlogSuccess(items))<br/>      })<br/>      .catch(error =&gt; {<br/>        console.log(error)<br/>        dispatch(actions.blogLoading(false))<br/>      })<br/>  }<br/>}</span></pre><p id="c482" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们去掉了所有的逻辑，因为这是Saga现在的工作，用一个我们的应用程序可以调用的简单动作对象来代替它。</p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="5477" class="kr ks hu mw b fv nb nc l nd ne"><strong class="mw hv">--- After ---</strong></span><span id="2b94" class="kr ks hu mw b fv nf nc l nd ne">import { createAction } from './Utilities'<br/>import * as types from './blog/types'</span><span id="5a97" class="kr ks hu mw b fv nf nc l nd ne">export const actions = {<br/>  pending: () =&gt; createAction(types.GET_BLOG_ASYNC.PENDING),<br/>  success: (posts) =&gt; createAction(types.GET_BLOG_ASYNC.SUCCESS, { posts }),<br/>  error: (error) =&gt; createAction(types.GET_BLOG_ASYNC.ERROR, { error })<br/>}</span></pre><p id="86ee" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> createAction </strong>函数除了通过make清理我们的代码之外，并没有做更多的事情，因此不管有多少东西实际上作为有效载荷传入，这个函数总是接受2个参数。我认为在未来，我们可以用它来帮助自动化我们的一些异步CRUD过程。</p><h2 id="0ce9" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">最后一件事，初始化传奇</h2><p id="289f" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">在我们的<code class="eh mt mu mv mw b">store/index.js</code></p><pre class="jk jl jm jn fq mx mw my mz aw na dt"><span id="891a" class="kr ks hu mw b fv nb nc l nd ne">...<br/>import createSagaMiddleware from 'redux-saga'<br/><strong class="mw hv">import { initSagas } from './rootSaga'</strong></span><span id="fdae" class="kr ks hu mw b fv nf nc l nd ne">const sagaMiddleware = createSagaMiddleware()</span><span id="6e31" class="kr ks hu mw b fv nf nc l nd ne">export function configureStore() {<br/> <strong class="mw hv"> const store = </strong>createStore(<br/>    rootReducer,<br/>    composeWithDevTools(<br/>      applyMiddleware(<br/>        sagaMiddleware,<br/>        thunk,<br/>        reduxImmutableStateInvariant()<br/>      )<br/>    )<br/>  )<br/>  <strong class="mw hv">initSagas(sagaMiddleware)<br/>  <br/>  return store</strong><br/>}</span></pre><p id="5ba0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最初，我们返回createStore，但是initSagas需要先初始化sagaMiddleware。因此，我们需要创建商店，然后将sagaMiddleware传递给initSages，这将启动我们所有的观察器。</p><p id="6989" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">相反，在应用程序根索引中做一些复杂的事情来调用initSagas，我们可以只设置一个Store变量来创建store，然后在返回store之前调用initSagas。</p><h2 id="24ca" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">就是这样！</h2><p id="409e" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">当然，我只是刚刚触及了Sagas能做什么的表面，这是一个很好的入门书，让他们设置和实际工作。</p><h1 id="d958" class="mi ks hu bd kt mj mk ml kx mm mn mo lb ja mp jb le jd mq je lh jg mr jh lk ms dt translated">让我们回顾一下</h1><ul class=""><li id="8e70" class="ng nh hu jx b jy lm kb ln ke nu ki nv km nw kq nx nm nn no dt translated">我们安装了传奇</li><li id="3e22" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nx nm nn no dt translated">我们为类型和归约器创建了一些助手。</li><li id="5515" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nx nm nn no dt translated">更新了我们的类型</li><li id="3e5a" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nx nm nn no dt translated">更新了我们的减速器，学习了一些新技术</li><li id="6a7d" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nx nm nn no dt translated">创造了我们的第一个传奇</li><li id="0cdf" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nx nm nn no dt translated">建立根</li><li id="60c2" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nx nm nn no dt translated">将我们的行动转移到公共类</li><li id="20a7" class="ng nh hu jx b jy np kb nq ke nr ki ns km nt kq nx nm nn no dt translated">在加载的应用程序上初始化我们的传奇</li></ul><p id="98f5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">是的，这要复杂得多，而且有相当多的额外设置，而且有一个循序渐进的学习曲线，而且…你明白了。但是，这最终是一个更好的解决方案。它更干净，更可伸缩，更可控，它是实时可用的，并且它非常容易测试，我们将在我的文章中看到😉</p><blockquote class="ma mb mc"><p id="3ed8" class="jv jw ls jx b jy jz iv ka kb kc iy kd md kf kg kh me kj kk kl mf kn ko kp kq hn dt translated"><strong class="jx hv">下一个</strong> —用Redux Sagas编写React博客的单元测试</p></blockquote></div></div>    
</body>
</html>