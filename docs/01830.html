<html>
<head>
<title>Let’s Build a Custom Vue.js Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个定制的Vue.js路由器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-build-a-custom-vue-js-router-7de634be87c4?source=collection_archive---------5-----------------------#2018-02-27">https://medium.com/hackernoon/lets-build-a-custom-vue-js-router-7de634be87c4?source=collection_archive---------5-----------------------#2018-02-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2129" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">作者<a class="ae jj" href="https://twitter.com/djirdehh" rel="noopener ugc nofollow" target="_blank">哈桑·吉尔德</a></h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/2cef9c3791949ed1c8b3aabb86ce3f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuuDpW8KefKQDcUW5NtgGA.png"/></div></div></figure><p id="7321" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><em class="ks">本文交叉发布于CSS-Tricks-</em><a class="ae jj" href="https://css-tricks.com/build-a-custom-vue-router/" rel="noopener ugc nofollow" target="_blank"><em class="ks">https://css-tricks.com/build-a-custom-vue-router/</em></a></p></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><p id="95f0" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">有大量的教程<a class="ae jj" href="https://alligator.io/vuejs/intro-to-routing/" rel="noopener ugc nofollow" target="_blank">在解释Vue的官方路由库<code class="eh la lb lc ld b"><a class="ae jj" href="https://router.vuejs.org/en/" rel="noopener ugc nofollow" target="_blank">vue-router</a></code>如何集成到现有的Vue应用中做了大量的工作。<code class="eh la lb lc ld b">vue-router</code>非常出色，它为我们提供了将应用程序组件映射到不同浏览器URL路径所需的项目。</a></p><p id="245d" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">但是，简单的应用程序通常不需要像<code class="eh la lb lc ld b">vue-router</code>这样成熟的路由库。在本文中，我们将使用Vue构建一个简单的定制客户端路由器。通过这样做，我们将了解构建客户端路由需要处理什么，以及哪里可能存在潜在的缺点。</p><p id="6d70" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">虽然本文假设了Vue.js中的基础知识；当我们开始写代码时，我们将彻底地解释事情！</p><h1 id="66a3" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">按指定路线发送</h1><p id="6ec8" class="pw-post-body-paragraph jw jx hu jy b jz lw iv kb kc lx iy ke kf ly kh ki kj lz kl km kn ma kp kq kr hn dt translated">首先也是最重要的:让我们为那些可能不熟悉这个概念的人定义一下<strong class="jy hv">路由</strong>。</p><p id="1aea" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在web开发中，路由通常是指根据浏览器URL派生的规则来分割应用程序的ui。想象一下，点击一个链接，网址从<code class="eh la lb lc ld b">https://website.com</code>转到<code class="eh la lb lc ld b">https://website.com/article/</code>。那是路由。</p><p id="466a" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">路由通常分为两个主要类别:</p><ul class=""><li id="06da" class="mb mc hu jy b jz ka kc kd kf md kj me kn mf kr mg mh mi mj dt translated"><strong class="jy hv">服务器端路由:</strong>每次URL改变时，客户端(即浏览器)都会向服务器发出请求<em class="ks">。</em></li><li id="4900" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated"><strong class="jy hv">客户端路由:</strong>客户端<em class="ks">只有</em>在初始页面加载时向服务器发出请求。基于URL路由对应用程序UI的任何更改都在客户端处理。</li></ul><p id="ecab" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">客户端路由是术语<strong class="jy hv">单页面应用</strong>(或简称SPA)出现的地方。spa是只加载<em class="ks">一次</em>的web应用，并且可以通过用户交互<em class="ks">动态更新</em>，而无需向服务器发出后续请求。有了SPAs中的路由，<em class="ks"> JavaScript就是动态呈现不同UI的驱动力</em>。</p><p id="8b7b" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">现在我们已经对客户端路由和spa有了一个简单的了解，让我们对将要做的事情有一个大致的了解！</p><h1 id="325e" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">案例研究:神奇宝贝</h1><p id="7938" class="pw-post-body-paragraph jw jx hu jy b jz lw iv kb kc lx iy ke kf ly kh ki kj lz kl km kn ma kp kq kr hn dt translated">我们旨在构建的应用程序是一个简单的神奇宝贝应用程序，它根据URL路由显示特定神奇宝贝的详细信息。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mp"><img src="../Images/039fc8f4ea80edc39c5ab04e3b53bfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bl5SfrD3DwzvhwyBIMGQzQ.png"/></div></div></figure><p id="b2ab" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">该应用程序将有三个唯一的URL路由:<code class="eh la lb lc ld b">/charizard</code>、<code class="eh la lb lc ld b">/blastoise</code>和<code class="eh la lb lc ld b">/venusaur</code>。根据输入的URL路径，将显示不同的神奇宝贝:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/108c12bf48a8ad9d98437131f8b589ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBjzvVd381NJHF26x2bkdg.png"/></div></div></figure><p id="5509" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">此外，页脚链接位于应用程序的底部，通过单击将用户引导至各个路线:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mq"><img src="../Images/05f998bb477394cf2831b88efd1ecde8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MmlJHYAMKYNbzZLVYaH-A.png"/></div></div></figure><h1 id="1b23" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">我们需要路由吗？</h1><p id="d641" class="pw-post-body-paragraph jw jx hu jy b jz lw iv kb kc lx iy ke kf ly kh ki kj lz kl km kn ma kp kq kr hn dt translated">对于像这样的简单应用，我们不一定需要客户端路由器来使我们的应用正常工作。这个特定的应用程序可以由一个简单的父子组件层次结构组成，该层次结构使用Vue <code class="eh la lb lc ld b"><a class="ae jj" href="https://vuejs.org/v2/guide/components.html#Props" rel="noopener ugc nofollow" target="_blank">props</a></code>来指定应该显示的信息。这里有一支<a class="ae jj" href="https://codepen.io/itslit/full/yvymJL" rel="noopener ugc nofollow" target="_blank">笔</a>显示的就是这个:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="f80c" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">尽管这款应用在功能上是可行的，但是它缺少了一个大部分网络应用都应该具备的重要特性——响应浏览器导航事件。我们希望我们的神奇宝贝应用程序是可访问的，并显示不同路径名的不同细节:<code class="eh la lb lc ld b">/charizard</code>、<code class="eh la lb lc ld b">/blastoise</code>和<code class="eh la lb lc ld b">/venusaur</code>。这将允许用户刷新不同的页面，并保留他们在应用程序中的位置，将URL标记为书签以便以后返回，并可能与其他人共享URL。这些是在应用程序中创建路线的一些主要好处。</p><p id="c9a3" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">既然我们已经有了要做什么的想法，让我们开始建造吧！</p><h1 id="f6ec" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">准备应用程序</h1><p id="6617" class="pw-post-body-paragraph jw jx hu jy b jz lw iv kb kc lx iy ke kf ly kh ki kj lz kl km kn ma kp kq kr hn dt translated">一步一步来的最简单的方法(如果你愿意的话)是克隆我建立的GitHub repo:</p><blockquote class="mt mu mv"><p id="c53e" class="jw jx ks jy b jz ka iv kb kc kd iy ke mw kg kh ki mx kk kl km my ko kp kq kr hn dt translated"><a class="ae jj" href="https://github.com/djirdehh/pokemon-routing" rel="noopener ugc nofollow" target="_blank"> <strong class="jy hv"> GITHUB回购</strong> </a></p></blockquote><p id="5754" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">克隆后，安装项目依赖项，包括:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="325b" class="nd lf hu ld b fv ne nf l ng nh">npm install</span></pre><p id="0b2a" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">让我们简单地看一下项目目录。</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="7343" class="nd lf hu ld b fv ne nf l ng nh">$ ls<br/>README.md<br/>index.html<br/>node_modules/<br/>package.json<br/>public/<br/>src/<br/>static/<br/>webpack.config.js</span></pre><p id="0ad5" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">项目支架中还存在隐藏文件<code class="eh la lb lc ld b">.babelrc</code>和<code class="eh la lb lc ld b">.gitignore</code>。</p><p id="f095" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">这个项目是一个简单的webpack配置的应用程序，使用Vue命令行界面<code class="eh la lb lc ld b"><a class="ae jj" href="https://github.com/vuejs-templates/webpack-simple" rel="noopener ugc nofollow" target="_blank">vue-cli</a></code>搭建。</p><p id="2692" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><code class="eh la lb lc ld b">index.html</code>是我们声明DOM元素的地方——<code class="eh la lb lc ld b">#app</code>——我们将使用它来挂载我们的Vue应用程序:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="8cac" class="nd lf hu ld b fv ne nf l ng nh">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;link rel="stylesheet"<br/>      href="<!-- -->https://cdnjs.cloudflare.com/ajax/libs/bulma/0.5.3/...<!-- -->"&gt;<br/>    &lt;link rel="stylesheet"<br/>      href="../public/styles.css" /&gt;<br/>    &lt;title&gt;Pokémon - Routing&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div <strong class="ld hv">id="app"</strong>&gt;&lt;/div&gt;<br/>    &lt;script src="/dist/build.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7dbb" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在<code class="eh la lb lc ld b">index.html</code>文件的<code class="eh la lb lc ld b">&lt;head&gt;</code>标签中，我们引入了<a class="ae jj" href="https://bulma.io/" rel="noopener ugc nofollow" target="_blank">布尔玛</a>作为我们应用程序的CSS框架和我们自己的<code class="eh la lb lc ld b">styles.css</code>文件，该文件位于<code class="eh la lb lc ld b">public/</code>文件夹中。</p><p id="df14" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">因为我们的重点是Vue.js的使用，所以应用程序已经有了所有定制的CSS布局。</p><p id="0b23" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><code class="eh la lb lc ld b">src/</code>文件夹是我们直接工作的地方:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="d44a" class="nd lf hu ld b fv ne nf l ng nh">$ ls src/<br/>app/<br/>main.js</span></pre><p id="e566" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><code class="eh la lb lc ld b">src/main.js</code>代表我们Vue应用的起点。这是我们的Vue实例被实例化的地方，在这里我们声明要被渲染的父组件，以及我们的应用要被挂载到的DOM元素<code class="eh la lb lc ld b">#app</code>:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="d8bf" class="nd lf hu ld b fv ne nf l ng nh">import Vue from 'vue';<br/>import App from './app/app';</span><span id="991c" class="nd lf hu ld b fv ni nf l ng nh">new Vue({<br/>  el: '#app',<br/>  render: h =&gt; h(App)<br/>});</span></pre><p id="443f" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们从<code class="eh la lb lc ld b">src/app/app.js</code>文件中指定组件<code class="eh la lb lc ld b">App</code>作为应用程序的主要父组件。</p><p id="30e2" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在<code class="eh la lb lc ld b">src/app</code>目录中，存在另外两个文件- <code class="eh la lb lc ld b">app-custom.js</code>和<code class="eh la lb lc ld b">app-vue-router.js</code>:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="0da2" class="nd lf hu ld b fv ne nf l ng nh">$ ls src/app/<br/>app-custom.js<br/>app-vue-router.js<br/>app.js</span></pre><p id="323f" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><code class="eh la lb lc ld b">app-custom.js</code>表示使用定制Vue路由器完成应用程序的实现(即我们将在本文中构建的内容)。<code class="eh la lb lc ld b">app-vue-router.js</code>是使用<code class="eh la lb lc ld b">vue-router</code>库完成的路由实现。</p><p id="4711" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">对于整篇文章，我们将只介绍<code class="eh la lb lc ld b">src/app/app.js</code>文件的代码。说了这么多，我们来看看<code class="eh la lb lc ld b">src/app/app.js</code>内的起始代码:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="319b" class="nd lf hu ld b fv ne nf l ng nh"><strong class="ld hv">const CharizardCard</strong> = {<br/>  name: 'charizard-card',<br/>  template: `<br/>    &lt;div class="card card--charizard has-text-weight-bold<br/>                has-text-white"&gt;<br/>      &lt;div class="card-image"&gt;<br/>        &lt;div class="card-image-container"&gt;<br/>          &lt;img src="../../static/charizard.png"/&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="card-content has-text-centered"&gt;<br/>        &lt;div class="main"&gt;<br/>          &lt;div class="title has-text-white"&gt;Charizard&lt;/div&gt;<br/>          &lt;div class="hp"&gt;hp 78&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="stats columns is-mobile"&gt;<br/>          &lt;div class="column"&gt;&amp;#x1f525;&lt;br&gt;<br/>            &lt;span class="tag is-warning"&gt;Type&lt;/span&gt;<br/>          &lt;/div&gt;<br/>          &lt;div class="column center-column"&gt;199 lbs&lt;br&gt;<br/>            &lt;span class="tag is-warning"&gt;Weight&lt;/span&gt;<br/>          &lt;/div&gt;<br/>          &lt;div class="column"&gt;1.7 m &lt;br&gt;<br/>            &lt;span class="tag is-warning"&gt;Height&lt;/span&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `<br/>};</span><span id="5d07" class="nd lf hu ld b fv ni nf l ng nh"><strong class="ld hv">const App</strong> = {<br/>  name: 'App',<br/>  template: `<br/>    &lt;div class="container"&gt;<br/>      &lt;div class="pokemon"&gt;<br/>        &lt;pokemon-card&gt;&lt;/pokemon-card&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>  components: {<br/>    'pokemon-card': CharizardCard<br/>  }<br/>};</span><span id="5de9" class="nd lf hu ld b fv ni nf l ng nh">export default App;</span></pre><p id="ebdd" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">目前存在两个组件:<code class="eh la lb lc ld b">CharizardCard</code>和<code class="eh la lb lc ld b">App</code>。<code class="eh la lb lc ld b">CharizardCard</code>组件是一个简单的模板，显示了Charizard神奇宝贝的详细信息。<code class="eh la lb lc ld b">App</code>组件在其<code class="eh la lb lc ld b">components</code>属性中声明了<code class="eh la lb lc ld b">CharizardCard</code>组件，并在其<code class="eh la lb lc ld b">template</code>中将其呈现为<code class="eh la lb lc ld b">&lt;pokemon-card&gt;&lt;/pokemon-card&gt;</code>。</p><p id="4ce3" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们目前只有静态内容，如果运行我们的应用程序，我们将能够看到这些内容:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="da32" class="nd lf hu ld b fv ne nf l ng nh">npm run dev</span></pre><p id="473d" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">并发射<code class="eh la lb lc ld b">localhost:8080</code>:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff nj"><img src="../Images/b8bd831ef825c10585f07331259a62a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yffZRuTW_aeLyjohFAbKTg.png"/></div></div></figure><p id="802d" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">首先，让我们介绍两个新组件:<code class="eh la lb lc ld b">BlastoiseCard</code>和<code class="eh la lb lc ld b">VenusaurCard</code>，分别包含Blastoise和Venusaur Pokémon的详细信息。我们可以在<code class="eh la lb lc ld b">CharizardCard</code>之后布置这些组件:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="5535" class="nd lf hu ld b fv ne nf l ng nh">const CharizardCard = { <br/>  // ... <br/>};<br/><br/><strong class="ld hv">const BlastoiseCard</strong> = {<br/>  name: 'blastoise-card',<br/>  template: `<br/>    &lt;div class="card card--blastoise has-text-weight-bold<br/>               has-text-white"&gt;<br/>      &lt;div class="card-image"&gt;<br/>        &lt;div class="card-image-container"&gt;<br/>          &lt;img src="../../static/blastoise.png"/&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="card-content has-text-centered"&gt;<br/>        &lt;div class="main"&gt;<br/>          &lt;div class="title has-text-white"&gt;Blastoise&lt;/div&gt;<br/>          &lt;div class="hp"&gt;hp 79&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="stats columns is-mobile"&gt;<br/>          &lt;div class="column"&gt;&amp;#x1f4a7;&lt;br&gt;<br/>            &lt;span class="tag is-light"&gt;Type&lt;/span&gt;<br/>          &lt;/div&gt;<br/>          &lt;div class="column center-column"&gt;223 lbs&lt;br&gt;<br/>            &lt;span class="tag is-light"&gt;Weight&lt;/span&gt;<br/>          &lt;/div&gt;<br/>          &lt;div class="column"&gt;1.6 m&lt;br&gt;<br/>            &lt;span class="tag is-light"&gt;Height&lt;/span&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `<br/>};<br/><br/><strong class="ld hv">const VenusaurCard</strong> = {<br/>  name: 'venusaur-card',<br/>  template: `<br/>    &lt;div class="card card--venusaur has-text-weight-bold<br/>               has-text-white"&gt;<br/>      &lt;div class="card-image"&gt;<br/>        &lt;div class="card-image-container"&gt;<br/>          &lt;img src="../../static/venusaur.png"/&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="card-content has-text-centered"&gt;<br/>        &lt;div class="main"&gt;<br/>          &lt;div class="title has-text-white"&gt;Venusaur&lt;/div&gt;<br/>          &lt;div class="hp hp-venusaur"&gt;hp 80&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="stats columns is-mobile"&gt;<br/>          &lt;div class="column"&gt;&amp;#x1f343;&lt;br&gt;<br/>            &lt;span class="tag is-danger"&gt;Type&lt;/span&gt;<br/>          &lt;/div&gt;<br/>          &lt;div class="column center-column"&gt;220 lbs&lt;br&gt;<br/>            &lt;span class="tag is-danger"&gt;Weight&lt;/span&gt;<br/>          &lt;/div&gt;<br/>          &lt;div class="column"&gt;2.0 m&lt;br&gt;<br/>            &lt;span class="tag is-danger"&gt;Height&lt;/span&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `<br/>};<br/><br/>const App = { <br/>  // ... <br/>}<br/><br/>export default App;</span></pre><p id="82ed" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">建立了应用程序组件后，我们现在可以开始考虑如何在这些组件之间创建路由。</p><h1 id="8876" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated"><code class="eh la lb lc ld b">router-view</code></h1><p id="66de" class="pw-post-body-paragraph jw jx hu jy b jz lw iv kb kc lx iy ke kf ly kh ki kj lz kl km kn ma kp kq kr hn dt translated">为了建立路由，我们将首先构建一个新的组件，它负责根据应用程序的位置呈现指定的组件。我们将在一个名为<code class="eh la lb lc ld b">View</code>的常量变量中创建这个组件。</p><p id="df3a" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在我们创建这个组件之前，让我们看看如何使用它。在<code class="eh la lb lc ld b">App</code>组件的<code class="eh la lb lc ld b">template</code>中，我们将删除<code class="eh la lb lc ld b">&lt;pokemon-card&gt;</code>的声明，转而呈现即将到来的<code class="eh la lb lc ld b">router-view</code>组件。在<code class="eh la lb lc ld b">components</code>属性中；我们将把<code class="eh la lb lc ld b">View</code>组件常量注册为要在模板中声明的<code class="eh la lb lc ld b">&lt;router-view&gt;</code>。</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="a072" class="nd lf hu ld b fv ne nf l ng nh">const App = {<br/>  name: 'App',<br/>  template: `<br/>    &lt;div class="container"&gt;<br/>      &lt;div class="pokemon"&gt;<br/><strong class="ld hv">        &lt;router-view&gt;&lt;/router-view&gt;</strong><br/>      &lt;/div&gt;<br/>    &lt;/div&gt; <br/>  `,<br/>  components: {<br/><strong class="ld hv">    'router-view': View</strong><br/>  }<br/>};</span><span id="adff" class="nd lf hu ld b fv ni nf l ng nh">export default App;</span></pre><p id="a977" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><code class="eh la lb lc ld b">router-view</code>组件将根据URL路由匹配正确的神奇宝贝组件。这种匹配将在我们将要创建的<code class="eh la lb lc ld b">routes</code>数组中指定。我们将在<code class="eh la lb lc ld b">App</code>组件的正上方创建这个数组:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="0b42" class="nd lf hu ld b fv ne nf l ng nh">const CharizardCard = { <br/>  // ... <br/>};<br/>const BlastoiseCard = { <br/>  // ... <br/>};<br/>const VenusaurCard = { <br/>  // ... <br/>};</span><span id="d50c" class="nd lf hu ld b fv ni nf l ng nh"><strong class="ld hv">const routes</strong> = [<br/>  {path: '/', component: CharizardCard},<br/>  {path: '/charizard', component: CharizardCard},<br/>  {path: '/blastoise', component: BlastoiseCard},<br/>  {path: '/venusaur', component: VenusaurCard}<br/>];</span><span id="803c" class="nd lf hu ld b fv ni nf l ng nh">const App = { <br/>  // ... <br/>};</span><span id="c92a" class="nd lf hu ld b fv ni nf l ng nh">export default App;</span></pre><p id="3cca" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们已经将每个神奇宝贝路径设置为它们各自的组件(例如，<code class="eh la lb lc ld b">/blastoise</code>将渲染<code class="eh la lb lc ld b">BlastoiseCard</code>组件)。我们还将根路径<code class="eh la lb lc ld b">/</code>设置为<code class="eh la lb lc ld b">CharizardCard</code>组件。</p><p id="14ad" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">现在让我们开始创建我们的<code class="eh la lb lc ld b">router-view</code>组件。</p><p id="c7da" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><code class="eh la lb lc ld b">router-view</code>组件实质上是一个<em class="ks">安装点</em>，用于在组件之间动态切换。在Vue中我们可以这样做的一个方法是使用保留的<code class="eh la lb lc ld b">&lt;component&gt;</code>元素来建立<a class="ae jj" href="https://vuejs.org/v2/guide/components.html#Dynamic-Components" rel="noopener ugc nofollow" target="_blank">动态组件</a>。</p><p id="fd4e" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">让我们为<code class="eh la lb lc ld b">router-view</code>创建一个起点来了解它是如何工作的。如前所述；我们将在名为<code class="eh la lb lc ld b">View</code>的常量变量中创建<code class="eh la lb lc ld b">router-view</code>。也就是说，让我们在路由声明之后立即设置<code class="eh la lb lc ld b">View</code>:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="8f70" class="nd lf hu ld b fv ne nf l ng nh">const CharizardCard = { <br/>  // ... <br/>};<br/>const BlastoiseCard = { <br/>  // ... <br/>};<br/>const VenusaurCard = { <br/>  // ... <br/>};<br/><br/>const routes = [<br/>  // ...<br/>];<br/><br/><strong class="ld hv">const View</strong> = {<br/>  name: 'router-view',  <br/>  template: `&lt;component :is="currentView"&gt;&lt;/component&gt;`,  <br/>  data() {  <br/>    return {  <br/>      currentView: CharizardCard  <br/>    }<br/>  }<br/>};<strong class="ld hv"> </strong><br/><br/>const App = {<br/>// ... <br/>};<br/><br/>export default App;</span></pre><p id="26a9" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">保留的<code class="eh la lb lc ld b">&lt;component&gt;</code>元素将呈现<code class="eh la lb lc ld b">is</code>属性绑定到的任何组件。上面，我们已经将<code class="eh la lb lc ld b">is</code>属性附加到了一个<code class="eh la lb lc ld b">currentView</code>数据属性，该属性简单地映射到了<code class="eh la lb lc ld b">CharizardCard</code>组件。到目前为止，我们的应用程序通过显示<code class="eh la lb lc ld b">CharizardCard</code>类似于起点，而不管URL路由是什么。</p><p id="fa4c" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">虽然<code class="eh la lb lc ld b">router-view</code>在<code class="eh la lb lc ld b">App</code>中被适当地渲染，但它目前不是动态的。我们需要<code class="eh la lb lc ld b">router-view</code>在页面加载时根据URL路径名<em class="ks">显示正确的组件。为此，我们将使用<code class="eh la lb lc ld b">created()</code>钩子来过滤<code class="eh la lb lc ld b">routes</code>数组，并返回具有与URL路径匹配的<code class="eh la lb lc ld b">path</code>的组件。这将使<code class="eh la lb lc ld b">View</code>看起来像这样:</em></p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="03ea" class="nd lf hu ld b fv ne nf l ng nh">const View = {<br/>  name: 'router-view',  <br/>  template: `&lt;component :is="currentView"&gt;&lt;/component&gt;`,  <br/>  data() {  <br/>    return {  <br/>      <strong class="ld hv">currentView: {}</strong>  <br/>    }<br/>  },<br/>  <strong class="ld hv">created()</strong> {<br/>    this.currentView = routes.find(<br/>      route =&gt; route.path === window.location.pathname<br/>    ).component;<br/>  }<br/>};</span></pre><p id="5786" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在<code class="eh la lb lc ld b">data</code>中，我们现在用一个空对象实例化<code class="eh la lb lc ld b">currentView</code>。在<code class="eh la lb lc ld b">created()</code>钩子中，我们使用JavaScript的本地<code class="eh la lb lc ld b">find()</code>方法从<code class="eh la lb lc ld b">routes</code>返回第一个匹配<code class="eh la lb lc ld b">route.path === window.location.pathname</code>的对象。然后我们可以得到带有<code class="eh la lb lc ld b">object.component</code>的组件(其中<code class="eh la lb lc ld b">object</code>是从<code class="eh la lb lc ld b">find()</code>返回的对象)。</p><p id="d4be" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在浏览器环境中，<code class="eh la lb lc ld b">window.location</code>是一个包含浏览器当前位置属性的特殊对象。我们从这个对象中获取<code class="eh la lb lc ld b">pathname</code>,它是URL的路径。</p><p id="078e" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">现阶段；我们将能够根据浏览器URL的状态看到不同的神奇宝贝卡组件！</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mp"><img src="../Images/fdf18166400255632009bc57f4af2129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1dKde3RYrtOFAMCUyctVBg.png"/></div></div><figcaption class="nk nl fg fe ff nm nn bd b be z ek">The <code class="eh la lb lc ld b"><strong class="bd no">BlastoiseCard</strong></code> component now renders at the <code class="eh la lb lc ld b"><strong class="bd no">/blastoise</strong></code> route.</figcaption></figure><p id="4613" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们还应该考虑别的事情。如果输入一个随机的URL <code class="eh la lb lc ld b">pathname</code>,我们的应用程序将会出错，并且不会向视图显示任何内容。</p><p id="4095" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">为了避免这种情况，让我们引入一个简单的检查，如果URL <code class="eh la lb lc ld b">pathname</code>与<code class="eh la lb lc ld b">routes</code>数组中存在的任何<code class="eh la lb lc ld b">path</code>都不匹配，就显示一个“未找到”模板。为了避免重复，我们将把<code class="eh la lb lc ld b">find()</code>方法分离成一个名为<code class="eh la lb lc ld b">getRouteObject()</code>的组件方法。这会将<code class="eh la lb lc ld b">View</code>对象更新为:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="d926" class="nd lf hu ld b fv ne nf l ng nh">const View = {<br/>  name: 'router-view',<br/>  template: `&lt;component :is="currentView"&gt;&lt;/component&gt;`,<br/>  data() {<br/>    return {<br/>      currentView: {}  <br/>    }<br/>  },<br/>  created() {<br/>    if (this.getRouteObject() === undefined) {<br/>      this.currentView = {<br/>        template: `<br/>          &lt;h3 class="subtitle has-text-white"&gt;<br/>            Not Found :(. Pick a Pokémon from the list below!<br/>          &lt;/h3&gt;<br/>        `<br/>      };<br/>    } else {<br/>      this.currentView = this.getRouteObject().component;<br/>    }<br/>  },<br/>  methods: {<br/>    getRouteObject() {<br/>      return routes.find(<br/>        route =&gt; route.path === window.location.pathname<br/>      );<br/>    }<br/>  }<br/>};</span></pre><p id="9a33" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">如果<code class="eh la lb lc ld b">getRouteObject()</code>方法返回<code class="eh la lb lc ld b">undefined</code>，我们显示一个“未找到”模板。如果<code class="eh la lb lc ld b">getRouteObject()</code>从<code class="eh la lb lc ld b">routes</code>返回一个对象，我们将<code class="eh la lb lc ld b">currentView</code>绑定到该对象的组件。现在，如果输入一个随机的URL，用户将会收到通知:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mp"><img src="../Images/09de86e5807809d9786d3342f88fbcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FA-WBPTYvyKUmq46d04tw.png"/></div></div><figcaption class="nk nl fg fe ff nm nn bd b be z ek">The “Not Found” view is rendered if the URL <code class="eh la lb lc ld b">pathname</code> does not match any of the values in the routes array.</figcaption></figure><p id="0a74" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">“未找到”模板告诉用户从列表中选择一个神奇宝贝。这个列表将是我们创建的链接，允许用户导航到不同的URL路由。</p><p id="f502" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">厉害！我们的应用程序现在正在响应一些外部状态，即浏览器的位置。<code class="eh la lb lc ld b">router-view</code>根据应用程序的位置决定显示哪个组件。现在，我们需要构建一些链接来<em class="ks">改变浏览器的位置，而不需要发出web请求</em>。随着位置的更新，我们想要重新渲染我们的Vue应用程序，并依靠<code class="eh la lb lc ld b">router-view</code>来适当地确定渲染哪个组件。</p><p id="1fe2" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们将这些链接标记为<code class="eh la lb lc ld b">router-link</code>组件。</p><h1 id="9ab9" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated"><code class="eh la lb lc ld b">router-link</code></h1><p id="f7a7" class="pw-post-body-paragraph jw jx hu jy b jz lw iv kb kc lx iy ke kf ly kh ki kj lz kl km kn ma kp kq kr hn dt translated">在web界面中，我们使用HTML <code class="eh la lb lc ld b">&lt;a&gt;</code>标签来创建链接。这里我们想要的是一种特殊类型的<code class="eh la lb lc ld b">&lt;a&gt;</code>标签。当用户点击这个标签时，我们希望浏览器跳过默认的发出web请求获取下一页的例程。相反，我们只想手动更新浏览器的位置。</p><p id="8092" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">让我们组成一个<code class="eh la lb lc ld b">router-link</code>组件，它产生一个带有特殊<code class="eh la lb lc ld b">click</code>绑定的<code class="eh la lb lc ld b">&lt;a&gt;</code>标签。当用户点击<code class="eh la lb lc ld b">router-link</code>组件时，我们将使用浏览器的<a class="ae jj" href="https://developer.mozilla.org/en-US/docs/Web/API/History" rel="noopener ugc nofollow" target="_blank">历史API </a>来更新浏览器的位置。</p><p id="a322" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">就像我们对<code class="eh la lb lc ld b">router-view</code>所做的一样，让我们在构建之前看看我们将如何使用这个组件。</p><p id="ef3f" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在<code class="eh la lb lc ld b">App</code>组件的模板中，让我们在一个父<code class="eh la lb lc ld b">&lt;div class="pokemon-links"&gt;&lt;/div&gt;</code>元素中创建三个<code class="eh la lb lc ld b">&lt;router-link&gt;</code>元素。我们不使用<code class="eh la lb lc ld b">&lt;router-link&gt;</code>中的<code class="eh la lb lc ld b">href</code>属性，而是使用<code class="eh la lb lc ld b">to</code>属性指定链接的期望位置。我们还将在<code class="eh la lb lc ld b">App</code> <code class="eh la lb lc ld b">components</code>属性中注册即将到来的<code class="eh la lb lc ld b">router-link</code>组件(来自<code class="eh la lb lc ld b">Link</code>常量变量):</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="a844" class="nd lf hu ld b fv ne nf l ng nh">const App = {<br/>  name: 'App',<br/>  template: `<br/>    &lt;div class="container"&gt;<br/>      &lt;div class="pokemon"&gt;<br/>        &lt;router-view&gt;&lt;/router-view&gt;<br/>  <br/>        <strong class="ld hv">&lt;div class="pokemon-links has-text-centered"&gt;<br/>          &lt;router-link to="/charizard"&gt;&lt;/router-link&gt;<br/>          &lt;router-link to="/blastoise"&gt;&lt;/router-link&gt;<br/>          &lt;router-link to="/venusaur"&gt;&lt;/router-link&gt;<br/>        &lt;/div&gt;</strong><br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>  components: {<br/>    'router-view': View,<br/>    <strong class="ld hv">'router-link': Link</strong><br/>  }<br/>};</span></pre><p id="b7b9" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们将在<code class="eh la lb lc ld b">App</code>组件的正上方创建表示<code class="eh la lb lc ld b">router-link</code>的<code class="eh la lb lc ld b">Link</code>对象。我们已经确定了<code class="eh la lb lc ld b">router-link</code>组件应该总是被赋予一个具有目标位置值的<code class="eh la lb lc ld b">to</code>属性(即prop)。我们可以像这样强制执行这个适当验证要求:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="6e28" class="nd lf hu ld b fv ne nf l ng nh">const CharizardCard = { <br/> // ... <br/>};<br/>const BlastoiseCard = { <br/>  // ... <br/>};<br/>const VenusaurCard = { <br/>  // ... <br/>};</span><span id="1fbf" class="nd lf hu ld b fv ni nf l ng nh">const routes = [ <br/>  // ... <br/>];</span><span id="9b26" class="nd lf hu ld b fv ni nf l ng nh">const View = { <br/>  // ... <br/>};</span><span id="5af2" class="nd lf hu ld b fv ni nf l ng nh"><strong class="ld hv">const Link</strong> = {<br/>  name: 'router-link',<br/>  props: {<br/>    to: {<br/>      type: String,<br/>      required: true<br/>    }<br/>  }<br/>};</span><span id="0a84" class="nd lf hu ld b fv ni nf l ng nh">const App = { <br/>  // ... <br/>};</span><span id="e6da" class="nd lf hu ld b fv ni nf l ng nh">export default App;</span></pre><p id="3df4" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们可以创建<code class="eh la lb lc ld b">router-link</code>的<code class="eh la lb lc ld b">template</code>来包含一个带有<code class="eh la lb lc ld b">@click</code>处理程序属性的<code class="eh la lb lc ld b">&lt;a&gt;</code>标签。一旦触发，<code class="eh la lb lc ld b">@click</code>处理程序将调用一个组件方法，标记为<code class="eh la lb lc ld b">navigate()</code>，将浏览器导航到所需的位置。这种导航将通过使用<code class="eh la lb lc ld b"><a class="ae jj" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_pushState()_method" rel="noopener ugc nofollow" target="_blank">history.pushState()</a></code>方法来实现。也就是说，<code class="eh la lb lc ld b">Link</code>常量对象将被更新为:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="a090" class="nd lf hu ld b fv ne nf l ng nh">const Link = {<br/>  name: 'router-link',<br/>  props: {<br/>    to: {<br/>      type: String,<br/>      required: true<br/>    }<br/>  },<br/>  template: `&lt;a @click="navigate" :href="to"&gt;{{ to }}&lt;/a&gt;`,<br/>  methods: {  <br/>    navigate(evt) {  <br/>      evt.preventDefault();  <br/>      window.history.pushState(null, null, this.to);  <br/>    }<br/>  }<br/>};</span></pre><p id="1fac" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在<code class="eh la lb lc ld b">&lt;a&gt;</code>标签中，我们用<code class="eh la lb lc ld b">{{ to }}</code>将<code class="eh la lb lc ld b">to</code>属性的值绑定到元素文本内容。</p><p id="798f" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">当<code class="eh la lb lc ld b">navigate()</code>被触发时，它首先调用事件对象上的<code class="eh la lb lc ld b">preventDefault()</code>来阻止浏览器对新位置的web请求。然后调用<code class="eh la lb lc ld b">history.pushState()</code>方法将用户指引到所需的路线位置。<code class="eh la lb lc ld b">history.pushState()</code>需要三个参数:</p><ul class=""><li id="5384" class="mb mc hu jy b jz ka kc kd kf md kj me kn mf kr mg mh mi mj dt translated">传递序列化状态信息的状态对象</li><li id="aa75" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated">一个标题</li><li id="be61" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated">目标URL</li></ul><p id="1604" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在我们的例子中，没有需要传递的状态信息，所以我们将第一个参数保留为<code class="eh la lb lc ld b">null</code>。一些浏览器(例如Firefox)目前忽略了第二个参数<code class="eh la lb lc ld b">title</code>，因此我们也将它保留为<code class="eh la lb lc ld b">null</code>。</p><p id="09e2" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">目标位置<code class="eh la lb lc ld b">to</code> prop被传递给第三个也是最后一个参数。由于<code class="eh la lb lc ld b">to</code>属性包含相对状态的目标位置，所以它将相对于当前URL进行解析。在我们的例子中，<code class="eh la lb lc ld b">/blastoise</code>将解析为<code class="eh la lb lc ld b"><a class="ae jj" href="http://localhost:8080/blastoise." rel="noopener ugc nofollow" target="_blank">http://localhost:8080/blastoise</a></code> <a class="ae jj" href="http://localhost:8080/blastoise." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ed6d" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">如果我们现在点击任何链接，我们会注意到我们的浏览器更新到正确的位置，而无需重新加载整个页面。但是，我们的应用程序不会更新和呈现正确的组件。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff np"><img src="../Images/40e72b1c7c0dd992aa62b4d36dfe2c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QHAd1ahTcCwAi1-D7d0Sng.gif"/></div></div></figure><p id="2e3e" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">这种意外行为的发生是因为当<code class="eh la lb lc ld b">router-link</code>正在更新浏览器的位置时，<strong class="jy hv">我们的Vue应用程序没有收到关于这一变化的警报</strong>。每当位置改变时，我们需要触发我们的应用程序(或者仅仅是<code class="eh la lb lc ld b">router-view</code>组件)来重新渲染。</p><p id="e962" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">虽然有几种方法可以实现这种行为，但是我们将通过使用自定义的<code class="eh la lb lc ld b"><a class="ae jj" href="https://alligator.io/vuejs/global-event-bus/" rel="noopener ugc nofollow" target="_blank">EventBus</a></code>来实现。一个<code class="eh la lb lc ld b">EventBus</code>是一个Vue实例，负责允许独立的组件在彼此之间订阅和发布<a class="ae jj" href="https://vuejs.org/v2/guide/components.html#Custom-Events" rel="noopener ugc nofollow" target="_blank">自定义事件</a>。</p><p id="9229" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在文件的开头，我们将<code class="eh la lb lc ld b">import</code>库<code class="eh la lb lc ld b">vue</code>并创建一个带有新<code class="eh la lb lc ld b">Vue()</code>实例的<code class="eh la lb lc ld b">EventBus</code>:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="381c" class="nd lf hu ld b fv ne nf l ng nh">import Vue from 'vue';</span><span id="b762" class="nd lf hu ld b fv ni nf l ng nh">const EventBus = new Vue();</span></pre><p id="84fe" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">当一个链接被点击，我们需要通知应用程序的必要部分(即<code class="eh la lb lc ld b">router-view</code>)用户正在导航到一个特定的路线。第一步是在<code class="eh la lb lc ld b">router-link</code>的<code class="eh la lb lc ld b">navigate()</code>方法中使用<code class="eh la lb lc ld b">EventBus</code>的events接口创建一个事件发射器。我们将这个自定义事件命名为<code class="eh la lb lc ld b">navigate</code>:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="04a9" class="nd lf hu ld b fv ne nf l ng nh">const Link = {<br/>  // ...,<br/>  methods: {<br/>    navigate(evt) {<br/>      evt.preventDefault();<br/>      window.history.pushState(null, null, this.to);<br/>      <strong class="ld hv">EventBus.$emit('navigate');</strong> <br/>    }<br/>  }<br/>};</span></pre><p id="46e9" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们现在可以在<code class="eh la lb lc ld b">router-view</code>的<code class="eh la lb lc ld b">created()</code>钩子中设置事件监听器/触发器。通过在<code class="eh la lb lc ld b">if/else</code>语句之外设置自定义事件监听器，<code class="eh la lb lc ld b">View</code>的<code class="eh la lb lc ld b">created()</code>钩子将被更新为:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="548d" class="nd lf hu ld b fv ne nf l ng nh">const View = {<br/>  // ...,<br/>  created() {  <br/>    if (this.getRouteObject() === undefined) {<br/>      this.currentView = {<br/>        template: `<br/>          &lt;h3 class="subtitle has-text-white"&gt;<br/>            Not Found :(. Pick a Pokémon from the list below!<br/>          &lt;/h3&gt;<br/>        `<br/>      };<br/>    } else {<br/>      this.currentView = this.getRouteObject().component;<br/>    }</span><span id="bece" class="nd lf hu ld b fv ni nf l ng nh"><strong class="ld hv">    // Event listener for link navigation<br/>    EventBus.$on('navigate', () =&gt; {<br/>      this.currentView = this.getRouteObject().component;<br/>    });</strong><br/>  },<br/>  .. ///<br/>};</span></pre><p id="e694" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">当浏览器的位置通过点击一个<code class="eh la lb lc ld b">&lt;router-link&gt;</code>元素而改变时，这个监听函数将被调用，重新呈现<code class="eh la lb lc ld b">router-view</code>以匹配最新的URL！</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff nq"><img src="../Images/a5e3ff6b54ea490fe91d8af1a35f869b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RMt1jjKR9IHW4IAH3iFruw.gif"/></div></div></figure><p id="78d0" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">太好了！当我们点击每个链接时，我们的应用程序现在可以正确导航。</p><p id="fa10" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们还需要考虑最后一件事。如果我们尝试使用浏览器的后退/前进按钮来浏览浏览器历史，我们的应用程序当前将无法正确地重新呈现。虽然这是意料之外的，但这是因为当用户点击<code class="eh la lb lc ld b">browser back</code>或<code class="eh la lb lc ld b">browser forward</code>时<strong class="jy hv">没有事件通知程序发出</strong>。</p><p id="a093" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">为了实现这一点，我们将使用<code class="eh la lb lc ld b"><a class="ae jj" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate" rel="noopener ugc nofollow" target="_blank">onpopstate</a></code>事件处理程序。</p><p id="55c1" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">每次活动的历史条目改变时，触发<code class="eh la lb lc ld b">onpopstate</code>事件。通过点击<code class="eh la lb lc ld b">browser back</code>或<code class="eh la lb lc ld b">browser forward</code>按钮，或通过编程调用<code class="eh la lb lc ld b">history.back()</code>或<code class="eh la lb lc ld b">history.forward()</code>调用历史变更。</p><p id="b89a" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">就在我们的<code class="eh la lb lc ld b">EventBus</code>创建之后，让我们设置<code class="eh la lb lc ld b">onpopstate</code>事件监听器，以便在调用历史更改时发出navigate事件:</p><pre class="jl jm jn jo fq mz ld na nb aw nc dt"><span id="86e9" class="nd lf hu ld b fv ne nf l ng nh">window.addEventListener('popstate', () =&gt; {  <br/>  EventBus.$emit('navigate');  <br/>});</span></pre><p id="7b33" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">即使使用了浏览器导航按钮，我们的应用程序现在也会做出适当的响应！</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff np"><img src="../Images/05bcecc9c2b189b47d57689c2bd19740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jAERnzmI3rZc2bIsP4-hCg.gif"/></div></div></figure><p id="4afb" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">我们做到了！我们刚刚使用<code class="eh la lb lc ld b">EventBus</code>和动态组件构建了一个定制的Vue路由器。即使我们的应用程序很小，我们也可以享受到显著的性能提升。避免全页面加载也节省了数百毫秒，并防止我们的应用程序在页面变化期间“闪烁”。</p><h1 id="c1c1" class="le lf hu bd lg lh li lj lk ll lm ln lo ja lp jb lq jd lr je ls jg lt jh lu lv dt translated">结论</h1><p id="09cd" class="pw-post-body-paragraph jw jx hu jy b jz lw iv kb kc lx iy ke kf ly kh ki kj lz kl km kn ma kp kq kr hn dt translated">我爱Vue。其中一个原因是——正如我们在本文中看到的，使用和操作Vue组件非常简单。</p><p id="9c9f" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在简介中，我们提到了Vue如何提供<code class="eh la lb lc ld b">vue-router</code>库作为框架的官方路由库。我们刚刚创建了在<code class="eh la lb lc ld b">vue-router</code>中使用的相同主项目的简单版本:</p><ul class=""><li id="9b6a" class="mb mc hu jy b jz ka kc kd kf md kj me kn mf kr mg mh mi mj dt translated"><code class="eh la lb lc ld b">routes</code>:负责将组件映射到各自URL路径名的数组。</li><li id="1145" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated"><code class="eh la lb lc ld b">router-view</code>:基于应用的位置呈现指定应用组件的组件</li><li id="b877" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated"><code class="eh la lb lc ld b">router-link</code>:允许用户改变浏览器位置而无需发出web请求的组件。</li></ul><p id="4653" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">对于<em class="ks">非常</em>简单的应用程序，我们构建的路由(或者它的变体<a class="ae jj" href="https://github.com/chrisvfritz/vue-2.0-simple-routing-example" rel="noopener ugc nofollow" target="_blank">像这个</a>由<a class="ae jj" href="https://github.com/chrisvfritz" rel="noopener ugc nofollow" target="_blank"> Chris Fritz </a>构建)可以做路由我们的应用程序所需的最少量的工作。</p><p id="4e55" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">另一方面,<code class="eh la lb lc ld b">vue-router</code>库以更复杂的方式构建，并引入了非常有用的功能，这些功能通常在大型应用程序中需要，例如:</p><ul class=""><li id="3f3f" class="mb mc hu jy b jz ka kc kd kf md kj me kn mf kr mg mh mi mj dt translated">不同浏览器之间的一致性</li><li id="774b" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated"><a class="ae jj" href="https://router.vuejs.org/en/essentials/nested-routes.html" rel="noopener ugc nofollow" target="_blank">嵌套路线</a></li><li id="2fc0" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated"><a class="ae jj" href="https://router.vuejs.org/en/advanced/navigation-guards.html" rel="noopener ugc nofollow" target="_blank">导航护板</a></li><li id="f7d8" class="mb mc hu jy b jz mk kc ml kf mm kj mn kn mo kr mg mh mi mj dt translated"><a class="ae jj" href="https://router.vuejs.org/en/advanced/transitions.html" rel="noopener ugc nofollow" target="_blank">过渡效果</a></li></ul><p id="ac65" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">尽管<code class="eh la lb lc ld b">vue-router</code>库确实附带了额外的样板文件，但是一旦你的应用程序由隔离良好的不同组件组成，集成起来就相当容易了。如果你感兴趣，你可以在这里看到<code class="eh la lb lc ld b">vue-router</code>的组件被用来在这个应用<a class="ae jj" href="https://github.com/djirdehh/pokemon-routing/blob/master/src/app/app-vue-router.js" rel="noopener ugc nofollow" target="_blank">中启用路由。</a></p><p id="1a16" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">希望这能让你感到愉快，就像我在编辑这篇文章时一样！感谢阅读！</p><p id="83c2" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">—————————♥———<br/>本文是从<a class="ae jj" href="https://hackernoon.com/tagged/book" rel="noopener ugc nofollow" target="_blank">书</a>、<strong class="jy hv"> Fullstack Vue改编(并总结)的片段。</strong> Fullstack Vue是一种学习<a class="ae jj" href="https://hackernoon.com/tagged/learning" rel="noopener ugc nofollow" target="_blank">Vue . js的项目驱动方法，因为一切都是在构建更大的应用程序的背景下解释的。Fullstack Vue目前可用，你可以从主网站</a><a class="ae jj" href="https://www.fullstack.io/vue" rel="noopener ugc nofollow" target="_blank">https://www.fullstack.io/vue</a>免费下载<em class="ks">的第一章</em></p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="nr ms l"/></div></figure></div></div>    
</body>
</html>