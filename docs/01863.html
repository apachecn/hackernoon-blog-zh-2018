<html>
<head>
<title>Redesigning Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新设计Redux</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redesigning-redux-b2baee8b8a38?source=collection_archive---------0-----------------------#2018-02-28">https://medium.com/hackernoon/redesigning-redux-b2baee8b8a38?source=collection_archive---------0-----------------------#2018-02-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="83ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在国家管理不应该是一个已经解决的问题吗？直觉上，开发人员似乎知道一个隐藏的事实:状态管理似乎比它需要的更难。在本文中，我们将探讨一些你可能一直在问自己的问题:</p><ul class=""><li id="61df" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">状态管理需要库吗？</li><li id="2312" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">Redux的人气是实至名归吗？为什么或为什么不？</li><li id="078b" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">我们能做出更好的状态管理解决方案吗？如果有，如何实现？</li></ul><h1 id="4094" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">国家管理需要图书馆吗？</h1><p id="0c71" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">做前端开发者不仅仅是移动像素；开发的真正艺术是知道在哪里存储状态。简而言之:很复杂，但没那么复杂。</p><p id="a3ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看看使用基于组件的视图框架/库(如React)时的选项:</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff lg"><img src="../Images/b2b5830838aebb1ef19f3f0f0b06e6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVjLQBND9Ji1QqgzgokHCA.png"/></div></div></figure><h2 id="8352" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">1.组件状态</h2><p id="c744" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">存在于单个组件内部的状态。在React中，认为<code class="eh mg mh mi mj b">state</code>用<code class="eh mg mh mi mj b">setState</code>更新了。</p><h2 id="b000" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">2.相对状态</h2><p id="0e1e" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">状态从父代传递给子代。在React中，认为<code class="eh mg mh mi mj b">props</code>作为属性传递给了一个子组件。</p><h2 id="4d1b" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">3.提供状态</h2><p id="85d9" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">状态保存在根<strong class="it hv">提供者</strong>中，并由组件树中某处的<strong class="it hv">消费者</strong>访问，而不考虑邻近性。在反应过来的时候，想起了<code class="eh mg mh mi mj b">context API</code>。</p><p id="2a40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多状态属于视图，因为它反映了UI。但是反映底层数据和逻辑的所有其他代码呢？</p><p id="22d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将所有内容都放在视图中会导致不良的<strong class="it hv"> <em class="mk">关注点分离:</em> </strong>它将您与javascript视图库捆绑在一起，使代码更难测试，并且可能是最大的烦恼:您必须不断地思考和重新调整您存储状态的位置。</p><p id="f811" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于设计的变化，状态管理变得很复杂，而且通常很难判断哪个组件需要哪个状态。最直接的选择是只提供根组件的所有状态，此时，您最好选择下一个选项。</p><h2 id="aad1" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">4.外部状态</h2><p id="ca45" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">状态可以移动到视图库之外。然后，库可以使用提供者/消费者模式“连接”以保持同步。</p><p id="45bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许最流行的状态管理库是Redux。在过去的两年里，它越来越受欢迎。那么，为什么这么喜欢一个简单的库呢？</p><p id="115e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mk">Redux的性能更高吗？</em>不会。每处理一个新动作，速度都会变慢。</p><p id="00c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mk">Redux更简单吗？</em>肯定不是。</p><p id="4d05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单就是纯javascript:</p><figure class="lh li lj lk fq ll"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="06c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么为什么不是每个人都使用<code class="eh mg mh mi mj b">global.state = {}</code>？</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="95c4" class="kd ke hu bd kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la dt translated">为什么是Redux？</h1><p id="c779" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">实际上，Redux与TJ的根对象是一样的——只是包装在一个实用程序管道中。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/605b97e1936bd1ed7cfc949904fc9530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*2FuGS7siVavYWxuHtx8ynw.png"/></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">The Redux Store Pipeline</figcaption></figure><p id="ee47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Redux中，不能直接修改状态。只有一种方法:<strong class="it hv">将</strong>和<strong class="it hv">动作</strong>发送到最终更新状态的管道中。</p><p id="1a0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">管道沿线有两套监听器:<strong class="it hv">中间件</strong> &amp; <strong class="it hv">订阅</strong>。中间件<strong class="it hv"> </strong>是可以监听传入的动作的函数，支持诸如“logger”、“devtools”或“syncWithServer”监听器之类的工具。订阅<strong class="it hv"> </strong>是用于广播这些状态变化的功能。</p><p id="a40b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，<strong class="it hv">reducer</strong>更新函数，将状态变化分解成更小、更模块化和更易管理的块。</p><blockquote class="ne nf ng"><p id="cfc5" class="ir is mk it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">对于开发来说，Redux实际上可能比用一个全局对象作为状态更简单。</p></blockquote><p id="6b38" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以把Redux想象成一个带有前/后更新挂钩的全局对象，以及“减少”下一个状态的简化方法。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="c083" class="kd ke hu bd kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la dt translated">但是Redux是不是太复杂了？</h1><p id="3c73" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">是的。有几个不可否认的迹象表明API需要改进；这些可以用下面的等式来总结:</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/9ad2d7c93dc5eb525268506bd7a324ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*FGpB-B21W94dhS9a6pwSEg.png"/></div></figure><p id="b87d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑用<code class="eh mg mh mi mj b">time_saved</code>代表你开发自己的解决方案所花费的时间，而<code class="eh mg mh mi mj b">time_invested</code>相当于阅读文档、学习教程和研究不熟悉的概念所花费的时间。</p><p id="04d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux本质上是一个简单的小型库，具有陡峭的学习曲线。对于每一个克服了Redux并受益于它的深入函数式编程的开发人员来说，都有另一个潜在的开发人员迷失了，他们认为“这不适合我，我要回到jQuery”。</p><p id="6f04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用jQuery不需要理解什么是“comonad ”,也不一定需要理解函数组合来处理状态管理。</p><p id="4d78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mk">任何库的目的都是通过抽象让更复杂的东西</em> <strong class="it hv"> <em class="mk">看起来</em> </strong> <em class="mk">简单。</em></p><p id="cc2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">澄清一下，我的意图并不是要折磨丹·阿布拉莫夫。Redux变得太受欢迎，在其婴儿期太早。</p><ul class=""><li id="e1d6" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">如何重构一个已经被数百万开发者使用的库？</li><li id="577b" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">你如何证明发布影响全球无数项目的突破性变化是正当的？</li></ul><p id="6570" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你不能。但是你可以通过广泛的文档、教育视频和社区拓展来提供惊人的支持。丹·阿布拉莫夫赢得了比赛。</p><p id="04c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者也许有别的方法。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="61c2" class="kd ke hu bd kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la dt translated">重新设计Redux</h1><p id="0d5f" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我认为Redux值得重写。我有7个需要改进的地方。</p><h2 id="2537" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">1.设置</h2><p id="44bb" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">让我们看看左边的<a class="ae nl" href="https://github.com/reactjs/redux/blob/master/examples/real-world/src/store/configureStore.dev.js" rel="noopener ugc nofollow" target="_blank">真实世界</a> Redux示例的基本设置。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff nm"><img src="../Images/784301d11cc86c45593bd36e626866f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5aUT2n8ie90TvMXqx7_MQ.png"/></div></div></figure><p id="6693" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很多开发商都在这里停了下来，在刚刚迈出第一步之后，茫然地望向深渊。什么是<strong class="it hv"> <em class="mk">铛</em> </strong>？<strong class="it hv"> <em class="mk">作曲</em> </strong>？一个函数连<strong class="it hv"> <em class="mk">都能做到</em> </strong>那样吗？</p><p id="cc88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑一下Redux是否基于配置而不是组合。设置可能看起来更像右边的例子。</p><h2 id="c1f4" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">2.简化的减速器</h2><p id="84a1" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Redux中的Reducers可以使用一个开关，远离我们已经习惯的不必要的冗长开关语句。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff nn"><img src="../Images/3133abe9121b81587762e7b6704182bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcEOGpeVlWoc-L0K45zkQQ.png"/></div></div></figure><p id="eab2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设一个缩减器在动作类型上匹配，我们可以反转参数，使得每个缩减器都是一个接受状态和动作的纯函数。也许更简单，我们可以标准化动作，只传入状态和有效载荷。</p><h2 id="2398" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">4.异步/等待超时</h2><p id="e729" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><strong class="it hv"> <em class="mk"> Thunks </em> </strong>常用于在Redux中创建异步动作。在许多方面，thunk的工作方式看起来更像是一个聪明的黑客，而不是官方推荐的解决方案。请跟随我:</p><ol class=""><li id="518d" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo no jv jw jx dt translated">你调度一个动作，它实际上是一个函数而不是预期的对象。</li><li id="296d" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo no jv jw jx dt translated">Thunk中间件检查每个动作，看它是否是一个函数。</li><li id="ea4b" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo no jv jw jx dt translated">如果是这样，中间件调用该函数并传递对一些存储方法的访问:dispatch和getState。</li></ol><p id="033b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">真的吗？将一个简单的动作动态类型化为一个对象、函数，甚至是一个承诺，这难道不是一种不好的做法吗？</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff nn"><img src="../Images/ca4a8a4d3fca1642207117989bfb9e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IP9TfDi1WPEeyfPoFuRCMg.png"/></div></div></figure><p id="8cd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像右边的例子，我们就不能异步/等待吗？</p><h2 id="b64a" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">5.两种行动</h2><p id="511d" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">仔细想想，实际上有两种行为:</p><ol class=""><li id="f773" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo no jv jw jx dt translated"><strong class="it hv"> <em class="mk">减速器动作</em> </strong>:触发减速器，改变状态。</li><li id="a8e4" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo no jv jw jx dt translated"><strong class="it hv"> <em class="mk">效果动作</em> </strong>:触发一个异步动作。这可能会调用Reducer操作，但是异步函数不会直接改变任何状态。</li></ol><p id="3051" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与上述“thunks”的用法相比，区分这两种类型的动作会更有帮助，更少混淆。</p><h2 id="cc94" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">6.没有更多的动作类型作为变量</h2><p id="3384" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">为什么区别对待动作创建者和减少者是标准做法？一个可以离开另一个而存在吗？改变一个不影响另一个吗？</p><blockquote class="ne nf ng"><p id="480b" class="ir is mk it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">行动创造者和减少者是一枚硬币的两面。</p></blockquote><p id="680f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mg mh mi mj b">const ACTION_ONE = 'ACTION_ONE'</code>是动作创造者和还原者分离的多余副作用。将两者视为一体，就不再需要导出类型字符串的大文件。</p><h2 id="85fb" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">7.作为行动创造者的减少者</h2><p id="6c67" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">将Redux的元素按照它们的用途分组，您可能会得到一个更简单的模式。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><a href="https://gist.github.com/ShMcK/6e8a7b576ffac1975ec2868c7816c37c"><div class="fe ff np"><img src="../Images/3fe330b31c7baf4d0e29f05bda826167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMvxjQuK_oI0Vj4bPFKatA.png"/></div></a></figure><p id="492b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从减速器中自动确定动作创建者是可能的。毕竟，在这个场景中<strong class="it hv">还原者可以成为动作创造者</strong>。</p><p id="745d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用基本的命名约定，以下内容是可预测的:</p><ol class=""><li id="688e" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo no jv jw jx dt translated">如果减速器的名称为“增量”，则类型为“增量”。更好的是，我们把它命名为:“计数/增量”。</li><li id="bdff" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo no jv jw jx dt translated">每个动作都通过一个“有效载荷”键传递数据。</li></ol><figure class="lh li lj lk fq ll fe ff paragraph-image"><a href="http://ShMcK/17b3a396576a425de091170ec141b1bf"><div class="fe ff nq"><img src="../Images/224ab54e429708cf01c1676656f255fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6r4EQrEQPYFjdoAPJEHSQ.png"/></div></a></figure><p id="14e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，从<code class="eh mg mh mi mj b">count.increment</code>开始，我们可以从reducer中生成action creator。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="e3cb" class="kd ke hu bd kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la dt translated">好消息:我们可以有一个更好的Redux</h1><p id="6733" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这些痛点就是我们创造<a class="ae nl" href="https://github.com/rematch/rematch" rel="noopener ugc nofollow" target="_blank">复赛</a>的原因。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/e1a62fdd28ac21f76e247ef9cda3378b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*8kmmNxJULJFfpVObiqB9Dg.png"/></div></figure><p id="cbde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Rematch是Redux的一个包装器，它提供了一个更简单的API，而没有损失任何可配置性。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/74e556251f4249443a406c889eb85adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*QE_sq7l5dtgkWATA3Q1IsA.png"/></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">Rematch: The Redux Framework</figcaption></figure><p id="cf7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请参见下面的完整复赛示例:</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><a href="https://gist.github.com/ShMcK/194360c2b54c2e55c1008a17e486510c"><div class="fe ff nt"><img src="../Images/f6fa7ab25fb05321d9e4d893bad8f41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kuwz7D9cpi7FzspViT9FTg.png"/></div></a></figure><p id="006f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">过去几个月我一直在生产中使用Rematch。作为证明，我会说:</p><blockquote class="ne nf ng"><p id="69d5" class="ir is mk it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">我从来没有花这么少的时间思考国家管理。</p></blockquote><p id="5da2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux不会消失，也不应该消失。拥抱Redux背后的简单模式，减少学习曲线、样板文件和认知开销。</p><p id="3a78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">试试<a class="ae nl" href="https://github.com/rematch/rematch" rel="noopener ugc nofollow" target="_blank">复赛</a>，看你爱不爱。<br/>给我们一颗星星，让别人知道你做了什么。</p></div></div>    
</body>
</html>