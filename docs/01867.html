<html>
<head>
<title>Don’t Fear The Rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要害怕Rebase</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dont-fear-the-rebase-bca683888dae?source=collection_archive---------4-----------------------#2018-02-28">https://medium.com/hackernoon/dont-fear-the-rebase-bca683888dae?source=collection_archive---------4-----------------------#2018-02-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2e70075661366acdbc25161eefd4ec09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09KWDWnv1JDeZ-LEkXpL7g.png"/></div></div></figure><p id="41a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Git的<code class="eh ka kb kc kd b">rebase</code>命令是Git用户恐惧和困惑的一个常见来源，尤其是那些来自更集中的版本控制系统的用户。这很正常。Rebase是一个奇怪的，看起来神奇的野兽，它只是进来，开始改变历史。</p><p id="010c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rebase有点像指针。这是每个人都在谈论的令人困惑的构造，但是你不知道为什么有人会使用它，然后突然一切都会<em class="ke">点击</em>并且整个想法变得非常明显和难以置信的简单。</p><p id="8e40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在这里强迫<em class="ke">点击</em>到你身上，这样你就可以去工作并传播<code class="eh ka kb kc kd b">git rebase</code>的奇迹。</p><h1 id="66a2" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么是Rebase？</h1><blockquote class="ld le lf"><p id="d6c8" class="jc jd ke je b jf jg jh ji jj jk jl jm lg jo jp jq lh js jt ju li jw jx jy jz hn dt translated">Git Rebase是一个工具，可以用来获取在一个地方进行的一些提交，并假装它们一直是在另一个地方进行的。</p></blockquote><p id="a139" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">好的，但是那个<em class="ke">是什么意思</em>？</strong></p><p id="5303" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看一个例子。我们在这个库中有两个分支:<code class="eh ka kb kc kd b">master</code>和<code class="eh ka kb kc kd b">feature/foo</code>。<code class="eh ka kb kc kd b">feature/foo</code>从<code class="eh ka kb kc kd b">master</code>分支出来，一些提交在<code class="eh ka kb kc kd b">feature/foo</code>进行。已经向前看了，因为当你不注意的时候，世界不会停止。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/7a1cd65791015ab39889ade236515c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQdhYt4nNVFKlpw_q_IYow.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Current state of affairs</figcaption></figure><p id="2778" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们希望将来自<code class="eh ka kb kc kd b">master</code>的变更集成到<code class="eh ka kb kc kd b">feature/foo</code>中，但是我们不想每次执行这个集成时都有一个讨厌的合并提交。</p><p id="3e24" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Rebase是一个工具，它使您能够集成发生在源分支上的变更，而无需执行合并，因此也无需提交合并。</strong></p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/7087ea7de2200afc34034004bdf3d696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZLwva5O5UoPxcrV68oYgQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Post-rebase. Visions of fast-forward…</figcaption></figure><p id="722c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">提交<em class="ke"> D </em>和<em class="ke"> F </em>已经在<code class="eh ka kb kc kd b">master</code>之上<em class="ke">重放</em>，当前指向提交<em class="ke"> G </em>。您会注意到这些提交实际上被命名为<em class="ke"> D` </em>和<em class="ke"> F` </em>，并且提交SHA-1是不同的。这是为什么呢？</p><h2 id="7806" class="lt kg hu bd kh lu lv lw kl lx ly lz kp jn ma mb kt jr mc md kx jv me mf lb mg dt translated">提交在Git中是不可变的</h2><p id="8ddb" class="pw-post-body-paragraph jc jd hu je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">提交有几个相关的属性:父提交、时间戳和提交时存储库的快照(提交不仅仅是变更集)。Git在计算标识提交的SHA-1时使用这些值。</p><p id="abbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于提交是不可变的，并且阿沙-1应该唯一地标识单个提交，Git必须创建新的提交，这些提交包含与原始提交相同的存储库快照，但是每个提交都有不同的父提交和时间戳。</p><p id="6526" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这导致新提交看起来与原始提交相同，但是具有不同的SHA-1。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h1 id="6c36" class="kf kg hu bd kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky mx la lb lc dt translated">查找提交</h1><p id="c170" class="pw-post-body-paragraph jc jd hu je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">当我们从<code class="eh ka kb kc kd b">feature/foo</code>运行<code class="eh ka kb kc kd b">git rebase master</code>时，Git如何知道要移动哪些提交？</p><p id="84be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们首先看一下每个分支上的提交的维恩图。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/14a33d603238e7c5e93af6b335ee69f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbxYqw71A8ehVCTGkNOyWw.png"/></div></div></figure><p id="2386" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们看到每个分支都有提交<em class="ke"> A </em>、<em class="ke"> B </em>和<em class="ke"> C </em>。<code class="eh ka kb kc kd b">master</code>有<code class="eh ka kb kc kd b">feature/foo</code>没有的提交<em class="ke"> E </em>和<em class="ke"> G </em>。<code class="eh ka kb kc kd b">feature/foo</code>有<code class="eh ka kb kc kd b">master</code>没有的提交<em class="ke"> F </em>和<em class="ke"> D </em>。</p><p id="60f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Git将执行集合减法<code class="eh ka kb kc kd b">{commits on feature/foo} — {commits on master}</code>，以找到正确的提交。这导致提交<em class="ke"> D </em>和<em class="ke">f</em></p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/5327a14fbdc13ae20fb73dccb0bf14e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkRc0FH6CzwSse5CNrscfA.png"/></div></div></figure><h2 id="2b9f" class="lt kg hu bd kh lu lv lw kl lx ly lz kp jn ma mb kt jr mc md kx jv me mf lb mg dt translated">我们能证明吗？</h2><p id="b304" class="pw-post-body-paragraph jc jd hu je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">是啊！一种简单的方法是使用<code class="eh ka kb kc kd b">git log</code>来查看我们从这个集合减法中得到的确切提交。</p><p id="b5d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">git log master..feature/foo</code> <em class="ke">应该</em>向我们展示提交的<code class="eh ka kb kc kd b">bc1f36b</code>和<code class="eh ka kb kc kd b">640e713</code>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/288a5ee73859200abb7d3ca2a4f9e0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3VrmbNmzlpuOm3Fl9Fe8w.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Current branch is implied if you omit a branch after ..</figcaption></figure><p id="74a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前看起来不错。让我们有一个更广阔的视野，以确保我没有拉链。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/2976a7ea54a03d5532c6cef029cddccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2qcOyvEF6CiZycntHQ_6g.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">These SHA-1s look familiar</figcaption></figure><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/67247625a013ab24cac34c05e78804e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUQkjOT3zHCNp_6LjilQ4A.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">76f5fd1 and 22033eb are missing because we diverged from master at 7559a0b</figcaption></figure></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="c8ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们现在对<code class="eh ka kb kc kd b">master</code>执行一个<code class="eh ka kb kc kd b">rebase</code>，我们应该看到在<code class="eh ka kb kc kd b">feature/foo</code>提交之前的提交<code class="eh ka kb kc kd b">76f5fd1</code>和<code class="eh ka kb kc kd b">22033eb</code>。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/33e839107b4b3eb0293dd94c9356add7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLXh6HY221LdULI_i79RyQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Git is replaying the commits that we expected</figcaption></figure><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/4f0cfe5161796bfa0c539604d86894ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCRyFq-dsWmZWWQ-8a-RJg.png"/></div></div></figure><p id="e4ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这看起来眼熟吗？</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/7087ea7de2200afc34034004bdf3d696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZLwva5O5UoPxcrV68oYgQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">We saw this earlier!</figcaption></figure><p id="57fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在有一个很好的线性历史。此时，您应该能够看到快速合并是如何发生的。</p><blockquote class="ld le lf"><p id="0164" class="jc jd ke je b jf jg jh ji jj jk jl jm lg jo jp jq lh js jt ju li jw jx jy jz hn dt translated">rebase策略有一个额外的好处，那就是知道如果您的CI管道通过了feature分支，它将在合并后通过main分支。对于非线性合并策略，您没有这种保证。</p></blockquote></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h1 id="9a60" class="kf kg hu bd kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky mx la lb lc dt translated">使用原力</h1><p id="c06d" class="pw-post-body-paragraph jc jd hu je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">如果<code class="eh ka kb kc kd b">feature/foo</code>已经被推送，并且在此基础上尝试另一个推送，Git将非常礼貌地拒绝推送。这是为什么呢？</p><blockquote class="ld le lf"><p id="62b2" class="jc jd ke je b jf jg jh ji jj jk jl jm lg jo jp jq lh js jt ju li jw jx jy jz hn dt translated">Git会尽一切努力防止历史被意外覆盖，这是一件好事。</p></blockquote><p id="a90f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看Git认为<code class="eh ka kb kc kd b">feature/foo</code>在远程存储库中是什么样子。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/b32e4f70929e1f7c3805fdb2d9a375c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v_6goRTKnPduN6q_x4Vpw.png"/></div></div></figure><p id="5938" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们看看我们告诉Git做什么。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/351da3c79f25277c0dcfe742b2e77871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zndxVsC81_e7okV0aQbVg.png"/></div></div></figure><p id="38e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Git的角度来看，提交<em class="ke"> D </em>和<em class="ke"> F </em>即将丢失。Git会给你一个类似于<code class="eh ka kb kc kd b">Updates were rejected because the tip of your current branch is behind</code>的好消息。</p><p id="79b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会说，“但我可以清楚地看到，在你拍的这张漂亮的照片中，<code class="eh ka kb kc kd b">feature/foo</code>比以前更领先了。”这是一个很好的观察，但是Git只是看到远程存储库上的<code class="eh ka kb kc kd b">feature/foo</code>包含<code class="eh ka kb kc kd b">bc1f36b</code>和<code class="eh ka kb kc kd b">640e713</code>，而您的本地版本的<code class="eh ka kb kc kd b">feature/foo</code>不包含这些提交。所以为了不丢失这些提交，Git会礼貌地拒绝一个普通的<code class="eh ka kb kc kd b">git push</code>，要求您执行一个<code class="eh ka kb kc kd b">git push --force</code>。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="c83f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你从这篇文章中拿走一样东西，记住在它的核心，rebase只是找到在某个分支上进行的提交，并创建具有相同内容的新提交，但是具有新的父提交或基础提交。</p><p id="16a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Git rebase <em class="ke">可以通过利用它的<code class="eh ka kb kc kd b">--interactive</code>模式让</em>做更多的事情，但是这超出了本文的范围。如果你想知道你能用<code class="eh ka kb kc kd b">--interactive</code>模式做什么，我会很快写下来。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="8fcc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢你当时读到的东西👏以示感谢！</p><p id="af8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">跟随<a class="nh ni gr" href="https://medium.com/u/4a8a924edf41?source=post_page-----bca683888dae--------------------------------" rel="noopener" target="_blank"> Hackernoon </a>和<a class="nh ni gr" href="https://medium.com/u/bc152e4dcd63?source=post_page-----bca683888dae--------------------------------" rel="noopener" target="_blank"> Jared Ready </a>获取更多高质量的软件工程内容。</p></div></div>    
</body>
</html>