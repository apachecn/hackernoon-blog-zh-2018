<html>
<head>
<title>Kernel is my friend — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内核是我的朋友—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kernel-is-my-friend-part-1-30a322d057e?source=collection_archive---------8-----------------------#2018-03-01">https://medium.com/hackernoon/kernel-is-my-friend-part-1-30a322d057e?source=collection_archive---------8-----------------------#2018-03-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ec91b11e89a1fb3cb14c50763e178435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKmOV7SYgIsXNV8TEKlbeQ.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/photos/qiNgutAfRpY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Roderico Y. Díaz</a> on <a class="ae ih" href="https://unsplash.com/search/photos/kernel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a> — This reminds me of the times I do `ls /proc` in my terminal.</figcaption></figure><div class=""/><div class=""><h2 id="dca6" class="pw-subtitle-paragraph jh ij ik bd b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ek translated">文件描述符的乐趣</h2></div><p id="6343" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">2018年初，我希望了解一下<a class="ae ih" href="https://hackernoon.com/tagged/linux" rel="noopener ugc nofollow" target="_blank"> Linux </a>和系统<a class="ae ih" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的总体情况。也就是说，和内核做朋友！于是，我开始阅读<a class="ae ih" href="http://man7.org/tlpi/" rel="noopener ugc nofollow" target="_blank">Linux编程接口</a>。这是我在阅读这本书并揭开Linux神秘面纱的过程中所写的系列博文的第一部分。</p><p id="b605" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这篇文章试图理解来自Linux编程接口的课程<a class="ae ih" href="http://man7.org/tlpi/" rel="noopener ugc nofollow" target="_blank">文件I/O:通用I/O模型</a>的某些部分。</p><h2 id="e490" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">文件类型</h2><p id="c89e" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">我听说过“Linux中的一切都是文件”这种说法。但是，我了解到Linux中有不同类型的文件。</p><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><h2 id="110b" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">系统调用</h2><p id="ecf7" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">系统调用是要求内核为我们做一些工作的一种方式。例如，这是帮助在Linux中处理文件的四个基本系统调用</p><ul class=""><li id="c189" class="mb mc ik kb b kc kd kf kg ki md km me kq mf ku mg mh mi mj dt translated">打开——嘿内核，你能为我打开一个文件吗？以便该流程可以对其进行处理。</li><li id="e986" class="mb mc ik kb b kc mk kf ml ki mm km mn kq mo ku mg mh mi mj dt translated">嘿，内核，你能读一下我保存在<code class="eh mp mq mr ms b">~/cool/stuff/is/here.js</code>中的这段神奇的代码吗？</li><li id="a963" class="mb mc ik kb b kc mk kf ml ki mm km mn kq mo ku mg mh mi mj dt translated">写——嘿内核，你能帮我把我很长的作业写到这个文件吗？</li><li id="2fa7" class="mb mc ik kb b kc mk kf ml ki mm km mn kq mo ku mg mh mi mj dt translated">关闭——嘿内核，我做完作业了，请关闭文件。我们会出去逛逛，做些其他有趣的事情。</li></ul><h2 id="8d13" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">文件描述符</h2><p id="ed03" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">文件描述符是一个非负整数，用于引用文件。</p><p id="5024" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当进程调用<code class="eh mp mq mr ms b">open()</code>系统调用时，会返回一个文件描述符，该文件描述符可用于其他系统调用，如读、写、关闭。</p><p id="b716" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我第一次读这一课时，我错过了仔细观察的一件有趣的事情是(这可能是一个重要的关键点)</p><blockquote class="mt"><p id="36ad" class="mu mv ik bd mw mx my mz na nb nc ku ek translated">每个进程都有自己的一组文件描述符</p></blockquote><p id="6668" class="pw-post-body-paragraph jz ka ik kb b kc nd jl ke kf ne jo kh ki nf kk kl km ng ko kp kq nh ks kt ku hn dt translated">让我们试着一步一步地理解这一点。</p><h2 id="2d25" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">一个过程，一个文件</h2><p id="ed97" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">让我们写一个程序，只打开一个文件并打印它的文件描述符值。</p><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="ni ma l"/></div></figure><p id="feef" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我创建了一个二进制文件，并执行它一次读取一个文件。这基本上就是一次从一个进程中读取一个文件。</p><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nj"><img src="../Images/d7d9768e0387eca58959a5b3d1fce591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oWSG_RvSyUf003g_j4Nmw.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">The file always gets the file descriptor value of 3 always</figcaption></figure><h2 id="5f29" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">一个进程，多个文件</h2><p id="0a50" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">现在，让我们试着一次从一个进程中打开多个文件</p><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="ni ma l"/></div></figure><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nk"><img src="../Images/d39fb30b0f52fda239b020aafe6e89ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEfd7Tu_MuJgCyqC_2Gv1g.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">files got allocated with sequential integer values</figcaption></figure><p id="be06" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">文件获取文件描述符编号的方法就是基于这个简单的想法</p><blockquote class="nl nm nn"><p id="f11a" class="jz ka no kb b kc kd jl ke kf kg jo kh np kj kk kl nq kn ko kp nr kr ks kt ku hn dt translated">SUSv3指定如果open()成功，它保证为进程使用编号最小的未使用文件描述符。</p><p id="1961" class="jz ka no kb b kc kd jl ke kf kg jo kh np kj kk kl nq kn ko kp nr kr ks kt ku hn dt translated">迈克尔·克尔风险。Linux编程接口:Linux和UNIX系统编程手册(第73页)。没有淀粉压机。Kindle版。</p></blockquote><h2 id="91ce" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">多个进程，多个文件</h2><p id="2d20" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">这是有趣的部分。如果多个进程同时访问相同的文件，会发生什么情况。那么文件描述符是如何分配的呢？</p><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="ni ma l"/></div></figure><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ns"><img src="../Images/5003d62eb8bd8bb9fff7e475d79d19e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ba3qUr1QOBHMMJ5U69w9DQ.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Numbering is done at a process level</figcaption></figure><p id="2ed3" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这证明了我们开始时的说法，</p><blockquote class="mt"><p id="3809" class="mu mv ik bd mw mx my mz na nb nc ku ek translated">每个进程都有自己的一组文件描述符</p></blockquote><p id="b25e" class="pw-post-body-paragraph jz ka ik kb b kc nd jl ke kf ne jo kh ki nf kk kl km ng ko kp kq nh ks kt ku hn dt translated">进程9012打开<code class="eh mp mq mr ms b">1.js</code>分配fd 3和<code class="eh mp mq mr ms b">2.js</code>分配fd 4。进程9015没有什么不同，它做了同样的事情。因为这些是那些进程中编号最小的未使用文件描述符值。</p><p id="0978" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">既然我们已经走了这么长的路，我脑海中有趣的问题是，如果两个进程试图同时写入打开的文件，会发生什么情况。(我猜，这个大概值得下次再来回答吧！)</p></div><div class="ab cl nt nu hc nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hn ho hp hq hr"><h2 id="ed40" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">标准文件描述符</h2><p id="4f79" class="pw-post-body-paragraph jz ka ik kb b kc lq jl ke kf lr jo kh ki ls kk kl km lt ko kp kq lu ks kt ku hn dt translated">我已经听说过这些名字，令我惊讶的是，它们只是文件描述符。</p><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="a9e5" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当创建一个进程时，它似乎会自动打开stdin、stdout和stderr文件，并分别分配fd编号0、1、2。</p><p id="f72d" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我进一步尝试查看这些文件在哪里。但我最终得到了一些我还不知道的东西。(厉害了！我们有事情要考虑)</p><figure class="lv lw lx ly fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff oa"><img src="../Images/8bcb12eb097850433554bf8b5112d39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVuquAhjz3W3AtwMTQF0dg.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">character special? ¯\_(ツ)_/¯</figcaption></figure></div><div class="ab cl nt nu hc nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hn ho hp hq hr"><h2 id="396c" class="kv kw ik bd kx ky kz la lb lc ld le lf ki lg lh li km lj lk ll kq lm ln lo lp dt translated">神秘的事物</h2><ul class=""><li id="56af" class="mb mc ik kb b kc lq kf lr ki ob km oc kq od ku mg mh mi mj dt translated">如果两个进程试图同时读取一个打开的文件会发生什么？</li><li id="6048" class="mb mc ik kb b kc mk kf ml ki mm km mn kq mo ku mg mh mi mj dt translated">如果两个进程试图同时写入一个打开的文件会发生什么？</li><li id="7713" class="mb mc ik kb b kc mk kf ml ki mm km mn kq mo ku mg mh mi mj dt translated">什么是<code class="eh mp mq mr ms b">/dev/pts/0</code>？</li><li id="f4d1" class="mb mc ik kb b kc mk kf ml ki mm km mn kq mo ku mg mh mi mj dt translated">什么是文件类型“特殊字符”？</li></ul><p id="7f56" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">(如果你有机会解决这些问题，请发表评论)</p></div><div class="ab cl nt nu hc nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hn ho hp hq hr"><p id="7bbd" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢阅读。我在博客文章的结尾引用了我最喜欢的泰米尔文学作品《Tirukkuṛaḷ》中的诗句。</p><blockquote class="mt"><p id="409b" class="mu mv ik bd mw mx my mz na nb nc ku ek">செய்தக்க அல்ல செயக்கெடும் செய்தக்க</p><p id="8ef9" class="mu mv ik bd mw mx my mz na nb nc ku ek">செய்யாமை யானும் கெடும்.</p><p id="e13d" class="mu mv ik bd mw mx my mz na nb nc ku ek translated"><em class="oe"> — திருக்குறள் </em></p></blockquote><p id="0ebb" class="pw-post-body-paragraph jz ka ik kb b kc nd jl ke kf ne jo kh ki nf kk kl km ng ko kp kq nh ks kt ku hn dt translated">翻译过来的意思(用我的话来说):做了不该做的事的人会出问题，不做该做的事的人也会出问题。</p><figure class="lv lw lx ly fq hw"><div class="bz el l di"><div class="of ma l"/></div></figure></div></div>    
</body>
</html>