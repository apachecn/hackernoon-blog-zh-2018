<html>
<head>
<title>Structuring projects and naming components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中构建项目和命名组件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/structuring-projects-and-naming-components-in-react-1261b6e18d76?source=collection_archive---------0-----------------------#2018-03-02">https://medium.com/hackernoon/structuring-projects-and-naming-components-in-react-1261b6e18d76?source=collection_archive---------0-----------------------#2018-03-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/bea8c27051414e063977e975e34d09a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnfoUx35p_wHEv-cVGcV3Q.png"/></div></div></figure><div class=""/><p id="ff23" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为<em class="ka"> React </em>只是一个库，它并没有规定你应该如何组织和构建你的项目。这很好，因为它让我们可以自由地尝试不同的方法，并调整更适合我们的方法。另一方面，这可能会给刚开始在<em class="ka"> React </em>世界工作的开发者带来一些困惑。</p><p id="66a9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将展示一些我已经使用了一段时间并且已经很好地扩展的方法。这些方法并没有再造轮子，它们只是把我们在市场上的东西放在一起并加以改进。</p><blockquote class="kb kc kd"><p id="f5e1" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">记住:这里没有什么是一成不变的！你可以只采取你认为有意义的方法，并根据你的情况进行调整/改变。</p></blockquote><h1 id="f6d9" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">文件夹结构</h1><p id="12c2" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">我经常看到的一个问题是关于如何组织文件和文件夹。在这篇文章中，我们认为你有一个最小的结构，就像用<code class="eh lk ll lm ln b">create-react-app</code>创建的一样。</p><p id="5111" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lk ll lm ln b">create-react-app</code>为我们生成一个基本项目，在其根中包含文件:<em class="ka">。gitignore </em>，<em class="ka"> package.json </em>，<em class="ka"> README.md </em>，<em class="ka"> yarn.lock </em></p><p id="edb8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它还生成文件夹:<code class="eh lk ll lm ln b">public</code>和<code class="eh lk ll lm ln b">src</code>。最后一个是我们保存源代码的地方。</p><p id="16a0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看下面的图片，具有所描述的结构:</p><figure class="lp lq lr ls fq hw fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/2e085c88592f08bf9446c4954938228a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*eXN1LlNnuZmosJ7n7EsJ-Q.png"/></div></figure><p id="6a79" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本帖中，我们将重点关注<code class="eh lk ll lm ln b">src</code>文件夹。除此之外的一切都将保持完整。</p><h1 id="0ab6" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">容器和组件</h1><p id="9c5a" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">您可能已经在某个项目的根文件夹中看到了<em class="ka">容器</em>和<em class="ka">表示组件</em>之间的分离。我的意思是，在<code class="eh lk ll lm ln b">src</code>里面，你有一个名为<code class="eh lk ll lm ln b">components</code>的文件夹和另一个名为<code class="eh lk ll lm ln b">containers</code>的文件夹:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="7d7d" class="lx ki if ln b fv ly lz l ma mb">src<br/>├─ components<!-- --> <br/>└─ containers</span></pre><p id="321f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，这种方法存在一些问题，如下所示:</p><ul class=""><li id="3677" class="mc md if je b jf jg jj jk jn me jr mf jv mg jz mh mi mj mk dt translated"><strong class="je ig">主观规则</strong>——你没有关于什么是<em class="ka">容器</em>和什么是<em class="ka">表示组件</em>的明确规则。彼此之间的差异可能是主观的，当你在一个团队中时，很难让所有的开发人员都同意并平等地判断这件事。</li><li id="113f" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated"><strong class="je ig">它没有考虑组件的动态性</strong> -即使你决定一个组件适合某个特定的类型，也很容易在项目生命周期中改变它，变成另一种类型，迫使你将它从<code class="eh lk ll lm ln b">components</code>移动到<code class="eh lk ll lm ln b">containers</code>文件夹，反之亦然。</li><li id="9d8c" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated"><strong class="je ig">允许两个组件有相同的名字</strong>——组件在应用程序中应该有声明性的和唯一的名字，以避免混淆每个组件的职责。然而，上面的方法打开了一个缺口，让两个组件同名，一个是<em class="ka">容器</em>，另一个是<em class="ka">表示。</em></li><li id="ca5d" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated"><strong class="je ig">生产力损失- </strong>您必须不断地在容器和组件文件夹之间导航，即使是在单个特征中工作。因为通常一个特性包含两种类型的组件。</li></ul><p id="95d7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法还有一种变体，它保持这种分离，但是在模块内部。</p><p id="2027" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设在您的应用程序中，有一个模块用户。在其中，您将有两个文件夹来分隔您的组件:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="097c" class="lx ki if ln b fv ly lz l ma mb">src<br/>└─ User<br/>  ├─ components<br/>  └─ containers</span></pre><p id="bfd3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的方法，最小化了在项目树中遥远的文件夹之间导航的问题。然而，它增加了许多噪音。根据您的应用程序有多少模块，您最终会有几十个<code class="eh lk ll lm ln b">containers</code>和<code class="eh lk ll lm ln b">components</code>文件夹。</p><p id="70a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于这些原因，当我们谈论组织文件夹和文件时，按照<em class="ka">表示</em>和<em class="ka">容器的概念来划分我们的组件是不相关的。</em>那个<em class="ka"> </em>说<em class="ka">，</em>我们要把我们所有的组件都保留在<code class="eh lk ll lm ln b">components</code>文件夹里面，除了<em class="ka">屏幕</em>。</p><blockquote class="kb kc kd"><p id="6753" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">即使在文件夹中把它们分开是无关紧要的，了解它们之间的概念差异也是很重要的。如果您对这个主题还有疑问，我建议您阅读文章:<a class="ae mq" rel="noopener" href="/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">表示和容器组件。</a></p></blockquote><h1 id="3982" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">分离和分组代码</h1><p id="fa72" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">在<code class="eh lk ll lm ln b">components</code>文件夹中，我们按照模块/特性对文件进行分组。</p><p id="3dc0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在一个<a class="ae mq" href="https://pt.wikipedia.org/wiki/CRUD" rel="noopener ugc nofollow" target="_blank"><em class="ka">CRUD</em></a><em class="ka"/>的用户中，我们就只有这个模块用户了。因此，我们的结构如下:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="10f9" class="lx ki if ln b fv ly lz l ma mb">src<br/>└─ components<br/>  └─ User<br/>    <!-- -->├─ Form.jsx<br/>    └─ List.jsx</span></pre><p id="25df" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当一个组件由多个文件组成时，我们将这个组件及其文件放在一个同名的文件夹中。例如:假设你有一个<em class="ka"> Form.css </em>包含<em class="ka"> Form.jsx的样式。</em>在这种情况下，你的结构应该是这样的:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="2164" class="lx ki if ln b fv ly lz l ma mb">src<br/>└─ components<br/>  └─ User<br/>    ├─ Form<br/>    │ ├─ Form.jsx<br/>    │<!-- --> <!-- -->└─ Form.css<br/>    └─ List.jsx</span></pre><blockquote class="kb kc kd"><p id="ca36" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">测试文件与被测试的文件在一起。在上面的例子中，<strong class="je ig"> Form.jsx </strong>的测试将会留在同一个文件夹中，并被命名为<strong class="je ig"> Form.spec.jsx </strong></p></blockquote><h2 id="f33a" class="lx ki if bd kj mr ms mt kn mu mv mw kr jn mx my kv jr mz na kz jv nb nc ld nd dt translated">UI组件</h2><p id="2452" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">除了通过模块分离组件之外，我们还在<code class="eh lk ll lm ln b">src/components</code>中包含了一个<code class="eh lk ll lm ln b">UI</code>文件夹，用来保存我们所有的通用组件。</p><p id="8f46" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">UI组件是足够通用的组件，不属于一个模块。它们是可以保存在开源库中的组件，因为它们没有来自特定应用程序的任何业务逻辑。这些组件的例子有:按钮、输入、复选框、选择、模态、数据显示元素等</p><h1 id="03b2" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">命名组件</h1><p id="3c43" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">上面我们看到了如何构建文件夹，以及如何通过模块来分离组件。然而，还有一个问题:如何给它们命名？</p><blockquote class="kb kc kd"><p id="7be8" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">当我们谈论给组件命名时，它是关于我们给定义组件的<strong class="je ig">类</strong>或<strong class="je ig">常量</strong>的名称:</p><p id="6aea" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">类<strong class="je ig"> MyComponent </strong>扩展组件{<br/>}<br/>const<strong class="je ig">my Component</strong>()=&gt;{ }；</p></blockquote><p id="6e35" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如前所述，我们给组件起的名字在应用程序中应该是清晰和唯一的，以便更容易找到它们并避免可能的混淆。</p><p id="d060" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们需要使用像<em class="ka"> React Dev Tools </em>这样的工具进行调试时，以及当应用程序中出现运行时错误时，组件的名称非常方便。错误总是伴随着发生错误的组件名。</p><p id="e0aa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了给组件命名，我们遵循模式<em class="ka">基于路径的组件命名，</em>这包括根据组件到文件夹<code class="eh lk ll lm ln b">components</code>或<code class="eh lk ll lm ln b">src</code>的相对路径来命名组件，如果你在<code class="eh lk ll lm ln b">components</code>文件夹之外。基本上，位于<code class="eh lk ll lm ln b">components/User/List.jsx</code>的组件将被命名为<code class="eh lk ll lm ln b">UserList</code>。</p><p id="ef52" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当文件在同名文件夹中时，我们不需要重复名称。也就是说，<code class="eh lk ll lm ln b">components/User/Form/Form.jsx</code>将被命名为<code class="eh lk ll lm ln b">UserForm</code>而不是<code class="eh lk ll lm ln b">UserFormForm</code>。</p><p id="5075" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的模式有一些好处，我们可以在下面看到:</p><h2 id="5387" class="lx ki if bd kj mr ms mt kn mu mv mw kr jn mx my kv jr mz na kz jv nb nc ld nd dt translated">便于在项目中搜索文件</h2><p id="86c7" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">如果您的编辑器支持模糊搜索，只需搜索名称<code class="eh lk ll lm ln b">UserForm</code>就能找到正确的文件:</p><figure class="lp lq lr ls fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ne"><img src="../Images/1bdfd4909be0244530d7cc7d4cd8c82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZO9Ci9a_lrfi2yTP9OiMA.png"/></div></div></figure><p id="f776" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想在文件夹树中搜索文件，你可以很容易地通过组件名找到它:</p><figure class="lp lq lr ls fq hw fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/790dd7d76af52a1196cc7ba30af48a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*DLndSrnMgIklk7tAhzgMWg.png"/></div></figure><h2 id="8d49" class="lx ki if bd kj mr ms mt kn mu mv mw kr jn mx my kv jr mz na kz jv nb nc ld nd dt translated">避免在导入中重复名称</h2><p id="c4bb" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">按照这个模式，您将总是根据其上下文来命名<strong class="je ig">文件</strong>。考虑到上面的<strong class="je ig">表单</strong>，我们知道它是一个<strong class="je ig">用户表单</strong>，但是由于我们已经在<strong class="je ig">用户</strong>文件夹中，我们不需要在组件<strong class="je ig">文件</strong>名称中重复那个单词。所以，我们只将其命名为<strong class="je ig"> Form.jsx </strong></p><p id="fb10" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我开始使用<em class="ka"> React </em>时，我习惯于将全名放在文件中。然而，这使你重复一个名字很多次，输入路径变得太大。看看这两种方法之间的区别:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="abed" class="lx ki if ln b fv ly lz l ma mb">import <strong class="ln ig">ScreensUserForm</strong> from '<strong class="ln ig">./screens/User/UserForm</strong>';<br/>// vs<br/>import <strong class="ln ig">ScreensUserForm</strong> from '<strong class="ln ig">./screens/User/Form</strong>';</span></pre><p id="58fa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，你看不到一种方法对另一种方法的优势。但是随着应用程序的增长，可能会看到不同之处。看一下下面的例子，考虑我工作的项目中的一个组件:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="357a" class="lx ki if ln b fv ly lz l ma mb">import MediaPlanViewChannel from '/MediaPlan/MediaPlanView/MediaPlanViewChannel.jsx';</span><span id="5ba0" class="lx ki if ln b fv nf lz l ma mb">// vs</span><span id="c7dc" class="lx ki if ln b fv nf lz l ma mb">import MediaPlanViewChannel from './MediaPlan/View/Channel';</span></pre><p id="14ff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在想象一下，在一个文件中，这个值被乘以5或10倍。</p><p id="6415" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们总是根据文件的上下文来命名文件，根据组件相对于<code class="eh lk ll lm ln b">components</code>或<code class="eh lk ll lm ln b">src</code>文件夹的位置来命名组件。</p><h1 id="fbe7" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">屏幕</h1><p id="b47f" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">顾名思义，屏幕就是应用程序中的屏幕。</p><p id="9615" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在用户的一个<em class="ka"> CRUD </em>中，我们会有一个用户列表的屏幕，一个创建新用户的屏幕和一个编辑现有用户的屏幕。</p><p id="febe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在屏幕上，您可以使用组件来编写应用程序的页面。理想情况下，屏幕不包含任何逻辑，而是一个功能组件。</p><p id="87a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将屏幕保存在<code class="eh lk ll lm ln b">src</code>根目录下的独立文件夹中，因为它们将根据路线定义而不是模块进行分组:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="91af" class="lx ki if ln b fv ly lz l ma mb">src<br/>├─ components<!-- --> <br/>└─ screens<br/>  └─ User<br/>    ├─ Form.jsx<br/>    └─ List.jsx</span></pre><p id="4a12" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到项目使用的是<em class="ka"> react-router </em>，我们将文件<em class="ka"> Root.jsx </em>保存在<code class="eh lk ll lm ln b">screens</code>文件夹中，我们在其中定义了所有的应用路由。</p><p id="224a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka"> Root.jsx </em>的代码类似于:</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="9852" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们将所有屏幕放在一个文件夹中，该文件夹具有相同的路线名称，<code class="eh lk ll lm ln b">user/ -&gt; User/</code>。尝试为每个父路由保留一个文件夹，并在其中分组子路由。在本例中，我们创建了文件夹<code class="eh lk ll lm ln b">User</code>，并在其中保存了屏幕列表和屏幕表单。这种模式将帮助您通过查看url轻松找到每条路线在哪个屏幕上显示。</p><p id="a5cd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">单个屏幕可以用来呈现两个不同的路线，就像我们在上面创建和编辑用户的路线一样。</p><p id="d61d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能会注意到，所有组件的名称中都包含Screen作为前缀。当组件位于<code class="eh lk ll lm ln b">components</code>文件夹之外时，我们应该根据它到<code class="eh lk ll lm ln b">src</code>文件夹的相对路径来命名它。位于<code class="eh lk ll lm ln b">src/screens/User/List.jsx</code>的组件应该命名为<code class="eh lk ll lm ln b">ScreensUserList</code>。</p><p id="9057" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<em class="ka"> Root.jsx </em>的创建，我们的结构如下:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="729a" class="lx ki if ln b fv ly lz l ma mb">src<br/>├─ components<!-- --> <br/>└─ screens<br/>  ├─ User<br/>  │ ├─ Form.jsx<br/>  │ └─ List.jsx<br/>  └─ <!-- -->Root.jsx</span></pre><blockquote class="kb kc kd"><p id="4e43" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">不要忘记在index.js内部导入Root.jsx，使之成为应用程序根组件。</p></blockquote><p id="1e19" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您对屏幕应该是什么样子还有疑问，请看下面的例子，用户表单的屏幕应该是什么样子。</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="ng nh l"/></div></figure><p id="f7d6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们的应用程序应该是这样的结构:</p><pre class="lp lq lr ls fq lt ln lu lv aw lw dt"><span id="ae84" class="lx ki if ln b fv ly lz l ma mb">src<br/>├─ components<!-- --> <br/>│  ├─ User<br/>│  │ ├─ Form<br/>│  │ │ ├─ Form.jsx<br/>│  │ │<!-- --> <!-- -->└─ Form.css<br/>│  │ └─ List.jsx<br/>│<!-- -->  <!-- -->└─ UI<!-- --> <br/>│<br/>└─ screens<br/>  ├─ User<br/>  │ ├─ Form.jsx<br/>  │ └─ List.jsx<br/>  └─ <!-- -->Root.jsx</span></pre><h1 id="0e27" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">概括</h1><ul class=""><li id="7c38" class="mc md if je b jf lf jj lg jn ni jr nj jv nk jz mh mi mj mk dt translated"><strong class="je ig">表象</strong>和<strong class="je ig">集装箱</strong>组件存放在<code class="eh lk ll lm ln b">src/<strong class="je ig">components</strong></code></li><li id="1252" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">按<strong class="je ig">模块/特征对组件进行分组。</strong></li><li id="c27a" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">将通用组件保留在内部<code class="eh lk ll lm ln b">src/<strong class="je ig">components</strong>/<strong class="je ig">UI</strong></code></li><li id="3e68" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">保持<strong class="je ig">屏幕</strong>简单，结构和代码最少。</li><li id="c2c4" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">根据路线定义对屏幕进行分组。对于路线<code class="eh lk ll lm ln b">/user/list</code>，我们将有一个位于<code class="eh lk ll lm ln b">/src/screens/User/List.jsx</code>的屏幕。</li><li id="229f" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">组件根据其相对于<code class="eh lk ll lm ln b">components</code>或<code class="eh lk ll lm ln b">src</code>的路径命名。鉴于此，位于<code class="eh lk ll lm ln b">src/components/User/List.jsx</code>的组件将被命名为<code class="eh lk ll lm ln b">UserList</code>。位于<code class="eh lk ll lm ln b">src/screens/User/List</code>的组件将被命名为<code class="eh lk ll lm ln b">ScreensUserList</code>。</li><li id="6857" class="mc md if je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">同名文件夹中的组件，不要在组件中重复名称。考虑到这一点，位于<code class="eh lk ll lm ln b">src/components/User/List/List.jsx</code>的部件将被命名为<code class="eh lk ll lm ln b">UserList</code>并且<strong class="je ig">而不是</strong>被命名为<code class="eh lk ll lm ln b">UserListList</code>。</li></ul><h1 id="ff8f" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">结论</h1><p id="7b8e" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">上面的提示只涵盖了项目的组织和结构的一部分。我试着只保留关于<em class="ka">反应</em>的内容，把<em class="ka">重复</em>留给以后的帖子。</p><p id="1803" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你呢？你有什么方法可以和我们分享吗？写一个答案在下面，我很想看！</p><p id="1a5b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你喜欢这本书吗？给我们一个喜欢和sharing️️️️ ❤️️，帮助我们传播这个词</p></div><div class="ab cl nl nm hc nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hn ho hp hq hr"><p id="5c29" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要忘记关注我，以接收关于未来帖子的通知！</p><figure class="lp lq lr ls fq hw"><div class="bz el l di"><div class="ns nh l"/></div></figure></div></div>    
</body>
</html>