<html>
<head>
<title>Creating WebAssembly-powered library for modern web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为现代web创建基于WebAssembly的库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-webassembly-powered-library-for-modern-web-846da334f8fc?source=collection_archive---------0-----------------------#2018-03-03">https://medium.com/hackernoon/creating-webassembly-powered-library-for-modern-web-846da334f8fc?source=collection_archive---------0-----------------------#2018-03-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2dde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">这篇文章讲述了我在创建</em> <a class="ae jq" href="https://github.com/Kagami/vmsg" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> vmsg库</em> </a> <em class="jp">时，第一次使用WebAssembly的实践经验和一些有用的技巧。</em></p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="8ab2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近我有一些空闲时间，所以我决定尝试新的WebAssembly标准，并用它实现简单但有用的库。</p><p id="9c36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如<a class="ae jq" href="http://webassembly.org/docs/high-level-goals/" rel="noopener ugc nofollow" target="_blank"> WebAssembly文档</a>中所述，主要目标之一是创建可以快速解析并具有紧凑代码表示的格式。所以我真的很好奇如何利用这一主要优势。我过去有过使用asm.js的经验，做过相当复杂的C软件的移植，比如FFmpeg和视频/音频编码器。构建规模非常糟糕——大约15兆字节的ffmpeg CLI精简版JavaScript，几乎没有基本的过滤器和编码器。鉴于代码解析是计算量很大的操作，尤其是在移动设备上，它看起来不太实用，更像是针对概念验证的小演示:<a class="ae jq" href="https://kagami.github.io/webm.js/" rel="noopener ugc nofollow" target="_blank"> webm.js </a>，<a class="ae jq" href="https://paulkinlan.github.io/deviceframe.es/" rel="noopener ugc nofollow" target="_blank"> deviceframe.es </a>。</p><p id="060b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，WebAssembly二进制文件可以在它通过网络时被解析和编译，这使得它成为用C编写的库的完美构建目标，您需要在网页中使用这些库。</p><p id="7e48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图书馆的想法来得很快:我在网络论坛上花了很多时间，通过短信和图像讨论各种事情。最近，随着HTML5视频和WebM/VPx格式的兴起，在帖子上附上小视频变得非常普遍，这进一步增加了自我表达的可能性。声音呢？如果你可以直接说出你的信息，并作为帖子的一部分发送出去，会怎么样？听起来很棒，我们试试吧！</p><h2 id="7914" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">决定高层架构</h2><p id="a184" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">因此，首先我们需要从麦克风获取音频样本，然后对其进行编码，然后将文件返回给库用户。看起来很简单。</p><p id="0a83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2018年<a class="ae jq" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" rel="noopener ugc nofollow" target="_blank">网络音频API </a>被广泛支持，这里没有真正的麻烦。<a class="ae jq" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia" rel="noopener ugc nofollow" target="_blank"> getUserMedia </a>结合<a class="ae jq" href="https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode" rel="noopener ugc nofollow" target="_blank"> ScriptProcessorNode </a>能够完成第一步，WebAssembly模块将负责第二步。因为<code class="eh lg lh li lj b">ScriptProcessor</code>节点的<code class="eh lg lh li lj b">onaudioprocess</code>回调是在主线程中执行的，也为了保持网页界面的响应性，WebAssembly模块将在Web Worker中实例化，通过消息与主线程通信。</p><blockquote class="lk ll lm"><p id="ab01" class="ir is jp it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated">旁注:<code class="eh lg lh li lj b">ScriptProcessNode</code>已经被弃用，很快将被<a class="ae jq" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API#Audio_processing_in_JavaScript" rel="noopener ugc nofollow" target="_blank">音频工作者</a>取代，但它目前只在Chrome 64+中实现，为了兼容，我们在不久的将来无论如何都要使用旧的API。此外，由于我们在worker中处理样本，不将它们输出到扬声器，并且可以使用大的缓冲区，因此在我们的特定情况下不需要Worklet。<code class="eh lg lh li lj b">ScriptProcessNode</code>应该工作得很好，它所需要做的就是将样本发送到Web Worker，这是一个非常快速和轻量级的操作。</p></blockquote><p id="f291" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还将创建一个简单的界面，要求允许使用麦克风，并显示带有开始/停止/关闭按钮的记录表单。下面您可以看到该库组件的示意图:</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lq"><img src="../Images/38b4e32fbeeebba008dbdaddc41af8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8H6LbK62f--kOOIICGMs4w.png"/></div></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Library architecture</figcaption></figure><h2 id="211e" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">选择格式</h2><p id="473c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">现在我们需要决定将接收到的样本编码成哪种音频格式。先决条件:它应该在所有支持WebAssembly的浏览器中工作，它应该提供合理的压缩，它应该在所有平台上广泛使用。</p><p id="c2ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最初的愿望是抓住Opus，因为它是最好的语音压缩工具。不幸的是，Safari和Edge中的<code class="eh lg lh li lj b">&lt;audio&gt;</code>元素不支持它。当然有各种各样的解决方法。例如，在Edge中，你可以手动获取Opus文件，并通过<a class="ae jq" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaSource" rel="noopener ugc nofollow" target="_blank"> MediaSource API </a>播放。似乎也有可能<a class="ae jq" href="https://wpdev.uservoice.com/forums/257854/suggestions/6513488" rel="noopener ugc nofollow" target="_blank">安装网络媒体扩展</a>包来获得全面支持。在Safari中，你可以使用移植到JavaScript的Opus解码器，比如<a class="ae jq" href="https://github.com/brion/ogv.js" rel="noopener ugc nofollow" target="_blank"> ogv.js </a>。</p><p id="2089" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管这是可能的，但在我看来这太不切实际了。可以这样说:“如果你想支持语音消息，请将这个库添加到你的项目中”。但是现在，您可以指定使用哪个播放器来收听结果音频，或者需要一些重要的代码来处理回放。我不喜欢它，所以我不得不放弃Opus。也许几年后，选择会容易得多。</p><blockquote class="lk ll lm"><p id="82e4" class="ir is jp it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated">旁注:Chrome和Firefox支持<a class="ae jq" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API" rel="noopener ugc nofollow" target="_blank"> MediaStream录制API </a>，并且可以使用Opus编解码器对<code class="eh lg lh li lj b">MediaStream</code>数据进行编码。虽然在Safari和Edge中没有，但我真的想让我的库在所有4个版本中工作，所以在这里没有运气了。</p></blockquote><p id="f55d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一个，所有浏览器都有WAV/PCM格式。从原始样本创建WAV文件是一个非常简单的过程，已经有了用于此的<a class="ae jq" href="https://github.com/mattdiamond/Recorderjs" rel="noopener ugc nofollow" target="_blank">库</a>。不过它有一个小小的缺点:根本没有压缩。因此，无论你是在麦克风里唱一些美妙的歌曲，还是保持沉默，30秒的录音(48 khz/单声道)总会正好重2.7兆字节。这太浪费了。</p><p id="7f28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">MP3呢？它在任何地方都受支持，有体面的压缩和伟大的<a class="ae jq" href="http://lame.sourceforge.net" rel="noopener ugc nofollow" target="_blank">蹩脚的编码器</a>。历史上，自由/开源软件项目因为软件专利而放弃使用它，但是所有的专利都在去年到期了。看来我们有赢家了。</p><p id="3625" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有AAC和Vorbis但是都不合适。以前的<a class="ae jq" href="https://en.wikipedia.org/wiki/Advanced_Audio_Coding#Licensing_and_patents" rel="noopener ugc nofollow" target="_blank">禁止以二进制形式</a>发布编解码器实现，而我们的WebAssembly模块将有效地发布。(同样值得怀疑的是，免费实现是否和专有实现一样好。)后者不适合语音压缩。</p><h2 id="a5ce" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">收集</h2><p id="e336" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">所以我们需要抓取LAME encoder，编译成WebAssembly模块，并使得从JavaScript使用它成为可能。</p><p id="903b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多LAME的asm.js端口，甚至可能是WASM端口，但我决定从头开始创建一个新的，以便专注于构建大小优化。</p><p id="bddb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">起初我<a class="ae jq" href="https://github.com/Kagami/lame-svn" rel="noopener ugc nofollow" target="_blank">用git-svn镜像了SVN回购协议</a>，因为<a class="ae jq" href="https://github.com/rbrito/deprecated-lame-mirror" rel="noopener ugc nofollow" target="_blank">之前的半官方镜像</a>由于某种原因被弃用，并且不包含最新的3.100版本，这可能会有一些有用的错误修复。</p><p id="af2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于编译，我们使用事实上的标准<a class="ae jq" href="http://webassembly.org/getting-started/developers-guide/" rel="noopener ugc nofollow" target="_blank"> Emscripten工具链</a>，这里没有什么新东西。它已经被积极开发了很多年，旨在将C/C++库移植到web上，这正是我们所需要的。我就不赘述了，你可以在<a class="ae jq" href="https://kripken.github.io/emscripten-site/" rel="noopener ugc nofollow" target="_blank">官网</a>了解更多关于Emscripten的内容。</p><p id="5ad6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Emscripten的asm.js编译器由名为fastcomp的LLVM后端提供支持。对于WebAssembly你有两个选择:首先编译成asm.js，然后用<a class="ae jq" href="https://github.com/WebAssembly/binaryen" rel="noopener ugc nofollow" target="_blank"> Binaryen </a>翻译成WASM。或者使用LLVM的in-tree WebAssembly后端，它能够自己生成WebAssembly二进制文件(差不多，最后一步还需要使用Binaryen)。我选择了第二个，因为在不久的将来，它似乎是首选。此外，Emscripten最近支持<a class="ae jq" href="https://github.com/kripken/emscripten/pull/6056" rel="noopener ugc nofollow" target="_blank">标准LLVM链接器</a>，这也将很快成为首选。</p><blockquote class="lk ll lm"><p id="edaf" class="ir is jp it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated">旁注:我不打算描述用WASM后端编译LLVM的过程。一般建议使用最新的SVN版本。你可以看看<a class="ae jq" href="https://gist.github.com/yurydelendik/4eeff8248aeb14ce763e" rel="noopener ugc nofollow" target="_blank">这个要领</a>为起点。通过提供<code class="eh lg lh li lj b">--enable-wasm</code>标志，也可以用emsdk编译WASM后端，但是它使用非常旧的LLVM(fastcomp补丁的基础),所以结果模块可能比SVN LLVM更大/更慢。它也不构建LLD。</p></blockquote><p id="5279" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们创建我们图书馆的存根。我将使用Linux shell命令，YMMV。</p><pre class="lr ls lt lu fq mg lj mh mi aw mj dt"><span id="8f53" class="jy jz hu lj b fv mk ml l mm mn">$ cd ~<br/>$ git init vmsg &amp;&amp; cd vmsg<br/>$ npm init -y</span></pre><p id="e620" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要LAME编码器的源代码，git子模块非常方便:</p><pre class="lr ls lt lu fq mg lj mh mi aw mj dt"><span id="0a67" class="jy jz hu lj b fv mk ml l mm mn">$ git submodule add https://github.com/Kagami/lame-svn.git<br/>$ cd lame-svn &amp;&amp; git checkout RELEASE__3_100 &amp;&amp; cd ..</span></pre><p id="3d27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止一切顺利。我们来编译一下<code class="eh lg lh li lj b">libmp3lame.so</code>(共享的LAME库)，这样以后就可以从WebAssembly模块调用它的函数了。我使用GNU Makefile，尽管像webpack和parcel这样的现代构建器正在获得对WASM的支持，因为它还不成熟，我想尝试编译器标志和其他优化。建筑商只会在这里碍手碍脚。</p><p id="8a21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用以下文本创建<code class="eh lg lh li lj b">Makefile</code>(确保使用制表符缩进):</p><pre class="lr ls lt lu fq mg lj mh mi aw mj dt"><span id="8364" class="jy jz hu lj b fv mk ml l mm mn">export EMCC_WASM_BACKEND = 1<br/>export EMCC_EXPERIMENTAL_USE_LLD = 1<br/><br/>lame-svn/lame/dist/lib/libmp3lame.so:<br/>	cd lame-svn/lame &amp;&amp; \<br/>	git reset --hard &amp;&amp; \<br/>	patch -p2 &lt; ../../lame-svn.patch &amp;&amp; \<br/>	emconfigure ./configure \<br/>		CFLAGS="-DNDEBUG -Oz" \<br/>		--prefix="$$(pwd)/dist" \<br/>		--host=x86-none-linux \<br/>		--disable-static \<br/>		\<br/>		--disable-gtktest \<br/>		--disable-analyzer-hooks \<br/>		--disable-decoder \<br/>		--disable-frontend \<br/>		&amp;&amp; \<br/>	emmake make -j8 &amp;&amp; \<br/>	emmake make install</span></pre><p id="675a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我告诉Emscripten使用WASM后端和LLD，启用高级收缩大小优化，禁用断言，并在LAME中禁用一些我们不需要的额外内容。<a class="ae jq" href="https://github.com/Kagami/vmsg/blob/v0.2.0/lame-svn.patch" rel="noopener ugc nofollow" target="_blank">补丁</a>修复了配置脚本中的strtol检查，并禁用了默认的LAME's reporters以缩小构建规模(否则Emscripten将包括<code class="eh lg lh li lj b">printf</code>函数和其他东西的实现)。</p><pre class="lr ls lt lu fq mg lj mh mi aw mj dt"><span id="114d" class="jy jz hu lj b fv mk ml l mm mn">$ source /path/to/emsdk/emsdk_env.sh<br/>$ make</span></pre><p id="bb65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将激活Emscripten环境并在<code class="eh lg lh li lj b">lame-svn/lame/dist/lib/</code>目录下创建LAME库。</p><p id="06fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要在WebAssembly模块中使用LAME库函数，并导出MP3创建例程，以便可以从JavaScript调用它们。这里就不多赘述了，大家可以查看一下结果<a class="ae jq" href="https://github.com/Kagami/vmsg/blob/v0.2.0/vmsg.c" rel="noopener ugc nofollow" target="_blank"> vmsg.c </a>。它有4个方法:<em class="jp"> init </em>，<em class="jp"> encode </em>，<em class="jp"> flush </em>和<em class="jp"> free </em>，这些方法都是自描述的，调用内部一个或几个相应的LAME函数。为了与JavaScript来回通信，使用了简单的<code class="eh lg lh li lj b">vmsg</code>结构来存储当前的编码状态。也可以并行编码多个文件，因为我们没有全局变量。</p><p id="ac6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们最后编译我们的WebAssembly模块。将此添加到<code class="eh lg lh li lj b">Makefile</code>:</p><pre class="lr ls lt lu fq mg lj mh mi aw mj dt"><span id="e06d" class="jy jz hu lj b fv mk ml l mm mn">vmsg.wasm: lame-svn/lame/dist/lib/libmp3lame.so vmsg.c<br/>	emcc $^ \<br/>		-DNDEBUG -Oz --llvm-lto 3 \<br/>		-Ilame-svn/lame/dist/include \<br/>		-s WASM=1 \<br/>		-s "EXPORTED_FUNCTIONS=['_vmsg_init','_vmsg_encode','_vmsg_flush','_vmsg_free']" \<br/>		-o _vmsg.js<br/>	cp _vmsg.wasm $@</span></pre><p id="09be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里没有什么真正令人困惑的，我们要求Emscripten编译我们的C包装器，将它与LAME共享库结合，并导出我们在JavaScript端需要的函数。</p><p id="dca8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">键入<code class="eh lg lh li lj b">make vmsg.wasm</code>就这样。我们已经将全功能的MP3编码器移植到网络上，重量只有70kb左右:</p><pre class="lr ls lt lu fq mg lj mh mi aw mj dt"><span id="035f" class="jy jz hu lj b fv mk ml l mm mn">$ wc -c &lt; vmsg.wasm<br/>152799<br/>$ gzip -6 -c vmsg.wasm | wc -c<br/>74152</span></pre><p id="b2f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，就解析复杂性而言，70kb的gzipped WebAssembly甚至与70kb的gzipped JavaScript不相上下。这就像一个小图像:WASM模块将被编译，并准备好使用后，它已经被下载。也许可以进一步缩小模块的尺寸，但是现在我对这个数字很满意。</p><h2 id="3c42" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">运行时间</h2><p id="6b60" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">用于加载和调用WebAssembly模块的JavaScript API 非常简单。这里棘手的部分是提供模块在web平台上正确操作所需的函数。WebAssembly规范没有像C语言那样定义任何负责内存分配、数学运算、输入/输出API等的标准库。而LAME没有其中一些是不行的。Emscripten在WASM端使用打了补丁的轻量级<a class="ae jq" href="https://en.wikipedia.org/wiki/Musl" rel="noopener ugc nofollow" target="_blank"> musl </a> C标准库(因此被移植的库不需要重写),并在JS中生成包装器模块，该模块将与musl协同工作，并调用例如浏览器内的<code class="eh lg lh li lj b">Date</code>对象，因此musl的日期/时间功能可以正常工作。不幸的是，这是有代价的:即使用闭包库缩小，它也会重约10kb，所以我很好奇在我的特殊情况下，我是否能比Emscripten做得更好。</p><p id="4272" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们先看看什么模块实际上需要来自Binaryen toolchain的<code class="eh lg lh li lj b">wasm-dis</code>:</p><pre class="lr ls lt lu fq mg lj mh mi aw mj dt"><span id="f462" class="jy jz hu lj b fv mk ml l mm mn">$ wasm-dis vmsg.wasm | grep '(import'<br/> (import "env" "memory" (memory $0 3))<br/> (import "env" "pow" (func $import$1 (param f64 f64) (result f64)))<br/> (import "env" "exit" (func $import$2 (param i32)))<br/> (import "env" "powf" (func $import$3 (param f32 f32) (result f32)))<br/> (import "env" "exp" (func $import$4 (param f64) (result f64)))<br/> (import "env" "sqrtf" (func $import$5 (param f32) (result f32)))<br/> (import "env" "cos" (func $import$6 (param f64) (result f64)))<br/> (import "env" "log" (func $import$7 (param f64) (result f64)))<br/> (import "env" "sin" (func $import$8 (param f64) (result f64)))<br/> (import "env" "sbrk" (func $import$9 (param i32) (result i32)))</span></pre><p id="e69c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只有10个函数，其中大部分可以直接映射到<code class="eh lg lh li lj b">Math</code>对象！还有<code class="eh lg lh li lj b">exit</code>，当模块决定退出时被调用，<code class="eh lg lh li lj b">memory</code>是虚拟内存，当需要分配更多内存时，由musl调用<code class="eh lg lh li lj b">new WebAssembly.Memory</code>和<code class="eh lg lh li lj b">sbrk</code>创建。<a class="ae jq" href="https://github.com/Kagami/vmsg/blob/efcbb9ffdd718fe0aebd13b19d0018b71027bfcc/vmsg.js#L24-L55" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以看到我实现的所有功能，它只用了30行代码，运行得非常好。</p><h2 id="0a51" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">聚合填料</h2><p id="380e" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">WebAssembly受到所有4种主要浏览器(Chrome/Firefox/Safari/Edge)的支持，这是一件好事，但并非所有网络用户都可以访问最新版本的浏览器。因此，在不损害可读性/性能/维护性等的情况下，让你的应用程序支持尽可能多的版本是合理的。例如，我有意在没有<a class="ae jq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming" rel="noopener ugc nofollow" target="_blank">web assembly . instantiate streaming</a>的浏览器上使用XHR，因为它使代码仅长5行，并允许支持没有Fetch API的浏览器，例如Edge 12–14。</p><p id="12ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前推荐的“多填充”WebAssembly的方法是用相同的代码创建单独的asm.js版本。它与Emscripten的运行时配合得很好，因为它抽象出了这两种技术之间的差异，并提供了单一的<code class="eh lg lh li lj b">Module</code>接口来与编译后的代码进行交互。因为我们使用我们自己的运行时，并且因为使用WebAssembly API(如果可用的话)和模拟它(如果不可用的话)感觉更自然，所以我决定踏上“真正的polyfill”之路。</p><p id="603f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">快速搜索“WebAssembly polyfill”会返回几个项目，其中最有希望的是莱恩·凯利的<a class="ae jq" href="https://github.com/rfk/wasm-polyfill" rel="noopener ugc nofollow" target="_blank"/>。它通过模拟WebAssembly浏览器API(如<code class="eh lg lh li lj b">WebAssembly.Memory</code>和<code class="eh lg lh li lj b">WebAssembly.Table</code>)来工作，解析二进制模块并动态生成类似asm.js的代码。正是我想要的！不幸的是，它不再被维护，所以我不得不分叉，稍微重构，修复明显的问题和测试，并发布到NPM。最可怕的错误出现在<code class="eh lg lh li lj b">i64.store</code>指令的代码生成中，但最终我还是修复了它。<a class="ae jq" href="https://github.com/Kagami/wasm-polyfill.js" rel="noopener ugc nofollow" target="_blank">这里</a>是我的叉子，我想它可能对其他项目也有用。</p><p id="297c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还在Binaryen repo 中发现了<a class="ae jq" href="https://github.com/WebAssembly/binaryen/blob/master/bin/wasm.js" rel="noopener ugc nofollow" target="_blank"> polyfill，但是它太大了(wasm-polyfill的大小为2.5mb，而wasm-poly fill的大小为95kb)，而且不完整:它没有模拟WebAssembly浏览器API。最后，</a><a class="ae jq" href="https://github.com/lukewagner/polyfill-prototype-1" rel="noopener ugc nofollow" target="_blank">官方polyfill原型</a>看起来被废弃了，所以wasm-polyfill可能是我们现在最好的选择。但是这并不理想:生成的代码并不像它应该的那样高效，有许多额外的检查被创建来保证完全的语义正确。请参阅最后一节，了解该领域可能的改进。</p><p id="38da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">polyfill的用法很简单:包括带有<code class="eh lg lh li lj b">&lt;script&gt;</code>标签的缩小的<code class="eh lg lh li lj b">wasm-polyfill.js</code> build，或者在工人的情况下调用<code class="eh lg lh li lj b">importScripts</code>。小菜一碟。</p><h2 id="5e64" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">把所有东西放在一起</h2><p id="888b" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我们已经有了WebAssembly模块，可以从JavaScript加载它并调用它的函数，还有什么？我们需要在Worker中生成它，定义通信协议，并从mic中输入一些真实数据。</p><p id="28ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，我们需要建立一些用户界面，这样用户就不必一直重新实现它。起初，我倾向于React，因为它对于创建可组合UI组件来说是非常流行和强大的库。不过这也是有代价的:并不是世界上的每个人都在使用React，比如Angular和Vue.js也很普遍，如果坚持使用React-only，你会把你的库的很多潜在用户拒之门外。鉴于我计划使接口非常简单，React在这里不会有太大帮助，所以最好利用标准的DOM API。此外，将这样的库包含到由任何框架支持的站点中总是可能的，但反之则不行。</p><p id="82cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会注释我所有的代码，大部分都是自我描述的。检查结果<a class="ae jq" href="https://github.com/Kagami/vmsg/blob/v0.2.0/vmsg.js" rel="noopener ugc nofollow" target="_blank"> vmsg.js </a>。在网络上，与网络音频和网络工作者的互动已经被很好地记录下来了。唯一有趣的部分是，我没有为worker source使用单独的文件，而是创建了一个<a class="ae jq" href="https://github.com/Kagami/vmsg/blob/v0.2.0/vmsg.js#L340-L344" rel="noopener ugc nofollow" target="_blank"> Blob URL </a>。这使得library更容易使用:你不必关心额外的文件。</p><p id="792f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整演示可从<a class="ae jq" href="https://kagami.github.io/vmsg/" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h2 id="7825" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jc kj kk kl jg km kn ko jk kp kq kr ks dt translated">未来的想法</h2><p id="abc3" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">现在怎么办？库工作得很好，我已经在我的论坛上使用它来支持语音信息。但是很少有更有趣的领域值得一试:</p><ol class=""><li id="80fe" class="mo mp hu it b iu iv iy iz jc mq jg mr jk ms jo mt mu mv mw dt translated">Emscripten将很快获得对<a class="ae jq" href="https://github.com/kripken/emscripten/pull/6249" rel="noopener ugc nofollow" target="_blank"> emmalloc </a>的支持，这应该会毫不费力地减少构建规模，只需通过选项启用它即可。这带来了降低malloc操作效率的成本，但对于LAME来说，这应该不是问题。</li><li id="8d5f" class="mo mp hu it b iu mx iy my jc mz jg na jk nb jo mt mu mv mw dt translated">作为WebAssembly模块的一部分，实现一些音频过滤器(如噪声抑制和音调变换)可能会很有趣。因为它在单独的工作线程中运行，所以我们可以使用高级算法，而不用担心引入延迟和冻结主线程。</li><li id="f632" class="mo mp hu it b iu mx iy my jc mz jg na jk nb jo mt mu mv mw dt translated">比较wasm-polyfill有无内存绑定检查的性能是值得的。因为LAME通常不应该设陷阱，所以为了获得更好的性能，禁用所有检查是相当安全的。即使在C代码出现错误的情况下，也不会影响JavaScript端，因为有沙箱保护。</li><li id="578c" class="mo mp hu it b iu mx iy my jc mz jg na jk nb jo mt mu mv mw dt translated">相当复杂但可行的任务是使wasm-polyfill asm.js翻译的代码兼容。现在有很多规范违规，所以它不可能是AOT编译的。它像普通的JavaScript一样运行，因此没有那么快和高性能(尽管JIT应该很难优化这样的代码)。</li></ol></div></div>    
</body>
</html>