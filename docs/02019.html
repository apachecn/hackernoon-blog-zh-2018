<html>
<head>
<title>Megaparsec: Same Syntax, More Features!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Megaparsec:相同的语法，更多的特性！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/megaparsec-same-syntax-more-features-b8f9b844bb02?source=collection_archive---------28-----------------------#2018-03-05">https://medium.com/hackernoon/megaparsec-same-syntax-more-features-b8f9b844bb02?source=collection_archive---------28-----------------------#2018-03-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/60da3e5292db825cdece747e2f9a5001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOfUP4liPys3cjV4mOu7zQ.png"/></div></div></figure><p id="d405" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上周，我们通过学习Attoparsec库，向一元解析世界迈进了一步。与应用解析相比，它为我们提供了更清晰的语法。本周，我们将探索最后一个库:<a class="ae ka" href="https://hackage.haskell.org/package/megaparsec" rel="noopener ugc nofollow" target="_blank"> Megaparsec </a>。</p><p id="f365" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个库和Attoparsec有很多共同之处。事实上，这两者在设计上有很多兼容性。最终，我们会发现我们不需要改变太多的语法。但是Megaparsec确实有一些额外的功能，可以让我们的生活更简单。</p><p id="d7d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要了解这里的代码示例，请前往Github上的<code class="eh kb kc kd ke b"><a class="ae ka" href="https://github.com/jhb563/GherkinParsing/tree/megaparsec" rel="noopener ugc nofollow" target="_blank">megaparsec</a></code> <a class="ae ka" href="https://github.com/jhb563/GherkinParsing/tree/megaparsec" rel="noopener ugc nofollow" target="_blank">分支</a>！要了解更多可以在生产中使用的优秀库，请务必下载我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！但是，如果您是Haskell的新手，请不要担心！只要看看我们的<a class="ae ka" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>，你就会知道从哪里开始！</p><h1 id="d39c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">不同的解析器类型</h1><p id="9d1f" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">首先，Megaparsec的基本解析类型稍微复杂一些。它有两个类型参数，<code class="eh kb kc kd ke b">e</code>和<code class="eh kb kc kd ke b">s</code>，还带有一个内置的单子变压器<code class="eh kb kc kd ke b">ParsecT</code>。</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="e9e3" class="lq kg hu ke b fv lr ls l lt lu">data ParsecT e s m a</span><span id="2db3" class="lq kg hu ke b fv lv ls l lt lu">type Parsec e s = ParsecT e s Identity</span></pre><p id="7cfb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">e</code>类型允许我们向解析器提供一些定制的错误数据。<code class="eh kb kc kd ke b">s</code>类型是指我们的解析器的输入类型，通常是String的某种变体。这个参数也存在于Attoparsec的引擎盖下。但是我们通过使用<code class="eh kb kc kd ke b">Text</code>模块避开了这个问题。现在，我们将设置自己的类型别名，将这些参数隐藏起来:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="c42d" class="lq kg hu ke b fv lr ls l lt lu">type MParser = Parsec Void Text</span></pre><h1 id="9a44" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">尽最大努力</h1><p id="34d8" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">让我们开始填充我们的解析器。Attoparsec和Megaparsec有一个结构上的区别。当解析器在Attoparsec中失败时，它的默认行为是回溯。这意味着它好像没有消耗任何输入。Megaparsec就不是这样！重复我们的<code class="eh kb kc kd ke b">nullParser</code>代码的幼稚尝试在某些方面可能会失败:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="e288" class="lq kg hu ke b fv lr ls l lt lu">nullParser :: MParser Value<br/>nullParser = nullWordParser &gt;&gt; return ValueNull<br/>  where<br/>    nullWordParser = string "Null" &lt;|&gt; string "NULL" &lt;|&gt; string "null"</span></pre><p id="c5ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们得到这个解析器的输入“NULL”。我们的程序将尝试选择第一个解析器，它将解析<code class="eh kb kc kd ke b">N</code>标记。然后会在<code class="eh kb kc kd ke b">U</code>失败。它将移动到第二个解析器，但是它已经消耗了<code class="eh kb kc kd ke b">N</code>！因此，第二个和第三个解析器也会失败！</p><p id="ebc6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们通过使用<code class="eh kb kc kd ke b">try</code>组合子来解决这个问题。如果我们的解析器失败，使用<code class="eh kb kc kd ke b">try</code>给我们提供了回溯的Attoparsec行为。以下内容可以正常工作:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="7477" class="lq kg hu ke b fv lr ls l lt lu">nullParser :: MParser Value<br/>nullParser = nullWordParser &gt;&gt; return ValueNull<br/>  where<br/>    nullWordParser = <br/>      try (string "Null") &lt;|&gt; <br/>      try (string "NULL") &lt;|&gt; <br/>      try (string "null")</span></pre><p id="a7d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更好的是，Megaparsec还有一个方便的函数<code class="eh kb kc kd ke b">string’</code>用于不区分大小写的解析。所以我们的null和boolean解析器变得更加简单:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="d445" class="lq kg hu ke b fv lr ls l lt lu">nullParser :: MParser Value<br/>nullParser = M.string' "null" &gt;&gt; return ValueNull</span><span id="fe6c" class="lq kg hu ke b fv lv ls l lt lu">boolParser :: MParser Value<br/>boolParser = <br/>  (trueParser &gt;&gt; return (ValueBool True)) &lt;|&gt; <br/>  (falseParser &gt;&gt; return (ValueBool False))<br/>    where<br/>      trueParser = M.string' "true"<br/>      falseParser = M.string' "false"</span></pre><p id="3fc5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与Attoparsec不同，我们没有方便的科学数字解析器。我们将不得不从应用解析回到我们的逻辑，只是这次是一元语法。</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="0372" class="lq kg hu ke b fv lr ls l lt lu">numberParser :: MParser Value<br/>numberParser = (ValueNumber . read) &lt;$&gt;<br/>  (negativeParser &lt;|&gt; decimalParser &lt;|&gt; integerParser)<br/>  where<br/>    integerParser :: MParser String<br/>    integerParser = M.try (some M.digitChar)</span><span id="6a93" class="lq kg hu ke b fv lv ls l lt lu">    decimalParser :: MParser String<br/>    decimalParser = M.try $ do<br/>      front &lt;- many M.digitChar<br/>      M.char '.'<br/>      back &lt;- some M.digitChar<br/>      return $ front ++ ('.' : back)</span><span id="b57b" class="lq kg hu ke b fv lv ls l lt lu">    negativeParser :: MParser String<br/>    negativeParser = M.try $ do<br/>      M.char '-'<br/>      num &lt;- decimalParser &lt;|&gt; integerParser<br/>      return $ '-' : num</span></pre><p id="6ac4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们的前两个解析器都使用<code class="eh kb kc kd ke b">try</code>来允许适当的回溯。为了解析字符串，我们将使用<code class="eh kb kc kd ke b">satisfy</code>组合符读取所有内容，直到一个小节或换行符:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="934c" class="lq kg hu ke b fv lr ls l lt lu">stringParser :: MParser Value<br/>stringParser = (ValueString . trim) &lt;$&gt;<br/>  many (M.satisfy (not . barOrNewline))</span></pre><p id="77da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后填充我们的值解析器就像以前一样简单了:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="af84" class="lq kg hu ke b fv lr ls l lt lu">valueParser :: MParser Value<br/>valueParser =<br/>  nullParser &lt;|&gt;<br/>  boolParser &lt;|&gt;<br/>  numberParser &lt;|&gt;<br/>  stringParser</span></pre><h1 id="3ea7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">填写细节</h1><p id="3e98" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">除了一些琐碎的改动，我们解析示例表的方式没有任何变化。当我们获取对时,<code class="eh kb kc kd ke b">Statement</code>解析器需要添加另一个<code class="eh kb kc kd ke b">try</code>调用:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="d1c5" class="lq kg hu ke b fv lr ls l lt lu">parseStatementLine :: Text -&gt; MParser Statement<br/>parseStatementLine signal = do<br/>  M.string signal<br/>  M.char ' '<br/>  pairs &lt;- many $ M.try ((,) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets)<br/>  finalString &lt;- nonBrackets<br/>  let (fullString, keys) = buildStatement pairs finalString<br/>  return $ Statement fullString keys<br/>  where<br/>    buildStatement  = ...</span></pre><p id="4ee0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">否则，如果我们在语句中不使用任何关键字，我们就会失败！但其他方面都是一样的。当然，我们首先还需要改变调用解析器的方式。我们将使用<code class="eh kb kc kd ke b">runParser</code>函数，而不是Attoparsec的<code class="eh kb kc kd ke b">parseOnly</code>。这为我们的解析器的源文件增加了一个额外的参数，以提供更好的消息。</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="a12f" class="lq kg hu ke b fv lr ls l lt lu">parseFeatureFromFile :: FilePath -&gt; IO Feature<br/>parseFeatureFromFile inputFile = do<br/>  …<br/>  case runParser featureParser finalString inputFile of<br/>    Left s -&gt; error (show s)<br/>    Right feature -&gt; return feature</span></pre><p id="8e84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我们的解析器的结构没有任何变化。获取Attoparsec代码和Megaparsec代码并在另一个库上重用它非常容易！</p><h1 id="3982" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">添加一些状态</h1><p id="5c46" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">我们从Megaparsec得到的一个好处是，它的monad transformer使我们更容易使用其他monad功能。我们的语句行解析器总是有点笨拙。让我们稍微清理一下，允许我们自己存储一个字符串列表作为一个状态对象。下面是我们改变解析器类型的方法:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="bdad" class="lq kg hu ke b fv lr ls l lt lu">type MParser = ParsecT Void Text (State [String])</span></pre><p id="f264" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，每当我们使用括号解析器解析一个键时，我们可以使用<code class="eh kb kc kd ke b">modify</code>将该键添加到现有列表中。我们还将连同字符串一起返回括号，而不仅仅是关键字:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="4339" class="lq kg hu ke b fv lr ls l lt lu">insideBrackets :: MParser String<br/>insideBrackets = do<br/>  M.char '&lt;'<br/>  key &lt;- many M.letterChar<br/>  M.char '&gt;'<br/>  modify (++ [key]) -- Store the key in the state!<br/>  return $ ('&lt;' : key) ++ ['&gt;']</span></pre><p id="53f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们可以将解析的字符串连接起来，而不是形成元组！</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="650b" class="lq kg hu ke b fv lr ls l lt lu">parseStatementLine :: Text -&gt; MParser Statement<br/>parseStatementLine signal = do<br/>  M.string signal<br/>  M.char ' '<br/>  pairs &lt;- many $ M.try ((++) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets)<br/>  finalString &lt;- nonBrackets<br/>  let fullString = concat pairs ++ finalString<br/>  …</span></pre><p id="b91e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们如何得到最终的密钥列表呢？简单！我们<code class="eh kb kc kd ke b">get</code>我们的状态值，重置它，并返回一切。不需要我们乱七八糟的<code class="eh kb kc kd ke b">buildStatement</code>函数！</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="7be3" class="lq kg hu ke b fv lr ls l lt lu">parseStatementLine :: Text -&gt; MParser Statement<br/>parseStatementLine signal = do<br/>  M.string signal<br/>  M.char ' '<br/>  pairs &lt;- many $ M.try ((++) &lt;$&gt; nonBrackets &lt;*&gt; insideBrackets)<br/>  finalString &lt;- nonBrackets<br/>  let fullString = concat pairs ++ finalString<br/>  keys &lt;- get<br/>  put []<br/>  return $ Statement fullString keys</span></pre><p id="1c98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们开始运行这个解析器时，我们现在必须使用<code class="eh kb kc kd ke b">runParserT</code>而不是<code class="eh kb kc kd ke b">runParser</code>。这返回给我们一个<code class="eh kb kc kd ke b">State</code>单子中的动作，意味着我们必须使用<code class="eh kb kc kd ke b">evalState</code>来获得最终结果:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="0d9b" class="lq kg hu ke b fv lr ls l lt lu">parseFeatureFromFile :: FilePath -&gt; IO Feature<br/>parseFeatureFromFile inputFile = do<br/>  …<br/>  case evalState (stateAction finalString) [] of<br/>    Left s -&gt; error (show s)<br/>    Right feature -&gt; return feature<br/>  where<br/>    stateAction s = runParserT featureParser inputFile s</span></pre><h1 id="5fb8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">百万奖金c</h1><p id="bd8f" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">作为最后的奖励，让我们看看Megaparsec中的错误消息。当我们在Attoparsec中有错误时，<code class="eh kb kc kd ke b">parseOnly</code>函数会给我们一个错误字符串。但没那么有帮助。它只告诉我们系统内部的单个解析器出了什么问题:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="08ab" class="lq kg hu ke b fv lr ls l lt lu">&gt;&gt; parseOnly nullParser "true"<br/>Left "string"<br/>&gt;&gt; parseOnly "numberParser" "hello"<br/>Left "Failed reading: takeWhile1"</span></pre><p id="0b3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些消息没有告诉我们它在输入中的什么地方失败了，或者我们所期望的是什么。让我们来比较一下Megaparsec和<code class="eh kb kc kd ke b">runParser</code>:</p><pre class="li lj lk ll fq lm ke ln lo aw lp dt"><span id="daca" class="lq kg hu ke b fv lr ls l lt lu">&gt;&gt; runParser nullParser "true" ""<br/>Left (TrivialError <br/>  (SourcePos {sourceName = "true", sourceLine = Pos 1, sourceColumn = Pos 1} :| []) <br/>  (Just EndOfInput) <br/>  (fromList [Tokens ('n' :| "ull")]))<br/>&gt;&gt; runParser numberParser "hello" ""<br/>Left (TrivialError <br/>  (SourcePos {sourceName = "hello", sourceLine = Pos 1, sourceColumn = Pos 1} :| []) <br/>    (Just EndOfInput) <br/>    (fromList [Tokens ('-' :| ""),Tokens ('.' :| ""),Label ('d' :| "igit")]))</span></pre><p id="d442" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这给了我们更多的信息！我们可以看到我们试图解析的字符串。我们还可以看到它失败的确切位置。它甚至会给我们一张它试图使用的解析器的图片。在一个更大的系统中，这有很大的不同。我们可以追踪出我们在开发我们的语法或者使我们的输入符合语法时哪里出错了。如果我们自定义<code class="eh kb kc kd ke b">e</code>参数类型，我们甚至可以将我们自己的详细信息添加到错误消息中，以提供更多帮助！</p><h1 id="b891" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="f194" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">这就结束了我们对Haskell中解析库的探索！在过去的几周里，我们学习了<a class="ae ka" href="https://hackage.haskell.org/package/regex-applicative" rel="noopener ugc nofollow" target="_blank">应用性</a>解析、<a class="ae ka" href="https://hackage.haskell.org/package/attoparsec" rel="noopener ugc nofollow" target="_blank"> Attoparsec </a>和<a class="ae ka" href="https://hackage.haskell.org/package/megaparsec" rel="noopener ugc nofollow" target="_blank"> Megaparsec </a>。第一个为我们的语言是正则的时候提供了有用和直观的组合子。它允许我们避免使用单子进行解析，以及可能带来的负担。在Attoparsec中，我们看到了一元风格解析的介绍。这为我们提供了一个更容易理解的语法，并且我们可以看到发生了什么。最后，本周，我们探索了Megaparsec。这个库在语法上与Attoparsec有很多共同之处。但是它提供了一些额外的功能，可以使许多任务变得更容易。</p><p id="7d54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">准备好探索Haskell develop的更多领域了吗？想获得一些新图书馆学习的想法？下载我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！它将为您提供从数据结构到web APIs等领域的一些工具的快速总结！</p><p id="a0f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从来没有用Haskell编程过？想开始吗？查看我们的<a class="ae ka" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>！它拥有您开始Haskell之旅所需的所有工具！</p></div></div>    
</body>
</html>