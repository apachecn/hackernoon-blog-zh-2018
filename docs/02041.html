<html>
<head>
<title>Apply the decorator pattern in .NET using Autofac</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在中应用装饰器模式。使用Autofac</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/apply-the-decorator-pattern-in-net-using-autofac-957502b771f7?source=collection_archive---------8-----------------------#2018-03-06">https://medium.com/hackernoon/apply-the-decorator-pattern-in-net-using-autofac-957502b771f7?source=collection_archive---------8-----------------------#2018-03-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/307b700bc493619b07bd76e4ab1afed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cl1FLSzewuybqI18Gliv8w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Russian Dolls — metaphor to extend a given functions behavior. Photo borrowed from <a class="ae jg" href="http://maxpixel.freegreatpicture.com/Traditional-Russian-Toy-Russian-Doll-Russian-1090697" rel="noopener ugc nofollow" target="_blank">Maxpixel</a>.</figcaption></figure><p id="c997" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我提倡在开发应用程序时遵循良好的设计原则和结构。</p><p id="57fb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随着开发过程的进行，我们会在应用程序中添加新的功能:这可能是客户的功能请求，也可能是您建议的改进。无论如何，这些即将到来的变化也将改变已经给出的代码库。当引入变更时，我们希望尽可能简单。</p><p id="0e34" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将向您展示一个例子，在您想要将功能扩展到一个现有特性的场景中，如何通过强大的IoC容器<a class="ae jg" href="https://autofac.org/" rel="noopener ugc nofollow" target="_blank"> Autofac </a>利用装饰器模式。</p><p id="5146" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设您将要构建一个服务于产品的服务。我们将把这个服务称为<strong class="jj hv">iproductreasury</strong>，为了简单起见，我们只使用一个叫做<em class="kf"> GetById </em>的方法。它可能看起来像这样，并连接了一个实现:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="41b4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常情况下，您可以使用下面的代码行将您的具体实现XmlProductRepository注册为IProductRepository，以支持<a class="ae jg" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank"> <em class="kf">依赖倒置原则</em> </a>:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="9130" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">比方说，当产品被获取时，您过一段时间需要一些日志记录。你如何做到这一点？</p><p id="e5db" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过注入一个日志服务来修改实现XmlProductRepository是很有诱惑力的，如下所示:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="ab60" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但这违反了<a class="ae jg" href="https://en.wikipedia.org/wiki/Open/closed_principle" rel="noopener ugc nofollow" target="_blank">打开/关闭原则</a>。原则声明不允许修改类，但是可以扩展它们。在这里，装饰器模式非常方便。</p><p id="9f32" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以通过添加一个日志代理来扩展，而不是搞乱你的原始实现，并将其注册为一个装饰器。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="89e5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不过，您必须修改一行代码，那就是<em class="kf">原始实现</em>的注册。现在它需要是一个命名注册，这样我们在注册装饰器时就可以引用它:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="b4cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后连接并注册装饰器:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="fe83" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们用来指代实现的关键字是<em class="kf"> productRepository </em>。当您准备好这段代码后，当您注入IProductRepository时，将调用的第一个类是LoggingProductRepositoryProxy，由于我们已经向它注入了内部实现，它将作为一个代理(俄罗斯娃娃风格)工作，遵循开放/封闭原则。</p><p id="a9f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设您的XmlProductRepository运行缓慢，您需要将产品缓存一段时间。你将如何实现它？在您的日志实现之上添加另一个装饰器是非常容易的:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Note that the logging implementation now needs to be named</figcaption></figure><p id="dce4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">相当灵活！</p><p id="1b91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">装饰模式在支持应用程序中的横切关注点时非常强大。</p><p id="4267" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你觉得这个帖子有用吗？你知道该怎么做！👏</p></div></div>    
</body>
</html>