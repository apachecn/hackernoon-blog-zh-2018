<html>
<head>
<title>Why the Blank Expression? Solution to App White-screen Syndrome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么一脸茫然？App白屏综合症的解决方案</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-the-blank-expression-46c40fb0fccf?source=collection_archive---------21-----------------------#2018-03-06">https://medium.com/hackernoon/why-the-blank-expression-46c40fb0fccf?source=collection_archive---------21-----------------------#2018-03-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e0f5" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">随着web内容进入日常生活的各个方面，移动设备的性能也在不断提高，发展使得内容可以在各种平台和设备上访问。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/2c10ed96e46238394755ae8a4a15cc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_2Ie46roNHOBmB0VvFgTw.jpeg"/></div></div></figure><p id="b023" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">然而，如果没有适当的优化，网页内容可能会成为某些限制的受害者。使用HTML 5标记创建的内容经常遇到的一个问题是，当用户访问内容时，最初的加载速度很慢。网页加载时出现白屏，HTML 5过程的复杂性往往导致加载时间过长，导致用户体验不佳。</p><p id="d788" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">本文探讨了提高应用程序功能模块的初始加载速度的可能方法，这些模块加载特定内容的网页。建议的优化可以应用于使初始加载体验像本机应用程序一样流畅。</p><h1 id="dc6a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">初始页面加载——为什么延迟？</h1><p id="2b45" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">标记语言HTML广泛用于跨多个平台构建和呈现数字内容。虽然第五个版本HTML 5为网页带来了更好的多媒体和多平台支持，但它也受到初始加载时间缓慢的困扰。</p><p id="1c3d" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这主要是由于加载HTML 5网页的复杂步骤:</p><blockquote class="lf lg lh"><p id="efcc" class="is it li iu b iv iw ix iy iz ja jb jc lj je jf jg lk ji jj jk ll jm jn jo jp hn dt translated">初始化webview →请求页面→下载数据→解析HTML →请求JS/CSS资源→ DOM渲染→解析JS执行→ JS请求数据(有时不需要)→解析渲染→下载渲染图片</p></blockquote><p id="8698" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">通常，在DOM渲染步骤之前会显示一个白屏。用户只有下载渲染图后才能浏览完整网页。在其他情况下，只显示页面的一部分。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lm"><img src="../Images/186fe7c16f48825f70fef7eb41933ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*je2N_tqQrP7BQl6s-GXVPA.jpeg"/></div></div></figure><p id="7dfa" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">为了解决这个问题，可以进行前端、客户端和其他优化，以减少此类过程的持续时间，从而实现初始加载的零延迟。</p><h1 id="de4d" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">前端优化</h1><p id="54b1" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">可以对页面的内部前端部分进行优化，以提高初始页面加载速度。这些优化包括:</p><p id="414e" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">减少请求数量</strong></p><p id="5081" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这是通过合并资源、减少HTTP请求的数量以及通过minify/gzip压缩、webP和lazyLoad来实现的。</p><p id="cce8" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">加速请求的速度</strong></p><p id="ab28" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这是通过预先解析DNS、减少域数量、并行加载和CDN分发来实现的。</p><p id="00dd" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">缓存</strong></p><p id="9eaa" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这包括HTTP协议缓存请求、脱机缓存清单和本地存储上的脱机数据缓存。</p><p id="f352" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">渲染</strong></p><p id="b92c" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这是通过利用JS/CSS优化、加载序列、服务器渲染和管道来实现的。</p><p id="b73a" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">在上述解决方案中，网络请求对初始加载速度的影响最大；因此，前端的请求缓存策略应该是优化的重点。</p><p id="5a14" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">缓存可以分为静态文件缓存(包含HTML和JS/CSS/image资源)和json数据缓存。静态文件缓存的协议由HTTP定义。一旦浏览器实现了这些协议，静态文件也可以被缓存(更多细节可以在<a class="ae ln" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" rel="noopener ugc nofollow" target="_blank">这里</a>找到)。对于静态文件，有两种类型的缓存:</p><blockquote class="lf lg lh"><p id="ee82" class="is it li iu b iv iw ix iy iz ja jb jc lj je jf jg lk ji jj jk ll jm jn jo jp hn dt translated"><strong class="iu hv">那些问有没有更新的</strong></p><p id="26a8" class="is it li iu b iv iw ix iy iz ja jb jc lj je jf jg lk ji jj jk ll jm jn jo jp hn dt translated">这些来自后端的缓存请求基于诸如If-Modified-Since/ETag之类的协议要求更新。如果没有更新，页面返回304，浏览器使用本地缓存。</p><p id="d19b" class="is it li iu b iv iw ix iy iz ja jb jc lj je jf jg lk ji jj jk ll jm jn jo jp hn dt translated"><strong class="iu hv">那些直接使用本地缓存的</strong></p><p id="5d38" class="is it li iu b iv iw ix iy iz ja jb jc lj je jf jg lk ji jj jk ll jm jn jo jp hn dt translated">这种类型的缓存根据协议中的缓存控制/过期字段确定多长时间不需要更新请求。当不需要这样的请求时，直接使用本地缓存。</p></blockquote><p id="6e36" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">基于以上所述，优化的前端缓存策略从HTML文件每次加载时向服务器请求更新开始，而JS/CSS/Image资源文件直接使用本地缓存，而不是请求更新。</p><p id="4193" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这种方法的一个潜在问题是更新JS/CSS文件。解决方案是在构建过程中给每个资源文件一个版本号或哈希值。如果资源文件有更新，版本号和哈希值将会改变，从而改变资源请求的URL。同时，相应的网页将被更新，并将请求新资源的URL，从而更新资源。</p><p id="79c4" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">关于json数据缓存，解决方案是使用从localStorage缓存请求的数据。第一次显示页面时可以使用本地数据，同时会发送更新请求。因此，下次可以使用新数据。这个过程仍然由JavaScript控制。</p><p id="ba72" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这些缓存策略可以实现完全缓存资源文件，如JS/CSS，以及用户数据缓存。它还在加载页面时直接使用本地缓存数据，而不需要网络请求。然而，这对于网页的缓存来说是不可能的。如果“Expires”和“max-age time”的时间段设置得太长，并且只有本地缓存被长时间使用，则页面将不会及时更新。同时，如果“Expires”和“max-age time”的时间段设置得太短，页面将在每次加载时向网络请求更新，然后决定是否使用本地资源。</p><p id="fe3a" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">一般的前端策略是每当用户长时间看到白屏时就请求更新。这是由于缓存和HTML文件更新之间的冲突造成的。</p><p id="4a75" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">通常情况下，前端采用每次加载页面都请求更新的策略。这使得白屏时间非常长，尤其是在网络连接不良的情况下。因此，HTML页面中的“缓存”和“更新”之间存在目标冲突。</p><h1 id="fc30" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">客户端优化</h1><p id="c294" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">现在大多数应用程序中都嵌入了网页，客户端有权进行页面优化。因为客户端在实现缓存策略方面有更多的自由，所以所有的网页请求都可以被拦截，缓存可以由客户端自己管理。</p><p id="b09d" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">为了克服HTML的缓存和更新之间的目标冲突，下面的方法显示了令人鼓舞的结果:</p><p id="b815" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">一旦客户端出现拦截请求，当HTML文件第一次被请求时，缓存数据。</p><p id="ac14" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">当第二次加载网页时，不要发送第二次请求，而是直接使用缓存的数据。</p><p id="afcc" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这种对本地资源的直接使用消除了等待网络请求的需要，因此提高了网页的加载速度。同时可以尽可能频繁地维护实时更新，解决缓存问题。</p><p id="933e" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这似乎完全解决了缓存问题，但实际上还有许多问题有待解决。改进缓存逻辑是解决这些问题的一种方法，但更好的解决方案是使用网页包。</p><h2 id="c7e5" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">改进的缓存逻辑</h2><p id="7fb7" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">Webview可以直接控制对缓存的访问，但不能控制对缓存逻辑的访问。这种不可控的缓存会导致多个问题，但每个问题都可以解决或变通。</p><p id="7549" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">重要的HTML/JS/CSS缓存在缓存一些大图后被清空</strong></p><p id="e70f" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这个问题源于不可控的清除逻辑和有限的缓存空间。解决方案是配置一个预加载缓存列表，这些缓存需要在应用程序打开时或在预设时间提前请求更新。这个列表必须包含所有需要的网页模块和资源，并且必须考虑一个网页模块可能有多个页面的事实。这个列表可能很长，因此需要工具来生成和管理它。</p><p id="76ec" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">数据无法从磁盘预加载到内存</strong></p><p id="e9b7" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这个问题源于不可控的磁盘IO。可以通过客户端接管所有请求的缓存并选择不使用webview的默认缓存逻辑来解决这个问题。然后，缓存机制根据缓存优先级和缓存预加载自行实现。</p><p id="13df" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">在后台HTML/JS/CSS更新期间完全下载非常耗时，而且网络连接很差</strong></p><p id="e409" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这是因为涉及到大量的数据。解决方案是对每个HTML和资源文件执行增量更新。然而，这在实现和管理上有些不便。</p><p id="92a1" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">被运营商或其他第三方劫持的HTML页面被长时间缓存</strong></p><p id="1d13" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这个问题可以通过在客户端使用httpdns + https反劫持系统来解决。</p><p id="3b82" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">尽管可行，但这些解决方案实现起来很麻烦，因为HTML和资源文件数量众多且分散，很难管理。</p><h2 id="dcce" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">网页包</h2><p id="e1df" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">由于提出的使用场景是使用网页开发功能模块，并且考虑到管理分散的文件会产生问题，一个显而易见的解决方案是打包并交付所有相关的页面和资源。</p><p id="f7b8" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">该解决方案可以使用某些相对简单的方法来解决上述问题:</p><p id="fa96" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">整个网页包可以预下载，其配置可以基于服务模块而不是文件进行。网页包包含与服务模块相关的所有页面，并且可以同时预加载所有页面。</p><p id="b60d" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">网页包的核心文件和页面的动态图片资源文件的缓存是分开的，这使得缓存管理更加容易。此外，整个网页包可以预加载到内存中，减少磁盘IO所需的时间。</p><p id="7cce" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">一个网页包可以很容易地基于版本进行增量更新。</p><p id="1f1e" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">网页包是通过一个加密和验证的档案，使运营商和第三方不可能劫持或篡改它。</p><p id="e21f" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">具体解决方案总结如下:</p><p id="d328" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">1.使用后端的构建工具，将同一个服务模块相关的所有页面和资源打包到一个文件中，同时进行加密/签名。</p><p id="41c0" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">2.在客户端，在定制的时间下载网页包，然后根据配置表进行解压缩/解密/验证。</p><p id="d16f" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">3.打开服务后，根据配置表将页面转移到网页包入口页面。</p><p id="b00e" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">4.拦截网络请求，并为网页包中的现有文件读取从网页包返回的数据。否则，应用HTTP协议的缓存逻辑。</p><p id="6c81" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">5.当更新网页包时，服务器仅传送当前版本和最新版本之间的差异数据包，而客户端通过合并两个客户端来执行增量更新。</p><p id="b31b" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">网页包是网页开发的一个可行的解决方案。还有许多其他的优化选项也应该考虑。</p><h1 id="70fc" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">其他优化</h1><p id="f52f" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">还可以实施其他优化来补充网页包解决方案，包括:</p><p id="88a1" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">使用公共资源包</p><p id="853a" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">Webview预加载</p><p id="835e" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">数据预加载</p><p id="971b" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">回退优化</p><p id="1466" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">客户端界面优化</p><p id="b05a" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">服务器渲染优化</p><h2 id="3602" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">使用公共资源包</h2><p id="e058" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">每个包都使用相同的JS框架和全局CSS样式。这些资源被浪费了，因为它们出现在每个网页包中。相反，可以创建一个公共资源包来提供这些全局文件。</p><h2 id="f777" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">Webview预加载</h2><p id="23cd" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">对于iOS和Android，webview组件的初始化都存在加载时间长的问题，这可以通过预加载webview来克服。有两种类型的预加载:</p><p id="1bb4" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv">首次预压</strong></p><p id="3cde" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">webview的第一次初始化通常非常慢。webview可以预先初始化，然后在应用程序打开时释放，这样当用户在网页模块中加载webview时，该过程会更快。</p><p id="048f" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated"><strong class="iu hv"> Webview池</strong></p><p id="446a" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">不同于每次打开一个网页都创建一个新的网络视图的老方法，两个或更多的网络视图可以被巧妙的使用。然而，这种方法的一个问题是当发生页面跳转时如何清除前一页。还有一个就是如果一个网页出现JS内存泄漏，其他页面会受到影响，无法释放。</p><h2 id="9594" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">数据预加载</h2><p id="a85a" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">理想情况下，第一次打开网页包时，所有HTML/JS/CSS都使用本地缓存，不需要网络请求。然而，页面上的用户数据仍然需要实时请求，这是可以应用优化的地方。发出并行数据请求可以节省大量加载时间。</p><p id="18c9" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">当实现该解决方案时，需要预加载到网页包中的URL使用配置表。在webview初始化期间，客户端发送请求，并在预加载完成时发送缓存结果。</p><p id="7bdb" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">接下来，初始化完成后，webview将开始请求预加载的URL。客户端截取请求，并将其传送给管理器。如果预加载完成，客户端返回到内容。如果不是，那么客户端等待它这样做。</p><h2 id="f8ab" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">回退优化</h2><p id="8c53" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">网页包模块的一个潜在问题是，用户可能试图访问尚未下载的网页包模块，或者配置表检测到新版本，但旧版本仍在应用程序中使用。</p><p id="3ff9" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">有几种解决方案可以用来克服这个问题:</p><p id="7e5e" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">如果没有本地网页包或者现有的本地网页包不是最新的，可以执行同步阻止来下载最新的网页包。但是，这种解决方案可能会影响用户体验，因为网页包的大小相对较大。</p><p id="e099" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">如果存在旧版本，用户可以被允许直接使用它一次。这种解决方案可能会导致更新延迟，并且用户可能没有使用最新版本。</p><p id="fdd2" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">可以创建网页包的在线版本，网页包中的每个文件在服务器上具有相应的访问地址。当没有现有的网页包时，可以像正常打开网页一样直接访问相应的在线地址。与下载整个网页包相比，该解决方案创建了更好的用户体验，并确保用户访问最新版本。这也可以作为备用解决方案。在不可预见的情况下，如果网页软件包出现故障，用户可以直接访问在线版本，因此网页的功能不会受到影响。</p><p id="698f" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这些回退优化的优点是它们可以根据需要混合和匹配。</p><h2 id="1658" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">客户端界面优化</h2><p id="2d40" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">如果在网络和客户端接口上使用webkit的ajax和localStorage，会有很多限制，优化变得更加困难。</p><p id="be00" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">JS可以在客户端提供这些接口，所以可以在客户端进行DNS预解析/IP直连/长连接/并行请求等更具体的优化。关于存储，客户端的接口可用于执行有针对性的优化，如读写并发性/用户隔离。</p><h2 id="76dc" class="lo kd hu bd ke lp lq lr ki ls lt lu km jd lv lw kq jh lx ly ku jl lz ma ky mb dt translated">服务器渲染优化</h2><p id="54ce" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">与早期的网页不同，大多数网页内容依赖于JS逻辑来确定要呈现的内容，这可能是一个非常耗时的过程。例如，等待JS请求JSON数据，然后将其拼接到HTML生成的DOM中并呈现到页面上，这是一个漫长的过程。</p><p id="e55e" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">这个问题的解决方案包括从人工减少JS呈现逻辑到更彻底和基础的服务器呈现。这是所有内容由服务器返回的HTML决定的地方，不需要等待JS逻辑发生。</p><p id="299b" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">然而，这可能会带来某些挑战，例如开发模式的改变/流量的增加/服务器成本的增加。QQ Mobile中的某些页面采用了一种称为“动态直接输出”的特定服务器渲染方法，有关更多详细信息，请参见本文<a class="ae ln" href="https://mp.weixin.qq.com/s/evzDnTsHrAr2b9jcevwBzA" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="1e1a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">结论</h1><p id="a1df" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">从前端优化、客户端缓存、网页打包，到更细致的优化，网页初始加载速度的解决方案数不胜数。如果这些解决方案被适当地采用和正确地执行，打开网页的用户体验几乎可以与原生应用相媲美。</p><p id="50ce" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">总而言之，优化网页的一般方法是“缓存、预加载、并行计算”:</p><p id="9098" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">缓存所有网络请求</p><p id="c548" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">在用户打开页面之前，加载尽可能多的内容</p><p id="d4f0" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt translated">尽可能并行执行多个流程，而不是串行执行</p><p id="d750" class="pw-post-body-paragraph is it hu iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hn dt">(Original article by Chen Zhenzhuo陈振焯)</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><h1 id="46c5" class="kc kd hu bd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph is it hu iu b iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl le jn jo jp hn dt translated">关于阿里巴巴最新技术的第一手深入信息→在<strong class="iu hv"/>上搜索<a class="ae ln" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="iu hv">【阿里巴巴科技】</strong> </a></p></div></div>    
</body>
</html>