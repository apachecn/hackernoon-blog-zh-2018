<html>
<head>
<title>Get an isomorphic web app up and running in 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在5分钟内启动并运行同构web应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/get-an-isomorphic-web-app-up-and-running-in-5-minutes-72da028c15dd?source=collection_archive---------1-----------------------#2018-03-08">https://medium.com/hackernoon/get-an-isomorphic-web-app-up-and-running-in-5-minutes-72da028c15dd?source=collection_archive---------1-----------------------#2018-03-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="67ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个同构的web应用程序给你提供了服务器端渲染和单页应用程序(SPA)的优点。</p><h2 id="2c8a" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">TL；速度三角形定位法(dead reckoning)</h2><p id="0079" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">让代码在localhost上运行:3000</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="9ad8" class="jp jq hu ku b fv ky kz l la lb">$ git clone <a class="ae lc" href="https://github.com/xiaoyunyang/isomorphic-router-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/xiaoyunyang/isomorphic-router-demo.git</a><br/>$ cd isomorphic-router-demo<br/>$ npm install<br/>$ npm start</span></pre><p id="54f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是检查代码的仓库:<a class="ae lc" href="https://github.com/xiaoyunyang/isomorphic-router-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/xiaoyunyang/isomorphic-router-demo</a></p></div><div class="ab cl ld le hc lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hn ho hp hq hr"><h1 id="80b3" class="lk jq hu bd jr ll lm ln jv lo lp lq jz lr ls lt kc lu lv lw kf lx ly lz ki ma dt translated">动机</h1><p id="0607" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">已经有很多文章写了同构web app的好处，像<a class="ae lc" rel="noopener" href="/@ghengeveld/isomorphism-vs-universal-javascript-4b47fb481beb">这个</a>、<a class="ae lc" href="https://writing.pupius.co.uk/beyond-pushstate-building-single-page-applications-4353246f4480" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae lc" rel="noopener" href="/airbnb-engineering/isomorphic-javascript-the-future-of-web-apps-10882b7a2ebc">这个</a>，还有<a class="ae lc" href="https://ponyfoo.com/articles/stop-breaking-the-web" rel="noopener ugc nofollow" target="_blank">这个</a>。有一本关于它的书正在写。我喜欢把同构的web应用程序想象成SPA 2.0。它是带有服务器端渲染的SPA。</p><p id="bb95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SPA是一个客户端(浏览器渲染)应用程序，在初始加载后启动整个网站。这意味着当你使用浏览器访问example.com时，example . com的服务器会发送一个HTML模板和一些javascript代码，供你的浏览器执行代码，呈现网页的实际内容。因为创建DOM的代码和DOM之间的紧密耦合，spa可以处理复杂的DOM操作。</p><p id="5f1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们都很熟悉SPA的特点:对用户输入的快速响应，高度互动的网页(想想google docs)，以及在页面加载后离线使用的能力。最重要的是，对于像我这样试图用一些虚拟数据快速创建网站原型的初创公司创始人来说，SPA可以让你独立于服务器应用程序构建网站。在许多情况下，如果您使用一个复杂的前端库，如<a class="ae lc" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>、亚马逊S3来托管，并且将数据存储在一个CSV文件中，那么您根本不用构建服务器应用程序。这正是我为<a class="ae lc" href="http://looseleafapp.com/" rel="noopener ugc nofollow" target="_blank">活页</a>所做的。</p><p id="cf88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您为您的网站构建MVP原型时，这种关注点的分离最初会提高生产率，但是对于部署为SPA的网站来说，会有一个收益递减点，该SPA通过API与服务器进行数据通信。这种方法的主要缺点是:</p><h2 id="b3f8" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated"><strong class="ak">加载时间长(坏UX) </strong></h2><p id="eb18" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">因为网站是引导式的，所以页面内容在初始加载后需要一段时间才能显示出来。当您在浏览器中键入example.com并按enter键时，会出现初始加载。浏览器从初始加载中获得的内容就是服务器发送的内容。</p><p id="143c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果服务器发送一个空白的HTML模板和javascript来呈现模板中的内容，那么用户将会看到一个空白的页面和一个页面加载动画。用户需要等待多长时间才能看到内容，这取决于网页的复杂程度以及移动设备上的互联网服务速度，因此网页加载速度往往会慢得多。</p><h2 id="9f75" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated"><strong class="ak">糟糕的SEO(不利于商业)</strong></h2><p id="dd24" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">搜索引擎和社交分享是获取新用户的两个最重要的手段。</p><p id="adae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以把搜索引擎优化(SEO)看作是让谷歌将你的网页在相关查询搜索列表中排名靠前的方法。为了让谷歌对你的网页内容进行排名，它需要知道你的网页上有什么内容。谷歌部署了一大批爬虫，它们只是一些程序，向网页发出请求，查看响应，从HTML中删除内容，并查看如何根据相关性在互联网上的其他网页中对该网页进行排名。这些爬虫一般不会运行JavaScript，也不会等待很长时间让页面自动呈现。如果你的网页在初次加载时给爬虫留下空白页面，那么当在google.com上输入相关搜索查询时，谷歌将不会知道你的页面将会准确地把你的网页放在命中列表的较高位置。</p><p id="8aa7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样的事情也发生在社交媒体网站上，比如脸书和Twitter sharing，他们有自己的爬虫大军，根据HTML标题中的meta标签来呈现页面预览。当网页在浏览器中引导时，标题在服务器端呈现，并且当内容基于动态加载而改变时不会改变。这意味着，如果你有一个销售书籍的网站和一个SPA，它使用相同的HTML模板为不同的书籍呈现不同的页面，那么当你在脸书上分享某本书的页面链接时，预览将显示关于你的网站的通用预览，它说这是一个销售成千上万本书的地方，但不会显示特定书籍的任何独特信息。<a class="ae lc" rel="noopener" href="/@cereallarceny/server-side-rendering-with-create-react-app-fiber-react-router-v4-helmet-redux-and-thunk-275cb25ca972">这篇文章</a>很好地展示了SPA在为社交分享生成独特标题的能力方面的局限性，以及如何使用服务器渲染来解决这个问题。</p><h2 id="dad9" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated"><strong class="ak">纯服务器渲染解决方案怎么样？</strong></h2><p id="3b2f" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">如果你正在读这篇文章，那意味着我已经说服你，简单的水疗不是一个好办法。纯粹的服务器端应用程序也不合适，因为从开发的角度来看，我们希望能够分别构建我们的客户端应用程序和服务器应用程序。从用户体验的角度来看，一旦SPA完全加载，用户体验可能会大大超过服务器呈现的网页。此外，我不希望每次单击按钮时都要重新加载整个页面。</p><p id="5810" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，纯SPA的缺点在于初始负载。纯服务器渲染解决方案的缺点是初始加载后会发生什么。我们怎样做才能两全其美？🤔</p></div><div class="ab cl ld le hc lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hn ho hp hq hr"><h1 id="0403" class="lk jq hu bd jr ll lm ln jv lo lp lq jz lr ls lt kc lu lv lw kf lx ly lz ki ma dt translated">设置同构的web应用程序</h1><p id="c8da" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">客户端渲染和服务器端渲染互为补充。我们可以构建一个同构的web应用程序，用SPA增强服务器呈现页面的能力。我将要介绍的同构web app starter项目利用了JavaScript用于构建客户端应用程序和服务器应用程序这一事实。这促进了代码的可重用性，因为我们可以使用相同的代码来呈现SPA以及服务器为初始加载发送的HTML。</p><p id="e844" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有的代码都包含在这个库中。在本文的剩余部分，我将逐一介绍其中的代码片段。</p><div class="mb mc fm fo md me"><a href="https://github.com/xiaoyunyang/isomorphic-router-demo" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab ej"><div class="mg ab mh cl cj mi"><h2 class="bd hv fv z el mj eo ep mk er et ht dt translated">杨晓云/同构路由器演示</h2><div class="ml l"><h3 class="bd b fv z el mj eo ep mk er et ek translated">这个项目向你展示了如何使用React Router 4和React Router 4建立一个同构的webapp</h3></div><div class="mm l"><p class="bd b gc z el mj eo ep mk er et ek translated">github.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms mt me"/></div></div></a></div><h2 id="a7fd" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated"><strong class="ak">堆栈</strong></h2><p id="73eb" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">这个starter项目的栈包括<a class="ae lc" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>、<a class="ae lc" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>、<a class="ae lc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae lc" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank"> React Router 4 </a>和<a class="ae lc" href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config" rel="noopener ugc nofollow" target="_blank"> react-router-config </a>，babel和<a class="ae lc" rel="noopener" href="/webpack/webpack-4-mode-and-optimization-5423a6bc597a"> Webpack 4 </a>。我没有使用任何第三方通用应用中间件或框架，如<a class="ae lc" href="https://github.com/faceyspacey/react-universal-component" rel="noopener ugc nofollow" target="_blank">React Universal Component</a>或<a class="ae lc" href="https://github.com/smooth-code/loadable-components" rel="noopener ugc nofollow" target="_blank"> Loadable Component </a>。</p><h2 id="f93d" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">文件结构</h2><p id="04cb" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">该项目分为特定于服务器的代码、用于呈现SPA的特定于客户端的代码，以及支持服务器和客户端呈现的共享代码。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="d01a" class="jp jq hu ku b fv ky kz l la lb">~/isomorphic-router-demo$ tree -l 3 --ignore 'node_modules'</span><span id="9c6f" class="jp jq hu ku b fv mu kz l la lb">/isomorphic-router-demo</span><span id="d34e" class="jp jq hu ku b fv mu kz l la lb">├── build<br/>|  └── main.bundle.js<br/>├── client<br/>|  └── main.js<br/>├── iso-middleware<br/>|  └── renderRoute.js<br/>├── package.json<br/>├── .babelrc<br/>├── .env<br/>├── server<br/>|  ├── run.js<br/>|  └── server.js<br/>├── shared<br/>|  ├── App.js<br/>|  ├── components<br/>|  |  ├── About.js<br/>|  |  ├── HTML.js<br/>|  |  ├── TopNav.js<br/>|  |  ├── Home.js<br/>|  |  ├── Main.js<br/>|  |  └── NotFound.js<br/>|  └── routes.js<br/>└── webpack.config.js</span></pre><h2 id="c3b4" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated"><strong class="ak">共享代码</strong></h2><p id="73f6" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">共享代码的主要入口点是<code class="eh mv mw mx ku b">&lt;App&gt;</code>组件:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="faf7" class="jp jq hu ku b fv ky kz l la lb">// shared/App.js</span><span id="c21f" class="jp jq hu ku b fv mu kz l la lb">import React from 'react';<br/>import TopNav from './components/TopNav';<br/>import Main from './components/Main';</span><span id="ad9c" class="jp jq hu ku b fv mu kz l la lb">const App = () =&gt; (<br/>  &lt;div&gt;<br/>    &lt;TopNav /&gt;<br/>    &lt;Main /&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="9bec" class="jp jq hu ku b fv mu kz l la lb">export default App;</span></pre><p id="c625" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个非常标准的top React组件，它使用子组件来呈现不同的页面。</p><p id="0a65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mv mw mx ku b">&lt;TopNav&gt;</code>使用React路由器的<code class="eh mv mw mx ku b">&lt;Link&gt;</code>组件定义应用导航:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="f491" class="jp jq hu ku b fv ky kz l la lb">// shared/components/TopNav.js</span><span id="9c91" class="jp jq hu ku b fv mu kz l la lb">import React from 'react';<br/>import { Link } from 'react-router-dom';</span><span id="e766" class="jp jq hu ku b fv mu kz l la lb">export default () =&gt; (<br/>  &lt;nav&gt;<br/>    &lt;div className="nav-wrapper"&gt;<br/>      &lt;a href="/" className="brand-logo"&gt;Demo&lt;/a&gt;<br/>      &lt;ul id="nav-mobile" className="right"&gt;<br/>        &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>        &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;<br/>        &lt;li&gt;&lt;Link to="/foo"&gt;Foo&lt;/Link&gt;&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  &lt;/nav&gt;<br/>);</span></pre><p id="c0b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于路由为哪个页面提供服务的映射包含在<code class="eh mv mw mx ku b">routes.js</code>中，它被导入到<code class="eh mv mw mx ku b">&lt;Main&gt;</code>组件中。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="4937" class="jp jq hu ku b fv ky kz l la lb">// shared/routes.js<br/>import Home from './components/Home';<br/>import About from './components/About';<br/>import NotFound from './components/NotFound';</span><span id="9f61" class="jp jq hu ku b fv mu kz l la lb">const routes = [<br/>  {<br/>    path: '/',<br/>    exact: true,<br/>    component: Home<br/>  },<br/>  {<br/>    path: '/about',<br/>    component: About<br/>  },<br/>  {<br/>    path: '*',<br/>    restricted: false,<br/>    component: NotFound<br/>  }<br/>];</span><span id="8c7a" class="jp jq hu ku b fv mu kz l la lb">export default routes;</span></pre><p id="6d5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh mv mw mx ku b">&lt;Main&gt;</code>组件中，<code class="eh mv mw mx ku b"><a class="ae lc" href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config" rel="noopener ugc nofollow" target="_blank">react-router-config</a></code> renderRoutes函数用于根据<code class="eh mv mw mx ku b">routes</code>中定义的组件映射路径生成<code class="eh mv mw mx ku b">&lt;Route&gt;</code>组件。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="3466" class="jp jq hu ku b fv ky kz l la lb">import React from 'react';<br/>import { Switch } from 'react-router-dom';<br/>import { renderRoutes } from 'react-router-config';</span><span id="9d55" class="jp jq hu ku b fv mu kz l la lb">import routes from '../routes';</span><span id="473b" class="jp jq hu ku b fv mu kz l la lb">const Main = () =&gt; (<br/>  &lt;Switch&gt;<br/>    {renderRoutes(routes)}<br/>  &lt;/Switch&gt;<br/>);</span><span id="96d3" class="jp jq hu ku b fv mu kz l la lb">export default Main;</span></pre><p id="2aac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如<code class="eh mv mw mx ku b">routes</code>中所定义，您可以呈现的页面有Home、About和NotFound，如下所示:</p><figure class="kp kq kr ks fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff my"><img src="../Images/613642d91228b377e8d9cf5ce7846bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQ2o8XaiQqbyZvcApbDg9w.png"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek">Home Page</figcaption></figure><figure class="kp kq kr ks fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nj"><img src="../Images/2825abc683b482df8903f1de0ca308bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ber268-teOhRYoJGN1hwYQ.png"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek">About page</figcaption></figure><figure class="kp kq kr ks fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nk"><img src="../Images/b26fbbe0ea0d9e5d69b7490902dcc99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQvyPtUCONOxDUVPOhy6xw.png"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek">NotFound page</figcaption></figure><h2 id="b59b" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">服务器渲染</h2><p id="1ea3" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">我们的想法是，当我们在浏览器中键入<code class="eh mv mw mx ku b">localhost:3000</code>并按enter键时，我们希望服务器发送主页的HTML。</p><p id="6fb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们从安装中间件功能开始，用于将应用程序渲染到服务器应用程序，如下面的<code class="eh mv mw mx ku b">server.js</code>所示:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="09c0" class="jp jq hu ku b fv ky kz l la lb">// server/server.js</span><span id="bccf" class="jp jq hu ku b fv mu kz l la lb">import express from 'express';<br/>import renderRouterMiddleware from '../iso-middleware/renderRoute';</span><span id="4069" class="jp jq hu ku b fv mu kz l la lb">// ...</span><span id="262f" class="jp jq hu ku b fv mu kz l la lb">app.get('*', renderRouterMiddleware);</span><span id="e9be" class="jp jq hu ku b fv mu kz l la lb">// ...</span></pre><p id="1e41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mv mw mx ku b">renderRouterMiddleware</code>包含使用<code class="eh mv mw mx ku b">shared</code>文件夹中的组件创建HTML字符串的所有逻辑。</p><p id="44af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mv mw mx ku b">renderRouterMiddleware</code>是我们项目中最重要的文件之一，因为它具有使应用程序同构的逻辑。</p><figure class="kp kq kr ks fq mz"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="5fdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在很大程度上，代码的服务器端呈现部分是非常样板化的，但是具有HTML的服务器端呈现的秘密成分，这使得客户端应用程序在初始加载之后接管成为可能。具体来说，这里为服务器端呈现导入的<code class="eh mv mw mx ku b">&lt;HTML&gt;</code>组件包含与客户端应用程序的联系。但是在我给你看代码之前，我们需要检查一些其他的东西。</p><p id="f0db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">边注:</strong>另一件值得注意的事情是，对于服务器渲染，我们希望在使用React的<code class="eh mv mw mx ku b">renderToString</code>函数转换一切之前，将我们的<code class="eh mv mw mx ku b">&lt;App&gt;</code>包装在React路由器的<code class="eh mv mw mx ku b">&lt;StaticRouter&gt;</code>组件中。对于我们接下来将要讨论的客户端渲染，我们想要使用<code class="eh mv mw mx ku b">&lt;BrowserRouter&gt;</code>。</p><h2 id="33a0" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">客户端渲染</h2><p id="5acd" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">下面的服务器代码为浏览器提供了呈现SPA所需的所有代码:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="8518" class="jp jq hu ku b fv ky kz l la lb">// server/server.js</span><span id="70c5" class="jp jq hu ku b fv mu kz l la lb">// ...</span><span id="9751" class="jp jq hu ku b fv mu kz l la lb">const buildPath = path.join(__dirname, '../', 'build');<br/>app.use('/', express.static(buildPath));<br/>app.use(express.static(__dirname));</span><span id="f3ca" class="jp jq hu ku b fv mu kz l la lb">// ...</span></pre><p id="1b64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码告诉服务器从构建文件夹向<code class="eh mv mw mx ku b">localhost:3000/</code>提供静态资产。</p><p id="ac8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如上面的文件结构所示，在构建文件夹中只有一个文件— <code class="eh mv mw mx ku b">main.bundle.js</code>。如果你在浏览器中输入<code class="eh mv mw mx ku b">localhost:3000/main.bundle.js</code>,你会看到一堆JavaScript，其中包含来自我们的<code class="eh mv mw mx ku b">shared</code>文件夹的代码，这些代码已经从ES6转到了JavaScript的早期版本。</p><p id="2267" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mv mw mx ku b">main.bundle.js</code>是由Webpack创建的。在<code class="eh mv mw mx ku b"><a class="ae lc" href="https://github.com/xiaoyunyang/isomorphic-router-demo/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">package.json</a></code>中，脚本已经被设置为在启动服务器之前执行构建，因此<code class="eh mv mw mx ku b">main.bundle.js</code>在我们每次启动服务器时都会被重新构建。</p><p id="3816" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建定义在我们的<code class="eh mv mw mx ku b">webpack.config.js</code>文件中，它将<code class="eh mv mw mx ku b">./client/main.js</code>定义为构建的条目。</p><p id="b084" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mv mw mx ku b">main.js</code>而它所使用的一切都被捆绑成<code class="eh mv mw mx ku b">main.bundle.js</code>。以下是<code class="eh mv mw mx ku b">main.js</code>的代码:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="e178" class="jp jq hu ku b fv ky kz l la lb">// client/main.js</span><span id="8ef5" class="jp jq hu ku b fv mu kz l la lb">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import { BrowserRouter } from 'react-router-dom';<br/>import App from '../shared/App';</span><span id="73cc" class="jp jq hu ku b fv mu kz l la lb">const renderRouter = Component =&gt; {<br/>  ReactDOM.hydrate(<br/>    &lt;BrowserRouter&gt;<br/>      &lt;Component /&gt;<br/>    &lt;/BrowserRouter&gt;, document.getElementById('root')<br/>  );<br/>};</span><span id="399f" class="jp jq hu ku b fv mu kz l la lb">renderRouter(App);</span></pre><p id="ea2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能注意到的第一件事是使用了<code class="eh mv mw mx ku b">ReactDOM.hydrate</code>而不是<code class="eh mv mw mx ku b">ReactDOM.render</code>。这是因为我们希望将客户端呈现的应用程序附加到服务器呈现的HTML的<code class="eh mv mw mx ku b">root</code> div。虽然我们使用React v16的应用程序将与<code class="eh mv mw mx ku b">ReactDOM.render</code>一起工作，但React会给你一个警告，告诉你:“<em class="nn"> ReactDOM.render()将在React v17中停止工作。如果您希望React附加到服务器HTML </em>，请用ReactDOM.hydrate()替换ReactDOM.render()调用</p><p id="c777" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还记得我之前说过的<code class="eh mv mw mx ku b">&lt;HTML&gt;</code>组件是服务器端呈现的HTML和客户端呈现的应用程序之间的纽带吗？</p><p id="d98d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">服务器使用<code class="eh mv mw mx ku b">&lt;HTML&gt;</code>来呈现初始加载的HTML，它创建一个<code class="eh mv mw mx ku b">root</code> div并在脚本标签中动态加载<code class="eh mv mw mx ku b">main.bundle.js</code>。<strong class="it hv">这就是这个同构app的工作原理！</strong></p><figure class="kp kq kr ks fq mz"><div class="bz el l di"><div class="nl nm l"/></div></figure><h2 id="f464" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">运行中的同构应用</h2><p id="d10a" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">使用<code class="eh mv mw mx ku b">npm start</code>启动应用程序后，在浏览器地址栏中键入<code class="eh mv mw mx ku b">localhost:3000</code>，按enter键，在浏览器标签中页面加载轮旋转一点后，您将看到主页被渲染。</p><p id="7f29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">页面加载轮旋转表明服务器已经做了一些工作来传递这个页面给你。如果你点击了导航栏上的<strong class="it hv">关于</strong>和<strong class="it hv"> Foo </strong>，你会看到“关于”页面和“未找到”页面加载，而浏览器标签中没有任何页面加载轮旋转。这告诉您SPA模式已经启动，并且正在处理基于点击事件的页面导航。事实上，当您停止服务器时，应用程序甚至可以运行。继续从终端停止服务器，看看您仍然可以像以前一样点击加载页面…但是有一点不同:</p><figure class="kp kq kr ks fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff no"><img src="../Images/d44afbfda62c9a76998a9c2d26dcc8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9cPA3m3UcebFalloBJ0vQ.png"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek">Home Page with Server Stopped</figcaption></figure><p id="eea5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您看到的不是来自服务器的消息和随机引用，而是“正在加载”这个词。</p><p id="8521" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是故意的。我试图让这款应用变得更有趣，每当你通过客户端应用TopNav导航到主页，或者直接从服务器加载时，它都会向主页发送一段随机的励志名言。</p><p id="1975" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也是为了演示现代web应用程序中的一种常见设计模式，通过这种模式，页面内容的一部分是在页面通过从API的异步获取加载之后加载的。</p><p id="4bad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mv mw mx ku b">&lt;Home&gt;</code>组件在挂载后立即从两个API端点获取一些数据。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="2e89" class="jp jq hu ku b fv ky kz l la lb">// shared/components/Home.js</span><span id="c848" class="jp jq hu ku b fv mu kz l la lb">import React from 'react';<br/>import fetch from 'isomorphic-fetch';</span><span id="852f" class="jp jq hu ku b fv mu kz l la lb">class Home extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      resHello: 'Loading...',<br/>      resQuote: 'Loading...'<br/>    };<br/>  }<br/>  componentDidMount() {<br/>    // Get hello message<br/>    this.callApi('<a class="ae lc" href="http://localhost:3000/api/hello'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/hello'</a>)<br/>      .then(res =&gt; this.setState({ resHello: res.express }))<br/>      .catch(err =&gt; console.log(err));</span><span id="c483" class="jp jq hu ku b fv mu kz l la lb">    // Get random quote<br/>    const rand = Math.random();<br/>    this.callApi(`<a class="ae lc" href="http://localhost:3000/api/quote/${rand}`" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/quote/${rand}`</a>)<br/>      .then(res =&gt; this.setState({ resQuote: res.express }))<br/>      .catch(err =&gt; console.log(err));<br/>    }<br/>    callApi = async function (endpoint) {<br/>      const response = await fetch(endpoint);<br/>      const body = await response.json();<br/>      <br/>      if (response.status !== 200) throw Error(body.message);<br/>      return body;<br/>  }<br/>  render() {<br/>    console.log('rendering: Home');<br/>    return (<br/>      &lt;div className="container"&gt;<br/>        &lt;h1&gt;Home page&lt;/h1&gt;<br/>        &lt;h6&gt;<br/>          {`Message from the server: ${this.state.resHello}`}<br/>        &lt;/h6&gt;<br/>        &lt;h5&gt;Random Quote&lt;/h5&gt;<br/>        &lt;blockquote&gt;<br/>          {this.state.resQuote}<br/>        &lt;/blockquote&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="dcbf" class="jp jq hu ku b fv mu kz l la lb">export default Home;</span></pre><p id="0ec9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">负责向这些API端点交付数据的服务器代码如下所示:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="7e20" class="jp jq hu ku b fv ky kz l la lb">// server/server.js</span><span id="3eff" class="jp jq hu ku b fv mu kz l la lb">import apiVersion1 from './api/api1';</span><span id="598f" class="jp jq hu ku b fv mu kz l la lb">// ... <br/>app.use('/api', apiVersion1);</span><span id="b4e0" class="jp jq hu ku b fv mu kz l la lb">// ...</span></pre><p id="06f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有这里:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="f889" class="jp jq hu ku b fv ky kz l la lb">// server/api/api1.js</span><span id="e95a" class="jp jq hu ku b fv mu kz l la lb">import express from 'express';</span><span id="b0b8" class="jp jq hu ku b fv mu kz l la lb">const api = express.Router();</span><span id="dd40" class="jp jq hu ku b fv mu kz l la lb">// const quotes = ... too long to write it out here</span><span id="5ea9" class="jp jq hu ku b fv mu kz l la lb">api.get('/quote/:rand', (req, res) =&gt; {<br/>  const rand = parseFloat(req.params.rand);<br/>  if (Number.isNaN(rand)) {<br/>    res.send({ express: 'Bad request.' });<br/>    return;<br/>  }<br/>  const randomQuote = quotes[randomInd(rand)];<br/>  res.send({ express: `${randomQuote}` });<br/>});</span><span id="79cc" class="jp jq hu ku b fv mu kz l la lb">module.exports = api;</span></pre><p id="1d03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了简单起见，我将<code class="eh mv mw mx ku b">quotes</code> JSON直接硬编码在api代码中，但是您可以将引号放在<code class="eh mv mw mx ku b">quotes.json</code>文件中或存储在数据库中，并使用express中间件在使用前获取它们。</p></div><div class="ab cl ld le hc lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hn ho hp hq hr"><h1 id="9b0e" class="lk jq hu bd jr ll lm ln jv lo lp lq jz lr ls lt kc lu lv lw kf lx ly lz ki ma dt translated">底线</h1><p id="1861" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">同构的web应用程序支持网页的服务器端渲染和动态渲染。这为开发您的web应用程序提供了很大的灵活性，并获得了很好的用户界面以及良好的SEO和快速的加载时间。但是权力越大，责任越大。作为web开发人员，我们必须决定如何将我们的web应用程序划分成更小的同构应用程序、spa或服务器呈现页面。我们必须决定在浏览器中动态呈现什么，以及只在服务器端做什么，这取决于什么对我们正在构建的应用程序更有意义。</p><h2 id="afc1" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">感谢阅读！</h2><p id="710d" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">同样，这是同构启动项目的回购:</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="4deb" class="jp jq hu ku b fv ky kz l la lb"><a class="ae lc" href="https://github.com/xiaoyunyang/isomorphic-router-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/xiaoyunyang/isomorphic-router-demo</a></span></pre><p id="2fbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我阅读了许多教程来设置这个项目的最新和最大的堆栈。repo的自述文件中提供了属性。</p><p id="3cb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这篇文章和starter project可以帮助更多的人理解一个同构web app背后的动机和概念，并开始使用它。</p><figure class="kp kq kr ks fq mz"><div class="bz el l di"><div class="np nm l"/></div></figure></div></div>    
</body>
</html>