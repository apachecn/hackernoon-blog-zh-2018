<html>
<head>
<title>How to Redux with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何还原和反应</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-redux-with-react-836ed6d85330?source=collection_archive---------2-----------------------#2018-03-08">https://medium.com/hackernoon/how-to-redux-with-react-836ed6d85330?source=collection_archive---------2-----------------------#2018-03-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/18f54bce05bdea59b447d3e9db35977f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpaqVMW2RjQAg9cFHcX1pw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Official redux logo from <a class="ae jg" href="https://github.com/reactjs/redux/tree/master/logo" rel="noopener ugc nofollow" target="_blank">https://github.com/reactjs/redux/tree/master/logo</a></figcaption></figure><blockquote class="jh ji jj"><p id="b4a7" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">先决条件:读者已经知道JavaScript和React。如果没有，请先阅读<a class="ae jg" rel="noopener" href="/prolanceer/how-to-be-a-frontend-engineer-tips-tricks-utility-belt-a69b2fea1124">这个</a>。这是对React前端工程的更新。</p></blockquote></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><p id="6565" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">根据<a class="ae jg" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">官方文档</a>，<a class="ae jg" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>是<strong class="jn hv">可预测的</strong>状态容器，用于<a class="ae jg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>应用。</p><p id="d55d" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">首先，让我们从一个为什么开始。它主要有三个方面:</p><ol class=""><li id="e2b8" class="kt ku hu jn b jo jp js jt kq kv kr kw ks kx ki ky kz la lb dt translated">纯函数</li><li id="d77f" class="kt ku hu jn b jo lc js ld kq le kr lf ks lg ki ky kz la lb dt translated">深度不可知的状态订阅</li><li id="c2c8" class="kt ku hu jn b jo lc js ld kq le kr lf ks lg ki ky kz la lb dt translated">易于测试</li></ol><h2 id="b4e2" class="lh li hu bd lj lk ll lm ln lo lp lq lr kq ls lt lu kr lv lw lx ks ly lz ma mb dt translated">纯函数</h2><p id="85db" class="pw-post-body-paragraph jk jl hu jn b jo mc jq jr js md ju jv kq me jy jz kr mf kc kd ks mg kg kh ki hn dt translated"><strong class="jn hv">定义:</strong>只对传入的参数进行操作且没有副作用的函数是纯函数。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/a3347731618010489b1a812e810e84fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*JFDqwFBo1NAhs0MDRNihmA.png"/></div></figure><p id="fb9c" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">在数学上，我们有<code class="eh mm mn mo mp b">sin(x)</code>。在JavaScript中，我们有，</p><pre class="mi mj mk ml fq mq mp mr ms aw mt dt"><span id="899a" class="lh li hu mp b fv mu mv l mw mx">const sum = (a, b) =&gt; a + b;</span></pre><p id="c0d6" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">因为<code class="eh mm mn mo mp b">sum</code>函数只处理传入的输入，给定的参数是相同的，它将产生相同的输出，而不管我们调用它的次数或条件。</p><p id="be79" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">如在，<code class="eh mm mn mo mp b">sum(4, 5)</code>将永远回到9。一次又一次。没有失败。</p><p id="d5b0" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">就像<code class="eh mm mn mo mp b">sin(x)</code>我们的<code class="eh mm mn mo mp b">sum(x, y)</code>是<strong class="jn hv">可预测的</strong>。</p><h2 id="3e39" class="lh li hu bd lj lk ll lm ln lo lp lq lr kq ls lt lu kr lv lw lx ks ly lz ma mb dt translated">如何适用于redux？</h2><p id="f0ac" class="pw-post-body-paragraph jk jl hu jn b jo mc jq jr js md ju jv kq me jy jz kr mf kc kd ks mg kg kh ki hn dt translated">Redux基于这样一个理念，即应用程序状态应该只有一个真实的来源，无论是UI状态(如哪个选项卡是活动的)还是数据状态(如用户配置文件详细信息):</p><pre class="mi mj mk ml fq mq mp mr ms aw mt dt"><span id="0cb3" class="lh li hu mp b fv mu mv l mw mx">{<br/>    first_name: 'John',<br/>    last_name: 'Doe',<br/>    age: 28',<br/>}</span></pre><p id="2201" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">所有这些数据都被redux保留在一个闭包中，redux称之为<code class="eh mm mn mo mp b"><strong class="jn hv">store</strong></code>。它还为我们提供了创建该商店的配方，即<code class="eh mm mn mo mp b">createStore(x)</code>。</p><p id="4d0f" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated"><code class="eh mm mn mo mp b">createStore</code>函数接受另一个函数<code class="eh mm mn mo mp b">x</code>作为参数。传入的函数负责返回应用程序在该时间点的状态，然后保存在存储中。</p><p id="645c" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">这个传入的函数被称为<code class="eh mm mn mo mp b"><strong class="jn hv">reducer</strong></code>。</p><p id="6759" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">这是一个有效的(但不完全有用的)缩减函数:</p><pre class="mi mj mk ml fq mq mp mr ms aw mt dt"><span id="4531" class="lh li hu mp b fv mu mv l mw mx">export default function reducer(state={}, action) {<br/>    return state;<br/>}</span></pre><p id="a157" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">Redux有这个<code class="eh mm mn mo mp b">actions</code>的概念。动作是一个普通的老式JavaScript对象，其形状如下:</p><pre class="mi mj mk ml fq mq mp mr ms aw mt dt"><span id="9afe" class="lh li hu mp b fv mu mv l mw mx">{<br/>    type: 'SOME_NAME',<br/>    payload: 'SOME FREE FORM DATA'<br/>}</span></pre><p id="71ab" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">例如，假设我们有一个微博站点，一个用户发布了一些内容。结果操作可能是这样的:</p><pre class="mi mj mk ml fq mq mp mr ms aw mt dt"><span id="4c0a" class="lh li hu mp b fv mu mv l mw mx">{<br/>    type: 'Add_USER_POST',<br/>    payload: {<br/>        content: 'A quick brown fox jumped over the lazy dog',<br/>    }<br/>}</span></pre><p id="b548" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">现在，这个动作被传递到<code class="eh mm mn mo mp b">reducer</code>中，以根据<code class="eh mm mn mo mp b">action</code>中传递的来得出更新后的状态。</p><p id="d8c0" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">为了处理它，让我们将我们的<code class="eh mm mn mo mp b">reducer</code>更新为:</p><pre class="mi mj mk ml fq mq mp mr ms aw mt dt"><span id="c0f4" class="lh li hu mp b fv mu mv l mw mx">export default function reducer(state = {posts: []}, action) {<br/>    switch (action.type) {<br/>        case 'Add_USER_POST':<br/>            return {<br/>                ...state,<br/>                posts: [<br/>                    ...state.posts, <br/>                    {<br/>                        content: action.payload.content,<br/>                    }<br/>                ]<br/>            };</span><span id="14cd" class="lh li hu mp b fv my mv l mw mx">        default:<br/>            return state;<br/>    }<br/>}</span></pre><p id="ea19" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">首先，我们在默认状态中添加了一个默认属性<code class="eh mm mn mo mp b">posts</code>，并用<code class="eh mm mn mo mp b">[]</code>初始化它。</p><p id="c993" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">接下来，我们简单地添加了一个开启<code class="eh mm mn mo mp b">action.type</code>的<code class="eh mm mn mo mp b">switch-case</code>模块。因为我们的动作有一个类型<code class="eh mm mn mo mp b">Add_USER_POST</code>，它将被我们的reducer的<code class="eh mm mn mo mp b">switch-case</code>中的第一个case截获，它将返回一个由我们现有状态组成的新对象，并将新添加的post添加到posts数组中。</p><p id="b935" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">这个返回的对象将被添加到存储中。</p><p id="a84e" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">这里需要注意的一点是，商店只能通过调度一个动作来更新。</p><p id="096f" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">你的App调度一个<code class="eh mm mn mo mp b">action</code>，它被传入<code class="eh mm mn mo mp b">reducer</code>；<code class="eh mm mn mo mp b">reducer</code>返回状态的新实例；商店通知你的应用程序，它可以根据需要开始重新渲染。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/977fe6032a905200e81e6b6a71669c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*fY_69_TNZDKD-72RffuqBA.png"/></div></figure><p id="7114" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated"><code class="eh mm mn mo mp b">store</code>公开了3个函数:<code class="eh mm mn mo mp b">dispatch</code>、<code class="eh mm mn mo mp b">getState</code>、&amp;、<code class="eh mm mn mo mp b">subscribe</code>。</p><p id="65c4" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated"><code class="eh mm mn mo mp b">dispatch</code>顾名思义，调度由reducer消耗的动作。</p><p id="fb48" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated"><code class="eh mm mn mo mp b">getState</code>返回此时你的应用状态的快照。</p><p id="026a" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated"><code class="eh mm mn mo mp b">subscribe</code>接受每次修改/更新状态树时触发的回调函数。</p><p id="aa2d" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">这些由特定于UI库的绑定使用，以处理到应用程序桥的redux。对于<code class="eh mm mn mo mp b">React</code>，推荐绑定为<code class="eh mm mn mo mp b">react-redux</code>。</p><p id="8de1" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">假设我们有一个呈现帖子列表的<code class="eh mm mn mo mp b">Posts</code>组件。我们是这样写的:</p><pre class="mi mj mk ml fq mq mp mr ms aw mt dt"><span id="c02f" class="lh li hu mp b fv mu mv l mw mx">import React, { Component } from 'react';<br/>import { connect } from 'react-redux';</span><span id="63fd" class="lh li hu mp b fv my mv l mw mx">class Posts extends Component {<br/>    render() {<br/>        const posts = this.props.posts.map((post, i) =&gt; (<br/>            &lt;li key={i}&gt;<br/>                {post.content}<br/>            &lt;/li&gt;<br/>        ));<br/>        return (<br/>            &lt;h3&gt;Posts&lt;/h3&gt;<br/>            &lt;ul&gt;<br/>                {posts}<br/>            &lt;/ul&gt;<br/>        )<br/>    }<br/>}</span><span id="880a" class="lh li hu mp b fv my mv l mw mx">const mapState = state =&gt; ({<br/>    posts: state.posts,<br/>});</span><span id="c958" class="lh li hu mp b fv my mv l mw mx">const mapDispatch = dispatch =&gt; ({});</span><span id="5d9c" class="lh li hu mp b fv my mv l mw mx">export default connect(<br/>    mapState,<br/>    mapDispatch<br/>)(Posts);</span></pre><p id="66c3" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">正如您所看到的，组件<code class="eh mm mn mo mp b">Posts</code>只是接收帖子列表作为道具，并按照接收到的内容进行渲染。</p><p id="702f" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">我们定义了两个函数:<code class="eh mm mn mo mp b">mapState</code> &amp; <code class="eh mm mn mo mp b">mapProps</code>，并将它们作为回调传递给<code class="eh mm mn mo mp b">connect</code>。</p><p id="8a6b" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated"><code class="eh mm mn mo mp b">connect</code>执行<code class="eh mm mn mo mp b">getState</code>并将当前状态快照提供给<code class="eh mm mn mo mp b">mapState</code>作为参数；</p><p id="1431" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">然后它将<code class="eh mm mn mo mp b">dispatch</code>函数作为参数传递给<code class="eh mm mn mo mp b">mapDispatch</code>，最后将<code class="eh mm mn mo mp b">Posts</code>组件传递给由<code class="eh mm mn mo mp b">connect(x, y)</code>调用返回的函数。</p><p id="d88d" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">在内部，它订阅状态更改并将数据一直传递给组件，以查看是否需要重新呈现。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><p id="36ca" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">有人可能会说，对于一个简单的应用程序来说，这是太多的工作，单一的真实来源可以在一些顶级组件中以纯粹的状态反应来实现，并将其作为道具传递下去。</p><p id="1ca1" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">但是，随着应用程序的增长，您会添加数十个组件，并且每次都需要将数据从顶层根一直传递到叶组件。不用说，它会很快变得很麻烦。</p><p id="7875" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">Redux允许我们从任何深度订阅状态树的任何部分。</p><h2 id="e0ab" class="lh li hu bd lj lk ll lm ln lo lp lq lr kq ls lt lu kr lv lw lx ks ly lz ma mb dt translated">深度不可知的状态订阅</h2><p id="e108" class="pw-post-body-paragraph jk jl hu jn b jo mc jq jr js md ju jv kq me jy jz kr mf kc kd ks mg kg kh ki hn dt translated">正如我们已经看到的，我们的<code class="eh mm mn mo mp b">Posts</code>组件可以简单地订阅商店中的<code class="eh mm mn mo mp b">posts</code>属性。</p><p id="d563" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated"><code class="eh mm mn mo mp b">Posts</code>组件与其父组件完全没有关系；因为它可以在n级深度中，并且它的逻辑或者它的父/呈现组件的逻辑将不会改变。</p><p id="9d81" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">假设您有一个呈现一个<code class="eh mm mn mo mp b">SearchBar</code>的搜索特性，这个特性最终会呈现一组<code class="eh mm mn mo mp b">SearchItems</code>组件。无论是<code class="eh mm mn mo mp b">&lt;SearchBar/&gt;</code> &amp; <code class="eh mm mn mo mp b">&lt;SearchItems/&gt;</code>都可以直接订阅商店。</p><p id="7aa4" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">明天，可能需要将搜索移到<code class="eh mm mn mo mp b">Posts</code>组件中，除了CSS的变化，组件层次结构方面，我们要做的就是剪切粘贴。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff na"><img src="../Images/f3a42ad240c088f43ec5ded895f33a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*nccecl-GPweSCe63Z_kDGw.png"/></div></figure><h2 id="2e12" class="lh li hu bd lj lk ll lm ln lo lp lq lr kq ls lt lu kr lv lw lx ks ly lz ma mb dt translated">易于测试</h2><p id="8006" class="pw-post-body-paragraph jk jl hu jn b jo mc jq jr js md ju jv kq me jy jz kr mf kc kd ks mg kg kh ki hn dt translated">因为reducers都是纯函数，所以当我们为它们编写单元测试时，不需要太多的努力。</p><p id="3961" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">只需传入<code class="eh mm mn mo mp b">action</code>并期待返回一个状态快照。您的应用程序逻辑现在可以进行全面的单元测试，因此是防弹的。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><p id="3d2b" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">乘坐redux在<a class="ae jg" href="https://stackblitz.com/edit/learning-redux-1nkg" rel="noopener ugc nofollow" target="_blank"> stackblitz </a>转一圈。或者，在这里玩嵌入(向下滚动直到结束)。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><p id="c605" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">感谢阅读。</p><p id="348a" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">如果你认为这是值得的，请鼓掌吧:)</p><p id="614e" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh ki hn dt translated">在LinkedIn<a class="ae jg" href="https://www.linkedin.com/in/rohanbagchi/" rel="noopener ugc nofollow" target="_blank">上找到我或者回复我的评论。</a></p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="nd nc l"/></div></figure></div></div>    
</body>
</html>