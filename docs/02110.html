<html>
<head>
<title>Real-time API Monitoring Using GO and Pusher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GO和Pusher进行实时API监控</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/real-time-api-monitoring-using-go-and-pusher-4e57c4e80cac?source=collection_archive---------8-----------------------#2018-03-08">https://medium.com/hackernoon/real-time-api-monitoring-using-go-and-pusher-4e57c4e80cac?source=collection_archive---------8-----------------------#2018-03-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a0f09ae0d92b19ea2f26fcfc495ca93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkRPNOGl8xDtiqOsUTKgTg.jpeg"/></div></div></figure><blockquote class="jc jd je"><p id="9f4d" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">披露:<a class="ae ke" href="https://goo.gl/52hnDL" rel="noopener ugc nofollow" target="_blank">为开发者提供实时API的Pusher </a>，此前曾赞助过黑客Noon。</p><p id="985a" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">阅读本教程需要对Go和JavaScript有一个基本的了解。</p></blockquote><p id="561a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">REST是一种流行的架构风格，用于在web上的计算机系统之间提供标准，使系统之间的通信更加容易。它主要被API用来向其他需要数据的系统提供数据。</p><p id="91f4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">有时，API的提供者想要监控它的使用。监控API有助于提供有用的信息，例如哪些端点被最频繁地调用，或者哪些区域是使用请求IP地址的最大受众。这些信息可以用来优化API。</p><p id="03b5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在本文中，我们将使用Pusher实现对用GoLang构建的小型API的实时监控。下面是它最终应该是什么样子的预览:</p><figure class="kj kk kl km fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ki"><img src="../Images/4a9036a697db0b42b7fecd2462077925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uxk2Dhe1apJP8iKvRbmh0A.gif"/></div></div></figure><h1 id="6fd5" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">要求</h1><p id="eb6e" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">要阅读本文，您需要以下内容:</p><ul class=""><li id="8700" class="lq lr hu ji b jj jk jn jo kf ls kg lt kh lu kd lv lw lx ly dt translated">您选择的IDE，例如<a class="ae ke" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>。</li><li id="5445" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated"><a class="ae ke" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">转到</a>安装在你的电脑上。</li><li id="990e" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated">GoLang基础知识。</li><li id="5775" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated">JavaScript (ES6语法)和jQuery的基础知识。</li><li id="203e" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated">使用CLI工具或终端的基本知识。</li></ul><p id="acf4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">一旦你具备了以上所有要求，我们就开始吧。</p><h1 id="065e" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">建立我们的代码库</h1><p id="316e" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">为了简单起见，我们将使用已经编写好的GoLang CRUD API，它可以在<a class="ae ke" href="https://github.com/neoighodaro/go-pusher-api-monitor/tree/master/api-goggles" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。我们将分叉这个库，并按照<strong class="ji hv"> README.md </strong>安装指南来设置它。</p><p id="4519" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">接下来，我们将在API项目中设置Pusher。Pusher是一种为我们的web和移动应用程序提供实时功能的简单实现的服务。我们将在本文中使用它，为我们的API monitor仪表板提供实时更新。</p><p id="4eaf" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们前往Pusher.com，如果你还没有一个免费账户，你可以<a class="ae ke" href="https://pusher.com/signup?plan=sandbox" rel="noopener ugc nofollow" target="_blank">创建一个。在</a><a class="ae ke" href="https://dashboard.pusher.com/" rel="noopener ugc nofollow" target="_blank">仪表板</a>上，创建一个新应用并复制应用凭证(应用ID、密钥、密码和集群)。我们将在API中使用这些凭证。</p><p id="6795" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">现在我们有了Pusher应用程序，我们将通过运行以下命令来安装Pusher Go库:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="644d" class="mj ko hu mf b fv mk ml l mm mn">$ go get github.com/pusher/pusher-http-go</span></pre><h1 id="4a1c" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">监控我们的API</h1><p id="d828" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">到目前为止，我们已经建立了一个功能性的CRUD API，现在我们将实现对它的监控调用。在本文中，我们将监控:</p><ul class=""><li id="2c45" class="lq lr hu ji b jj jk jn jo kf ls kg lt kh lu kd lv lw lx ly dt translated">被调用的端点的详细信息包括名称、请求类型(GET、POST等)和URL。</li><li id="29ca" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated">对于每个对端点的调用，我们还会注意到:</li><li id="d1c2" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated">请求IP地址删除，</li><li id="c236" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated">特定呼叫的响应状态代码。</li></ul><p id="f84f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">既然我们已经定义了要监控的内容，我们将开始创建模型来跟踪我们获取的数据。</p><h1 id="bd5a" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">创建监控模型</h1><p id="43a5" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">基于我们上面的规范，我们将创建两个新的模型文件<code class="eh mo mp mq mf b">EndPoints.go</code>和<code class="eh mo mp mq mf b">EndPointCalls.go</code>。正如在基础API中所使用的，我们将使用<a class="ae ke" href="http://jinzhu.me/gorm/" rel="noopener ugc nofollow" target="_blank">GORM</a>(GoLang ORM)来管理数据存储。</p><blockquote class="jc jd je"><p id="23be" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu">💡我们的新模型文件将存在于models目录中，并属于models包。</em></p></blockquote><p id="3f3f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在<code class="eh mo mp mq mf b">EndPoints.go</code>中，我们将定义<code class="eh mo mp mq mf b">EndPoints</code>对象和一个保存端点的方法:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="0e39" class="mj ko hu mf b fv mk ml l mm mn">package models</span><span id="2fd3" class="mj ko hu mf b fv mr ml l mm mn">import (<br/>    "github.com/jinzhu/gorm"<br/>)</span><span id="4a1e" class="mj ko hu mf b fv mr ml l mm mn">// EndPoints - endpoint model<br/>type EndPoints struct {<br/>    gorm.Model<br/>    Name, URL string<br/>    Type      string          `gorm:"DEFAULT:'GET'"`<br/>    Calls     []EndPointCalls `gorm:"ForeignKey:EndPointID"`<br/>}</span><span id="8148" class="mj ko hu mf b fv mr ml l mm mn">// SaveOrCreate - save endpoint called<br/>func (ep EndPoints) SaveOrCreate() EndPoints {<br/>    db.FirstOrCreate(&amp;ep, ep)<br/>    return ep<br/>}</span></pre><p id="f929" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在上面的代码块中，我们的模型没有重新初始化GORM实例<code class="eh mo mp mq mf b">db</code>，但是它被使用了。这是因为在<code class="eh mo mp mq mf b">Movies.go</code>文件中定义的实例对于包的所有成员都是全局的，所以它可以被<code class="eh mo mp mq mf b">package models</code>的所有成员引用和使用。</p><blockquote class="jc jd je"><p id="1cf8" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu">💡我们的端点模型有一个属性</em> <code class="eh mo mp mq mf b"><em class="hu">Calls</em></code> <em class="hu">，它是一个</em> <code class="eh mo mp mq mf b"><em class="hu">EndPointCalls</em></code> <em class="hu">对象的数组。该属性表示</em><a class="ae ke" href="http://jinzhu.me/gorm/associations.html#has-many" rel="noopener ugc nofollow" target="_blank"><em class="hu"/></a><em class="hu"/><code class="eh mo mp mq mf b"><em class="hu">EndPoints</em></code><em class="hu"/><code class="eh mo mp mq mf b"><em class="hu">EndPointCalls</em></code><em class="hu">之间的一对多关系。有关模型关联和关系的更多信息，请参见GORM </em> <a class="ae ke" href="http://jinzhu.me/gorm/associations.html" rel="noopener ugc nofollow" target="_blank"> <em class="hu">文档</em> </a> <em class="hu">。</em></p></blockquote><p id="c98b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">接下来，我们将在<code class="eh mo mp mq mf b">EndPointCalls.go</code>文件中填充<code class="eh mo mp mq mf b">EndPointCalls</code>模型的模型定义和方法:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="8d49" class="mj ko hu mf b fv mk ml l mm mn">package models</span><span id="40c1" class="mj ko hu mf b fv mr ml l mm mn">import (<br/>    "github.com/jinzhu/gorm"<br/>    "github.com/kataras/iris"<br/>)</span><span id="48b4" class="mj ko hu mf b fv mr ml l mm mn">// EndPointCalls - Object for storing endpoints call details<br/>type EndPointCalls struct {<br/>    gorm.Model<br/>    EndPointID   uint `gorm:"index;not null"`<br/>    RequestIP    string<br/>    ResponseCode int<br/>}</span><span id="a2b9" class="mj ko hu mf b fv mr ml l mm mn">// SaveCall - Save the call details of an endpoint<br/>func (ep EndPoints) SaveCall(context iris.Context) EndPointCalls {<br/>    epCall := EndPointCalls{<br/>        EndPointID:   ep.ID,<br/>        RequestIP:    context.RemoteAddr(),<br/>        ResponseCode: context.GetStatusCode(),<br/>    }</span><span id="137e" class="mj ko hu mf b fv mr ml l mm mn">    db.Create(&amp;epCall)<br/>    <br/>    return epCall<br/>}</span></pre><p id="7dc4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">如上所示，我们的<code class="eh mo mp mq mf b">EndPointCalls</code>模型定义了一个<code class="eh mo mp mq mf b">SaveCall</code>方法，它存储了一个现有<code class="eh mo mp mq mf b">EndPoint</code>对象的请求IP地址和响应代码。</p><p id="c83f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最后，我们将更新<code class="eh mo mp mq mf b">index.go</code>文件中的模型迁移，以包含我们的新模型:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="7b3f" class="mj ko hu mf b fv mk ml l mm mn">// index.go<br/>// ...</span><span id="20c7" class="mj ko hu mf b fv mr ml l mm mn">func main() {<br/>    // ...</span><span id="b1fc" class="mj ko hu mf b fv mr ml l mm mn">    // Initialize ORM and auto migrate models<br/>    db, _ := gorm.Open("sqlite3", "./db/gorm.db")<br/>    db.AutoMigrate(&amp;models.Movies{}, &amp;models.EndPoints{}, &amp;models.EndPointCalls{})</span><span id="ea3a" class="mj ko hu mf b fv mr ml l mm mn">    // ...<br/>}</span></pre><h1 id="a81f" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">保存用于监控的端点数据</h1><p id="ec84" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">使用我们新创建的模型，我们将编辑<code class="eh mo mp mq mf b">MoviesController.go</code>文件，以便在端点被调用时保存相关数据。</p><p id="b80c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">为此，我们将向<code class="eh mo mp mq mf b">MoviesController.go</code>添加一个私有的助手方法，它将保存模型的端点数据。请看下文:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="995c" class="mj ko hu mf b fv mk ml l mm mn">// MoviesController.go<br/>// ...</span><span id="34f7" class="mj ko hu mf b fv mr ml l mm mn">func (m MoviesController) saveEndpointCall(name string) {<br/>    endpoint := models.EndPoints{<br/>        Name: name,<br/>        URL:  m.Cntx.Path(),<br/>        Type: m.Cntx.Request().Method,<br/>    }</span><span id="10ec" class="mj ko hu mf b fv mr ml l mm mn">    endpoint = endpoint.SaveOrCreate()<br/>    endpointCall := endpoint.SaveCall(m.Cntx)<br/>}</span></pre><p id="6f30" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><code class="eh mo mp mq mf b">saveEndpointCall</code>方法将端点的名称作为参数。使用控制器的<code class="eh mo mp mq mf b">iris.Context</code>实例，它读取并保存端点路径和请求方法。</p><p id="a21f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">现在这个帮助器方法可用了，我们将在<code class="eh mo mp mq mf b">MoviesController.go</code>文件中的每个端点方法中调用它:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="2cc6" class="mj ko hu mf b fv mk ml l mm mn">// MoviesController.go<br/>// ...</span><span id="b97e" class="mj ko hu mf b fv mr ml l mm mn">// Get - get a list of all available movies<br/>func (m MoviesController) Get() {<br/>    movie := models.Movies{}<br/>    movies := movie.Get()</span><span id="0616" class="mj ko hu mf b fv mr ml l mm mn">    go m.saveEndpointCall("Movies List")<br/>    m.Cntx.JSON(iris.Map{"status": "success", "data": movies})<br/>}</span><span id="22d0" class="mj ko hu mf b fv mr ml l mm mn">// GetByID - Get movie by ID<br/>func (m MoviesController) GetByID(ID int64) {<br/>    movie := models.Movies{}<br/>    movie = movie.GetByID(ID)<br/>    if !movie.Validate() {<br/>        msg := fmt.Sprintf("Movie with ID: %v not found", ID)<br/>        m.Cntx.StatusCode(iris.StatusNotFound)<br/>        m.Cntx.JSON(iris.Map{"status": "error", "message": msg})<br/>    } else {<br/>        m.Cntx.JSON(iris.Map{"status": "success", "data": movie})<br/>    }</span><span id="b55a" class="mj ko hu mf b fv mr ml l mm mn">    name := fmt.Sprintf("Single Movie with ID: %v Retrieval", ID)<br/>    go m.saveEndpointCall(name)<br/>}</span><span id="0aed" class="mj ko hu mf b fv mr ml l mm mn">// ...</span></pre><p id="c627" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">如上面的代码片段所示，在每个CRUD方法中都将调用<code class="eh mo mp mq mf b">saveEndpointCall</code>助手方法。</p><blockquote class="jc jd je"><p id="fc49" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu">💡将</em> <code class="eh mo mp mq mf b"><em class="hu">saveEndpointCall</em></code> <em class="hu">方法称为</em><a class="ae ke" href="https://golangbot.com/goroutines/" rel="noopener ugc nofollow" target="_blank"><em class="hu">Goroutine</em></a><em class="hu">。以这种方式调用它会在端点方法执行的同时调用它，并允许我们的监控代码不会延迟或抑制API的响应。</em></p></blockquote><h1 id="521b" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">创建端点监控仪表板</h1><p id="e657" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">现在，我们已经实现了对API调用的监控，我们将在仪表板上显示我们积累的数据。</p><h1 id="e02a" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">注册我们的模板引擎</h1><p id="2593" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">GoLang框架Iris具有实现一系列模板引擎的能力，我们将充分利用这一点。</p><p id="bb3e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在本节中，我们将实现<strong class="ji hv">车把</strong>模板引擎，并且在我们的<code class="eh mo mp mq mf b">index.go</code>文件中，我们将把它注册到app实例:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="f79a" class="mj ko hu mf b fv mk ml l mm mn">// index.go<br/>package main</span><span id="e306" class="mj ko hu mf b fv mr ml l mm mn">import (<br/>    "goggles/controllers"<br/>    "goggles/models"<br/>    "github.com/jinzhu/gorm"<br/>    "github.com/kataras/iris"<br/>)</span><span id="20c4" class="mj ko hu mf b fv mr ml l mm mn">func main() {<br/>    app := iris.New()</span><span id="493c" class="mj ko hu mf b fv mr ml l mm mn">    tmpl := iris.Handlebars("./templates", ".html")  <br/>    app.RegisterView(tmpl)</span><span id="6213" class="mj ko hu mf b fv mr ml l mm mn">    // ...</span><span id="ac0d" class="mj ko hu mf b fv mr ml l mm mn">    app.Run(iris.Addr("127.0.0.1:1234"))<br/>}</span></pre><blockquote class="jc jd je"><p id="b658" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu">💡我们已经定义了我们的模板引擎(Handlebars)，来渲染包含在</em> <code class="eh mo mp mq mf b"><em class="hu">templates</em></code> <em class="hu">目录中的</em> <code class="eh mo mp mq mf b"><em class="hu">.html</em></code> <em class="hu">文件。</em></p></blockquote><h1 id="e7be" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">创建仪表板的路线和控制器</h1><p id="a6f4" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">既然我们已经将模板引擎注册到应用程序中，我们将在<code class="eh mo mp mq mf b">index.go</code>中添加一个路由来呈现我们的API monitor仪表板:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="bb24" class="mj ko hu mf b fv mk ml l mm mn">// index.go<br/>// ...</span><span id="2550" class="mj ko hu mf b fv mr ml l mm mn">func main() {<br/>    app := iris.New()</span><span id="7019" class="mj ko hu mf b fv mr ml l mm mn">    // ...</span><span id="3b36" class="mj ko hu mf b fv mr ml l mm mn">    app.Get("/admin/endpoints", func(ctx iris.Context) {<br/>        dashBoard := controllers.DashBoardController{Cntx: ctx}<br/>        dashBoard.ShowEndpoints()<br/>    })</span><span id="1253" class="mj ko hu mf b fv mr ml l mm mn">    app.Run(iris.Addr("127.0.0.1:1234"))<br/>}</span></pre><p id="21ad" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">上面，我们已经为路径/admin/endpoints添加了定义，我们打算在这里呈现API端点及其调用的详细信息。我们还指定路由应该由DashBoardController的ShowEndpoints方法处理。</p><p id="7dc1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">为了创建DashBoardController，我们将在controllers目录中创建一个DashBoardController.go文件。在我们的DashBoardController.go文件中，我们将定义DashBoardController对象及其ShowEndpoints方法:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="83fb" class="mj ko hu mf b fv mk ml l mm mn">// DashBoardController.go<br/>package controllers</span><span id="4c57" class="mj ko hu mf b fv mr ml l mm mn">import (<br/>    "goggles/models"<br/>    "github.com/kataras/iris"<br/>    "github.com/kataras/iris/mvc"<br/>)</span><span id="7916" class="mj ko hu mf b fv mr ml l mm mn">// DashBoardController - Controller object for Endpoints dashboard<br/>type DashBoardController struct {<br/>    mvc.BaseController<br/>    Cntx iris.Context<br/>}</span><span id="e4cf" class="mj ko hu mf b fv mr ml l mm mn">// ShowEndpoints - show list of endpoints<br/>func (d DashBoardController) ShowEndpoints() {<br/>    endpoints := (models.EndPoints{}).GetWithCallSummary()<br/>    d.Cntx.ViewData("endpoints", endpoints)<br/>    d.Cntx.View("endpoints.html")<br/>}</span></pre><p id="0c4a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在<code class="eh mo mp mq mf b">ShowEndpoints()</code>中，我们检索我们的端点和它们的呼叫摘要以供显示。然后我们使用<code class="eh mo mp mq mf b">d.Cntx.ViewData("endpoints", endpoints)</code>将这些数据传递给我们的视图，最后我们使用<code class="eh mo mp mq mf b">d.Cntx.View("endpoints.html")</code>呈现我们的视图文件<code class="eh mo mp mq mf b">templates/endpoints.html</code>。</p><h1 id="96f5" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">检索端点和呼叫摘要</h1><p id="830a" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">为了检索我们的端点列表和它们的调用摘要，我们将在<code class="eh mo mp mq mf b">EndPoints.go</code>文件中创建一个名为<code class="eh mo mp mq mf b">GetWithCallSummary</code>的方法。</p><p id="07e7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我们的<code class="eh mo mp mq mf b">GetWithCallSummary</code>方法应该返回端点和它们的调用摘要，以便显示。为此，我们将使用在<code class="eh mo mp mq mf b">EndPoints.go</code>文件中显示所需的属性定义一个集合对象<code class="eh mo mp mq mf b">EndPointWithCallSummary</code>:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="8f5e" class="mj ko hu mf b fv mk ml l mm mn">// EndPoints.go<br/>package models</span><span id="5d2d" class="mj ko hu mf b fv mr ml l mm mn">import (<br/>    "github.com/jinzhu/gorm"<br/>)</span><span id="9020" class="mj ko hu mf b fv mr ml l mm mn">// EndPoints - endpoint model<br/>type EndPoints struct {<br/>    gorm.Model<br/>    Name, URL string<br/>    Type      string          `gorm:"DEFAULT:'GET'"`<br/>    Calls     []EndPointCalls `gorm:"ForeignKey:EndPointID"`<br/>}</span><span id="968a" class="mj ko hu mf b fv mr ml l mm mn">// EndPointWithCallSummary - Endpoint with last call summary<br/>type EndPointWithCallSummary struct {<br/>    ID            uint<br/>    Name, URL     string<br/>    Type          string<br/>    LastStatus    int<br/>    NumRequests   int<br/>    LastRequester string<br/>}</span></pre><p id="d5c2" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">然后定义<code class="eh mo mp mq mf b">GetWithCallSummary</code>方法使用如下:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="2aef" class="mj ko hu mf b fv mk ml l mm mn">// EndPoints.go</span><span id="426c" class="mj ko hu mf b fv mr ml l mm mn">// ...</span><span id="1dde" class="mj ko hu mf b fv mr ml l mm mn">// GetWithCallSummary - get all endpoints with call summary details<br/>func (ep EndPoints) GetWithCallSummary() []EndPointWithCallSummary {<br/>    var eps []EndPoints<br/>    var epsWithDets []EndPointWithCallSummary</span><span id="5f5c" class="mj ko hu mf b fv mr ml l mm mn">    db.Preload("Calls").Find(&amp;eps)</span><span id="a4e4" class="mj ko hu mf b fv mr ml l mm mn">    for _, elem := range eps {<br/>        calls := elem.Calls<br/>        lastCall := calls[len(calls)-1:][0]</span><span id="5c93" class="mj ko hu mf b fv mr ml l mm mn">        newElem := EndPointWithCallSummary{<br/>            elem.ID,<br/>            elem.Name,<br/>            elem.URL,<br/>            elem.Type,<br/>            lastCall.ResponseCode,<br/>            len(calls),<br/>            lastCall.RequestIP,<br/>        }</span><span id="7fc1" class="mj ko hu mf b fv mr ml l mm mn">        epsWithDets = append(epsWithDets, newElem)<br/>    }</span><span id="2604" class="mj ko hu mf b fv mr ml l mm mn">    return epsWithDets<br/>}</span><span id="42ec" class="mj ko hu mf b fv mr ml l mm mn">// ...</span></pre><p id="482c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">上面，<code class="eh mo mp mq mf b">GetWithCallSummary</code>方法利用了<code class="eh mo mp mq mf b">EndPoints</code>的<code class="eh mo mp mq mf b">Calls</code>属性，该属性定义了它与<code class="eh mo mp mq mf b">EndPointCalls</code>的关系。当从数据库中检索端点列表时，我们使用<code class="eh mo mp mq mf b">db.Preload("Calls").Find(&amp;eps)</code>加载它的<code class="eh mo mp mq mf b">EndPointCalls</code>数据。</p><p id="dc82" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">有关GORM中的紧急加载的更多信息，请参见<a class="ae ke" href="http://jinzhu.me/gorm/crud.html#preloading-eager-loading" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="384b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><code class="eh mo mp mq mf b">GetWithCallSummary</code>初始化一个<code class="eh mo mp mq mf b">EndPointWithCallSummary</code>数组，并遍历从我们的数据库返回的<code class="eh mo mp mq mf b">EndPoints</code>对象来创建<code class="eh mo mp mq mf b">EndPointWithCallSummary</code>对象。</p><p id="4d2c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这些<code class="eh mo mp mq mf b">EndPointWithCallSummary</code>对象被附加到初始化的数组中并被返回。</p><blockquote class="jc jd je"><p id="0999" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu">💡</em> <code class="eh mo mp mq mf b"><em class="hu">EndPointWithCallSummary</em></code> <em class="hu">不是模型。它是一个集合对象，不需要在我们的数据库中有一个表。这就是为什么它没有自己的文件，也没有传递到</em> <code class="eh mo mp mq mf b"><em class="hu">index.go</em></code> <em class="hu">进行迁移。</em></p></blockquote><h1 id="57a8" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">实现仪表板和显示数据</h1><p id="e556" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">现在我们已经有了仪表板的路由、控制器和显示数据，我们将实现仪表板视图来实现端点及其摘要数据的简单列表显示。</p><p id="44d7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">让我们将<code class="eh mo mp mq mf b">templates/endpoints.html</code>更新为以下代码:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="c2d5" class="mj ko hu mf b fv mk ml l mm mn">&lt;!-- templates/endpoints.html --&gt;<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>    &lt;title&gt;Endpoints Monitor Dashboard&lt;/title&gt;<br/>    &lt;link rel="stylesheet" type="text/css" href="<a class="ae ke" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta.3/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta.3/css/bootstrap.min.css</a>" /&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div&gt;<br/>        &lt;nav class="navbar navbar-default navbar-static-top"&gt;<br/>            &lt;div class="container"&gt;<br/>                &lt;div class="navbar-header"&gt;<br/>                    &lt;a class="navbar-brand" href="<a class="ae ke" href="http://127.0.0.1:1234/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:1234/</a>"&gt;<br/>                        Goggles - A Real-Time API Monitor<br/>                    &lt;/a&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/nav&gt;<br/>        &lt;div class="container"&gt;<br/>            &lt;div class="row"&gt;<br/>                &lt;div class="col-xs-12 col-lg-12"&gt;<br/>                    &lt;div class="endpoints list-group"&gt;<br/>                        {{#each endpoints}}<br/>                            &lt;a id="endpoint-{{ID}}" href="#" class="list-group-item <br/>                            list-group-item-{{status_class LastStatus}}"&gt;<br/>                                &lt;strong&gt;{{name}}&lt;/strong&gt;<br/>                                &lt;span class="stats"&gt;<br/>                                    {{type}}: &lt;strong&gt;{{url}}&lt;/strong&gt; |<br/>                                    Last Status: &lt;span class="last_status"&gt;<br/>                                    {{LastStatus}}&lt;/span&gt; |<br/>                                    Times Called: &lt;span class="times_called"&gt;<br/>                                    {{NumRequests}}&lt;/span&gt; |<br/>                                    Last Request IP: &lt;span class="request_ip"&gt;<br/>                                    {{LastRequester}}&lt;/span&gt;<br/>                                &lt;/span&gt;<br/>                            &lt;/a&gt;<br/>                        {{/each}}<br/>                    &lt;/div&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="<a class="ae ke" href="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js</a>"&gt;&lt;/script&gt;<br/>    &lt;script src="<a class="ae ke" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta.3/js/bootstrap.min.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta.3/js/bootstrap.min.js</a>"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cf37" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">上面，我们使用<a class="ae ke" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>和把手模板引擎来呈现端点列表。我们还创建并使用了一个模板函数<code class="eh mo mp mq mf b">status_class</code>，根据他们最近的通话状态<code class="eh mo mp mq mf b">LastStatus</code>对我们的列表进行颜色编码。</p><p id="37f1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">初始化模板引擎后，我们在<code class="eh mo mp mq mf b">index.go</code>中定义了<code class="eh mo mp mq mf b">status_class</code>模板函数:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="1c40" class="mj ko hu mf b fv mk ml l mm mn">// index.go</span><span id="1053" class="mj ko hu mf b fv mr ml l mm mn">// ...</span><span id="7a22" class="mj ko hu mf b fv mr ml l mm mn">func main() {<br/>    app := iris.New()</span><span id="da4e" class="mj ko hu mf b fv mr ml l mm mn">    tmpl := iris.Handlebars("./templates", ".html")</span><span id="f74f" class="mj ko hu mf b fv mr ml l mm mn">    tmpl.AddFunc("status_class", func(status int) string {<br/>        if status &gt;= 200 &amp;&amp; status &lt; 300 {<br/>            return "success"<br/>        } else if status &gt;= 300 &amp;&amp; status &lt; 400 {<br/>            return "warning"<br/>        } else if status &gt;= 400 {<br/>            return "danger"<br/>        }<br/>        return "success"<br/>    })</span><span id="19cd" class="mj ko hu mf b fv mr ml l mm mn">    app.RegisterView(tmpl)<br/>}</span></pre><p id="996b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">然后，在我们的视图文件中，我们将该函数称为:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="bfd1" class="mj ko hu mf b fv mk ml l mm mn">class="list-group-item list-group-item-{{status_class LastStatus}}"</span></pre><blockquote class="jc jd je"><p id="9350" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu">💡上面的LastStatus是函数的参数。</em></p></blockquote><h1 id="da03" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">向我们的仪表板添加实时更新</h1><p id="8f1e" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">到目前为止，在本文中，我们已经监控了对API的调用，并通过仪表板显示了数据。我们现在将使用<a class="ae ke" href="http://pusher.com/" rel="noopener ugc nofollow" target="_blank">推送器</a>向我们的仪表板提供实时数据更新。</p><h1 id="baf3" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">从后端发送实时数据</h1><p id="2bd3" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">之前，我们安装了<a class="ae ke" href="https://github.com/pusher/pusher-http-go" rel="noopener ugc nofollow" target="_blank"> Pusher Go库</a>，我们将使用它在端点被调用时触发一个事件。在处理API请求的<code class="eh mo mp mq mf b">MoviesController.go</code>文件中，我们将初始化Pusher客户端:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="6544" class="mj ko hu mf b fv mk ml l mm mn">// MoviesController.go</span><span id="58e5" class="mj ko hu mf b fv mr ml l mm mn">    package controllers</span><span id="43a0" class="mj ko hu mf b fv mr ml l mm mn">    import (<br/>        // ...<br/>        "github.com/pusher/pusher-http-go"<br/>    )</span><span id="a5c3" class="mj ko hu mf b fv mr ml l mm mn">    // MoviesController - controller object to serve movie data<br/>    type MoviesController struct {<br/>        mvc.BaseController<br/>        Cntx iris.Context<br/>    }</span><span id="478b" class="mj ko hu mf b fv mr ml l mm mn">    var client = pusher.Client{<br/>        AppId:   "app_id",<br/>        Key:     "app_key",<br/>        Secret:  "app_secret",<br/>        Cluster: "app_cluster",<br/>    }</span><span id="fe96" class="mj ko hu mf b fv mr ml l mm mn">    // ...</span></pre><p id="eaa0" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这里，我们已经使用之前创建的应用程序中的凭证初始化了Pusher客户端。</p><blockquote class="jc jd je"><p id="2de9" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu"> ⚠️用你的app凭证替换</em> <code class="eh mo mp mq mf b"><em class="hu">app_id, app_key, app_secret and app_cluster</em></code> <em class="hu">。</em></p></blockquote><p id="f237" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">接下来，我们将使用Pusher客户端来触发一个事件，这将包括要在我们的视图中显示的端点数据。我们将在<code class="eh mo mp mq mf b">saveEndpointCall</code>方法中这样做，该方法记录一个端点及其调用:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="b1e3" class="mj ko hu mf b fv mk ml l mm mn">// MoviesController.go</span><span id="8a05" class="mj ko hu mf b fv mr ml l mm mn">    // ...</span><span id="36c2" class="mj ko hu mf b fv mr ml l mm mn">    func (m MoviesController) saveEndpointCall(name string) {<br/>        endpoint := models.EndPoints{<br/>            Name: name,<br/>            URL:  m.Cntx.Path(),<br/>            Type: m.Cntx.Request().Method,<br/>        }<br/>        endpoint = endpoint.SaveOrCreate()<br/>        endpointCall := endpoint.SaveCall(m.Cntx)<br/>        endpointWithCallSummary := models.EndPointWithCallSummary{<br/>            ID:            endpoint.ID,<br/>            Name:          endpoint.Name,<br/>            URL:           endpoint.URL,<br/>            Type:          endpoint.Type,<br/>            LastStatus:    endpointCall.ResponseCode,<br/>            NumRequests:   1,<br/>            LastRequester: endpointCall.RequestIP,<br/>        }</span><span id="6771" class="mj ko hu mf b fv mr ml l mm mn">        client.Trigger("goggles_channel", "new_endpoint_request", endpointWithCallSummary)<br/>    }</span></pre><p id="bb0e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">上面，我们从<code class="eh mo mp mq mf b">EndPoints</code>(端点)和<code class="eh mo mp mq mf b">EndPointCalls</code>创建了一个<code class="eh mo mp mq mf b">EndPointWithCallSummary</code>对象。该<code class="eh mo mp mq mf b">EndPointWithCallSummary</code>对象具有在仪表板上显示所需的所有数据，因此将被传递给Pusher进行传输。</p><h1 id="5c78" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">在仪表板上实时显示数据</h1><p id="1b51" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">为了显示端点的实时更新，我们将使用Pusher JavaScript客户端和jQuery库。</p><p id="d4b1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在我们的视图文件<code class="eh mo mp mq mf b">templates/endpoints.html</code>中，我们将首先使用我们应用程序的凭证导入并初始化一个Pusher实例:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="bd89" class="mj ko hu mf b fv mk ml l mm mn">&lt;!-- endpoints.html --&gt;<br/>    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;<br/>    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta.3/js/bootstrap.min.js"&gt;&lt;/script&gt;<br/>    &lt;script src="//js.pusher.com/4.1/pusher.min.js"&gt;&lt;/script&gt;<br/>    &lt;script&gt;<br/>      const pusher = new Pusher('app_id', {cluster: "app_cluster"});<br/>    &lt;/script&gt;</span></pre><blockquote class="jc jd je"><p id="b873" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu"> ⚠️用你的应用凭证中的值替换</em> <code class="eh mo mp mq mf b"><em class="hu">app_id and app_cluster</em></code> <em class="hu">。</em></p></blockquote><p id="428c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">接下来，我们将定义以下内容:</p><ul class=""><li id="e960" class="lq lr hu ji b jj jk jn jo kf ls kg lt kh lu kd lv lw lx ly dt translated">向视图添加新端点的模板。</li><li id="41af" class="lq lr hu ji b jj lz jn ma kf mb kg mc kh md kd lv lw lx ly dt translated">追加新端点并获取端点状态类的函数。</li></ul><p id="9438" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最后，我们将订阅<code class="eh mo mp mq mf b">goggles_channel</code>并监听<code class="eh mo mp mq mf b">new_endpoint_request</code>事件，在那里我们的端点更新将被传输:</p><pre class="kj kk kl km fq me mf mg mh aw mi dt"><span id="d169" class="mj ko hu mf b fv mk ml l mm mn">&lt;!-- endpoints.html --&gt;<br/>    &lt;script&gt;<br/>    // ...<br/><br/>    const channel = pusher.subscribe("goggles_channel");<br/><br/>    channel.bind('new_endpoint_request', function(data) {<br/>        let end_point_id = data.ID;<br/>        if ( $('#endpoint-' + end_point_id).length &gt; 0 ) {<br/>            let status_class = getItemStatusClass(data['LastStatus']),<br/>                endpoint     = $('#endpoint-' + end_point_id);<br/>            let calls = 1 * endpoint.find('span.times_called').text()<br/>            endpoint.find('span.last_status').text(data['LastStatus']);<br/>            endpoint.find('span.times_called').text( (calls + 1) )<br/>            endpoint.removeClass('list-group-item-success');<br/>            endpoint.removeClass('list-group-item-danger');<br/>            endpoint.removeClass('list-group-item-warning');<br/>            endpoint.addClass('list-group-item-' + status_class);<br/>        } else {<br/>            addNewEndPoint(data);<br/>        }<br/>    });<br/><br/>    // ...</span></pre><p id="975e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在<code class="eh mo mp mq mf b">new_endpoint_request</code>事件处理程序中，端点数据被分为更新场景(端点已经存在于仪表板上)或创建场景(创建并追加新的列表项)。</p><p id="fbdb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最后，您可以构建您的应用程序，当您运行它时，您应该会看到类似于我们在预览中看到的内容:</p><figure class="kj kk kl km fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ki"><img src="../Images/4a9036a697db0b42b7fecd2462077925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uxk2Dhe1apJP8iKvRbmh0A.gif"/></div></div></figure><h1 id="2280" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">结论</h1><p id="ae70" class="pw-post-body-paragraph jf jg hu ji b jj ll jl jm jn lm jp jq kf ln jt ju kg lo jx jy kh lp kb kc kd hn dt translated">在本文中，我们能够监控对REST API的实时请求，并演示Pusher如何与GoLang应用程序一起工作。</p><blockquote class="jc jd je"><p id="9802" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这篇文章最初出现在<a class="ae ke" href="https://blog.pusher.com/realtime-trade-platform-javascript-pusher/" rel="noopener ugc nofollow" target="_blank">推广者博客</a>上。</p></blockquote></div></div>    
</body>
</html>