<html>
<head>
<title>🔥 JavaScript Modules Worth Using 🔥</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🔥值得使用的JavaScript模块🔥</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascipt-modules-worth-using-9aa7301e41ac?source=collection_archive---------0-----------------------#2018-03-09">https://medium.com/hackernoon/javascipt-modules-worth-using-9aa7301e41ac?source=collection_archive---------0-----------------------#2018-03-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4a30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现自己反复使用的最有用的JavaScript模块的快速分类。</p><p id="a926" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一篇有见解的文章，重点关注通用模块和实用程序，我发现它们对NodeJS和前端JavaScript开发非常有价值。它不会是详尽无遗的，也不会包括任何特殊用途的模块，因为那些类型的<a class="ae jp" href="https://awesomelists.top/" rel="noopener ugc nofollow" target="_blank">牛逼列表</a>确实很牛逼，但往往有点势不可挡。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/4066012238e83dcf993b8563c3586714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ed4yEvBF4DmMJ1Es1p_hXw.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Yeahhh we all love npmmmmm huzzahhhhhh!!! (Image Credit: <a class="ae jp" href="http://blog.npmjs.org/post/161081169345/v500" rel="noopener ugc nofollow" target="_blank">npm</a>)</figcaption></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="1a7c" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">命令行工具</h1><p id="b12d" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">让我们从一些非常有用的命令行工具开始。</p><blockquote class="lq lr ls"><p id="1e81" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/sindresorhus/np" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">NP</strong></a>——更好的<code class="eh lx ly lz ma b">npm publish</code>。</p></blockquote><p id="d749" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是一个npm作者，我强烈推荐你去看看<a class="ae jp" href="https://github.com/sindresorhus/np" rel="noopener ugc nofollow" target="_blank"> np </a>，因为它让修改版本、添加git release标签和发布到npm的过程变得轻而易举，尤其是当你开始有很多模块需要维护的时候。同样值得注意的是<a class="ae jp" href="https://github.com/zeit/release" rel="noopener ugc nofollow" target="_blank">发布</a>由<a class="ae jp" href="https://zeit.co/" rel="noopener ugc nofollow" target="_blank"> Zeit </a>作为一个可靠的替代方案。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mb"><img src="../Images/4b87b74e9a97fd9da5dcaef38a1ab916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*64gMHXogmFze4Y1_RuESnw.gif"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Image Credit: <a class="ae jp" href="https://github.com/sindresorhus/np" rel="noopener ugc nofollow" target="_blank">np</a> by <a class="ae jp" href="https://sindresorhus.com/" rel="noopener ugc nofollow" target="_blank">Sindre Sorhus</a></figcaption></figure><blockquote class="lq lr ls"><p id="083f" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://yarnpkg.com" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">纱</strong> </a> -兼容<code class="eh lx ly lz ma b">npm</code>的更好的包管理器。</p></blockquote><p id="24a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然npm <a class="ae jp" href="http://blog.npmjs.org/post/161081169345/v500" rel="noopener ugc nofollow" target="_blank"> v5 </a>比以前的版本快了很多，但我仍然认为<a class="ae jp" href="https://yarnpkg.com" rel="noopener ugc nofollow" target="_blank"> yarn </a>在速度和一致性方面比npm更适合本地开发。无论哪种方式，你都是在使用同一个npm模块数据库，我觉得这两者之间没有明显的赢家。您应该选择最适合您的项目需求的包管理器。</p><p id="1c68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，作为2018年的JS开发者，我会确保你至少熟悉<code class="eh lx ly lz ma b">npm</code>和<code class="eh lx ly lz ma b">yarn</code>，并且在它们之间切换自如。</p><blockquote class="lq lr ls"><p id="8fd6" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">更漂亮</strong></a>——一个固执己见的代码格式化者。</p></blockquote><p id="8e5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Prettier通过解析您的代码，并根据自己的规则(考虑到最大行长度，在必要时换行)重新打印代码，来强制实现一致的风格。</p><p id="3f71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我喜欢eslint，尤其是长期使用JavaScript T2标准风格的T3，但是像T4漂亮T5和T6 gofmt T7这样的自动代码格式化器背后的想法无疑是有吸引力的。</p><p id="398c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为开发人员，我们花费了太多的时间和精力来担心代码的表示和样式，而<a class="ae jp" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">beautiful</a>减轻了对这些思考过程的需求，并允许您专注于您正在编写的内容，而不是如何编写。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mc"><img src="../Images/28da93e0d89f939998b58f2f5c7f4f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MvKCbHX2-GM4ERUd1UljA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Image Credit: <a class="ae jp" href="https://github.com/prettier/prettier" rel="noopener ugc nofollow" target="_blank">prettier</a></figcaption></figure><blockquote class="lq lr ls"><p id="5c1e" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://zeit.co/now" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">现在</strong></a>——极其简单的部署。</p></blockquote><p id="679d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就简单性、可靠性和特性集而言，Now绝对是当今最好的免费部署系统。它非常适合测试静态和动态部署，并且在您需要更多服务器时可以很好地扩展。Aaaaaaaaaand我提到过它是免费的吗？！</p><p id="03a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它与Node.js和js支持的webapps配合得非常好。我也强烈推荐看看Zeit的其他产品，因为他们的团队是由社区中最好的JS开发者组成的。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mc"><img src="../Images/c5470d9a928a584a161782588cdafd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuTnNz8z_4pDz2YG0eqUAA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Image Credit: <a class="ae jp" href="https://zeit.co" rel="noopener ugc nofollow" target="_blank">Zeit</a></figcaption></figure><blockquote class="lq lr ls"><p id="392f" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated">用于记录高质量终端会话的免费工具。</p></blockquote><p id="4e3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">参见我之前的博客文章“让你的代码变得漂亮”中关于如何利用asciinema制作高质量代码演示的分解。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="552e" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">承诺</h1><p id="b4c5" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">这一节确实值得写一整篇文章，尤其是现在<a class="ae jp" href="https://zeit.co/blog/async-and-await" rel="noopener ugc nofollow" target="_blank">async&amp;wait</a>已经开始成为JavaScript并发编程事实上的标准范例。话虽如此，如果你还没有的话，我强烈推荐你去看看<a class="ae jp" href="https://sindresorhus.com/" rel="noopener ugc nofollow" target="_blank">辛德雷·索胡斯</a>‘卓越<a class="ae jp" href="https://github.com/sindresorhus/promise-fun" rel="noopener ugc nofollow" target="_blank">许诺-乐趣</a>模块集。我对这些模块唯一的不满是，它们可能无法与大多数前端工具链一起开箱即用，如<a class="ae jp" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>或<a class="ae jp" href="https://rollupjs.org" rel="noopener ugc nofollow" target="_blank"> rollup </a>。</p><p id="cd17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是一些最有用的宝石，它们在Node中处理承诺和异步风格的代码时非常突出:</p><blockquote class="lq lr ls"><p id="118f" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/sindresorhus/pify" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> pify </strong> </a> -承诺一个回调风格的函数。</p></blockquote><p id="0738" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多方法可以将函数从老派的回调风格转换成承诺风格，但是我发现<a class="ae jp" href="https://github.com/sindresorhus/pify" rel="noopener ugc nofollow" target="_blank"> pify </a>是最好的。它很小，并且有一些内置的<a class="ae jp" href="https://nodejs.org/api/util.html#util_util_promisify_original" rel="noopener ugc nofollow" target="_blank">util . promise rify</a>所缺乏的类似自动方法绑定的细节。</p><blockquote class="lq lr ls"><p id="2796" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/sindresorhus/p-map" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">p-Map</strong></a>-Map over promises并发。</p></blockquote><p id="e9dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并发性很好，但大多数时候，您希望对并行性设置一个实际的限制，无论是限制网络带宽还是计算资源。这才是<a class="ae jp" href="https://github.com/sindresorhus/p-map" rel="noopener ugc nofollow" target="_blank"> p图</a>真正出彩的地方。我99%的时间都用它来替代<code class="eh lx ly lz ma b">Promise.all(…)</code>，它不支持限制并行。</p><p id="2d63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我知道<a class="ae jp" href="https://github.com/sindresorhus/p-map" rel="noopener ugc nofollow" target="_blank"> p-map </a>之前，我创建了自己的版本<a class="ae jp" href="https://github.com/transitive-bullshit/async-await-parallel" rel="noopener ugc nofollow" target="_blank"> async-await-parallel </a>，但是你应该使用<a class="ae jp" href="https://github.com/sindresorhus/p-map" rel="noopener ugc nofollow" target="_blank"> p-map </a>因为它更好。😛</p><blockquote class="lq lr ls"><p id="fb05" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/sindresorhus/p-retry" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">p-重试</strong> </a> -重试承诺返回或异步功能。</p></blockquote><p id="1407" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我通常用<a class="ae jp" href="https://github.com/sindresorhus/p-retry" rel="noopener ugc nofollow" target="_blank"> p-retry </a>包装任何HTTP请求和外部服务调用，以增加它们的基本健壮性。与<a class="ae jp" href="https://github.com/sindresorhus/p-map" rel="noopener ugc nofollow" target="_blank"> p-map </a>相结合，您可以用受控的并行性处理大批量的外部请求，而不必太担心偶然的传输错误、套接字挂起或服务器超时。</p><blockquote class="lq lr ls"><p id="dfbf" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/sindresorhus/p-timeout" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> p-timeout </strong> </a> -在指定的时间后超时一个承诺。</p></blockquote><p id="a75b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了<a class="ae jp" href="https://github.com/sindresorhus/p-retry" rel="noopener ugc nofollow" target="_blank"> p-retry </a>之外，<a class="ae jp" href="https://github.com/sindresorhus/p-timeout" rel="noopener ugc nofollow" target="_blank"> p-timeout </a>也是与第三方API和服务可靠协作所必需的。你也可以指定一个可选的回退，因为经常返回<em class="lt">一些东西</em>比无限期挂起或者过了很长时间才返回要好。</p><blockquote class="lq lr ls"><p id="9a2d" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/transitive-bullshit/p-cache" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> p缓存</strong> </a>或<a class="ae jp" href="https://github.com/sindresorhus/p-memoize" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> p内存</strong></a>——通过<a class="ae jp" href="https://github.com/isaacs/node-lru-cache" rel="noopener ugc nofollow" target="_blank"> LRU缓存</a>来内存异步函数的结果。</p></blockquote><p id="8ad6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多这些有前途的实用程序的目标让我想起了许多架构健壮的微服务，其中每个外部依赖都可以用一个支持重试、超时、缓存、断路器、回退等的公共接口来处理。</p><p id="b4af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">功能的适度退化通常比让系统不堪重负或完全不响应更好，所以如果你不太熟悉微服务，请查看它们，看看它们的设计决策是否也能帮助提高你的承诺处理能力。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="c825" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">擦</h1><p id="6e10" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">有很多很棒的抓取工具，其中一些运行在原始的HTML上，比如<a class="ae jp" href="https://github.com/cheeriojs/cheerio" rel="noopener ugc nofollow" target="_blank"> cheerio </a>，还有一些模拟了完整的浏览器环境，比如<a class="ae jp" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>。您决定使用什么实际上取决于您的用例，因为使用原始HTML更快、更轻量级，而自动化无头浏览器更健壮，但代价是入门更重。</p><blockquote class="lq lr ls"><p id="4758" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/cheeriojs/cheerio" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">cheerio</strong></a>——专为服务器设计的内核<code class="eh lx ly lz ma b">jQuery</code>的快速、灵活和精简实施。</p></blockquote><p id="9d92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Cheerio对于快速和肮脏的网页抓取非常有用，在这种情况下，您只需要对原始HTML进行操作。它为遍历和操作HTML文档提供了健壮的类似jQuery的语法。Cheerio与下面的<a class="ae jp" href="https://github.com/request/request-promise-native" rel="noopener ugc nofollow" target="_blank"> request-promise-native </a>配合得特别好，用于获取远程HTML文档。</p><blockquote class="lq lr ls"><p id="356b" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/></a>-无头Chrome节点API</p></blockquote><p id="4254" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与cheerio不同，puppeteer是一个自动化无头chrome实例的包装器，这对于使用现代JS驱动的spa非常有用。由于您使用的是Chrome本身，它还具有同类最佳的解析/呈现/脚本一致性支持。无头Chrome仍然相对较新，但它可能会在未来几年逐步淘汰旧的方法，如<a class="ae jp" href="http://phantomjs.org/" rel="noopener ugc nofollow" target="_blank"> PhantomJS </a>。</p><p id="f42b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你需要忠实地抓取网站，自动化基于网络的工作流程，或捕捉截图，<a class="ae jp" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>是一个明显的赢家，只会随着时间的推移越来越受欢迎。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="a04a" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">节点. js</h1><blockquote class="lq lr ls"><p id="d8e5" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/rolodato/dotenv-safe" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">dotenv-safe</strong></a><strong class="it hv">-</strong>从<code class="eh lx ly lz ma b">.env</code>加载环境变量并确保它们都存在。</p></blockquote><p id="e18b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个模块扩展了非常流行的<a class="ae jp" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>模块，通过一个<code class="eh lx ly lz ma b">.env.example</code>文件来加强预期环境变量的存在。像最初一样，它为Node提供了快速、安全和健壮的环境变量支持。</p><p id="2840" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它还可以很好地与Zeit的<a class="ae jp" href="https://zeit.co/now" rel="noopener ugc nofollow" target="_blank"> now.sh </a>部署一起使用<a class="ae jp" href="https://zeit.co/blog/now-json" rel="noopener ugc nofollow" target="_blank"> now.json </a>中设置的<code class="eh lx ly lz ma b">”dotenv”: true</code>选项。</p><blockquote class="lq lr ls"><p id="3c4f" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">请求</strong> </a>和<a class="ae jp" href="https://github.com/request/request-promise-native" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">请求-承诺-原生</strong> </a> -简化HTTP请求客户端。</p></blockquote><p id="a623" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">发出HTTP请求是一个极其常见的操作，我这里的goto模块是<a class="ae jp" href="https://github.com/request/request-promise-native" rel="noopener ugc nofollow" target="_blank"> request-promise-native </a>，它用原生ES6 promise支持包装了原来的<a class="ae jp" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank"> request </a>模块。95%的时间我希望等待一个承诺的HTTP请求的结果。其余5%的时间我想直接处理响应流，在这种情况下，我使用底层的<a class="ae jp" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank">请求</a>模块，放弃承诺支持。</p><p id="b021" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了保证健壮性，我经常会将<a class="ae jp" href="https://github.com/request/request-promise-native" rel="noopener ugc nofollow" target="_blank">请求-承诺-本机</a>调用包装在<a class="ae jp" href="https://github.com/sindresorhus/p-retry" rel="noopener ugc nofollow" target="_blank">p-重试</a>、<a class="ae jp" href="https://github.com/sindresorhus/p-timeout" rel="noopener ugc nofollow" target="_blank">p-超时</a>和<a class="ae jp" href="https://github.com/transitive-bullshit/p-cache" rel="noopener ugc nofollow" target="_blank">p-缓存</a>的某种组合中。</p><p id="7f7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样值得一提的是，<a class="ae jp" href="https://github.com/sindresorhus/got" rel="noopener ugc nofollow" target="_blank">得到了</a>作为<a class="ae jp" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank">请求</a>的更新替代，并内置了承诺支持，尽管我个人并没有怎么用过。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="md me l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Example of downloading an HTML document with <a class="ae jp" href="https://github.com/request/request-promise-native" rel="noopener ugc nofollow" target="_blank">request-promise-native</a>.</figcaption></figure><blockquote class="lq lr ls"><p id="8063" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/tj/consolidate.js" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/></a>-模板引擎为节点合并库。</p></blockquote><p id="53ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Consolidate非常适合处理任何类型的后端模板(电子邮件、推文、原始html等)。).我通常使用<a class="ae jp" href="http://handlebarsjs.com/" rel="noopener ugc nofollow" target="_blank">手柄</a>作为我选择的模板引擎，但无论如何，我总是将我的模板使用包装在<a class="ae jp" href="https://github.com/tj/consolidate.js" rel="noopener ugc nofollow" target="_blank"> consolidate </a>中，因为它提供了一个简单的&amp;一致的模板接口，而不管您决定使用哪个模板引擎。</p><p id="84ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，我在<a class="ae jp" href="https://github.com/transitive-bullshit/create-react-library" rel="noopener ugc nofollow" target="_blank"> create-react-library </a>中使用consolidate来呈现带有库特定变量的样板文件模板。</p><blockquote class="lq lr ls"><p id="5e52" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/sindresorhus/execa" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">execa</strong></a>——更好的<code class="eh lx ly lz ma b">child_process</code>。</p></blockquote><p id="e2f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您需要运行shell命令或生成一个子进程，这非常有用。</p><blockquote class="lq lr ls"><p id="6cd0" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/jprichardson/node-fs-extra" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> fs-extra </strong> </a> -有附加方法和承诺支持的更好的<code class="eh lx ly lz ma b">fs</code>。</p></blockquote><p id="a7df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现自己很少再直接使用<code class="eh lx ly lz ma b">fs</code>了。试试<code class="eh lx ly lz ma b">fs-extra</code>就不会回头了。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="8ef9" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">数学</h1><p id="2611" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">D3 (数据驱动文档)是一个流行的数据可视化和动画前端库。它还包含了一些最好的用于普通数学运算的<em class="lt">独立软件包</em>，我发现自己总是选择它们而不是其他模块。</p><blockquote class="lq lr ls"><p id="26b5" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/d3/d3-random" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">D3——随机</strong></a>——从各种分布中生成随机数。</p></blockquote><p id="9c9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当<code class="eh lx ly lz ma b">Math.random</code>不行的时候，给<a class="ae jp" href="https://github.com/d3/d3-random" rel="noopener ugc nofollow" target="_blank"> d3-random </a>一个尝试。它支持从不同的常见分布中取样，包括均匀分布、正态分布和指数分布。</p><blockquote class="lq lr ls"><p id="94ee" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/d3/d3-ease" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">D3-缓动</strong> </a> -平滑动画的缓动功能。</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://github.com/d3/d3-ease"><div class="fe ff mf"><img src="../Images/eb49c6cee003c69f65dd491132fc84f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uham3g52-ohGs0d8OZ42xQ.png"/></div></a><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Image Credit: <a class="ae jp" href="https://github.com/d3/d3-ease" rel="noopener ugc nofollow" target="_blank">d3-ease</a></figcaption></figure><blockquote class="lq lr ls"><p id="8516" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/d3/d3-interpolate" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">D3-插值</strong> </a> -插值数字、颜色、字符串、数组、对象，无论什么！</p></blockquote><p id="5d6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个模块为两个任意值之间的混合提供了多种插值方法。值可以是数字、颜色、字符串、数组，甚至是深度嵌套的对象。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="0110" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">测试</h1><blockquote class="lq lr ls"><p id="2a7a" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> ava </strong> </a> -牛逼的JS试跑者。</p></blockquote><p id="a457" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">毫不奇怪，我的Node.js单元测试运行程序是Sindre Sorhus创建的另一个工具。艾娃是一个较新的单元测试运行程序，它吸取了<a class="ae jp" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>、<a class="ae jp" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank">胶带</a>、<a class="ae jp" href="http://chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>和其他JS测试运行程序的许多优点，并把它们捆绑在一起，成为一个优质的项目，并带有明智的默认设置，这些默认设置“只是工作”。</p><p id="04d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得注意的是，默认情况下，艾娃的测试是并行运行的，对于像数据库测试这样的用例，单元测试运行的顺序可能很重要，您可以在文件级禁用它。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mg"><img src="../Images/8657b87a7ab86461beee2242ef1bb339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*C5QnzBhjtNaffYeda9RMFA.gif"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Image Credit: <a class="ae jp" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank">ava</a></figcaption></figure><blockquote class="lq lr ls"><p id="3510" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/node-nock/nock" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">nock</strong></a>——HTTP嘲讽与期望库。</p></blockquote><p id="faaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Nock非常适合测试独立执行HTTP请求的模块。如果您的节点模块发出HTTP请求，并且您想要提供适当的单元测试，那么<a class="ae jp" href="https://github.com/node-nock/nock" rel="noopener ugc nofollow" target="_blank"> nock </a>就是您要走的路。</p><blockquote class="lq lr ls"><p id="887e" class="ir is lt it b iu iv iw ix iy iz ja jb lu jd je jf lv jh ji jj lw jl jm jn jo hn dt translated"><a class="ae jp" href="http://sinonjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> sinon </strong> </a> -用于JS测试的函数间谍、存根和模拟。</p></blockquote><p id="c3bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Sinon是一个非常有用的工具库，通过利用依赖注入来编写隔离测试。它应该是每个节点开发人员工具带的一部分。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="1f15" class="kn ko hu bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">包扎</h1><p id="2a6b" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">我希望你已经发现这个分解是有帮助的，即使它只是学习你以前不知道的一个质量模块。我认识很多有抱负的、经验丰富的开发人员，他们最终推出了自己的解决方案来解决常见问题，这本身就是一种有用的实践，但是知道什么时候应该使用高质量的现有解决方案也是很好的，而不是不断地重新发明轮子。</p><p id="bbd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">NPM模块库的规模和范围是前所未有的，我认为这是JavaScript相对于其他编程语言的最大优势之一。作为一名开发人员，你越善于利用npm模块，你就会变得越快越有效率。像这样的高阶“软”技能是成为<a class="ae jp" href="http://antirez.com/news/112" rel="noopener ugc nofollow" target="_blank">神话中的10x程序员</a>的标志之一。</p><p id="13f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有没有我漏掉的最喜欢的npm模块？在评论里分享你喜欢的模块让我知道！❤️</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h2 id="4a80" class="mh ko hu bd kp mi mj mk kt ml mm mn kx jc mo mp lb jg mq mr lf jk ms mt lj mu dt translated">在你走之前…</h2><p id="e375" class="pw-post-body-paragraph ir is hu it b iu ll iw ix iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo hn dt translated">如果您喜欢这篇文章，请点击👏下面，并与他人分享，这样他们也可以享受它。</p></div></div>    
</body>
</html>