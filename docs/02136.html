<html>
<head>
<title>Stop deploying Laravel manually, steal this Docker configuration instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止手动部署Laravel，改用这个Docker配置</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/stop-deploying-laravel-manually-steal-this-docker-configuration-instead-da9ecf24cd2e?source=collection_archive---------1-----------------------#2018-03-09">https://medium.com/hackernoon/stop-deploying-laravel-manually-steal-this-docker-configuration-instead-da9ecf24cd2e?source=collection_archive---------1-----------------------#2018-03-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0203" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jp">感谢光临！您可能还想查看之前这篇关于在AWS上部署Laravel的文章</em></strong><a class="ae jq" href="https://hackernoon.com/laravel-on-aws-a-reference-architecture-a680755130d0" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"><em class="jp"/></strong></a><strong class="it hv"><em class="jp">或者甚至使用下面的表格下载这本书！</em>T13】</strong></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jy"><img src="../Images/95cbb406a6950ef338e41d44bf17e1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWCrOtVijQ8gqcEWKuWMBA.jpeg"/></div></div></figure><p id="8732" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们为web应用程序所做的事情…</p><p id="3043" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">抛开编码和测试不谈，我们为他们提供服务器，配置他们的数据库、搜索引擎、缓存引擎、工作人员、crons、队列，配置他们的web服务器，为他们获取SSL证书，为他们更新DNS，最后构建和部署他们。<br/>我们每天都这样做，所以希望我们可以轻松地设置它，这样我们就可以每天重新部署几次，而不用考虑太多！</p><p id="48d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为受人尊敬的开发人员，我们也不会为我们的web应用做一些事情:<br/> —我们不会点击AWS控制台试图记住我们上次是如何做的<br/> —我们不会SSH到一个虚拟机并到处运行<em class="jp"> apt-get installs </em>，试图记住我们上次是如何做的<em class="jp"> <br/> </em> —我们不会通过任何东西重新部署我们的应用，除了我们可以轻松回滚的单个命令</p><p id="033b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将为许多可能的人为错误铺平道路，使部署充满压力和风险，使我们的应用程序不稳定和潜在的不安全(哎哟)。</p><p id="ace5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，我们将脚本化和自动化。我们将把我们的配置提交为代码。我们将使用一个可重复的自我记录的过程，任何开发人员(包括我们自己)都可以接手，没有风险。我们将在以后的项目中使用相同的可重复过程，随着时间的推移改进它，增加它的可靠性，减少劳动力和部署错误。我们将尽可能多地自动化低商业价值的活动，让我们的公司变得更好。</p><p id="2cab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这本指南是给谁的？<br/> 本指南是为小型<a class="ae jq" href="https://hackernoon.com/tagged/tech" rel="noopener ugc nofollow" target="_blank">科技</a>公司设计的，这些公司可能已经手动完成了太多自己的部署，并且已经被淘汰了一两次。它非常适合任何想要开始使用AWS的团队，首先使用它的基本服务，然后逐渐增加复杂性。</p><p id="7337" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我用来在AWS上部署客户的Laravel应用程序的程序之一。希望这能对你的部署有所帮助。如果您的用例更复杂，或者您希望我指导您的开发人员了解devOps最佳实践，请来https://getlionel.com与我交谈</p><p id="4297" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于AWS，我们需要了解什么？<br/> 好消息是，对于一个只有少量后台服务(数据库、缓存、队列、文件存储和搜索引擎)的简单Laravel应用程序来说， 你不需要太了解AWS: <br/> —我们不会使用特定的网络(比如无法从互联网访问的私有子网)，所以我们将使用AWS帐户的默认VPC和公共子网<br/> —我们将在一台EC2服务器上部署所有服务，并使用S3进行文件存储。 因此，我们不必太担心其他AWS服务<br/> —我们将部署一个无状态的应用程序并将数据库备份到S3，因此我们不必担心EBS (EC2的持久存储选项)<br/> —将有一个单一的防火墙配置来设置<br/> —实际上，我们将做的大多数事情都可以移植到更便宜的托管提供商(除了S3文件存储，它可以在不同托管提供商的虚拟机上运行应用程序时单独使用)</p><p id="9e74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">为什么是Docker？<br/> </strong> <a class="ae jq" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>将是我们这篇文章的瑞士军刀。它将帮助我们配置服务器、配置(as-code)和协调我们的服务:</p><blockquote class="kf kg kh"><p id="29fa" class="ir is jp it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated"><strong class="it hv">服务器配置</strong>是一组为服务器准备适当的系统、数据和软件，并使其为网络运行做好准备的操作</p><p id="a780" class="ir is jp it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated"><strong class="it hv"> Configuration-as-code </strong>是一个DevOps实践，它提倡将应用配置作为代码存储在源代码存储库中</p><p id="92ba" class="ir is jp it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hn dt translated"><strong class="it hv">编排</strong>是计算机系统和服务的自动化安排、协调和管理</p></blockquote><p id="fc23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker本身不足以应对更复杂的情况(例如，如果我们有10多个微服务需要单独更新和扩展，运行在多台服务器上)。然而，我们这里的应用程序只有少量的后台服务，各种Docker工具是我们所需要的:<br/> —我们将使用<strong class="it hv"> Docker Machine </strong>直接从命令行将我们的EC2服务器配置到我们的AWS帐户中<br/> —我们将使用<strong class="it hv"> Docker images </strong>将我们的服务配置定义为代码<br/> —我们将使用<strong class="it hv"> Docker Compose </strong>将我们的服务编排在一起<br/> —我们最终将使用<strong class="it hv"> Docker</strong></p><p id="466f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第一步。用Docker Machine <br/> </strong>配置我们的服务器Docker Machine是一个工具，它通过一次性安装适当的Linux发行版和Docker守护进程来配置我们的服务器。它可以通过代表我们调用Amazon API来连接到AWS，并在我们的AWS帐户中创建一个EC2实例。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff km"><img src="../Images/c1fa9c4d35ae7cf16961944564ccdd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rr9dP55wRp4fzKKLSA0mOg.jpeg"/></div></div></figure><p id="8fcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里发生了什么！？<em class="jp"> <br/> — </em>首先，Docker Machine在我们的AWS帐户中创建了一个EC2实例，其大小由我们指定(t2.large)，并在我们指定的AWS区域中创建了一个EC2实例(us-east-1) <br/> —它还创建了一个安全组(实例级AWS防火墙)，允许任何流量进入端口80和443 <br/> —然后它安装了Docker守护程序，并将其配置为可通过端口2376远程访问。 使用它专门为这台机器创建的新TLS证书<br/> —它还创建了一个新的SSH密钥，并在服务器上安装了它的公共部分，同时将私有密钥保存在您的机器上。 端口22已经为SSH访问开放。你可以随时使用<em class="jp">进入你的机器</em></p><p id="97be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这已经是相当多的自动化工作了！</p><p id="9bf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您现在可以在<em class="jp"> ~/中查看Docker Machine将所有这些配置保存在本地机器上的位置/方式。码头工人/机器/机器</em>。有一个以您刚刚创建的Docker机器命名的新目录(<em class="jp"> laravel </em>此处)，包含上面提到的SSH密钥和TLS证书。<br/>然后，您可以使用命令<em class="jp"> docker-machine ls </em>查看通过Docker Machine创建的所有机器的列表。</p><p id="0f6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"><br/>尽管这可行，但这绝对不是一种在公司内共享秘密/SSH密钥的安全方式，Docker Machine还没有为此提供企业级的解决方案。Docker Machine不是提供大规模项目的解决方案，Terraform等更复杂的工具提供远程状态后端，以便与您的团队安全地共享配置。与此同时，如果你和一个小团队一起工作，并且想快速上手，Docker Machine正符合你的要求。<br/>编辑:我曾经在这里 写过关于共享Docker Machines  <a class="ae jq" href="https://hackernoon.com/finally-you-can-share-docker-machines-without-a-script-8f946d050f7" rel="noopener ugc nofollow" target="_blank"> <em class="jp"/></a></strong></p><p id="ba9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第二步。使用Docker <br/> </strong>配置我们的服务下一步是将我们的每个服务构建为单独的Docker映像，然后这些映像将作为单独的Docker容器运行。这里的好消息是，我们的大多数服务不需要特定的配置(数据库、缓存引擎、搜索引擎和队列)，因此我们可以开箱即用地使用他们的官方Docker映像！<br/>对于其余的(我们的Nginx服务器、Laravel应用程序、Laravel worker和cron)，我们将不得不从我们的源代码构建我们自己的Docker映像。<br/>我们通过编写描述图像如何构建的docker文件来实现这一点。我们将使用我们的代码提交这些docker文件，有效地实现配置即代码(yaaayy！)</p><p id="b3e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们的docker文件和配置文件的概述:</p><pre class="jr js jt ju fq kn ko kp kq aw kr dt"><span id="337c" class="ks kt hu ko b fv ku kv l kw kx">root of your Laravel app<br/>|--deploy<br/>|    |-- nginx<br/>|    |    |-- ssl<br/>|    |    |    +-- ssl.cert             # our SSL certificate<br/>|    |    |    +-- ssl.key              # our SSL certificate<br/>|    |    +-- default.conf              # our Nginx config <br/>|    |    +-- index.php<br/>|    |    +-- nginx.conf<br/>|    |    +-- robots.txt<br/>|    |-- cron<br/>|    |    +-- artisan-schedule-run      # our artisan scheduler<br/>|    |-- php-fpm<br/>|    |    +-- php-fpm.conf<br/>|    |    +-- php.ini                   # PHP configuration<br/>|    |    +-- www.conf<br/>+-- Dockerfile                          # our Laravel Dockerfile<br/>+-- Dockerfile-nginx                    # our Nginx Dockerfile<br/>+-- docker-compose.yml                  # Docker Compose file<br/>+-- docker-compose.env                  # our environment variables</span></pre><p id="d1b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来看看Nginx的配置(default.conf):</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">The only funny part here is<em class="lc"> </em><strong class="ak"><em class="lc">fastcgipass: app:9000</em></strong><em class="lc">, explanations below</em></figcaption></figure><p id="e42b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和Docker文件来使用我们的定制配置构建Nginx:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Just adding our config and static assets into the Nginx Docker image, that’s it</figcaption></figure><p id="f7ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于我们的Laravel应用程序工作人员和cron，我们使用一个Docker文件构建一个映像，并且我们将覆盖每个容器的Docker CMD。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">This Docker CMD will launch PHP-FPM and tail the Laravel logs into Docker logs</figcaption></figure><p id="eb79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第三步。Docker Compose是一个用Docker编排多容器应用程序的工具。在我们的例子中，我们将同时运行多达7个容器:<br/>—Laravel应用程序<br/> — Nginx作为PHP的反向代理——FPM<br/>—Redis作为缓存引擎和队列引擎<br/> — PostgreSQL或MySQL用于我们的数据库<br/> — Laravel worker在一个单独的容器中运行<br/> — Laravel cron也在另一个容器中运行<br/> —如果我们的应用程序需要的不仅仅是数据库原生搜索功能，最终运行ElasticSearch</strong></p><p id="df49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那我们为什么需要3个Laravel集装箱？它们都需要运行在相同的Laravel代码上，但是我们希望每个容器只运行一个进程:PHP-FPM、Laravel Artisan worker和cron。由于Docker在每个容器中只能启动一个进程，否则我们将不得不使用Docker中的进程控制系统来解决这个问题。不太干净。</p><p id="a48f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">在我们继续之前，有一些关于Docker Compose的概念我们需要在这一点上理解:<br/> — </em> <strong class="it hv"> <em class="jp">网络</em> </strong> <em class="jp"> : Docker Compose创建了一个</em> <strong class="it hv"> <em class="jp"> </em> </strong> <em class="jp">桥接网络，它是主机内部的私有网络，因此该网络上的容器可以通信。在幕后，Docker引擎创建必要的Linux桥、内部接口、iptables规则和主机路由来实现这种连接。<br/> — </em> <strong class="it hv"> <em class="jp">链接</em> </strong> <em class="jp">:容器可以通过链接相互连接。链接是Docker服务发现机制:这是如何将服务名解析为容器IP的。我们在Nginx配置中使用它来指向我们的PHP-FPM容器。<br/> — </em> <strong class="it hv"> <em class="jp">端口映射</em> </strong> <em class="jp">:默认情况下，一个端口只在当前容器上公开，链接到它的容器可以访问。为了向互联网公开它，并且假设我们的主机本身连接到互联网，Docker可以将容器端口映射到主机端口<br/> — </em> <strong class="it hv"> <em class="jp">环境变量</em> </strong> <em class="jp"> : Docker Compose使您能够在。yml文件将您需要的环境变量放在您的容器中。这很好，因为您可以在不同的环境(暂存、生产等)中部署相同的映像，而无需重建映像。<br/> — </em> <strong class="it hv"> <em class="jp">卷</em> </strong> <em class="jp">:默认情况下，删除Docker容器时，容器内写入的数据会丢失。可以通过使用Docker卷将数据持久化到主机上(我们将把这个用于数据库)<br/> — </em> <strong class="it hv"> <em class="jp">日志</em> </strong> <em class="jp"> : Docker Compose有几个日志记录驱动程序，其中之一是AWS CloudWatch。我们将把每个服务流日志直接发送到CloudWatch，只需要docker-compose.yml </em>中的几行代码</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">The Docker Compose file that rules all of our services</figcaption></figure><p id="7f57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们构建我们的应用程序吧！</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff ld"><img src="../Images/c2e953a16b27250ce1e44813a7ef37c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0ibDcnmkWmTWZAuy8Dhbw.png"/></div></div></figure><p id="c666" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们检查一下我们所有的图像都已经构建好了:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff ld"><img src="../Images/074f5c6e6a11706d34e512d9b0146e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYJHoPWJHt0dyHvdBo3bjA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Docker Compose default prefix for images is our current directory’s name</figcaption></figure><p id="22e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，在启动我们的应用程序之前，我们可以检查Docker Compose是否会使用适当的环境变量来执行我们的应用程序:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff ld"><img src="../Images/76a3848007e49197771184eaa2eae616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOteCjXi5pPZDutXfu2ypQ.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Docker Compose compiled our docker-compose.yml file by injecting environment variables and secrets from docker-compose.env</figcaption></figure><p id="a4c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看起来不错，现在让我们运行我们的应用程序:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff le"><img src="../Images/02cacf26c47a67014ffe9b3a8d008753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6f1K3C3JdAvocipCZwLspQ.png"/></div></div></figure><p id="a5d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们用<em class="jp">docker-machine IP laravel</em>检索我们的服务器公共IP……答对了！</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lf"><img src="../Images/be3b462ed5c1b8f6cfb14436a14bd638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElwurtsjwDmi3SCnZ5T1sg.png"/></div></div></figure><p id="4aac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个阶段，您可以带着<em class="jp"> Dockerfile </em>和<em class="jp"> docker-compose.yml </em>文件，将它们复制到您拥有的每个新Laravel项目的根目录，然后在几分钟内部署一个新项目……听起来如何！？</p><p id="ac8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来的步骤是将我们所有的日志集中到CloudWatch中，在我们的Nginx映像中设置自动更新和免费的SSL证书，并定期将我们的数据库备份到S3。</p><p id="37db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">嘿！您是愿意让我为您完成所有这些工作，还是愿意培训您的团队掌握Docker、AWS和devOps最佳实践？来和我聊聊</em><a class="ae jq" href="https://getlionel.com" rel="noopener ugc nofollow" target="_blank"><em class="jp">【https://getlionel.com】</em>T5】</a></p><p id="0e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第四步。(可选)将日志流式传输到CloudWatch<br/></strong>Docker-Compose提供了一个CloudWatch驱动程序，这样所有符合Docker标准输出的内容都可以流式传输到一个新的cloud watch日志组中。</p><p id="c695" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您所需要做的就是在创建时创建一个与EC2实例相关联的实例概要文件:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div></figure><p id="231d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并在<em class="jp"> docker-compose.yml </em>文件中取消对每个服务定义的日志记录指令的注释。例如:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Configuring AWS CloudWatch driver for Docker</figcaption></figure><p id="a270" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面将在您的CloudWatch仪表板中创建一个名为“laravel”的日志组，并开始在那里推送日志事件。一旦我们的所有服务都连接到CloudWatch，您将会看到:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lg"><img src="../Images/7b72bc16f73f337142d9f7a93ee99461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_oqJ0sss8A8LGnrIAzLow.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Logs for all of our services are centralised in CloudWatch</figcaption></figure><p id="33ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从那里，你可以使用CloudWatch的所有优点，比如设置警报和通知，而不必运行自己的ElasticSearch/Kibana堆栈。</p><p id="9ef2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第五步。(可选)设置SSL并将所有HTTP流量重定向到HTTPS <br/> </strong>您应该在第一个版本中就设置HTTPS，这样可以省去很多后续的麻烦。首先，我们将更新Nginx配置，将所有HTTP流量重定向到HTTPS:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Redirecting HTTP traffic to HTTPS and <a class="ae jq" href="http://www.laravelaws.com" rel="noopener ugc nofollow" target="_blank">www.laravelaws.com</a> to APEX</figcaption></figure><p id="8bc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们从Let's Encrypt订购SSL证书。让我们加密证书是免费的，有效期为3个月。我们不会在这里讨论如何设置Nginx来自动更新证书，但至少我们有一个解决方案可以在几分钟内获得免费证书:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">This script uses our AWS CLI using the default profile and an existing Route53 Hosted Zone for your domain</figcaption></figure><p id="906b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将文件<em class="jp"> fullchain.pem </em>(我们的证书)<em class="jp"> </em>和<em class="jp"> privkey.pem </em>(证书的私钥)复制到我们的<em class="jp"> deploy/nginx/ssl </em>目录中，并更新我们的Nginx Dockerfile文件以导入ssl证书:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kl jx l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Adding the certificates to our Nginx image</figcaption></figure><p id="5553" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重建您的Nginx映像并重新启动您的应用程序。使用cURL检查证书是否有效，以及到HTTPS的重定向是否按预期工作:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lh"><img src="../Images/8200eeb0acdcf4de8ba3d3eb191c5473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NhWBvITofqV_eY1l4OqoQ.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Nginx successfully forcing redirection to HTTPS</figcaption></figure><p id="7e45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以用Chrome检查证书是否有效:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff li"><img src="../Images/755fd40044265dc495985e61a3ace1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2pxFy5A4n-eO8s2WooqKw.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Nginx serving our Laravel application through HTTPS</figcaption></figure><p id="b252" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第六步。(可选)自动数据库备份</strong><br/>…我们将添加一个容器，每天定期将我们的数据库备份到S3。</p><p id="820a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">即将推出</em></p><p id="f411" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更进一步:(可选)在多个实例上扩展我们的应用，在RDS上托管我们的数据库，等等..哇，已经有很多工作自动化了！现在，如果我们想在AWS RDS上运行数据库，跨越多个工作人员，在多个服务器上自动扩展我们的应用程序，等等，该怎么办呢？<br/>除了仅仅使用Docker Machine和Docker Compose，我们还能走得更远吗？不完全是。Docker的集群解决方案是Docker Swarm，它正在失去吸引力，并被Kubernetes等更受欢迎的解决方案所取代。</strong></p><p id="8097" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，那是另一个时间，但在此期间，你可以阅读我关于Laravel和AWS的其他文章“<a class="ae jq" href="https://hackernoon.com/laravel-on-aws-a-reference-architecture-a680755130d0" rel="noopener ugc nofollow" target="_blank"> <em class="jp">如何使用CloudFormation </em> </a>在AWS上部署Laravel”和“<a class="ae jq" href="https://hackernoon.com/how-to-continuously-deploy-your-laravel-application-on-aws-7fc0f39c558e" rel="noopener ugc nofollow" target="_blank"> <em class="jp">如何在AWS上持续部署你的Laravel应用程序</em> </a>”。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><p id="7418" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">莱昂内尔是总部位于伦敦的初创公司Wi5的首席技术官，也是《面向未来的工程文化课程  <em class="jp">的作者。你可以在</em><a class="ae jq" href="https://getlionel.com" rel="noopener ugc nofollow" target="_blank"><em class="jp">https://getlionel.com</em></a>上联系他</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure></div></div>    
</body>
</html>