<html>
<head>
<title>Service discovery in microservice architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构中的服务发现</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understand-service-discovery-in-microservice-c323e78f47fd?source=collection_archive---------5-----------------------#2018-03-09">https://medium.com/hackernoon/understand-service-discovery-in-microservice-c323e78f47fd?source=collection_archive---------5-----------------------#2018-03-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0a85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很多年前，和朋友失去联系最简单的方法就是在不通知他们的情况下更换电话号码。</p><p id="647f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这同样适用于微服务架构系统中的服务。两个服务可能正在愉快地互相交谈，直到其中一个移动到另一个ip地址。</p><h2 id="69f4" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">什么是服务发现</h2><p id="d1a0" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">服务发现是关于找到服务提供商的网络位置。</p><h2 id="5bdd" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">我们为什么需要它</h2><p id="123b" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">如果一个团队正在维护物理服务器，那么一个配置文件将最能满足需要。</p><p id="1967" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果您使用云，由于重启、故障和扩展，您的服务可能会有动态网络位置。手动维护配置文件是不可行的。</p><h2 id="9c1b" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">有哪些组件</h2><p id="d907" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">服务发现涉及三方:服务提供者、服务消费者和服务注册中心。</p><ol class=""><li id="d7b4" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated">服务提供商在进入系统时向服务注册中心注册自己，在离开系统时注销自己</li><li id="3446" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">服务消费者从注册中心获取提供者的位置，然后与提供者对话</li><li id="6c51" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">服务注册维护提供者的最新位置</li></ol><p id="3b8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多现有的服务发现工具可供使用。但是如果我们想要建立自己的呢？</p><h2 id="701a" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">设计服务发现</h2><p id="123d" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">由于service registry基本上维护键-值对<code class="eh ld le lf lg b">(provider name, provider locations)</code>，redis可能是一个不错的选择。让我们用redis作为注册中心来模拟服务发现过程。</p><p id="6b3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当服务提供商<code class="eh ld le lf lg b">inventory_service</code>在注册表中注册自己时，我们使用<code class="eh ld le lf lg b">SADD</code>将其位置添加到<code class="eh ld le lf lg b">set</code>:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/ffb0d69fbf2d5d83f19bf169a27549a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQ3z4qaLCXHNXNZwdyuHWA.png"/></div></div></figure><p id="8310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当服务消费者查询<code class="eh ld le lf lg b">inventory_service</code>的位置时，我们可以使用<code class="eh ld le lf lg b">SMEMBERS</code>获取所有位置，也可以使用<code class="eh ld le lf lg b">SRANDMEMBER</code>随机选取一个位置:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lt"><img src="../Images/74a2869b8ebbce5edcdb34b35f2ee0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxGhgNpCsph8mvIpUYLx2Q.png"/></div></div></figure><p id="f402" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当<code class="eh ld le lf lg b">inventory_service</code>取消自己的注册时，我们使用<code class="eh ld le lf lg b">SREM</code>将其从集合中删除:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lu"><img src="../Images/df30d7a0d0ed6722311dc41980a8663f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Udx3gW8ljbq7tWw9YSPKyQ.png"/></div></div></figure><p id="eed1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是要处理的事情很复杂:</p><ol class=""><li id="d6d6" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated"><strong class="it hv">该服务可能不会在消失后自行注销</strong>。则注册中心向消费者提供无效地址。为了解决这个问题，服务提供商需要周期性地发送其<strong class="it hv"> <em class="lv">心跳</em> </strong>(可能每5秒一次)。如果提供者在一段时间内没有发送任何心跳，注册表将假定提供者死亡，并注销它。</li><li id="ef2a" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><strong class="it hv">每次调用提供者前查询注册表？</strong>它给注册表带来了过多的负载，并对性能产生了不必要的影响。最好在消费者本身保留一份副本。</li><li id="0afb" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><strong class="it hv">如果保存在消费者处，如何通知消费者供应商的变更？</strong>有两种方法可以做到。1)消费者使用<strong class="it hv"> <em class="lv">轮询</em> </strong>获取最新版本。因为位置通常不会经常改变，所以这仍然有效。缺点是轮询之间可能会停机。2) <strong class="it hv"> <em class="lv"> pubsub </em> </strong>模式。它提供了更即时的位置更新，但它会占用消费者的额外线程。</li><li id="bec0" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><strong class="it hv">发送回提供商的所有数据可能不是必需的。</strong>我们可以保留提供者的<strong class="it hv"> <em class="lv">全局版本</em> </strong>，消费者只需要在版本增加时更新其本地副本。</li><li id="7e82" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><strong class="it hv">单点故障</strong>。如果服务注册中心(例如我们在这里使用的redis实例)关闭，所有的消费者和提供者都会受到影响。为了缓解这一点，我们可以使用一个<strong class="it hv"> <em class="lv">分布式数据库</em> </strong>作为服务注册中心，比如<code class="eh ld le lf lg b">zookeeper/etcd/consul</code>。</li></ol><h2 id="316a" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">客户端发现或服务器端发现</h2><ol class=""><li id="b933" class="kp kq hu it b iu kk iy kl jc lw jg lx jk ly jo ku kv kw kx dt translated">客户端发现:服务消费者保留提供者的所有位置，并跨位置对请求进行负载平衡。优点:注册表是唯一的一个组件。缺点:需要为系统中使用的不同语言/框架实现服务发现客户端。</li><li id="d122" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">服务器端发现:消费者向负载均衡器发送请求，负载均衡器从注册表中查询并决定将请求发送给哪个位置的提供者。优点:语言/框架不可知。缺点:现在您需要管理另一个移动部件——负载平衡器。</li></ol><h2 id="1e6d" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">结论</h2><p id="5d83" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">本文解释了服务发现如何在微服务架构系统中工作。当读者使用像<a class="ae lz" href="https://github.com/Netflix/eureka" rel="noopener ugc nofollow" target="_blank">网飞尤里卡</a>这样的开源工具时，它可以帮助他们理解或调试。</p><p id="013a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">参考推荐阅读:</p><ol class=""><li id="c3f9" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated"><a class="ae lz" href="https://github.com/Netflix/eureka/wiki/Understanding-eureka-client-server-communication" rel="noopener ugc nofollow" target="_blank">https://github . com/网飞/尤里卡/维基/理解-尤里卡-客户端-服务器-通信</a></li><li id="1d45" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><a class="ae lz" href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" rel="noopener ugc nofollow" target="_blank">https://www . nginx . com/blog/service-discovery-in-a-micro services-architecture/</a></li></ol></div></div>    
</body>
</html>