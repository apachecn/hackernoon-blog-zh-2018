<html>
<head>
<title>React and Code Splitting made easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应和代码分割变得容易</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-and-code-splitting-made-easy-f118befb5168?source=collection_archive---------7-----------------------#2018-03-09">https://medium.com/hackernoon/react-and-code-splitting-made-easy-f118befb5168?source=collection_archive---------7-----------------------#2018-03-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7617" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码分割一直是个问题。从那时起，当你添加大量不同的脚本标签，直到RequireJS出现。</p><p id="5fe9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码分割一直存在，被支持，被使用，让我们跳过“如何”支持和使用它的问题。无论如何——从海外带来代码并执行清关——这是可以讨论的。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/dad984d22e751d8c7f3f7358cf174eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D21ERITfpEV-mN2nZgygEQ.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Importing components….</figcaption></figure><p id="4e1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，让我们跳过历史课，直接跳到一个动作的开始。</p><h2 id="852c" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">Webpack 2出来了，给了一个导入。</h2><p id="2a10" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">代码分割(又一次)成为一件事，下周我们有一群“反应加载器”。你最好问的第一个问题很简单</p><blockquote class="lf"><p id="d018" class="lg lh hu bd li lj lk ll lm ln lo jo ek translated">为什么我需要“加载器”？</p></blockquote><p id="ef6e" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">所以，你应该可以接受npm包或React组件只用于<em class="lu">一切</em>。为什么不给装载机装一个特殊的部件呢？</p><p id="54b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种组件最简单的代码是简短的。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="150f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有什么？这个组件实际上是做一些状态处理，并为你的应用提供代码分割。你可以照原样使用它。</p><p id="956f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">只需添加一些错误处理，重试加载、预缓存、测试的能力，当您加载或未能加载时显示某些内容，您将获得一个真正的react组件。你应该只写一次，或者最好不要花时间使用现有的解决方案——一些来自开源的库。</p><h2 id="d82e" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">那好吧。怎么挑那个库？</h2><p id="e007" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">如果你去github搜索一个库——你会找到几个，他们会选择你要用的那个。</p><blockquote class="lf"><p id="8429" class="lg lh hu bd li lj lk ll lm ln lo jo ek translated">有什么区别？如何选择？</p></blockquote><p id="665e" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">首先——忽略星级计数、提交、活动等等。“装载机”不是火箭，正如我们刚刚发现的——这是<strong class="it hv"> 22行稀疏代码</strong>。</p><p id="298e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二—看API。你要用，API要“适合”你。实际上，API有两种“形式”。</p><pre class="jq jr js jt fq lx ly lz ma aw mb dt"><span id="f645" class="kf kg hu ly b fv mc md l me mf">1. loadable(() =&gt; import('./Home'))<br/>2. loadable({ loader: () =&gt; import('./Home') })</span></pre><p id="a931" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在<a class="ae mg" href="https://github.com/theKashey/react-imported-component" rel="noopener ugc nofollow" target="_blank"> react-imported-component </a>、<a class="ae mg" href="https://github.com/faceyspacey/react-universal-component" rel="noopener ugc nofollow" target="_blank">react-universal-component</a>和<a class="ae mg" href="https://github.com/smooth-code/loadable-components" rel="noopener ugc nofollow" target="_blank">loadable-component</a>中找到第一个，而第二个— <a class="ae mg" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank"> react-loadable </a>和<a class="ae mg" href="https://github.com/ctrlplusb/react-async-component" rel="noopener ugc nofollow" target="_blank"> react-async-component </a>。</p><p id="1475" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在“额外的”选项中也有一点小小的不同，你可以传递到加载器中</p><ol class=""><li id="5360" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">可加载元件-您可以指定加载时要显示的内容，在发生错误时，或者如何显示元件。</li></ol><pre class="jq jr js jt fq lx ly lz ma aw mb dt"><span id="56e4" class="kf kg hu ly b fv mc md l me mf">const Home = loadable(() =&gt; import('./Home'), {<br/>  LoadingComponent: Loading,<br/>  ErrorComponent: ErrorDisplay,<br/>  render: ({ Component, loading, ownProps }) =&gt; {...})<br/>});</span></pre><p id="ae9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Loadable-components还提出用第三方工具来处理延迟和超时。</p><div class="mq mr fm fo ms mt"><a href="https://github.com/smooth-code/loadable-components" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">平滑代码/可加载组件</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">可加载组件反应代码分裂，使简单的✂️✨</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jz mt"/></div></div></a></div><p id="d221" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.React-imported-component实际上有相同的API，只是引入了额外的onError属性。最好参考可加载组件自述文件来理解如何处理反应导入组件。</p><div class="mq mr fm fo ms mt"><a href="https://github.com/theKashey/react-imported-component" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">kashey/react-导入组件</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">react-imported-component-Bundler独立于任何延迟组件的解决方案，以实现更好的SSR、代码拆分和…</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">github.com</p></div></div><div class="nc l"><div class="ni l ne nf ng nc nh jz mt"/></div></div></a></div><p id="788c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.React-async-component也是一样的。有很多有趣的问题和答案。</p><div class="mq mr fm fo ms mt"><a href="https://github.com/ctrlplusb/react-async-component" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">ctrl plusb/react-async-组件</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">异步解析组件，支持代码分割和高级服务器端…</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">github.com</p></div></div><div class="nc l"><div class="nj l ne nf ng nc nh jz mt"/></div></div></a></div><p id="21f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.React-loadable略有不同，首先接受的不仅仅是“导入”函数，而是由最终组件解决(即它可以处理“映射”)，将LoadingComponent和ErrorComponent混合在一起，并内置“延迟”功能以减少加载“微调器”的闪烁。</p><pre class="jq jr js jt fq lx ly lz ma aw mb dt"><span id="d9a0" class="kf kg hu ly b fv mc md l me mf">Loadable({<br/>  loader: () =&gt; import('./WillFailToLoad'), // oh no!<br/>  loading: (props) =&gt; {<br/>     if (props.error) {<br/>       return &lt;div&gt;Error!&lt;/div&gt;;<br/>     } else {<br/>       return &lt;div&gt;Loading...&lt;/div&gt;;<br/>     }<br/>  }<br/>});</span></pre><div class="mq mr fm fo ms mt"><a href="https://github.com/jamiebuilds/react-loadable" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">jamiebuilds/react-loadable</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">react-loadable-:hourglass _ flow _ sand:一个高阶组件，用于加载带有承诺的组件。</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">github.com</p></div></div></div></a></div><p id="840d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">5.React-universal-component与所有其他组件也没有太大区别。唯一一个有真正动态的动态导入。</p><pre class="jq jr js jt fq lx ly lz ma aw mb dt"><span id="d9a7" class="kf kg hu ly b fv mc md l me mf">const Component = universal(props =&gt; import(`./${props.page}`))</span></pre><blockquote class="nk nl nm"><p id="c886" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">PS:这种做法可能副作用很大，要注意。</p></blockquote><div class="mq mr fm fo ms mt"><a href="https://github.com/faceyspacey/react-universal-component" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">面空间/反应通用组件</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">反应-通用-组件-🚀React通用组件的最终答案:同步SSR +代码拆分</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">github.com</p></div></div><div class="nc l"><div class="nq l ne nf ng nc nh jz mt"/></div></div></a></div><p id="fbac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们都很好地完成了自己的工作，如果您想了解更多关于代码拆分本身的知识，请参考关于这些加载器的文章。</p><div class="mq mr fm fo ms mt"><a rel="noopener follow" target="_blank" href="/faceyspacey/announcing-react-universal-component-2-0-babel-plugin-universal-import-5702d59ec1f4"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">React通用组件2.0 &amp;巴别塔插件通用导入</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">怎么了，大西洋！</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">medium.com</p></div></div><div class="nc l"><div class="nr l ne nf ng nc nh jz mt"/></div></div></a></div><div class="mq mr fm fo ms mt"><a href="https://jamie.build/react-loadable.html" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">介绍React Loadable</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">React“The Beach House(Mndsgn Remix)”中以组件为中心的代码拆分和加载</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">杰米。建立</p></div></div><div class="nc l"><div class="ns l ne nf ng nc nh jz mt"/></div></div></a></div><div class="mq mr fm fo ms mt"><a rel="noopener follow" target="_blank" href="/smooth-code/introducing-loadable-components-️-646dd3ab0aa6"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">引入可加载组件✂️✨</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">一个解决React代码分割客户端和服务器端的库。</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">medium.com</p></div></div><div class="nc l"><div class="nt l ne nf ng nc nh jz mt"/></div></div></a></div><blockquote class="nk nl nm"><p id="5abf" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">PS:其实那些文章大多是关于“进口”的东西。</p></blockquote><p id="d50a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您正在构建纯粹的前端SPA，可以随意选择“加载器”，甚至使用您自己的加载器，因为这是一个很好的选择。</p><h2 id="19aa" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">客户端代码分割和服务器端渲染</h2><blockquote class="lf"><p id="04a8" class="lg lh hu bd li lj lk ll lm ln lo jo ek translated">从表面上看，它们都有相似之处，尤其是在只与客户方打交道时。然而，我个人发现，当您尝试执行服务器端渲染时，每个解决方案之间的真正区别变得很明显。— <a class="ae mg" href="https://github.com/ctrlplusb/react-async-component/issues/37" rel="noopener ugc nofollow" target="_blank"> react-async-loader </a>，第37期</p></blockquote><p id="2362" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">客户端代码拆分是<strong class="it hv">一件超级容易的事情</strong>。“好的”客户端代码分解成更复杂的东西…但是你仍然可以在一两个小时内写完所有你需要的东西。结果可能会比上面所有的库更好。是的，为客户端编写“加载程序”很容易。</p><p id="8182" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">服务器端和代码拆分？啊？实际上没有人解决这个问题。</p><h2 id="5378" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">问题是</h2><p id="0191" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">你正在<strong class="it hv">服务器</strong>上渲染你的应用程序，并将<strong class="it hv">的整个</strong> html发送到<strong class="it hv">客户端</strong>。接下来，客户端<strong class="it hv"> <em class="lu">重新水合</em> </strong>代码，用React表示替换死的html，让它活起来。没有代码分割的简单<strong class="it hv">。</strong></p><p id="a389" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题#1是——由于代码分割，客户端<strong class="it hv">没有</strong>所有必需的<strong class="it hv">代码</strong>来完全恢复服务器呈现的响应。一秒钟前还不错的页面被spinners取代了，几秒钟后又变得不错了。它将尽可能多地渲染，加载延迟的部分，然后重新渲染其余部分。事情就是这样运作的！</p><blockquote class="nk nl nm"><p id="891b" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">你搞砸了你在SSR上做的所有工作，让客户生气，甚至由于闪烁的内容和旋转的加载程序而导致癫痫发作。</p></blockquote><blockquote class="lf"><p id="246a" class="lg lh hu bd li lj nu nv nw nx ny jo ek translated">规则#1 —首先装载所有“备用”零件。只有下一个复水内容，使客户看不到复水。</p></blockquote><p id="337d" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">问题#2是——服务器端React渲染是同步的。“代码分离”组件是“异步”同步的。如果您将在服务器上渲染它们，您将什么也不渲染，或者“加载组件”，但不是您必须渲染的React组件。它是异步的，并且将在您将结果发送到客户端之后准备好呈现<strong class="it hv">。答对了。第一价格！</strong></p><blockquote class="lf"><p id="2585" class="lg lh hu bd li lj lk ll lm ln lo jo ek translated">规则#2 —客户端异步。在服务器上同步。不要混。</p></blockquote><p id="10ad" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">那些问题是纠缠在一起的——你得知道你在渲染时“将要”加载什么，“是否”加载了它，还要让客户端知道如何重复。</p><p id="a6d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许Lyft的<a class="ae mg" href="https://github.com/lyft/universal-async-component" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">通用异步组件</strong> </a>就是<em class="lu"> cheatest </em>那个。他们使用“string-replace-loader”来替换“import ”,让它在服务器上同步，然后从webpack stats中提取“used”脚本。所有内容50行代码。</p><p id="69a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae mg" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">React-lodable</strong></a><strong class="it hv"/>做的几乎一样，但是使用babel插件来“传输”关于所用导入的信息，并且在异步导入之后提供同步需求。</p><p id="1392" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">通用部件</strong>走了相似和不同的路。他们做着同样的事情，通过babel-plugin-universal-import传递“解密”的信息，但他们传递的是“导入”中的信息。</p><p id="f4b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来上面列出的所有库将访问webpack stat信息，以确定用户在主上下文之前必须加载哪些额外的脚本。</p><blockquote class="nk nl nm"><p id="e164" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">优点:他们完成了工作。</p><p id="2a44" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">缺点:仅webpack，将在主脚本之前同步导入额外的脚本。可能会受到webpack将来可能引入的一些优化的影响。</p></blockquote><p id="8918" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">可加载和异步组件</strong>非常不同——它们在服务器端精确地“<strong class="it hv">渲染反应树</strong>，为最终结果提供“异步渲染”的东西。这不需要任何webpack或babel插件，但可能会影响页面渲染的性能。您必须在客户端执行客户端渲染，将所有内容重新渲染几次。</p><p id="d5c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，他们在前端做了几乎相同的事情。但是有一个问题——您一次只能导入一个“级别”的导入。如果你有一个异步页面，它加载异步小部件——他们将首先加载页面，只有在它之后，他们才能够<strong class="it hv">加载小部件，并得到代码来完成它。</strong></p><p id="851c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PS: Loadable-components有一个巴别塔插件来缓解(一点)这个问题。</p><blockquote class="nk nl nm"><p id="f09f" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">优点:可以使用任何捆扎机，即使没有额外的配置</p><p id="b62b" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">缺点:慢速异步SSR，慢速“受波浪影响”的前端渲染。</p></blockquote><p id="22ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> React-imported-component </strong>介于两者之间。它仍然总是异步的，但是通过简单地执行导入并在第一个用户生成页面之前记忆结果，使SSR呈现同步。只是一个简单的假设，承诺将在所有套接字之前执行，需要接受第一个客户端请求来呈现一些东西。</p><p id="4860" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，它将跟踪导入的使用情况，并尝试在客户端补液之前重放它们。</p><blockquote class="nk nl nm"><p id="1010" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">优点:这是工作吗</p><p id="0471" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">缺点:不只是webpack，不受wave影响，不慢，将来也不会坏。</p></blockquote><h2 id="7ab8" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">瓦特？</h2><p id="a1f6" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">有一件事，我忘了说——这些加载器如何发出“同步”请求，并了解在再水合之前客户端必须加载什么。</p><p id="3c8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他们使用babel来找到“import ”,并使用import里面的字符串作为“mark ”,并作为文件名指向<code class="eh nz oa ob ly b">require</code>真正的文件。喜欢</p><pre class="jq jr js jt fq lx ly lz ma aw mb dt"><span id="2315" class="kf kg hu ly b fv mc md l me mf">const LoadableComponent = Loadable({<br/>  loader: () =&gt; import('./my-component'),<br/>  loading: Loading,<br/>});</span></pre><p id="d4d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是！如果您将导入从该功能中移出</p><pre class="jq jr js jt fq lx ly lz ma aw mb dt"><span id="f08a" class="kf kg hu ly b fv mc md l me mf">const loader = () =&gt; import('./my-component');<br/>const LoadableComponent = Loadable({<br/>  loader,<br/>  loading: Loading,<br/>});</span></pre><p id="e9f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它会打碎东西。这是<a class="ae mg" href="https://github.com/jamiebuilds/react-loadable#how-do-i-avoid-repetition" rel="noopener ugc nofollow" target="_blank">已知的</a>问题。这仅适用于SSR。</p><p id="0ebd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想将加载器作为UI库或UI套件的一部分，我的意思是——标准站点范围的“加载”或“错误”、分析、监控——你将无法通过帮助器函数包装“加载器”或转换成HOC。它将<strong class="it hv">正确停止SSR </strong>，只要它将丢失使用过的组件的轨迹。</p><p id="600a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，这不是一个“常见”的问题:</p><ul class=""><li id="5fa6" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo oc mn mo mp dt translated">react-universal-component <a class="ae mg" href="https://github.com/faceyspacey/babel-plugin-universal-import" rel="noopener ugc nofollow" target="_blank">用<code class="eh nz oa ob ly b">universalImport</code>替换了</a> <code class="eh nz oa ob ly b">import</code>，被导入的同步和异步“版本”所迷惑。</li><li id="cdc1" class="mh mi hu it b iu od iy oe jc of jg og jk oh jo oc mn mo mp dt translated">react-imported-component几乎做了同样的事情，用“findable”包装器代替。</li><li id="a0c2" class="mh mi hu it b iu od iy oe jc of jg og jk oh jo oc mn mo mp dt translated">universal-async-component也用它们的包装器代替了<code class="eh nz oa ob ly b">import</code>。</li></ul><p id="39ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以——他们都将能够理解正在发生的事情，并使用“间接”进口。“问题”只是react-loadable和loadable-components的“问题”。webpack v4对<code class="eh nz oa ob ly b">mjs</code>文件<a class="ae mg" href="https://github.com/smooth-code/loadable-components/issues/46" rel="noopener ugc nofollow" target="_blank">的支持可能会破坏</a>文件，因为目前的实现方式。</p><p id="3653" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二件重要的事情——如果你想加载模块“A”——web pack可能会加载“B”、“C”和“D”。由于CommonChunk、AsyncChunk、Webpack v4 AutoMagicChunking或他们将来会发明的任何东西。理解(和预测)webpack stat文件的所有魔力并不容易，这就是为什么由于“意外的”串联插件universal-async-component可能已经被破坏了。</p><p id="ae6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">反应导入组件</strong>改变了这一点。一点点。这不是好的，也不是最终的解决方案，但可能现在对每个人都有效。</p><ol class=""><li id="ee1b" class="mh mi hu it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp dt translated">它将您提供的“导入函数”转换为string，并在其中注册导入。所以你可以从任何地方传递“import ”,但是你仍然不能使用复杂的函数，只要除了loader函数体之外的所有东西对导入的组件都是不可见的。<br/>与同样“攻击”导入的react-universal-component和universal-async-component的区别很简单——导入的组件不会每次都执行“导入功能”。在启动时只有一个，保持异步，允许你在里面放入任何逻辑(像一堆导入，等待，最后产生一个新的组件)。</li><li id="f3eb" class="mh mi hu it b iu od iy oe jc of jg og jk oh jo mm mn mo mp dt translated">它在您的代码库中搜索导入，产生一个“查找”文件，包含您项目中的每一个<code class="eh nz oa ob ly b">import</code>。接下来，它可以使用它通过“mark”(导入名称)导入一些东西，以减少“加载波”。</li></ol><p id="9350" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并且加载将是<strong class="it hv">异步的</strong>。并且在主束之后装载。在“什么时候”加载东西——在“main”之前同步或者在“main”之后异步——有什么区别吗？当然，第二个版本会更快，快${numberOfExtraScripts}倍。</p><blockquote class="nk nl nm"><p id="c729" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">优点:可以和任何捆绑工一起工作。</p><p id="e228" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">缺点:需要单独步骤从代码库中“提取”导入。还有巴别。</p></blockquote><p id="94f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多装载机，所以尝试一下这个新的。实际上，它并不新鲜，因为它是在一年前作为React-Hot-Loader的“react-hot-component-loader”而诞生的。也可以随意尝试我上面列出的所有其他库。只是因为他们都是不同的，他们中的每一个都可能更适合你。他们都会变得更好并进化。</p><blockquote class="nk nl nm"><p id="86aa" class="ir is lu it b iu iv iw ix iy iz ja jb nn jd je jf no jh ji jj np jl jm jn jo hn dt translated">PS:就像react-imported-components刚刚做的那样(这已经是第4版了)</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="oi lw l"/></div></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/0c02142b18bb98f18f73bc86432148a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*IhZVMOnFn557lVsDXlrSyg.png"/></div></figure><p id="346a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而代码拆分本身呢？去做吧！不多。主要是在逻辑层，而不是组件层。</p><p id="ec4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关键思想是——将“拆分”的代码与“数据”并行加载。或者您必须首先加载代码，这将开始加载数据。我们为客户体验而战，而不是代码分割本身。</p><h2 id="a287" class="kf kg hu bd kh ki kj kk kl km kn ko kp jc kq kr ks jg kt ku kv jk kw kx ky kz dt translated">想要更多吗？</h2><div class="mq mr fm fo ms mt"><a rel="noopener follow" target="_blank" href="/@antonkorzunov/react-server-side-code-splitting-made-again-a61f8cbbd64b"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">React服务器端代码拆分已完成..又</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">React代码拆分在一年前就成为了一件事。从那时起，我们一直在寻找新的方法来代码分割和推迟…</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">medium.com</p></div></div><div class="nc l"><div class="ok l ne nf ng nc nh jz mt"/></div></div></a></div></div></div>    
</body>
</html>