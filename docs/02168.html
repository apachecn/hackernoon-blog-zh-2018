<html>
<head>
<title>AlloyCI Dev Diary — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合金开发日记—第四部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/alloyci-dev-diary-part-4-4656ceed60a5?source=collection_archive---------33-----------------------#2018-03-09">https://medium.com/hackernoon/alloyci-dev-diary-part-4-4656ceed60a5?source=collection_archive---------33-----------------------#2018-03-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="fd0b" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">通过Guardian &amp;über auth进行用户验证</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/c97adcc1245cebfa26581ff7cf5525af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiltvM4ydji8sXcvbsEL_Q.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/photos/pY_AZJfdbHQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Matt Artz</a> on <a class="ae jz" href="https://unsplash.com/search/photos/security?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="76db" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这篇博客文章是详细描述<a class="ae jz" href="https://hackernoon.com/tagged/alloyci" rel="noopener ugc nofollow" target="_blank"> AlloyCI </a>的<a class="ae jz" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a>过程的系列文章的一部分。之前的条目有:</p><ul class=""><li id="f2db" class="kw kx hu kc b kd ke kg kh kj ky kn kz kr la kv lb lc ld le dt translated"><a class="ae jz" href="https://hackernoon.com/alloyci-dev-diary-part-1-8ae564fce9f3" rel="noopener ugc nofollow" target="_blank">第一部分:开始一个新项目</a></li><li id="f85c" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv lb lc ld le dt translated"><a class="ae jz" href="https://hackernoon.com/alloyci-dev-diary-part-2-6a61b02faca8" rel="noopener ugc nofollow" target="_blank">第2部分:构建新的Phoenix项目</a></li><li id="c9a1" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv lb lc ld le dt translated"><a class="ae jz" href="https://hackernoon.com/alloyci-dev-diary-part-3-4c454d82cd69" rel="noopener ugc nofollow" target="_blank">第3部分:GitHub问题的项目管理&amp;板</a></li></ul></div><div class="ab cl lk ll hc lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hn ho hp hq hr"><p id="1fa8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">对于一个重要的web应用程序，首先需要做的事情之一是用户管理和认证。</p><p id="db2a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">AlloyCI需要连接到OAuth服务，比如GitHub，但也让用户用邮箱和密码注册。在Rails生态系统中，我们已经<a class="ae jz" href="https://github.com/plataformatec/devise" rel="noopener ugc nofollow" target="_blank">设计了</a>。Devise负责用户管理的繁重工作，它加密密码，使恢复密码变得容易，你可以在用户使用他们的帐户之前验证他们的电子邮件，等等。这也使得与OmniAuth的集成变得非常容易，omni auth允许用户通过实现OAuth的服务注册和登录。</p><p id="3d30" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我的第一反应是搜索一个类似的库，比如Devise，但是是Phoenix/Elixir生态系统。当我找不到像Devise这样功能丰富的东西时，我很惊讶。在<a class="ae jz" href="https://elixirforum.com/t/user-authentication-in-phoenix/118/7" rel="noopener ugc nofollow" target="_blank"> ElixirForum </a>上有一场关于人们使用什么来认证用户的大讨论。这是我的第一个信息来源。</p><p id="791b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">该讨论的第一个要点是，<strong class="kc hv"> <em class="lr">是</em> </strong>一个非常类似于design的库，那是斯蒂芬·帕伦的<a class="ae jz" href="https://github.com/smpallen99/coherence" rel="noopener ugc nofollow" target="_blank"> Coherence项目</a>，但它仍处于早期开发阶段，不支持OAuth。这对我来说是一个障碍，因为OAuth是AlloyCI与GitHub正确通信所必需的。</p><p id="4354" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">第二点是，对于许多开发人员使用什么来进行身份验证，似乎有一些共识，但是对于初学者来说，没有多少资源可以正确入门。最常用的方法似乎是混合了<a class="ae jz" href="https://github.com/ueberauth/guardian" rel="noopener ugc nofollow" target="_blank"> Guardian </a>和<a class="ae jz" href="https://github.com/ueberauth/ueberauth" rel="noopener ugc nofollow" target="_blank">über auth</a>。两个项目都由同一组人维护，因此集成它们并不复杂。</p><h2 id="4273" class="ls lt hu bd lu lv lw lx ly lz ma mb mc kj md me mf kn mg mh mi kr mj mk ml mm dt translated">监护人</h2><p id="7f2d" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">Guardian使用JSON Web令牌来认证用户并授权他们的操作。它提供了创建、加密和验证jwt的完整机制。它为您提供了一种为用户保持“会话”活动的方法，但是它没有提供实际管理它们的方法。</p><h2 id="a563" class="ls lt hu bd lu lv lw lx ly lz ma mb mc kj md me mf kn mg mh mi kr mj mk ml mm dt translated">berauth</h2><p id="40bb" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">berauth允许您从不同的身份验证提供商创建用户。它与许多OAuth服务兼容，还提供了一个名为“Identity”的通用提供程序，允许您的应用程序基于电子邮件/密码组合创建用户。它为您提供了验证用户身份的第一个入口点，但是它无法保持会话活动或授权操作。</p><blockquote class="ms mt mu"><p id="3e37" class="ka kb lr kc b kd ke iv kf kg kh iy ki mv kk kl km mw ko kp kq mx ks kt ku kv hn dt translated">集成Guardian和berauth是获得合适的认证和会话管理系统的关键。</p></blockquote><h1 id="82f8" class="my lt hu bd lu mz na nb ly nc nd ne mc ja nf jb mf jd ng je mi jg nh jh ml ni dt translated">好东西</h1><p id="21c8" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">现在说点好的。如何将Guardian &amp;übera uth集成到现有的Phoenix应用程序中？</p><p id="2e99" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">AlloyCI中的代码基于<a class="ae jz" href="https://github.com/hassox/phoenix_guardian" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>，但是它被更新为与Phoenix 1.3.0和Elixir 1.6.1兼容。</p><h2 id="3655" class="ls lt hu bd lu lv lw lx ly lz ma mb mc kj md me mf kn mg mh mi kr mj mk ml mm dt translated">1.迁移</h2><p id="cf9f" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">您应该已经有了一个包含字段<code class="eh nj nk nl nm b">email</code>和<code class="eh nj nk nl nm b">name</code>的<code class="eh nj nk nl nm b">user</code>模式。密码和其他授权相关信息不会存储在<code class="eh nj nk nl nm b">User</code>模式中，而是存储在自己的<code class="eh nj nk nl nm b">Authorization</code>模式中。让我们创建它:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nn no l"/></div></figure><p id="0467" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这个数据结构将存储关于用户认证方法的信息。(示例应用程序将它们称为“授权”，因为Guardian提供了将权限编码到它创建的JWT中的选项，所以从技术上讲，您也可以使用它来授权用户的操作，而不仅仅是验证它们)</p><p id="2602" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">随着<code class="eh nj nk nl nm b">Authentication</code>模式的创建，我们现在需要修改<code class="eh nj nk nl nm b">User</code>模式来告诉它<code class="eh nj nk nl nm b">has_many :authentications</code></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nn no l"/></div></figure><p id="b341" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在正常情况下，jwt是不可撤销的，所以如果您的一个令牌受到损害，您将需要切换您的生成/验证函数，从而使所有现有的令牌失效。Guardian提供了一个解决方法。通过添加<code class="eh nj nk nl nm b">GuardianDb</code>依赖项，Guardian会将您的jwt保存到数据库中，如果需要的话，您可以很容易地撤销单个令牌。很多人认为这违背了整个JWT模式，因为它将一个无会话的认证模式变成了一个全会话的认证模式，但是对于AlloyCI的需求来说，这种方法非常有效。</p><p id="3fb5" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">为了使用<code class="eh nj nk nl nm b">GuardianDb</code>,您需要创建一个新的数据库表来保存令牌信息:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nn no l"/></div></figure><h2 id="26a3" class="ls lt hu bd lu lv lw lx ly lz ma mb mc kj md me mf kn mg mh mi kr mj mk ml mm dt translated">2.控制器</h2><p id="600b" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">现在我们已经准备好了模式，我们可以继续使用控制器了。示例应用程序已经为我们提供了所需的一切，所以只需修改它来满足我们的需求。这是我最初为AlloyCI做的。我添加的第一个功能是用户登录，因为这是任何在线服务最必要的功能。</p><p id="b3ef" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们从认证控制器开始，因为这是我们的认证逻辑的入口点。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nn no l"/></div></figure><p id="025d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">正如您所看到的，该控制器具有呈现登录页面、处理注销操作、处理来自berauth的回调以及针对未经身份验证的用户的通用回调和未经授权的操作的操作。</p><p id="bc29" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">berauth回调处理OAuth提供者发送的信息。我们在函数签名中使用模式匹配来处理成功和失败的OAuth回调。</p><p id="39d5" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">berauth的工作方式如下:</p><ul class=""><li id="b18b" class="kw kx hu kc b kd ke kg kh kj ky kn kz kr la kv lb lc ld le dt translated">注册一个拦截来自OAuth提供者的原始HTTP请求的插件</li><li id="e8b4" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv lb lc ld le dt translated">对原始信息执行操作，并为请求准备特殊的<code class="eh nj nk nl nm b">assigns</code></li><li id="fc80" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv lb lc ld le dt translated">将处理后的信息转发给控制器</li></ul><p id="8c16" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">根据OAuth回调是成功还是失败，berauth插件填充相应的assign。我们就是用这个<code class="eh nj nk nl nm b">assign</code>来匹配请求的。如果回调失败，我们将用户重定向到登录屏幕并显示一条错误消息。如果行动成功，我们将委托给<code class="eh nj nk nl nm b">Accounts</code>模块来完成实际的繁重工作。</p><p id="0f87" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">该模块负责读取由OAuth提供者发送的、由berauth插件准备的信息，并返回一个用户对象。这个用户可以是新用户，也可以是现有用户，确定返回哪个用户的工作就落在了Accounts模块上。这由<code class="eh nj nk nl nm b">get_or_create_user/2</code>功能处理。你可以看看这个文件，看看一切是如何联系在一起的:</p><div class="np nq fm fo nr ns"><a href="https://github.com/AlloyCI/alloy_ci/blob/master/lib/alloy_ci/accounts/accounts.ex" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hv fv z el nx eo ep ny er et ht dt translated">合金ci/合金_ci</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">alloy _ ci——持续集成、部署和交付协调器，用Elixir编写。</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jt ns"/></div></div></a></div><p id="2960" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">此时，如何处理应用程序如何处理OAuth提供者返回的信息完全取决于您。在GitHub的例子中，对于AlloyCI，如果一个帐户不存在，我们就创建一个新帐户，并用返回的数据填充它，即姓名、电子邮件和用户名。</p><p id="c3ac" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">AlloyCI还允许用户通过常规的帐户创建表单进行创建，在这种情况下，我们要求用户提供所有这些信息，加上密码和密码确认。为了配合berauth的认证过程，它提供了一个通用的<code class="eh nj nk nl nm b">Identity</code> OAuth提供者。这个提供程序模拟一个正确的OAuth请求，并发送表单中的所有信息。然后使用<code class="eh nj nk nl nm b">Comeonin.Bcrypt</code>哈希算法对密码进行哈希和加盐处理。</p><p id="fec0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果帐户存在，则使用数据库中已有的数据对其进行验证。用户通过身份验证后，他们就可以使用整个应用程序了。身份验证作为JWT令牌添加到会话中，包含:</p><pre class="jk jl jm jn fq oh nm oi oj aw ok dt"><span id="8dfd" class="ls lt hu nm b fv ol om l on oo">Guardian.Plug.sign_in(user, :access, perms: %{default:  Guardian.Permissions.max})</span></pre><h2 id="2cfd" class="ls lt hu bd lu lv lw lx ly lz ma mb mc kj md me mf kn mg mh mi kr mj mk ml mm dt translated">3.按指定路线发送</h2><p id="ce92" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">为了使认证过滤器工作，需要在控制器和路由上设置认证过滤器。在Rails中，你可以给你的控制器添加一个<code class="eh nj nk nl nm b">before_filter</code>,然后就结束了，但是在Phoenix中有两种方法可以做到这一点，一个路由管道，或者作为一个特定于控制器的插件。</p><p id="9195" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">路由管道</strong></p><p id="34dd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">路由管道允许您通过一组预定义的插件发送请求。AlloyCI的认证管道在<code class="eh nj nk nl nm b"><a class="ae jz" href="https://github.com/AlloyCI/alloy_ci/blob/master/lib/alloy_ci/web/router.ex#L12-L18" rel="noopener ugc nofollow" target="_blank">routes.ex</a></code>文件中定义如下:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff op"><img src="../Images/1f174125e20d9997ce7187b7c59b4373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8LTrKpFGaK3QTyCku24JQ.png"/></div></div></figure><p id="0f23" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">正如您在评论中看到的，这些插件只检查正确的JWT，但是如果没有发现，它们不做任何其他事情。这是故意的，因为我们拥有无需令牌即可访问的资源。对于所有其他需要认证用户的资源，需要一个额外的插件。这就是控制器特定“过滤器”的用武之地。</p><p id="93f8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">控制器专用插头</strong></p><p id="9dfe" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">您可以在每个控制器上定义额外的插件来进一步过滤请求。我们在AlloyCI上为需要认证用户的控制器和管理员专用控制器使用这个。以<code class="eh nj nk nl nm b"><a class="ae jz" href="https://github.com/AlloyCI/alloy_ci/blob/818d50a00c57a913f830bde74facc26b7c232191/lib/alloy_ci/web/controllers/pipeline_controller.ex#L4-L5" rel="noopener ugc nofollow" target="_blank">pipeline_controller.ex</a></code>为例，我们使用一个插件来确保用户登录，使用另一个插件来更改默认布局，但只用于“显示”动作:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oq"><img src="../Images/8183d8f062b3dc9573fae7a4e3686301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7M9_ErwTy8Jo-lpj6Chew.png"/></div></div></figure><p id="8e23" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><a class="ae jz" href="https://github.com/AlloyCI/alloy_ci/blob/master/lib/alloy_ci/web/controllers/public_controller.ex" rel="noopener ugc nofollow" target="_blank">公共控制器</a>不调用任何认证插件，因为它不需要用户对象来显示公共信息，如登录页面或注册页面。</p><p id="b4e3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">究竟什么是插头？</strong></p><p id="a2c7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">插件是web应用程序之间可组合模块的规范。它们允许您在模块之间共享信息，并在此过程中对其进行操作。Plug表示与<code class="eh nj nk nl nm b">Plug.Conn</code>的连接，它在整个请求周期中都是可用的。您可以使用一个插件来操作请求，从中提取信息，向其中添加信息，等等。</p><p id="04eb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">对于身份验证插件，我们从连接会话中获取信息，验证它，然后向它添加私有声明。然后我们在另一个插件中使用这个私有声明来加载<code class="eh nj nk nl nm b">current_user</code>资源(这都是由Guardian库处理的)。这实际上就是我们上面展示的<code class="eh nj nk nl nm b">:browser_auth</code>管道所做的事情。</p><p id="3823" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">可以在<a class="ae jz" href="https://github.com/AlloyCI/alloy_ci/blob/master/lib/alloy_ci/web/plugs/github_header.ex" rel="noopener ugc nofollow" target="_blank">这里的</a>中找到一个插头的更基本的用法，我们从连接头中获取信息，并将其保存到连接内部的赋值器中，以便能够对其进行模式匹配:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff or"><img src="../Images/719001dec8b101dbadbbb62421386af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdVIud4N5_CbzhzFCQZmdA.png"/></div></div></figure><p id="e976" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这个插件是在GitHub API处理程序的<a class="ae jz" href="https://github.com/AlloyCI/alloy_ci/blob/master/lib/alloy_ci/web/router.ex#L42-L44" rel="noopener ugc nofollow" target="_blank">管道</a>中声明的，并像这样在<code class="eh nj nk nl nm b">github_event_controller.ex</code>中使用，在这里我们针对一个引用被删除的“push”事件进行模式匹配:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff os"><img src="../Images/8b1576e18ecbb6ddea66368c0e0dafc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_IhZgJrImsj90YuYKKQKg.png"/></div></div></figure><h2 id="4a4d" class="ls lt hu bd lu lv lw lx ly lz ma mb mc kj md me mf kn mg mh mi kr mj mk ml mm dt translated">4.视图和模板</h2><h2 id="167d" class="ls lt hu bd lu lv lw lx ly lz ma mb mc kj md me mf kn mg mh mi kr mj mk ml mm dt translated">5.试验</h2><p id="3f5d" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">如何测试您的应用程序完全取决于您，但是如果您想要测试身份验证墙后面的控制器，那么您将需要一些帮助器方法来准备连接，并用测试所需的结构填充它:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ot"><img src="../Images/f541866f9e1b0de099781ab3ed7543eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vjm8txzJ2JZ8mQ9ha6V2tA.png"/></div></div></figure><p id="e9f6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这些方法应该添加到<code class="eh nj nk nl nm b"><a class="ae jz" href="https://github.com/AlloyCI/alloy_ci/blob/master/test/support/conn_case.ex" rel="noopener ugc nofollow" target="_blank">conn_case.ex</a></code>文件中，并在你的控制器测试中使用，例如<code class="eh nj nk nl nm b"><a class="ae jz" href="https://github.com/AlloyCI/alloy_ci/blob/master/test/web/controllers/pipeline_controller_test.exs" rel="noopener ugc nofollow" target="_blank">pipeline_controller_test.exs</a></code>:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ou"><img src="../Images/812eede994c9a021f5cac5a86acf55b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCmfVQfl-uz_g08-vjk2UQ.png"/></div></div></figure></div><div class="ab cl lk ll hc lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hn ho hp hq hr"><p id="f260" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这涵盖了Guardian和berauth如何与AlloyCI集成的基础知识，应该会为您提供一个起点，以及如何将它们与您的项目集成的一些见解。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ov no l"/></div></figure></div></div>    
</body>
</html>