<html>
<head>
<title>The 4 Layers of Single Page Applications You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的4层单页应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/architecting-single-page-applications-b842ea633c2e?source=collection_archive---------0-----------------------#2018-03-10">https://medium.com/hackernoon/architecting-single-page-applications-b842ea633c2e?source=collection_archive---------0-----------------------#2018-03-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="abde" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">让我们从头开始构建一个React应用程序，探索领域及其服务、商店、应用程序服务和视图。</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/3323d744cb85d6db34c28404a4040a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*5aa2cNrij2fVO0rZTJCZHQ.png"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">The four layers of single page applications — by <a class="ae kb" href="https://dribbble.com/AlbertoV" rel="noopener ugc nofollow" target="_blank">Alberto V</a></figcaption></figure><p id="92f3" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">每个成功的项目都需要一个清晰的架构，所有团队成员都理解这个架构。</p><p id="81bb" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">想象你是团队的新成员。技术负责人介绍了路线图中即将出现的新应用的建议体系结构:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/4f6a7cf99c830e5c148a66dff449ac91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*6wpX8u_mM8Z1xdZVMFj67w.png"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">The four layers of single page applications (detailed)</figcaption></figure><p id="313e" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">他谈到了要求:</p><blockquote class="la lb lc"><p id="b7d0" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">我们的应用程序将显示文章列表。作为用户，我将能够创建、删除和喜欢文章。</p></blockquote><p id="4410" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">然后他让你去做！</p><h1 id="58ec" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">好的，没问题，让我们开始架构吧</h1><p id="33d0" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">我选择了<a class="ae kb" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>和<a class="ae kb" href="https://flow.org" rel="noopener ugc nofollow" target="_blank"> Flow </a>进行类型检查。为简洁起见，应用程序没有样式。</p><p id="8db4" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">作为先决条件，让我们谈谈现代框架的声明性本质，触及状态的概念。</p><h1 id="6e9a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">今天的框架是声明性的</h1><p id="a2dd" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">React、Angular、Vue是<a class="ae kb" href="https://tylermcginnis.com/imperative-vs-declarative-programming/" rel="noopener ugc nofollow" target="_blank">声明式</a>，鼓励我们使用功能性<strong class="ke hv"> </strong>编程的元素。</p><p id="b7f9" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">你见过翻书吗？</p><blockquote class="la lb lc"><p id="b722" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">翻页书是一本有一系列图片的书，这些图片从一页到下一页逐渐变化，所以当快速翻页时，这些图片看起来是有生命的……[1]</p></blockquote><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lm"><img src="../Images/5967072860d19d9fa1faf39af88a4b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YC8GwZboKkBFfJI8cRzUnQ.jpeg"/></div></div></figure><p id="bb14" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">现在让我们检查React定义的一部分:</p><blockquote class="la lb lc"><p id="1bea" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">为应用程序中的每个状态设计简单的视图，当数据发生变化时，React将有效地更新和呈现正确的组件……[2]</p></blockquote><p id="a5f1" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">也是Angular的一部分:</p><blockquote class="la lb lc"><p id="5ce0" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">使用简单的声明性模板快速构建功能。用你自己的组件扩展模板语言… [3]</p></blockquote><p id="7ded" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">听起来很熟悉？</p><p id="73f6" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">框架帮助我们构建由视图组成的应用程序。视图是状态的表示。但是状态是什么呢？</p><h1 id="d04b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">国家</h1><p id="8c96" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">状态代表应用程序中发生变化的每一条数据。</p><p id="2e99" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">你访问一个URL，这是state，发出一个Ajax调用来检索电影列表，这也是state，你把信息持久化到本地存储，同上，state。</p><p id="49d3" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">状态将由<strong class="ke hv">不可变对象</strong>组成。</p><p id="985b" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><a class="ae kb" href="http://enterprisecraftsmanship.com/2016/05/12/immutable-architecture" rel="noopener ugc nofollow" target="_blank">不可变架构</a>有很多好处，一个是在视图级别。</p><p id="dd0f" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">这里引用了React的<a class="ae kb" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">优化性能</a>指南:</p><blockquote class="la lb lc"><p id="d898" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">不变性使得跟踪变更变得便宜。一个改变总是会产生一个新的对象，所以我们只需要检查对该对象的引用是否已经改变。[4]</p></blockquote><h1 id="55eb" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">领域层</h1><p id="4307" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">域描述了状态并保存了业务逻辑。它代表了我们应用程序的核心，对于视图层应该是不可知的。Angular，React，Vue，应该没关系，不管选择什么框架，我们都应该能够使用自己的域。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/831c3fcbb7a027427b7f0effed3e862f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*iNmdhMwXJ53tv0fyhhpmmw.png"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">The domain layer</figcaption></figure><p id="8ea7" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">因为我们正在处理不可变的架构，我们的领域层将由实体和领域服务组成。</p><p id="230c" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">在OOP中存在争议，尤其是在大规模应用中，当处理不可变数据时，贫血域模型是完全可以接受的。</p><blockquote class="la lb lc"><p id="1ea7" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">对我来说，Vladimir Khorikov的这个<a class="ae kb" href="https://www.pluralsight.com/courses/refactoring-anemic-domain-model" rel="noopener ugc nofollow" target="_blank">课程</a>让我大开眼界。</p></blockquote><p id="f06e" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">为了显示文章列表，我们首先要建模的是<strong class="ke hv">文章</strong>实体。</p><p id="a02e" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">所有类型为<strong class="ke hv"> Article </strong>的未来对象都是不可变的。流可以通过将每个属性设为只读<strong class="ke hv"> </strong>来<a class="ae kb" href="https://flow.org/en/docs/react/redux/#typing-redux-state-immutability-a-classtoc-idtoc-typing-redux-state-immutability-hreftoc-typing-redux-state-immutabilitya" rel="noopener ugc nofollow" target="_blank">实施不变性</a>(参见每个属性前的加号)。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">Article.js</figcaption></figure><p id="b426" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">现在让我们使用工厂函数模式创建<strong class="ke hv"> articleService </strong>。</p><blockquote class="la lb lc"><p id="b856" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">看看@mpjme的这个<a class="ae kb" href="https://www.youtube.com/watch?v=ImwrezYhw4w" rel="noopener ugc nofollow" target="_blank">视频</a>吧，里面有很棒的解释<strong class="ke hv">。</strong></p></blockquote><p id="68e0" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">由于在我们的应用程序中只需要一个<strong class="ke hv"> articleService </strong>，我们将把它导出为一个singleton。</p><p id="eaf7" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv"> createArticle </strong>方法<strong class="ke hv"> </strong>将允许我们创建<strong class="ke hv"> Article </strong>类型的<a class="ae kb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">冻结对象</a>。每篇新文章将有一个唯一的自动生成的id和零喜欢，让我们只提供作者和标题。</p><blockquote class="la lb lc"><p id="e481" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">方法冻结一个对象:也就是说，防止新的属性被添加到它里面。[5]</p></blockquote><p id="e373" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv"> createArticle </strong>方法返回一个“maybe”<strong class="ke hv">Article</strong>类型。</p><blockquote class="la lb lc"><p id="058e" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated"><a class="ae kb" href="https://flow.org/en/docs/types/maybe" rel="noopener ugc nofollow" target="_blank">也许</a>类型会让你在操作一个<strong class="ke hv"> Article </strong>对象之前检查它是否存在。</p></blockquote><p id="ccca" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">如果创建文章所需的任何字段验证失败，<strong class="ke hv"> createArticle </strong>方法返回null。有些人可能认为抛出一个用户定义的异常更好。如果我们强制这样做，而上层没有实现catch块，程序将在运行时终止。</p><p id="35bb" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv">的updateLikes </strong>方法将帮助我们更新一篇<strong class="ke hv"> </strong>现有文章的赞数，方法是返回一份包含新赞数的副本。</p><p id="9e96" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">最后，<strong class="ke hv"> isTitleValid </strong>和<strong class="ke hv"> isAuthorValid </strong>方法防止<strong class="ke hv"> createArticle </strong>处理损坏的数据。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleService.js</figcaption></figure><p id="e134" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">验证对于保持数据的一致性非常重要，尤其是在领域级别。我们可以从纯函数中组合出我们的<strong class="ke hv">验证器</strong>服务。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">Validators.js</figcaption></figure><p id="c8b9" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">出于演示的目的，请对这些验证持保留态度。</p><blockquote class="la lb lc"><p id="8d17" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">在JavaScript中，检查一个对象实际上是否是一个对象并不容易。:)</p></blockquote><p id="c01d" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">我们现在有我们的领域层设置！</p><p id="9d6b" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">好的一面是，我们现在就可以使用我们的代码，与框架无关。</p><p id="601b" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">让我们看看如何使用<strong class="ke hv"> articleService </strong>来创建一篇关于我最喜欢的一本书的文章，并更新它的赞数。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">domain-demo.js</figcaption></figure><h1 id="840a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">商店层</h1><p id="34b9" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">创建和更新文章产生的数据代表了应用程序的状态。</p><p id="0f8b" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">我们需要一个存放这些数据的地方，商店是这项工作的最佳人选。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/e354910acb9723d4d3c1dab0d2447240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*h8IDykExd_PhCBhKYr9e0Q.png"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">The store layer</figcaption></figure><p id="aacd" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">这种状态很容易用一组文章来模拟。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleState.js</figcaption></figure><p id="c56f" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv"> ArticleStoreFactory </strong>实现了发布-订阅模式，并将<strong class="ke hv"> articleStore </strong>作为单例导出。</p><p id="3d94" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">商店保存文章，并对它们执行添加、删除和更新不可变操作。</p><blockquote class="la lb lc"><p id="f6f4" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">请记住，商店只经营<strong class="ke hv"> </strong>商品。只有<strong class="ke hv"> articleService </strong>可以创建或更新它们。</p></blockquote><p id="1705" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">有兴趣的可以订阅和退订<strong class="ke hv">文章库</strong>。</p><p id="002a" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">articleStore在所有订户的内存中保存一个列表，并通知他们每一个变化。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek"><a class="ae kb" href="https://gist.github.com/intojs/3acd875bf72c42c559e80e0495039bb5#file-articlestorefactory-js" rel="noopener ugc nofollow" target="_blank">ArticleStore.js</a></figcaption></figure><p id="32d7" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">我们的商店实现对于演示目的是有意义的，允许我们理解它背后的概念。在现实生活中，我推荐使用类似<a class="ae kb" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>、<a class="ae kb" href="https://github.com/ngrx" rel="noopener ugc nofollow" target="_blank"> ngrx </a>、<a class="ae kb" href="https://github.com/mobxjs/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>或者至少是<a class="ae kb" rel="noopener" href="/bucharestjs/the-developers-guide-to-redux-like-state-management-in-angular-3799f1877bb">可观察数据服务</a>的状态管理系统。</p><p id="f740" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">好了，现在我们已经设置了域和商店层。</p><p id="d453" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">让我们为商店创建两个文章和两个订阅者，并观察订阅者是如何得到更改通知的。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">store-demo.js</figcaption></figure><h1 id="3df8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">应用服务程序</h1><p id="f90d" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">这一层对于执行与状态流相邻的各种操作非常有用，比如Ajax调用从服务器或状态预测中检索数据。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/3ee4318da084467e3b96f4f3360850ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ZVstPN2LBFjdPoRaFq4SEw.png"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">The application services layer</figcaption></figure><p id="1c8a" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">不管出于什么原因，设计师会要求所有作者的名字都是大写的。</p><p id="35db" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">我们知道这个要求有点傻，我们不想让它污染我们的模型。</p><p id="6684" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">我们创建了<strong class="ke hv">articleiservice</strong>来处理这个特性。该服务将获取一个状态，即作者的名字，并对其进行投影，将它的大写版本返回给调用者。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleUiService.js</figcaption></figure><p id="0e8b" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">让我们来看一个如何使用该服务的演示！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">app-service-demo.js</figcaption></figure><h1 id="135b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">视图层</h1><p id="628e" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">现在我们有一个完全正常工作的应用程序，不依赖于任何框架，随时可以被React投入使用。</p><p id="7c33" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">视图层由表示组件和容器组件组成。</p><p id="3f00" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">表示组件关注事物的外观，而容器组件关注事物的工作方式。详细的解释请看丹·阿布拉莫夫的<a class="ae kb" rel="noopener" href="/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">文章</a>。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/5cbde24cbcda657f31876a990fa8f99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*R-6nKbTqru_qsdg8O7PJJg.png"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">The view layer</figcaption></figure><p id="35b0" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">让我们构建<strong class="ke hv"> App </strong>组件，由<strong class="ke hv"> ArticleFormContainer </strong>和<strong class="ke hv"> ArticleListContainer组成。</strong></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">App.js</figcaption></figure><p id="bf87" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">现在让我们创建<strong class="ke hv"> ArticleFormContainer。</strong>有反应，有棱角，不要紧，形态复杂。</p><blockquote class="la lb lc"><p id="3c89" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">查看<a class="ae kb" href="http://ramdajs.com" rel="noopener ugc nofollow" target="_blank"> Ramda </a>库以及它的方法如何增强我们代码的声明性。</p></blockquote><p id="297e" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">该表单接受用户输入，并将其传递给<strong class="ke hv"> articleService </strong>。该服务从该输入创建一个<strong class="ke hv">文章</strong>，并将其添加到<strong class="ke hv">文章存储库</strong>，供感兴趣的组件使用。所有这些逻辑主要存在于<strong class="ke hv"> submitForm </strong>方法中。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleFormContainer.js</figcaption></figure><p id="4da8" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">注意，<strong class="ke hv"> ArticleFormContainer </strong>返回用户看到的实际表单，即表象的<strong class="ke hv"> ArticleFormComponent </strong>。该组件显示容器传递的数据，并发出类似<strong class="ke hv"> changeArticleTitle </strong>、<strong class="ke hv"> changeArticleAuthor </strong>和<strong class="ke hv"> submitForm </strong>的事件。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek"><a class="ae kb" href="https://gist.github.com/intojs/4a41a3817de53c9c8767d11d96d61d79" rel="noopener ugc nofollow" target="_blank">ArticleFormComponent.js</a></figcaption></figure><p id="fc92" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">现在我们有了创建文章的表单，是时候列出它们了。<strong class="ke hv">文章列表容器</strong>订阅<strong class="ke hv">文章库</strong>，获取所有文章并显示<strong class="ke hv">文章列表组件</strong>。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleListContainer.js</figcaption></figure><p id="feb9" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv">文章列表组件</strong>是一个表示组件。它通过道具接收物品并渲染<strong class="ke hv">物品容器</strong>组件。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleListComponent.js</figcaption></figure><p id="a52d" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv"> ArticleContainer </strong>将文章数据传递给表示的<strong class="ke hv"> ArticleComponent </strong>。它还实现了<strong class="ke hv"> likeArticle </strong>和<strong class="ke hv"> removeArticle </strong>方法。</p><p id="ce8a" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv"> likeArticle </strong>方法通过用更新的副本替换商店中现有的文章来更新喜欢的数量。</p><p id="79f4" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv"> removeArticle </strong>方法从存储中删除文章。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleContainer.js</figcaption></figure><p id="8b86" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv">文章容器</strong>将文章数据传递给<strong class="ke hv">文章组件</strong>并显示。它还通过执行适当的回调，在点击like或delete按钮时通知容器组件。</p><blockquote class="la lb lc"><p id="de5f" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz hn dt translated">还记得作者名字要大写的疯狂要求吗？</p></blockquote><p id="ec51" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated"><strong class="ke hv"> ArticleComponent </strong>使用来自应用层的<strong class="ke hv"> ArticleUiService </strong>将一段状态从其原始值(没有大写规则的字符串)投射到所需的值，即大写字符串。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">ArticleComponent.js</figcaption></figure><h1 id="e6d1" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">干得好！</h1><p id="c6e8" class="pw-post-body-paragraph kc kd hu ke b kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ll kx ky kz hn dt translated">我们现在有了一个全功能的React应用程序和一个健壮的、定义清晰的架构。任何加入我们团队的人都可以阅读这篇文章，并放心地继续我们的工作。:)</p><p id="891d" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">你可以在这里查看完成的app <a class="ae kb" href="https://intojs.github.io/architecting-single-page-applications/" rel="noopener ugc nofollow" target="_blank">，在这里</a>查看GitHub库<a class="ae kb" href="https://github.com/intojs/architecting-single-page-applications" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3fa1" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">如果你喜欢这个指南，请为它鼓掌。如果你想帮我改进它，我对你的评论很感兴趣。<a class="ae kb" href="http://twitter.com/danielDughy" rel="noopener ugc nofollow" target="_blank"> @danielDughy </a></p><p id="3de6" class="pw-post-body-paragraph kc kd hu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">[1]<a class="ae kb" href="https://en.wikipedia.org/wiki/Flip_book" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Flip_book</a><br/>【2】<a class="ae kb" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">https://reactjs.org</a><br/>【3】<a class="ae kb" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">https://angular . io</a><br/>【4】<a class="ae kb" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/optimizing-performance.html</a><br/>【5】<a class="ae kb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Object/freeze</a></p></div></div>    
</body>
</html>