<html>
<head>
<title>Functional Programming in JS: map, filter, reduce (Pt. 5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中的函数式编程:map，filter，reduce (Pt。5)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-programming-in-js-map-filter-reduce-pt-5-308a205fdd5f?source=collection_archive---------1-----------------------#2018-03-12">https://medium.com/hackernoon/functional-programming-in-js-map-filter-reduce-pt-5-308a205fdd5f?source=collection_archive---------1-----------------------#2018-03-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="84cc" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">注意:这是学习JavaScript ES6+中函数式编程技术的“Javascript和函数式编程”系列的一部分。查看上一篇关于curry<a class="ae jt" href="https://hackernoon.com/javascript-and-functional-programming-currying-pt-4-96e3230782ab" rel="noopener ugc nofollow" target="_blank">&lt;Part 4&gt;</a>的功能文章。从<a class="ae jt" href="https://hackernoon.com/javascript-and-functional-programming-an-introduction-286aa625e26d" rel="noopener ugc nofollow" target="_blank">开始，从这里</a>开始。</p></blockquote><p id="59cb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">来点实际的吧！之前，我们研究了<em class="iw">高阶函数。</em>作为一个快速提醒<em class="iw">，</em>高阶函数<em class="iw">是一个</em> <strong class="ix hv">函数，它接受另一个函数作为参数。</strong></p><p id="fa14" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><a class="ae jt" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>数组有几个<strong class="ix hv">内置方法</strong>是高阶函数。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/6bbdf1eff3ea24b0e4b7a8217daf2248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRAwpLpaqSMBV6VOHY_Vdw.png"/></div></div></figure><p id="5816" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这篇文章将讨论3个最流行的:<em class="iw">过滤，映射和减少。</em>🙂🙂</p><h2 id="d657" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">过滤器</h2><blockquote class="ir is it"><p id="a521" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">filter array方法创建一个新数组，其中所有元素都通过了由提供的函数实现的测试。</p></blockquote><p id="1afb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这是直接从文件出来的<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">。以一种更友好的方式来说，filter是一种在给定集合/数组上运行的方法，它基于返回布尔值(true或false)的函数来过滤项目。</a></p><p id="8060" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">让我们先来看一个例子，然后逐步了解实际发生了什么。在我们的例子中，我们假设下面的集合。</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="faae" class="kj kk hu lf b fv lj lk l ll lm">const iceCreams = [<br/>  { flavor: 'pineapple', color: 'white' },<br/>  { flavor: 'strawberry', color: 'red' },<br/>  { flavor: 'watermelon', color: 'red' },<br/>  { flavor: 'kiwi', color: 'green' },<br/>  { flavor: 'mango', color: 'yellow' },<br/>  { flavor: 'pear', color: 'green' }<br/>];</span></pre><p id="2cb8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">让我们使用filter方法创建一个新的数组，其中只有红色的冰淇淋。记住，filter创建了一个新的数组，因此我们必须将函数的输出保存到一个变量中，以便以后使用。</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="4d4d" class="kj kk hu lf b fv lj lk l ll lm">const favoriteFlavors = iceCreams<br/>    .filter(iceCream =&gt; iceCream.color === 'red');</span><span id="bf28" class="kj kk hu lf b fv ln lk l ll lm">console.log(favoriteFlavors);</span></pre><p id="1633" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在控制台中运行此代码片段将产生以下输出:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff lo"><img src="../Images/3a340a2f994057d51185125edff8e8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YWAhyJYbdFDYtJTr57G0Q.png"/></div></div></figure><p id="147f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果你感到有点困惑，那很好。让我们走一遍:)</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/051c26700cec0899cc3afc8119d23fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Mo0oHuz4hx4P8pmcXI5wfg.gif"/></div></figure><p id="c9c1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">的。<strong class="ix hv"> <em class="iw"> filter </em> </strong>方法接受带有4个参数的函数，顺序如下</p><ul class=""><li id="0b70" class="lq lr hu ix b iy iz jc jd ju ls jv lt jw lu js lv lw lx ly dt translated"><strong class="ix hv">元素</strong>-数组的当前元素</li><li id="e2c3" class="lq lr hu ix b iy lz jc ma ju mb jv mc jw md js lv lw lx ly dt translated"><strong class="ix hv">索引</strong> -数组的当前索引(可选)</li><li id="1201" class="lq lr hu ix b iy lz jc ma ju mb jv mc jw md js lv lw lx ly dt translated"><strong class="ix hv">数组</strong> -对数组本身的引用(可选)</li><li id="c903" class="lq lr hu ix b iy lz jc ma ju mb jv mc jw md js lv lw lx ly dt translated"><strong class="ix hv">this arg</strong>-执行回调时用作this的值(可选)</li></ul><p id="336c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">总之，我们需要提供一个具有以下签名的函数</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/9514596692ba55576632c5bc5bafc2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_cXL8CA4cETkVtW5fbmhQ.png"/></div></div></figure><p id="2971" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">请注意，在我们的示例中，我们传递了一个匿名函数(它没有命名！)我们也可以选择传递一个命名函数，如下所示:</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="74c8" class="kj kk hu lf b fv lj lk l ll lm">const getRed = icecream =&gt; icecream.color === 'red';</span><span id="b629" class="kj kk hu lf b fv ln lk l ll lm">const favoriteFlavors = iceCreams<br/>    .filter(getRed);</span><span id="36e7" class="kj kk hu lf b fv ln lk l ll lm">console.log(favoriteFlavors);</span></pre><p id="a275" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">输出将如下所示:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff me"><img src="../Images/de12987adaff9df272f4b4151c23bcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60EGsl46qLXtxxGZmq7a-g.png"/></div></div></figure><p id="2543" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">请注意，我们传递了用元素参数隐式调用的getRed函数。</p><p id="d21d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">过滤是一种快速解析数据的好方法，只留下与我们相关的内容。如果你是第一次阅读，传递一个遵循特定结构的函数的想法可能看起来有点笨拙，但最终会变得非常强大。首先，这种结构使开发人员更容易阅读彼此的代码。其次，在检查<em class="iw">时，我们现在将使用相同的模式。地图</em>阵列法😎😎😎😎😎</p><h2 id="f428" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">地图</h2><p id="1b49" class="pw-post-body-paragraph iu iv hu ix b iy mf ja jb jc mg je jf ju mh ji jj jv mi jm jn jw mj jq jr js hn dt translated"><code class="eh mk ml mm lf b"><strong class="ix hv">map()</strong></code>方法创建一个新数组，其结果是在调用数组中的每个元素上调用一个提供的函数。本质上，map方法<em class="iw">基于初始数组创建了一个新数组</em>。快速看了一下<strong class="ix hv"> <em class="iw">地图()</em> </strong>签名:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/b14710b85f4dce774b4cc7ed88e2a14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkcYRGvVCLfOBYqDP2SBXg.png"/></div></div></figure><p id="f164" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">就像<strong class="ix hv"> <em class="iw"> filter() </em> </strong>，<strong class="ix hv"> <em class="iw"> map() </em> </strong>是另一个高阶函数。类似于<strong class="ix hv"> <em class="iw"> filter() </em> </strong>的方法结构我们在这里也必须传递一个函数。但是我们不是过滤原始数组中的项目，而是转换数据。</p><p id="eb22" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt">🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔</p><p id="2836" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们来看一个例子来阐明！我们将使用上一个示例中的数组。</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="3048" class="kj kk hu lf b fv lj lk l ll lm">const iceCreams = [<br/>  { flavor: 'pineapple', color: 'white' },<br/>  { flavor: 'strawberry', color: 'red' },<br/>  { flavor: 'watermelon', color: 'red' },<br/>  { flavor: 'kiwi', color: 'green' },<br/>  { flavor: 'mango', color: 'yellow' },<br/>  { flavor: 'pear', color: 'green' }<br/>];</span></pre><p id="ad57" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">假设我们想要创建一个新的字符串数组，包含所有口味的冰淇淋。在我们使用<strong class="ix hv"> <em class="iw"> map() </em> </strong>之前，让我们试着用经典的<strong class="ix hv"> <em class="iw"> </em> </strong>这种老派的方式来进行循环。</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="2e57" class="kj kk hu lf b fv lj lk l ll lm">let flavors = [];<br/>for (let i = 0; i &lt; iceCreams.length; i++) {<br/>    flavors.push(iceCreams[i].flavor)<br/>}</span><span id="7cdf" class="kj kk hu lf b fv ln lk l ll lm">console.log(flavors);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mn"><img src="../Images/a6531b0d0db26f98787e7c5433204dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65Ly7CXSyJw9OokiQUfUPw.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Our output from the for loop code snippet</figcaption></figure><p id="52e2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">从技术上讲，对于这个简单的例子来说，这样做很好。但是，当像这样对循环使用<em class="iw">时，您是否看到了一些悄悄出现的问题？我的悲观主义认为这里有三个机会搞砸😳😳😳</em></p><ul class=""><li id="3efd" class="lq lr hu ix b iy iz jc jd ju ls jv lt jw lu js lv lw lx ly dt translated">定义迭代器值</li></ul><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="dc3f" class="kj kk hu lf b fv lj lk l ll lm">let i = 0; </span></pre><ul class=""><li id="6f05" class="lq lr hu ix b iy iz jc jd ju ls jv lt jw lu js lv lw lx ly dt translated">为循环定义<em class="iw">的结束值</em></li></ul><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="8d56" class="kj kk hu lf b fv lj lk l ll lm">i &lt; iceCreams.length</span></pre><ul class=""><li id="c98b" class="lq lr hu ix b iy iz jc jd ju ls jv lt jw lu js lv lw lx ly dt translated">递增迭代器值</li></ul><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="6a79" class="kj kk hu lf b fv lj lk l ll lm">i++</span></pre><p id="ee74" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在不同的情况下，根据我们的数据，这里很容易出现错误。这可能是一个简单的输入错误，比如忘记了一个分号，或者错误地将迭代器实例化为错误的值。</p><p id="b215" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">再用<strong class="ix hv"> <em class="iw"> map() </em> </strong>的方法试试同样的方法。</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="00f1" class="kj kk hu lf b fv lj lk l ll lm">const iceCreams = [<br/>  { flavor: 'pineapple', color: 'white' },<br/>  { flavor: 'strawberry', color: 'red' },<br/>  { flavor: 'watermelon', color: 'red' },<br/>  { flavor: 'kiwi', color: 'green' },<br/>  { flavor: 'mango', color: 'yellow' },<br/>  { flavor: 'pear', color: 'green' }<br/>];</span><span id="ecea" class="kj kk hu lf b fv ln lk l ll lm">const flavors = iceCreams.map(icecream =&gt; icecream.flavor)<br/>console.log(flavors)</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ms"><img src="../Images/441b7b9433a53123c457e4f32b2a6b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sANCYWy7AE5Qd8AHyy-W0A.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">OMG?!!</figcaption></figure><p id="a2e2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们的输出是相同的，但是请注意代码是多么的简洁明了。没有索引，没有分号，没有声明数据长度！自从用<strong class="ix hv"> <em class="iw"> map() </em> </strong>和<strong class="ix hv"> <em class="iw"> filter()，</em> </strong>编程以来，我注意到，基于我们的集合/数组的复杂性，与循环相比，使用这些函数方法的容易程度显著提高了。这些绝对值得整合到您的日常编程工作流程中。</p><h2 id="5a94" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">减少</h2><p id="ddb7" class="pw-post-body-paragraph iu iv hu ix b iy mf ja jb jc mg je jf ju mh ji jj jv mi jm jn jw mj jq jr js hn dt translated">终于！正如克里斯蒂安·酒井在之前的评论中提到的，reduce是所有这些方法的鼻祖👵🏻👵🏻👵🏻👵🏻👵🏻👵🏻👵🏻</p><p id="d7b9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">根据<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="ir is it"><p id="0341" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><code class="eh mk ml mm lf b"><strong class="ix hv">reduce()</strong></code>方法对一个累加器和数组中的每个元素(从左到右)应用一个函数，将其减少到一个值。</p></blockquote><p id="6a99" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这太神秘了！让我们把这个的意思“简化”成简单的东西。让我们再回到<strong class="ix hv"> <em class="iw"> filter() </em> </strong>，和<strong class="ix hv"> <em class="iw"> map() </em> </strong>方法。他们有什么共同点？本质上，它们将一个集合/数组转换成一个不同的集合/数组。但是这些方法在如何转换数据方面是特定的。相比较而言，<strong class="ix hv"> <em class="iw"> reduce() </em> </strong>就像是瑞士军刀对列表的变换。它可以用来表达<strong class="ix hv">任何</strong>变换！事实上，我们甚至可以用<strong class="ix hv"> <em class="iw"> reduce() </em> </strong>来实现<strong class="ix hv"> <em class="iw"> map() </em> </strong>和<strong class="ix hv"> <em class="iw"> filter()。</em> </strong>说够了！让我们来看看对数组求和的经典reduce示例🙃 🙃 🙃 🙃</p><p id="4795" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">先用<em class="iw">作</em>循环</strong></p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="a3af" class="kj kk hu lf b fv lj lk l ll lm">const arr = [10,20,30]</span><span id="cda8" class="kj kk hu lf b fv ln lk l ll lm">let total = 0;<br/>for(let i = 0; i &lt; arr.length; i++) {<br/>    total += arr[i]</span><span id="190a" class="kj kk hu lf b fv ln lk l ll lm">}</span><span id="7902" class="kj kk hu lf b fv ln lk l ll lm">console.log(total);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mv"><img src="../Images/1e55b7da20870b8de9df902cd435e58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqcMkXc1McLHfMZVEtQHNQ.png"/></div></div></figure><p id="3ddb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">现在随着减少</strong></p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="2773" class="kj kk hu lf b fv lj lk l ll lm">const arr = [10, 20, 30];</span><span id="61f6" class="kj kk hu lf b fv ln lk l ll lm">const reducerFunction = (acc, currentItem) =&gt; acc + currentItem;</span><span id="3f2c" class="kj kk hu lf b fv ln lk l ll lm">const sum = arr.reduce(reducerFunction, 0);<br/>console.log(sum);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mw"><img src="../Images/89a05cc0f473ea87abe66534b9a67f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsPPjyvJBtfdfy0A3oFqQA.png"/></div></div></figure><p id="e241" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">很明显，我们得到了同样的结果。我们来分解一下。内置数组方法<strong class="ix hv"><em class="iw">reduce()</em></strong><em class="iw"/><strong class="ix hv">需要一个回调函数作为第一个参数。</strong>这个回调函数在其输入中是预先确定的，最多接受4个参数，类似于<strong class="ix hv"> <em class="iw"> filter()和map() </em> </strong>期望的回调。我们来看看预期的<strong class="ix hv"> <em class="iw"> reducer() </em> </strong>函数签名。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/10f02bbacfd6b87f8311a7f1c0a62304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQrjP0aMK7xY1_SSHO2kjg.png"/></div></div></figure><p id="6cfe" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw"> reduce() </em> </strong>第二个参数是可选的，是initialValue。当我们迭代一个数组并试图将它减少到一个单一值时，建议实例化初始值。在我们的<em class="iw">数组求和</em>示例中，我们将<em class="iw"> initialValue </em>实例化为零。如果我们没有实例化初始值，会发生什么？</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="00f7" class="kj kk hu lf b fv lj lk l ll lm">const arr = [10, 20, 30];</span><span id="121e" class="kj kk hu lf b fv ln lk l ll lm">const reducerFunction = (acc, currentItem) =&gt; acc + currentItem;</span><span id="3c02" class="kj kk hu lf b fv ln lk l ll lm">// Not instantiating the initial value!<br/>const sum = arr.reduce(reducerFunction);<br/>console.log(sum);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mx"><img src="../Images/cf44e62c5c8590e8a77ba7bd97c43dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6M04mrhUSiYo03X5Ei_xA.png"/></div></div></figure><p id="7f3b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们得到相同的值！这是为什么呢？根据文档，当没有提供<em class="iw"> initialValue </em>时，将使用数组中的第一个元素。虽然这个例子没有提供初始值，但是<strong class="ix hv">我建议习惯于总是提供一个</strong>。这将防止<a class="ae jt" href="https://hackernoon.com/tagged/future" rel="noopener ugc nofollow" target="_blank">未来的</a>错误，并且还需要您思考您试图在您的阵列上进行的<em class="iw">缩减</em>是否有意义。</p><h2 id="a56d" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">实现<strong class="ak"><em class="my">map()</em></strong><strong class="ak"><em class="my">filter()</em></strong>与<strong class="ak"> <em class="my"> reduce() </em> </strong></h2><p id="0a8b" class="pw-post-body-paragraph iu iv hu ix b iy mf ja jb jc mg je jf ju mh ji jj jv mi jm jn jw mj jq jr js hn dt translated">前面我声称<strong class="ix hv"> <em class="iw"> reduce() </em> </strong>是列表转换方法的始祖，因为我们可以用它来实现所有的方法。让我们证明这一点！</p><p id="e911" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">地图与减少()</em> </strong></p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="6f49" class="kj kk hu lf b fv lj lk l ll lm">// ************* Map with Reduce *************</span><span id="914e" class="kj kk hu lf b fv ln lk l ll lm">const data = [10, 20, 30];</span><span id="0e68" class="kj kk hu lf b fv ln lk l ll lm">const tripledWithMap = data.map(item =&gt; {<br/>  return item * 3;<br/>});</span><span id="5d6e" class="kj kk hu lf b fv ln lk l ll lm"><br/>const tripledWithReduce = data.reduce((acc, value) =&gt; {<br/>  acc.push(value * 3);<br/>  return acc;<br/>}, []);</span><span id="d5df" class="kj kk hu lf b fv ln lk l ll lm">console.log(tripledWithMap, tripledWithReduce);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mz"><img src="../Images/bc3f10b920a0e4264ccf0a8c8b1fb7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FKiyTWLR3yhedGfFJ7VEA.png"/></div></div></figure><p id="4c24" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">用reduce()过滤</em> </strong></p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="85be" class="kj kk hu lf b fv lj lk l ll lm">// ************* Filter with Reduce *************</span><span id="e7b8" class="kj kk hu lf b fv ln lk l ll lm">const data2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><span id="6db9" class="kj kk hu lf b fv ln lk l ll lm">const evenWithFilter = data2.filter(item =&gt; {<br/>  return item % 2 === 0;<br/>})</span><span id="f30f" class="kj kk hu lf b fv ln lk l ll lm">const evenWithReduce = data2.reduce((acc, value) =&gt; {<br/>  if (value % 2 === 0) {<br/>    acc.push(value);<br/>  }</span><span id="31ec" class="kj kk hu lf b fv ln lk l ll lm">return acc;<br/>}, []);</span><span id="0bfc" class="kj kk hu lf b fv ln lk l ll lm">console.log(evenWithFilter, evenWithReduce);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff na"><img src="../Images/326f55955e16ed192f27b3819184f1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J01FkBbvZIz8pwf_AZhckQ.png"/></div></div></figure><h2 id="94bb" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">一个更实际的reduce()例子</h2><p id="294d" class="pw-post-body-paragraph iu iv hu ix b iy mf ja jb jc mg je jf ju mh ji jj jv mi jm jn jw mj jq jr js hn dt translated">让我们用我们的<strong class="ix hv"> <em class="iw"> reduce() </em> </strong>方法做一些更有用的事情。让我们计算一下最佳冰淇淋口味的投票结果🍦🍦🍦🍦🍓🍋 🍌 🍉 🍇</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="636b" class="kj kk hu lf b fv lj lk l ll lm">const flavours = [<br/>  "strawberry",<br/>  "strawberry",<br/>  "kiwi",<br/>  "kiwi",<br/>  "kiwi",<br/>  "strawberry",<br/>  "mango",<br/>  "kiwi",<br/>  "banana"<br/>];</span><span id="cc88" class="kj kk hu lf b fv ln lk l ll lm">const votes = {};<br/>const reducer = (votes, vote) =&gt; {<br/>  votes[vote] = !votes[vote] ? (votes[vote] = 1) : votes[vote] + 1;</span><span id="8729" class="kj kk hu lf b fv ln lk l ll lm">return votes;<br/>};<br/>const outcome = flavours.reduce(reducer, votes);</span><span id="9266" class="kj kk hu lf b fv ln lk l ll lm">// Output<br/>console.log("Strawberry: ", outcome.strawberry);<br/>console.log("Kiwi: ", outcome.kiwi);<br/>console.log("Mango: ", outcome.mango);<br/>console.log("Banana: ", outcome.banana);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff nb"><img src="../Images/beb04209ca488d98c3cb6bee6f78b674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBSzBJKAvoKvXKXa1OxJBw.png"/></div></div></figure><p id="e616" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">类似于我们使用reduce的任何时候，我们在一个数组上调用<strong class="ix hv"> <em class="iw"> reduce() </em> </strong>方法，并提供回调和initialValue。注意，在这个例子中，我们将初始值设置为一个空对象。如果没有初始化，这将会失败！</p><h2 id="5b62" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">用reduce扁平化数据</h2><p id="fe98" class="pw-post-body-paragraph iu iv hu ix b iy mf ja jb jc mg je jf ju mh ji jj jv mi jm jn jw mj jq jr js hn dt translated">首先，让我们为我们的例子定义扁平化数据。展平看起来像这样:</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="bde5" class="kj kk hu lf b fv lj lk l ll lm">[[a, b, c], [d, e, f], [g, h i]] -&gt; [a, b, c, d, e, f, g, h, i]</span></pre><p id="6ac9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">本质上，我们希望按照数组出现的顺序合并所有的数组。<strong class="ix hv"> <em class="iw"> reduce() </em> </strong>很好地解决了这个问题🤗🤗</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="4829" class="kj kk hu lf b fv lj lk l ll lm">const letterArr = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']];<br/>const flattened = letterArr.reduce((acc, val) =&gt; {<br/>  return acc.concat(val);<br/>}, []);</span><span id="bc7d" class="kj kk hu lf b fv ln lk l ll lm">console.log(flattened);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff nc"><img src="../Images/2340c129ae5afd23465655acb3fbfdc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vs11Ye6h4uYUXMwmW-_Zng.png"/></div></div></figure><h2 id="d07f" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">列表转换器的性能</h2><p id="ef6b" class="pw-post-body-paragraph iu iv hu ix b iy mf ja jb jc mg je jf ju mh ji jj jv mi jm jn jw mj jq jr js hn dt translated">一种常见的模式是链表变压器。虽然它使复杂的转换更容易阅读，但在处理非常大的数组时速度不够快。让我们看一个例子。</p><pre class="jy jz ka kb fq le lf lg lh aw li dt"><span id="c580" class="kj kk hu lf b fv lj lk l ll lm">let bigData = [];<br/>for (let i = 0; i &lt; 1000000; i++) {<br/>  bigData[i] = i;<br/>}</span><span id="e006" class="kj kk hu lf b fv ln lk l ll lm">// Slow<br/>let filterBegin = Date.now();<br/>const filterMappedBigData = bigData<br/>  .filter(value =&gt; value % 2 === 0)<br/>  .map(value =&gt; value * 2);<br/>  <br/>let filterEnd = Date.now();<br/>let filtertimeSpent = (filterEnd - filterBegin) / 1000 + "secs";</span><span id="9362" class="kj kk hu lf b fv ln lk l ll lm">// Fast<br/>let reducedBegin = Date.now();<br/>const reducedBigData = bigData.reduce((acc, value) =&gt; {<br/>  if (value % 2 === 0) {<br/>    acc.push(value * 2);<br/>  }<br/>  return acc;<br/>}, []);<br/>let reducedEnd = Date.now();<br/>let reducedtimeSpent = (reducedEnd - reducedBegin) / 1000 + " secs";</span><span id="0688" class="kj kk hu lf b fv ln lk l ll lm">console.log("filtered Big Data:", filtertimeSpent);<br/>console.log("reduced Big Data:", reducedtimeSpent);</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff nd"><img src="../Images/cc0180a263b0f3737ce1f91ab72135a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJ6M5zf8wGJcJF5K_iEFKA.png"/></div></div></figure><p id="8333" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为什么滤镜和贴图的链接这么慢？第一个<strong class="ix hv"> <em class="iw"> filter() </em> </strong>需要遍历整个数组(1，000，000)，过滤一半。然后<strong class="ix hv"> <em class="iw"> map() </em> </strong>遍历数组余数(500，000)并创建新数组。相比之下，在<strong class="ix hv"> <em class="iw"> reduce() </em> </strong>中我们只迭代一次数组！不经常迭代相同的数据集更有效，但性能较差。</p><h2 id="bb82" class="kj kk hu bd kl km kn ko kp kq kr ks kt ju ku kv kw jv kx ky kz jw la lb lc ld dt translated">如果这篇文章有帮助，请点击拍手👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph iu iv hu ix b iy mf ja jb jc mg je jf ju mh ji jj jv mi jm jn jw mj jq jr js hn dt translated">如果你对更多科技和创业相关的内容感兴趣，可以在<a class="ae jt" rel="noopener" href="/@omergoldberg"> Medium </a>、<a class="ae jt" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae jt" href="https://github.com/Arieg419" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae jt" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上关注我。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>