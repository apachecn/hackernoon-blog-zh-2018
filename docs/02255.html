<html>
<head>
<title>Deploying Java Applications with Kubernetes and an API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes和API网关部署Java应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deploying-java-applications-with-kubernetes-and-an-api-gateway-fc471644bea7?source=collection_archive---------3-----------------------#2018-03-13">https://medium.com/hackernoon/deploying-java-applications-with-kubernetes-and-an-api-gateway-fc471644bea7?source=collection_archive---------3-----------------------#2018-03-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ebf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，您将了解如何将三个简单的Java服务部署到Kubernetes中(通过新的Docker for Mac/Windows Kubernetes集成在本地运行)，并通过Kubernetes-native Ambassador API网关向最终用户公开前端服务。所以，拿起你选择的含咖啡因的饮料，在你的终端前舒服地休息一下吧！</p><h1 id="7e04" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">快速回顾:架构和部署</h1><p id="d9ff" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">去年10月<a class="ae ks" href="https://twitter.com/danielbryantuk/" rel="noopener ugc nofollow" target="_blank"> Daniel Bryant </a>在<a class="ae ks" href="https://www.oreilly.com/ideas/how-to-manage-docker-containers-in-kubernetes-with-java" rel="noopener ugc nofollow" target="_blank"> Kubernetes支持下</a>扩展了他简单的基于Java微服务的“<a class="ae ks" href="https://github.com/danielbryantuk/oreilly-docker-java-shopping" rel="noopener ugc nofollow" target="_blank"> Docker Java Shopping </a>容器部署演示。如果您有时间完成本教程，您应该已经在Docker镜像中打包了三个简单的Java服务——Spring Boot商店和库存管理器服务，以及产品目录Java EE DropWizard服务，并且将生成的容器部署到本地的由minikube支持的Kubernetes集群中。他还向您展示了如何通过使用<a class="ae ks" href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport" rel="noopener ugc nofollow" target="_blank">节点端口服务</a>映射和公开Kubernetes集群端口，向最终用户开放店面服务。虽然这对于演示来说是可行的，但是许多人问如何在API网关后面部署应用程序。这是一个很好的问题，因此我们渴望在本教程系列中添加另一篇文章(在Daniel的帮助下)，目标是在开源的Kubernetes-native<a class="ae ks" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank">Ambassador API Gateway</a>后面部署“Docker Java Shopping”Java应用程序。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/27709612cc974cd7f5ade2844f1ad86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/0*JHScUqnLojiDps59."/></div></figure><p id="ee60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">图一。与Ambassador API网关一起部署的“Docker Java购物”应用程序</strong></p><h1 id="679e" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">快速旁白:为什么要使用API网关？</h1><p id="ccb3" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">你们中的许多人以前都用过(或者至少碰到过)API网关的概念。Chris Richardson在<a class="ae ks" href="http://microservices.io/patterns/apigateway.html" rel="noopener ugc nofollow" target="_blank"> microservices.io </a>上写了一篇很好的细节概述，而创建大使API网关<a class="ae ks" href="https://www.datawire.io/" rel="noopener ugc nofollow" target="_blank"> Datawire </a>的团队也谈到了使用<a class="ae ks" href="https://www.getambassador.io/about/why-ambassador" rel="noopener ugc nofollow" target="_blank"> Kubernetes-native API网关</a>的好处。API网关允许你集中应用程序的许多横切关注点，比如负载平衡、安全和速率限制。此外，API网关可以成为帮助<a class="ae ks" href="https://blog.getambassador.io/continuous-delivery-how-can-an-api-gateway-help-or-hinder-1ff15224ec4d" rel="noopener ugc nofollow" target="_blank">加速持续交付</a>的有用工具。运行Kubernetes-native API网关还允许您将一些与部署和维护网关相关的操作问题——比如实现弹性和可伸缩性——转移到Kubernetes本身。</p><p id="d19c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Java开发者有几个API网关可供选择，比如<a class="ae ks" href="https://github.com/Netflix/zuul" rel="noopener ugc nofollow" target="_blank">网飞的Zuul </a>、<a class="ae ks" href="https://cloud.spring.io/spring-cloud-gateway/" rel="noopener ugc nofollow" target="_blank"> Spring Cloud Gateway </a>、<a class="ae ks" href="https://getkong.org/" rel="noopener ugc nofollow" target="_blank"> Mashape的Kong </a>，一个云厂商的实现(比如<a class="ae ks" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank">亚马逊的API网关</a>，当然还有传统热门的<a class="ae ks" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>和<a class="ae ks" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>，还有一些更现代的变种比如<a class="ae ks" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>。选择一个API网关需要做大量的工作，因为这是你的基础设施的一个关键部分(将每一点流量都接触到你的应用程序)，并且有许多权衡要考虑。特别是，注意潜在的高耦合点——例如，<a class="ae ks" href="https://github.com/Netflix/zuul/wiki/zuul-simple-webapp" rel="noopener ugc nofollow" target="_blank">将“Filter”</a>Groovy脚本动态部署到的Zuul中的能力使业务逻辑能够在服务和网关之间传播——以及随着最终用户流量的增加部署复杂数据存储的需求——例如，Kong需要一个<a class="ae ks" href="https://getkong.org/about/faq/#how-does-it-work" rel="noopener ugc nofollow" target="_blank"> Cassandra集群或Postgres安装</a>来进行水平扩展。</p><p id="92ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了简单起见，本文中我们将使用开源的Kubernetes-native API Gateway，Ambassador。Ambassador有一个简单的实现，减少了偶然将任何业务逻辑耦合到它上面的可能性。它还允许您通过声明性方法指定服务路由，这种方法与Kubernetes和其他现代基础设施的“原生云”方法一致。额外的好处是，路由可以很容易地存储在版本控制中，并与所有其他代码更改一起被推入CI/CD构建管道。</p><h1 id="bfb3" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">入门:节点端口和负载平衡器101</h1><p id="7f99" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">首先，确保您从一个新的(空的)Kubernetes集群开始。这个演示将使用Docker for Mac中新的Kubernetes集成。如果你想继续下去，你需要确保你已经安装了Mac版的<a class="ae ks" href="https://blog.docker.com/2018/01/docker-mac-kubernetes/" rel="noopener ugc nofollow" target="_blank">Docker</a>或者Windows版的<a class="ae ks" href="https://blog.docker.com/2018/01/docker-windows-desktop-now-kubernetes/" rel="noopener ugc nofollow" target="_blank">Docker</a>，并且按照<a class="ae ks" href="https://docs.docker.com/docker-for-mac/#kubernetes" rel="noopener ugc nofollow" target="_blank"> Docker Kubernetes文档</a>中的说明启用了Kubernetes支持。在切换到Ambassador之前，我们将首先使用节点端口设置入口。如果你有兴趣了解更多关于Kubernetes ingress的细微差别，<a class="ae ks" href="https://blog.getambassador.io/kubernetes-ingress-nodeport-load-balancers-and-ingress-controllers-6e29f1c44f2d" rel="noopener ugc nofollow" target="_blank">这篇文章有更多的细节</a>。</p><p id="9f5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来克隆<a class="ae ks" href="https://github.com/danielbryantuk/oreilly-docker-java-shopping" rel="noopener ugc nofollow" target="_blank">“Docker Java shop front”GitHub存储库</a>。如果您想探索目录结构并了解组成应用程序的三个服务中的每一个，那么可以看看本系列的前一篇文章<a class="ae ks" href="https://www.oreilly.com/ideas/how-to-manage-docker-containers-in-kubernetes-with-java" rel="noopener ugc nofollow" target="_blank">或相关的迷你书</a><a class="ae ks" href="https://www.nginx.com/resources/library/containerizing-continuous-delivery-java/" rel="noopener ugc nofollow" target="_blank">Java中的容器化连续交付</a>。成功克隆存储库后，您可以导航至<code class="eh lb lc ld le b">kubernetes</code>目录。如果您按照教程进行操作，那么您将在这个目录中进行修改，因此欢迎您派生您自己的repo副本并创建一个分支，您可以将您的工作推进到这个分支。我不建议跳过前面(或作弊)，但<code class="eh lb lc ld le b"><a class="ae ks" href="https://github.com/danielbryantuk/oreilly-docker-java-shopping/tree/master/kubernetes-ambassador" rel="noopener ugc nofollow" target="_blank">kubernetes-ambassador</a></code>目录包含完整的解决方案，以防你想检查你的工作！</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="e9c0" class="lj jq hu le b fv lk ll l lm ln">$ git clone <a class="ae ks" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:danielbryantuk/oreilly-docker-java-shopping.git<br/>$ cd oreilly-docker-java-shopping/kubernetes<br/>(master) kubernetes $ ls -lsa<br/>total 24<br/>0 drwxr-xr-x 5 danielbryant staff 160 5 Feb 18:18 .<br/>0 drwxr-xr-x 18 danielbryant staff 576 5 Feb 18:17 ..<br/>8 -rw-r — r — 1 danielbryant staff 710 5 Feb 18:22 productcatalogue-service.yaml<br/>8 -rw-r — r — 1 danielbryant staff 658 5 Feb 18:11 shopfront-service.yaml<br/>8 -rw-r — r — 1 danielbryant staff 677 5 Feb 18:22 stockmanager-service.yaml</span></pre><p id="cc10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您在您选择的编辑器/IDE中打开<code class="eh lb lc ld le b"><a class="ae ks" href="https://github.com/danielbryantuk/oreilly-docker-java-shopping/blob/master/kubernetes/shopfront-service.yaml" rel="noopener ugc nofollow" target="_blank">shopfront-service.yaml</a> </code>,您将会看到我们将店面服务公开为可通过TCP端口8010访问的<code class="eh lb lc ld le b">NodePort</code>。这意味着可以通过任何公开的群集节点IP(不受防火墙阻止)上的端口8010访问该服务。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="7a04" class="lj jq hu le b fv lk ll l lm ln">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/> name: shopfront<br/> labels:<br/> app: shopfront<br/>spec:<br/> type: NodePort<br/> selector:<br/> app: shopfront<br/> ports:<br/> — protocol: TCP<br/> port: 8010<br/> name: http</span></pre><p id="3705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过minikube运行该服务时，<code class="eh lb lc ld le b">NodePort</code>允许您通过集群外部IP访问该服务。当通过Docker运行服务时，NodePort允许您通过localhost和Kubernetes分配的端口访问服务。假设Docker for Mac或Windows已经配置为成功运行Kubernetes，那么现在您可以部署这个服务了:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="7d20" class="lj jq hu le b fv lk ll l lm ln">(master) kubernetes $ kubectl apply -f shopfront-service.yaml<br/>service “shopfront” created<br/>replicationcontroller “shopfront” created<br/>(master) kubernetes $ kubectl get services<br/>NAME        TYPE       CLUSTER-IP   EXTERNAL-IP PORT(S)        AGE<br/>kubernetes  ClusterIP  10.96.0.1    &lt;none&gt;      443/TCP        19h<br/>shopfront   NodePort   10.110.74.43 &lt;none&gt;      8010:31497/TCP 0s</span></pre><p id="a495" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以看到已经创建了店面服务，虽然没有列出外部ip，但是您可以看到在<code class="eh lb lc ld le b"> stockmanager-service.yaml</code> (8010)中指定的端口已经映射到端口31497(您的端口号在这里可能不同)。如果你正在使用Docker for Mac或Windows，你现在可以从本地主机获取数据(因为Docker应用程序在幕后发挥了一些神奇的作用)，如果你正在使用minikube，你可以通过在终端中键入<code class="eh lb lc ld le b">minikube ip</code>来获取集群IP地址。</p><p id="c9cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设您正在使用Docker，并且您只部署了单个的店面服务，那么您应该会看到来自curl的这个响应，它使用了从<code class="eh lb lc ld le b">kubectl get svc</code>命令中可以看到的端口号(对我来说是31497):</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="672a" class="lj jq hu le b fv lk ll l lm ln">(master) kubernetes $ curl -v localhost:31497<br/>* Rebuilt URL to: localhost:31497/<br/>* Trying ::1…<br/>* TCP_NODELAY set<br/>* Connected to localhost (::1) port 31497 (#0)<br/>&gt; GET / HTTP/1.1<br/>&gt; Host: localhost:31497<br/>&gt; User-Agent: curl/7.54.0<br/>&gt; Accept: */*<br/>&gt;<br/>&lt; HTTP/1.1 500<br/>&lt; X-Application-Context: application:8010<br/>&lt; Content-Type: application/json;charset=UTF-8<br/>&lt; Transfer-Encoding: chunked<br/>&lt; Date: Tue, 06 Feb 2018 17:20:19 GMT<br/>&lt; Connection: close<br/>&lt;</span><span id="9f35" class="lj jq hu le b fv lo ll l lm ln">* Closing connection 0</span><span id="03fa" class="lj jq hu le b fv lo ll l lm ln">{“timestamp”:1517937619690,”status”:500,”error”:”Internal Server Error”,”exception”:”org.springframework.web.client.ResourceAccessException”,”message”:”I/O error on GET request for \”http://productcatalogue:8020/products\": productcatalogue; nested exception is java.net.UnknownHostException: productcatalogue”,”path”:”/”}</span></pre><p id="90ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您会注意到这个curl会得到一个HTTP 500错误响应，这是意料之中的，因为您还没有部署所有的支持服务。但是，在部署其余服务之前，您需要将所有服务的节点端口配置更改为ClusterIP。这意味着每个服务只能在群集内的其他网络上访问。当然，您可以使用防火墙来限制NodePort公开的服务，但是通过在我们的本地开发环境中使用ClusterIP，您将不得不通过除了我们将部署的API网关之外的任何方式来访问我们的服务。</p><p id="0392" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在编辑器中打开<code class="eh lb lc ld le b">shopfront-service.yaml</code>，将<code class="eh lb lc ld le b">NodePort</code>改为<code class="eh lb lc ld le b">ClusterIP</code>。你可以在下面看到文件内容的相关部分:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="f487" class="lj jq hu le b fv lk ll l lm ln">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/> name: shopfront<br/> labels:<br/> app: shopfront<br/>spec:<br/> type: ClusterIP<br/> selector:<br/> app: shopfront<br/> ports:<br/> — protocol: TCP<br/> port: 8010<br/> name: http</span></pre><p id="b7a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在您可以将包含在<code class="eh lb lc ld le b">productcatalogue-service.yaml</code>和<code class="eh lb lc ld le b">stockmanager-service.yaml</code>文件中的服务修改为<code class="eh lb lc ld le b">ClusterIP</code>。</p><p id="68e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，您还可以删除现有的shopfront服务，为在本教程的下一部分中部署整个堆栈做好准备。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="b8f7" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl delete -f shopfront-service.yaml<br/>service “shopfront” deleted<br/>replicationcontroller “shopfront” deleted</span></pre><h1 id="a1b9" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">部署整个堆栈</h1><p id="f9bd" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">再次使用空的Kubernetes集群，您现在可以部署完整的三服务堆栈，并获得每个服务的相关Kubernetes信息:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="11dc" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl apply -f .<br/>service “productcatalogue” created<br/>replicationcontroller “productcatalogue” created<br/>service “shopfront” created<br/>replicationcontroller “shopfront” created<br/>service “stockmanager” created<br/>replicationcontroller “stockmanager” created</span><span id="63dc" class="lj jq hu le b fv lo ll l lm ln">(master *) kubernetes $ kubectl get services<br/>NAME             TYPE      CLUSTER-IP EXTERNAL-IP PORT(S)  AGE<br/>kubernetes       ClusterIP 10.96.0.1  &lt;none&gt;      443/TCP  2h<br/>productcatalogue ClusterIP 10.106.8.5 &lt;none&gt;      8020/TCP 1s<br/>shopfront        ClusterIP 10.9.19.20 &lt;none&gt;      8010/TCP 1s<br/>stockmanager     ClusterIP 10.96.27.5 &lt;none&gt;      8030/TCP 1s</span></pre><p id="c86c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以看到服务中声明的端口按指定可用(即8010、8020、8030) —每个运行的pod都有自己的集群IP和关联的端口范围(即每个pod都有自己的“网络名称空间”)。我们无法在集群外部访问该端口(就像我们可以使用<code class="eh lb lc ld le b">NodePort</code>一样)，但是在集群内部，一切都按预期工作。</p><p id="bd52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以看到，使用<code class="eh lb lc ld le b">ClusterIP</code>并没有通过尝试卷曲端点来对外公开服务(这一次您应该会收到“连接被拒绝”):</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="a570" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ curl -v localhost:8010<br/>* Rebuilt URL to: localhost:8010/<br/>* Trying ::1…<br/>* TCP_NODELAY set<br/>* Connection failed<br/>* connect to ::1 port 8010 failed: Connection refused<br/>* Trying 127.0.0.1…<br/>* TCP_NODELAY set<br/>* Connection failed<br/>* connect to 127.0.0.1 port 8010 failed: Connection refused<br/>* Failed to connect to localhost port 8010: Connection refused<br/>* Closing connection 0<br/>curl: (7) Failed to connect to localhost port 8010: Connection refused</span></pre><h1 id="ac61" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">部署API网关</h1><p id="b684" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">现在是时候部署Ambassador API网关了，以便向最终用户公开您的店面服务。其他两个服务可以在集群中保持私有，因为它们是支持服务，不必公开。</p><p id="fa94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，创建一个<code class="eh lb lc ld le b">LoadBalancer</code>服务，该服务使用Kubernetes注释将来自集群外部的请求路由到适当的服务。将以下内容保存在名为<code class="eh lb lc ld le b">ambassador-service.yaml</code>的新文件中。注意<code class="eh lb lc ld le b">getambassador.io/config</code>的注释。您可以使用<a class="ae ks" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/" rel="noopener ugc nofollow" target="_blank"> Kubernetes annotations </a>将任意的非标识性元数据附加到对象上，并且像Ambassador这样的客户端可以检索这些元数据。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="9c9d" class="lj jq hu le b fv lk ll l lm ln">—--<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    service: ambassador<br/>  name: ambassador<br/>  annotations:<br/>    getambassador.io/config: |<br/>    ---<br/>    apiVersion: ambassador/v0<br/>    kind: Mapping<br/>    name: shopfront<br/>    prefix: /shopfront/<br/>    service: shopfront:8010<br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>  - name: ambassador<br/>    port: 80<br/>    targetPort: 80<br/>  selector:<br/>    service: ambassador</span></pre><p id="7e1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大使注释是网关如何工作的关键——它如何将来自集群外部的“进入”流量(例如，最终用户请求)路由到集群内的服务。让我们来分解一下:</p><ul class=""><li id="2b9f" class="lp lq hu it b iu iv iy iz jc lr jg ls jk lt jo lu lv lw lx dt translated"><code class="eh lb lc ld le b">getambassador.io/config: |</code>指定该注释用于大使</li><li id="e60c" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><code class="eh lb lc ld le b">apiVersion: ambassador/v0</code>指定大使API/模式版本</li><li id="428d" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><code class="eh lb lc ld le b">kind: Mapping</code>指定您正在创建一个“映射”(路由)配置</li><li id="ba63" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><code class="eh lb lc ld le b">name: shopfront</code>是这个映射的名称(它将出现在调试UI中)</li><li id="30e5" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><code class="eh lb lc ld le b">prefix: /shopfront/</code>是您想要内部路由的URI的外部前缀</li><li id="a064" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><code class="eh lb lc ld le b">service: shopfront:8010</code>是您要路由到的Kubernetes服务</li></ul><p id="d670" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，该注释声明任何对LoadBalancer服务的外部IP(在Mac/Windows的Docker示例中为<code class="eh lb lc ld le b">localhost</code>)的带有前缀<code class="eh lb lc ld le b">/shopfront/</code>的请求都将被路由到运行在(ClusterIP)端口8010上的Kubernetes shopfront服务。在您的示例中，当您在web浏览器中输入<a class="ae ks" href="http://localhost/shopfront/" rel="noopener ugc nofollow" target="_blank">http://localhost/shopfront/</a>时，您应该会看到由shop front服务提供的UI。希望这一切都有意义，但如果没有意义，那么请访问<a class="ae ks" href="https://gitter.im/datawire/ambassador" rel="noopener ugc nofollow" target="_blank">大使吉特</a>并提出任何问题，或在twitter上ping我！</p><p id="e4c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以部署大使服务:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="0ffb" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl apply -f ambassador-service.yaml<br/>service “ambassador” created</span></pre><p id="6128" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还需要部署Ambassador Admin服务(以及相关的pod/containers ),它们负责与路由相关的繁重工作。值得注意的是，路由是由“sidecar”代理进行的，在本例中是<a class="ae ks" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使代理</a>。<a class="ae ks" href="https://www.datawire.io/envoyproxy/" rel="noopener ugc nofollow" target="_blank">特使</a>负责Lyft内部的所有生产网络流量。它的创作者<a class="ae ks" href="https://twitter.com/mattklein123?lang=en" rel="noopener ugc nofollow" target="_blank">马特·克莱恩</a>，写了很多关于<a class="ae ks" href="https://blog.envoyproxy.io/envoy-threading-model-a8d44b922310" rel="noopener ugc nofollow" target="_blank">细节</a>的<a class="ae ks" href="https://eng.lyft.com/envoy-7-months-later-41986c2fd443" rel="noopener ugc nofollow" target="_blank">非常有趣的</a>内容<a class="ae ks" href="https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc" rel="noopener ugc nofollow" target="_blank">。今天，由于种种原因，它是NGINX和HAProxy增长最快的替代品。你可能也听说过新兴的“</a><a class="ae ks" href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/" rel="noopener ugc nofollow" target="_blank">服务网格</a>技术，流行的<a class="ae ks" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>项目也使用Envoy。</p><p id="1578" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">反正回到教程！您可以在<a class="ae ks" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank"> getambassador.io </a>网站上找到为<a class="ae ks" href="https://getambassador.io/yaml/ambassador/ambassador-no-rbac.yaml" rel="noopener ugc nofollow" target="_blank"> Ambassador Admin </a>预先准备的Kubernetes配置文件(在本演示中，您将使用“无RBAC”版本的服务，但是如果您运行的是启用了基于角色的访问控制(RBAC)的Kubernetes集群，您也可以找到启用了RBAC版本的<a class="ae ks" href="https://getambassador.io/yaml/ambassador/ambassador-rbac.yaml" rel="noopener ugc nofollow" target="_blank">配置文件</a>。您可以下载配置文件的副本并在应用前查看，或者您可以通过互联网直接应用服务:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="8e97" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl apply -f <a class="ae ks" href="https://getambassador.io/yaml/ambassador/ambassador-no-rbac.yaml" rel="noopener ugc nofollow" target="_blank">https://getambassador.io/yaml/ambassador/ambassador-no-rbac.yaml</a><br/>service “ambassador-admin” created<br/>deployment “ambassador” created</span></pre><p id="0968" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您发出一个<code class="eh lb lc ld le b">kubectl get svc</code>，您可以看到您的大使负载平衡器和大使管理服务已经成功部署:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="67e6" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl get svc<br/>NAME             TYPE         CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>ambassador       LoadBalancer 10.12.1.42 &lt;pending&gt;   80:31053/TCP 5m<br/>ambassador-admin NodePort     10.15.58.25 &lt;none&gt;     8877:31516/TCP 1m<br/>kubernetes       ClusterIP    10.96.0.1  &lt;none&gt;      443/TCP  20h<br/>productcatalogue ClusterIP    10.106.8.5 &lt;none&gt;      8020/TCP 22m<br/>shopfront        ClusterIP    10.98.1.20 &lt;none&gt;      8010/TCP 22m<br/>stockmanager     ClusterIP    10.96.2.45 &lt;none&gt;      8030/TCP 22m</span></pre><p id="e7af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会在ambassador服务上注意到external-ip被列为<pending>，这是Docker for Mac/Windows 的一个<a class="ae ks" href="https://www.datawire.io/docker-mac-kubernetes-ingress/" rel="noopener ugc nofollow" target="_blank">已知错误。您仍然可以通过localhost访问<code class="eh lb lc ld le b">LoadBalancer</code>服务——尽管您可能需要等待一两分钟，以便在幕后成功部署所有的东西。</a></pending></p><p id="3360" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们尝试使用您之前在Ambassador注释中配置的<code class="eh lb lc ld le b">/shopfront/</code>路线访问店面。您可以<code class="eh lb lc ld le b"> curl localhost/shopfront/</code>(无需指定端口，因为您将大使<code class="eh lb lc ld le b">LoadBalancer</code>服务配置为监听端口80):</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="1d4b" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ curl localhost/shopfront/<br/>&lt;!DOCTYPE html&gt;</span><span id="883c" class="lj jq hu le b fv lo ll l lm ln">&lt;html lang=”en” xmlns=”http://www.w3.org/1999/xhtml"&gt;<br/>&lt;head&gt;<br/>&lt;meta charset=”utf-8" /&gt;<br/>&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge” /&gt;<br/>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1" /&gt;<br/>&lt;! — The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags --&gt;</span><span id="4f19" class="lj jq hu le b fv lo ll l lm ln">...</span><span id="6ae9" class="lj jq hu le b fv lo ll l lm ln">&lt;! — jQuery (necessary for Bootstrap’s JavaScript plugins) →<br/>&lt;script src=”https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt;<br/>&lt;! — Include all compiled plugins (below), or include individual files as needed --&gt;<br/>&lt;script src=”js/bootstrap.min.js”&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="1378" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！您现在可以通过Ambassador访问隐藏在Kubernetes集群中的店面服务。您还可以通过浏览器访问店面UI，这提供了一个更加友好的视图！</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff md"><img src="../Images/06612155308b96a9007f39d9485c980b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zWLghBYiEnpedG0y."/></div></div></figure><h1 id="83f2" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">奖励:大使诊断</h1><p id="e03a" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">如果你想看看大使诊断用户界面，那么你可以使用端口转发。我们将在以后的文章中解释如何使用它，但是现在你可以自己四处看看。首先你需要找到大使舱的名字:</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="c8e8" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl get pods<br/>NAME                        READY STATUS  RESTARTS AGE<br/>ambassador-6d9f98bc6c-5sppl 2/2   Running 0        19m<br/>ambassador-6d9f98bc6c-nw6z9 2/2   Running 0        19m<br/>ambassador-6d9f98bc6c-qr87m 2/2   Running 0        19m<br/>productcatalogue-sdtlc      1/1   Running 0        22m<br/>shopfront-gr794             1/1   Running 0        22m<br/>stockmanager-bp7zq          1/1   Running 1        22m</span></pre><p id="cec8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们就挑<code class="eh lb lc ld le b">ambassador-6d9f98bc6c-5sppl</code>。现在，您可以从本地网络适配器端口转发到集群内部，并公开在端口8877上运行的大使诊断UI。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="1b35" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl port-forward ambassador-6d9f98bc6c-5sppl 8877:8877</span></pre><p id="35e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在可以在浏览器中访问<a class="ae ks" href="http://localhost:8877/ambassador/v0/diag" rel="noopener ugc nofollow" target="_blank">http://localhost:8877/ambassador/v 0/diag</a>四处看看了！</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff md"><img src="../Images/8284d236f402bc049c83d1297ee0adf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B5HHDpJb9ne7xDEG."/></div></div></figure><p id="db20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完成后，您可以通过<code class="eh lb lc ld le b">ctrl-c</code>退出端口转发。您还可以通过在kubernetes目录中发出一个<code class="eh lb lc ld le b">kubectl delete -f .</code>来删除您已经部署到Kubernetes集群中的所有服务。您还需要删除已经部署的ambassador-admin服务。</p><pre class="ku kv kw kx fq lf le lg lh aw li dt"><span id="f3df" class="lj jq hu le b fv lk ll l lm ln">(master *) kubernetes $ kubectl delete -f .<br/>service “ambassador” deleted<br/>service “productcatalogue” deleted<br/>replicationcontroller “productcatalogue” deleted<br/>service “shopfront-canary” deleted<br/>replicationcontroller “shopfront-canary” deleted<br/>service “shopfront” deleted<br/>replicationcontroller “shopfront” deleted<br/>service “stockmanager” deleted<br/>replicationcontroller “stockmanager” deleted</span><span id="887f" class="lj jq hu le b fv lo ll l lm ln">(master *) kubernetes $ kubectl delete -f <a class="ae ks" href="https://getambassador.io/yaml/ambassador/ambassador-no-rbac.yaml" rel="noopener ugc nofollow" target="_blank">https://getambassador.io/yaml/ambassador/ambassador-no-rbac.yaml</a><br/>service “ambassador-admin” deleted<br/>deployment “ambassador” deleted</span></pre><h1 id="d292" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">下一步是什么？</h1><p id="ef13" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Ambassador使<a class="ae ks" href="https://www.datawire.io/faster/canary-workflow/" rel="noopener ugc nofollow" target="_blank">金丝雀测试变得非常容易</a>，所以请期待未来的一篇关于Java微服务的文章。我们将探讨的其他主题是将所有这些集成到CD管道中，以及如何最好地建立本地开发工作流。此外，Ambassador支持<a class="ae ks" href="https://blog.getambassador.io/grpc-and-the-open-source-ambassador-api-gateway-510eaaf9a0e0" rel="noopener ugc nofollow" target="_blank"> gRPC </a>、<a class="ae ks" href="https://www.getambassador.io/user-guide/with-istio" rel="noopener ugc nofollow" target="_blank"> Istio </a>和<a class="ae ks" href="https://www.getambassador.io/reference/statistics" rel="noopener ugc nofollow" target="_blank"> statsd风格的监控</a>，这些都是当今云原生环境中的热门话题。如果您有任何想法或反馈，请随时评论！</p><p id="86cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mi">注:本文基于丹尼尔·布莱恩特</em> <a class="ae ks" href="https://blog.getambassador.io/deploying-java-apps-with-kubernetes-and-the-ambassador-api-gateway-c6e9d9618f1b" rel="noopener ugc nofollow" target="_blank"> <em class="mi">原著</em> </a> <em class="mi">搭配Java微服务和API网关。</em></p></div></div>    
</body>
</html>