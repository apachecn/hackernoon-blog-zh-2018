<html>
<head>
<title>How Re2 Shattered My Bottleneck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Re2如何打破我的瓶颈</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-re2-shattered-my-bottleneck-e18d77afbf6e?source=collection_archive---------35-----------------------#2018-03-13">https://medium.com/hackernoon/how-re2-shattered-my-bottleneck-e18d77afbf6e?source=collection_archive---------35-----------------------#2018-03-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/c4cc1006f9e36d26e87dc8c7aa52753f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*wpSJQxhqN0RtTakw.jpg"/></div></figure><p id="49a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">几乎在一夜之间，一个主要的数据管道系统成为了公司的主要瓶颈，需要一个解决方案，而且要快！</p><p id="fcf3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">幸运的是Re2在那里救援。通过很少的工作，我成功地将系统运行时间减少了大约15%。</p><p id="b757" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这篇文章中，我将分享如何使用Gprof2dot漂亮的图像渲染来找到瓶颈，当然，Re2是什么以及如何使用它。</p><blockquote class="jw jx jy"><p id="c043" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hn dt translated">这篇文章解决了我在Python框架中遇到的一个难题，但是因为所有主要语言都有Re2实现，所以阅读这篇文章还是有价值的。</p></blockquote></div><div class="ab cl kd ke hc kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hn ho hp hq hr"><h1 id="f90c" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated"><strong class="ak">缓解瓶颈的策略非常简单</strong></h1><ul class=""><li id="69b8" class="li lj hu ja b jb lk jf ll jj lm jn ln jr lo jv lp lq lr ls dt translated"><strong class="ja hv">第一步:</strong>认清最疼的地方</li><li id="4312" class="li lj hu ja b jb lt jf lu jj lv jn lw jr lx jv lp lq lr ls dt translated"><strong class="ja hv">第二步:</strong>减轻痛苦</li><li id="f615" class="li lj hu ja b jb lt jf lu jj lv jn lw jr lx jv lp lq lr ls dt translated">第三步:重复第一步，直到得到想要的结果</li></ul><p id="dab1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">听起来很简单，对吧？理论上是这样的。<br/>通常情况下，实施是你成功的关键。</p><h1 id="c381" class="kk kl hu bd km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh dt translated"><strong class="ak">第一步:认清哪里最疼</strong></h1><p id="5390" class="pw-post-body-paragraph iy iz hu ja b jb lk jd je jf ll jh ji jj md jl jm jn me jp jq jr mf jt ju jv hn dt translated">就像任何曾经在电视上看到一个人谈论戒酒会的人一样，他会说:<strong class="ja hv"> <em class="jz">“处理你的问题的第一步是认识到它的存在”</em> </strong>，在我们的情况下，这意味着测量和找到瓶颈。</p><p id="8601" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个系统是一个用Python编写的非常简单的ETL系统，所以我决定先从转换部分开始。</p><p id="cce2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我花了几个小时将代码的主要部分提取到一个独立的进程中，完成后我开始了一个<a class="ae mg" href="http://jupyter.org/." rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>。<br/>使用cProfile内置python包和gprof2dot，我运行了以下代码来测试它——</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mh"><img src="../Images/bfb8f95dd4f05f90efaa770ca0107e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B36kGrXZbgox5k-K.png"/></div></div></figure><p id="7b70" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是Gprof2dot生成的图像:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mh"><img src="../Images/371840f482d3138782783600f9cbe5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SoJF1oYL_hkRTJHt.png"/></div></div></figure><p id="4dff" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">如果这是您第一次遇到Gprof2dot库</strong>的话，简单解释一下:我得到的图像是一个测量我们代码的配置文件，它为每个主要块确定了我们的代码访问该块的时间，以及每个块在总运行时间中所占的总时间。</p><p id="0116" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">深蓝色的是“冷”区域，是我们研究中有趣的部分。从红盒子开始，一直“冷却”到树叶的路径是值得研究的有趣路径。</p><p id="2d4d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">每个框都有以下格式:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/aa7b7eaf5668e8a18ff67f72899dbc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*-7niAaZEcQOUYcj-.png"/></div></figure><p id="bbe4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在下面的下一张图中，我看着小路尽头的叶子。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/709b1f38626c8b379f0509557d1cfef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/0*gPaUQKzE7xNAjzRK.png"/></div></figure><p id="b1c7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你看上面的框，你可以看到它是一个在GenericTextInTextSearch类中名为doesTextFit的方法。系统在代码上花费了32.05%的运行时间，但只有4.94%的时间是在方法的实际代码上，其余95%的时间是在从doesTextFit调用的代码上。2，221，386是这个代码被调用的次数。<br/>更有趣的部分是doesTextFit调用了另一个方法，它花了大约26%的时间。<br/>这是我决定集中注意力的方法。</p><blockquote class="jw jx jy"><p id="94e3" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hn dt translated">在叶框中可能会发生这样的情况，括号中的<strong class="ja hv"> <em class="hu">自我时间</em></strong>——和自我时间上方的<strong class="ja hv"> <em class="hu">总时间</em></strong>——不相加。<br/>当执行时间过短，导致舍入误差过大时，会出现这种情况。别担心。</p></blockquote><p id="5b3d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> <em class="jz">“方法‘搜索的’_ sre。SRE _模式对象"</em> </strong>来自Python内置库——Regex<a class="ae mg" href="https://hackernoon.com/tagged/regex" rel="noopener ugc nofollow" target="_blank">库</a><strong class="ja hv"><em class="jz">re</em></strong>。<br/>结果是，有很多活动部件的系统，在单个库调用的单个方法上花费了大约26%的时间。</p><p id="ee4b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以现在我开始尝试寻找Python内置方法的替代品。</p><p id="191b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">原来是有的。我对此感到非常惊讶。</p><h1 id="c2b9" class="kk kl hu bd km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh dt translated"><strong class="ak">第二步:减轻痛苦</strong></h1><p id="1900" class="pw-post-body-paragraph iy iz hu ja b jb lk jd je jf ll jh ji jj md jl jm jn me jp jq jr mf jt ju jv hn dt translated">我看到了这两篇文章:</p><ul class=""><li id="f289" class="li lj hu ja b jb jc jf jg jj ms jn mt jr mu jv lp lq lr ls dt translated"><a class="ae mg" href="http://www.benfrederickson.com/python-catastrophic-regular-expressions-and-the-gil/" rel="noopener ugc nofollow" target="_blank"> Python，灾难性正则表达式</a></li><li id="3e5d" class="li lj hu ja b jb lt jf lu jj lv jn lw jr lx jv lp lq lr ls dt translated"><a class="ae mg" href="https://swtch.com/~rsc/regexp/regexp1.html" rel="noopener ugc nofollow" target="_blank">正则表达式匹配可以简单快速</a></li></ul><p id="2cf4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">他们基本上告诉我，我生活在一个谎言中——我一直认为正则表达式是匹配字符串最有效的方式。事实证明，它可能是这样开始的，但是在这个过程中的某个地方，我们牺牲了——在所有主要的编程语言中——性能<a class="ae mg" href="https://hackernoon.com/tagged/performance" rel="noopener ugc nofollow" target="_blank">来换取特性</a>。</p><p id="b824" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">拯救之道是回到基础:基于状态机的正则表达式！</p><h1 id="3d7a" class="kk kl hu bd km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh dt translated"><strong class="ak">内置的Regex引擎有什么问题？</strong></h1><p id="1c80" class="pw-post-body-paragraph iy iz hu ja b jb lk jd je jf ll jh ji jj md jl jm jn me jp jq jr mf jt ju jv hn dt translated"><strong class="ja hv"><em class="jz">TL；</em>博士</strong>出尔反尔。</p><p id="b284" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当内置的正则表达式试图匹配一个字符串时，它遵循一种贪婪的算法模式。首先尝试匹配整个字符串，当失败时，尝试分别匹配整个字符串和剩余字符上的负一个字符。然后在整个字符串上减去两个字符，并分别在剩下的两个字符上，等等。如果没有匹配，引擎注定会失败，它只是在迭代所有不同的组合之前不知道。</p><p id="5cbc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个过程既费时又费空间。</p><h1 id="02d4" class="kk kl hu bd km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh dt translated">那么还有什么选择呢？</h1><p id="e85e" class="pw-post-body-paragraph iy iz hu ja b jb lk jd je jf ll jh ji jj md jl jm jn me jp jq jr mf jt ju jv hn dt translated">介绍肯·汤普森。你可以在他的<a class="ae mg" href="https://en.wikipedia.org/wiki/Ken_Thompson" rel="noopener ugc nofollow" target="_blank">维基页面</a>上读到更多关于他的信息，但这里是TL；博士列举了他的成就:</p><ul class=""><li id="68f5" class="li lj hu ja b jb jc jf jg jj ms jn mt jr mu jv lp lq lr ls dt translated">Unix操作系统</li><li id="71c2" class="li lj hu ja b jb lt jf lu jj lv jn lw jr lx jv lp lq lr ls dt translated">b(编程语言)——C的祖先</li><li id="9cf7" class="li lj hu ja b jb lt jf lu jj lv jn lw jr lx jv lp lq lr ls dt translated">UTF-8</li><li id="b280" class="li lj hu ja b jb lt jf lu jj lv jn lw jr lx jv lp lq lr ls dt translated">Go(编程语言)</li><li id="c223" class="li lj hu ja b jb lt jf lu jj lv jn lw jr lx jv lp lq lr ls dt translated">基于状态机的正则表达式！</li></ul><p id="47f4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后一点在这张对比图中得到了最好的体现:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mv"><img src="../Images/4bf694e8dd74343e825108bbdfc79c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cDTk-r0UdodJxnZZ.png"/></div></div></figure><p id="acac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">左边的是Perl，但是代表了主要的编程语言，右边的是Thompson方法。确保你注意到左边的是<strong class="ja hv">秒</strong>，右边的是<strong class="ja hv">微秒(！)</strong>。</p><p id="0c48" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">他是怎么做到的？状态机。</p><p id="ec2f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">可以把正则表达式想象成一个状态机，它是由你想要匹配的表达式构建而成的。</p><p id="828d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">引擎遇到的每一个char都会促使它做出下一个决定，如果在它的旅程结束时它到达了“最终”状态。然后引擎找到了匹配。</p><p id="acc7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果不匹配，则不匹配。</p><p id="bdda" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">像这样的解的空间复杂度，是正则表达式有不同状态的数量。时间复杂度是被检查文本的长度。</p><p id="4378" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">考虑到这一点，我出去看看是否能找到Thompson引擎的实现，我找到了Google的优秀人员，他们用C++实现了Re2。</p><p id="9506" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了在Python中集成Google Re2，我不得不使用第三方包装器<a class="ae mg" href="https://pypi.python.org/pypi/re2/" rel="noopener ugc nofollow" target="_blank"> py-re2 </a>，但对于Java，有<a class="ae mg" href="https://github.com/google/re2j" rel="noopener ugc nofollow" target="_blank"> Google Re2/J项目</a>或<a class="ae mg" href="http://www.brics.dk/automaton/" rel="noopener ugc nofollow" target="_blank"> Brics </a>，我们在Taboola中，在我们的Java代码中使用Brics，你可以在这个伟大的博客中阅读这两个项目的比较:<a class="ae mg" href="https://blog.rapid7.com/2016/03/15/brics-vs-re2j/" rel="noopener ugc nofollow" target="_blank"> brics-vs-re2j </a>。</p><p id="464d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">代码中的集成就是这么简单:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/c95a4ac7bfb32e27510ebae64a6369e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*Ju8iu2qmJ6KtuIsO.png"/></div></figure><p id="8943" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">重要的是要记住，并不是re中的所有功能都存在于re2中。所以我所做的，以及如果你打算使用这个解决方案，你应该做的，是分析你所有的正则表达式调用，并确保你得到预期的结果。</p><p id="2d44" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尽管上图承诺性能提升了几百倍，但我得到的性能提升只有40%-50%。我没有抱怨，这几天的工作还算不错。</p><h1 id="cbb5" class="kk kl hu bd km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh dt translated"><strong class="ak">第三步:重复第一步，直到得到想要的结果</strong></h1><p id="2c03" class="pw-post-body-paragraph iy iz hu ja b jb lk jd je jf ll jh ji jj md jl jm jn me jp jq jr mf jt ju jv hn dt translated">我从来没有到这一部分，希望，如果你使用这个引擎，你也不会…</p><h1 id="a5f7" class="kk kl hu bd km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh dt translated"><strong class="ak">没有银弹</strong></h1><p id="ba44" class="pw-post-body-paragraph iy iz hu ja b jb lk jd je jf ll jh ji jj md jl jm jn me jp jq jr mf jt ju jv hn dt translated">我在这里描述的系统的具体情况是，大多数正则表达式的比较在没有匹配的情况下结束。<br/>所以有了一个新的正则表达式引擎，比常规的回溯引擎更快地返回“不匹配”,效果真的很好。您需要在您独特的场景中测试它，看看您将获得多少性能提升。</p><p id="1461" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第二件要检查的事情是你使用的正则表达式，如果它需要回溯来完成它的比较，它将不会工作，你将得到Segfault。但是，把它们改写成更简单的语法应该不会太难。</p><p id="acdb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第三件需要监控的事情是构建确定性自动机时的状态爆炸问题，这可能发生在一些Re2实现中，例如在Java实现中:例如Brics库，但在Google Re2中不会发生。代价在于性能。</p><p id="460b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您需要检查的最后一件事是返回值，可能会有这样的情况，预期的结果与您之前的结果不同。例如，在得到False之前先得到一个null。</p><p id="76e5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">底线是，在升级到新版本的库之前，您需要执行相同的评估过程。事情可能会变，所以你需要小心。</p><p id="dba1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">话虽如此，即使只有百分之几的改进，它如此容易集成的事实使它成为一个“地板上的钱”的场景。</p><p id="3261" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">好运</strong>，随时联系我寻求帮助和指导。</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>