<html>
<head>
<title>How does JavaScript’s Math.random() generate random numbers?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的Math.random()如何生成随机数？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-does-javascripts-math-random-generate-random-numbers-ef0de6a20131?source=collection_archive---------1-----------------------#2018-03-14">https://medium.com/hackernoon/how-does-javascripts-math-random-generate-random-numbers-ef0de6a20131?source=collection_archive---------1-----------------------#2018-03-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/eef15dcfe5fb75b292b38cd4f8831a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFyawcsqoYctkTuZg6wQ1A.jpeg"/></div></div></figure><div class=""/><p id="ce08" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开你的开发工具(Mac:cmd+option+I/Windows:ctrl+shift+I)，进入控制台，输入<code class="eh ka kb kc kd b">Math.random()</code>，点击return。</p><p id="a777" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">砰。你会得到一个随机数。</p><p id="aece" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我得到了0.6199322557631561。</p><p id="7939" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我一直想知道这些数字到底是从哪里来的。更重要的是，它们怎么可能是随机的？毕竟，计算机不就是接受一些输入，用一些数学知识使之旋转，然后再把它吐出来吗？这似乎是一个可以预见的过程。那么当你想产生一个‘随机’数时会发生什么呢？这是怎么做到的，幕后发生了什么？</p><h2 id="1a0b" class="ke kf if bd kg kh ki kj kk kl km kn ko jn kp kq kr jr ks kt ku jv kv kw kx ky dt translated">首先，这不是随机的</h2><p id="2a62" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">惊喜惊喜，答案是<code class="eh ka kb kc kd b">Math.random()</code>并不会真的产生一个随机数。不完全是。它在模拟随机性方面做得非常好。</p><p id="7813" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从本质上来说，算法随机数的产生不可能是随机的；这就是为什么它们被更恰当地称为伪随机数发生器(PRNGs)的原因。如果你使用数学和公式来创建一个数字序列，尽管它们看起来是随机的，但这些数字最终会重复出现，并显示出非随机的模式。</p><p id="3325" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是有些PRNGs比其他的要好。PRNG的质量取决于许多因素，一个非常重要的因素是它的<strong class="je ig">期</strong>；PRNG在开始自我重复之前所经历的迭代次数。不仅对我们人类来说，长周期的PRNG看起来更随机，而且对计算机来说破解/预测也更困难(也就是更耗费资源);这是一个具有安全隐患的事实，尽管没有人应该使用<code class="eh ka kb kc kd b">Math.random()</code>进行加密——但它还是发生了。</p><p id="a2f8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以现在的问题是:JavaScript<a class="ae lf" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank">使用什么PRNG？</a></p><p id="62bb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">答案是:没有。</p><h2 id="4d46" class="ke kf if bd kg kh ki kj kk kl km kn ko jn kp kq kr jr ks kt ku jv kv kw kx ky dt translated">这取决于浏览器</h2><p id="547c" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">JavaScript并不决定如何实现<code class="eh ka kb kc kd b">Math.random()</code>，而是你的浏览器。JavaScript中没有硬编码的PRNG算法。相反，创建您的浏览器的工程师决定使用符合ECMAScript规范的算法，如下所示:</p><blockquote class="lg lh li"><p id="fc7a" class="jc jd le je b jf jg jh ji jj jk jl jm lj jo jp jq lk js jt ju ll jw jx jy jz hn dt translated">[Math.random]使用依赖于实现的算法或策略，返回一个大于或等于0但小于1的带正号的数值，该数值是随机选择的或伪随机选择的，在该范围内近似均匀分布。这个函数没有参数。</p><p id="9f85" class="jc jd le je b jf jg jh ji jj jk jl jm lj jo jp jq lk js jt ju ll jw jx jy jz hn dt translated">为不同代码领域创建的每个Math.random函数必须从连续调用中产生不同的值序列。</p></blockquote><p id="26ba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些是说明，由浏览器决定如何遵循它们。直到最近，不同的浏览器使用稍微不同的方法来实现这一点。他们使用的算法有着性感的名字，如<em class="le"> Marsenne-Twister </em>、<em class="le">乘进位</em>或<em class="le">线性同余发生器。不过，不要担心，理解所有这些东西的意思对你来说并不重要(尽管如果你理解的话，我会印象深刻)。</em></p><p id="4402" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于这一切，需要知道的重要一点是:( 1)浏览器决定他们想要使用哪种算法来计算<code class="eh ka kb kc kd b">Math.random()</code>;( 2)在2015年，几乎每个浏览器(至少是主流浏览器)都抛弃了他们旧的PRNG算法，现在他们都使用同一个算法:名为<strong class="je ig"> <em class="le"> xorshift128+ </em> </strong>。</p><p id="c0ef" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实证明，xorshift128+在假装随机方面比老算法做得好得多；此外，它的重量非常轻，计算速度很快。因此，它几乎被全面采纳，当你考虑到以前在这个问题上有许多不同意见时，这充分说明了它的有效性。</p><p id="1400" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是它到底是如何工作的呢？</p><p id="f401" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然每个浏览器实现该算法的方式略有不同，但我们可以看看它的一种“普通”版本，以了解它是如何工作的。</p><h2 id="8bc8" class="ke kf if bd kg kh ki kj kk kl km kn ko jn kp kq kr jr ks kt ku jv kv kw kx ky dt translated">一些有趣的数学</h2><p id="3d9f" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">首先，我将向您展示该算法，以便您能够完全理解(如C所示)，然后我们将进一步了解:</p><pre class="lm ln lo lp fq lq kd lr ls aw lt dt"><span id="9b8f" class="ke kf if kd b fv lu lv l lw lx"><strong class="kd ig">uint64_t</strong> state0 = 1;<br/><strong class="kd ig">uint64_t</strong> state1 = 2;</span><span id="bba9" class="ke kf if kd b fv ly lv l lw lx"><strong class="kd ig">uint64_t</strong> xorshift128plus() {<br/>  <strong class="kd ig">uint64_t</strong> s1 = state0;<br/>  <strong class="kd ig">uint64_t</strong> s0 = state1;<br/>  state0 = s0;<br/>  s1 ^= s1 &lt;&lt; 23;<br/>  s1 ^= s1 &gt;&gt; 17;<br/>  s1 ^= s0;<br/>  s1 ^= s0 &gt;&gt; 26;<br/>  state1 = s1;<br/>  <strong class="kd ig">return</strong> state0 + state1;<br/>}</span></pre><p id="66c2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你和我一样(有前端背景，没有CS学位)你看着这个，想“好吧，变量赋值，变量赋值，函数…够简单了…”但是然后你来到<code class="eh ka kb kc kd b">s1 ^= s1 &lt;&lt; 23;</code>说“搞什么鬼？”</p><p id="8ae1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些是<strong class="je ig">位运算符。</strong>它们在比特级别(1和0)处理数据，它们构成了我们正在研究的算法的核心和灵魂。它们也是普通web开发人员很少有机会使用的东西。为了解释这个算法在做什么，我将快速浏览一下上面显示的三个按位运算符，以及它们是如何工作的。</p><p id="fca9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个操作符<code class="eh ka kb kc kd b">&lt;&lt;</code>，叫做左移。下面举个例子:<code class="eh ka kb kc kd b">12 &lt;&lt; 4</code>。在这个例子中，你需要一个数字12的二进制表示，并把它向左移动4位；因此左移。这是如何工作的:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lz"><img src="../Images/ec8f65c521679c526b9d1b698105992f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOWMtIHTeFOsSUZ4PEfcog.jpeg"/></div></div></figure><p id="996d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与此相反，称为右移<code class="eh ka kb kc kd b">&gt;&gt;</code>，做同样的事情，但向右而不是向左移动。</p><p id="279c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个运算符<code class="eh ka kb kc kd b">=^</code>是xor赋值运算符。xor(<em class="le">异或</em>的缩写)比较两个数的二进制表示，当对应的位匹配时输出0，当对应的位不匹配时输出1。你可以认为xor是“一个<em class="le">或</em>另一个，但<em class="le">不是两个</em>”。这里有一个随机异或<code class="eh ka kb kc kd b">53^18</code>(没有赋值的异或)的可视化</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ma"><img src="../Images/c8eb25a0ac65eb7ff21c5a7c6437f08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwXH104SqYeRFb2-kVk8KA.jpeg"/></div></div></figure><p id="4a79" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在您已经知道了所有操作符的作用，您可以开始理解上面的<a class="ae lf" href="https://hackernoon.com/tagged/xorshift" rel="noopener ugc nofollow" target="_blank"> xorshift </a>算法了。我之前提到的那个令人困惑的位(<code class="eh ka kb kc kd b">s1 ^= s1 &lt;&lt; 23;</code>)只是将s1左移23位，然后将结果与s1进行异或运算，得到s1的新赋值。或者，换句话说，这是xor移位。</p><p id="1ad3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，为了完全简化事情，该算法采用两个种子值，交换它们，打乱它们的位值，将它们的位值通过一个逻辑门，重复几次，然后将它们加在一起…</p><p id="d0a5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">砰。你会得到一个“随机”数字。</p><h2 id="5c0e" class="ke kf if bd kg kh ki kj kk kl km kn ko jn kp kq kr jr ks kt ku jv kv kw kx ky dt translated">结论(TL；博士)</h2><p id="6dd7" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了将所有东西打包整齐，这里有一个概述。</p><p id="ac92" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">问题:【JavaScript的<code class="eh ka kb kc kd b">Math.random()</code>如何生成随机数？</strong></p><p id="4fcd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">回答:</strong></p><ul class=""><li id="8e55" class="mb mc if je b jf jg jj jk jn md jr me jv mf jz mg mh mi mj dt translated">JS什么都不做，全靠浏览器</li><li id="8e45" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">截至2015年，大多数浏览器都使用一种叫做xorshift128+的算法</li><li id="a91e" class="mb mc if je b jf mk jj ml jn mm jr mn jv mo jz mg mh mi mj dt translated">xorshift128+生成的数字并不是真正随机的，序列只是需要很长时间来重复，并且它们相对均匀地分布在预期的值范围内。</li></ul><p id="fb05" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，事实证明，我们在这里真正做的是接受一些输入，用一些数学知识处理它，然后输出一个结果。一个完全可预测的，非随机的过程。但是对我们来说，它的随机性足以满足我们在JavaScript中随意制造混乱的目的。</p><p id="8a73" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="le">对于任何感兴趣的人，我在GitHub上有一个xorshift128+的JS实现(链接如下),它给你一个算法‘随机性’的可视化，让你玩</em> <strong class="je ig"> <em class="le">种子</em> </strong> <em class="le">和</em> <strong class="je ig"> <em class="le">移位</em> </strong> <em class="le">值。感谢阅读！</em></p><div class="ht hu fm fo hv mp"><a href="https://github.com/lordpoint/xorshift-sandbox-and-visualizer.git" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd ig fv z el mu eo ep mv er et ie dt translated">Lord point/xor shift-沙盒和可视化工具</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">xorshift+伪随机数生成(PRNG)算法的一个实现…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ib mp"/></div></div></a></div><p id="b64e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">— — —</p><p id="6ac0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="le">感谢阅读！如果你现在正准备转行到网络/软件开发，我会在这里写更多关于这个话题的内容:</em></strong></p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ne"><img src="../Images/c6f4b328e5e3b505673b17785e691f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhFI2QLtcDRQ2fvy0H_J7A.png"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek"><a class="ae lf" href="https://swwwitch.dev" rel="noopener ugc nofollow" target="_blank">https://swwwitch.dev</a></figcaption></figure></div></div>    
</body>
</html>