<html>
<head>
<title>Everything you need to know about GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于GraphQL您需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/everything-you-need-to-know-about-graphql-a5bc3622e54?source=collection_archive---------5-----------------------#2018-03-14">https://medium.com/hackernoon/everything-you-need-to-know-about-graphql-a5bc3622e54?source=collection_archive---------5-----------------------#2018-03-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="aacb" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">还有一个用GraphCool搭建的聊天App！</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/bebdc52221facd9a31ad31e8155f5d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyIdyliKO2McJOFGyFkcXQ.jpeg"/></div></div></figure><blockquote class="jv"><p id="a1ea" class="jw jx hu bd jy jz ka kb kc kd ke kf ek translated"># REST APIs现在是# RestInPeace APIs |万岁#GraphQL</p></blockquote><p id="e89e" class="pw-post-body-paragraph kg kh hu ki b kj kk iv kl km kn iy ko kp kq kr ks kt ku kv kw kx ky kz la kf hn dt translated">这是萨梅尔·布纳发的一条推特。我非常同意这一点！</p><p id="6062" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">自从脸书在2015年首次发布以来，GraphQL的社区支持呈指数级增长。如今，成千上万的公司在其生产级应用中使用GraphQL。</p><p id="5141" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">在进入它的甜蜜之前，让我先来定义GraphQL:</p><blockquote class="li lj lk"><p id="b801" class="kg kh ll ki b kj ld iv kl km le iy ko lm lf kr ks ln lg kv kw lo lh kz la kf hn dt translated">GraphQL是一种数据查询语言，它是REST API和ad-hoc webservice架构的更好的替代方案。</p></blockquote><p id="1836" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">GraphQL的一个伟大之处在于，客户端可以定义所需数据的结构，服务器将以完全相同的结构返回数据！简单来说:</p><ul class=""><li id="850d" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">它让客户端确切地指定它需要什么数据。</li><li id="9c92" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">这使得从多个来源(服务器)收集数据变得更加容易。</li><li id="26a9" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">它使用类型系统来描述数据。</li></ul><p id="1446" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">GraphQL服务器支持多种语言，包括JavaScript、Python、Ruby、Java、C#、Scala、Go、Elixir、Erlang、PHP和Clojure。</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="1392" class="mk ml hu bd mm mn mo mp mq mr ms mt mu ja mv jb mw jd mx je my jg mz jh na nb dt translated">对GraphQL的需求REST API的限制</h1><p id="22bb" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">比方说，你正在创建一个移动应用程序，它有一个<code class="eh nh ni nj nk b">movies</code>列表，在每部电影下面，你想要一个主<code class="eh nh ni nj nk b">actors</code>列表。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nl"><img src="../Images/17820d9c28c24c604200fa038424851e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ww-MyOubROYxgwxxLDBkHA.png"/></div></div></figure><p id="939c" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">似乎很容易。但当你试图将这些数据加载到你的移动应用程序中时，你会发现事情开始变慢。</p><p id="1d7a" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">这里我只有两部电影，每部只有两个演员。实际上，我的应用程序可能需要管理数百部电影，每部电影肯定都有两部以上的<code class="eh nh ni nj nk b">actors</code>。</p><h2 id="0ac7" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">解决办法</h2><p id="aefc" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">这个问题的解决方法相当简单。与其有多个端点，不如有一个可以接受复杂查询的端点，然后将数据输出更改为客户机需要的任何结构。</p><p id="d56a" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">这正是GraphQL所做的。它位于客户机和数据源(服务器)之间，接收客户机请求，并根据客户机的指令获取必要的数据。</p><p id="cb51" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">下面是REST模型如何将数据传递到我的应用程序:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oa"><img src="../Images/d8bf184af18c525077a3e7ea54a88747.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*0yMDtNto8AL2Z7ktboR1EQ.png"/></div></figure><p id="9921" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">另一方面，GraphQL就像有一个私人助理，它只是简单地问你想要什么，然后为你得到它！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ob"><img src="../Images/0071a60418bcb93dc83d0679877c423d.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*WxKeKBBXI79K5YgLgib6Jg.png"/></div></figure></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="d3c9" class="mk ml hu bd mm mn mo mp mq mr ms mt mu ja mv jb mw jd mx je my jg mz jh na nb dt translated">GraphQL的优势</h1><ul class=""><li id="21f5" class="lp lq hu ki b kj nc km nd kp oc kt od kx oe kf lu lv lw lx dt translated">次要代码</li><li id="4527" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">更具声明性或优雅的数据检索</li><li id="22e0" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">避免多次REST调用</li><li id="c623" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">向后兼容且无版本限制</li><li id="f7db" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">灵活的</li><li id="7133" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">更好的性能</li><li id="6571" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">强大的开发工具</li><li id="702c" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">可以随着版本发展</li></ul></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="2d80" class="mk ml hu bd mm mn mo mp mq mr ms mt mu ja mv jb mw jd mx je my jg mz jh na nb dt translated">GraphQL提供了什么？</h1><h2 id="d252" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">菲尔茨</h2><p id="2f29" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">从根本上来说，GraphQL就是询问对象上的特定字段。因此，如果我想知道<code class="eh nh ni nj nk b">superhero</code>的<code class="eh nh ni nj nk b">name</code>和<code class="eh nh ni nj nk b">abilities</code>，我的查询应该是这样的:</p><div class="jk jl jm jn fq ab cb"><figure class="of jo og oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/dc2c8756336801fe21aea68f56c78f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*CpQtBautqDVcB8xhFuuNJg.png"/></div></figure><figure class="of jo ol oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/51b730d052e0e2023fe6a45343797ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*A0wwVtKGYlIqNUBnx4fcMw.png"/></div><figcaption class="om on fg fe ff oo op bd b be z ek oq di or os">GraphQL query and its response</figcaption></figure></div><p id="3393" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">正如您所注意到的，结果的形状与查询完全相同。通过使用GraphQL，您将总是得到您所期望的，因为服务器知道客户端需要什么字段。</p><p id="1e53" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">在GraphQL中，这些字段还可以引用其他对象。您所需要做的就是为该对象制作一个字段的子选择。GraphQL查询还可以遍历相关对象及其字段，让客户端在一个请求中获取大量相关数据，而不像REST API那样需要多次往返。</p><div class="jk jl jm jn fq ab cb"><figure class="of jo ot oh oi oj ok paragraph-image"><img src="../Images/2b6a85e759eb2bb301271c75388d8476.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*PV-D6p3U7Jck1QSGZlvrgg.png"/></figure><figure class="of jo ou oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/528eacb2d1217a78e0b5f331712f649d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*UhNhcYTuVDN5WMuxHzkZnw.png"/></div></figure></div><h2 id="d82c" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">争论</h2><p id="2522" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">除了让我们遍历对象及其字段，GraphQL还让您能够向字段传递参数。</p><div class="jk jl jm jn fq ab cb"><figure class="of jo ov oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/19a4e2c21039436e6a20a5973a5f8624.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*f0SGW5CWVRAyOodQVS1peA.png"/></div></figure><figure class="of jo ow oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/d93d23f284435206d5a7d4e0d4220b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*2y2HyvXAfj5Js9yw8TgBOg.png"/></div></figure></div><p id="b26b" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">与REST只能传递一组参数不同，在GraphQL中，每个字段和嵌套对象都可以获得自己的一组参数。</p><h2 id="7bfd" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">别名</h2><p id="d975" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">别名在查询具有不同参数的相同字段时非常有用。</p><h2 id="d473" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">突变</h2><p id="8499" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">虽然GraphQL查询可以帮助客户机获取任何形状的数据，但客户机还需要某种方法来修改服务器端数据。</p><p id="0645" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">任何请求都有可能对服务器造成某种副作用。通常建议不要使用<code class="eh nh ni nj nk b">GET</code>请求来修改数据。REST和GraphQL都是类似的。</p><p id="1194" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">为了在服务器端写/修改数据，GraphQL为我们提供了一个叫做<strong class="ki hv">突变</strong>的特殊字段。</p><div class="jk jl jm jn fq ab cb"><figure class="of jo ox oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/0d7f0824728ed14f13ffccbaa8e257e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*3II0xCz_biyPb7yxk6DMOQ.png"/></div></figure><figure class="of jo oy oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/73e6abd353af82dda7c6701a65b9083f.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*2IwQCCACkw8M5D4y0u9Obg.png"/></div></figure></div><p id="da8d" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">类似于查询，如果一个突变字段返回一个对象类型，您也可以要求嵌套字段。如果您想在更新后获取对象的新状态，这非常有用。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oz"><img src="../Images/9ea48a2d9e236dad1245acd52b4ac7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIZqpb_Mil-EQA3KceweNQ.png"/></div></div></figure><p id="6eac" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated"><code class="eh nh ni nj nk b">createReview</code>字段将向<code class="eh nh ni nj nk b">stars</code>和<code class="eh nh ni nj nk b">commentary</code>字段返回一个审查。当您需要更改现有数据时，这将特别有用。</p><h2 id="a84a" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">捐款</h2><p id="4c56" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">订阅允许开发人员通过近乎实时的更新为他们的应用程序引入新的交互水平。通过添加订阅，您可以根据不同用户之间的最新变化来更新您的应用。</p><p id="93c3" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">客户端在查询中指定他们想要“订阅”的数据，如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pa"><img src="../Images/c2c6ce33dfbed4e4f3fc039a0425381a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LDXODGsJNNSL_tL9vODmA.png"/></div></div></figure><p id="d979" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">当某个内容发布到订阅的通道时，服务器将运行订阅中指定的GraphQL查询，并向客户端发送一个完整的新结果。</p><p id="e924" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">与查询或变异不同，订阅可以提供多个结果，因此长期连接是必要的。我建议使用WebSocket连接。</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="dbd0" class="mk ml hu bd mm mn mo mp mq mr ms mt mu ja mv jb mw jd mx je my jg mz jh na nb dt translated">如何在React/React本地项目中设置Apollo客户端</h1><p id="5f0f" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">在React/React本地项目中设置Apollo客户端相当容易。你所需要做的就是在你的<code class="eh nh ni nj nk b">App.js</code>文件中写下这段代码:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nl"><img src="../Images/ca8fa0a8c5aa06704231f3aa6a2e30ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIqyaed7-z2ly_dC9z2GBQ.png"/></div></div></figure><p id="1024" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">瞧啊。您已经成功地在React或React本地项目中设置了Apollo客户端。</p><p id="67ca" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">您所要做的就是将您的<code class="eh nh ni nj nk b">App</code>组件包装在一个<code class="eh nh ni nj nk b">ApolloProvider</code>组件中。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pb"><img src="../Images/708b362aaa91af2b85305a1a9f55a2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e80zHzk8EWm3jHbGykfPkg.png"/></div></div></figure><p id="4da1" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">没有更多的事情要处理。请确保已将下列依赖项添加到项目中。</p><ul class=""><li id="7d8b" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">阿波罗-客户端预设</li><li id="53bf" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated">反应-阿波罗</li></ul><p id="2b26" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">通过这样做，查询的数据现在在同一个组件的props中是可用的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pc"><img src="../Images/a23ed905f6e806de78f1fbf0bbedf42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxY9NNDTB6WJko7jzWFGMw.png"/></div></div></figure></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="ead1" class="mk ml hu bd mm mn mo mp mq mr ms mt mu ja mv jb mw jd mx je my jg mz jh na nb dt translated">用GraphQL构建一个ChatApp</h1><p id="46c1" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">GeekyAnts的软件工程师Prameet Chakraborty 构建了这个令人敬畏的React原生聊天应用程序，并使用GraphQL作为后端。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff pd"><img src="../Images/f6727616f68d0063eaebf52e0fac8202.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/1*fQAvH1GoWIioRd5YXr-eYA.gif"/></div></figure><h2 id="65b3" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">属国</h2><p id="fc80" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated"><strong class="ki hv"> GraphCool </strong>是GraphQL发展的下一个重要步骤。更“酷”的是它是开源的！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="cd15" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">GraphCool Framework是一个全面的构建块集合，涵盖了开发现代的、以数据为中心的GraphQL APIs的整个范围，包括:</p><ul class=""><li id="8928" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated"><strong class="ki hv"> GraphQL数据库</strong>:graph QL数据库，允许你通过<a class="ae pg" href="https://www.graph.cool/docs/reference/graphql-api/overview-abogasd0go" rel="noopener ugc nofollow" target="_blank"> GraphQL CRUD API </a>查询、突变&amp;流数据。它还包含一个强大的数据库迁移工具，允许您使用GraphQL SDL定义和发展您的数据模型。</li><li id="f460" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated"><strong class="ki hv">强大的权限系统:</strong>使用强大的权限系统保护您的GraphQL API，该权限系统基于您根据简单的GraphQL <a class="ae pg" href="https://blog.graph.cool/reinventing-authorization-graphql-permission-queries-f2bd041bcd76" rel="noopener ugc nofollow" target="_blank">权限查询</a>定义的规则。</li><li id="4982" class="lp lq hu ki b kj ly km lz kp ma kt mb kx mc kf lu lv lw lx dt translated"><strong class="ki hv"> GraphQL订阅API: </strong>使用Graphcool框架，实时功能(基于GraphQL订阅)是免费的。您的突变会自动将订阅事件发布到事件网关，事件网关会将更新转发给所有订阅的客户端。</li></ul><p id="07ce" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated"><strong class="ki hv"> Apollo Client </strong>是一个超灵活的、社区驱动的GraphQL客户端。它是从头开始设计的，目的是使构建使用GraphQL获取数据的UI组件变得容易。</p><p id="7242" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">这是一个由社区驱动的努力，旨在构建一个强大、灵活和生产就绪的GraphQL客户端，并支持各种前端框架，如React、Angular和Vue。</p><p id="e468" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated"><strong class="ki hv"> NativeBase </strong>是GeekyAnts为React Native开发的开源UI组件库。就UI组件而言，NativeBase是开发人员的首选之一。</p><h2 id="e97b" class="nm ml hu bd mm nn no np mq nq nr ns mu kp nt nu mw kt nv nw my kx nx ny na nz dt translated">它是如何工作的</h2><p id="fa4e" class="pw-post-body-paragraph kg kh hu ki b kj nc iv kl km nd iy ko kp ne kr ks kt nf kv kw kx ng kz la kf hn dt translated">GraphQL提供了一种更简单的方法来构建一个简单而有效的聊天应用。下面是Prameet的聊天应用程序的工作方式:</p><ul class=""><li id="f963" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">一个<strong class="ki hv">突变</strong>被发送到服务器，以便创建一个新用户(注册)。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ph"><img src="../Images/464ea8733fa984eeb42c79ec77b367f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vytUtVBzrTVQnVlMav8abw.png"/></div></div></figure><ul class=""><li id="0d27" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">当用户试图登录时，包含用户凭证的<strong class="ki hv">突变</strong>被发送到服务器。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pi"><img src="../Images/fb1df07cc902130d89dda7cccc842edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ulnpRQDLgV8fhN9ddEpug.png"/></div></div></figure><ul class=""><li id="1cdb" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">一旦用户使用他们的凭证登录聊天，应用程序就向服务器发送一个<strong class="ki hv">查询</strong>，以获取所有已经在应用程序上注册的用户。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff pj"><img src="../Images/4f2148f6a58669fefedf11928c06a87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*qHsJF_-fziXb5GECvunBvA.png"/></div></figure><ul class=""><li id="bb4f" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">该应用程序还发送一个<strong class="ki hv">查询</strong>获取所有的消息，并根据发送者和接收者的<code class="eh nh ni nj nk b">id</code>进行过滤。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pk"><img src="../Images/38d06ecd4852cc09ca7aabe74794e2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26Mrw5CQJHrr5YzSqSEdwA.png"/></div></div></figure><ul class=""><li id="ab63" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">当用户发送新消息时，该消息通过<strong class="ki hv">突变</strong>被注册到服务器上。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pl"><img src="../Images/d68e5e6debb43928c4e56802051ea288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAKDEED5Ju8ilj_BcQ1omQ.png"/></div></div></figure><ul class=""><li id="51e5" class="lp lq hu ki b kj ld km le kp lr kt ls kx lt kf lu lv lw lx dt translated">所有这些都包装在一个<strong class="ki hv">订阅</strong>下。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pm"><img src="../Images/6bf4b26bb9576750ab263ca35b025f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmh3XlfgYdU3gkrdPRcbKA.png"/></div></div><figcaption class="om on fg fe ff oo op bd b be z ek">Subscription to listen for any new created message</figcaption></figure></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><p id="1e21" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">我是<a class="lb lc gr" href="https://medium.com/u/ae259dddfc25?source=post_page-----a5bc3622e54--------------------------------" rel="noopener" target="_blank"> Rajat S </a>，是<a class="ae pg" href="https://geekyants.com/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"> GeekyAnts </a>的技术内容撰稿人。有抱负的程序员还有很长的路要走。一个热爱漫威电影的铁杆DC漫画迷。😛在<a class="ae pg" href="https://twitter.com/rajatk16" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，了解<a class="ae pg" href="https://geekyants.com/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank">极客之家</a>正在发生的所有令人惊奇的事情。</p><p id="3699" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">感谢Prameet Chakraborty 对这篇文章的帮助，以及帮助我理解关于GraphQL和GraphCool框架的一切。Prameet 是<a class="ae pg" href="https://geekyants.com/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"> GeekyAnts </a>的软件工程师。这篇文章的灵感来自于他关于GraphQL的演讲。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="pn pf l"/></div></figure><p id="7251" class="pw-post-body-paragraph kg kh hu ki b kj ld iv kl km le iy ko kp lf kr ks kt lg kv kw kx lh kz la kf hn dt translated">感谢你阅读这篇长文！请吧👏如果你喜欢的话。</p></div></div>    
</body>
</html>