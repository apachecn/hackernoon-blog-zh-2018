<html>
<head>
<title>Smart Contract Security: Part 1 Reentrancy Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合约安全性:第1部分重入攻击</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smart-contract-security-part-1-reentrancy-attacks-ddb3b2429302?source=collection_archive---------11-----------------------#2018-03-15">https://medium.com/hackernoon/smart-contract-security-part-1-reentrancy-attacks-ddb3b2429302?source=collection_archive---------11-----------------------#2018-03-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2a12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以太坊是目前最大的两种加密货币之一，市值超过600亿美元，每天处理60多万笔交易。使用其图灵完备的高级编程语言Solidity，人们每天都在构建智能合约。已经有大量的应用程序在主网络上运行，从令牌系统到钱包、对冲合约、彩票等等。哪里涉及金钱，哪里就有恶意的行为者。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/afba92b907f5ffe672b726559c4f0d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXKiXQgLo89YqB-B7SBPgQ.png"/></div></div></figure><p id="57f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">智能合约一旦在区块链上部署，就不能再更改。这就是它们被称为“不可变”的原因。因此，遵循一些基本的安全准则，在部署之前做大量的测试，并尽可能保持代码的简单性是非常重要的。</p><p id="d529" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一系列文章中，我将尝试解释一些我所理解的常见漏洞，并提供由专家撰写的材料供进一步研究。</p><p id="8220" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们先简单解释一下<a class="ae kb" href="https://ethereum.stackexchange.com/questions/8270/what-does-soliditys-call-function-mean" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="kc">调用</em> </strong> </a> <strong class="it hv"> </strong>函数是如何工作的。它用于调用另一个或同一契约的函数，并向其传输数据和/或以太网。在异常情况下它不会抛出，它只是返回<em class="kc"> false - </em>否则返回<em class="kc"> true </em>。<em class="kc">调用</em>触发代码执行，并为此花费所有可用的gas。这就是问题开始的地方，稍后您将会看到。让我们看看这在实践中是如何工作的</p><p id="f50a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将使用这个简单的日志契约，它包含一个任何人都可以调用的<em class="kc"> logNum </em>函数。它将一个整数作为参数，并使用<em class="kc"> _myNum </em>映射将该数字映射/记录到您的地址。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kd"><img src="../Images/362e65d6a68de9af19e69d2d99420528.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*_9xgAUkSdD4EGGUpG-rYOA.png"/></div></figure><p id="592e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在假设，在我正在构建的另一个契约中，我想调用这个<em class="kc"> logNum </em>函数，并将数字10传递给它。使用<em class="kc">调用</em>的语法是:</p><pre class="jq jr js jt fq ke kf kg kh aw ki dt"><span id="993a" class="kj kk hu kf b fv kl km l kn ko">addressOfLogger.call(bytes4(sha3("logNum(uint256)")), 10);</span></pre><p id="9bcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">call方法内部的4个字节作为一个<strong class="it hv">哈希签名</strong>，用来指向我们要调用的函数。实际上，<em class="kc"> logNum </em>的hash的前4个字节与call方法的hash相匹配，这个函数是用值10作为参数来调用的。</p><p id="4bb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您也可以使用<em class="kc">调用</em>方法发送乙醚。让我们使用这个简单的测试契约来理解如何实现。这个由两个函数组成。<em class="kc">购买</em>应付的函数(接受魏)和<a class="ae kb" href="https://ethereum.stackexchange.com/questions/7570/whats-a-fallback-function-when-using-address-send" rel="noopener ugc nofollow" target="_blank"> <em class="kc">回退</em> </a>的方法。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kp"><img src="../Images/423d405c3ec8c27efe78a96c3b0114b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*WgtzJTVxqWtMlFhHdWbTlQ.png"/></div></figure><p id="0ba3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用<em class="kc">调用</em>方法，从您自己的合同中与<em class="kc">购买</em>功能进行交互，并向其转账，几乎与我们在上面使用的方式相同。你只需要知道测试合同的地址。在这种情况下，您可以写:</p><pre class="jq jr js jt fq ke kf kg kh aw ki dt"><span id="183c" class="kj kk hu kf b fv kl km l kn ko">addressOfTest.call.value(amount)(bytes4(sha3("buy()")));</span></pre><p id="657f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想把以太转移到<em class="kc">回退</em>方法，你应该写:</p><pre class="jq jr js jt fq ke kf kg kh aw ki dt"><span id="a8f3" class="kj kk hu kf b fv kl km l kn ko">addressOfTest.call.value(amount)(); //the parenthesis is empty</span></pre><p id="e891" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，<em class="kc">调用</em>方法在没有gas限制的情况下触发代码执行，<a class="ae kb" href="https://consensys.github.io/smart-contract-best-practices/recommendations/#be-aware-of-the-tradeoffs-between-send-transfer-and-callvalue" rel="noopener ugc nofollow" target="_blank">除非您手动设置一个</a>，这使得<strong class="it hv">容易受到重入攻击</strong>。这在过去导致了巨大的财务损失(DAO hack ~ 70M万美元/2016年6月)。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff kq"><img src="../Images/ac5639042d4a55643702358a94025e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYERS0E0kvLxfLPzvlJxuw.png"/></div></div></figure><h1 id="ad8f" class="kr kk hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">重入攻击</h1><p id="77c5" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">下面的合同将用于详细分析这种攻击。想象它代表一个钱包契约。你可以把乙醚送去储存在那里。的映射平衡将您的地址映射到您在此钱包中存储的乙醚量(单位为魏)。提款权功能允许任何使用钱包的人提取他们的余额。这就是不好的事情发生的地方。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/ca9c851ec5b40803b4b84935bbb45e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*dg7cR9B9ElapybCwIr7aQQ.png"/></div></figure><p id="8f2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们前面看到的，<em class="kc"> withdrawEquity </em>中的<em class="kc"> call </em>语句调用<em class="kc"> msg.sender的</em> fallback函数，以便将wei发送给他。事情是…它没有气体限制，所以这个回退函数中的任何代码都将被执行(只要有剩余气体用于这个目的)。现在，恶意参与者可以部署如下所示的智能合约:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/f5bf4a4245d46a8a99e18368ee66e026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*QIlKWNIiRuYatdPRgXPaCw.png"/></div></figure><p id="8e91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们检查一下这个。在构造函数中有一个私有地址<em class="kc"> _owner </em>被初始化。它在构造函数内部启动，并指示谁是契约的所有者/谁部署了它。另一个地址是易受攻击的钱包的地址(这里为了简单起见，我使用0x0)。然后，创建了该契约的一个实例，我们差不多完成了。</p><p id="ea8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果坏人把魏发过来，从恶意契约到钱包再调用他的<em class="kc">回退</em>函数，怪事就发生了。当他调用该函数时，调用<em class="kc"> withdrawEquity </em>函数(第15行)。</p><p id="1a9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在withdrawEquity中，require语句中的<em class="kc">调用</em>方法包含一个没有gas限制的空签名</p><pre class="jq jr js jt fq ke kf kg kh aw ki dt"><span id="007e" class="kj kk hu kf b fv kl km l kn ko">msg.sender.call.value(x)()</span></pre><p id="00aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，它调用恶意契约的回退方法，除非它失败(在失败的情况下，事务被恢复)。</p><pre class="jq jr js jt fq ke kf kg kh aw ki dt"><span id="123a" class="kj kk hu kf b fv kl km l kn ko">vul.withdrawEquity();</span></pre><p id="5832" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是对提款权函数<strong class="it hv">的再次调用</strong>。实际上，坏人的合约接收以太，然后再次调用withdrawEquity()。由于第一份合同的状态没有改变(攻击者的余额还没有被设置为零)，他再次获得报酬。一次又一次…直到执行耗尽或达到调用堆栈限制。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lv"><img src="../Images/753538f9c8319f90bb13e28558457930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yo9vxQvdqPT0rvjcAVlezQ.png"/></div></div></figure><p id="821d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果调用了10次withdrawEquity，那么只有最后一次调用会失败，因为调用不会传播异常，只有对/错，所以只有最后一次调用的执行会被恢复。这意味着恶意的家伙得到了x9倍的报酬，而不是1。从这个角度来看，有人可以先储存2个乙醚，然后再得到18个乙醚。然后用18乙醚做同样的事情，以此类推…</p><h1 id="732a" class="kr kk hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">如何避免这种情况</h1><ul class=""><li id="5cb2" class="lw lx hu it b iu lo iy lp jc ly jg lz jk ma jo mb mc md me dt translated"><em class="kc"> transfer() </em>和<em class="kc"> send() </em>对可重入攻击是安全的，因为它们将代码执行限制在2300 gas，目前足以记录日志和事件。</li><li id="c026" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">如果无法避免使用<em class="kc"> call() </em>在使用外部调用之前，一定要做好内部工作(例如更改余额)。</li><li id="96c3" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">一般来说，请记住，任何运行外部代码的函数都是一种威胁。</li></ul><h1 id="bdcd" class="kr kk hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated"><strong class="ak">用于进一步学习的文档和资源</strong></h1><ol class=""><li id="62fe" class="lw lx hu it b iu lo iy lp jc ly jg lz jk ma jo mk mc md me dt translated"><a class="ae kb" href="http://solidity.readthedocs.io/en/latest/security-considerations.html" rel="noopener ugc nofollow" target="_blank">坚固性文件</a></li><li id="8c58" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated"><a class="ae kb" href="https://consensys.github.io/smart-contract-best-practices/" rel="noopener ugc nofollow" target="_blank"> Consensys智能合同安全性最佳实践</a></li><li id="bd5d" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated"><a class="ae kb" href="https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/" rel="noopener ugc nofollow" target="_blank">维塔利科的安全系统</a></li><li id="b2dc" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated"><a class="ae kb" href="https://eprint.iacr.org/2016/1007.pdf" rel="noopener ugc nofollow" target="_blank">以太坊智能合约攻击调查</a></li><li id="59fe" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated"><a class="ae kb" href="http://chriseth.github.io/notes/talks/safe_solidity/#/" rel="noopener ugc nofollow" target="_blank">如何编写安全的智能合约-chriseth </a></li><li id="bfae" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mk mc md me dt translated">保护隐私的智能合同</li></ol></div></div>    
</body>
</html>