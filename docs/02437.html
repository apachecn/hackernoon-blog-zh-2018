<html>
<head>
<title>Effective Code Splitting in React: A Practical Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的有效代码分割:实用指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/effective-code-splitting-in-react-a-practical-guide-2195359d5d49?source=collection_archive---------1-----------------------#2018-03-18">https://medium.com/hackernoon/effective-code-splitting-in-react-a-practical-guide-2195359d5d49?source=collection_archive---------1-----------------------#2018-03-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="be91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大的包大小和缓慢的启动是单页面应用程序(spa)面临的一个常见问题，因为它们通常在开始渲染单个像素之前下载应用程序每个页面所需的所有JavaScript。</p><p id="402e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决这个问题的一个简单方法是使用代码分割，即将应用程序的JavaScript分解成称为<em class="jp">块</em>的小型模块化包，当访问特定功能时，可以按需加载这些包。目标是将单个块保持在100-150 KB以下，以便应用程序在4-5秒内变得可交互，即使在糟糕的网络上也是如此。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/f5e68e35a4490b8ceec4d12e4755955f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIcRAC_SRp3zxhuTyfOHJw.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Source: <a class="ae kg" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank">https://github.com/jamiebuilds/react-loadable</a></figcaption></figure><h1 id="4f69" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">基于组件的代码拆分</h1><p id="2099" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">开源库<code class="eh lk ll lm ln b"><a class="ae kg" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank">react-loadable</a></code>为代码分割提供了一个React友好的API，让你只需要几行代码就可以添加断点。如果您使用的是<code class="eh lk ll lm ln b"><a class="ae kg" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code>，<a class="ae kg" href="https://gist.github.com/aakashns/2bb0437b0770faa038798e1280872672" rel="noopener ugc nofollow" target="_blank"> Webpack </a>会自动拆分包并在需要时加载块。</p><p id="9a25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它是这样工作的:假设我们想要在用户点击特定的或者导航到特定的路线时，按需加载和呈现组件<code class="eh lk ll lm ln b">SettingsPage</code>。我们需要做的就是使用<code class="eh lk ll lm ln b">react-loadable</code>如下包装它:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="8e84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以像普通的React组件一样使用<code class="eh lk ll lm ln b">AsyncSettingsPage</code>。模块<code class="eh lk ll lm ln b">SettingsPage.js</code>及其依赖项不再是主JavaScript包的一部分，并且在第一次呈现<code class="eh lk ll lm ln b">AsyncSettingsPage</code>时异步加载。</p><p id="6765" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当程序块被加载时，组件<code class="eh lk ll lm ln b">Loading</code>被呈现在它的位置上。下面是<code class="eh lk ll lm ln b">Loading</code>的一个示例实现:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="6272" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果块加载失败，prop <code class="eh lk ll lm ln b">error</code>被设置为非空值。</p><h1 id="697a" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">将多个组件放在一起</h1><p id="e976" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">在某些情况下，简单的基于组件的拆分可能还不够。例如，您可能有一组几乎总是在几个不同的特性中一起使用的组件。在这种情况下，拥有一个包含所有相关组件的块是有意义的。</p><p id="bc36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是我们通常如何导出一组相关组件:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="65c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设上述代码在文件<code class="eh lk ll lm ln b">item-list/index.js</code>中，我们可以用以下内容创建另一个文件<code class="eh lk ll lm ln b">item-list/async.js</code>:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2bca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的关键变化是在动态<code class="eh lk ll lm ln b">import</code>中:我们不是导入单个组件，而是导入所有的<code class="eh lk ll lm ln b">index.js</code>，并在承诺回调中提取所需的组件。</p><h1 id="b4a5" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">区块命名和优化</h1><p id="4789" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">当我们在实现代码拆分后构建生产应用程序时，我们会得到许多类似如下的Javascript代码块:</p><pre class="jr js jt ju fq lq ln lr ls aw lt dt"><span id="ef98" class="lu ki hu ln b fv lv lw l lx ly">File sizes after gzip:</span><span id="404d" class="lu ki hu ln b fv lz lw l lx ly">  396.71 KB              build/static/js/main.3a8842c0.js<br/>  178.51 KB              build/static/css/main.e32b4522.css<br/>  68.31 KB               build/static/js/6.af93367f.chunk.js<br/>  44.34 KB               build/static/js/2.6a7f1417.chunk.js<br/>  23.61 KB               build/static/js/1.bdfdcd83.chunk.js<br/>  22.24 KB               build/static/js/3.d9e4ee99.chunk.js<br/>  19.29 KB               build/static/js/4.a66b3cdb.chunk.js<br/>  17.1 KB                build/static/js/5.f1ce26f7.chunk.js<br/>  7.63 KB                build/static/js/8.2e807534.chunk.js<br/>  6.71 KB                build/static/js/9.409015da.chunk.js<br/>  5.09 KB                build/static/js/7.1b95d8e8.chunk.js<br/>  1.71 KB                build/static/js/0.6bea2af7.chunk.js<br/>  1 KB                   build/static/js/10.ce9f2434.chunk.js</span></pre><p id="8f79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在查看了这个输出之后，我们可能想要删除最后几个块，因为它们真的很小。但是我们不知道哪一次分裂导致了哪一部分被创造出来。这就是块命名有用的地方。</p><p id="6ab9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在<code class="eh lk ll lm ln b">import</code>中使用一个<em class="jp">魔法注释</em>,告诉Webpack使用特定块的给定名称:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2372" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦命名了所有的块，我们就可以识别导致更小块的分割:</p><pre class="jr js jt ju fq lq ln lr ls aw lt dt"><span id="5cae" class="lu ki hu ln b fv lv lw l lx ly">File sizes after gzip:</span><span id="bfe1" class="lu ki hu ln b fv lz lw l lx ly">  312.09 KB  build/static/js/main.491eaaf4.js<br/>  181 KB      build/static/css/main.ac06cedb.css<br/>  68.88 KB   build/static/js/settings.1525d075.chunk.js<br/>  45.08 KB   build/static/js/alerts.0f5ad4d6.chunk.js<br/>  23.62 KB   build/static/js/profile.199c7f90.chunk.js<br/>  22.24 KB   build/static/js/history.07ccea31.chunk.js<br/>  19.3 KB    build/static/js/actions.903378a5.chunk.js<br/>  8.87 KB    build/static/js/events.f540de3a.chunk.js<br/>  7.62 KB    build/static/js/colors.89aa1e6f.chunk.js<br/>  6.7 KB     build/static/js/posts.929f04fc.chunk.js<br/>  5.1 KB     build/static/js/post-details.6c133f77.chunk.js<br/>  1.71 KB    build/static/js/friend-list.be516e45.chunk.js<br/>  1.01 KB    build/static/js/edit-avatar.33a4ff21.chunk.js</span></pre><p id="9c5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我们可以选择删除或合并一些较小的块(&lt; 20–30 KB in size), since the overhead of loading a 5 KB chunk might be higher than combining it with one of the larger chunks. Play around with different splits and see what works best for you.</p><h1 id="7ba2" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">Analyzing the Bundle Size</h1><p id="f5b6" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated"><a class="ae kg" href="https://www.npmjs.com/package/source-map-explorer" rel="noopener ugc nofollow" target="_blank">源地图浏览器</a>使用源地图分析JavaScript包。这有助于您理解代码膨胀的来源。要将源地图浏览器添加到Create React App项目，请运行以下命令:</p><pre class="jr js jt ju fq lq ln lr ls aw lt dt"><span id="80a9" class="lu ki hu ln b fv lv lw l lx ly">npm install --save source-map-explorer</span></pre><p id="c555" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后在<code class="eh lk ll lm ln b">package.json</code>中，将下面一行添加到<code class="eh lk ll lm ln b">scripts</code>:</p><pre class="jr js jt ju fq lq ln lr ls aw lt dt"><span id="c489" class="lu ki hu ln b fv lv lw l lx ly">"scripts": {<br/>    <strong class="ln hv">"analyze": "source-map-explorer build/static/js/main.*",</strong></span></pre><p id="cb80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后要分析包，运行生产构建，然后运行分析脚本。</p><pre class="jr js jt ju fq lq ln lr ls aw lt dt"><span id="3209" class="lu ki hu ln b fv lv lw l lx ly">npm run build<br/>npm run analyze</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/86672e580bb9e74de78683b324bc12d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gim2V4ykKLDljKnIFYzbBg.jpeg"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek"><a class="ae kg" href="https://www.npmjs.com/package/source-map-explorer" rel="noopener ugc nofollow" target="_blank">Source map explorer</a></figcaption></figure><p id="6c93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">寻找对包大小影响最大的部分，作为代码分割的可能候选。还要考虑从<code class="eh lk ll lm ln b">node_modules</code>中移除或删除大的依赖项。</p><h1 id="78f6" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">摘要</h1><p id="4abd" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">以下是在React应用程序中实现有效代码拆分的步骤:</p><ol class=""><li id="c514" class="mb mc hu it b iu iv iy iz jc md jg me jk mf jo mg mh mi mj dt translated">使用<code class="eh lk ll lm ln b">react-loadable</code>实现基于组件的代码拆分，按需加载应用不同部分的Javascript包。</li><li id="b712" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">使用<code class="eh lk ll lm ln b">import("./index").then</code>技巧将经常使用的多个组件组合成一个文件。</li><li id="7fc7" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">使用神奇的注释<code class="eh lk ll lm ln b">/* webpackChunkName: xxx */</code>命名您的块，并优化包的大小，使它们既不太小也不太大。</li><li id="f8fd" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">使用<code class="eh lk ll lm ln b">source-map-explorer</code>识别可能的代码分割候选。</li></ol><p id="b74c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了使本文简短，我跳过了许多细节，将重点放在代码拆分的实际方面。以下是一些了解该主题更多信息的好地方:</p><ul class=""><li id="678c" class="mb mc hu it b iu iv iy iz jc md jg me jk mf jo mp mh mi mj dt translated">动态<code class="eh lk ll lm ln b">import</code>:<a class="ae kg" href="https://developers.google.com/web/updates/2017/11/dynamic-import" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/updates/2017/11/dynamic-import</a></li><li id="58b2" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mp mh mi mj dt translated">反应官方文件:【https://reactjs.org/docs/code-splitting.html T4】</li><li id="f5bd" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mp mh mi mj dt translated"><code class="eh lk ll lm ln b">react-loadable</code>:<a class="ae kg" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank">https://github.com/jamiebuilds/react-loadable</a></li><li id="1742" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mp mh mi mj dt translated">Webpack中的块命名:<a class="ae kg" href="https://github.com/webpack/webpack/tree/master/examples/code-splitting-specify-chunk-name" rel="noopener ugc nofollow" target="_blank">https://github . com/web pack/web pack/tree/master/examples/code-splitting-specify-chunk-name</a></li></ul></div></div>    
</body>
</html>