<html>
<head>
<title>How to use ImmutableJS without going crazy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不发疯的情况下使用ImmutableJS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-use-immutablejs-without-going-crazy-bfcb805a0043?source=collection_archive---------3-----------------------#2018-03-18">https://medium.com/hackernoon/how-to-use-immutablejs-without-going-crazy-bfcb805a0043?source=collection_archive---------3-----------------------#2018-03-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/636096279eb1780402a3c21f296c0ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvG4chagatK_o9xQa6jKeA.png"/></div></div></figure><div class=""/><p id="7c7d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你在<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>生态系统中，你可能知道有许多新的库和良好的实践仍在开发中，尤其是在ReactJS生态系统中。</p><p id="8919" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您正在使用ReactJS开发单页面应用程序，并且使用Redux进行状态管理<a class="ae ka" href="https://hackernoon.com/tagged/management" rel="noopener ugc nofollow" target="_blank">和</a>，那么您可能听说过ImmutableJS。</p><p id="7da6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个帮助开发人员保持状态不变以避免难以发现的错误的库。</p><p id="fe25" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使不是这样，但它也有助于在正确的时间重新渲染组件。你大概知道React是用浅层比较来知道部分道具是否有改动。</p><p id="f0c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您将结构化数据传递到组件(数组、对象)时，这可能会带来问题。React不要执行深度比较(因为代价很高)，这样可能会遇到意想不到的行为。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="1549" class="kk kl if kg b fv km kn l ko kp">// In reducer.js<br/>const state = {<br/>  usersPage: {<br/>    loading: false,<br/>    isFetched: false,<br/>    list: [],<br/>  },<br/>  companiesPage: {<br/>    loading: false,<br/>    isFetched: false,<br/>    list: [],<br/>  },<br/>};</span><span id="513f" class="kk kl if kg b fv kq kn l ko kp">// In UsersPage.js<br/>class UsersPage extends React.Component {<br/>  render() {<br/>    const { loading, list } = this.props.usersPage;</span><span id="d424" class="kk kl if kg b fv kq kn l ko kp">    return (<br/>      &lt;div&gt;<br/>        { loading &amp;&amp; &lt;LoadingIndicator /&gt; }<br/>        { !loading &amp;&amp; &lt;UsersTable list={list} /&gt; }<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="9d80" class="kk kl if kg b fv kq kn l ko kp">function mapStateToProps(state) {<br/>  return {<br/>    usersPage: <strong class="kg ig">selectors.selectUsersPage(state)</strong>,<br/>  };<br/>}</span><span id="e6d8" class="kk kl if kg b fv kq kn l ko kp">// In selectors.js<br/>const selectUsersPage = (state) =&gt; state.usersPage;</span></pre><p id="cee0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到上面的代码，一切似乎都很好。然而，如果你以错误的方式实现了状态更新，比如你没有创建一个新的对象，那么React不会更新你的组件。例如:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="07d6" class="kk kl if kg b fv km kn l ko kp">// Incorrect implementation<br/>function reducer(state, action) {<br/>  switch(action.type) {<br/>    case 'USERS_LOADED':<br/>      state.usersPage.list = action.payload;<br/>      state.usersPage.loading = false;<br/>      state.usersPage.isFetched = true;<br/>      return state;<br/>    default:<br/>      return state;<br/>  }<br/>}<br/>// Correct implementation<br/>function reducer(state, action) {<br/>  switch(action.type) {<br/>    case 'USERS_LOADED':<br/>      return {<br/>        ...state,<br/>        usersPage: Object.assign({}, state.usersPage, {<br/>          list: Object.payload,<br/>          loading: false,<br/>          isFetched: true,<br/>        }),<br/>      };<br/>    default:<br/>      return state;<br/>  }<br/>}</span></pre><p id="2ebe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你在上面的代码中看到的，事情很容易变得棘手。你必须确保，你在返回新的对象的同时，还保留了状态的其他分支，并正确地更新了当前分支中的变量。</p><p id="93df" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们看看不可变JS中的实现:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="2284" class="kk kl if kg b fv km kn l ko kp">import { fromJS } from 'immutable';<br/>const state = fromJS({<br/>  usersPage: {<br/>    loading: false,<br/>    isFetched: false,<br/>    list: [],<br/>  },<br/>  companiesPage: {<br/>    loading: false,<br/>    isFetched: false,<br/>    list: [],<br/>  },<br/>});</span><span id="60cf" class="kk kl if kg b fv kq kn l ko kp">function reducer(state, action) {<br/>  switch(action.type) {<br/>    case 'USERS_LOADED':<br/>      return state<br/><strong class="kg ig">        .setIn(['usersPage', 'list'], fromJS(action.payload))<br/>        .setIn(['usersPage', 'isFetched'], true)<br/>        .setIn(['usersPage', 'loading'], false)<br/></strong>        ;<br/>    default:<br/>      return state;<br/>  }<br/>}</span></pre><p id="1625" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种语法使得阅读和维护更加简单。并且ImmutableJS在您每次改变状态时都会返回一个新的对象。</p><p id="54c2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，您将不得不使用ImmutableJS <strong class="je ig"> getters </strong>来获取这些值:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="67e4" class="kk kl if kg b fv km kn l ko kp">// In UsersPage.js<br/>class UsersPage extends React.Component {<br/>  render() {<br/>    const { usersPage } = this.props;<br/><strong class="kg ig">    const loading = usersPage.get('loading');<br/>    const list = usersPage.get('list').toJS();</strong></span><span id="0367" class="kk kl if kg b fv kq kn l ko kp">    return (<br/>      &lt;div&gt;<br/>        { loading &amp;&amp; &lt;LoadingIndicator /&gt; }<br/>        { !loading &amp;&amp; &lt;UsersTable list={list} /&gt; }<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="0359" class="kk kl if kg b fv kq kn l ko kp">function mapStateToProps(state) {<br/>  return {<br/>    usersPage: selectors.selectUsersPage(state),<br/>  };<br/>}</span><span id="74a4" class="kk kl if kg b fv kq kn l ko kp">// In selectors.js<br/><strong class="kg ig">const selectUsersPage = (state) =&gt; state.get('usersPage');</strong></span></pre><p id="b5f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更糟糕的是，有时不可变的对象会更深地渗入到你的组件中，甚至可能渗入到你的在线组件中(请看<code class="eh kr ks kt kg b">toJS()</code>)。这通常是人们反对使用不变量的原因之一。</p><p id="c1fc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您计划发布您的包时，情况会变得更糟。你不想让开发人员使用某个库来束缚他们的手脚。</p><p id="12d4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么如何结合两个世界的优点呢？</p><h1 id="4a71" class="ku kl if bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated"><strong class="ak">重新选择救援！</strong></h1><p id="68a2" class="pw-post-body-paragraph jc jd if je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">Reselect是一个很棒的库，可以帮助你解决这个问题。</p><p id="a1e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们首先了解一下Reselect是为什么而构建的:</p><p id="967c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">【Redux的简单“选择器”库。</p><ul class=""><li id="9dc3" class="lx ly if je b jf jg jj jk jn lz jr ma jv mb jz mc md me mf dt translated"><em class="lw">选择器可以计算派生数据，允许Redux存储最小可能状态。</em></li><li id="bb10" class="lx ly if je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated"><em class="lw">选择器效率高。除非选择器的一个参数发生更改，否则不会重新计算选择器。</em></li><li id="6cbc" class="lx ly if je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated"><em class="lw">选择器是可组合的。它们可以用作其他选择器的输入。</em></li></ul><p id="8b98" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">跟我裸一会儿。考虑以下代码:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="d6eb" class="kk kl if kg b fv km kn l ko kp">import { createSelector } from 'reselect';</span><span id="3ee0" class="kk kl if kg b fv kq kn l ko kp">const selectUsersPageDomain = (state) =&gt; state.get('usersPage');</span><span id="5f19" class="kk kl if kg b fv kq kn l ko kp">const makeSelectUsersPage = createSelector(<br/>  selectUsersPageDomain,<br/>  (substate) =&gt; substate.toJS(),<br/>);</span></pre><p id="71dc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，您可以再次使用纯JS语法:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="1fb8" class="kk kl if kg b fv km kn l ko kp">import { <strong class="kg ig">createStructuredSelector</strong> } from 'reselect';</span><span id="eb5b" class="kk kl if kg b fv kq kn l ko kp">class UsersPage extends React.Component {<br/>  render() {<br/><strong class="kg ig">    const { loading, list } = this.props.usersPage;</strong></span><span id="b22b" class="kk kl if kg b fv kq kn l ko kp">return (<br/>      &lt;div&gt;<br/>        { loading &amp;&amp; &lt;LoadingIndicator /&gt; }<br/>        { !loading &amp;&amp; &lt;UsersTable list={list} /&gt; }<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="328d" class="kk kl if kg b fv kq kn l ko kp">const mapStateToProps = <strong class="kg ig">createStructuredSelector</strong>({<br/>  usersPage: selectors.makeSelectUsersPage(),<br/>});</span></pre><p id="d175" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果<code class="eh kr ks kt kg b">userPage</code>分支没有变化，选择器<strong class="je ig">不会重新计算</strong>的值，反应<strong class="je ig">不会触发</strong>组件渲染。</p><p id="f4aa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你所看到的，使用这个策略，你可以结合两个世界的优点。</p><p id="214f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">但是有一个重要的不明显的好处我还没有谈到:</strong></p><p id="86ed" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您使用ImmutableJS更新某个分支时，所有未受影响的分支保持不变:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="b136" class="kk kl if kg b fv km kn l ko kp">const { fromJS } = require('immutable');<br/>const state = fromJS({<br/>  usersPage: {<br/>    loading: false,<br/>    isFetched: false,<br/>    list: [],<br/>  },<br/>  companiesPage: {<br/>    loading: false,<br/>    isFetched: false,<br/>    list: [],<br/>  },<br/>});</span><span id="ff51" class="kk kl if kg b fv kq kn l ko kp">console.log('Updating usersPage branch');<br/>const state1 = state.setIn(['usersPage', 'loading'], true);<br/>state.get('usersPage') === state1.get('usersPage'); // false<br/><strong class="kg ig">state.get('companiesPage') === state1.get('companiesPage'); // true<br/></strong>state === state1; // false</span><span id="c7e1" class="kk kl if kg b fv kq kn l ko kp">console.log('Updating companiesPage branch');<br/>const state2 = state1.setIn(['companiesPage', 'loading'], true);<br/><strong class="kg ig">state1.get('usersPage') === state2.get('usersPage'); // true<br/></strong>state1.get('companiesPage') === state2.get('companiesPage'); // false<strong class="kg ig"><br/></strong>state1 === state2; // false</span></pre><p id="acbc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lw">注意:我删除了</em> <code class="eh kr ks kt kg b"><em class="lw">console.log</em></code> <em class="lw">语句以使行更短。</em></p><p id="4763" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你看看代码，你会发现没有更新的分支将保持不变-&gt;所以<code class="eh kr ks kt kg b">reselect</code>选择器不会触发更新。<strong class="je ig">只有更新分支的选择器才会被更新</strong>。</p><p id="da51" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是状态的根也被更新了！因此，在编写选择器时，您必须小心一点:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="56d9" class="kk kl if kg b fv km kn l ko kp">// In reducer.js<br/>const { fromJS } = require('immutable');<br/>const state = fromJS({<br/><strong class="kg ig">  pages: { // We put our pages 1 more level deeper<br/></strong>    usersPage: {<br/>      loading: false,<br/>      isFetched: false,<br/>      list: [],<br/>    },<br/>    companiesPage: {<br/>      loading: false,<br/>      isFetched: false,<br/>      list: [],<br/>    },<br/>  }<br/>});</span><span id="ad75" class="kk kl if kg b fv kq kn l ko kp">// In selectors.js<br/><strong class="kg ig">// Incorrect implementation<br/></strong>import { createSelector } from 'reselect';<br/><strong class="kg ig">const selectPagesDomain = (state) =&gt; state.get('pages');<br/></strong>const selectUsersPageDomain = (state) =&gt; state.get('usersPage');<br/>const selectCompaniesPageDomain = (state) =&gt; state.get('companiesPage');</span><span id="b728" class="kk kl if kg b fv kq kn l ko kp">const makeSelectUsersPage = createSelector(<br/>  <strong class="kg ig">selectPagesDomain</strong>, // source of problem<br/>  selectUsersPageDomain,<br/>  (substate) =&gt; substate.toJS(),<br/>);</span><span id="67c0" class="kk kl if kg b fv kq kn l ko kp">const makeSelectCompaniesPage = createSelector(<br/>  <strong class="kg ig">selectPagesDomain</strong>, // source of problem<br/>  selectCompaniesPageDomain,<br/>  (substate) =&gt; substate.toJS(),<br/>);</span></pre><p id="55a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你像这样实现选择器，当你只改变其中一个的值时，<code class="eh kr ks kt kg b">makeSelectCompaniesPage</code>和<code class="eh kr ks kt kg b">makeSelectUsersPage</code>都会被触发。这可能是你不想要的。</p><p id="6a13" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为什么会被触发？回头看看这条规则:</p><ul class=""><li id="d3c5" class="lx ly if je b jf jg jj jk jn lz jr ma jv mb jz mc md me mf dt translated">选择器是高效的。除非选择器的一个参数发生更改，否则不会重新计算选择器。</li></ul><p id="f8d8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为如果<strong class="je ig">的任何一个</strong>分支发生变化，<code class="eh kr ks kt kg b">selectPagesDomain</code>将返回不同的值，所以<code class="eh kr ks kt kg b">reselect</code>每次都会重新计算两个选择器。</p><p id="0507" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是正确的实现方式:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f60a" class="kk kl if kg b fv km kn l ko kp">// Correct implementation<br/>import { createSelector } from 'reselect';<br/>const selectUsersPageDomain = (state) =&gt; <strong class="kg ig">state.getIn(['pages', 'usersPage'])</strong>;<br/>const selectCompaniesPageDomain = (state) =&gt; <strong class="kg ig">state.getIn(['pages', 'companiesPage'])</strong>;</span><span id="20df" class="kk kl if kg b fv kq kn l ko kp">const makeSelectUsersPage = createSelector(<br/>  <strong class="kg ig">selectUsersPageDomain</strong>,<br/>  (substate) =&gt; substate.toJS(),<br/>);</span><span id="3512" class="kk kl if kg b fv kq kn l ko kp">const makeSelectCompaniesPage = createSelector(<br/>  <strong class="kg ig">selectCompaniesPageDomain</strong>,<br/>  (substate) =&gt; substate.toJS(),<br/>);</span></pre><p id="775c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您希望选择与选择器中要使用的数据最接近的路径，以防止在其他分支发生变化时重新计算。</p><blockquote class="ml mm mn"><p id="7571" class="jc jd lw je b jf jg jh ji jj jk jl jm mo jo jp jq mp js jt ju mq jw jx jy jz hn dt translated">如果你坚持到了这里，恭喜你！</p></blockquote><p id="9e96" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们把这些放在一起:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f160" class="kk kl if kg b fv km kn l ko kp"><strong class="kg ig">// In reducer.js<br/></strong>const { fromJS } = require('immutable');<br/>const state = fromJS({<br/>  pages: {<br/>    usersPage: {<br/>      loading: false,<br/>      isFetched: false,<br/>      list: [],<br/>    },<br/>    companiesPage: {<br/>      loading: false,<br/>      isFetched: false,<br/>      list: [],<br/>    },<br/>  }<br/>});</span><span id="ec56" class="kk kl if kg b fv kq kn l ko kp">function reducer(state, action) {<br/>  switch(action.type) {<br/>    case 'USERS_LOADED':<br/>      return state<br/>        .setIn(['usersPage', 'list'], fromJS(action.payload))<br/>        .setIn(['usersPage', 'isFetched'], true)<br/>        .setIn(['usersPage', 'loading'], false)<br/>        ;<br/>    case 'COMPANIES_LOADED':<br/>      return state<br/>        .setIn(['companiesPage', 'list'], fromJS(action.payload))<br/>        .setIn(['companiesPage', 'isFetched'], true)<br/>        .setIn(['companiesPage', 'loading'], false)<br/>        ;<br/>    default:<br/>      return state;<br/>  }<br/>}</span><span id="b323" class="kk kl if kg b fv kq kn l ko kp">export default reducer;</span><span id="22d3" class="kk kl if kg b fv kq kn l ko kp"><strong class="kg ig">// In selectors.js<br/></strong>import { createSelector } from 'reselect';<br/>const selectUsersPageDomain = (state) =&gt; state.getIn(['pages', 'usersPage']);<br/>const selectCompaniesPageDomain = (state) =&gt; state.getIn(['pages', 'companiesPage']);</span><span id="7b25" class="kk kl if kg b fv kq kn l ko kp">export const makeSelectUsersPage = createSelector(<br/>  selectUsersPageDomain,<br/>  (substate) =&gt; substate.toJS(),<br/>);</span><span id="b1e9" class="kk kl if kg b fv kq kn l ko kp">export const makeSelectCompaniesPage = createSelector(<br/>  selectCompaniesPageDomain,<br/>  (substate) =&gt; substate.toJS(),<br/>);</span><span id="df4e" class="kk kl if kg b fv kq kn l ko kp"><strong class="kg ig">// In UsersPage.js<br/></strong>import { createStructuredSelector } from 'reselect';<br/>import * as selectors from './selectors';</span><span id="4528" class="kk kl if kg b fv kq kn l ko kp">class UsersPage extends React.Component {<br/>  render() {<br/>    const { loading, list } = this.props.usersPage;</span><span id="415f" class="kk kl if kg b fv kq kn l ko kp">    return (<br/>      &lt;div&gt;<br/>        { loading &amp;&amp; &lt;LoadingIndicator /&gt; }<br/>        { !loading &amp;&amp; &lt;UsersTable list={list} /&gt; }<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="7e08" class="kk kl if kg b fv kq kn l ko kp">const mapStateToProps = createStructuredSelector({<br/>  usersPage: selectors.makeSelectUsersPage(),<br/>});</span><span id="e124" class="kk kl if kg b fv kq kn l ko kp">export default connect(mapStateToProps)(UsersPage);</span><span id="8b91" class="kk kl if kg b fv kq kn l ko kp"><strong class="kg ig">// In CompaniesPage.js<br/></strong>import { createStructuredSelector } from 'reselect';<br/>import * as selectors from './selectors';</span><span id="9c7b" class="kk kl if kg b fv kq kn l ko kp">class CompaniesPage extends React.Component {<br/>  render() {<br/>    const { loading, list } = this.props.companiesPage;</span><span id="dbcf" class="kk kl if kg b fv kq kn l ko kp">    return (<br/>      &lt;div&gt;<br/>        { loading &amp;&amp; &lt;LoadingIndicator /&gt; }<br/>        { !loading &amp;&amp; &lt;CompaniesTable list={list} /&gt; }<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="84c0" class="kk kl if kg b fv kq kn l ko kp">const mapStateToProps = createStructuredSelector({<br/>  companiesPage: selectors.makeSelectCompaniesPage(),<br/>});</span><span id="f990" class="kk kl if kg b fv kq kn l ko kp">export default connect(mapStateToProps)(CompaniesPage);</span></pre><p id="7f47" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样！</p><p id="6284" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您可以使用两个<strong class="je ig">不可变组件</strong>的所有优点，而不需要在您的容器或呈现组件中使用它的getters。</p><p id="58ef" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最重要的是，你获得了<strong class="je ig">重新选择</strong>库的优势，它可以帮助你使你的选择器更有效。</p><p id="1849" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我知道你的想法！</p><p id="6485" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">参考资料:</p><div class="ht hu fm fo hv mr"><a href="https://redux.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab ej"><div class="mt ab mu cl cj mv"><h2 class="bd ig fv z el mw eo ep mx er et ie dt translated">Redux</h2><div class="my l"><h3 class="bd b fv z el mw eo ep mx er et ek translated">如果不使用模块捆绑器，也没问题。npm包包括预编译的生产和开发…</h3></div><div class="mz l"><p class="bd b gc z el mw eo ep mx er et ek translated">redux.js.org</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ib mr"/></div></div></a></div><div class="ht hu fm fo hv mr"><a href="https://github.com/reactjs/reselect" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab ej"><div class="mt ab mu cl cj mv"><h2 class="bd ig fv z el mw eo ep mx er et ie dt translated">反应/重新选择</h2><div class="my l"><h3 class="bd b fv z el mw eo ep mx er et ek translated">Redux的重选选择器库</h3></div><div class="mz l"><p class="bd b gc z el mw eo ep mx er et ek translated">github.com</p></div></div><div class="na l"><div class="ng l nc nd ne na nf ib mr"/></div></div></a></div><figure class="kb kc kd ke fq hw"><div class="bz el l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>