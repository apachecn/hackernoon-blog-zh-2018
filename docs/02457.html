<html>
<head>
<title>The Javascript Developer’s Guide to Graphs and Detecting Cycles in Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript开发人员关于图形和检测图形中的循环的指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-javascript-developers-guide-to-graphs-and-detecting-cycles-in-them-96f4f619d563?source=collection_archive---------2-----------------------#2018-03-19">https://medium.com/hackernoon/the-javascript-developers-guide-to-graphs-and-detecting-cycles-in-them-96f4f619d563?source=collection_archive---------2-----------------------#2018-03-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9635" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我第一次参加全栈软件工程职位的现场面试时，我被要求写一个函数来检测有向图中是否存在循环。</p><p id="24d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">读者:我没有成功地编写那个函数。</p><p id="82dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">老实说，我对什么是图有一个模糊的想法，即使是<em class="jp">是</em>。在我生命的大部分时间里，我认为图表是这样的:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/b5d4cf6ec41c3b39621ba41d9ec0c5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtE4YK8X5_RkikL2wFNZ-g.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Source: <a class="ae kg" href="http://bit.ly/2HFsh9w" rel="noopener ugc nofollow" target="_blank">http://bit.ly/2HFsh9w</a></figcaption></figure><p id="0757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，图表实际上是这样的:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kh"><img src="../Images/93c6fc7e225bb1c9fe1a12b76f2e584a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qq0sgd0Kny9QTaD-UT8LbQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Source: <a class="ae kg" href="http://bit.ly/1OCkA1r" rel="noopener ugc nofollow" target="_blank">http://bit.ly/1OCkA1r</a></figcaption></figure><p id="769e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我知道，我也认为第一部看起来更有趣。但是图形实际上是一个非常酷的数据结构。它们在计算机科学中无处不在，用于<a class="ae kg" href="http://www.objectivity.com/building-a-recommendation-engine-using-a-graph-database/" rel="noopener ugc nofollow" target="_blank">推荐引擎</a>和<a class="ae kg" href="http://blogs.cornell.edu/info2040/2011/09/14/google-maps-its-just-one-big-graph/" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>，当然还有<a class="ae kg" href="http://graphql.org/learn/thinking-in-graphs/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>。问题是，没有多少文章详细介绍Javascript中用图形实现/tricks。所以我决定写一个。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><p id="28a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么什么是图表呢？</p><p id="4ddb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于图要知道的最基本的事情是它们由<strong class="it hv">顶点</strong>和<strong class="it hv">边组成。</strong>顶点是图的<em class="jp">事物</em>:整数、物体、网站等。边连接一对顶点。</p><p id="99ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图表可以是:</p><ol class=""><li id="4af3" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated">加权或未加权-这是指图表的边是否标有值。如果是，那就是加权的。</li><li id="8b2a" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">有向或无向-这是指边的行为是像桥(无向)还是像保龄球道(有向)。</li><li id="0cb7" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">循环或非循环—这是指图中是否存在循环。</li></ol><p id="df4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有两种主要的方式来表示一个图:用一个<strong class="it hv">邻接表</strong>，它是与每个节点<strong class="it hv">相关联的数组(或者对象，如果你喜欢的话)的集合</strong></p><pre class="jr js jt ju fq ld le lf lg aw lh dt"><span id="4580" class="li lj hu le b fv lk ll l lm ln">{<br/>a: [b,c,d],<br/>b: [c,f],<br/>d: [e],<br/>e: [a,f],<br/>f: [a, c, d, e]<br/>}</span></pre><p id="fe28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者使用一个<strong class="it hv">邻接矩阵</strong>，它是一个二维数组，其中顶点之间的边用1 <strong class="it hv"> : </strong>表示</p><pre class="jr js jt ju fq ld le lf lg aw lh dt"><span id="6133" class="li lj hu le b fv lk ll l lm ln">[ [0, 1, 0, 0, 0, 0, 1, 0, 1, 0],<br/>  [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],<br/>  [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],<br/>  [0, 0, 0, 0, 1, 1, 0, 0, 1, 0],<br/>  [0, 1, 1, 1, 0, 1, 0, 0, 0, 1],<br/>  [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],<br/>  [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],<br/>  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1],<br/>  [1, 0, 0, 1, 0, 0, 0, 1, 0, 0],<br/>  [0, 1, 0, 0, 1, 0, 0, 1, 0, 0] ]</span></pre><p id="566d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每种表现都有利弊。一般来说，边多的图作为矩阵更好，边少的图作为列表更好。邻接表更常见，这就是我们今天要用的。</p><h1 id="c11a" class="lo lj hu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk dt translated">制作图表</h1><p id="141d" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">所以让我们开始制作吧！喔。我们要做的第一件事是…制作一个图表。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mq"><img src="../Images/e6194e46ca6fc3ae08f045116b07f921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EQ603pGGHvnMPfpXcVtgQ.png"/></div></div></figure><p id="0322" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图构造函数内部的逻辑很简单:只是一个实例化为对象文字的邻接表。接下来的两个方法并不复杂:一个是添加顶点的方法，将每个顶点初始化为空数组；另一个是添加边的方法，将一个顶点推入另一个顶点的数组。所以像这样的事情…</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/160c15e19a29597c323ff98c5665fea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*sJHV41QbfmQRgqs8lTVp_A.png"/></div></figure><p id="3df8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">制作了一个类似这样的图表:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/73a8ad0cccf410fed0cc1efed2ddb700.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*dlDaYcPg0_oEgRTKeHfyfw.png"/></div></figure><p id="aa0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者换句话说:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mt"><img src="../Images/01cd9436b6bc1f875ed2e8e4dc3fb0d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54Ay9dXerR87OoZUS1uI7w.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">RIP Microsoft Paint</figcaption></figure><p id="07ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了一个图表！耶。不是任何一个图:一个未加权的，有向的，无环的图。</p><h1 id="f159" class="lo lj hu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk dt translated">遍历图形</h1><p id="900c" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">现在我们有了一个图，我们将需要找出一种方法来访问不同的顶点——毕竟，我们的最终目标是检测图是否是循环的，这意味着沿着图的边从一个顶点遍历到另一个顶点。</p><p id="176e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">遍历一个图有两种方法:一种是<strong class="it hv">广度优先遍历，</strong>先访问一个顶点的每个子节点，然后再访问该子节点的任何一个子节点，另一种是<strong class="it hv">深度优先遍历，</strong>我们沿着一系列由边连接的顶点进行遍历，直到我们不能继续下去，然后再继续到原始顶点的下一个子节点。我们检测有向图中的循环的算法将使用深度优先遍历的修改版本，所以让我们快速地看一下这个遍历方法是什么样子的。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mu"><img src="../Images/426fe01abd50b932b670f7fa67590eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXyMasS2xV_rTiK3EnGTcg.png"/></div></div></figure><p id="bc7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有两个函数:一个dfs函数和一个_dfsUtil函数。</p><p id="6076" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">dfs功能只做三件事:</p><ol class=""><li id="1b7f" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated">创建一个名为“节点”的数组；每个元素都是我们图中的一个顶点</li><li id="c2d7" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">创建一个名为“visited”的对象文字</li><li id="97fd" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">在图中的每个顶点上调用我们的效用函数。</li></ol><p id="6a44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们执行一个图的深度优先遍历时，需要记住的重要事情是，与二叉树相反(例如)，我们需要跟踪我们已经访问过的节点，并且<em class="jp">而不是</em>第二次访问它们，即使另一个顶点有到那个节点的边。例如，如果我们没有跟踪我们访问过的顶点，那么从起点‘A’开始遍历我们的图会导致我们访问‘B’四次，而不是一次！🙅🙅🙅</p><pre class="jr js jt ju fq ld le lf lg aw lh dt"><span id="3772" class="li lj hu le b fv lk ll l lm ln">A -&gt; B<br/>A -&gt; D -&gt; B<br/>A -&gt; D -&gt; E -&gt; B<br/>A -&gt; C -&gt; E -&gt; B</span></pre><p id="763f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是为什么我们把访问过的数组作为参数传递给我们的效用函数。效用函数是我们访问一个顶点，将它标记为已访问，获取它的边，检查给定的边是否已经被访问过，如果没有，递归调用我们的效用函数，将该顶点作为新的起点和更新的“已访问”数组。</p><h1 id="4119" class="lo lj hu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk dt translated">但是……周期检测？</h1><p id="7412" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">对！检测周期。我们如何修改深度优先搜索功能来确定我们的图是循环的还是非循环的？</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mv"><img src="../Images/458575e04c677ffe39df03f6a76f1657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wG9rCrdzAXx62s_km2nheA.png"/></div></div></figure><p id="8228" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和以前一样，我们将为图中的每个顶点调用循环检测效用函数。只有当效用函数从不返回true时，我们才能确定这个图是非循环的。但是我们还将创建一个名为“recStack”的对象文字。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mw"><img src="../Images/c772764a1b113f5cd184967a7551b9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGCOOyu8Lmg8mI-feT62XQ.png"/></div></div></figure><p id="4681" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们正在做几件事:</p><ol class=""><li id="9a99" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated">在第45行，我们正在检查以确保我们还没有访问这个节点。如果有，就没必要再查了。</li><li id="976d" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">在第46和47行，我们在访问堆栈和recStack中将顶点设为真。在这个新的效用函数中，recStack代表“递归堆栈”,它跟踪<strong class="it hv">后沿，</strong>我们访问的顶点，以到达当前顶点。</li><li id="d2b9" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">和以前一样，我们将获得当前顶点的邻居并遍历它们。然而，这一次，我们不仅仅是检查我们是否访问过它们——我们还检查一个特定的边是否在我们的recStack中，这意味着我们已经访问过它。这是我们发现循环的标志。</li><li id="7785" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated">如果顶点不在我们的recStack中，那么我们将它从递归堆栈中弹出(第59行),这样当我们遍历图中的另一条路径时就不会得到误报。</li></ol><p id="4428" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嘿，很快:这就是我们检测图中是否有循环的函数。</p></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><p id="884e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我看过的大部分计算机科学入门资源中，图表并没有涉及太多，这真是一个遗憾。他们真的很酷，遍布整个学科，并且在入门级软件开发职位的面试中非常普遍(至少在我的经历中是这样)。所以，对我的(有抱负的)初级开发人员同事们:在你参加下一次面试之前，先学习一些图表。世事难料。</p><p id="ea00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是repl:<a class="ae kg" href="https://repl.it/@samisthesam/Cycle-detection-in-a-directed-graph" rel="noopener ugc nofollow" target="_blank">https://repl . it/@ samisthesam/有向图循环检测</a></p><p id="5b2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">感谢</em> <a class="ae kg" href="https://www.linkedin.com/in/sulamita/" rel="noopener ugc nofollow" target="_blank"> <em class="jp">苏拉米塔</em> </a> <em class="jp">的咨询和道义支持</em></p></div></div>    
</body>
</html>