<html>
<head>
<title>Reducing boilerplate in Redux Apps with Arc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Arc减少Redux应用程序中的样板文件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reducing-boilerplate-in-redux-apps-with-arc-d9550434470e?source=collection_archive---------3-----------------------#2018-03-19">https://medium.com/hackernoon/reducing-boilerplate-in-redux-apps-with-arc-d9550434470e?source=collection_archive---------3-----------------------#2018-03-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/fc07d6e2ce82f6d4a3a0b8cd6ce72d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjhNSm6uGpVJteJ5OeHWWw.jpeg"/></div></div></figure><div class=""/><p id="5dcc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Redux太牛逼了！但是人们经常抱怨在使用它的时候要写多少样板文件。这个问题的一部分，是因为他们觉得定义<em class="ka">常量</em>、<em class="ka">动作创建者</em>和大<em class="ka">缩减者</em>是徒劳的，也因为他们不清楚如何组织他们的项目，甚至不知道如何正确处理异步请求。在这篇文章中，我们将讨论这些问题，并提出一些解决方法。</p><h1 id="4a3e" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">关于Redux Arc</h1><p id="6cf1" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Arc 是一个微小且经过良好测试的库，可以帮助你在日常工作中使用Redux提高效率。它具有抽象<em class="ka">动作类型</em>、<em class="ka">动作创建者</em>、<em class="ka">减少者</em>的实用程序，并且它还具有管理<em class="ka">异步请求</em>的优雅方式。另外值得一提的是，在生产中用了快一年，没有后悔过一天！</p><p id="8351" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们谈谈创造行动！</p><h1 id="1035" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">关于创建动作的过程</h1><p id="0495" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当我们在谈论<em class="ka"> Redux </em>的时候，通常，我们要创建一个新特性的第一步是:创建<strong class="je ig"> <em class="ka">动作类型</em> </strong>和<strong class="je ig"> <em class="ka">动作创建者</em> </strong>。</p><p id="bb01" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们正在创建一个联系人应用程序，我们必须实现的第一个功能是创建一个联系人。类型为的<strong class="je ig">和动作为<strong class="je ig">的创建者</strong>看起来是这样的:</strong></p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="5112" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，您导入<em class="ka">动作类型</em>以在您的reducer中使用，并导入<em class="ka">动作创建器</em>以在您的组件中使用。</p><p id="95f6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码很好，但是不太可能只有一个<strong class="je ig">创建</strong>特性。在现实世界中，你至少会有一个<a class="ae lk" href="https://pt.wikipedia.org/wiki/CRUD" rel="noopener ugc nofollow" target="_blank"> <em class="ka"> CRUD </em> </a>。那么，让我们来看看它的代码:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="c3fe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码非常简单，但是正如你所看到的，感觉我们在重复代码。如果在Contacts CRUD中有这种感觉，想象一下在一个有几十个模块的应用程序中。</p><p id="fee5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你熟悉<em class="ka">干</em>，你就知道我们应该避免代码重复。你可能会说我们没有重复代码，因为每个创建者都有自己的“业务逻辑”,并且正在创建不同类型的操作，但是我不敢苟同。如果你真的注意，你可以看到模式:</p><ul class=""><li id="96a0" class="ll lm if je b jf jg jj jk jn ln jr lo jv lp jz lq lr ls lt dt translated">正如我们正在遵循<a class="ae lk" href="https://github.com/redux-utilities/flux-standard-action" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig"> <em class="ka">通量标准动作</em> </strong> </a>规范一样，每次我们想用我们的动作发送一个内容时，我们都应该把它保存在<code class="eh lu lv lw lx b">action.payload</code>中。任何额外的元信息，应归入<code class="eh lu lv lw lx b">action.meta</code>。如果我们的动作指示一个错误，<code class="eh lu lv lw lx b">action.error</code>应该为真，<code class="eh lu lv lw lx b">action.payload</code>应该包含实际的错误。</li><li id="0d20" class="ll lm if je b jf ly jj lz jn ma jr mb jv mc jz lq lr ls lt dt translated">我们总是用相同的名字定义动作<strong class="je ig">类型</strong>和<strong class="je ig">创建者</strong>，唯一的区别是一个是大写的，另一个是小写的。</li></ul><p id="da60" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">知道了第一种模式，我们可以试着规范化我们的创建者，稍微改变他们来使用固定的参数:<code class="eh lu lv lw lx b">payload</code>和<code class="eh lu lv lw lx b">meta</code>。</p><p id="5f45" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们以<strong class="je ig">创建</strong>动作为例，不使用<code class="eh lu lv lw lx b">name</code>、<code class="eh lu lv lw lx b">email</code>和<code class="eh lu lv lw lx b">phone</code>作为参数，我们可以只使用<code class="eh lu lv lw lx b">payload</code>:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="d5ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于第二种模式，动作类型可以基于创建者的名字生成。</p><p id="a638" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们可以规范化我们的<strong class="je ig">创建者</strong>，并且我们知道<strong class="je ig">类型</strong>可以基于<strong class="je ig">创建者</strong>的名字生成，那么完全有可能创建一个工厂，给定一个配置，它为我们生成<strong class="je ig">创建者</strong>和<strong class="je ig">类型</strong>。</p><p id="61eb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个带有生成创建者和类型的简单api的工厂会非常方便，对吗？这正是你在Arc的<code class="eh lu lv lw lx b">createActions</code>上看到的:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="md lj l"/></div></figure><blockquote class="me mf mg"><p id="689e" class="jc jd ka je b jf jg jh ji jj jk jl jm mh jo jp jq mi js jt ju mj jw jx jy jz hn dt translated">点击“运行”查看<code class="eh lu lv lw lx b">createActions</code>生成的输出</p></blockquote><p id="0d46" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">函数<code class="eh lu lv lw lx b">createActions</code>期望一个名称空间作为第一个参数，一个动作定义对象作为第二个参数。</p><p id="9487" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于动作定义对象，每个<strong class="je ig">键</strong>应该是创建者名称，每个<strong class="je ig">值</strong>可以是具有<code class="eh lu lv lw lx b">payload</code>、<code class="eh lu lv lw lx b">meta</code>和<code class="eh lu lv lw lx b">error</code>默认值的对象，或者如果您不想要任何默认值，可以是<code class="eh lu lv lw lx b">null</code>。</p><p id="b500" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果将是一个对象，包含每个动作的<strong class="je ig">创建者</strong>和<strong class="je ig">类型</strong>。</p><h2 id="5072" class="mk kc if bd kd ml mm mn kh mo mp mq kl jn mr ms kp jr mt mu kt jv mv mw kx mx dt translated">类型</h2><p id="b094" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">上述配置中的类型如下所示:</p><pre class="le lf lg lh fq my lx mz na aw nb dt"><span id="3309" class="mk kc if lx b fv nc nd l ne nf">{<br/>  CREATE: 'CONTACTS_CREATE',<br/>  READ:   'CONTACTS_READ',<br/>  UPDATE: 'CONTACTS_UPDATE',<br/>  REMOVE: 'CONTACTS_REMOVE',<br/>}</span></pre><blockquote class="me mf mg"><p id="b572" class="jc jd ka je b jf jg jh ji jj jk jl jm mh jo jp jq mi js jt ju mj jw jx jy jz hn dt translated">注意:我们在配置中提供的名称空间被用来作为动作类型值的前缀，以避免在应用程序<strong class="je ig">中有两个同名的不同动作。</strong></p></blockquote><p id="a99b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于上面的对象，只要你想使用类型<strong class="je ig">创建</strong>，你就可以导入<strong class="je ig">类型</strong>对象并如下使用它:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><h2 id="9b6c" class="mk kc if bd kd ml mm mn kh mo mp mq kl jn mr ms kp jr mt mu kt jv mv mw kx mx dt translated">创造者</h2><p id="86b8" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">基于我们的CRUD配置，creators对象将类似于此:</p><pre class="le lf lg lh fq my lx mz na aw nb dt"><span id="e017" class="mk kc if lx b fv nc nd l ne nf">const creators = {<br/>  <strong class="lx ig">create</strong>: function (payload, meta, error) {...},<br/>  <strong class="lx ig">read</strong>:   function (payload, meta, error) {...},<br/>  <strong class="lx ig">update</strong>: function (payload, meta, error) {...},<br/>  <strong class="lx ig">remove</strong>: function (payload, meta, error) {...},<br/>};</span></pre><p id="43b3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Creators使用<code class="eh lu lv lw lx b">payload</code>、<code class="eh lu lv lw lx b">meta</code>和<code class="eh lu lv lw lx b">error</code>参数创建动作。它们都是可选的，因此，您可以随意省略它们。</p><p id="2ba3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看我们将如何使用我们的<strong class="je ig"> create </strong> creator:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="0701" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">creators只生成动作，因此，每当您想要调度一个动作时，您必须将它与Redux store中的<strong class="je ig"> dispatch </strong>方法结合使用，正如我们将在下面看到的。</p><h1 id="ffef" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">在组件中使用动作创建器</h1><p id="0880" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们最常使用creators的地方是在连接到商店的组件内部。</p><p id="25fe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你必须在一个组件中使用arc生成的creators时，没有什么秘密可言。看一下这个例子:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="b845" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你在上面的例子中看到的，我们刚刚在<strong class="je ig"> mapDispatchToProps </strong>中定义了一个<strong class="je ig"> create </strong>方法，以访问<strong class="je ig"> dispatch </strong>方法。然后，在我们的组件中，我们可以通过道具访问<strong class="je ig">创建</strong>。</p><pre class="le lf lg lh fq my lx mz na aw nb dt"><span id="b8f2" class="mk kc if lx b fv nc nd l ne nf">this.props.create(formValues);</span></pre><h1 id="933e" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">创建减速器</h1><p id="642f" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">正如您已经知道的，我们将在我们的<strong class="je ig">减速器</strong>中重用生成的<strong class="je ig">类型</strong>。但是，这也是我们必须讨论的关于减速器的其他内容。</p><p id="24d2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们调度一个动作时，Redux调用所有的应用程序reducer，然后，在reducer内部，我们必须检查调度的动作对给定的reducer是否有意义。</p><p id="54b1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我见过很多人使用开关盒来处理这种情况，你将动作<strong class="je ig">类型</strong>与你的<strong class="je ig">盒</strong>相匹配，你可以使用<code class="eh lu lv lw lx b">default case</code>返回到先前的状态。问题是switch cases不能很好地扩展，并且您可能最终需要维护痛苦的代码。</p><p id="12bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我也见过很多人使用多个if，包括我，但是这种方法与switch case的方法有类似的问题。</p><p id="d951" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用这两种方法，您最终会在同一个地方处理匹配逻辑和状态变化。这种方式很难每次专注于一小段代码。</p><p id="2427" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到这一点，我们在<em class="ka"> Arc </em>中创建了一个<code class="eh lu lv lw lx b">createReducers</code>函数，它接受一个<strong class="je ig">初始状态</strong>和一个<strong class="je ig">处理程序</strong>对象，其键是动作类型，值是每个动作的处理程序。看看下面的例子:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="de4d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法的主要思想是为每一种动作设置一个处理程序。这样你就可以每次专注于一小块代码，而不是一个100行的函数。与if和开关情况相比，它还具有更好的性能，因为它使用短路验证。其代码如下所示:</p><figure class="le lf lg lh fq hw"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="b7c1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，代码中没有魔法，我们所做的只是验证给定动作是否有处理程序。如果我们这样做了，我们就称之为提供<code class="eh lu lv lw lx b">state</code>和<code class="eh lu lv lw lx b">action</code>，如果我们没有，我们就返回先前的<code class="eh lu lv lw lx b">state</code>。不同之处在于，您已经对其进行了抽象和测试，并额外进行了验证，以减少您在提供无效操作类型或无效处理程序时的调试时间:</p><figure class="le lf lg lh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ng"><img src="../Images/d25f052abea48be1877676a2da93d76f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0uAIdhZK6-hvOj62hoykw.png"/></div></div></figure><h1 id="399c" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">创建异步请求</h1><p id="72f7" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Arc 也有一个很好的支持来帮助你处理异步请求，因为它最初就是被设计来做这个的。我计划在另一篇文章中探讨这个话题，但是如果你对此感兴趣，看看文档，看看你如何使用它:<a class="ae lk" href="http://redux-arc.js.org/#async-actions" rel="noopener ugc nofollow" target="_blank">redux-arc.js.org/#async-actions</a>。</p><h1 id="94e0" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">概述</h1><ul class=""><li id="3726" class="ll lm if je b jf kz jj la jn nh jr ni jv nj jz lq lr ls lt dt translated">函数<code class="eh lu lv lw lx b">createAction</code>接受一个配置并返回<strong class="je ig">类型</strong>和<strong class="je ig">创建者。</strong></li><li id="3760" class="ll lm if je b jf ly jj lz jn ma jr mb jv mc jz lq lr ls lt dt translated">您可以导入<strong class="je ig">类型</strong>并配合<code class="eh lu lv lw lx b">createReducers</code>使用。</li><li id="fc96" class="ll lm if je b jf ly jj lz jn ma jr mb jv mc jz lq lr ls lt dt translated"><code class="eh lu lv lw lx b">createReducers</code>让你把你的减压器变成小搬运器。</li><li id="2fe1" class="ll lm if je b jf ly jj lz jn ma jr mb jv mc jz lq lr ls lt dt translated">您可以在您的组件内部或任何您需要分派动作的地方导入并使用<strong class="je ig">创建器</strong>。</li></ul><h1 id="5943" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">有用的链接</h1><ul class=""><li id="0866" class="ll lm if je b jf kz jj la jn nh jr ni jv nj jz lq lr ls lt dt translated"><a class="ae lk" href="https://github.com/redux-arc/redux-arc-demo" rel="noopener ugc nofollow" target="_blank">在还原弧</a>中接触积垢。</li><li id="4cea" class="ll lm if je b jf ly jj lz jn ma jr mb jv mc jz lq lr ls lt dt translated">redux-arc.js.org。</li><li id="20a2" class="ll lm if je b jf ly jj lz jn ma jr mb jv mc jz lq lr ls lt dt translated"><a class="ae lk" href="https://github.com/viniciusdacal/redux-arc" rel="noopener ugc nofollow" target="_blank"> Gitub库</a>。</li></ul><h1 id="a35a" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="9f58" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">除了减少样板文件并允许您优雅地拆分代码，<code class="eh lu lv lw lx b">createReducers</code>和<code class="eh lu lv lw lx b">createActions</code>都是关于通过编程实现的配置。这使我们能够运行验证来帮助您进行调试，也使您能够专注于真正计量的内容。</p><p id="b5c8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你不想仅仅因为犯了一个打字错误就花时间写样板文件或调试整个应用程序。</p><p id="485e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您希望尽可能更好、更快地实现功能和修复错误，而不失去灵活性，我们希望帮助您做到这一点！</p></div><div class="ab cl nk nl hc nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="hn ho hp hq hr"><p id="e88d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非常欢迎任何反馈和贡献。请随意在github 上打开一个问题来问我更多关于它的问题。</p><p id="25d5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你喜欢这本书吗？</p><p id="d722" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">️❤️通过给我们和sharing️️️️ ❤️一个赞来帮助我们传播信息</p><p id="5c29" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">🖖别忘了关注我，我会通知你未来的帖子！🖖</p></div></div>    
</body>
</html>