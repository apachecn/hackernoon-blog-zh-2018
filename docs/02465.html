<html>
<head>
<title>How I made a Service like S3 over the weekend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在周末像S3一样提供服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-made-a-service-like-s3-over-the-weekend-bfa83e224dc7?source=collection_archive---------10-----------------------#2018-03-19">https://medium.com/hackernoon/how-i-made-a-service-like-s3-over-the-weekend-bfa83e224dc7?source=collection_archive---------10-----------------------#2018-03-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1c3bd21c7a7bcced5e6a17dfb6cd258f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3roywYB7DFnIn29KPhxrg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://www.pixelstalk.net/sky-wallpapers-hd/" rel="noopener ugc nofollow" target="_blank"><em class="jh">Picture</em><strong class="bd ji"><em class="jh"> </em></strong><em class="jh">Credit</em></a></figcaption></figure><p id="9a74" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt kh translated">首先，我说2018年是我人生中最糟糕的一年。到目前为止，我已经因为加密损失了一半的积蓄，毁了一笔非常昂贵的<a class="ae jg" href="https://www.youtube.com/watch?v=5KLYz0pApq0" rel="noopener ugc nofollow" target="_blank">股份</a>，而且根本没有尝试过任何新东西。这种创造力的丧失让我开始思考- <em class="kq">我需要休息。不是为了和我的老朋友叙旧，而是把我在网上的工作放在一边一个星期，重新和我有创造力的一面联系起来。</em></p><p id="838f" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我和我的联合创始人拉胡尔谈了这件事，以及它对我的重要性。我有点像一个懒惰的员工，要求他的队友为他们打掩护。他不仅同意了，还建议了一些我可能会感兴趣的东西。他知道伊利诺伊大学正在进行一个关于云计算的远程学位项目，这让我印象深刻，这是我第二喜欢的话题，仅次于人工智能，它与我的工作完全吻合。我知道对我来说这比神经网络容易得多，谁知道我什么时候有机会为一个真正的项目训练一个模型。我毫不犹豫地报名参加了这个课程。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="dfaa" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">就这样开始了，这就像是大学时代的重演..分配..演讲..和测试。在其中一项作业中，教授告诉同学们对Globus和Openstack进行比较。这两个都是实现您自己的虚拟化云计算平台的很好的解决方案，对于这篇文章，我将谈论我如何使用openstack实现对象存储，但是我鼓励您查看<a class="ae jg" href="http://toolkit.globus.org" rel="noopener ugc nofollow" target="_blank"> Globus </a>，因为它也很棒。</p><blockquote class="ky kz la"><p id="00a3" class="jj jk kq jl b jm jn jo jp jq jr js jt lb jv jw jx lc jz ka kb ld kd ke kf kg hn dt translated">OpenStack软件控制整个数据中心的大型计算、存储和网络资源池，通过仪表板或OpenStack API进行管理。OpenStack与流行的企业和开源技术配合使用，是异构基础设施的理想选择。</p></blockquote><h1 id="6b2d" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">服务架构</h1><p id="1a65" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">在浏览了Openstack的<a class="ae jg" href="https://www.openstack.org/software/" rel="noopener ugc nofollow" target="_blank">服务列表</a>后，我决定创建一个分布式对象存储，它可以像AWS S3一样在不同的容器中存储blobs，但这是openstack提供的众多服务之一，这些服务由一个中心节点控制，该节点也有助于与这些服务或我们的对象存储进行通信。</p><p id="1a0e" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这个分布式云中的每个节点都需要一个专用的机器，你可以使用虚拟化软件剥离它，或者像我一样，通过使用<a class="ae jg" href="https://www.vultr.com/" rel="noopener ugc nofollow" target="_blank"> Vultr </a>创建真实的实例，基本上是任何运行全新安装的<a class="ae jg" href="https://hackernoon.com/tagged/ubuntu" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>的机器(本文至少有3个)。</p><p id="a980" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">下图是一个示例配置，显示了云网络中的各种节点，但我的实现更短，这让我对如何安排一切有了一个基本的想法。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/c9faba19cf01f5becd587583b22c9106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vo6k6DdnHPK5hnltpRigFA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://docs.openstack.org/ocata/install-guide-ubuntu/_images/hwreqs.png" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="4fb8" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">首先，我从创建一个控制器节点开始，因为它对于控制和同步我们设置中的所有其他节点是必不可少的。</p><blockquote class="mm"><p id="43ac" class="mn mo hu bd mp mq mr ms mt mu mv kg ek translated">控制器节点运行身份服务、影像服务、计算管理部分、网络管理部分、各种网络代理和控制面板。它还包括支持服务，如SQL数据库、消息队列和NTP。</p></blockquote><p id="39e7" class="pw-post-body-paragraph jj jk hu jl b jm mw jo jp jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg hn dt translated">我分别为我的云、计算和对象存储启动了一个运行Ubuntu 16.04的新实例，总共3个，接下来确认你的机器可以访问网络，输入…</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="6953" class="ng lf hu nc b fv nh ni l nj nk"># ping -c 4 amankhalid.com</span></pre><p id="1584" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">您应该在终端中看到以下输出。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/308e76bc93bb06ecedf83ddb47a4edb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*zU4ybGa6UlQSgzdDhRO-Lw.png"/></div></figure><p id="9189" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">请记下这3个节点的IP地址，因为它们将用于配置。在每个实例中，我将文件<strong class="jl hv"> /etc/hosts编辑为</strong>，使其具有以下值。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="1776" class="ng lf hu nc b fv nh ni l nj nk"># controller<br/>XXX.XX.XX.X       controller<br/><br/># compute1<br/>XXX.XX.XX.X       compute1<br/><br/># object1<br/>XXX.XX.XX.X       object</span></pre><p id="28fa" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我分别用我的控制器、计算和对象节点的IP地址替换了<code class="eh nm nn no nc b"><strong class="jl hv">XXX.XX.XX.X</strong></code>。在对我的所有节点进行更改之后，我按如下方式检查了连接性。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="6f59" class="ng lf hu nc b fv nh ni l nj nk"># ping -c 4 controller</span></pre><p id="a456" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">为了验证连通性，我通过我的每个实例ping另外两个节点，当我ping<a class="ae jg" href="http://amankhalid.com" rel="noopener ugc nofollow" target="_blank">amankhalid.com</a>时，它们返回了类似的输出。现在是时候同步我的节点了。</p><h1 id="c048" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">同步节点</h1><p id="9e9d" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">正如我的教授所说，在分布式环境中通信时，同步是一个重要的问题。在开放式堆栈中，每个节点都将其时钟与控制器节点同步。为了在我的设置中定义网络时间协议(<a class="ae jg" href="https://en.wikipedia.org/wiki/Network_Time_Protocol" rel="noopener ugc nofollow" target="_blank"> NTP </a>)，我首先在我的控制器节点上安装了Chrony。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="77af" class="ng lf hu nc b fv nh ni l nj nk"># sudo apt-get install chrony</span></pre><p id="65f8" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">完成后，我必须确保其他节点与我的控制器同步。我在每个节点上安装了chrony，并在它们的<strong class="jl hv">/etc/chrony/chrony . conf</strong>文件中添加了下面一行。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="9227" class="ng lf hu nc b fv nh ni l nj nk">server controller iburst</span></pre><p id="1626" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">之后，我重启了每个节点中的chrony服务，一切都设置好了，为了进一步验证我的节点是否引用了控制器，我运行了以下命令。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="f645" class="ng lf hu nc b fv nh ni l nj nk"># chronyc sources</span></pre><p id="d97b" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这个命令打印出源的名称或ip地址，在我的例子中是控制器。</p><h1 id="9555" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">安装Openstack</h1><p id="8e8d" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">现在，经过所有的挣扎，我的节点已经准备好真正的交易。我离实现自己的云存储又近了一步。但是首先我必须在我的每台机器上安装Openstack仓库。我运行了以下命令来准备好节点。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="96dd" class="ng lf hu nc b fv nh ni l nj nk"># sudo apt-get install software-properties-common<br/># add-apt-repository cloud-archive:queens</span><span id="4b2c" class="ng lf hu nc b fv np ni l nj nk"># sudo apt-get install software-properties-common<br/># add-apt-repository cloud-archive:pike</span></pre><p id="3903" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">最后，更新您的本地存储库列表，并在您的每台机器上安装openstack python客户端。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="dc04" class="ng lf hu nc b fv nh ni l nj nk"># sudo apt-get update &amp;&amp; apt dist-upgrade<br/># sudo apt-get install python-openstackclient</span></pre><h2 id="4859" class="ng lf hu bd lg nq nr ns lk nt nu nv lo ju nw nx ls jy ny nz lw kc oa ob ma oc dt translated">数据库供应</h2><p id="13b4" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">现在是时候初始化Openstack的数据存储了，它用于内部目的。我们将使用MySQL数据库，尽管Openstack也支持其他数据存储，但我决定坚持使用好的ol' MySQL。我们只需要在控制器节点上安装它，通过<a class="ae jg" href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">这个</a>指南了解基本安装步骤，我们现在只需要根用户，确保你的密码符合MySQL安全安装。</p><h2 id="d8e9" class="ng lf hu bd lg nq nr ns lk nt nu nv lo ju nw nx ls jy ny nz lw kc oa ob ma oc dt translated">信息排队</h2><p id="c2c6" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">为了在服务之间交换状态信息和协调操作，Openstack使用消息队列。这个任务我选择了rabbitMQ。</p><p id="f34b" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">RabbitMQ只在控制器节点上需要，我使用下面的命令安装了它。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="7f6d" class="ng lf hu nc b fv nh ni l nj nk"># apt install rabbitmq-server</span></pre><p id="2b6d" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">添加<code class="eh nm nn no nc b"><strong class="jl hv">openstack</strong></code>用户，最后，允许<code class="eh nm nn no nc b"><strong class="jl hv">openstack</strong></code>用户的配置、写和读访问:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="614e" class="ng lf hu nc b fv nh ni l nj nk"># rabbitmqctl add_user openstack AMNOX_PASSWORD</span><span id="f4f5" class="ng lf hu nc b fv np ni l nj nk"># rabbitmqctl set_permissions openstack “.*” “.*” “.*” Setting permissions for user “openstack” in vhost “/” …</span></pre><p id="3f80" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">用合适的密码替换<code class="eh nm nn no nc b"><strong class="jl hv">AMNOX_PASSWORD</strong></code>。</p><h2 id="8a4a" class="ng lf hu bd lg nq nr ns lk nt nu nv lo ju nw nx ls jy ny nz lw kc oa ob ma oc dt translated">Memcached</h2><p id="7058" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">Openstack中使用缓存服务来缓存用户使用以下命令安装memcached时生成的令牌:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="192c" class="ng lf hu nc b fv nh ni l nj nk"># apt install memcached python-memcache</span></pre><p id="4791" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">因为有一个工具可以创建不同的用户和角色，并为他们分配服务，所以用户需要使用令牌进行身份验证，才能访问分配给他们的服务。</p><h1 id="8c85" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">最终前沿:对象存储</h1><p id="e212" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">我已经有了对象存储节点和完整的网络连接，现在是时候让控制器启用对象存储服务了。为此，我在我的控制器节点上创建了一个服务和一个有权访问它的用户。</p><h2 id="df59" class="ng lf hu bd lg nq nr ns lk nt nu nv lo ju nw nx ls jy ny nz lw kc oa ob ma oc dt translated">控制器节点设置</h2><p id="5b10" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">首先，需要在将传入请求路由到对象存储节点的控制器节点上释放一个代理服务。我首先在我的控制器节点上创建一个用户。我进一步给了这个用户admin特权，使其能够访问我将在下一步中创建的服务。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="7628" class="ng lf hu nc b fv nh ni l nj nk"># openstack user create --domain default --password-prompt swift</span><span id="f14a" class="ng lf hu nc b fv np ni l nj nk"># openstack role add --project service --user swift admin</span></pre><p id="75d3" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">接下来创建对象存储服务。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="bbec" class="ng lf hu nc b fv nh ni l nj nk">$ openstack service create --name swift \<br/>  --description "OpenStack Object Storage" object-store</span></pre><p id="b74d" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">接下来，我配置了服务端点并安装了额外的包，使代理能够转发传入的请求。额外的包可以在<a class="ae jg" href="https://docs.openstack.org/project-install-guide/object-storage/ocata/controller-install-ubuntu.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="4a04" class="ng lf hu bd lg nq nr ns lk nt nu nv lo ju nw nx ls jy ny nz lw kc oa ob ma oc dt translated">存储节点设置</h2><p id="d55d" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">现在是设置存储节点的时候了，使用Openstack有可能拥有许多这样的存储节点。这个概念可以通过使用水平可伸缩性来进一步扩展，顺便说一下，这是现实生活服务中的规范。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="970f" class="ng lf hu nc b fv nh ni l nj nk"># sudo apt-get install xfsprogs rsync</span></pre><p id="a7b8" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们的存储节点将使用<a class="ae jg" href="http://searchstorage.techtarget.com/definition/XFS-file-system" rel="noopener ugc nofollow" target="_blank"> XFS </a>文件系统，运行这些命令来格式化存储位置。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="9d04" class="ng lf hu nc b fv nh ni l nj nk"># mkfs.xfs /dev/sdb<br/># mkfs.xfs /dev/sdc</span></pre><p id="80d1" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">创建挂载点目录结构:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="c5a7" class="ng lf hu nc b fv nh ni l nj nk"># mkdir -p /srv/node/sdb # mkdir -p /srv/node/sdc</span></pre><p id="c1b4" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">编辑<code class="eh nm nn no nc b">/etc/fstab</code>文件并添加以下内容:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="516a" class="ng lf hu nc b fv nh ni l nj nk">/dev/sdb /srv/node/sdb xfs noatime,nodiratime,nobarrier,logbufs=8 0 2 <br/>/dev/sdc /srv/node/sdc xfs noatime,nodiratime,nobarrier,logbufs=8 0 2</span></pre><p id="3213" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">安装设备:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="019b" class="ng lf hu nc b fv nh ni l nj nk"># mount /srv/node/sdb # mount /srv/node/sdc</span></pre><p id="210d" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">创建或编辑<code class="eh nm nn no nc b">/etc/rsyncd.conf</code>文件，以包含以下内容:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="7f92" class="ng lf hu nc b fv nh ni l nj nk">uid = swift<br/>gid = swift<br/>log file = /var/log/rsyncd.log<br/>pid file = /var/run/rsyncd.pid<br/>address = controller<br/><br/>[account]<br/>max connections = 2<br/>path = /srv/node/<br/>read only = False<br/>lock file = /var/lock/account.lock<br/><br/>[container]<br/>max connections = 2<br/>path = /srv/node/<br/>read only = False<br/>lock file = /var/lock/container.lock<br/><br/>[object]<br/>max connections = 2<br/>path = /srv/node/<br/>read only = False<br/>lock file = /var/lock/object.lock</span></pre><p id="370b" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">编辑<code class="eh nm nn no nc b">/etc/default/rsync</code>文件并启用<code class="eh nm nn no nc b">rsync</code>服务:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="61d3" class="ng lf hu nc b fv nh ni l nj nk">RSYNC_ENABLE=true</span></pre><p id="4ff8" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">启动<code class="eh nm nn no nc b">rsync</code>服务:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="41d6" class="ng lf hu nc b fv nh ni l nj nk"># sudo service rsync start</span></pre><p id="05fa" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">现在存储节点已经准备好安装必要的服务，我在启用rsync并指定存储格式后安装的包在这里<a class="ae jg" href="https://docs.openstack.org/project-install-guide/object-storage/ocata/storage-install-ubuntu-debian.html" rel="noopener ugc nofollow" target="_blank">列出</a>。</p><h1 id="3785" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">戒指:的确非常珍贵</h1><p id="3e0f" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">数据驻留在Openstack中的环，这可以是任何数据，比如帐户、容器或对象相关的数据。对于我的用例，我需要所有这三个，因为我有一个被授权使用存储服务的帐户，通过它我将创建一个容器，它将依次存储我希望它存储的对象。</p><p id="fe6f" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">环主要管理数据的存储方式，并控制数据在设置中的复制次数(默认情况下为三次)。当您的集群在地理上分布时，比如说跨大洲分布时，这个概念更有用。但是这个迷你装置需要它来确定我们物体的位置。</p><blockquote class="ky kz la"><p id="bf4e" class="jj jk kq jl b jm jn jo jp jq jr js jt lb jv jw jx lc jz ka kb ld kd ke kf kg hn dt translated">I <!-- -->在<strong class="jl hv">控制器</strong>节点上为账户、容器和对象创建了如下的环。</p></blockquote><p id="e152" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl hv">创建账户环</strong></p><p id="7f1e" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">转到<code class="eh nm nn no nc b">/etc/swift</code>目录。创建基础<code class="eh nm nn no nc b">account.builder</code>文件:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="1ed0" class="ng lf hu nc b fv nh ni l nj nk"># swift-ring-builder account.builder create 10 3 1</span></pre><p id="90d0" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">将我们的存储节点添加到环中:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="b22f" class="ng lf hu nc b fv nh ni l nj nk"># swift-ring-builder container.builder \<br/>  add --region 1 --zone 1 --ip object1 --port 6201 \<br/>  --device sdb --weight 100</span></pre><p id="f7e5" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl hv">创建容器环</strong></p><p id="5983" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">切换到<code class="eh nm nn no nc b">/etc/swift</code>目录。初始化<code class="eh nm nn no nc b">container.builder</code>文件:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="af32" class="ng lf hu nc b fv nh ni l nj nk"># swift-ring-builder container.builder create 10 3 1</span></pre><p id="6eb6" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">接下来，我将存储节点添加到环中:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="e4a3" class="ng lf hu nc b fv nh ni l nj nk"># swift-ring-builder object.builder add \<br/>  --region 1 --zone 1 --ip object1 --port 6200 --device sdb --weight 100</span></pre><p id="47a3" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl hv">创建对象环</strong></p><p id="f84c" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">对象服务器使用对象环来维护本地设备上的对象位置列表。</p><p id="db73" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">转到<code class="eh nm nn no nc b">/etc/swift</code>目录。创建基础<code class="eh nm nn no nc b">object.builder</code>文件:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="06e1" class="ng lf hu nc b fv nh ni l nj nk"># swift-ring-builder object.builder create 10 3 1</span></pre><p id="5021" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">将存储节点添加到环中</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="9d23" class="ng lf hu nc b fv nh ni l nj nk"># swift-ring-builder object.builder add \ — region 1 — zone 1 — ip object1 — port 6200 — device sdb — weight 100</span></pre><h1 id="4a62" class="le lf hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">它还活着！</h1><p id="a628" class="pw-post-body-paragraph jj jk hu jl b jm mc jo jp jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg hn dt translated">从对象存储源库中获取<code class="eh nm nn no nc b">/etc/swift/swift.conf</code>文件:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="0fb6" class="ng lf hu nc b fv nh ni l nj nk"># curl -o /etc/swift/swift.conf \ <a class="ae jg" href="https://git.openstack.org/cgit/openstack/swift/plain/etc/swift.conf-sample?h=stable/newton" rel="noopener ugc nofollow" target="_blank">https://git.openstack.org/cgit/openstack/swift/plain/etc/swift.conf-sample?h=stable/newton</a></span></pre><p id="2bbb" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">编辑<code class="eh nm nn no nc b">/etc/swift/swift.conf</code>文件，并在<code class="eh nm nn no nc b">[swift-hash]</code>部分为您的环境配置散列路径前缀和后缀。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="1a19" class="ng lf hu nc b fv nh ni l nj nk">[swift-hash] … swift_hash_path_suffix = MY_SECRET_SUFFIX swift_hash_path_prefix = MY_SECRET_PREFIX</span></pre><p id="0a1a" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">在<code class="eh nm nn no nc b">[storage-policy:0]</code>部分，配置默认存储策略:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="5b4a" class="ng lf hu nc b fv nh ni l nj nk">[storage-policy:0] … name = Policy-0 default = yes</span></pre><p id="4b41" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">将<code class="eh nm nn no nc b">swift.conf</code>文件复制到存储节点的<code class="eh nm nn no nc b">/etc/swift</code>目录，确保您拥有对象存储节点上配置目录的所有权。最后，在对象存储节点上启动服务器。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="d853" class="ng lf hu nc b fv nh ni l nj nk"># chown -R root:swift /etc/swift</span><span id="90cf" class="ng lf hu nc b fv np ni l nj nk"># swift-init all start</span></pre><p id="e2b0" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl hv">在容器中存储文件</strong></p><p id="173a" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">登录到您的控制器节点和<code class="eh nm nn no nc b"><strong class="jl hv">echo</strong></code>环境中的授权凭证。</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="2ebb" class="ng lf hu nc b fv nh ni l nj nk">export OS_USERNAME=admin<br/>export OS_PASSWORD=9qZjkwmKUrkFn2dv<br/>export OS_PROJECT_NAME=admin<br/>export OS_USER_DOMAIN_NAME=Default<br/>export OS_PROJECT_DOMAIN_NAME=Default<br/>export OS_AUTH_URL=<a class="ae jg" href="http://controller:35357/v3" rel="noopener ugc nofollow" target="_blank">http://controller:35357/v3</a><br/>export OS_IDENTITY_API_VERSION=3</span></pre><p id="f1b0" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">创建<code class="eh nm nn no nc b">container1</code>容器:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="cd49" class="ng lf hu nc b fv nh ni l nj nk"># openstack container create container1</span></pre><p id="01c2" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">上传一个测试文件到<code class="eh nm nn no nc b">container1</code>容器:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="c140" class="ng lf hu nc b fv nh ni l nj nk"># openstack object create container1 FILE</span></pre><p id="19da" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">列出<code class="eh nm nn no nc b">container1</code>容器中的文件:</p><pre class="mi mj mk ml fq nb nc nd ne aw nf dt"><span id="deff" class="ng lf hu nc b fv nh ni l nj nk">$ openstack object list container1</span></pre><p id="dd3c" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">您应该会看到新创建的文件。您还可以通过我们之前创建的API端点与您的服务进行通信。您可以为openstack用户创建许多这样容器，并在其中存储blobs。请记住，这是一个非常CPU密集型的任务，您可能需要一个更好的实例。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="b844" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">对象存储只是Openstack的一个用例，还可以使用<a class="ae jg" href="https://www.openstack.org/software/releases/ocata/components/nova" rel="noopener ugc nofollow" target="_blank"> NOVA </a>服务创建自己的虚拟化实例。我也鼓励你去看看Openstack API，以获得更强大的功能。</p><p id="95d9" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我希望通过提高我的技术来结束今年年初以来困扰我的厄运。写这篇文章不仅帮助我加深了对云计算的理解，也让我意识到为这个帮助我成长了这么多年的社区做出了一些贡献。</p><blockquote class="mm"><p id="6ed5" class="mn mo hu bd mp mq mr ms mt mu mv kg ek translated">感谢您阅读这篇文章，我非常感谢您对我的实现技术的任何建议或改进。</p></blockquote><p id="96e6" class="pw-post-body-paragraph jj jk hu jl b jm mw jo jp jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg hn dt translated">您可以通过<a class="ae jg" href="mailto:mailamankhalid@gmail.com" rel="noopener ugc nofollow" target="_blank">邮件</a>联系我，询问关于本文的任何问题，或者只是进行一次愉快的交谈:)</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="od oe l"/></div></figure></div></div>    
</body>
</html>