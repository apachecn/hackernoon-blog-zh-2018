<html>
<head>
<title>[PoC] Partially random passwords</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[PoC]部分随机密码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/poc-partially-random-passwords-6e1ed080ada6?source=collection_archive---------31-----------------------#2018-03-19">https://medium.com/hackernoon/poc-partially-random-passwords-6e1ed080ada6?source=collection_archive---------31-----------------------#2018-03-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="27e1" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">或者如何保护用户的密码不被部分随机密码的键盘记录器窃取</h1><p id="286e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当我们登录到一些在线帐户时，尤其是在公共计算机上，或者在我们不拥有的任何计算机上，我们都面临的一个问题是，我们的密码总是有被盗的风险，尤其是使用键盘记录器。如果黑客得到了你密码的“副本”，她就可以登录你的账户，为所欲为。</p><p id="e00a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">与往常一样，使用双因素认证可以缓解这个问题，因为黑客也需要访问您的手机。但是，如果使用2FA不是一个选项，即使在这种情况下，我们也想保护用户，那么当黑客试图登录时，我们能否检测到不是真正的用户，而是试图登录的人窃取了她的密码？</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/47c29beb34e4f1b0e7f174cc51552681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*y8JUuKW9QXkFh9Qw."/></div></figure><h1 id="ebc3" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">部分随机密码</h1><p id="4a0c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这个问题的一个解决方案是使用部分随机密码，其中随机部分每次都不相同。我的意思是这样的:<br/>假设我的密码是123456789，但当我尝试登录时，我不会直接使用这个密码，而是会在开头或结尾(甚至在中间)添加一些随机字符串，就像这样:<br/> <strong class="jr hv"> 564564 </strong> 123456789</p><p id="f287" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">当我们收到这个密码(让我们称之为“原始密码”)时，我们将去掉随机部分，并将剩余部分用作密码，并将这个原始密码的散列版本保存在used_passwords表中。下次同一个用户试图登录时，我们会检查这个原始密码(真实密码+随机部分)以前是否被使用过，如果找到，我们会拒绝访问该帐户。<br/>代码将如下所示:</p><pre class="kt ku kv kw fq la lb lc ld aw le dt"><span id="98de" class="lf is hu lb b fv lg lh l li lj">public function postLogin(Request $request)<br/>    {<br/>        $data = $request-&gt;all();</span><span id="a07e" class="lf is hu lb b fv lk lh l li lj">        $email = $data['email'];<br/>        $rawPassword = $data['password'];<br/>        $user = User::where('email', $email)-&gt;first();</span><span id="d767" class="lf is hu lb b fv lk lh l li lj">        $password = $this-&gt;getRealPassword($rawPassword, $user);</span><span id="ad36" class="lf is hu lb b fv lk lh l li lj">        if (Auth::attempt(['email' =&gt; $email, 'password' =&gt; $password])) {<br/>            if (! $this-&gt;usedBefore($user-&gt;id, $rawPassword)) {<br/>                $this-&gt;saveRawPassword($user-&gt;id, $rawPassword);<br/>                return redirect('/home');<br/>            } else {<br/>                Auth::logout();<br/>                return redirect()-&gt;route('login')-&gt;with('authentication-issue', true)-&gt;with('used-password', true);<br/>            }<br/>        } else {<br/>            return redirect()-&gt;route('login')-&gt;with('authentication-issue', true);<br/>        }<br/>    }</span></pre><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/097af42251a7c4afbb9294e2c2a4e416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*W1Qd2Pu3UEAZ9HRy."/></div></figure><h1 id="34a8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">如果黑客确切知道密码的哪一部分是随机的呢？</h1><p id="2d8b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是一个合理的担忧，如果我们的黑客知道某个实施部分随机密码技术的特定网站每次都会删除前6个字符，她也会这样做并登录受害者的帐户。</p><p id="7ffd" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这个问题的解决方案是允许用户自己选择随机部分的长度及其在密码中的位置，并且每次我们试图验证某个用户时，我们将使用她自己的“规则”(即随机部分的位置和长度因用户而异)。</p><p id="aa71" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我们甚至可以在同一个密码中添加多个随机部分，这使得从任何捕获的密码中提取真实密码变得更加困难。</p><p id="176c" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我们甚至可以将部分随机密码的概念与我在上一篇文章中描述的基于密码的角色和动作的概念结合起来，如果密码被第二次使用，通过触发一些特定的动作来为帐户增加另一层安全性。</p><p id="e7cf" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">您可以在此处找到该概念的回购(演示):</p><div class="lm ln fm fo lo lp"><a href="https://github.com/djug/partially-random-passwords" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab ej"><div class="lr ab ls cl cj lt"><h2 class="bd hv fv z el lu eo ep lv er et ht dt translated">调整/部分随机密码</h2><div class="lw l"><h3 class="bd b fv z el lu eo ep lv er et ek translated">PoC]部分随机密码:或如何保护用户密码免受部分随机密码的键盘记录器的攻击…</h3></div><div class="lx l"><p class="bd b gc z el lu eo ep lv er et ek translated">github.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md ky lp"/></div></div></a></div><figure class="kt ku kv kw fq kx fe ff paragraph-image"><a href="https://goo.gl/RDUt4v"><div class="fe ff fg"><img src="../Images/52bf9e84126f483254abfde8427668f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fh3jPIRkLQOFi35thK-fkQ.png"/></div></a></figure></div></div>    
</body>
</html>