<html>
<head>
<title>Sending Texts with Twilio + Haskell!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Twilio + Haskell发短信！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sending-texts-with-twilio-haskell-24960b0ffd05?source=collection_archive---------34-----------------------#2018-03-19">https://medium.com/hackernoon/sending-texts-with-twilio-haskell-24960b0ffd05?source=collection_archive---------34-----------------------#2018-03-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/99b12bc6d5d16fcd22d958f6b5c7a4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*jB5lliJYNht2vjOXFO1TdQ.jpeg"/></div></figure><p id="1164" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">只使用简单的库编写我们自己的Haskell代码很有趣。但是我们不能一切从零开始。有各种各样的酷服务可以使用，所以我们不需要这么做。通过使用API，我们可以与其中的许多接口。通常，最受支持的API使用像Python和Javascript这样的语言。但是富有冒险精神的Haskell开发人员也为这些系统开发了绑定！所以在接下来的几周里，我们将探索其中的一些。我们还将看看当没有现成的库可供我们使用时，我们能做些什么。</p><p id="6f06" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">本周，我们将关注Twilio API。我们将看到如何使用<a class="ae jw" href="https://hackage.haskell.org/package/twilio" rel="noopener ugc nofollow" target="_blank"> twilio </a>库从我们的Haskell代码中发送SMS消息。我们还将编写一个简单的服务器来使用Twilio的回调系统接收文本消息并以编程方式处理它们。您可以在这个系列的<a class="ae jw" href="https://james-bowen-c4sg.squarespace.com/blog/2018/3/19/TODO" rel="noopener ugc nofollow" target="_blank"> Github库</a>上跟随代码。</p><p id="5645" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当然，如果您以前从未编写过任何Haskell，这些都没有用！如果你想从语言基础开始，下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>。要了解更多关于高级技术和库的信息，请访问我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！</p><h1 id="1f72" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置我们的帐户</h1><p id="29e4" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">自然，您需要一个Twilio帐户来使用Twilio API。设置好之后，您需要添加您的第一个Twilio号码。这将是您要发送短信的号码。您还会将其视为系统中其他邮件的发件人。您还应该经历验证您自己的电话号码的过程。这将允许您在手机上发送和接收信息，而无需“发布”您的应用程序。</p><p id="38e8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您还需要您的帐户中的一些其他信息。有帐户SID和身份验证令牌。您可以在Twilio页面的项目仪表板上找到这些信息。您的代码中需要这些值。但是由于您不想将它们置于版本控制之下，您应该将它们作为环境变量保存在您的机器上。然后当你需要的时候，你可以像这样获取它们:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="d28a" class="lj jy hu lf b fv lk ll l lm ln">fetchSid :: IO String<br/>fetchSid = getEnv “TWILIO_ACCOUT_SID”</span><span id="aa18" class="lj jy hu lf b fv lo ll l lm ln">fetchToken :: IO String<br/>fetchToken = getEnv “TWILIO_AUTH_TOKEN”</span></pre><h1 id="ebf3" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">发送消息</h1><p id="c817" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">我们要做的第一件事是使用API实际发送一条文本消息。我们在<code class="eh lp lq lr lf b">Twilio</code>单子内执行Twilio动作。从<code class="eh lp lq lr lf b">IO</code>访问这个单子非常简单。我们所需要的就是<code class="eh lp lq lr lf b">runTwilio’</code>函数:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="5705" class="lj jy hu lf b fv lk ll l lm ln">runTwilio’ :: IO String -&gt; IO String -&gt; Twilio a -&gt; IO a</span></pre><p id="725f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个函数的前两个参数是获取账户SID和认证令牌的<code class="eh lp lq lr lf b">IO</code>动作。我们已经写好了。那么最后一个参数当然就是我们的<code class="eh lp lq lr lf b">Twilio</code>动作了。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="b1ec" class="lj jy hu lf b fv lk ll l lm ln">sendMessage :: IO ()<br/>sendMessage = runTwilio’ fetchSid fetchToken $ do<br/>  ...</span></pre><p id="713a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了编写消息，我们将使用<code class="eh lp lq lr lf b">PostMessage</code>构造函数。这需要三个参数。首先，我们信息的“收件人”号码。把你的手机号码填进去。然后，第二个参数是“发件人”号码，这必须是我们的Twilio帐户的电话号码。第三个参数是消息本身。要发送消息，我们所要做的就是使用<code class="eh lp lq lr lf b">post</code>功能！这就是全部了！</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="f75a" class="lj jy hu lf b fv lk ll l lm ln">sendMessage :: IO ()<br/>sendMessage = runTwilio’ fetchSid fetchToken $ do<br/>  let msg = PostMessage “+15551231234” “+15559879876” “Hello Twilio!”<br/>  _ &lt;- post msg<br/>  return ()</span></pre><p id="97c6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">就这样，你发出了第一条Twilio消息！请注意，通过Twilio发送消息确实要花费少量的钱。但是一个试用帐户应该给你足够的免费信用来尝试一点。</p><h1 id="9880" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">接收消息</h1><p id="8daa" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">现在，处理传入的消息有点复杂。我们需要做的第一件事是在我们的Twilio帐户上创建一个webhook。为此，请从您的项目仪表板页面转到“管理数字”。然后选择您的Twilio号码。现在，您需要滚动到名为“消息”的部分，然后在其中找到“有消息进来”。您需要在下拉列表中选择“Webhook”。然后，您需要指定您的服务器所在的URL，并选择“HTTP Post”。为了建立一个快速的服务器，我使用Heroku结合这个<a class="ae jw" href="https://github.com/mfine/heroku-buildpack-stack" rel="noopener ugc nofollow" target="_blank">漂亮的构建包</a>与Stack一起工作。我将在以后的文章中对此进行更深入的探讨。但主要是要看到我们的终点是<code class="eh lp lq lr lf b">/api/sms</code>。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ls"><img src="../Images/3613ac48a225c8d7a2146031c6ceb28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yi-IT51ZFFi28KVjr-IprA.png"/></div></div></figure><p id="bcc8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有了这个webhook之后，每当用户发送我们的号码时，Twilio就会向端点发送一个post请求。该请求将包含消息和发送者的号码。因此，让我们使用Servant设置一个服务器来接收该请求。</p><p id="d154" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将首先指定一个简单的类型来编码我们将从Twilio收到的消息:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="83e0" class="lj jy hu lf b fv lk ll l lm ln">data IncomingMessage = IncomingMessage<br/>  { fromNumber :: Text<br/>  , body :: Text<br/>  }</span></pre><p id="d97f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Twilio将其post请求主体编码为<code class="eh lp lq lr lf b">FormURLEncoded</code>。为了让Servant对此进行反序列化，我们需要为我们的类型定义一个<code class="eh lp lq lr lf b">FromForm</code>类的实例。这个函数接受一个从键到值列表的散列映射。它将返回一个错误字符串或者我们想要的值。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="528e" class="lj jy hu lf b fv lk ll l lm ln">instance FromForm IncomingMessage where<br/>  fromForm :: Form -&gt; Either Text IncomingMessage<br/>  fromForm (From form) = ...</span></pre><p id="666b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以<code class="eh lp lq lr lf b">form</code>是一个散列图，我们想要查找消息的“发件人”号以及消息体。然后，只要我们为这些中的每一个找到至少一个结果，我们将返回消息。否则，我们返回一个错误。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="5173" class="lj jy hu lf b fv lk ll l lm ln">instance FromForm IncomingMessage where<br/>  fromForm :: Form -&gt; Either Text IncomingMessage<br/>  fromForm (From form) = case lookupResults of<br/>    Just ((fromNumber : _), (body : _)) -&gt; <br/>      Right $ IncomingMessage fromNumber body<br/>    Just _ -&gt; Left “Found the keys but no values”<br/>    Nothing -&gt; Left “Didn’t find keys”<br/>    where<br/>      lookupResults = do<br/>        fromNumber &lt;- HashMap.lookup “From” form<br/>        body &lt;- HashMap.lookup “Body” form<br/>        return (fromNumber, body)</span></pre><p id="c6bc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们有了这个实例，我们终于可以定义我们的API端点了！它只需要简单的路径组件和请求体。目前，我们实际上不会发布任何回应。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="dc52" class="lj jy hu lf b fv lk ll l lm ln">type TwilioServerAPI = "api" :&gt; "sms" :&gt; <br/>  ReqBody '[FormUrlEncoded] IncomingMessage :&gt; Post '[JSON] ()</span></pre><h1 id="01a2" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">编写我们的处理程序</h1><p id="0067" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">现在让我们为我们的端点写一个处理程序。首先，我们将编写一个自然转换，这样我们就可以在<code class="eh lp lq lr lf b">Twilio</code>单子中编写我们的处理程序。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="9635" class="lj jy hu lf b fv lk ll l lm ln">transformToHandler :: Twilio :~&gt; Handler<br/>transformToHandler = NT $ \action -&gt; <br/>  liftIO $ runTwilio' fetchSid fetchToken action</span></pre><p id="f3c6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们将编写一个简单的处理程序，将用户的消息回显给他们。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="a870" class="lj jy hu lf b fv lk ll l lm ln">twilioNum :: Text<br/>twilioNum “+15559879876”</span><span id="ae77" class="lj jy hu lf b fv lo ll l lm ln">smsHandler :: IncomingMessage -&gt; Twilio ()<br/>smsHandler msg = do<br/>  let newMessage = PostMessage (fromNumber msg) twilioNum (body msg)<br/>  _ &lt;- post newMessage<br/>  return ()</span></pre><p id="6ae3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们总结一下运行服务器的一些服务机制。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="7a66" class="lj jy hu lf b fv lk ll l lm ln">twilioAPI :: Proxy TwilioServerAPI<br/>twilioAPI = Proxy :: Proxy TwilioServerAPI</span><span id="5609" class="lj jy hu lf b fv lo ll l lm ln">twilioServer :: Server TwilioServerAPI<br/>twilioServer = enter transformToHandler smsHandler</span><span id="b52e" class="lj jy hu lf b fv lo ll l lm ln">runServer :: IO ()<br/>runServer = do<br/>  port &lt;- read &lt;$&gt; getEnv “PORT”<br/>  run port (serve twilioAPI twilioServer)</span></pre><p id="003e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，如果我们向我们的Twilio号码发送短信，我们将会看到相同的回复消息！</p><h1 id="b87d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="f217" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">在本文中，我们看到了如何使用几行简单的Haskell来发送和接收文本消息。使用Twilio工具本身需要付出相当大的努力，但是一旦你知道去哪里找，大部分工作就很容易了！下周回来，我们将探索如何使用<a class="ae jw" href="https://www.mailgun.com/" rel="noopener ugc nofollow" target="_blank"> Mailgun </a> API发送电子邮件。我们将看到如何将文本和电子邮件结合起来，实现一些非常酷的功能。</p><p id="5032" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让这些应用变得简单的一件重要的事情是知道使用正确的工具！我们在这一部分中使用的工具之一是服务web API库。要了解更多，一定要看看我们的<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell网络技能系列</a>。想了解更多关于网络库的想法，请下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">产品清单</a>。</p><p id="c3bf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你以前从未写过Haskell，希望我已经让你相信用这种语言做一些很酷的事情是可能的！下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>以获得陈述！</p></div></div>    
</body>
</html>