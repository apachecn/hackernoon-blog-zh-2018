<html>
<head>
<title>ReactAF: Always Fresh (or As F%!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactAF:永远新鲜(或作为F%！)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reactaf-always-fresh-or-as-f-d9f55aed596d?source=collection_archive---------3-----------------------#2018-03-20">https://medium.com/hackernoon/reactaf-always-fresh-or-as-f-d9f55aed596d?source=collection_archive---------3-----------------------#2018-03-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d99c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">ReactAF对React的作用就像Babel对JavaScript的作用一样</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/2a089bf0d71fae49a6f0ba2ef8de57b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YA0TgmRdOD7_X09xsnOqgg.png"/></div></div></figure><p id="2abf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">假设你是一名组件开发人员，你正在维护或者编写一个OSS React包。由于您不能控制应用程序本身，所以最好的做法是在您的<code class="eh kr ks kt ku b">package.json</code>中将<code class="eh kr ks kt ku b">react</code>指定为<code class="eh kr ks kt ku b">peerDependency</code>，类似这样的文件。</p><pre class="jk jl jm jn fq kv ku kw kx aw ky dt"><span id="4aa0" class="kz la hu ku b fv lb lc l ld le">"peerDependencies": {<br/>  "react": "&gt;=15.0.0"<br/>}</span></pre><p id="0f28" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这说明您的包依赖于<code class="eh kr ks kt ku b">react</code>版本15.0.0和更高版本，但是您期望为您提供依赖关系(这意味着应用程序必须在<strong class="jx hv">的</strong>依赖关系列表中包含<code class="eh kr ks kt ku b">react</code>)。使用<code class="eh kr ks kt ku b">peerDependencies</code>可以防止库构建中不必要的膨胀和混乱。</p><p id="4d1f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是想一想这个—</p><p id="9ea4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您的组件<strong class="jx hv">不知道消费应用程序指定了React的哪个版本，您的代码将在哪个版本上运行。从软件包的角度来看，你所能做的就是给出一个可接受的版本范围。您的代码必须能够处理任何版本的React。</strong></p><p id="15e6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所以…例如，如果您的软件包希望使用React 16.2.0中引入的React特性，如果应用程序使用React 15.4.0，您就不太走运了。</p><p id="3041" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如，如果您想使用React 16.3.0中引入的新上下文API，该怎么办？抱歉(好吧，除非你想强迫你的用户使用16.3.0)。新静态<code class="eh kr ks kt ku b">getDerivedStateFromProps</code>怎么样？同样的事情。</p><p id="f8f3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">作为一名开发人员，这有点让人左右为难。要么你用各种各样的<a class="ae lf" href="https://en.wikipedia.org/wiki/Feature_detection_(web_development)" rel="noopener ugc nofollow" target="_blank">特性检测</a>来填充你的代码，要么你编码到最小公分母。</p><p id="aa44" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果不管React运行的是什么版本，您都可以依赖于较新的React特性，这不是很好吗？</p><p id="2153" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Babel用<a class="ae lf" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> <a class="ae lf" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>语言做到了这一点。当你使用Babel传输文件时，你可以像浏览器支持ES2018一样编码，即使你的代码可能运行在2012年发布的IE10上。</p><p id="dfc4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">ReactAF就是这么做的。</p><h1 id="7a67" class="lg la hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">它是如何工作的？</h1><p id="fa1c" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">ReactAF对React的作用就像Babel对JavaScript的作用一样。它允许您使用旧版本React中没有的React特性进行编码。</p><p id="6395" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是它是如何工作的呢？ReactAF进口在内部反应。如果React的版本已经具有它所模拟的特性，则返回“真正的”React。如果没有，它<a class="ae lf" href="https://en.wikipedia.org/wiki/Polyfill_(programming)" rel="noopener ugc nofollow" target="_blank">polyfill</a>缺失的特性并公开一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Monkey_patch" rel="noopener ugc nofollow" target="_blank">猴子修补的</a>版本的React。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/b1ce8f07df09288b32247ea7fc11f7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/1*ljTFIMmjzU5_IxkLssllAA.gif"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">How does it work? It’s like magic.</figcaption></figure><h1 id="e872" class="lg la hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">应用程序接口</h1><p id="ba96" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">ReactAF在React的较低版本上提供/模拟以下React APIs。</p><h2 id="b2ce" class="kz la hu bd lh mh mi mj ll mk ml mm lp ke mn mo lr ki mp mq lt km mr ms lv mt dt translated"><code class="eh kr ks kt ku b">static getDerivedStateFromProps</code></h2><p id="b217" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">这是React 16.3.0-alpha中引入的关于类组件的静态方法。它旨在取代生命周期事件<code class="eh kr ks kt ku b">componentWillReceiveProps</code>，后者在17.0版中将被弃用。</p><p id="28db" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您运行的是v16.3.0或更高版本，您将使用本机实现。否则，此方法被聚合填充。</p><p id="7cab" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">关于<code class="eh kr ks kt ku b">getDerivedStateFromProps</code>的更多信息，请参见本文作者<a class="mu mv gr" href="https://medium.com/u/a5f578f5b81a?source=post_page-----d9f55aed596d--------------------------------" rel="noopener" target="_blank">巴托什·什切青斯基</a>。</p><h2 id="e0d1" class="kz la hu bd lh mh mi mj ll mk ml mm lp ke mn mo lr ki mp mq lt km mr ms lv mt dt translated">做出反应。碎片</h2><p id="509a" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated"><code class="eh kr ks kt ku b">Fragment</code>是在v16.2.0及更高版本的<code class="eh kr ks kt ku b">React</code>对象上公开的新组件。这是一种从<code class="eh kr ks kt ku b">render</code>返回多个元素而不需要包装虚拟<code class="eh kr ks kt ku b">div</code>元素的方式。</p><p id="3219" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">更多关于碎片的信息可以在<a class="ae lf" href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" rel="noopener ugc nofollow" target="_blank">官方React博客</a>上找到。</p><h2 id="068d" class="kz la hu bd lh mh mi mj ll mk ml mm lp ke mn mo lr ki mp mq lt km mr ms lv mt dt translated">做出反应。<strong class="ak">创造环境</strong></h2><p id="11a3" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated"><code class="eh kr ks kt ku b">createContext</code>是让许多人兴奋不已的新的上下文API。它也是在React 16.3.0-alpha中发布的。</p><p id="9939" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以在Kent C. Dodds 撰写的<a class="ae lf" rel="noopener" href="/dailyjs/reacts-️-new-context-api-70c9fe01596b">这篇文章</a>中了解更多关于新的上下文API的信息。</p><h1 id="b31f" class="lg la hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">还有更多…</h1><p id="06c6" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">其实没有…就这些。</p><p id="7af1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是随着React发布新特性，ReactAF将被更新以通过polyfill支持它们，如果可能的话(欢迎PRs😉).这样，无论消费应用程序使用的是哪个版本，您都可以在包中使用最新的React APIs进行编码。</p><h1 id="c510" class="lg la hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">更改您的代码</h1><p id="5579" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">最棒的是。要开始使用ReactAF，你需要做的就是添加3个小字符:<code class="eh kr ks kt ku b">-af</code>。</p><p id="361e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">而不是这个。</p><pre class="jk jl jm jn fq kv ku kw kx aw ky dt"><span id="25cd" class="kz la hu ku b fv lb lc l ld le">import React from 'react';</span></pre><p id="8451" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你会这么做。</p><pre class="jk jl jm jn fq kv ku kw kx aw ky dt"><span id="2349" class="kz la hu ku b fv lb lc l ld le">import React from 'react<strong class="ku hv">-af</strong>';</span></pre><h1 id="4138" class="lg la hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">你从哪里得到它？</h1><p id="753b" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">ReactAF在npm 上<a class="ae lf" href="https://www.npmjs.com/package/react-af" rel="noopener ugc nofollow" target="_blank">可用(当然)。你可以在GitHub上看到源代码和/或投稿。我希望你能帮助ReactAF做得更好！</a></p><p id="616d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你觉得慷慨，⭐️会很受欢迎。🙏</p><div class="mw mx fm fo my mz"><a href="https://github.com/donavon/react-af" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">多纳文/react-af</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">react-af -允许你使用某些React.next特性来编码！非常适合组件库维护者。</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jt mz"/></div></div></a></div><h1 id="2c72" class="lg la hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">结论</h1><p id="0f71" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">虽然ReactAF可能不适合所有人，但它确实可以让OSS包开发者受益，让他们可以自由地使用现代React APIs进行编码。我会说让这个包反应为F%!</p><p id="02b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">请…原谅这篇帖子的任何信息式的品质。\_(ツ)_/</p></div><div class="ab cl no np hc nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="hn ho hp hq hr"><p id="4194" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="nv">我也为美国运通工程博客写稿。在</em><a class="ae lf" href="http://americanexpress.io/" rel="noopener ugc nofollow" target="_blank"><em class="nv">American express . io</em></a><em class="nv">查看我的其他作品和我才华横溢的同事的作品。也可以</em> <a class="ae lf" href="https://twitter.com/donavon" rel="noopener ugc nofollow" target="_blank"> <em class="nv">在Twitter上关注我</em> </a> <em class="nv">。</em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nw nx l"/></div></figure></div></div>    
</body>
</html>