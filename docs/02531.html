<html>
<head>
<title>Securing a React Native App with Server-side Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过服务器端身份验证保护React本机应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/securing-a-react-native-app-with-server-side-authentication-d5e8dbbc08e3?source=collection_archive---------2-----------------------#2018-03-21">https://medium.com/hackernoon/securing-a-react-native-app-with-server-side-authentication-d5e8dbbc08e3?source=collection_archive---------2-----------------------#2018-03-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/dc27d280cd8b12a775b106d59b10f271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hs3HAKYqoUpPzomTkA0-w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The key components in this story: NodeJS, ReactiveSearch, React Native and Auth0</figcaption></figure><p id="40cd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">构建应用程序时，身份验证是一个重要的考虑因素。我们在构建应用时遇到的一个常见用例是<strong class="ji hv">保护我们的</strong> <a class="ae ke" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv"> API </strong> </a>，以便只接受经过身份验证的请求，从而防止误用。</p><p id="40b7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这个故事中，我将使用一个用React Native 构建的<a class="ae ke" href="https://medium.freecodecamp.org/how-to-build-a-real-time-todo-app-with-react-native-19a1ce15b0b3" rel="noopener ugc nofollow" target="_blank"> Todos应用程序，并解释如何创建一个安全的Node/Express API来处理应用程序的<strong class="ji hv">C</strong>create、<strong class="ji hv"> U </strong> pdate和<strong class="ji hv">D</strong>delete操作。这将使应用程序只允许经过身份验证的用户编辑数据。对于这篇文章，我们假设:</a></p><ol class=""><li id="6262" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated">所有用户对todos都有<strong class="ji hv">读</strong>权限。</li><li id="ba4a" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">只有通过验证的用户才有写权限<strong class="ji hv">创建</strong>、<strong class="ji hv">更新</strong>和<strong class="ji hv">删除</strong>待办事项。为简洁起见，我们将考虑所有经过身份验证的用户都具有写访问权限。</li></ol><p id="18ec" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我将在应用程序中使用的关键组件是:</p><ol class=""><li id="cfa6" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated"><a class="ae ke" href="https://github.com/appbaseio/reactivesearch" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">React search Native</strong></a><strong class="ji hv">，</strong>React Native的数据驱动UI组件库，</li><li id="e503" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><strong class="ji hv"> NodeJS/Express，</strong>作为中间件服务器，对请求进行认证，对数据库进行写操作，</li><li id="4c03" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae ke" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv"> Auth0 </strong> </a>，作为托管认证服务，</li><li id="15e3" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae ke" href="https://appbase.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv"> Appbase.io </strong> </a>，作为托管数据库服务。</li></ol><blockquote class="kt"><p id="4f3c" class="ku kv hu bd kw kx ky kz la lb lc kd ek translated">你可以点击查看应用<a class="ae ke" href="https://www.youtube.com/watch?v=Ykwdfxl7IOo&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">的截图。</a></p></blockquote><figure class="le lf lg lh li iv fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/95e63b90a6afb7d44833f059e3297dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*qNHfoSWeNrpKf-TarLs4ig.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Final app preview</figcaption></figure><h1 id="a4bb" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">反应搜索</h1><p id="79c0" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated"><a class="ae ke" href="https://hackernoon.com/tagged/reactivesearch" rel="noopener ugc nofollow" target="_blank">React search</a>是一个开源的React和React原生UI组件库，用于Elasticsearch，是我和<a class="ae ke" href="https://github.com/appbaseio/reactivesearch/graphs/contributors" rel="noopener ugc nofollow" target="_blank">一些了不起的人</a>共同编写的。它提供了各种React本地组件，可以<a class="ae ke" href="https://opensource.appbase.io/reactive-manual/native/getting-started/reactivebase.html#connect-to-elasticsearch" rel="noopener ugc nofollow" target="_blank">连接到任何Elasticsearch </a>集群。</p><p id="cd2a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这个故事中，我将扩展我在<a class="ae ke" href="https://medium.freecodecamp.org/how-to-build-a-real-time-todo-app-with-react-native-19a1ce15b0b3" rel="noopener ugc nofollow" target="_blank">上写的另一个故事，如何用React Native </a>构建一个实时todo应用程序，如果你对构建我将在这里使用的starter项目感兴趣，你可以查看一下。</p><h1 id="d43a" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">入门指南</h1><p id="28db" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">我们将使用由appbase.io和ReactiveSearch Native 构建的<a class="ae ke" href="https://medium.freecodecamp.org/how-to-build-a-real-time-todo-app-with-react-native-19a1ce15b0b3" rel="noopener ugc nofollow" target="_blank"> Todos应用作为基线来构建我们的认证Todos应用。我已经设置了启动项目，我们将在客户端和服务器端使用。然而，在我们深入研究代码之前，我将讨论几个概念。</a></p><ul class=""><li id="aef2" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated">每个Appbase应用程序都允许不同组的凭证(<strong class="ji hv">读取</strong>和<strong class="ji hv">写入</strong>)用于<a class="ae ke" href="http://docs.appbase.io/concepts/intro.html#http-basic-authentication" rel="noopener ugc nofollow" target="_blank">读取和写入访问控制</a>。</li><li id="2aaf" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd mm kl km kn dt translated">在本文中，我们将确保客户端应用程序只能持有我们的appbase应用程序的<strong class="ji hv">读取凭证</strong>，并且我们将提取节点/Express服务器的<strong class="ji hv">写入</strong>操作(用于创建、删除和编辑todos)的逻辑。这将允许我们将写访问权限仅限于经过身份验证的用户，同时保持<strong class="ji hv">写凭证</strong>的安全。</li><li id="a5da" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd mm kl km kn dt translated">所有todos将具有以下结构:</li></ul><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="4eac" class="mw lk hu ms b fv mx my l mz na">{<br/> "title": "Writing code",<br/> "completed": true,<br/> "createdAt": 1518766646430,<br/> "name": "divyanshu",<br/> "avatar": "https://s.gravatar.com/avatar/33ca46e56260bc7d54b2d7246f9a7052?s=480&amp;r=pg&amp;d=https%3A%2F%2Fcdn.auth0.com%2Favatars%2Fdi.png"<br/>}</span></pre><p id="e282" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们开始构建UI之前，我们需要一个地方来存储我们的待办事项。简而言之，你可以使用托管在<a class="ae ke" href="https://appbase.io" rel="noopener ugc nofollow" target="_blank"> appbase.io </a>上的<a class="ae ke" href="https://opensource.appbase.io/dejavu/live/#?input_state=XQAAAAL1AAAAAAAAAAA9iIqnY-B2BnTZGEQz6wkFsvSiNDYsjvhmh6bR2aMQ_b8tfAYV5i8SWTc_IE_DnS6BceaXTW2gpbXukBeX2O1FPfldvf_iKvL58obaZr3r1kiYuxUWyYGFx95VU3wsDNhT-rQ-dTKe93wqnEskMMPDhF9HexjeqTmAn__P7WMUiN_V_oE1L0wcoZ-gyOMV4QAXG0t_80hyKz3VGcgSfnwfmAd_NYgrrO0mK5VolnUO5L-lr_niJOTXMbvy_-H8KAA&amp;editable=false" rel="noopener ugc nofollow" target="_blank">我的应用</a>或者通过点击<a class="ae ke" href="https://opensource.appbase.io/dejavu/live/#?input_state=XQAAAAL1AAAAAAAAAAA9iIqnY-B2BnTZGEQz6wkFsvSiNDYsjvhmh6bR2aMQ_b8tfAYV5i8SWTc_IE_DnS6BceaXTW2gpbXukBeX2O1FPfldvf_iKvL58obaZr3r1kiYuxUWyYGFx95VU3wsDNhT-rQ-dTKe93wqnEskMMPDhF9HexjeqTmAn__P7WMUiN_V_oE1L0wcoZ-gyOMV4QAXG0t_80hyKz3VGcgSfnwfmAd_NYgrrO0mK5VolnUO5L-lr_niJOTXMbvy_-H8KAA&amp;editable=false" rel="noopener ugc nofollow" target="_blank">此链接</a>并点击<em class="nb">克隆此应用</em>按钮来克隆它。这将允许您制作数据集的副本作为自己的应用程序。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/f73d86a4b759c5a2c4ae751c3de1bc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWA-tIhv5aJd1Qxh4Mptzw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">View my app dataset <a class="ae ke" href="https://opensource.appbase.io/dejavu/live/#?input_state=XQAAAAL1AAAAAAAAAAA9iIqnY-B2BnTZGEQz6wkFsvSiNDYsjvhmh6bR2aMQ_b8tfAYV5i8SWTc_IE_DnS6BceaXTW2gpbXukBeX2O1FPfldvf_iKvL58obaZr3r1kiYuxUWyYGFx95VU3wsDNhT-rQ-dTKe93wqnEskMMPDhF9HexjeqTmAn__P7WMUiN_V_oE1L0wcoZ-gyOMV4QAXG0t_80hyKz3VGcgSfnwfmAd_NYgrrO0mK5VolnUO5L-lr_niJOTXMbvy_-H8KAA&amp;editable=false" rel="noopener ugc nofollow" target="_blank">here</a>. You can also clone this to your own app</figcaption></figure><h1 id="48c5" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">认证概念</h1><p id="76c6" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">我们使用Auth0来处理认证，它使用<a class="ae ke" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv"/></a>(JSON Web令牌)作为访问令牌。它由三部分组成<strong class="ji hv">报头</strong>、<strong class="ji hv">有效载荷</strong>和<strong class="ji hv">签名</strong>，由<strong class="ji hv">点(。)</strong>。JWT看起来像:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="c60a" class="mw lk hu ms b fv mx my l mz na">xxx.yyy.zzz</span></pre><p id="1d8f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">报头(xxx)定义了令牌的类型和用于散列的算法。有效负载(yyy)包含关于用户和附加元数据的信息。签名(zzz)用于验证令牌的发送者，并确保消息在传输过程中没有被篡改。你可以在<a class="ae ke" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"> JWT介绍指南</a>中找到更详细的解释。</p><blockquote class="nd ne nf"><p id="0e06" class="jg jh nb ji b jj jk jl jm jn jo jp jq ng js jt ju nh jw jx jy ni ka kb kc kd hn dt translated">使用JWT令牌的另一个流行的替代方法是管理会话。然而，这引入了国家性——JWT是无国籍的，是一个更好的方法。</p></blockquote><p id="1dc7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">访问令牌一旦被验证，就告诉我们用户被授权访问API，并形成我们的基于<a class="ae ke" href="https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication#toc-how-token-based-works" rel="noopener ugc nofollow" target="_blank">令牌的认证</a>系统的基础。身份验证流程如下所示:</p><ul class=""><li id="1f7a" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated">从React应用程序到服务器的每个请求都将包含一个<strong class="ji hv"> access_token </strong>，它将在服务器上使用Express中间件进行验证。当我们通过Auth0注册或登录时，我们将收到一个<a class="ae ke" href="https://auth0.com/docs/tokens/id-token" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv"> id_token </strong> </a>(包含用户的个人资料信息)和一个<a class="ae ke" href="https://auth0.com/docs/tokens/access-token" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv"> access_token </strong> </a>(客户端可以使用的访问API的凭证)。</li></ul><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nj"><img src="../Images/1b116bedb3e37018b12a0769b1462cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drf0mPpyZU5-GlOZnwUBJQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">App design</figcaption></figure><ul class=""><li id="7b10" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated">我们将使用<a class="ae ke" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，并为我们的教程应用程序创建一个新的<strong class="ji hv">本地</strong>客户端。我们需要<strong class="ji hv">客户端ID </strong>和<strong class="ji hv">域</strong>，以便在我们的应用程序中配置auth0。您可以从您的Auth0 <a class="ae ke" href="https://manage.auth0.com/#/" rel="noopener ugc nofollow" target="_blank">仪表板</a>获取这些信息。</li></ul><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nk"><img src="../Images/a1d050a9310512d09090a50a37206078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4t1u1ojvYoistarcmduGg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Getting Domain and Client Id for the app</figcaption></figure><ul class=""><li id="200a" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated">我们还需要在<strong class="ji hv">允许的回调URL</strong>部分添加一个回调URL，因为在认证之后，客户端会被重定向回带有<strong class="ji hv">令牌</strong>信息的回调URL，我们稍后将解析该信息以供使用。我们稍后会谈到这一部分。</li></ul><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/53fc72302ba43b7805db56b280ebb479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DGqG7tmhvWUPucOE_cIXg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Adding callback URLs for the app</figcaption></figure><ul class=""><li id="621b" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated">接下来，我们需要为<strong class="ji hv">受众</strong>标识符(用于在应用程序中配置auth0实例的唯一字符串值)创建一个新的API，稍后我们将使用它来验证访问令牌。</li></ul><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nm"><img src="../Images/f185811b3ebe18e35b5e8c79bc6576c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wg44FZ4IJH7RXlVNFx-HpA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Getting the audience identifier</figcaption></figure><h1 id="262b" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">钻研代码</h1><p id="b1bb" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">最终的目录结构如下所示:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="dc34" class="mw lk hu ms b fv mx my l mz na">android                      // android related configs<br/>ios                          // ios related configs<br/>components<br/>├── RootComponent.js         // Root component for our app<br/>├── MainTabNavigator.js      // Tab navigation component      <br/>├── TodosScreen.js           // Renders the TodosContainer          <br/>├── Header.js                // Header component         <br/>├── AddTodo.js               // Add todo input        <br/>├── AddTodoButton.js         // Add todo floating button        <br/>├── TodoItem.js              // The todo item         <br/>├── TodosContainer.js        // Todos main container<br/>api                          <br/>├── todos.js                 // APIs for performing writes<br/>constants                    // Some constants used in the app<br/>types                        // Todo type to be used with prop-types<br/>utils                        // Streaming logic goes here</span></pre><p id="7e68" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是最终的存储库，因此您可以随时参考它们:</p><p id="af4a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">(i) <a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-client" rel="noopener ugc nofollow" target="_blank"> Todos认证客户端</a> (React Native App)</p><p id="5784" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">(二)<a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-server" rel="noopener ugc nofollow" target="_blank"> Todos认证服务器</a>(节点/快速服务器)</p><h2 id="c3e9" class="mw lk hu bd ll nn no np lp nq nr ns lt jr nt nu lx jv nv nw mb jz nx ny mf nz dt translated">1.准备好项目</h2><p id="06a8" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">我们从这篇<a class="ae ke" href="https://medium.freecodecamp.org/how-to-build-a-real-time-todo-app-with-react-native-19a1ce15b0b3" rel="noopener ugc nofollow" target="_blank">上一篇</a>文章中的Todos应用代码开始，并向其中添加一个认证流程。您可以使用以下存储库作为起始项目文件:</p><p id="31cb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">(一)<a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-client-starter" rel="noopener ugc nofollow" target="_blank"> Todos原生认证客户端启动项目</a></p><p id="c2ea" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">(二)<a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-server-starter" rel="noopener ugc nofollow" target="_blank">Todos Native Auth Server starter项目</a></p><p id="e371" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">克隆项目后，您可以切换到客户端项目目录并进行测试:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="7860" class="mw lk hu ms b fv mx my l mz na">npm install<br/>npm start<br/>react-native run-ios (or)<br/>react-native run-android</span></pre><p id="c1fd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将启动Todos应用程序(在客户端有完整的逻辑)。既然一切都已启动并运行，我们可以开始编写身份验证流代码了。</p><blockquote class="nd ne nf"><p id="e5b8" class="jg jh nb ji b jj jk jl jm jn jo jp jq ng js jt ju nh jw jx jy ni ka kb kc kd hn dt translated"><strong class="ji hv">注</strong></p><p id="6a4b" class="jg jh nb ji b jj jk jl jm jn jo jp jq ng js jt ju nh jw jx jy ni ka kb kc kd hn dt translated">我们正在使用一个弹出的create-react-native-app模板，因此使用<code class="eh oa ob oc ms b">react-native</code>来运行应用程序。这是我在这里使用的用于认证目的的<code class="eh oa ob oc ms b">react-native-auth0</code>包所需要的。</p></blockquote><h2 id="0dd0" class="mw lk hu bd ll nn no np lp nq nr ns lt jr nt nu lx jv nv nw mb jz nx ny mf nz dt translated">2.配置Auth0回调</h2><p id="b160" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">Auth0需要对<code class="eh oa ob oc ms b">ios</code>或<code class="eh oa ob oc ms b">android</code>的回调，您可以用以下方式定义:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="97d8" class="mw lk hu ms b fv mx my l mz na">{PRODUCT_BUNDLE_IDENTIFIER}://divyanshu.auth0.com/ios/{PRODUCT_BUNDLE_IDENTIFIER}/callback</span></pre><p id="f806" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">和</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="26f3" class="mw lk hu ms b fv mx my l mz na">{YOUR_APP_PACKAGE_NAME}://divyanshu.auth0.com/android/{YOUR_APP_PACKAGE_NAME}/callback</span></pre><p id="96e4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以通过Auth0 <a class="ae ke" href="http://manage.auth0.com/" rel="noopener ugc nofollow" target="_blank">仪表板</a>将这些添加到您的应用程序的回调URL中。</p><p id="1058" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们的例子中，包名是<code class="eh oa ob oc ms b">com.todosnative</code>，但是你可以使用你自己的包名，并在android manifest和ios plist文件中更新相同的包名。在启动文件中，我已经添加了这些内容，但是如果你要自己做，你可以这样做<em class="nb">(这里你可以跳到下一步)</em>:</p><ul class=""><li id="b4a7" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated">你可以在<code class="eh oa ob oc ms b">/android/app/src/main/AndroidManifest.xml</code>找到<code class="eh oa ob oc ms b">AndroidManifest.xml</code>文件</li></ul><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="ea39" class="mw lk hu ms b fv mx my l mz na">package="com.auth0sample"</span></pre><ul class=""><li id="de0e" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated">对于ios，可以在<code class="eh oa ob oc ms b">/ios/todosnative/Info.plist</code>更新<code class="eh oa ob oc ms b">Info.plist</code>文件</li></ul><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="c26d" class="mw lk hu ms b fv mx my l mz na">&lt;key&gt;CFBundleIdentifier&lt;/key&gt;<br/>&lt;string&gt;com.todosnative&lt;/string&gt;</span></pre><p id="f9c5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">起始项目中已经存在对<code class="eh oa ob oc ms b">react-native-auth0</code>的依赖。您可以运行下面的命令来<code class="eh oa ob oc ms b">link</code>所有的本机依赖项:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="9282" class="mw lk hu ms b fv mx my l mz na">react-native link</span></pre><p id="63b5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们可以更新<code class="eh oa ob oc ms b">AndroidManifest.xml</code>文件，使其具有一个<code class="eh oa ob oc ms b">singleTask</code>的<code class="eh oa ob oc ms b">launchMode</code>，并添加另一个<code class="eh oa ob oc ms b">intent-filter</code>。该文件应该类似于:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="2252" class="mw lk hu ms b fv mx my l mz na">&lt;activity<br/>    android:name=".MainActivity"<br/>    android:label="@string/app_name"<br/>    android:launchMode="singleTask"      android:configChanges="keyboard|keyboardHidden|orientation|screenSize"<br/>    android:windowSoftInputMode="adjustResize"&gt;<br/>&lt;intent-filter&gt;<br/>    &lt;action android:name="android.intent.action.MAIN" /&gt;<br/>    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>&lt;/intent-filter&gt;<br/>&lt;intent-filter&gt;<br/>    &lt;action android:name="android.intent.action.VIEW" /&gt;<br/>    &lt;category android:name="android.intent.category.DEFAULT" /&gt;<br/>    &lt;category android:name="android.intent.category.BROWSABLE" /&gt;<br/>    &lt;data<br/>        android:host="YOUR_AUTH0_DOMAIN"<br/>        android:pathPrefix="/android/YOUR_APPLICATION_ID/callback"<br/>        android:scheme="YOUR_APPLICATION_ID" /&gt;<br/>&lt;/intent-filter&gt;<br/>&lt;/activity&gt;</span></pre><p id="ccb5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以用自己的auth0域和应用程序id替换存根值。</p><p id="7cf7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，更新<code class="eh oa ob oc ms b">/ios/todosnative/AppDelegate.m</code>文件并添加以下内容:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="e017" class="mw lk hu ms b fv mx my l mz na">#import &lt;React/RCTLinkingManager.h&gt;</span><span id="6950" class="mw lk hu ms b fv od my l mz na">/* Add the following after @implementation AppDelegate */</span><span id="60da" class="mw lk hu ms b fv od my l mz na">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url<br/>  sourceApplication:(NSString *)sourceApplication annotation:(id)annotation<br/>{<br/>  return [RCTLinkingManager application:application openURL:url<br/>                      sourceApplication:sourceApplication annotation:annotation];<br/>}</span></pre><p id="f265" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将在<code class="eh oa ob oc ms b">Info.plist</code>文件中添加一个<code class="eh oa ob oc ms b">CFBundleURLSchemes</code>:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="8cf5" class="mw lk hu ms b fv mx my l mz na">&lt;key&gt;CFBundleURLTypes&lt;/key&gt;<br/>&lt;array&gt;<br/>    &lt;dict&gt;<br/>        &lt;key&gt;CFBundleTypeRole&lt;/key&gt;<br/>        &lt;string&gt;None&lt;/string&gt;<br/>        &lt;key&gt;CFBundleURLName&lt;/key&gt;<br/>        &lt;string&gt;auth0&lt;/string&gt;<br/>        &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;<br/>        &lt;array&gt;<br/>            &lt;string&gt;org.reactjs.native.example.$(PRODUCT_NAME:rfc1034identifier)&lt;/string&gt;<br/>        &lt;/array&gt;<br/>    &lt;/dict&gt;<br/>&lt;/array&gt;</span></pre><h2 id="5282" class="mw lk hu bd ll nn no np lp nq nr ns lt jr nt nu lx jv nv nw mb jz nx ny mf nz dt translated">3.处理认证</h2><p id="5147" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">当您从starter项目启动该应用程序时，它看起来将如下所示:</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff oe"><img src="../Images/b45561dd0ee8326ea0b38fcf15a67a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*WoW3ujgIXe9fN1G4oFsmWA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Initial version of the app</figcaption></figure><p id="8bd7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意，最初您将无法添加、删除或更新待办事项。我们将很快添加处理这些操作的方法。</p><p id="42ed" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先让我们在<code class="eh oa ob oc ms b">/components/TodosContainer.js</code>中添加登录<code class="eh oa ob oc ms b">Button</code>。您可以在<code class="eh oa ob oc ms b">TodosContainer</code>的<code class="eh oa ob oc ms b">render</code>功能中添加以下内容:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="3c33" class="mw lk hu ms b fv mx my l mz na">&lt;ScrollView&gt;<br/>  &lt;Button<br/>    title="Login Button"<br/>    style={{<br/>      marginTop: 10,<br/>      marginBottom: 10<br/>    }}<br/>  /&gt;<br/>  ...</span></pre><p id="ceb5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将在<code class="eh oa ob oc ms b">/components/RootComponent.js</code>中为登录和注销创建处理程序，并将它们传递给子组件使用。我已经在starter项目中添加了注释，以确定我们需要在哪里添加代码。</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="of og l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Adding handlers in RootComponent</figcaption></figure><p id="7aca" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于认证，我使用的是<a class="ae ke" href="https://github.com/auth0/react-native-auth0" rel="noopener ugc nofollow" target="_blank"> react-native-auth0 </a>。这里可以使用自己的Auth0 <code class="eh oa ob oc ms b">domain</code>和<code class="eh oa ob oc ms b">clientId</code>。在<code class="eh oa ob oc ms b">handleLogin</code>方法中，我们保存了<code class="eh oa ob oc ms b">accessToken</code>以及用户<code class="eh oa ob oc ms b">avatar</code>和<code class="eh oa ob oc ms b">name</code>的状态。<code class="eh oa ob oc ms b">handleLogout</code>方法会将这些从状态中移除。所有的处理程序和状态都通过<code class="eh oa ob oc ms b">screenProps</code>传递给由<code class="eh oa ob oc ms b">MainTabNavigator</code>组件呈现的子组件，该组件使用来自<code class="eh oa ob oc ms b">react-navigation</code>的<code class="eh oa ob oc ms b"><a class="ae ke" href="https://reactnavigation.org/docs/tab-navigator.html" rel="noopener ugc nofollow" target="_blank">TabNavigator</a></code>。它获取这些道具，并使它们在<code class="eh oa ob oc ms b">screenProps</code>下可用。</p><p id="4405" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将在<code class="eh oa ob oc ms b">/components/TodosContainer.js</code>中使用这些:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="of og l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Handling authentication in TodosContainer</figcaption></figure><p id="b00d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们将能够通过单击登录按钮进行登录，并保存访问令牌以供使用。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff oe"><img src="../Images/755f8c4d131a281bb94f1dbaf12529fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*Hhg04tnQnQQnXPQodF501g.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">After adding authentication</figcaption></figure><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff oe"><img src="../Images/6c70c725c41a686874c1c6966107c60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*TsNLpv7ZvZJqAdkG5aBEiA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Login screen after clicking on Login button</figcaption></figure><h2 id="b4e1" class="mw lk hu bd ll nn no np lp nq nr ns lt jr nt nu lx jv nv nw mb jz nx ny mf nz dt translated">4.传递screenProps以更新和删除TodoItem中的呼叫</h2><p id="1dff" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">认证发生后，我将<code class="eh oa ob oc ms b">accessToken</code>、<code class="eh oa ob oc ms b">avatar</code>和<code class="eh oa ob oc ms b">name</code>保存在<code class="eh oa ob oc ms b">/components/RootComponent</code>状态。这些由<code class="eh oa ob oc ms b">/components/MainTabNavigator.js</code>中的<code class="eh oa ob oc ms b">TabNavigator</code>通过<code class="eh oa ob oc ms b">screenProps</code>提供给子组件。在前面的步骤中，我们已经将<code class="eh oa ob oc ms b">screenProps</code>传递给了<code class="eh oa ob oc ms b">TodoItem</code>组件。接下来，我们将更新组件，使它们传递给API调用。</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="of og l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Passing screenProps in TodoItem for Update and Delete calls</figcaption></figure><h2 id="f72e" class="mw lk hu bd ll nn no np lp nq nr ns lt jr nt nu lx jv nv nw mb jz nx ny mf nz dt translated">5.处理写入</h2><p id="12ff" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">到目前为止，我们只记录了调用<code class="eh oa ob oc ms b">add</code>、<code class="eh oa ob oc ms b">update</code>或<code class="eh oa ob oc ms b">delete</code>调用时的控制台日志。接下来，我将使用三个端点来处理数据写入:</p><ul class=""><li id="b03f" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd mm kl km kn dt translated"><strong class="ji hv"> POST / </strong>创建todos</li><li id="c575" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd mm kl km kn dt translated"><strong class="ji hv"> PUT / </strong>更新todos</li><li id="ee80" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd mm kl km kn dt translated"><strong class="ji hv">删除/ </strong>删除待办事项</li></ul><p id="1faf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是我们如何在客户端应用程序上处理这些呼叫。我们将这些添加到<code class="eh oa ob oc ms b">/api/todos.js</code>:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="of og l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">API calls from the client side</figcaption></figure><p id="41eb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你会注意到我在<code class="eh oa ob oc ms b">fetch</code>调用中传递了一些<code class="eh oa ob oc ms b">headers</code>。我正在使用我们之前收到的访问令牌，并在所有调用中传递它。我们将用它来验证服务器端的请求。<code class="eh oa ob oc ms b">body</code>包括创建、更新或删除待办事项的必要数据。此外，如果访问令牌不存在，呼叫也不会接通。</p><p id="f09b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，对于最后缺失的部分，下面是我在服务器上处理请求的方式:</p><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="of og l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Routes for handling write operations on the server</figcaption></figure><p id="bc36" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里，<code class="eh oa ob oc ms b">checkJwt</code>中间件使用我们在客户端指定的相同的<code class="eh oa ob oc ms b">audience</code>和这里指定为<code class="eh oa ob oc ms b">issuer</code>的<code class="eh oa ob oc ms b">domain</code>来验证每个请求上的访问令牌。如果令牌不存在或无效，请求将被视为未授权而被拒绝。现在你可以在不同的终端启动服务器，你将能够安全地处理你的应用程序的写操作。🙂</p><h1 id="47e5" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">有用的链接</h1><ol class=""><li id="e517" class="kf kg hu ji b jj mh jn mi jr oh jv oi jz oj kd kk kl km kn dt translated">用于<a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-client-starter" rel="noopener ugc nofollow" target="_blank">客户端</a>和<a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-server-starter" rel="noopener ugc nofollow" target="_blank">服务器端</a>的Todos app starter项目</li><li id="4137" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">Todos app最终回购<a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-client" rel="noopener ugc nofollow" target="_blank">客户端</a>和<a class="ae ke" href="https://github.com/appbaseio-apps/todos-native-auth-server" rel="noopener ugc nofollow" target="_blank">服务端</a></li><li id="5509" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae ke" href="https://github.com/appbaseio/reactivesearch" rel="noopener ugc nofollow" target="_blank">反应搜索GitHub报告</a> ⭐️</li><li id="4d65" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">反应搜索<a class="ae ke" href="https://opensource.appbase.io/reactive-manual/native" rel="noopener ugc nofollow" target="_blank">文档</a></li></ol><h1 id="7743" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">进一步阅读</h1><p id="fb2b" class="pw-post-body-paragraph jg jh hu ji b jj mh jl jm jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd hn dt translated">希望你喜欢这个故事。你可能也会喜欢我写的一些相关故事:</p><div class="ok ol fm fo om on"><a href="https://medium.freecodecamp.org/how-to-build-a-real-time-todo-app-with-react-native-19a1ce15b0b3" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab ej"><div class="op ab oq cl cj or"><h2 class="bd hv fv z el os eo ep ot er et ht dt translated">如何使用React Native构建实时待办事项应用</h2><div class="ou l"><h3 class="bd b fv z el os eo ep ot er et ek translated">todo应用涉及构建任何数据驱动应用的所有重要部分，包括创建、读取、更新和…</h3></div><div class="ov l"><p class="bd b gc z el os eo ep ot er et ek translated">medium.freecodecamp.org</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ja on"/></div></div></a></div><div class="ok ol fm fo om on"><a href="https://medium.freecodecamp.org/building-a-github-repo-explorer-with-react-and-elasticsearch-8e1190e59c13" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab ej"><div class="op ab oq cl cj or"><h2 class="bd hv fv z el os eo ep ot er et ht dt translated">用React和Elasticsearch构建GitHub Repo Explorer</h2><div class="ou l"><h3 class="bd b fv z el os eo ep ot er et ek translated">Elasticsearch是最受欢迎的全文搜索引擎之一，它允许你搜索大量的数据…</h3></div><div class="ov l"><p class="bd b gc z el os eo ep ot er et ek translated">medium.freecodecamp.org</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ja on"/></div></div></a></div><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="pd og l"/></div></figure></div></div>    
</body>
</html>