<html>
<head>
<title>Making a game with Javascript: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript制作游戏:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-a-game-with-javascript-part-2-8154bd6e2de1?source=collection_archive---------4-----------------------#2018-03-21">https://medium.com/hackernoon/making-a-game-with-javascript-part-2-8154bd6e2de1?source=collection_archive---------4-----------------------#2018-03-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e9bb" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">建造宇宙飞船</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/517d297c18a1723dc227b9d2fec0f107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6LciqpRc7XxOV_kCOU_NQ.png"/></div></div></figure><h2 id="0b5b" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">迎头赶上</h2><p id="f0d6" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">大家好！本文是我用Javascript制作一个小游戏的教程的第二部分。<a class="ae lm" href="https://hackernoon.com/making-a-game-with-javascript-and-pixijs-part-1-e3235139cd6f" rel="noopener ugc nofollow" target="_blank"> <strong class="kv hv">你可以在这里阅读Part 1</strong></a><strong class="kv hv">。</strong></p><p id="fb19" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><a class="ae lm" href="https://github.com/Karzam/Spaceship_Tutorial_Part_2" rel="noopener ugc nofollow" target="_blank"> <strong class="kv hv">本教程的完整源代码可以在这里找到</strong> </a> <strong class="kv hv">。</strong></p><h2 id="05b4" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">创造宇宙飞船</h2><p id="4e51" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">现在背景完成了，我们终于可以开始设置我们的飞船了！</p><p id="e157" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">让我们<strong class="kv hv">创建一个</strong> <em class="ls"> Player.js </em> <strong class="kv hv">文件</strong><strong class="kv hv">添加到</strong><em class="ls">index.html</em>作为脚本(同<em class="ls"> CloudManager </em>)。</p><p id="b768" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">这是一个在几分钟内设计出来的(漂亮的)飞船，你可以<strong class="kv hv">添加到你的</strong> <em class="ls">资产</em> <strong class="kv hv">文件夹</strong>和<em class="ls"> main.js </em>的loader <strong class="kv hv"> </strong>函数中:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/cc146f2a93356a1be66b3334fc127287.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*ExJFkzXCUvOL4D1OyWc0pw.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Spaceship</figcaption></figure><p id="9cd4" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">基本上，我们希望这艘船出现在屏幕左边附近。我们还需要<strong class="kv hv">的锚点</strong>(对象的位置点)在精灵的中心<strong class="kv hv">，因为它可能太大了，我们可以重新调整它的大小:</strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="8905" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">当然，我们必须将<strong class="kv hv">声明为</strong> <em class="ls"> main.js </em> <strong class="kv hv"> </strong>文件的全局变量，这样它就可以在游戏中实例化:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="274b" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">…和同一文件的 <em class="ls"> init </em> <strong class="kv hv">函数中的<strong class="kv hv">(就在<em class="ls"> CloudManager </em>之后):</strong></strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="a79b" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">现在你应该看到闪闪发光的宇宙飞船巡航。</p><p id="a17c" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">然而，如果你等待几秒钟，你应该得到一些麻烦:</p><p id="5c12" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><strong class="kv hv"> <em class="ls">飞船在云层后面飞行！</em>T57】</strong></p><p id="d149" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">是的，因为事实上，<strong class="kv hv">最后一个创建的对象正在移动到前一个的后面。飞船实例化后，云正在生成，所以我们需要云管理器在对象列表的底部生成云。为此，我们只需对<strong class="kv hv">更新一点</strong><em class="ls">addChild</em><strong class="kv hv"/>中的<strong class="kv hv"/><em class="ls">cloud manager</em><strong class="kv hv"/>类:</strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="3033" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><em class="ls"> addChildAt </em>允许我们传递第二个参数，即<strong class="kv hv">舞台对象列表</strong>中的位置。它越远，精灵在屏幕上就越远。</p><p id="c4c0" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">“0”表示对象列表中的第一个索引<strong class="kv hv">，所以每次我们创建一个新的云，我们<strong class="kv hv">会把它添加到列表</strong>的第一个位置，确保<strong class="kv hv">会出现在飞船后面。</strong></strong></p><p id="2701" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">现在完成了，我们可以启动飞船控制器了。</p><h2 id="5d1b" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">移动宇宙飞船</h2><p id="2946" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">让我们回到<em class="ls"> Player.js </em>类，<strong class="kv hv">在构造函数</strong>中添加一些行:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="0a0d" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">这允许游戏捕捉<strong class="kv hv">键盘事件</strong>(当一个键被按下和释放时)。当其中一个事件发生时，将执行每行末尾的方法。</p><p id="0c27" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><strong class="kv hv"> <em class="ls">注</em> </strong> <em class="ls">:通过添加”。bind(this)”在函数的最后，我们将对象的上下文传递给它，这意味着我们仍然可以通过调用“this”来访问它的属性。如果我们不这样写，回调函数就不能确定我们正在处理哪个对象。请记住，如果您一个回调函数得到一个“undefined this”错误，您可能必须像这样绑定您的对象。</em></p><p id="7fef" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">让我们<strong class="kv hv">在同一个类</strong>中定义两个空方法(我们稍后将填充这些方法):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="9174" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">我们还需要3个变量来移动飞船:它的<strong class="kv hv">水平和垂直方向</strong> (X &amp; Y)和<strong class="kv hv">速度</strong>(它们都在构造函数中):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="4e34" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">该对象基本上是键码和方向值的关联:</p><ul class=""><li id="65dc" class="ma mb hu kv b kw ln kz lo kg mc kk md ko me ll mf mg mh mi dt translated">37是<strong class="kv hv">左箭头键</strong>，要向左移动我们的飞船，我们需要减少它的X位置。</li><li id="7fe6" class="ma mb hu kv b kw mj kz mk kg ml kk mm ko mn ll mf mg mh mi dt translated">38是<strong class="kv hv">向上箭头键</strong>，要将我们的飞船移动到顶部，我们需要降低它的Y位置。</li><li id="2ebd" class="ma mb hu kv b kw mj kz mk kg ml kk mm ko mn ll mf mg mh mi dt translated">39是<strong class="kv hv">右箭头键</strong>，要向右移动我们的飞船，我们需要增加它的X位置。</li><li id="38aa" class="ma mb hu kv b kw mj kz mk kg ml kk mm ko mn ll mf mg mh mi dt translated">40是<strong class="kv hv">向下箭头键</strong>，要将我们的飞船移到底部，我们需要增加它的Y位置。</li></ul><p id="c079" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">每次按下一个键，我们检索相应的方向:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="b7fa" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">这看起来很奇怪，但让我们解释一下:<strong class="kv hv">如果键码是37或39(这意味着左箭头键或右箭头键)，那么我们只需设置X方向</strong>。如果是38或40，你可以猜猜发生了什么(是的，实际上是垂直方向)。仅此而已！</p><p id="6256" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">再来<strong class="kv hv">加上玩家</strong>的更新方法(<a class="ae lm" href="https://hackernoon.com/making-a-game-with-javascript-and-pixijs-part-1-e3235139cd6f" rel="noopener ugc nofollow" target="_blank">像云经理，还记得吗？</a>):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="02b4" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">…当然还有，<strong class="kv hv">别忘了在<em class="ls"> main.js </em>的循环函数</strong>中调用它！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="1c63" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">如果你保存并重新加载游戏，它(应该)会运行良好，除了当我们释放方向键时船<strong class="kv hv">继续移动。很明显是因为我们没有完成<em class="ls"> onKeyUp </em>功能，也就是<strong class="kv hv">抓住刚刚发布的键</strong>。这样，我们可以通过将<em class="ls">方向X </em>或<em class="ls">方向</em>设置为0来停止它。</strong></p><p id="9868" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">这里有一个小问题:<strong class="kv hv">如果我们将方向设置为0，因为我们释放了左键，但右键仍被按下，这是怎么回事？</strong></p><p id="e800" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">是的，宇宙飞船要停下来了，而<strong class="kv hv">我们必须再次按下右键来移动</strong>，这不太符合逻辑。</p><p id="9c6c" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">那么，为什么不检查右键或左键是否仍然被按下，这样我们就可以<strong class="kv hv">将方向重置为这个先前被按下的键？</strong></p><p id="5f29" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">这就是我们将要做的。为此，我们需要将每个键的状态存储在一个布尔值中，按下或释放(<em class="ls">真</em>或<em class="ls">假</em>)。让我们将所有这些状态放入<em class="ls">播放器</em>构造函数的一个对象变量中:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="7554" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">如果一个键(由它自己的代码识别)被按下，那么<strong class="kv hv">我们就把它的状态改变为<em class="ls">真</em>T25】，如果它被释放，我们就把它设置为<em class="ls">假</em>。很简单，对吧？</strong></p><p id="f0d7" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">让我们在<em class="ls"> onKeyDown </em>的开头加上这一行:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="72a4" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">…还有这个在<em class="ls"> onKeyUp </em>里的:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="810f" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">现在我们可以继续<em class="ls"> onKeyUp </em>逻辑:<strong class="kv hv">如果水平或垂直键中的一个被释放，但另一个仍然被按下，我们将方向改变到最后一个</strong>。<strong class="kv hv">如果</strong> <strong class="kv hv">他们两个都被释放，我们停船</strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="1f21" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><strong class="kv hv"> <em class="ls">注:</em> </strong> <em class="ls">处理飞船移动有多种方式，这当然不是最干净的一种，但我认为这是最简单易懂的一种。</em></p><p id="3c9d" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">我们都准备好了，保存&amp;重新加载&amp;享受！</p><p id="1642" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><strong class="kv hv">升级:</strong> <em class="ls">飞船可以退出屏幕了！尝试在更新它之前检查它的位置。</em> <a class="ae lm" href="https://github.com/Karzam/Spaceship_Tutorial_Part_2/blob/master/src/Player.js" rel="noopener ugc nofollow" target="_blank">你可以在这里查看结果</a>。</p><h2 id="6fbe" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">发射火箭</h2><p id="916b" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">既然我们能控制飞船，我们希望它能发射火箭。</p><p id="a8de" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">让我们从<strong class="kv hv">开始在</strong> <em class="ls">资产</em> <strong class="kv hv">文件夹中添加精灵:</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/795f769375e264c79e5174e47b0d3adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:100/format:webp/1*3HQFL4Wbr9s3uahvNhHLNg.png"/></div></figure><p id="131e" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">…然后<strong class="kv hv">像往常一样将其添加到资产加载器</strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="4740" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><strong class="kv hv">在<em class="ls"> src </em>文件夹中创建一个名为<em class="ls"> Rocket.js </em>的新文件</strong>，并<strong class="kv hv">将其添加到<em class="ls">index.html</em>中，与其他人一起:</strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="43cc" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">让我们回到<em class="ls">玩家</em>类。我们希望它能够<strong class="kv hv">发射火箭，如果他按下空格键按钮</strong>。<em class="ls"> onKeyDown </em>函数已经在捕捉这样的事件了，所以我们只需要<strong class="kv hv">用我们想要的键码</strong>(本例中为空格键)做一个条件:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="fbaa" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">我们在火箭构造器中给出了飞船的位置，所以在里面我们只需<strong class="kv hv">将其位置设置为飞船一号</strong>(有一个偏移量使其出现在飞船的前面而不是中间)。</p><p id="ff38" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">那么我们开始吧，用构造函数初始化<em class="ls"> Rocket.js </em>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="20f2" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">好吧，如果你保存并重新装弹，<strong class="kv hv">你可以按空格键发射(静态)火箭！</strong></p><p id="62c5" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">为了让它们移动，我们需要<strong class="kv hv">创建一个数组变量</strong>包含游戏中存在的所有火箭(我们不知道有多少在舞台上):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="a4ee" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><em class="ls"> _list </em>变量位于类之外，因为它是静态的，这意味着它的<strong class="kv hv">值是唯一的，并且不仅仅是一个对象的属性</strong>(不像<em class="ls">这个</em>)。然而，我们可以得到它，并根据我们的需要设置它(使用类的前2行)。</p><p id="ddd6" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">我们可以<strong class="kv hv">将当前对象推入这个列表</strong>(在构造函数内)并且<strong class="kv hv">同时声明</strong> <em class="ls">速度</em> <strong class="kv hv">变量</strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="49ec" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">…并且<strong class="kv hv">添加了</strong> <em class="ls">更新</em> <strong class="kv hv">方法</strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="16ce" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">这基本上和以前一样，我们<strong class="kv hv">更新火箭</strong>的<em class="ls"/><strong class="kv hv">x位置(而不是y位置，因为它不是垂直移动的)并且像云一样，当它超出屏幕限制</strong>时，我们<strong class="kv hv">移除它，除了这次是右边。</strong></p><p id="a752" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">之后，在<em class="ls"> main.js </em>的循环中，我们只需<strong class="kv hv">解析火箭列表</strong>和<strong class="kv hv">为每个元素调用</strong> <em class="ls">更新</em> <strong class="kv hv">函数:</strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="54c8" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">保存和重新加载，并尝试它！</p><p id="4b35" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">它在射击，但不是自动的。你必须按下每个火箭<strong class="kv hv"> </strong>的按键，当你不动的时候，这有点奇怪，因为它的发射速度非常快。我们想要的是能够在按键保持按下的情况下<strong class="kv hv">自动拍摄，速度可调。</strong></p><p id="79c0" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">让我们<strong class="kv hv">在</strong> <em class="ls">玩家</em> <strong class="kv hv">构造器</strong>中定义两个新变量:开火速度(可以修改)和冷却时间，这将是计时器值:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="11a7" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">我们还需要<strong class="kv hv">更新</strong> <em class="ls">按键状态</em>到<strong class="kv hv">添加空格键</strong>，因为我们想知道它是否被按下:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="9562" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">下面是我们用来拍摄的函数(需要在播放器的 <em class="ls">更新</em> <strong class="kv hv">中<strong class="kv hv">调用):</strong></strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="edb2" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">这里非常简单:<strong class="kv hv">我们只需将计时器从0增加到我们设定的射击速度</strong>，如果按键被按下，计时器已经达到该值，我们<strong class="kv hv">就会产生一个火箭，并将计时器重置为0。</strong></p><p id="c6e0" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">该功能在播放器的<em class="ls">更新</em>循环中永久执行:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="4b70" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">工作完成！如果你想让它更快，只要降低射击速度变量(并增加它为较慢的速度)。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mp"><img src="../Images/0edf4494ef5e985ab97eb4c830c48922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*43IY-GlgG93yqB87tBiDXg.gif"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Firing some rockets</figcaption></figure><h2 id="e1f2" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">下一个帖子:我们正在增加一些敌人！</h2><p id="1c2c" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">感谢您的阅读！</p><p id="9754" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><strong class="kv hv"> <em class="ls">如果有什么问题或者建议，请告诉我，我好改进下一条！</em> </strong></p></div></div>    
</body>
</html>