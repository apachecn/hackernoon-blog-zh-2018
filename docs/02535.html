<html>
<head>
<title>RESTful API with Spark Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Spark Kotlin的RESTful API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/restful-api-with-spark-kotlin-f43bd57affc4?source=collection_archive---------6-----------------------#2018-03-21">https://medium.com/hackernoon/restful-api-with-spark-kotlin-f43bd57affc4?source=collection_archive---------6-----------------------#2018-03-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/7ac53a218378bc5313706757be7849aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X1uWde7ezIWsJefD."/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/@stephaniemccabe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephanie McCabe</a> on <a class="ae ih" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="d84b" class="pw-subtitle-paragraph jh ij ik bd b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ek translated">构建API的非主流方式</h2></div><p id="1a9d" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">说到构建后端API，最常用的工具要么是Java的Spring Boot，要么是JavaScript的ExpressJS。即使对于科特林，Spring Boot和JetBrain自己的ktor也是通常的选择。但是今天我将探索spark-kotlin这个不太受欢迎的选项。</p><p id="7fb0" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">免责声明:我无论如何都不属于这个项目，也不在这个项目中工作。我只是偶然发现了它，并在做副业时开始使用它。(即将推出</em><strong class="kb il"/><em class="kv">)</em></p><h1 id="814b" class="kw kx ik bd ky kz la lb lc ld le lf lg jq lh jr li jt lj ju lk jw ll jx lm ln dt translated">理解休息</h1><p id="2ae8" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">如果你已经知道或者构建了一个RESTful API，你可以跳过这一部分。已经有相当多的指南详细介绍了什么是休息，以及所有令人惊奇的事情。因此，相反，我将只涉及基本的(更像是，这就是我所知道的)。这是通过HTTP在互联网上进行通信的标准方式。在互联网的世界里，前端web界面需要一种与后端通信的方式。虽然前端可以说各种各样的事情，但他们仍然需要在他们之间声明一组标准的“短语”,以便后端知道前端在要求什么。</p><h1 id="51ca" class="kw kx ik bd ky kz la lb lc ld le lf lg jq lh jr li jt lj ju lk jw ll jx lm ln dt translated">安装</h1><p id="ef68" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在开始之前，您可能需要安装以下几样东西:</p><ul class=""><li id="d1df" class="lt lu ik kb b kc kd kf kg ki lv km lw kq lx ku ly lz ma mb dt translated">玛文/格拉德勒</li><li id="bffd" class="lt lu ik kb b kc mc kf md ki me km mf kq mg ku ly lz ma mb dt translated">科特林</li><li id="6323" class="lt lu ik kb b kc mc kf md ki me km mf kq mg ku ly lz ma mb dt translated">Java？(不太确定，但你可能需要它)</li><li id="66d0" class="lt lu ik kb b kc mc kf md ki me km mf kq mg ku ly lz ma mb dt translated">(可选)IntelliJ</li></ul><h1 id="1b21" class="kw kx ik bd ky kz la lb lc ld le lf lg jq lh jr li jt lj ju lk jw ll jx lm ln dt translated">入门指南</h1><p id="100e" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">根据spark-kotlin 的官方GitHub repo<a class="ae ih" href="https://github.com/perwendel/spark-kotlin" rel="noopener ugc nofollow" target="_blank">显示，以下内容可用于Maven或Gradle。就我个人而言，我使用Gradle只是因为我从未在Android开发之外使用过它。(而且，这是新的性感事物。算是吧。)</a></p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><pre class="mh mi mj mk fq mn mo mp mq aw mr dt"><span id="19c9" class="ms kx ik mo b fv mt mu l mv mw"><strong class="mo il">dependencies {<br/>    ...<br/>    compile</strong> "com.sparkjava:spark-kotlin:1.0.0-alpha"<br/>    ...<br/>}</span></pre><h1 id="f2fd" class="kw kx ik bd ky kz la lb lc ld le lf lg jq lh jr li jt lj ju lk jw ll jx lm ln dt translated">基础知识</h1><p id="e6ea" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">这就是吸引我在弹簧靴上使用它的原因。相比之下，它看起来简单明了多了。不可否认，我从未在服务器开发中使用过spring-boot，所以我可能完全错了，尤其是当它涉及到大规模应用时。</p><h2 id="3ba3" class="ms kx ik bd ky mx my mz lc na nb nc lg ki nd ne li km nf ng lk kq nh ni lm nj dt translated">获取请求</h2><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="091a" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">就是这样！我可以在这里结束这篇文章，你可以自己想出剩下的部分。但是，让我们探索一些更有趣的特性。</p><h2 id="1cc6" class="ms kx ik bd ky mx my mz lc na nb nc lg ki nd ne li km nf ng lk kq nh ni lm nj dt translated">发布请求</h2><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="6d62" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">对于帖子请求，他们工作起来也一样轻松！您需要知道的是，可以用<code class="eh nk nl nm mo b">request.body()</code>检索请求体。</p><h1 id="3e3e" class="kw kx ik bd ky kz la lb lc ld le lf lg jq lh jr li jt lj ju lk jw ll jx lm ln dt translated">更多有趣的东西</h1><h2 id="880f" class="ms kx ik bd ky mx my mz lc na nb nc lg ki nd ne li km nf ng lk kq nh ni lm nj dt translated">重定向()，参数()</h2><p id="3c2b" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">现在，如果您希望不同的链接有相同的输出呢？嗯，你可以只做<code class="eh nk nl nm mo b">redirect("/path")</code>。你也可以通过<code class="eh nk nl nm mo b">params(":path")</code>标签从网址获取信息。类似这样的…</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><h2 id="755b" class="ms kx ik bd ky mx my mz lc na nb nc lg ki nd ne li km nf ng lk kq nh ni lm nj dt translated">实例API</h2><p id="ca63" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">您还可以拥有一个单独的实例API，它运行在不同的端口上，或者具有与静态API不同的设置，只需将它声明为一个单独的变量。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="8665" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当然，还有很多更高级的特性(比如会话、uri等。)这一点我没有涉及。请按照回购的<a class="ae ih" href="https://github.com/perwendel/spark-kotlin/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件自行探索。</a></p></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><p id="e63a" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">从现在开始，我会在上面加入一些相关但不完全是spark-kotlin的东西。</p><h1 id="3b3e" class="kw kx ik bd ky kz la lb lc ld le lf lg jq lh jr li jt lj ju lk jw ll jx lm ln dt translated">处理JSON</h1><p id="10f4" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在许多(或大多数)场合，请求和响应都是JSON格式的。这就是<a class="nu nv gr" href="https://medium.com/u/991272e72e68?source=post_page-----f43bd57affc4--------------------------------" rel="noopener" target="_blank">谷歌开发者</a>’<a class="ae ih" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank">Gson库</a>派上用场的地方。它真的很容易使用，并得到了广泛的支持。我在下面放了一个简单的例子来展示它是如何被使用的。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="0d79" class="kw kx ik bd ky kz la lb lc ld le lf lg jq lh jr li jt lj ju lk jw ll jx lm ln dt translated">单元测试</h1><p id="2e53" class="pw-post-body-paragraph jz ka ik kb b kc lo jl ke kf lp jo kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">我花了一段时间才找到一个像我希望的那样简单的测试库。这是由<a class="ae ih" href="https://www.despegar.com" rel="noopener ugc nofollow" target="_blank"> Despegar </a>专门为spark框架制作的测试库，名为<a class="ae ih" href="https://github.com/despegar/spark-test" rel="noopener ugc nofollow" target="_blank"> spark-test </a>。</p><figure class="mh mi mj mk fq hw"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="8013" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">不过，有几件事要记住:</p><ul class=""><li id="1ec4" class="lt lu ik kb b kc kd kf kg ki lv km lw kq lx ku ly lz ma mb dt translated">这是为<a class="ae ih" href="https://github.com/perwendel/spark" rel="noopener ugc nofollow" target="_blank"> spark-java </a>而不是<a class="ae ih" href="https://github.com/perwendel/spark-kotlin" rel="noopener ugc nofollow" target="_blank"> spark-kotlin </a>制作的Java库</li><li id="c87d" class="lt lu ik kb b kc mc kf md ki me km mf kq mg ku ly lz ma mb dt translated">服务器需要在后台运行(在我的例子中，在端口4567上)才能工作</li><li id="8789" class="lt lu ik kb b kc mc kf md ki me km mf kq mg ku ly lz ma mb dt translated">无法为删除请求附加请求正文</li></ul><p id="3375" class="pw-post-body-paragraph jz ka ik kb b kc kd jl ke kf kg jo kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">注意:正如在撰写本文时所提到的，删除请求无法附加任何类型的请求主体，这使得很难测试您的删除请求。就我个人而言，我对每个特性使用不同的url，所以我只是将一个POST请求从同一个URL重定向到DELETE请求，并通过POST请求测试它。不理想，但目前有效。</em></p></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><h1 id="8e86" class="kw kx ik bd ky kz nw lb lc ld nx lf lg jq ny jr li jt nz ju lk jw oa jx lm ln dt translated">参考</h1><ul class=""><li id="a0bd" class="lt lu ik kb b kc lo kf lp ki ob km oc kq od ku ly lz ma mb dt translated"><a class="ae ih" rel="noopener" href="/@codemwnci/kotlin-webapp-tutorial-todolist-part-1-c544b9a70f29">科特林WebApp教程</a>作者<a class="nu nv gr" href="https://medium.com/u/6f0e89485e0d?source=post_page-----f43bd57affc4--------------------------------" rel="noopener" target="_blank">韦恩埃利斯</a></li><li id="b65a" class="lt lu ik kb b kc mc kf md ki me km mf kq mg ku ly lz ma mb dt translated"><a class="ae ih" rel="noopener" href="/@v.souhrada/build-rest-service-with-kotlin-spark-java-and-requery-part-1-1798844fdf04">由<a class="nu nv gr" href="https://medium.com/u/3f2747b2fdec?source=post_page-----f43bd57affc4--------------------------------" rel="noopener" target="_blank">瓦茨拉夫·苏赫拉达</a>用Kotlin、Spark Java和Requery </a>构建REST服务</li></ul></div></div>    
</body>
</html>