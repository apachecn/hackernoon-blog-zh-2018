<html>
<head>
<title>React Conditional Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应条件渲染</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/conditional-rendering-on-react-57a864c2d04d?source=collection_archive---------1-----------------------#2018-03-22">https://medium.com/hackernoon/conditional-rendering-on-react-57a864c2d04d?source=collection_archive---------1-----------------------#2018-03-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/4c18b4a818adbf27b834b281382a9a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vitRNIHGSAbLJ7dfCXDOdQ.png"/></div></div></figure><div class=""/><p id="19f6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们开发一个React应用程序时，我们经常需要在给定的条件下显示或隐藏一个元素。无论是用户交互，还是来自请求的数据，甚至是权限级别。这被称为条件渲染，我们将看看处理这些情况的不同方法。</p><h1 id="e9a3" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">如果</h1><p id="e39c" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">IF是所有方法中最基本的，也可能是你最常看到的，但是它仅限于组件的总块。在条件中使用IF，并返回要呈现的元素。观察下面的例子:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="3951" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面我们有一个用户列表，他们接收<code class="eh lj lk ll lm b">isLoading</code>道具和<code class="eh lj lk ll lm b">results</code>。如果<code class="eh lj lk ll lm b">isLoading</code>为真，我们返回一条消息说明它正在加载，否则，我们呈现用户列表。</p><blockquote class="ln lo lp"><p id="341b" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">注意我们<strong class="je ig">不使用</strong>ELSE<strong class="je ig">因为没有必要，因为我们在第一个<strong class="je ig"> IF </strong>内使用<strong class="je ig"> return </strong>。不要害怕在每个函数中使用不止一个<strong class="je ig"> return </strong>，这种做法将有助于降低代码的复杂性。</strong></p></blockquote><p id="d667" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的例子没有错，恰恰相反，代码简单易读。然而，正如我提到的，这种方法仅限于渲染整个块，在许多情况下，我们不能使用它。</p><p id="a746" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们的用户列表更加复杂，它有一个标题和一个创建新用户的按钮。在这种情况下，页面应该总是显示标题和按钮。加载消息只会出现在列表中的位置，如下所示:</p><figure class="ld le lf lg fq hw fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/f699e4cde7f31f4e4cb0fa16ee4ba291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*urlZK7IVsyMj9VblOxbqkw.png"/></div></figure><p id="3680" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到上面的图片，我们不能使用<strong class="je ig"> IF </strong>，因为我们需要重复整个代码块来改变列表的内容。</p><p id="55e1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这些情况，我们可以在我们的<em class="lq"> JSX </em>中使用<code class="eh lj lk ll lm b">&amp;&amp;</code>逻辑运算符来编写一个表达式，如下例所示:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="908a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如上例所示，我们可以使用大括号(<code class="eh lj lk ll lm b">{}</code>)在<em class="lq"> JSX </em>中插入一个<em class="lq"> JS </em>表达式。React将获得每个表达式的结果，并将呈现在屏幕上。当一个表达式返回一个<code class="eh lj lk ll lm b">Boolean</code>、<code class="eh lj lk ll lm b">undefined</code>或<code class="eh lj lk ll lm b">null</code>、<em class="lq">反应</em>只是忽略，不渲染任何东西！</p><blockquote class="ln lo lp"><p id="330e" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">反应本机将<strong class="je ig">而不是</strong>忽略<code class="eh lj lk ll lm b">undefined</code>并且你以一个运行时错误结束。如果您在web环境之外使用React，那么应该将值转换为布尔值。</p></blockquote><h2 id="4426" class="lv kb if bd kc lw lx ly kg lz ma mb kk jn mc md ko jr me mf ks jv mg mh kw mi dt translated">理解表达</h2><p id="6ec4" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">当我们使用逻辑运算符<code class="eh lj lk ll lm b">&amp;&amp;</code>时，JS将解释表达式的每个值，直到它到达最后一个值，或者某些求值以一个<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank"> <em class="lq">假值</em> </a>结束。在任何情况下，最后解释的值将是表达式的结果。示例:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="0532" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如上例所示，从第7行开始，解释第一个元素<code class="eh lj lk ll lm b">user</code>。由于是一个<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank"> <em class="lq">真值</em> </a>，光标传递到第二个元素，也就是<code class="eh lj lk ll lm b">user.name</code>。由于这是最后一个被解释的元素，表达式的结果将是第二个元素的值:<code class="eh lj lk ll lm b">'John'</code>。</p><p id="d54c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh lj lk ll lm b">address</code>的情况下，第一个元素<code class="eh lj lk ll lm b">user</code>被解释并标识为<em class="lq">真值</em>，然后光标转到第二个元素<code class="eh lj lk ll lm b">user.address</code>，在这种情况下，第二个元素的值为<code class="eh lj lk ll lm b">null</code>。因为我们没有更多的元素，并且最后解释的值是<code class="eh lj lk ll lm b">null</code>，所以这成为表达式的结果。</p><p id="6d12" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，在<code class="eh lj lk ll lm b">zipCode</code>的情况下，发生与<code class="eh lj lk ll lm b">address</code>相同的过程。它解释第一个，然后传递给第二个。然而，由于第二个元素是<em class="lq"> falsy </em>，光标完成了表达式的执行，并一如既往地采用最后解释的值，在本例中为:<code class="eh lj lk ll lm b">null</code>。</p><p id="e08c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理解表达式是如何工作的很重要，因为有时你可能期望结果是<code class="eh lj lk ll lm b">false</code>，然后你得到<code class="eh lj lk ll lm b">null</code>或<code class="eh lj lk ll lm b">0</code>。</p><h2 id="cdd5" class="lv kb if bd kc lw lx ly kg lz ma mb kk jn mc md ko jr me mf ks jv mg mh kw mi dt translated">可读性</h2><p id="003f" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">因为我们在<em class="lq"> JSX </em>中包含了逻辑，所以我们必须小心维护代码的可读性。因此，对于包含两个以上项的表达式，创建一个变量来抽象验证项是很有趣的。一个例子:</p><pre class="ld le lf lg fq mk lm ml mm aw mn dt"><span id="fb4e" class="lv kb if lm b fv mo mp l mq mr">{!isLoading &amp;&amp; !results.length &amp;&amp; (<br/>  &lt;span&gt;<strong class="lm ig">NO RESULTS FOUND</strong>&lt;/span&gt;<br/>)}</span><span id="11ef" class="lv kb if lm b fv ms mp l mq mr">// VS</span><span id="a755" class="lv kb if lm b fv ms mp l mq mr">const shouldDisplayNotFound = !isLoading &amp;&amp; !results.length;</span><span id="e4cd" class="lv kb if lm b fv ms mp l mq mr">{shouldDisplayNotFound &amp;&amp; (<br/>  &lt;span&gt;<strong class="lm ig">NO RESULTS FOUND</strong>&lt;/span&gt;<br/>)}</span></pre><p id="6ae8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的例子只是为了理解这个概念，我知道我们没有清楚地看到一种方法对另一种方法的优势。这是因为我们面前有一小块代码。但是在下面，我们将以一种更实际的方式看到同样的应用概念。</p><p id="4427" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设对于我们的用户列表，当没有找到记录时，我们需要显示一条消息。但是，我们只能在结果加载后显示此消息。这样我们就可以通过<code class="eh lj lk ll lm b">results.length</code>查看结果的数量。下面，我们将看到不使用变量时这个逻辑是什么样子。</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="a64b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面我们看到，在<em class="lq"> JSX </em>中间，逻辑开始变得有点复杂，但我们仍然可以理解它。基本上，在所有检查中，我们需要考虑<code class="eh lj lk ll lm b">isLoading</code>，以确保列表被加载，然后基于<code class="eh lj lk ll lm b">results.length</code>来判断是否有结果。</p><blockquote class="ln lo lp"><p id="81f5" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">注意，为了显示列表，我们检查了长度是否大于<code class="eh lj lk ll lm b">0</code>。还记得表达式的值是如何解释的，以及表达式的结果是如何获得的吗？如果我们只是检查长度是否真实，写下<code class="eh lj lk ll lm b">results.length &amp;&amp;</code>，如果是<code class="eh lj lk ll lm b">0</code>，这将是表达式的结果，然后React将在屏幕上打印<code class="eh lj lk ll lm b">0</code>。</p></blockquote><p id="a022" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到前面的例子，现在想象一下，除了处理没有结果的状态，如果请求中有错误，您还需要显示不同的消息。注意代码看起来像什么:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="1401" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，复杂性开始变得越来越大，理解发生了什么变得越来越困难。让我们探索简化代码的方法吧！</p><h1 id="09ba" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">将验证转换为变量</h1><p id="1356" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">如上所述，可以从引用验证的每个表达式中提取一部分，并将其提取到具有声明性名称的变量中。这样，我们的逻辑会变得更清晰一点。请注意下面的代码:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="511d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以看到，从<em class="lq"> JSX </em>的中间提取逻辑，有可能更容易理解它，此外变量名已经明确了表达式所代表的内容。任何将来维护代码的人都可以毫无顾虑地更改验证。</p><h1 id="4e0e" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">块的提取</h1><p id="729c" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">请注意，在我们的示例中，大多数验证都集中在单个块上。因此，我们可以将正在讨论的块提取到一个函数中，或者将其转换为另一个组件，如下例所示:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="2053" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">观察我们所有的逻辑是如何通过将块提取到另一个组件而变得更简单的。还可以看到，我们在返回时再次使用了<strong class="je ig">if</strong>的方法。这种方法也称为提前返回。当我们使用<em class="lq">早期返回</em>时，我们的逻辑往往更简单，因为下一个验证不必担心上一个。例如:检查它是否正在加载，我不必担心是否发生了错误，因为这种情况已经在之前的<strong class="je ig"> IF </strong>中处理过了。</p><h1 id="48d0" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">三元组的使用</h1><p id="15da" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在给定一定条件下两个块交替的情况下，Ternaries也是受欢迎的。请注意用户创建表单下面的模型:</p><figure class="ld le lf lg fq hw fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/2cc661e8cc56ceb8e8255d41326a08ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*H6stD5AbpDZvhMxx_L-qbw.jpeg"/></div></figure><p id="c955" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如上图所示，我们有字段:姓名、电子邮件、国家和一个为省字段保留的位置。“省”字段要求您首先选择一个国家。一旦选择了国家，根据下面的代码，状态字段将出现在屏幕上:</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><blockquote class="ln lo lp"><p id="c147" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">让我们不要进入<code class="eh lj lk ll lm b">onChange</code>或者进入保存状态的逻辑，只是假设<code class="eh lj lk ll lm b">values</code>将总是具有表单字段的更新值。</p></blockquote><p id="143f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于值，我们编写一个三元组来显示<code class="eh lj lk ll lm b">ProvinceSelector</code>，如果<code class="eh lj lk ll lm b">country</code>值存在，否则，我们将显示消息。三元很有用，但并不是在哪里都适用。我会避免使用它来呈现大块的代码，在某些情况下会使它难以阅读。</p><h1 id="780a" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">使用处理程序</h1><p id="d1f8" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">处理程序也用于特定的情况。当您需要将不同的内容呈现给同一个块时，它们都基于给定的值。</p><p id="861f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您正在开发一个用于呈现数据的通用组件。每个数据都有一种类型，可以是<code class="eh lj lk ll lm b">date</code>、<code class="eh lj lk ll lm b">number</code>、<code class="eh lj lk ll lm b">currency</code>等。对于每种类型，您需要指定不同的格式/样式。对于这种情况，我们可以使用处理程序。</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="71b5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">处理程序只不过是一个键值对象，其中<strong class="je ig">键</strong>是上下文中每个处理程序的唯一标识符，而<strong class="je ig">值</strong>是一个负责呈现特定块的函数。</p><p id="4bd5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，每个处理程序接收<code class="eh lj lk ll lm b">value</code>参数，但是您可以根据需要接收任意多的参数，因为处理程序的执行逻辑是由您实现的。</p><p id="ffed" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，在<code class="eh lj lk ll lm b">displayData</code>函数中，我们得到一个<code class="eh lj lk ll lm b">type</code>和一个<code class="eh lj lk ll lm b">value</code>作为参数。在第10行，我们根据<code class="eh lj lk ll lm b">type</code>将其中一个处理程序分配给<code class="eh lj lk ll lm b">const</code>处理程序，或者使用<a class="ae mj" href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Operators/Operadores_Logicos#Short-Circuit_Evaluation" rel="noopener ugc nofollow" target="_blank">短路</a>评估来分配默认处理程序。</p><blockquote class="ln lo lp"><p id="d742" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">短路评估往往比开关情况执行得更好，因为它只评估值的存在。</p></blockquote><p id="6e39" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在第11行，我们执行传递值的处理程序，并返回结果。</p><p id="7ed6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们在我们的<code class="eh lj lk ll lm b">DataDisplay</code>组件中执行<code class="eh lj lk ll lm b">displayData</code>函数，传递<code class="eh lj lk ll lm b">type</code>和<code class="eh lj lk ll lm b">value</code>。</p><p id="ec65" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用其他方法来解决这类问题，您的代码可能会变得混乱。相比之下，您可能会注意到，使用处理程序，上面的示例将很容易扩展，如果需要，可以根据类型呈现10、20甚至30种不同的数据类型。</p><h1 id="eac0" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="93c1" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">以上所有的方法在正确的情况下都是有效的，这取决于我们在适当的情况下使用被称为“良好感觉”的超能力。</p><p id="de8c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你呢，你有什么特别的方法想和我们分享吗？</p><p id="7f66" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你喜欢邮报吗？通过在社交网络上点赞和分享来帮助我们传播信息，让更多的人可以访问！❤️ ️</p><p id="8c58" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">别忘了关注我，我会通知你未来的帖子！✌</p><figure class="ld le lf lg fq hw"><div class="bz el l di"><div class="mt li l"/></div></figure></div></div>    
</body>
</html>