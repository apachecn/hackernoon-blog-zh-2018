<html>
<head>
<title>Real time communication with Webrtc on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android上与Webrtc进行实时通信</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/real-time-communication-with-webrtc-on-android-f96cdcfc4771?source=collection_archive---------3-----------------------#2018-03-22">https://medium.com/hackernoon/real-time-communication-with-webrtc-on-android-f96cdcfc4771?source=collection_archive---------3-----------------------#2018-03-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="2b7e" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">WebRTC是一个免费的开放项目，它通过简单的API为浏览器和移动应用程序提供实时通信(RTC)功能。</p></blockquote><p id="bd88" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">Webrtc是一个具有rtc功能的跨平台解决方案。人们可以通过webrtc将自己的视频流从摄像机或屏幕录制或任何其他视频传输到任何对等方。如果一个人正在开发一个实时的对等游戏，在对等点之间实时共享数据，webrtc是一个选择。让我们了解一下在webrtc中从一个对等体到另一个对等体的视频呼叫是如何工作的。</p><h1 id="39bc" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">入门指南</h1><p id="63f1" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">自2017年9月以来，谷歌开始通过maven为android分发预编译版本的webrtc。如果你想摆弄源代码并自己编译，你可以按照<a class="ae kz" href="https://webrtc.org/native-code/development/" rel="noopener ugc nofollow" target="_blank">的步骤</a>轻松完成(以前你只能在linux上编译，但现在所有三大操作系统都支持)。要使用预编译版本，只需添加以下依赖项。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="51cb" class="lj jx hu lf b fv lk ll l lm ln">compile 'org.webrtc:google-webrtc:1.0.22379'</span></pre><h1 id="744c" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">webrtc是如何工作的？</h1><p id="bc96" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">在我们开始通过webrtc在两个对等体之间交换数据之前，我们需要向对等体提供关于彼此的信息，以便进行媒体格式协商和发现。这是通过以下协议完成的。<a class="ae kz" href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" rel="noopener ugc nofollow" target="_blank">交互连接建立(ICE) </a>用于对等连接。<a class="ae kz" href="http://en.wikipedia.org/wiki/Session_Description_Protocol" rel="noopener ugc nofollow" target="_blank">会话描述协议(SDP) </a>用于提供媒体内容的元数据，如分辨率、编码、比特率等。如果两个对等体不在同一个网络上，那么我们将需要为NAT (STUN) 服务器提供一个<a class="ae kz" href="http://en.wikipedia.org/wiki/STUN" rel="noopener ugc nofollow" target="_blank">会话遍历实用程序，以提供对等体的公共地址。如果任何网络是防火墙保护的，我们还需要使用NAT (TURN) </a>服务器周围的中继来提供<a class="ae kz" href="http://en.wikipedia.org/wiki/TURN" rel="noopener ugc nofollow" target="_blank">遍历。你可以在这里了解更多关于这些协议的信息。</a>对等体之间交换ICE和SDP的机制称为信令系统，通常通过websockets完成。</p><h1 id="cfa6" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">Webrtc android API</h1><p id="eb2d" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">我们的大部分webrtc代码将利用<em class="iw"> PeerConnection </em>和<em class="iw">peer connection factory</em>API。<a class="ae kz" href="http://dev.w3.org/2011/webrtc/editor/webrtc.html#peer-to-peer-connections" rel="noopener ugc nofollow" target="_blank"> <em class="iw">对等连接</em> </a> <em class="iw"> </em>相当于web世界中的RTCPeerConnection，用于建立对等连接。<em class="iw"> PeerConnectionFactory </em>用于创建<em class="iw"> PeerConnection、MediaStream </em>和<em class="iw"> MediaStreamTrack </em>对象<em class="iw">。</em></p><figure class="la lb lc ld fq lp fe ff paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="fe ff lo"><img src="../Images/5ae09538f25054bf39719da69663ddbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PU9cgm80KU1WZCEHdeYv7w.jpeg"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Signalling flow diagram for Webrtc (<a class="ae kz" href="https://mdn.mozillademos.org/files/12363/WebRTC%20-%20Signaling%20Diagram.svg" rel="noopener ugc nofollow" target="_blank">original photo</a> by <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$history" rel="noopener ugc nofollow" target="_blank">Mozilla Contributers </a>is licensed under <a class="ae kz" href="http://creativecommons.org/licenses/by-sa/2.5/" rel="noopener ugc nofollow" target="_blank">CC-BY-SA 2.5</a>.)</figcaption></figure><p id="f474" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">创建PeerConnectionFactory</em><br/>T22】在创建工厂对象之前我们需要初始化webrtc。正如你可以<em class="iw">初始化选项</em>这里提供了启用/禁用硬件加速(我不得不在某些设备上禁用)和设置现场试验的选项。<em class="iw">现场试验</em>是为了启用实验性的webrtc特性。</strong></p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="1146" class="lj jx hu lf b fv lk ll l lm ln">val fieldTrials = (PeerConnectionFactory.<em class="iw">VIDEO_FRAME_EMIT_TRIAL </em>+ "/" + PeerConnectionFactory.<em class="iw">TRIAL_ENABLED </em>+ "/")<br/>val options = InitializationOptions.builder(application)<br/>      .setFieldTrials(fieldTrials)<br/>      .setEnableVideoHwAcceleration(videoAccelerationEnabled)<br/>      .createInitializationOptions()<br/>PeerConnectionFactory.initialize(options)<br/>factory = PeerConnectionFactory(PeerConnectionFactory.Options())<br/>val rootEglBase = EglBase.create()<br/>factory?.setVideoHwAccelerationOptions(rootEglBase.<em class="iw">eglBaseContext</em>, rootEglBase.<em class="iw">eglBaseContext</em>)</span></pre><p id="7fbc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">创建媒体流</em> </strong> <em class="iw"> <br/> </em>一旦我们有了<em class="iw"> PeerConnectionFactory </em>对象，我们现在就可以创建一个<em class="iw"> MediaStream </em>对象<em class="iw"> </em>，它有<em class="iw">音频轨道</em>和<em class="iw">视频轨道</em>与之相关联。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="2439" class="lj jx hu lf b fv lk ll l lm ln">val localMediaStream = factory.createLocalMediaStream(MEDIA_ID)<br/>val audioSource = factory.createAudioSource(MediaConstraints())<br/>val audioTrack = factory.createAudioTrack(AUDIO_ID, audioSource)<br/>localMediaStream.addTrack(audioTrack)<br/><br/>videoCapturer = if (Build.VERSION.<em class="iw">SDK_INT </em>&gt; Build.VERSION_CODES.<em class="iw">LOLLIPOP</em>) {<br/>   createCameraCapturer(Camera2Enumerator(application))<br/>} else {<br/>   createCameraCapturer(Camera1Enumerator(videoAccelerationEnabled))<br/>}<br/>val videoTrack = factory.createVideoTrack("VideoTrack", factory.createVideoSource(videoCapturer))<br/>localMediaStream.addTrack(videoTrack)</span></pre><p id="4d5c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"><em class="iw">cameravideocapter</em></strong><br/>Webrtc为我们提供了一种非常简单的方式来使用<em class="iw"> Camera </em>和<em class="iw"> Camera2 </em> API，具体取决于支持。在受支持的设备上，我们可以使用这两种API中的任何一种</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="fa12" class="lj jx hu lf b fv lk ll l lm ln">private fun createCameraCapturer(enumerator: CameraEnumerator): CameraVideoCapturer? {<br/>   val deviceNames = enumerator.<em class="iw">deviceNames<br/></em>   for (deviceName in deviceNames) {<br/>      if (enumerator.isFrontFacing(deviceName)) {<br/>         val videoCapturer = enumerator.createCapturer(deviceName, null)<br/>         if (videoCapturer != null) {<br/>            return videoCapturer<br/>         }<br/>      }<br/>   }<br/><br/>   for (deviceName in deviceNames) {<br/>      if (!enumerator.isFrontFacing(deviceName)) {<br/>         Timber.d("Creating other camera capturer.")<br/>         val videoCapturer = enumerator.createCapturer(deviceName, null)<br/>         if (videoCapturer != null) {<br/>            return videoCapturer<br/>         }<br/>      }<br/>   }<br/>   return null<br/>}</span></pre><p id="5357" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"><em class="iw">SurfaceViewRenderer</em></strong><em class="iw"><br/></em>因为我们已经准备好本地<em class="iw"> MediaStream </em>了，我们需要在视图上渲染它，以便它对用户可见。<em class="iw"> SurfaceViewRenderer </em>是webrtc libray中的一个<em class="iw">视图</em>，它为我们渲染webrtc帧。我们可以直接在布局xml中添加它。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="88cb" class="lj jx hu lf b fv lk ll l lm ln">localViewRenderer.init(rootEglBase.getEglBaseContext(), null)<br/>localViewRenderer.setEnableHardwareScaler(true)<br/>localViewRenderer.setMirror(true)<br/>localViewRenderer.setScalingType(ScalingType.SCALE_ASPECT_FILL)<br/>val localVideoRenderer = VideoRenderer(localViewRenderer)<br/>videoTrack.addRenderer(localVideoRenderer)</span></pre><p id="b685" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"><em class="iw">peer connection</em></strong><br/>现在我们已经做好了传输的一切准备，该创建<em class="iw"> PeerConnection了。我们在工厂方法中传递一个PeerConnection#Observer实例，当ICE候选生成时(我们需要将它发送给另一个对等体)通知它。当远程<em class="iw">媒体流</em>可用时，观察者也会得到通知。我们将为它附加一个渲染器，就像本地<em class="iw">媒体流</em>一样。它还需要一个列表IceServer(STUN和TURN服务器),如果在本地网络上测试，该列表可以为空</em></p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="7816" class="lj jx hu lf b fv lk ll l lm ln">val peerConnectionObserver = object : PeerConnection.Observer {<br/>   override fun onIceCandidate(iceCandidate: IceCandidate) {<br/>      localIceCandidatesSource.onNext(iceCandidate)<br/>   }<br/>   override fun onAddStream(mediaStream: MediaStream) {<br/>       mediaStream.addRenderer(remoteRenderer)<br/>   }<br/>   ...<br/>}<br/>peerConnection = factory?.createPeerConnection(getIceServers(), peerConnectionObserver)</span></pre><blockquote class="ir is it"><p id="0119" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">注意:在观察者的onIceCandidate中，我们不应该将IceCandidate添加到对等连接(peer connection . addicecandidate(ice candidate ),直到我们拥有远程SDP</p></blockquote><p id="f8c5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"><em class="iw">create offer/create answer</em></strong><br/>一旦建立了对等连接，我们就需要发起视频通话。发起呼叫的对等体将<em class="iw">创建提议</em>并设置其本地SDP ( <em class="iw">对等体连接#setLocalSdp </em>)。当本地SDP被设置时，它将把该SDP发送到另一个对等体，该对等体将设置它的远程SDP ( <em class="iw">对等体连接#setRemoteSdp </em>)。一旦设置了远程sdp，它将<em class="iw">用该sdp创建应答</em>,并在创建asnwer时设置其本地sdp，并将本地SDP发送给创建提议的对等体。发起方对等体现在将设置其远程SDP。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="251d" class="lj jx hu lf b fv lk ll l lm ln">fun createOffer() {<br/>   peerConnection.createOffer(object : SdpObserver {<br/>       override fun onCreateSuccess(sdp: SessionDescription) {<br/>          setLocalSdp(sdp)<br/>       }<br/>       ...<br/>       }, getPeerConnectionConstraints())<br/>}<br/>fun setLocalSdp(sdp: SessionDescripton) {<br/>   peerConnection.setLocalDescription(object : SdpObserver {<br/>      override fun onSetSuccess() {<br/>         api.sendSdp(peerConnection.<em class="iw">localDescription</em>)<br/>         drainIceCandidates()<br/>      }<br/>      ...<br/>   }, sdp)<strong class="lf hv"><br/></strong>}</span><span id="5ba1" class="lj jx hu lf b fv ma ll l lm ln">fun onOffer(sdp: SessionDescription) {<br/>   peerConnection.setRemoteDescription(object : SdpObserver {<br/>      override fun onSetSuccess() {<br/>         createAnswer()<br/>      } <br/>   }, sdp)<br/>}</span><span id="855a" class="lj jx hu lf b fv ma ll l lm ln">fun createAnswer() {<br/>   peerConnection?.createAnswer(object : SdpObserver {<br/>      override fun onCreateSuccess(sdp: SessionDescription) {<br/>         setLocalSdp(sdp)<br/>      }<br/>   }, getPeerConnectionConstraints())<br/>}</span></pre><p id="10bf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"><em class="iw">Dispose/Clean up</em></strong><em class="iw"><br/></em>当对等体决定结束连接时，按照特定的顺序进行清理是非常重要的，因为C层会进行引用计数检查，如果没有正确处理对象，就会因断言失败而崩溃。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="e53b" class="lj jx hu lf b fv lk ll l lm ln">fun cleanUp() { <br/>    peerConnection.dispose()<br/>    viceoCapturer.dispose()<br/>    videoSource.dispose()<br/>    factory.dispose()<br/>    localVideoRenderer.dispose()<br/>    remoteRenderer.dispose()<br/>    localViewRenderer.release()<br/>    remoteViewRenderer.release()<br/>    rootEglBase.release()<br/>}</span></pre><p id="7d1b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">接下来的<br/> </strong>使用<a class="ae kz" href="https://ktor.io" rel="noopener ugc nofollow" target="_blank"> ktor.io </a>和webrtc的视频过滤器实现webrtc的基本套接字。</p><h1 id="f39b" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">参考</h1><ul class=""><li id="e119" class="mb mc hu ix b iy ku jc kv jt md ju me jv mf js mg mh mi mj dt translated"><a class="ae kz" href="https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/" rel="noopener ugc nofollow" target="_blank">https://tech . appear . in/2015/05/25/Introduction-to-WebRTC-on-Android/</a></li><li id="d229" class="mb mc hu ix b iy mk jc ml jt mm ju mn jv mo js mg mh mi mj dt translated"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/WebRTC _ API/Signaling _ and _ video _ calling</a></li></ul></div></div>    
</body>
</html>