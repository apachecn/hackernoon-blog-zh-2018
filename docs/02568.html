<html>
<head>
<title>Running a scalable &amp; reliable GraphQL endpoint with Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无服务器运行可扩展且可靠的GraphQL端点</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/running-a-scalable-reliable-graphql-endpoint-with-serverless-db16e42dc266?source=collection_archive---------6-----------------------#2018-03-22">https://medium.com/hackernoon/running-a-scalable-reliable-graphql-endpoint-with-serverless-db16e42dc266?source=collection_archive---------6-----------------------#2018-03-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9d33" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">第3部分:AppSync前端:AWS托管的GraphQL服务</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/0d92436a2212f6ef911ea412db043f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1KwFeH3ahexWaHVFIFuow.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">AWS AppSync architecture</figcaption></figure><blockquote class="jz ka kb"><p id="2126" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">第1部分</strong> : <a class="ae kz" href="https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless/" rel="noopener ugc nofollow" target="_blank">简介:带API网关的GraphQL端点+ AWS Lambda </a> <br/> <strong class="kf hv">第2部分</strong> : <a class="ae kz" href="https://hackernoon.com/running-a-scalable-reliable-graphql-endpoint-with-serverless-24c3bb5acb43" rel="noopener ugc nofollow" target="_blank"> AppSync后端:AWS托管GraphQL服务</a> <br/> <strong class="kf hv">第3部分</strong> : AppSync前端:AWS托管GraphQL服务(本帖)<br/> <strong class="kf hv">第4部分</strong> : <a class="ae kz" href="https://hackernoon.com/serverless-appsync-plugin-top-10-new-features-3faaf6789480" rel="noopener ugc nofollow" target="_blank">无服务器AppSync插件:新特性</a>(最新！！！)</p></blockquote><blockquote class="la"><p id="63ab" class="lb lc hu bd ld le lf lg lh li lj ky ek translated"><em class="lk"> " </em> AWS AppSync是一个完全托管的无服务器GraphQL服务，提供实时数据查询、同步、通信和离线编程功能。<em class="lk">”—第二部分</em></p></blockquote><h1 id="29af" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja lw jb lx jd ly je lz jg ma jh mb mc dt translated">介绍</h1><p id="7a42" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated">在本帖中，我们将学习如何使用<strong class="kf hv"> ReactJS </strong>和<strong class="kf hv"> AWS AppSync </strong>构建迷你Twitter应用的客户端组件。具体而言，我将重点介绍:</p><ul class=""><li id="a98f" class="ml mm hu kf b kg kh kj kk mf mn mh mo mj mp ky mq mr ms mt dt translated"><em class="ke">通过AWS Amplify进行用户认证</em>。</li><li id="d682" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><em class="ke">迷你推特应用组件</em>。</li><li id="b8c3" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><em class="ke"> GraphQL订阅</em>。</li><li id="7d24" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><em class="ke"> GraphQL突变与</em> <em class="ke">乐观UI和离线支持。</em></li><li id="f47a" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><em class="ke">使用Netlify和S3的无服务器客户端部署</em><em class="ke"/>。</li></ul><p id="f4ea" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">我们开始吧！🏃</p><blockquote class="jz ka kb"><p id="7fdf" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">注1: </strong>在<a class="ae kz" href="https://hackernoon.com/running-a-scalable-reliable-graphql-endpoint-with-serverless-24c3bb5acb43" rel="noopener ugc nofollow" target="_blank">第二部分</a>中，我们已经使用AWS AppSync、DynamoDB、ElasticSearch和AWS Lambda创建了迷你Twitter应用的后端GraphQL API。我们还使用新的<a class="ae kz" href="https://github.com/sid88in/serverless-appsync-plugin" rel="noopener ugc nofollow" target="_blank">server less-app sync-plugin</a>部署了API。</p><p id="c30d" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">注2: </strong>您可以使用<code class="eh mz na nb nc b">yarn start.</code>在<a class="ae kz" href="https://github.com/serverless/serverless-graphql/blob/master/app-client/appsync-client/src/App.js" rel="noopener ugc nofollow" target="_blank"> serverless-graphql </a>存储库中快速开始使用此应用程序，请确保配置设置正确。</p><p id="fdb3" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">注3: </strong> AppSync客户端也有针对原生iOS、web和React Native的SDK，但在本文中，我们将使用<a class="ae kz" href="https://github.com/awslabs/aws-mobile-appsync-sdk-js" rel="noopener ugc nofollow" target="_blank"> JS SDK </a>构建React JS应用。</p></blockquote><h1 id="363f" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">AppSync客户端+ AWS放大器</h1><p id="e7d8" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated"><a class="ae kz" href="https://hackernoon.com/tagged/appsync" rel="noopener ugc nofollow" target="_blank"> AppSync </a>客户端使用<a class="ae kz" href="https://dev-blog.apollodata.com/aws-appsync-powered-by-apollo-df61eb706183" rel="noopener ugc nofollow" target="_blank"> Apollo Client 2.0 </a>在幕后简化用户认证，管理离线逻辑，支持<a class="ae kz" href="https://hackernoon.com/tagged/real-time" rel="noopener ugc nofollow" target="_blank">实时</a>订阅。</p><p id="efed" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">另一方面，您可以使用带有<a class="ae kz" href="https://github.com/aws/aws-amplify" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>的AppSync客户端来简化应用程序中的用户认证工作流🔑。AppSync使用API密钥、Cognito用户池或AWS IAM策略提供身份验证，AWS Amplify使用<a class="ae kz" href="https://aws.github.io/aws-amplify/api/classes/authclass.html" rel="noopener ugc nofollow" target="_blank"> Auth Class </a>中提供的方法对<em class="ke">用户注册、登录、密码确认和注销进行补充。</em></p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="1c94" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">import </strong>Amplify, { Auth } <strong class="nc hv">from 'aws-amplify'</strong>;<br/><strong class="nc hv">import </strong>{ <em class="ke">withAuthenticator </em>} <strong class="nc hv">from 'aws-amplify-react/dist/Auth'</strong>;<br/><strong class="nc hv">import </strong>AWSAppSyncClient <strong class="nc hv">from 'aws-appsync'</strong>;<br/><strong class="nc hv">import </strong>{ ApolloProvider } <strong class="nc hv">from 'react-apollo'</strong>;</span><span id="0f96" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">const </strong>client = <strong class="nc hv">new </strong>AWSAppSyncClient({<br/>  <strong class="nc hv">url</strong>: 'https://xxxx.appsync-api.us-east-1.amazonaws.com/graphql',<br/>  <strong class="nc hv">region</strong>: 'us-east-1',<br/>  <strong class="nc hv">auth</strong>: {</span><span id="d199" class="nk lm hu nc b fv np nm l nn no">    // AWS Cognito User Pool<br/>    <strong class="nc hv">type</strong>: <strong class="nc hv">AUTH_TYPE</strong>.<strong class="nc hv">AMAZON_COGNITO_USER_POOLS</strong>,<br/>    jwtToken: <strong class="nc hv">async </strong>() =&gt;<br/>      (<strong class="nc hv">await </strong>Auth.currentSession()).getIdToken().getJwtToken(),<br/>    <br/>    // API KEY<br/>    <strong class="nc hv">type</strong>: <strong class="nc hv">AUTH_TYPE</strong>.<strong class="nc hv">API_KEY</strong>,<br/>    apiKey: 'xxxxxxxxxxxxx',</span><span id="9cc7" class="nk lm hu nc b fv np nm l nn no">    // AWS IAM<br/>    <strong class="nc hv">type: AUTH_TYPE.AWS_IAM</strong><br/>    credentials: () =&gt; Auth.currentCredentials(),</span><span id="46d3" class="nk lm hu nc b fv np nm l nn no">   },<br/>});</span><span id="bafa" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">const </strong><em class="ke">WithProvider </em>= () =&gt; (<br/>  &lt;<strong class="nc hv">Router</strong>&gt;<br/>    &lt;<strong class="nc hv">ApolloProvider client=</strong>{client}&gt;<br/>  &lt;/<strong class="nc hv">Router</strong>&gt;<br/>);</span><span id="88d4" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">export default </strong><em class="ke">withAuthenticator</em>(<em class="ke">WithProvider</em>);</span></pre><p id="59c1" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">如上面的<code class="eh mz na nb nc b">App.js</code>代码所示，向应用程序添加身份验证就像用<code class="eh mz na nb nc b">withAuthenticator</code>高阶组件包装应用程序的主组件一样简单。您可以使用AWS的<code class="eh mz na nb nc b"><em class="ke">aws-appsync-react</em></code>和<code class="eh mz na nb nc b"><em class="ke">aws-amplify-react</em></code> <em class="ke"> </em>包进行所有这些集成。</p><blockquote class="jz ka kb"><p id="c52e" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">注意:</strong>对于这个演示，我使用AWS Cognito用户池进行用户认证，并在Cognito中创建了两个测试用户(sidg_sid和nikgraf)。一旦用户登录，他们的会话就会被Amplify保存在<code class="eh mz na nb nc b">localStorage</code>中。所以用户可以离开页面，回来，仍然登录！你可以在<a class="nq nr gr" href="https://medium.com/u/695782484bda?source=post_page-----db16e42dc266--------------------------------" rel="noopener" target="_blank"> Nader Dabit </a>的<a class="ae kz" href="https://hackernoon.com/react-authentication-in-depth-4deebda9aa45" rel="noopener ugc nofollow" target="_blank">这个帖子</a>中找到更多细节。</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ns"><img src="../Images/793f9493f255cfa062abb751799963fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RAaDClm7sIgqNfLkNoq6Sg.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">User Authentication with AWS AppSync + AWS Amplify + AWS Cognito</figcaption></figure><h1 id="731b" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">迷你Twitter应用组件</h1><p id="9693" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated">现在，激动人心的事情开始了！💃</p><p id="b495" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">这个应用的基本结构是使用<code class="eh mz na nb nc b"><a class="ae kz" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code>创建的。此外，我们正在使用<code class="eh mz na nb nc b"><a class="ae kz" href="https://github.com/styled-components/styled-components" rel="noopener ugc nofollow" target="_blank">styled-components</a></code>使我们的应用程序看起来很花哨💅下面给出了该应用程序的五个主要组件。</p><ul class=""><li id="b693" class="ml mm hu kf b kg kh kj kk mf mn mh mo mj mp ky mq mr ms mt dt translated"><strong class="kf hv"> <em class="ke"> UserLogin </em> </strong>:用户可以从本App <em class="ke">(上一节)登录或注销。</em></li><li id="0bc1" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><strong class="kf hv"> <em class="ke"> ProfileInfo </em> </strong>:从DynamoDB中检索用户基本资料信息。</li><li id="97ba" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><strong class="kf hv"><em class="ke">profile Tweets</em></strong>:从ElasticSearch检索tweets列表。</li><li id="8c6b" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><strong class="kf hv"> <em class="ke"> TweetForm </em> </strong>:用户可以发送推文。</li><li id="85ed" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><strong class="kf hv"> <em class="ke"> TweetSearch </em> </strong>:用户可以通过关键词搜索所有tweets的语料库。</li></ul><p id="6e29" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">为了使这一切正常工作，我们利用了特定的GraphQL操作:</p><ul class=""><li id="0354" class="ml mm hu kf b kg kh kj kk mf mn mh mo mj mp ky mq mr ms mt dt translated"><strong class="kf hv"> <em class="ke">查询</em> </strong> —获取给定用户的个人资料信息和推文列表。</li><li id="370e" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><strong class="kf hv"> <em class="ke">突变</em> </strong> —为给定用户创建和删除推文。</li><li id="618f" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky mq mr ms mt dt translated"><strong class="kf hv"> <em class="ke">订阅</em> </strong> —给定用户的关注者可以看到他的新推文。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nt"><img src="../Images/2317cb665c8489473d86c240ff775cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUw1OiqWxksfgBHoikup7g.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Various Components of mini Twitter App</figcaption></figure><h1 id="a2a5" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">个人资料信息组件:</h1><p id="9a7c" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated">在本节中，您将看到如何使用<code class="eh mz na nb nc b">react-apollo</code>中的<code class="eh mz na nb nc b">ProfileInfoQuery</code>、<code class="eh mz na nb nc b">graphql</code>连接该组件。</p><p id="5727" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">这个应用程序的GraphQL模式定义了<code class="eh mz na nb nc b">getUserInfo</code>。下面给出的查询的解析器为给定的用户<em class="ke">句柄从DynamoDB获取数据。</em></p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="acd7" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">export const </strong>ProfileInfoQuery = gql<strong class="nc hv">`<br/>  query </strong>ProfileInfoQuery(<strong class="nc hv">$handle: String!) {<br/>    getUserInfo(handle: $handle) {<br/>      name<br/>      location<br/>      description<br/>      following<br/>     }<br/>  }<br/>`</strong>;</span></pre><p id="59ce" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated"><em class="ke">句柄</em>的值是从JWT令牌中解析出来的，可以在<code class="eh mz na nb nc b">context.identity.username</code>中获得，或者可以作为输入<code class="eh mz na nb nc b">context.arguments.handle</code>提供。上面的查询是使用AppSync后端中的以下映射模板解决的。</p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="c1d3" class="nk lm hu nc b fv nl nm l nn no">{<br/>    "version" : "2017-02-28",<br/>    "operation" : "<strong class="nc hv">Query</strong>",<br/>    "query" : {<br/>        "expression": "<strong class="nc hv">handle</strong> = <strong class="nc hv">:handle</strong>",<br/>        "expressionValues" : {<br/>            ":handle" : {<br/>                "S" : "${<strong class="nc hv">context.identity.username</strong>}"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="494c" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated"><code class="eh mz na nb nc b">ProfileInfoComponent</code>结尾是:</p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="d3c2" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">import </strong>React <strong class="nc hv">from 'react'</strong>;<br/><strong class="nc hv">import </strong>{ <em class="ke">graphql </em>} <strong class="nc hv">from 'react-apollo'</strong>;<br/><strong class="nc hv">import </strong>{ ProfileInfoQuery } <strong class="nc hv">from '../queries'</strong>;</span><span id="8088" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">const </strong><em class="ke">ProfileInfo </em>= ({ data: { loading, <strong class="nc hv">getUserInfo</strong> }}) =&gt; {<br/>  <strong class="nc hv">if </strong>(loading) { <strong class="nc hv">return </strong>( &lt;<strong class="nc hv">p</strong>&gt;Loading ...&lt;/<strong class="nc hv">p</strong>&gt; ); }</span><span id="24af" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">  return </strong>( &lt;d<strong class="nc hv">iv</strong>&gt; &lt;<strong class="nc hv">h4</strong>&gt; {<strong class="nc hv">getUserInfo</strong>.<strong class="nc hv">name</strong>} &lt;/<strong class="nc hv">h4</strong>&gt; &lt;/d<strong class="nc hv">iv</strong>&gt; );<br/>};</span><span id="9d72" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">export default </strong><em class="ke">graphql</em>(ProfileInfoQuery, {<br/>  options: props =&gt; ({<br/>    <strong class="nc hv">variables</strong>: {<br/>      <strong class="nc hv">handle</strong>: props.<strong class="nc hv">handle</strong>,<br/>    },<br/>  }),<br/>})(<strong class="nc hv"><em class="ke">ProfileInfo</em></strong>);</span></pre><blockquote class="jz ka kb"><p id="52f2" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">注</strong>:迷你Twitter应用的GraphQL模式和解析器在<a class="ae kz" href="https://hackernoon.com/running-a-scalable-reliable-graphql-endpoint-with-serverless-24c3bb5acb43" rel="noopener ugc nofollow" target="_blank">第2部分</a>中有解释。</p></blockquote><h1 id="236d" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">个人资料推文组件:</h1><p id="83a1" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated">该组件的数据也从AppSync模式中定义的<code class="eh mz na nb nc b">getUserInfo</code>中检索。该查询的解析器点击ElasticSearch tweet索引，并通过<em class="ke">句柄检索tweet。</em></p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="4abe" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">export const </strong>ProfileTweetsQuery = gql<strong class="nc hv">`<br/>  query </strong>ProfileTweetsQuery<strong class="nc hv"> {<br/>    getUserInfo {<br/>      tweets(limit: 10) {<br/>        items {<br/>          tweet<br/>          tweet_id<br/>        } <br/>        nextToken<br/>      }<br/>    }<br/>  }<br/>`</strong>;</span></pre><h1 id="a945" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">乐观的回应和线下的支持</h1><p id="3013" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated">现在，让我们想象以下场景:</p><blockquote class="jz ka kb"><p id="38c7" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">场景:在漫长的一天工作后，你正准备回家。你乘火车从A站到b站。现在，你还在推特上发表你对你最感兴趣的话题的想法，但突然火车穿过隧道，现在你遇到了网络连接问题。你的应用程序将如何处理这个问题？</p></blockquote><p id="9d96" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">在这种可能的情况下，用户会期望应用程序正常运行(哦耶！用户期望很高😉点击删除应用程序按钮并不会花费他们太多时间💁).这就是<strong class="kf hv"> <em class="ke">乐观响应</em> </strong>和<strong class="kf hv"> <em class="ke">离线支持</em> </strong> <em class="ke"> </em>在后端不可达时前来救援的地方。</p><p id="b8d0" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">我们的下一个组件，<strong class="kf hv"> TweetForm </strong>处理上面解释的场景。在这种情况下，<em class="ke"> create tweet mutation </em>将一条tweet记录放入ElasticSearch索引中。</p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="5aef" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">export const </strong>AddTweetMutation = gql<strong class="nc hv">`<br/>  mutation AddTweetMutation(<br/>    $tweet: String!<br/>  ) {<br/>    createTweet(<br/>      tweet: $tweet<br/>    ) {<br/>      tweet_id<br/>      tweet<br/>    }<br/>  }<br/>`</strong>;</span></pre><p id="2554" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">现在，我们需要在我们的组件中增加两个功能，在这篇文章的<a class="ae kz" href="https://code.tutsplus.com/tutorials/code-an-app-with-graphql-react-native-and-aws-appsync-the-app--cms-30569" rel="noopener ugc nofollow" target="_blank">中也有解释。</a></p><ol class=""><li id="c5cd" class="ml mm hu kf b kg kh kj kk mf mn mh mo mj mp ky nu mr ms mt dt translated"><code class="eh mz na nb nc b">optimisticResponse</code>定义您希望在更新功能中可用的新响应。</li><li id="0494" class="ml mm hu kf b kg mu kj mv mf mw mh mx mj my ky nu mr ms mt dt translated"><code class="eh mz na nb nc b">update</code>接受两个参数，代理(允许您从缓存中读取)和您想要用来进行更新的数据。我们读取当前缓存(<code class="eh mz na nb nc b">proxy.readQuery</code>)，将它作为我们的新条目添加到条目数组中，然后写回缓存，这更新了我们的UI。</li></ol><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="37b0" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">export default </strong><em class="ke">graphql</em>(AddTweetMutation, {<br/>  props: ({ mutate }) =&gt; ({<br/>    addTweet: tweet =&gt; {<br/>      <strong class="nc hv">return </strong>mutate({<br/>        <strong class="nc hv">variables</strong>: {<br/>          tweet,<br/>        },<br/>        optimisticResponse: () =&gt; ({<br/>          <strong class="nc hv">createTweet</strong>: {<br/>            tweet,<br/>            <strong class="nc hv">tweet_id</strong>: uuid(),<br/>            <strong class="nc hv">__typename</strong>: <strong class="nc hv">'Tweet'</strong>,<br/>          },<br/>        }),<br/>        update: (proxy, { data: { createTweet } }) =&gt; {<br/>          <strong class="nc hv">const </strong>data = proxy.readQuery({<br/>            <strong class="nc hv">query</strong>: ProfileTweetsQuery,<br/>            <strong class="nc hv">variables</strong>: {<br/>              tweet,<br/>            },<br/>          });<br/>          data.<strong class="nc hv">meInfo</strong>.<strong class="nc hv">tweets</strong>.<strong class="nc hv">items</strong>.push(createTweet);<br/>          proxy.writeQuery({<br/>            <strong class="nc hv">query</strong>: ProfileTweetsQuery,<br/>            data,<br/>            <strong class="nc hv">variables</strong>: {<br/>              tweet,<br/>            },<br/>          });<br/>        },<br/>      });<br/>    },<br/>  }),<br/>})(TweetFormComponent);</span></pre><blockquote class="la"><p id="cda1" class="lb lc hu bd ld le lf lg lh li lj ky ek translated">和..嘣！你可以亲眼目睹这种魔力👓</p></blockquote><figure class="nw nx ny nz oa jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nv"><img src="../Images/19d91b879ddd2e257062a72ac9c5b75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LkypTlddKOJvl_c-BL9Gfg.gif"/></div></div></figure><h1 id="91a6" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">让我们看看所有这些实时的东西是如何工作的:</h1><blockquote class="la"><p id="2352" class="lb lc hu bd ld le ob oc od oe of ky ek translated">最精彩的部分？要让订阅在后端工作，您只需用4行代码扩展您的GraphQL模式:</p></blockquote><pre class="nw nx ny nz oa ng nc nh ni aw nj dt"><span id="5731" class="nk lm hu nc b fv nl nm l nn no">type Subscription {<br/>  addTweet: Tweet<br/>  @aws_subscribe(mutations: [“createTweet”]<br/>}</span></pre><blockquote class="jz ka kb"><p id="e945" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">场景:假设我们有两个用户(sidg_sid和nikgraf)互相关注。在这种情况下，两个用户都订阅了对方的推文。如下所示，当用户sidg_sid发送一条推文时，它会立即被推送给包括nikgraf在内的所有关注者，反之亦然。</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nv"><img src="../Images/7f2f60739bc8a5818b7969286111ce29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cuts_Q1frrZYovPjNUuX0w.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Real Time Subscriptions</figcaption></figure><p id="7fcc" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">AWS AppSync中的订阅被调用作为对突变的响应。此外，它们由AWS AppSync客户端SDK自动处理，使用MQTT over Websockets作为客户端和服务之间的网络协议。每次添加新的tweet时，都会调用下面的订阅。</p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="82c7" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">export const </strong>AddTweetSubscription = gql<strong class="nc hv">`<br/>  subscription AddTweetSubscription {<br/>    addTweet {<br/>      __typename<br/>      tweet_id<br/>      tweet<br/>    }<br/>  }<br/>`</strong>;<br/><br/><strong class="nc hv">export default </strong>{<br/>  AddTweetSubscription,<br/>};</span></pre><p id="c445" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">我们现在通过使用<code class="eh mz na nb nc b">AddTweetSubscription</code>和用户<code class="eh mz na nb nc b">handle</code>调用<code class="eh mz na nb nc b">subscribeToMore</code>函数，将该订阅添加到<em class="ke">个人资料推文组件</em>。<code class="eh mz na nb nc b">updateQuery</code>在给定用户之前的推文中添加一条新推文。</p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="55ba" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">const </strong>tweetsQuery = <em class="ke">graphql</em>(ProfileTweetsQuery, {<br/>  options: props =&gt; ({<br/>    <strong class="nc hv">variables</strong>: { ...variables, <strong class="nc hv">handle</strong>: props.<strong class="nc hv">handle </strong>},<br/>    <strong class="nc hv">fetchPolicy</strong>: <strong class="nc hv">'cache-and-network'</strong>,<br/>  }),<br/>  props: props =&gt; ({<br/>    ...props,<br/>    subscribeToNewTweets: params =&gt;<br/>      props.<strong class="nc hv">data</strong>.subscribeToMore({<br/>        <strong class="nc hv">document</strong>: AddTweetSubscription,<br/>        <strong class="nc hv">variables</strong>: params,<br/>        updateQuery: (prev, { subscriptionData: { data: { addTweet } } }) =&gt; {<br/>          <strong class="nc hv">return </strong>{<br/>            ...prev,<br/>            <strong class="nc hv">getUserInfo</strong>: {<br/>              ...prev.<strong class="nc hv">getUserInfo</strong>,<br/>              <strong class="nc hv">tweets</strong>: {<br/>                <strong class="nc hv">items</strong>: [addTweet, ...prev.<strong class="nc hv">getUserInfo</strong>.<strong class="nc hv">tweets</strong>.<strong class="nc hv">items</strong>],<br/>              },<br/>            },<br/>          };<br/>        },<br/>      }),<br/>  }),<br/>});<br/><br/><strong class="nc hv">export default </strong>compose(tweetsQuery)(ProfileTweetsComponent);</span></pre><h1 id="07d4" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">搜索所有推文组件</h1><p id="3eb4" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated">最后但并非最不重要的一点是，用户还可以通过关键词搜索推文语料库。该查询的解析器映射到后端的ElasticSearch查询。</p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="9d6f" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">export const </strong>SearchTweetsQuery = gql<strong class="nc hv">`<br/>  query UserQuery($keyword: String!) {<br/>    searchAllTweetsByKeyword(keyword: $keyword) {<br/>      items {<br/>        tweet<br/>        tweet_id<br/>      }<br/>    }<br/>  }<br/>`</strong>;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff og"><img src="../Images/8bd11eb2bf3124abcdfafdf794120fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2rMuWsmEIjq8FD9TxHJB1w.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">ElasticSearch Query</figcaption></figure><p id="a981" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated"><code class="eh mz na nb nc b">SearchTweetsComponent</code>结尾是:</p><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="ed0b" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">import </strong>React <strong class="nc hv">from 'react'</strong>;<br/><strong class="nc hv">import </strong>{ <em class="ke">graphql </em>} <strong class="nc hv">from 'react-apollo'</strong>;<br/><strong class="nc hv">import </strong>{ SearchTweetsQuery } <strong class="nc hv">from '../queries'</strong>;</span><span id="cd33" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">const </strong>Search<em class="ke"> </em>= ({ data: { loading, searchAllTweetsByKeyword }}) =&gt; {<br/>  <strong class="nc hv">if </strong>(loading) { <strong class="nc hv">return </strong>( &lt;<strong class="nc hv">p</strong>&gt;Loading ...&lt;/<strong class="nc hv">p</strong>&gt; ); }</span><span id="ccbf" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">return </strong>(<br/>  &lt;<strong class="nc hv">Container</strong>&gt;<br/>    {searchAllTweetsByKeyword.<strong class="nc hv">items</strong>.map((item, index) =&gt; (<br/>      &lt;<strong class="nc hv">Tweet key=</strong>{index}&gt;{item.tweet}&lt;/<strong class="nc hv">Tweet</strong>&gt;<br/>    ))}<br/>  &lt;/<strong class="nc hv">Container</strong>&gt;<br/>);<br/>};</span><span id="c75f" class="nk lm hu nc b fv np nm l nn no"><strong class="nc hv">export default </strong><em class="ke">graphql</em>(SearchTweetsQuery, {<br/>  options: props =&gt; ({<br/>    <strong class="nc hv">variables</strong>: {<br/>      <strong class="nc hv">handle</strong>: props.<strong class="nc hv">handle</strong>,<br/>    },<br/>  }),<br/>})(<!-- -->Search<!-- -->);</span></pre><h1 id="efe3" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">使用Netlify和/或S3的无服务器客户端部署</h1><blockquote class="jz ka kb"><p id="a1ca" class="kc kd ke kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">部署Netlify:<strong class="kf hv">yarn build&amp;&amp;Netlify部署build <br/> </strong>部署S3: <strong class="kf hv"> yarn build &amp; &amp;无服务器客户端部署</strong></p></blockquote><pre class="jk jl jm jn fq ng nc nh ni aw nj dt"><span id="a4b4" class="nk lm hu nc b fv nl nm l nn no"><strong class="nc hv">service: </strong>serverless-graphql-client<br/><br/><strong class="nc hv">frameworkVersion: "&gt;=1.21.0 &lt;2.0.0"<br/><br/>provider:<br/>  name: </strong>aws<br/>  <strong class="nc hv">runtime: </strong>nodejs6.10<br/>  <strong class="nc hv">stage: </strong>dev<br/>  <strong class="nc hv">region: </strong>us-east-1<br/><br/><strong class="nc hv">plugins:<br/>  </strong>- serverless-finch<br/><br/><strong class="nc hv">custom:<br/>  client:<br/>    bucketName: </strong>&lt;unique bucket name&gt;<br/>    <strong class="nc hv">distributionFolder: </strong>build</span></pre><h1 id="0816" class="ll lm hu bd ln lo lp lq lr ls lt lu lv ja nd jb lx jd ne je lz jg nf jh mb mc dt translated">特别感谢</h1><p id="cba2" class="pw-post-body-paragraph kc kd hu kf b kg md iv ki kj me iy kl mf mg ko kp mh mi ks kt mj mk kw kx ky hn dt translated"><a class="nq nr gr" href="https://medium.com/u/ff3f225e7f5c?source=post_page-----db16e42dc266--------------------------------" rel="noopener" target="_blank"> Nik Graf </a>合作实现客户端组件。<br/> <a class="ae kz" href="https://twitter.com/menyao" rel="noopener ugc nofollow" target="_blank"> Manuel </a>和<a class="nq nr gr" href="https://medium.com/u/695782484bda?source=post_page-----db16e42dc266--------------------------------" rel="noopener" target="_blank"> Nader </a>用于帮助和审查代码。</p><p id="2df2" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">最后但同样重要的是，感谢所有人鼓励我多写点东西，感谢以前的博客。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="oh oi l"/></div></figure><p id="ac6f" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated">我想用我最喜欢的一句话来结束我的博客—</p><p id="4fbc" class="pw-post-body-paragraph kc kd hu kf b kg kh iv ki kj kk iy kl mf kn ko kp mh kr ks kt mj kv kw kx ky hn dt translated"><em class="ke">“想象力比知识更重要。因为知识是有限的，而想象力包含整个世界，刺激进步，催生进化。”— </em>阿尔伯特·爱因斯坦</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="oj oi l"/></div></figure></div></div>    
</body>
</html>