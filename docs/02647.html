<html>
<head>
<title>Fun with Functors and ReasonML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Functors和ReasonML的乐趣</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fun-with-functors-and-reasonml-8bb59b243e9c?source=collection_archive---------12-----------------------#2018-03-24">https://medium.com/hackernoon/fun-with-functors-and-reasonml-8bb59b243e9c?source=collection_archive---------12-----------------------#2018-03-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5e85" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">初学者对ReasonML类型和函子类型的简短介绍。</h2></div><p id="bfe8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在阅读了<a class="kf kg gr" href="https://medium.com/u/a3129fead82b?source=post_page-----8bb59b243e9c--------------------------------" rel="noopener" target="_blank">布莱恩·朗斯多夫</a>的令人惊叹的书<a class="ae kh" href="https://github.com/MostlyAdequate/mostly-adequate-guide" rel="noopener ugc nofollow" target="_blank">“JavaScript函数式编程基本指南”</a>之后，我开始学习一些函数式模式。这本书让我对这种我从未学过的新范式着迷，并让我想在某个地方实践这些模式。</p><p id="751d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我发现自己在有趣的项目中使用它，但从未在实际工作项目中使用过——它总是属于“大多数javascript程序员不会这样编码”的范畴。我的同事是对的，所以我决定学习一种不同的语言。最初是哈斯克尔。我开始学习它，但是它对我来说太理论化了(或者说太“学术化了”):我是一个非常实际的人，我喜欢能够用我首先学习的范例和语言来使用和构建软件。</p><blockquote class="ki"><p id="5081" class="kj kk hu bd kl km kn ko kp kq kr ke ek translated">所以…在过去的几天里，我一直在学习<a class="ae kh" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank">原因</a>。</p></blockquote><h1 id="8d59" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">原因？</h1><p id="ce17" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">Reason，或<a class="ae kh" href="https://hackernoon.com/tagged/reasonml" rel="noopener ugc nofollow" target="_blank"> ReasonML </a>，是OCaml的新语法。它看起来更像JavaScript，所以更容易上手。OCaml部分不需要告诉你太多，除了你背后有一个很大的社区，这种语言已经存在很多年了。OCaml有<code class="eh lp lq lr ls b">opam</code>作为他们的包管理工具，这个社区非常活跃。查看<a class="ae kh" href="https://github.com/rizo/awesome-ocaml" rel="noopener ugc nofollow" target="_blank"> awesome-ocaml </a>来看看来自ocaml社区的一些很酷的东西。</p><p id="4e5d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“新语法”是什么意思？拥有OCaml的新语法，就像使用CoffeeScript或者使用Babel将新的JS语法转换成旧的JS语法——用一种语法编写，然后编译成另一种语法。Reason“编译”成OCaml，和BuckleScript，一个把OCaml编译成非常高效的JavaScript的工具一起，你可以看到这个链条:reason➡·ocaml➡JavaScript。</p><p id="5363" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">OCaml和Reason都有一个完整的(和推断的)类型系统，所以100%的代码在编译时都被类型覆盖。这意味着更少的错误。推理部分也很神奇；这意味着您不必自己编写类型。编译器理解你的代码，并为你做。</p><p id="f2aa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于开发类似Java类型系统的开发人员来说，像Reason has这样的类型系统——注意，在Reason中，<code class="eh lp lq lr ls b">null</code> s不是一个东西。你不能把<code class="eh lp lq lr ls b">null</code>作为一个想要得到<code class="eh lp lq lr ls b">string</code>的函数的参数。这不可能。这并不是说缺席的整个概念没有融入到理性中，只是你有一种特殊的方式。那种方式叫做<code class="eh lp lq lr ls b">option</code>。</p><h1 id="fd9d" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja lu jb le jd lv je lg jg lw jh li lj dt translated">选项类型</h1><p id="cbc4" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">按理说，您可以将类型声明为构造函数。构造函数<em class="lt">可以在</em>中包含数据，但这不是强制性的。让我们以<code class="eh lp lq lr ls b">option</code>类型为例，它的声明如下:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="946b" class="mf kt hu ls b fv mg mh l mi mj">type option('a) = None | Some('a)</span></pre><p id="708c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">喔呼，对于第一个来的人来说这里有很多事情要做。让我们一起回顾一下这个定义。</p><p id="95d4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先我们声明一个<code class="eh lp lq lr ls b">type</code>，叫做<code class="eh lp lq lr ls b">option</code>。然后，还有类型参数:那个<code class="eh lp lq lr ls b">'a</code>东西被称为“类型参数”——它像泛型或模板一样在Java、C++等语言中使用。这使得<code class="eh lp lq lr ls b">option</code>可以“包装”许多不同的类型:如果你有一个可为空的整数，你可以有<code class="eh lp lq lr ls b">option(int)</code>，或者如果你有一个可为空的字符串，你可以有<code class="eh lp lq lr ls b">option(string)</code>！类型参数总是以一个记号(<code class="eh lp lq lr ls b">'</code>)为前缀，所以在例子中你不能看不到它。您可以有多个类型参数，稍后会详细介绍。</p><p id="a982" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们说我们的类型是两个构造函数的并集:<code class="eh lp lq lr ls b">None</code>，它不接收任何数据，和<code class="eh lp lq lr ls b">Some</code>，它接收类型为<code class="eh lp lq lr ls b">'a</code>的数据，正如类型参数所说。</p><p id="fdc5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">内置的<code class="eh lp lq lr ls b">option</code>类型是我们合理处理缺席的方式。在Haskell中，它被称为<code class="eh lp lq lr ls b">Maybe</code>。我们总是知道我们收到一个期权类型，当我们有一个期权类型时，我们总是要在使用它之前解包。我们用一个叫做<a class="ae kh" href="https://reasonml.github.io/docs/en/pattern-matching.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>的很酷的特性来解包数据:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="ccbe" class="mf kt hu ls b fv mg mh l mi mj">let greet = (optionalName: option(string)) : string =&gt;<br/>  switch optionalName {<br/>  | Some(name) =&gt; "Hello, " ++ name<br/>  | None =&gt; "Who are you?"<br/>  };</span><span id="bf49" class="mf kt hu ls b fv mk mh l mi mj">print_endline(greet(Some("Gal"))); /* prints "Hello, Gal" */<br/>print_endline(greet(None)); /* prints "Who are you?" */</span></pre><p id="2613" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">看看我如何轻松地解开数据。当我得到<code class="eh lp lq lr ls b">None</code>时，我返回一个包含<code class="eh lp lq lr ls b">Who are you?</code>的字符串。当我得到带有一些T3的T2时，我返回T4。它实际上是这样工作的，这可能看起来很奇怪，但它确实如此！(<a class="ae kh" href="https://reasonml.github.io/en/try.html?reason=DYUwLgBA5gTi4QLwQBQHsAOYCWaB2AhsAHIEC2IAXBJjvigM5gzZ5QCU7E1TLbSAPgBQECAwDu2MAGMAFqlq5CJciC4BvERAA+EAMpoKKQhS6IBEAEQAJEMGBoANFYgBqVxBMgtu4vhCCVgDqsmgQBHAQAJ5oAK4A-JZaAL4A3EJCGHxgAPogeAAmwKwgKLDwYCgGRpYA4kSWnOypEAD0AFQQWaxgDFa29k4Q9cCWEO2tmdl5hcV4peXgKH7znC0dXdl9liFhEQExCWMTQA" rel="noopener ugc nofollow" target="_blank">您可以点击此处，在原因尝试页面</a>中查看它的编译结果)</p><h1 id="f5c0" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja lu jb le jd lv je lg jg lw jh li lj dt translated">好吧好吧…可选类型。什么是函子？</h1><p id="fe64" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">现在我们知道了什么是<code class="eh lp lq lr ls b">option</code>类型，我们可以从这里继续，并在本文的剩余部分中使用它作为我们的例子。</p><p id="cccb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">函子是一种可以映射的数据类型。这意味着你可以在上面调用<code class="eh lp lq lr ls b">map</code>函数。<code class="eh lp lq lr ls b">map</code>函数接受一个仿函数和一个函数，然后将提供的函数应用于仿函数的值(解开它)，并用仿函数的实例再次包装结果。</p><p id="0228" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能已经熟悉了来自ES5  : <code class="eh lp lq lr ls b">array.map(fn)</code>的<code class="eh lp lq lr ls b"><a class="ae kh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">Array#map</a></code>。这是因为<em class="lt">数组是一个包含多个值的仿函数</em>。提供的函数用数组中的每个值来计算，作为回报，你得到一个新的数组！顺便说一句，从道理上讲，你不会对一个值调用方法——这就是OOP。调用方法的方式是调用一个函数并将值传递给它:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="4704" class="mf kt hu ls b fv mg mh l mi mj">let increment = x =&gt; x + 1;<br/>map(Array[1], increment) // =&gt; Array[2]</span></pre><p id="4a08" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">option</code>类型，就像<code class="eh lp lq lr ls b">Array</code>一样，也是一个函子。为了理解它是如何工作的，让我们把它分成两个构造函数:<code class="eh lp lq lr ls b">Some</code>和<code class="eh lp lq lr ls b">None</code>。</p><p id="b3e8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们<code class="eh lp lq lr ls b">map</code>超过<code class="eh lp lq lr ls b">None</code>会发生什么？我建议它应该具有与映射空数组相同的行为:它不应该做任何事情，它根本不应该执行所提供的函数——它应该只返回<code class="eh lp lq lr ls b">None</code>。对于<code class="eh lp lq lr ls b">Some</code>，我建议它应该具有与映射具有单个值的数组相同的行为。所以单个值将被应用到函数中，然后用<code class="eh lp lq lr ls b">Some</code>再次打包:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="fe5b" class="mf kt hu ls b fv mg mh l mi mj">let increment = x =&gt; x + 1;<br/>map(None, increment); // =&gt; None<br/>map(Some(1), increment); // =&gt; Some(2)</span></pre><p id="5711" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">实现这个<code class="eh lp lq lr ls b">map</code>函数只需要几行代码:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="48ff" class="mf kt hu ls b fv mg mh l mi mj">let mapOption = (opt, fn) =&gt;<br/>  switch opt {<br/>  | None =&gt; None<br/>  | Some(value) =&gt; Some(fn(value))<br/>  };</span></pre><p id="4032" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Reason惊人的类型系统确保了<code class="eh lp lq lr ls b">fn</code>是一个接收提供的<code class="eh lp lq lr ls b">option</code>值的函数，并返回一个新的选项。<code class="eh lp lq lr ls b">mapOption</code>的完整类型声明是:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="f277" class="mf kt hu ls b fv mg mh l mi mj">let mapOption = (opt: option('a), fn: 'a =&gt; 'b) : option('b)</span></pre><p id="8aa3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们一起回顾一下:我们首先声明一个名为mapOption的函数，它接收一个名为<code class="eh lp lq lr ls b">opt</code>的参数，类型为<code class="eh lp lq lr ls b">option(‘a)</code>。正如我们已经谈到的，<code class="eh lp lq lr ls b">‘a</code>是一个类型参数，使得这个函数得到<em class="lt">任何类型的选项。</em>然后，我们接收一个函数，该函数接收<code class="eh lp lq lr ls b">‘a</code>(我们在<code class="eh lp lq lr ls b">opt</code>参数中的类型参数)，并返回<code class="eh lp lq lr ls b">‘b</code>，这是或不是一个不同的类型。然后，函数返回<code class="eh lp lq lr ls b">option(‘b)</code>，它与内部函数结果类型相同，但是被包装在一个<code class="eh lp lq lr ls b">option</code>中。</p><p id="102e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">换句话说，我们接收一个<code class="eh lp lq lr ls b">option(‘a)</code>，然后我们接收一个将值从类型<code class="eh lp lq lr ls b">‘a</code>转换为<code class="eh lp lq lr ls b">‘b</code>的函数，然后我们返回<code class="eh lp lq lr ls b">option(‘b)</code>:我们支持内部类型之间的转换，而我们仍然在<code class="eh lp lq lr ls b">option</code>的土地上:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="564f" class="mf kt hu ls b fv mg mh l mi mj">let stringify = x =&gt; string_of_int(x); // int =&gt; string<br/>mapOption(Some(1), stringify); // Some("1")<br/>mapOption(None, stringify); // None</span></pre><h1 id="971d" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja lu jb le jd lv je lg jg lw jh li lj dt translated">更多仿函数示例</h1><p id="fa32" class="pw-post-body-paragraph jj jk hu jl b jm lk iv jo jp ll iy jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">我们可以声明另一种类型——<code class="eh lp lq lr ls b">result</code>函子。<code class="eh lp lq lr ls b">result</code>仿函数几乎和<code class="eh lp lq lr ls b">option</code>一样，但是它的负端也有一个值。你可以把它的值当作一个<code class="eh lp lq lr ls b">reason</code>，或者<code class="eh lp lq lr ls b">error</code>，或者仅仅是<code class="eh lp lq lr ls b">failure</code>。当你返回<code class="eh lp lq lr ls b">result</code>仿函数时，你基本上是在说“这个方法可能会失败”。您可以在验证和数据库查询中使用<code class="eh lp lq lr ls b">result</code>,或者用于任何错误很重要的事情:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="998c" class="mf kt hu ls b fv mg mh l mi mj">type result('s, 'f) = Success('s) | Failure('f)</span></pre><p id="01a2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lp lq lr ls b">map</code>行为几乎与<code class="eh lp lq lr ls b">optionMap</code>行为相同。如果我们有<code class="eh lp lq lr ls b">Success</code>，我们将获取它的数据并将其应用到所提供的函数中。如果我们有一个<code class="eh lp lq lr ls b">Failure</code>，我们不会将值应用到函数中，只是让<code class="eh lp lq lr ls b">Failure</code>保持原样。实现也是几行代码:</p><pre class="lx ly lz ma fq mb ls mc md aw me dt"><span id="bfc9" class="mf kt hu ls b fv mg mh l mi mj">let mapResult = (res, fn) =&gt;<br/>  switch res {<br/>  | Failure(failure) =&gt; Failure(failure)<br/>  | Success(success) =&gt; Success(fn(success))<br/>  };</span></pre><p id="9ce7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种数据结构帮助我们将程序构建成一棵树。当我们遇到问题时，我们停止运用我们的逻辑去解决它。我们基本上停止了“快乐之路”,直到我们处理了失败。<em class="lt">当我们映射到</em> <code class="eh lp lq lr ls b"><em class="lt">Failure</em></code> <em class="lt">上时，我们停留在相同的失败上，所以一旦我们有了</em> <code class="eh lp lq lr ls b"><em class="lt">Failure</em></code> <em class="lt">就不会发生数据转换。</em></p><p id="9e25" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在下一篇文章中，我将写关于单子的内容，单子是<a class="ae kh" href="https://hackernoon.com/tagged/functors" rel="noopener ugc nofollow" target="_blank">函子</a>的一个特例，它在构建数据转换时可以给你很大的帮助。</p><blockquote class="ki"><p id="391c" class="kj kk hu bd kl km kn ko kp kq kr ke ek translated">在那之前，你对自定义函子有什么想法？</p></blockquote><p id="7c50" class="pw-post-body-paragraph jj jk hu jl b jm ml iv jo jp mm iy jr js mn ju jv jw mo jy jz ka mp kc kd ke hn dt translated">感谢阅读！</p><figure class="lx ly lz ma fq mq"><div class="bz el l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>