<html>
<head>
<title>Building a JIRA integration with Clojure &amp; Atlassian Connect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Clojure &amp; Atlassian Connect构建JIRA集成</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-jira-integration-with-clojure-atlassian-connect-506ebd112807?source=collection_archive---------23-----------------------#2018-03-24">https://medium.com/hackernoon/building-a-jira-integration-with-clojure-atlassian-connect-506ebd112807?source=collection_archive---------23-----------------------#2018-03-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="be53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.atlassian.com/software/jira" rel="noopener ugc nofollow" target="_blank"> Atlassian JIRA </a>是市场领先的问题跟踪和敏捷项目管理工具，在全球各地的公司中广泛使用。</p><p id="2253" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<a class="ae jp" href="https://getctx.io/" rel="noopener ugc nofollow" target="_blank"> CTX，我的团队搜索应用</a>我想建立一个光滑的集成到<a class="ae jp" href="https://www.atlassian.com/software/jira" rel="noopener ugc nofollow" target="_blank"> JIRA </a>来帮助我的客户搜索他们的JIRA问题以及他们的Slack消息，Trello卡，文件，GitHub问题和电子邮件。</p><p id="d704" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当实际构建集成时，我对可用的<a class="ae jp" href="https://developer.atlassian.com/explore-the-apis/" rel="noopener ugc nofollow" target="_blank">API</a>感到惊喜，尤其是<a class="ae jp" href="https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/" rel="noopener ugc nofollow" target="_blank"> Atlassian Connect API </a>及其推广的简单集成模式。</p><p id="ed11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然有很多文档，甚至还有一个简短的关于将Bitbucket与Clojure应用程序集成的博客系列，但是我找不到一个简单的教程，在一个地方涵盖了Connect、webhook接口和主要的JIRA API。</p><p id="a6fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我写了一个。</p><p id="8aad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://github.com/getctx/connect-example" rel="noopener ugc nofollow" target="_blank">我们正在构建的应用程序的完整源代码可以从GitHub这里获得</a>。</p><h1 id="4121" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">我们在建造什么？</h1><p id="54a4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们将在Clojure中构建一个JIRA集成，它监听正在被创建和变异的问题，并创建一个变更的基本活动提要。</p><p id="9162" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我们需要一个Clojure web应用程序，监听HTTPS端点。我们将向JIRA注册该应用程序，每次用户创建或更新票证时，JIRA都会在Webhook上向我们发送一个事件。</p><p id="e4e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将这些记录在内存数据库中，并编写一个小的前端应用程序来轮询我们的应用程序，以显示问题的更改列表。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/ad345c15e938366d24968fa7bba04c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*v2HClZJf23hI7Kg8.png"/></div></figure><h1 id="a114" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">什么是亚特兰蒂斯连接？</h1><p id="9478" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Connect为集成Atlassian应用程序(如JIRA和Confluence)提供了一个简单的框架。它利用了OAuth2和JWT，以及一些简单的集成模式，为开发人员提供了一种与Atlassian API套件对话的良好且一致的方式。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/f08abbdd6498cf6c0acb9c2a373cab51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*hl6k7ZobHfAHgvg-.png"/></div></figure><p id="f6ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在其最基本的形式中，您所需要做的就是发布一个描述符，列出您提供的端点和您需要的服务，将您的Atlassian应用程序指向它，然后在列出的端点上部署一些能与HTTP / JSON对话的代码。</p><h2 id="ed92" class="lc jr hu bd js ld le lf jw lg lh li ka jc lj lk ke jg ll lm ki jk ln lo km lp dt translated">先决条件</h2><p id="5198" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">首先，安装<a class="ae jp" href="https://leiningen.org/" rel="noopener ugc nofollow" target="_blank"> Leiningen </a>，并确保它在您的路径中。如果你没有的话，给自己买一个爪哇JDK吧。</p><p id="105d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查一切正常:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="36c9" class="lc jr hu lr b fv lv lw l lx ly">$ lein --version<br/>Leiningen 2.8.1 on Java 9.0.4 Java HotSpot(TM) 64-Bit Server VM</span></pre><h1 id="ba74" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">基本项目设置</h1><p id="7207" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们使用<a class="ae jp" href="https://github.com/weavejester/compojure/wiki/Getting-Started" rel="noopener ugc nofollow" target="_blank"> Compojure模板</a>创建一个基本的Clojure应用程序框架。</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="50c2" class="lc jr hu lr b fv lv lw l lx ly">$ lein new compojure connect-example<br/>$ cd connect-example<br/>$ ls<br/><br/>-rw-r--r--  1 rory  Users  273 20 Mar 16:21 README.md<br/>-rw-r--r--  1 rory  Users  483 20 Mar 16:21 project.clj<br/>drwxr-xr-x  3 rory  Users  102 20 Mar 16:21 resources  <br/>drwxr-xr-x  3 rory  Users  102 20 Mar 16:21 src  <br/>drwxr-xr-x  3 rory  Users  102 20 Mar 16:21 test<br/><br/>$ lein ring server-headless<br/><br/>Retrieving lein-ring/lein-ring/0.9.7/lein-ring-0.9.7.pom from clojars  <br/>...<br/>2018-03-20 16:24:40.501:INFO:oejs.Server:jetty-7.6.13.v20130916  <br/>2018-03-20 16:24:40.550:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000</span></pre><p id="fc77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第二个选项卡中，使用<code class="eh lz ma mb lr b">curl</code>测试它正在运行:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="9c93" class="lc jr hu lr b fv lv lw l lx ly">$ curl http://localhost:3000<br/>Hello World</span></pre><p id="a865" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了！我们有一个运行的应用程序。</p><h1 id="eb37" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">导入基本依赖项</h1><p id="3999" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们需要在Clojure项目中添加一些库，让我们完成HTTP通信、连接流等基础工作。</p><p id="f724" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在您选择的编辑器中打开文件<code class="eh lz ma mb lr b">project.clj</code>，如下所示:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="7732" class="lc jr hu lr b fv lv lw l lx ly">(defproject connect-example "0.1.0-SNAPSHOT"<br/>  :min-lein-version "2.0.0"<br/>  :dependencies [[org.clojure/clojure "1.9.0"]<br/>                 [compojure "1.6.0"]<br/>                 [ring/ring-defaults "0.3.1"]<br/>                 [ring/ring-json "0.4.0"]<br/>                 [clj-connect "0.2.4"]]<br/>  :plugins [[lein-ring "0.9.7"]]<br/>  :ring {:handler connect-example.handler/app}<br/>  :resource-paths ["resources"]<br/>  :profiles<br/>  {:dev {:dependencies [[javax.servlet/servlet-api "2.5"]<br/>                        [ring/ring-mock "0.3.0"]]}})</span></pre><p id="5304" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> :dependencies </strong>子句中的库为我们提供了HTTP服务(<code class="eh lz ma mb lr b">ring</code>)、路由(<code class="eh lz ma mb lr b">compojure</code>)和一个简单的包装器，包装了JWT技术(<code class="eh lz ma mb lr b">clj-connect</code>)底层的Atlassian Connect API &amp;</p><h1 id="d1e8" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">连接到JIRA</h1><p id="ef22" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">JIRA只会通过HTTPS与我们的应用程序对话，所以第一个障碍是如何将它放到互联网上。</p><p id="3195" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果不设置服务器，或者使用Heroku之类的工具，这可能会非常耗时，所以这里有一个简单的解决方法:<a class="ae jp" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>。</p><p id="562d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ngrok允许您创建一个外部可访问的SSL端点来测试您的集成软件。你只要像这样运行它；</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="2b46" class="lc jr hu lr b fv lv lw l lx ly">$ ngrok tls 3000<br/><br/>ngrok by @inconshreveable    <br/><br/>Session Status                online  <br/>Account                       Rory Gibson  <br/>Version                       2.2.8  <br/>Region                        United States (us)  <br/>Web Interface                 http://127.0.0.1:4040  <br/>Forwarding                    http://9a69173f.ngrok.io -&gt; localhost:3000  <br/>Forwarding                    https://9a69173f.ngrok.io -&gt; localhost:3000<br/><br/>Connections                   ttl     opn     rt1     rt5     p50     p90  <br/>                              0       0       0.00    0.00    0.00    0.00</span></pre><p id="1877" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将创建一个隧道，并给你一个URL —例如<code class="eh lz ma mb lr b">https://9a69173f.ngrok.io</code>—你可以使用它来访问你的软件，该软件运行在你的开发机器上，但可以通过互联网上的SSL访问。</p><p id="e4ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了一个外部可发现的服务，我们可以在JIRA生成OAuth凭证。</p><h1 id="b47b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为描述符服务</h1><p id="c1c9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们已经解决了所有的问题，我们可以提供连接描述符了。</p><p id="ed73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个简单的JSON文件，它声明了应用程序的功能和依赖关系，因此JIRA(和其他Atlassian应用程序)知道如何与它对话。</p><p id="6a15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh lz ma mb lr b">&lt;project&gt;/resources/public/connect.json</code>创建一个文件，并将以下内容粘贴到其中(确保baseUrl属性与您的ngrok URL匹配):</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="d4bb" class="lc jr hu lr b fv lv lw l lx ly">{<br/>    "key": "connect-example",<br/>    "name": "connect-example",<br/>    "description": "Demo JIRA / Clojure integration",<br/>    "baseUrl": "https://9a69173f.ngrok.io",<br/>    "authentication": {<br/>        "type": "jwt"<br/>    },<br/>    "lifecycle": {<br/>        "installed": "/installed"<br/>    },<br/>    "modules": {<br/>        "oauthConsumer": {<br/>            "clientId": "PLACEHOLDER"<br/>        },<br/>        "webhooks": [<br/>            {<br/>                "event": "*",<br/>                "url": "/recv"<br/>            }<br/>        ]        <br/>    },<br/>    "scopes": ["READ"]<br/>}</span></pre><h1 id="3374" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">处理生命周期回调</h1><p id="4940" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Connect API的工作方式是加载您的描述符，然后在您的应用程序上调用<code class="eh lz ma mb lr b">/installed</code>作为“生命周期回调”(还有其他的，比如Uninstalled，我们在这里忽略了)。</p><p id="8a28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它想要的只是200的回应。</p><p id="36b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用Compojure和Ring创建一个简单的处理程序来服务这个功能(并提供基本的API管道)</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="98f9" class="lc jr hu lr b fv lv lw l lx ly">(ns connect-example.handler<br/>  (:require [compojure.core :refer :all]<br/>            [compojure.route :as route]<br/>            [ring.middleware.defaults :refer [wrap-defaults api-defaults]]<br/>            [ring.middleware.json :refer [wrap-json-body wrap-json-response]]<br/>            [ring.util.response :refer [response]]))<br/><br/>(defroutes app-routes<br/>  (POST "/installed" [] {:status 200 :body "OK"}))<br/><br/>(def app<br/>  (-&gt; app-routes<br/>    wrap-json-body<br/>    wrap-json-response<br/>    (wrap-defaults api-defaults)))</span></pre><p id="57d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经有了这么多，我们可以将其连接到云中的JIRA。保存所有内容并重新启动应用程序(<code class="eh lz ma mb lr b">lein ring server-headless</code>)</p><p id="1fc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">进入并登录您的JIRA实例，点击<strong class="it hv">设置</strong>(cog图标)<strong class="it hv"> &gt;插件</strong>。</p><p id="bc27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">转到页面底部的小<strong class="it hv">设置</strong>链接。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/1888ad9eb11b943695238a0c83816202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RMLXmKWTWhm3oLBt.png"/></div></div></figure><p id="6da8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并确保<strong class="it hv">启用开发模式</strong>和<strong class="it hv">启用私募</strong>均勾选。</p><p id="5f7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你应该看到一个到<em class="mh">上传插件</em>的链接——点击这个并在完全限定的<strong class="it hv"> HTTPS </strong> URL中粘贴到你的描述符(例如<a class="ae jp" href="https://abcd1234.ngrok.com/connect.json" rel="noopener ugc nofollow" target="_blank">https://abcd1234.ngrok.com/connect.json</a>)</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mi"><img src="../Images/98f810b8a89043667410d887bfc89789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A_55fWWs_fG4ZwnE.png"/></div></div></figure><h1 id="2295" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">处理事件</h1><p id="59ff" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">一旦Connect连接到您的应用程序，您就会开始接收我们在描述符中指定的事件。<br/>我们需要的只是一些处理程序和逻辑。</p><p id="353b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">向路由块添加两条路由—一条供JIRA在事件发生时调用，一条供我们调用以列出事件。</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="8124" class="lc jr hu lr b fv lv lw l lx ly">(POST "/recv" req (recv req))<br/>(GET "/events" req (response (events req)))</span></pre><p id="c3ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以及它们要调用的函数。</p><p id="9953" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb lr b">recv</code>获取有效负载，提取我们想要的数据，并将其存储在服务器的<code class="eh lz ma mb lr b">atom</code>中(而不是数据库，这只是一个演示:)</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="fb13" class="lc jr hu lr b fv lv lw l lx ly">(def event-store (atom '()))<br/><br/>(defn persist!<br/>  "Save event to local in-memory structure"<br/>  [e]<br/>  (swap! event-store conj e)<br/>  (println e) ;; debug info for development<br/>  e)<br/><br/>(defn transform<br/>  "Get the fields we care about from the JIRA payload"<br/>  [e1]<br/>  (let [id        (-&gt; e1 :issue :key)<br/>        user      (-&gt; e1 :user :displayName)<br/>        timestamp (-&gt; e1 :timestamp)<br/>        type      (-&gt; e1 :webhookEvent)<br/>        summary   (-&gt; e1 :issue :fields :summary)]<br/><br/>    {:user user :id id :timestamp timestamp :summary summary :type type}))<br/><br/>(defn handle-event<br/>  [raw]<br/>  (-&gt; raw<br/>    clojure.walk/keywordize-keys<br/>    transform<br/>    persist!))<br/><br/>(defn events<br/>  [_]<br/>  @event-store)<br/><br/>(defn recv<br/>  "Handler function for all events"<br/>  [req]<br/>  (handle-event (:body req))<br/>  {:status 200 :body "OK"})</span></pre><p id="168f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重新启动应用程序</p><p id="79c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次点击<code class="eh lz ma mb lr b">Ctrl-C</code>然后点击<code class="eh lz ma mb lr b">lein ring server-headless</code>。</p><p id="c27a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您在JIRA更改了一个问题(比如在敏捷视图中将它从待办事项移动到完成),您应该会在您的终端中看到一些输出，因为JIRA调用了我们的应用程序，我们保存了数据，并使用上面的<code class="eh lz ma mb lr b">println</code>将其转储到屏幕上。</p><p id="943e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击<code class="eh lz ma mb lr b">/events</code>端点检查我们正在保存数据，您应该会看到类似这样的内容:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="76c5" class="lc jr hu lr b fv lv lw l lx ly">$ curl http://localhost:3000/events<br/>[{"summary":"My issue 1,"timestamp":1521891438142,"type":"jira:issue_updated","id":"TEST-1"}]</span></pre><h1 id="9d20" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">添加用户界面</h1><p id="e9bc" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">太好了！我们有一个入站和出站API。<br/>但是大多数非开发人员不喜欢使用<code class="eh lz ma mb lr b">curl</code>做任何事情，所以我们最好添加一个用户界面。</p><p id="53f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在ClojureScript中构建一些东西，这样我们就可以在前端和后端代码库中使用相同的范例和方言。</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="51cd" class="lc jr hu lr b fv lv lw l lx ly">$ mkdir -p src/clj<br/>$ mv src/connect-example src/clj<br/>$ mkdir -p src/cljs/connect-example<br/>$ touch resources/public/index.html</span></pre><p id="fd82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在将您的<code class="eh lz ma mb lr b">project.clj</code>编辑为以下内容(引入新目录并添加ClojureScript库和构建配置)</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="549b" class="lc jr hu lr b fv lv lw l lx ly">(defproject connect-example "0.1.0-SNAPSHOT"<br/>  :min-lein-version "2.0.0"<br/>  :dependencies [[org.clojure/clojure "1.9.0"]<br/>                 [org.clojure/clojurescript "1.10.217"]<br/>                 [compojure "1.6.0"]<br/>                 [ring/ring-defaults "0.3.1"]<br/>                 [ring/ring-json "0.4.0"]<br/>                 [rum "0.11.2"]<br/>                 [clj-connect "0.2.4"]<br/>                 [cljs-ajax "0.7.3"]]<br/><br/>  :plugins [[lein-ring "0.9.7"]<br/>            [lein-figwheel "0.5.13"]]<br/><br/>  :source-paths ["src/clj"]<br/>  :resource-pahts ["resources" "target/cljsbuild"]<br/>  :ring {:handler connect-example.handler/app}<br/>  :profiles<br/>  {:dev {:dependencies [[javax.servlet/servlet-api "2.5"]<br/>                        [ring/ring-mock "0.3.2"]]}}<br/><br/>  :clean-targets ^{:protect false} [:target-path "out" "resources/public/cljs"]<br/><br/>  :figwheel {:css-dirs ["resources/public/css"]<br/>             :server-port 3000<br/>             :ring-handler connect-example.handler/app}<br/><br/>  :cljsbuild {<br/>              :builds [{:id "dev"<br/>                        :source-paths ["src/cljs"]<br/>                        :figwheel true<br/>                        :compiler {:main "connect-example.core"<br/>                                   :asset-path "cljs/out"<br/>                                   :output-to  "resources/public/cljs/main.js"<br/>                                   :output-dir "resources/public/cljs/out"}<br/>                        }]<br/>              })</span></pre><p id="2a05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建并填写您的<code class="eh lz ma mb lr b">resources/public/index.html</code></p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="ff22" class="lc jr hu lr b fv lv lw l lx ly">&lt;!DOCTYPE html&gt;  <br/>&lt;html&gt;  <br/>  &lt;head&gt;&lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="content"&gt;&lt;/div&gt;<br/>    &lt;script src="app.js" type="text/javascript"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="fa50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和<code class="eh lz ma mb lr b">src/cljs/connect-example/core.cljs</code>...</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="0bb3" class="lc jr hu lr b fv lv lw l lx ly">(ns connect-example.core)<br/><br/>(let [el (.getElementById js/document "content")]<br/>  (set! (.-innerText el) "Hello World"))</span></pre><p id="e89c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">加载后，它会找到ID为<code class="eh lz ma mb lr b">content</code>的<code class="eh lz ma mb lr b">div</code>，并在其中输入信息。</p><p id="4579" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们试着运行它，使用<a class="ae jp" href="https://github.com/bhauman/lein-figwheel" rel="noopener ugc nofollow" target="_blank">令人敬畏的Figwheel插件</a>；</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="015b" class="lc jr hu lr b fv lv lw l lx ly">$ lein figwheel<br/><br/>Retrieving figwheel/figwheel/0.5.13/figwheel-0.5.13.pom from clojars  <br/>Retrieving org/clojure/core.async/0.3.443/core.async-0.3.443.pom from central  <br/>...<br/>Figwheel: Validating the configuration found in project.clj  <br/>Spec Warning:  missing an :output-to option - you probably will want this ...  <br/>Figwheel: Configuration Valid ;)  <br/>Figwheel: Starting server at http://0.0.0.0:3449  <br/>Figwheel: Watching build - dev  <br/>Figwheel: Cleaning build - dev  <br/>Figwheel: Starting server at http://0.0.0.0:3449  <br/>Figwheel: Watching build - dev  <br/>Compiling "main.js" from ["src/cljs"]...  <br/>Successfully compiled "main.js" in 1.95 seconds.  <br/>Launching ClojureScript REPL for build: dev  <br/>Figwheel Controls:  <br/>          (stop-autobuild)                ;; stops Figwheel autobuilder<br/>          (start-autobuild [id ...])      ;; starts autobuilder focused on optional ids<br/>          (switch-to-build id ...)        ;; switches autobuilder to different build<br/>          (reset-autobuild)               ;; stops, cleans, and starts autobuilder<br/>          (reload-config)                 ;; reloads build config and resets autobuild<br/>          (build-once [id ...])           ;; builds source one time<br/>          (clean-builds [id ..])          ;; deletes compiled cljs target files<br/>          (print-config [id ...])         ;; prints out build configurations<br/>          (fig-status)                    ;; displays current state of system<br/>          (figwheel.client/set-autoload false)    ;; will turn autoloading off<br/>          (figwheel.client/set-repl-pprint false) ;; will turn pretty printing off<br/>  Switch REPL build focus:<br/>          :cljs/quit                      ;; allows you to switch REPL to another build<br/>    Docs: (doc function-name-here)<br/>    Exit: Control+C or :cljs/quit<br/> Results: Stored in vars *1, *2, *3, *e holds last exception object<br/>Prompt will show when Figwheel connects to your application</span></pre><p id="505a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">打开一个指向<code class="eh lz ma mb lr b">http://localhost:3000</code>的浏览器标签，你应该会在浏览器中看到“Hello World”的消息。</p><blockquote class="mj mk ml"><p id="63f6" class="ir is mh it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated"><em class="hu">你好世界</em></p></blockquote><h1 id="f598" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">有些人有魔法反应</h1><p id="b74b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">ClojureScript web开发非常关注React生态系统。</p><p id="6382" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">存在几个React绑定；其中最容易上手的是<a class="ae jp" href="https://github.com/tonsky/rum" rel="noopener ugc nofollow" target="_blank">朗姆酒</a>。</p><p id="c7d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将以下内容添加到您的<code class="eh lz ma mb lr b">project.clj</code>中的<strong class="it hv"> :dependencies </strong>键:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="6fbe" class="lc jr hu lr b fv lv lw l lx ly">[cljs-ajax "0.7.3"]<br/>[rum "0.11.2"]</span></pre><p id="d225" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">修改<code class="eh lz ma mb lr b">core.cljs</code>,使其包含Rum的<code class="eh lz ma mb lr b">require</code>和一个组件定义(这将在底层创建一个React组件),然后将它安装到文档体上。</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="976c" class="lc jr hu lr b fv lv lw l lx ly">(ns connect-example.core<br/>  (:require [rum.core :as rum :refer [defc mount]))<br/><br/>(defc label [text]<br/>  [:div {:class "label"} text])<br/><br/>(mount (label "Hello again") js/document.body)</span></pre><p id="f84c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重启Figwheel(在你的终端中按Ctrl-C，然后再次按<code class="eh lz ma mb lr b">lein figwheel</code>)并刷新你的浏览器，就这样——你看到的是一个React渲染的应用程序！</p><h1 id="c9a1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">简单的基于列表的用户界面</h1><p id="30ba" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在我们有了在屏幕上放置React UI的基本结构，让我们用一些实际有用的东西填充它。</p><p id="559c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了匹配上面的线框，我们将为标题设置一个H1:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="a444" class="lc jr hu lr b fv lv lw l lx ly">(defc heading []<br/>  [:h1 "JIRA Activity Feed"])</span></pre><p id="6731" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和一个迭代JIRA问题列表的组件，所以我们将每个结果的显示称为一个“问题”。我们还将创建一些虚拟数据进行初始渲染。</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="a1cf" class="lc jr hu lr b fv lv lw l lx ly">(defc issue<br/>  [{:keys [id summary type timestamp] :as issue}]<br/>  [:div.issue<br/>   [:div.id id]<br/>   [:div.info<br/>    [:div.title summary]<br/>    [:div.detail type]<br/>    [:div.date timestamp]]])<br/><br/>(defc issues<br/>  [is]<br/>  [:div.issues<br/>   (map issue is)])<br/><br/>(def fake-issues '({:id "FOO-1" :summary "The Title" :type "jira:issue_updated" :timestamp 123456789}))<br/><br/>(defc content<br/>  [data]<br/>  [:div.container<br/>   (heading)<br/>   (if data<br/>     (issues data)<br/>     [:div "No activity found in feed."])])<br/><br/>(mount (content fake-issues) (.getElementById js/document "content"))</span></pre><p id="7fe5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">保存所有东西，重新加载你的浏览器，你应该会看到一个非常基本的列表和标题。</p><p id="def7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能需要一些样式，所以让我们对<code class="eh lz ma mb lr b">index.html</code>做如下调整:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="bf5a" class="lc jr hu lr b fv lv lw l lx ly">&lt;!DOCTYPE html&gt;  <br/>&lt;html&gt;  <br/>  &lt;head&gt;<br/>    &lt;link rel="stylesheet" href="/site.css" /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="content"&gt;&lt;/div&gt;<br/>    &lt;script src="cljs/main.js" type="text/javascript"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="1328" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用一些简单的样式创建一个文件<code class="eh lz ma mb lr b">resources/public/css/site.css</code>:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="a2cf" class="lc jr hu lr b fv lv lw l lx ly">body {  <br/>  font-family: sans-serif;<br/>}<br/><br/>.container {<br/>  margin-left: auto;<br/>  margin-right: auto;<br/>  padding-top: 30px;<br/>  width: 800px;<br/>}<br/><br/>div.issue {  <br/>  font-size: 16px;<br/>  width: 600px;<br/>  border: solid black 1px;<br/>  padding: 1em;<br/>  margin-bottom: 1em;<br/>}<br/><br/>.issue .id {<br/>  font-weight: bold;<br/>  float: left;<br/>  width: 75px;<br/>  height: 50px;<br/>  text-align: center;<br/>  padding: 1em .5em 0 0;<br/>}<br/><br/>.issue .info {<br/>  height: 100%;<br/>}<br/><br/>.issue .summary {<br/>  font-weight: bold;<br/>  padding-bottom: 0.5em<br/>}</span></pre><p id="7e42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次重启<code class="eh lz ma mb lr b">lein figwheel</code>并重新加载，一切都应该是完美的。</p><blockquote class="mj mk ml"><p id="97d9" class="ir is mh it b iu iv iw ix iy iz ja jb mm jd je jf mn jh ji jj mo jl jm jn jo hn dt translated"><strong class="it hv"> <em class="hu"> NB: </em> </strong> <em class="hu">一旦到了这个阶段，Figwheel最牛逼的好处就来了ClojureScript和CSS文件的热自动重载。只需保存在编辑器中，浏览器就会自动更新！</em></p></blockquote><h1 id="a891" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">AJAX通信</h1><p id="e3a1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们通过用户界面向服务器端查询我们的JIRA信息…</p><p id="bdff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加一个新的<code class="eh lz ma mb lr b">require</code>，使<code class="eh lz ma mb lr b">core.cljs</code>的顶部看起来像这样:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="0232" class="lc jr hu lr b fv lv lw l lx ly">(ns connect-example.core<br/>  (:require [rum.core :as rum]<br/>            [ajax.core :refer [GET]]))</span></pre><p id="7103" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后让我们添加一个函数来获取和显示数据(并实际调用该函数来进行显示)</p><p id="d2e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">删除现有的<code class="eh lz ma mb lr b">mount</code>表单，并将其添加到<code class="eh lz ma mb lr b">core.cljs</code>的末尾:</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="6937" class="lc jr hu lr b fv lv lw l lx ly">(defn handler [data]<br/>  (mount (content data) (.getElementById js/document "content")))<br/><br/>(fetch-issues handler)</span></pre><p id="926e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，让浏览器应用程序每5秒钟轮询一次服务器以更新提要。</p><pre class="ku kv kw kx fq lq lr ls lt aw lu dt"><span id="0f98" class="lc jr hu lr b fv lv lw l lx ly">(js/setInterval<br/>  #(fetch-issues handler)<br/>  5000)</span></pre><h1 id="aff9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">我们得到了什么？</h1><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mp"><img src="../Images/38bc65d73dd5e36f58364dde8ebe1beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZNpuQoDSuck5AW8R.png"/></div></div></figure><p id="b447" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经构建了一个动态更新的ClojureScript React应用程序，显示来自JIRA的实时变化。</p><p id="405f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，通过Atlassian Connect将Clojure应用程序与JIRA集成起来非常容易。</p><p id="5f67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显然，我们在这里建立的只是一个生产应用程序的最基本的开端；在现实生活中，您可能希望使用Connect API内置的JWT功能来检查入站事件的有效性，并且您至少希望有某种适当的数据库来保存您的数据。</p><p id="018e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住——这个应用程序的完整源代码在GitHub上，供你参考:<a class="ae jp" href="https://github.com/getctx/connect-example" rel="noopener ugc nofollow" target="_blank">https://github.com/getctx/connect-example</a></p><h1 id="9440" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">还有一件事…</h1><p id="ffbd" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果你喜欢你在这里看到的，请检查我们的应用，<a class="ae jp" href="https://getctx.io/" rel="noopener ugc nofollow" target="_blank"> CTX，让你和你的团队搜索你的应用</a>像JIRA，特雷罗，Slack，GitHub，谷歌驱动，电子邮件和更多的一击。我们提供免费试用，不需要信用卡。<br/>谢谢！</p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="d45b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mh">原载于2018年3月24日</em><a class="ae jp" href="https://getctx.io/blog/building-an-atlassian-connect-integration-with-clojure/" rel="noopener ugc nofollow" target="_blank"><em class="mh">getctx . io</em></a><em class="mh">。</em></p></div></div>    
</body>
</html>