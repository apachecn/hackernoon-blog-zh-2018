<html>
<head>
<title>Setting up RESTful API Server for Hyperledger Fabric With NodeJS SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NodeJS SDK为Hyperledger Fabric设置RESTful API服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/setting-up-restful-api-server-for-hyperledger-fabric-with-nodejs-sdk-a4642edaf98e?source=collection_archive---------2-----------------------#2018-03-26">https://medium.com/hackernoon/setting-up-restful-api-server-for-hyperledger-fabric-with-nodejs-sdk-a4642edaf98e?source=collection_archive---------2-----------------------#2018-03-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e544" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">了解如何为您的<a class="ae jp" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>网络设置NodeJS服务器，以允许多个用户轻松地与链进行交互。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/47ca5dc3a236068d9c22319aba7e4827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9KZS6iwrwlhfhsfSba8Ig.png"/></div></div></figure><p id="dc7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上一篇文章中，我们学习了如何在Go中编写第一个简单的<a class="ae jp" href="https://hackernoon.com/tagged/hyperledger-fabric" rel="noopener ugc nofollow" target="_blank">Hyperledger Fabric</a>chain code，以及<a class="ae jp" href="https://www.skcript.com/svr/setting-up-your-development-environment-for-hyperledger-fabric/" rel="noopener ugc nofollow" target="_blank">如何为Hyperledger Fabric </a>设置开发环境。本文重点介绍如何使用ExpressJS为您的Hyperledger Fabric网络构建NodeJS服务器。</p><h1 id="53ad" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">先决条件</h1><p id="1155" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在我进一步阅读本文之前，我将假设您熟悉与多个组织建立网络，并且假设您的机器上已经有一个网络在运行。(如果没有，请按照我们以前的文章来完成它们。)</p><p id="fe7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有以下方面的经验也很好，</p><ul class=""><li id="6e08" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">JavaScript OOP概念</li><li id="d072" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">Javascript承诺</li><li id="de2f" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">服务器路由和HTTP方法。</li><li id="2654" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">ExpressJS</li></ul><h1 id="cfd5" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">步骤1:设置项目</h1><p id="bd7d" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">作为任何项目的第一步，我们将创建文件夹和文件结构。</p><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="63e0" class="ly kd hu lu b fv lz ma l mb mc">mkdir myapp<br/>cd myapp<br/>touch index.js<br/>npm install express fabric-ca-client fabric-client body-parser --save</span></pre><p id="45ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">包<code class="eh md me mf lu b">fabric-ca-client</code> &amp; <code class="eh md me mf lu b">fabric-client</code>是帮助我们与光纤网络交互的包，<code class="eh md me mf lu b">express</code>是为RESTFul API创建web服务器，最后<code class="eh md me mf lu b">body-parser</code>解析请求体中传递的数据。</p><h1 id="5253" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">步骤2:创建连接配置文件和加密配置</h1><p id="4b00" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">设置完成后，我们需要创建一个公共连接配置文件，其中包含有关当前组织的对等方、订购方和CA的信息，以便客户端可以与相应的服务进行通信。</p><p id="271d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经在<code class="eh md me mf lu b">Config/ConnectionProfile.yml</code>下创建了一个文件</p><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="b1fc" class="ly kd hu lu b fv lz ma l mb mc">name: "Org1 Client"<br/>version: "1.0"</span><span id="895e" class="ly kd hu lu b fv mg ma l mb mc">client:<br/>  organization: Org1<br/>  credentialStore:<br/>    path: "./hfc-key-store"<br/>    cryptoStore:<br/>      path: "./hfc-key-store"</span><span id="b062" class="ly kd hu lu b fv mg ma l mb mc">channels:<br/>  mychannel:<br/>    orderers:<br/>      - orderer.example.com<br/>    peers:<br/>      peer0.org1.example.com:<br/>        endorsingPeer: true<br/>        chaincodeQuery: true<br/>        ledgerQuery: true<br/>        eventSource: true<br/>      peer0.org2.example.com:<br/>        endorsingPeer: true<br/>        chaincodeQuery: false<br/>        ledgerQuery: true<br/>        eventSource: false</span><span id="244c" class="ly kd hu lu b fv mg ma l mb mc">organizations:<br/>  Org1:<br/>    mspid: Org1MSP<br/>    peers:<br/>      - peer0.org1.example.com<br/>      - peer1.org1.example.com<br/>    certificateAuthorities:<br/>      - ca.org1.example.com<br/>    adminPrivateKey:<br/>      path: crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore/1a11ffdebfb3bba13a7738dfa820a505002d29ba3e812657a127f27ba79345e5_sk<br/>    signedCert:<br/>      path: crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/Admin@org1.example.com-cert.pem</span><span id="be9d" class="ly kd hu lu b fv mg ma l mb mc">orderers:<br/>  orderer.example.com:<br/>    url: grpcs://localhost:7050<br/>    grpcOptions:<br/>      ssl-target-name-override: orderer.example.com<br/>      grpc-max-send-message-length: 15<br/>    tlsCACerts:<br/>      path: crypto-config/ordererOrganizations/example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><span id="2493" class="ly kd hu lu b fv mg ma l mb mc">peers:<br/>  peer0.org1.example.com:<br/>    url: grpcs://localhost:7051<br/>    eventUrl: grpcs://localhost:7053<br/>    grpcOptions:<br/>      ssl-target-name-override: peer0.org1.example.com<br/>      grpc.keepalive_time_ms: 600000<br/>    tlsCACerts:<br/>      path: crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/tlscacerts/tlsca.org1.example.com-cert.pem</span><span id="1c2f" class="ly kd hu lu b fv mg ma l mb mc">  peer1.org1.example.com:<br/>    url: grpcs://localhost:8051<br/>    eventUrl: grpcs://localhost:8053<br/>    grpcOptions:<br/>      ssl-target-name-override: peer1.org1.example.com<br/>      grpc.keepalive_time_ms: 600000<br/>    tlsCACerts:<br/>      path: crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp/tlscacerts/tlsca.org1.example.com-cert.pem</span><span id="4d06" class="ly kd hu lu b fv mg ma l mb mc">certificateAuthorities:<br/>  ca.org1.example.com:<br/>    url: https://localhost:7054<br/>    httpOptions:<br/>      verify: false<br/>    tlsCACerts:<br/>      path: crypto-config/peerOrganizations/org1.example.com/ca/ca.org1.example.com-cert.pem<br/>    registrar:<br/>      - enrollId: admin<br/>        enrollSecret: adminpw<br/>    caName: ca-org1</span></pre><p id="968b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里要注意的重要事情是应用程序将用来存储密钥和证书的凭证存储。</p><p id="abb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有关连接配置文件的详细说明，请查看<a class="ae jp" href="https://fabric-sdk-node.github.io/tutorial-network-config.html" rel="noopener ugc nofollow" target="_blank">https://fabric-SDK-node . github . io/tutorial-network-config . html</a>。</p><h1 id="b420" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第三步。创建用于生成管理加密材料的脚本。</h1><p id="98f9" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">为了从客户端提交事务，您需要在SDK中设置用户内容。但是，在此之前，我们需要为组织的管理员注册并获得证书。下面是一个简单的脚本，<code class="eh md me mf lu b">./enrollAdmin.js</code></p><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="c6a5" class="ly kd hu lu b fv lz ma l mb mc">'use strict';<br/>var fabricClient = require('./Config/FabricClient');<br/>var FabricCAClient = require('fabric-ca-client');</span><span id="8b57" class="ly kd hu lu b fv mg ma l mb mc">var connection = fabricClient;<br/>var fabricCAClient;<br/>var adminUser;</span><span id="c8ad" class="ly kd hu lu b fv mg ma l mb mc">connection.initCredentialStores().then(() =&gt; {<br/>  fabricCAClient = connection.getCertificateAuthority();<br/>  return connection.getUserContext('admin', true);<br/>}).then((user) =&gt; {<br/>  if (user) {<br/>    throw new Error("Admin already exists");<br/>  } else {<br/>    return fabricCAClient.enroll({<br/>      enrollmentID: 'admin',<br/>      enrollmentSecret: 'adminpw',<br/>      attr_reqs: [<br/>          { name: "hf.Registrar.Roles" },<br/>          { name: "hf.Registrar.Attributes" }<br/>      ]<br/>    }).then((enrollment) =&gt; {<br/>      console.log('Successfully enrolled admin user "admin"');<br/>      return connection.createUser(<br/>          {username: 'admin',<br/>              mspid: 'Org1MSP',<br/>              cryptoContent: { privateKeyPEM: enrollment.key.toBytes(), signedCertPEM: enrollment.certificate }<br/>          });<br/>    }).then((user) =&gt; {<br/>      adminUser = user;<br/>      return connection.setUserContext(adminUser);<br/>    }).catch((err) =&gt; {<br/>      console.error('Failed to enroll and persist admin. Error: ' + err.stack ? err.stack : err);<br/>      throw new Error('Failed to enroll admin');<br/>    });<br/>  }<br/>}).then(() =&gt; {<br/>    console.log('Assigned the admin user to the fabric client ::' + adminUser.toString());<br/>}).catch((err) =&gt; {<br/>    console.error('Failed to enroll admin: ' + err);<br/>});</span></pre><p id="b8fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一个名为<code class="eh md me mf lu b">./Config/FabricClient</code>的文件，它扩展了FabricClient SDK的功能，以提供增强的特性。</p><p id="59c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在您可以运行上面的脚本来生成一个管理证书，它将被存储在<code class="eh md me mf lu b">ConnectionProfile.yml</code>中提到的加密存储中</p><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="4b3d" class="ly kd hu lu b fv lz ma l mb mc">node enrollAdmin.js</span></pre><p id="dc73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相应的结果应该是这样的，</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mh"><img src="../Images/a6f46d164a0053137eca60eed798e0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MNJG3YHwW1lQeoU9.png"/></div></div></figure><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="44a7" class="ly kd hu lu b fv lz ma l mb mc">var FabricClient = require('fabric-client');<br/>var fs = require('fs');<br/>var path = require('path');</span><span id="3593" class="ly kd hu lu b fv mg ma l mb mc">var configFilePath = path.join(__dirname, './ConnectionProfile.yml');<br/>const CONFIG = fs.readFileSync(configFilePath, 'utf8')</span><span id="ec1a" class="ly kd hu lu b fv mg ma l mb mc">class FBClient extends FabricClient {<br/>    constructor(props) {<br/>        super(props);<br/>    }</span><span id="4878" class="ly kd hu lu b fv mg ma l mb mc">    submitTransaction(requestData) {<br/>        var returnData;<br/>        var _this = this;<br/>        var channel = this.getChannel();<br/>        var peers = this.getPeersForOrg();<br/>        var event_hub = this.getEventHub(peers[0].getName());<br/>        return channel.sendTransactionProposal(requestData).then(function (results) {<br/>            var proposalResponses = results[0];<br/>            var proposal = results[1];<br/>            let isProposalGood = false;</span><span id="51c5" class="ly kd hu lu b fv mg ma l mb mc">            if (proposalResponses &amp;&amp; proposalResponses[0].response &amp;&amp;<br/>                proposalResponses[0].response.status === 200) {<br/>                isProposalGood = true;<br/>                console.log('Transaction proposal was good');<br/>            } else {<br/>                throw new Error(results[0][0].details);<br/>                console.error('Transaction proposal was bad');<br/>            }<br/>            returnData = proposalResponses[0].response.payload.toString();<br/>            returnData = JSON.parse(returnData);</span><span id="cee7" class="ly kd hu lu b fv mg ma l mb mc">            if (isProposalGood) {<br/>                console.log(<br/>                    'Successfully sent Proposal and received ProposalResponse: Status - %s, message - "%s"',<br/>                    proposalResponses[0].response.status, proposalResponses[0].response.message);</span><span id="434b" class="ly kd hu lu b fv mg ma l mb mc">                var request = {<br/>                    proposalResponses: proposalResponses,<br/>                    proposal: proposal<br/>                };</span><span id="7687" class="ly kd hu lu b fv mg ma l mb mc">                var transaction_id_string = requestData.txId.getTransactionID();<br/>                var promises = [];</span><span id="2e0b" class="ly kd hu lu b fv mg ma l mb mc">                var sendPromise = channel.sendTransaction(request);<br/>                promises.push(sendPromise); </span><span id="5274" class="ly kd hu lu b fv mg ma l mb mc">                let txPromise = new Promise((resolve, reject) =&gt; {<br/>                    let handle = setTimeout(() =&gt; {<br/>                        event_hub.disconnect();<br/>                        resolve({ event_status: 'TIMEOUT' });<br/>                    }, 3000);<br/>                    event_hub.connect();</span><span id="37ec" class="ly kd hu lu b fv mg ma l mb mc">                    event_hub.registerTxEvent(transaction_id_string, (tx, code) =&gt; {<br/>                        clearTimeout(handle);<br/>                        event_hub.unregisterTxEvent(transaction_id_string);<br/>                        event_hub.disconnect();</span><span id="2020" class="ly kd hu lu b fv mg ma l mb mc">                        var return_status = { event_status: code, tx_id: transaction_id_string };<br/>                        if (code !== 'VALID') {<br/>                            console.error('The transaction was invalid, code = ' + code);<br/>                            resolve(return_status);<br/>                        } else {<br/>                            console.log('The transaction has been committed on peer ' + event_hub._ep._endpoint.addr);<br/>                            resolve(return_status);<br/>                        }<br/>                    }, (err) =&gt; {<br/>                        console.log(err)<br/>                        reject(new Error('There was a problem with the eventhub ::' + err));<br/>                    });<br/>                });<br/>                promises.push(txPromise);</span><span id="6b6d" class="ly kd hu lu b fv mg ma l mb mc">                return Promise.all(promises);<br/>            } else {<br/>                console.error('Failed to send Proposal or receive valid response. Response null or status is not 200. exiting...');<br/>                throw new Error('Failed to send Proposal or receive valid response. Response null or status is not 200. exiting...');<br/>            }<br/>        }).then((results) =&gt; {<br/>            console.log('Send transaction promise and event listener promise have completed');<br/>            if (results &amp;&amp; results[0] &amp;&amp; results[0].status === 'SUCCESS') {<br/>                console.log('Successfully sent transaction to the orderer.');<br/>            } else {<br/>                console.error('Failed to order the transaction. Error code: ' + response.status);<br/>            }</span><span id="f2ec" class="ly kd hu lu b fv mg ma l mb mc">            if (results &amp;&amp; results[1] &amp;&amp; results[1].event_status === 'VALID') {<br/>                console.log('Successfully committed the change to the ledger by the peer');<br/>            } else {<br/>                console.log('Transaction failed to be committed to the ledger due to ::' + results[1].event_status);<br/>            }<br/>        }).then(function () {<br/>            return returnData;<br/>        })<br/>    }</span><span id="2a82" class="ly kd hu lu b fv mg ma l mb mc">    query(requestData) {<br/>        var channel = this.getChannel();<br/>        return channel.queryByChaincode(requestData).then((response_payloads) =&gt; {<br/>            var resultData = JSON.parse(response_payloads.toString('utf8'));<br/>            return resultData;<br/>        }).then(function(resultData) {<br/>            if (resultData.constructor === Array) {<br/>                resultData = resultData.map(function (item, index) {<br/>                    if (item.data) {<br/>                        return item.data<br/>                    } else {<br/>                        return item;<br/>                    }<br/>                })<br/>            }</span><span id="9c74" class="ly kd hu lu b fv mg ma l mb mc">            return resultData;<br/>        });<br/>    }<br/>}</span><span id="ab9d" class="ly kd hu lu b fv mg ma l mb mc">var fabricClient = new FBClient();<br/>fabricClient.loadFromConfig(configFilePath);</span><span id="8d6c" class="ly kd hu lu b fv mg ma l mb mc">module.exports = fabricClient;</span></pre><p id="a0c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的脚本中，我扩展了基本客户端，并创建了一个函数来提交事务并查询数据以在检索后清理数据。这些将用于将来的目的。</p><h1 id="7ef8" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">步骤4:创建基本端点</h1><p id="2bbf" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">现在我们所有的基本东西都准备好了，让我们从提交一个名为<code class="eh md me mf lu b">sell</code>的事务的端点开始。</p><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="896c" class="ly kd hu lu b fv lz ma l mb mc">const express = require('express')<br/>const app = express()<br/>var bodyParser = require('body-parser')</span><span id="abbc" class="ly kd hu lu b fv mg ma l mb mc">//Attach the middleware<br/>app.use( bodyParser.json() );</span><span id="447b" class="ly kd hu lu b fv mg ma l mb mc">app.post('/api/sell', function (req, res) {<br/>  // ...<br/>})</span></pre><h1 id="8935" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">第五步。建立一个模型类</h1><p id="5cbb" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">我们将创建一个模型类，它将像一个库函数一样执行一组与应用程序相关的操作，这些操作将由每条路由使用。</p><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="09fd" class="ly kd hu lu b fv lz ma l mb mc">var fabricClient = require('./Config/FabricClient');<br/>var FabricCAClient = require('./Config/FabricCAClient');</span><span id="1f8d" class="ly kd hu lu b fv mg ma l mb mc">class ExampleNetwork {</span><span id="c8f7" class="ly kd hu lu b fv mg ma l mb mc">  constructor(userName) {<br/>    this.currentUser;<br/>    this.issuer;<br/>    this.userName = userName;<br/>    this.connection = fabricClient;<br/>  }</span><span id="a681" class="ly kd hu lu b fv mg ma l mb mc">  init() {<br/>    var isAdmin = false;<br/>    if (this.userName == "admin") {<br/>      isAdmin = true;<br/>    }<br/>    return this.connection.initCredentialStores().then(() =&gt; {<br/>      return this.connection.getUserContext(this.userName, true)<br/>    }).then((user) =&gt; {<br/>      this.issuer = user;<br/>      if (isAdmin) {<br/>        return user;<br/>      }<br/>      return this.ping();<br/>    }).then((user) =&gt; {<br/>      this.currentUser = user;<br/>      return user;<br/>    })<br/>  }</span><span id="21cd" class="ly kd hu lu b fv mg ma l mb mc">   sell(data) {<br/>    var tx_id = this.connection.newTransactionID();<br/>    var requestData = {<br/>      fcn: 'createProduct',<br/>      args: [data.from, data.to, data.product, data.quantity],<br/>      txId: tx_id<br/>    };<br/>    var request = FabricModel.requestBuild(requestData);<br/>    return this.connection.submitTransaction(request);<br/>  }<br/>}</span></pre><p id="74a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的代码中，你会注意到我们再次使用了和以前一样的<code class="eh md me mf lu b">fabricClient</code>。此外，我们有一个向系统提交<code class="eh md me mf lu b">sell</code>交易建议的功能。</p><p id="1942" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，模型接受构造函数中的<code class="eh md me mf lu b">userName</code>，并将其设置为客户端当前实例的上下文。在我们的例子中，管理员将签署这个交易。</p><h1 id="9e74" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">步骤6:桥接库和服务器端点</h1><p id="0e45" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">一旦我们创建了库和服务器端点，让我们从服务器函数调用库，如下所示。</p><pre class="jr js jt ju fq lt lu lv lw aw lx dt"><span id="1f72" class="ly kd hu lu b fv lz ma l mb mc">const ExampleNetwork = require('./ExampleNetwork');<br/>app.post('/api/sell', function(req, res) {<br/>        var data = req.body.data;<br/>        var exampleNetwork = new ExampleNetwork('admin');</span><span id="ee24" class="ly kd hu lu b fv mg ma l mb mc">exampleNetwork.init().then(function(data) {<br/>          return exampleNetwork.sell(data)<br/>        }).then(function (data) {<br/>          res.status(200).json(data)<br/>        }).catch(function(err) {<br/>          res.status(500).json({error: err.toString()})<br/>        })<br/>})</span></pre><p id="20bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您注意到，上面的代码使用admin作为用户名与网络交互。如果您有多个用户，只要证书存在于存储中，您就可以使用相应的用户名呼叫网络。在我的下一篇文章中，我将解释如何为多用户场景处理用户管理和会话管理。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mi mj l"/></div></figure></div></div>    
</body>
</html>