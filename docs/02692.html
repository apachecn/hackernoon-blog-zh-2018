<html>
<head>
<title>Process Large Data from Excel File with a Breeze</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松处理Excel文件中的大量数据</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/process-large-data-from-excel-file-with-a-breeze-3db39e189c82?source=collection_archive---------4-----------------------#2018-03-26">https://medium.com/hackernoon/process-large-data-from-excel-file-with-a-breeze-3db39e189c82?source=collection_archive---------4-----------------------#2018-03-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="95a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你需要的只是文件中的数据时，为什么还要上传文件呢？更干净，更快避免连接超时，损坏的数据只需添加excel_uploader js</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/ef7b590642ce44cb13d57a6686930402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCVH-S0ApqxVBDSBTaCyzw.jpeg"/></div></div></figure><h1 id="f463" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">1.概观</h1><p id="e0c7" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">从excel文件中可靠地批量上传数据有时可能是一件棘手的工作。这就是如何用一个简单的<a class="ae le" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>库驯服野兽。</p><p id="1202" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个库不会先将整个文件上传到服务器，然后再进行处理，而是在本地机器上处理文件，然后将提取的数据(这是您实际需要的)批量上传到服务器，从而为您节省一些带宽。</p><p id="7616" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为它是成批上传的，所以连接超时之类的问题得到了解决。除此之外，它还报告在服务器上导致异常的数据，并以Excel文件的形式提供下载</p><h1 id="fc87" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">2.问题是</h1><p id="b6d9" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我需要从3000到16000行的excel文件中批量上传用户记录。每个excel记录(一行)将用于在系统中创建一个用户帐户。这包括访问多个数据库表、发送电子邮件、数据验证以及一个或多个循环。</p><p id="6ef6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先想到的技术是寻找excel库，将excel文件上传到服务器，处理excel文件，最后返回成功或错误消息——所有这些都在一个HTTP请求中完成！</p><p id="73eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法的缺点是:</p><p id="f96f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">- HTTP请求超时，特别是使用非多线程的<a class="ae le" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言</p><p id="337b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">-不可靠的错误报告</p><p id="25b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">诸如此类。</p><h1 id="a0f4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">3.解决方案</h1><p id="8730" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我做的是在客户端浏览器用JavaScript提取数据，将这些数据批量推送到服务器。</p><p id="77c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在服务器端，接收到的数据在一个<code class="eh lf lg lh li b">try…catch</code>块中进行处理，引发异常的数据存储在一个错误数组中。一旦服务器处理完当前批处理，它就向客户端发送OK响应，同时发送错误数据(如果有的话)。</p><p id="0d41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">这个过程的另一个关键技术是数据库事务管理</strong>。特定记录的所有数据库交互都是在服务器端的DB事务范围内完成的。如果在数据库交互过程中出现错误，事务将回滚，否则将被提交。</p><p id="52aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在编程中，通常有不止一种方法来实现一项壮举，每种方法都有自己的缺点。然而，这种技术在错误报告和HTTP连接管理方面是可靠的。</p><h1 id="d0d6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">4.使用excel_uploader.js JavaScript库</h1><p id="c177" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我在一个名为excel_uploader.js的简单JavaScript文件中实现了上述解决方案。要在项目中使用JavaScript文件:我们需要从其<a class="ae le" href="https://github.com/SeunMatt/excel_uploader" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中获取库，并将其与jQuery、xlsx.min.js、FileSaver.js以及可选的bootstrap 4和sweetalert.js一起包含在项目中:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="5e50" class="ln kc hu li b fv lo lp l lq lr">&lt;!-- required --&gt;<br/>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;</span><span id="c270" class="ln kc hu li b fv ls lp l lq lr">&lt;!--- optional --&gt;<br/>&lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt;<br/>&lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt;</span><span id="631c" class="ln kc hu li b fv ls lp l lq lr">&lt;!-- needed by older browsers --&gt;<br/>&lt;script src="https://github.com/eligrey/Blob.js"&gt;&lt;/script&gt;</span><span id="7da6" class="ln kc hu li b fv ls lp l lq lr">&lt;!-- Required --&gt;<br/>&lt;script src="https://rawgit.com/eligrey/FileSaver.js/src/FileSaver.js"&gt;&lt;/script&gt;<br/>&lt;script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"&gt;&lt;/script&gt;<br/>&lt;script src="https://cdn.rawgit.com/SeunMatt/excel_uploader/4f4ebd93/src/excel_uploader.js"&gt;&lt;/script&gt;</span></pre><p id="4fc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注意，在较旧的浏览器上需要</strong> <a class="ae le" href="https://github.com/eligrey/Blob.js" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Blob.js </strong> </a> <strong class="it hv">才能让FileSaver.js工作。</strong></p><p id="8c9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将把它添加到希望excel上载发生的HTML页面中:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="f017" class="ln kc hu li b fv lo lp l lq lr">&lt;script&gt;<br/>    $(document).ready( function () {<br/>        new ExcelUploader({<br/>            maxInAGroup: 1000,<br/>            serverColumnNames: ["Name", "Email", "Phone Number"],<br/>            importTypeSelector: "#dataType",<br/>            fileChooserSelector: "#fileUploader",<br/>            outputSelector: "#tableOutput",<br/>            extraData: {_token: "23333323323223323232"}<br/>        });<br/>    });<br/>&lt;/script&gt;</span></pre><p id="860b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从上面的片段中，我们用配置参数实例化了<em class="lt"> ExcelUploader </em>对象。以下是对每个参数及其作用的解释。</p><p id="1bdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> maxInAGroup: </strong>该参数控制每次发送到服务器的记录数量。默认值为1000，因此如果源excel文件中有5000条记录，数据将分5批上传到服务器。它可以根据可用资源根据我们的口味进行微调。</p><p id="9ccd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> serverColumnNames </strong>:这是服务器期望的列的数组。每次<em class="lt"> excel_uploader </em>向服务器推送数据时，也会发送一个<em class="lt"> column_map </em>。</p><p id="6865" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<em class="lt"> serverColumnNames </em>中元素的小写形式作为键，使用相应excel列的索引作为值，生成列映射。</p><p id="5863" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，如果服务器希望上传的excel数据包含3列—姓名、电子邮件和电话号码。</p><p id="4e43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用户将首先上传一个excel文件，然后在excel中映射哪个列代表什么数据。然后<em class="lt"> excel_uploader </em>将使用小写的<em class="lt"> serverColumnNames、</em>用下划线(_)字符替换空格来组成服务器列名。</p><p id="eed8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，最后的服务器将收到一个JSON有效负载，如下所示:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="ebf0" class="ln kc hu li b fv lo lp l lq lr">{<br/>  "column_map":{"name":0,"email":2,"phone_number":1}, <br/>  "data":[ <br/>        ["name1", "08010xxx", "email1@g.com"],<br/>        ["name2", "08020xxx", "email2@g.com"],<br/>        ["name3", "08030xxx", "email3@g.com"],<br/>        ...<br/>     ]<br/>}</span></pre><p id="bd2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以解释为列<em class="lt">名称</em>在数据的索引零(0)，电子邮件在索引二(2)，电话号码<em class="lt">在索引1。</em></p><p id="b68b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> importTypeSelector </strong>:这是HTML <em class="lt"> select </em>字段的jQuery选择器。<strong class="it hv">选择选项的值是excel数据发送到的实际URL(如果选择了该选项)。</strong>这样就可以使用同一个页面进行多次上传。只需将目标URL作为选项添加到导入类型选择器中。</p><p id="2c81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">文件选择选择器:</strong>这是HTML文件输入字段的jQuery选择器。用于用户从本地存储中实际选择excel文件。</p><p id="c7f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> outputSelector </strong>:这是HTML div的jQuery选择器，用于显示进度、状态和错误消息。</p><p id="904c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> extraData </strong>:这是与上传的数据和列映射一起发送到服务器的数据。例如，CSRF·托肯。这是一个可选参数。</p><p id="e56f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们已经查看了选项，我们一定已经注意到我们需要在我们的web页面上添加一些标记，这样才能工作。</p><p id="af33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此需要下面的HTML:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="c348" class="ln kc hu li b fv lo lp l lq lr">&lt;!--This is the import type selector--&gt;<br/>&lt;div class="form-group"&gt;<br/>    &lt;select class="form-control" id="dataType"&gt;<br/>        &lt;option value="-1" disabled selected&gt;Select Data to Import&lt;/option&gt;<br/>        &lt;option selected value="http://localhost/excel_uploader/demo/php/demo.php"&gt;Import Posts Data&lt;/option&gt;<br/>    &lt;/select&gt;<br/>&lt;/div&gt;</span><span id="6847" class="ln kc hu li b fv ls lp l lq lr">&lt;!-- This is the file chooser input field--&gt;<br/>&lt;div class="form-group"&gt;<br/>    &lt;input type="file" id="fileUploader" class="btn btn-fill btn-primary btn-large" /&gt;<br/>&lt;/div&gt;</span><span id="380d" class="ln kc hu li b fv ls lp l lq lr">&lt;!-- This is the Blank output/progress div--&gt;<br/>&lt;div id="tableOutput"&gt;&lt;/div&gt;</span></pre><p id="aee6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整的HTML可以在demo.html的<a class="ae le" href="https://github.com/SeunMatt/excel_uploader/tree/master/demo" rel="noopener ugc nofollow" target="_blank">页面上找到。</a></p><p id="d5d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:在上面的JavaScript代码片段中，HTML元素各自的id用于配置<em class="lt"> ExcelUploader </em>对象。这就是我们在前端需要做的一切。简单不是吗？</p><h1 id="f228" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">5.一点点服务器端处理</h1><p id="6472" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><strong class="it hv"> <em class="lt"> excel_uploader.js </em>库与服务器端无关！</strong>它几乎可以与任何服务器端技术一起工作。它只需要知道通过<em class="lt"> importTypeSelector </em>推送数据的URL，如此而已。</p><p id="c448" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将使用jQuery ajax在POST请求中将数据推送到服务器。POST请求有效载荷将包含两个强制条目:<em class="lt">数据</em>和<em class="lt">列_映射</em>。</p><p id="5979" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">数据</strong>:这是数组中的数组——代表用户上传的excel文件中的数据。它是JSON格式的，应该被解码成一个键值数据结构，比如PHP中的关联数组或者Java中的<em class="lt"> Map </em>或者其他服务器端编程语言中的等效物。</p><p id="0781" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">外部数组表示整体，而内部数组表示excel文件中每一行的数据。因此，<em class="lt">数据[0] </em>的长度数将是上传期间映射的列数，而<em class="lt">数据</em>数组本身的长度是上传文件中可用的行/记录总数。</p><p id="2a7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是在post请求中收到的数据示例:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="08b2" class="ln kc hu li b fv lo lp l lq lr">{<br/>  "column_map":{"name":0,"email":2,"phone_number":1}, <br/>  "data":[ <br/>        ["name1", "08010xxx", "email1@g.com"],<br/>        ["name2", "08020xxx", "email2@g.com"],<br/>        ["name3", "08030xxx", "email3@g.com"],<br/>        ...<br/>     ]<br/>}</span></pre><h2 id="eb79" class="ln kc hu bd kd lu lv lw kh lx ly lz kl jc ma mb kp jg mc md kt jk me mf kx mg dt translated">5.1.访问数据</h2><p id="2084" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">从上一节中我们了解到，<em class="lt"> column_map </em>将列名与包含在<em class="lt">数据中的数组中的相应索引相关联。</em></p><p id="1574" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们可以通过将JSON有效负载解析为键值数据结构(如关联数组(PHP)或映射(Java))来访问数据。</p><p id="a022" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在PHP CodeIgniter中，我们可以这样做:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="69fb" class="ln kc hu li b fv lo lp l lq lr">$columnMap = json_decode($this-&gt;input-&gt;post("column_map"), true);</span><span id="2861" class="ln kc hu li b fv ls lp l lq lr">//to get the name of the first row<br/>$name = $data[0][$columnMap["name"]];</span><span id="c659" class="ln kc hu li b fv ls lp l lq lr">//to get the email of the first row<br/>$email = $data[0][$columnMap["email"]];</span><span id="799e" class="ln kc hu li b fv ls lp l lq lr">//to get the phone_number in first row<br/>$phoneNumber = $data[0][$columnMap["phone_number"]];</span><span id="11c7" class="ln kc hu li b fv ls lp l lq lr">//we can definitely use a loop to process all the data</span></pre><p id="9469" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你注意到了，从上面的片段中，我们不需要记住<em class="lt">数据</em>数组中每一列的对应索引。我们简单地使用<em class="lt"> column_map </em>，这要容易得多。</p><p id="3bdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果服务器端在像Spring Boot这样的框架中使用Java编程语言，同样的事情也是适用的:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="49e8" class="ln kc hu li b fv lo lp l lq lr">//extract the index of the columns we're expecting from the map<br/>int nameIndex = Integer.parseInt(columnMap.get("name").toString());<br/>int emailIndex = Integer.parseInt(columnMap.get("email").toString());<br/>int phoneIndex = Integer.parseInt(columnMap.get("phone_number").toString());</span><span id="e698" class="ln kc hu li b fv ls lp l lq lr">//save a user<br/>User user = new User();<br/>user.setName(data.get(nameIndex));<br/>user.setEmail(data.get(emailIndex));<br/>user.setPhone(data.get(phoneIndex));<br/>user.setPassword("newHashedPassword");<br/>User savedUser = userRepository.save(user);</span></pre><p id="5086" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae le" href="https://github.com/SeunMatt/excel_uploader/tree/master/demo/php" rel="noopener ugc nofollow" target="_blank"> PHP </a>和<a class="ae le" href="https://github.com/SeunMatt/excel_uploader/tree/master/demo/java/exceluploaderdemo" rel="noopener ugc nofollow" target="_blank"> Java </a>的完整演示代码可以在<a class="ae le" href="https://github.com/SeunMatt/excel_uploader/tree/master/demo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="5c99" class="ln kc hu bd kd lu lv lw kh lx ly lz kl jc ma mb kp jg mc md kt jk me mf kx mg dt translated">5.2.处理数据</h2><p id="9ac0" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">处理传入post数据的最好方法之一是有两个方法(或函数)。</p><p id="24e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中POST有效载荷将被解码，数据数组将被循环，我们称之为<em class="lt"> uploadUserData() </em>。</p><p id="967a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个函数中，会有一个<em class="lt"> $errorArray </em>变量，它本身必须是一个数组的数组。从POST有效负载解码的<em class="lt">数据</em>数组将被循环，该数据的每个元素(对应于excel文件中的一行)将由另一个方法<em class="lt"> doUserUpload() </em>处理。</p><p id="845c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">方法<em class="lt"> doUserUpload </em>将在封装在数据库事务中的<code class="eh lf lg lh li b"><em class="lt">try … catch</em></code>块中执行数据库交互。如果任何数据库交互失败，它将回滚数据库更改并返回false，否则返回true。</p><p id="6af6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果<em class="lt"> doUserUpload </em>返回<em class="lt"> false </em>，正在处理的特定记录/行将被添加到<em class="lt"> $errorArray </em></p><p id="a120" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PHP中<em class="lt"> uploadUserData() </em>的实现示例:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="e58d" class="ln kc hu li b fv lo lp l lq lr">$errorArray = [];</span><span id="41cf" class="ln kc hu li b fv ls lp l lq lr">//this is where the data will be handled and process<br/>foreach ($data as $datum) {<br/>   if(!empty($datum) &amp;&amp; !$this-&gt;doUserUpload($datum,  $columnMap)) {<br/>     //that means there was an error processing the file<br/>     //so we will just add this $datum to the errorArray<br/>     array_push($errorArray, $datum);<br/>   }<br/>}</span><span id="da9e" class="ln kc hu li b fv ls lp l lq lr">//....</span><span id="9901" class="ln kc hu li b fv ls lp l lq lr">//after all the data has been processed, let's respond to the client<br/>if(!empty($errorArray)) {<br/>    //there was an error somewhere. Let's send the client the affected data<br/>    $this-&gt;respond(json_encode(["data" =&gt; $errorArray]));<br/>} else{<br/>    $this-&gt;respond(json_encode(["success" =&gt; "OK"]));<br/>}</span></pre><p id="320d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">完整的服务器端处理示例可以在</strong><a class="ae le" href="https://github.com/SeunMatt/excel_uploader/tree/master/demo" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/></a><strong class="it hv">中找到。相应的Java演示也可以在这里</strong>  <strong class="it hv">找到</strong> <a class="ae le" href="https://github.com/SeunMatt/excel_uploader/tree/master/demo/java/exceluploaderdemo" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">。</strong></a></p><h2 id="00fc" class="ln kc hu bd kd lu lv lw kh lx ly lz kl jc ma mb kp jg mc md kt jk me mf kx mg dt translated"><strong class="ak"> 5.3。服务器响应</strong></h2><p id="5a18" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">这个流程的关键步骤是服务器响应。服务器应该用JSON响应，内容类型应该是<em class="lt">应用程序/json </em>。</p><p id="6dcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果任何上传的数据在处理时导致错误，并被添加到<em class="lt"> errorArray </em>中，则产生的错误数组应被发送到excel_uploader.js，否则，应发送成功消息:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="ae58" class="ln kc hu li b fv lo lp l lq lr">if(!empty($errorArray)) {<br/>    //there was an error somewhere. Let's send the user some data that are affected.<br/>    $this-&gt;respond(json_encode(["data" =&gt; $errorArray]));<br/>} else{<br/>    $this-&gt;respond(json_encode(["success" =&gt; "OK"]));<br/>}</span></pre><p id="392e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者在Java中:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="45c3" class="ln kc hu li b fv lo lp l lq lr">if(errors.isEmpty()) {<br/>    //all is well during the process<br/>    responseMap.put("success", "OK");<br/>    return ResponseEntity.ok(responseMap);<br/>}</span><span id="ced7" class="ln kc hu li b fv ls lp l lq lr">//there are errors and some data are not processed.<br/>// Let's send those data back to the client<br/>//note that we're sending the OK response 200<br/>//it's just that we're appending some error data that might have been present<br/>responseMap.put("data", errors);<br/>return ResponseEntity.ok(mapper.writeValueAsString(responseMap));</span></pre><p id="f04c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们注意到正在发送一个无效数据，并且我们想要通知用户，我们可以发送一个JSON响应，其中包含一个错误条目和一个200状态代码——因为我们实际上自己处理了这个错误:</p><pre class="jq jr js jt fq lj li lk ll aw lm dt"><span id="5404" class="ln kc hu li b fv lo lp l lq lr">if(count($data[0]) &lt; 3 || count($columnMap) &lt; 3) {<br/>    $this-&gt;respond(json_encode([<br/>      "error" =&gt; "The Data Seems not to be complete! " . count($columnMap) . " columns were mapped instead of 3"]), 200);<br/>}</span></pre><p id="a1e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:JSON响应应该有一个状态代码200，以便excel_uploader.js能够处理它。</p><p id="3960" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果有任何其他服务器生成的错误，它们将在ajax方法的fails()回调中处理。</p><h1 id="dfdf" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">6.汤好了！</h1><p id="e034" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">只需一点点JavaScript，一点点config和HTML，我们就可以开始了。好的一面是，我们可以使用同一个页面将数据上传到许多端点，即使有额外的负载。只需将URL作为另一个选项添加到<em class="lt"> importTypeSelector </em>中，就可以了。</p><p id="48e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想听听你将这个简单的工具集成到你的项目中的经历。如果您发现任何bug，请向Github报告。</p><p id="6ee5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">github:【https://github.com/SeunMatt/excel_uploader T2】</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><blockquote class="mo mp mq"><p id="56cd" class="ir is lt it b iu iv iw ix iy iz ja jb mr jd je jf ms jh ji jj mt jl jm jn jo hn dt translated">你听说过<a class="ae le" href="https://palcrib.app.link/medium" rel="noopener ugc nofollow" target="_blank">吗？这是我正在开发的一个新的社交媒体应用。如果你喜欢我的作品，你一定会喜欢这个应用程序。现在就从谷歌PlayStore下载吧，让我知道你的想法</a></p></blockquote></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mu mv l"/></div></figure></div></div>    
</body>
</html>