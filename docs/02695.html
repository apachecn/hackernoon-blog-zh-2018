<html>
<head>
<title>The Assignment Problem &amp; Calculating the Minimum Matrix Sum (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">指派问题&amp;计算最小矩阵和(Python)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-assignment-problem-calculating-the-minimum-matrix-sum-python-1bba7d15252d?source=collection_archive---------7-----------------------#2018-03-26">https://medium.com/hackernoon/the-assignment-problem-calculating-the-minimum-matrix-sum-python-1bba7d15252d?source=collection_archive---------7-----------------------#2018-03-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/e17ac0f88eb368914799ec70fc91907b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cj41dGWZjuCVRSFr.jpg"/></div></div></figure><div class=""/><p id="f946" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑以下问题:</p><p id="29f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于疏忽，你的家急需修理。很自然地，你会去获取关于改造和修复需要做的事情的报价。让我们假设您收到的四个报价如下所示:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ka"><img src="../Images/d6050c2759d8ef2803176ccea5d0e229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mV-hCb1-WF7DNu42IZnZkQ.png"/></div></div></figure><p id="1280" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从各方面考虑，这似乎很合理。我们自然会选择苏珊，因为她给了我们最好的综合价格。然而，另一个解决方案可能是将我们需要做的事情分解成单独的项目。然后我们可以从我们的承包商那里得到每个维修项目的价格。这在两个方面更有利:</p><ol class=""><li id="145a" class="kf kg if je b jf jg jj jk jn kh jr ki jv kj jz kk kl km kn dt translated">我们将节省时间，因为所有承包商可以同时处理每个维修项目，从而更快地完成整个项目。</li><li id="2dae" class="kf kg if je b jf ko jj kp jn kq jr kr jv ks jz kk kl km kn dt translated">我们也可以根据承包商的最低项目成本来雇佣他们，从而获得更好的价格。</li></ol><p id="0dc5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看下面的图表，这些单个价格可能是什么样的:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kt"><img src="../Images/4c81d7aa6ecc501985987ba8db00b1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0k0lwZbp41qlqDvMiEyng.png"/></div></div></figure><p id="4ca9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们这样做的时候，我们需要记住两件事:</p><ol class=""><li id="23e5" class="kf kg if je b jf jg jj jk jn kh jr ki jv kj jz kk kl km kn dt translated">为了最大限度地利用时间，我们可能只想为一项工作雇用一名承包商。</li><li id="6649" class="kf kg if je b jf ko jj kp jn kq jr kr jv ks jz kk kl km kn dt translated">这意味着我们不能两次使用同一个承包商，自然，我们在任何时候都不会有两个承包商从事同一项工作。</li></ol><p id="8566" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，我们可以选择以下内容:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ku"><img src="../Images/c6f060aa96204879be6ab1ccf4657221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SL28Jg9n6ADEQrjD5XI-8Q.png"/></div></div></figure><p id="fa20" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用这种策略，我们可以通过将工作分配给4个承包商来最大限度地减少我们的时间，但是我们也可以通过为每个维修项目雇佣承包商来最大限度地降低我们的成本。尽管这看起来很简单，但如果我们有更多的承包商可供选择，或者有更多的维修工作要考虑，计算起来可能会非常困难。幸运的是，有一个很好的公式可以解决这类问题。我将使用一种叫做匈牙利方法的东西。<strong class="je ig">匈牙利方法</strong>是一种组合优化算法，它在多项式时间内解决分配问题，并预测了后来的原始对偶方法。该算法是由哈罗德·库恩于1955年开发并发表的，他将该算法命名为“匈牙利方法”，因为该算法在很大程度上是基于两位匈牙利数学家德内斯·kőnig和jenő·埃格尔瓦里的早期工作。在使用伪代码解决了这个问题之后，我将看看我们如何使用Python创建一个函数来使用相同的方法解决它。使用Python的优势在于，无论网格大小如何，我们都可以创建一个动态函数来求解我们的方程。如果像上面的例子一样，我们决定增加更多的维修，或者获得更多的承包商报价，这可能会特别方便。希望随着我们的深入，这一策略的其他应用将变得显而易见。</p><p id="86ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">匈牙利方法基本上有三个步骤:</p><h2 id="1826" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">1.找出每列中的最小值。</h2><ul class=""><li id="f99c" class="kf kg if je b jf lq jj lr jn ls jr lt jv lu jz lv kl km kn dt translated">将每列中的最低值转换为零。</li><li id="dd6b" class="kf kg if je b jf ko jj kp jn kq jr kr jv ks jz lv kl km kn dt translated">从同一列中的其他值中减去每列中的最小值。</li></ul><h2 id="c55d" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">2.找出每一行中的最小值。</h2><ul class=""><li id="b162" class="kf kg if je b jf lq jj lr jn ls jr lt jv lu jz lv kl km kn dt translated">如果行中的最小值还不是零，那么将其转换为零。</li><li id="aa01" class="kf kg if je b jf ko jj kp jn kq jr kr jv ks jz lv kl km kn dt translated">再次从每行的剩余值中减去每行的最小值。</li></ul><h2 id="4d6f" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">3.选择只有零的行/列(如我们在上面的例子中所做的)。</h2><p id="9f35" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">这种方法背后的原因是:在每一列中，我们都有自己的工作。每一列中的最低值代表我们必须支付的最低价格。因此，通过将该值设置为零，我们可以从其他列值中减去该值。这些行代表我们必须支付给承包商的价格。最小行值表示我们必须支付给每个承包商的最低价格，同样，将它设置为零允许我们从该行的其他值中减去它。让我们看看如何将这种方法应用于我们当前的问题:</p><h2 id="b4f1" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">步骤1:将最低的列值设置为0。</h2><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lz"><img src="../Images/91ff8284f46ba04a6060c04093e851f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeekaXnvW9Chse5-55t69A.png"/></div></div></figure><p id="2115" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们可以看到每一列都有一个零。但是，只有第1、3和4行有零，第4行有2个零。现在，我们将从剩余的列值中减去已经转换为零的最小值。这里，我已经更新了列1，从剩余的列值中减去最小值70，剩下15、30和80:</p><h2 id="b104" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">步骤1:从其他列值中减去最低的列值。</h2><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lz"><img src="../Images/6a98672937d47df4d0a9ee3ec358d3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hcu_14c0vwhu56p55jTHuw.png"/></div></div></figure><p id="fc40" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们将浏览剩余的列，并对它们进行更新:</p><h2 id="014c" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">步骤1:从其他列值中减去最低的列值。</h2><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ma"><img src="../Images/f05d60eb5d5085343e87d4a82810cc85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*od-jemlpE72d9WSD5GQuyA.png"/></div></div></figure><p id="c934" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们会注意到每一列都包含一个零。但是，只有第1、3和4行有一个零，第2行有两个零。从这里，我们继续第二步。我们现在循环遍历这些行，仅当该行当前没有零时，才将每行中的最小值转换为零。</p><h2 id="70bf" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">步骤2:确定不包含0值的行中最低的行值。</h2><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lz"><img src="../Images/b3ec3cf79d4164d70a3d4b2d07f5e2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZQPyynzbV6V9nKQ39llAQ.png"/></div></div></figure><p id="0895" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，重复上一步，我们将从该行的剩余值中减去该值:</p><h2 id="a156" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">第2步:从该行的其他值中减去最低的行值。</h2><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lz"><img src="../Images/ae89165fc6c517e1f83193246ed42e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgA83-Z6gxP5SJRrqIokBg.png"/></div></div></figure><h2 id="bf70" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">第三步:确定并分配最底层的工作给承包商。</h2><p id="e607" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">完成第2步后，我们可以看到每一行和每一列都有一个零，这给我们带来了将适当的工作分配给每个承包商的挑战。从这里开始，我们将只选择值为零的行或列。在第4行，我们可以选择Susan进行粉刷或铺地板。我们可以选择迭戈或苏珊铺地板。如果我们手动分配适当的列和行值，而不使用Python或其他程序，我们可能只是首先选择没有其他选择的值。这里，列2和列4只给我们一个选择，所以我们可以先选择那些。在为Susan选择铺地板还是刷油漆时，我们可以看到，如果我们为Susan选择铺地板，我们就删除了第4行，这样第1列就没有替代零了。因此，唯一可能的解决方案是Diego负责地板，Susan负责油漆，这样我们就可以为每一行和每一列选择一个零。</p><p id="d56d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们最初决定的，只有一个4x4的矩阵，并不困难。但是想象一下如果我们的矩阵大得多。试图以这种方式分配工作，以最大限度地减少时间和费用将是非常困难的。这种方法使得那些计算变得容易得多。</p><p id="eda3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们看看如何创建一个程序来解决这个问题。我的目标不是简单地编写一个程序来解决这个问题，而是编写代码来解决任何大小矩阵的问题，允许我在多个应用程序中重用代码。您可以看到这样做在各种环境中是多么有用。</p><p id="b1a7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我将把我们的矩阵放在一个数组中，这样会更容易处理。然后，如果我需要重复使用代码，我只需刷出一个新的数组。</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="7dbb" class="kv kw if mc b fv mg mh l mi mj">arr = [100, 130, 115, 55, 150, 75, 35, 110, 85, 50, 120, 120, 70, 150, 25, 90]</span></pre><p id="1eab" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，清楚地知道我们下一步要做什么是很好的。对我来说，记录几件事是有意义的。我有这个数字列表，但是记住匈牙利方法是如何工作的，我们想知道关于每个数字的几件事，比如它的当前值是什么，它的修改值是什么，数字在哪一行，在哪一列。我可能还想知道列表中出现的索引值。对我来说，将我的数字列表转换成python字典列表是有意义的。python字典看起来很像JavaScript对象。基本上我想做的是:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mk"><img src="../Images/de7b96afdfcc3776fb36fc6dce7a911f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6YsclcCb98AQjUk6zMzLw.png"/></div></div></figure><p id="d35a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，在将每个值转换成一个字典后，我就可以在循环中从每个数字中获得更多信息。拥有修改后的值和原始值也有帮助，因为虽然修改后的值将帮助我们分配最终要使用的值，但是原始值是实际的价格或成本，我们最终需要参考它。</p><p id="5cc2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我将设置一些变量，帮助我将数字列表转换为词典列表:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="47d6" class="kv kw if mc b fv mg mh l mi mj">arr2 = []<br/>numberOfRows = 4<br/>numberOfColumns = 4<br/>column = 0</span></pre><h2 id="892b" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">arr2</h2><p id="7ba1" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">—当我遍历我的原始列表<code class="eh ml mm mn mc b">arr</code>时，我会将修改后的字典推送到我的新列表<code class="eh ml mm mn mc b">arr2</code>的字典中。</p><h2 id="3251" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">行数和列数</h2><p id="95b5" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">这些变量的伟大之处在于，它们将帮助我们跟踪我们在矩阵中的位置。此外，它将帮助我们保持代码的可重用性。将来，如果我们改变这个矩阵，或者开始一个新的矩阵，我们可以只更新列表，行数和列数，Python会重新计算剩下的。这让我们在未来几乎没有什么可改变的。</p><h2 id="c542" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">圆柱</h2><p id="4735" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">这个变量将为我们提供一个遍历列表的起点。我们可以不断增加它，并相应地更新我们的字典。</p><p id="6e8a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们将开始我们的for循环，并给它一个条件:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="ce72" class="kv kw if mc b fv mg mh l mi mj">for idx, val in enumerate(arr):<br/>    row = len(arr2)/numberOfRows+1<br/>    column = column + 1<br/>    if column &gt; numberOfColumns:<br/>        column = 1</span></pre><h2 id="41f5" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">对于idx，枚举中的值(arr):</h2><p id="795a" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">Python中的enumerate方法将允许我们查看每个列表项中的值和索引号。这将帮助我们获得添加到对象中的<code class="eh ml mm mn mc b">index value</code>，以及<code class="eh ml mm mn mc b">original value</code>。</p><h2 id="3865" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">row = len(arr2)/numberOfRows+1</h2><p id="92ed" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">这就是我们跟踪将哪个行值添加到当前字典中的方式。例如，如果我们在For循环中的第一项，我们还没有向<code class="eh ml mm mn mc b">arr2</code>添加任何东西。所以<code class="eh ml mm mn mc b">arr2</code>的长度会是0。我们知道，在这个练习中，行数是4，所以0/4+1 = 1。因此，我们的行将是1。但是如果我们在最后一个项目上，我们已经为<code class="eh ml mm mn mc b">arr2</code>增加了很多。此时<code class="eh ml mm mn mc b">arr2</code>的长度为15。所以15/4 = 3 + 1 = 4。那么这一行就是4。</p><h2 id="6e2c" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">列=列+ 1</h2><p id="469b" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">在这里，因为我们的原始值是0，我们只是增加1，因为没有列0。在每个列表项之后，我们的列将增加1。</p><h2 id="2db7" class="kv kw if bd kx ky kz la lb lc ld le lf jn lg lh li jr lj lk ll jv lm ln lo lp dt translated">如果列&gt;列数:<br/>列= 1</h2><p id="dbb2" class="pw-post-body-paragraph jc jd if je b jf lq jh ji jj lr jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz hn dt translated">我们这里的条件有助于我们跟踪这些列。例如，在这种情况下，我们不能连续增加列数，因为最大列数是4。因此，由于我们是将列递增1，如果在循环中的每一项的开始，如果当前列号大于4，它将重置回1，并再次开始递增，直到我们再次到达5，并将重置。</p><p id="5d5f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们将创建我们的字典:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="304e" class="kv kw if mc b fv mg mh l mi mj">idx = {<br/>        "row": row,<br/>        "column": column,<br/>        "index": idx,<br/>        "original_value": val,<br/>        "modified_value": val,<br/>    }<br/>    arr2.append(idx)</span></pre><p id="f9d4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们只是使用我们已经设置的值，并创建键值对以允许我们以后访问这些值。下面是整个代码块的样子:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="dfe1" class="kv kw if mc b fv mg mh l mi mj">for idx, val in enumerate(arr):<br/>    row = len(arr2)/numberOfRows+1<br/>    column = column + 1<br/>    if column &gt; numberOfColumns:<br/>        column = 1<br/>    idx = {<br/>        "row": row,<br/>        "column": column,<br/>        "index": idx,<br/>        "original_value": val,<br/>        "modified_value": val,<br/>    }<br/>    arr2.append(idx)</span></pre><p id="6c72" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我将按照列表中的原始值键对列表进行排序。稍后，我想访问每一列和每一行中的最低值，如果我将它们按最低的原始值排序，这将容易得多。我们将这样做:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="2bf0" class="kv kw if mc b fv mg mh l mi mj">newlist = sorted(arr2, key=lambda k: k['original_value'])</span></pre><p id="b65a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我现在用的变量是<code class="eh ml mm mn mc b">newlist</code>。从现在开始，我不再需要<code class="eh ml mm mn mc b">arr</code>或<code class="eh ml mm mn mc b">arr2</code>，但是我将只与这个列表<code class="eh ml mm mn mc b">newlist</code>交互。以下是我的输出，供参考:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="4ed6" class="kv kw if mc b fv mg mh l mi mj">{'column': 3, 'index': 14, 'original_value': 25, 'modified_value': 25, 'row': 4}<br/>{'column': 3, 'index': 6, 'original_value': 35, 'modified_value': 35, 'row': 2}<br/>{'column': 2, 'index': 9, 'original_value': 50, 'modified_value': 50, 'row': 3}<br/>{'column': 4, 'index': 3, 'original_value': 55, 'modified_value': 55, 'row': 1}<br/>{'column': 1, 'index': 12, 'original_value': 70, 'modified_value': 70, 'row': 4}<br/>{'column': 2, 'index': 5, 'original_value': 75, 'modified_value': 75, 'row': 2}<br/>{'column': 1, 'index': 8, 'original_value': 85, 'modified_value': 85, 'row': 3}<br/>{'column': 4, 'index': 15, 'original_value': 90, 'modified_value': 90, 'row': 4}<br/>{'column': 1, 'index': 0, 'original_value': 100, 'modified_value': 100, 'row': 1}<br/>{'column': 4, 'index': 7, 'original_value': 110, 'modified_value': 110, 'row': 2}<br/>{'column': 3, 'index': 2, 'original_value': 115, 'modified_value': 115, 'row': 1}<br/>{'column': 3, 'index': 10, 'original_value': 120, 'modified_value': 120, 'row': 3}<br/>{'column': 4, 'index': 11, 'original_value': 120, 'modified_value': 120, 'row': 3}<br/>{'column': 2, 'index': 1, 'original_value': 130, 'modified_value': 130, 'row': 1}<br/>{'column': 1, 'index': 4, 'original_value': 150, 'modified_value': 150, 'row': 2}<br/>{'column': 2, 'index': 13, 'original_value': 150, 'modified_value': 150, 'row': 4}</span><span id="06ac" class="kv kw if mc b fv mo mh l mi mj">[Finished in 0.089s]</span></pre><p id="e034" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个好主意，因为我们正在打印每个列表的结果，以确保我们得到了我们期望的数据。</p><p id="2341" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我将创建空白列表:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="79e6" class="kv kw if mc b fv mg mh l mi mj">columnsTested = []<br/>columnAndValue = []</span></pre><p id="48d7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我这里的想法是循环通过newlist。因为它是按原始值组织的，所以我将把每一列中最低的值追加到<code class="eh ml mm mn mc b">columnAndValue</code>中，只把列值推入<code class="eh ml mm mn mc b">columnsTested</code>。这样，我可以创建一个条件，检查<code class="eh ml mm mn mc b">x</code>列是否已经在<code class="eh ml mm mn mc b">columnsTested</code>中。如果是，我就略过。</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="f25d" class="kv kw if mc b fv mg mh l mi mj">for i in newlist:<br/>    testObj = {<br/>        "column": i['column'],<br/>        "minVal": i['original_value']<br/>    }</span></pre><p id="fbb7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了开始我的列表，我创建了一个列和<code class="eh ml mm mn mc b">original value</code>的对象，稍后我将对照我的<code class="eh ml mm mn mc b">newlist</code>列表测试这个对象。我可以说，如果这个<code class="eh ml mm mn mc b">testObj</code>中的列与我的<code class="eh ml mm mn mc b">newlist</code>项的列匹配，我将从newlist中修改后的值中减去<code class="eh ml mm mn mc b">testObj</code>中的<code class="eh ml mm mn mc b">minVal</code>。只是想让你知道我的计划是什么。</p><p id="b377" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我来补充我的条件:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="e8b6" class="kv kw if mc b fv mg mh l mi mj">if i['column'] not in columnsTested:<br/>        columnAndValue.append(testObj)<br/>        columnsTested.append(i['column'])</span></pre><p id="fccd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，<code class="eh ml mm mn mc b">newlist</code>中的前6或7个条目可能在不同的列中，但是因为它是从最低值开始组织的，所以它可能会抓取第2列中的条目和索引3。那么索引4处的值也可能在列2中。但是它不会获得第二个值，因为第2列中的一个值已经存在于<code class="eh ml mm mn mc b">columnsTested</code>中。并且它附加到<code class="eh ml mm mn mc b">columnAndValue</code>的第一个值低于第二个值。</p><p id="dcc1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是这段代码的整体外观:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="4b44" class="kv kw if mc b fv mg mh l mi mj">columnsTested = []<br/>columnAndValue = []<br/>for i in newlist:<br/>    testObj = {<br/>        "column": i['column'],<br/>        "minVal": i['original_value']<br/>    }<br/>    if i['column'] not in columnsTested:<br/>        columnAndValue.append(testObj)<br/>        columnsTested.append(i['column'])</span></pre><p id="bfc3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我将执行一个嵌套的for循环，根据columnAndValue中的字典测试newlist中的字典。如果每个中的列都匹配，我将根据newlist中的modifiedValue从columnAndValue中sub rect minVal。在这一点上，modifiedValue和originalValue是相同的，但是这将给出我们想要的两个值的差异。</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="3b3a" class="kv kw if mc b fv mg mh l mi mj">for i in newlist:<br/>    for j in columnAndValue:<br/>        if i['column'] == j['column']:<br/>            i['modified_value'] = i['modified_value'] - j['minVal']</span></pre><p id="ea88" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很直接，对吧？同样，检查是个好主意，通过打印<code class="eh ml mm mn mc b">newlist</code>的内容来确保我们得到了我们期望的数据。我们的输出可能如下所示:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="4495" class="kv kw if mc b fv mg mh l mi mj">{'column': 3, 'index': 14, 'original_value': 25, 'modified_value': 0, 'row': 4}<br/>{'column': 3, 'index': 6, 'original_value': 35, 'modified_value': 10, 'row': 2}<br/>{'column': 2, 'index': 9, 'original_value': 50, 'modified_value': 0, 'row': 3}<br/>{'column': 4, 'index': 3, 'original_value': 55, 'modified_value': 0, 'row': 1}<br/>{'column': 1, 'index': 12, 'original_value': 70, 'modified_value': 0, 'row': 4}<br/>{'column': 2, 'index': 5, 'original_value': 75, 'modified_value': 25, 'row': 2}<br/>{'column': 1, 'index': 8, 'original_value': 85, 'modified_value': 15, 'row': 3}<br/>{'column': 4, 'index': 15, 'original_value': 90, 'modified_value': 35, 'row': 4}<br/>{'column': 1, 'index': 0, 'original_value': 100, 'modified_value': 30, 'row': 1}<br/>{'column': 4, 'index': 7, 'original_value': 110, 'modified_value': 55, 'row': 2}<br/>{'column': 3, 'index': 2, 'original_value': 115, 'modified_value': 90, 'row': 1}<br/>{'column': 3, 'index': 10, 'original_value': 120, 'modified_value': 95, 'row': 3}<br/>{'column': 4, 'index': 11, 'original_value': 120, 'modified_value': 65, 'row': 3}<br/>{'column': 2, 'index': 1, 'original_value': 130, 'modified_value': 80, 'row': 1}<br/>{'column': 1, 'index': 4, 'original_value': 150, 'modified_value': 80, 'row': 2}<br/>{'column': 2, 'index': 13, 'original_value': 150, 'modified_value': 100, 'row': 4}</span><span id="b979" class="kv kw if mc b fv mo mh l mi mj">[Finished in 0.107s]</span></pre><p id="c856" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们将重复最后两步，但是目标是行而不是列，但是该代码的所有构建块将完全相同:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="8e2d" class="kv kw if mc b fv mg mh l mi mj">rowsTested = []<br/>rowAndValue = []<br/>for i in newlist:<br/>    testObj = {<br/>        "row": i["row"],<br/>        "minVal": i["modified_value"],<br/>        "modified": i["modified_value"]<br/>    }<br/>    if i['row'] not in rowsTested:<br/>        rowAndValue.append(testObj)<br/>        rowsTested.append(i['row'])</span><span id="67f5" class="kv kw if mc b fv mo mh l mi mj">for i in newlist:<br/>    for j in rowAndValue:<br/>        if i['row'] == j['row'] and j['modified'] &gt; 0:<br/>            i['modified_value'] = i['modified_value'] - j['minVal']</span></pre><p id="471f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">瞧啊。现在，如果我们打印newlist，我们可以看到带有0的四个值位于列表的顶部，我们可以很容易地选择那些没有出现在重复的行或列中的值。我们的输出应该如下所示:</p><pre class="kb kc kd ke fq mb mc md me aw mf dt"><span id="8f27" class="kv kw if mc b fv mg mh l mi mj">{'column': 3, 'index': 14, 'original_value': 25, 'modified_value': 0, 'row': 4}<br/>{'column': 3, 'index': 6, 'original_value': 35, 'modified_value': 0, 'row': 2}<br/>{'column': 2, 'index': 9, 'original_value': 50, 'modified_value': 0, 'row': 3}<br/>{'column': 4, 'index': 3, 'original_value': 55, 'modified_value': 0, 'row': 1}<br/>{'column': 1, 'index': 12, 'original_value': 70, 'modified_value': 0, 'row': 4}<br/>{'column': 2, 'index': 5, 'original_value': 75, 'modified_value': 15, 'row': 2}<br/>{'column': 1, 'index': 8, 'original_value': 85, 'modified_value': 15, 'row': 3}<br/>{'column': 4, 'index': 15, 'original_value': 90, 'modified_value': 35, 'row': 4}<br/>{'column': 1, 'index': 0, 'original_value': 100, 'modified_value': 30, 'row': 1}<br/>{'column': 4, 'index': 7, 'original_value': 110, 'modified_value': 45, 'row': 2}<br/>{'column': 3, 'index': 2, 'original_value': 115, 'modified_value': 90, 'row': 1}<br/>{'column': 3, 'index': 10, 'original_value': 120, 'modified_value': 95, 'row': 3}<br/>{'column': 4, 'index': 11, 'original_value': 120, 'modified_value': 65, 'row': 3}<br/>{'column': 2, 'index': 1, 'original_value': 130, 'modified_value': 80, 'row': 1}<br/>{'column': 1, 'index': 4, 'original_value': 150, 'modified_value': 70, 'row': 2}<br/>{'column': 2, 'index': 13, 'original_value': 150, 'modified_value': 100, 'row': 4}</span><span id="14e3" class="kv kw if mc b fv mo mh l mi mj">[Finished in 0.082s]</span></pre><p id="c8bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">伟大的事情是，虽然这需要一些时间来建立，我们现在可以评估任何矩阵，对于任何类似的问题。</p></div></div>    
</body>
</html>