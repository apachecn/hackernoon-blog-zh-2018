<html>
<head>
<title>Mailing it out with Mailgun!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Mailgun寄出去！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mailing-it-out-with-mailgun-9302400bed52?source=collection_archive---------32-----------------------#2018-03-26">https://medium.com/hackernoon/mailing-it-out-with-mailgun-9302400bed52?source=collection_archive---------32-----------------------#2018-03-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/73bb06515d9ef077b51643129452cc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*IO1Zoh7mEHACMEvtKlKtxQ.jpeg"/></div></figure><p id="4651" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae jw" href="https://mmhaskell.com/blog/2018/3/19/sending-texts-with-twilio-and-haskell" rel="noopener ugc nofollow" target="_blank">上周</a>，我们通过集成Haskell和Twilio开始了对API世界的探索。我们能够发送基本的SMS消息，然后创建一个能够响应用户消息的服务器。本周，我们将尝试另一种效果:发送电子邮件。我们将使用<a class="ae jw" href="https://www.mailgun.com/" rel="noopener ugc nofollow" target="_blank"> Mailgun </a>完成这项任务，同时使用<a class="ae jw" href="https://hackage.haskell.org/package/hailgun" rel="noopener ugc nofollow" target="_blank"> Hailgun </a> Haskell API。</p><p id="0044" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可以通过查看我们的Github资源库上的<code class="eh jx jy jz ka b"><a class="ae jw" href="https://github.com/jhb563/HaskellApisSeries/tree/mailgun" rel="noopener ugc nofollow" target="_blank">mailgun</a></code>分支来查看本文的完整代码。如果这篇文章激发了你对更多Haskell库的好奇心，你应该下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！</p><h1 id="cb11" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">做账</h1><p id="a422" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">首先，我们显然需要一个mailgun帐户。注册是免费和简单的。它会问你一个电子邮件域，但你不需要一个开始。只要您处于测试模式，您就可以使用他们提供的沙盒域来托管您的邮件服务器。</p><p id="771c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于Twilio，我们必须指定一个“经过验证”的电话号码，以便在测试模式下发送消息。同样，您还需要指定一个经过验证的电子邮件地址。您的沙盒域将只能向此地址发送邮件。你还需要保存一些关于你的Mailgun账户的信息。特别是，您需要您的API密钥、沙盒电子邮件域以及您的电子邮件要使用的回复地址。将这些作为环境变量保存在本地系统和远程机器上。</p><h1 id="1679" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">基本电子邮件</h1><p id="7113" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">现在，让我们通过发送一封基本的电子邮件来感受一下Hailgun代码。所有这些都发生在简单的<code class="eh jx jy jz ka b">IO</code>单子上。我们最终想要使用函数<code class="eh jx jy jz ka b">sendEmail</code>，它需要一个<code class="eh jx jy jz ka b">HailgunContext</code>和一个<code class="eh jx jy jz ka b">HailgunMessage</code>:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="a571" class="lm kc hu ka b fv ln lo l lp lq">sendEmail<br/>  :: HailgunContext<br/>  -&gt; HailgunMessage<br/>  -&gt; IO (Either HailgunErrorResponse HailgunSendResponse)</span></pre><p id="1bed" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将从检索环境变量开始。利用我们的域和API键，我们可以构建需要作为参数传递的<code class="eh jx jy jz ka b">HailgunContext</code>。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="1a1d" class="lm kc hu ka b fv ln lo l lp lq">import Data.ByteString.Char8 (pack)</span><span id="23ed" class="lm kc hu ka b fv lr lo l lp lq">sendMail :: IO ()<br/>sendMail = do<br/>  domain &lt;- getEnv “MAILGUN_DOMAIN”<br/>  apiKey &lt;- getEnv “MAILGUN_API_KEY”<br/>  replyAddress &lt;- pack &lt;$&gt; getEnv “MAILGUN_REPLY_ADDRESS”<br/>  -- Last argument is an optional proxy<br/>  let context = HailgunContext domain apiKey Nothing<br/>  ...</span></pre><p id="a872" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，为了构建消息本身，我们将使用一个构建函数<code class="eh jx jy jz ka b">hailgunMessage</code>。它需要几个不同的参数:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="ceb1" class="lm kc hu ka b fv ln lo l lp lq">hailgunMessage<br/> :: MessageSubject<br/> -&gt; MessageContent<br/> -&gt; UnverifiedEmailAddress -- Reply Address, just a ByteString<br/> -&gt; MessageRecipients<br/> -&gt; [Attachment]<br/> -&gt; Either HailgunErrorMessage HailgunMessage</span></pre><p id="7b61" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这些都很好填。<code class="eh jx jy jz ka b">MessageSubject</code>是<code class="eh jx jy jz ka b">Text</code>，然后我们将从上面传递我们的回复地址。对于内容，我们将从使用纯文本电子邮件的<code class="eh jx jy jz ka b">TextOnly</code>构造函数开始。稍后我们将看到一个如何在内容中使用HTML的例子:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="850c" class="lm kc hu ka b fv ln lo l lp lq">sendMail :: IO ()<br/>sendMail = do<br/>  …<br/>  replyAddress &lt;- pack &lt;$&gt; getEnv “MAILGUN_REPLY_ADDRESS”<br/>  let msg = mkMessage replyAddress<br/>  …<br/>  where<br/>    mkMessage replyAddress = hailgunMessage<br/>      “Hello Mailgun!”<br/>      (TextOnly “This is a test message.”)<br/>      replyAddress<br/>      ...</span></pre><p id="19d9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh jx jy jz ka b">MessageRecipients</code>类型有三个字段。首先是直接收件人，然后是抄送电子邮件，然后是密件抄送用户。我们目前只发送给一个用户。所以我们可以选择<code class="eh jx jy jz ka b">emptyMessageRecipients</code>项并修改它。现在，我们将通过提供一个空的附件列表来结束我们的构造:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="a272" class="lm kc hu ka b fv ln lo l lp lq">where<br/>  mkMessage replyAddress = hailgunMessage<br/>    “Hello Mailgun!”<br/>    (TextOnly “This is a test message.”)<br/>    replyAddress<br/>    (emptyMessageRecipients { recipientsTo = [“verified@mail.com”] } )<br/>    []</span></pre><p id="d49d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果有问题，<code class="eh jx jy jz ka b">hailgunMessage</code>函数会抛出一个错误，就像<code class="eh jx jy jz ka b">sendEmail</code>函数本身一样。但是，只要我们检查这些错误，我们就能很好地发送电子邮件！</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="7dca" class="lm kc hu ka b fv ln lo l lp lq">createAndSendEmail :: IO ()<br/>createAndSendEmail = do<br/>  domain &lt;- getEnv “MAILGUN_DOMAIN”<br/>  apiKey &lt;- getEnv “MAILGUN_API_KEY”<br/>  replyAddress &lt;- pack &lt;$&gt; getEnv “MAILGUN_REPLY_ADDRESS”<br/>  let context = HailgunContext domain apiKey Nothing<br/>  let msg = mkMessage replyAddress<br/>  case msg of<br/>    Left err -&gt; putStrLn (“Making failed: “ ++ show err)<br/>    Right msg’ -&gt; do<br/>      result &lt;- sendEmail context msg<br/>      case result of<br/>        Left err -&gt; putStrLn (“Sending failed: “ ++ show err)<br/>        Right resp -&gt; putStrLn (“Sending succeeded: “ ++ show rep)</span></pre><p id="529c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，当我们从类型定义开始时，构建所有的函数是多么容易。我们可以研究每种类型，找出它需要什么。在这篇关于<a class="ae jw" href="https://mmhaskell.com/haskell-brain-4" rel="noopener ugc nofollow" target="_blank">编译驱动学习</a>的文章中，我对这个想法进行了更多的思考，这是我们为Haskell新手准备的<a class="ae jw" href="https://mmhaskell.com/haskell-brain" rel="noopener ugc nofollow" target="_blank"> Haskell大脑系列</a>的一部分！</p><h1 id="cffa" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">有效的电子邮件</h1><p id="ef4c" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">现在，我们想将发送电子邮件整合到我们的服务器中。正如你从查看<a class="ae jw" href="https://github.com/jhb563/HaskellApisSeries/blob/mailgun/src/Server.hs" rel="noopener ugc nofollow" target="_blank">源代码</a>中注意到的，我修改了服务器以使用免费的单子。在我们的系统中有许多不同的影响，这有助于我们保持他们的直线。查看<a class="ae jw" href="https://mmhaskell.com/blog/2017/11/20/eff-to-the-rescue" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解更多关于自由单子和Eff库的细节。首先，我们想把发送电子邮件描述成一种效果。我们将从一个只有一个构造函数的简单数据类型开始:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="af2e" class="lm kc hu ka b fv ln lo l lp lq">data Email a where<br/>  SendSubscribeEmail :: Text -&gt; Email (Either String ())</span><span id="1ff0" class="lm kc hu ka b fv lr lo l lp lq">sendSubscribeEmail :: (Member Email r)<br/>  =&gt; Text -&gt; Eff r (Either String ())<br/>sendSubscribeEmail email = send (SendSubscribeEmail email)</span></pre><p id="a865" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们需要一种方法来剥离堆栈中的<code class="eh jx jy jz ka b">Email</code>效果，只要我们有<code class="eh jx jy jz ka b">IO</code>就可以做到这一点。我们将模仿我们已经编写的转换的<code class="eh jx jy jz ka b">sendEmail</code>函数。现在，我们将接收用户的电子邮件作为输入！</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="1930" class="lm kc hu ka b fv ln lo l lp lq">runEmail :: (Member IO r) =&gt; Eff (Email ': r) a -&gt; Eff r a<br/>runEmail = runNat emailToIO<br/>  where<br/>    emailToIO :: Email a -&gt; IO a<br/>    emailToIO (SendSubscribeEmail subEmail) = do<br/>      domain &lt;- getEnv "MAILGUN_DOMAIN"<br/>      apiKey &lt;- getEnv "MAILGUN_API_KEY"<br/>      replyEmail &lt;- pack &lt;$&gt; getEnv "MAILGUN_REPLY_ADDRESS"<br/>      let context = HailgunContext domain apiKey Nothing<br/>      case mkSubscribeMessage replyEmail (encodeUtf8 subEmail) of<br/>        Left err -&gt; return $ Left err<br/>        Right msg -&gt; do<br/>          result &lt;- sendEmail context msg<br/>          case result of<br/>            Left err -&gt; return $ Left (show err)<br/>            Right resp -&gt; return $ Right ()</span></pre><h1 id="c3fa" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">扩展我们的短信处理程序</h1><p id="87c5" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">现在我们已经恰当地描述了发送电子邮件的效果，让我们把它合并到我们的服务器中！我们将从编写另一种数据类型开始，它将代表用户可能发给我们的潜在命令。目前，它只有“订阅”命令。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="6cd1" class="lm kc hu ka b fv ln lo l lp lq">data SMSCommand = SubscribeCommand Text</span></pre><p id="11e7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，让我们编写一个函数，它将接收他们的消息，并将其解释为一个命令。如果他们发短信，我们会给他们发邮件！</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="0042" class="lm kc hu ka b fv ln lo l lp lq">messageToCommand :: Text -&gt; Maybe SMSCommand<br/>messageToCommand messageBody = case splitOn " " messageBody of<br/>  ["subscribe", email] -&gt; Just $ SubscribeCommand email<br/>  _ -&gt; Nothing</span></pre><p id="13c1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们将扩展我们的服务器处理程序来回复。如果我们正确理解他们的命令，我们将发送电子邮件！否则，我们会给他们回短信说我们听不懂。注意我们的<code class="eh jx jy jz ka b">SMS</code>效果和<code class="eh jx jy jz ka b">Email</code>效果是这个处理程序的一部分:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="06c8" class="lm kc hu ka b fv ln lo l lp lq">smsHandler :: (Member SMS r, Member Email r)<br/>  =&gt; IncomingMessage -&gt; Eff r ()<br/>smsHandler msg = <br/>  case messageToCommand (body msg) of<br/>    Nothing -&gt; sendText (fromNumber msg) <br/>      "Sorry, we didn't understand that request!"<br/>    Just (SubscribeCommand email) -&gt; do<br/>      _ &lt;- sendSubscribeEmail email<br/>      return ()</span></pre><p id="e7a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们的服务器将能够在用户“订阅”时发送电子邮件！</p><h1 id="5e0e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">附加文件</h1><p id="7f1c" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">让我们把我们的电子邮件变得复杂一点。现在我们只发送一封非常简单的电子邮件。让我们修改它，使它有一个附件。我们可以通过提供文件路径和描述文件的字符串来构建附件。为了得到这个文件，我们的消息生成函数需要当前的运行目录。我们还会稍微改变一下身体。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="91f1" class="lm kc hu ka b fv ln lo l lp lq">mkSubscribeMessage :: ByteString -&gt; ByteString -&gt; FilePath -&gt; Either HailgunErrorMessage HailgunMessage<br/>mkSubscribeMessage replyAddress subscriberAddress currentDir = <br/>  hailgunMessage<br/>    "Thanks for signing up!"<br/>    content<br/>    replyAddress <br/>    (emptyMessageRecipients { recipientsTo = [subscriberAddress] })<br/>    -- Notice the attachment!<br/>    [ Attachment <br/>        (rewardFilepath currentDir)<br/>        (AttachmentBS "Your Reward")<br/>    ]<br/>  where<br/>    content = TextOnly "Here's your reward!”</span><span id="be78" class="lm kc hu ka b fv lr lo l lp lq">rewardFilepath :: FilePath -&gt; FilePath<br/>rewardFilepath currentDir = currentDir ++ "/attachments/reward.txt"</span></pre><p id="06d7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，当我们的用户注册时，他们将获得我们指定的任何附件文件！</p><h1 id="7f8c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">HTML内容</h1><p id="0b1c" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">为了展示更多的功能，让我们改变电子邮件的内容，使它包含一些HTML而不仅仅是文本！特别是，我们将让他们有机会通过点击我们服务器的链接来确认他们的订阅。这里所有的变化是我们将使用<code class="eh jx jy jz ka b">TextAndHTML</code>构造函数代替<code class="eh jx jy jz ka b">TextOnly</code>。我们确实想为我们的电子邮件提供一个纯文本的解释，以防HTML由于任何原因无法呈现。注意链接使用了<code class="eh jx jy jz ka b">&lt;a&gt;</code>标签:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="b2b7" class="lm kc hu ka b fv ln lo l lp lq">content = TextAndHTML <br/>   textOnly<br/>   ("Here's your reward! To confirm your subscription, click " &lt;&gt; <br/>     link &lt;&gt; "!")<br/>  where<br/>    textOnly = "Here's your reward! To confirm your subscription, go to "<br/>       &lt;&gt; "https://haskell-apis.herokuapp.com/api/subscribe/"<br/>       &lt;&gt; subscriberAddress<br/>       &lt;&gt; " and we'll sign you up!"<br/>   link = "&lt;a href=\"https://haskell-apis.herokuapp.com/api/subscribe/" <br/>     &lt;&gt; subscriberAddress &lt;&gt; "\"&gt;this link&lt;/a&gt;"</span></pre><p id="3ccd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们将添加另一个端点，它将捕获电子邮件作为参数，并将其保存到数据库中。<code class="eh jx jy jz ka b">Database</code>效果非常类似于<a class="ae jw" href="https://mmhaskell.com/blog/2017/11/20/eff-to-the-rescue" rel="noopener ugc nofollow" target="_blank"> Eff文章</a>中的效果。它会将电子邮件保存在一个数据库表中。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e894" class="lm kc hu ka b fv ln lo l lp lq">type ServerAPI = "api" :&gt; "ping" :&gt; Get '[JSON] String :&lt;|&gt;<br/>  "api" :&gt; "sms" :&gt; ReqBody '[FormUrlEncoded] IncomingMessage<br/>    :&gt; Post '[JSON] () :&lt;|&gt;<br/>  "api" :&gt; "subscribe" :&gt; Capture "email" Text :&gt; Get '[JSON] ()</span><span id="7fef" class="lm kc hu ka b fv lr lo l lp lq">subscribeHandler :: (Member Database r) =&gt; Text -&gt; Eff r ()<br/>subscribeHandler email = registerUser email</span></pre><p id="969a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，如果我们想写一个函数，给我们系统中的每个人发邮件，这一点也不难！我们扩展了<code class="eh jx jy jz ka b">Email</code>和<code class="eh jx jy jz ka b">Database</code>的效果类型。<code class="eh jx jy jz ka b">Database</code>函数将检索我们系统中的所有订户。同时<code class="eh jx jy jz ka b">Email</code>效果会将指定的邮件发送给整个列表。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="1a2c" class="lm kc hu ka b fv ln lo l lp lq">data Database a where<br/>  RegisterUser :: Text -&gt; Database ()<br/>  RetrieveSubscribers :: Database [Text]</span><span id="4e87" class="lm kc hu ka b fv lr lo l lp lq">data Email a where<br/>  SendSubscribeEmail :: Text -&gt; Email (Either String ())<br/>  -- First parameter is (Subject line, Text content, HTML Context)<br/>  SendEmailToList<br/>    :: (Text, ByteString, Maybe ByteString)<br/>    -&gt; [Text]<br/>    -&gt; Email (Either String ())</span></pre><p id="b01e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">组合这些只需要使用两种效果:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="f9b0" class="lm kc hu ka b fv ln lo l lp lq">sendEmailToList :: (Member Email r, Member Database r) =&gt; ByteString -&gt; ByteString -&gt; Eff r ()<br/>sendEmailToList = do<br/>  list &lt;- retrieveSubscribers<br/>  void $ sendEmailToList list</span></pre><p id="ed91" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意没有任何<code class="eh jx jy jz ka b">lift</code>电话！这是<code class="eh jx jy jz ka b">Eff</code>的酷劲之一。</p><h1 id="c8c3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="8e43" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">正如我们在本文中看到的，用Haskell发送电子邮件并不可怕。API是非常直观的，当你把事情一件一件的分解，看看涉及的类型。本文汇集了编译驱动开发和Eff框架的思想。特别是，我们可以在这个系列中看到用<code class="eh jx jy jz ka b">Eff</code>来分离我们的效果是多么的方便，这样我们就不会做很多杂乱的提升。</p><p id="e2b1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这篇文章中有很多高级材料，所以如果你认为你需要回溯，不要担心，我们已经为你准备好了！我们的<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web技能系列</a>将教你如何使用像Persistent这样的库进行数据库管理和Servant来制作API。要获得更多可以用来编写增强型Haskell的库，请下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！</p><p id="bdca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您从未使用Haskell编程，您应该尝试一下！下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank"> Haskell初学者清单</a>或者阅读我们的<a class="ae jw" href="https://www.mmhaskell.com/liftoff" rel="noopener ugc nofollow" target="_blank">升空系列</a>！</p></div></div>    
</body>
</html>