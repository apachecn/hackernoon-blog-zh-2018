<html>
<head>
<title>Codable in Swift4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift4中的可编码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/codable-in-swift4-e24f7cc253da?source=collection_archive---------1-----------------------#2018-03-27">https://medium.com/hackernoon/codable-in-swift4-e24f7cc253da?source=collection_archive---------1-----------------------#2018-03-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="14b1" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">远离繁重的NSCoding和任何其他JSON解析</h2></div><p id="a8b0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然这篇文章有点长，但相信我，这是值得的。</p><p id="86ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">大多数情况下，当一个应用程序与外部API甚至有时与本地静态数据交互时，我们实际上操作的是不同的数据类型，如JSON或plist，有时甚至是其他格式。</p><p id="8dd2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些任务通常需要在传输或消费数据时，将数据编码为中间格式或从中间格式解码。</p><p id="c86e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">大多数情况下，开发人员使用JSONSerialization来解析JSON，JSON实际上将数据转换为dictionary，您必须再次解析dictionary并将其转换为应用程序友好的数据模型，以便在每次需要时都能高效轻松地读取数据。同样，如果您必须使用一些API向外部源发送一些数据，很可能您需要再次将您的数据模型转换为字典，以便稍后将其序列化为JSON。这显然是一项需要大量手工劳动的单调乏味的任务。</p><p id="e722" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文中，我们将了解以下内容:</p><ul class=""><li id="6224" class="kg kh hu jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko dt translated">Swift4中摆脱NSCoding和JSONSerialization的新功能</li><li id="9e40" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko dt translated">在JSON数据中编码和解码定制模型</li><li id="a9cf" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko dt translated">选择特定属性进行编码/解码(跳过不必要的属性)</li><li id="386b" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko dt translated">在JSON和模型类/结构中处理不同的键名</li><li id="a949" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko dt translated">编码/解码嵌套的JSON数据</li><li id="0a07" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko dt translated">在编码和解码时合并多个嵌套层</li></ul><p id="aac2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> NSCoding </em>是现有的协议，它可以使您的数据模型进出<em class="kf"> NSData </em>以对其进行任何进一步的操作，无论是保存在<em class="kf"> NSUserDefaults </em>中，其他源还是归档/取消归档自定义对象。</p><p id="79ef" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使您的类符合<em class="kf"> NSCoding </em>协议要求您的类实现两个额外的方法<em class="kf"> encode(带编码器:)</em>和<em class="kf"> init(编码器aDecoder:) </em>，这再次要求您手动序列化和反序列化每个方法中您需要转换为编码/解码数据的属性。</p><h1 id="45c2" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">1.Swift 4中的新功能</h1><p id="df83" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">因此，这是一种拯救，Swift标准库现在包括新的协议:</p><blockquote class="lr ls lt"><p id="5cb3" class="jj jk kf jl b jm jn iv jo jp jq iy jr lu jt ju jv lv jx jy jz lw kb kc kd ke hn dt translated">简而言之，编码是将您自己的自定义类型、类或结构转换为外部数据表示类型(如JSON或plist或其他)的过程&amp;解码是将外部数据表示类型(如JSON或plist)转换为您自己的自定义类型、类或结构的过程</p></blockquote><ul class=""><li id="d417" class="kg kh hu jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko dt translated"><strong class="jl hv">可编码:</strong>用于将模型编码为数据的外部表示，如JSON或plist</li><li id="acf8" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko dt translated"><strong class="jl hv">可解码:</strong>用于将数据的外部表示解码为您的模型。</li><li id="51c8" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko dt translated"><strong class="jl hv">可编码:</strong>用于编码和解码。苹果将其定义为:</li></ul><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="cd12" class="mg kv hu mc b fv mh mi l mj mk">typealias Codable = Encodable &amp; Decodable</span></pre><p id="1171" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在您自己的类型上采用<em class="kf">可编码的</em>使您能够将它们序列化为任何内置数据格式，以及自定义编码器和解码器提供的任何格式。</p><p id="add7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么我可以编码和解码哪些类型呢？</p><p id="e1a4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想编码或解码任何模型或你的自定义类型，你必须符合<em class="kf">编码</em>。少数内置类型如<em class="kf">字符串、Int、Double、Date </em>和<em class="kf">数据</em>已经符合<em class="kf">可编码</em>。</p><p id="4c07" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">内置类型如<em class="kf">数组</em>、<em class="kf">字典</em>、<em class="kf">可选</em>只要包含<em class="kf">可编码</em>类型也符合<em class="kf">可编码</em>。</p><p id="ad81" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在下面的例子中，所有属性都可以被编码或解码，因为它们要么是标准的<em class="kf">可编码</em>类型，要么包含<em class="kf">可编码</em>类型。</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="46aa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们通过对真实场景中的数据进行编码和解码来了解更多细节:</p><p id="e0b3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有两种编码器可以将您的数据编码成所需的格式:</p><ol class=""><li id="22c5" class="kg kh hu jl b jm jn jp jq js ki jw kj ka kk ke mo km kn ko dt translated"><strong class="jl hv">PropertyListEncoder</strong>—<em class="kf">将您的类型编码为plist格式</em></li><li id="4932" class="kg kh hu jl b jm kp jp kq js kr jw ks ka kt ke mo km kn ko dt translated"><strong class="jl hv"> JSONEncoder </strong> — <em class="kf">将你的类型编码成JSON格式</em></li></ol><h1 id="0a91" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">2.在JSON数据中编码和解码定制模型</h1><p id="b79f" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">所以，让我们从编码和解码一些真实数据开始。</p><p id="bf83" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">考虑如下几种数据结构:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="d11a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">编码:</strong>让我们创建一个<em class="kf"> Car </em>实例，并将其编码为JSON</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="7193" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">解码:</strong>考虑下面的JSON，符合<em class="kf"> Car </em>类元数据。只需用JSON解码器将这个JSON解码回<em class="kf"> Car </em> object。</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><h1 id="b7be" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated"><strong class="ak"> 3。选择要编码/解码的特定属性(跳过不必要的属性)</strong></h1><p id="367f" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">您不太可能需要对所有的类/结构属性进行编码，或者将JSON的所有字段解码到您的本机模型中。在JSON中，Like和API响应可能包含一堆值，但在您的应用程序中，您可能只需要其中的几个值。在这种情况下，您可能只需要担心您感兴趣的字段，而不是解码或解析整个JSON。</p><blockquote class="lr ls lt"><p id="ad8e" class="jj jk kf jl b jm jn iv jo jp jq iy jr lu jt ju jv lv jx jy jz lw kb kc kd ke hn dt translated">可编码类型可以声明一个名为CodingKeys的特殊嵌套枚举，该枚举符合CodingKey协议。当此枚举存在时，它的事例充当对可编码类型的实例进行编码或解码时必须包括的属性的权威列表。枚举事例的名称应该与您赋予类型中相应属性的名称相匹配。如果属性在解码实例时不存在，或者某些属性不应该包含在编码表示中，则忽略CodingKeys枚举中的属性。</p></blockquote><p id="3a57" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> CodingKey枚举— </strong>使用<em class="kf"> CodingKey </em>枚举时，需要遵循的规则很少。<em class="kf"> CodingKey </em>的RawType为<em class="kf"> String </em>和<em class="kf"> Enum </em>值必须与JSON键名的大小写相匹配。</p><p id="996e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例子:考虑下面的辩护</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="20fe" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">编码:</strong>对<em class="kf">人物</em>类的对象进行编码。</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="2b96" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">解码:</strong>考虑下面的JSON，符合<em class="kf"> Person </em>类元数据。来自JSON的解码对象将只有填充的<em class="kf">姓名、年龄、性别</em>属性，但是“<em class="kf">电话</em>”和“<em class="kf">国家</em>”将为<em class="kf">空</em>，因为我们在<em class="kf">编码密钥</em>枚举中排除了这些编码/解码属性。</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><h1 id="b9be" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated"><strong class="ak"> 4。在JSON和模型类/结构中处理不同的键名</strong></h1><p id="e006" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">正如到目前为止可能意识到的，声明<em class="kf">编码键</em>需要<em class="kf">枚举</em>值与你的类或结构中声明的属性名完全一致。</p><p id="d9d0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是在现实世界中，从外部API接收的JSON格式的数据可能有完全不同的键名，这些键名可能与类中定义的属性名匹配，也可能不匹配。例如，在一些针对图书列表的API响应中，book <em class="kf"> name </em> key可能是'<em class="kf"> bookName </em>'，但这并不意味着您也必须在您的模型中对属性使用相同的名称。如果您只想使用'<em class="kf">名称</em>'并且这个'<em class="kf">名称</em>'应该自动映射到JSON中定义的'<em class="kf">图书名称</em>'键，该怎么办。</p><p id="b294" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗯，你可以用一点点代码来实现它，让我们看看如何实现，考虑下面的类声明:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="8772" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">编码:</strong>让我们创建一个<em class="kf"> Book </em>对象并编码</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="97c0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个编码json将按照上面定义的<em class="kf">编码键</em>枚举来重命名JSON中的属性名。</p><p id="e788" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="kf">名称</em> </strong> <em class="kf">属性将被重命名为</em> <strong class="jl hv"> <em class="kf">书名</em></strong><em class="kf"><br/></em><strong class="jl hv"><em class="kf">作者</em> </strong> <em class="kf">属性将被重命名为</em> <strong class="jl hv"> <em class="kf">作者</em></strong><em class="kf"><br/></em><strong class="jl hv"><em class="kf">页数</em> </strong></p><p id="3049" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所有其他属性在JSON中的名称都与在Book类中定义的名称相同。</p><p id="4eb9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">解码:</strong>考虑下面的JSON，符合<em class="kf">书</em>类元数据。来自JSON的解码对象会自动将JSON键映射到<em class="kf"> Book </em>类中各自的属性。</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="3988" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> 5。编码/解码嵌套的JSON数据</strong></p><p id="f755" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然我已经在第一个例子中介绍过了，但是让我们再来看一下如何在JSON数据中，甚至在您自己的类/结构中处理多层嵌套对象。让我们从下面的类声明开始，它是由Apple文档中的一个例子启发而来的:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="070d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">任何包含<em class="kf">可编码</em>数据类型的自定义类型或集合都可以被编码和解码。在上面的例子中，我们的每个嵌套类都是<em class="kf">可编码的</em>，同样的还有<em class="kf">超市</em>。</p><p id="0a77" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">编码:</strong>让我们创建一个超市并对其进行编码。</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="da5d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不言自明！只需检查<em class="kf"> encodedObjectJsonString </em>，它将拥有所有级别的嵌套信息。</p><p id="abc4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">解码:</strong>考虑上例中为<em class="kf">encodedObjectJsonString</em>变量创建的JSON，为了节省空间，我不会再放这个JSON了，我们只是重用同一个变量，并尝试将同一个JSON解码回<em class="kf">超市</em>对象。(为什么不试一试，通过添加多个<em class="kf">产品/货架/通道</em>来创建一个JSON？)</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="9729" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">非常管用！</p><h1 id="9131" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated"><strong class="ak"> 6。编解码时合并多个嵌套层次</strong></h1><p id="7e39" class="pw-post-body-paragraph jj jk hu jl b jm lm iv jo jp ln iy jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">所有这些例子都非常好，除非你说你不想在你的对象模型中保留和JSON中相同的嵌套层次，或者你不想在你的JSON中保留和你在类中定义的相同的嵌套层次。让我们一个一个地瞄准:</p><p id="b97d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> 6.A .在编码为JSON时移除对象级嵌套</strong></p><p id="50f4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">考虑下面符合某种JSON结构的类声明:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="8108" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当您将它编码成JSON时，您将得到类似如下的内容:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="95dd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但实际上你想成为这样的人:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="8ca8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们更新我们的<em class="kf">照片</em>类如下:</p><p id="4b15" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，通过指定所需层次结构中的<em class="kf">枚举</em>值，在Photo类中包含一个<em class="kf"> CodingKey </em>枚举:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="2bfc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，<em class="kf"> CodingKeys </em> enum包括<em class="kf"> height </em>和<em class="kf"> width </em> enum值，而不是我们到目前为止所遵循的<em class="kf"> Size </em>。</p><p id="c502" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，您需要在您的类中显式实现<em class="kf">可编码</em>和<em class="kf">可解码</em>协议的<em class="kf">编码(to:) </em>和<em class="kf">初始化(from:) </em>方法:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="853b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">并且，一旦你现在通过映射<em class="kf"> height </em>和<em class="kf"> width </em>键到你的<em class="kf"> Size </em> struct在你的对象模型中编码你的对象模型或者解码JSON数据回到你的类模型。</p><p id="b444" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> 6.B .解码到对象模型时移除JSON层嵌套</strong></p><p id="1f91" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还记得我们在第5点中用过的<em class="kf">超市</em>类及其相关结构吗？</p><p id="2402" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，如果我们可以直接将JSON中的<em class="kf">产品</em>映射到<em class="kf">超市</em>类下，这样我的API仍然使用相同的JSON格式，即使我的应用程序将它精简为只需要的层次结构和数据，又会怎么样呢？更明确地说，我希望我的<em class="kf">超市</em>类在从同一个JSON解码时看起来像这样。</p><p id="8fdd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我的来自<em class="kf">超市</em>类的实际JSON看起来像:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="563b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我希望我解码的<em class="kf">超市</em>类对象看起来像下面这样，通过避免<em class="kf">超市- &gt;过道- &gt;货架- &gt;产品</em>层次结构:</p><figure class="lx ly lz ma fq ml"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="a1f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不幸的是，swift还不直接支持它。但这并不意味着你能实现它。所以你能做的就是保持原来的<em class="kf">超市</em>类不变，让它用原来的层次结构解码所有数据，并创建一个新的类<em class="kf"> SupermarketData </em>，它可以匹配上面在<em class="kf"> ExpectedSupermarket </em>类中提到的声明，并编写allProducts属性的getter方法，它可以使用原来的<em class="kf">超市</em>类，并可以通过<em class="kf">过道</em>和<em class="kf">货架</em>返回所有的<em class="kf">产品</em></p><p id="9255" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我知道这不是一个聪明的解决方案，但你可以实现它，直到苹果公司提供内置支持。</p><p id="d05d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于本文中使用的所有场景的示例应用程序，您可以在这里使用<a class="ae mp" href="https://github.com/VireshS/CodableInSwift4" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv"/></a>中的代码。</p><p id="080c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您有进一步的意见或问题，请随时在下面提出。</p><p id="c355" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以关注我上<a class="ae mp" rel="noopener" href="/@viresh.singh"> <strong class="jl hv"> <em class="kf">中</em> </strong> </a>。在<a class="ae mp" href="https://www.linkedin.com/in/viresh-singh-33935835/" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv"><em class="kf">LinkedIn</em></strong></a>上跟我连线。</p></div></div>    
</body>
</html>