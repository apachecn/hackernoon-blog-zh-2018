<html>
<head>
<title>Negative Indexing Multi Arrays in C/++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C/++中的负索引多数组</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/negative-indexing-multi-arrays-in-c-b551ce252972?source=collection_archive---------17-----------------------#2018-03-27">https://medium.com/hackernoon/negative-indexing-multi-arrays-in-c-b551ce252972?source=collection_archive---------17-----------------------#2018-03-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0f0c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">一个方便的谎言——C/++中的多数组</h2></div><p id="b135" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">灵感来自</em> <a class="ae kg" href="https://blog.feabhas.com/2016/12/a-convenient-untruth/" rel="noopener ugc nofollow" target="_blank"> <em class="kf">【格兰南·卡尼</em> </a> <em class="kf">的《一个方便的谎言》。</em></p><p id="99bb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当在C/++中声明一个多数组(多维数组)时，我们得到的是一个连续的内存块。这个内存块跨越了所有维度的乘积的大小。</p><p id="7518" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于一个2×3的数组<code class="eh kh ki kj kk b">arr[2][3]</code>，我们得到一个6单元的内存块。我说单位而不是实际大小(以字节为单位),因为大小会根据数组的数据类型和机器架构而有所不同。</p><p id="487a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们查询数组(即访问元素)时，我们执行指针算法来从单个6单元内存块中提取值。</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="eac0" class="kt ku hu kk b fv kv kw l kx ky">int arr[2][3] = {11,22,33,44,55,66};<br/>cout &lt;&lt; arr[1][1]; // 55</span><span id="2891" class="kt ku hu kk b fv kz kw l kx ky"><br/>int *ptr = &amp;arr[0][0];<br/>cout &lt;&lt; *(ptr + 1*3 + 1*1); // 55</span><span id="f9e6" class="kt ku hu kk b fv kz kw l kx ky"><br/>data      11  22  33  44  55  66<br/>address  100 104 108 112 116 120<br/>           ↑               ↑<br/>         ptr            ptr+4</span></pre><p id="46cd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这让我想知道——我能回到过去吗？</p></div><div class="ab cl la lb hc lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hn ho hp hq hr"><h1 id="6ea2" class="lh ku hu bd li lj lk ll lm ln lo lp lq ja lr jb ls jd lt je lu jg lv jh lw lx dt translated">负索引</h1><p id="41fb" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">现在有趣的部分来了。在上面给出的2x3整数数组中，如何查询数字<code class="eh kh ki kj kk b">33</code>？显而易见的答案是<code class="eh kh ki kj kk b">arr[0][2]</code>。这是正确的。</p><p id="b937" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在指针中，它变成了<code class="eh kh ki kj kk b">*(ptr + 0*3 + 2*1)</code>，也就是<code class="eh kh ki kj kk b">*(ptr + 2)</code>。那么接下来的问题就是:我们有多少种方法可以让<code class="eh kh ki kj kk b">x * 3 + y * 1</code>等于<code class="eh kh ki kj kk b">2</code>？换句话说，对于<code class="eh kh ki kj kk b">x</code>，<code class="eh kh ki kj kk b">y</code>的什么值，等式<code class="eh kh ki kj kk b">3x + y == 2</code>成立？</p><p id="b14a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以下是解决方案的示例:</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="8c32" class="kt ku hu kk b fv kv kw l kx ky">x  0  1  2 -1 -2 ...<br/>y  1 -1 -4  5  8 ...</span></pre><p id="d199" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以使用这些<code class="eh kh ki kj kk b">(x, y)</code>对中的任何一个来查询数字<code class="eh kh ki kj kk b">33</code>:</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="880b" class="kt ku hu kk b fv kv kw l kx ky">int arr[2][3] = {11,22,33,44,55,66};</span><span id="80c2" class="kt ku hu kk b fv kz kw l kx ky">cout &lt;&lt; arr[0][2];  // 33<br/>cout &lt;&lt; arr[1][-1]; // 33<br/>cout &lt;&lt; arr[2][-4]; // 33<br/>cout &lt;&lt; arr[-1][5]; // 33<br/>cout &lt;&lt; arr[-2][8]; // 33</span><span id="e488" class="kt ku hu kk b fv kz kw l kx ky"><br/>data      11  22  33  44  55  66<br/>address  100 104 108 112 116 120<br/>           ↑       ↑<br/>          ptr    ptr+2</span></pre><p id="0e71" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种行为适用于所有维度为<code class="eh kh ki kj kk b">n</code>的多<a class="ae kg" href="https://hackernoon.com/tagged/arrays" rel="noopener ugc nofollow" target="_blank">数组</a>。唯一的问题是，在3D和以上阵列中可视化这个原理变得相当麻烦。幸运的是，我做了一个很小的工具来帮你做这件事:)</p><p id="e542" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个工具有助于创建一个多阵列高达5D阵列，每个“水平”可以容纳多达4个“细胞”。生成数组后，您可以对其运行查询，该工具将突出显示用于得出<a class="ae kg" href="https://hackernoon.com/tagged/output" rel="noopener ugc nofollow" target="_blank">输出</a>值的内存单元。</p><p id="c731" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="kf">注:</em> </strong>我所说的“水平”和“细胞”的意思稍后会解释。</p><figure class="kl km kn ko fq md"><div class="bz el l di"><div class="me mf l"/></div></figure></div><div class="ab cl la lb hc lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hn ho hp hq hr"><h1 id="ecf2" class="lh ku hu bd li lj lk ll lm ln lo lp lq ja lr jb ls jd lt je lu jg lv jh lw lx dt translated">展示和讲解</h1><p id="26ac" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">为了更好地解释，我将使用下面的2x3x2数组的内存映射。看一看它，让自己相信下面的等式<code class="eh kh ki kj kk b">arr[0][2][0] == arr[0][0][4] == arr[1][0][-2]</code></p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="f015" class="kt ku hu kk b fv kv kw l kx ky"> _____________________________________________________________<br/>|        | L0 |           0           |          1            |<br/>|        |----|-----------------------------------------------|<br/>| Memory | L1 |   0   |   1   |   2   |   0   |   1   |   2   |<br/>| Levels |----|-----------------------------------------------|<br/>|        | L2 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |<br/>|=============|===============================================|<br/>|  Data Level | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12|<br/> ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾</span></pre><p id="d2ef" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另外，我使用了函数<code class="eh kh ki kj kk b">PROD()</code>和<code class="eh kh ki kj kk b">SUM()</code>，它们给出了一个数组范围的乘积和总和。</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="741d" class="kt ku hu kk b fv kv kw l kx ky">prod(i, [a..b], arr) = arr_a * arr_(a+1) * ... * arr_(b-1)<br/>prod(arr) = arr_0 * arr_1 * ... * arr_(n-1)</span><span id="6b2b" class="kt ku hu kk b fv kz kw l kx ky">sum(i, [a..b], arr) = arr_a + arr_(a+1) + ... + arr_(b-1)<br/>sum(arr) = arr_0 + arr_1 + ... + arr_(n-1)</span><span id="1d5a" class="kt ku hu kk b fv kz kw l kx ky">where n = size of array</span></pre><h2 id="7676" class="kt ku hu bd li mg mh mi lm mj mk ml lq js mm mn ls jw mo mp lu ka mq mr lw ms dt translated">单元格和级别</h2><p id="d211" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">这两个术语都是虚构的。这些只是我用来指代特定内存位置的符号。</p><p id="f828" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个<strong class="jl hv">存储单元</strong>只是一个可以被指针或数组索引指向的存储单元。当我们访问元素<code class="eh kh ki kj kk b">arr[0][2][1]</code>时，我们以数据值<code class="eh kh ki kj kk b">6</code>结束。</p><p id="6bf5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是<code class="eh kh ki kj kk b">[0][2][1]</code>代表什么呢？我回答说它们是指向“记忆细胞”的指针。一种解读方式是:</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="ef3d" class="kt ku hu kk b fv kv kw l kx ky">* access 0th cell in the block<br/>* access 2nd cell in the 0th cell<br/>* access 1st cell in the 2nd cell<br/>* retrieve the value</span></pre><p id="ef29" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">内存级别</strong>是驻留在相同内存维度中的内存单元的集合。</p><h2 id="da8b" class="kt ku hu bd li mg mh mi lm mj mk ml lq js mm mn ls jw mo mp lu ka mq mr lw ms dt translated">观察</h2><p id="e0bd" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">最初的观察是比较明显的:</p><ul class=""><li id="d9d5" class="mt mu hu jl b jm jn jp jq js mv jw mw ka mx ke my mz na nb dt translated">维度计数:<code class="eh kh ki kj kk b"><strong class="jl hv">N</strong> = 3</code></li><li id="cc2c" class="mt mu hu jl b jm nc jp nd js ne jw nf ka ng ke my mz na nb dt translated">尺寸规格:<code class="eh kh ki kj kk b"><strong class="jl hv">D</strong> = [2, 3, 2]</code></li></ul><p id="5290" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们访问<code class="eh kh ki kj kk b">arr[1][2][1] </code>，那么查询将是:<code class="eh kh ki kj kk b"><strong class="jl hv">Q</strong> = [1, 2, 1]</code></p><h2 id="d05b" class="kt ku hu bd li mg mh mi lm mj mk ml lq js mm mn ls jw mo mp lu ka mq mr lw ms dt translated">单元格跨度</h2><p id="62ae" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">站在<code class="eh kh ki kj kk b">ith</code>内存级别，如果我移动1个单元，数据级别的跳跃大小就是该内存级别的<strong class="jl hv">单元步幅</strong>。</p><p id="1fce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">各级的单元格跨度为:</p><ul class=""><li id="fe1a" class="mt mu hu jl b jm jn jp jq js mv jw mw ka mx ke my mz na nb dt translated">L0: 6 = 1*2*3</li><li id="1270" class="mt mu hu jl b jm nc jp nd js ne jw nf ka ng ke my mz na nb dt translated">L1: 2 = 1*2</li><li id="ecf7" class="mt mu hu jl b jm nc jp nd js ne jw nf ka ng ke my mz na nb dt translated">L2: 1 = 1</li></ul><p id="89a9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这为我们提供了这样的关系:对于<code class="eh kh ki kj kk b">ith</code>内存级别，步长是该级别以上所有维度大小的乘积。</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="97c0" class="kt ku hu kk b fv kv kw l kx ky">S_i = 1 * prod(j, [i+1..N], D)<br/>or<br/>S_i = S_(i+1) * D_(i+1)</span></pre><h2 id="7acb" class="kt ku hu bd li mg mh mi lm mj mk ml lq js mm mn ls jw mo mp lu ka mq mr lw ms dt translated">查询匹配(M)</h2><p id="b584" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">当我们运行一个查询时，我们在每一层匹配一个存储单元。这形成了跨越级别的跳转链<strong class="jl hv">，在数据级别结束，并产生数据值。</strong></p><p id="85b3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这为我们提供了以下关系:对于<code class="eh kh ki kj kk b">ith</code>存储级别，匹配单元为:</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="2cc0" class="kt ku hu kk b fv kv kw l kx ky">M_i = (1 / S_i) * sum(j, [1..N], S_j * Q_j)<br/>or simply<br/>M_i = (1 / S_i) * sum(S_j * Q_j)</span></pre><p id="0b48" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不幸的是，我的这段感情之旅很难解释清楚。所以我就直接跳过了。</p><p id="cbbe" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我使用这个值(查询匹配)来突出显示查询产生的存储单元和最终数据值。</p><h2 id="8ddd" class="kt ku hu bd li mg mh mi lm mj mk ml lq js mm mn ls jw mo mp lu ka mq mr lw ms dt translated">混杂的</h2><p id="a06b" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated"><strong class="jl hv">细胞计数</strong>:在<code class="eh kh ki kj kk b">ith</code>内存级别<br/> <code class="eh kh ki kj kk b"><strong class="jl hv">C_i</strong> = prod(j, [0..i], D) = C_(i-1) * D_i</code>中的细胞数量</p><p id="1e17" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">数据计数</strong>:存储的数据值总数<br/> <code class="eh kh ki kj kk b"><strong class="jl hv">n</strong> = prod(i, [0..N], D) = prod(D)</code></p><p id="70cf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过比较关系<code class="eh kh ki kj kk b">C_i</code>、<code class="eh kh ki kj kk b">S_i</code>和<code class="eh kh ki kj kk b">n</code>，得到关系<code class="eh kh ki kj kk b">n = C_i * S_i</code>，因为:</p><ul class=""><li id="3b8c" class="mt mu hu jl b jm jn jp jq js mv jw mw ka mx ke my mz na nb dt translated"><code class="eh kh ki kj kk b">n = prod(i, [0..N], D)</code></li><li id="4492" class="mt mu hu jl b jm nc jp nd js ne jw nf ka ng ke my mz na nb dt translated"><code class="eh kh ki kj kk b">C_i = prod(j, [0..i], D)</code></li><li id="2f20" class="mt mu hu jl b jm nc jp nd js ne jw nf ka ng ke my mz na nb dt translated"><code class="eh kh ki kj kk b">S_i = prod(j, [i+1..N], D)</code></li></ul></div><div class="ab cl la lb hc lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hn ho hp hq hr"><h1 id="7fce" class="lh ku hu bd li lj lk ll lm ln lo lp lq ja lr jb ls jd lt je lu jg lv jh lw lx dt translated">结束了</h1><p id="694d" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">C/++允许在多数组中使用负索引，因为它只是一个连续的内存块，索引查找只是指针运算。<br/>那里。那是你现在知道的事情。</p><p id="7b6d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在这里或者在<a class="ae kg" href="https://codepen.io/zhirzh/pen/yKPNjo" rel="noopener ugc nofollow" target="_blank">代码笔</a>上找到代码<a class="ae kg" href="https://gist.github.com/zhirzh/aa02be34407eebe8998d2ff35946cdc9" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="22c0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，如果你想知道在其他语言中是否可能，答案是“视情况而定”。将多数组实现为真正的多数组(数组的数组)的语言不能有负索引。像C/++这样实现多数组的语言<em class="kf">可能</em>支持它。</p></div><div class="ab cl la lb hc lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hn ho hp hq hr"><h1 id="0bbb" class="lh ku hu bd li lj lk ll lm ln lo lp lq ja lr jb ls jd lt je lu jg lv jh lw lx dt translated">奖金</h1><p id="d8d9" class="pw-post-body-paragraph jj jk hu jl b jm ly iv jo jp lz iy jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">假设我们有一个整数数组<code class="eh kh ki kj kk b">arr[3]</code>，我们访问元素<code class="eh kh ki kj kk b">arr[1]</code>，我们得到什么？我们得到了第二个值。那没意思。</p><p id="55af" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">有趣的是</em>编译器如何通过将查询重写为<code class="eh kh ki kj kk b">*(arr + 1)</code>来解决这个问题。这是简单的指针加法。因为加法是可交换的，我们可以…</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="1a1d" class="kt ku hu kk b fv kv kw l kx ky">arr[1]     -&gt; *(arr + 1)<br/>*(arr + 1) -&gt; *(1 + arr)<br/>*(1 + arr) -&gt; 1[arr]</span></pre><p id="dc7a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">…并得出结论<code class="eh kh ki kj kk b">arr[i]</code>与<code class="eh kh ki kj kk b">i[arr]</code>相同。这一点对于多阵列也是正确的。</p><pre class="kl km kn ko fq kp kk kq kr aw ks dt"><span id="b8d9" class="kt ku hu kk b fv kv kw l kx ky">int main () {<br/>  int arr[2][3] = {11,22,33,44,55,66};</span><span id="489c" class="kt ku hu kk b fv kz kw l kx ky">cout&lt;&lt;arr[0][2]; // good<br/>  cout&lt;&lt;2[0[arr]]; // bad<br/>  cout&lt;&lt;2[arr[0]]; // also bad<br/>  cout&lt;&lt;0[arr][2]; // ???<br/>}</span></pre><p id="2b7f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从那里来的还有很多。查看格兰南·卡尼的文章<br/> <a class="ae kg" href="https://blog.feabhas.com/2016/12/a-convenient-untruth/" rel="noopener ugc nofollow" target="_blank">【一个便利的谎言】</a>。</p><figure class="kl km kn ko fq md"><div class="bz el l di"><div class="nh mf l"/></div></figure></div></div>    
</body>
</html>