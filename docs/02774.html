<html>
<head>
<title>Analysing 1.4 billion rows with python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用python分析14亿行</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/analysing-1-4-billion-rows-with-python-6cec86ca9d73?source=collection_archive---------1-----------------------#2018-03-28">https://medium.com/hackernoon/analysing-1-4-billion-rows-with-python-6cec86ca9d73?source=collection_archive---------1-----------------------#2018-03-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d929" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用pytubes、numpy和matplotlib</h2></div><p id="5665" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Google Ngram viewer是一个有趣/有用的工具，它使用Google从书籍中扫描的大量数据来绘制单词的用法。以单词<em class="kg"> Python </em>(区分大小写)<em class="kg"> : </em>为例</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff kh"><img src="../Images/95b4b93d7f9853fa7ca1e3d01ae2c6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBBDttphxwvek-nhV9v6eg.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Untitled graph taken from: <a class="ae kf" href="https://books.google.com/ngrams/graph?content=Python&amp;year_start=1800&amp;corpus=15&amp;smoothing=0" rel="noopener ugc nofollow" target="_blank">https://books.google.com/ngrams/graph?content=Python&amp;year_start=1800&amp;corpus=15&amp;smoothing=0</a> charting the usage of the word ‘Python’ over time.</figcaption></figure><p id="8406" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它来自谷歌的n-gram数据集，一个特定单词或单词序列在每个出版年度被谷歌图书发现次数的日志。虽然不完整(不包括所有出版过的书！)，这套书有几百万本，包括16世纪到2008年出版的书。数据集可以在这里免费下载<a class="ae kf" href="http://storage.googleapis.com/books/ngrams/books/datasetsv2.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b591" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我决定看看使用Python和我的新数据加载库来再现上面的图形有多容易:<a class="ae kf" href="http://github.com/stestagg/pytubes" rel="noopener ugc nofollow" target="_blank"> PyTubes </a></p><h2 id="bee3" class="kx ky hu bd kz la lb lc ld le lf lg lh js li lj lk jw ll lm ln ka lo lp lq lr dt translated">挑战</h2><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff ls"><img src="../Images/51b0230b3c5c3eed0dc53a4f3586597a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTuX_3Xo3bxvtf_GgJTwpA.jpeg"/></div></div></figure><p id="0566" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">1克的数据集在磁盘上扩展到27 Gb，这对于读入python来说是相当大的数据量。总的来说，Python可以轻松处理千兆字节的数据，但是一旦数据被析构和处理，速度就会慢很多，内存效率也会降低。</p><p id="b72f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总共有14亿行(1，430，727，243)分布在38个源文件中，总计2400万(24，359，460)个单词(以及POS标记单词，见下文)，统计时间在1505年至2008年之间。</p><p id="7733" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当处理10亿行时，事情会变得很慢，很快。而原生Python并没有针对这种处理进行优化。幸运的是,<a class="ae kf" href="https://github.com/numpy/numpy" rel="noopener ugc nofollow" target="_blank"> numpy </a>非常擅长处理大量的数字数据。通过一些简单的技巧，我们可以使用numpy使这种分析变得可行。</p><p id="8b90" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在python/numpy中处理字符串很复杂。python中字符串的内存开销非常大，numpy只在字符串长度已知且固定的情况下才真正处理字符串。在这种情况下，大多数单词都有不同的长度，所以这并不理想。</p><h2 id="241b" class="kx ky hu bd kz la lb lc ld le lf lg lh js li lj lk jw ll lm ln ka lo lp lq lr dt translated">加载数据</h2><blockquote class="lt lu lv"><p id="7c38" class="jj jk kg jl b jm jn iv jo jp jq iy jr lw jt ju jv lx jx jy jz ly kb kc kd ke hn dt translated">以下所有代码/示例都是在2016款Macbook Pro上运行的，配有<strong class="jl hv"> 8 GB ram </strong>。具有适当数量ram的硬件/云实例应该表现得更好</p></blockquote><p id="9cd3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">1克计数以一组制表符分隔的文件形式提供，如下所示:</p><pre class="ki kj kk kl fq lz ma mb mc aw md dt"><span id="46b1" class="kx ky hu ma b fv me mf l mg mh">Python 1587 4 2<br/>Python 1621 1 1<br/>Python 1651 2 2<br/>Python 1659 1 1</span></pre><p id="e57e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中每行包含以下字段:</p><pre class="ki kj kk kl fq lz ma mb mc aw md dt"><span id="2f5c" class="kx ky hu ma b fv me mf l mg mh">1. Word<br/>2. Year of Publication<br/>3. Total number of times the word was seen<br/>4. Total number of books containing the word</span></pre><p id="0ef4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了生成所请求的图，我们只需要知道一些信息，即:</p><pre class="ki kj kk kl fq lz ma mb mc aw md dt"><span id="e8d1" class="kx ky hu ma b fv me mf l mg mh">1. Is the word the one we’re interested in?<br/>2. Year of publication<br/>3. Total number of times the word was seen</span></pre><p id="9599" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过提取这些信息，可以避免处理可变长度字符串数据的开销，但是我们仍然需要比较字符串值，以确定哪些行与我们感兴趣的字段有关。这就是pytubes的用武之地:</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="19b6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">大约170秒(3分钟)后，<em class="kg"> one_grams </em>是一个大约有14亿行的numpy数组，如下所示(为清楚起见添加了标题):</p><pre class="ki kj kk kl fq lz ma mb mc aw md dt"><span id="4bf3" class="kx ky hu ma b fv me mf l mg mh">╒═══════════╤════════╤═════════╕<br/>│   Is_Word │   Year │   Count │<br/>╞═══════════╪════════╪═════════╡<br/>│         0 │   1799 │       2 │<br/>├───────────┼────────┼─────────┤<br/>│         0 │   1804 │       1 │<br/>├───────────┼────────┼─────────┤<br/>│         0 │   1805 │       1 │<br/>├───────────┼────────┼─────────┤<br/>│         0 │   1811 │       1 │<br/>├───────────┼────────┼─────────┤<br/>│         0 │   1820 │     ... │<br/>╘═══════════╧════════╧═════════╛</span></pre><p id="add8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从这里开始，只是用numpy方法计算一些东西的问题:</p><h2 id="633e" class="kx ky hu bd kz la lb lc ld le lf lg lh js li lj lk jw ll lm ln ka lo lp lq lr dt translated">每年的总字数</h2><p id="8aaa" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">Google显示了每个单词出现的百分比(一个单词出现的次数/当年发表的总字数),这在某种程度上比原始字数更有用。为了计算这个，我们需要知道总字数是多少。</p><p id="a0bf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">幸运的是numpy让这变得非常简单:</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="48cc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个图表显示了谷歌每年收集了多少单词:</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff mp"><img src="../Images/30b849d3650b7fbe78ed61a7bf40e7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGpmL__D90H1skGgYO2ibg.png"/></div></div></figure><p id="2313" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">显而易见的是，在1800年之前，数据量迅速下降，因此可能会扭曲结果，隐藏有趣的模式。为了反驳这一点，我们只包括1800年以后的数据:</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="1b07" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它返回13亿行(只有3.7%的单词是1800年以前记录的)</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff mq"><img src="../Images/86c422af0c527dc4d82c33b3749b5962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVjNfqQb0j-5S_opj4oTIA.png"/></div></div></figure><h2 id="65c7" class="kx ky hu bd kz la lb lc ld le lf lg lh js li lj lk jw ll lm ln ka lo lp lq lr dt translated">Python按年百分比</h2><p id="a7b4" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">获得python的%计数现在出奇的容易。</p><p id="1ab7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用使基于年份的数组2008元素变长的简单技巧意味着每一年的索引等于年份数，因此找到1995年的条目只是获得第1995个元素的问题。</p><p id="588e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为此甚至不值得使用numpy操作:</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="97e1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">绘制结果字数:</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff mq"><img src="../Images/89e3601e02502c8ddf9f0574de4d4947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJD7p3d6J8Ecl75tHIR5vQ.png"/></div></div></figure><p id="ee4a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这与谷歌的版本非常相似:</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff kh"><img src="../Images/95b4b93d7f9853fa7ca1e3d01ae2c6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBBDttphxwvek-nhV9v6eg.png"/></div></div></figure><p id="c899" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">实际的%数字根本不匹配，我认为这是因为可下载的数据集包含了用各种词类标记的单词(例如:Python_VERB)。这个数据集在google页面上没有很好的解释，并且提出了几个问题:</p><ul class=""><li id="9dbd" class="mr ms hu jl b jm jn jp jq js mt jw mu ka mv ke mw mx my mz dt translated">如何使用Python作为动词？</li><li id="863d" class="mr ms hu jl b jm na jp nb js nc jw nd ka ne ke mw mx my mz dt translated">“Python”的计数包括“Python_VERB”的计数吗？等等。</li></ul><p id="fedb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">幸运的是，很明显，我使用的方法产生了与google足够相似的图形形状，相对趋势不受影响，因此对于这次探索，我不打算尝试修复它。</p><h2 id="4707" class="kx ky hu bd kz la lb lc ld le lf lg lh js li lj lk jw ll lm ln ka lo lp lq lr dt translated">表演</h2><p id="09af" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">Google在大约1秒钟内生成图表，相比之下，使用这个脚本需要大约8分钟，但这是合理的。谷歌字数统计的后端将从数据集的大量准备视图开始工作。</p><p id="43fd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，预先计算每年的总字数并将其存储在一个查找表中可以节省大量时间。同样，将字数存储在单个数据库/文件中并索引第一列将消除几乎所有的处理时间。</p><p id="1de8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，这次探索<em class="kg">所展示的是，使用numpy和羽翼未丰的pytubes，使用标准的商用硬件和Python，在合理的时间内从原始的十亿行数据集中加载、处理和提取一些任意的统计信息是可能的。</em></p><h1 id="ab89" class="nf ky hu bd kz ng nh ni ld nj nk nl lh ja nm jb lk jd nn je ln jg no jh lq np dt translated">语言战争</h1><p id="0ce0" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">为了用一个稍微复杂一点的例子来证明这个概念，我决定比较三种编程语言的相对提及率:<strong class="jl hv"> Python、【Pascal】、</strong>和<strong class="jl hv"> Perl。</strong></p><p id="944d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">源数据非常嘈杂(它包括所有使用的英语单词，不仅仅是编程语言提及，例如，python也有非技术含义！)为了对此进行调整，我们做了两件事:</p><ol class=""><li id="ac7a" class="mr ms hu jl b jm jn jp jq js mt jw mu ka mv ke nq mx my mz dt translated">仅匹配名称的标题大小写形式(python，而非Python)</li><li id="e850" class="mr ms hu jl b jm na jp nb js nc jw nd ka ne ke nq mx my mz dt translated">在1800年到1960年之间，每种语言的提及次数已经被平均百分比数所转移，假设Pascal作为一种语言在1970年被首次提及，这应该给出一个合理的基线。</li></ol><h2 id="d3b5" class="kx ky hu bd kz la lb lc ld le lf lg lh js li lj lk jw ll lm ln ka lo lp lq lr dt translated">结果:</h2><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff mq"><img src="../Images/143155e26661069e4d7be6052fdd8eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AsipoFxV-cE2zIuDqZOiHw.png"/></div></div></figure><p id="1c14" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对比Google ( <em class="kg">无任何基线调整</em>):</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff nr"><img src="../Images/1b02e78898a2cc3775acd6e6d8dd00a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWPxvopsNmbY50WKF8Wvjg.png"/></div></div></figure><p id="3af6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">运行时间:10分钟多一点</p><p id="b332" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">编码:<a class="ae kf" href="https://gist.github.com/stestagg/910859576f44f20e509822365414290d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/stestagg/910859576 f 44 f 20 e 509822365414290d</a></p><h2 id="19bd" class="kx ky hu bd kz la lb lc ld le lf lg lh js li lj lk jw ll lm ln ka lo lp lq lr dt translated">未来PyTubes的改进</h2><p id="5422" class="pw-post-body-paragraph jj jk hu jl b jm mk iv jo jp ml iy jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">目前，pytubes只有一个整数的概念，即64位int。这意味着pytubes生成的numpy数组对所有整数使用i8 dtypes。在某些情况下(比如ngrams数据)，8字节整数有点过分，浪费内存(这里的完整n数组大约是38Gb，使用更好的dtypes可以很容易地减少60%)。我计划很快增加一些1、2和4字节整数支持(<a class="ae kf" href="https://github.com/stestagg/pytubes/issues/9" rel="noopener ugc nofollow" target="_blank">https://github.com/stestagg/pytubes/issues/9</a>)</p><p id="44c3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更多过滤逻辑Tube.skip _ unless()方法是过滤行的一种简单方法，但是缺少组合条件(AND/OR/NOT)的能力。对于某些用例来说，这将大大加快减少加载数据量的速度。</p><p id="270d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更好的字符串匹配——像startswith、endswith、contains和is_one_of这样的简单测试很容易添加，并且在加载大量字符串数据时显著提高了有用性。</p><p id="444f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kg">一如既往，</em> <a class="ae kf" href="https://github.com/stestagg/pytubes" rel="noopener ugc nofollow" target="_blank"> <em class="kg">补丁</em> </a> <em class="kg">更受欢迎！</em></p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="ns mj l"/></div></figure></div></div>    
</body>
</html>