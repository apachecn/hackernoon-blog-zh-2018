<html>
<head>
<title>Functional JavaScript: Function Decorators Part 2 #JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript:函数装饰器第2部分#JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/function-decorators-part-2-javascript-fadd24e57f83?source=collection_archive---------4-----------------------#2018-03-28">https://medium.com/hackernoon/function-decorators-part-2-javascript-fadd24e57f83?source=collection_archive---------4-----------------------#2018-03-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0067269ac029f6575eb863b66eb26fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t73HZWmP9JGbUy15FpThVQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://pixabay.com/en/think-switch-arrows-rethinking-2177840/" rel="noopener ugc nofollow" target="_blank">geralt @ pixelbay</a></figcaption></figure><h1 id="26e6" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">开始</h1><blockquote class="kf kg kh"><p id="b2c2" class="ki kj kk kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg hn dt translated"><strong class="kl hv">函数装饰器</strong>允许你在不修改原函数的情况下增强现有函数。</p></blockquote><p id="fdce" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">在第1部分中，我演示了函数装饰者如何将回调转换成承诺，然后再转换回来。但是函数装饰器比有限范围的回调和承诺有用得多，所以我认为这个主题需要重启。</p><p id="1084" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated"><strong class="kl hv">第一部分:</strong></p><div class="lk ll fm fo lm ln"><a href="https://hackernoon.com/transforming-callbacks-into-promises-and-back-again-e274c7cf7293" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">函数装饰者:将回调转化为承诺，然后再转化回来</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">我在JavaScript领域工作的每一天，都会遇到回调、承诺或async/await。我有我的…</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">hackernoon.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb ja ln"/></div></div></a></div><p id="6e4b" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">我认为展示一堆例子将是展示函数装饰者的最好方式，所以<strong class="kl hv">这篇文章将稍微轻于文字，更多地关注代码。</strong></p><h1 id="dd0a" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">一个函数装饰者的Hello世界</h1><p id="54ac" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">基本的函数装饰非常简单(它什么也不做)。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="5996" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">为了支持n-arity函数，我们可以把它扩展成这样(仍然什么也不做)。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="2916" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">现在让我们创建并使用一个<code class="eh mn mo mp mq b">helloWorld</code>装饰器来装饰<code class="eh mn mo mp mq b">add</code>函数。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="b0af" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">使用这个基础装饰器作为您想要创建的任何函数装饰器的模板。</p><h1 id="0f6b" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">日志功能装饰器</h1><p id="b696" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">轻松地将您的日志逻辑包装到现有函数中。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="ef0f" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated"><strong class="kl hv">作业:</strong>你如何修改它来支持异步函数？要得到提示，请看下面的<code class="eh mn mo mp mq b">timed</code>函数装饰器。</p><h1 id="e7ad" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">计时器函数装饰器</h1><p id="efb1" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">同步和异步代码都可以使用的基本定时器函数。</p><p id="0a7b" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">第15行检查该值是否是一个承诺，并将返回值放到一个<code class="eh mn mo mp mq b">then</code>中，而不是返回它。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="11f6" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">函数参数保护装饰器</h1><p id="93d3" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">防止所有参数为空或未定义。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="5367" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated"><strong class="kl hv">家庭作业:</strong>如何改进这个装饰器？如何添加参数名？你如何防范一些争论？</p><h1 id="8763" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">异常处理</h1><p id="f4f3" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">您可以返回一个包含值或错误的对象，而不是引发异常。这类似于任一单子如何处理它的值。(现在不用担心单子)。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="3b74" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated"><strong class="kl hv">作业:</strong>研究并学会使用<a class="ae jg" href="https://github.com/sanctuary-js/sanctuary" rel="noopener ugc nofollow" target="_blank">或</a>单子。更改此代码以返回。</p><h1 id="9015" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">获取JSON函数装饰器</h1><p id="b928" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">使用fetch时，经常会看到这样的代码散布在您的代码库中:</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="80bc" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">要访问那个json，你必须首先调用<code class="eh mn mo mp mq b">response.json()</code>。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="d63d" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">Currying</h1><p id="5c40" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">如果你熟悉像Ramda的curry这样的curry函数，那么你可能已经熟悉了函数装饰器。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="c4a3" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">注:我推荐使用更成熟的<a class="ae jg" href="http://ramdajs.com/docs/#curry" rel="noopener ugc nofollow" target="_blank">库里功能</a>，比如Ramda的那个。尽管这种方法可以很好地工作，但它只是作为示例提供的。</p><h1 id="0769" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">Next.js浏览器检查</h1><p id="ea84" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">在我创建的一个Next.js项目中，我不得不限制几个函数只能在浏览器端执行。我可以用一个简单的函数装饰器干净利落地做到这一点。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="cfc2" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">多种装饰方式</h1><p id="b5a7" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">有几种方法可以修饰函数。你如何决定使用decorators将取决于你的用例。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="b452" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">组合函数装饰器</h1><p id="fa63" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">因为每个装饰器也返回一个函数，所以函数装饰器可以很容易地组合起来创建一个大型函数。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="82e6" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">还可以使用函数组合来组合装饰器</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="aa93" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">反应</h1><p id="8bfb" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">反应和整个生态系统充满了功能装饰。如果你用过React，很有可能你已经用过函数装饰器了。<code class="eh mn mo mp mq b">react-redux</code>的<code class="eh mn mo mp mq b">connect</code>是一个函数装饰器。<code class="eh mn mo mp mq b">redux</code>的<code class="eh mn mo mp mq b">bindActionCreators</code>是一个函数装饰者。</p><h1 id="21ce" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">结束了</h1><p id="25d8" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">函数装饰器是用来增强现有函数的强大工具。它们不是什么新东西，如果你还没有使用过函数装饰器，你很可能会在不久的将来使用它们。</p><p id="ec0d" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">即使它们如此强大且易于创建，我也没有看到很多人在他们的代码中创建函数装饰器。这告诉我，函数装饰器是未被充分利用的工具，值得更多的探索。</p><p id="ebe9" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">别忘了做这篇文章里的作业！</p><p id="19ff" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">我很想在下面的评论中听到你如何使用函数装饰器来改进你的代码库！😃</p><p id="2189" class="pw-post-body-paragraph ki kj hu kl b km kn ko kp kq kr ks kt lh kv kw kx li kz la lb lj ld le lf lg hn dt translated">干杯！</p><h2 id="ff03" class="mr ji hu bd jj ms mt mu jn mv mw mx jr lh my mz jv li na nb jz lj nc nd kd ne dt translated">跟我来</h2><p id="d864" class="pw-post-body-paragraph ki kj hu kl b km mc ko kp kq md ks kt lh me kw kx li mf la lb lj mg le lf lg hn dt translated">推特:<a class="ae jg" href="https://twitter.com/joelnet" rel="noopener ugc nofollow" target="_blank">https://twitter.com/joelnet</a>T8】中:<a class="ae jg" href="https://medium.com/@joelthoms/latest" rel="noopener">https://medium.com/@joelthoms/latest</a>T11】dev . to:<a class="ae jg" href="https://dev.to/joelnet" rel="noopener ugc nofollow" target="_blank">https://dev.to/joelnet</a>T14】LinkedIn:<a class="ae jg" href="https://www.linkedin.com/in/joel-thoms/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/joel-thoms/</a></p></div></div>    
</body>
</html>