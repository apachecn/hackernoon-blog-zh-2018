<html>
<head>
<title>Running distributed Erlang &amp; Elixir applications on Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker上运行分布式Erlang &amp; Elixir应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/running-distributed-erlang-elixir-applications-on-docker-b211d95affbe?source=collection_archive---------20-----------------------#2018-03-28">https://medium.com/hackernoon/running-distributed-erlang-elixir-applications-on-docker-b211d95affbe?source=collection_archive---------20-----------------------#2018-03-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f337" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由<a class="ae jp" href="https://github.com/oltarasenko" rel="noopener ugc nofollow" target="_blank">奥列格塔拉森科</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/77c712435d6caa87cfa2094ad5cd8cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eoqlQCdr6ywQFL8UTE1NHg.png"/></div></div></figure><p id="4eac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">docker平台已经存在好几年了，所以让我们简单回顾一下它提供了哪些好处，以及为什么您应该考虑使用它:</p><h1 id="786c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">在桌面上启动生产服务的简单方法</h1><p id="de4c" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">我仍然记得过去在OS X提出MySql是多么复杂。但是，如果您考虑这样一个场景，您的生产环境正在运行某个特定版本的MySQL，尤其是在非OS X上构建的MySQL，情况会更糟。</p><p id="de85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会怎么提出来？幸运的是，当你使用docker时，这个问题就消失了，因为你可以像执行命令<code class="eh lf lg lh li b">docker run mysql:5.3</code>一样容易地调出任何版本的程序。</p><h1 id="cd35" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">能够在真实的测试环境中工作，而不必实现服务模拟</h1><p id="93df" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">这一直是个问题。如果你想正确地测试你的软件，你必须提出(或模仿)许多相关的服务。这总是会产生问题，因为模拟从来不会真正匹配完整的运行服务的特征。</p><p id="bd97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用docker，您可以插入您的应用程序所依赖的任何软件，并将其作为测试环境的一部分。</p><h1 id="c503" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">使用容器创建真实的云基础设施</h1><p id="9b75" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">最后，docker容器可以通过像<a class="ae jp" href="http://mesos.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Mesos </a>这样的工具旋转起来，形成全功能的云，以轻松清晰的方式部署，并且非常稳定！</p><p id="80d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感兴趣吗？让我们看看这项技术在Erlang和Elixir领域能给你带来哪些好处。</p><h1 id="52ff" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">用docker测试分布式erlang应用程序</h1><p id="ddf3" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">让我们考虑这样一种情况，当我们需要创建和测试一个运行在同一台机器上的分布式erlang应用程序时，假设我们想让它运行，但是它依赖于一些额外的服务。</p><p id="2c3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种设置可以在下面的docker-compose文件中描述:</p><pre class="jr js jt ju fq lj li lk ll aw lm dt"><span id="c56d" class="ln kd hu li b fv lo lp l lq lr">version: "3"<br/>services:<br/>  c1:<br/>    image: erlang:latest<br/>    # We're using the following command to bring up erlang shell<br/>    # for the example purposes, but in the other case the command<br/>    # will describe a running container<br/>    command: erl -noshell -name app@host1.com -setcookie cookie<br/>    container_name: host1.com<br/>    networks:<br/>      - net1<br/><br/>  c2:<br/>    image: erlang:17.5<br/>    command: erl -noshell -name app@host2.com -setcookie cookie<br/>    container_name: host2.com<br/>    networks:<br/>     - net1<br/><br/>  ejabberd:<br/>    image: rroemhild/ejabberd<br/>    ports:<br/>      - 5222:5222<br/>      - 5269:5269<br/>      - 5280:5280<br/>    container_name: host3.com<br/>    environment:<br/>      - ERLANG_NODE=ejabberd@host3.com<br/>      - XMPP_DOMAIN=test.io<br/>      - ERLANG_COOKIE=cookie<br/>      - EJABBERD_ADMINS=admin@test.io<br/>      - EJABBERD_USERS=admin@test.io:admin<br/>      - EJABBERD_SKIP_MODULES_UPDATE=true<br/>    networks:<br/>     - net1<br/><br/># We're using custom network setup, as it ships with a DNS<br/># system which allows containers to communicate by hostnames.<br/>networks:<br/>  net1:<br/>    driver: bridge</span></pre><p id="6099" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们启动这个设置，看看我们如何促进这些容器之间的通信:</p><ol class=""><li id="5fc4" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo lx ly lz ma dt translated">调出文件中描述的每个容器:<code class="eh lf lg lh li b">docker-compose up -d</code></li><li id="635f" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">连接到其中一个主机:<code class="eh lf lg lh li b">docker exec -it host2.com erl -name test@host2.com -setcookie cookie -remsh app@host2.com</code></li><li id="afe2" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">验证主机连接是否正常工作:</li></ol><pre class="jr js jt ju fq lj li lk ll aw lm dt"><span id="c2ca" class="ln kd hu li b fv lo lp l lq lr">(app@host2.com)1&gt; net_adm:ping('app@host2.com').<br/>pong<br/>(app@host2.com)2&gt; net_adm:ping('app@host1.com').<br/>pong<br/>(app@host2.com)4&gt; net_adm:ping('ejabberd@host3.com').<br/>pong<br/>(app@host2.com)5&gt; nodes().<br/>['test@host2.com','app@host1.com','ejabberd@host3.com']</span></pre><p id="b426" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个简单的例子中，我们使用标准的erlang发行版将几个容器连接起来。这是可能的，因为所有的容器都运行在同一个docker网络中，并且可以访问彼此的epmd守护进程…</p><p id="55cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我们如何连接运行在不同主机上的docker容器呢？</p><h1 id="d895" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">独立机器上运行的连接梁</h1><p id="ee9c" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">最后，如果你想进入生产阶段，创建一个真正的云，运行多台主机，上面的设置将不起作用，因为容器不知道如何相互连接。</p><p id="9bb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，主机不会知道彼此的docker网络(实际上，一些使用docker swarm或amazon ec2 containers服务互连docker容器的工作正在进行，但我们无法使其可靠地运行)，我们将不得不组织一个更复杂的连接机制。</p><p id="2be3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，创建替代的erlang分发协议的想法来自这篇精彩的文章，<a class="ae jp" href="https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html" rel="noopener ugc nofollow" target="_blank">没有epmd的Erlang(和Elixir)分发</a>，我们只是决定向前迈出几步，创建一个可插入的应用程序，它只是“找到它们，将它们全部链接起来，并……确保它们始终连接。”</p><h1 id="c272" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">无epmd方法</h1><p id="8033" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">正如Magnus Henoch 在他的博客文章中所描述的那样，在dockered设置中并不真正需要epmd，因为docker环境已经在强制暴露特定端口以供外部访问。正因为如此，erlang发行版只能使用一个端口(因为其他端口不会公开)。</p><p id="9dc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，在Erlang应用程序中存储主机和端口之间的映射非常容易。现在我们已经有了申请:<a class="ae jp" href="https://github.com/oltarasenko/epmdless" rel="noopener ugc nofollow" target="_blank"> EpmdLess </a>(功劳归于<a class="ae jp" href="https://github.com/dmzmk?tab=followers" rel="noopener ugc nofollow" target="_blank"> Dmitry Mazurin </a>构建了它的初始版本)。</p><p id="f546" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们看看它是如何工作的:</p><ul class=""><li id="1f60" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo mg ly lz ma dt translated">在Docker沙盒应用程序中克隆出Erlang发行版:<code class="eh lf lg lh li b">git clone <a class="ae jp" href="https://github.com/oltarasenko/erlang_distribution_in_docker.git" rel="noopener ugc nofollow" target="_blank">https://github.com/oltarasenko/erlang_distribution_in_docker.git</a></code></li><li id="25db" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo mg ly lz ma dt translated">签出到epmdless_example分支:<code class="eh lf lg lh li b">git checkout epmdless_example</code></li><li id="d221" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo mg ly lz ma dt translated">为应用程序构建docker映像:<code class="eh lf lg lh li b">cd erlang_distribution_in_docker &amp;&amp; docker-compose build</code></li><li id="8add" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo mg ly lz ma dt translated">调出docker-compose.yml中描述的容器:<code class="eh lf lg lh li b">docker-compose up</code></li><li id="fd2e" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo mg ly lz ma dt translated">让我们检查epmd是否真的在节点上运行:</li></ul><pre class="jr js jt ju fq lj li lk ll aw lm dt"><span id="57b4" class="ln kd hu li b fv lo lp l lq lr">docker-compose exec app1 lsof -i -n -P<br/>COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME<br/>beam.smp   1 root   13u  IPv4 251627      0t0  TCP *:17012 (LISTEN)</span></pre><ul class=""><li id="0176" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo mg ly lz ma dt translated">登录其中一个容器:<code class="eh lf lg lh li b">docker-compose exec app3 _build/default/rel/sample_app/bin/sample_app console</code></li><li id="3759" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo mg ly lz ma dt translated">使用epmdless连接到另一个节点:</li></ul><pre class="jr js jt ju fq lj li lk ll aw lm dt"><span id="913d" class="ln kd hu li b fv lo lp l lq lr">&gt; epmdless_dist:add_node(‘app1@host1.com’, 17012). % Add node into epmdless database<br/>&gt; net_adm:ping(‘app1@host1.com’). % Do ping<br/>&gt; nodes(). % Node is discovered<br/></span></pre><p id="124f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一个简短的视频，展示了上面执行的步骤:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Watch: EPMDLess NewExample</figcaption></figure><p id="d25f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很好，如你所见，我们能够以这种方式连接节点。看起来很难通过这种方式发现节点，因为我们需要为每个节点启动epmdless_dist:add_node和net_adm:ping调用。这就是为什么我们也想建议一个方便的方法(至少我们希望你会喜欢它),它允许你也为docker平台启用自动节点发现…</p><h1 id="1557" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">分布式集群上的节点发现</h1><p id="bbea" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">为了能够组织节点发现过程，我们发布了<a class="ae jp" href="https://github.com/oltarasenko/erlang-node-discovery" rel="noopener ugc nofollow" target="_blank"> Erlang节点发现</a>应用程序，该应用程序可以自动建立不同节点之间的连接，正如应用程序配置文件中所指定的那样。</p><p id="a111" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除此之外，它还提供了一个简单的API，允许您扩展节点发现机制，并使用来自任何其他节点/端口数据库(本地文件、redis、数据库等)的数据。</p><pre class="jr js jt ju fq lj li lk ll aw lm dt"><span id="2856" class="ln kd hu li b fv lo lp l lq lr">{ erlang_node_discovery, [<br/>    % epmdless_dist as our database<br/>    {db_callback, epmdless_dist},<br/>    {hosts, ["host1.com", "host2.com", "host3.com"]},<br/>    % query following appnames/ports<br/>    {node_ports, [<br/>      {'app1', 17012},<br/>      {'app2', 17013},<br/>      {'app3', 17014}<br/>    ]}<br/>  ]}</span></pre><p id="1273" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该应用程序现在将为每个可能的{appname@hostname，port}对生成一个进程，并将尝试组织一个完全连接的集群(并将进行重新连接)。</p><p id="dbd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的例子中(如上面配置文件中的定义),它将为以下可能的节点生成进程:</p><pre class="jr js jt ju fq lj li lk ll aw lm dt"><span id="935f" class="ln kd hu li b fv lo lp l lq lr">app1@host1.com:17012 app2@host1.com:17013 app3@host1.com:17014 app1@host2.com:17012 app2@host2.com:17013 app3@host2.com:17014 app1@host3.com:17012 app2@host3.com:17013 app3@host3.com:17014</span></pre><p id="c5e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们试一试:</p><ol class=""><li id="61c1" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo lx ly lz ma dt translated">在Docker沙盒应用程序中克隆出Erlang发行版:<code class="eh lf lg lh li b">git clone <a class="ae jp" href="https://github.com/oltarasenko/erlang_distribution_in_docker.git" rel="noopener ugc nofollow" target="_blank">https://github.com/oltarasenko/erlang_distribution_in_docker.git</a></code></li><li id="325d" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">签出到主分支(如果在上一步中已经克隆了所有内容，则需要):<code class="eh lf lg lh li b">git checkout master</code></li><li id="e1ac" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">为应用程序构建docker映像:<code class="eh lf lg lh li b">cd erlang_distribution_in_docker &amp;&amp; docker-compose build</code></li><li id="edb6" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">调出docker-compose.yml中描述的容器:<code class="eh lf lg lh li b">docker-compose up</code></li></ol><p id="dee4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一段视频总结了上述步骤:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Watch: ErlangNodeDiscovery</figcaption></figure><h1 id="5544" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">好吧，但是长生不老药呢？</h1><p id="fc73" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">实际上，重用相同的erlang库来运行连接的elixir集群是没有问题的。唯一的技巧是显示elixir在哪里可以找到erlang libs:)。这次我添加了一个Makefile来演示它。</p><pre class="jr js jt ju fq lj li lk ll aw lm dt"><span id="d1c5" class="ln kd hu li b fv lo lp l lq lr">start:<br/>    @ERL_LIBS=_build/dev/lib/ iex --name ${NODE_NAME} \<br/>        --erl "+K true" \<br/>        --erl "-config config/sys.config" \<br/>        --erl "-proto_dist epmdless_proto" \<br/>        --erl "-start_epmd false" \<br/>        --erl "-epmd_module epmdless_client" \<br/>        -S mix</span></pre><h1 id="921a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">现在让我们回顾一下长生不老药的例子:</h1><ol class=""><li id="d855" class="ls lt hu it b iu la iy lb jc mn jg mo jk mp jo lx ly lz ma dt translated">git克隆<a class="ae jp" href="https://github.com/oltarasenko/epmdless.git" rel="noopener ugc nofollow" target="_blank">https://github.com/oltarasenko/epmdless.git</a></li><li id="a5c7" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">docker-撰写构建</li><li id="db9b" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">docker-排版</li></ol><p id="52fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仅此而已。下面是短视频演示！</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mq mi l"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Watch: ElixirEpmdLess</figcaption></figure></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="fae1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="my">最初发表于</em><a class="ae jp" href="http://www2.erlang-solutions.com/l/23452/2018-03-28/5d3rbc" rel="noopener ugc nofollow" target="_blank"><em class="my">www.erlang-solutions.com</em></a><em class="my">。</em></p></div></div>    
</body>
</html>