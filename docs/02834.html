<html>
<head>
<title>Why All The Monolithic Serverless API Hate?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么所有的单片无服务器API讨厌？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-all-the-monolithic-serverless-api-hate-2f673bf089e3?source=collection_archive---------18-----------------------#2018-03-29">https://medium.com/hackernoon/why-all-the-monolithic-serverless-api-hate-2f673bf089e3?source=collection_archive---------18-----------------------#2018-03-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f253" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">原载于</em><a class="ae jq" href="https://www.stackery.io/blog/why-all-the-monolithic-serverless-api-hate" rel="noopener ugc nofollow" target="_blank"><em class="jp">www . stackery . io</em></a><em class="jp">。</em></p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="a395" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个分裂存在于无服务器的土地上。在一个重要的架构问题上，双方的人数大致相同:你的API应该由一个单一的函数支持，还是由每个端点的独立函数支持？对于无服务器生态系统的信用，这种分裂并没有演变成交战派系。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div class="fe ff jy"><img src="../Images/3e71eb14550e80f3add7b4d700deacb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*SDPiaRjhNKedi9jH.jpg"/></div></figure><p id="321e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无服务器生态系统中的战斗是什么样的</p><p id="e705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就是说，有些人将API功能合理地拆分为独立的功能，其论据归结为以下几点的组合:</p><ul class=""><li id="3dca" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">我们现在可以前所未有地将功能拆分成纳米服务，为什么不呢？</li><li id="0c13" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">关于独立功能实际上更容易跟踪的理由，即使我们可能都同意大多数跟踪无服务器资源爆炸的工具仍然不够成熟*</li><li id="c2d6" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">基于代码架构偏好或由于低效实现导致的长冷启动时间，单片无服务器功能不好的原因</li></ul><p id="169e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(*无耻地宣传Stackery 如何对此有所帮助)</p><p id="a4cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为前两个论点相当无力，独立函数支持的API的主要理由更多的是基于单一API的问题，而不是为什么独立函数支持的API更好。我还没有看到一个好的理由来说明为什么所有的API都应该被分解成独立的函数。仅仅因为整体架构有可能出现问题并不能证明走向相反的极端是理想的。</p><p id="8347" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">单体方法当然有局限性，但是这些局限性更多的是由于康威定律而不是技术架构。康威定律表明，当有单独的团队管理API的不同部分时，合理的方法是将API分成独立的功能。</p><p id="2c15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有些人担心，由于需要一次初始化API的所有组件，单块函数的冷启动时间可能会更长。然而，每种语言都有减少冷启动时间的合理策略。例如，<a class="ae jq" href="http://jbavari.github.io/blog/2015/08/25/lazy-loading-your-node-modules/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae jq" href="http://code.activestate.com/recipes/473888-lazy-module-imports/" rel="noopener ugc nofollow" target="_blank"> Python </a>都使得功能的延迟加载变得容易，而Go的冷启动时间很短，这仅仅是因为它是一个完全编译的可执行文件。</p><p id="f47e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这自然导致了对功能架构对冷启动的影响的更广泛的讨论。令人欣慰的是，大多数API用例都容忍冷启动延迟，但这并不是完全可以忽略的。例如，我们都知道<a class="ae jq" href="https://blog.gigaspaces.com/amazon-found-every-100ms-of-latency-cost-them-1-in-sales/" rel="noopener ugc nofollow" target="_blank">著名的研究</a>显示了延迟如何对电子商务的收入产生巨大影响。一般来说，几乎每个构建公共无服务器API的人都应该以某种形式监控冷启动。</p><p id="9e23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">崔琰(又名<a class="ae jq" href="https://theburningmonk.com/" rel="noopener ugc nofollow" target="_blank">燃烧的和尚</a>和全能杰出开发者)最近写道<a class="ae jq" href="https://theburningmonk.com/2018/02/aws-lambda-monolithic-functions-wont-help-you-with-cold-starts/" rel="noopener ugc nofollow" target="_blank">单片无服务器功能不会帮助冷启动</a>。他提出了一个有效的观点，即在大范围内，冷启动会变成噪音。没有服务提供商的帮助，我们永远无法摆脱冷启动，这也是事实。但他的主要论点是，无论使用单片函数还是独立函数，冷启动次数都是一样的。</p><p id="1218" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这个论点有一个不正确的假设。Yan提出了一个API来分析冷启动的影响，其中每个端点都受到相同量的流量的冲击。实际上，几乎没有任何API在所有端点上都有统一的流量。大多数API端点流量遵循类似于自然<a class="ae jq" href="https://en.wikipedia.org/wiki/Power_law" rel="noopener ugc nofollow" target="_blank">幂定律</a>的模式。少数端点会有很高的流量，但大多数会少得多。几个端点将只有很少的流量。</p><figure class="jz ka kb kc fq kd fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/988ef7be8e442786cb4c6903903a561d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*_oUxGzLPbrDbVidm.png"/></div></figure><p id="2269" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您的API由一个整体函数支持时，冷启动会按照吞吐量的比例分布在所有API请求中。换句话说，触发冷启动的请求的百分比对于所有端点都是相同的。</p><p id="fa4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们来看看独立函数支持的API的含义。假设您有一个每小时被1000个请求命中的端点，和一个每小时被5个请求命中的端点。根据您的函数的<a class="ae jq" href="https://theburningmonk.com/2017/06/aws-lambda-compare-coldstart-time-with-different-languages-memory-and-code-sizes/" rel="noopener ugc nofollow" target="_blank">冷启动速率</a>，您可能会发现，虽然您很少冷启动高吞吐量端点，但几乎每个对低吞吐量函数的请求都会导致冷启动。</p><p id="df19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许对你的API来说，每个端点有不同的冷启动率是可以的。但是对于许多API来说，这是有问题的。想象一下，您的API既有列出条目的端点，也有创建条目的端点，其中列表请求比条目创建请求更频繁。您可能有一个关于每个端点要满足的延迟的服务级别协议。在这种情况下，最好将冷启动分散到所有端点。</p><p id="fd3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然可以使用触发器来保温函数，但是如果你有一个单一的函数，保温它比保温许多独立的函数要容易得多。此外，与普遍的看法相反，即使在高吞吐量的情况下，也有一些有意义的方法来预热函数，不过我将在另一篇文章中讨论这个问题。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="f119" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有的架构选择都有权衡。但是在单一的和独立的API函数之间的选择是一个错误的二分法。实际上，在单个整体功能中包含的所有功能和作为独立微服务部署的每个三线helper之间存在广泛的差异。这两者在所有情况下都是不可取的，这就是为什么反对其中一个的论点往往是无力或荒谬的。人们应该做的是考虑他们如何为他们的API组件确定适当的界限，以及随着他们的总代码行、架构复杂性和涉及的人数的增长，他们如何管理这个界限。</p></div></div>    
</body>
</html>