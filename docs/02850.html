<html>
<head>
<title>Problematic React Lifecycle Methods are Going Away in React 17</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有问题的React生命周期方法将在React 17中消失</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/problematic-react-lifecycle-methods-are-going-away-in-react-17-4216acc7d58b?source=collection_archive---------1-----------------------#2018-03-30">https://medium.com/hackernoon/problematic-react-lifecycle-methods-are-going-away-in-react-17-4216acc7d58b?source=collection_archive---------1-----------------------#2018-03-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4a06602a19d3fda7aa252e575ddd63b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaqFjk6prZYIyeyHwRoE_A.jpeg"/></div></div></figure><p id="495e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您在理解一些react生命周期方法以及如何在不出错的情况下实现它们方面有困难吗？</p><p id="fbc5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你的答案是肯定的，你并不孤单。</p><p id="0a32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我一直在React原生应用中使用它们，我必须承认，我已经多次误用它们，并以艰难的方式吸取了教训。</p><p id="40f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React团队已经决定在React 17中弃用一些生命周期方法。reactjs团队最近的一篇博客文章揭示了组件生命周期方法的未来。</p><p id="ca54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">他们为什么决定除掉他们？最初的生命周期模型并不打算用于即将到来的一些特性，比如异步渲染。随着异步渲染的引入，这些生命周期方法中的一些在使用时会变得不安全。</p><blockquote class="kb"><p id="c7fc" class="kc kd hu bd ke kf kg kh ki kj kk jz ek translated"><em class="kl">传统的生命周期方法有太多的潜在缺陷，无法安全地用于异步渲染。</em></p></blockquote><h1 id="6e08" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">那么，什么正在消失？</h1><p id="8681" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">下面的生命周期方法将很快被弃用。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="e6b2" class="ly kn hu lu b fv lz ma l mb mc">componentWillMount</span><span id="ac17" class="ly kn hu lu b fv md ma l mb mc">componentWillRecieveProps</span><span id="d3c3" class="ly kn hu lu b fv md ma l mb mc">componentWillUpdate</span></pre><p id="7178" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">他们将分阶段淘汰这些方法，所以这不会是一夜之间的改变。我相信我们中的许多人都经常使用这三种方法。</p><p id="2c6b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上述生命周期方法在16.3版本中被归类为<strong class="je hv"> <em class="me">不安全</em> </strong>。在之后的版本中，弃用警告将被添加到遗留方法中。最后，在React 17中，遗留方法将被完全废弃。</p><p id="1a6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有趣的是，<strong class="je hv"> <em class="me">不安全</em> </strong>方法在React 17中仍然会被使用。</p><h1 id="15d5" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx mf kz la lb mg ld le lf mh lh li lj dt translated">什么是新的？</h1><p id="80ff" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">三种旧的生命周期方法将被重命名，另外两种方法也将被引入。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="0dfb" class="ly kn hu lu b fv lz ma l mb mc">UNSAFE_componentWillMount</span><span id="7b54" class="ly kn hu lu b fv md ma l mb mc">UNSAFE_componentWillRecieveProps</span><span id="5328" class="ly kn hu lu b fv md ma l mb mc">UNSAFE_componentWillUpdate</span><span id="142e" class="ly kn hu lu b fv md ma l mb mc">getDerivedStateFromProps</span><span id="6559" class="ly kn hu lu b fv md ma l mb mc">getSnapshotBeforeUpdate</span></pre><p id="2f64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以方法并没有真的消失，但是它们被标记为不安全。程序员应该意识到不要使用它们，或者小心谨慎地使用它们。</p><p id="78f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">异步渲染将导致<em class="me"> componentWillMount </em>触发组件树的多重渲染。这使得它不安全。</p><p id="de8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想知道未来的服务器渲染如何只使用<em class="me"> componentDidMount，</em>这里有一个来自<a class="ae ka" href="https://medium.com/u/a3a8af6addc1" rel="noopener"> Dan Abramov </a>的回复来解释它。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><h1 id="0ae0" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx mf kz la lb mg ld le lf mh lh li lj dt translated">安全的生命周期方法</h1><p id="a2ca" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">以下是我从博文中收集到的关于新生命周期方法的信息。</p><p id="0d84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"><em class="me">getDerivedStateFromProps</em></strong></p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="ff4e" class="ly kn hu lu b fv lz ma l mb mc">static getDerivedStateFromProps(nextProps, prevState) {<br/>    // ...<br/>  }</span></pre><p id="7074" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个方法将处理<em class="me">component will receive props</em>和<em class="me"> componentDidUpdate能够做的事情。</em>是静态的。它在一个组件被创建后被调用，当它收到一个新的属性时也被调用。这将是比<em class="me">组件接收弹出窗口更安全的选择。</em></p><p id="6425" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它返回一个对象来更新状态以响应属性更改。它将返回null，表示状态没有变化。</p><p id="a34a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使道具没有改变，React也可能调用这个方法。</p><p id="9663" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"><em class="me">getsnapshotbefore update</em></strong></p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="67ee" class="ly kn hu lu b fv lz ma l mb mc">getSnapshotBeforeUpdate(prevProps, prevState) {<br/>    // ...<br/>  }</span></pre><p id="c357" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将处理<em class="me"> componentWillUpdate </em>和<em class="me"> componentDidUpdate能够做的事情。</em>这是在DOM更新之前调用的。从<em class="me">getsnapshotbeforedupdate</em>返回的值被传递给<em class="me"> componentDidUpdate。</em></p><p id="7f8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DOM一更新，componentDidUpdate 就被调用。<em class="me">快照</em>值被传递给<em class="me"> componentDidUpdate。</em></p><p id="5c31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当<em class="me">getsnapshotbefore update</em>可用时，在异步渲染期间调整窗口大小是一个很好的用例。</p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><h1 id="502e" class="km kn hu bd ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf mv lh li lj dt translated">编辑:当我写这篇文章的时候，React 16.3.0正式发布了。Wohoo！！！</h1><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="d10f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了生命周期方法的改变，他们还发布了一个叫做<strong class="je hv">严格模式的新工具。</strong> It <strong class="je hv"> </strong>识别并强调组件中不安全的生命周期方法，以及开发过程中的许多其他副作用。从他们的博客文章中了解更多关于严格模式的信息。</p><p id="c573" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于新的生命周期方法及其用法的例子，请查看最初的博客文章。</p><p id="3faf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了更好地理解，请查看React团队展示这些很酷的新功能的预览视频。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mw mj l"/></div></figure></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><h1 id="c16a" class="km kn hu bd ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf mv lh li lj dt translated">我怎么想？</h1><p id="b7d9" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">当最初设计react组件生命周期方法时，它们不必担心许多未来的用例，如异步呈现。</p><p id="2517" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这些弃用不是向后兼容的，但这是朝着改进迈出的一步，我很喜欢。</p><p id="7467" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很高兴react团队指出遗留生命周期方法是不安全的。这将禁止反模式和误用这些方法。我很高兴能在React 16.3.0中看到为我们开发者准备的所有新特性。</p><p id="d5c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们去找点乐子吧。</p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="46b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我是致力于React本地应用的软件顾问。我也是一名多视作家，热爱教学。你可以查看我在React Native上的最新课程，来自下面的<a class="ae ka" href="https://www.pluralsight.com/courses/react-native-big-picture" rel="noopener ugc nofollow" target="_blank"> pluralsight </a>:</p><p id="f5a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://www.pluralsight.com/courses/react-native-big-picture" rel="noopener ugc nofollow" target="_blank">https://www . plural sight . com/courses/react-native-big-picture</a></p><p id="fd3f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如需更多信息和我的帖子，请访问<a class="ae ka" href="http://adhithiravichandran.com/" rel="noopener ugc nofollow" target="_blank">http://adhithiravichandran.com/</a>并在twitter上关注我<a class="ae ka" href="https://twitter.com/AdhithiRavi" rel="noopener ugc nofollow" target="_blank"> @AdhithiRavi </a>。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mx mj l"/></div></figure></div></div>    
</body>
</html>