<html>
<head>
<title>Which is the fastest version of Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python最快的版本是哪个？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/which-is-the-fastest-version-of-python-2ae7c61a6b2b?source=collection_archive---------0-----------------------#2018-04-02">https://medium.com/hackernoon/which-is-the-fastest-version-of-python-2ae7c61a6b2b?source=collection_archive---------0-----------------------#2018-04-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="43e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，“视情况而定”，但是它取决于什么，您如何评估哪个版本的Python对您的应用程序来说是最快的？</p><blockquote class="jp"><p id="2e1e" class="jq jr hu bd js jt ju jv jw jx jy jo ek translated">Python 3比Python 2慢吗？Python 3的哪个版本最快，你对速度还有什么其他选择？</p></blockquote><h1 id="72ea" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">使用性能套件实用程序</h1><p id="74f7" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">核心Python团队非常关心性能，我在speed.python.org网站之前已经提到过，这是将“官方”基准与CPython版本进行比较的好方法。</p><p id="7be1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是有几个问题:</p><ol class=""><li id="7817" class="lc ld hu it b iu iv iy iz jc le jg lf jk lg jo lh li lj lk dt translated">结果很难解读</li><li id="017c" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">他们不包括PyPy</li></ol><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lq"><img src="../Images/01ba8f05fd93ab123fd7df28ef68c671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fG_PKDlfg-JUj9HaT2bRAA.png"/></div></div></figure><p id="6576" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过运行<code class="eh md me mf mg b">pip install performance</code>下载运行这个网站的工具箱，然后你就可以运行了</p><p id="718a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh md me mf mg b">pyperformance run --python={chosen_python_runtime} -o my_results.json</code></p><p id="c937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将针对Python的目标版本多次运行一系列有文档记录的“真实世界”应用程序，并记录平均值、中间值和</p><p id="560e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是我在本文中针对Python的官方安装所做的工作:</p><ul class=""><li id="6e94" class="lc ld hu it b iu iv iy iz jc le jg lf jk lg jo mh li lj lk dt">2.7.10,</li><li id="f490" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo mh li lj lk dt">3.4.4,</li><li id="5a67" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo mh li lj lk dt">3.5.4,</li><li id="dc89" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo mh li lj lk dt translated">3.6.1和</li><li id="a02b" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo mh li lj lk dt translated">3.7(我有beta 2)。</li></ul><p id="586c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，这也包括PyPy(5.6。)和PyPy3 (5.4.10)。</p><h1 id="05bc" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw dt translated">结果呢</h1><p id="826c" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">我已经根据用例对结果进行了分解，所以看一看，运行你自己的测试，并且可能编写你自己的测试。</p><p id="21db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还创建了一个简单的脚本来获取perf数据文件的列表，并为每个测试创建图表。<a class="ae mc" href="https://gist.github.com/tonybaloney/4e8e45f9128e9eb6e4f36c73ba5e5574" rel="noopener ugc nofollow" target="_blank">代码在GitHub上</a>。</p><blockquote class="jp"><p id="99b8" class="jq jr hu bd js jt ju jv jw jx jy jo ek translated">在所有图表中，结果以秒为单位，越低越好。</p></blockquote><p id="6d2e" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">完整的结果和图表可以在这里找到:<a class="ae mc" href="https://github.com/tonybaloney/performance_testing/tree/master/png" rel="noopener ugc nofollow" target="_blank">https://github . com/tonybaloney/performance _ testing/tree/master/png</a></p><p id="ded2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经包括了我认为有意义的测试。<em class="mq">其余的测试显示了非常相似的模式，这在结论中。</em></p><h2 id="6932" class="mr ka hu bd kb ms mt mu kf mv mw mx kj jc my mz kn jg na nb kr jk nc nd kv ne dt translated">呈现HTML模板</h2><p id="f893" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated"><code class="eh md me mf mg b">django_html</code>测试将使用Django模板渲染引擎来构建一个150x150单元格的HTML表格。它利用了Django引擎的内容和模板类。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff nf"><img src="../Images/50d85c19d108451a0f02306b26cf5a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JswUxN3bOPQ7UHSjm0Ekzw.png"/></div></div></figure><p id="7861" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python 3.7比Python 2.7 快了<strong class="it hv">1.19倍，但却是我运行的唯一一个击败Python 2.7基准测试的Python 3.x版本。speed.python.org基准显示了类似的结果。</strong></p><p id="2a23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PyPy粉碎任何CPython结果，但是PyPy3比PyPy慢一倍。值得注意的是Django最近决定在Django 2.0和更高版本中放弃Python 2支持，这意味着PyPy也不再与Django 2兼容。</p><h2 id="ad96" class="mr ka hu bd kb ms mt mu kf mv mw mx kj jc my mz kn jg na nb kr jk nc nd kv ne dt translated">启动时间</h2><p id="3c72" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">这个测试只是测试解释器启动所花费的时间。如果你通过运行多个进程来绕过Python的“GIL”约束，那么这将是非常重要的。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff nf"><img src="../Images/2d8b13a0d38f4666a47cab06a20c9f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KRGUToNBwTIBlvYRHMAbA.png"/></div></div></figure><p id="7df2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意这里关于PyPy的跳转，尤其是PyPy3，我将在本文结尾解释原因。</p><blockquote class="jp"><p id="9ff3" class="jq jr hu bd js jt ju jv jw jx jy jo ek translated">但这其中的症结在于Python 2.7启动时间依然不败。</p></blockquote><h2 id="1b34" class="mr ka hu bd kb ms ng mu kf mv nh mx kj jc ni mz kn jg nj nb kr jk nk nd kv ne dt translated">加密:crypto_paes</h2><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff nf"><img src="../Images/4eedf12480a1113bdb42f53ace01abe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6xWxEEJfsR4ANOPEYb34A.png"/></div></div></figure><p id="42ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个测试中，您将看到Python 2和3之间的速度明显下降。为什么？Crypto需要大量的数字运算，Python 3不再有32位整数类型，只有一个(非常)长的整数。</p><p id="3826" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PyPy用户——你会注意到PyPy3比PyPy<strong class="it hv">几乎慢5倍</strong>！</p><h2 id="ca49" class="mr ka hu bd kb ms mt mu kf mv mw mx kj jc my mz kn jg na nb kr jk nc nd kv ne dt translated">n皇后:算法测试</h2><p id="7350" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">这个实现不是特别优雅，很抱歉给那些不得不耐着性子听完关于这个主题的算法讲座的人带来了不好的回忆。这个难题很简单，就是把(n)个皇后放在棋盘上，这样他们就不能互相吃掉对方。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff nf"><img src="../Images/9a49e12c9befc43e77064b3e1053d1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhPlahXo8Kdy1_U2Gp_yZw.png"/></div></div></figure><p id="8f6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在CPython系列中，3.7再次<em class="mq">拔得头筹</em>，但值得注意的是PyPy和PyPy3的结果非常相似。</p><h2 id="5548" class="mr ka hu bd kb ms mt mu kf mv mw mx kj jc my mz kn jg na nb kr jk nc nd kv ne dt translated">浮点运算</h2><p id="066a" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">“float”基准测试是一个人工的浮点运算密集型应用程序，它将创建100，000个点对象来计算<code class="eh md me mf mg b">math.cos()</code>、<code class="eh md me mf mg b">math.sin()</code>和<code class="eh md me mf mg b">math.sqrt()</code>。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff nf"><img src="../Images/11955ecb66ef8163915cce3f94e211c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U-4S9qctHDiTpPC0eAC6kA.png"/></div></div></figure><p id="c908" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一种非常适合PyPy的应用程序，有大量的数字运算、可预测的类型和方法以及循环。Python 3.7具有新的快速方法调用操作码，该操作码正在这个测试中使用。</p><h2 id="54a0" class="mr ka hu bd kb ms mt mu kf mv mw mx kj jc my mz kn jg na nb kr jk nc nd kv ne dt translated">正则表达式</h2><p id="8cb1" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">在regex测试中，“web上50个最流行的页面，并记录所有执行的regexp操作。每个操作都被赋予一个权重，这个权重是根据它出现的页面的受欢迎程度以及在加载每个页面时它被执行的次数来计算的。最后，数据中的文字字母使用ROT13进行编码，编码方式不会影响正则表达式与输入的匹配程度。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff nf"><img src="../Images/955a85ce2a004876d2eff117630a2e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzxIdFNg2t_C9HacAW64Vw.png"/></div></div></figure><p id="517b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不知道PyPy在这里发生了什么，我很想知道其他人是否有同样的结果！</p><blockquote class="nl nm nn"><p id="d689" class="ir is mq it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated"><strong class="it hv">更新</strong>:PyPy团队看到了这篇文章，并在几个小时内修复了这个问题</p></blockquote><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="nr ns l"/></div></figure><h1 id="87b1" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw dt translated">那么Python 3比Python 2快吗？</h1><p id="cfc1" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">是啊！在<strong class="it hv">几乎所有的测试</strong>中。值得注意的例外是<code class="eh md me mf mg b">crypto_paes</code>测试，Python 3慢了1.35倍(因为整数类型)，python_startup慢了1.39倍。</p><p id="8daf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python 3启动缓慢是核心CPython团队正在为3.8、3.9版本解决的问题之一。</p><p id="74c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了这两个测试之外，Python 3在这些基准测试中大约快了1.2-1.3倍。当Python 3.7在今年晚些时候上市时，您应该会看到它的改进。</p><h1 id="da76" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw dt translated">为什么PyPy要快得多，为什么每个人都不用它呢？</h1><p id="5399" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">PyPy比CPython快，因为它有一个即时编译器。JIT编译器有一个很大的好处，那就是它们在执行可预测的、重复的任务时非常高效。基准测试的一个本质是，你试图多次运行同一段代码，以使其准确，推动应用程序并减少误差。因此PyPy在这些测试中大放异彩。</p><p id="47de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JIT编译器，尤其是PyPy编译器的缺点是启动成本高。另一个缺点是许多C扩展缺乏兼容性。因为“Python”(CPython，官方PSF Python)是用C写的，PyPi上的许多第三方扩展利用了这一点。Numpy就是一个很好的例子，Numpy的大部分都是用优化的C代码编写的。当您<code class="eh md me mf mg b">pip install numpy</code>它使用您的本地C编译器并构建一个二进制库供您的Python运行时使用。</p><p id="5f48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为PyPy是用Python编写的，所以许多模块根本无法在PyPy中工作。所以你应该经常检查。</p><p id="101f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，PyPy面临着与CPython相同的挑战——从该语言的版本2到版本3的转变。我发现PyPy3直到最近都不稳定，在基准测试中你仍然可以看到PyPy奇怪的不一致性。我也遇到过软件包(例如PyTest)在解决问题时放弃对PyPy3的支持的问题。</p><h1 id="d7a4" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw dt translated">结论</h1><p id="0f74" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">Python 3.7是“官方”Python中最快的，PyPy是我测试过的最快的实现。</p><p id="80a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着Python 2越来越少被使用，我希望看到PyPy3在未来表现得一样好，如果不是比PyPy更好的话。</p><h2 id="b257" class="mr ka hu bd kb ms mt mu kf mv mw mx kj jc my mz kn jg na nb kr jk nc nd kv ne dt translated">还卡在Python 2上？</h2><p id="a870" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated"><a class="ae mc" href="https://www.pluralsight.com/courses/python-2-to-python-3" rel="noopener ugc nofollow" target="_blank">查看我在Pluralsight上关于从Python 2迁移到3的新课程。</a></p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="nt ns l"/></div></figure></div></div>    
</body>
</html>