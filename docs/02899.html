<html>
<head>
<title>WebAssembly, the Journey — What is WASM?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly，旅程——WASM是什么？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/webassembly-the-journey-what-is-wasm-caf9871108aa?source=collection_archive---------3-----------------------#2018-04-02">https://medium.com/hackernoon/webassembly-the-journey-what-is-wasm-caf9871108aa?source=collection_archive---------3-----------------------#2018-04-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0b58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文是关于我们WebAssembly之旅的系列文章的第三部分。如果你从这篇文章开始，你可能想从<a class="ae jp" rel="noopener" href="/p/webassembly-the-journey-a069d6ea18a">开始。</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/8e539a896588342c3aeef0dfba23ea7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f__SEWRvsNwt4B-u8-85Bw.png"/></div></div></figure><p id="71fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上一篇文章中，我们介绍了JavaScript是如何发展的，以及实时编译器(JIT)是如何在这种语言中工作的，从而加快了JS的执行速度。这个解释为我们比较JavaScript和WebAssembly的性能提供了基础。但是什么是WebAssembly呢？</p><h2 id="4c23" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">什么是WebAssembly？</h2><p id="a9fe" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">WebAssembly或WASM是一个二进制格式的<strong class="it hv">编译器目标</strong>(编译器生成的代码)，它允许我们在浏览器上执行C、C++和Rust，性能接近本机代码。</p><p id="fb5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">WebAssembly的一个令人兴奋的方面是，它不是JavaScript的替代品，而是与JavaScript一起工作。同时，这种组合可以提供类型化/编译语言的性能和JavaScript的灵活性。使用JavaScript上的WebAssembly API，您可以在JS应用程序上加载模块WASM，并在它们之间共享功能。</p><p id="9319" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上一篇文章中，在理解了JavaScript有多快之后，我们想知道哪种技术可以帮助我们实现2008年JIT带来的同样的性能飞跃。WebAssembly就是这种技术。但是为了理解WASM代码为什么比Javascript更快，我们需要分析JavaScript引擎在概念上是如何处理这两者的。</p><ul class=""><li id="4119" class="lc ld hu it b iu iv iy iz jc le jg lf jk lg jo lh li lj lk dt translated"><strong class="it hv">加载时间:</strong>Javascript代码下载比WebAssembly代码慢。它比较慢，因为<code class="eh ll lm ln lo b">.wasm</code>格式是二进制的，正因为如此，它比<code class="eh ll lm ln lo b">.js</code>类似的代码更紧凑。</li><li id="d21e" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated"><strong class="it hv">解析器:</strong>不需要解析. wasm代码。相反，浏览器解码WASM文件比解析JavaScript代码花费的时间少，因为wasm代码已经更接近机器码了。众所周知，解析1MB的JavaScript代码可能需要1秒钟；<a class="ae jp" href="https://github.com/binast/ecmascript-binary-ast" rel="noopener ugc nofollow" target="_blank">二进制AST提议</a>可以缓解JavaScript解析速度慢的问题，但这是另一篇文章的主题。</li><li id="d8c8" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">编译/优化。wasm代码在生成二进制代码时得到优化，从而消除了在执行时间上花费时间的需要。JavaScript不会发生这种情况，在JavaScript中，浏览器优化程序，而JiT编译器执行程序。WASM上的编译时间仍然更快，因为这些预先的优化是在WebAssembly源代码上完成的。除此之外，浏览器正在实现流式WASM编译器，这将使编译时间比下载时间更快。</li><li id="3945" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated"><strong class="it hv">执行:</strong>正如上一篇文章所解释的，执行阶段不仅仅与代码执行有关。它包括JIT编译器进行的所有推测性优化，这是因为JavaScript代码的不可预测性。相反，wasm代码不需要这些优化，因为它是从静态类型代码中生成的。它还使浏览器花费更少的内存，因为分析器不需要维护一个包含代码执行统计信息的表来优化它。</li><li id="ba29" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">GC: We Assembly还没有垃圾收集器。</li></ul><p id="14c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了形象化起见，JavaScript和WebAssembly代码之间的生命周期比较理论上可以如下图所示:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lu"><img src="../Images/c0bab5b04a9bdf94e14f8cb2253627e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XdcikPGwbP_aqCsgyK3tMQ.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Theoretically comparison between JavaScript and WASM code life cycle.</figcaption></figure><h2 id="01ee" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">关于WebAssembly的常见误解</h2><p id="3b32" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">这些是我在人们讨论这个话题时看到的最常见的误解:</p><ul class=""><li id="96a6" class="lc ld hu it b iu iv iy iz jc le jg lf jk lg jo lh li lj lk dt translated"><strong class="it hv"> WASM是JavaScript杀手:</strong> WebAssembly不是用来取代JavaScript的。它的创建是为了完善性能对web应用程序至关重要的环境。</li><li id="0c81" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated"><strong class="it hv"> WASM是一种新的编程语言:</strong>值得一提的是，WASM是一种中间格式，二进制，是其他语言如C、C++和Rust的编译器目标。尽管wasm有一个文本表示，但人们并不希望在它上面编程，因为人们并不希望在汇编中编码。</li><li id="b01d" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">只有C或Rust程序员可以编写WASM代码:一旦WebAssembly增加了新的功能，对其他语言的支持就会到来，比如<em class="lz">垃圾收集器</em>。此外，还有一些新语言的项目，甚至是编译到WASM的JavaScriot的子/超集。</li></ul><p id="d293" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们在上面和以前的文章中看到的，理论上WASM比JavaScript快，但是实际上它是怎样的呢？这是我们将在下一篇文章中发现的。</p><h1 id="0620" class="ma kd hu bd ke mb mc md ki me mf mg km mh mi mj kp mk ml mm ks mn mo mp kv mq dt translated">链接</h1><ul class=""><li id="14ea" class="lc ld hu it b iu kx iy ky jc mr jg ms jk mt jo lh li lj lk dt translated">什么是web assembly:<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/web assembly/Concepts</a></li><li id="0292" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">二进制AST，JS提案说明:<a class="ae jp" href="https://github.com/binast/ecmascript-binary-ast" rel="noopener ugc nofollow" target="_blank">https://github.com/binast/ecmascript-binary-ast</a></li><li id="3c78" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">Javascript启动性能:<a class="ae jp" rel="noopener" href="/reloading/javascript-start-up-performance-69200f43b201">https://medium . com/reloading/JavaScript-start-up-performance-69200 f43b 201</a></li><li id="e2b7" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">turbo script——编译成https://github.com/01alchemist/TurboScript WASM的Javascript超集:<a class="ae jp" href="https://github.com/01alchemist/TurboScript" rel="noopener ugc nofollow" target="_blank"/></li><li id="1bbc" class="lc ld hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">Walt—web assembly的JavaScript语法:<a class="ae jp" href="https://github.com/ballercat/walt" rel="noopener ugc nofollow" target="_blank">https://github.com/ballercat/walt</a></li></ul></div></div>    
</body>
</html>