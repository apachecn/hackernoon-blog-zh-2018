<html>
<head>
<title>Get notified of user signups and plan changes automatically using Postgres &amp; Phoenix PubSub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Postgres &amp; Phoenix PubSub自动获得用户注册和计划变更的通知</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/get-notified-of-user-signups-and-plan-changes-automatically-using-postgres-phoenix-pubsub-e67d061b04bc?source=collection_archive---------4-----------------------#2018-04-02">https://medium.com/hackernoon/get-notified-of-user-signups-and-plan-changes-automatically-using-postgres-phoenix-pubsub-e67d061b04bc?source=collection_archive---------4-----------------------#2018-04-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/025cac31946845b2e7f546d3f0649b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrbIiOF-8aO0tKn0p3Kxlg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A look in to the future 🔮</figcaption></figure><p id="53dc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">很多时候你需要创建一个系统，它可以根据事件向你自己或其他用户<strong class="ji hv">发送<strong class="ji hv">通知</strong>，特别是与你的数据库中的变化相关的事件。Postgres </strong>和<strong class="ji hv"> Phoenix </strong>让这变得简单得可笑。</p><p id="d007" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这篇简短的<strong class="ji hv">文章结束时，你将拥有:</strong></p><ol class=""><li id="d66a" class="ke kf hu ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">设置一个Phoenix 1.3项目</li><li id="3b5f" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">在Postgres中设置广播功能和触发器</li><li id="c466" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">使用GenServer监听来自Postgres的广播</li><li id="f238" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">当用户注册或更改他们的支付计划时，使用Bamboo给自己发送电子邮件。</li></ol><h1 id="ee0c" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">获取设置</h1><h2 id="0537" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">开始之前</h2><p id="1f97" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">请确保您已经安装和/或准备好以下内容:</p><ol class=""><li id="0898" class="ke kf hu ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated"><a class="ae mj" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">仙丹</a></li><li id="0e62" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated"><a class="ae mj" href="https://hexdocs.pm/phoenix/installation.html" rel="noopener ugc nofollow" target="_blank">凤凰</a></li><li id="9b44" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated"><a class="ae mj" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a></li><li id="6522" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">有效的<a class="ae mj" href="http://www.sendgrid.com" rel="noopener ugc nofollow" target="_blank"> SendGrid </a>账户</li></ol><h2 id="1c9d" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">初始化项目</h2><p id="2e69" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">让我们创建一个新的Phoenix 1.3项目，名为<code class="eh mk ml mm mn b">pub_sub_demo</code></p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="be99" class="lq kt hu mn b fv mw mx l my mz">mix phx.new pub_sub_demo</span><span id="e45f" class="lq kt hu mn b fv na mx l my mz">cd pub_sub_demo</span><span id="e938" class="lq kt hu mn b fv na mx l my mz">mix ecto.create</span></pre><h2 id="c122" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">添加两个附加依赖项</h2><p id="9bcc" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">接下来，我们想添加<code class="eh mk ml mm mn b">HTTPoison</code>来帮助解码从数据库发送的字符串，添加<code class="eh mk ml mm mn b">Bamboo</code>来帮助我们发送电子邮件。</p><p id="7949" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要在您的<code class="eh mk ml mm mn b">mix.exs</code>文件中做到这一点，请将以下内容添加到您的<code class="eh mk ml mm mn b">deps</code>中:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="3ee8" class="lq kt hu mn b fv mw mx l my mz">{:httpoison, "~&gt; 1.0"},<br/>{:bamboo, "~&gt; 0.8"}</span></pre><p id="9dc7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此外，更新<code class="eh mk ml mm mn b">extra_applications</code>部分以包含<code class="eh mk ml mm mn b">:bamboo</code></p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="e5af" class="lq kt hu mn b fv mw mx l my mz">extra_applications: [:logger, :runtime_tools, :bamboo]</span></pre><h2 id="2cba" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">创建模型</h2><p id="b65a" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">最后，让我们创建<code class="eh mk ml mm mn b">User</code>模型，我们将使用它来展示所有这些广播的优点。</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="0227" class="lq kt hu mn b fv mw mx l my mz">mix phx.gen.context Accounts User users name:string payment_plan:string</span></pre><p id="7aa9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="nb">注:我们在一个名为</em> <code class="eh mk ml mm mn b"><em class="nb">Accounts</em></code> <em class="nb">的新上下文中创建了</em> <code class="eh mk ml mm mn b"><em class="nb">User</em></code> <em class="nb">。如果您不熟悉上下文，也没什么好怕的，这只是phoenix用来对功能进行分组的惯例。它们并不特别，只是一种将功能打包在一起的方式。</em></p><h2 id="07fe" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">踢它！</h2><p id="7e2a" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">迁移数据库，获取您的依赖项，然后放手吧！</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="2379" class="lq kt hu mn b fv mw mx l my mz">mix ecto.migrate<br/>mix deps.get<br/>mix phx.server</span></pre><p id="d7a0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="nb">注:您现在应该能够导航到</em> <code class="eh mk ml mm mn b"><em class="nb">localhost:4000</em></code> <em class="nb">并看到您的应用程序正在运行。尽管出于演示的目的，您不会真正看到任何屏幕。</em></p><h1 id="de06" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">Postgres的广播变化</h1><p id="5dc7" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">这样做的全部目的是让Postgres让<strong class="ji hv"> <em class="nb"> US </em> </strong>知道什么时候事情发生了变化。为此，我们需要设置两件事情:</p><ol class=""><li id="b6f2" class="ke kf hu ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">一个函数，它对一行执行一个动作(<code class="eh mk ml mm mn b">INSERT</code>、<code class="eh mk ml mm mn b">UPDATE</code>、<code class="eh mk ml mm mn b">DELETE</code>)，目的是在数据库之外传播该行。</li><li id="39fd" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">当特定表上发生操作时调用此函数的触发器。</li></ol><h2 id="c42c" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">创建外业迁移</h2><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="6e9b" class="lq kt hu mn b fv mw mx l my mz">mix ecto.gen.migration broadcast_users_table_changes</span></pre><h2 id="dab3" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">添加函数和触发器</h2><p id="ea64" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">更新您在上面创建的迁移文件，以包括以下内容</p><figure class="mo mp mq mr fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="896b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="nb">如果你想更好地理解这里正在发生的事情，看看@kaisersly的这篇博客文章，它很大程度上是你在这里阅读的灵感来源:</em></p><p id="5999" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae mj" rel="noopener" href="/@kaisersly/postgrex-notifications-759574f5796e"><em class="nb">https://medium . com/@ kaisersly/postgrex-notifications-759574 f 5796 e</em></a></p><h1 id="1824" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">倾听变化</h1><p id="d1a5" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">现在我们已经有了数据库广播发生在我们的<code class="eh mk ml mm mn b">users</code>表上的变化，我们需要能够在相同的通道上监听和操作。幸运的是，Postgrex默认使用<code class="eh mk ml mm mn b">Postgrex.Notifications</code>来提供这个功能。</p><p id="3c4d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要使用它，我们必须创建一个负责监听<code class="eh mk ml mm mn b">Postgrex</code>并根据消息广播采取行动的<code class="eh mk ml mm mn b">GenServer</code>。</p><h2 id="03dd" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">创建我们的GenServer</h2><p id="5851" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">创建文件<code class="eh mk ml mm mn b">lib/pub_sub_demo/pub_sub/listener.ex</code>并用以下内容填充它:</p><figure class="mo mp mq mr fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="02e6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">目前，它所做的只是监听所提供的通道，并记录广播到该通道的消息。</p><p id="a5d1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，让我们将它配置为一个Worker，并给它一个它将监听的通道。</p><h2 id="474e" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">吸引听众</h2><p id="a1d5" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">更新<code class="eh mk ml mm mn b">application.ex</code>文件，以便它启动我们刚刚用适当的<code class="eh mk ml mm mn b">users_changes</code>通道定义的<code class="eh mk ml mm mn b">Listener</code>。</p><figure class="mo mp mq mr fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure><h2 id="af5d" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">看看它的实际效果</h2><p id="8d8d" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">现在，您应该能够通过运行以下命令再次启动您的应用程序:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="4287" class="lq kt hu mn b fv mw mx l my mz">mix ecto.migrate<br/>mix phx.server</span></pre><p id="6d66" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后，您通过Postgres的CLI对<code class="eh mk ml mm mn b">users</code>表所做的任何更改都应该输出到我们的应用程序<code class="eh mk ml mm mn b">stdout</code>。</p><figure class="mo mp mq mr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/cbd28ee4d40922e1d33b02a2cff26e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuE5myTaF5e_gh2T65vJeQ.png"/></div></div></figure><h1 id="05d1" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">监听特定的动作</h1><p id="bb80" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">虽然能够看到数据库中发生的<strong class="ji hv"> <em class="nb">一切</em> </strong> <em class="nb"> </em>很好，但我们通常只关心这些变化的一小部分。特别针对本演示:</p><ol class=""><li id="93b5" class="ke kf hu ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">用户创建的</li><li id="95b1" class="ke kf hu ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">用户订阅已更新</li></ol><p id="df12" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">幸运的是，Elixir的模式匹配提供了一种非常简单的方法来减少所有的干扰，并准确地专注于您正在寻找的数据的形状。</p><p id="1906" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们想要做的是更新<code class="eh mk ml mm mn b">handle_info</code>以将有效载荷发送给一个函数，该函数将匹配重要的事件。</p><figure class="mo mp mq mr fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="ec0e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面只对我们正在寻找的确切事件起作用，并向我们的日志输出特定的消息。其他的都忽略。</p><figure class="mo mp mq mr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/c3e315859b4cea8d61153420945b1036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSwHywCLas44jWTHldvx9g.png"/></div></div></figure><h1 id="f24e" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">把它链接到电子邮件服务</h1><p id="6a9a" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">标准输出很好，但是在一个正在运行的应用程序中，您不希望为您的业务所关心的事件梳理日志，您希望得到实时通知。</p><p id="3f80" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们把信息链接到电子邮件提供商，这样当用户注册或升级他们的计划时，我们就能在收件箱里收到通知。</p><p id="408f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mk ml mm mn b">Bamboo</code>药剂库和<code class="eh mk ml mm mn b">Send Grid</code>服务让这变得太容易了。</p><h2 id="7f11" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">设置竹子</h2><p id="400a" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">将以下内容添加到您的<code class="eh mk ml mm mn b">config.exs</code>文件中</p><figure class="mo mp mq mr fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure><p id="896d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="nb">注意:如果您有不同的偏好，Bamboo提供了比Send Grid更多的适配器。</em><a class="ae mj" href="https://github.com/thoughtbot/bamboo#adapters" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://github.com/thoughtbot/bamboo#adapters</em></a></p><p id="8e5b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在你的<code class="eh mk ml mm mn b">pub_sub_demo</code>文件夹中创建一个<code class="eh mk ml mm mn b">mailer.ex</code>文件</p><figure class="mo mp mq mr fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure><h2 id="2943" class="lq kt hu bd ku lr ls lt ky lu lv lw lc jr lx ly lg jv lz ma lk jz mb mc lo md dt translated">从我们的听众发送电子邮件</h2><p id="bc4c" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">更新<code class="eh mk ml mm mn b">listener.ex</code>中的<code class="eh mk ml mm mn b">handle_user_changes</code>，将我们的日志消息发送到我们自己的电子邮件地址。</p><figure class="mo mp mq mr fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure><h1 id="8445" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">最后一次运行它</h1><p id="180b" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">现在，如果您在<code class="eh mk ml mm mn b">users</code>表中创建和更新了一个用户，您应该会看到电子邮件出现在您的SendGrid日志中。</p><figure class="mo mp mq mr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/77b17d2ae06a501c69b6ff319cee6e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MxCC7SnylUcNa5xudoAZQ.png"/></div></div></figure><p id="be92" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就是这样！</p><h1 id="ad2a" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">结论</h1><p id="c5f5" class="pw-post-body-paragraph jg jh hu ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">直接从数据库广播事件的概念并不新鲜，因此这种类型的功能在任何语言和框架中都可用。</p><p id="b163" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是！Elixir和Phoenix的核心特性和功能使得使用数据库事件比我在任何其他系统中发现的更容易和更合理。模式匹配和OTP原则既简单又强大，我鼓励任何人在可能的情况下深入研究它们。</p><figure class="mo mp mq mr fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/736d77e4c20180837205beff3eb5be33.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/1*pR5Ao54twSvMu2bPwdR_vQ.gif"/></div></figure><blockquote class="ni"><p id="f4a2" class="nj nk hu bd nl nm nn no np nq nr kd ek translated">🧞‍这是开源的！你可以在Github上找到它</p><p id="05ec" class="nj nk hu bd nl nm ns nt nu nv nw kd ek translated">❤️:我只写编程和远程工作。如果你在推特上关注我，我不会浪费你的时间。</p></blockquote></div></div>    
</body>
</html>