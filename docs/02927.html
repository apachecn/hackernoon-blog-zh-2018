<html>
<head>
<title>Your First Steps in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的第一步</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/your-first-steps-in-react-dce29b400bde?source=collection_archive---------31-----------------------#2018-04-02">https://medium.com/hackernoon/your-first-steps-in-react-dce29b400bde?source=collection_archive---------31-----------------------#2018-04-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="952b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> ReactJS </strong> </a>是一个用于构建ui的JavaScript库。尽管没有严格的定义，React的思想是遵循基于组件的思想。它的声明性视图使得<strong class="it hv">代码更加可预测</strong>并且<strong class="it hv">更容易调试</strong>。</p><p id="91ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我所在的Kolosek团队使用ReactJS结合<a class="ae jp" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Webpack </strong> </a>作为捆绑包管理器，使用<a class="ae jp" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Redux </strong> </a>结合<a class="ae jp" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">不可变JS </strong> </a>进行应用状态管理，使用其他一些让开发人员生活更轻松的库，如<a class="ae jp" href="https://gulpjs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/></a>处理构建和部署(以及其他一些)任务。</p><p id="2713" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既可以作为简单的静态网页使用，也可以在服务器端渲染，例如<a class="ae jp" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">节点JS </strong> </a>。在服务器上呈现的React应用通常被称为<a class="ae jp" href="https://scotch.io/tutorials/react-on-the-server-for-beginners-build-a-universal-react-and-node-app" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">通用应用</strong> </a>，但有时也被称为同构。</p><p id="b962" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，重点只放在React上，因为Redux和不可变JS将被分别记录。</p><h1 id="1c9f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">和JSX反应过来</h1><p id="72b2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在React中，您会广泛地看到如下代码部分:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="83fa" class="lc jr hu ky b fv ld le l lf lg">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span></pre><p id="fad4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这既不是JavaScript字符串，也不是HTML，但它被称为<strong class="it hv"> JSX </strong>，JavaScript的一种语法扩展。它在React的render方法中被广泛使用，用来呈现网页的动态部分。JSX产生React“元素”，例如，当<a class="ae jp" href="https://kolosek.com/react-jsx-conditions/" rel="noopener ugc nofollow" target="_blank">基于条件</a>渲染某些东西时，它被广泛使用。</p><p id="2df4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要使用JSX内部渲染方法，需要将其包裹在<strong class="it hv"> {} </strong>内部:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="48e4" class="lc jr hu ky b fv ld le l lf lg">&lt;img src={user.avatarUrl}&gt;&lt;/img&gt;</span></pre><p id="7b9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用JSX是安全的，因为它可以防止注入攻击，所以不用担心会有代码注入。</p><p id="4636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开发时，您肯定还想呈现一个项目列表，或者在某个点上遍历某个对象。这也是使用JSX完成的，和条件一样，我有<a class="ae jp" href="https://kolosek.com/react-jsx-loops/" rel="noopener ugc nofollow" target="_blank">一篇单独的文章，只关注列表的渲染</a>。<br/>永远记住使用列表键！</p><p id="7dcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">键</strong>帮助React识别哪些项目被改变、添加或删除。键必须是唯一的，并且不应该为了列表中React元素的正确呈现而改变。</p><h1 id="b361" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">基于组件的组织和道具</h1><p id="b81d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">React推荐<strong class="it hv">基于组件的代码组织</strong>。代码的所有逻辑上可分离的部分，如输入字段、按钮、表单、列表等。应该在单独的组件中编写。</p><p id="643b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码的所有简单部分都应该写成<strong class="it hv">虚拟</strong>组件(通常也被称为<strong class="it hv">纯</strong>)，这意味着它们只会根据传递给它们的参数进行渲染，而不会对任何应用程序逻辑有任何想法。</p><p id="3034" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是虚拟组件的两个示例:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="0c72" class="lc jr hu ky b fv ld le l lf lg">   function Button({ onClick, text }) {<br/>       return (<br/>           &lt;button<br/>               onClick={onClick}<br/>           &gt;<br/>               {text}<br/>           &lt;/button&gt;<br/>       );<br/>    }</span></pre><p id="24ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用{…objectName}语法将整个对象作为<a class="ae jp" href="https://kolosek.com/react-props-basic/" rel="noopener ugc nofollow" target="_blank"> props </a>传递；这将把objectName中的每个键值作为单独的属性传递。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8ffa" class="lc jr hu ky b fv ld le l lf lg">   function InputField(props) {<br/>       // props is an object containing keys like onChange, placeholder, etc...<br/>       //<br/>       return (<br/>           &lt;input<br/>               {...props}<br/>           /&gt;<br/>       );<br/>     }</span></pre><p id="cd67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想只提取一些道具，你可以这样做:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="140a" class="lc jr hu ky b fv ld le l lf lg">    function InputField(props) {<br/>        const {<br/>            onChange,<br/>            placeholder,<br/>            value,<br/>        } = props;<br/>        return (<br/>            &lt;input<br/>                onChange={onChange}<br/>                placeholder={placeholder}<br/>                value={value}<br/>            /&gt;<br/>        );<br/>      }</span></pre><p id="6b0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">现在，如何使用这些虚拟组件？</strong>基本上，你可以通过将它们导入文件(使用文件的相对路径)然后在render方法中调用它们来使用它们。这里有一个例子:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2268" class="lc jr hu ky b fv ld le l lf lg">    import React, { Component } from 'react';<br/>    import InputField from '../components/InputField.js';<br/>    import Button from '../components/Button.js';<br/>    class Login extends Component {<br/>         ...<br/>         render() {<br/>             return (<br/>                 &lt;InputField<br/>                     onChange={this.handleChange('email')}<br/>                     placeholder={"Email"}<br/>                     type="text"<br/>                     value={this.state.email}<br/>                 /&gt;<br/>                 &lt;InputField<br/>                     onChange={this.handleChange('password')}<br/>                     placeholder={"Password"}<br/>                     type="password"<br/>                     value={this.state.password}<br/>                 /&gt;<br/>                 &lt;Button<br/>                     onClick={this.login}<br/>                 &gt;<br/>                     {'Login'}<br/>                 &lt;/Button&gt;<br/>               );<br/>           }<br/>           ...<br/>      }</span></pre><p id="4fa6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你注意到了吗，我写这个组件的方式和以前的不同。那是因为它不是一个虚拟的，而是包含了更多的逻辑。以这种方式编写的组件被称为智能组件或<strong class="it hv">类</strong>，除了render方法之外，还可以绑定其他方法。点击可了解更多关于虚拟和智能组件的信息<a class="ae jp" href="https://jaketrent.com/post/smart-dumb-components-react/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cc15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，<strong class="it hv">的道具</strong>到底是什么？</p><p id="e928" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以把一个组件想象成一个功能(还记得那些虚拟的例子吗？他们甚至使用标准的函数定义！).基本上，props是调用时传递给该函数的<strong class="it hv">参数。任何东西都可以是道具:字符串、布尔值、数字、一些其他的React元素、未定义的…</strong></p><p id="995b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于道具，要记住的最重要的事情是它们是<strong class="it hv">只读的</strong>，这意味着它们不能在接收它们的组件中被改变，也不应该被变异。你可以在我们关于如何在React 中正确使用道具的系列文章<a class="ae jp" href="https://kolosek.com/react-props-basic/" rel="noopener ugc nofollow" target="_blank">中阅读更多关于如何传递道具的内容。</a></p><h1 id="c2d1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">反应状态</h1><p id="4c5c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在前一章中，你已经知道了props是传递给组件的参数。另一方面，<strong class="it hv">状态</strong>是私有的，它的主要目的是在组件内操纵它。状态只对类可用<em class="lh"/>,用于处理一些内部变化(比如更新一些基于onChange事件存储的文本):</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="9357" class="lc jr hu ky b fv ld le l lf lg">    import React, { Component } from 'react';<br/>    import InputField from '../components/InputField.js';<br/>    ...<br/>    class Login extends Component {<br/>        // We define initial component state in constructor function<br/>        constructor() {<br/>            super();<br/>            this.state = {<br/>                email: '',<br/>            }<br/>        }<br/>        // Handling state change is done by using this.setState function<br/>        handleChange = (event) =&gt; {<br/>             this.setState(() =&gt; {<br/>                 return {<br/>                     email: event.target.value,<br/>                 };<br/>             });<br/>        }</span><span id="28f9" class="lc jr hu ky b fv li le l lf lg"><br/>        ...<br/>        render() {<br/>            return (<br/>                &lt;InputField<br/>                    onChange={this.handleChange}<br/>                    placeholder={"Email"}<br/>                    type="text"<br/>                    value={this.state.email}<br/>                /&gt;<br/>                {<br/>                    ...<br/>                }<br/>              );<br/>         }<br/>         ...<br/>    }</span></pre><p id="3771" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">状态在<strong class="it hv">构造函数</strong>中初始化，这是一个在初始组件渲染之前调用的特殊方法。所有的自定义方法(比如上一个例子中的handleChange)都应该使用arrow函数编写，这样它们就会自动绑定到一个组件。</p><p id="8bb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能会注意到其他一些人像这样使用this.setState:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="e1af" class="lc jr hu ky b fv ld le l lf lg">    this.setState({<br/>        email: event.target.value,<br/>    });</span></pre><p id="647e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是更新状态的好方法！状态是异步更新的，如果需要在一行中多次更新状态，它会以这种方式批量处理所有的设置状态。使用<a class="ae jp" href="https://medium.freecodecamp.org/functional-setstate-is-the-future-of-react-374f30401b6b" rel="noopener ugc nofollow" target="_blank">功能方式更新状态</a>，如其他示例所述。</p><p id="0a54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们看另一个例子:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="6082" class="lc jr hu ky b fv ld le l lf lg">    import React, { Component } from 'react';<br/>    import InputField from '../components/InputField.js';<br/>    ...<br/>    class Login extends Component {<br/>        constructor() {<br/>            super();<br/>            this.state = {<br/>                email: '',<br/>                password: '',<br/>            }<br/>         }</span><span id="8b39" class="lc jr hu ky b fv li le l lf lg">         handleChange = (type) =&gt; (event) =&gt; {<br/>             this.setState(() =&gt; {<br/>                 const stateUpdates = {};<br/>                 stateUpdates[type] = event.target.value;<br/>                 return stateUpdates;<br/>              });<br/>         }</span><span id="b0de" class="lc jr hu ky b fv li le l lf lg">         ...<br/>         render() {<br/>             return (<br/>                 &lt;InputField<br/>                     onChange={this.handleChange("email")}<br/>                     placeholder={"Email"} type="text"<br/>                     value={this.state.email}<br/>                 /&gt;<br/>                 &lt;InputField<br/>                     onChange={this.handleChange("password")}<br/>                     placeholder={"Password"}<br/>                     type="password"<br/>                     value={this.state.password}<br/>                 /&gt;<br/>                 {<br/>                      ...<br/>                 }<br/>               );<br/>          }<br/>          ...<br/>    }</span></pre><p id="c78a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在定义自定义方法时有一条规则:<strong class="it hv">永远不要在呈现方法</strong>中绑定它。上面的例子展示了一种正确的方法。如果该方法绑定在render方法中，则每次重新呈现组件时都会创建新函数。我已经在<a class="ae jp" href="https://kolosek.com/react-props-basic/" rel="noopener ugc nofollow" target="_blank">一篇关于道具功能的文章</a>中提到了这一点。</p><h1 id="fb92" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">组件生命周期</h1><p id="b21c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">处理组件生命周期的方法继承自component(是的，您在文件顶部导入的组件)。生命周期方法的最详细描述可以在<a class="ae jp" href="http://busypeoples.github.io/post/react-component-lifecycle/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="9deb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要记住的一件重要的事情是，在通用应用程序(服务器上呈现的应用程序)的情况下，浏览器相关的全局变量如窗口、本地存储等。仅可在组件安装后使用(即仅在<strong class="it hv">componentid mount</strong>中可用)。</p><h1 id="51bd" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">样式反应组件</h1><p id="dbc2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">虽然React本身不支持直接使用CSS进行样式化，但更面向内联JSXstyles(将样式对象prop传递给HTML标记)，这种方法并不常用。</p><p id="52a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在你将会看到的许多(如果不是全部)真实项目中，已经设置了一些<a class="ae jp" href="https://github.com/webpack-contrib/css-loader" rel="noopener ugc nofollow" target="_blank"> CSS/SCSS加载器</a>，所以你可以轻松地使用像<a class="ae jp" href="https://kolosek.com/css-columns/" rel="noopener ugc nofollow" target="_blank"> CSS列</a>这样的样式。这是通过Webpack配置的。</p><h1 id="ba9b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">React中的路由</h1><p id="342f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于路由，使用<a class="ae jp" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank">T5】React路由器v4T7】。它的文档非常简单明了，也非常简短，所以是必读的。基本上，我们使用路由器和路由来定义路由，使用链接组件来链接页面，使用重定向组件来重定向到某个动作上某个其他页面。</a></p><h1 id="71e2" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">实践想法</h1><ul class=""><li id="f341" class="lj lk hu it b iu ko iy kp jc ll jg lm jk ln jo lo lp lq lr dt translated">使用<a class="ae jp" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">创建React应用</strong> </a>启动一个新的React应用。</li><li id="b748" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">尝试创建几个非常简单的组件:带标签的输入标签包装器，一个灰色的按钮，禁用后文本会改变，一个头像。</li><li id="8f45" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">尝试创建一个稍微复杂一点的组件:一个包含电子邮件、密码、名字和姓氏字段以及一个按钮的表单(重用您在上一步中编写的虚拟组件！).</li><li id="dc04" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">验证表单:在启用按钮之前，应该填写电子邮件、密码、名字和姓氏字段。电子邮件也应该是有效的格式。</li><li id="86e5" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">一旦表单有效并按下登录按钮，弹出一个用户填写值的警告。</li><li id="ac07" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">恭喜你！您已经编写了您的第一个React组件！</li></ul><p id="94be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lh">原载于2018年4月2日kolosek.com</em><a class="ae jp" href="https://kolosek.com/react-first-steps/" rel="noopener ugc nofollow" target="_blank"><em class="lh"/></a><em class="lh">。</em></p></div></div>    
</body>
</html>