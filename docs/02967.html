<html>
<head>
<title>How to Improve Your C++ Skills From Awesome Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从令人敬畏的项目中提高你的C++技能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-improve-your-c-skills-from-awesome-projects-251b300ed5a1?source=collection_archive---------3-----------------------#2018-04-04">https://medium.com/hackernoon/how-to-improve-your-c-skills-from-awesome-projects-251b300ed5a1?source=collection_archive---------3-----------------------#2018-04-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="1753" class="hs ht hu bd b gc hv hw hx hy hz ia ek ib translated" aria-label="kicker paragraph">虚幻引擎案例研究</h2><div class=""/><p id="eb68" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><a class="ae jy" href="https://www.unrealengine.com/" rel="noopener ugc nofollow" target="_blank">虚幻引擎</a>是由<a class="ae jy" href="http://en.wikipedia.org/wiki/Epic_Games" rel="noopener ugc nofollow" target="_blank">史诗游戏</a>开发的游戏引擎，首次展示于1998年的第一人称射击游戏<em class="jz">虚幻</em>。虽然主要是为第一人称射击游戏开发的，但它已经成功地用于各种其他类型，包括潜行、MMORPGs和其他RPG。</p><p id="587a" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">它的代码是用C++写的，现在被许多游戏开发者使用。它的源代码可以从GitHub获得，对学生是免费的。许多令人惊叹的游戏都是用这个引擎开发的，它允许生成像这样非常逼真的渲染。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="fe ff ka"><img src="../Images/62bfae54f291e322224938f1a96accc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pGEaaidE0OJlndSg.jpg"/></div></div></figure><p id="df6f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">产生这种逼真渲染的幕后执行的源代码是什么？</p><p id="4f81" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">走进这个强大的游戏引擎，发现它是如何设计和实现的，这非常有趣。C++开发人员可以从它的代码库中学到许多最佳实践。</p><p id="674e" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们使用<a class="ae jy" href="http://www.cppdepend.com/" rel="noopener ugc nofollow" target="_blank"> CppDepend </a>和<a class="ae jy" href="http://cppdepend.com/cqlinq" rel="noopener ugc nofollow" target="_blank"> CQLinq </a>来探索它的源代码，以检测它的开发团队的一些设计和实现选择。</p><h1 id="1cb0" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">1-名称空间</h1><p id="7318" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">虚幻引擎广泛使用名称空间有三个主要原因:</p><ul class=""><li id="5c82" class="lp lq hu jc b jd je jh ji jl lr jp ls jt lt jx lu lv lw lx dt translated">许多名称空间只包含枚举，如下面的CQLinq查询所示，它给出了只包含枚举的名称空间。</li></ul><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/60b28b59598732d0c0c10a0d4de03060.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*KuAijmBS_OXPumq8.png"/></div></figure><p id="d349" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在一个大型项目中，你不能保证两个不同的枚举不会都用相同的名字调用。这个问题在C++11中通过使用<strong class="jc ie">枚举类</strong>得到了解决，该枚举类隐式地将枚举值限定在枚举名称的范围内。</p><ul class=""><li id="139a" class="lp lq hu jc b jd je jh ji jl lr jp ls jt lt jx lu lv lw lx dt translated">匿名命名空间:没有名字的命名空间避免了产生全局静态变量。您创建的“匿名”命名空间只能在您创建它的文件中访问。以下是使用的所有匿名名称空间的列表:</li></ul><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/2b08c36721ccf429a518ecaeb279331c.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/0*znUjdDx5kCgiDp_l.png"/></div></figure><ul class=""><li id="6267" class="lp lq hu jc b jd je jh ji jl lr jp ls jt lt jx lu lv lw lx dt translated">模块化代码库:让我们搜索所有其他名称空间，即既不是匿名的也不是只包含枚举的名称空间:</li></ul><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/900c18d46f7103449aa46735b3ad0727.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/0*IrJOoAI546Tln14J.png"/></div></figure><p id="aa46" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">名称空间是模块化应用程序的一个好的解决方案；Unreal Engine定义了250多个名称空间来加强其模块化，这使得代码更具可读性和可维护性。</p><h1 id="2919" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">使用的2-范式:</h1><p id="0927" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">C++不仅仅是面向对象的语言。正如比雅尼·斯特劳斯特鲁普指出的，“C++是一种多范式语言。”它支持许多不同风格的程序或范例，面向对象编程只是其中之一。其他一些是过程编程和泛型编程。</p><p id="1731" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><strong class="jc ie">2–1程序范例</strong></p><p id="7c71" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">2–1–1全局函数</em></p><p id="577b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们搜索虚幻引擎源代码中定义的所有全局函数:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/d55b05e665034f35d1f2a750f22cf9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/0*euwmOi7moqZqb8Gd.png"/></div></figure><p id="befd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们可以将这些功能分为三类:</p><p id="a133" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">1-效用函数:例如，其中6344个函数涉及Z _ Construct _ UXXX函数，用于创建引擎所需的实例。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/58f3547bce1388d3f4a1e10692ae46e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*2n_yol0KaekUDtSh.png"/></div></figure><p id="517c" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">2 —操作符:许多操作符都是由CQLinq查询的结果定义的，如下所示:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/63a07da0d3311b399a4a8b60d9124909.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/0*IGxhEiVr9pTiVARW.png"/></div></figure><p id="06ce" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">虚幻引擎源代码中几乎实现了各种运算符。</p><p id="6efd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">3 —与引擎逻辑相关的函数:实现了许多包含一些引擎处理的全局函数。也许这些类型的函数可以按类别分组，比如将静态方法分组到类中，或者分组到名称空间中。</p><p id="d0ad" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">2–1–2静态全局函数:</em></p><p id="ee5b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">最佳实践是将全局函数声明为静态的，除非您特别需要从另一个源文件调用它。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff md"><img src="../Images/c2c65cadf05994bd0e0a1aa42563b043.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/0*Zu_ak5DosYMGlBaN.png"/></div></figure><p id="3f96" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">许多全局函数被声明为静态的，并且如前所述，其他全局函数被定义在匿名名称空间中</p><p id="5528" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">2–1–3个候选静态全局函数。</p><p id="9862" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">全局未导出函数，未在匿名命名空间中定义，也未被定义它们的文件之外的任何方法使用。这些都是可以重构为静态的很好的候选者。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff me"><img src="../Images/a6b662ff48db01570dbbf103764ca7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*pxffMtllBLERdzuC.png"/></div></figure><p id="f128" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">正如我们所观察到的，一些全局函数可以被重构为静态函数。</p><p id="47e8" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><strong class="jc ie">2–2面向对象范例</strong></p><p id="2505" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">2–2–1继承</em></p><p id="dd46" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在面向对象编程(OOP)中，继承是建立对象间关系的一种方式。它经常被混淆为重用现有代码的方法，这不是一个好的实践，因为实现重用的继承导致了紧密耦合。代码的可重用性是通过组合实现的(组合胜于继承)。让我们搜索至少有一个基类的所有类:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/bd789a63e726f7eadaa4b3513254d6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*Kx2A81o6txNTD3AA.png"/></div></figure><p id="7d3f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">为了更好地了解这个查询所涉及的类，我们可以使用Metric视图。</p><p id="6629" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在Metric视图中，代码库通过树形图表示。Treemapping是一种通过使用嵌套矩形来显示树结构数据的方法。CppDepend treemap中使用的树结构是通常的代码层次结构:</p><ul class=""><li id="1087" class="lp lq hu jc b jd je jh ji jl lr jp ls jt lt jx lu lv lw lx dt translated">项目包含命名空间。</li><li id="b98e" class="lp lq hu jc b jd mg jh mh jl mi jp mj jt mk jx lu lv lw lx dt translated">命名空间包含类型。</li><li id="44ad" class="lp lq hu jc b jd mg jh mh jl mi jp mj jt mk jx lu lv lw lx dt translated">类型包含方法和字段。</li></ul><p id="e7a0" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">treemap视图提供了一种表示CQLinq请求结果的有用方法；蓝色的矩形代表这个结果，所以我们可以直观地看到请求所涉及的类型。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="fe ff ml"><img src="../Images/7c8f86c42c63c170e307643afae76b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nquRH6Uk0Zzox_Q3.png"/></div></div></figure><p id="4814" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">正如我们所观察到的，继承在虚幻引擎源代码中被广泛使用。</p><p id="8c91" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">多重继承:让我们搜索从多个具体类继承的类。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/83a895485861bcdc3c09b8ba60e56239.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*JS3Qws9_tN-6xI1L.png"/></div></figure><p id="997d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">多重继承并没有被广泛使用，只有少数类从一个以上的类继承。</p><p id="6893" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">2–2–2个虚拟方法</em></p><p id="28d7" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们搜索虚幻引擎源代码中定义的所有虚拟方法:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/ce69cdc99de657be99f91af90ee217a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/0*3AC3BZy4ld0MpPaI.png"/></div></figure><p id="96ef" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">许多方法是虚拟的，其中一些是纯虚拟的:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/cbdbb15c6dc123347a34c287573e96e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/0*5h-8dkbNxXaBPXdH.png"/></div></figure><p id="c7f8" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">作为过程化范式，OOP范式也广泛应用于虚幻引擎源代码中。泛型编程范式呢？</p><p id="cf7f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><strong class="jc ie">2–3通用编程</strong></p><p id="23f4" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">C++提供了通过模板表达泛型编程思想的独特能力。模板提供了一种形式的参数多态性，允许表达通用算法和数据结构。C++模板的实例化机制确保当使用通用算法或数据结构时，将创建完全优化的专用版本，并针对特定用途进行定制，从而允许通用算法与其非通用对应算法一样高效。</p><p id="bd88" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">2–3–1通用类型:</em></p><p id="aaa9" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们搜索引擎源代码中定义的所有泛型类型:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/7e2e98ee8d54a2af8df8bd04fd69bf1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/0*hRhSf-vRssffG1e4.png"/></div></figure><p id="a264" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">只有少数类型被定义为泛型。让我们搜索通用方法:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/f22c16f9aaade5a27956c47bad80652e.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*XRmbZPxsC0oJKWBL.png"/></div></figure><p id="973f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">超过40000个方法是通用的；它们代表了所实现的方法的25%以上。</p><p id="ab7c" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">要恢复虚幻引擎源代码，请混合使用这三种范例。</p><h1 id="d7bc" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">定义数据模型的3-pod</h1><p id="e605" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">在面向对象编程中，普通旧数据(POD)是一种数据结构，只表示为字段值(实例变量)的被动集合，不使用面向对象的功能。在计算机科学中，这被称为被动数据结构</p><p id="245b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们在虚幻引擎源代码中搜索POD类型</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/cfeffe9f71f3c5ab51a116a56e6dd5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*rCcC6iSKwLxbxw6U.png"/></div></figure><p id="6fe6" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">超过2000种类型被定义为POD类型，其中许多用于定义引擎数据模型。</p><h1 id="4726" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">四人组设计模式</h1><p id="f1f3" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">设计模式是一个软件工程概念，描述软件设计中常见问题的重复解决方案。四人帮模式是最受欢迎的。让我们来发现虚幻引擎源代码中使用的一些。</p><p id="40e7" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">4–1单胞胎</em></p><p id="6206" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">单例是最受欢迎和使用最多的一种。下面是源代码中定义的一些单例类:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/407e762699a5380761a76efad354ed09.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*A4ZpsuhdTB6VzVeu.png"/></div></figure><p id="5270" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">TThreadSingleton是Singleton的特殊版本。这意味着每个线程只创建一个实例。调用它的方法Get()是线程安全的。</p><p id="c258" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">4–2个工厂</p><p id="42c1" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">使用工厂来隔离逻辑实例化和增强内聚性是很有趣的；下面是源代码中定义的工厂列表:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/8af83ad85a2e160c037fc2bba399dbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*K6xUhuiqsSwdFrvD.png"/></div></figure><p id="1b6d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这是一些抽象的例子:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/7154d82e6a74a49f3b1947171bdc9b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/0*DlnjNxQoRgrE8Nxg.png"/></div></figure><p id="d0a2" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">4–3名观察员</em></p><p id="9b85" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">观察者模式是一种软件设计模式，在这种模式中，一个对象维护一个称为观察者的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。</p><p id="0b36" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">它们是一些在其源代码中实现的观察者，FAIMessageObserver就是其中之一。</p><p id="7e7d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">下面是一个依赖关系图，显示了这个观察器的OnMessage方法的调用:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/13c85d12b501534751b32c6c096e278d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*o5eKyw2gxtLsN2c4.png"/></div></figure><p id="0994" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">4–4命令</em></p><p id="e9f4" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">命令模式是一种行为设计模式，其中使用一个对象来表示和封装稍后调用方法所需的所有信息。</p><p id="6c14" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">与命令模式相关的四个术语是命令、接收者、调用者和客户。command对象有一个receiver对象，并以特定于该receiver类的方式调用receiver的方法。</p><p id="a4e0" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">以下是从IAutomationLatentCommand继承的所有命令:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/fde63f7298778bc865bb4d127fe30458.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*_24rwD5OhDNaWIi3.png"/></div></figure><h1 id="23a4" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">5-耦合和内聚</h1><p id="2fc8" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">5–1联轴器</p><p id="8ae3" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">低耦合是可取的，因为应用程序的一个方面的变化在整个应用程序中需要较少的变化。从长远来看，这可以减少与修改应用程序和向应用程序添加新功能相关的大量时间、精力和成本。</p><p id="28ed" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">低耦合可以通过使用抽象类或使用泛型类型和方法来实现。</p><p id="644f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们搜索虚幻引擎源代码中定义的所有抽象类:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/e4c5032d117467236be8a3cc6c16ab73.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/0*jvLcQx-XVskS431x.png"/></div></figure><p id="84f5" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">只有少数类型被声明为抽象类型。通过使用泛型类型和泛型方法，可以更好地实现低耦合。</p><p id="924d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">以下是至少使用一种泛型方法的方法:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/095b4c5ecac2191af06e88ff267943df.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/0*ygJU6BfFpMKdHcPN.png"/></div></figure><p id="d4be" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">正如我们可以观察到的，许多方法都使用泛型方法，低耦合性是通过函数模板参数实现的。事实上，这些参数的真实类型可以在不改变被调用方法的源代码的情况下改变。</p><p id="6bf8" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><strong class="jc ie">凝聚力</strong></p><p id="4b03" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">单一责任原则规定一个类不应该有一个以上的改变理由。这样的类被称为内聚类。高LCOM值通常指出一个内聚性差的类。有几个LCOM指标。LCOM的取值范围为[0–1]。LCOM房协(房协代表恒基兆业卖方)的取值范围为[0–2]。高于1的LCOM HS值应被视为警报。以下是计算LCOM指标的方法:</p><blockquote class="mw mx my"><p id="4817" class="ja jb jz jc b jd je jf jg jh ji jj jk mz jm jn jo na jq jr js nb ju jv jw jx hn dt translated">LCOM = 1 —(总和(MF)/M*F) <br/> LCOM HS = (M —总和(MF)/F)(M-1)</p></blockquote><p id="d25a" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">其中:</p><ul class=""><li id="62cc" class="lp lq hu jc b jd je jh ji jl lr jp ls jt lt jx lu lv lw lx dt translated">m是一个类中方法的数量(静态和实例方法都计算在内，它还包括构造函数、属性getter/setter、事件add/remove方法)。</li><li id="5abd" class="lp lq hu jc b jd mg jh mh jl mi jp mj jt mk jx lu lv lw lx dt translated">f是类中实例字段的数量。</li><li id="de7b" class="lp lq hu jc b jd mg jh mh jl mi jp mj jt mk jx lu lv lw lx dt translated">MF是访问特定实例字段的类的方法的数量。</li><li id="393d" class="lp lq hu jc b jd mg jh mh jl mi jp mj jt mk jx lu lv lw lx dt translated">Sum(MF)是该类的MF总体实例字段的总和。</li></ul><p id="0e91" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这些公式背后基本思想可以陈述如下:如果一个类的所有方法都使用它的所有实例字段，则该类是完全内聚的，这意味着sum(MF)=M*F，然后LCOM = 0，LCOMHS = 0。</p><p id="2480" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">LCOMHS值高于1应视为报警。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/953e803db4c2f88f292d5cef48792f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/0*Mtc34ZZA8GTQ8JJY.png"/></div></figure><p id="e426" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">只有一些类型被认为是不内聚的。</p><h1 id="b34d" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">6-不变性、纯度和副作用</h1><p id="ab08" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated"><em class="jz">6–1不可变类型</em></p><p id="aa54" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">基本上，一旦对象被创建，如果它的状态没有改变，那么它就是不可变的。因此，如果一个类的实例是不可变的，那么这个类就是不可变的。</p><p id="d724" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">支持使用不可变对象的一个重要理由是:它极大地简化了并发编程。想一想，为什么编写合适的多线程编程是一项艰巨的任务？因为很难同步线程对资源(对象或其他OS资源)的访问。为什么很难同步这些访问？因为很难保证多线程对多个对象进行的多次写访问和读访问之间不会出现争用情况。如果没有更多的写访问呢？换句话说，如果线程访问的对象的状态不变，那会怎样？再也不需要同步了！</p><p id="b831" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">不可变类的另一个好处是它们永远不会违反LSP(lis kov subtution原则)，下面是从其wiki页面引用的LSP的定义:</p><blockquote class="mw mx my"><p id="4f67" class="ja jb jz jc b jd je jf jg jh ji jj jk mz jm jn jo na jq jr js nb ju jv jw jx hn dt translated">Liskov的行为子类型的概念定义了可变对象的可替代性的概念；也就是说，如果S是T的子类型，那么程序中T类型的对象可以用S类型的对象替换，而不改变该程序的任何期望的属性(例如，正确性)。</p></blockquote><p id="9a59" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">下面是源代码中定义的不可变类型列表:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="fe ff nd"><img src="../Images/183c4d6019698997510ff14d98b88a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/0*-QIsPTLWpgL6E1Di.png"/></div></div></figure><p id="6705" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">6–2纯度和副作用</p><p id="1d3c" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">不可变类型的主要好处来自于它们消除了副作用。我说不出比韦斯·戴尔更好的话了，所以我引用他的话:</p><p id="2f6f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">我们都知道通常使用全局变量不是一个好主意。这基本上是暴露副作用的极端情况(全局范围)。许多不使用全局变量的程序员没有意识到同样的原则在更有限的范围内也适用于字段、属性、参数和变量:除非有充分的理由，否则不要改变它们。(…) </em></p><p id="dce5" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="jz">提高设备可靠性的一个方法是消除副作用。这使得将单元组合和集成在一起变得更加容易和健壮。因为它们没有副作用，所以不管在什么环境下，它们都是一样的。这被称为参照透明。</em></p><p id="4e17" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">编写没有副作用的函数/方法——所以它们是纯函数，也就是说，不改变对象——更容易推断程序的正确性。</p><p id="83eb" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这里列出了所有没有副作用的方法</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/576a7d74e8b100f23aa5b860131c3e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/0*OP0zxSsyahS_oMGt.png"/></div></figure><p id="edcd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">超过125 000种方法是纯的。</p><h1 id="c407" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">7-实施质量</h1><p id="9123" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">7–1太大的方法</p><p id="e005" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">太大的方法不容易维护和理解。让我们搜索超过60行的方法。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/34a652bcfcd0417a829ba56ad32ad6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/0*9bgnNtNG3Jv1JbeL.png"/></div></figure><p id="28ba" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">虚幻引擎源代码包含超过150，0 00个方法，所以不到1%就可以认为太大了。</p><p id="5503" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">7–2种带有许多参数的方法</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/37075d55b8a4e1e7254e0742baf50bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/0*LPXCqVi5cTZzXd0z.png"/></div></figure><p id="22c1" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">很少有方法有8个以上的参数，大多数都是泛型的，以避免定义变量函数，就像TCStringt::Snprintf方法一样。</p><p id="793b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">7–3种具有许多局部变量的方法</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/a8915828f000cf3a7ab606e316c2bed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/0*lZtE0MdCSVE1edPn.png"/></div></figure><p id="5589" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">不到1%有很多局部变量。</p><p id="a17d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">7–4种方法太复杂</p><p id="9881" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">存在许多度量来检测复杂函数，NBLinesOfCode、参数数目和局部变量数目是基本的度量。</p><p id="209c" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">还有其他有趣的度量来检测复杂函数:</p><ul class=""><li id="d52d" class="lp lq hu jc b jd je jh ji jl lr jp ls jt lt jx lu lv lw lx dt translated">圈复杂度是一个流行的过程化软件度量，等于一个过程中可以做出的决策的数量。</li><li id="9b21" class="lp lq hu jc b jd mg jh mh jl mi jp mj jt mk jx lu lv lw lx dt translated">嵌套深度是在方法上定义的度量，相对于方法体中嵌套更深的范围的最大深度。</li><li id="4016" class="lp lq hu jc b jd mg jh mh jl mi jp mj jt mk jx lu lv lw lx dt translated">最大嵌套循环等于函数中循环嵌套的最大级别。</li></ul><p id="4675" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这些指标的最大容许值更多地取决于团队的选择，没有标准值。</p><p id="99fb" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们在虚幻引擎代码库中搜索被认为复杂的方法。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/9a3ba580d8cdab37322495fccbe8c27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*4C3wd7yIEh2frPfg.png"/></div></figure><p id="3815" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">只有1.5%的方法可以被重构以最小化它们的复杂性。</p><h2 id="0246" class="nh kn hu bd ko ni nj nk ks nl nm nn kw jl no np la jp nq nr le jt ns nt li ia dt translated">7–4霍尔斯特德复杂度</h2><p id="7af8" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">HALSTEAD复杂性度量是由MAURICE HOWARD HALSTEAD在1977年引入的软件度量。HALSTEAD观察到，软件的度量应该反映不同语言中算法的实现或表达，但独立于它们在特定平台上的执行。因此，这些指标是从代码中静态计算出来的。</p><p id="466c" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">Halstead引入了许多度量标准，让我们以timetoimplementation为例，它表示以秒为单位编写方法所需的时间。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/d54d114fe58459d9f8802032f0222274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/0*2qY1rZuNln0HKuKr.png"/></div></figure><p id="7499" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">1748个方法需要一个多小时才能实现。</p><h1 id="17c3" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">8- RTTI</h1><p id="bb71" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">RTTI是指系统在运行时(相对于编译时)报告对象的动态类型并提供该类型信息的能力。然而，RTTI在C++社区中引起了争议。许多C++开发人员选择不使用这种机制。</p><p id="6a43" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">虚幻引擎开发者团队呢？</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/eacb164216a489ee176b67ffc5b26317.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*XM6fruVrF_bKNNo5.png"/></div></figure><p id="460b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">没有方法使用dynamic_cast工具。虚幻引擎团队选择不使用RTTI机制。</p><h1 id="9a8e" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">9-例外</h1><p id="82ab" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">异常处理也是另一个有争议的C++特性。许多已知的开源C++项目不使用它。</p><p id="6c79" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">让我们搜索一下虚幻引擎源代码中是否抛出了异常。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/5207d65402435191a5361a1df5c6cec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*nVIJXNOpWswS6zHH.png"/></div></figure><p id="6192" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在一些方法中会引发异常；就像RaiseException一样:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nw"><img src="../Images/13a66018dd797651e44bacacdade1d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/0*k5x2duqnC5v3x7F8.png"/></div></figure><p id="9bdb" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">正如他们的注释中所指出的，异常可能是为header工具生成的，但是在正常的运行时代码中，他们不支持异常处理。</p><h1 id="5009" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">10-一些统计数据</h1><p id="cd81" class="pw-post-body-paragraph ja jb hu jc b jd lk jf jg jh ll jj jk jl lm jn jo jp ln jr js jt lo jv jw jx hn dt translated">10–1最受欢迎的类型</p><p id="59f1" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">了解项目中使用最多的类型很有趣；事实上，这些类型必须被很好地设计、实现和测试。他们身上发生的任何变化都会影响整个项目。</p><p id="93e4" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们可以使用<em class="jz">类型使用我</em>度量来找到它们:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/e04511a7c9f990be69c57d9191bc97c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/0*gHPoyhQunczLa0Q2.png"/></div></figure><p id="d882" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">然而，还有另一个有趣的指标来搜索流行类型:TypeRank。</p><p id="397e" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">TypeRank值是通过在类型依赖关系图上应用<a class="ae jy" href="http://www.iprcom.com/papers/pagerank/" rel="noopener ugc nofollow" target="_blank"> Google PageRank </a>算法来计算的。应用中心为0.15的同质性，以使TypeRank的平均值为1。</p><p id="1318" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">应该更仔细地测试具有高TypeRank的类型，因为这种类型中的错误可能更具灾难性。</p><p id="b681" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">根据TypeRank指标，以下是所有流行类型的结果:</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff ny"><img src="../Images/072ece04e3a482d8ee6a05b9ff61ecf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*KOagQfX4KjA28J9_.png"/></div></figure><p id="6580" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">10–2种最流行的方法</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="fe ff nz"><img src="../Images/e7d027a90282f9f5921c95d8a310b24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*F00s_fomVwygxtpD.png"/></div></div></figure><p id="1cfa" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">10–3个方法调用许多其他方法</p><p id="55c0" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">了解使用许多其他方法的方法是很有趣的，它可以揭示这些方法中的设计问题。在某些情况下，需要重构以使它们更具可读性和可维护性。</p><figure class="kb kc kd ke fq kf fe ff paragraph-image"><div class="fe ff nz"><img src="../Images/ef5cc542e3273dff89cfa6321ddd437a.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*KEkBUzvYyykVsJJT.png"/></div></figure><p id="3d73" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><strong class="jc ie">结论:</strong></p><p id="799d" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">探索实现良好的项目的源代码非常有趣。我们可以学习一些有用的设计和实现最佳实践。</p></div></div>    
</body>
</html>