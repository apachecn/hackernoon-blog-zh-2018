<html>
<head>
<title>Creating a Progressive Web App with a Headless CMS — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无头CMS创建渐进式Web应用程序—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-progressive-web-app-with-a-headless-cms-part-2-88ffee198ff6?source=collection_archive---------7-----------------------#2018-04-04">https://medium.com/hackernoon/creating-a-progressive-web-app-with-a-headless-cms-part-2-88ffee198ff6?source=collection_archive---------7-----------------------#2018-04-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e6ea816d063af36ed41322bd2642407a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omtqPm7skI8ZSHs3ZCxfxg.jpeg"/></div></div></figure><p id="0be4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-1-85ede9dba59b" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第一部分</strong> </a> <strong class="je hv"> | </strong>第二部分| <a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-3-a6bb538084" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第三部分</strong> </a></p><p id="f8c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嘿，欢迎回来！在本系列的<a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-1-85ede9dba59b" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第1部分</strong> </a>中，我向您介绍了渐进式Web App (PWA)。我介绍了它们是什么，它们是如何工作的，以及一个无头CMS如何真正添加一些令人敬畏的功能。在<strong class="je hv">第2部分</strong>中，我将深入构建一个PWA并添加一些很酷的特性。这意味着创建基础应用程序，添加魔力，并进行测试。</p><p id="cc6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，让我们开始吧！</p><h1 id="9a23" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">重述</strong></h1><p id="5b87" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在<a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-1-85ede9dba59b" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第一部分</strong> </a>中，我提到了一些我们将在本系列中多次讨论的服务。</p><p id="f230" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Google PWA教程</strong> </a> <strong class="je hv"> <br/> </strong>这是我们开始演示用的“base”app。这是一个很棒的教程，为PWA提供了一个很好的基础。</p><p id="d0e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://kenticocloud.com" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">Kentico Cloud</strong></a><strong class="je hv"><br/></strong>这是我们用来驱动我们的应用的基于云的CMS。这是一个可扩展的、灵活的CMS，有大量的SDK和示例项目来帮助你快速上手。</p><h1 id="bd66" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">创建基础应用程序</h1><p id="6ab0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好了，让我们开始创建你的应用程序。您可以从头开始，或者使用许多可用的演示之一来快速启动您的开发。无论你选择哪种方式，你的应用都将包含一些关键组件。</p><p id="b3bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">应用外壳(App Shell) </strong> <br/>应用外壳是App的基础UI。这是您最初将加载的内容，以便为用户提供一致的体验，而不管他们的连接和设备如何。该组件通常在第一次加载应用程序时存储在浏览器缓存中，因为它不会经常更改。您还应该在应用程序外壳中包含任何控件、按钮或图像，以帮助它们快速加载。</p><p id="5529" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务人员 <br/>你的服务人员可能是最重要的组成部分，他会给你的PWA带来新鲜的内容。当人们使用PWA时，他们将期待丰富的、响应性的体验。服务人员就是让这一切发生的人。这些组件负责处理异步事件和执行代码来更新UI。您可以完全控制脚本的生命周期和状态管理。</p><p id="ee79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Manifest </strong> <br/>要获得类似app的体验，你的PWA需要告诉浏览器如何表现。在您的清单文件中，您将定义应用程序的基本内容，以及要加载的URL和图标。您甚至可以设置方向、全屏模式和其他环境变量，以确保您的内容完全按照您想要的方式加载。</p><p id="1c18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">真正的代码</strong> <br/>在您定义了您的AppShell、service worker和manifest之后，您需要添加功能。我的意思是获取数据、更新布局和任何其他想要包含的特性的代码。它可以是一个独立的JaveScript文件，也可以是它们的组合。我还将任何外部库组合到这个组合中，以防您计划在设计中添加一些可爱的光标轨迹。</p><h1 id="8237" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">制作应用程序外壳</h1><p id="c5df" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对于我们的演示，我们从标题、标题和兴趣点列表的基本布局开始。通过使用标准的顶栏，PWA将在浏览器和移动设备上具有熟悉和一致的外观。这基本上构成了我们的应用程序外壳，所以我们尽可能保持简单。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/ede3a31d16587e6c756a5362b5dc2878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DT9uYLpF35V71L17Knx7pQ.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">This is the extent of my design skills.</figcaption></figure><p id="85da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序外壳中还包括我们的兴趣点的基本布局。为此，我们使用一个模板来显示元素。不是很令人兴奋，但这就是一个应用程序的第一个版本的目的！</p><pre class="lf lg lh li fq ln lo lp lq aw lr dt"><span id="b307" class="ls kc hu lo b fv lt lu l lv lw">&lt;main class=”main”&gt;<br/> &lt;div class=”card cardTemplate” hidden&gt;<br/> &lt;h2 class=”title”&gt;&lt;/h2&gt;<br/> &lt;div class=”content”&gt;&lt;/div&gt;<br/> &lt;a class=”map-link” target=”_blank” hidden&gt;Open the map&lt;/a&gt;<br/> &lt;/div&gt;<br/>&lt;/main&gt;</span></pre><p id="6187" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们在获取内容后将兴趣点写入应用程序时，我们将使用该模板。</p><h1 id="d2a8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">添加服务人员</h1><p id="5c8f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">下一个要添加的是服务人员。文件。您需要设置触发器，定义缓存信息，并配置应用程序的运行方式。这可能会对应用程序的行为产生很大影响，并使其更像移动用户的原生应用程序。你和你的服务人员可能会花很多时间在一起，所以带一份乔迁礼物来打破僵局。</p><p id="92d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的演示中，我们创建了一个新的脚本来保存服务工作者逻辑。在示例的基础上，我们添加了缓存信息、想要存储的文件列表和事件侦听器。有了这个工人，我们可以在用户与应用程序交互时捕获事件，并根据请求和/或环境控制功能的处理方式。</p><pre class="lf lg lh li fq ln lo lp lq aw lr dt"><span id="d402" class="ls kc hu lo b fv lt lu l lv lw">var dataCacheName = 'packAndGoData-v1';<br/> var cacheName = 'packAndGoApp-v1';</span><span id="e02c" class="ls kc hu lo b fv lx lu l lv lw">var filesToCache = [<br/>   '/',<br/>   '/index.html',<br/>   '/main.js',<br/>   '/manifest.json',<br/>   '/styles/fonts/RobotoMedium.eot',<br/>   '/styles/fonts/RobotoMedium.svg',<br/>   '/styles/fonts/RobotoMedium.ttf',<br/>   '/styles/fonts/RobotoMedium.woff',<br/>   '/styles/fonts/RobotoMedium.woff2',<br/>   '/styles/style.css',<br/>   '/assets/images/icon_refresh.svg'|<br/> ];</span><span id="2920" class="ls kc hu lo b fv lx lu l lv lw">self.addEventListener('install', function (e) {<br/>   console.log('[ServiceWorker] Install');<br/>   e.waitUntil(<br/>     caches.open(cacheName).then(function (cache) {<br/>       console.log('[ServiceWorker] Caching app shell');<br/>       return cache.addAll(filesToCache);<br/>     })<br/>   );<br/> });</span><span id="6cda" class="ls kc hu lo b fv lx lu l lv lw">self.addEventListener('activate', function (e) {<br/>   console.log('[ServiceWorker] Activate');<br/>   e.waitUntil(<br/>     caches.keys().then(function (keyList) {<br/>       return Promise.all(keyList.map(function (key) {<br/>         if (key !== cacheName &amp;&amp; key !== dataCacheName) {<br/>           console.log('[ServiceWorker] Removing old cache', key);<br/>           return caches.delete(key);<br/>         }<br/>       }));<br/>     })<br/>   );<br/> <br/>   /*<br/>    * Fixes a corner case in which the app wasn't returning the latest data.|<br/>    * You can reproduce the corner case by commenting out the line below and<br/>    * then doing the following steps: 1) load app for first time so that the<br/>    * initial New York City data is shown 2) press the refresh button on the<br/>    * app 3) go offline 4) reload the app. You expect to see the newer NYC<br/>    * data, but you actually see the initial data. This happens because the<br/>    * service worker is not yet activated. The code below essentially lets<br/>    * you activate the service worker faster.<br/>    */<br/>   return self.clients.claim();<br/> });</span><span id="0d1e" class="ls kc hu lo b fv lx lu l lv lw">self.addEventListener('fetch', function (e) {<br/>   console.log('[Service Worker] Fetch', e.request.url);<br/>   var dataUrl = 'https://deliver.kenticocloud.com/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/items';<br/>   if (e.request.url.indexOf(dataUrl) &gt; -1) {<br/>     /*<br/>      * When the request URL contains dataUrl, the app is asking for fresh<br/>      * weather data. In this case, the service worker always goes to the<br/>      * network and then caches the response. This is called the "Cache then<br/>      * network" strategy:<br/>      * <a class="ae ka" href="https://jakearchibald.com/2014/offline-cookbook/#cache-then-network" rel="noopener ugc nofollow" target="_blank">https://jakearchibald.com/2014/offline-cookbook/#cache-then-network</a><br/>      */<br/>     e.respondWith(<br/>       caches.open(dataCacheName).then(function (cache) {<br/>         return fetch(e.request).then(function (response) {<br/>           cache.put(e.request.url, response.clone());<br/>           return response;<br/>         })<br/>       })<br/>     );<br/>   } else {<br/>     /*<br/>      * The app is asking for app shell files. In this scenario the app uses the<br/>      * "Cache, falling back to the network" offline strategy:<br/>      * <a class="ae ka" href="https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network" rel="noopener ugc nofollow" target="_blank">https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network</a><br/>      */<br/>     e.respondWith(<br/>       caches.match(e.request).then(function (response) {<br/>         return response || fetch(e.request)<br/>       })<br/>     );<br/>   }<br/> });</span></pre><h1 id="fbba" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">集成Kentico云</h1><p id="c747" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有了应用程序集的基础，您就可以添加好的东西了。如果你走的是基于云的CMS路线，这就是你想要利用任何可用的API和SDK的地方。这些将帮助您快速将平台集成到PWA中，确保系统之间的无缝通信。有可能他们有几种SDK版本，所以选择一种与你的架构相匹配的。</p><p id="4d72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的PWA，我们为Kentico CloudT3选择了一个<a class="ae ka" href="https://github.com/Enngage/KenticoCloudDeliveryTypeScriptSDK" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> JavaScript SDK。因为我们的应用程序是以JavaSscript为中心的，所以这个SDK提供了最好的解决方案来快速整合到我们的架构中。通过执行几个<strong class="je hv"> npm </strong>命令，我们将SDK安装到了应用程序中，并准备好进行编程。这导致了一些新的包文件，用于创建我们的CMS客户端和检索内容。</strong></a></p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/cbd3dff51f0ad1fd909c20b51475f0d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OcqDdR3mwlAZOsNGFGmrA.png"/></div></div></figure><p id="6d15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以进一步了解<a class="ae ka" href="https://github.com/Enngage/KenticoCloudDeliveryTypeScriptSDK" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">Kentico Cloud JavaScript SDK</strong></a>。</p><h1 id="89e8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">添加内容</h1><p id="2635" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好了，你已经花了这么多时间来学习架构、定义内容和创建功能。现在是时候让它发挥作用了！这就是你的“真正的代码”发挥作用的地方。您需要将您的应用程序连接到CMS，获取一些内容，并连接您的服务人员来处理这些请求。</p><p id="702c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的应用程序，我们创建了一些脚本来保存我们的功能。首先，我们创建了一个<strong class="je hv"> client.js </strong>文件来定义我们的CMS客户端。这个文件利用了我们集成到站点中的JavaScript SDK，使得创建客户端变得轻而易举。因为我们为应用程序使用了Kentico Cloud，这意味着定义我们的项目id并创建一个新的<strong class="je hv"> DeliveryClient </strong>来访问我们的内容。</p><pre class="lf lg lh li fq ln lo lp lq aw lr dt"><span id="9f86" class="ls kc hu lo b fv lt lu l lv lw">import { DeliveryClient, DeliveryClientConfig } from 'kentico-cloud-delivery-typescript-sdk';<br/> const projectId = 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX;<br/> const previewApiKey = "";</span><span id="fffd" class="ls kc hu lo b fv lx lu l lv lw">const isPreview = () =&gt; {<br/>     return previewApiKey !== "";<br/> }</span><span id="5187" class="ls kc hu lo b fv lx lu l lv lw">const client = new DeliveryClient(<br/>     new DeliveryClientConfig(projectId, [],<br/>         {<br/>             enablePreviewMode: isPreview(),<br/>             previewApiKey: previewApiKey<br/>         }<br/>     )<br/> )</span><span id="f64b" class="ls kc hu lo b fv lx lu l lv lw">module.exports = {<br/>     projectId,<br/>     client<br/> }</span></pre><p id="68d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们为主要功能添加了一个<strong class="je hv"> app.js </strong>文件。按照Google PWA教程，我们编写了POI卡更新的方式和时间。</p><p id="c7c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为pwa大量利用缓存，所以我们添加了检查POI数据是否已经被检索的功能。如果是这样，应用程序将加载该内容。否则，我们使用我们的Kentico云交付客户端从我们的项目中检索信息。</p><pre class="lf lg lh li fq ln lo lp lq aw lr dt"><span id="b61c" class="ls kc hu lo b fv lt lu l lv lw">const getPointsOfInterest = () =&gt; {</span><span id="7106" class="ls kc hu lo b fv lx lu l lv lw">const url = 'https://deliver.kenticocloud.com/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/items?system.type=point_of_interest';<br/>     if ('caches' in window) {<br/>         /*<br/>          * Check if the service worker has already cached this data about the Point of interests<br/>          * data. If the service worker has the data, then display the cached<br/>          * data while the app fetches the latest data.<br/>          */<br/>         caches.match(url).then(response =&gt;<br/>             response &amp;&amp; response<br/>                 .json()<br/>                 .then(json =&gt; {<br/>                     const typedResponse = new BaseResponse(json, response);<br/>                     responseMapService<br/>                         .mapMultipleResponse(typedResponse, client.config)<br/>                         .items.forEach(pointOfInterest =&gt;<br/>                             updatePointOfInterestCard(pointOfInterest))<br/>                 })<br/>         );<br/>     }</span><span id="fdb3" class="ls kc hu lo b fv lx lu l lv lw">client.items()<br/>         .type('point_of_interest')<br/>         .get()<br/>         .toPromise()<br/>         .then(response =&gt;<br/>             response.items.forEach(pointOfInterest =&gt; {<br/>                 updatePointOfInterestCard(pointOfInterest);<br/>             }))<br/> }</span></pre><p id="dac1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这两种情况下，我们调用<strong class="je hv">updatePointOfInterestCard</strong>函数来用内容更新我们的布局。</p><p id="d2aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们创建了<strong class="je hv">updatePointOfInterestCard</strong>函数来与页面元素进行交互。我们检查以确保卡存在，如果需要就创建它。然后，我们找到每个元素并用检索到的数据更新值。因为我们使用SDK，所以我们利用一些预建的功能和模式来帮助轻松设置我们的内容。</p><pre class="lf lg lh li fq ln lo lp lq aw lr dt"><span id="735f" class="ls kc hu lo b fv lt lu l lv lw">const updatePointOfInterestCard = (data) =&gt; {<br/>    const key = data.system.id;<br/>    const title = data.title.value;<br/>    const content = data.description.value<br/>    const latitude = data.latitude__decimal_degrees_ &amp;&amp; data.latitude__decimal_degrees_.value;<br/>    const longitude = data.longitude__decimal_degrees_ &amp;&amp; data.longitude__decimal_degrees_.value;</span><span id="75cd" class="ls kc hu lo b fv lx lu l lv lw">let card = visibleCards[key];</span><span id="5828" class="ls kc hu lo b fv lx lu l lv lw">if (!card) {<br/>         card = cardTemplate.cloneNode(true);<br/>         card.classList.remove('cardTemplate');<br/>         card.removeAttribute('hidden');<br/>         container.appendChild(card);<br/>         visibleCards[key] = card;<br/>     }</span><span id="882b" class="ls kc hu lo b fv lx lu l lv lw">card.querySelector('.title').textContent = title;<br/>     card.querySelector('.content').innerHTML = content;</span><span id="ddae" class="ls kc hu lo b fv lx lu l lv lw">if (latitude &amp;&amp; longitude) {<br/>         card.querySelector('.map-link').setAttribute('href',<br/> `http://maps.google.com/?ie=UTF8&amp;hq=&amp;ll=${latitude},${longitude}&amp;z=16`)<br/>         card.querySelector('.map-link').removeAttribute('hidden');<br/>     }</span><span id="3439" class="ls kc hu lo b fv lx lu l lv lw">if (isLoading) {<br/>         loader.setAttribute('hidden', true);<br/>         isLoading = false;<br/>     }<br/> };</span></pre><h1 id="589d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">配置清单</h1><p id="a14f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好了，你已经准备好你的程序了。您已经集成了布局、服务人员和功能，但是您需要让它在所有设备上都看起来不错。这就是清单文件发挥作用的地方。在这个文件中，您将定义用户将看到的体验、他们可以使用的选项以及应用程序在他们设备上的外观。</p><p id="f86e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的PWA中，我们在清单中为标题和颜色设置了一些基础。对于显示，我们选择了<strong class="je hv">独立。这使得页面看起来像一个本地应用，去掉了地址栏。最后，我们定义了我们的图标。因为PWAs可以固定在用户的主屏幕上，所以包含所有可能使用的尺寸非常重要。</strong></p><pre class="lf lg lh li fq ln lo lp lq aw lr dt"><span id="ad60" class="ls kc hu lo b fv lt lu l lv lw">{<br/>   "name": "Travel app",<br/>   "short_name": "travelapp",<br/>   "theme_color": "#1564bf",<br/>   "background_color": "#e1e2e1",<br/>   "display": "standalone",<br/>   "Scope": "/",<br/>   "start_url": "/",<br/>   "icons": [<br/>     {<br/>       "src": "\/assets\/images\/icons\/android-icon-36x36.png",<br/>       "sizes": "36x36",<br/>       "type": "image\/png",<br/>       "density": "0.75"<br/>     },<br/>     {<br/>       "src": "\/assets\/images\/icons\/android-icon-48x48.png",</span><span id="0f11" class="ls kc hu lo b fv lx lu l lv lw">"sizes": "48x48",<br/>       "type": "image\/png",<br/>       "density": "1.0"<br/>     },<br/>     {<br/>       "src": "\/assets\/images\/icons\/android-icon-72x72.png",<br/>       "sizes": "72x72",<br/>       "type": "image\/png",<br/>       "density": "1.5"<br/>     },<br/>     {<br/>       "src": "\/assets\/images\/icons\/android-icon-96x96.png",<br/>       "sizes": "96x96",<br/>       "type": "image\/png",<br/>       "density": "2.0"<br/>     },<br/>     {<br/>       "src": "\/assets\/images\/icons\/android-icon-144x144.png",<br/>       "sizes": "144x144",<br/>       "type": "image\/png",<br/>       "density": "3.0"<br/>     },<br/>     {<br/>       "src": "\/assets\/images\/icons\/android-icon-192x192.png",<br/>       "sizes": "192x192",<br/>       "type": "image\/png",<br/>       "density": "4.0"<br/>     }<br/>   ],<br/>   "splash_pages": null<br/> }</span></pre><h1 id="9df0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">测试应用程序</h1><p id="982b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">此时，您应该能够测试您的应用程序了。您会希望在您的计算机和移动设备上查看它。您应该会看到整个环境一致、整洁的外观。在你的手机上，它应该看起来非常类似于一个本地应用程序，并使你能够与主屏幕和你添加的任何其他功能进行交互。</p><p id="120f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的演示，我在电脑上打开了应用程序，并检查了布局。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/27c78845d14c9ff032e3eb56e25b0a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUyf2yc4wTi4hYejv-v_Gg.png"/></div></div></figure><p id="63e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我使用开发工具来模拟一个移动设备。这是为了测试响应式布局是否正确地调整了内容的大小。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/48c9a532ece76ffce90e4286ed422c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8jolR_U7zFDfuPa6EL8ZA.png"/></div></div></figure><p id="91d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我将应用程序部署到Azure应用程序服务，以便从外部访问站点。我在移动设备上打开了这个应用程序，以确认它显示正常。</p><p id="bcac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">提示</strong> <br/>我必须运行<strong class="je hv"> npm run build-prod </strong>命令来为部署创建<strong class="je hv"> dist </strong>文件夹。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/71f90ba76f0b809fd3f7f06c3176def9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dF0_P3fx2S_doLQ6zJ2eqQ.png"/></div></div></figure><p id="37d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于<strong class="je hv"> manifest.json </strong>的设置，我能够将应用程序添加到主屏幕，并确认图标显示正确。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/f6287c931fcfb2554d23f849390c5950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99aw6_X0bYJ4ID0ac6aefg.png"/></div></div></figure><p id="4786" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想看现场演示，请查看<a class="ae ka" href="https://bryansdemopwa1.azurewebsites.net/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">我的网站</strong> </a>。随着博客系列的继续，我将继续用新特性更新这个部署。</p><h1 id="9137" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">下次</h1><p id="341f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">咻，要输入的信息太多了！如果你一直跟着，毫无疑问你和我一样累了，应该休息一下。在这篇博客中，我介绍了如何设置我的基本应用程序、添加我的服务人员和布局，以及在不同的点缓存文件和数据。在确保我所有的代码都准备就绪后，我启动了这个应用，并在各种设备上进行测试。</p><p id="8b32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在以后的博客中，我将会涉及更多高级的主题，比如推送通知、图片和原生应用功能。我将继续构建这里提到的演示，所以我希望你喜欢这个旅程。下次见，朋友们！</p><p id="6ba0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想跟踪我们的PWA演示应用程序，请查看我们的<a class="ae ka" href="https://github.com/Kentico/cloud-sample-pwa-app/tree/v1-introduction" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Pack and Go GitHub项目</strong> </a> <strong class="je hv">。</strong></p><p id="539f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-1-85ede9dba59b" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第一部分</strong> </a> <strong class="je hv"> | </strong>第二部分| <a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-3-a6bb538084" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第三部分</strong> </a></p></div></div>    
</body>
</html>