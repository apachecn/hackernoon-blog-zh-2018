<html>
<head>
<title>Speaking in Tongues: 1950–1960</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">说方言:1950年至1960年</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-first-decade-of-programming-speaking-in-tongues-f395a228cf35?source=collection_archive---------14-----------------------#2018-04-06">https://medium.com/hackernoon/the-first-decade-of-programming-speaking-in-tongues-f395a228cf35?source=collection_archive---------14-----------------------#2018-04-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="6a90" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">个人编程史第一章的第二部分</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/6e3bc3687b45a6c4bd595a4bdccb7963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*4y1-wyXtHhky2AfuZleWPg.png"/></div></figure><h2 id="3fc8" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">言语含混</h2><p id="0588" class="pw-post-body-paragraph kp kq hu kr b ks kt iv ku kv kw iy kx kc ky kz la kg lb lc ld kk le lf lg lh hn dt translated">1957年，FORTRAN(公式翻译)使得人们可以通过用人类的逻辑进行组合来编写程序，而不需要记住困难的操作码。</p><p id="7ad1" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">人类可读(和相关)的编程语言的工作方式是通过获取一个概念，比如打印出一些东西，正如我们刚才看到的，这需要十几行汇编代码，并将那个概念<em class="ln"> abstracting⁶ </em>成一个<em class="ln">保留字</em>。保留字不同于二进制或十六进制字。保留字是人类语言的代码字，用计算机字表示整个句子。在FORTRAN的情况下，取代上面大部分汇编程序的保留字是“write”。</p><p id="0b49" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">一个叫做<em class="ln">编译器</em>的特殊程序将“写”扩展成十六行汇编语言，并将其他保留字扩展成它们各自的汇编语言等价物。</p><p id="37da" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">我们很快就会看到，许多早期的程序员不喜欢编译器。他们不相信他们能做得像人类一样好。一开始，这很可能是有价值的，但是随着时间的推移，人类将更多的“智慧”转移到了编译器中。此外，随着计算机容量越来越大，程序也越来越大，越来越复杂。对于一个现代程序员来说，击败编译器几乎是不可能的，也没有人真正去尝试。</p><p id="eebe" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">但是在过去，即使使用编译器，程序员仍然“接近”金属。他们通常知道编译器在做什么，当它“看到”人类可读语言中的某些模式时会做出什么“选择”。优秀的程序员会以特定的方式编写人类可读的代码，以迫使编译器“做正确的事情”。</p><p id="8b5b" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">以下是用FORTRAN语言编写的“Hello World”程序:</p><pre class="jk jl jm jn fq lo lp lq lr aw ls dt"><span id="88b7" class="jr js hu lp b fv lt lu l lv lw">1 implicit none<br/>2 write ( *, ‘(a)’ ) ‘ Hello, world!’<br/>3 stop<br/>4 end</span></pre><p id="6412" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">正如您所看到的，用FORTRAN编写减少了所需的编程语句的数量。平均来说是20倍。</p><p id="8e9c" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">编程生产率的提高是数量级的，因为程序越长或越复杂，生产率的提高就越显著。我给你举的例子都很短。对于一个更大的程序(几万或几十万行),这种差别会更明显。写500行而不是10000行比写4行而不是16行更能提高生产力。</p><p id="159b" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">几年前，格蕾丝·赫柏创造了一种商业语言，叫做FLOW-MATIC，她认为人们应该能够用简单的英语给计算机编程，让计算机把英语单词转换成机器指令。很少有人听说过FLOW-MATIC，但很多人听说过COBOL(面向公共业务的语言),它在很大程度上基于FLOW-MATIC，被很多人认为比FORTRAN更易于阅读。</p><pre class="jk jl jm jn fq lo lp lq lr aw ls dt"><span id="8dd9" class="jr js hu lp b fv lt lu l lv lw">1 IDENTIFICATION DIVISION.<br/>2 PROGRAM-ID. HELLO-WORLD.<br/>3 * simple hello world program<br/>4 PROCEDURE DIVISION.<br/>5 DISPLAY ‘Hello world!’.<br/>6 STOP RUN.</span></pre><p id="b483" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">必须指出的是，许多程序员不喜欢COBOL程序，因为它非常罗嗦，这可以被认为是生产力的下降。</p><p id="0090" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">麻省理工学院的术语File⁷是这样说的:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/f1afaf07629a3c1459caf3acb6a4f564.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*03XXh7Qngd2KLcS92_4rPA.png"/></div></figure><p id="9d8a" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">来自瑞典的报道，一种(假设的)疾病可能是由COBOL语言编码引起的。该语言要求代码过于冗长(参见candygrammar)；因此，有人声称用COBOL编程太多会导致一个人的手指因无休止的打字而磨损。“我拒绝再次输入所有源代码；它会给我COBOL手指！”</p><p id="53be" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">尽管如此，让更多的人能够使用编程总体上来说是一种生产力的提高，而且它仍然比汇编代码要少得多。</p><p id="0eaa" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">在50年代后期，同时出现了另外两种有影响力的语言，LISP和ALGOL(算法语言), LISP今天仍被用于AI(人工智能)编程。</p><p id="b428" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">几乎所有今天常用的语言都不是FORTRAN或COBOL的后代，而是ALGOL的后代(有时还带有一点LISP的影响)。但是这些后代在二十年后才开始出现，接下来的十年属于计算机制造商和电气工程师。他们不是通过语言，而是通过硬件和操作系统来提高编程效率。</p><blockquote class="ly"><p id="a0fe" class="lz ma hu bd mb mc md me mf mg mh lh ek translated">这是一种远远领先于其时代的语言，它不仅是对其前辈的改进，而且是对几乎所有后继者的改进。⁸</p><p id="9e5f" class="lz ma hu bd mb mc md me mf mg mh lh ek translated">~查尔斯·安东尼·理查德·霍尔爵士<br/>图灵奖获得者计算机科学家<br/>谈到ALGOL</p></blockquote></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><h2 id="34e6" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated"><a class="ae mp" href="https://hackernoon.com/https-medium-com-it-explained-for-normal-people-the-metal-years-5be295dad17c" rel="noopener ugc nofollow" target="_blank">&lt;——上一篇系列文章</a></h2><h2 id="53b6" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated"><a class="ae mp" href="https://hackernoon.com/https-medium-com-it-explained-for-normal-people-big-iron-6aee4e32ed51" rel="noopener ugc nofollow" target="_blank">系列下一篇- &gt; </a></h2></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><p id="d4a4" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">[1]稍后，在第四章，我将深入解释<em class="ln">抽象</em>在计算中的含义。</p><p id="d3ee" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">[2]“行话文件是<a class="ae mp" href="https://en.wikipedia.org/wiki/Computer_programmer" rel="noopener ugc nofollow" target="_blank">电脑程序员</a> <a class="ae mp" href="https://en.wikipedia.org/wiki/Slang" rel="noopener ugc nofollow" target="_blank">俚语</a>的<a class="ae mp" href="https://en.wikipedia.org/wiki/Glossary" rel="noopener ugc nofollow" target="_blank">词汇表</a>和<a class="ae mp" href="https://en.wikipedia.org/wiki/Usage_dictionary" rel="noopener ugc nofollow" target="_blank">用法词典</a>。最初的行话文件是来自技术文化的术语的集合，例如<a class="ae mp" href="https://en.wikipedia.org/wiki/MIT_Computer_Science_and_Artificial_Intelligence_Laboratory" rel="noopener ugc nofollow" target="_blank">麻省理工学院人工智能实验室</a>、<a class="ae mp" href="https://en.wikipedia.org/wiki/Stanford_University_centers_and_institutes#Stanford_Artificial_Intelligence_Laboratory" rel="noopener ugc nofollow" target="_blank">斯坦福人工智能实验室</a> (SAIL)和其他旧的<a class="ae mp" href="https://en.wikipedia.org/wiki/ARPANET" rel="noopener ugc nofollow" target="_blank"> ARPANET </a>、<a class="ae mp" href="https://en.wikipedia.org/wiki/Artificial_intelligence" rel="noopener ugc nofollow" target="_blank">人工智能</a>/<a class="ae mp" href="https://en.wikipedia.org/wiki/Lisp_programming_language" rel="noopener ugc nofollow" target="_blank">LISP</a>/<a class="ae mp" href="https://en.wikipedia.org/wiki/PDP-10" rel="noopener ugc nofollow" target="_blank">PDP-10</a>社区，包括<a class="ae mp" href="https://en.wikipedia.org/wiki/BBN_Technologies" rel="noopener ugc nofollow" target="_blank"> Bolt、Beranek和Newman </a>、<a class="ae mp" href="https://en.wikipedia.org/wiki/Carnegie_Mellon_University" rel="noopener ugc nofollow" target="_blank">卡耐基梅隆大学</a>和<a class="ae mp" href="https://en.wikipedia.org/wiki/Worcester_Polytechnic_Institute" rel="noopener ugc nofollow" target="_blank"/><a class="ae mp" href="https://en.wikipedia.org/wiki/Jargon_File" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Jargon_File</a></p><p id="f709" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">全文可在http://catb.org/jargon/html/index.html获得。我在我的<em class="ln">幼虫期</em>的时候，怀着宗教般的热情阅读了它。可以在行话文件中查找<em class="ln">幼虫期</em>。</p><p id="607a" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">3 c . a . r .霍尔。1973.<em class="ln">编程语言设计提示</em>。技术报告。美国加州斯坦福大学。</p></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><p id="e1c1" class="pw-post-body-paragraph kp kq hu kr b ks li iv ku kv lj iy kx kc lk kz la kg ll lc ld kk lm lf lg lh hn dt translated">这篇文章摘自我即将出版的书<em class="ln">混乱工厂</em>，它解释了为什么大多数公司和政府不能编写“正常工作”的软件，以及如何解决这个问题。</p></div></div>    
</body>
</html>