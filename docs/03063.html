<html>
<head>
<title>You don’t understand blockchain unless you understand this simple data structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">除非你理解这个简单的数据结构，否则你不会理解区块链</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/you-dont-understand-blockchain-unless-you-understand-this-simple-data-structure-fb1df7982cc5?source=collection_archive---------2-----------------------#2018-04-07">https://medium.com/hackernoon/you-dont-understand-blockchain-unless-you-understand-this-simple-data-structure-fb1df7982cc5?source=collection_archive---------2-----------------------#2018-04-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ef3c386cd1ce693d2fcc86cb5c2c1958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtVmwewSvaY_p_bjRKXJLg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/3H_2x19c23A?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Brooke Lark</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4e86" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">区块链是一个不可变的、有序的、反向链接的事务块列表。如果你想真正理解区块链，你需要理解链表。</p><p id="9e6b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">链表是数据元素的线性集合。链表中的线性不是由每个元素的物理位置定义的。相反，链表中的每个数据节点指向链表中的一个或两个其他节点。</p><p id="7f42" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于像[1，2，3]这样的数组，您知道元素1位于位置[0]，元素2位于位置[1]。</p><p id="139a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个元素的物理位置定义了阵列的线性度。链表不会出现这种情况。</p><p id="bccd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">节点构成了链表中的元素。每个节点都有一个数据段。和数据一样，每个节点都有一个“向前”和“向后”部分，指向列表中的上一个和下一个节点。</p><p id="9a59" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在一个数组中，如果你想在[0]处插入一个项目，你需要将数组1中的每个元素向右移动，以便在[0]处留出空间。</p><p id="3a75" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了链表，你可以在列表的任何地方插入数据项，而不必移动整个列表。为此，您必须告诉下一个和上一个节点指向这个新节点。</p><p id="a442" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设你有一个每天都在增长的数组。有一天，数组中有5000个元素。若要在[0]处插入项目，您必须移动5000个元素。</p><p id="f400" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了链表，你不必移动任何项目，你可以插入它们。这使得它们对于快速增长的列表非常有用。</p><p id="0263" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">链表具有可伸缩性和适应性。</p><p id="6243" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们称节点的“向前”和“向后”元素为节点的指针。节点中有2 / 3的元素，这取决于它是单向链表还是双向链表。</p><h1 id="192c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">单链表</h1><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/9bd512307c1d90428bd32a6dc92ee22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*tZeQ7c4s8mIdgQPFs6DpPw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A Node of a Singly Linked List</figcaption></figure><p id="ffa4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">单向链表有一个数据元素和一个指向下一个节点的指针。当指针没有指向任何东西时，我们说它指向零。</p><p id="52e6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2 <strong class="jj hv">组件</strong>组成了单链表节点——数据和指针。</p><p id="f4ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">单链表不能向后指向，因为它们没有“向后”指针。</p><p id="eaf4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了下一个节点所在的位置，指针不存储任何数据。它实际上是一个指针。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff li"><img src="../Images/2521eadf1661f707c260d3ba6ea071ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*d3f_qh9xp1JCGvBM1yRtrQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">2 nodes in a linked list. One of them is correctly pointing to NULL.</figcaption></figure><p id="b56e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">添加了一个新的节点来显示包含多个节点的单链表。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/078103b708c2c731338a5dc8ad53f7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*5TjzOrO0_kOx2eFXf0_rKQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">3 nodes in a linked list, with a header and tail pointer.</figcaption></figure><p id="f0db" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据实现的不同，一个链表也可以有两个特殊的指针——头和尾。</p><p id="d6ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">头指针指向链表中的第一个节点。尾指针指向链表中的最后一个节点。</p><p id="79b6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果链表中只有一个节点，约定是head指向它，tail指向null。尽管这完全取决于程序员，并且在某些情况下，头尾可以指向同一个单个节点。</p><p id="a675" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">程序员为链表创建特殊的函数，使它们更容易使用。这些功能是:</p><ul class=""><li id="1880" class="lk ll hu jj b jk jl jo jp js lm jw ln ka lo ke lp lq lr ls dt translated">node.data =从当前节点获取数据</li><li id="124b" class="lk ll hu jj b jk lt jo lu js lv jw lw ka lx ke lp lq lr ls dt translated">node.next =转到下一个节点</li></ul><h1 id="2bb2" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">双向链表</h1><p id="7d7c" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">双向链表是一个单向链表，它有一个“反向”组件。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/5998c08ed56915709c095f6c0b9669b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*AdjEZlPyCe-yXhXwFhUrJA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A node in a doubly linked list with 3 components</figcaption></figure><p id="ffc2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">双向链表中的每个<strong class="jj hv">节点</strong>有3个<strong class="jj hv">组件</strong>。向后指针、数据元素和向前指针。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/ec6daebfe2c0f196ce06cdb6957a5d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBc-5orIYMBzOvwzAjKs1Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">2 nodes in a doubly linked list. Both nodes are correctly pointing at NULL. There are header and tail pointers in this linked list.</figcaption></figure><p id="13b6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">和单链表一样，双向链表也有特殊的功能。这些功能是:</p><ul class=""><li id="52b4" class="lk ll hu jj b jk jl jo jp js lm jw ln ka lo ke lp lq lr ls dt translated">node.data =从当前节点获取数据</li><li id="44a9" class="lk ll hu jj b jk lt jo lu js lv jw lw ka lx ke lp lq lr ls dt translated">node.next =转到下一个节点</li><li id="a2ff" class="lk ll hu jj b jk lt jo lu js lv jw lw ka lx ke lp lq lr ls dt translated">node.prev =转到上一个节点</li></ul><p id="9c3a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果在头节点上使用node.prev，那么函数将出错或产生空值。如果在尾节点上使用node.next，那么函数将出错或产生空值。</p><h1 id="e814" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">遍历链表</h1><p id="c5bb" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">我们想对链表做的很多事情就是遍历它们。在链表中上下移动。</p><p id="bd52" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要做的第一件事是确定我们从哪里开始。嗯，链表的起点(head)是个好地方。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="ebb5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们需要一个遍历整个列表的循环。我们希望遍历每一个节点，直到当前选择的节点为“NULL”或者在Python中为None。一旦我们到达一个“无”节点，我们就知道我们到了终点。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="76af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们想在遍历链表时对它做些什么。让我们打印链表中每个节点的每个数据元素。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="4445" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，为了实际移动到下一个节点，我们使用node.next函数:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="21b0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">的符号:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="550c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">被称为<strong class="jj hv">点</strong>符号，因为我们调用链表的函数“下一步”。我们将很快看到如何编写一个链表。</p><p id="e94b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">搜索和遍历链表的时间复杂度是O(n)。如果你不理解大O符号，我强烈推荐这篇文章:</p><div class="mh mi fm fo mj mk"><a href="https://hackernoon.com/you-need-to-understand-big-o-notation-now-4ada3d2ec93a" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">你现在需要理解大O符号。</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">你的算法可能会很慢，除非你学会这一基本技能，否则你可能不会注意到它。</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">hackernoon.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ja mk"/></div></div></a></div><h1 id="586a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">链表编程</h1><p id="d4a6" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">链表在大多数语言中都不可用，所以我们必须自己编程。</p><p id="400a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为一个节点在我们的链表中具有相同的功能和外观，所以最好将其创建为一个类。</p><p id="9e78" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个类是一个<strong class="jj hv">对象</strong>的模板。您可以从一个类中创建许多对象。</p><p id="9aa3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们用Java设计链表。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="1a5d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以使用点符号将3种方法应用于该节点:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="cce7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个类有一个“构造器”方法，每次我们创建一个新节点时它都会运行。这为我们初始化了节点。构造函数方法设置下一个和上一个指针指向“null”。然后，它将数据设置为“I ”,这是用户希望放入节点的内容。</p><p id="0dbe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们想创建一个节点，我们只需编写以下代码:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="3054" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这创建了Node类的一个<strong class="jj hv">实例</strong>，并提供数字“5”作为该节点的数据元素。</p><p id="48cd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，只有一个单一节点是没有用的。我们想在链表中添加更多的节点。</p><p id="834a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还记得前面的例子吗？在这个例子中，将一个元素添加到数组的前面需要将每个元素向右移动1？</p><p id="437d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将展示如何使用链表更容易做到这一点。</p><p id="d236" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了在列表的前面添加一个新的节点，我们需要一个方法(函数)来完成这个任务</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="65ee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们可以将一个节点添加到前端之前，我们首先必须用我们想要的值创建一个节点:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/47e52eeb1d3516f76243c110ad3be2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwNAmCQNH3biOcA8WgpC7Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A doubly linked list already exsists with data 15 and 14. We create a new node with data Value that is not currently connected to the linked list; as such both pointers point to NULL.</figcaption></figure><p id="2531" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，根据我们前面对节点类的定义，节点的函数node.next和node.prev指向null。让我们改变这一点:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="b8aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们没有更新头指针，所以它仍然指向链表的头，这就是我们想要在链表中创建的第二个节点。我们让node.next指针指向head指针指向的地方。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/bf0a622e278993e40e590b06e5defee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSxgCOxx3g1ULbYS27m8Uw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">We begin to attach the new node to the rest of the linked list. We tell the forward component to point at where head is pointing at.</figcaption></figure><p id="81de" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我们要在链表的前面插入一个新的节点，所以我们需要很快更新head指针。首先，我们将定义上一个指针指向的新节点。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="1220" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们实际上不需要将newNode.prev更新为null，因为它已经在Node类中完成了；然而，为了使事情清楚，代码已经放在那里。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/bf0a622e278993e40e590b06e5defee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSxgCOxx3g1ULbYS27m8Uw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Since we defined both pointers of a doubly linked list node to point to NULL nothing has changed. The code has been put here for extra clarity. This has <strong class="bd nb">not</strong> changed the linked list.</figcaption></figure><p id="8b62" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们需要更新第二个节点，头指针仍然指向的节点。它需要知道node.previous现在指向一个实际的节点，而不仅仅是null。</p><p id="6509" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果头指针没有指向任何东西，因为链表还没有创建，那么我们不需要更新节点。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/04c064b272f556aa41c6ffd5dcadab6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vi7Omq3KWb0q9JbnBU1BQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The second node (head node) has been updated so the previous component points at our new node.</figcaption></figure><p id="e5e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果头指针指向一个节点，那么就通知这个节点。prev函数指向我们刚刚插入的新节点。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="b448" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">否则，如果头部没有指向任何东西，就把尾部作为新节点。前面我们讨论了一个单个节点是否有一个头指针或尾指针指向它。这是程序员决定的部分。在这里，我们选择了同时将单个节点作为尾部和头部。</p><p id="1a8e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们现在只需要更新头部指针，使其指向链表的新头部:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/21502dfe5122fd4877a8e2e020c24c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oa2rx4xWSKxij6Y6EcTgQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The new node has been inserted at the head of the linked list. We have just updated the head pointer to point to the new head.</figcaption></figure><p id="b0ba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们也可以用类似的方式删除链表前面的节点:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="95f9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们假设curr是一个指向链表中任意节点的指针。</p><p id="1236" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们希望将curr设置为head，因为我们要删除head节点:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/4adf888f884dba7e80a3138a76f90cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1gmq_aVCT4lY6usR96JgA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The curr pointer is pointing at the same place the head pointer is.</figcaption></figure><p id="6f7f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们要确保那个头指向某个东西。curr不等于null，因为那里有一个节点。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="6e76" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们向右移动头部指针1。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/43cb1f087c337b62b652d4602dbc1182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cf6j4zPjrkEeIvvfdbPwow.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">We have moved the head pointer to the right</figcaption></figure><p id="1565" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还将head.prev设置为null。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="769b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们移除curr.next的指针</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/f20c38a7143d33d98ae85f623027c5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TQS4dmYjQji0quKcQR4uQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The Curr node is completely disconnected from the linked list.</figcaption></figure><p id="d980" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们让这个节点坐在一个空间里，什么也不做。我们返回这个节点，以防我们想用它做别的事情。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="a20d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就是这样！该节点不再连接到链表，因此使其“被删除”。</p><h1 id="9402" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">将项目插入链接列表</h1><p id="b2ef" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">链表的真正强大之处在于能够在其中的任何地方插入条目。</p><p id="3d9c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在链表中的任意位置插入一个项类似于在头部插入一个项。你只是改变了几个变量，想法还是一样的。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="a43e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每当我们想要插入一个新的节点时，我们只需要告诉这个节点下一个和前一个节点是什么。</p><h1 id="7d79" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">搜索链接列表</h1><p id="82b8" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">链表通常是排序的。项目可以插入链表中的任何位置，所以把它们放在正确的位置是有意义的。如果你有一个数据为3，4，6的链表，程序员可能会把包含5的新节点放在4和6之间。但这完全取决于程序员。</p><p id="27f1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以用二分搜索法来搜索名单。但是，这是个坏主意。我们不知道链表的中间在哪里。每次我们想找到中间的节点时，我们都必须计算列表中的每一个节点，然后用2减去一半。</p><p id="5ab9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以使用顺序搜索的修改版本来搜索链表。</p><p id="2864" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设链表是按升序排序的。我们可以利用这些信息加快顺序搜索的速度。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="0042" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为链表是按顺序排序的，我们知道链表中的节点是按一定的顺序排列的，比如1，2，3，4，5。如果node.data比键(我们正在寻找的)多，我们知道它不在列表中，因为它是排序的。</p><p id="8ab1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，如果我们想找到2.5，我们会这样做:</p><pre class="le lf lg lh fq nd ne nf ng aw nh dt"><span id="8c08" class="ni kg hu ne b fv nj nk l nl nm">1 is selected</span><span id="49d1" class="ni kg hu ne b fv nn nk l nl nm">is 1 goal? - no</span><span id="1610" class="ni kg hu ne b fv nn nk l nl nm">is 1 &gt; 2.5? no</span><span id="7fdd" class="ni kg hu ne b fv nn nk l nl nm">2 is selected</span><span id="be8a" class="ni kg hu ne b fv nn nk l nl nm">is 2 goal? no</span><span id="6f3f" class="ni kg hu ne b fv nn nk l nl nm">is 2 &gt; 2.5? no</span><span id="e5fd" class="ni kg hu ne b fv nn nk l nl nm">3 is selected</span><span id="8a99" class="ni kg hu ne b fv nn nk l nl nm">is 3 goal? no</span><span id="1b80" class="ni kg hu ne b fv nn nk l nl nm">is 3 &gt; 2.5? yes - we can assume 2.5 is not in list and thus end the search here</span></pre><p id="16fd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有许多搜索算法。但是大多数时候，如果你知道一点点关于数据的信息，你可以改变搜索算法，使其更有效。总的来说，二分搜索法是非常有效的，但在这里它不是那么好。不要使用一种算法，因为栈溢出说它是最快的，最好的算法。</p><p id="805b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">算法就像编程语言。我们都有自己喜欢的语言，有时我们会说一种编程语言比另一种好(Python，我爱你)。但是说到底，说一种编程语言比其他所有语言都好是愚蠢和幼稚的。使用适合工作的工具，如果你想改变它！</p><h1 id="b483" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">区块链</h1><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="ab fr cl no"><img src="../Images/0e4435c72a12479c2a0a718332402d7b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*qYKsqQ6aV-DgFD0REfcnig.png"/></div></figure><p id="8cbd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回到区块链科技。之前我说过:</p><blockquote class="np nq nr"><p id="70a6" class="jh ji ns jj b jk jl jm jn jo jp jq jr nt jt ju jv nu jx jy jz nv kb kc kd ke hn dt translated">区块链是一个不可变的、有序的、反向链接的事务块列表。</p></blockquote><p id="0dfd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以让我们来解决这个问题。</p><p id="cdf8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">区块链是不可改变的。理论上你不能改变区块链。这是可能的，但非常非常难做到，尤其是对于像比特币的区块链这样的区块链。</p><p id="e4e3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">区块链是按照最频繁的交易来排序的，位于链的“顶端”。或者最频繁的交易在最右边。</p><p id="e201" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">区块链被“向后”链接，引用链中的前一个块。每个块都引用它后面的块。</p><p id="f8c5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个块都是一个事务。</p><p id="a854" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，您应该对链表及其工作原理有了很深的理解。你还应该理解区块链的链表部分。</p><h1 id="e162" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">如果你喜欢这篇文章，请联系我！</h1><p id="1426" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated"><a class="ae jg" href="https://www.linkedin.com/in/brandonls/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae jg" href="https://twitter.com/brandon_skerrit" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae jg" href="http://brandonskerritt.github.io/" rel="noopener ugc nofollow" target="_blank">网站</a> | <a class="ae jg" href="https://upscri.be/885736-2/" rel="noopener ugc nofollow" target="_blank">简讯</a></p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="nw mg l"/></div></figure></div></div>    
</body>
</html>