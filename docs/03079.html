<html>
<head>
<title>Always return JSON with Laravel API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">总是用Laravel API返回JSON</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/always-return-json-with-laravel-api-870c46c5efb2?source=collection_archive---------3-----------------------#2018-04-08">https://medium.com/hackernoon/always-return-json-with-laravel-api-870c46c5efb2?source=collection_archive---------3-----------------------#2018-04-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/60904f22b82bf1bd312ece88d5d26d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*2f_ubcCK3g4zbzgfQp_VFA.png"/></div></figure><div class=""/><p id="ec11" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我最近开始做一些小项目，这些项目将只使用Laravel的后端部分。我们首先遇到的事情之一是试图重定向到<code class="eh jw jx jy jz b">/home</code>或<code class="eh jw jx jy jz b">/login</code>的认证异常。这种重定向成为另一个例外:<code class="eh jw jx jy jz b">InvalidArgumentException: Route [login] is not defined.</code>。当您只想处理API响应时，这里有一个非常简单的解决方案。</p><h2 id="c696" class="ka kb ib bd kc kd ke kf kg kh ki kj kk jj kl km kn jn ko kp kq jr kr ks kt ku dt translated">1-写一个新的<code class="eh jw jx jy jz b">BaseRequest</code></h2><p id="2c16" class="pw-post-body-paragraph iy iz ib ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">通过扩展Laravel请求对象，我们可以覆盖框架使用的方法，该框架决定是否给出重定向响应或JSON响应，以始终首选JSON。</p><figure class="la lb lc ld fq hw"><div class="bz el l di"><div class="le lf l"/></div></figure><h2 id="e21c" class="ka kb ib bd kc kd ke kf kg kh ki kj kk jj kl km kn jn ko kp kq jr kr ks kt ku dt translated">2-交换实现</h2><p id="41be" class="pw-post-body-paragraph iy iz ib ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">在<code class="eh jw jx jy jz b">public/index.php</code>内部，我们可以找到Laravel构建请求对象的地方。让我们用新的<code class="eh jw jx jy jz b">BaseRequest</code>类替换<code class="eh jw jx jy jz b">\Illumiate\Http\Request</code>。</p><pre class="la lb lc ld fq lg jz lh li aw lj dt"><span id="ed07" class="ka kb ib jz b fv lk ll l lm ln">$response = $kernel-&gt;handle(<br/>    $request = \App\Http\Requests\BaseRequest::<em class="lo">capture</em>()<br/>);</span></pre><h2 id="f893" class="ka kb ib bd kc kd ke kf kg kh ki kj kk jj kl km kn jn ko kp kq jr kr ks kt ku dt translated">3-搞定！</h2><p id="8472" class="pw-post-body-paragraph iy iz ib ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">就这么简单，现在任何HTTP请求都将被当作它想要的响应<code class="eh jw jx jy jz b">application/json</code>。不再有重定向异常。</p><h2 id="1287" class="ka kb ib bd kc kd ke kf kg kh ki kj kk jj kl km kn jn ko kp kq jr kr ks kt ku dt translated">更新</h2><p id="4e3e" class="pw-post-body-paragraph iy iz ib ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated"><a class="lp lq gr" href="https://medium.com/u/af8b18bcd4e3?source=post_page-----870c46c5efb2--------------------------------" rel="noopener" target="_blank"> Alexander Lichter </a>有一个杀手级的单行中间件可以达到同样的效果。点击查看他的解决方案<a class="ae lr" href="https://twitter.com/TheAlexLichter/status/969879256271597568" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>