<html>
<head>
<title>Java is too old, What should you learn in 2018?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java太老了，2018年该学什么？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/java-is-too-old-what-should-you-learn-in-2018-12cd0151b2d1?source=collection_archive---------4-----------------------#2018-04-09">https://medium.com/hackernoon/java-is-too-old-what-should-you-learn-in-2018-12cd0151b2d1?source=collection_archive---------4-----------------------#2018-04-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/a7931e0c70a72076c23b2fd038a39ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*TAnKZzCNpH1Vb87FZJCznQ.jpeg"/></div></figure><div class=""/><p id="63ef" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Java已经成为遗产。它不可能在保持向后兼容性的同时发展成一种现代语言。但它给了我们一个美妙的JVM生态系统，并创造了许多优秀的语言Groovy、Scala、Clojure、Kotlin。</p><h1 id="038a" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">欢迎最新的婴儿科特林</h1><p id="fa99" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin诞生于2011年，但在去年谷歌宣布将其作为Android的官方语言后，它开始流行起来。Kotlin带来了许多其他JVM语言的强大特性。让我们快速浏览一下Kotlin给Java开发人员带来的好处。</p><h2 id="1ca8" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">永远不要担心NPEs</h2><p id="8cc4" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">每个Java程序员都讨厌在运行时抛出空指针异常。Kotlin提供了一流的支持，以避免编译时的空引用。默认情况下，所有对象都是不可空的，你必须使用<code class="eh ln lo lp lq b">? </code>操作符来定义可空的类型。编译器会强迫你使用安全的调用操作符<code class="eh ln lo lp lq b">?.</code>来访问可空的对象。你也可以使用埃尔维斯运算符<code class="eh ln lo lp lq b">?:</code>来分配默认值。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="4c8c" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">不需要提供显式类型声明。</h2><p id="0e0e" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin自动推断类型，所以不需要显式声明。您可以简单地使用<code class="eh ln lo lp lq b">val</code>定义最终变量，使用<code class="eh ln lo lp lq b">var</code>定义非最终变量。只有在声明和赋值都在单个语句中完成时，才能推断出注释类型。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="dfc3" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">避免复杂的字符串格式。</h2><p id="7bfa" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">在Kotlin中，您可以使用字符串模板来简化字符串的格式化。<code class="eh ln lo lp lq b">$</code>用于引用变量，您可以将<code class="eh ln lo lp lq b">${}</code>用于复杂表达式</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="75fb" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">创建简单的POJOs不需要锅炉板代码。</h2><p id="490f" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin为用于简单保存值的对象提供了<code class="eh ln lo lp lq b">data</code>类。它自动为数据类生成<code class="eh ln lo lp lq b">equals</code>、<code class="eh ln lo lp lq b">hashCode</code>、<code class="eh ln lo lp lq b">toString</code>、<code class="eh ln lo lp lq b">copy</code>、<code class="eh ln lo lp lq b">getters</code>和<code class="eh ln lo lp lq b">setters</code>(对于定义为<code class="eh ln lo lp lq b">var</code>的属性)方法。您还可以对数据类进行对象解构，以提取变量的属性。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="d408" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">您可以避免生成器类和多余的方法重载。</h2><p id="02b1" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin支持命名方法参数，因此在大多数情况下，您不需要创建构建器。此外，Kotlin支持默认方法参数，因此您不需要创建冗余的重载方法来传递默认值。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="cb1c" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">您不再需要guava库来静态初始化集合。</h2><p id="36b1" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin提供了使用<code class="eh ln lo lp lq b">listOf</code>、<code class="eh ln lo lp lq b">mapOf</code>、<code class="eh ln lo lp lq b">setOf</code>方法内联初始化集合的简洁方法。地图还支持直观的语法<code class="eh ln lo lp lq b">key to value</code>进行初始化。它还提供了对映射键、值的解构，以便于迭代。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="4c77" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">你不需要复杂的方法来创建单例。</h2><p id="24d1" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin支持<code class="eh ln lo lp lq b">object</code>声明，在单行中创建单例。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="c550" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">你不需要不必要的局部变量</h2><p id="1ded" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">在Kotlin中，像<code class="eh ln lo lp lq b">try</code>和<code class="eh ln lo lp lq b">when</code>这样的结构是返回值的表达式。例如，你可以将<code class="eh ln lo lp lq b">try</code>的结果赋给一个变量，而不是创建一个局部变量。同理对于<code class="eh ln lo lp lq b">when</code>也可以作为表达式使用。<code class="eh ln lo lp lq b">when</code>相当于Java中的<code class="eh ln lo lp lq b">switch</code>，但功能强大得多。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="6f6c" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">您将避免类强制转换异常。</h2><p id="48cf" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin提供了<code class="eh ln lo lp lq b">is</code>操作符(相当于Java中的<code class="eh ln lo lp lq b">instanceOf</code>)来检查对象是否为特定类型。使用<code class="eh ln lo lp lq b">is</code>操作器会自动为你铸造。这将防止在转换为错误类型时出现类转换异常。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="40ed" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">您不需要重复变量名来调用同一对象中的序列方法。</h2><p id="b74e" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin提供了<code class="eh ln lo lp lq b">with</code>构造来轻松调用同一对象上的方法序列，而不必重复变量名。在Java中，我们通常使用构建器模式和方法链接。Kotlin使类似的事情变得简单，甚至对非构建类也是如此。</p><p id="f529" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Kotlin也提供了<code class="eh ln lo lp lq b">apply</code>扩展函数来实现同样的事情。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="60c9" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">使用委托或装饰模式不需要样板代码。</h2><p id="88d8" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">为了支持组合而不是继承，我们经常使用委托或装饰模式，但是我们必须在包装类中复制委托类的每个方法。Kotlin使用<code class="eh ln lo lp lq b">by</code>操作符为简化委托提供了一流的支持。它会自动实现必要的方法来调用委托类的方法。当然，您可以在需要时覆盖特定的方法。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="6f2f" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">你不需要一个类来创建静态函数。</h2><p id="0a4e" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin支持类之外的函数，因此您不需要仅为静态实用函数创建一个类。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="f51f" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">修改lambdas中的非final变量不需要黑客。</h2><p id="4a8c" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Java通过用匿名内部类自动替换lambda来支持它，但是不能在lambdas内部修改非final变量。但是在Kotlin中，你也可以在lambda中修改非最终变量。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="7253" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">懒装不需要努力。</h2><p id="a577" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin提供了一种非常简单的方法来使用<code class="eh ln lo lp lq b">lazy</code>关键字惰性地初始化一个属性。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="85cd" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">你不必完全转换到一种新的语言。</h2><p id="0f21" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin与Java无缝互操作，因此您可以轻松地与遗留Java代码集成。您可以继续利用第三方Java库和框架。与Scala不同，Kotlin没有自己的收藏库，但扩展了JDK收藏。所以不需要编写glue代码在Java和Kotlin集合类型之间进行转换。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="a01a" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">您可以编写简洁且可读性更强的代码。</h2><p id="be78" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin使用方法名称约定来重载许多操作符以提高可读性。例如方法<code class="eh ln lo lp lq b">plus</code>用于重载<code class="eh ln lo lp lq b">+</code>运算符，<code class="eh ln lo lp lq b">minus</code>用于重载<code class="eh ln lo lp lq b"> -</code>运算符，<code class="eh ln lo lp lq b">times</code>用于重载<code class="eh ln lo lp lq b">*</code>运算符，<code class="eh ln lo lp lq b">div</code>用于重载<code class="eh ln lo lp lq b"> / </code>运算符，以此类推。它支持重载更多像<code class="eh ln lo lp lq b">%, += , +- , ++,--</code>这样的操作符</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="55a5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Kotlin提供了使用<code class="eh ln lo lp lq b">..</code>操作符定义范围的简洁方法。它还提供了用于排除边界的<code class="eh ln lo lp lq b">until</code>关键字和用于跳过项目的<code class="eh ln lo lp lq b">step</code>运算符。它有<code class="eh ln lo lp lq b">in</code>操作员检查范围内的东西。我们也可以通过实现<code class="eh ln lo lp lq b">rangeTo</code>和<code class="eh ln lo lp lq b">contains</code>方法来重载<code class="eh ln lo lp lq b">..</code>操作符和<code class="eh ln lo lp lq b">in</code>操作符。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h2 id="64c7" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">您可以轻松地扩展现有的JDK类。</h2><p id="fb9b" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">Kotlin支持向现有类添加扩展函数的简单方法。这是一个非常强大的功能，可以帮助我们轻松地扩展核心语言API。</p><figure class="lr ls lt lu fq hw"><div class="bz el l di"><div class="lv lw l"/></div></figure><h1 id="89ef" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">为什么要使用Kotlin？</h1><h2 id="8e08" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">它能成倍提高你的生产力</h2><ul class=""><li id="0014" class="lx ly ib ja b jb ku jf kv jj lz jn ma jr mb jv mc md me mf dt translated">它是静态类型的语言，所以你会在编译时发现很多错误。</li><li id="eaaf" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">它有强大的工具支持。毫无疑问，它是由IDE公司开发的</li><li id="089e" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">它是由JetBrains创建的，JetBrains是一家关注开发人员生产力的IDE公司。</li><li id="23f0" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">避免Java开发人员的许多日常挫折。</li></ul><h2 id="871a" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">默认情况下，您会受益于许多最佳实践(来自<a class="ae ml" href="https://amzn.to/2qi8VRv" rel="noopener ugc nofollow" target="_blank"> Effective Java Book </a>的原则)。</h2><ul class=""><li id="e362" class="lx ly ib ja b jb ku jf kv jj lz jn ma jr mb jv mc md me mf dt translated">所有课程都是最终的。</li><li id="162c" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">集合是不可变的。</li><li id="00df" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">覆盖强制关键字，而不是可选注释</li><li id="5788" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">没有已检查的异常</li><li id="6e2d" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">没有原始类型</li><li id="3f43" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">更干净的泛型支持。</li></ul><h2 id="eaa7" class="kz jx ib bd jy la lb lc kc ld le lf kg jj lg lh kk jn li lj ko jr lk ll ks lm dt translated">非JVM支持。</h2><ul class=""><li id="02e0" class="lx ly ib ja b jb ku jf kv jj lz jn ma jr mb jv mc md me mf dt translated">Kotlin还编译成Javascript用于前端开发。</li><li id="f6b0" class="lx ly ib ja b jb mg jf mh jj mi jn mj jr mk jv mc md me mf dt translated">他们还致力于添加本地运行时，使其在没有JVM的情况下运行。</li></ul><h1 id="71fd" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">你应该换成科特林吗？</h1><p id="c30f" class="pw-post-body-paragraph iy iz ib ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">科特林很棒，但还不够完美。进化成一门伟大的语言需要一些时间。JetBrains和Google都在积极支持Kotlin，所以你可以肯定它只会变得更好。</p><p id="cf86" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你是Android开发者，你应该立即开始使用Kotlin。</p><p id="527c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你是一名Java开发人员，你可能需要考虑其他因素，比如团队成员、公司采用等。但即使不能马上使用，也绝对要学习这种现代的美。</p><p id="2993" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，根据thoughtworks技术雷达，公司可以在能够处理一些风险的项目中进行尝试。</p><p id="93b8" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja ic"><em class="mm">2018 . 10 . 10更新:</em> </strong></p><p id="55b0" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Kotlin在<a class="ae ml" href="https://www.thoughtworks.com/radar/languages-and-frameworks" rel="noopener ugc nofollow" target="_blank">thoughtworks technology radar</a>中的<strong class="ja ic"> <em class="mm">试用</em> </strong>升级为<strong class="ja ic"> <em class="mm">采用</em> </strong>类别，因此公司可以在适当的时候在项目中采用使用kotlin。</p><h1 id="f2f2" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">参考</h1><div class="ht hu fm fo hv mn"><a rel="noopener follow" target="_blank" href="/mindorks/should-i-learn-kotlin-or-stick-to-java-3a73c3580ac3"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd ic fv z el ms eo ep mt er et ia dt translated">我应该学习Kotlin还是坚持Java？</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">在GoogleIO 2017中，谷歌宣布Kotlin作为Android开发的官方语言。某著名开发商…</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">medium.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb hx mn"/></div></div></a></div><p id="5ee3" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae ml" href="https://amzn.to/2qiL8Ro" rel="noopener ugc nofollow" target="_blank">科特林在行动书</a>作者<a class="ae ml" href="https://www.amazon.com/s/ref=dp_byline_sr_book_1?ie=UTF8&amp;text=Dmitry+Jemerov&amp;search-alias=books&amp;field-author=Dmitry+Jemerov&amp;sort=relevancerank" rel="noopener ugc nofollow" target="_blank">德米特里·杰梅罗夫</a>(作者)<a class="ae ml" href="https://www.amazon.com/s/ref=dp_byline_sr_book_2?ie=UTF8&amp;text=Svetlana+Isakova&amp;search-alias=books&amp;field-author=Svetlana+Isakova&amp;sort=relevancerank" rel="noopener ugc nofollow" target="_blank">斯韦特兰娜·伊萨科娃</a>(作者)</p></div><div class="ab cl nc nd hc ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hn ho hp hq hr"><p id="196f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你喜欢这篇文章，请鼓掌，这样会有更多的观众看到。我正计划写一些关于Kotlin特征的深度文章。如果你想了解更多关于科特林的内容，请关注我，这样你会得到新故事的通知。</p></div></div>    
</body>
</html>