<html>
<head>
<title>Gambling &amp; Probability (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">赌博与概率(Python)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/gambling-probability-python-dfd3e301b1ad?source=collection_archive---------13-----------------------#2018-04-09">https://medium.com/hackernoon/gambling-probability-python-dfd3e301b1ad?source=collection_archive---------13-----------------------#2018-04-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/8a6e6c7f7cbebd594afc307851a0cb95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yyIDj96HTULiL4Qk.png"/></div></figure><div class=""/><p id="ca96" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我最近对某些结果的概率产生了兴趣。Python为我们提供了一种测试场景的好方法，通过允许你运行特定场景数百万次，并计算特定结果发生的次数，来查看特定场景发生的可能性..以抛硬币为例。我们可能有兴趣看到任何给定的掷硬币结果是正面还是反面的概率。我们可以掷一百万次硬币，找出每种情况的可能性。</p><p id="75b7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在掷硬币等情况下，结果很大程度上取决于在两种或多种可能性之间的随机选择。Python包括一个名为‘random’的库，你可以通过<code class="eh jw jx jy jz b">import random</code>导入这个库来使用。使用random，我设置了一个脚本来确定正面或反面的概率，并将该场景运行了一百万次。我发现了以下内容:</p><p id="13e4" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">总人数:499588人</p><p id="3bad" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">总尾数:500，412</p><p id="bb25" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最多的头像:19个</p><p id="3c66" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">连续最多的尾巴:19条</p><p id="b95c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">很有趣吧？这提供了一些有用的见解，因为知道任何事情的特定运行的概率，将帮助我们确定在每个硬币被投掷之后增加我们的赌注多少。</p><p id="a6a6" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">于是，我决定变得复杂一点，用Python建立一个模拟21点游戏的测试。现在，我没有同时给庄家和玩家编程，所以从技术上来说这不是一个真正的游戏。然而我想知道的是，在前两张牌发完之后，得到任何特定值的概率。那么，在100万回合中，前两张牌加起来是2，还是3，还是4等等的概率是多少？</p><p id="6e1e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这本身就产生了一个有趣的问题，因为Ace的值可以是1或11，所以在我确定Ace的值之前，如果它出现在手中，我想先浏览一下代码。</p><p id="0a1b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你想继续，这是我的项目github:【https://github.com/ethanjarrell/blackJackPython<a class="ae ka" href="https://github.com/ethanjarrell/blackJackPython" rel="noopener ugc nofollow" target="_blank"/></p><p id="73a0" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，为了使用确定一张新卡，我知道我会想要随机库，所以在我的页面顶部，我再次导入随机。</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="9cb2" class="kj kk ib jz b fv kl km l kn ko">import random<br/>iterations = 1000000</span></pre><p id="769f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我还创建了一个名为迭代的变量。如果我想运行100万次，或者仅仅100次，我可以在这里改变这个变量，而不是在整个脚本中的多个位置改变我的算法。</p><p id="9094" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我将创建一个名为<code class="eh jw jx jy jz b">sumValue</code>的变量。基本上，我要记录的是每张牌抽完之后的总数。前两张牌抽完后，我要初始金额。然后，如果我抽第三张牌，我只想知道当前和是否超过21。第四次抽牌时也是一样。</p><p id="f7de" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这有助于我把事情画出来，所以我的想法是这样的:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="fe ff kp"><img src="../Images/0e8de5f5b39f86a74a5dbd6c1bed7779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPZyZuBCIpmh8tcmE4rlNw.png"/></div></div></figure><p id="dbef" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">根据前两张卡片的初始值，我想知道一些事情，比如总数出现的次数。所以前两张卡是什么并不重要，重要的是总数出现的频率。然后，根据最初的总数，我想知道我每次抽牌超过21的机会有多大。在这里，我只是编造了这些数字，但这是基本的想法。</p><p id="dd0d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">将这种想法转化为Python，似乎最好的跟踪方式是使用一系列列表。2，3，4，5，6等等都将是一个Python列表，然后当我抽牌并获得新的值时，我会添加到那个列表中。有点像这样:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="fe ff ku"><img src="../Images/e9431bda04ac0849770074f95b905fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCAEmEqPuxFdZ8k_Gcj4-A.png"/></div></div></figure><p id="9dc8" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以回到我的<code class="eh jw jx jy jz b">sumValue</code>变量，<code class="eh jw jx jy jz b">sumValue</code>将是一个列表的列表。每个子列表的大部分都是占位符数字，我将把它们设置为零。</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="4fdf" class="kj kk ib jz b fv kl km l kn ko">sumValue = [["2: ", 0, 0, 0, 0, 0, 0, 0, 0], ["3: ", 0, 0, 0, 0, 0, 0, 0, 0], ["4: ", 0, 0, 0, 0, 0, 0, 0, 0], ["5: ", 0, 0, 0, 0, 0, 0, 0, 0], ["6: ", 0, 0, 0, 0, 0, 0, 0, 0], ["7: ", 0, 0, 0, 0, 0, 0, 0, 0], ["8: ", 0, 0, 0, 0, 0, 0, 0, 0], ["9: ", 0, 0, 0, 0, 0, 0, 0, 0], ["10: ", 0, 0, 0, 0, 0, 0, 0, 0], ["11: ", 0, 0, 0, 0, 0, 0, 0, 0], ["12: ", 0, 0, 0, 0, 0, 0, 0, 0], ["13: ", 0, 0, 0, 0, 0, 0, 0, 0], ["14: ", 0, 0, 0, 0, 0, 0, 0, 0], ["15: ", 0, 0, 0, 0, 0, 0, 0, 0], ["16: ", 0, 0, 0, 0, 0, 0, 0, 0], ["17: ", 0, 0, 0, 0, 0, 0, 0, 0], ["18: ", 0, 0, 0, 0, 0, 0, 0, 0], ["19: ", 0, 0, 0, 0, 0, 0, 0, 0], ["20: ", 0, 0, 0, 0, 0, 0, 0, 0], ["21: ", 0, 0, 0, 0, 0, 0, 0, 0], ["21+: ", 0, 0, 0, 0, 0, 0, 0, 0]]</span></pre><p id="0ef6" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如您所见，每个子列表有8个索引。下面是我打算如何使用每个索引:</p><p id="df2c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">索引0:当前列表。</p><p id="95d1" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">索引1:该列表的值在2张牌后出现的次数。</p><p id="a42d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">索引2:该值在2张牌后出现的次数百分比。</p><p id="7a0f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">指数3:抽第三张牌的次数，并且总数不超过21。</p><p id="93f4" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">指数4:这个和不超过21的次数的百分比，基于初始和。</p><p id="4320" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">指数5:抽取第四张牌的次数，并且总数不超过21。</p><p id="2d53" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">指数6:这个和不超过21的次数百分比，基于初始和。</p><p id="30b9" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">指数7:抽第五张牌的次数，并且总数不超过21。</p><p id="8f14" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">指数8:基于初始总和，该总和不超过21的次数的百分比。</p><p id="2432" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请随意检查我的github，并给我一些关于我如何生成一切的反馈。这是我得到的输出，非常酷，基于一百万只模拟手:</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="0c79" class="kj kk ib jz b fv kl km l kn ko">['2: ', 4407, 0.4407, 4407, 100.0, 3611, 81.9378261856138, 1622, 44.918305178620884]<br/>['3: ', 12242, 1.2242, 12242, 100.0, 9461, 77.28312367260251, 3754, 39.67868090053906]<br/>['4: ', 16655, 1.6655, 16655, 100.0, 11803, 70.8676073251276, 4461, 37.79547572651021]<br/>['5: ', 24185, 2.4185, 24185, 100.0, 15744, 65.09820136448212, 5311, 33.733485772357724]<br/>['6: ', 28641, 2.8641, 28641, 100.0, 16746, 58.46862888865612, 5186, 30.96858951391377]<br/>['7: ', 36233, 3.6233, 36233, 100.0, 18682, 51.56073192945657, 5175, 27.700460336152446]<br/>['8: ', 40852, 4.0852, 40852, 100.0, 18091, 44.284245569372366, 4668, 25.80288541263612]<br/>['9: ', 48010, 4.801, 44060, 91.77254738596126, 17717, 40.211075805719474, 4134, 23.333521476547947]<br/>['10: ', 52891, 5.2891, 44294, 83.7458168686544, 16580, 37.43170632591322, 3451, 20.814234016887816]<br/>['11: ', 60226, 6.0226, 45693, 75.86922591571746, 15375, 33.64848007353424, 2967, 19.297560975609755]<br/>['12: ', 64898, 6.4898, 44762, 68.97284970261025, 13456, 30.061212635717798, 2244, 16.676575505350772]<br/>['13: ', 72088, 7.2088, 44059, 61.11835534346909, 11615, 26.362377720783496, 1602, 13.792509685751185]<br/>['14: ', 77072, 7.7072, 41540, 53.897654141581896, 9312, 22.416947520462205, 1042, 11.189862542955327]<br/>['15: ', 72808, 7.2808, 33722, 46.31633886386111, 6446, 19.115117727299687, 588, 9.121936084393422]<br/>['16: ', 64783, 6.4783, 25256, 38.98553632897519, 3841, 15.208267342413684, 240, 6.248372819578234]<br/>['17: ', 60308, 6.0308, 18896, 31.3324932015653, 2196, 11.621507197290432, 85, 3.8706739526411655]<br/>['18: ', 52487, 5.2487, 12599, 24.00403909539505, 926, 7.349789665846496, 11, 1.187904967602592]<br/>['19: ', 48301, 4.8301, 7708, 15.958261733711517, 239, 3.1006746237675142, 0, 0.0]<br/>['20: ', 40825, 4.0825, 3244, 7.946111451316595, 0, 0.0, 0, 0]<br/>['21: ', 36151, 3.6151, 0, 0.0, 0, 0, 0, 0]<br/>['21+: ', 85937, 8.5937, 0, 0.0, 0, 0, 0, 0]</span><span id="499a" class="kj kk ib jz b fv kv km l kn ko">[Finished in 29.804s]</span></pre><p id="489b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，这些数据中的大部分看起来很明显，在现实中，你不需要Python来告诉你，当你抽两张低牌时，你不太可能超过21。但是玩着玩着还是很好玩的！</p><p id="c6a8" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可能记得我之前提到过处理ace的问题。该输出反映了将ace仅作为值1而不是11来处理。</p><p id="8902" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我函数的第一部分:</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="a254" class="kj kk ib jz b fv kl km l kn ko">def hand():<br/>    deck = []<br/>    value = range(1, 14)<br/>    for i in value:<br/>       if i == 10 or i == 11 or i == 12 or i == 13:<br/>            i = 10</span><span id="4471" class="kj kk ib jz b fv kv km l kn ko">        d = "D-"+str(i)<br/>        c = "C-"+str(i)<br/>        s = "S-"+str(i)<br/>        h = "H-"+str(i)<br/>        deck.append(d)<br/>        deck.append(c)<br/>        deck.append(s)<br/>        deck.append(h)<br/>    hand = []<br/>    hand2 = []<br/>    card1 = random.choice(deck)<br/>    hand.append(card1)<br/>    if card1 in deck:<br/>        deck.remove(card1)<br/>    card2 = random.choice(deck)<br/>    hand.append(card2)<br/>    if card2 in deck:<br/>        deck.remove(card2)</span><span id="5959" class="kj kk ib jz b fv kv km l kn ko">value1 = int(hand[0].split("-")[1])<br/>    value2 = int(hand[1].split("-")[1])</span></pre><p id="1e3d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">基本上，我的名为<code class="eh jw jx jy jz b">hand()</code>的函数有一个名为deck的列表。因为每个套件都有从1(a)开始到13(k)结束的牌。然而，扑克和21点之间的一个区别是，在扑克中，10的值是10，杰克是11，皇后是12，国王是13。然而，在21点中，杰克、皇后和国王都是10。所以我从1到13的数值范围开始。</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="1233" class="kj kk ib jz b fv kl km l kn ko">value = range(1, 14)</span></pre><p id="5f92" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我遍历它来创建我的卡片，但是，如果值是10到13，我就把它改成10。</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="563d" class="kj kk ib jz b fv kl km l kn ko">for i in value:<br/>       if i == 10 or i == 11 or i == 12 or i == 13:<br/>            i = 10</span></pre><p id="ab56" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，对21点来说，花色并不重要，但只是为了好玩，我也创造了花色。</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="2c36" class="kj kk ib jz b fv kl km l kn ko">        d = "D-"+str(i)<br/>        c = "C-"+str(i)<br/>        s = "S-"+str(i)<br/>        h = "H-"+str(i)<br/>        deck.append(d)<br/>        deck.append(c)<br/>        deck.append(s)<br/>        deck.append(h)</span></pre><p id="842c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这样，当脚本运行时，我们的牌组将在D(方块)中创建4个a，然后在C(梅花)中创建4个a，等等，因为它遍历我的范围。您的输出将如下所示:</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="783c" class="kj kk ib jz b fv kl km l kn ko">['D-1', 'C-1', 'S-1', 'H-1', 'D-2', 'C-2', 'S-2', 'H-2', 'D-3', 'C-3', 'S-3', 'H-3', 'D-4', 'C-4', 'S-4', 'H-4', 'D-5', 'C-5', 'S-5', 'H-5'.......]</span></pre><p id="8e7e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在从一副牌中抽一张牌时，我想确保我不会重复抽任何牌，而且不会两次都抽同一张牌。我在这里的想法是为牌组和手牌各准备一份清单。当我从牌组列表中随机选择一张牌时，我会将它添加到牌组列表中，然后从牌组列表中移除它。像这样:</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="e136" class="kj kk ib jz b fv kl km l kn ko">card1 = random.choice(deck)<br/>    hand.append(card1)<br/>    if card1 in deck:<br/>        deck.remove(card1)</span></pre><p id="2751" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我基本上可以重复同样的代码来计算任意多的抽牌。</p><p id="ab01" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我会思考如何处理Ace卡的值。这是我对此的想法。我会随机抽两张牌，加到手上。然后，如果其中一个值是1 (ace)，我将把值改为11，确保我得到最高的总数。然后，如果两张牌的和大于21，并且任何一张牌都是a，我就把它改成1。我会这样做:</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="7949" class="kj kk ib jz b fv kl km l kn ko">    value1 = int(hand[0].split("-")[1])<br/>    value2 = int(hand[1].split("-")[1])<br/>    if value1 == 1:<br/>        value1 = 11<br/>    if value2 == 1:<br/>        value2 = 11<br/>    sum1 = value1 + value2<br/>    if sum1 &gt; 21 and value2 == 11:<br/>        value2 = 1<br/>        sum1 = value1 + value2<br/>    if sum1 &gt; 21 and value1 == 11:<br/>        value1 = 1<br/>        sum1 = value1 + value2</span></pre><p id="6277" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">由于此时我的列表只有两个值，<code class="eh jw jx jy jz b">hand[0]</code>和<code class="eh jw jx jy jz b">hand[1]</code>代表手牌列表中的两个值。但是，正如我说的，我不需要这个套件，所以我要拆分它，得到拆分的第二部分的整数，如果它是1，就把这个值设置为11。然后得到总和，如果其中一个值是11，如果总和超过21，则将值重置为1。</p><p id="c363" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有趣的是，我们可以看到这对事情的影响有多大。如果没有Ace牌的初始重置，在5000手模拟牌中，有600多手牌的前两张牌都超过了21。但是在添加Ace值调整后，这个数字下降到5000手模拟牌中的300多一点。</p><p id="acdd" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们如何处理ace的值可以调整。例如，我们可能希望等到发了3或4张牌后再检查总数，并在必要时进行ace调整。有趣的是，我们可以看到这种变化如何影响我们的统计数据。例如，我之前提到的输出来自100万手模拟牌，但没有经过ace调整，但这里是经过调整的100万手模拟牌:</p><pre class="kb kc kd ke fq kf jz kg kh aw ki dt"><span id="d71e" class="kj kk ib jz b fv kl km l kn ko">['2: ', 0, 0.0, 0, 0, 0, 0, 0, 0]<br/>['3: ', 0, 0.0, 0, 0, 0, 0, 0, 0]<br/>['4: ', 4499, 0.4499, 4499, 100.0, 3555, 79.01755945765726, 1382, 38.874824191279885]<br/>['5: ', 11950, 1.195, 11950, 100.0, 8737, 73.11297071129707, 2958, 33.85601465033764]<br/>['6: ', 16511, 1.6511, 16511, 100.0, 10815, 65.50178668766277, 3390, 31.345353675450763]<br/>['7: ', 24130, 2.413, 24130, 100.0, 14029, 58.13924575217572, 3971, 28.30565257680519]<br/>['8: ', 28895, 2.8895, 28895, 100.0, 15073, 52.164734383111266, 3712, 24.626816161348106]<br/>['9: ', 36296, 3.6296, 36296, 100.0, 15917, 43.85331716993608, 3419, 21.48017842558271]<br/>['10: ', 40583, 4.0583, 40583, 100.0, 14188, 34.960451420545546, 2718, 19.157034113335214]<br/>['11: ', 48467, 4.8467, 48467, 100.0, 12446, 25.679328202694617, 2456, 19.733247629760566]<br/>['12: ', 93381, 9.3381, 64545, 69.12005654255148, 19480, 30.180494228832597, 3069, 15.754620123203285]<br/>['13: ', 96590, 9.659, 59441, 61.539496842323224, 15431, 25.960195824430947, 2162, 14.010757565938695]<br/>['14: ', 89771, 8.9771, 48436, 53.955063439195285, 10855, 22.411016599223718, 1254, 11.552280055274068]<br/>['15: ', 84662, 8.4662, 38888, 45.93324041482602, 7362, 18.931289858053898, 669, 9.08720456397718]<br/>['16: ', 76903, 7.6903, 30166, 39.22603799591693, 4636, 15.368295431943247, 274, 5.910267471958585]<br/>['17: ', 72024, 7.2024, 22710, 31.531156281239586, 2576, 11.343020695728754, 95, 3.687888198757764]<br/>['18: ', 65253, 6.5253, 15392, 23.588187516282776, 1102, 7.159563409563409, 8, 0.7259528130671506]<br/>['19: ', 59526, 5.9526, 9415, 15.816617948459497, 288, 3.0589484864577803, 0, 0.0]<br/>['20: ', 102666, 10.2666, 8011, 7.802972746576277, 0, 0.0, 0, 0]<br/>['21: ', 47893, 4.7893, 0, 0.0, 0, 0, 0, 0]<br/>['21+: ', 0, 0.0, 0, 0, 0, 0, 0, 0]</span><span id="1d39" class="kj kk ib jz b fv kv km l kn ko">[Finished in 29.911s]</span></pre><p id="7cfc" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如您所见，我们根本得不到任何2或3值，因为我们总是从11而不是1开始。这也略微增加了我们在第3张和第4张牌之后没有超过的可能性。</p><p id="536a" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样，这并不是惊天动地的事情，但是很容易看到构建这样一个简单的函数如何真正帮助我们看到一些很酷的模式。无论如何，我会感谢任何反馈，并祝你未来的赌博好运！</p></div></div>    
</body>
</html>