<html>
<head>
<title>Building an app with Stellar and IPFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与恒星和IPFS一起构建应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-an-app-with-stellar-and-ipfs-7ad57b48fda5?source=collection_archive---------15-----------------------#2018-04-09">https://medium.com/hackernoon/building-an-app-with-stellar-and-ipfs-7ad57b48fda5?source=collection_archive---------15-----------------------#2018-04-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bd7c772d6f83753e8ddc68fc53f969c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHlDicaBHHUXf7UJkOGZ-g.png"/></div></div></figure><p id="a2e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然以太坊一直是编写dApps的首选平台，但可以说<a class="ae ka" href="https://hackernoon.com/tagged/stellar" rel="noopener ugc nofollow" target="_blank"/><a class="ae ka" href="https://hackernoon.com/why-stellar-could-be-the-next-big-ico-platform-f48fc3cb9a6c" rel="noopener ugc nofollow" target="_blank"/>的交易费用非常低，而且比其他区块链(包括以太坊)快得多。</p><p id="2900" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我开始想，用一流的<a class="ae ka" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>来构建一个像HackerNews或Reddit这样的论坛的去中心化版本会是什么样子。以下是我所设想的工作方式:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/28499f73c525c62f5c074ec528340556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rn_Lc8Vcr82erBLu.png"/></div></div></figure><p id="bbd4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看我们将如何去实现它。</p><p id="55a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们需要<a class="ae ka" href="https://www.stellar.org/laboratory/#account-creator?network=test" rel="noopener ugc nofollow" target="_blank">在Stellar testnet上创建一个账户</a>。什么是测试网？用最简单的话来说，这是一个区块链，旨在测试你不会产生任何实际费用。在这种情况下，我们将用10k假流明加载我们的测试帐户进行测试。</p><p id="a862" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将构建一个小的JavsScript客户端，允许用户在应用程序上提交帖子。</p><p id="8cd6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以直接获取这篇文章，并让用户通过将它放在交易的备忘录字段中，将其发送到我们应用程序的帐户。尽管Stellar的交易只允许有限的备忘录格式——文本(最多28字节的UTF-8字符串)、ID(无符号64位整数)或哈希(十六进制格式的32字节哈希)。所以存储大量的文本或JSON是不可能的。</p><p id="d94c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">把它寄到IPFS </strong></p><p id="8156" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是IPFS的用武之地——一种P2P协议和网络，旨在跨所有设备存储和共享分布式文件系统中的内容(可以将其视为git和BitTorrent的私生子)。</p><p id="8381" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将获取这些数据，并将其存储在IPFS的一个JSON对象中。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="05d6" class="kl km hu kh b fv kn ko l kp kq">import ipfsAPI from 'ipfs-api'</span><span id="37ec" class="kl km hu kh b fv kr ko l kp kq">// I'm just using an IPFS gateway here for testing but in a real-world setting, we would run our own IPFS node so we can persist data<br/>const ipfs = ipfsAPI({ host: 'ipfs.infura.io', port: 5001, protocol: 'https' });<br/>const post = JSON.stringify({title: "'So exited!!!', content: 'This is my first post on the blockchain!', username: 'h4ck3r'})"<br/>const buffer = Buffer.from(post);</span><span id="d51d" class="kl km hu kh b fv kr ko l kp kq">ipfs.files.add(buffer, { pin: false }, (err, ipfsHash) =&gt; {<br/>  console.log(ipfsHash[0].path) // =&gt; QmV3C3HFE8824KWYTMq5fbZyF93GTMz5W7h3uBG1oVZCv8<br/>});</span></pre><p id="c79d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有了一个足够小的散列值，可以在memo字段中发送。虽然看起来可能有另一个问题。IPFS使用Base58编码的<a class="ae ka" href="https://multiformats.io/multihash/" rel="noopener ugc nofollow" target="_blank">multi hash</a><a class="ae ka" href="https://multiformats.io/" rel="noopener ugc nofollow" target="_blank">multi format</a>表示文件和对象的散列。前缀<code class="eh ks kt ku kh b">Qm</code>对应于IPFS使用的算法(SHA-256)和长度(32字节)。</p><p id="1ef9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，看起来我们不能将它添加到我们的事务的文本字段中，该字段只允许最多28字节的字符串，我们也不能使用只允许32字节哈希的哈希字段。</p><p id="701c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们必须编写一个函数，将这个IPFS散列转换回十六进制格式的32字节散列:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="63cf" class="kl km hu kh b fv kn ko l kp kq">import bs58 from 'bs58'</span><span id="6a2d" class="kl km hu kh b fv kr ko l kp kq">this.getBytes32FromIpfsHash = (ipfsListing) =&gt; {<br/>  // Decode the base58 string and then slice the first two bytes<br/>  // which represent the function code and it's length, in this case:<br/>  // function:0x12=sha2, size:0x20=256 bits<br/>  return bs58.decode(ipfsListing).slice(2).toString('hex')<br/>}</span></pre><p id="a05f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">加在区块链上</strong></p><p id="531a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们已经有了存储在memo字段中的正确散列，我们就必须弄清楚如何实际发送这个事务。一个选项是提示用户使用<a class="ae ka" href="https://pay.meta.re/" rel="noopener ugc nofollow" target="_blank"> MetaPay </a>，这是一个恒星的Chrome扩展钱包(有点像恒星流明的MetaMask)。一旦他们安装了MetaPay，我们就可以像这样设置一个URL:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="8825" class="kl km hu kh b fv kn ko l kp kq">&lt;a ref='savePost' data-meta-pay<br/>    href="https://stellar.meta.re/transaction?to=[address]&amp;amount=1&amp;memo=[txMemo]" target="_blank" &gt;Save Post&lt;/a&gt;</span></pre><p id="3e8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果我们将所有这些放在一起，提交帖子的逻辑将如下所示:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="6328" class="kl km hu kh b fv kn ko l kp kq">import StellarSdk from 'stellar-sdk'</span><span id="5210" class="kl km hu kh b fv kr ko l kp kq">// Add the post data to IPFS<br/>this.submitPost = (post) =&gt; {<br/>  const buffer = Buffer.from(post);<br/>  ipfs.files.add(buffer, (err, ipfsHash) =&gt; {<br/>    this.txMemo = this.getBytes32FromIpfsHash(ipfsHash[0].path)<br/>    this.refs['savePost'].click() // This will open the MetaPay popup<br/>    this.confirmPayment(this.txMemo) // Listen to see if the transaction went through<br/>  });<br/>}</span><span id="5980" class="kl km hu kh b fv kr ko l kp kq">// Check to see if the transaction went through<br/>this.confirmPayment = (ipfsHash) =&gt; {<br/>  const server = new StellarSdk.Server('https://horizon-testnet.stellar.org');</span><span id="cef3" class="kl km hu kh b fv kr ko l kp kq">  server.transactions().forAccount('OUR_ACCOUNT_ID').cursor('now').stream({<br/>    onmessage: (transaction) =&gt; {<br/>      if(transaction.memo == ipfsHash) {<br/>        // Yes, it made it on the blockchain!<br/>        transaction.operations().then((ops) =&gt; {<br/>          var payment = ops._embedded.records[0];<br/>          if(parseInt(parseFloat(payment.amount)) &lt; 1) { <br/>            console.error('Payment insufficient. Post not saved!');<br/>          } else { <br/>            this.pinIpfsListing(ipfsHash); <br/>          }<br/>        }).catch((error) =&gt; {<br/>          error.target.close(); // Close stream<br/>          console.error('Payment Error: ', error);<br/>          alert('Error confirming payment. Try again later');<br/>        });<br/>      }<br/>    },<br/>    onerror: (error) =&gt; {<br/>      error.target.close(); // Close stream<br/>      console.error('Streaming Error: ', error);<br/>    }<br/>  });<br/>}</span></pre><p id="d41a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将打开带有所有预填充字段的MetaPay弹出窗口，我们将等待并查看用户是否完成该交易，如果是，我们将进入下一步。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kv"><img src="../Images/6502f3f73aeffb2c994add59eecdb313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/0*JMSgluMyBqrQkk_N.png"/></div></figure><p id="ba3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">坚持在IPFS </strong></p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="4fd2" class="kl km hu kh b fv kn ko l kp kq">// If successful, pin our post on the IPFS node<br/>this.pinIpfsListing = (ipfsHash) =&gt; {<br/>  ipfs.pin.add(ipfsHash)<br/>}</span></pre><p id="5b70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，当我们将数据添加到IPFS时，我们没有锁定它。如果不锁定帖子，我们的数据将不会永久存储在IPFS节点上，最终将被垃圾收集。</p><p id="d460" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在某种程度上，小额交易费有助于我们支付锁定数据/运行IPFS节点的成本，并确保数据可供所有用户使用。</p><p id="657b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">从区块链上读取&amp;在IPFS上找到</strong></p><p id="61b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，当其他用户访问该应用程序时，我们将提取发布到该应用程序帐户的所有交易，获取memo字段，将其编码回Base58，并从IPFS提取数据:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="93bd" class="kl km hu kh b fv kn ko l kp kq">import StellarSdk from 'stellar-sdk'<br/>import ipfsAPI from 'ipfs-api'</span><span id="b5d0" class="kl km hu kh b fv kr ko l kp kq">this.getIpfsHashFromBytes32 = (bytes32Hex) =&gt; {<br/>  // Add our default ipfs values for first 2 bytes:<br/>  // function:0x12=sha2, size:0x20=256 bits<br/>  const hashHex = "1220" + bytes32Hex<br/>  const hashBytes = Buffer.from(hashHex, 'hex');<br/>  const hashStr = bs58.encode(hashBytes)<br/>  return hashStr<br/>}</span><span id="7c40" class="kl km hu kh b fv kr ko l kp kq">const server = new StellarSdk.Server('https://horizon-testnet.stellar.org');<br/>const ipfs = ipfsAPI({ host: 'ipfs.infura.io', port: 5001, protocol: 'https' });<br/>let posts = [];</span><span id="21d3" class="kl km hu kh b fv kr ko l kp kq">server.transactions()<br/>  .forAccount('OUR_ACCOUNT_ID')<br/>  .order('desc')<br/>  .call()<br/>  .then((page) =&gt; {<br/>    page.records.forEach(record =&gt; {<br/>      if (record.memo) {<br/>        const ipfsListing = this.getIpfsHashFromBytes32(record.memo)<br/>        ipfs.files.get(ipfsListing, function (err, files) {<br/>          files.forEach((file) =&gt; {<br/>            const post = file.content.toString('utf8')<br/>            posts.push(post) // Show this to the user<br/>          })<br/>        })<br/>      }<br/>    });<br/>});</span></pre><p id="81e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">分权</strong></p><p id="77fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种架构确保我们的数据是分散的，但应用程序本身呢？如果应用程序宕机，用户可以编写另一个客户端，可以读取该帐户的区块链，并从IPFS获取相应的数据。</p><p id="47b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管我们可以更进一步，通过利用<code class="eh ks kt ku kh b">manageData</code>帐户操作，将客户端代码实际存储在区块链上。</p><p id="8958" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类似这样的东西可能是应用程序构建/部署链的一部分，所以每次发布新版本时，它也会被添加到区块链中:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="1190" class="kl km hu kh b fv kn ko l kp kq">import fs from 'fs'</span><span id="df42" class="kl km hu kh b fv kr ko l kp kq">this.publishClient = () {<br/>  const code = fs.readFileSync('my_project/client.js');</span><span id="b07d" class="kl km hu kh b fv kr ko l kp kq">  ipfs.files.add(buffer, (err, ipfsHash) =&gt; {<br/>    const server = new StellarSdk.Server('https://horizon-testnet.stellar.org');</span><span id="1f39" class="kl km hu kh b fv kr ko l kp kq">    server.loadAccount('OUR_ACCOUNT_ID').then((base) =&gt; {<br/>        const tx = new StellarSdk.TransactionBuilder(base);<br/>        const data = {name: 'v1.0.0', value: ipfsHash[0].path};<br/>        tx.addOperation(StellarSdk.Operation.manageData(data));<br/>        var builtTx = tx.build();<br/>        builtTx.sign(StellarSdk.Keypair.fromSecret('OUR_ACCOUNT_SECRET'));<br/>        return server.submitTransaction(builtTx);<br/>    });<br/>  });<br/>}</span></pre><p id="2735" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管需要记住，每个数据条目都会增加账户所需的最小余额。因此，我们可能只想维护客户代码库的最后一个版本或最后几个版本。但这应该足以使我们的演示应用程序或多或少地分散。</p><p id="5c1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">结论</strong></p><p id="6b1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个有趣的思想实验，但这个演示应用程序仍然没有办法管理评论，upvotes等，因为我们在某种程度上受到恒星平台的能力限制。</p><p id="9c31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要构建更高级的东西，我们需要在真正的dApp平台上构建，比如以太坊或NEO，它们拥有实现这一目标的所有必要工具。</p><p id="2cf7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但随着最近脸书数据和用户隐私的争议，现在绝对是时候考虑如何建立分散的社交应用程序了。</p><p id="0bff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一领域有许多有趣的工作，如<a class="ae ka" href="https://datawallet.com/" rel="noopener ugc nofollow" target="_blank"> Datawallet </a>、<a class="ae ka" href="https://blockstack.org/" rel="noopener ugc nofollow" target="_blank"> Blockstack </a>、<a class="ae ka" href="https://akasha.world/" rel="noopener ugc nofollow" target="_blank">阿卡夏</a>等项目，这些项目在未来几年将会很有意思。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="kw kx l"/></div></figure></div></div>    
</body>
</html>