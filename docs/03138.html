<html>
<head>
<title>Stop manually provisioning AWS for Laravel — use Terraform instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止为Laravel手动配置AWS改用Terraform</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/stop-manually-provisioning-aws-for-laravel-use-terraform-instead-11b8b360617c?source=collection_archive---------2-----------------------#2018-04-10">https://medium.com/hackernoon/stop-manually-provisioning-aws-for-laravel-use-terraform-instead-11b8b360617c?source=collection_archive---------2-----------------------#2018-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d36039495b05778b7aeb0e14f9085e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tNhLaNF_QMO2UBg5hoBUQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Poe knows a fair bit about automating</figcaption></figure><p id="b419" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有太多的产品希望帮助我们在云中运行应用程序。不幸的是，它们都没有涵盖我们所需要的全部。有时候我们需要自带服务器。或者他们负责托管，但我们无法访问底层基础架构。</p><p id="d1ec" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，我们不仅为它们付费，在闭源软件上下赌注，而且只处理我们需要的一小部分。</p><p id="58de" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">我正在分享一个完整的Terraform和Docker配置，让你从头开始配置AWS和部署Laravel/Nginx/MySQL/Redis/elastic search，只需几个命令</strong>。我们将使用“基础设施即代码”和“配置即代码”来实现这一点，以确保流程的可重复性、可共享性和可记录性。</p><blockquote class="ke kf kg"><p id="c0e8" class="jg jh kh ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">关于自动化的一句话:<strong class="ji hv">自动化是我们有效发展你的技术团队的唯一途径。</strong>我们自动化程度越高，流程就越标准。我们将用普遍理解的技术，如Docker、<a class="ae kl" href="https://hackernoon.com/tagged/terraform" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、Kubernetes、Consul等以及它们的设计模式来取代你的零散脚本。我们可以快速构建并移交给新的开发者。我们可以忘记它们，几个月后再回来，而不会大脑冻结。</p></blockquote><p id="6643" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们在<a class="ae kl" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>上部署Laravel所需的完整源代码可以在GitHub上公开获得，网址是:</p><div class="km kn fm fo ko kp"><a href="https://github.com/li0nel/laravel-terraform" rel="noopener  ugc nofollow" target="_blank"><div class="kq ab ej"><div class="kr ab ks cl cj kt"><h2 class="bd hv fv z el ku eo ep kv er et ht dt translated">里欧内尔/拉勒韦尔-地形</h2><div class="kw l"><h3 class="bd b fv z el ku eo ep kv er et ek translated">laravel-terraform -一键部署Laravel -无需支付额外的Saas费用</h3></div><div class="kx l"><p class="bd b gc z el ku eo ep kv er et ek translated">github.com</p></div></div><div class="ky l"><div class="kz l la lb lc ky ld ja kp"/></div></div></a></div><p id="1ec3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">准备好了吗？开始吧！</p><p id="5bcc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kh">这是我用来在AWS上部署客户的Laravel应用程序的过程。希望这能对你的部署有所帮助。如果您的用例更复杂，我会提供持续的支持包，从指导您的开发人员到亲手在AWS上构建应用程序。在hi@getlionel.com ping我</em></p><h2 id="37fa" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">1.克隆部署脚本</h2><p id="46a5" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">我们首先下载部署Laravel所需的Terraform和Docker脚本。从我们的Laravel根目录:</p><p id="8164" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh me mf mg mh b">git clone git@github.com:li0nel/laravel-terraform deploy</code></p><p id="074e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将在我们的Laravel安装的根目录下创建一个部署目录。现在，我们将使用该目录中的Terraform脚本来创建我们的基础设施。</p><pre class="mi mj mk ml fq mm mh mn mo aw mp dt"><span id="2132" class="le lf hu mh b fv mq mr l ms mt">├── deploy<br/>  └── terraform                 <em class="kh"># our Terraform scripts</em><br/>    ├── master.tf               # <em class="kh">entrypoint for Terraform (TF)</em><br/>    ├── terraform.tfvars        # <em class="kh">TF input variables</em><br/>    └── modules<br/>      └── vpc                   # <em class="kh">VPC configuration</em><br/>        ├── vpc.tf<br/>        └── outputs.tf<br/>      └── ec2                   <em class="kh"># EC2 configuration</em><br/>        ├── ec2.tf<br/>        └── outputs.tf<br/>      └── aurora      <em class="kh">          # Aurora configuration</em><br/>        ├── aurora.tf<br/>        └── outputs.tf<br/>      └── s3                    <em class="kh"># S3 configuration</em><br/>        ├── s3.tf<br/>        └── outputs.tf<br/>  └── cron                      <em class="kh"># cron configuration for Docker</em><br/>    └── artisan-schedule-run<br/>  └── nginx                     <em class="kh"># Nginx configuration</em><br/>    ├── default.conf<br/>    ├── nginx.conf<br/>    └── ssl                     <em class="kh"># Nginx SSL certificates</em><br/>      ├── ssl.cert<br/>      └── ssl.key<br/>  ├── php-fpm                   <em class="kh"># PHP-FPM config<br/>  </em>├── Dockerfile                <em class="kh"># Dockerfile for Laravel containers<br/>  </em>├── Dockerfile-nginx          <em class="kh"># Dockerfile for Nginx container<br/>  </em>└── docker-compose.yml        <em class="kh"># Docker Compose configuration</em></span></pre><h2 id="c3df" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">2.配置我们的AWS命令行</h2><p id="c4fd" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">我们从认证命令行开始，在AWS控制台的IAM部分为新用户下载API密钥和密码。该用户需要拥有为我们将在下面使用的所有服务创建资源的权限。按照以下提示操作:</p><p id="271e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh me mf mg mh b">aws configure</code></p><h2 id="5cfb" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">3.更新Terraform输入变量</h2><p id="e952" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">Terraform自动从当前目录中的任何<code class="eh me mf mg mh b">terraform.tfvars</code>或<code class="eh me mf mg mh b">*.auto.tfvars</code>加载输入变量。</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mu mv l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Update “stack_name” with your project’s name</figcaption></figure><h2 id="3681" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">4.用Terraform构建我们的基础设施</h2><p id="8507" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">让我们通过<code class="eh me mf mg mh b">terraform plan</code>查看一下我们的AWS账户中Terraform将要为我们构建什么:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/f3fd4236ada80610b2093b30957fcb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlnxHmkfGsLwhx1r-QR5eQ.png"/></div></div></figure><p id="451a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这些是在AWS上部署Laravel所需的33个基础设施部分。如果我们包括监控警报、数据库副本和一个自动扩展组，这个数字将很容易达到60左右。</p><p id="a513" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您能看到在AWS控制台中为每个新项目手动设置它会有多危险和痛苦吗？</p><p id="eac7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">执行设置的命令是<code class="eh me mf mg mh b">terraform apply plan.tf</code></p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/54cdf96a7e19a3f058f6a81eec4b0670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzMehecxTTTDWPwg4BbkRg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Terraform created our infrastructure in less than 8 minutes</figcaption></figure><p id="feaa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Terraform不仅能让我们变得非常高效，而且用它来编写基础设施也是一种真正的乐趣。请看它的语法示例:</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mu mv l"/></div></figure><p id="88b0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用Terraform时要记住的两件事:<br/> —我们尽可能用项目名称标记每个资源，以便在AWS控制台中识别它们<br/> —我们将设置Terraform在S3上存储我们的状态文件(更多信息在下面的步骤7中)<strong class="ji hv">，并确保<em class="kh">桶版本控制</em>已启用</strong>！如果我们不这样做，并且意外地覆盖了我们的状态文件，Terraform将会停止跟踪我们的堆栈，我们需要手动删除控制台中的所有内容。</p><h2 id="d05a" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">4.(可选)克隆我们的堆栈</h2><p id="60c3" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">Terraform的一个很大的特点是，它不仅可以跟踪我们的基础设施，还可以跟踪它的不同版本(即测试、试运行、生产)。</p><p id="5405" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">把它想象成Git分支。Terraform称其版本为<a class="ae kl" href="https://www.terraform.io/docs/state/workspaces.html" rel="noopener ugc nofollow" target="_blank">工作空间</a>。它是这样工作的:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/3f6f5628c4361db774f5b9a61fd89597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBwu4-JCSJFW0H_hZI4DIQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Creating the exact same stack, in production</figcaption></figure><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/62e3a7ad17140347057320dc22aeb50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6DlhgOcwLcGiPJFOb2Zhg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Switching back to our initial workspace</figcaption></figure><h2 id="b222" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">5.使用Docker机器在我们的EC2实例上安装Docker</h2><p id="dbd6" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">Docker Machine是供应新Docker主机或<em class="kh">机器</em>的最简单方法。</p><p id="1509" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">—它非常快<br/> —命令行非常简单<br/> —它管理所有的SSH密钥和TLS证书，即使我们有几十台服务器<br/> —使我们的服务器立即为Docker部署做好准备</p><p id="340c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为我们已经用Terraform创建了一个EC2实例，然后我们使用<a class="ae kl" href="https://docs.docker.com/machine/drivers/generic/" rel="noopener ugc nofollow" target="_blank"> Docker机器通用驱动程序</a>，它通过SSH使用现有的VM/主机创建<em class="kh">机器</em>:</p><pre class="mi mj mk ml fq mm mh mn mo aw mp dt"><span id="5b77" class="le lf hu mh b fv mq mr l ms mt">docker-machine create \<br/>  --driver generic \<br/>  --generic-ip-address=$(terraform output ec2_ip) \<br/>  --generic-ssh-key $(terraform output ssh_key_path) \<br/>  <!-- -->--generic-ssh-user "ubuntu" \<br/>laravelaws</span></pre><p id="9ce5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Docker Machine将通过SSH连接到远程服务器，安装Docker守护程序并生成TLS证书来保护Docker守护程序端口。然后，我们可以在任何地方使用<code class="eh me mf mg mh b">eval "$(docker-machine env your_machine_name)"</code>连接到我们的机器，从这里我们可以列出正在运行的容器。</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/85a2e0ef4f31afaec03ebc80227e5de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YJVSYjWQyS422ENpIxwcQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Provisioning our existing EC2 instance with the Docker daemon with Docker Machine</figcaption></figure><h2 id="2d40" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">6.使用Docker Compose构建和部署Docker映像</h2><p id="ee47" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">太好了，我们已经完成一半了！我们有一个完全配置好的基础设施，现在可以在上面部署我们的Laravel堆栈。我们将部署以下Docker容器:</p><p id="1705" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">—我们在PHP-FPM容器中的Laravel代码<br/> — Nginx作为PHP-FPM的反向代理<br/> —(可选)Redis作为Laravel的缓存和队列引擎<br/> —(可选)elastic搜索我们的应用程序搜索引擎<br/> —我们在运行<em class="kh"> cron </em>的容器中的Laravel代码，用于artisan调度命令<br/> —我们在worker容器中的Laravel代码，它将侦听来自Redis队列的Laravel作业</p><p id="5a4f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就像我们不想手动管理我们基础架构的所有移动部分一样，我们也不可能手动管理所有这些配置和流程编排。</p><p id="772a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">码头工人组成救援队！</p><p id="3dbd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上述所有容器的配置被提交到<em class="kh">docker文件:</em></p><pre class="mi mj mk ml fq mm mh mn mo aw mp dt"><span id="d18c" class="le lf hu mh b fv mq mr l ms mt">└── deploy<br/><em class="kh">  </em>├── Dockerfile                <em class="kh"># Dockerfile for Laravel containers<br/>  </em>├── Dockerfile-nginx          <em class="kh"># Dockerfile for Nginx container<br/>  </em>└── docker-compose.yml        <em class="kh"># Docker Compose configuration</em></span></pre><p id="8f3e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">…协调所有这些的脚本是<code class="eh me mf mg mh b">docker-compose.yml</code>文件:</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mu mv l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Orchestrating all of our containers</figcaption></figure><p id="e971" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">将这些文件复制到项目的根目录:<br/> <code class="eh me mf mg mh b">mv Dockerfile Dockerfile-nginx docker-compose.yml .dockerignore ..</code></p><p id="dd9c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后为我们的远程环境变量<br/> <code class="eh me mf mg mh b">cp .env docker-compose.env</code>创建一个<code class="eh me mf mg mh b">docker-compose.env</code>文件</p><p id="be18" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">用适当的环境变量更新<code class="eh me mf mg mh b">docker-compose.env</code>文件:<br/> — <code class="eh me mf mg mh b">DB_HOST</code>，输出<code class="eh me mf mg mh b">terraform output aurora_endpoint</code> <br/> — <code class="eh me mf mg mh b">DB_DATABASE</code>，输出<code class="eh me mf mg mh b">terraform output aurora_db_name</code> <br/> — <code class="eh me mf mg mh b">DB_USERNAME</code>，输出<code class="eh me mf mg mh b">terraform output aurora_master_username<br/></code> — <code class="eh me mf mg mh b">DB_PASSWORD</code>，输出<code class="eh me mf mg mh b">terraform output aurora_master_password<br/></code> — <code class="eh me mf mg mh b">CACHE_DRIVER</code>，<code class="eh me mf mg mh b">SESSION_DRIVER</code>，<code class="eh me mf mg mh b">QUEUE_DRIVER</code>，输出<code class="eh me mf mg mh b">redis</code></p><p id="7061" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们现在准备构建我们的映像并运行我们的容器:<br/> <code class="eh me mf mg mh b">docker-compose up --build -d</code></p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/c841730e745769b4fab84c1c06c86d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_WsENJQuGwjQ1RVv94J8w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Building and running all containers at once</figcaption></figure><p id="74c3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们通过运行默认的数据库迁移来确认我们的Laravel代码是否正确地配置了正确的数据库连接细节:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/3430158e9f5b45fd00a2816c2428cb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWDMxi86068ctouxAO9H9Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Our Laravel project successfully connecting to Aurora</figcaption></figure><p id="51c1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">…并且我们的web项目可以通过端口80访问:</p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/f4acccef10e49ce410e152c8beeab64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zc5qEJFN_forboqQkcMj6A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Laravel running in its Docker container on our Terraform-provisioned EC2</figcaption></figure><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/96a6fefe93284d49fe378b182b74feab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CAx_CiSJCIkIUl3qdT9zg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Each container’s log stream is centralised in our CloudWatch console</figcaption></figure><h2 id="70de" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated"><strong class="ak"> 7。(可选)与队友共享访问权限</strong></h2><p id="b4da" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">太神奇了！我们现在可以随意重新部署您的Laravel代码，修改我们的基础设施和配置，同时跟踪您代码中的所有更改。</p><p id="460d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">队友可以通过从我们的源代码库中提取代码来访问所有的Docker配置和Terraform文件。然而，在这个阶段，他们不能:<br/> —修改基础设施或访问Terraform输出，因为他们不能访问Terraform本地保存在我们机器上的状态文件<br/> —将他们的Docker客户端连接到我们的EC2实例，因为他们没有像我们一样安装指向EC2的Docker机器</p><p id="6550" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">第一点的解决方案是让Terraform使用S3远程<em class="kh">后端</em>，其中Terraform状态被有效地远程保存在S3桶上以供共享。这是通过取消注释<code class="eh me mf mg mh b">master.tf</code>中的以下行并运行<code class="eh me mf mg mh b">terraform init</code>将状态迁移到新的后端来实现的:</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mu mv l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Terraform S3 backend configuration</figcaption></figure><p id="cb97" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="kh">强烈建议在您的S3存储桶上激活版本控制，以便在您意外覆盖它时能够检索您的地形状态！</em></p><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/cfd32524fd72cf9f7ac7d048c27fb809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWUsdClEEq5vjLzmxqpICw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Migrating Terraform’s state to S3 for security and collaboration</figcaption></figure><p id="581e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，如果我们的同事使用AWS凭证来访问我们的S3存储桶，他们将和我们一样连接到相同的Terraform后端，我们可以同时在堆栈上工作，没有任何风险。</p><h2 id="70cc" class="le lf hu bd lg lh li lj lk ll lm ln lo jr lp lq lr jv ls lt lu jz lv lw lx ly dt translated">8.(可选)随意销毁和重新创建您的堆栈</h2><p id="f770" class="pw-post-body-paragraph jg jh hu ji b jj lz jl jm jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd hn dt translated">恭喜你在本指南中走了这么远！一旦完成，使用<code class="eh me mf mg mh b">terraform destroy</code>清理你的基础设施，这样你就不会在月底收到账单惊喜。</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mx mv l"/></div></figure></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="e2b6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">莱昂内尔是总部位于伦敦的初创公司Wi5的首席技术官，也是面向未来的工程文化课程 <a class="ae kl" href="https://hackernoon.com/why-the-platform-model-is-broken-a51478b1b4ee" rel="noopener ugc nofollow" target="_blank"> <em class="kh">的作者。你可以在</em></a><a class="ae kl" href="https://getlionel.com" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://getlionel.com</em></a>上联系他</p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mx mv l"/></div></figure></div></div>    
</body>
</html>