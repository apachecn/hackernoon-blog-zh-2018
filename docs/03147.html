<html>
<head>
<title>Here are some simple optimisations to squeeze performance out of CPU</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下面是一些简单的优化来提高CPU的性能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/here-are-some-simple-optimisations-to-squeeze-performance-out-of-cpu-6306342ed1a5?source=collection_archive---------11-----------------------#2018-04-10">https://medium.com/hackernoon/here-are-some-simple-optimisations-to-squeeze-performance-out-of-cpu-6306342ed1a5?source=collection_archive---------11-----------------------#2018-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/832c17af3dc57f215d272f2e6a580587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zbJqUFy5nPyNResI."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@jplenio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Johannes Plenio</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a5d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在作为软件开发人员的职业生涯开始时，大多数人认为程序的T2性能归结于其操作的渐近复杂性。但是一旦你应用了最好的算法，你的代码仍然不能给你想要的性能，你该怎么办？</p><p id="b795" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一些基本的技术可以帮助你从CPU内核中获得额外的能量。</p><h1 id="7100" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">循环展开</h1><p id="e5fd" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">一个现代的CPU内核有多个功能单元，如<a class="ae jg" href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit" rel="noopener ugc nofollow" target="_blank"> ALU </a>，加载/存储，在其<a class="ae jg" href="https://en.wikipedia.org/wiki/Execution_unit" rel="noopener ugc nofollow" target="_blank">执行单元</a>中分支。</p><div class="li lj fm fo lk ll"><a href="https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake#Architecture" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd hv fv z el lq eo ep lr er et ht dt translated">Kaby Lake -微架构-英特尔- WikiChip</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">Kaby Lake (KBL)是英特尔Skylake的继任者，sky Lake是一款面向主流台式机的增强型14纳米制程微架构…</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">en.wikichip.org</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz ja ll"/></div></div></a></div><p id="b9a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">程序应该总是试图利用这一点来实现并行性。</p><p id="8bd1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中一个技巧是使用<a class="ae jg" href="https://en.wikipedia.org/wiki/Loop_unrolling" rel="noopener ugc nofollow" target="_blank">循环展开</a>。循环展开允许您打破参数的依赖链。一个无序的CPU可以并行执行多条指令，并使你的程序运行得更快。</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="326a" class="mj kg hu mf b fv mk ml l mm mn"><strong class="mf hv">func F1</strong>() int {<br/>       <strong class="mf hv">var </strong>acc int = 1;<br/>       <strong class="mf hv">for </strong>j := 0; j &lt; length; j++ {<br/>              acc = acc + inputList1[j]<br/>       }<br/>       <strong class="mf hv">return </strong>acc<br/>}</span><span id="a763" class="mj kg hu mf b fv mo ml l mm mn"><strong class="mf hv">func F2</strong>() int {<br/>       <strong class="mf hv">var </strong>acc1 int = 1;<br/>       <strong class="mf hv">var </strong>acc2 int = 1;<br/><br/>       <strong class="mf hv">for </strong>j := 0; j + 1 &lt; length; j += 2 {<br/>              acc1 = acc1 + inputList1[j]<br/>              acc2 = acc2 + inputList1[j + 1]<br/>       }<br/>       <strong class="mf hv">return </strong>acc1 + acc2<br/>}</span></pre><p id="4da5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在F1中，在执行下一个循环之前，程序通常必须等待<em class="mp"> acc </em>更新。然而，在F2中，您的程序将利用内核中的多个整数加法单元，并且将并行进行。如果您运行基准测试，您会注意到F2的速度几乎是F1的两倍。</p><h1 id="b914" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">向量指令</h1><p id="c57a" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现代CPU可以将向量(原始类型的数组)作为一个单元而不是单个元素来操作。向量指令包括一次加载多个值，在一条指令中对它们进行操作，然后存储它们。这些指令被称为<a class="ae jg" href="http://qr.ae/TU1wkb" rel="noopener ugc nofollow" target="_blank"> SIMD </a>(单指令，多数据)。SIMD比较流行的分机是<a class="ae jg" href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" rel="noopener ugc nofollow" target="_blank">上交所</a>、<a class="ae jg" href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions" rel="noopener ugc nofollow" target="_blank"> AVX </a>以及那里的分机。</p><p id="375d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">SIMD指令通常可以一次处理8个32位或4个64位值，因此可以使程序运行得更快。通常编译器会注意这一点。</p><h1 id="981d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">贮藏</h1><p id="dae2" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">程序员通常认为缓存是理所当然的。您编写的代码通常会对是否有有效的缓存产生很大的影响。</p><p id="78b1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以<a class="ae jg" href="https://github.com/ardanlabs/gotraining/tree/47261e94421eaad383d5c6bcfdb4e60087fa86f0/topics/go/testing/benchmarks/caching" rel="noopener ugc nofollow" target="_blank"> github </a>为例</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="340a" class="mj kg hu mf b fv mk ml l mm mn"><strong class="mf hv">func </strong>ColumnTraverse() int {<br/>       <strong class="mf hv">var </strong>ctr int<br/><br/>       <strong class="mf hv">for </strong>col := 0; col &lt; <strong class="mf hv"><em class="mp">cols</em></strong>; col++ {<br/>              <strong class="mf hv">for </strong>row := 0; row &lt; <strong class="mf hv"><em class="mp">rows</em></strong>; row++ {<br/>                     <strong class="mf hv">if </strong>matrix[row][col] == 0xFF {<br/>                            ctr++<br/>                     }<br/>              }<br/>       }<br/><br/>       <strong class="mf hv">return </strong>ctr<br/>}<br/><em class="mp"><br/></em><strong class="mf hv">func </strong>RowTraverse() int {<br/>       <strong class="mf hv">var </strong>ctr int<br/><br/>       <strong class="mf hv">for </strong>row := 0; row &lt; <strong class="mf hv"><em class="mp">rows</em></strong>; row++ {<br/>              <strong class="mf hv">for </strong>col := 0; col &lt; <strong class="mf hv"><em class="mp">cols</em></strong>; col++ {<br/>                     <strong class="mf hv">if </strong>matrix[row][col] == 0xFF {<br/>                            ctr++<br/>                     }<br/>              }<br/>       }<br/><br/>       <strong class="mf hv">return </strong>ctr<br/>}</span></pre><p id="cc68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这两个函数在做同样的事情，并且具有相同的渐近复杂度。如果您运行基准测试，您会发现RowTraverse通常比ColumnTraverse快4倍。</p><p id="f8e9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是因为行遍历利用了缓存中已经存在的值，但是列遍历必须在每次比较时从内存中获取一个值。</p><p id="df4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在我的文章中读到更多关于缓存的内容</p><div class="li lj fm fo lk ll"><a href="https://codeburst.io/understanding-hardware-to-push-performance-to-the-max-and-then-some-part-1-c048021114e3" rel="noopener follow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd hv fv z el lq eo ep lr er et ht dt translated">为什么您应该关心知识库？</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">让我们充分利用CPU缓存的潜力</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">codeburst.io</p></div></div><div class="lu l"><div class="mq l lw lx ly lu lz ja ll"/></div></div></a></div><h1 id="7e98" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">分支预测</h1><p id="2650" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现代CPU在看到分支时不会停止(即if else类型的条件)。相反，他们<a class="ae jg" href="https://www.extremetech.com/computing/261792-what-is-speculative-execution" rel="noopener ugc nofollow" target="_blank">推测性地执行</a>下一条指令，假设分支是否被采用。仅当确定预测是否正确时，才提交结果。在错误预测的情况下，CPU会丢弃结果，并从分支后的第一条语句开始执行指令。除了执行更多指令的额外开销之外，这种未命中通常会导致5–10 ns的损失。</p><p id="76e3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你的程序在if-else之间频繁切换，那么分支失误预测惩罚将对你的性能产生影响。避免这种情况的最佳方法是使用尽可能少的分支，如果绝对必要，使它们可预测(例如，在比较之前对值进行排序)。</p><h1 id="ddbf" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">并发！=并行度</h1><p id="9cf7" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">您将线程数量从10个增加到100个，程序的性能变得更差。为什么会这样？</p><p id="2b7c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">问题出在CPU上。它只有有限数量的内核来支持并行操作。在应用中并行发生的情况通常是处理器在线程之间快速切换。但是，这种切换成本很高，因为它涉及来回复制PC、SP和内存/缓存中的所有寄存器。</p><p id="f398" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你有大量的线程，CPU将花费大部分时间在这些线程之间周旋，而不是执行实际的指令。现代语言试图通过在几个操作系统线程上复用大量抽象来解决这个问题。</p><h1 id="0ea4" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">互斥（体）…</h1><p id="dff1" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果您实现了最佳的并发性，但是您使用锁来同步数据结构，您仍然不会注意到应有的性能提升。</p><p id="1cac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是因为一个简单的<a class="ae jg" href="https://searchnetworking.techtarget.com/definition/mutex" rel="noopener ugc nofollow" target="_blank">互斥</a>锁定/解锁需要大约25ns。这看起来不是很多，但是一旦你以1000万RPM运行你的程序，这25ns就变成了250ms，这就很多了。</p><p id="0d74" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">避免互斥的最简单的方法之一是使用线程本地数据结构。如果你需要在线程间共享数据，使用无锁的通信技术(比如goroutines中的通道)而不是共享内存ds。</p><h1 id="7f92" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">内存引用</h1><p id="e090" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">除非绝对需要，否则不应该使用内存引用。编译器通常避免对内存引用进行优化，因为这会产生前所未有的影响。</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="f758" class="mj kg hu mf b fv mk ml l mm mn"><strong class="mf hv">func </strong>AddPointers(x *int, y *int){<br/>       *x += *y<br/>       *x += *y<br/>}</span></pre><p id="255a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个简单的优化编译器应该做的是使它<em class="mp">* x = 2 *(x)+* y</em>从而减少指令的数量<em class="mp">。</em></p><p id="ff53" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，如果x和y指向同一个变量，<em class="mp"> AddPointers </em>将给出输出4(*x)，而优化将给出3(*x)，这是不正确的。编译器在遇到这种情况时会安全运行，并会避免任何优化。</p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="90a8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">还有更多技术可以应用，例如内核旁路、避免内核间通信等。但是那些不满足简单的标准。我将在另一篇文章中详细讨论这些。</p><p id="7241" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">深入研究这些主题的一些资源包括:</p><ul class=""><li id="cfcd" class="my mz hu jj b jk jl jo jp js na jw nb ka nc ke nd ne nf ng dt translated"><a class="ae jg" href="https://www.amazon.com/Computer-Systems-Programmers-Perspective-3/dp/9332573905/ref=sr_1_1?ie=UTF8&amp;qid=1522789499&amp;sr=8-1&amp;keywords=computer+systems+a+programmer%27s+perspective" rel="noopener ugc nofollow" target="_blank">计算机系统程序员的视角</a></li><li id="f365" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated"><a class="ae jg" href="http://highscalability.com/all-time-favorites/" rel="noopener ugc nofollow" target="_blank">http://highscalability.com/all-time-favorites/</a></li><li id="605e" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated"><a class="ae jg" href="https://www.youtube.com/watch?v=WDIkqP4JbkE" rel="noopener ugc nofollow" target="_blank"> Scott Meyers: Cpu缓存和你为什么关心它</a></li><li id="9d89" class="my mz hu jj b jk nh jo ni js nj jw nk ka nl ke nd ne nf ng dt translated"><a class="ae jg" href="https://gist.github.com/jboner/2841832" rel="noopener ugc nofollow" target="_blank">每个程序员都应该知道的延迟数字</a></li></ul></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="ea07" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> <em class="mp">在</em></strong><a class="ae jg" href="http://www.linkedin.com/in/kartik-khare" rel="noopener ugc nofollow" target="_blank"><strong class="jj hv"><em class="mp">LinkedIn</em></strong></a><strong class="jj hv"><em class="mp">或</em> </strong> <a class="ae jg" href="https://www.facebook.com/KK.corps" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> <em class="mp">【脸书】</em> </strong> </a> <strong class="jj hv"> <em class="mp">上与我联系或给</em></strong><a class="ae jg" href="mailto:kharekartik@gmail.com" rel="noopener ugc nofollow" target="_blank"><strong class="jj hv"><em class="mp">【kharekartik@gmail.com</em></strong></a><strong class="jj hv"><em class="mp">留言分享反馈。</em>T47】</strong></p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure></div></div>    
</body>
</html>