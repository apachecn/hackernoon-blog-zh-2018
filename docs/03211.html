<html>
<head>
<title>Two Years of Functional Programming in JavaScript: Lessons Learned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两年的JavaScript函数式编程:经验教训</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/two-years-of-functional-programming-in-javascript-lessons-learned-1851667c726?source=collection_archive---------0-----------------------#2018-04-12">https://medium.com/hackernoon/two-years-of-functional-programming-in-javascript-lessons-learned-1851667c726?source=collection_archive---------0-----------------------#2018-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a11a580f4155fc38fa82ce8aaf50cbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5Cmkdx6ADWya5jSHClXIg.png"/></div></div></figure><p id="8d08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章不是关于学习FP原则或JavaScript FP库的。有许多关于这个主题的好文章。这篇文章是关于在一个项目中切换到函数式JS的冒险和后果。</p><p id="e65d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当这个故事开始的时候，我已经是一个有10+年经验的职业程序员了。C++，然后C#，然后Python。我可以编写任何程序。我对已经获得的模式和原则的信心扩展到了我看不到学习新东西的理由的程度。“我知道编程中90%好的部分，”我想。</p><p id="8b0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，2016年5月我们开始开发<a class="ae ka" href="https://xod.io/?utm_source=post&amp;utm_campaign=fp_dev&amp;utm_medium=medium" rel="noopener ugc nofollow" target="_blank"> XOD项目</a>。XOD是面向电子爱好者的可视化编程IDE。为了保持随意性，我们必须有一个网络版的IDE。Web？JavaScript！JavaScript中成熟的IDE？是的，我们不会用快速而肮脏的jQuery结束；我们需要更好的东西。</p><p id="3c19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当时，一种用于重型前端开发的新技术正在出现:一种叫做React的东西及其伴随的Flux/Redux模式。在文档和文章中，它们与函数式编程的概念高度交织在一起。我开始探索FP。</p><p id="fed6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">哇哦。就像我发现了另一个大陆。开发的澳大利亚，程序员倒着走，数据在路的另一边流动。当然，我听说过Haskell、OCaml、LISP，但我曾经认为这些开发人员是一种边缘知识分子，他们为了编程而编程，而不是为了发布产品。我对自己专业水平的信心很快被侵蚀了。</p><p id="46db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">XOD是一种基因中带有功能性和反应性编程原则的产品。这在开发开始之前并不明显。我“发明”或者借鉴其他产品的很多东西，确实是FP基础。所以，星配星随，我们要用一些沉重的现代FRP JavaScript创建一个FRP编程环境。</p><p id="36eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">预见到这些事件，努力是值得的。FP给了这个项目一个非常坚实和灵活的框架。我不想再回头看“经典”编程了，在可预见的未来，我肯定会用函数式编程原则开发所有新项目。</p><h1 id="31d9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">打破壁垒</h1><p id="3a41" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">你会在NPM 上找到大量的<a class="ae ka" href="https://npms.io/search?q=fp" rel="noopener ugc nofollow" target="_blank"> JavaScript函数式编程库。其中最引人注目的是</a><a class="ae ka" href="http://ramdajs.com/" rel="noopener ugc nofollow" target="_blank">拉姆达</a>。这是一种“下划线”或“下划线”，但是要记住FP-first。Ramda提供了几十个函数来处理数据和编写函数。</p><p id="680d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">函数本身是好的，但是你需要一些FP对象来处理。另一个库<a class="ae ka" href="https://github.com/ramda/ramda-fantasy" rel="noopener ugc nofollow" target="_blank"> Ramda Fantasy </a>会把它们给你。你可能还会注意到其他流行的FP库，比如<a class="ae ka" href="https://github.com/sanctuary-js/sanctuary" rel="noopener ugc nofollow" target="_blank">避难所</a>、<a class="ae ka" href="https://github.com/fluture-js/Fluture" rel="noopener ugc nofollow" target="_blank">长笛</a>、<a class="ae ka" href="https://github.com/fantasyland/daggy" rel="noopener ugc nofollow" target="_blank"> Daggy </a>。当你开始有想法的时候，看看它们。不过，先从拉姆达开始，让你的大脑保持原位。</p><p id="1d89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是你遇到的第一个障碍。如果你查看任何一个FP库的文档，最好的情况下，你会得到很多WTF的问题。混乱的参数顺序、外来的术语、一些函数的不明确的实用价值会使你倾向于停止尝试并切换回惯用的编程。所以…</p><p id="7726" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第1点</strong>。从与特定语言或库无关的文章开始学习FP。您需要首先概述基本概念，了解好处，评估如何将您现有的代码转换以适应新的世界。</p><p id="3af8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很多关于函数式编程的文章都是书呆子数学家混蛋写的。没有经过初步训练就阅读它们是危险的:类别和变体会让你大吃一惊，却什么也没换来。</p><p id="6d5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，有优秀的出版物可以开始。对我影响最大的读物是:</p><ul class=""><li id="02a9" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated"><a class="ae ka" href="https://mostly-adequate.gitbooks.io/mostly-adequate-guide/" rel="noopener ugc nofollow" target="_blank">功能编程指南</a></li><li id="cb27" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ka" href="http://randycoulman.com/blog/categories/thinking-in-ramda/" rel="noopener ugc nofollow" target="_blank">拉姆达思维</a></li><li id="7827" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ka" href="https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript" rel="noopener ugc nofollow" target="_blank">Frisby教授介绍可组合函数式JavaScript </a></li><li id="1eaf" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ka" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener ugc nofollow" target="_blank">图片中的函子、应用程序和单子</a></li></ul><h1 id="ac36" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">无意义的疯狂</h1><p id="ce9f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当你开始探索FP的时候，你学到的第一个不寻常的概念是隐性编程，也称为无点风格或者(讽刺的)无意义编码。</p><p id="62de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本思想是省略函数参数名，或者更准确地说，完全省略参数:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="5648" class="mb kc hu lx b fv mc md l me mf">export const snapNodeSizeToSlots = R.compose(<br/>  nodeSizeInSlotsToPixels,<br/>  pointToSize,<br/>  nodePositionInPixelsToSlots,<br/>  offsetPoint({ x: WIDTH * 0.75, y: HEIGHT * 1.1 }),<br/>  sizeToPoint<br/>);</span></pre><p id="d5aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个典型的函数定义，完全由其他函数组合而成。它没有声明输入参数，尽管调用需要它们。即使没有上下文，您也可以理解该函数的作用，就像一些传送带接收大小并产生一些像素坐标。要了解具体的细节，您需要深入研究组成该组合的函数。反过来，它们可能是其他函数的组合，等等。</p><p id="bbcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个非常强大的技术，直到你把它提升到荒谬的地步。当我们开始积极地使用FP技巧时，我们把把一切都转换成无点的问题当作一个我们必须一次又一次解决的难题:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="e229" class="mb kc hu lx b fv mc md l me mf">// Instead of<br/>const format = (actual, expected) =&gt; {<br/>  const variants = expected.join(‘, ‘);<br/>  return `Value ${actual} is not expected here. Possible variants are: ${variants}`;<br/>}</span><span id="2988" class="mb kc hu lx b fv mg md l me mf">// you write<br/>const format = R.converge(<br/>  R.unapply(R.join(‘ ‘)),<br/>  [<br/>    R.always(“Value”),<br/>    R.nthArg(0),<br/>    R.always(“is not expected here. Possible variants are:”),<br/>    R.compose(R.join(‘, ‘), R.nthArg(1))<br/> ]<br/>);</span></pre><p id="f136" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">啊，什么？你很酷，你已经解决了。在代码评审中与他人分享这个难题。</p><p id="64ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，你学习单子和纯度。好了，我的功能从现在开始不能有任何副作用。它们不能引用<code class="eh mh mi mj lx b">this</code>(没关系)，不能引用time和random (o-o-ok)，不能引用除了给它们的参数之外的任何东西，甚至是全局字符串常量，甚至是数学Pi。您从最外层的函数通过嵌套链向下到内部传递必要的参数、工厂和生成器，展开签名，然后学习读取器或状态单子。哎哟，你用零星的单子图和链感染了你所有的代码，这碗意大利面就做好了！</p><p id="416c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，组合子！多么有趣的动物。哦，Y-combinator不仅是一个启动加速器，还是一个递归替换。下次我遇到可以通过递归或简单的“reduce”调用简单解决的问题时，让我们使用它。</p><p id="b695" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第二点</strong>。函数式编程是关于λ演算、单子、态射和组合子的<em class="mk">而不是</em>。它是关于拥有许多小的定义良好的<em class="mk">可组合</em>函数，而没有全局状态、它们的参数和IO的突变。</p><p id="a59d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">换句话说，如果无要点风格在特定情况下有助于更好地沟通，就使用它。否则，不要。不要使用单子，因为你可以，当它们精确地解决问题时使用它们。对了，你知道安<code class="eh mh mi mj lx b">Array</code>和<code class="eh mh mi mj lx b">Promise</code>是单子吗？如果没有，这并不妨碍你正确应用它们。你应该在一定程度上训练你的直觉，当你明白什么是单子所需要的，或者更好的是，它根本不需要。它来自实践，不要过度使用新的东西，直到你能舒服地思考它。</p><p id="a76b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">单独来说，尽可能切换到没有副作用的小的可组合函数会给你带来最大的好处。从它开始。</p><h1 id="7c8d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">要么抛出一个异常，要么返回null</h1><p id="a2e0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">切换到FP风格的一个方面曾经让我很恼火。在经典的JS中，至少有两个选项来显示错误:</p><ul class=""><li id="76a2" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">返回null/undefined而不是结果</li><li id="09cd" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">抛出异常</li></ul><p id="b1b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你获得FP时，你仍然有这些选择，并作为奖励获得<code class="eh mh mi mj lx b">Either</code>和<code class="eh mh mi mj lx b">Maybe</code>单子。我现在应该如何处理错误？我的lib的公共API应该是什么样子的？</p><p id="aeaf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从一个角度来看，<code class="eh mh mi mj lx b">Maybe</code> / <code class="eh mh mi mj lx b">Either</code>是一种更“合适”的方式，但对于图书馆消费者来说可能会比较陌生。空值和异常是惯例，但是你总是以控制台中的“T4”结束。长话短说…</p><p id="aa98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第三点</strong>。不要害怕通过<code class="eh mh mi mj lx b">Maybe</code> s和<code class="eh mh mi mj lx b">Either</code> s的错误处理，这对夫妇是你在一元世界中最好的收获。</p><p id="e08d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看优秀的<a class="ae ka" href="https://fsharpforfunandprofit.com/rop/" rel="noopener ugc nofollow" target="_blank">面向铁路的编程</a>模式。在你的公共API <em class="mk">和</em>中使用Maybes，如果你担心你不被理解，提供带有后缀的瘦包装卫星，比如‘unsafe’、‘nullable’、‘exc ’,供命令式JS使用</p><h1 id="64c9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">清晰是一种药物</h1><p id="2255" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当您在用函数式编程原则开发的项目中合作时，您会很快注意到结果。现在做一个回顾需要低得多的认知负荷。如果你看函数，函数代码是你应该考虑的。你不再需要去想象改变这个领域会给那个组件带来什么样的后果。你不觉得在这里是浅抄，深抄，还是只是引用更合适。你只需要不要局限于你现在看到的十行代码。</p><p id="c83c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，当你看到一个过时的代码时，它总是看起来很可疑。“嗯……为什么它改变了我的对象中的一个字段？为什么它存储在字段中，它会在随机时刻未经许可就变异我的对象吗？”经典代码开始看起来不对了。</p><p id="b31d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第四点</strong>。你必须选择FP兼容的库和FP兼容的同事。后者尤为重要。如果摩擦面积大，团队一部分人争取FP，另一部分人自由地破坏原则，最后FP会在项目中落败。</p><p id="3055" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">雇佣FP JS开发者更难，因为它设置了一个很高的最低水平。但是一旦你找到了，你就很有可能为你的产品找到最好的专家。在XOD中，我们都是FP专家，我很高兴我们一起工作。</p><h1 id="9886" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">利益伴随着受害者</h1><p id="1607" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">函数式编程与主流有很大不同，以至于你正在使用的主流工具将停止工作。</p><p id="7a40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Flow和Typescript无法正常工作，因为它们很难表达所有currying和参数多态性。例如，虽然有针对Ramda的绑定，但它们经常给你错误的警报，当确实有错误时，消息非常含糊不清。</p><p id="dd8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以找到一些在运行时执行类型检查的库。我们用<a class="ae ka" href="https://github.com/xodio/hm-def" rel="noopener ugc nofollow" target="_blank">这样一个</a>。唉，它们的伸缩性不好。性能损失通常高于函数执行本身的成本。因此，您只能通过显式启用它来进行检查，例如，对于单元测试。</p><p id="0579" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你在深度作文中犯了一个错误，比如把输入输出类型搞得有点乱，看到栈迹就会哭。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="38d3" class="mb kc hu lx b fv mc md l me mf">Error: Can’t find prototype Patch of Node with Id “HJbQvOPL-” from Patch “@/main”<br/> at /home/nailxx/devel/xod/packages/xod-func-tools/dist/monads.js:88:9<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:2491:23<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:860:20<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:14<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_arity.js:7:53<br/> at src/project.js:887:5<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:2491:23<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:860:20<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:14<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:27<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_arity.js:5:45<br/> at _filter (/home/nailxx/devel/xod/node_modules/ramda/src/internal/_filter.js:7:9)<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/filter.js:47:7<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_dispatchable.js:39:15<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_curry2.js:20:46<br/> at f1 (/home/nailxx/devel/xod/node_modules/ramda/src/internal/_curry1.js:17:17)<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:14<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_arity.js:5:45<br/> at src/typeDeduction.js:171:37<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:2491:23<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:864:20<br/> at src/project.js:618:33<br/> at _Right.chain (/home/nailxx/devel/xod/node_modules/ramda-fantasy/src/Either.js:67:10)<br/> at src/project.js:617:8<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:2491:23<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:860:20<br/> at _map (/home/nailxx/devel/xod/node_modules/ramda/src/internal/_map.js:6:19)<br/> at map (/home/nailxx/devel/xod/node_modules/ramda/src/map.js:57:14)<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_dispatchable.js:39:15<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_curry2.js:20:46<br/> at f1 (/home/nailxx/devel/xod/node_modules/ramda/src/internal/_curry1.js:17:17)<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:14<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:27<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:27<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_arity.js:5:45<br/> at validateProject (src/project.js:1031:3)<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:27<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_pipe.js:3:27<br/> at /home/nailxx/devel/xod/node_modules/ramda/src/internal/_arity.js:5:45<br/> at src/flatten.js:1021:5<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:2491:23<br/> at /home/nailxx/devel/xod/node_modules/sanctuary-def/index.js:864:20<br/> at Context.&lt;anonymous&gt; (test/flatten.spec.js:1805:27)</span></pre><p id="9eb5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在寻找问题根源时，大多数跟踪都是没有意义的。幸运的是，一旦FP代码第一次成功运行，你就可以确信它坚如磐石，不会给你带来任何惊喜。如果你在JS中做FP，明显的结果是需要一个完整的单元测试套件。</p><p id="02aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代码覆盖率和断点也会中断。FP代码更像CSS而不是JS。看看<a class="ae ka" href="https://github.com/xodio/xod/tree/master/packages/xod-project/src/" rel="noopener ugc nofollow" target="_blank"> XOD来源</a>。在CSS中放置一个断点并一步一步地执行它有意义吗？CSS文件的覆盖范围是什么？当然，效果也不是100%。在从声明式风格切换回命令式风格的地方，这些工具仍然可以工作；但是现在你的代码对于devtools来说是支离破碎的，体验也发生了巨大的变化。</p><p id="75d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第五点</strong>。一旦你碰了FP，你就会不高兴和生气。当我从Windows切换到Linux时，我经历了同样的情绪，并且明白这两者都很糟糕，我没有办法撤销这些知识。从成熟的IDE到Vim的切换也是如此。霍普，你明白这个想法。</p><p id="86ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们能两全其美吗？同时获得不疯狂的函数式编程和优秀的开发者体验？我也这么认为还有其他一些以JS为目标的语言从一开始就是功能性的:<a class="ae ka" href="http://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>，<a class="ae ka" href="http://www.purescript.org/" rel="noopener ugc nofollow" target="_blank"> PureScript </a>，<a class="ae ka" href="https://bucklescript.github.io/" rel="noopener ugc nofollow" target="_blank"> OCaml (BuckleScript) </a>，<a class="ae ka" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank"> ReasonML </a>。</p><p id="30ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近在实践中尝试了ReasonML，但那是另一回事了。如果你想听，就拍几下；)</p></div></div>    
</body>
</html>