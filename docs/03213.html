<html>
<head>
<title>Ethereum Smart Contracts in Python: a comprehensive(ish) guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的以太坊智能合约:综合(ish)指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ethereum-smart-contracts-in-python-a-comprehensive-ish-guide-771b03990988?source=collection_archive---------2-----------------------#2018-04-12">https://medium.com/hackernoon/ethereum-smart-contracts-in-python-a-comprehensive-ish-guide-771b03990988?source=collection_archive---------2-----------------------#2018-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e091815396e6bf7c19767f1255c11d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BbuCZSM0Io6cWIbWl_Jng.png"/></div></div></figure><p id="4a10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在以太坊上获得一个基本的智能合约是一回事——只需谷歌“ERC20令牌教程”你就会找到大量关于如何做的信息。以编程方式与契约交互完全是另一回事，如果你是Python程序员，那么教程就很少。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ka"><img src="../Images/806fea971becabcfaa9debc10916f696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpzQ8i_VZqW_rGVSqNzCKw.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">One, by my count, and it’s soooo 2017.</figcaption></figure><p id="9d0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对我们来说幸运的是，Web3.py的第4版刚刚发布，这意味着现在运行python脚本并观察区块链上发生的神奇事情比以往任何时候都更容易。<em class="kj">阴森森的。</em></p><p id="9c7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大声喊出<a class="kk kl gr" href="https://medium.com/u/8bb8b999b3b8?source=post_page-----771b03990988--------------------------------" rel="noopener" target="_blank">派珀·梅里亚姆</a>、<a class="kk kl gr" href="https://medium.com/u/d9a8ea9bbef6?source=post_page-----771b03990988--------------------------------" rel="noopener" target="_blank">杰森·卡弗</a>和所有其他在Web3.py上努力工作让我们其他人的生活变得轻松的人——在<a class="ae km" href="https://sempo.ai" rel="noopener ugc nofollow" target="_blank"> Sempo </a>上，我们正在使用以太坊让灾难响应更加透明，多亏了Web3.py，这才真正成为可能</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h1 id="56fb" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">正在设置</h1><p id="0636" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">首先，我们进行设置，确保安装了相关的python库等等。</p><h2 id="9ad3" class="lx kv hu bd kw ly lz ma la mb mc md le jn me mf li jr mg mh lm jv mi mj lq mk dt translated">Python库无处不在，但它们有什么用呢？</h2><p id="4ce0" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">有很多与以太坊相关的python库，但是当人们谈论以太坊时，有两个出现得很多:<em class="kj"> Web3.py </em>和<em class="kj"> Pyethereum </em>。乍一看，您应该使用哪一个来做什么并不明显。</p><p id="19af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">肾盂</strong></p><p id="506d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以太坊虚拟机(EVM)的Python实现。反过来，EVM是以太坊协议的一部分，它实际运行智能合约中的代码，并确定它们的输出。因此，如果您想在Python中运行以太坊节点，Pyethereum是一个不错的起点。</p><p id="46a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使你非常乐意在不运行自己的节点的情况下运行智能合约，Pyethereum仍然是一个很好的库——它包含了许多有用的功能，比如根据用户的私钥计算用户的地址等等。</p><p id="19c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Web3.py </strong></p><p id="5bda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个用于实际与以太坊区块链交互的库。我们正在谈论的事情包括在账户之间转移以太网、发布智能合约以及触发现有智能合约附带的功能。它的灵感来自流行的javascript库Web3.js，它将是我们在本教程中使用的主要库。</p><h2 id="14f7" class="lx kv hu bd kw ly lz ma la mb mc md le jn me mf li jr mg mh lm jv mi mj lq mk dt translated">好了，少说多做！</h2><p id="bfdc" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">起初我尝试使用Python 3.5版本，但是在运行时我遇到了问题，显然是由Python的类型暗示引起的。基于Python 3.6创建一个<a class="ae km" href="https://docs.python.org/3/tutorial/venv.html" rel="noopener ugc nofollow" target="_blank">虚拟环境</a>解决了这个问题，所以我建议也这么做。</p><p id="b93b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续pip-install <a class="ae km" href="https://pypi.python.org/pypi/web3/4.0.0" rel="noopener ugc nofollow" target="_blank"> web3 </a>(确保你得到版本4)。</p><p id="b9c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除非你喜欢为了花钱而花钱，否则你需要在以太坊测试网上放一个钱包，比如Ropsten，里面有很多以太可以玩。一个简单的方法是下载Chrome的<a class="ae km" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Metamask </a>扩展，并在那里创建一个新账户。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/da213a01533284b9db15a98f960aa7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIPo3BiH0T0l1wapT_kQcA.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Make sure you also select the ‘Ropsten Test Net’ on the left</figcaption></figure><p id="e899" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使你已经有一个装有乙醚的钱包，我也强烈建议你为开发目的创建一个新的。我们将要用私钥做一些相对鲁莽的事情，所以如果它们意外地变成了公钥(公私钥？)</p><p id="6be9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为你新创建的钱包获取测试乙醚很容易:只需进入<a class="ae km" href="https://faucet.metamask.io/" rel="noopener ugc nofollow" target="_blank">水龙头。metamask.io </a>并点击“从水龙头请求1乙醚”。这对我们将要做的事情来说应该足够了。</p><p id="ee48" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，因为我们将在没有托管我们自己的节点的情况下使用Ropsten TestNet，所以我们需要一个可以连接区块链的提供商。Infura.io 在这方面做得很好，所以去那里创建一个免费账户吧。记下Ropsten TestNet的提供者url(类似于https://Ropsten . in fura . io/Fe 2g fedc m3 tfed 3)。</p><h1 id="2bd3" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">部署智能合同</h1><p id="0979" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在不运行自己的节点的情况下使用Python来部署智能合约是相当困难的，因此我们将在这一步作弊。对于许多智能契约用例，你只需要做一次。</p><p id="c669" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我前面提到的，关于如何部署ERC20合同有上百万个指南，所以我们将部署一个稍微不同的(并且方便地更短)。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="03a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">问:</strong>谁喜欢在网上分享自己的观点？</p><p id="c45a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kj">大家？</em></p><p id="53a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回答得好。下面这个被我命名为“肥皂盒”的智能合约允许任何人向区块链广播任何他们想要的观点，在那里它将永远可见(给予或接受)。</p><p id="4312" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过有一个条件:只有支付了必要的0.02以太费的地址才能广播他们的观点。听起来不太公平，但事实就是如此。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="cb82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae km" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>，以太坊的在线代码编辑器很优秀，所以在那边新建一个文件，粘贴下面的代码。是用Solidity(智能合约的编程语言)写的。如果代码没有太多意义也没关系——我们稍后将更详细地讨论相关部分，但归根结底这是一个<em class="kj"> Python </em>教程。</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="c79c" class="lx kv hu ms b fv mw mx l my mz">pragma solidity ^0.4.0;<br/>contract SoapBox {</span><span id="be60" class="lx kv hu ms b fv na mx l my mz">// Our 'dict' of addresses that are approved to share opinions<br/>    mapping (address =&gt; bool) approvedSoapboxer;<br/>    string opinion;<br/>     <br/>    // Our event to announce an opinion on the blockchain<br/>    event OpinionBroadcast(address _soapboxer, string _opinion);</span><span id="0564" class="lx kv hu ms b fv na mx l my mz">// This is a constructor function, so its name has to match the contract<br/>    function SoapBox() public {<br/>    }<br/>    <br/>    // Because this function is 'payable' it will be called when ether is sent to the contract address.<br/>    function() public payable{<br/>        // msg is a special variable that contains information about the transaction<br/>        if (msg.value &gt; 20000000000000000) {  <br/>            //if the value sent greater than 0.02 ether (in Wei)<br/>            // then add the sender's address to approvedSoapboxer <br/>            approvedSoapboxer[msg.sender] =  true;<br/>        }<br/>    }<br/>    <br/>    <br/>    // Our read-only function that checks whether the specified address is approved to post opinions.<br/>    function isApproved(address _soapboxer) public view returns (bool approved) {<br/>        return approvedSoapboxer[_soapboxer];<br/>    } <br/>    <br/>    // Read-only function that returns the current opinion<br/>    function getCurrentOpinion() public view returns(string) {<br/>        return opinion;<br/>    }</span><span id="d9d0" class="lx kv hu ms b fv na mx l my mz">//Our function that modifies the state on the blockchain<br/>    function broadcastOpinion(string _opinion) public returns (bool success) {</span><span id="7994" class="lx kv hu ms b fv na mx l my mz">        // Looking up the address of the sender will return false if the sender isn't approved<br/>        if (approvedSoapboxer[msg.sender]) {<br/>            <br/>            opinion = _opinion;<br/>            emit OpinionBroadcast(msg.sender, opinion);<br/>            return true;<br/>            <br/>        } else {<br/>            return false;<br/>        }<br/>        <br/>    }</span><span id="d2a5" class="lx kv hu ms b fv na mx l my mz">}</span></pre><p id="fde2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是Metamask变得非常有用的地方:如果你点击remix窗口右上角的“运行”标签，并在“环境”下拉菜单下选择“注入的Web3”,“帐户”下拉菜单应该会填充你之前在MetaMask中创建的帐户的地址。如果没有，就刷新浏览器。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/1075766b23e06da4519c65a34b1ae9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJyW4mK9MwAWv56w3Gravw.png"/></div></div></figure><p id="8c4a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来点击“创建”。Metamask将弹出一个窗口，要求您确认交易。如果没有，只需打开元掩码扩展并在那里执行:</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/b03d13a3b43a216b0871e8f7720502a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QM4b6U72SUFBRzTaW79DHg.png"/></div></div></figure><p id="9641" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您将在Remix控制台的底部收到一条消息，让您知道合同的创建正在进行中。点击链接查看其在Etherscan上的状态。如果您刷新并且“至”字段中填充了合同地址，则合同已成功部署。</p><p id="3b62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你记下了合同地址，我们就该开始通过Web3.py与合同互动了</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="981f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我看来，你可以用四种半方式与以太坊智能合约互动。最后两个(半个)经常被混为一谈，但是区别是很重要的。我们已经看到了第一个——在区块链上部署智能合约。现在我们将讨论python的其余部分:</p><ul class=""><li id="ae5e" class="nd ne hu je b jf jg jj jk jn nf jr ng jv nh jz ni nj nk nl dt translated"><strong class="je hv">向合同发送以太:</strong>自解释真— <strong class="je hv"> </strong>从钱包向智能合同的地址发送以太。希望能换来一些有用的东西</li><li id="9bf4" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv">调用函数:</strong>执行智能合约的只读函数，获取一些信息(如地址余额)</li><li id="1d8b" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv">使用函数进行交易:</strong>执行智能合约的函数，该函数对区块链的状态进行更改。</li><li id="3b8d" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv">查看事件:</strong>查看因之前与函数的交易而发布到区块链上的信息。</li></ul><h1 id="7850" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated"><strong class="ak">发送以太合同</strong></h1><p id="8005" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">一些(但不是全部)智能合约包含“可支付”功能。如果您将以太网发送到合同地址，将触发这些功能。这方面的一个经典用例是ICO:向一个合同发送以太，然后返回您将获得的令牌。</p><p id="7de3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们将从导入开始，创建一个新的web3对象，它通过Infura.io连接到Ropsten TestNet。</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="c701" class="lx kv hu ms b fv mw mx l my mz"><strong class="ms hv">import </strong>time<br/><strong class="ms hv">from </strong>web3 <strong class="ms hv">import </strong>Web3, HTTPProvider<br/><br/>contract_address     = [YOUR CONTRACT ADDRESS]<strong class="ms hv"><br/></strong>wallet_private_key   = [YOUR TEST WALLET PRIVATE KEY]<strong class="ms hv"><br/></strong>wallet_address       = [YOUR WALLET ADDRESS]<strong class="ms hv"><br/><br/></strong>w3 = Web3(HTTPProvider([YOUR INFURA URL]))<br/><br/>w3.eth.enable_unaudited_features()</span></pre><p id="e5c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以在Metamask中您的帐户名称旁边的菜单中找到您的钱包私钥。因为我们使用的Web3.py的一些特性还没有经过完全的安全性审计，所以我们需要调用<em class="kj">w3 . eth . enable _ unaudited _ features()</em>来确认我们已经意识到可能会发生不好的事情<em class="kj">。我告诉过你我们正在用私钥做一些冒险的事情！</em></p><p id="96a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们将编写一个函数，将我们钱包中的以太网发送到合同:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="cb27" class="lx kv hu ms b fv mw mx l my mz"><strong class="ms hv">def </strong>send_ether_to_contract(amount_in_ether):<br/><br/>    amount_in_wei = w3.toWei(amount_in_ether,<strong class="ms hv">'ether'</strong>);<br/><br/>    nonce = w3.eth.getTransactionCount(wallet_address)<br/><br/>    txn_dict = {<br/>            <strong class="ms hv">'to'</strong>: contract_address,<br/>            <strong class="ms hv">'value'</strong>: amount_in_wei,<br/>            <strong class="ms hv">'gas'</strong>: 2000000,<br/>            <strong class="ms hv">'gasPrice'</strong>: w3.toWei(<strong class="ms hv">'40'</strong>, <strong class="ms hv">'gwei'</strong>),<br/>            <strong class="ms hv">'nonce'</strong>: nonce,<br/>            <strong class="ms hv">'chainId'</strong>: 3<br/>    }<br/><br/>    signed_txn = w3.eth.account.signTransaction(txn_dict, wallet_private_key)<br/><br/>    txn_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction)<br/><br/>    txn_receipt = <strong class="ms hv">None<br/>    </strong>count = 0<br/>    <strong class="ms hv">while </strong>txn_receipt <strong class="ms hv">is None and </strong>(count &lt; 30):<br/><br/>        txn_receipt = w3.eth.getTransactionReceipt(txn_hash)<br/><br/>        print(txn_receipt)<br/><br/>        time.sleep(10)<br/><br/><br/>    <strong class="ms hv">if </strong>txn_receipt <strong class="ms hv">is None</strong>:<br/>        <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'failed'</strong>, <strong class="ms hv">'error'</strong>: <strong class="ms hv">'timeout'</strong>}<br/><br/>    <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'added'</strong>, <strong class="ms hv">'txn_receipt'</strong>: txn_receipt}</span></pre><p id="16ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先让我们看一下事务字典<em class="kj"> txn_dict </em> —它包含了定义我们发送给智能契约的事务所需的大部分信息。</p><ul class=""><li id="3875" class="nd ne hu je b jf jg jj jk jn nf jr ng jv nh jz ni nj nk nl dt translated"><strong class="je hv">到</strong>:我们发送以太网的目的地(在本例中是智能合约)</li><li id="402d" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv"> Value: </strong>我们在魏送多少</li><li id="b9d4" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv"> Gas: </strong> Gas是对以太坊上执行一个交易所花费的计算量的一种度量。在这种情况下，我们指定了执行该事务所需的气体量的上限。*</li><li id="c68e" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv">汽油价格:</strong>每单位汽油我们愿意付多少钱(单位:魏)。</li><li id="6b4b" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated">这是一个地址随机数，而不是通常所说的工作证明。它只是对发送地址之前进行了多少次交易的计数，用于防止重复消费。</li><li id="4dfa" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated"><strong class="je hv">链ID: </strong>每个以太坊网络都有自己的链ID——主网的ID是1，而Ropsten的是3。你可以在这里找到一个更长的列表。</li></ul><p id="2fc4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kj">*关于汽油限制的快速说明:有一些函数允许您估计一个交易将使用多少汽油。然而，我发现选择限额的最好方法是，在你宁愿交易失败之前，计算出你愿意支付多少，然后继续。</em></p><p id="c086" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们定义了交易的重要部分，我们将使用钱包的私钥来签名。然后它准备好被发送到网络，我们将用<em class="kj"> sendRawTransaction </em>方法来完成。</p><p id="96e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的事务实际上不会完成，直到一个矿工决定将它包括在一个区块中。一般而言，您为每单位天然气支付的价格(请记住我们的天然气价格参数)决定了节点决定将您的交易包括在一个块中的速度(如果有的话)。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nr"><img src="../Images/4e38b71616b1d4ec09c26c6cd8b94cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5ZZcF5DJ8SOc8XaLC1qPA.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><a class="ae km" href="https://ethgasstation.info/" rel="noopener ugc nofollow" target="_blank">https://ethgasstation.info/</a> is good place to work out how long you’ll be waiting for your transaction to be included in a block.</figcaption></figure><p id="0cc9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种时间延迟意味着事务是异步的。当我们调用<em class="kj"> sendRawTransaction时，</em>我们会立即得到事务的惟一散列。您可以在任何时候使用这个散列来查询您的事务是否已经包含在一个块中。当且仅当我们能够获得交易收据时，我们才知道交易已经被添加到区块链中(因为所有好的购买都有收据，对吗？).这就是为什么我们创建循环来定期检查我们是否有收据:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="09b6" class="lx kv hu ms b fv mw mx l my mz">    txn_receipt = <strong class="ms hv">None<br/>    </strong>count = 0</span><span id="2bd6" class="lx kv hu ms b fv na mx l my mz">    <strong class="ms hv">while </strong>txn_receipt <strong class="ms hv">is None and </strong>(count &lt; 30):<br/><br/>        txn_receipt = w3.eth.getTransactionReceipt(txn_hash)<br/><br/>        print(txn_receipt)<br/><br/>        time.sleep(10)</span></pre><p id="a8f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">值得注意的是，可以将一个事务添加到区块链中，但仍然会因为许多原因而失败，比如没有足够的汽油。</p><p id="da1c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是将以太发送到契约的Python代码。让我们快速回顾一下我们在Solidity中编写的应付款函数:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="2342" class="lx kv hu ms b fv mw mx l my mz">function() public payable{<br/>        if (msg.value &gt;= 20000000000000000) {  <br/>            approvedSoapboxer[msg.sender] =  true;<br/>        }<br/>    }</span></pre><p id="22e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kj"> Msg </em>是智能合约中的一个特殊变量，包含发送到智能合约的交易信息。在本例中，我们使用的是<em class="kj"> msg.value </em>，它给出了事务中发送的乙醚量(单位为Wei，而不是原始乙醚)。同样，<em class="kj"> msg.sender </em>给出进行交易的钱包的地址——如果已经发送了足够的以太网，我们将把它添加到批准帐户的字典中。</p><p id="de24" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续安润的<em class="kj">发送以太合同</em>功能。希望你能拿回收据。你也可以通过在以太网扫描的Ropsten网络部分查找你的钱包地址来检查交易是否成功。在下一节中，我们将能够获得更多关于Python的信息。</p><h1 id="1bd8" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated"><strong class="ak">调用函数</strong></h1><p id="202b" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">我们刚刚向我们的智能合约发送了一些以太网，因此我们有必要检查我们的钱包地址现在是否已被批准共享意见。为此，我们在智能合约中定义了以下功能:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="2dc3" class="lx kv hu ms b fv mw mx l my mz">function isApproved(address _soapboxer) public view returns (bool approved) {<br/>        return approvedSoapboxer[_soapboxer];<br/>    }</span></pre><p id="4cba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与python相比，围绕这个函数有很多额外的东西，比如声明类型(<em class="kj">地址</em>和<em class="kj">布尔值</em> ) <em class="kj">。</em>这个函数的核心只是获取一个地址(<em class="kj"> _soapboxer </em>参数)，在实际上(但不完全)是哈希表/python字典中查找相应的批准布尔值，并返回该值。</p><p id="8c53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你调用<em class="kj"> </em>一个智能合约函数时，以太坊节点会计算出结果，并返回给你。这里事情变得有点复杂:调用是<em class="kj">只读的，</em>意味着它们不对区块链做任何改变。如果上面的函数包含一行代码来记录地址被检查批准的次数:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="3b2a" class="lx kv hu ms b fv mw mx l my mz">approvedCheckedCount[_soapboxer] = approvedCheckedCount[_soapboxer] + 1</span></pre><p id="019c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，当调用该函数时，节点将计算新的值<em class="kj"> approvedCheckedCount，</em>，但是一旦返回结果，就将其丢弃。</p><p id="219d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为只读的交换，函数调用不会花费你任何运行成本，所以你可以愉快地检查一个帐户是否被批准，而不用担心成本。</p><p id="0574" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们跳回到python文件的顶部，添加更多的设置代码。</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="67df" class="lx kv hu ms b fv mw mx l my mz"><strong class="ms hv">import </strong>contract_abi</span><span id="622e" class="lx kv hu ms b fv na mx l my mz">contract = w3.eth.contract(address = contract_address, abi = contract_abi.abi)</span></pre><p id="c186" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您需要创建另一个名为contract_abi的python文件。这将包含一大串JSON信息，Python需要这些信息与我们在智能契约中定义的函数进行交互，称为应用程序二进制接口(ABI)。您可以在Remix中找到智能合约的ABI JSON字符串:</p><ul class=""><li id="9670" class="nd ne hu je b jf jg jj jk jn nf jr ng jv nh jz ni nj nk nl dt translated">点击“编译”选项卡</li><li id="1b86" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated">点击“详细信息”——应该会出现一个包含大量信息的模式</li><li id="2674" class="nd ne hu je b jf nm jj nn jn no jr np jv nq jz ni nj nk nl dt translated">向下滚动到ABI部分，然后单击“复制到剪贴板”图标。</li></ul><p id="c334" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将复制的字符串粘贴到“contract_abi.py”文件中，该文件应如下所示:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="85b4" class="lx kv hu ms b fv mw mx l my mz">abi = """[<br/> {<br/>   A BIG LIST OF ABI INFO SPREAD ACROSS MULTIPLE DICTS<br/> }<br/>]"""</span></pre><p id="cee1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们添加到主python文件中的另一行现在接受这个ABI JSON字符串，并使用它来设置一个<em class="kj">契约</em>对象。如果您研究<em class="kj">契约</em>，您会注意到它包含一个<em class="kj">函数</em>属性，该属性包含我们在智能契约中创建的三个函数。</p><p id="5e08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们将创建一个python函数，<strong class="je hv">调用智能合约的<em class="kj"> isApproved </em>函数来检查指定地址是否被批准共享意见。</strong></p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="112a" class="lx kv hu ms b fv mw mx l my mz"><strong class="ms hv">def </strong>check_whether_address_is_approved(address):</span><span id="502c" class="lx kv hu ms b fv na mx l my mz">    <strong class="ms hv">return </strong>contract.functions.isApproved(address).call()</span></pre><p id="402c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗯，这是短暂的。</p><p id="e6fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你现在可以用它来检查你的钱包地址是否被批准。如果您之前运行了<em class="kj"> send_ether_to_contract </em>函数并发送了足够量的乙醚，希望您会返回“true”。</p><h1 id="5867" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated"><strong class="ak">使用功能进行交易</strong></h1><p id="02b5" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">我们正在进行智能合约的最后一个主要交互——传播观点。让我们再一次回顾我们的可靠性代码:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="fb58" class="lx kv hu ms b fv mw mx l my mz">function broadcastOpinion(string _opinion) public returns (bool success) {<br/>        if (approvedSoapboxer[msg.sender]) { <br/>  <br/>            opinion = _opinion;<br/>            emit OpinionBroadcast(msg.sender, opinion);<br/>            return true;</span><span id="80cc" class="lx kv hu ms b fv na mx l my mz">        } else {<br/>            return false;<br/>        }<br/>    }</span></pre><p id="206d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里没有什么太新的东西:我们接受传入的<em class="kj"> _opinion </em>参数，并使用它来设置全局变量<em class="kj"> opinion。</em>(如果需要，可以通过getter函数查询)。有一行有点不同:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="63e7" class="lx kv hu ms b fv mw mx l my mz">emit OpinionBroadcast(msg.sender, opinion)</span></pre><p id="7e8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们很快会谈到这一点。<br/> <em class="kj"> <br/> </em>当您通过交易与智能合约的功能进行交互时，该功能对智能合约状态所做的任何更改都会在区块链上发布。作为这一特权的交换，你必须向矿工支付一些(希望很少)乙醚。Python时间:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="c1a9" class="lx kv hu ms b fv mw mx l my mz"><strong class="ms hv">def </strong>broadcast_an_opinion(covfefe):<br/><br/><br/>    nonce = w3.eth.getTransactionCount(wallet_address)<br/><br/>    txn_dict = contract.functions.broadcastOpinion(covfefe).buildTransaction({<br/>        <strong class="ms hv">'chainId'</strong>: 3,<br/>        <strong class="ms hv">'gas'</strong>: 140000,<br/>        <strong class="ms hv">'gasPrice'</strong>: w3.toWei(<strong class="ms hv">'40'</strong>, <strong class="ms hv">'gwei'</strong>),<br/>        <strong class="ms hv">'nonce'</strong>: nonce,<br/>    })<br/><br/>    signed_txn = w3.eth.account.signTransaction(txn_dict, private_key=wallet_private_key)<br/><br/>    result = w3.eth.sendRawTransaction(signed_txn.rawTransaction)<br/><br/>    tx_receipt = w3.eth.getTransactionReceipt(result)<br/><br/>    count = 0<br/>    <strong class="ms hv">while </strong>tx_receipt <strong class="ms hv">is None and </strong>(count &lt; 30):<br/><br/>        time.sleep(10)<br/><br/>        tx_receipt = w3.eth.getTransactionReceipt(result)<br/><br/>        print(tx_receipt)<br/><br/><br/>    <strong class="ms hv">if </strong>tx_receipt <strong class="ms hv">is None</strong>:<br/>        <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'failed'</strong>, <strong class="ms hv">'error'</strong>: <strong class="ms hv">'timeout'</strong>}<br/><br/>    processed_receipt = contract.events.OpinionBroadcast().processReceipt(tx_receipt)<br/><br/>    print(processed_receipt)<br/>    <br/>    output = <strong class="ms hv">"Address {} broadcasted the opinion: {}"</strong>\<br/>        .format(processed_receipt[0].args._soapboxer, processed_receipt[0].args._opinion)<br/>    print(output)<br/><br/>    <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'added'</strong>, <strong class="ms hv">'processed_receipt'</strong>: processed_receipt}</span></pre><p id="ef99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这实际上与向智能合约发送以太网时使用的过程相同。我们将创建并签署一个交易，然后将其发送到网络。同样，事务是异步的，这意味着不管Solidity代码中告诉函数返回什么，您实际得到的总是事务的散列。</p><p id="2036" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到事务本身不会返回任何有用的信息，我们需要一些别的东西。这就把我们带到了与智能合约交互的最后(一半)方法。</p><p id="2643" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">事件</strong></p><p id="1fe0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将事件称为与智能合约交互的“半”方式，因为从技术上讲，它们是由事务发出的。事件是智能合约以一种易于阅读的形式在区块链上记录事情的方式，它们基本上只是一组值，可以使用特定交易的收据来查找。我们在智能合约的顶部定义了一个:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="b84e" class="lx kv hu ms b fv mw mx l my mz">event OpinionBroadcast(address _soapboxer, string _opinion);</span></pre><p id="4f33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，当我们使用<em class="kj"> broadcastOpinion </em>函数时，我们用它向区块链发送信息。</p><p id="6d21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将事务添加到块中后，可以使用事务哈希查询区块链，以获取由OpinionBroadcast事件发出的特定值。这是函数<em class="kj"> broadcast_an_opinion中python代码的最后一部分。</em>您会注意到，我们要求事件发出的信息存储在‘args’属性中。</p><p id="5e51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个事件是非常公开的。事实上，任何人都可以很容易地使用Etherscan或类似工具来查看您的智能合约发出的所有事件的日志。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ns"><img src="../Images/3df30c2b9143e134709eb62104aa03d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwjFW30Gt2D3HaJ3bnIx_A.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Etherscan automatically detects ‘Transfer’ events a lists them all. Nifty</figcaption></figure><p id="a179" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你做到了这一步，你就赢得了发表意见的权利。继续运行<em class="kj"> broadcast_an_opinion </em>和你选择的意见。</p><p id="7681" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果一切运行顺利，您应该很快就会收到一张经过处理的收据，以及一份已经放在区块链上的OpinionBroadcast事件的打印件。</p><p id="980d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很好。</p><p id="b5f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是完整的python代码:</p><pre class="kb kc kd ke fq mr ms mt mu aw mv dt"><span id="1a80" class="lx kv hu ms b fv mw mx l my mz"><strong class="ms hv">import </strong>time<br/><strong class="ms hv">from </strong>web3 <strong class="ms hv">import </strong>Web3, HTTPProvider<br/><br/>contract_address     = [YOUR CONTRACT ADDRESS]<strong class="ms hv"><br/></strong>wallet_private_key   = [YOUR TEST WALLET PRIVATE KEY]<strong class="ms hv"><br/></strong>wallet_address       = [YOUR WALLET ADDRESS]<strong class="ms hv"><br/><br/></strong>w3 = Web3(HTTPProvider([YOUR INFURA URL]))<br/><br/>w3.eth.enable_unaudited_features()<br/><br/>contract = w3.eth.contract(address = contract_address, abi = contract_abi.abi)<br/><br/><strong class="ms hv">def </strong>send_ether_to_contract(amount_in_ether):<br/><br/>    amount_in_wei = w3.toWei(amount_in_ether,<strong class="ms hv">'ether'</strong>);<br/><br/>    nonce = w3.eth.getTransactionCount(wallet_address)<br/><br/>    txn_dict = {<br/>            <strong class="ms hv">'to'</strong>: contract_address,<br/>            <strong class="ms hv">'value'</strong>: amount_in_wei,<br/>            <strong class="ms hv">'gas'</strong>: 2000000,<br/>            <strong class="ms hv">'gasPrice'</strong>: w3.toWei(<strong class="ms hv">'40'</strong>, <strong class="ms hv">'gwei'</strong>),<br/>            <strong class="ms hv">'nonce'</strong>: nonce,<br/>            <strong class="ms hv">'chainId'</strong>: 3<br/>    }<br/><br/>    signed_txn = w3.eth.account.signTransaction(txn_dict, wallet_private_key)<br/><br/>    txn_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction)<br/><br/>    txn_receipt = <strong class="ms hv">None<br/><br/>    </strong>count = 0<br/>    <strong class="ms hv">while </strong>txn_receipt <strong class="ms hv">is None and </strong>(count &lt; 30):<br/><br/>        txn_receipt = w3.eth.getTransactionReceipt(txn_hash)<br/><br/>        print(txn_receipt)<br/><br/>        time.sleep(10)<br/><br/><br/>    <strong class="ms hv">if </strong>txn_receipt <strong class="ms hv">is None</strong>:<br/>        <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'failed'</strong>, <strong class="ms hv">'error'</strong>: <strong class="ms hv">'timeout'</strong>}<br/><br/>    <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'added'</strong>, <strong class="ms hv">'txn_receipt'</strong>: txn_receipt}<br/><br/><br/><strong class="ms hv">def </strong>check_whether_address_is_approved(address):<br/><br/>    <strong class="ms hv">return </strong>contract.functions.isApproved(address).call()<br/><br/><br/><strong class="ms hv">def </strong>broadcast_an_opinion(covfefe):<br/><br/>    nonce = w3.eth.getTransactionCount(wallet_address)<br/><br/>    txn_dict = contract.functions.broadcastOpinion(covfefe).buildTransaction({<br/>        <strong class="ms hv">'chainId'</strong>: 3,<br/>        <strong class="ms hv">'gas'</strong>: 140000,<br/>        <strong class="ms hv">'gasPrice'</strong>: w3.toWei(<strong class="ms hv">'40'</strong>, <strong class="ms hv">'gwei'</strong>),<br/>        <strong class="ms hv">'nonce'</strong>: nonce,<br/>    })<br/><br/>    signed_txn = w3.eth.account.signTransaction(txn_dict, private_key=wallet_private_key)<br/><br/>    result = w3.eth.sendRawTransaction(signed_txn.rawTransaction)<br/><br/>    tx_receipt = w3.eth.getTransactionReceipt(result)<br/><br/>    count = 0<br/>    <strong class="ms hv">while </strong>tx_receipt <strong class="ms hv">is None and </strong>(count &lt; 30):<br/><br/>        time.sleep(10)<br/><br/>        tx_receipt = w3.eth.getTransactionReceipt(result)<br/><br/>        print(tx_receipt)<br/><br/><br/>    <strong class="ms hv">if </strong>tx_receipt <strong class="ms hv">is None</strong>:<br/>        <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'failed'</strong>, <strong class="ms hv">'error'</strong>: <strong class="ms hv">'timeout'</strong>}<br/><br/>    processed_receipt = contract.events.OpinionBroadcast().processReceipt(tx_receipt)<br/><br/>    print(processed_receipt)<br/><br/>    output = <strong class="ms hv">"Address {} broadcasted the opinion: {}"</strong>\<br/>        .format(processed_receipt[0].args._soapboxer, processed_receipt[0].args._opinion)<br/>    print(output)<br/><br/>    <strong class="ms hv">return </strong>{<strong class="ms hv">'status'</strong>: <strong class="ms hv">'added'</strong>, <strong class="ms hv">'processed_receipt'</strong>: processed_receipt}<br/><br/><strong class="ms hv">if </strong>__name__ == <strong class="ms hv">"__main__"</strong>:<br/><br/>    send_ether_to_contract(0.03)<br/><br/>    is_approved = check_whether_address_is_approved(wallet_address)<br/>    <br/>    print(is_approved)<br/><br/>    broadcast_an_opinion(<strong class="ms hv">'Despite the Constant Negative Press'</strong>)</span></pre><h1 id="ef90" class="ku kv hu bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr dt translated">包扎</h1><p id="7fc3" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">这样就差不多了。正如我提到的，我们还没有达到使用python实际部署智能合约的地步，但其他一切都在那里。在<a class="ae km" href="https://sempo.ai" rel="noopener ugc nofollow" target="_blank"> Sempo </a>，我们正在使用我上面提到的所有技术来使灾难响应更加透明。</p><p id="48c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你有任何想法或建议，请在评论中留下，我会尽快回复你！</p><p id="21f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编辑:感谢<a class="kk kl gr" href="https://medium.com/u/6771b8406a1c?source=post_page-----771b03990988--------------------------------" rel="noopener" target="_blank"> Sebastian Dirman </a>指出w3.toWei(value，' ether ')是一种在ether和Wei之间转换的更好的方法——简单地将你在Ether中的数量乘以1000000000000000会导致类型错误！</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nt"><img src="../Images/fecf96405dfc6f95695b04b93c27fed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_2iOC9Nfo1mzcxNEQS9FQ.jpeg"/></div></div></figure></div></div>    
</body>
</html>