<html>
<head>
<title>How to write Scalable Nodejs Services [+Code Examples]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写可伸缩的Nodejs服务[+代码示例]</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-write-scalable-nodejs-services-code-examples-b48baa2d9eb9?source=collection_archive---------10-----------------------#2018-04-12">https://medium.com/hackernoon/how-to-write-scalable-nodejs-services-code-examples-b48baa2d9eb9?source=collection_archive---------10-----------------------#2018-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8aad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近有机会在<a class="ae jp" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> Nodejs </a>环境中使用OOP模式，并且我花了很长时间这样做。</p><p id="4795" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看这次我们要构建什么:</p><ul class=""><li id="d4ca" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">构建一个<a class="ae jp" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>服务，提供两个资源:<strong class="it hv"> apps </strong>和<strong class="it hv"> developers </strong>，但是以后会添加更多的资源。</li><li id="c85b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">数据是从NoSql数据库中读取的，但是读取数据的位置将来可能会改变。</li><li id="311c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">当提供应用程序时，我们需要为其关联的开发者提供一个特殊的属性“author_info”(每个模型可能包含不同的规则，这些规则定义了如何提供项目)。</li><li id="97ab" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">现在这个服务将只负责读取数据，但是我们应该允许在每个模型上创建和更新操作。</li><li id="7c1f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">我们需要能够改变特定模型的输出格式(我们有合作伙伴仍然使用xml格式)。</li></ul><p id="020b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">存储在数据库中的模型原始格式如下:</p><p id="6b7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">开发商</strong></p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="b218" class="kn ko hu kj b fv kp kq l kr ks">{<br/>    "id": 23,<br/>    "name": "AresGalaxy",<br/>    "url": "<a class="ae jp" href="https://aresgalaxy.io/" rel="noopener ugc nofollow" target="_blank">https://aresgalaxy.io/</a>"<br/>},</span></pre><p id="3605" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> app </strong></p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="e7e8" class="kn ko hu kj b fv kp kq l kr ks">{<br/>    "id": 21824,<br/>    "developer_id": 23,<br/>    "title": "Ares",<br/>    "version": "2.4.0",<br/>    "url": "<a class="ae jp" href="http://ares.en.softonic.com" rel="noopener ugc nofollow" target="_blank">http://ares.en.softonic.com</a>",<br/>    "short_description": "Fast and unlimited P2P file sharing",<br/>    "license": "Free (GPL)",<br/>    "thumbnail": "<a class="ae jp" href="https://screenshots.en.sftcdn.net/en/scrn/21000/21824/ares-14-100x100.png" rel="noopener ugc nofollow" target="_blank">https://screenshots.en.sftcdn.net/en/scrn/21000/21824/ares-14-100x100.png</a>",<br/>    "rating": 8,<br/>    "total_downloads": "4741260",<br/>    "compatible": [<br/>      "Windows 2000",<br/>      "Windows XP",<br/>      "Windows Vista",<br/>      "Windows 7",<br/>      "Windows 8"<br/>    ]<br/>},</span></pre><p id="29ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当获取开发者资源时，它应该保持原样。但是在获取<strong class="it hv">应用</strong>时，我们需要像这样合并<code class="eh kt ku kv kj b">developer</code>模型:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="068a" class="kn ko hu kj b fv kp kq l kr ks">{<br/>    "id": 21824,<br/>    "developer_id": 23,<br/><strong class="kj hv">    "author_info": {<br/>        "id": 23,<br/>        "name": "AresGalaxy",<br/>        "url": "</strong><a class="ae jp" href="https://aresgalaxy.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kj hv">https://aresgalaxy.io/</strong></a><strong class="kj hv">"<br/>    },</strong><br/>    "title": "Ares",<br/>    "version": "2.4.0",<br/>    "url": "<a class="ae jp" href="http://ares.en.softonic.com" rel="noopener ugc nofollow" target="_blank">http://ares.en.softonic.com</a>",<br/>    "short_description": "Fast and unlimited P2P file sharing",<br/>    "license": "Free (GPL)",<br/>    "thumbnail": "<a class="ae jp" href="https://screenshots.en.sftcdn.net/en/scrn/21000/21824/ares-14-100x100.png" rel="noopener ugc nofollow" target="_blank">https://screenshots.en.sftcdn.net/en/scrn/21000/21824/ares-14-100x100.png</a>",<br/>    "rating": 8,<br/>    "total_downloads": "4741260",<br/>    "compatible": [<br/>      "Windows 2000",<br/>      "Windows XP",<br/>      "Windows Vista",<br/>      "Windows 7",<br/>      "Windows 8"<br/>    ]<br/>},</span></pre><p id="6e4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是我对此的想法:</p><p id="0039" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要以一种非常简单的方式来声明资源，但是似乎每个资源在格式和输出上都是不同的。</p><p id="c364" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们需要从<code class="eh kt ku kv kj b">Resource</code>概念中提取“公共”部分，并为每个<code class="eh kt ku kv kj b">Model</code>构建不同且独立的实现。</p><p id="9809" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">什么是<code class="eh kt ku kv kj b">Model</code>？在REST范式中，我们通常将资源调用到某个通过URL ( <code class="eh kt ku kv kj b">api.io/rest/employee</code>)表示的<code class="eh kt ku kv kj b">domain item</code>，我们可以使用HTTP动词并提供几个参数来轻松地与它进行交互。</p><p id="70c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当编写可维护的API时，我们需要区别于描述每个资源的规则的代码和定义如何实现HTTP连接的代码。</p><p id="d439" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我最后创建了两个基本实体，分别是<code class="eh kt ku kv kj b">models</code>和<code class="eh kt ku kv kj b">resources</code>。</p><ul class=""><li id="648b" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">资源是执行HTTP通信的类，现在我们只有一个类，因为应用程序和开发人员在这一层不包含差异。</li><li id="47e5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">模型是描述如何操作的类，比如从数据库读取数据、连接数据、格式化输出等。是为某个特定的领域实体做的，像开发者和app，它们是不同的，应该是独立的。</li></ul><p id="b85a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们有两个模型类<code class="eh kt ku kv kj b">developer</code>和<code class="eh kt ku kv kj b">app</code>以及一个单独的<code class="eh kt ku kv kj b">resource</code>类。但是，在运行时，我们有两个资源实例，每个都有自己的模型实例，负责特定的域规则。</p><p id="685d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是开始的脚本:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="e106" class="kn ko hu kj b fv kp kq l kr ks">const { setConfig } = require("ritley");<br/>setConfig(require("./ritley.conf"));</span><span id="1876" class="kn ko hu kj b fv kw kq l kr ks">const BasicResource = require("./resources/basic-resource");</span><span id="6aa6" class="kn ko hu kj b fv kw kq l kr ks">[<br/>  require("./models/app"),<br/>  require("./models/developer"),<br/>].forEach(Model =&gt; <strong class="kj hv">new BasicResource(new Model)</strong>);</span></pre><p id="384d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们用的是<a class="ae jp" href="https://www.npmjs.com/package/ritley" rel="noopener ugc nofollow" target="_blank">里特利</a>。一个月前我为快速后端开发和REST服务做的轻量级包。</p><p id="0c7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以在前面的代码中，我们只需要我们的ritley配置，它基本上设置了rest路径、静态资产文件夹(如果需要)和监听端口。</p><p id="4725" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们只需遍历模型，并创建一个资源实例来绑定它的模型，我们就准备好了。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="3cf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一下文件夹结构:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="ed14" class="kn ko hu kj b fv kp kq l kr ks">.<br/>├── <strong class="kj hv">adapters</strong><br/>│ ├── low.conf.js<br/>│ ├── low.js<br/>│ └── low-provider.js<br/>├── low.database.json<br/>├── <strong class="kj hv">models</strong><br/>│ ├── app.js<br/>│ ├── common.js<br/>│ └── developer.js<br/>├── package.json<br/>├── README.md<br/>├── <strong class="kj hv">resources</strong><br/>│ └── basic-resource.js<br/>├── ritley.conf.js<br/>├── run.js<br/>├── <strong class="kj hv">test<br/></strong>│ └── developers.test.js</span><span id="98bf" class="kn ko hu kj b fv kw kq l kr ks">4 directories, 13 files</span></pre><p id="2427" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经创建了models/common.js抽象类作为进一步模型的起点:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="4f71" class="kn ko hu kj b fv kp kq l kr ks">const { inject, createClass } = require("kaop")<br/>const LowProvider = require("../adapters/low-provider");</span><span id="7ab3" class="kn ko hu kj b fv kw kq l kr ks">module.exports = CommonModel = createClass({<br/>  adapter: null,<br/><strong class="kj hv">  constructor: [inject.args(LowProvider), function(_db) {<br/>    this.adapter = _db;<br/>  }],<br/></strong>  read() {<br/>    return new Promise(resolve =&gt; resolve("read not implemented"));<br/>  },<br/>  find() {<br/>    return new Promise(resolve =&gt; resolve("find not implemented"));<br/>  },<br/>  toString(obj) {<br/>    return JSON.stringify(obj);<br/>  }<br/>})</span></pre><p id="c0a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能注意到我没有使用和声ES类。那是因为我们需要像装饰者这样的东西，而我们现在不想使用任何代码转换器。相反，我们使用<a class="ae jp" href="https://www.npmjs.com/package/kaop" rel="noopener ugc nofollow" target="_blank"> kaop </a>来轻松实现反射技术，例如<strong class="it hv">依赖注入</strong>。</p><p id="8114" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以基本上前面的代码声明了一个<strong class="it hv">抽象模型</strong>，它将包含一个访问数据库的lowdb实例适配器。如果我们改变我们的数据库服务，我们只需要关心导入另一个提供者。</p><p id="14d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下代码代表models/developer.js:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="c8a0" class="kn ko hu kj b fv kp kq l kr ks">const { extend } = require("kaop");<br/>const CommonModel = require("./common");</span><span id="1432" class="kn ko hu kj b fv kw kq l kr ks">module.exports = DeveloperModel = extend(CommonModel, {<br/><strong class="kj hv">  path: "developer",<br/></strong>  read() {<br/>    return new Promise(resolve =&gt;<br/>      resolve(this.adapter.getCollection("developers")));<br/>  }<br/>});</span></pre><p id="64b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这只是在读取方法实现上不同于通用模型，所以我们只是用一个新的模型来替换它。</p><p id="f88c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们的DeveloperModel包含path属性，basic resource将使用该属性来监听几个路径。以下是方法:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="2615" class="kn ko hu kj b fv kp kq l kr ks">const { extend, override } = require("kaop");</span><span id="6b94" class="kn ko hu kj b fv kw kq l kr ks">module.exports = BasicResource = extend(AbstractResource, {<br/>  constructor: [override.implement, function(parent, _model) {<br/><strong class="kj hv">    parent(_model.path);</strong><br/>    this.model = _model;<br/>  }],</span><span id="2973" class="kn ko hu kj b fv kw kq l kr ks">  get(request, response) {<br/>    let prom = null;</span><span id="3d9c" class="kn ko hu kj b fv kw kq l kr ks">    if(request.query.id) {<br/>      prom = this.model.find(request.query);<br/>    } else {<br/>      prom = this.model.read();<br/>    }<br/>    prom.then(result =&gt;<br/>      this.writeResponse(response, this.model.toString(result)));<br/>  },</span><span id="03fc" class="kn ko hu kj b fv kw kq l kr ks">  writeResponse(response, body) {<br/>    body &amp;&amp; response.write(body);<br/>    response.statusCode = 200;<br/>    response.end();<br/>  }<br/>})</span></pre><p id="2f2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">BasicResource从AbstractResource扩展而来，重写其构造函数以提供路径，正如您在突出显示的行中所看到的，这将为每个实例调用。正如我们在启动脚本中看到的，模型被传递给资源，以正确地构建我们的HTTP侦听器。BasicResource的get方法将拦截所有指向每个路径的HTTP GET请求。用开发人员模型配置的一个实例将只在<strong class="it hv"> &lt;主机&gt;/rest/开发人员</strong>路径上有效地监听，依此类推。</p><p id="4fca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，请求<strong class="it hv">&lt;host&gt;/rest/developer</strong>的客户机将由BasicResource实例来回答，该实例是用DeveloperModel实例创建的。</p><p id="1fc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，如果我们希望允许post或PUT请求，我们需要在BasicResource上写下一个POST方法，ritley允许我们简单地编写名为HTTP动词的方法，因此任何匹配的请求都将得到处理。如果我们需要仅在几个路径上允许POST，我们可能需要将BasicResource扩展到AdvancedResource或允许更多HTTP动词的东西。这是正确分离关注点的最佳实践。</p><p id="a01a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许模型需要按照它们需要挂载的资源类型进行分组。</p><p id="ad54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="af64" class="kn ko hu kj b fv kp kq l kr ks">const { setConfig } = require("ritley");<br/>setConfig(require("./ritley.conf"));</span><span id="3c62" class="kn ko hu kj b fv kw kq l kr ks">const BasicResource = require("./resources/basic-resource");<br/><strong class="kj hv">const AdvancedResource = require("./resources/advanced-resource");</strong></span><span id="76b5" class="kn ko hu kj b fv kw kq l kr ks">[<br/>  require("./models/app"),<br/>  require("./models/developer"),<br/>].forEach(Model =&gt; new BasicResource(new Model));</span><span id="0dce" class="kn ko hu kj b fv kw kq l kr ks"><strong class="kj hv">[<br/>  require("./models/company")<br/>].forEach(Model =&gt; new AdvancedResource(new Model));</strong></span></pre></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><p id="dbbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们看一下初始需求，看看这是不是一个好方法(<em class="le">问题</em> — <strong class="it hv">回答</strong>):</p><ul class=""><li id="8165" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><em class="le">构建一个API服务，提供两种模式:</em><strong class="it hv"><em class="le">apps</em></strong><em class="le">和</em><strong class="it hv"><em class="le">developers</em></strong><em class="le">，不过以后会增加更多的资源。— </em> <strong class="it hv">添加新模型非常简单，我们只需从普通模型扩展创建一个新模型，实现所需的方法，并在启动脚本上声明</strong></li><li id="33bd" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><em class="le">数据是从NoSql数据库中读取的，但是读取数据的位置将来可能会改变。— </em> <strong class="it hv">负责访问数据服务的代码在</strong> <code class="eh kt ku kv kj b"><strong class="it hv">adapter</strong></code> <strong class="it hv">文件夹里，我们用的是一个牛逼的资源比如</strong><a class="ae jp" href="https://www.npmjs.com/package/lowdb" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">lowdb</strong></a><strong class="it hv">。我们有3个不同的文件:</strong> <code class="eh kt ku kv kj b"><strong class="it hv">low.conf.js</strong></code> <strong class="it hv">包含数据库路径，</strong> <code class="eh kt ku kv kj b"><strong class="it hv">low.js</strong></code> <strong class="it hv">将lowdb方法包装成与域相关的动作供模型使用，以及</strong> <code class="eh kt ku kv kj b"><strong class="it hv">low-provider.js</strong></code> <strong class="it hv">声明注入模型的单例依赖，这样我们可以快速切换不同的数据库服务:)</strong></li><li id="239b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><em class="le">当提供应用程序时，我们需要为其相关开发者提供一个特殊属性“author_info”(每个模型可能包含不同的规则，这些规则定义了如何提供项目)</em>。— <strong class="it hv">每个模型都有自己的方法来检索数据，直到资源，因此我们可以根据自己的需要构建数据。对于这个特殊的例子，我们在db适配器上创建了一个方法，因为嵌套模型在这里是一个非常常见的例子</strong> <code class="eh kt ku kv kj b"><strong class="it hv">adapters/low.js</strong></code> <strong class="it hv"> : </strong></li></ul><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="1960" class="kn ko hu kj b fv kp kq l kr ks"><strong class="kj hv">getMappedCollection(uid, joinuid, joinkey, newkey) {<br/></strong>  const joincollection = this.instance.get(joinuid);<br/>  return this.instance<br/>    .get(uid)<br/>    .map(app =&gt; this.mergePredicate(<br/>      app,<br/>      joincollection.find({ "id": app[joinkey]}),<br/>      newkey)<br/>    )<br/>    .value();<br/>},<br/>mergePredicate(app, subject, newkey) {<br/>  return { ...app, { [newkey]: ...subject } };<br/>},</span></pre><p id="1d1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">然后，因为app model是唯一一个提供嵌套项目的，所以我们利用它</strong> <code class="eh kt ku kv kj b"><strong class="it hv">models/app.js</strong></code> <strong class="it hv"> : </strong></p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="5b64" class="kn ko hu kj b fv kp kq l kr ks">read() {<br/>  return new Promise(resolve =&gt;<br/><strong class="kj hv">    resolve(this.adapter.getMappedCollection(<br/></strong>      "apps", "developers", "developer_id", "author_info")<br/>    ));<br/>},</span></pre><ul class=""><li id="4783" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><em class="le">现在这个服务将只负责读取数据，但是我们应该允许在每个模型上创建和更新操作。— </em> <strong class="it hv">已经解决，但要展示一个例子:</strong></li></ul><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="d8d6" class="kn ko hu kj b fv kp kq l kr ks">const { extend, override } = require("kaop");<br/>const BasicResource = require("./basic-resource");</span><span id="a6f7" class="kn ko hu kj b fv kw kq l kr ks">// we only need to implement a new method since this class inherits<br/>// from BasicResource<br/>module.exports = AdvancedResource = extend(BasicResource, {</span><span id="3410" class="kn ko hu kj b fv kw kq l kr ks">  post(request, response) {<br/>    // create entry logic<br/>  }<br/>});</span></pre><ul class=""><li id="0c23" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><em class="le">我们需要能够改变特定模型的输出格式(我们有合作伙伴仍然使用xml格式)</em>。— <strong class="it hv">如果一个特定的模型需要不同于其他模型的输出，那么我们需要从</strong> <code class="eh kt ku kv kj b"><strong class="it hv">models/common.js</strong></code> <strong class="it hv">中覆盖</strong> <code class="eh kt ku kv kj b"><strong class="it hv">toString()</strong></code> <strong class="it hv">方法。假设DeveloperModel需要以XML格式输出，因为我们的一些合作伙伴目前仍在使用2008 SQL Server..</strong></li></ul><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="fa1e" class="kn ko hu kj b fv kp kq l kr ks">const { extend } = require("kaop");<br/>const CommonModel = require("./common");<br/><strong class="kj hv">const xmlconverter = require("awesomexmlparser");</strong></span><span id="73fc" class="kn ko hu kj b fv kw kq l kr ks">module.exports = DeveloperModel = extend(CommonModel, {<br/>  path: "developer",<br/>  read() {<br/>    return new Promise(resolve =&gt;<br/>      resolve(this.adapter.getCollection("developers")));<br/>  },<br/><strong class="kj hv">  toString(obj) {<br/>    return xmlconverter.stringify(obj);<br/>  }<br/></strong>})</span></pre><h1 id="faf0" class="lf ko hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">今天就到这里吧！非常感谢:)</h1><p id="a6b4" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">你可以在这里查看代码<a class="ae jp" href="https://github.com/k1r0s/micro-ritley-lowdb-example" rel="noopener ugc nofollow" target="_blank">https://github.com/k1r0s/micro-ritley-lowdb-example</a></p><figure class="ke kf kg kh fq mh"><div class="bz el l di"><div class="mi mj l"/></div></figure></div></div>    
</body>
</html>