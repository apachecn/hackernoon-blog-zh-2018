<html>
<head>
<title>Thoughts on cyclomatic complexity in Golang's world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于戈朗世界圈复杂度的思考</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/thoughts-on-cyclomatic-complexity-in-golangs-world-51db3507e1ec?source=collection_archive---------11-----------------------#2018-04-12">https://medium.com/hackernoon/thoughts-on-cyclomatic-complexity-in-golangs-world-51db3507e1ec?source=collection_archive---------11-----------------------#2018-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fad7768bc4149c00189d5ce6f35e91cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFaeNO48gYlRMQii977cQg.jpeg"/></div></div></figure><p id="dff3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">圈复杂度有助于我们避免编写更容易出错、测试更复杂、推理更困难的复杂代码。我会特别关注后者，因为它意味着可读性低和维护成本高。例如，if/else语句通常用作:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="f5f5" class="kj kk hu kf b fv kl km l kn ko">if THIS then<br/> do some logic in order to return THAT</span><span id="d0f0" class="kj kk hu kf b fv kp km l kn ko">if THAT then<br/> do some logic in order to return THIS</span><span id="b226" class="kj kk hu kf b fv kp km l kn ko">if SOMETHINGELSE then<br/> do some logic in order to return THAT and THIS<br/>else<br/> do some logic in order to return THIS and THAT</span></pre><p id="5fbd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常每个块都包含一些逻辑，以便做一些事情。自然，每个逻辑都需要关注，因为你必须理解一个模块在做什么，它的目的是什么，以及预期的结果是否是正在产生的。现在想象一个有20个条件语句的函数，每个语句产生一个不同的结果，你必须解释(并记住)这个函数在什么条件下返回所有的值。可能你已经明白了。</p><p id="1f01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，请注意圈复杂度并不试图确定控制流图中包含的每条路径有多复杂。它并不试图理解程序架构的每个模块，相反，它关注于大多数程序是如何编写的，并假设所有情况都是一样的。为了有所帮助，它假设所有的执行路径都包含一个特定的和唯一的逻辑，大多数时候都是这样。从我开始在Go中<a class="ae kq" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>开始，我就一直在思考那一点。按照我们在<a class="ae kq" href="https://hackernoon.com/tagged/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a>中使用的错误处理模式，检查另一个例子:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="e5af" class="kj kk hu kf b fv kl km l kn ko"><br/>THIS, ERR := fnGetThis()<br/>if ERR then<br/> return error</span><span id="469c" class="kj kk hu kf b fv kp km l kn ko">THAT, ERR := fnGetThat()<br/>if ERR then<br/> return error</span><span id="8b9c" class="kj kk hu kf b fv kp km l kn ko">SOMETHINGELSE, ERR := fnGetSomethingElse()<br/>if ERR then<br/> return error</span><span id="0550" class="kj kk hu kf b fv kp km l kn ko">WHATEVER, ERR := fnGetWhatever()<br/>if ERR then<br/> return error</span><span id="dff8" class="kj kk hu kf b fv kp km l kn ko">do some logic in order to produce the expected result using THIS, THAT, SOMETHINGELSE and WHATEVER<br/></span></pre><p id="2360" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我看来，只返回一个错误而没有额外逻辑的if语句没有一个是容易出错的，也没有一个是很难推理的，也没有一个是很难解释整个代码块的目的的。它做一件事，一旦它需要的一切工作。</p><p id="91e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们可以选择放弃返回一个错误是唯一要做的事情，而不是其他事情的情况，也许会出现一个更好的圈复杂度分析。因为产生这些错误的真正复杂性并没有写在那里，而是写在被调用的函数中。</p><p id="9cb3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望听到更多关于这个主题的想法，因为我在这里的目标是讨论它。所以，请随意发表评论😉。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure></div></div>    
</body>
</html>