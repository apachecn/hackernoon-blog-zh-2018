<html>
<head>
<title>Learnings while benchmarking Java Template Engine with Spring Boot — 2018</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 2018年Java模板引擎性能指标评测的收获</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/learnings-while-benchmarking-java-template-engine-with-spring-boot-2018-41ff2a7d6314?source=collection_archive---------11-----------------------#2018-04-13">https://medium.com/hackernoon/learnings-while-benchmarking-java-template-engine-with-spring-boot-2018-41ff2a7d6314?source=collection_archive---------11-----------------------#2018-04-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="22e2" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用java模板引擎+ Spring Boot的服务器端渲染性能测试和一些正在进行的学习</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/503ba643ca2128769acb5834d4bdecf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*vFgAOLNVaRYSrtGPRFnZsw.jpeg"/></div></figure><p id="3f58" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这篇文章是关于服务器端渲染工具的基准测试，即最常用的基于<a class="ae kn" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> java </a>的模板引擎，即<a class="ae kn" href="http://velocity.apache.org/" rel="noopener ugc nofollow" target="_blank"> Velocity </a>、<a class="ae kn" href="https://freemarker.apache.org/" rel="noopener ugc nofollow" target="_blank"> Freemarker </a>和<a class="ae kn" href="http://httl.github.io/" rel="noopener ugc nofollow" target="_blank"> HTTL </a>(对我来说是新的)以及我在这样做时学到的经验。我已经使用过Velocity和Freemarker作为我的服务器端渲染工具，但是在阅读了关于HTTL的内容后，我想真正了解这三个软件在Spring Boot项目中的表现。</p><p id="1102" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">下面是java服务器端渲染/模板基准测试将发生的系统信息:</p><ol class=""><li id="93b8" class="ko kp hu jt b ju jv jx jy ka kq ke kr ki ks km kt ku kv kw dt translated">操作系统:MacOS Sierra</li><li id="0fb9" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km kt ku kv kw dt translated">处理器:1.6 GHz英特尔酷睿i5处理器</li><li id="b37f" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km kt ku kv kw dt translated">Java: Java(TM) SE运行时环境(内部版本1.8.0_121-b13)</li><li id="9eee" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km kt ku kv kw dt translated">Java HotSpot(TM) 64位服务器虚拟机(内部版本25.121-b13，混合模式)</li></ol><p id="6c58" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">对于基准测试，我们使用的是<a class="ae kn" href="https://httpd.apache.org/docs/2.4/programs/ab.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hv"> Apache bench </strong> </a>。代码是一个简单的spring boot应用程序，公开了三个端点和三个基于spring的视图解析器，如下所示。</p><p id="775d" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">你可以从这个<a class="ae kn" href="https://github.com/apuravchauhan/java-serversiderender-performance" rel="noopener ugc nofollow" target="_blank"> github repo </a>下载完整的代码</p><blockquote class="lc ld le"><p id="6167" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated">@ springboot application<br/>@ Controller<br/>public class template benchmark {</p><p id="0bbf" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated">@ Bean<br/>public httlviewrolver httlviewrolver(){<br/>httlviewrolver resolver = new httlviewrolver()；<br/>……<br/>返回解析器；<br/>}<br/>@ Bean<br/>public view resolver vmviewrolver(){<br/>velocitylayoutviewrolver Bean = new velocitylayoutviewrolver()；<br/> …。<br/>返豆；<br/>}<br/><br/>@ request mapping("/check out-httl ")<br/>公共字符串check out(Model Model){<br/>Model . add attribute(" name "，" Apurav Chauhan ")；<br/>返回“check out-httl”；<br/> } <br/> }</p></blockquote><h1 id="15b4" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ja lu jb lv jd lw je lx jg ly jh lz ma dt translated">第1轮—简单键值+ HTML呈现</h1><h2 id="d2d9" class="mb lk hu bd ll mc md me lp mf mg mh lt ka mi mj lv ke mk ml lx ki mm mn lz mo dt translated">用于服务器端渲染的HTTL模板引擎</h2><p id="9eeb" class="pw-post-body-paragraph jr js hu jt b ju mp iv jw jx mq iy jz ka mr kc kd ke ms kg kh ki mt kk kl km hn dt translated">我们用总共5000个请求预热服务器，并发数为5。</p><p id="d8b0" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最后，我们使用以下命令将工作台设置为达到25K个请求，并发数为25</p><blockquote class="lc ld le"><p id="1242" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated"><em class="hu">a b-n 25000-c 25-g httl . tsv-k</em><a class="ae kn" href="http://localhost:9090/checkout-httl" rel="noopener ugc nofollow" target="_blank"><em class="hu">http://localhost:9090/check out-httl</em></a></p></blockquote><p id="ca3b" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="lf"> -n用于总请求的标志| -c用于并发| -g用于将工作台统计信息保存到制表符分隔的文件| -k用于启用保持活动连接</em></p><h2 id="2af6" class="mb lk hu bd ll mc md me lp mf mg mh lt ka mi mj lv ke mk ml lx ki mm mn lz mo dt translated">学习1</h2><p id="94f7" class="pw-post-body-paragraph jr js hu jt b ju mp iv jw jx mq iy jz ka mr kc kd ke ms kg kh ki mt kk kl km hn dt translated">在进行基准测试时，如果看到这个错误<strong class="jt hv"><em class="lf">" apr _ socket _ recv:Operation timed out(60)"</em></strong>其原因是负载已经消耗了MacOS上所有可用的16，383个端口。</p><p id="02d2" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae kn" href="https://stackoverflow.com/a/30357879/949912" rel="noopener ugc nofollow" target="_blank"> <em class="lf">当每个端口被使用时，它被放入一个队列，在那里等待tcp“最大段寿命”，在osx上被配置为15秒。因此，如果您在15秒钟内使用超过16，383个端口，您将有效地被操作系统限制进一步的连接。根据哪个进程先用完端口，会从服务器得到连接错误，或者从</em> </a> <code class="eh mu mv mw mx b"><a class="ae kn" href="https://stackoverflow.com/a/30357879/949912" rel="noopener ugc nofollow" target="_blank"><em class="lf">ab</em></a></code> <a class="ae kn" href="https://stackoverflow.com/a/30357879/949912" rel="noopener ugc nofollow" target="_blank"> <em class="lf">挂起。</em> </a></p><p id="0270" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">要解决这个问题，使用下面的命令检查macos终端的默认等待时间。</p><blockquote class="lc ld le"><p id="9056" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated"><code class="eh mu mv mw mx b">sysctl net.inet.tcp.msl</code></p></blockquote><p id="554d" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">并使用以下命令将其更新为较低的值，如1000毫秒</p><blockquote class="lc ld le"><p id="fc8e" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated"><code class="eh mu mv mw mx b">sudo sysctl -w net.inet.tcp.msl=1000</code></p></blockquote><h2 id="7712" class="mb lk hu bd ll mc md me lp mf mg mh lt ka mi mj lv ke mk ml lx ki mm mn lz mo dt translated">下面是统计数据:</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff my"><img src="../Images/fa7edf1df3c53297230377c8f3ee3880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFF536LCSk-qjMhp4pZEQw.png"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">HTTL VisualVM Stats</figcaption></figure><p id="f322" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">总共有25K个请求在大约3秒内完成</strong>。CPU使用率飙升至70%。单个请求的平均处理时间为0.134毫秒</p><h2 id="c9ed" class="mb lk hu bd ll mc md me lp mf mg mh lt ka mi mj lv ke mk ml lx ki mm mn lz mo dt translated">用于java服务器端渲染的Freemarker模板引擎</h2><p id="5d2a" class="pw-post-body-paragraph jr js hu jt b ju mp iv jw jx mq iy jz ka mr kc kd ke ms kg kh ki mt kk kl km hn dt translated">重复相同的步骤来获取下面的统计数据</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff nh"><img src="../Images/166a8feb704682216a955a9213f64874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlYgDkFZHuv1c7OC0zJS0A.png"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">FTL JVM Stats</figcaption></figure><p id="d7d1" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">总共有25K个请求在大约12秒</strong>内完成。CPU使用率飙升至30%。单个请求的平均处理时间为0.476毫秒</p><h2 id="e290" class="mb lk hu bd ll mc md me lp mf mg mh lt ka mi mj lv ke mk ml lx ki mm mn lz mo dt translated">用于java服务器端渲染的Velocity模板引擎</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff ni"><img src="../Images/a4c49c01da73a79029c66de55fc204e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZMU_UyQ3-wazhnziicpYQ.png"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">VM JVM Stats</figcaption></figure><p id="6331" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">总共25K个请求在大约6秒内完成</strong>。CPU使用率飙升至90%。单个请求的平均处理时间为0.253毫秒</p><h1 id="bbbb" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ja lu jb lv jd lw je lx jg ly jh lz ma dt translated">基准数据的GNUPLOT</h1><p id="c30a" class="pw-post-body-paragraph jr js hu jt b ju mp iv jw jx mq iy jz ka mr kc kd ke ms kg kh ki mt kk kl km hn dt translated">使用通过-g标志生成的tsv文件，我们现在将生成一个图表来实际查看这些引擎彼此之间的性能比较。您可以查看用于创建下图的<a class="ae kn" href="https://github.com/apuravchauhan/java-serversiderender-performance/blob/master/gnuplots-templates/template.p" rel="noopener ugc nofollow" target="_blank"> this </a>和<a class="ae kn" href="https://github.com/apuravchauhan/java-serversiderender-performance/blob/master/gnuplots-templates/template2.p" rel="noopener ugc nofollow" target="_blank"> this </a> github链接中的模板文件。运行以下命令:</p><blockquote class="lc ld le"><p id="ebeb" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated">gnuplot模板. p</p><p id="0f94" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated">gnuplot模板2.p</p></blockquote><div class="jk jl jm jn fq ab cb"><figure class="nj jo nk nl nm nn no paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><img src="../Images/1452af4aeed1f18e4c725afd7f099ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1SpG_IwXQDxM9lpZUJqLFw.jpeg"/></div></figure><figure class="nj jo nk nl nm nn no paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><img src="../Images/d18ad5ba74409dd76dc5a5f4dbb879dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*r29bXcVnp9jXbG2oo7TcUw.png"/></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek np di nq nr">Benchmarks HTTL vs Freemarker vs Velocity</figcaption></figure></div><blockquote class="lc ld le"><p id="be6c" class="jr js lf jt b ju jv iv jw jx jy iy jz lg kb kc kd lh kf kg kh li kj kk kl km hn dt translated">HTTL无疑大放异彩，但Freemarker显示出巨大的劣势。让我们深入挖掘。在分析ab结果时，我们可以看到freemarker没有使用任何导致扭曲行为的keep alive请求，而是在结果中包含了连接创建延迟。但是为什么呢？</p></blockquote><h2 id="8b7b" class="mb lk hu bd ll mc md me lp mf mg mh lt ka mi mj lv ke mk ml lx ki mm mn lz mo dt translated">学习2</h2><p id="5da7" class="pw-post-body-paragraph jr js hu jt b ju mp iv jw jx mq iy jz ka mr kc kd ke ms kg kh ki mt kk kl km hn dt translated">经过一些研究，发现ab工具工作在Http/1.0协议上，该协议定义了服务器发送一个Content-Length报头以尊重保持活动连接。Freemarker使用分块编码响应进行响应，因此不允许使用Connection: KeepAlive头进行连接重用。</p><p id="88df" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">让我们更新代码，为我们的简单用例设置内容长度头，看看我们得到了什么:</p><div class="jk jl jm jn fq ab cb"><figure class="nj jo nk nl nm nn no paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><img src="../Images/d5c72fb67a71a60a418e187d0ae86d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*KZACr3a04k153_7EwOOLJQ.jpeg"/></div></figure><figure class="nj jo nk nl nm nn no paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><img src="../Images/71e10328b6e126f7d120881d9acabaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*kmcKz8Cxz3Y6-DqMwHEGbg.png"/></div></figure></div><p id="e496" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">看起来Freemarker又回来了！:)</p><p id="7e0c" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">还不满意？现在让我们尝试使用<strong class="jt hv"> jmeter </strong>对这三个进行基准测试。我使用了25个用户，上升周期为20秒，循环次数为25k，结果如下:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff ns"><img src="../Images/bc621dddd63dc78b5a15c38e3cc78245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-BPMB6ffUQEJbRb1J5VSg.png"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">Jmeter stats for response time</figcaption></figure><p id="5a21" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">对于带有键值对象的简单模板渲染，HTTL和Freemarker的性能似乎不相上下。然而，速度是完全不相干的！</p><p id="1bcf" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这里是用于测试上面讨论的java服务器端模板的<a class="ae kn" href="https://github.com/apuravchauhan/java-serversiderender-performance/blob/master/jmeter-testplan/SSR-Jmeter-Testplan.jmx" rel="noopener ugc nofollow" target="_blank"> Jmeter测试计划</a>。</p><h1 id="95cd" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ja lu jb lv jd lw je lx jg ly jh lz ma dt translated">第2轮—复杂对象+ HTML渲染</h1><p id="cfb9" class="pw-post-body-paragraph jr js hu jt b ju mp iv jw jx mq iy jz ka mr kc kd ke ms kg kh ki mt kk kl km hn dt translated"><em class="lf">即将推出</em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nt nu l"/></div></figure></div></div>    
</body>
</html>