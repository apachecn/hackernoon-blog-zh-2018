<html>
<head>
<title>Gentle guide to setup Keras deep learning framework and build a travel recommendation engine (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置Keras深度学习框架和构建旅游推荐引擎的简明指南(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/gentle-guide-to-setup-keras-deep-learning-framework-and-build-a-travel-recommendation-engine-part-9c805b325a2d?source=collection_archive---------19-----------------------#2018-04-13">https://medium.com/hackernoon/gentle-guide-to-setup-keras-deep-learning-framework-and-build-a-travel-recommendation-engine-part-9c805b325a2d?source=collection_archive---------19-----------------------#2018-04-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/f453a01bdaab7e7f7476d5b4049d2134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*F8z30d9YMMUNnjAd.jpg"/></div></figure><p id="e542" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们继续构建旅游推荐引擎的旅程。你可以在我的博客上找到《T2》系列的第一部分。读完这篇文章后，你会知道如何将一个为分类而训练的模型变成一个提取图像特征向量的模型。然后，我们将通过它们的特征向量来研究如何计算两幅图像之间的相似性。最后，我们将生成具有最相似图像的旅行推荐。</p><p id="43a4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了获得最佳的学习体验，我建议在阅读本教程时打开<a class="ae jw" href="https://drive.google.com/file/d/1MER51W-x2JLvAjKJnmGXLQduWaqjTsUf/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Colab笔记本</a>。</p><p id="d448" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们要打造的引擎是一个基于内容的推荐引擎。如果用户喜欢目的地照片，那么系统将向他/她显示类似的旅行目的地图像。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/0355d7b7137bdd02cf75cf5a63e34a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*rcFqOBEsbc_MG14F.jpg"/></div></figure><h1 id="fbfb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">从分类器到特征提取器</h1><p id="3f9d" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">在我们之前的帖子中，构建了一个模型来将输入图像分类为365个地点/场景名称中的一个。</p><p id="8f54" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将删除负责生成位置逻辑的最后4层，只保留网络的“特征提取器”部分。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff le"><img src="../Images/624e04bd4cffc55c33577e4287ee8891.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/0*CsLTTWroF7LY6IcQ.jpg"/></div></figure><p id="f06a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在Keras中，我们可以像这样弹出最后4层。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="bf8b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">上面的最后一行将模型权重保存到一个文件中，供以后使用。下一次，我们只需要定义没有4个分类器层的模型，并用保存的权重初始化网络。</p><p id="563e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您再次运行<code class="eh lh li lj lk b">mode.predict</code>，您会注意到输出不再是365个浮点数的向量。相反，它现在是一个4096浮点数的向量。这是特征向量，输入图像的抽象表示。</p><h1 id="4ed0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">推荐相似图片</h1><p id="2caa" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">我们的推荐引擎获取用户喜欢的查询图像并推荐相似的地方。</p><p id="79e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">通过测量两个特征向量之间的距离来计算两个图像之间的相似性。</p><p id="997c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可以想象在4096维的空间里测量两个特征向量之间的距离。距离越小，两幅图像越相似。</p><h1 id="b8bd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">预计算图像特征</h1><p id="9936" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">我们可以在运行时计算所有已知图像的特征向量，并与查询图像的特征向量进行比较。但是这将是无效的，因为我们基本上是一次又一次地计算这些值。另一种更快的方法是预先计算这些特征向量，并将它们存储在存储器中。在运行时，我们只需要计算查询图像的特征向量，如果它以前没有被计算过，这节省了很多时间，特别是当你有很多图像要比较的时候。</p><p id="2ddd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是通过调用特征提取器模型的预测函数来计算图像特征向量的函数。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="f3fc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还有另一个功能来预先计算所有已知的图像特征向量，并将它们存储到存储器中，这只需要做一次。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf lg l"/></div></figure><h1 id="3558" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">获得最相似的图像</h1><p id="4833" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">下面是我们在运行时执行的函数，用于搜索和显示与新查询图像最相似的图像。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="c84a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们通过运行下面的代码来尝试一下。</p><pre class="jx jy jz ka fq ll lk lm ln aw lo dt"><span id="c65a" class="lp kc hu lk b fv lq lr l ls lt">get_similar_photo("images/canyon2.jpg")[0].name</span></pre><p id="7f1b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是结果，我们的模型推荐了一张与查询图像相似的照片。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/f958872eeae795fdc3c48301818c2093.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*StQKYjDOHs0D6m0Y.jpg"/></div></figure><h1 id="c66c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">进一步的改进</h1><p id="f623" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">如果您使用推荐引擎，您可能会注意到它偶尔会生成错误的推荐。</p><p id="1f2e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有两个原因，</p><p id="de37" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">1.该模型被训练用于分类，并且网络的图像特征提取器部分被优化用于将图像分类为356类，而不是用于区分相似的图像。</p><p id="07b2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">2.该模型在分布于365类地点的图像数据集上进行训练。训练集可能没有足够的图像用于特定类型的海滩或不同季节的一个地方。</p><p id="9e53" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一个问题的一个解决方案是使用具有三重丢失的的<strong class="ja hv">连体网络，这在人脸验证任务中很流行。该模型将被训练以识别两个图像是否来自同一个地方。你可以看看Coursera上关于这个概念的<a class="ae jw" href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/bjhmj/siamese-network" rel="noopener ugc nofollow" target="_blank">视频介绍</a>，我觉得很有帮助。</strong></p><p id="e4ed" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第二个问题的解决方案是通过“冻结”一些早期的卷积层，将<strong class="ja hv">转移学习</strong>应用于我们的模型，并用我们的自定义图像数据集训练其余的模型参数。在训练新图像模型时，迁移学习是利用从大型图像数据集学习的一般特征的一种很好的方式。</p><h1 id="a5a8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="1842" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">现在，您已经尝到了深度学习的无限潜力，并且可能对亲手构建和运行Keras模型留下了深刻的印象。掌握任何技术的旅程都不容易，深度学习也不例外。这就是最初激励我创建这个博客网站的原因，我通过分享和教授我在这个过程中所学到的东西，来更好地将深度学习应用于现实生活中的问题。如果您正在寻找解决方案或只是打个招呼，请不要犹豫，直接联系我。</p><p id="981c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="lv">在</em> <a class="ae jw" href="https://github.com/Tony607" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae jw" href="https://www.linkedin.com/in/chengweizhang/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae jw" href="https://mp.weixin.qq.com/s?__biz=MzIyNTI3NTI3Mg==&amp;mid=100000016&amp;idx=1&amp;sn=3b7e519ffcabd65efe339a9ee8bb327d&amp;chksm=68037df75f74f4e1aa762fc8d69d9ce725f40189ca4534786492267b448239926c943a8b2970&amp;mpshare=1&amp;scene=1&amp;srcid=1212R4Cm7BhxGSfTAa9V5Ofw#rd" rel="noopener ugc nofollow" target="_blank">微信</a>、<a class="ae jw" href="https://twitter.com/TonyZhang607" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae jw" href="https://www.facebook.com/chengwei.zhang.96" rel="noopener ugc nofollow" target="_blank">脸书</a>上找我。</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="3ac0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="lv">原载于</em><a class="ae jw" href="https://www.dlology.com/blog/gentle-guide-to-setup-keras-deep-learning-framework-and-build-a-travel-recommendation-engine-part-2/" rel="noopener ugc nofollow" target="_blank"><em class="lv">www.dlology.com</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>