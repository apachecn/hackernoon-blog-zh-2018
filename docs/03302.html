<html>
<head>
<title>IPFS 👽 and Merkle Forest🌳</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">IPFS👽和默克森林🌳</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ipfs-and-merkle-forest-a6b7f15f3537?source=collection_archive---------5-----------------------#2018-04-15">https://medium.com/hackernoon/ipfs-and-merkle-forest-a6b7f15f3537?source=collection_archive---------5-----------------------#2018-04-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0cdc428e482db1a357ea1aa272a15887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akxO7xye03Owr9q_et3BWw.jpeg"/></div></div></figure><h1 id="b495" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">什么是IPFS？</h1><p id="dead" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">IPFS是行星间文件系统的缩写。它是一个点对点的分布式文件系统，使网络更快、更安全、更开放。要从当前版本的web转移到分布式版本的web，我们需要IPFS。本质上，目标是取代HTTP。</p><h2 id="40bb" class="kz jd hu bd je la lb lc ji ld le lf jm kl lg lh jq kp li lj ju kt lk ll jy lm dt translated"><strong class="ak">但是，嘿，为什么要替换HTTP？</strong></h2><ol class=""><li id="f93a" class="ln lo hu kc b kd ke kh ki kl lp kp lq kt lr kx ls lt lu lv dt translated"><strong class="kc hv">疯狂的带宽成本:</strong><strong class="kc hv"/>现在的Web使用<strong class="kc hv"> </strong> HTTP，基于单一的客户端-服务器模式。人们总是不得不接近中央服务器来下载任何类型的文件。想象一下，如果您可以从您附近的节点获得相同文件的片段，会怎么样？您可以使用更少的带宽更快地下载文件。<a class="ae ky" href="http://math.oregonstate.edu/~kovchegy/web/papers/p2p-vdn.pdf" rel="noopener ugc nofollow" target="_blank">通过视频传输，P2P方法可以节省60%的带宽成本。</a></li></ol><blockquote class="lw"><p id="bb2a" class="lx ly hu bd lz ma mb mc md me mf kx ek translated">IPFS使高效分发大量数据成为可能。零重复意味着节省存储空间。</p></blockquote><p id="bcb7" class="pw-post-body-paragraph ka kb hu kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx hn dt translated">2.<strong class="kc hv"> 404太普通了</strong>！一个网页的平均寿命是100天。在那之后，你会看到一条404消息。现在的网是如此脆弱。链接总是会断开。和焚书一样好。</p><blockquote class="lw"><p id="dc7b" class="lx ly hu bd lz ma ml mm mn mo mp kx ek translated">IPFS提供了历史版本控制(如git ),并简化了为数据镜像建立弹性网络的过程。</p></blockquote><p id="73de" class="pw-post-body-paragraph ka kb hu kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx hn dt translated">3.<strong class="kc hv">集中式基础设施，呃</strong>:我们数据的所有权力都掌握在主服务器上。如果失败了，我们就完了。如果推特瘫痪了，我们就不能再发推特了。如果脸书崩溃了，那么它已经崩溃了哈哈。</p><blockquote class="lw"><p id="14a3" class="lx ly hu bd lz ma ml mm mn mo mp kx ek translated">IPFS仍然忠于开放和扁平网络的最初愿景，但提供了使这一愿景成为现实的技术。</p></blockquote><p id="130e" class="pw-post-body-paragraph ka kb hu kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx hn dt translated">4.<strong class="kc hv">线下是新线上</strong>:在发展中国家，在自然灾害期间，临时网络不好，我们怎么办？只是坐着？我们使用的网络是20世纪的。我们可以做得更好。</p><blockquote class="lw"><p id="362b" class="lx ly hu bd lz ma ml mm mn mo mp kx ek translated">IPFS推动了多样化弹性网络的创建，无论有无互联网主干连接，都能实现持续可用性。</p></blockquote></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><h1 id="6db7" class="jc jd hu bd je jf mx jh ji jj my jl jm jn mz jp jq jr na jt ju jv nb jx jy jz dt translated">IPFS是如何工作的？(简单来说)</h1><p id="b997" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">因此，如果你想检索一个数据结构或者一个文件保存在网上使用IPFS，你不会击中中央服务器。你会要求网络中的同伴给你一个文件的路径。你的同事会给你一个文件的“加密散列”。这是该文件的唯一指纹。</p><p id="9991" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">假设你想得到/foo/bar/baz.png，它的加密哈希是wmxgtagwtx 1 uutfsb 2s bavarmevlk 4 qec 4g 5 bv 7 wwdz 1u。(这可以使用SHA1、SHA2或任何其他算法来生成)。你用这个链接上网。</p><figure class="ni nj nk nl fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/8845de585101e6f85a64480de4bf4a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*tSvpEM4Nc3eii14xiulL7w.png"/></div></figure><p id="0ffb" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">维基百科已经开始使用IPFS:</p><div class="nm nn fm fo no np"><a href="https://ipfs.io/ipfs/QmT5NvUtoM5nWFfrQdVrFtvGfKFmG7AHE8P34isapyhCxX/wiki/Anasayfa.html" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab ej"><div class="nr ab ns cl cj nt"><h2 class="bd hv fv z el nu eo ep nv er et ht dt translated">土耳其语维基百科</h2><div class="nw l"><p class="bd b gc z el nu eo ep nv er et ek translated">ipfs.io</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ja np"/></div></div></a></div><p id="4c31" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">网址格式为:<a class="ae ky" href="https://ipfs.io/ipfs/QmT5NvUtoM5nWFfrQdVrFtvGfKFmG7AHE8P34isapyhCxX/wiki/Anasayfa.html" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv">https://ipfs . io/ipfs/qmt 5 nvutom 5 nwffrqdvrftvgfkfmg 7 ahe 8 p 34 isapyhcxx/wiki/anasayfa . html</strong>T3】</a></p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><h1 id="b474" class="jc jd hu bd je jf mx jh ji jj my jl jm jn mz jp jq jr na jt ju jv nb jx jy jz dt translated">关于Merkle树的一点信息</h1><p id="22fb" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><em class="od">关于Merkle link的研究论文可以在这里找到</em><a class="ae ky" href="https://people.eecs.berkeley.edu/~raluca/cs261-f15/readings/merkle.pdf" rel="noopener ugc nofollow" target="_blank"><em class="od"/></a><em class="od">。Ralph Merkle是Merkle数据结构背后的大脑。</em></p><p id="bff8" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated"><em class="od">一个美丽的插图什么是积少成多树可以在这里找到</em><a class="ae ky" href="https://media.consensys.net/ever-wonder-how-merkle-trees-work-c2f8b7100ed3" rel="noopener ugc nofollow" target="_blank"><em class="od"/></a><em class="od">。</em></p><p id="995b" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">Merkle树在C++中的基本实现</p><pre class="ni nj nk nl fq oe of og oh aw oi dt"><span id="27ee" class="kz jd hu of b fv oj ok l ol om">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;iterator&gt;<br/>#include &lt;vector&gt;<br/><br/>using namespace std;<br/><br/>// Hashing functions.                                                                                                                                                                                                                                                                                                                                                <br/>int multiplyThem(int a, int b) {<br/>  return a*b;<br/>}<br/><br/>int addThem(int a, int b) {<br/>  return a+b;<br/>}<br/><br/>class Merkle {<br/>private:<br/>  vector&lt;int&gt; values;<br/>  int (*hasher)(int, int);<br/><br/>public:<br/>  Merkle(int (*f)(int,int)) {<br/>    this-&gt;hasher = f;<br/>  }<br/><br/>  int size() {<br/>    return values.size();<br/>  }<br/><br/>  void add(int value) {<br/>    values.push_back(value);<br/>  }<br/><br/>  int root() {<br/>    vector&lt;int&gt; current;<br/><br/>    current = getHashedParents(this-&gt;values);<br/>    while (current.size() != 1) {<br/>      current = getHashedParents(current);<br/>    }<br/>    return current[0];<br/>  }<br/><br/>private:<br/>  vector&lt;int&gt; getHashedParents(const vector&lt;int&gt; &amp;children) {<br/>    vector&lt;int&gt; result;<br/><br/>    for (int i=0; i &lt; children.size(); ) {<br/>      int a = children[i], b = children[i];<br/>      if (++i &lt; children.size()) {<br/>        b = children[i++];<br/>      }<br/>      int hash = this-&gt;hasher(a,b);<br/>      printf("hash(%d, %d)=&gt;%d ", a, b, hash);<br/>      result.push_back(hash);<br/>    }<br/>    printf("\n");<br/>    return result;<br/>  }<br/>};<br/><br/>int main(int argc, char** argv) {<br/>    Merkle merkle(multiplyThem);<br/>    merkle.add(1);<br/>    merkle.add(2);<br/>    merkle.add(3);<br/>    merkle.add(4);<br/>    merkle.add(5);<br/><br/>    printf("Merkle Root = %d\n\n", merkle.root());<br/><br/>    merkle = Merkle(addThem);<br/>    merkle.add(1);<br/>    merkle.add(2);<br/>    merkle.add(3);<br/>    merkle.add(4);<br/>    merkle.add(5);<br/><br/>    printf("Merkle Root = %d\n\n", merkle.root());<br/>    return 0;<br/>}</span></pre></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><h1 id="8602" class="jc jd hu bd je jf mx jh ji jj my jl jm jn mz jp jq jr na jt ju jv nb jx jy jz dt translated">IPFS的心脏是IPLD。</h1><p id="51bd" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">IPLD是行星间关联数据的缩写。文件/数据结构使用Merkle链接相互链接。</p><figure class="ni nj nk nl fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/53d4b5541ecd0111cbffe93aa8034c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*18GRoCrx-f63achMJqtLQA.png"/></div></figure><p id="a19a" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated"><strong class="kc hv"> <em class="od">(什么是默克尔达格？这是一个Merkle有向无环图。它类似于Merkle树。然而，Merkle DAG不需要平衡，并且它的非叶节点被允许包含数据。)</em> </strong></p><p id="aa2b" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">在IPFS中，两个节点之间的链接采用加密哈希的形式。由于Merkle DAG数据结构，这是可能的。Merkle DAGs为IPFS提供了许多有用的属性，包括:</p><ol class=""><li id="d123" class="ln lo hu kc b kd nc kh nd kl on kp oo kt op kx ls lt lu lv dt translated"><strong class="kc hv">内容寻址</strong>:所有内容都通过其加密哈希进行唯一标识，包括链接。</li><li id="c7f6" class="ln lo hu kc b kd oq kh or kl os kp ot kt ou kx ls lt lu lv dt translated"><strong class="kc hv">防篡改</strong>:所有内容都通过其校验和进行验证。如果数据被篡改或损坏，IPFS会检测到，因为哈希会改变。</li><li id="8bb3" class="ln lo hu kc b kd oq kh or kl os kp ot kt ou kx ls lt lu lv dt translated"><strong class="kc hv">无重复</strong>:保存完全相同内容的所有对象都是相等的(即它们的哈希值相等)，并且只存储一次。</li></ol></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="6f65" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">只要把<strong class="kc hv"> merkle root </strong>交给某人，你就可以把大量的数据交给那个人。因为，merkle根本质上持有其下所有块的签名。</p><p id="a5bd" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">系统的互操作性也可以在merkle森林中保持，其中每棵树代表一个单独的merkle树。在一个森林里，一棵树可以是<a class="ae ky" href="https://hackernoon.com/tagged/bitcoin" rel="noopener ugc nofollow" target="_blank">比特币</a>，一棵树可以是以太坊，一棵树可以是常规的SQL数据库。因此，为了在这些树之间交换信息，这些基于内容的加密散列函数是有效的。不是发送整个文件，而是只发送散列。想象使用以太坊进行一些交易，并在交易中添加一个Git页面。</p><p id="80b1" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">目前使用这种系统的有:</p><ol class=""><li id="c3bb" class="ln lo hu kc b kd nc kh nd kl on kp oo kt op kx ls lt lu lv dt translated">比特币</li><li id="6a3f" class="ln lo hu kc b kd oq kh or kl os kp ot kt ou kx ls lt lu lv dt translated">以太坊</li><li id="f051" class="ln lo hu kc b kd oq kh or kl os kp ot kt ou kx ls lt lu lv dt translated">饭桶</li><li id="d6fb" class="ln lo hu kc b kd oq kh or kl os kp ot kt ou kx ls lt lu lv dt translated">比特洪流</li></ol><p id="6dc9" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">还有更多，但这些是主要的。</p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="4eb0" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">现在就从IPFS开始吧！</p><div class="nm nn fm fo no np"><a href="https://ipfs.io/docs/getting-started/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab ej"><div class="nr ab ns cl cj nt"><h2 class="bd hv fv z el nu eo ep nv er et ht dt translated">开始使用| IPFS文档</h2><div class="ov l"><h3 class="bd b fv z el nu eo ep nv er et ek translated">如果您还没有这样做，安装IPFS。安装IPFS现在在这个教程中，如果你有任何问题，随时…</h3></div><div class="nw l"><p class="bd b gc z el nu eo ep nv er et ek translated">ipfs.io</p></div></div><div class="nx l"><div class="ow l nz oa ob nx oc ja np"/></div></div></a></div><p id="2766" class="pw-post-body-paragraph ka kb hu kc b kd nc kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx hn dt translated">这又是一项突破性的技术，将网络从Web2.0推向Web3.0</p><figure class="ni nj nk nl fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ox"><img src="../Images/2cdfc05b485b9851198834e62c74b048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3BFp35i_jfTo7RMHsDNwg.jpeg"/></div></div></figure><figure class="ni nj nk nl fq iv"><div class="bz el l di"><div class="oy oz l"/></div></figure></div></div>    
</body>
</html>