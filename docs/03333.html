<html>
<head>
<title>Why Table Join Orders In Relational Databases Don’t Matter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么关系数据库中的表连接顺序无关紧要</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-table-join-orders-in-relational-databases-dont-matter-6de3a35f2959?source=collection_archive---------11-----------------------#2018-04-16">https://medium.com/hackernoon/why-table-join-orders-in-relational-databases-dont-matter-6de3a35f2959?source=collection_archive---------11-----------------------#2018-04-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/89c62d5c0098c031ad0215f65b798b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t9404IsziUK_3fgs.jpg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="jg">Photo by </em><a class="ae jh" href="https://unsplash.com/photos/pj-BrFZ9eAA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">pan xiaozhen</em></a><em class="jg"> on </em><a class="ae jh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">Unsplash</em></a></figcaption></figure><p id="6532" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有人向我提交了一个很好的问题，我认为这将是一篇很好的SQL Server博客文章:</p><blockquote class="kg kh ki"><p id="18f6" class="ji jj kj jk b jl jm jn jo jp jq jr js kk ju jv jw kl jy jz ka km kc kd ke kf hn dt translated">我一直在想，从性能的角度来看，在哪里开始查询是否真的很重要。例如，如果我从A-B-C加入，我会更好地从 <a class="ae jh" href="https://hackernoon.com/tagged/table" rel="noopener ugc nofollow" target="_blank"> <em class="hu">表</em> </a> <em class="hu"> B开始，然后去A &amp; C吗？</em></p></blockquote><p id="0398" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">简短的回答是:是的。没有。</p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="4c6f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">与其说是读者，不如说是观察者？在YouTube上看本周的 <a class="ae jh" href="https://youtu.be/iIzdAJxedwE" rel="noopener ugc nofollow" target="_blank"> <em class="kj">集</em> </a> <em class="kj">！</em></p><h1 id="cb8d" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">表连接顺序对性能很重要！</h1><p id="ced1" class="pw-post-body-paragraph ji jj hu jk b jl lr jn jo jp ls jr js jt lt jv jw jx lu jz ka kb lv kd ke kf hn dt translated"><em class="kj">免责声明:在这篇文章中，我将只讨论内部连接。外部(左、右、全等)连接是另一种动物，我将留到以后再说。</em></p><p id="fc1e" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们使用来自WideWorldImporters的以下查询作为示例:</p><pre class="kn ko kp kq fq lw lx ly lz aw ma dt"><span id="acfe" class="mb ku hu lx b fv mc md l me mf">/* <br/>-- Run if if you want to follow along - add  a computed column and index for CountryOfManufacture<br/>ALTER TABLE Warehouse.StockItems SET (SYSTEM_VERSIONING = OFF);   <br/>ALTER TABLE Warehouse.StockItems<br/>ADD CountryOfManufacture AS CAST(JSON_VALUE(CustomFields,'$.CountryOfManufacture') AS NVARCHAR(10)) <br/>ALTER TABLE Warehouse.StockItems SET (SYSTEM_VERSIONING = ON); <br/>CREATE INDEX IX_CountryOfManufacture ON Warehouse.StockItems (CountryOfManufacture)<br/>*/<br/> <br/>SELECT<br/>  o.OrderID,<br/>  s.CountryOfManufacture<br/>FROM<br/>  Sales.Orders o      -- 73595 rows<br/>  INNER JOIN Sales.OrderLines l   -- 231412 rows<br/>    ON o.OrderID = l.OrderID   -- 231412 rows after join<br/>  INNER JOIN Warehouse.StockItems s  -- 227 rows<br/>    ON l.StockItemID = s.StockItemID -- 1036 rows after join <br/> AND s.CountryOfManufacture = 'USA' -- 8 rows for USA</span></pre><p id="df4b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kj">注意:对于内部连接，我通常更喜欢将‘USA’过滤器放在WHERE子句中，但是对于这些示例的其余部分，将它放在ON子句中会更容易。</em></p><p id="144c" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">需要注意的关键点是，我们正在连接三个表——Orders、OrderLines和stock items——order lines是我们用来连接另外两个表的。</p><p id="515d" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">对于表连接订单，我们基本上有两种选择——我们可以先将订单与订单行连接，然后再连接库存项，或者我们可以先将订单行和库存项连接，然后再连接订单。</p><p id="7291" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">就性能而言，几乎可以肯定，后一种情况(首先将OrderLines与StockItems连接起来)会更快，因为StockItems将帮助我们更有选择性。</p><p id="03b0" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">选择性？您可能注意到我们的StockItems表很小，只有227行。通过对“USA”进行过滤，它变得更小，减少到只有8行。</p><p id="b3a7" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">因为StockItems表没有重复的行(这是一个简单的产品信息查找表)，所以它是一个很好的表，可以尽早连接，因为它将减少查询剩余部分传递的总行数。</p><p id="ffe0" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果我们尝试先执行Orders to OrderLines连接，我们实际上不会在第一步中过滤掉任何行，导致我们后续的StockItems连接更加缓慢(因为需要处理更多的行)。</p><p id="5024" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">基本上，连接顺序很重要，因为如果我们可以连接两个表，减少后续步骤需要处理的行数，那么我们的性能就会提高。</p><p id="e483" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">因此，如果我们的表的连接顺序对性能有很大影响，那么SQL Server<a class="ae jh" href="https://hackernoon.com/tagged/sql-server" rel="noopener ugc nofollow" target="_blank">会遵循我们定义的连接顺序，对吗？</a></p><h1 id="ddf7" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">SQL Server不允许您选择联接顺序</h1><p id="2b27" class="pw-post-body-paragraph ji jj hu jk b jl lr jn jo jp ls jr js jt lt jv jw jx lu jz ka kb lv kd ke kf hn dt translated">SQL是一种声明性语言:您编写的代码指定要获取“什么”数据，而不是“如何”获取数据。</p><p id="2432" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">基本上，SQL Server查询优化器接受您的SQL查询，并自行决定它认为应该如何获取数据。</p><p id="83c9" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">它通过对表大小和数据内容使用预先计算的统计数据来做到这一点，以便能够快速选择一个“足够好”的计划。</p><p id="b427" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">因此，即使我们像这样重新排列FROM语句中表的顺序:</p><pre class="kn ko kp kq fq lw lx ly lz aw ma dt"><span id="cf4f" class="mb ku hu lx b fv mc md l me mf">SELECT<br/>  o.OrderID,<br/>  s.CountryOfManufacture<br/>FROM<br/>  Sales.OrderLines l<br/>  INNER JOIN Warehouse.StockItems s<br/> ON l.StockItemID = s.StockItemID<br/> AND s.CountryOfManufacture = 'USA'<br/>  INNER JOIN Sales.Orders o<br/>    ON o.OrderID = l.OrderID</span></pre><p id="dfb7" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">或者如果我们加上括号:</p><pre class="kn ko kp kq fq lw lx ly lz aw ma dt"><span id="4b7a" class="mb ku hu lx b fv mc md l me mf">SELECT<br/>  o.OrderID,<br/>  s.CountryOfManufacture<br/>FROM<br/>  (Sales.OrderLines l<br/>  INNER JOIN Sales.Orders o<br/>    ON l.OrderID = o.OrderID)<br/>  INNER JOIN Warehouse.StockItems s<br/> ON l.StockItemID = s.StockItemID<br/> AND s.CountryOfManufacture = 'USA'</span></pre><p id="7621" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">或者，即使我们将表重写为子查询:</p><pre class="kn ko kp kq fq lw lx ly lz aw ma dt"><span id="9d3c" class="mb ku hu lx b fv mc md l me mf">SELECT<br/>  l.OrderID,<br/>  s.CountryOfManufacture<br/>FROM<br/>  (<br/>  SELECT <br/>    o.OrderID,<br/>    l.StockItemId<br/>  FROM<br/>    Sales.OrderLines l<br/> INNER JOIN Sales.Orders o<br/>      ON l.OrderID = o.OrderID<br/>  ) l<br/>  INNER JOIN Warehouse.StockItems s<br/> ON l.StockItemID = s.StockItemID<br/> AND s.CountryOfManufacture = 'USA'</span></pre><p id="338c" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">SQL Server会将我们的三个单独的查询(加上页面顶部的原始查询)解释并优化为相同的执行计划:</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/b2fc5c824d395585a07a5c1f87070938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qC6EfCHQ1fG_unCw.png"/></div></div></figure><p id="d678" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">基本上，无论我们如何尝试在FROM语句中重新定义表的顺序，SQL Server仍然会做它认为最好的事情。</p><h1 id="bcf9" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">但是如果SQL Server不是最了解的呢？</h1><p id="fdc7" class="pw-post-body-paragraph ji jj hu jk b jl lr jn jo jp ls jr js jt lt jv jw jx lu jz ka kb lv kd ke kf hn dt translated">大多数时候，我看到SQL Server在执行计划时效率很低，这通常是由于该表/索引的统计数据有问题。</p><p id="d706" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">统计也是另一天(或另一个月)博客文章的另一个主题，所以为了避免这篇文章离题太远，我会让你看看Kimberly Tripp关于这个主题的介绍性博客文章:<a class="ae jh" href="https://www.sqlskills.com/blogs/kimberly/the-accidental-dba-day-15-of-30-statistics-maintenance/" rel="noopener ugc nofollow" target="_blank">https://www . sqlskills . com/blogs/Kimberly/the-accident-DBA-day-15-of-30-statistics-maintenance/</a></p><p id="cbdc" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">需要注意的关键点</strong>是，如果SQL Server生成的执行计划中表连接的顺序没有意义<strong class="jk hv">首先检查您的统计数据</strong>，因为它们是许多性能问题的根源！</p><h1 id="865b" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">强制连接顺序</h1><p id="eec5" class="pw-post-body-paragraph ji jj hu jk b jl lr jn jo jp ls jr js jt lt jv jw jx lu jz ka kb lv kd ke kf hn dt translated">所以你已经检查过你的统计数据是否是问题所在，并且在这方面用尽了所有的可能性。SQL Server没有针对最佳的表连接顺序进行优化，那么您能做什么呢？</p><h1 id="374b" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">行目标</h1><p id="bcec" class="pw-post-body-paragraph ji jj hu jk b jl lr jn jo jp ls jr js jt lt jv jw jx lu jz ka kb lv kd ke kf hn dt translated">如果SQL Server不工作，我需要强制执行表连接顺序，我的首选方法是通过TOP()命令来执行。</p><p id="de95" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我从观看亚当·基尼克关于这个主题的精彩演讲中学到了这个技巧，我强烈推荐你观看。</p><p id="a4df" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">因为在我们的示例查询中，SQL Server已经以最有效的顺序连接了表，所以让我们通过首先连接订单和订单行来强制一个低效的连接。</p><p id="f2e1" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">基本上，我们首先在想要连接的表周围编写一个子查询，并确保包含一个TOP子句。</strong></p><pre class="kn ko kp kq fq lw lx ly lz aw ma dt"><span id="d746" class="mb ku hu lx b fv mc md l me mf">SELECT<br/>  o.OrderID,<br/>  s.CountryOfManufacture<br/>FROM<br/>  (<br/>  SELECT TOP(2147483647) -- A number of rows we know is larger than our table.  Watch Adam's presentation above for more info.<br/> o.OrderID,<br/> l.StockItemID<br/>  FROM<br/>    Sales.Orders o<br/>    INNER JOIN Sales.OrderLines l<br/>      ON o.OrderID = l.OrderID<br/>  ) o<br/>  INNER JOIN Warehouse.StockItems s<br/>    ON o.StockItemID = s.StockItemID<br/> AND s.CountryOfManufacture = 'USA'</span></pre><p id="c2e0" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">包含TOP会强制SQL首先执行订单和订单行之间的连接——在本例中效率很低，但在能够控制SQL Server的操作方面取得了巨大成功。</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/5731a257495d14c4590daa0e04a6fc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-xlvo0_QxhQe20gt.png"/></div></div></figure><p id="2fad" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这是我最喜欢的强制连接顺序的方法，因为在这种情况下，我们可以控制两个特定表的连接顺序(Orders和OrderLines ),但是SQL Server仍然会使用自己的判断来决定剩余的表应该如何连接。</p><p id="a34f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">虽然强制连接顺序通常不是一个好主意(如果基础数据在未来发生变化，并且您的强制连接不再是最佳选择，那么会发生什么)，但是在某些需要强制连接的场景中，TOP技术将导致最少的性能问题(因为SQL仍然可以决定其余的表会发生什么)。</p><p id="f5ff" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果使用提示就不一样了…</p><h1 id="f9a9" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">查询和联接提示</h1><p id="ace6" class="pw-post-body-paragraph ji jj hu jk b jl lr jn jo jp ls jr js jt lt jv jw jx lu jz ka kb lv kd ke kf hn dt translated">查询和连接提示将成功地强制查询中的表连接顺序，但是它们有明显的缺点。</p><p id="9eaf" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们来看一下FORCE ORDER查询提示。将它添加到您的查询中会成功地强制表连接按照它们列出的顺序发生:</p><pre class="kn ko kp kq fq lw lx ly lz aw ma dt"><span id="bb93" class="mb ku hu lx b fv mc md l me mf">SELECT<br/>  o.OrderID,<br/>  s.CountryOfManufacture<br/>FROM<br/>  Sales.Orders o<br/>  INNER JOIN Sales.OrderLines l<br/>    ON o.OrderID = l.OrderID<br/>  INNER JOIN Warehouse.StockItems s<br/>    ON l.StockItemID = s.StockItemID<br/> AND s.CountryOfManufacture = 'USA'<br/>OPTION (FORCE ORDER)</span></pre><p id="fd5f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">查看执行计划，我们可以看到订单和订单行首先按照预期连接在一起:</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/538298d97f902adebf4e205987a43064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P9k8Zo6BXNv8UR0L.png"/></div></div></figure><p id="e972" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">FORCE ORDER提示的最大缺点是查询中的所有<em class="kj">表的连接顺序都将被强制(在本例中并不明显……但是假设我们总共连接了4或5个表)。</em></p><p id="80b1" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这使得您的查询非常脆弱；如果基础数据将来发生变化，您可能会强制执行多个低效的连接订单。使用FORCE ORDER优化的查询可能会从几秒钟运行到几分钟或几小时。</p><p id="3b13" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">使用连接提示也存在同样的问题:</p><pre class="kn ko kp kq fq lw lx ly lz aw ma dt"><span id="d4f2" class="mb ku hu lx b fv mc md l me mf">SELECT<br/>  o.OrderID,<br/>  s.CountryOfManufacture<br/>FROM<br/>  Sales.Orders o <br/>  INNER LOOP JOIN Sales.OrderLines l<br/>    ON o.OrderID = l.OrderID<br/>  INNER JOIN Warehouse.StockItems s<br/>    ON l.StockItemID = s.StockItemID<br/> AND s.CountryOfManufacture = 'USA'</span></pre><p id="616c" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">成功地使用LOOP提示再次强制我们的连接顺序，但是所有表的连接顺序再次变成固定的:</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fbbe45ee237eaf8bc3c6794407927642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cX_SQXFsg5bawgq1.png"/></div></div></figure><p id="dc2e" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">join提示可能是强制表连接顺序的最脆弱的提示，因为它不仅强制连接顺序，而且还强制用于执行连接的算法。</p><p id="201f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">一般来说，我只使用查询提示来强制表连接顺序，作为一种临时的解决方案</strong>。</p><p id="fe9a" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">也许生产出了问题，我需要让事情重新运转起来；查询或联接提示可能是解决当前问题的最快方法。然而，长期使用这个提示可能不是一个好主意，所以在眼前的麻烦被扑灭之后，我将回去尝试确定性能问题的根本原因。</p><h1 id="eab9" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">摘要</h1><ul class=""><li id="5b4a" class="mj mk hu jk b jl lr jp ls jt ml jx mm kb mn kf mo mp mq mr dt translated">表连接顺序对于减少查询的其余部分需要处理的行数很重要。</li><li id="6c23" class="mj mk hu jk b jl ms jp mt jt mu jx mv kb mw kf mo mp mq mr dt translated">默认情况下，SQL Server无法控制连接顺序，它使用统计信息和查询优化器来选择它认为合适的连接顺序。</li><li id="cbcc" class="mj mk hu jk b jl ms jp mt jt mu jx mv kb mw kf mo mp mq mr dt translated">大多数时候，查询优化器在挑选有效的连接顺序方面做得很好。如果没有，我做的第一件事就是检查我的统计数据的健康状况，并判断它是否因此选择了次优计划。</li><li id="1251" class="mj mk hu jk b jl ms jp mt jt mu jx mv kb mw kf mo mp mq mr dt translated">如果我在一个特殊的场景中，并且我确实需要强制一个连接顺序，我将使用TOP子句来强制一个连接顺序，因为它只强制单个连接的顺序。</li><li id="909d" class="mj mk hu jk b jl ms jp mt jt mu jx mv kb mw kf mo mp mq mr dt translated">在紧急“生产服务器着火”的情况下，我可能会使用查询或连接提示来立即修复性能问题，并在事情平息后返回来实现更好的解决方案。</li></ul><p id="821b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kj">感谢阅读。你可能也喜欢在推特上关注我</em> <a class="ae jh" href="https://twitter.com/bertwagner" rel="noopener ugc nofollow" target="_blank"> <em class="kj">。</em> </a></p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="mx ks l"/></div></figure></div></div>    
</body>
</html>