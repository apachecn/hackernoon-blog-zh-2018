<html>
<head>
<title>For All the World to See: Deploying Haskell with Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让全世界都看到:与Heroku一起部署Haskell</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/for-all-the-world-to-see-deploying-haskell-with-heroku-7ea46f827ce?source=collection_archive---------15-----------------------#2018-04-16">https://medium.com/hackernoon/for-all-the-world-to-see-deploying-haskell-with-heroku-7ea46f827ce?source=collection_archive---------15-----------------------#2018-04-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/04c6d96c89be0f8fdad398b3f4d25225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*D4rHksELHm5llRIBsDn-9w.jpeg"/></div></figure><p id="7409" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在现在的几篇不同的文章中，我们已经探索了如何使用Haskell构建web应用程序。例如，看看我们的<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>和我们的<a class="ae jw" href="https://www.mmhaskell.com/apis" rel="noopener ugc nofollow" target="_blank"> API集成</a>系列。但是，如果我们没有一种方法来部署我们的代码，以便互联网上的其他人可以找到它，这一切最终都是没有意义的！在下一个系列中，我们将探索如何使用公共服务来部署Haskell代码。这比用更受支持的语言编写代码要多几个步骤！</p><p id="cd1c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您从未使用Haskell编程，那么在开始部署代码之前，您需要学习一些东西！下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>获取如何开始学习的提示！但是也许你已经做了一些Haskell，并且需要更多的想法供库使用。在这种情况下，请查看我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>以获得指导！</p><h1 id="bdf5" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">在Heroku上部署代码</h1><p id="e79b" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">在本文中，我们将重点关注使用<a class="ae jw" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>服务部署我们的代码。Heroku让我们可以轻松做到这一点。我们可以免费得到一个快速原型，使它成为黑客马拉松的理想选择。不过像大多数平台一样，Heroku最容易与更常见的语言一起使用。Heroku可以自动检测Javascript或Python应用程序，并采取适当的措施。由于Haskell不常用，我们需要一个额外的规范来获得Heroku的支持。幸运的是，大部分艰难的工作已经为我们完成了。</p><h1 id="daa2" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">构建包</h1><p id="5067" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">Heroku使用“buildpack”的概念来决定如何将你的项目转换成可运行的代码。您将通过将代码推送到远程存储库来部署您的应用程序。然后buildpack会告诉Heroku如何构建你需要的可执行文件。如果你指定一个Node.js项目，Heroku会找到你的<code class="eh la lb lc ld b">package.json</code>文件并从NPM下载所有东西。如果是Python，Heroku会安装<code class="eh la lb lc ld b">pip</code>做同样的事情。</p><p id="0604" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Heroku没有Haskell项目的默认构建包。然而，Github 上有一个<a class="ae jw" href="https://github.com/mfine/heroku-buildpack-stack" rel="noopener ugc nofollow" target="_blank"> buildpack我们可以使用(启动这个库！).它将告诉我们的Heroku容器下载Stack，然后使用Stack构建我们所有的可执行文件。因此，让我们看看如何使用这个过程来构建一个基本的Haskell项目。</a></p><h1 id="b9ba" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">创建我们的应用程序</h1><p id="df45" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">我们需要在Heroku上创建一个免费账户。然后，我们将下载Heroku CLI，这样我们就可以从终端进行连接。使用<code class="eh la lb lc ld b">heroku login</code>命令并输入您的凭证。</p><p id="8d3e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们想创建我们的应用程序。在您的终端中，<code class="eh la lb lc ld b">cd</code>进入包含您的Haskell堆栈项目的目录。确保它已经是一个Github库了。如果存储库目前只是本地的，那也没关系。运行此命令创建您的应用程序(用您想要的应用程序名称替换<code class="eh la lb lc ld b">haskell-test-app</code>):</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="cca0" class="lm jy hu ld b fv ln lo l lp lq">heroku create haskell-test-app \<br/>  -b <a class="ae jw" href="https://github.com/mfine/heroku-buildpack-stack" rel="noopener ugc nofollow" target="_blank">https://github.com/mfine/heroku-buildpack-stack</a></span></pre><p id="9916" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh la lb lc ld b">-b</code>参数指定了我们的构建包。我们将从指定的Github库中提取它。如果可以的话，你应该可以在Heroku的仪表板上看到你的新应用程序的条目。你的项目将会有一个Heroku域，你可以在项目设置中看到。</p><p id="e2a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们需要制作一个Procfile。这告诉Heroku我们需要运行特定的二进制文件来启动我们的web服务器。确保您的<code class="eh la lb lc ld b">.cabal</code>文件中有一个启动服务器的可执行文件。然后在<code class="eh la lb lc ld b">Procfile</code>中，您将在<code class="eh la lb lc ld b">web</code>名称下指定可执行文件:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="24bb" class="lm jy hu ld b fv ln lo l lp lq">web: run-server</span></pre><p id="8347" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是请注意，您不能使用硬编码的端口！Heroku会为你选择一个港口。您可以通过检索<code class="eh la lb lc ld b">PORT</code>环境变量来获得它。下面是您的代码可能的样子:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="e85d" class="lm jy hu ld b fv ln lo l lp lq">runServer :: IO ()<br/>runServer = do<br/>  port &lt;- read &lt;$&gt; getEnv “PORT”<br/>  Run port (serve myAPI myServer)</span></pre><p id="8651" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，您需要“扩展”应用程序，以确保它至少有一台机器可以运行。从存储库中，运行以下命令:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="7756" class="lm jy hu ld b fv ln lo l lp lq">heroku ps:scale web=1</span></pre><p id="8776" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我们需要将应用程序推送到Heroku容器中。为此，确保Heroku添加了远程<code class="eh la lb lc ld b">heroku</code> Github库。您可以使用以下命令来完成此操作:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="1bcf" class="lm jy hu ld b fv ln lo l lp lq">git remote -v</span></pre><p id="f63f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它应该显示两个名为<code class="eh la lb lc ld b">heroku</code>的遥控器，一个用于获取，一个用于推送。如果这些不存在，您可以像这样添加它们:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="af48" class="lm jy hu ld b fv ln lo l lp lq">heroku git:remote -a haskell-test-app</span></pre><p id="320a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，您可以通过运行以下命令来结束:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="efe9" class="lm jy hu ld b fv ln lo l lp lq">git push heroku master</span></pre><p id="fe4c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您应该看到终端输出表明Heroku识别了您的应用程序。如果您等待足够长的时间，您将开始看到堆栈构建过程。如果您的项目有任何环境变量，请从应用程序仪表板设置它们。您也可以使用以下命令设置变量:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="0caa" class="lm jy hu ld b fv ln lo l lp lq">heroku config:set VAR_NAME=var_value</span></pre><p id="ef3c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一旦我们的应用程序完成构建，您就可以访问Heroku提供给您的URL。看起来应该是<code class="eh la lb lc ld b">https://your-app.herokuapp.com</code>。现在，您已经将Haskell代码部署到云中了！</p><h1 id="6712" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">弱点</h1><p id="a479" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">这个系统有一些弱点。最主要的一点是，我们的整个构建过程都发生在云上。这似乎是一个优势，也有它的好处。尽管Haskell应用程序可能需要很长时间来编译。如果项目很大，并且涉及到模板Haskell，情况尤其如此。像Heroku这样的服务在构建过程中经常会超时。因此，如果编译时间过长，构建将会失败。幸运的是，容器将缓存以前的结果。这意味着Stack不必重新下载所有的库。因此，即使我们的第一个构建超时，第二个也可能成功。</p><h1 id="3b11" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="af33" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">我们的Haskell部署系列的第1部分到此结束。在这个系列中，我们将会经常看到相同的主题。使用公共服务部署我们的Haskell代码绝对是可能的。但是我们经常需要做更多的工作来达到这个目的。下周，我们将看到如何通过整合<a class="ae jw" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> Circle CI </a>来自动化我们的部署过程。</p><p id="c958" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">想要更多关于使用Haskell开发web应用程序的技巧吗？下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">制作清单</a>，了解一些你可以使用的其他库！对于一种方法的更详细的解释，请阅读我们的<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell网络技能</a>系列。</p></div></div>    
</body>
</html>