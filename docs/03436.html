<html>
<head>
<title>The Future of Native Mobile Apps on Blockchain — What They Should Look Like, and How to Build One Today.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链上的原生移动应用的未来——它们应该是什么样子，以及如何在今天构建一个。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-future-of-native-mobile-apps-on-blockchain-what-they-should-look-like-and-how-to-build-one-d25024db07d5?source=collection_archive---------1-----------------------#2018-04-19">https://medium.com/hackernoon/the-future-of-native-mobile-apps-on-blockchain-what-they-should-look-like-and-how-to-build-one-d25024db07d5?source=collection_archive---------1-----------------------#2018-04-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a2d32d68e249fe65e5eea6ae053401b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztYnVw5kl7scH5fYhJLvJA.png"/></div></div></figure><p id="8a90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多很好的理由让你的<a class="ka kb gr" href="https://medium.com/u/d626b3859bc9?source=post_page-----d25024db07d5--------------------------------" rel="noopener" target="_blank">以太坊</a>令牌/智能合约/DApp(去中心化应用)拥有一个独立的原生移动应用:</p><ul class=""><li id="68dc" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><strong class="je hv">可访问性:</strong>离开主屏幕只需轻轻一点就意味着更频繁的使用</li><li id="58f5" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><strong class="je hv">独立性:</strong>您可以为使用app专用私钥登录的用户提供定制的用户体验。您可以控制自己的用户体验，不必依赖通用的web浏览器或通用的wallet UI。</li><li id="cb5f" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><strong class="je hv">优化的UX: </strong>依赖普通的钱包或普通的DApp浏览器意味着你将所有与交易相关的UX委托给浏览器。这意味着你不能为你的DApp提供一个优化的、死一般简单的用户界面。使用您自己的专用应用程序，您可以构建一个精简的界面，没有令人困惑的部分。</li><li id="c490" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><strong class="je hv">手机特有功能:</strong>您可以使用推送通知、蓝牙、摄像头等功能。这可以显著改善用户体验。</li></ul><p id="8df9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，当您开始考虑构建移动应用程序时，您会发现自己立即面临一些重大挑战:</p><ol class=""><li id="565b" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated"><strong class="je hv">风险:</strong>您可能已经有太多的协议/智能合约/令牌需要处理，没有时间或资源来构建应用程序，更不用说维护了。当您的主要业务应该在协议中时，拥有一个只有少数人能够理解和维护的专用移动代码库是一个风险和负担。</li><li id="52da" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated"><strong class="je hv">你真的不应该是那个开发应用的人:</strong>你可能想开发一些可以永久使用的东西，即使在你当前的团队离开之后。我们的目标是让社区在您的协议之上构建客户端，而不是让您成为单个网关的唯一开发者。从“官方团队”推动单一的主导实现只会阻碍第三方开发者的参与，对去中心化没有帮助。</li><li id="0208" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated"><strong class="je hv"> Fabric vs. Single App: </strong>你不想构建一个单独的App，你希望你的协议是去中心化互联网的Fabric。理想情况下，它应该被各种不同的应用程序使用，而不仅仅是你自己开发的一个单一的应用程序。</li></ol><p id="d51c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些都是没有明确答案的现实问题，很少有人愿意谈论它们。我想到了一个解决办法，那就是重新思考“应用”是什么。为此，我试图创建一个死简单的框架，使我们更接近这一认识。</p><p id="d1da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我首先构建了一个简单的<a class="ae kr" href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" rel="noopener ugc nofollow" target="_blank"> ERC20令牌</a>移动应用程序，如下所示:</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/0ced53e692c894625a77648362ccd6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/1*iYp3Y_apnocO7aHKGAYEQw.gif"/></div></figure><p id="78a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文的其余部分，我将讨论:</p><ol class=""><li id="8646" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated"><strong class="je hv">成分:</strong>从后端到前端，浏览这个项目中使用的所有技术。</li><li id="a818" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated"><strong class="je hv">实施:</strong>我如何构建移动应用程序的高级概述</li><li id="a93d" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated"><strong class="je hv">经验:</strong>我从以这种方式构建应用程序中学到的东西，以及我认为区块链的移动应用程序未来会是什么样子。</li></ol><p id="bc2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然我在这篇文章中使用了特定的工具和框架，但一般原则和经验应该适用于任何考虑在以太坊上构建移动应用的人。</p><h1 id="a148" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">佐料</h1><p id="6fa8" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">在使用移动应用程序之前，让我们先来看看构建完整堆栈所需的所有要素:</p><ul class=""><li id="4fde" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><strong class="je hv">后端:</strong>智能合约</li><li id="401d" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated"><strong class="je hv">前端:</strong> Web +移动</li></ul><blockquote class="ma mb mc"><p id="b03c" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated"><strong class="je hv">可靠性智能合约</strong></p></blockquote><p id="e6bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于这篇文章不是关于如何编写智能合约的教程，我将只分享我部署到Rinkeby(一个以太坊测试网)的一个简单的ERC20令牌合约。</p><p id="fefd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">制作中可以在这里找到(记得连接rinke by):<a class="ae kr" href="https://gliechtenstein.github.io/erc20/web/" rel="noopener ugc nofollow" target="_blank">https://gliechtenstein.github.io/erc20/web/</a></p><p id="a4ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而来源在这里:<a class="ae kr" href="https://github.com/gliechtenstein/erc20/tree/master/contracts" rel="noopener ugc nofollow" target="_blank">https://github . com/gliechtenstein/ERC 20/tree/master/contracts</a></p><p id="761c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简单起见，代码本身99%是从<a class="ae kr" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>合同中复制和粘贴的，1%是定制的。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/fe68c59ec573bdf972bb2ec172c2e2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bL302k0DFy6FzaiNrJyyEA.png"/></div></div></figure><p id="73f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像以太坊的<a class="ae kr" href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" rel="noopener ugc nofollow" target="_blank"> ERC这样的标准很酷的一点是，你可以写一次，然后在任何地方使用它，所以大多数开发者不必担心自己的安全实现，他们可以重用其中的大部分，只定制他们需要的东西。整个社区共享利益。</a></p><p id="6cd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这非常符合我在本文中将要讨论的解决方案所要达到的目标。不同的是<strong class="je hv"> </strong> <a class="ka kb gr" href="https://medium.com/u/4e5199c3ee0a?source=post_page-----d25024db07d5--------------------------------" rel="noopener" target="_blank"> <strong class="je hv">齐柏林</strong> </a> <strong class="je hv">和朋友侧重于后端(智能合约)</strong><strong class="je hv">我侧重于前端(手机app)。</strong></p><blockquote class="ma mb mc"><p id="000f" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated"><strong class="je hv"> Web3.js DApp </strong></p></blockquote><p id="4367" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我编写了一个简单的web3.js Dapp来处理我在上一节中部署的ERC20令牌。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/30676478ddefd5d9257caa4cfb4fcb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gA4KeD7ZZy6lI5HZRHt_PA.png"/></div></div></figure><p id="c1d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简单起见，我没有使用复杂的工具和框架，如<a class="ae kr" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank"> Truffle </a>等。它实际上只是一个简单的HTML文件。可以在这里查看代码:<a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/web/index.html" rel="noopener ugc nofollow" target="_blank">https://github . com/gliechtenstein/ERC 20/blob/master/web/index . html</a></p><blockquote class="ma mb mc"><p id="78bb" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated"><a class="ka kb gr" href="https://medium.com/u/fe1564152eed?source=post_page-----d25024db07d5--------------------------------" rel="noopener" target="_blank"> <strong class="je hv"> INFURA </strong> </a> <strong class="je hv"> : </strong>一个可信的节点，被很多人信任，包括MetaMask。</p></blockquote><p id="cfb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在大多数DApp开发者都承认，期望所有用户下载整个区块链是不现实的，因为它有几百千兆字节。事实上，大多数用户使用第三方可信节点。这就是<a class="ae kr" href="https://metamask.io" rel="noopener ugc nofollow" target="_blank">元掩码</a>桌面浏览器扩展的用武之地。</p><p id="5b39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ka kb gr" href="https://medium.com/u/17995a9c1d1c?source=post_page-----d25024db07d5--------------------------------" rel="noopener" target="_blank">元掩码</a>采用“瘦客户端”方法。它没有下载完整的区块链，而是连接到一个名为Infura的可信节点。由于整个区块链都使用公钥加密技术——在向网络广播之前，您使用本地私钥签署每笔交易，因此网络无法伪造它——通常认为使用可信节点进行广播是足够安全的。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/153ba4f51c6c98f7fe1efc9289fd848b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*4qNiX0IjgYHBQw7A62AL2w.png"/></div></figure><p id="a5b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于移动开发，使用像Infura这样的可信节点更有意义，因为没有人愿意下载数十亿字节的区块链，浪费网络流量，并在持续的对等同步中耗尽电池。所以<a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/web/index.html#L209" rel="noopener ugc nofollow" target="_blank">我们用Infura </a>吧。</p><div class="mk ml fm fo mm mn"><a href="https://infura.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">Infura -可扩展的区块链基础设施</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">对以太坊API和IPFS网关的安全、可靠和可伸缩的访问。</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">infura.io</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ja mn"/></div></div></a></div><blockquote class="ma mb mc"><p id="29f1" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated"><strong class="je hv"> Jasonette: </strong>跨平台<strong class="je hv"> </strong>原生手机App框架</p></blockquote><p id="9d12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个构建块是本机UI。我们将使用Jasonette，这是一种构建跨平台原生应用的标记驱动方法。</p><div class="mk ml fm fo mm mn"><a href="https://www.jasonette.com" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">Jasonette —基于HTTP的本地应用</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">Jasonette把JSON变成iOS和Android原生组件。</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">www.jasonette.com</p></div></div><div class="mw l"><div class="nc l my mz na mw nb ja mn"/></div></div></a></div><p id="40ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Jasonette就像一个网页浏览器，但用于构建本地应用。就像web浏览器如何动态解释HTML并将其呈现在浏览器屏幕上一样，Jasonette解释JSON标记以在iOS和Android上动态构造原生应用程序。</p><p id="67dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">标记语法支持从<strong class="je hv">模型</strong>到<strong class="je hv">视图</strong>到<strong class="je hv">控制器</strong>的一切表达，所以构建一个原生应用只需要一个JSON标记。</p><p id="9cb3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Jasonette工作原理快速介绍:</p><figure class="kt ku kv kw fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="a9b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">深入教程:</p><figure class="kt ku kv kw fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><blockquote class="ma mb mc"><p id="7852" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated"><strong class="je hv">代理:</strong>移动前端的微服务</p></blockquote><p id="594d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的用例来说，Jasonette 的一个重要内置特性是<code class="eh nf ng nh ni b">agent</code>。</p><p id="c82a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代理就像一个微服务，你可以把它嵌入到你的本地应用前端。它自动在父本地应用程序和它自己之间形成双向通信通道，允许它们通过<a class="ae kr" href="http://www.jsonrpc.org/specification" rel="noopener ugc nofollow" target="_blank"> JSON-RPC协议</a>进行通信。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nj"><img src="../Images/e66b1621518c858fcd70a177aad2c74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KXQdNKuhcu7igrLerm0DmA.png"/></div></div></figure><p id="ca54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，您可以将任何在浏览器中工作的web应用程序作为代理嵌入到本机应用程序中，而不是将一些API数据呈现到DOM中，而是将其作为事件发送到父应用程序。然后app就可以原生渲染了。</p><p id="5797" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">我们将使用代理将我们现有的web3 DApp嵌入到一个本机应用程序中，并将其用作数据源(并使用本机部分来呈现数据)。</strong></p><p id="e35b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">快速浏览以下页面，了解有关代理的更多信息:</p><div class="mk ml fm fo mm mn"><a href="https://www.jasonette.com/agent" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">茉莉酮酸酯剂</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">将任何JavaScript应用程序转变为跨平台的原生移动应用程序</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">www.jasonette.com</p></div></div><div class="mw l"><div class="nk l my mz na mw nb ja mn"/></div></div></a></div><h1 id="b5e0" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">履行</h1><p id="5cb1" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">现在我们已经准备好构建移动应用程序了。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/bc398a3b17c3fcf443eb3c437733b3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXfghLLKQ0TL-HcQsiNZeQ.png"/></div></div></figure><p id="1f5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上图是总体数据流的快速概览。</p><ul class=""><li id="7c36" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">用户与本机UI进行交互。</li><li id="3f4f" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">本机UI向“DApp容器”(包含您的web3 DApp代理)发出请求</li><li id="ccfc" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">DApp容器向“钱包容器”代理发出请求(现在，就把它想象成元掩码的移动等价物)</li><li id="f5c4" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">钱包容器然后连接到以太坊。</li></ul><p id="d557" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些都通过JSON-RPC协议相互连接，应用程序——所有三个模块——完全用JSON标记描述。</p><p id="1417" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们开始之前，提醒一下您可以在以下网址找到完整的源代码:</p><div class="mk ml fm fo mm mn"><a href="https://github.com/gliechtenstein/erc20" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">格利希滕斯坦/erc20</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">erc20 —全栈erc20令牌应用程序(合同+网络+移动)</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">github.com</p></div></div><div class="mw l"><div class="nm l my mz na mw nb ja mn"/></div></div></a></div><p id="4820" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">说了这么多，现在让我们看看每个模块。</p><h2 id="0e84" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">1.本机用户界面</h2><p id="b60d" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">第一个构建块是本机UI。Jasonette有一个内置的模板引擎——也是用JSON编写的——它可以接受任何JSON对象并呈现到本机布局和UI组件中，还可以在JSON标记中表达本机API函数调用。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ob"><img src="../Images/593b31bd8e5a7265d87c5070d4e980de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tC38wnIgUcDg_-p69EKSzw.png"/></div></div></figure><p id="42c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，我们将使用DApp容器——我们将在下一节中讨论——作为数据源，因此我们定义模板并等待来自DApp容器的响应。一旦DApp容器触发了一个事件，我们将根据模板呈现数据。以下是完整的标记:</p><p id="c508" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/mobile/app/main.json" rel="noopener ugc nofollow" target="_blank">https://github . com/gliechtenstein/ERC 20/blob/master/mobile/app/main . JSON</a></p><p id="6053" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">标记驱动方法最酷的一点是<strong class="je hv">应用程序逻辑与设备完全分离。</strong>这意味着你可以在任何地方存储和提供应用程序(就像网络浏览器做的那样)。它可以存储在远程服务器上，本地设备上，甚至像IPFS一样分散存储。</p><p id="17b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们退一步想想这意味着什么。通过将应用与设备分离，我们可以确保无论苹果或谷歌未来发生什么，我们的应用都可以移植到新的平台，只要框架本身移植到新的主导平台。这也是Jasonette选择JSON作为标记语言的原因，<strong class="je hv"> JSON是机器存储和相互通信数据最流行的格式</strong>，因此，未来假想的“新平台”很可能也将支持JSON作为一等公民。</p><p id="a757" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的MVP应用程序，我们从github上的一个远程JSON】提供服务。</p><h2 id="b2ef" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">2.DApp集装箱</h2><p id="91f3" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">第二个构件是DApp容器。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oc"><img src="../Images/35ccd4bec80aad66240bd54305e3cf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utVZ1Vbe9lrZkuCV4EfJjw.png"/></div></div></figure><p id="78ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从这个图表中可以注意到一些事情:</p><ol class=""><li id="c49a" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">用户只与本机UI交互。对于用户来说，DApp是不可见的，它只是作为一个数据源。</li><li id="32a7" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">本机模块通过JSON-RPC将用户请求转发给DApp容器。</li><li id="d3a5" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">然后，DApp容器向以太坊网络(thanks，Infura)发出请求，当它得到响应时，将它转发回父本地应用程序，该应用程序使用上面提到的本地模板呈现。</li></ol><p id="f657" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将DApp容器实例化为一个代理。声明一个代理只需要在现有的应用程序标记中添加3行JSON代码:</p><pre class="kt ku kv kw fq od ni oe of aw og dt"><span id="afa0" class="nn ky hu ni b fv oh oi l oj ok">{<br/>  "$jason": {<br/>    "head": {<br/>      "title": "Web3 DApp in a mobile app",<br/><em class="md">      "agents": {<br/></em><strong class="ni hv"><em class="md">        "eth": {<br/>          "url": "</em></strong><a class="ae kr" href="https://gliechtenstein.github.io/erc20/web/" rel="noopener ugc nofollow" target="_blank">https://gliechtenstein.github.io/erc20/web</a><strong class="ni hv"><em class="md">"<br/>        }<br/></em></strong><em class="md">      },<br/>      ...<br/>    </em>}<br/>  }<br/>}</span></pre><p id="9d2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，我们初始化DApp容器并将其命名为<code class="eh nf ng nh ni b">eth</code>，当我们进行JSON-RPC调用时，我们将使用它作为ID。</p><p id="9aea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是完整源代码:<a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/mobile/app/main.json" rel="noopener ugc nofollow" target="_blank">https://github . com/gliechtenstein/ERC 20/blob/master/mobile/app/main . JSON</a></p><p id="b6f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们没有接触到原始的web应用程序。<strong class="je hv">我们只是将DAPP作为代理嵌入，并将其用作移动应用程序的即时伪后端。</strong>要明确的是，你不必这样做，只需保留一个单独的代理程序来嵌入到移动应用程序中，但我只是想展示如何在移动应用程序中重用相同的DApp。</p><h2 id="9d32" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">3.钱包容器</h2><p id="3eff" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">写以太坊比读以太坊更棘手。我们必须更加小心，因为它处理的是创建实际交易和发送真实货币。</p><p id="4347" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常，当构建一个常规的DApp时，我们使用<code class="eh nf ng nh ni b">web3.js</code>库进行API调用，如下所示:</p><pre class="kt ku kv kw fq od ni oe of aw og dt"><span id="1812" class="nn ky hu ni b fv oh oi l oj ok">contract.transfer.<strong class="ni hv">sendTransaction</strong>(receiver, tokens, {<br/>  to: contract.address,<br/>  gasLimit: 21000,<br/>  gasPrice: 20000000000<br/>}, function(err, result) {<br/>  // Render the DOM with result<br/>})</span></pre><p id="7521" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个方法<code class="eh nf ng nh ni b">sendTransaction</code>实际上做了两件事:</p><ol class=""><li id="d574" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">为名为<code class="eh nf ng nh ni b">"transfer"</code>的契约方法创建一个编码的事务对象。</li><li id="4a5b" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">通过JSON-RPC对交易对象进行签名并广播到以太坊。</li></ol><p id="e6f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的项目，我们将不再让DApp处理这两者，而是:</p><ol class=""><li id="4f8f" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">让我们的<strong class="je hv"> DApp容器</strong> <strong class="je hv">只处理第一部分</strong></li><li id="113e" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">并创建一个名为<strong class="je hv">“钱包容器”</strong><strong class="je hv">的单独容器来处理第二部分</strong></li></ol><p id="4846" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过将两者分开，DApp容器不必处理私钥，而是将它委托给钱包容器，就像<a class="ae kr" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank">元掩码</a>在桌面上自动处理这个问题一样。这样，DApp开发人员可以专注于应用程序逻辑。</p><p id="4c56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们没有使用<code class="eh nf ng nh ni b">sendTransaction</code>方法，而是首先使用一个名为<code class="eh nf ng nh ni b">getData</code>的API来获取一个事务对象:</p><pre class="kt ku kv kw fq od ni oe of aw og dt"><span id="2ac8" class="nn ky hu ni b fv oh oi l oj ok">var tx = contract.transfer.<strong class="ni hv">getData</strong>(receiver, tokens)</span></pre><p id="7a9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后通过<a class="ae kr" href="https://docs.jasonette.com/agents/#2-agentresponse" rel="noopener ugc nofollow" target="_blank"/><code class="eh nf ng nh ni b"><a class="ae kr" href="https://docs.jasonette.com/agents/#2-agentresponse" rel="noopener ugc nofollow" target="_blank">$agent.response</a></code><a class="ae kr" href="https://docs.jasonette.com/agents/#2-agentresponse" rel="noopener ugc nofollow" target="_blank">API</a>将其传递回父app:</p><pre class="kt ku kv kw fq od ni oe of aw og dt"><span id="d931" class="nn ky hu ni b fv oh oi l oj ok">$agent.response({ tx: tx })</span></pre><p id="e433" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，父本地应用将<a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/mobile/app/main.json#L54" rel="noopener ugc nofollow" target="_blank">将其传递给我们的新钱包视图</a>。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ol"><img src="../Images/3e1f78efab36287a3d4e53d51dcae1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-iLeXA8SLZuTkrRL9Csnw.png"/></div></div></figure><p id="430f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">wallet视图(及其包含的wallet代理)将获取这个未签名的交易数据，对其进行签名，然后通过Infura进行广播。可以在这里查看钱包视图源代码:<a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/mobile/wallet/wallet.json" rel="noopener ugc nofollow" target="_blank">https://github . com/gliechtenstein/ERC 20/blob/master/mobile/wallet/wallet . JSON</a></p><p id="8a82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是钱包代理代码:<a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/mobile/wallet/wallet.html" rel="noopener ugc nofollow" target="_blank">https://github . com/gliechtenstein/ERC 20/blob/master/mobile/wallet/wallet . html</a></p><p id="c68d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，“钱包视图”是一个完全独立的沙盒视图，就像MetaMask在新的弹出浏览器中打开一样。这是故意的。这使DApp开发者不必处理私钥。</p><h1 id="9db7" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">为什么要这样建？</h1><p id="510c" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">概括一下，我们的整个移动应用程序是如何工作的:</p><ul class=""><li id="1c7b" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">用户只与本地的UI进行交互</li><li id="6a07" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">原生UI是由标记实时构建的，而不是硬编码的编译程序。</li><li id="50ec" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">原生UI嵌入了多个类似微服务的web容器，它们运行独立的HTML/JavaScript应用，通过JSON-RPC相互通信。</li><li id="775e" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">开发人员需要编写的唯一“程序”是描述UI和指令的JSON标记。</li></ul><p id="7b32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样构建一个app有什么好处，尤其是对于以太坊这种去中心化的网络？</p><h2 id="89ec" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">1.容易的</h2><p id="b5ea" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">用这种方式构建应用程序简单多了。你不需要重写你的DApp来在移动上工作，你不需要雇佣一个移动开发者，你不需要维护一个单独的移动代码库。</p><p id="ea67" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你需要做的就是:</p><ol class=""><li id="71fb" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">编写两个表示每个视图的标记文件</li><li id="2789" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">像iframe一样嵌入自己的DApp作为代理</li><li id="f5b1" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">让您的DApp和父本机应用程序通过JSON-RPC之类的协议进行通信。</li></ol><p id="d4e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这给了你一个单一的代码库，既可以作为你的网站，也可以用于手机。<strong class="je hv">你唯一需要维护的是标记</strong>。但是即使是标记——因为它是公开的——也可以被不同的应用程序共享。</p><p id="e55a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以看看以太坊的ERC标准是如何工作的，以便理解其含义。大多数ERC20令牌开发者只是简单地继承了<a class="ka kb gr" href="https://medium.com/u/4e5199c3ee0a?source=post_page-----d25024db07d5--------------------------------" rel="noopener" target="_blank"> Zeppelin </a>的<a class="ae kr" href="https://github.com/OpenZeppelin/zeppelin-solidity" rel="noopener ugc nofollow" target="_blank">Zeppelin/solidity</a>——审计最多，因此也是最安全的ERC20令牌合约——并在此基础上实现他们自己的定制，这使得构建智能合约更容易，同时保持其安全性。</p><p id="2743" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我预测，同样类型的标准可能会出现，用于构建安全的移动前端。</p><h2 id="4f99" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">2.永恒的</h2><p id="35b9" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">每个视图都被表示为一个独立的JSON标记——就像所有的网页都被表示为一个HTML标记——没有什么隐藏在复杂的依赖关系后面，使得一段代码难以理解。JSON标记语法都不是特定于设备的。每个视图都是独立的和沙盒化的，这也有助于简化。简单带来透明。</p><p id="ff70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了构建一个将永远持续的协议，您希望您的客户尽可能透明，这样就可以围绕您的协议的客户形成一个自由市场。这样<strong class="je hv">你的协议可以永远存在，甚至在你离开这个项目之后。</strong></p><div class="mk ml fm fo mm mn"><a href="https://levelup.gitconnected.com/how-to-write-code-that-will-last-forever-f8c4b1c0c867" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">如何编写永久有效的代码</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">这并不是因为每个人都不敢碰它</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">levelup.gitconnected.com</p></div></div><div class="mw l"><div class="om l my mz na mw nb ja mn"/></div></div></a></div><h2 id="5343" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">3.可定制的</h2><p id="e150" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">下面的例子使用了和上面完全一样的DApp，只是用了不同的视图标记来创建一个完全不同的界面。</p><div class="kt ku kv kw fq ab cb"><figure class="on iv oo op oq or os paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/5e4d79364d222f8b2057e4deec0a7b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*P15bdhCUFVwRO3ThKIZNOg.jpeg"/></div></figure><figure class="on iv ot op oq or os paragraph-image"><img src="../Images/62b5fa546b5385e05d4894d4d7114ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/1*4OIlv68lpOGQ07yUoU_TwQ.gif"/></figure></div><p id="6eba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不需要做什么特别的事情来实现这个改变。你在上面看到的实际上是一个JSON标记，是我从早期版本中派生出来的。我花了不到5分钟写下:</p><p id="a9db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/mobile/app/simple.json" rel="noopener ugc nofollow" target="_blank">https://github . com/gliechtenstein/ERC 20/blob/master/mobile/app/simple . JSON</a></p><p id="a926" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">真正酷的是，你也可以获得相同的标记，并为<strong class="je hv">你自己的ERC20令牌</strong>定制它，因为所有的ERC20令牌共享相同的后端协议。甚至DApp集装箱也可以简单地通过切换出<a class="ae kr" href="https://github.com/gliechtenstein/erc20/blob/master/web/index.html#L208" rel="noopener ugc nofollow" target="_blank">合同地址</a>来重复使用。</p><h1 id="dabc" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">未来的移动应用会是什么样子？</h1><p id="6543" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">未来的移动应用将建立在连接到比特币和以太坊等分散网络的加密协议之上，而不是连接到脸书这样的集中网络。</p><p id="62b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个世界上，我们可能需要重新思考什么是“移动应用”的概念，以及当用户的身份被植入协议时，如何在不损害用户安全的情况下构建一个移动应用。</p><h2 id="146f" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">1.最小权力原则</h2><p id="5485" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">有一个概念叫做“最小能量法则”，由蒂姆·伯纳斯·李爵士创造并实施，作为万维网的基本设计原则。</p><div class="mk ml fm fo mm mn"><a href="https://www.w3.org/2001/tag/doc/leastPower.html" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">最小权力原则</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">万维网在全球范围内促进信息重用的能力是独一无二的。信息发布于…</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">www.w3.org</p></div></div></div></a></div><p id="f2aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个想法是，在潜在的危险环境中，简单优于复杂，比如网络。该规则规定<a class="ae kr" href="https://en.wikipedia.org/wiki/Rule_of_least_power" rel="noopener ugc nofollow" target="_blank">“描述性”语言比“过程性”语言更强</a>:</p><blockquote class="ma mb mc"><p id="95bc" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">“……在计算机语言中进行选择，……<strong class="je hv">一个人选择的语言越不程序化、越具描述性，他就越能处理用该语言存储的数据。</strong></p></blockquote><p id="cefc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，简单的语言比复杂的语言更安全:</p><blockquote class="ma mb mc"><p id="6fa5" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">“……<strong class="je hv">功能较弱的语言通常更容易保护</strong>……因为用简单语言编写的程序更容易分析，也更容易识别它们确实存在的安全问题”</p></blockquote><p id="57a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总结:<strong class="je hv">简单比复杂更强大。简单比复杂更安全</strong>。像万维网这样的狂野西部环境应该用尽可能简单的语言来实现，比如HTML。</p><blockquote class="ma mb mc"><p id="2605" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">“使语言变得强大的各种特征可能会使对用这些语言表达的程序或信息的分析复杂化或阻止这种分析，这表明在网上发布信息时要认真权衡这种风险。的确，在网络上，通常应该选择最不强大的语言。</p></blockquote><p id="d23f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">快进到今天，我们正在应对一个新的互联网，我们通过它发送真金白银，我们希望我们的应用程序在最初的创意团队离开后很长时间内以最少的维护安全地运行。<strong class="je hv">“最小功率法则”的设计原则从未像今天这样重要。</strong></p><p id="2b0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是为什么我相信一个“不太强大”的标准化<a class="ae kr" href="https://www.jasonette.com" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">标记驱动的方法</strong>更适合构建基于加密协议的移动应用</a>，而不是构建“强大”的应用，从长远来看，这些应用最终会成为一种负担。</p><h2 id="f450" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">2.分散式互联网的结构</h2><p id="1f1e" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">作为一名协议开发人员，你的目标不应该是构建一个单一的应用程序——你不是一名“应用程序开发人员”。相反，<strong class="je hv">你应该100%的专注于让任何人都可以轻松的将你的协议嵌入到他们的应用程序中</strong>，并尽可能的开放它。</p><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ou"><img src="../Images/98d8428e6d4dd44066c319d72e04a02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c03iLywZFDoChl4Cimcpbw.png"/></div></div><figcaption class="ov ow fg fe ff ox oy bd b be z ek">Hypothetical example: <a class="ka kb gr" href="https://medium.com/u/f4d568271227?source=post_page-----d25024db07d5--------------------------------" rel="noopener" target="_blank">Augur</a></figcaption></figure><p id="a2fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的假设示例中，<a class="ae kr" href="https://www.augur.net/" rel="noopener ugc nofollow" target="_blank">augr</a>拥有多个智能合约，构成了整个体验。Augur团队可以自己开发一个单一的一体化应用，但是这对去中心化有什么好处呢？</p><p id="adf9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">构建协议最酷的一点是，你可以让任何人构建自己的解释，并根据特定需求进行优化。采用何种方式应由自由市场决定。构建一个“参考”实现可能不错，但这不应该是你的目标。我们的目标是让您的社区成员Alice、Bob和Carol尽可能轻松地在此基础上构建他们自己的定制应用程序。最好的方法是用一种尽可能可分叉的语言编写你的应用程序，在我看来，这是一种标记方法。</p><h2 id="a698" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">3.单体与混搭</h2><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oz"><img src="../Images/0c273f8c5e0c1fbb02d42ded5ef2dbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j58cP7SmhnXhZCGDyeEMQg.png"/></div></div></figure><p id="da4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们更进一步。</p><p id="d463" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今天，我们只有一个占主导地位的协议——HTTP。然而，未来的<strong class="je hv">移动应用将是多协议的。</strong></p><p id="20c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当前的“移动应用”模式就是构建一个开发者拥有100%所有权的单一应用。在“客户机-服务器”世界中，这是一个自然的选择，因为在这个世界中，移动客户机的开发者也拥有服务器。比如脸书app连接脸书服务器，Twitter app连接Twitter服务器等。在那种情况下，客户端开发人员构建一个完整的应用程序是完全有意义的，这也是我们到目前为止所习惯的。</p><p id="06f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在分散协议的时代，<strong class="je hv">一个应用可以由多个协议支持</strong>。一个应用程序可以是多个无主协议的“混搭”。</p><p id="da13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">没有<strong class="je hv">【奥格app】</strong><strong class="je hv">【0x app】</strong><strong class="je hv">【去中心化app】</strong>等。那是一种旧的思维方式。</p><p id="37bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">取而代之的是在一个应用程序中同时使用所有这些协议的应用程序。</p><h2 id="7a32" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">4.通过无依赖实现的安全性</h2><p id="e4f3" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">问题是，实现这一切并不像听起来那么容易。我们在这里处理的是真金白银，整合肯定不像运行<code class="eh nf ng nh ni b">npm install</code>那么简单。如今，构建任何类型的应用程序的传统方法是:</p><ol class=""><li id="e947" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">紧密耦合的模块</li><li id="c279" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">具有复杂的依赖性</li><li id="5161" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">假设一个单一的集中式应用程序</li></ol><p id="c88e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这对于<strong class="je hv">集中式可信应用程序提供商</strong>的时代来说已经很棒了，但是在<strong class="je hv">分散式无信任协议</strong>的世界里，这太冒险了，因为无论协议有多安全，应用程序开发人员一方都可能出错。</p><p id="96a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">毕竟，众所周知，高度耦合的依赖性会带来一连串的安全漏洞:</p><div class="kt ku kv kw fq ab cb"><figure class="on iv pa op oq or os paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/ea80375776e0542e977fb65dc6eac555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*bTvkXxIfIPL76Fp3h_XwAQ.png"/></div></figure><figure class="on iv pb op oq or os paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/9d67995a84b3f813c43737f51c737173.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*bOlyiyH3QyVoqySvDwxLZw.png"/></div></figure></div><p id="682c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">避免这个问题的最好方法是… <strong class="je hv">避免依赖，简化！</strong></p><div class="mk ml fm fo mm mn"><a href="https://www.schneier.com/essays/archives/1999/11/a_plea_for_simplicit.html" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">对简单的请求</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">请任何21位专家预测未来，他们可能会指向21个不同的方向。但是不管怎样…</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">www.schneier.com</p></div></div><div class="mw l"><div class="pc l my mz na mw nb ja mn"/></div></div></a></div><p id="1ee2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如Bruce Schneier在文章中宣扬的那样，<strong class="je hv">你不能保护你不了解的东西。</strong></p><p id="26cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于这些假设，我对构建移动应用的建议是将它们构建为<strong class="je hv">沙盒</strong>、<strong class="je hv">松耦合</strong>、<strong class="je hv">无依赖容器:</strong></p><div class="mk ml fm fo mm mn"><a rel="noopener follow" target="_blank" href="/@gliechtenstein/native-mobile-view-as-microservice-fd24ea62defa"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">原生移动视图作为微服务</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">Jasonette中沙盒视图如何相互对话</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">medium.com</p></div></div><div class="mw l"><div class="pd l my mz na mw nb ja mn"/></div></div></a></div><figure class="kt ku kv kw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pe"><img src="../Images/9f3454b9d1edebf5a58ac844167b59e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceLnMZ1ePxJJWGOHnYmNgQ.png"/></div></div></figure><ol class=""><li id="8615" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">每个视图都是一个沙盒容器，就像网页一样。每个视图的状态不会延续到另一个“页面”，除非明确声明(视图A和视图B是完全分离的)</li><li id="bca3" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated"><strong class="je hv">松散耦合:</strong>每个视图通过容器间协议(<code class="eh nf ng nh ni b">$href</code>用于向前移动，而<code class="eh nf ng nh ni b">$ok</code>用于向后返回)以及有时应用程序范围的共享全局变量松散耦合。</li><li id="2be1" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated"><strong class="je hv">无依赖性:</strong>所有视图都是完全独立的，无依赖性的，因此一个视图可以集成到多个不同的应用程序中，而不必重写任何东西(您可以简单地通过将<code class="eh nf ng nh ni b">href</code>属性改为指向视图C而不是视图B，将这个应用程序变成一个完全不同的应用程序)</li></ol><p id="0504" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一设计原则确保:</p><ol class=""><li id="a617" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">一个实现错误<strong class="je hv">不会导致多米诺骨牌效应</strong>导致巨大的灾难。(<a class="ae kr" href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/" rel="noopener ugc nofollow" target="_blank">参见leftpad </a>)</li><li id="94b1" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">应用程序可以<strong class="je hv">“按视图升级”</strong>而不必重新构建整个应用程序。如果没有这一点，一个错误将意味着每个使用该协议的应用程序开发人员将需要立即重建和更新他们的应用程序，这将永远不会发生。</li><li id="c6aa" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">协议开发者可以<strong class="je hv">将他们的“应用”作为一个安全的原子单元</strong>来分发，应用开发者可以轻松地将其嵌入到他们的应用中(而不是作为一个单一的应用)</li></ol><h2 id="8181" class="nn ky hu bd kz no np nq ld nr ns nt lh jn nu nv ll jr nw nx lp jv ny nz lt oa dt translated">5.将HTML无缝集成到本地应用中</h2><p id="6185" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">如果你是一名开发人员，你可能知道<strong class="je hv">“Native vs . html 5”</strong>之间的斗争。这两个派别的支持者一直在争夺哪个将成为构建移动应用的单一主导平台。</p><p id="3cc9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看待这个问题的一个更好的方法是<strong class="je hv">考虑如何将它们如此无缝地融合在一起，以至于集成几乎无法识别</strong>，因此这个问题变得无关紧要。</p><p id="0263" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经验法则是尽可能原生地构建应用程序，但是在某些情况下，集成HTML组件是有意义的——比如大量图形可视化——您应该能够以最无缝的方式来这样做。</p><p id="dc11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象构建一个简单的游戏应用程序，您可以:</p><ul class=""><li id="c390" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">使用基于HTML5的游戏引擎构建游戏的图形部分</li><li id="545a" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">但是应用程序的其余部分使用原生视图</li></ul><p id="b083" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只有当你摆脱“只有一种方法成功”的思维模式，并专注于以最佳方式整合两者时，这才是可能的。下面是本机组件和HTML组件如何完美融合在一起的示例，而根本不需要修改HTML:</p><figure class="kt ku kv kw fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="ad9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将在另一篇文章中进一步讨论这个问题:</p><div class="mk ml fm fo mm mn"><a href="https://medium.freecodecamp.org/how-to-turn-your-website-into-a-mobile-app-with-7-lines-of-json-631c9c9895f5" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab ej"><div class="mp ab mq cl cj mr"><h2 class="bd hv fv z el ms eo ep mt er et ht dt translated">如何用7行JSON把你的网站变成手机App</h2><div class="mu l"><h3 class="bd b fv z el ms eo ep mt er et ek translated">一种将Web引擎融入本地应用的新方法</h3></div><div class="mv l"><p class="bd b gc z el ms eo ep mt er et ek translated">medium.freecodecamp.org</p></div></div><div class="mw l"><div class="pf l my mz na mw nb ja mn"/></div></div></a></div><h1 id="087b" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">感兴趣吗？</h1><p id="9f49" class="pw-post-body-paragraph jc jd hu je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">在这篇文章中，我解释了如何将一个现有的web3 DApp变成一个本地移动应用程序。该方法的关键要点是:</p><ol class=""><li id="828f" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">标记驱动的</li><li id="756b" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">沙盒视图</li><li id="01c7" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">通过协议松散耦合</li></ol><p id="fd51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前两个类似于<strong class="je hv">网络浏览器</strong>的工作方式，第三个类似于<strong class="je hv">微服务</strong>的工作方式。结合这些，我提出了一个构建安全移动应用的独特架构。</p><p id="8e1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章的目的不是声称这是“最终的解决方案”，而是提出一个思考这个主题的思维框架，以及一个实际的功能实现来支持这个假设。</p><p id="e5b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我觉得<strong class="je hv">的这个题目“去中心化协议时代的前端会是什么样子？”</strong>在社区中谈得不多，因为:</p><ul class=""><li id="72eb" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">大多数人专注于构建后端，人们并不真的想担心集中式平台。</li><li id="896c" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kh ki kj kk dt translated">大部分考虑过的人都在构建集中式产品。</li></ul><p id="7621" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果你想要主流采用，移动应用是不可避免的，我们需要开始以不同的方式思考一个应用将如何在区块链世界工作。</p><p id="3557" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我对分散化技术感到兴奋，因为它与我对未来的看法非常一致，我正计划进一步探索这一领域。以下是我想到的一些主题:</p><ol class=""><li id="de09" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kq ki kj kk dt translated">拿我开发的应用程序来说，<strong class="je hv">把它变成一个</strong> <strong class="je hv">【即插即用】的框架</strong>(所以作为一个开发者，你需要做的就是用3行JSON“嵌入”你的DApp)</li><li id="8f09" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">在顶层创建高级覆盖框架，例如<strong class="je hv"> ERC20或ERC721令牌特定代理。</strong></li><li id="d1e0" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">支持其他链条:<strong class="je hv">比特币</strong>等。(欢迎建议)</li><li id="f839" class="kc kd hu je b jf kl jj km jn kn jr ko jv kp jz kq ki kj kk dt translated">考虑与<strong class="je hv">硬件钱包</strong>集成，如<a class="ae kr" href="https://www.ledgerwallet.com/" rel="noopener ugc nofollow" target="_blank">总账</a>和<a class="ae kr" href="https://trezor.io/" rel="noopener ugc nofollow" target="_blank"> Trezor </a>。</li></ol><p id="cf68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如有任何建议或反馈，欢迎分享。另外，如果你想继续这个旅程，请保持联系。我很想收到你的来信！</p><blockquote class="ma mb mc"><p id="45bf" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated"><strong class="je hv">去哪里找我:</strong></p><p id="38ad" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">在<strong class="je hv">懈怠</strong>:<a class="ae kr" href="https://jasonette.now.sh/" rel="noopener ugc nofollow" target="_blank">https://jasonette.now.sh/</a>和我聊天</p><p id="20cc" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">在<strong class="je hv">推特</strong>:<a class="ae kr" href="https://twitter.com/gliechtenstein" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">https://twitter.com/gliechtenstein</strong></a>上关注我</p><p id="b646" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">跟我上<strong class="je hv">中</strong>:<a class="ae kr" rel="noopener" href="/@gliechtenstein"><strong class="je hv">https://medium.com/@gliechtenstein</strong></a></p><p id="5704" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">在<strong class="je hv">Github</strong>:<a class="ae kr" href="https://github.com/Jasonette" rel="noopener ugc nofollow" target="_blank">https://github.com/Jasonette</a>上给Jasonette投稿</p><p id="3c35" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">在Twitter:<a class="ae kr" href="https://twitter.com/jasonclient" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">https://twitter.com/jasonclient</strong></a>上关注Project Jasonette</p><p id="f932" class="jc jd md je b jf jg jh ji jj jk jl jm me jo jp jq mf js jt ju mg jw jx jy jz hn dt translated">订阅Jasonette <strong class="je hv">简讯</strong>:<a class="ae kr" href="https://docs.jasonette.com/#mc-embedded-subscribe-form" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">https://docs.jasonette.com/#mc-embedded-subscribe-form</strong></a></p></blockquote></div></div>    
</body>
</html>