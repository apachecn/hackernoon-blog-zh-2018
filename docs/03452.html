<html>
<head>
<title>How to Migrate a Go API to Serverless (in under 10 mins)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Go API迁移到无服务器(不到10分钟)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-migrate-a-go-api-to-serverless-in-under-10-mins-e27b8a31202e?source=collection_archive---------17-----------------------#2018-04-19">https://medium.com/hackernoon/how-to-migrate-a-go-api-to-serverless-in-under-10-mins-e27b8a31202e?source=collection_archive---------17-----------------------#2018-04-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9693" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将带您逐步完成将现有Go <a class="ae jp" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>转换为<a class="ae jp" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>并将其部署到带有<a class="ae jp" href="https://aws.amazon.com/about-aws/whats-new/2016/11/introducing-the-aws-serverless-application-model/" rel="noopener ugc nofollow" target="_blank"> AWS无服务器应用程序模型(SAM) </a>的AWS Lambda &amp; API网关的过程。整个过程应该不到10分钟。我们开始吧！</p><h1 id="24b6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">1.设置</h1><p id="36e5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们的示例API使用了<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/julienschmidt/httprouter" rel="noopener ugc nofollow" target="_blank">HttpRouter</a></code> <a class="ae jp" href="https://github.com/julienschmidt/httprouter" rel="noopener ugc nofollow" target="_blank">包</a>，所以让我们先安装它。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="ca7a" class="lf jr hu kw b fv lg lh l li lj">$ go get github.com/julienschmidt/httprouter</span></pre><p id="5ba3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们定义了一个HTTP处理程序，它将返回一个200 HTTP响应，其主体为<code class="eh kt ku kv kw b">ok</code>。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5922" class="lf jr hu kw b fv lg lh l li lj"># handlers.go<br/>package main</span><span id="675e" class="lf jr hu kw b fv lk lh l li lj">import "net/http"</span><span id="448c" class="lf jr hu kw b fv lk lh l li lj">func HealthHandler(w http.ResponseWriter, r *http.Request) {<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write([]byte("ok"))<br/>}</span></pre><p id="6fcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应用程序的入口点是<code class="eh kt ku kv kw b">main</code>函数，它将<code class="eh kt ku kv kw b">HealthHandler</code>连接到<code class="eh kt ku kv kw b">/healthz</code>路由，并监听端口<code class="eh kt ku kv kw b">8080</code>上的HTTP请求。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="843a" class="lf jr hu kw b fv lg lh l li lj"># main.go<br/>package main</span><span id="42fe" class="lf jr hu kw b fv lk lh l li lj">import (<br/>    "fmt"<br/>    "log"<br/>    "net/http"<br/>    "github.com/julienschmidt/httprouter"<br/>)</span><span id="6fec" class="lf jr hu kw b fv lk lh l li lj">const (<br/>    serverPort = 8000<br/>)</span><span id="56f9" class="lf jr hu kw b fv lk lh l li lj">func main() {<br/>    router := httprouter.New()<br/>    router.Handler("GET", "/healthz", http.HandlerFunc(goserverlessapi.HealthHandler))</span><span id="0c1b" class="lf jr hu kw b fv lk lh l li lj">    fmt.Printf("Server listening on port: %d\n", serverPort)<br/>    log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", serverPort), router), nil)<br/>}</span></pre><p id="cb35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们在本地构建并运行它，以检查一切是否正常。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e046" class="lf jr hu kw b fv lg lh l li lj">$ go build -o go-serverless-api &amp;&amp; ./go-serverless-api<br/>Server listening on port: 8080</span></pre><h1 id="bbe1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">2.将应用程序代码转换为无服务器</h1><p id="8a50" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">为了部署到无服务器后端，我们需要能够处理来自AWS Lambda的请求。Lambda函数的签名与常规HTTP处理程序不同。想象一下，如果我们的应用程序中有数百个而不是一个。我们将不得不手动更新所有功能并重新编写测试，这样做我们将丧失部署到非无服务器后端的能力。</p><p id="2bad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一个解决方案可以避免刚才列出的所有问题。我们将为AWS Lambda创建一个修改的入口点。使用<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/apex/gateway" rel="noopener ugc nofollow" target="_blank">gateway</a></code> <a class="ae jp" href="https://github.com/apex/gateway" rel="noopener ugc nofollow" target="_blank">包</a>，我们将把<code class="eh kt ku kv kw b">net/http</code>的<code class="eh kt ku kv kw b">ListenAndServe</code>换成<code class="eh kt ku kv kw b">gateway.ListenAndServe</code>，这将把AWS Lambda提供的有效载荷转换成HTTP处理程序接受的<code class="eh kt ku kv kw b"><a class="ae jp" href="https://godoc.org/net/http#Request" rel="noopener ugc nofollow" target="_blank">*http.Request</a></code>类型。</p><p id="88e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现第二个入口点，我们需要重新组织我们的项目。我们将为AWS Lambda one创建一个目录，并将我们原来的入口点也移到一个新文件夹中。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="9e7c" class="lf jr hu kw b fv lg lh l li lj"># original entrypoint moved to new location<br/>$ mkdir -p cmd/go-serverless-api</span><span id="644d" class="lf jr hu kw b fv lk lh l li lj"># new entrypoint for lambda<br/>$ mkdir -p cmd/go-serverless-api-lambda</span></pre><p id="94f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将把<code class="eh kt ku kv kw b">main.go</code>文件复制到每个新目录中，然后从我们项目的根目录中删除它。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="91a5" class="lf jr hu kw b fv lg lh l li lj">$ cp main.go cmd/go-serverless-api<br/>$ cp main.go cmd/go-serverless-api-lambda<br/>$ rm main.go</span></pre><p id="d4e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们项目根目录中的包不再是<code class="eh kt ku kv kw b">main</code>包(Go用来运行应用程序的包)。我们将把它重命名为<code class="eh kt ku kv kw b">goserverlessapi</code>,这样我们就可以把它作为一个库导入到我们的新入口点，这两个入口点都将成为<code class="eh kt ku kv kw b">main</code>包。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="86f7" class="lf jr hu kw b fv lg lh l li lj">$ grep -l 'package main' *.go | xargs sed -i 's/package main/package goserverlessapi/g'</span></pre><p id="4993" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在简单地查找并替换项目根目录下的Go文件后，你的<code class="eh kt ku kv kw b">handlers.go</code>应该是这样的。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="cc85" class="lf jr hu kw b fv lg lh l li lj"># handlers.go<br/>package goserverlessapi</span><span id="dd0b" class="lf jr hu kw b fv lk lh l li lj">import "net/http"</span><span id="f1a5" class="lf jr hu kw b fv lk lh l li lj">func HealthHandler(w http.ResponseWriter, r *http.Request) {<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write([]byte("ok"))<br/>}</span></pre><p id="bbde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要更新我们的原始入口点来导入<code class="eh kt ku kv kw b">goserverlessapi</code>包并访问<code class="eh kt ku kv kw b">HealthHandler</code>函数作为导出。注意，您需要修改<code class="eh kt ku kv kw b">goserverlessapi</code>包的导入路径，以匹配您的项目根目录在<code class="eh kt ku kv kw b">$GOPATH</code>中的位置。本教程中使用的github上的<a class="ae jp" href="https://github.com/techjacker/go-serverless-api" rel="noopener ugc nofollow" target="_blank">示例应用程序的正确路径是<code class="eh kt ku kv kw b">github.com/techjacker/go-serverless-api</code>。</a></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="9861" class="lf jr hu kw b fv lg lh l li lj"># cmd/go-serverless-api/main.go<br/>package main</span><span id="4235" class="lf jr hu kw b fv lk lh l li lj">import (<br/>    "fmt"<br/>    "log"<br/>    "net/http"</span><span id="1c56" class="lf jr hu kw b fv lk lh l li lj">"github.com/julienschmidt/httprouter"<br/>    "github.com/techjacker/go-serverless-api"<br/>)</span><span id="fb4c" class="lf jr hu kw b fv lk lh l li lj">const (<br/>    serverPort = 8080<br/>)</span><span id="038f" class="lf jr hu kw b fv lk lh l li lj">func main() {<br/>    router := httprouter.New()<br/>    router.Handler("GET", "/healthz", http.HandlerFunc(goserverlessapi.HealthHandler))<br/>    <br/>    fmt.Printf("Server listening on port: %d\n", serverPort)<br/>    log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", serverPort), router), nil)<br/>}</span></pre><p id="2a70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来更新AWS Lambda入口点。我们将使用<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/apex/gateway" rel="noopener ugc nofollow" target="_blank">gateway</a></code>包，它是在AWS Lambda &amp; API网关上运行时Go net/http的替代包，所以让我们先安装它。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="10a2" class="lf jr hu kw b fv lg lh l li lj">$ go get github.com/apex/gateway</span></pre><p id="9e5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后将AWS Lambda入口点文件更新为以下内容。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="84ca" class="lf jr hu kw b fv lg lh l li lj"># cmd/go-serverless-api-lambda/main.go<br/>package main</span><span id="c19f" class="lf jr hu kw b fv lk lh l li lj">import (<br/>    "log"<br/>    "net/http"</span><span id="7861" class="lf jr hu kw b fv lk lh l li lj">    "github.com/apex/gateway"<br/>    "github.com/julienschmidt/httprouter"<br/>    "github.com/techjacker/go-serverless-api"<br/>)</span><span id="3de4" class="lf jr hu kw b fv lk lh l li lj">func main() {<br/>    router := httprouter.New()<br/>    router.Handler("GET", "/healthz", http.HandlerFunc(goserverlessapi.HealthHandler))<br/>    log.Fatal(gateway.ListenAndServe("", router), nil)<br/>}</span></pre><p id="4843" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经将<code class="eh kt ku kv kw b">gateway</code>添加到我们的导入中，并将其替换为<code class="eh kt ku kv kw b">http.ListenAndServe</code>。端口值在Lambda上下文中是多余的，<code class="eh kt ku kv kw b">gateway</code>包丢弃了它，因此我们可以安全地删除端口常量并用空字符串替换它。此外，我们还包含了来自<code class="eh kt ku kv kw b">go-serverless-api</code>包的<code class="eh kt ku kv kw b">HealthHandler</code>(这个包在项目的根目录中，曾经是我们的主包)作为<code class="eh kt ku kv kw b">/healthz</code>路径的处理程序。</p><h1 id="ca94" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">3.在本地构建和运行</h1><p id="71c3" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们再次构建并运行我们最初的HTTP API。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="27ff" class="lf jr hu kw b fv lg lh l li lj">$ go build \<br/>    -o go-serverless-api \<br/>    ./cmd/go-serverless-api</span><span id="e383" class="lf jr hu kw b fv lk lh l li lj">$ ./go-serverless-api<br/>Server listening on port: 8080</span></pre><p id="d9ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">打开另一个终端窗口并进行查询。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5e77" class="lf jr hu kw b fv lg lh l li lj">$ curl -s http://localhost:8080/healthz ok</span></pre><p id="7386" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一切都还能用！</p><p id="c673" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们对AWS Lambda版本做同样的事情。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="cad2" class="lf jr hu kw b fv lg lh l li lj">$ go build \<br/>    -o go-serverless-api-lambda \<br/>    ./cmd/go-serverless-api-lambda</span><span id="e0f1" class="lf jr hu kw b fv lk lh l li lj">$ ./go-serverless-api-lambda</span></pre><p id="7096" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次，打开一个新的终端并查询它。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="370a" class="lf jr hu kw b fv lg lh l li lj">$ curl -s <a class="ae jp" href="http://localhost:8080/healthz" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/healthz</a><br/>http: error: ConnectionError: HTTPConnectionPool(host='localhost', port=8080): Max retries exceeded with url: /healthz (Caused by NewConnectionError(': Failed to establish a new connection: [Errno 111] Connection refused',)) while doing GET request to URL: <a class="ae jp" href="http://localhost:8080/healthz" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/healthz</a></span></pre><p id="b10e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要担心，这个错误是意料之中的，因为AWS Lambda版本没有监听HTTP连接，而是期望获得一个<code class="eh kt ku kv kw b"><a class="ae jp" href="https://godoc.org/github.com/aws/aws-lambda-go/events#APIGatewayProxyRequest" rel="noopener ugc nofollow" target="_blank">APIGatewayProxyRequest</a></code>类型。</p><h1 id="0510" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">4.AWS Lambda的程序包应用程序</h1><p id="b92d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">为AWS Lambda使用的操作系统linux构建二进制文件。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3cdf" class="lf jr hu kw b fv lg lh l li lj">$ GOOS=linux go build \<br/>    -o go-serverless-api-lambda \<br/>    ./cmd/go-serverless-api-lambda</span></pre><p id="fc01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">AWS Lambda要求将函数代码捆绑到一个zip文件中，所以让我们继续压缩二进制文件。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4bec" class="lf jr hu kw b fv lg lh l li lj">$ zip go-serverless-api-lambda.zip go-serverless-api-lambda</span></pre><p id="9820" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在最后一步部署中使用创建的<code class="eh kt ku kv kw b">go-serverless-api-lambda.zip</code>。</p><h1 id="c22f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">5.部署</h1><p id="effc" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我看过一些使用<a class="ae jp" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI工具</a>的教程，使用特别命令部署到AWS Lambda。这绝对是错误的做法！您应该像应用程序的其他方面一样自动化您的基础设施。部署的行业标准要么是<a class="ae jp" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank">地形</a>要么是<a class="ae jp" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> AWS云形成</a>。两者都为您提供了一种构建基础设施的声明式方法。您将此配置保存在提交到存储库的YAML/JSON (Cloudformation)或HCL (Terraform)文件中。这样做的问题是，您必须处理堆栈的所有底层细节。如果我们能够用不到20行代码而不是数百行代码来描述我们的基础设施，那就太好了。进入<a class="ae jp" href="https://aws.amazon.com/about-aws/whats-new/2016/11/introducing-the-aws-serverless-application-model/" rel="noopener ugc nofollow" target="_blank"> AWS无服务器应用模型(SAM) </a>。</p><h2 id="5a7e" class="lf jr hu bd js ll lm ln jw lo lp lq ka jc lr ls ke jg lt lu ki jk lv lw km lx dt translated">AWS无服务器应用程序模型(SAM)</h2><p id="2336" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">SAM是由Amazon倡导的新标准，旨在使部署无服务器基础设施更简单、更简洁。SAM是一个开源规范— <a class="ae jp" href="https://github.com/awslabs/serverless-application-model/blob/develop/versions/2016-10-31.md" rel="noopener ugc nofollow" target="_blank">参见完整的参考指南</a>。希望其他云供应商将来会采用这种技术，这样就有可能用一个配置无缝地部署到多个云中。</p><h2 id="3839" class="lf jr hu bd js ll lm ln jw lo lp lq ka jc lr ls ke jg lt lu ki jk lv lw km lx dt translated">使用AWS SAM部署</h2><p id="271d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">将以下YAML文件添加到项目的根目录中。这是一个配置AWS Lambda函数的SAM模板，该函数运行您的Go应用程序，并将其部署在AWS API Gateway提供的HTTP接口后面。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6e44" class="lf jr hu kw b fv lg lh l li lj"># template.yaml<br/>AWSTemplateFormatVersion: '2010-09-09'<br/>Transform: 'AWS::Serverless-2016-10-31'<br/>Description: 'Boilerplate Go API.'<br/>Resources:<br/>  GoAPI:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      Handler: go-serverless-api-lambda<br/>      Runtime: go1.x<br/>      CodeUri: ./go-serverless-api-lambda.zip<br/>      Events:<br/>        Request:<br/>          Type: Api<br/>          Properties:<br/>            Method: ANY<br/>            Path: /{proxy+}</span></pre><p id="bf07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第<code class="eh kt ku kv kw b">Type: AWS::Serverless::Function</code>行创建了一个Lambda函数，由我们之前构建的二进制文件处理(<code class="eh kt ku kv kw b">Handler: go-serverless-api-lambda</code>)。这个Lambda函数可以响应由其他AWS服务触发的任意数量的事件，例如由AWS S3和Kinesis触发的事件。文件包含<a class="ae jp" href="https://github.com/awslabs/serverless-application-model/blob/develop/versions/2016-10-31.md#event-source-types" rel="noopener ugc nofollow" target="_blank">事件源</a>的完整列表。在我们的例子中，我们希望它通过API网关响应HTTP请求，因此我们将事件设置为<code class="eh kt ku kv kw b">Type: Api</code>。SAM隐式地为我们创建了一个API网关，作为其中的一部分，然后我们通过将方法设置为<code class="eh kt ku kv kw b">ANY</code>，对其进行配置以响应任何类型的HTTP请求。我们告诉我们的API通过添加<code class="eh kt ku kv kw b">Path: /{proxy+}</code>来处理下面包括根的所有路径。</p><p id="b526" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们仍然需要将包含Go二进制文件的zip文件上传到AWS S3。确保您已经创建了一个S3桶，准备接收我们的zip。这是您希望手动执行的一次性操作。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1b96" class="lf jr hu kw b fv lg lh l li lj">$ aws s3 mb s3://my-bucket</span></pre><p id="e39e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下命令将上传zip文件并创建打包的SAM模板。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="edd6" class="lf jr hu kw b fv lg lh l li lj">$ aws cloudformation package \<br/>    --template-file template.yaml \<br/>    --s3-bucket my-bucket \<br/>    --output-template-file packaged-template.yaml</span></pre><p id="be8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您现在应该有一个指向上传的zip文件的<code class="eh kt ku kv kw b">packaged-template.yaml</code>文件。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="134c" class="lf jr hu kw b fv lg lh l li lj"># packaged-template.yaml<br/>AWSTemplateFormatVersion: '2010-09-09'<br/>Transform: 'AWS::Serverless-2016-10-31'<br/>Description: 'Boilerplate Go API.'<br/>Resources:<br/>  GoAPI:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      Handler: go-serverless-api-lambda<br/>      Runtime: go1.x<br/>      CodeUri: s3://my-bucket/8982639e71e0d433cd99f9fa4207ecbe<br/>      Events:<br/>        Request:<br/>          Type: Api<br/>          Properties:<br/>            Method: ANY<br/>            Path: /{proxy+}</span></pre><p id="bebb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们使用这个新的打包模板进行部署。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="fed2" class="lf jr hu kw b fv lg lh l li lj">$ aws cloudformation deploy \<br/>    --template-file packaged-template.yaml \<br/>    --stack-name go-serverless-api-stack \<br/>    --capabilities CAPABILITY_IAM</span></pre><p id="1a33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">cloudformation需要<code class="eh kt ku kv kw b">--capabilities CAPABILITY_IAM</code>标志来为您创建堆栈，因为这将涉及修改IAM权限——AWS要求您明确地将它设置为一种安全措施。在幕后，SAM模板被编译成一个长达数百行的常规cloudformation模板。所有这些对用户来说都是完全隐藏的(尽管如果愿意，您可以自由地检查编译好的cloudformation模板)。</p><h1 id="543b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">设置6。测试部署的无服务器API</h1><p id="88b5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">为了发现我们部署的API的端点，我们需要找出API网关REST <code class="eh kt ku kv kw b">id</code>。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d5a2" class="lf jr hu kw b fv lg lh l li lj">$ aws apigateway get-rest-apis<br/>{<br/>    "items": [<br/>        {<br/>            "id": "0qu18x8pyd",<br/>            "name": "go-serverless-api-stack",<br/>            "createdDate": 1523987269,<br/>            "version": "1.0",<br/>            "apiKeySource": "HEADER",<br/>            "endpointConfiguration": {<br/>                "types": [<br/>                    "EDGE"<br/>                ]<br/>            }<br/>        }<br/>    ]<br/>}</span></pre><p id="0fe2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">AWS API网关地址采用以下格式。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="8524" class="lf jr hu kw b fv lg lh l li lj">https://&lt;api-rest-id&gt;.execute-api.&lt;your-aws-region&gt;.amazonaws.com/&lt;api-stage&gt;</span></pre><p id="ad8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个<a class="ae jp" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-stages.html" rel="noopener ugc nofollow" target="_blank">阶段</a>是亚马逊对部署的术语。SAM为您创建了两个不同的阶段:<code class="eh kt ku kv kw b">Stage</code>和<code class="eh kt ku kv kw b">Prod</code>。请注意标题的大小写，它也在URL中使用！我想AWS忘记了每个人都称他们的测试环境为<code class="eh kt ku kv kw b">Staging</code>而不是<code class="eh kt ku kv kw b">Stage</code>，但是没关系！</p><p id="add3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">萨姆在以下地点为我们设置了终端。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7722" class="lf jr hu kw b fv lg lh l li lj">https://0qu18x8pyd.execute-api.eu-west-1.amazonaws.com/Stage <a class="ae jp" href="https://0qu18x8pyd.execute-api.eu-west-1.amazonaws.com/Prod" rel="noopener ugc nofollow" target="_blank">https://0qu18x8pyd.execute-api.eu-west-1.amazonaws.com/Prod</a></span></pre><p id="fa95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们调用我们的API。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2953" class="lf jr hu kw b fv lg lh l li lj">$ curl -s https://0qu18x8pyd.execute-api.eu-west-1.amazonaws.com/Prod {"message":"Missing Authentication Token"}</span></pre><p id="5412" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不用慌！当你向根资源发出请求而没有为它定义一个处理程序时，这就是标准API网关错误。我们定义的唯一处理程序是<code class="eh kt ku kv kw b">/healthz</code>，所以让我们试试。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="8c2c" class="lf jr hu kw b fv lg lh l li lj">$ curl -s https://0qu18x8pyd.execute-api.eu-west-1.amazonaws.com/Prod/healthz ok</span></pre><p id="8d61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">瞧啊。我们的API现在由一个无服务器的后端提供支持。</p><p id="a7d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本教程的完整代码可在<a class="ae jp" href="https://github.com/techjacker/go-serverless-api" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。</p><p id="564c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将很快在Go和无服务器上发布更多文章。在推特<a class="ae jp" href="https://twitter.com/agriffonline" rel="noopener ugc nofollow" target="_blank">上关注我</a>以便在我关注时得到通知。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="e25a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mf">最初发表于</em><a class="ae jp" href="https://andrewgriffithsonline.com/blog/180412-migrate-go-api-to-serverless-under-10-mins/" rel="noopener ugc nofollow" target="_blank"><em class="mf">andrewgriffithsonline.com</em></a><em class="mf">。</em></p><figure class="kx ky kz la fq mg"><div class="bz el l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>