<html>
<head>
<title>Lessons Learned — A Year Of Going “Fully Serverless” In Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验教训—生产中“完全无服务器”的一年</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lessons-learned-a-year-of-going-fully-serverless-in-production-3d7e0d72213f?source=collection_archive---------0-----------------------#2018-04-20">https://medium.com/hackernoon/lessons-learned-a-year-of-going-fully-serverless-in-production-3d7e0d72213f?source=collection_archive---------0-----------------------#2018-04-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1133479ae26619ac19ed551bcfa2c343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBfYFgLJIU8Ef3Z6dvG35A.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by Aaron Burden</figcaption></figure><p id="7b0d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<a class="ae ke" href="https://toriihq.com" rel="noopener ugc nofollow" target="_blank">鸟居</a>，我们决定尽可能走<strong class="ji hv">无运营</strong>的道路，这意味着我们将把所有的精力放在我们的产品上，而不是在<strong class="ji hv">运营</strong>上。虽然我们喜欢开发运维，但这不是我们公司的主要关注点。</p><blockquote class="kf kg kh"><p id="36dc" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="hu">无服务器，因为我们喜欢晚上睡觉。</em>T11】</strong></p></blockquote><p id="6f8e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以将应用程序分为三个部分:</p><ol class=""><li id="2e68" class="km kn hu ji b jj jk jn jo jr ko jv kp jz kq kd kr ks kt ku dt translated"><strong class="ji hv">静态网站</strong>。这些是前端网站，用React编写，在构建时静态生成。</li><li id="6367" class="km kn hu ji b jj kv jn kw jr kx jv ky jz kz kd kr ks kt ku dt translated"><strong class="ji hv">后台工作。</strong>这些是由文件上传、webhooks或任何其他异步事件等事件调度或触发的作业。</li><li id="314d" class="km kn hu ji b jj kv jn kw jr kx jv ky jz kz kd kr ks kt ku dt translated"><strong class="ji hv"> API服务器。</strong>REST API服务器与我们的数据库交互，并为所有客户端请求提供服务。</li></ol><h1 id="d29c" class="la lb hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">经验教训</h1><h2 id="edd9" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #1。静态网站</strong></h2><p id="0792" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">静态网站速度快、易于扩展且易于分发。我们使用React构建我们的前端，代码被打包成一个简单的HTML/JS/resources包，准备分发。</p><p id="fdc1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们使用<a class="ae ke" href="https://www.netlify.com" rel="noopener ugc nofollow" target="_blank"> Netlify </a>在CDN上托管这些静态资产，并从世界任何地方获得<strong class="ji hv">快速加载时间</strong>。</p><p id="de1f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里没有要配置的Nginx/Apache服务器👍</p><h2 id="2a7c" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #2。无服务器上的API服务器</strong></h2><p id="7019" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">基本思想是API服务器是一个函数:输入是一个HTTP请求，输出是一个HTTP响应。这对于FaaS来说是完美的，每个HTTP请求都有自己的服务器实例来处理。</p><p id="9c59" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">这种设置带来了自动可扩展性、高可用性，并显著降低了成本</strong>。它还使事情变得更简单，因为移动的部分更少:没有服务器，没有负载平衡器，没有自动扩展组。所有这些都被抽象掉了，我们只关心一个函数。</p><p id="0995" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将整个Node.js应用程序打包成一个单独的AWS Lambda函数。API网关将所有流量路由到它，Node.js应用程序将其视为常规HTTP请求。</p><p id="6fad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们选择了<code class="eh mr ms mt mu b">apex/up</code>来设置堆栈、更新它和部署我们的功能。真的就像在你的终端里写<code class="eh mr ms mt mu b">up</code>一样简单。它是高度可配置的，所以您可以根据自己的需要定制部署，但是如果您没有特殊的需求，那么默认的部署就可以了。</p><p id="2b87" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">无需为任何服务器供应、配置或应用安全补丁👏</strong></p><h2 id="2947" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #3。无服务器包装</strong></h2><p id="15cf" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">部署Lambda函数有一个52Mb的函数限制，包括它的所有依赖项。如果你最近编写了一个不错的Node.js项目，你就会知道我们可以轻松地超越这个限制。注意:有一种从S3部署它的方法可以绕过这个限制，我们还没有尝试过。</p><p id="69ec" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了减轻这种情况，我们只包含必需的依赖项，并通过排除未使用的文件(如READMEs、包历史、测试、文档和示例)来缩减它们的大小。我们发布了一个名为<code class="eh mr ms mt mu b"><a class="ae ke" href="https://www.npmjs.com/package/lambdapack" rel="noopener ugc nofollow" target="_blank">lambdapack</a></code>的包来帮助完成这项工作。它会用<code class="eh mr ms mt mu b">webpack</code>打包你的代码，提供最新的Node.js和JavaScript特性，同时让你的<code class="eh mr ms mt mu b">node_modules</code>尽可能小。<code class="eh mr ms mt mu b">lambdapack</code>与<code class="eh mr ms mt mu b">apex/up</code>完全集成，因此构建过程得到优化并高效打包。</p><p id="64b9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在GitHub上阅读更多关于<code class="eh mr ms mt mu b"><a class="ae ke" href="https://www.npmjs.com/package/lambdapack" rel="noopener ugc nofollow" target="_blank">lambdapack</a></code>的内容。</p><h2 id="b61f" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #4。部署</strong></h2><p id="8e4e" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">这非常有效，每个部署都创建了Lambda的一个新版本。AWS允许保存每个Lambda的多个版本，并有指向版本的别名。通俗的别名有:<code class="eh mr ms mt mu b">test</code>、<code class="eh mr ms mt mu b">staging</code>、<code class="eh mr ms mt mu b">production</code>。因此，新的部署意味着上传Lambda的新版本，并将别名<code class="eh mr ms mt mu b">production</code>指向它。幸运的是，<code class="eh mr ms mt mu b">up</code>用<code class="eh mr ms mt mu b">up deploy production</code>自动做到了这一点。回滚只是将指针别名化为所需的版本。</p><h2 id="286a" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #5。本地测试/开发</strong></h2><p id="867e" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">因为我们使用的是常规的Node.js服务器，所以本地运行就意味着像往常一样运行您的服务器。然而，这并没有模仿AWS基础设施的所有重要差异，例如:实施相同的Node.js版本、API网关超时、Lambda超时、与其他AWS资源通信等等。<strong class="ji hv">不幸的是，最好的测试方式是在AWS基础设施本身上。</strong></p><h2 id="cabb" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #6。后台工作</strong></h2><p id="fe80" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">对于后台作业，如文件处理或与第三方API同步，我们保留了一组不属于API服务器的专用Lambda函数。这些作业被安排在<code class="eh mr ms mt mu b">CloudWatch</code>之前运行，或者作为对我们系统中事件的响应。</p><p id="97aa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">目前我们使用一个“兄弟”项目来处理这些后台任务——使用开源软件<code class="eh mr ms mt mu b"><a class="ae ke" href="https://github.com/apex/apex" rel="noopener ugc nofollow" target="_blank">apex/apex</a></code>。</p><p id="c003" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这些功能只在需要时运行，不需要让服务器一直运行来处理这些任务。无服务器方法的另一个胜利🚀</p><h2 id="8db4" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #7。记录日志</strong></h2><p id="d303" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">AWS服务带有内置的<code class="eh mr ms mt mu b">CloudWatch logs</code>服务，它有糟糕的用户界面、UX和DX。虽然<code class="eh mr ms mt mu b">up cli</code>有一个<code class="eh mr ms mt mu b">log</code>特性可以查看日志，但还有更多问题需要解决:警报、聚合日志等。</p><p id="95a6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的第一个解决方案是直接从API服务器记录到第三方记录服务(我们使用<a class="ae ke" href="https://papertrailapp.com" rel="noopener ugc nofollow" target="_blank"> papertrail </a>)，但是这保持了Lambda函数始终运行。</p><p id="fa24" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">一个更好的方法是将Lambda日志</strong>流式传输到一个专用的Lambda中，该Lambda负责将其发送给第三方日志服务。我们使用了更新版本的<a class="ae ke" href="https://github.com/apiaryio/cloudwatch-to-papertrail" rel="noopener ugc nofollow" target="_blank">云观察到文件线索</a>。我还建议流式传输API网关日志以获得完整的图片。</p><h2 id="2d26" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #8。环境变量和秘密</strong></h2><p id="c97e" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">不要将你的秘密提交给源代码控制。既然我们已经解决了这个问题，我们应该将它们加密存储在某个地方。AWS对此有一个确切的解决方案，它被称为<a class="ae ke" href="https://aws.amazon.com/ec2/systems-manager/parameter-store/" rel="noopener ugc nofollow" target="_blank"> AWS参数存储</a>。你添加你的参数，选择是否加密它们，然后选择谁可以读取这些秘密。我们将允许我们的Lambda函数一开始运行就读取这些秘密。由于Lambda函数被重用，这只会发生在Lambda的第一次调用(第一次API调用)。为了进行设置，我们添加了层次为<code class="eh mr ms mt mu b">/{env}/env_variable</code>的参数，例如<code class="eh mr ms mt mu b">/production/MYSQL_PASSWORD</code>。现在我们可以读取所有的<code class="eh mr ms mt mu b">/production</code>参数，并将它们用作环境变量，或者只是将它们存储在内存中。</p><h2 id="896a" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #9。性能和冷启动</strong></h2><p id="f7bc" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">当一个Lambda在一段时间内没有被调用时，它将被冻结，下一次调用将导致启动一个新的服务器实例的时间。这可能需要一些时间，取决于应用程序的复杂程度，有时在600毫秒到2000毫秒之间。除了(1)预热Lambda(使用监控服务定期调用它，或者使用CloudWatch进行另一次预定的Lambda调用)和(2)让Node.js应用程序加载更快，目前还没有真正的解决方案。希望AWS将来能找到减少冷启动时间的方法。</p><p id="e541" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您的API服务器必须符合SLA，那么此时无服务器可能不太合适😞</p><h2 id="8834" class="ly lb hu bd lc lz ma mb lg mc md me lk jr mf mg lo jv mh mi ls jz mj mk lw ml dt translated"><strong class="ak"> #10。没有并行请求</strong></h2><p id="e0ba" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在构建Node.js服务器时，我们习惯在事件循环和异步函数的帮助下处理多个请求。然而，当在AWS Lambda中运行时，每个Lambda容器将只处理一个请求。</p><p id="26cb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这意味着<strong class="ji hv">并行性是通过API网关</strong>产生多个Lambdas而不是一个Node.js应用服务多个请求来实现的。</p><p id="42a6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">测试你的应用和用例，看看这个模型是否合适。</p><h1 id="9c3c" class="la lb hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">结论</h1><p id="8143" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">无服务器是运营领域的一大进步吗？使用<strong class="ji hv"> devops </strong>时，我们希望了解操作是如何工作的，而使用无服务器时，我们受益于将操作责任委托给其他人(在这种情况下是AWS)，我们可以称之为<strong class="ji hv">无操作</strong>。虽然我们失去了灵活性，但我们获得了许多功能、轻松的心态和将精力集中在代码和产品上的能力。</p><p id="e2a8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">无服务器在未来几年肯定会占据主导地位，包括更具体的无服务器产品，如无服务器数据库、无服务器流媒体服务等。</p><p id="c1af" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于我们开发人员来说，这几乎是圣杯。<strong class="ji hv">建造它，运输它，它就能工作。</strong></p><blockquote class="kf kg kh"><p id="a170" class="jg jh ki ji b jj jk jl jm jn jo jp jq kj js jt ju kk jw jx jy kl ka kb kc kd hn dt translated">更多有趣的故事👩‍💻👨‍💻</p></blockquote><ul class=""><li id="49fc" class="km kn hu ji b jj jk jn jo jr ko jv kp jz kq kd mv ks kt ku dt translated"><a class="ae ke" rel="noopener" href="/hackernoon/the-non-secret-formula-for-writing-better-code-e41d1ff38682?source=friends_link&amp;sk=6e45e763cdea3b5ba360af94e270ec64">写出更好代码的非秘密公式</a></li><li id="9f5f" class="km kn hu ji b jj kv jn kw jr kx jv ky jz kz kd mv ks kt ku dt translated"><a class="ae ke" rel="noopener" href="/swlh/to-make-a-great-web-application-create-an-awesome-website-12c3d04802d5?source=friends_link&amp;sk=f2f19efa1ef340fcf13e6cdf8e295806">创建一个伟大的网络应用——创建一个令人敬畏的网站</a></li></ul></div></div>    
</body>
</html>