<html>
<head>
<title>How to take advantage of Local Storage in your React projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React项目中利用本地存储</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-take-advantage-of-local-storage-in-your-react-projects-a895f2b2d3f2?source=collection_archive---------0-----------------------#2018-04-22">https://medium.com/hackernoon/how-to-take-advantage-of-local-storage-in-your-react-projects-a895f2b2d3f2?source=collection_archive---------0-----------------------#2018-04-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="af55" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">以及为什么你应该这么做。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/b8c43fc25ac8e79ac2a3074fab13cc13.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*To2H39eauxaeYxYMtV1afQ.png"/></div></figure><p id="b968" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">本地存储</a>是现代网络浏览器自带的网络API。它允许网站/应用程序在浏览器中存储数据(简单和有限)，使这些数据在未来的浏览器会话中可用。</p><p id="3c39" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在深入本教程之前，可能不清楚为什么要在React应用程序中使用本地存储。</p><p id="022a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">有很多原因和用例，超出了我的想象，但这里是我发现的一些。</p><ul class=""><li id="8d42" class="ko kp hu jt b ju jv jx jy ka kq ke kr ki ks km kt ku kv kw dt translated"><strong class="jt hv">为你的前端React项目提供一个简单的、虚假的后端— </strong>给你的前端组合项目添加一个后端/数据库的外观通常是很好的。额外的功能将使你的应用更上一层楼，改善用户体验，给潜在雇主留下深刻印象。</li><li id="12f4" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km kt ku kv kw dt translated"><strong class="jt hv">在开发过程中尝试不同的状态— </strong>在开发应用程序时，应用程序拥有特定的<code class="eh lc ld le lf b">state</code>来处理特定的样式和功能通常是有用或必要的，(例如，样式化项目列表和移除项目<em class="lg">需要项目</em>)。本地存储可以保存应用程序的状态，而不是在每次刷新时重新创建应用程序的状态，这使得开发<strong class="jt hv"><em class="lg"/></strong>更加高效和愉快。</li><li id="797f" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km kt ku kv kw dt translated"><strong class="jt hv">跨会话保存表单数据— </strong>比起填写表单，人们更讨厌什么？<strong class="jt hv">填两次表！</strong></li></ul><p id="9c56" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">快速侧边栏:<em class="lg"> </em> </strong>我正在考虑做一个React dev工具(npm包和/或chrome扩展),通过保存旧的状态和一次点击就能恢复组件的状态，这很容易。目标是在开发时最大限度地减少手动重新创建应用程序状态所花费的时间。<strong class="jt hv">如果你也有同样的痛点，希望我构建解决方案，请留下评论或</strong> <a class="ae kn" href="https://ryanjyost.com" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hv">邮件我</strong> </a> <strong class="jt hv">！</strong></p><h1 id="4715" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">入门指南</h1><p id="9857" class="pw-post-body-paragraph jr js hu jt b ju lz iv jw jx ma iy jz ka mb kc kd ke mc kg kh ki md kk kl km hn dt translated">使用<a class="ae kn" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建一个新的React项目。</p><pre class="jk jl jm jn fq me lf mf mg aw mh dt"><span id="a851" class="mi li hu lf b fv mj mk l ml mm">npx create-react-app local-storage</span></pre><p id="0890" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><code class="eh lc ld le lf b">cd</code>进入新目录，启动应用程序。<a class="ae kn" href="https://www.npmjs.com/package/yarn" rel="noopener ugc nofollow" target="_blank">如果还没有安装纱线</a>。</p><pre class="jk jl jm jn fq me lf mf mg aw mh dt"><span id="b8da" class="mi li hu lf b fv mj mk l ml mm">yarn start</span></pre><p id="795d" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">用下面的代码更新你的<code class="eh lc ld le lf b">App.js</code>。在这里，我们设置了一个简单的待办事项应用程序。绝对没什么特别的，但是玩<code class="eh lc ld le lf b">localStorage</code>会很有趣。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="1d9a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">复制完这段代码后，您应该能够将待办事项添加到列表中并删除它们。</p><h1 id="5544" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">开始保存东西到本地存储</h1><p id="937a" class="pw-post-body-paragraph jr js hu jt b ju lz iv jw jx ma iy jz ka mb kc kd ke mc kg kh ki md kk kl km hn dt translated">将我们的<code class="eh lc ld le lf b">newItem</code>输入的值保存到<code class="eh lc ld le lf b">localStorage</code>是小菜一碟。</p><p id="e89c" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在<code class="eh lc ld le lf b">updateInput()</code>方法中，我们将调用<code class="eh lc ld le lf b"><a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem" rel="noopener ugc nofollow" target="_blank">localStorage.setItem()</a></code>方法，它有两个参数:</p><ul class=""><li id="c025" class="ko kp hu jt b ju jv jx jy ka kq ke kr ki ks km kt ku kv kw dt translated"><code class="eh lc ld le lf b">key: string</code> —本地存储项目的名称</li><li id="f7fd" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km kt ku kv kw dt translated"><code class="eh lc ld le lf b">value: string</code> —要为给定的本地存储器<code class="eh lc ld le lf b">key</code>保存的值。<strong class="jt hv">注意:</strong>即使是数组和对象也需要保存为字符串。<em class="lg">更详细一点。</em></li></ul><p id="d70d" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是我们新的<code class="eh lc ld le lf b">updateInput()</code>方法。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="701f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如你所见，和更新React <code class="eh lc ld le lf b">state</code>没太大区别。</p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><p id="1f70" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在你选择的浏览器中打开Web Developer tools，找到Web存储部分(Chrome中的“应用程序”选项卡)，选择当前域<code class="eh lc ld le lf b">localhost:3000</code>，观察<code class="eh lc ld le lf b">newItem</code>键的值与应用程序的输入保持同步。</p><h2 id="4584" class="mi li hu bd lj mw mx my ln mz na nb lr ka nc nd lt ke ne nf lv ki ng nh lx ni dt translated">现在，让我们保存待办事项列表</h2><p id="d24c" class="pw-post-body-paragraph jr js hu jt b ju lz iv jw jx ma iy jz ka mb kc kd ke mc kg kh ki md kk kl km hn dt translated">当添加一个条目时，我们将新的、更新的<code class="eh lc ld le lf b">list</code>保存到<code class="eh lc ld le lf b">localStorage</code>，并将<code class="eh lc ld le lf b">newItem</code>输入重置为空字符串。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="f7f9" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这里没有惊喜，除了<code class="eh lc ld le lf b"><a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="noopener ugc nofollow" target="_blank">JSON.stringify()</a></code>的使用。该方法将JavaScript值转换成JSON字符串。</p><p id="58e1" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">因为<code class="eh lc ld le lf b">localStorage</code>只能存储字符串，<strong class="jt hv">数组和对象需要先传入</strong> <code class="eh lc ld le lf b"><strong class="jt hv">JSON.stringify()</strong></code> <strong class="jt hv">，再传入</strong> <code class="eh lc ld le lf b"><strong class="jt hv">setItem()</strong></code> <strong class="jt hv">。</strong></p><p id="7771" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在继续之前，我们还想在删除一个项目时更新<code class="eh lc ld le lf b">localStorage</code>中的列表。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><h1 id="4efe" class="lh li hu bd lj lk nj lm ln lo nk lq lr ja nl jb lt jd nm je lv jg nn jh lx ly dt translated">喜欢这个教程？</h1><p id="3ca6" class="pw-post-body-paragraph jr js hu jt b ju lz iv jw jx ma iy jz ka mb kc kd ke mc kg kh ki md kk kl km hn dt translated"><a class="ae kn" href="https://tinyletter.com/ryanjyost" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hv">订阅约斯特的帖子简讯</strong> </a> <strong class="jt hv">获取更多。</strong></p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><h1 id="403b" class="lh li hu bd lj lk nj lm ln lo nk lq lr ja nl jb lt jd nm je lv jg nn jh lx ly dt translated">好的，我们在节约。但是请注意刷新页面时会发生什么…</h1><p id="b1bf" class="pw-post-body-paragraph jr js hu jt b ju lz iv jw jx ma iy jz ka mb kc kd ke mc kg kh ki md kk kl km hn dt translated">……<code class="eh lc ld le lf b">App</code>恢复到初始状态！我们还没有使用存储的项目，只是在后台保存它们。不是很有帮助…</p><p id="d826" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了即使在刷新页面后也能保持应用程序的<code class="eh lc ld le lf b">state</code>，我们需要借助几个新方法，用<code class="eh lc ld le lf b">localStorage</code>中的值来<em class="lg">融合</em>T2的状态:</p><ul class=""><li id="b917" class="ko kp hu jt b ju jv jx jy ka kq ke kr ki ks km kt ku kv kw dt translated"><code class="eh lc ld le lf b"><a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem" rel="noopener ugc nofollow" target="_blank">localStorage.getItem()</a></code> —获取一个存储<code class="eh lc ld le lf b">key</code>并返回保存在该键下的值。</li><li id="4c5c" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km kt ku kv kw dt translated"><code class="eh lc ld le lf b"><a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" rel="noopener ugc nofollow" target="_blank">JSON.parse()</a></code> —将JSON字符串转换为JavaScript值。您需要它来正确地检索作为字符串保存到<code class="eh lc ld le lf b">localStorage</code>的对象和数组。</li></ul><p id="d4db" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">下面的方法用保存到<code class="eh lc ld le lf b">localStorage</code>的值来混合应用程序的状态。将这个新方法添加到您的<code class="eh lc ld le lf b">App</code>组件中。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="1c34" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当页面加载时，即在<a class="ae kn" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">组件生命周期</a>的早期，水合<code class="eh lc ld le lf b">state</code>是有意义的。所以让我们在<code class="eh lc ld le lf b">componentDidMount()</code>中调用这个函数。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="defe" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">一旦你将上面的代码添加到你的<code class="eh lc ld le lf b">App</code>组件中，刷新页面不再重置应用程序，而是保持它与<code class="eh lc ld le lf b">localStorage</code>同步！</p><h1 id="5af4" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">持续储蓄是不必要的——有更好的方法。</h1><p id="c73a" class="pw-post-body-paragraph jr js hu jt b ju lz iv jw jx ma iy jz ka mb kc kd ke mc kg kh ki md kk kl km hn dt translated">虽然我们的应用程序通过在用户每次更新时保存React <code class="eh lc ld le lf b">state</code>到<code class="eh lc ld le lf b">localStorage</code>来工作，但我们并不需要如此频繁地保存。</p><p id="4399" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为什么？因为React会在用户的整个会话过程中跟踪应用程序的<code class="eh lc ld le lf b">state</code>——这就是它的用途！此外，对于更复杂的组件和状态，在更新<code class="eh lc ld le lf b">state</code>时使用<code class="eh lc ld le lf b">localStorage.setItem()</code>会非常麻烦和重复。</p><p id="6030" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">因此，我们不要继续保持<code class="eh lc ld le lf b">localStorage</code>与React <code class="eh lc ld le lf b">state</code>同步，只要用户结束他们的会话，无论是通过离开应用程序(“卸载”组件)还是刷新页面，我们都可以简单地将<code class="eh lc ld le lf b">state</code>保存到<code class="eh lc ld le lf b">localStorage</code>。</p><h2 id="8d54" class="mi li hu bd lj mw mx my ln mz na nb lr ka nc nd lt ke ne nf lv ki ng nh lx ni dt translated">事件/操作的新顺序将是…</h2><ol class=""><li id="3a9d" class="ko kp hu jt b ju lz jx ma ka no ke np ki nq km nr ku kv kw dt translated">用户访问应用程序(在我们的例子中是localhost:3000)</li><li id="e20d" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km nr ku kv kw dt translated">组件<code class="eh lc ld le lf b">App</code>使用任何适用的<code class="eh lc ld le lf b">localStorage</code>值安装并水合其<code class="eh lc ld le lf b">state</code>。</li><li id="afd5" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km nr ku kv kw dt translated">React将在整个用户会话期间更新<code class="eh lc ld le lf b">state</code>。<code class="eh lc ld le lf b"><em class="lg">localStorage</em></code> <em class="lg">不会改变。</em></li><li id="6993" class="ko kp hu jt b ju kx jx ky ka kz ke la ki lb km nr ku kv kw dt translated">当用户结束他们的会话时，将当时的<code class="eh lc ld le lf b">state</code>保存到<code class="eh lc ld le lf b">localStorage</code>，使其可用于下一个会话的补水。</li></ol></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><p id="ab5c" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">好的，这里有一个新的方法可以一次保存所有的<code class="eh lc ld le lf b">state</code>到<code class="eh lc ld le lf b">localStorage</code>。将它添加到您的<code class="eh lc ld le lf b">App</code>组件中。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="fd28" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了在用户离开app时保存<code class="eh lc ld le lf b">state</code>到<code class="eh lc ld le lf b">localStorage</code>，我们需要调用<code class="eh lc ld le lf b">componentWillUnmount</code>中的<code class="eh lc ld le lf b">saveStateToLocalStorage</code>方法。</p><p id="67ac" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">警告— </strong> <code class="eh lc ld le lf b"><strong class="jt hv">componentWillUnmount</strong></code> <strong class="jt hv">在用户刷新或离开页面时不会触发，所以我们需要利用</strong> <code class="eh lc ld le lf b"><a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload" rel="noopener ugc nofollow" target="_blank"><strong class="jt hv">window.onbeforeunload</strong></a></code> <strong class="jt hv">事件来保存到</strong> <code class="eh lc ld le lf b"><strong class="jt hv">localStorage</strong></code> <strong class="jt hv">。</strong> <a class="ae kn" href="https://stackoverflow.com/questions/39084924/componentwillunmount-not-being-called-when-refreshing-the-current-page" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hv">在此了解更多。</strong> </a></p><p id="8db8" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这里有一些更新的代码，我们将事件监听器添加到<code class="eh lc ld le lf b">componentDidMount</code>，并将我们需要的添加到<code class="eh lc ld le lf b">componentWillUnmount</code>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="635f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当更新React <code class="eh lc ld le lf b">state</code>时，我们不再需要<code class="eh lc ld le lf b">setItem</code>，所以你需要删除它们。</p><p id="4302" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">自从本教程开始以来，已经发生了很多变化，所以这里是<code class="eh lc ld le lf b">App.js</code>文件。*<em class="lg"/><code class="eh lc ld le lf b"><em class="lg">render()</em></code><em class="lg">中的方法没有任何改变。* </em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="3f1d" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">就是这样！现在，您已经拥有了在React项目中使用本地存储的工具。</p><h1 id="5eba" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">反应简单存储——一个几乎无耻的插头</h1><div class="ns nt fm fo nu nv"><a href="https://www.npmjs.com/package/react-simple-storage" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab ej"><div class="nx ab ny cl cj nz"><h2 class="bd hv fv z el oa eo ep ob er et ht dt translated">反应-简单-存储</h2><div class="oc l"><h3 class="bd b fv z el oa eo ep ob er et ek translated">将localStorage与React一起使用的简单组件和助手函数。</h3></div><div class="od l"><p class="bd b gc z el oa eo ep ob er et ek translated">www.npmjs.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jp nv"/></div></div></a></div><p id="12ad" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我发现自己在工作中想要利用大量不同组件的本地存储，所以我创建了一个组件，<a class="ae kn" href="https://github.com/ryanjyost/react-simple-storage" rel="noopener ugc nofollow" target="_blank"><strong class="jt hv">react-simple-Storage</strong></a>，它可以处理我们刚刚实现的所有内容以及更多内容。请继续关注我们的小应用程序，看看它有多简单。</p><h2 id="74c9" class="mi li hu bd lj mw mx my ln mz na nb lr ka nc nd lt ke ne nf lv ki ng nh lx ni dt translated">1.安装它</h2><pre class="jk jl jm jn fq me lf mf mg aw mh dt"><span id="10a7" class="mi li hu lf b fv mj mk l ml mm">yarn add react-simple-storage</span></pre><h2 id="4d4f" class="mi li hu bd lj mw mx my ln mz na nb lr ka nc nd lt ke ne nf lv ki ng nh lx ni dt translated">2.将其导入App.js</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><h2 id="bdc0" class="mi li hu bd lj mw mx my ln mz na nb lr ka nc nd lt ke ne nf lv ki ng nh lx ni dt translated">3.将它包含在您的<app>组件中，就像这样…</app></h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="83a7" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">就是这样！</strong>你<strong class="jt hv"> </strong>不需要教程中所有的额外方法和事件监听器，所以最后的<code class="eh lc ld le lf b">App.js</code>使用<a class="ae kn" href="https://github.com/ryanjyost/react-simple-storage" rel="noopener ugc nofollow" target="_blank"> react-simple-storage </a>看起来像这样…</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn mo l"/></div></figure><div class="ns nt fm fo nu nv"><a href="https://github.com/ryanjyost/react-simple-storage" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab ej"><div class="nx ab ny cl cj nz"><h2 class="bd hv fv z el oa eo ep ob er et ht dt translated">ryanjyost/react-简单-存储</h2><div class="oc l"><h3 class="bd b fv z el oa eo ep ob er et ek translated">React-Simple-storage——React中使用localStorage的简单组件和辅助函数。</h3></div><div class="od l"><p class="bd b gc z el oa eo ep ob er et ek translated">github.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj jp nv"/></div></div></a></div><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ol mo l"/></div></figure></div></div>    
</body>
</html>