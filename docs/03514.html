<html>
<head>
<title>Configuring .gitlab-ci.yml with AWS EC2 for Continuous Integration (CI) or Continuous Deplyment (CD)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正在配置。gitlab-ci.yml，带AWS EC2，用于持续集成(ci)或持续部署(CD)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/configuring-gitlab-ci-yml-150a98e9765d?source=collection_archive---------0-----------------------#2018-04-23">https://medium.com/hackernoon/configuring-gitlab-ci-yml-150a98e9765d?source=collection_archive---------0-----------------------#2018-04-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="06d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这原本是一个完整的帖子，但是它变得太大了，以至于我不得不把它分成2篇！上接文章#2，<a class="ae jp" rel="noopener" href="/@josjaviasilis/configuring-gitlab-ci-on-aws-ec2-using-docker-7c359d513a46">使用Docker在AWS EC2上配置GitLab CI。</a></p><p id="5b72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">帖子:</strong></p><ol class=""><li id="498d" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><a class="ae jp" rel="noopener" href="/@josjaviasilis/tutorial-guide-installing-gitlab-gitlab-ci-on-aws-ec2-from-zero-751927e5ae5">【教程—指南】从零开始在AWS EC2上安装GitLab，GitLab CI。</a></li><li id="b94e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" rel="noopener" href="/@josjaviasilis/configuring-gitlab-ci-on-aws-ec2-using-docker-7c359d513a46">使用Docker </a>在AWS EC2上配置GitLab CI</li><li id="6e92" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" rel="noopener" href="/@josjaviasilis/configuring-gitlab-ci-yml-150a98e9765d">正在配置。gitlab-ci.yml </a>(本帖)</li><li id="f28b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><a class="ae jp" rel="noopener" href="/@josjaviasilis/troubleshooting-gitlab-and-gitlab-ci-79d3b71ad79f">git lab和GitLab CI故障排除</a></li></ol><h1 id="109e" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#1-了解。gitlab-ci.yml文件</h1><p id="ebe1" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated"><code class="eh lh li lj lk b">.gitlab-ci.yml</code>文件是一个<a class="ae jp" href="https://en.wikipedia.org/wiki/YAML" rel="noopener ugc nofollow" target="_blank"> YAML </a>文件，它是<strong class="it hv">在<strong class="it hv">项目的根目录下创建的</strong>。</strong>每当您向服务器推送提交时，该文件会自动运行<strong class="it hv">。这将向您在#3中指定的运行者触发一个通知，然后它处理您指定的一系列任务。所以如果你推它3次，它就会跑3次！这就是为什么如果你推多个，你要么想要一个更快的转轮，或每台机器一个单独的转轮。</strong></p><p id="5ae3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，由于我们使用的是<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>，任务总是在一个干净的映像状态下开始。这意味着您在。gitlab-ci.yml，将在您每次向服务器推送提交时恢复。您可以通过指定缓存来避免这种情况。</p><p id="03cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">文件的内容由你可以在他的页面中找到的关键字组成。你不需要遵循什么顺序，但是要非常小心压痕。这可能会决定你项目的成败。你可以在推之前用在线YAML棉绒器检查一下它是否工作。</p><p id="19e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将开发一个示例<a class="ae jp" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>应用程序。以卡玛为试跑者。我已经在<a class="ae jp" href="https://gist.github.com/superjose/709989dd58aa90bfeda75767668482b2" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">这个GitHub Gist </strong> </a> <strong class="it hv">里贴了一个我过去一个项目里用过的. gitlab-ci.yml。</strong>(请看！)</p><p id="dfe5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.exclamationlabs.com/blog/continuous-deployment-to-npm-using-gitlab-ci/" rel="noopener ugc nofollow" target="_blank">本页</a>可以给你另一个视角。</p><p id="9d64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">分解一下:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="43cd" class="lt kf hu lk b fv lu lv l lw lx">image: node:9.4.0</span></pre><p id="a9eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图像键从<a class="ae jp" href="http://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker Hub，</a>获取图像，并将其用作基础图像。GitLab将根据这张图片进行所有的测试。如果你在用Ruby、Java、Go、PHP等语言做一个项目。从Docker中心指定正确的图像。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="fe74" class="lt kf hu lk b fv lu lv l lw lx">cache:<br/>  paths:<br/>    - node_modules/<br/>    - .yarn</span></pre><p id="b794" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将创建一个临时缓存文件夹，防止在每次CI运行时(每次提交时)重新创建<code class="eh lh li lj lk b">node_modules</code>和<code class="eh lh li lj lk b">.yarn </code>。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="6ea6" class="lt kf hu lk b fv lu lv l lw lx">before_script:<br/>   - apt-get update -qq &amp;&amp; apt-get install<br/>   - another-command that will run after the one above<br/>   - you can keep adding lines and lines.</span></pre><p id="f85b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj lk b">before_script</code>告诉GitLab先运行你指定的任何东西。您可以将此视为准备脚本。</p><h1 id="668c" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#1.1理解阶段</h1><p id="c694" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">阶段是代码为了到达最终目的地(生产)而经历的一系列步骤。GitLab允许你用任何名字定义任何数量的阶段。你可以通过在stage键下指定它来实现，i <strong class="it hv"> n你希望它们运行的顺序</strong>。</p><p id="83ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，GitLab将一步一步地运行它们。如果其中一个失败，它会阻止后面的运行。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="9557" class="lt kf hu lk b fv lu lv l lw lx">stages:<br/>  - build<br/>  - test<br/>  - staging<br/>  - openMr<br/>  - production</span></pre><p id="dafb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的部分中，它将首先运行<code class="eh lh li lj lk b">build </code>阶段，一直到<code class="eh lh li lj lk b">production</code>。</p><h1 id="4616" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#1.2在中定义阶段的行动。gitlab-ci.yml文件</h1><p id="54bf" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">通过首先指定阶段名父键，可以定义阶段将要运行的内容。这个键<strong class="it hv">可以随意命名，可以包含空格</strong>。</p><p id="abce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="fed5" class="lt kf hu lk b fv lu lv l lw lx">Build My App:<br/>  stage: build<br/>  tags:<br/>   #- you_would_put_your_tag_in_here<br/>   #- node<br/>  before_script:<br/>   - yarn config set cache-folder .yarn<br/>   - yarn install<br/>  script:<br/>    - npm run build</span></pre><p id="d024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">阶段名称是<code class="eh lh li lj lk b">Build My App</code>，它指定了一个名为<code class="eh lh li lj lk b">stage </code>的键，该键引用您之前在阶段列表中创建的阶段。</p><p id="7dc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">before_script与我们之前指定的脚本运行相同，只是在<code class="eh lh li lj lk b">build</code>阶段的上下文中:在这些脚本执行之前，什么都不会运行。</p><p id="9186" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，我们使用<a class="ae jp" href="https://yarnpkg.com/en/" rel="noopener ugc nofollow" target="_blank"> yarn </a> insead of <a class="ae jp" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>，它创建一个包含所有yarn配置的缓存文件夹，不会在每个项目运行时重新创建(每次推送至repo)</p><h1 id="9cd9" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#1.3标签</h1><p id="da86" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">如果你遵循了我写的关于“标签”的前一篇文章(<a class="ae jp" href="https://hackernoon.com/configuring-gitlab-ci-on-aws-ec2-using-docker-7c359d513a46#5d25" rel="noopener ugc nofollow" target="_blank">第3.1点，来自第2篇文章</a>)，这是我们指定它们的地方！如果标签与我们在runner中指定的标签相匹配，那么一旦完成就会触发runner。您可以在自己的行中指定每个标记。如果你参考上面的例子，如果你删除了<code class="eh lh li lj lk b">node</code>前的<code class="eh lh li lj lk b">#</code>，这意味着，那个特定的阶段将只在带有节点标签的流道上工作。如果您没有指定标签(省略<code class="eh lh li lj lk b">tags</code>键)，您可以连接到运行器(只要它没有锁定到当前项目)。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="de3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注:5.4–5.6是文件各部分的略述。我将更详细地解释#7中的内容为什么、如何以及是什么。</strong></p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h1 id="8dbb" class="ke kf hu bd kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb dt translated">#1.4测试环境</h1><p id="c82b" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">再说一次，你如何命名你的舞台并不重要。在这种情况下，我只是称之为“测试”来测试。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="399a" class="lt kf hu lk b fv lu lv l lw lx">Test:<br/>  stage: test<br/>  before_script:<br/>    - yarn config set cache-folder .yarn<br/>    - yarn install<br/>  script:<br/>  # Installs Chrome<br/>    - wget -q -O — <a class="ae jp" href="https://dl-ssl.google.com/linux/linux_signing_key.pub" rel="noopener ugc nofollow" target="_blank">https://dl-ssl.google.com/linux/linux_signing_key.pub</a> | apt-key add - <br/>    - echo ‘deb [arch=amd64] <a class="ae jp" href="http://dl.google.com/linux/chrome/deb/" rel="noopener ugc nofollow" target="_blank">http://dl.google.com/linux/chrome/deb/</a> stable main’ | tee /etc/apt/sources.list.d/google-chrome.list<br/>    - apt-get update<br/>    - apt-get install google-chrome-stable -y<br/>    # Runs the tests.<br/>    - npm run test:karma-headless</span></pre><p id="7381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那里有很多东西。持续集成方法依赖于您在本地机器上运行的测试。这些测试伴随着在您将要部署的实际机器上运行它们。</p><p id="d69a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于这是特定于Node和JavaScript的(我的项目是由什么组成的)，所以我需要准备字段，以便它们可以完美地运行。在这种情况下，我使用karma作为测试运行程序来运行我所有的本地测试。它需要一个本地网络浏览器，在这种情况下，谷歌浏览器。</p><p id="6d4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我需要发出一个Google Chrome的安装命令(记住每次我们推送时，一切都是从干净的状态开始)，并运行测试。</p><p id="60d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果所有测试成功，GitLab将自动进行到下一部分。</p><h1 id="61c6" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#1.5打开合并请求</h1><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="d504" class="lt kf hu lk b fv lu lv l lw lx"># Remember to have the PRIVATE_TOKEN generated. This is only needed to be done once per project and not per user.<br/># Once you add it (Needs Master privileges) as a Secret Variable, it should work.</span><span id="7118" class="lt kf hu lk b fv mk lv l lw lx">Open Merge Request:<br/># Got it from here: <a class="ae jp" href="https://gitlab.com/tmaier/gitlab-auto-merge-request/blob/develop/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/tmaier/gitlab-auto-merge-request/blob/develop/.gitlab-ci.yml</a><br/>  image: tmaier/gitlab-auto-merge-request<br/>  stage: openMr<br/>  script:<br/>    - bash ./gitlab-deploy/auto-merge-request.sh # The name of the script</span></pre><p id="92c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的测试环境成功之后，我们希望GitLab自动打开一个合并请求，如果它通过，我们可以成功地合并到master。</p><h1 id="1b69" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"># 1.6试运行和生产环境</h1><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="1cc8" class="lt kf hu lk b fv lu lv l lw lx">Deploy to Staging:<br/>  stage: staging<br/>  before_script:<br/>   # Generates to connect to the AWS unit the SSH key.<br/>   - mkdir -p ~/.ssh<br/>   - echo -e “$SSH_PRIVATE_KEY” &gt; ~/.ssh/id_rsa<br/>   # Sets the permission to 600 to prevent a problem with AWS<br/>   # that it’s too unprotected.<br/>   - chmod 600 ~/.ssh/id_rsa<br/>   - ‘[[ -f /.dockerenv ]] &amp;&amp; echo -e “Host *\n\tStrictHostKeyChecking no\n\n” &gt; ~/.ssh/config’</span><span id="b893" class="lt kf hu lk b fv mk lv l lw lx">script:<br/>     - bash ./gitlab-deploy/.gitlab-deploy.staging.sh<br/>  environment:<br/>    name: staging<br/>  # Exposes a button that when clicked take you to the defined URL:<br/>    url: <a class="ae jp" href="http://ec2-13-59-173-91.us-east-2.compute.amazonaws.com:3001" rel="noopener ugc nofollow" target="_blank">http://ec2-11-44-514-91.us-east-2.compute.amazonaws.com:3001</a></span><span id="b927" class="lt kf hu lk b fv mk lv l lw lx">Deploy to Production:<br/>  stage: production<br/>  before_script:<br/>  # Generates to connect to the AWS unit the SSH key.<br/>    - mkdir -p ~/.ssh<br/>    - echo -e "$SSH_PRIVATE_KEY" &gt; ~/.ssh/id_rsa<br/>  # Sets the permission to 600 to prevent a problem with AWS<br/>  # that it's too unprotected<br/>    - chmod 600  ~/.ssh/id_rsa<br/>    - '[[ -f /.dockerenv ]] &amp;&amp; echo -e "Host *\n\tStrictHostKeyChecking no\n\n" &gt; ~/.ssh/config'<br/>   script:<br/>    - bash ./gitlab-deploy/.gitlab-deploy.prod.sh<br/>   environment:<br/>     name: production<br/>     # Exposes a button that when clicked take you to the defined URL:<br/>     url: <a class="ae jp" href="http://ec2-13-59-173-91.us-east-2.compute.amazonaws.com:81" rel="noopener ugc nofollow" target="_blank">http://ec2-13-59-173-91.us-east-2.compute.amazonaws.com:81</a></span><span id="2aa7" class="lt kf hu lk b fv mk lv l lw lx">when: manual</span></pre><p id="4d4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这方面的内容我会在下面讲。</p><h1 id="0917" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#2管道</h1><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/d9c8e56d0e632ea524e84fb335b04ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDqCEpC43cSQndI2uGn9tA.png"/></div></div></figure><p id="ea58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您将带有<code class="eh lh li lj lk b">.gitlab-ci.yml</code>文件的git repo推送到GitLab时，它将自动触发管道。管道是您在<code class="eh lh li lj lk b">.gitlab-ci.yml.</code>中定义的阶段。在我们的例子中，我们有构建、测试、试运行、openMr和生产。你在上面截图中看到的每一个标记都代表了每一个阶段。一个红叉将代表一个失败的阶段。绿色勾号表示测试成功通过。斜线表示测试已被取消。</p><p id="bb7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以看到一个命令行界面，它向你展示了开发的每一个阶段，点击图标，然后点击弹出:</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff mt"><img src="../Images/89c78988329b22dfac9b86c70d461264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyFPSaggtRtuMR0K-sv9pQ.png"/></div></div></figure><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/91fac5c1825ea1f34a773979022215e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhK2n7ESrVYMzEZoSimC5g.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">This is the screen that it shows you after the build stage has been successfully completed.</figcaption></figure><h1 id="d2c8" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak"> #3-整合到AWS。如何用您的项目将GitLab实例连接到EC2实例</strong></h1><p id="99d9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">最大的挑战之一是将CI渠道与您的项目集成。<strong class="it hv">据我所知<em class="my"/></strong>，GitLab并没有提供一种本地方式来做到这一点。您可以将您的代码推送到<a class="ae jp" href="https://aws.amazon.com/codedeploy/" rel="noopener ugc nofollow" target="_blank"> AWS代码部署</a>，然后通过那里进行迁移。</p><p id="297d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">stackoverflow的autronix提供了一个奇妙的<a class="ae jp" href="https://stackoverflow.com/a/38672045/1057052" rel="noopener ugc nofollow" target="_blank">逐步指南</a>来指导您完成这个过程:</p><div class="mz na fm fo nb nc"><a href="https://stackoverflow.com/a/38672045/1057052" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">如何使用AWS CodeDeploy/CodePipeline/S3将Gitlab-Ci部署到EC2</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">我已经创建了一组示例文件来配合下面提供的指南。</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">stackoverflow.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq mr nc"/></div></div></a></div><p id="c9e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我推荐上面的方法，而不是我将要向您展示的方法</strong>。如果autronix 的方法不起作用，请执行以下操作。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="b6d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种集成传达了利用git(我们从GitLab中提取合并的存储库)并在EC2实例中就地升级它，我们从npm中执行重新加载脚本(我们假设在这个项目中使用Node)并发布更改。到目前为止，您可能会看到，这看起来更像是一个黑客，而不是一个实际的解决方案。这个<strong class="it hv">在高度分布式的环境中可能不起作用</strong>，在这种环境中，您需要跨多个EC2实例复制代码库。但同样，这是关于有选择，对不对？</p><h1 id="31e2" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#4 —准备托管已部署代码的EC2机器。</h1><p id="64f6" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">这种方法是受<a class="ae jp" rel="noopener" href="/@lucabecchetti/autodeploy-from-gitlab-to-multiple-aws-ec2-instances-a43448727c5a">这篇文章</a>的启发。</p><p id="d2e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将EC2机器(生产中托管代码的机器)视为GitLab客户端。我们创建一个连接到GitLab的SSH密钥，并从那里提取代码。</p><p id="0bce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你记得，从第一个教程:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="e7de" class="lt kf hu lk b fv lu lv l lw lx">ssh-keygen -t rsa -C “your_name@your_email.com”<br/>ssh-add ~/.ssh/id_rsa</span></pre><p id="00e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您在添加密钥时遇到了问题，请尝试首先执行以下命令(<a class="ae jp" href="https://stackoverflow.com/questions/17846529/could-not-open-a-connection-to-your-authentication-agent" rel="noopener ugc nofollow" target="_blank"> Source </a>):</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="de41" class="lt kf hu lk b fv lu lv l lw lx">eval `ssh-agent -s`<br/>ssh-add ~/.ssh/id_rsa</span></pre><p id="698a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于这种方法的一个问题是，我还没有找到一种方法使它与密码一起工作，所以当它问你这个问题时，<strong class="it hv">让它空白</strong>！</p><p id="9d05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建密钥时，它位于以下位置:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="849c" class="lt kf hu lk b fv lu lv l lw lx">~/.ssh/id_rsa.pub</span></pre><p id="f667" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这一次您将无法复制到剪贴板的内容，除非您安装“剪辑”</p><p id="45a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:这将占用300多MB的磁盘空间。除非不受磁盘空间的限制，否则不要这样做。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="22bd" class="lt kf hu lk b fv lu lv l lw lx">sudo apt-get install clip</span><span id="e105" class="lt kf hu lk b fv mk lv l lw lx">cat ~/.ssh/id_rsa.pub | clip</span></pre><p id="3295" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种选择是执行cat，并复制命令的输出。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="d037" class="lt kf hu lk b fv lu lv l lw lx">cat ~/.ssh/id_rsa.pub</span></pre><p id="0319" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了控制潜在的安全风险，我建议您在GitLab中创建一个单独的用户，该用户只处理回购的拉取，不处理其他任何事情。您将公钥附加到该帐户。</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff nr"><img src="../Images/5793d3856ea7315842f895e468aa4f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gixcAy7CfqSTGIuz6eDEdg.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">I created a ghost user in GitLab that handles the pull from GitLab.</figcaption></figure><p id="f3d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请访问GitLab地址上的/admin。(您也可以单击导航栏上的工具图标)</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ns"><img src="../Images/5574176e86a842c1ae0efc0d9180c1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cjecn110Zo8QPTJ7lHOrqA.png"/></div></div></figure><p id="28b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建新用户:</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/77fe21db2c5ac5235eedd3da2ccb3b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C0I8aI3zKhWBEbSPdRANmQ.png"/></div></div></figure><p id="da8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">取消选中“可以创建组”。访问级别“常规”，外部“已检查”。</p><p id="b0c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">转到您有回购的项目:</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/fd26ae36a2d8065ef0e7335b414ad34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlUWXwO7Bh3S1_AvbycYow.png"/></div></div></figure><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/5a259bee469f3e95874125033bdf1eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iysHuhXZ4RPzHbVUmLpP2w.png"/></div></div></figure><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff nt"><img src="../Images/9f128fb2e72a8b20cd57c7727aa60ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtrS1p_e-PRWbrjcnBeOsA.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Search the new member you created and set it as a Reporter.</figcaption></figure><p id="c816" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">导航到管理区域中的用户选项卡，并单击最近创建的用户的名称:</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/da9a84ee31ebd367397652eba6b54ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBk4TYGPb-7DJNyPcEflNw.png"/></div></div></figure><p id="9044" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">单击“模拟”，并转到ssh密钥页面。</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/06e346eef351c6cba427b8e16247d090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HkQTiigkw6XKxRU94y0E7Q.png"/></div></div></figure><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/d7371ff524bf2e2a103fc0a785a9624d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSkYoUe_g3bKZSX0FhMbuQ.png"/></div></div></figure><h1 id="b627" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#5-暂存环境，配置:</h1><p id="6d98" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">这是我开始解释我在上面写的到底是什么的地方。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="2c9f" class="lt kf hu lk b fv lu lv l lw lx">Deploy to Staging:<br/>  stage: staging<br/>  before_script:<br/>    # Generates to connect to the AWS unit the SSH key.<br/>    - mkdir -p ~/.ssh<br/>    - echo -e “$SSH_PRIVATE_KEY” &gt; ~/.ssh/id_rsa<br/>    # Sets the permission to 600 to prevent a problem with AWS<br/>    # that it’s too unprotected.<br/>    - chmod 600 ~/.ssh/id_rsa<br/>    - ‘[[ -f /.dockerenv ]] &amp;&amp; echo -e “Host *\n\tStrictHostKeyChecking no\n\n” &gt; ~/.ssh/config’</span><span id="e694" class="lt kf hu lk b fv mk lv l lw lx">  script:<br/>    - bash ./gitlab-deploy/.gitlab-deploy.staging.sh</span><span id="2358" class="lt kf hu lk b fv mk lv l lw lx">  environment:<br/>    name: staging<br/>    # Exposes a button that when clicked take you to the defined URL:<br/>     url: <a class="ae jp" href="http://ec2-13-59-173-91.us-east-2.compute.amazonaws.com:3001" rel="noopener ugc nofollow" target="_blank">http://ec2-13-14-444-91.us-east-2.compute.amazonaws.com:3001</a></span></pre><h1 id="a0a7" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#5.1-与EC2实例通信。</h1><p id="5d96" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我们需要一种与自动气象站沟通的方式。我们这样做的方法是抓住<strong class="it hv">私有</strong>密钥(小心！敏感信息)并将其与预定义的shell脚本一起发送(稍后我将详细介绍)。</p><p id="656f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">before_script中的代码所做的是生成一个名为id_rsa的空白文件(它符合私钥的约定)。每次项目运行时，我们用一个定制变量(现在将详细介绍)填充它。</p><p id="2daf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GitLab CI允许您在项目的设置中存储变量:</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/949d2274cf97566ccdadf3464dd92409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W925SJvEV1H4Vm9QWmd3lw.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Go to Your Project -&gt; Settings -&gt; CI/CD -&gt; Secret Variables</figcaption></figure><p id="39c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们要做的是从id_rsa(私钥，没有的那个)中抓取内容。pub ),我们将复制并粘贴它的内容。</p><p id="e90f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们执行与公共文件相同的过程(注意这是无扩展名的id_rsa):</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="4b32" class="lt kf hu lk b fv lu lv l lw lx">cat ~/.ssh/id_rsa | clip</span></pre><p id="048b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，如果您没有安装clip，请从控制台复制并粘贴它:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="e089" class="lt kf hu lk b fv lu lv l lw lx">cat ~/.ssh/id_rsa</span></pre><p id="9963" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将把这个值复制粘贴到“秘密变量”表单中，并给它一个“SSH_PRIVATE_KEY”(这与<code class="eh lh li lj lk b">.gitlab-ci.yml</code>中的值相匹配，你可以在上图中看到)</p><p id="4feb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你有了它，点击“保存变量”。</p><h1 id="2e91" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#5.2-为暂存环境创建一个Shell脚本</h1><p id="3d62" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我们仍然需要指示GitLab在我们的EC2环境中执行pull请求。</p><p id="2fca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了分离关注点和可维护性，我们可以指定一个外部shell文件，它将从主分支执行pull。我们把这个文件叫做<code class="eh lh li lj lk b">.gitlab-deploy.staging.sh </code>你可以把这个文件叫做你想要的任何东西。只要记得在<code class="eh lh li lj lk b">.gitlab-ci.yml</code>文件中指定就行了。</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/c8ce98d1bb2bca7bff0ea894f9c46b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*ZMIYdjkyMfXpJPirgD_JpQ.png"/></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">This is how I have my project structured.</figcaption></figure><p id="b976" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj lk b">.gitlab-ci.yml </code>是在根。而shell文件在一个名为<code class="eh lh li lj lk b">gitlab-deploy</code>的文件夹下。因此我们称他们为<code class="eh lh li lj lk b">./gitlab-deploy/.gitlab-deploy.staging.sh</code>。</p><p id="abe7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该文件的内容如下:</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="0392" class="lt kf hu lk b fv lu lv l lw lx"># !/bin/bash</span><span id="6681" class="lt kf hu lk b fv mk lv l lw lx"># Get servers list:<br/>set — f</span><span id="57ef" class="lt kf hu lk b fv mk lv l lw lx"># Variables from GitLab server:<br/># Note: They can’t have spaces!!<br/>string=$DEPLOY_SERVER<br/>array=(${string//,/ })<br/># Iterate servers for deploy and pull last commit<br/># Careful with the ; <a class="ae jp" href="https://stackoverflow.com/a/20666248/1057052" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/20666248/1057052</a><br/>for i in “${!array[@]}”; do<br/>  echo “Deploy project on server ${array[i]}”<br/>ssh ubuntu@${array[i]} “cd ./Staging/vr &amp;&amp; git stash &amp;&amp; git checkout $CI_BUILD_REF_NAME &amp;&amp; git stash &amp;&amp; git pull &amp;&amp; sudo yarn install &amp;&amp; sudo npm run staging”</span><span id="5a7d" class="lt kf hu lk b fv mk lv l lw lx">done</span></pre><p id="998a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，我们在这里所做的是执行git拉取，并在暂存服务器中安装软件包。</p><p id="9a6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很便宜，我在同一个服务器上运行生产和测试(我暴露了不同的端口)。我建议你为此使用不同的机器。</p><p id="15c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj lk b">$DEPLOY_SERVER</code>变量是我们在secrets变量页面中用EC2实例的IPv4地址创建的另一个定制变量:</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/949d2274cf97566ccdadf3464dd92409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W925SJvEV1H4Vm9QWmd3lw.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Go to Your Project -&gt; Settings -&gt; CI/CD -&gt; Secret Variables</figcaption></figure><p id="3557" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">指定名称和url的环境关键字“只是为了显示”。这将在控制台的stage中显示一个按钮，该按钮将指向您在那里指定的URL。这是可选的，可以省略。</p><h1 id="a61b" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#6自动打开合并请求</h1><p id="d0d4" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">GitLab不会自动打开合并请求。这就是为什么我们必须自己做一些工作来让它工作。</p><p id="6805" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是通过GitHub的tmaier的<a class="ae jp" href="https://github.com/tmaier/gitlab-auto-merge-request" rel="noopener ugc nofollow" target="_blank"> Docker图像完成的</a></p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="479c" class="lt kf hu lk b fv lu lv l lw lx"># Remember to have the PRIVATE_TOKEN generated. This is only needed to be done once per project and not per user.<br/># Once you add it (Needs Master privileges) as a Secret Variable, it should work.</span><span id="316c" class="lt kf hu lk b fv mk lv l lw lx">Open Merge Request:<br/># Got it from here: <a class="ae jp" href="https://gitlab.com/tmaier/gitlab-auto-merge-request/blob/develop/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/tmaier/gitlab-auto-merge-request/blob/develop/.gitlab-ci.yml</a><br/>  image: tmaier/gitlab-auto-merge-request<br/>  stage: openMr<br/>  script:<br/>    - bash ./gitlab-deploy/auto-merge-request.sh # The name of the script</span></pre><p id="6289" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是<code class="eh lh li lj lk b">auto-merge-request.sh</code>文件</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="1590" class="lt kf hu lk b fv lu lv l lw lx">#!/usr/bin/env bash<br/>set -e</span><span id="aa86" class="lt kf hu lk b fv mk lv l lw lx"># Gotten from:<br/># <a class="ae jp" href="https://about.gitlab.com/2017/09/05/how-to-automatically-create-a-new-mr-on-gitlab-with-gitlab-ci/" rel="noopener ugc nofollow" target="_blank">https://about.gitlab.com/2017/09/05/how-to-automatically-create-a-new-mr-on-gitlab-with-gitlab-ci/</a><br/># This shall automatically create a merge request right after the build has been pushed.<br/># Added some touches from: <a class="ae jp" href="https://gitlab.com/tmaier/gitlab-auto-merge-request/blob/develop/merge-request.sh" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/tmaier/gitlab-auto-merge-request/blob/develop/merge-request.sh</a></span><span id="5866" class="lt kf hu lk b fv mk lv l lw lx">if [ -z “$PRIVATE_TOKEN” ]; then<br/> echo “PRIVATE_TOKEN not set”<br/> echo “Please set the GitLab Private Token as PRIVATE_TOKEN”<br/> exit 1<br/>fi</span><span id="f6ed" class="lt kf hu lk b fv mk lv l lw lx"># Extract the host where the server is running, and add the URL to the APIs<br/>[[ $CI_PROJECT_URL =~ ^https?://[^/]+ ]] &amp;&amp; HOST=”${BASH_REMATCH[0]}/api/v4/projects/”</span><span id="0d45" class="lt kf hu lk b fv mk lv l lw lx"># Look which is the default branch<br/>TARGET_BRANCH=`curl — silent “${HOST}${CI_PROJECT_ID}” — header “PRIVATE-TOKEN:${PRIVATE_TOKEN}” | jq — raw-output ‘.default_branch’`;</span><span id="4688" class="lt kf hu lk b fv mk lv l lw lx"># The description of our new MR, we want to remove the branch after the MR has<br/># been closed<br/>BODY=”{<br/> \”id\”: ${CI_PROJECT_ID},<br/> \”source_branch\”: \”${CI_COMMIT_REF_NAME}\”,<br/> \”target_branch\”: \”${TARGET_BRANCH}\”,<br/> \”remove_source_branch\”: true,<br/> \”title\”: \”WIP: ${CI_COMMIT_REF_NAME}\”,<br/> \”assignee_id\”:\”${GITLAB_USER_ID}\”<br/>}”;</span><span id="840d" class="lt kf hu lk b fv mk lv l lw lx"># Require a list of all the merge request and take a look if there is already<br/># one with the same source branch<br/>LISTMR=`curl — silent “${HOST}${CI_PROJECT_ID}/merge_requests?state=opened” — header “PRIVATE-TOKEN:${PRIVATE_TOKEN}”`;<br/>COUNTBRANCHES=`echo ${LISTMR} | grep -o “\”source_branch\”:\”${CI_COMMIT_REF_NAME}\”” | wc -l`;</span><span id="918a" class="lt kf hu lk b fv mk lv l lw lx"># No MR found, let’s create a new one<br/>if [ ${COUNTBRANCHES} -eq “0” ]; then<br/> curl -X POST “${HOST}${CI_PROJECT_ID}/merge_requests” \<br/> — header “PRIVATE-TOKEN:${PRIVATE_TOKEN}” \<br/> — header “Content-Type: application/json” \<br/> — data “${BODY}”;</span><span id="48f1" class="lt kf hu lk b fv mk lv l lw lx">echo “Opened a new merge request: WIP: ${CI_COMMIT_REF_NAME} and assigned to you”;<br/> exit;<br/>fi</span><span id="ff0c" class="lt kf hu lk b fv mk lv l lw lx">echo “No new merge request opened”;</span></pre><p id="811e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我们需要生成一个<code class="eh lh li lj lk b">PRIVATE_TOKEN </code>，这只是一个我们可以生成的随机令牌。为了有一个强大和安全的令牌，我们可以使用一个<a class="ae jp" href="https://lastpass.com/generatepassword.php" rel="noopener ugc nofollow" target="_blank">密码生成器</a>或任何其他东西(你的选择！).</p><p id="45de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">把“秘密变量”里面的内容作为<code class="eh lh li lj lk b">PRIVATE_TOKEN</code></p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/949d2274cf97566ccdadf3464dd92409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W925SJvEV1H4Vm9QWmd3lw.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Go to Your Project -&gt; Settings -&gt; CI/CD -&gt; Secret Variables</figcaption></figure><h1 id="0eaf" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">#7部署到生产环境</h1><p id="5efb" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">这与准备过程非常相似，但这里有一个不同之处。CI(持续集成)和持续部署(CD)方法之间的主要区别在于，后者，即您对代码所做的任何更改，都会自动推送到生产中。</p><p id="d298" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在GitLab中，我们可以通过指定“when”键来指定是否手动将其部署到生产环境中。</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="acf5" class="lt kf hu lk b fv lu lv l lw lx">Deploy to Production:<br/>  stage: production<br/>  before_script:<br/>  # Generates to connect to the AWS unit the SSH key.<br/>    - mkdir -p ~/.ssh<br/>    - echo -e "$SSH_PRIVATE_KEY" &gt; ~/.ssh/id_rsa<br/>  # Sets the permission to 600 to prevent a problem with AWS<br/>  # that it's too unprotected<br/>    - chmod 600  ~/.ssh/id_rsa<br/>    - '[[ -f /.dockerenv ]] &amp;&amp; echo -e "Host *\n\tStrictHostKeyChecking no\n\n" &gt; ~/.ssh/config'<br/>   script:<br/>    - bash ./gitlab-deploy/.gitlab-deploy.prod.sh<br/>   environment:<br/>     name: production<br/>     # Exposes a button that when clicked take you to the defined URL:<br/>     url: <a class="ae jp" href="http://ec2-13-59-173-91.us-east-2.compute.amazonaws.com:81" rel="noopener ugc nofollow" target="_blank">http://ec2-13-59-173-91.us-east-2.compute.amazonaws.com:81</a></span><span id="8dc2" class="lt kf hu lk b fv mk lv l lw lx">when: manual</span></pre><p id="8a5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你所看到的，通过指定键<code class="eh lh li lj lk b">when:manual</code>，我们告诉GitLab <strong class="it hv">不要将代码自动推向生产，等待我们的命令。</strong></p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff nv"><img src="../Images/83274531917f8a6c2b6939e8898ec062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_Py_ygrbWeL2kaK2zidRw.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">On the pipelines page, you click a Playback button to “Deploy to Production”, which is the name you specified in the .gitlab-ci.yml</figcaption></figure><p id="2e19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，但同样重要的是，检查。gitlab-deploy.prod.sh</p><pre class="ll lm ln lo fq lp lk lq lr aw ls dt"><span id="f5ca" class="lt kf hu lk b fv lu lv l lw lx"># !/bin/bash</span><span id="e380" class="lt kf hu lk b fv mk lv l lw lx"># Get servers list:<br/>set — f</span><span id="338c" class="lt kf hu lk b fv mk lv l lw lx"># Variables from GitLab server:<br/># Note: They can’t have spaces!!<br/>string=$DEPLOY_SERVER<br/>array=(${string//,/ })</span><span id="902b" class="lt kf hu lk b fv mk lv l lw lx"># Iterate servers for deploy and pull last commit<br/># Careful with the ; <a class="ae jp" href="https://stackoverflow.com/a/20666248/1057052" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/20666248/1057052</a><br/>for i in “${!array[@]}”; do<br/>  echo “Deploy project on server ${array[i]}”<br/>  ssh ubuntu@${array[i]} “cd ./Pardo/vr &amp;&amp; git stash &amp;&amp; git checkout $CI_BUILD_REF_NAME &amp;&amp; git stash &amp;&amp; git pull origin master &amp;&amp; sudo yarn install &amp;&amp; sudo npm run production”</span><span id="d038" class="lt kf hu lk b fv mk lv l lw lx">done</span></pre><p id="432e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你注意的话，你会发现它与临时版本很相似(甚至完全相同)。除了我将它指向EC2实例中生产代码所在的不同位置。您也可以随意修改这个文件。</p><h1 id="14f7" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"># 8 CI/CD管道已配置完毕！该用力了！</h1><p id="7917" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">是啊！！终于到那个时候了！</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff nw"><img src="../Images/4480b32080003614efa1c95b635fe633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CO0Ww2i1H9qx68Ph2pDUpw.png"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Commit your file and push to your GitLab instance!</figcaption></figure><p id="c49f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看你的改变是如何开始发生的！</p><figure class="ll lm ln lo fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff nx"><img src="../Images/089279c2db0494ef7e161e4dce6f6f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDrnRkXEKb55cRTCEdHxVA.png"/></div></div></figure><p id="bac3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！</p><p id="138e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">WOAH！谢谢你载我一程。</p><figure class="ll lm ln lo fq mm"><div class="bz el l di"><div class="ny nz l"/></div></figure></div></div>    
</body>
</html>