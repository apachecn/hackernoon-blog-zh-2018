<html>
<head>
<title>Deploying Confidently: Haskell and Circle CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自信地部署:Haskell和Circle CI</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deploying-confidently-haskell-and-circle-ci-53cc44a300b4?source=collection_archive---------22-----------------------#2018-04-23">https://medium.com/hackernoon/deploying-confidently-haskell-and-circle-ci-53cc44a300b4?source=collection_archive---------22-----------------------#2018-04-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0526aeb0cc4d045ff16c2b5975c71094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddrXjDlCLO4Dv4fhlXzWwg.png"/></div></div></figure><p id="2731" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上周的文章中，我们使用Heroku将Haskell代码部署到云中。我们的解决方案是可行的，但是这个过程也是非常基础和非常手动的。让我们回顾一下使用这种方法在实际项目中部署代码的步骤。</p><ol class=""><li id="af65" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">对主分支机构提出拉取请求</li><li id="6c94" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">将代码合并到母版中</li><li id="d4e8" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">在本地拉主控，运行测试</li><li id="e072" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">手动运行<code class="eh kp kq kr ks b">git push heroku master</code></li><li id="aa1b" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">希望Heroku一切顺利</li></ol><p id="eb78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这不是一个好方法。在我们的开发过程中，无论哪里有手工步骤，我们都可能忘记一些东西。这几乎总会在某个时候反咬我们一口。在本文中，我们将看到如何使用Circle CI来自动化我们的开发工作流。</p><h1 id="1321" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">Circle入门</h1><p id="dfab" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">要阅读本文，您应该已经将项目存储在Github上了。一旦有了这个，你就可以很容易的和Circle融合了。去<a class="ae ka" href="https://www.circleci.com/" rel="noopener ugc nofollow" target="_blank">圈子网站</a>用Github登录。然后转到“添加项目”。您应该会看到您所有的个人存储库。单击您的Haskell项目应该允许您集成这两个服务。</p><p id="5aa3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在Circle知道了我们的资源库，每当我们将代码推送到Github时，它都会尝试构建。但是我们必须告诉Circle CI，一旦我们发布了代码，该做什么！对于这一步，我们需要创建一个配置文件，并将其存储为我们的存储库的一部分。请注意，我们将使用Circle CI配置的第2版。为了定义这个配置，我们首先在存储库的根目录下创建一个名为<code class="eh kp kq kr ks b">.circleci</code>的文件夹。然后我们制作一个YAML文件叫做<code class="eh kp kq kr ks b">config.yaml</code>。</p><p id="c20d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Circle V2中，我们为Circle容器指定要运行的“工作流”。为了简单起见，我们将把我们的操作限制在一个工作流中。我们在配置的底部指定了<code class="eh kp kq kr ks b">workflows</code>部分:</p><pre class="lw lx ly lz fq ma ks mb mc aw md dt"><span id="30ec" class="me ku hu ks b fv mf mg l mh mi">workflows:<br/>  version: 2<br/>  build_and_test:<br/>    jobs:<br/>      - build_project</span></pre><p id="1983" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在在顶部，我们将再次指定版本2，然后列出我们的<code class="eh kp kq kr ks b">build_project</code>工作的基本定义。</p><pre class="lw lx ly lz fq ma ks mb mc aw md dt"><span id="df90" class="me ku hu ks b fv mf mg l mh mi">version: 2<br/>jobs:<br/>  build_project:<br/>    machine: true<br/>    steps:<br/>      - checkout<br/>      - run: echo “Hello”</span></pre><p id="3737" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kp kq kr ks b">machine</code>部分显示了我们在项目中使用的默认圆机图像。没有我们可以使用的内置Haskell机器配置，所以我们使用一个基本映像。然后对于我们的步骤，我们将首先检查我们的代码，然后运行一个简单的“echo”命令。现在，让我们考虑如何让这台机器获得堆栈实用程序，这样我们就可以实际构建我们的代码了。</p><h1 id="8e7d" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">安装堆栈</h1><p id="1131" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">所以现在我们的Circle容器没有Haskell工具。这意味着我们需要从头开始。这是一个有用的学习练习。我们将学习在Linux机器上构建Haskell项目所需的最少步骤。下周，我们将看到一条我们可以使用的捷径。</p><p id="68ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，Stack工具为我们处理了大部分问题，但是我们首先必须下载它。因此，在检查了我们的代码之后，我们将运行几个不同的命令来安装Stack。下面是它们的样子:</p><pre class="lw lx ly lz fq ma ks mb mc aw md dt"><span id="d534" class="me ku hu ks b fv mf mg l mh mi">steps:<br/>  - checkout<br/>  - run: wget https://github.com/commercialhaskell/stack/releases/download/v1.6.1/stack-1.6.1-linux-x86_64.tar.gz -O /tmp/stack.tar.gz<br/>  - run: sudo mkdir /tmp/stack-download<br/>  - run: sudo tar -xzf /tmp/stack.tar.gz -C /tmp/stack-download<br/>  - run: sudo chmod +x /tmp/stack-download/stack-1.6.1-linux-x86_64/stack<br/>  - run: sudo mv /tmp/stack-download/stack-1.6.1-linux-x86_64/stack /usr/bin/stack</span></pre><p id="0e82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kp kq kr ks b">wget</code>命令从Github下载堆栈。如果您使用的Stack版本与我们的不同(1.6.1)，您当然需要更改版本号。然后，我们将创建一个临时目录，将实际的可执行文件解压缩到该目录。然后我们使用<code class="eh kp kq kr ks b">tar</code>来执行解压缩步骤。这使得我们将<code class="eh kp kq kr ks b">stack</code>可执行文件放在适当的文件夹中。我们将赋予这个可执行文件<code class="eh kp kq kr ks b">x</code>权限，然后将它移动到机器的路径上。那我们就用<code class="eh kp kq kr ks b">stack</code>！</p><h1 id="d41e" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">构建我们的项目</h1><p id="2390" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">现在我们已经完成了大部分艰难的工作！从这里开始，我们将只使用堆栈命令来确保我们的代码正常工作。我们从运行<code class="eh kp kq kr ks b">stack setup</code>开始。这将下载我们的项目需要的任何版本的GHC。然后我们将运行<code class="eh kp kq kr ks b">stack test</code>命令来确保我们的代码编译并通过所有的测试套件。</p><pre class="lw lx ly lz fq ma ks mb mc aw md dt"><span id="df4b" class="me ku hu ks b fv mf mg l mh mi">steps:<br/>  - checkout<br/>  - run: wget …<br/>  ... <br/>  - run: stack setup<br/>  - run: stack test</span></pre><p id="8477" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，Circle希望我们的命令以退出代码0结束。这意味着如果它们中的任何一个有非零的退出代码，构建将是“失败”的。这包括我们的<code class="eh kp kq kr ks b">stack test</code>步骤。因此，如果我们推送的代码没有通过任何测试，我们会将其视为构建失败！这使我们省去了手动运行测试的额外步骤，并“希望”它们能在我们部署的环境中工作。</p><h1 id="06e3" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">贮藏</h1><p id="f2d0" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">目前这一过程有一个相当大的弱点。我们做的每一个圆形容器都是从零开始的。因此，我们将不得不下载GHC和所有不同的库，我们的代码依赖于每一个构建。这意味着您可能需要等待30-60分钟来查看您的代码是否通过，这取决于您项目的大小！我们不想这样。所以为了让事情变得更快，我们将告诉Circle缓存这个信息，因为它不会在大多数构建中改变。我们将采取以下两个步骤:</p><ol class=""><li id="8af2" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">仅在<code class="eh kp kq kr ks b">stack.yaml</code>改变时下载GHC(因为LTS可能已经改变)。这涉及到缓存<code class="eh kp kq kr ks b">~/.stack</code>目录</li><li id="a335" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">仅当<code class="eh kp kq kr ks b">stack.yaml</code>或我们的<code class="eh kp kq kr ks b">.cabal</code>文件改变时才重新下载库。为此，我们将缓存<code class="eh kp kq kr ks b">.stack-work</code>库。</li></ol><p id="ba09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于其中的每一个，我们将创建一个适当的缓存键。在构建过程的开始，我们将尝试根据特定的键从缓存中恢复这些目录。作为每个密钥的一部分，我们将使用相关文件的校验和。</p><pre class="lw lx ly lz fq ma ks mb mc aw md dt"><span id="4da5" class="me ku hu ks b fv mf mg l mh mi">steps:<br/>  - checkout<br/>  - restore-cache:<br/>      keys:<br/>        - stack-{{ checksum “stack.yaml” }}<br/>  - restore-cache:<br/>      keys:<br/>        - stack-{{checksum “stack.yaml”}}-{{checksum “project.cabal”}}</span></pre><p id="4982" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果这些文件改变，校验和将是不同的，所以圆将无法恢复目录。然后，我们的其他步骤将完全运行，下载所有相关信息。在这个过程的最后，我们希望确保我们已经在同一个键下保存了这些目录。我们用<code class="eh kp kq kr ks b">save_cache</code>命令来做这件事:</p><pre class="lw lx ly lz fq ma ks mb mc aw md dt"><span id="2e10" class="me ku hu ks b fv mf mg l mh mi">steps:<br/>  …<br/>  - stack test<br/>  - save-cache:<br/>      key: stack-{{ checksum “stack.yaml” }}<br/>      paths:<br/>        - “~/.stack”<br/>  - restore-cache:<br/>      keys: stack-{{checksum “stack.yaml”}}-{{checksum “project.cabal”}}<br/>      paths:<br/>        - “.stack-work”</span></pre><p id="6967" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，下一次构建将不会花这么长时间！还有其他方法可以创建缓存键。例如，我们可以使用堆栈LTS作为键的一部分，并且每次我们改变使用哪个LTS时都要删除它。缺点是需要更多的手工操作。但这项工作不会经常发生。积极的一面是，当我们向<code class="eh kp kq kr ks b">stack.yaml</code>添加额外的依赖项时，我们不需要重新下载GHC。</p><h1 id="f73d" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">部署到Heroku</h1><p id="778d" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">最后但同样重要的是，每次我们推进到主分支时，我们都希望将代码部署到heroku。Heroku让我们很容易做到这一点！首先，进入Heroku的应用仪表板。然后找到部署选项卡。您应该会看到一个连接Github的选项。使用它来连接您的存储库。然后，确保选中指示Heroku应该等待CI的复选框。现在，只要你的构建成功完成，你的代码就会被推送到Heroku！</p><h1 id="f393" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">结论</h1><p id="ca17" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">你可能已经注意到我们现在的方法有一些冗余！我们的Circle CI容器将构建代码。然后我们的Heroku容器也会构建代码！这是非常低效的，并且会导致部署问题。下周，我们将看到如何在这个过程中使用Docker。Docker完全融入了V2圈。这将简化我们的圆配置定义。这也将使我们不再需要在Heroku上重新构建所有代码！</p><p id="7598" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了所有这些工具，是时候最终构建您一直想要的Haskell应用程序了！下载我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">制作清单</a>，了解一些你可以使用的酷库！</p><p id="22d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你以前从未用Haskell编程，希望你能看到它并不太难用！下载我们的<a class="ae ka" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank"> Haskell初学者清单</a>并开始吧！</p></div></div>    
</body>
</html>