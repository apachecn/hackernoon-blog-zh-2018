<html>
<head>
<title>You might not need React Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能不需要反应上下文</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/you-might-not-need-react-context-e1adb35b2e04?source=collection_archive---------26-----------------------#2018-04-23">https://medium.com/hackernoon/you-might-not-need-react-context-e1adb35b2e04?source=collection_archive---------26-----------------------#2018-04-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7e35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React 16.3终于让<a class="ae jp" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>稳定了。从那时起，许多开发人员开始使用它来解决“prop-drilling”问题——您需要沿着没有使用它的组件向下传递一个<code class="eh jq jr js jt b">prop</code>,以便访问正在树的深处呈现的组件中的那个<code class="eh jq jr js jt b">prop</code>。<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>文档如下陈述了上下文API的意图:</p><blockquote class="jv jw jx"><p id="838d" class="ir is ju it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">在一个典型的React应用程序中，<a class="ae jp" href="https://hackernoon.com/tagged/data" rel="noopener ugc nofollow" target="_blank">数据</a>是通过props自顶向下(父到子)传递的，但是对于应用程序中许多组件所需要的某些类型的props(例如区域设置首选项、UI主题)来说，这可能很麻烦。上下文提供了一种在组件之间共享这样的值的方式，而不必显式地通过树的每一层传递一个属性。</p><p id="7e77" class="ir is ju it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">Context被设计为<strong class="it hv">共享数据，这些数据可以被认为是React组件树的“全局”数据，比如当前认证的用户、主题或首选语言。</strong></p></blockquote><p id="9696" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看跟踪用户活动的例子。为此，我们想在用户每次点击UI元素时调用某个<code class="eh jq jr js jt b">track</code>函数。</p><h2 id="c894" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">平原反应中的追踪者</h2><pre class="kw kx ky kz fq la jt lb lc aw ld dt"><span id="7037" class="kb kc hu jt b fv le lf l lg lh">const track = event =&gt; console.log(`${event} occured`);<br/><br/>class App extends React.Component {<br/>  render() {<br/>    return &lt;Toolbar track={track} /&gt;;<br/>  }<br/>}<br/><br/>function Toolbar(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;TrackedButton track={props.track} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>function TrackedButton(props) {<br/>  const onClick = () =&gt; {<br/>    props.track("button click");<br/>    // do something on click<br/>  };<br/>  return &lt;Button onClick={onClick} /&gt;;<br/>}</span></pre><p id="07c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要在应用程序的许多不同组件中使用<code class="eh jq jr js jt b">track</code>功能，在没有任何高级模式的情况下使用React，我们需要在整个组件树中传递<code class="eh jq jr js jt b">track</code>，即使<code class="eh jq jr js jt b">App</code>和<code class="eh jq jr js jt b">Toolbar</code>没有使用它。</p><h2 id="be2b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">带上下文的跟踪器</h2><p id="08b3" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">我们可以使用新的React上下文API将<code class="eh jq jr js jt b">track</code>函数注入到所需的组件中:</p><pre class="kw kx ky kz fq la jt lb lc aw ld dt"><span id="6dc2" class="kb kc hu jt b fv le lf l lg lh">const track = event =&gt; console.log(`${event} occured`);<br/>const TrackerContext = React.createContext(track);<br/><br/>class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;TrackerContext.Provider value={track}&gt;<br/>        &lt;Toolbar /&gt;<br/>      &lt;/TrackerContext.Provider&gt;<br/>    );<br/>  }<br/>}<br/><br/>function Toolbar(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      {/* does not need to forward props anymore */}<br/>      &lt;TrackedButton /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>function TrackedButton(props) {<br/>  return (<br/>    &lt;TrackerContext.Consumer&gt;<br/>      {value =&gt; (<br/>        &lt;Button<br/>          onClick={() =&gt; {<br/>            // call track<br/>            value("button click");<br/>            // do something on click<br/>          }}<br/>        /&gt;<br/>      )}<br/>    &lt;/TrackerContext.Consumer&gt;<br/>  );<br/>}</span></pre><p id="59d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们创建一个<code class="eh jq jr js jt b">TrackerContext</code>，用<code class="eh jq jr js jt b">Provider</code>包装根组件，使得<code class="eh jq jr js jt b">track</code>功能<em class="ju">消耗</em>作为<code class="eh jq jr js jt b">TrackedButton</code>组件中的<code class="eh jq jr js jt b">value</code>。</p><p id="b961" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这不是我们在<code class="eh jq jr js jt b">Context</code> API之前不能做的事情，你<strong class="it hv">总是可以在React中用一个特设的</strong>(高阶组件)来做这件事。使用特设的代码可读性更好。</p><h2 id="f272" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">作为特设的跟踪器</h2><p id="c3f7" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">我们可以创建一个HOC，一个接受一个组件并返回一个新组件的函数，这个新组件通过一些增强来呈现原始组件。在我们的例子中，我们只是将<code class="eh jq jr js jt b">track</code>函数作为<code class="eh jq jr js jt b">prop</code>注入到内部组件中。</p><pre class="kw kx ky kz fq la jt lb lc aw ld dt"><span id="c3a4" class="kb kc hu jt b fv le lf l lg lh">const track = event =&gt; console.log(`${event} occured`);<br/>const withTracker = track =&gt; Component =&gt; (props) =&gt; (<br/>  &lt;Component track={track} {...props}/&gt;<br/>);<br/><br/>class App extends React.Component {<br/>  render() {<br/>    return (<br/>      /* no need to wrap root Component */<br/>      &lt;Toolbar /&gt;<br/>    );<br/>  }<br/>}<br/><br/>function Toolbar(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      {/* need to use the HOC here */}<br/>      &lt;TrackedButtonWrapped /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>// TrackedButton is the same as in first solution<br/>function TrackedButton(props) {<br/>  const onClick = () =&gt; {<br/>    props.track("button click");<br/>    // do something on click<br/>  };<br/>  return &lt;Button onClick={onClick} /&gt;;<br/>}<br/>// Need to create a higher-order component out of TrackedButton<br/>const TrackedButtonWrapped = withTracker(track)(TrackedButton)</span></pre><p id="ff61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样做的好处是代码比使用<code class="eh jq jr js jt b">Context</code>要干净得多:</p><ol class=""><li id="6af5" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv dt translated"><code class="eh jq jr js jt b">App</code>不再需要<code class="eh jq jr js jt b">ContextProvider</code>包装。</li><li id="e3bc" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated"><code class="eh jq jr js jt b">TrackedButton</code>与普通React溶液中的成分完全相同。它不再负责检索<code class="eh jq jr js jt b">track</code>函数。这是因为我们将<code class="eh jq jr js jt b">prop</code>检索转移到了<code class="eh jq jr js jt b"><strong class="it hv">TrackedButtonWrapped</strong></code> <strong class="it hv">特设</strong>中，而不是在<code class="eh jq jr js jt b">Toolbar</code>中呈现。</li></ol><blockquote class="jv jw jx"><p id="1614" class="ir is ju it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">所以React.createContext没用吗？</p></blockquote><p id="afeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们回到<a class="ae jp" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>中给出的例子。在那里，<code class="eh jq jr js jt b">Context</code>是用来<em class="ju">主题</em>的一个app。</p><h2 id="039e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">结合上下文进行主题化</h2><p id="52c0" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">代码类似于<em class="ju">跟踪上下文</em>的例子。<code class="eh jq jr js jt b">ThemeContext.Provider</code>提供<code class="eh jq jr js jt b">theme</code>和<em class="ju">切换主题</em>的功能，主题在根组件中设置<code class="eh jq jr js jt b">state</code>。这些变量只在需要的地方使用——在<code class="eh jq jr js jt b">ThemedButton</code>中设计按钮的样式并在按钮点击时切换主题。</p><pre class="kw kx ky kz fq la jt lb lc aw ld dt"><span id="e5db" class="kb kc hu jt b fv le lf l lg lh">const ThemeContext = React.createContext();<br/><br/>class App extends React.Component {<br/>  state = {<br/>    theme: 'light'<br/>  }<br/><br/>  toggleTheme = () =&gt; {<br/>    this.setState(({ theme }) =&gt; ({<br/>      theme: theme === 'light' ? 'dark' : 'light',<br/>    }));<br/>  }<br/><br/>  render() {<br/>    const value = {<br/>      theme: this.state.theme,<br/>      toggleTheme: this.toggleTheme,<br/>    }<br/>    return (<br/>      &lt;ThemeContext.Provider value={value}&gt;<br/>        &lt;Toolbar /&gt;<br/>      &lt;/ThemeContext.Provider&gt;<br/>    );<br/>  }<br/>}<br/><br/>function Toolbar(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ThemedButton /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>function ThemedButton(props) {<br/>  return (<br/>    &lt;ThemeContext.Consumer&gt;<br/>      {({ theme, toggleTheme }) =&gt; &lt;Button theme={theme} onClick={toggleTheme}/&gt;}<br/>    &lt;/ThemeContext.Consumer&gt;<br/>  );<br/>}</span></pre><h2 id="04eb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">主题化:第一次尝试</h2><p id="893a" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">让我们试着将与<code class="eh jq jr js jt b">Tracking</code>相同的特殊模式应用到<code class="eh jq jr js jt b">Theming</code>。</p><blockquote class="jv jw jx"><p id="e4e2" class="ir is ju it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">剧透:行不通。</p></blockquote><pre class="kw kx ky kz fq la jt lb lc aw ld dt"><span id="361f" class="kb kc hu jt b fv le lf l lg lh">const withTheme = InnerComponent =&gt; class extends React.Component {<br/>  state = {<br/>    theme: 'light'<br/>  }<br/><br/>  toggleTheme = () =&gt; {<br/>    this.setState(({ theme }) =&gt; ({<br/>      theme: theme === 'light' ? 'dark' : 'light',<br/>    }));<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;InnerComponent theme={this.state.theme} toggleTheme={this.toggleTheme} /&gt;<br/>    )<br/>  }<br/>}<br/><br/>class App extends React.Component {<br/>  render() {<br/>    return (<br/>      // again no Provider needed<br/>        &lt;Toolbar /&gt;<br/>    );<br/>  }<br/>}<br/><br/>function Toolbar(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      {/* use the HOC here */}<br/>      &lt;ThemedButtonWrapped /&gt;<br/>      {/* let's add another Button here */}<br/>      &lt;ThemedButtonWrapped /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>function ThemedButton(props) {<br/>  return &lt;Button onClick={props.toggleTheme} theme={props.theme} /&gt;;<br/>}<br/>// Need to create a higher-order component out of ThemedButton<br/>const ThemedButtonWrapped = withTheme(ThemedButton)</span></pre><p id="762d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里怎么了？如果我们添加另一个<code class="eh jq jr js jt b">ThemedButton</code>，你会发现它在这里不起作用。每次创建HOC时，组件实例都以一个新的<code class="eh jq jr js jt b">state</code>开始，因此按钮的主题是相互独立的。你可以在这里摆弄它<a class="ae jp" href="https://codesandbox.io/s/r5o2zjop5m" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="mb mc fm fo md me"><a href="https://codesandbox.io/embed/r5o2zjop5m" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab ej"><div class="mg ab mh cl cj mi"><h2 class="bd hv fv z el mj eo ep mk er et ht dt translated">CodeSandbox</h2><div class="ml l"><h3 class="bd b fv z el mj eo ep mk er et ek translated">CodeSandbox是一个为web应用程序量身定制的在线编辑器。</h3></div><div class="mm l"><p class="bd b gc z el mj eo ep mk er et ek translated">codesandbox.io</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms mt me"/></div></div></a></div><p id="c4a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">为什么它在跟踪示例中有效？</strong>在跟踪示例中，数据(<code class="eh jq jr js jt b">track</code>函数)是<em class="ju">静态的</em>并且从不改变，因此使用相同函数的每个按钮实例在这里都不是问题。</p><p id="29eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是<code class="eh jq jr js jt b">Context API</code>相对于<code class="eh jq jr js jt b">HOC pattern</code>的一大优势，也是它如此强大的原因:<strong class="it hv">使用</strong> <code class="eh jq jr js jt b"><strong class="it hv">Context</strong></code> <strong class="it hv">数据在所有</strong> <code class="eh jq jr js jt b"><strong class="it hv">Consumers</strong></code>中共享<em class="ju">。</em></p><figure class="kw kx ky kz fq mv fe ff paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="fe ff mu"><img src="../Images/1d5371fbcb3da99f4295ad34ac0c220e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P6hAe0yytsFjjlBQ.png"/></div></div></figure><h1 id="637f" class="nb kc hu bd kd nc nd ne kh nf ng nh kl ni nj nk ko nl nm nn kr no np nq ku nr dt translated">摘要</h1><p id="1cec" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">这里是React文档对<code class="eh jq jr js jt b">Context</code>用例的描述:</p><blockquote class="jv jw jx"><p id="1193" class="ir is ju it b iu iv iw ix iy iz ja jb jy jd je jf jz jh ji jj ka jl jm jn jo hn dt translated">上下文旨在共享数据，这些数据可以被视为React组件树的“全局”数据</p></blockquote><p id="29b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我可以更进一步说，<code class="eh jq jr js jt b">Context API</code>是用于全局<strong class="it hv">动态</strong>数据的，这些数据被多个组件实例使用<strong class="it hv">。在<strong class="it hv">静态</strong>数据的情况下，您可能不需要<code class="eh jq jr js jt b">Context</code>。它总是可以被注入<code class="eh jq jr js jt b">props</code>的更简单易用的HOC所替代。</strong></p><p id="5864" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是如何决定是否使用React的<code class="eh jq jr js jt b">Context</code> API的通用指南:</p><figure class="kw kx ky kz fq mv fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/c3d0b37eabc4cf6cd52b0e687e921502.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/0*zcD97HdmsZulgiEV.png"/></div></figure></div><div class="ab cl nt nu hc nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hn ho hp hq hr"><p id="c6c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最初发表于<a class="ae jp" href="https://cmichel.io/you-might-not-need-react-context/" rel="noopener ugc nofollow" target="_blank"> cmichel.io </a></p><figure class="kw kx ky kz fq mv"><div class="bz el l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>