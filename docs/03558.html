<html>
<head>
<title>GraphQL authorization with multiple data sources using AWS AppSync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS AppSync对多个数据源进行GraphQL授权</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphql-authorization-with-multiple-data-sources-using-aws-appsync-dfae2e350bf2?source=collection_archive---------2-----------------------#2018-04-24">https://medium.com/hackernoon/graphql-authorization-with-multiple-data-sources-using-aws-appsync-dfae2e350bf2?source=collection_archive---------2-----------------------#2018-04-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e6a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">我最近在React Amsterdam上做了一个关于运行GraphQL at scale </em>  <em class="jp">的</em> <a class="ae jq" href="https://youtu.be/smBND2pwdUE?t=19535" rel="noopener ugc nofollow" target="_blank"> <em class="jp">演讲，涵盖了生产中出现的一些不同的用例及技术。其中一个场景与使用多个数据源以级联方式</em> </a> <em class="jp">进行</em> <a class="ae jq" href="https://youtu.be/smBND2pwdUE?t=20332" rel="noopener ugc nofollow" target="_blank"> <em class="jp">授权有关，这也是本文的出发点。这是一个有点高级的主题，所以如果你刚刚开始，我建议从更多的介绍性信息开始</em> </a><a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/security.html#fine-grained-access-control" rel="noopener ugc nofollow" target="_blank"> <em class="jp">这里</em> </a> <em class="jp">和</em> <a class="ae jq" href="https://www.youtube.com/watch?v=etax3aEe2dA" rel="noopener ugc nofollow" target="_blank"> <em class="jp">这里</em> </a> <em class="jp">。</em></p><p id="762d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">授予对GraphQL中数据的访问权可能是一个棘手的问题，随着该技术被更广泛地采用，多种策略和新兴的最佳实践开始涌现。<a class="ae jq" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>为您提供了强大的技术来对用例实施不同的授权控制，例如:</p><ul class=""><li id="7488" class="jr js hu it b iu iv iy iz jc jt jg ju jk jv jo jw jx jy jz dt translated">完全公开的API</li><li id="beb4" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">对API部分的私有和公共访问</li><li id="a8d6" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">私有和公共记录，在运行时对字段进行检查</li><li id="c4e6" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">一个或多个用户可以写入/读取记录</li><li id="28a3" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">一个或多个组可以写入/读取记录</li><li id="998e" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">每个人都可以阅读，但只有记录创建者可以编辑或删除</li></ul><p id="bbfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从根本上讲，在任何系统中实现访问控制时，必须存在一些关于谁或什么可以访问资源的元数据。定义这一点的经典方法是使用巴特勒兰普森的<a class="ae jq" href="https://en.wikipedia.org/wiki/Access_Control_Matrix" rel="noopener ugc nofollow" target="_blank">访问控制矩阵</a>，其中授予的权限是由资源和参与者(可以是用户、角色、组等)组成的行和列的交集。).当直接与数据库交互时，这种“授权元数据”往往是该系统的一部分，访问控制在连接时或运行时执行。在以GraphQL API为前端的服务架构中，存在一个间接层，代表调用者进行数据库交互。GraphQL还允许在字段级别对查询返回的部分结果进行授权。虽然这一开始看起来令人望而生畏，但实际上您最终会得到强大的控件，这些控件允许您将授权数据存储在一个资源上、一个单独的数据源中，或者混合/匹配控件的组合。您甚至可以在不同级别进行级联检查，以满足您独特的业务需求。</p><p id="22a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文展示了如何使用GraphQL技术通过<a class="ae jq" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"> AWS AppSync </a>进行授权，但是这些策略也可以应用于定制的GraphQL解决方案。虽然AppSync有一个被称为“数据源”的第一类概念，但这种概括可以应用于GraphQL解析器，因为它们使用这个位置来获取数据。使用上面关于执行访问控制检查的描述，您可以在下图中看到如何通过在资源<br/>(数据库记录的“作者”列)上存储用于授权的元数据，并在调用GraphQL解析器时通过请求线程化调用者的身份信息来执行条件检查。在这里阅读更多<a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/security.html#fine-grained-access-control" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff kf"><img src="../Images/635962ae057130ee3fda372bd66763c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0jjNV-2GqL0jVroGSyNcw.png"/></div></div></figure><p id="4521" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然许多访问控制场景可以使用单个数据源，但是一些授权用例需要使用多个数据源。例如，在AppSync中，您可能会这样做，因为您希望在将数据读取或写入DynamoDB表之前，首先在Lambda函数中执行一些逻辑，或者可能是首先执行查找，例如只允许您的“朋友”读取您的数据(一对多检查)。</p><p id="c0c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GraphQL通过在您的字段上使用解析器、遍历应用程序图、从不同的数据源获取数据并在适当的时候执行授权检查来实现这一点。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff kr"><img src="../Images/170f1317f3ccf693c43934767eead868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7bxQB8awaI_YcZFGxtT6g.png"/></div></div></figure><p id="0465" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于许多高级场景，您可以将这种技术与AWS AppSync 的<a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/security.html#fine-grained-access-control" rel="noopener ugc nofollow" target="_blank">内置细粒度访问控制结合使用。例如，虽然细粒度的访问控制允许您在解析器中执行条件逻辑，如用户或组检查，但嵌套解析器和聚合上下文允许您使用来自父对象的结果来执行此逻辑。为了演示这一点，我们将从一个简单的用例开始。</a></p><h1 id="9bc5" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">嵌套解析器</h1><p id="7df8" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">在<a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/security-authorization-use-cases.html" rel="noopener ugc nofollow" target="_blank"> AWS AppSync细粒度访问控制示例</a>中，授权元数据被直接存储在资源上(比如一个名为“所有者”的表中的一个项目的属性)。出于演示的目的，假设这些是单独的表，我想读取“数据”表中的数据，但首先对“验证”表中的数据运行授权检查，该表列出了谁是“数据”表中某项的“所有者”。只有“Auth”表中列出的“Owner”有权读取“Data”表中的相应信息(每个表中的id都有一个隐式关联)。下图是表格布局，其中包含一些记录和您希望逻辑检查如何工作的伪代码。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/01d43b8c1c58fda9b56a1dfd55786af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*O-FhCsKxpQjhZ-CIlJvbHg.png"/></div></figure><p id="ebc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个布局中，用户Nadia可以访问“数据”表中的项目1和3，而Shaggy可以访问项目2。要使用单独的数据源，可以将想要检索的数据“嵌套”在GraphQL类型中，该类型从单独的数据源获取授权元数据，并在查询中遍历对象图。执行这种嵌套的GraphQL模式示例如下。</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="dfd8" class="mb kt hu lx b fv mc md l me mf">type AuthCheckData {</span><span id="45ef" class="mb kt hu lx b fv mg md l me mf">  id: ID!</span><span id="b6bf" class="mb kt hu lx b fv mg md l me mf">  data: Data</span><span id="34a2" class="mb kt hu lx b fv mg md l me mf">}</span><span id="20ae" class="mb kt hu lx b fv mg md l me mf">type Data {</span><span id="6ee8" class="mb kt hu lx b fv mg md l me mf">  id: ID!</span><span id="ff76" class="mb kt hu lx b fv mg md l me mf">  title: String</span><span id="ce98" class="mb kt hu lx b fv mg md l me mf">  content: String</span><span id="840b" class="mb kt hu lx b fv mg md l me mf">}</span><span id="495e" class="mb kt hu lx b fv mg md l me mf">type Query {</span><span id="ad41" class="mb kt hu lx b fv mg md l me mf">  getData(id:ID!): AuthCheckData</span><span id="a77a" class="mb kt hu lx b fv mg md l me mf">}</span></pre><p id="0ddc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的GraphQL模式中，<strong class="it hv"> getData </strong>查询将调用针对<strong class="it hv"> Auth表</strong>的解析器，并返回类型<strong class="it hv"> AuthCheckData </strong>。然后在<strong class="it hv"> data:Data </strong>字段上设置的解析器将访问其父字段返回的数据，以执行授权检查。流程图如下。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/277c464d7532ed6a4433660052e73d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*xXmO5BDWdF_ygGSURyTIzw.png"/></div></figure><p id="27c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> getData </strong> resolver请求模板相当标准——它实际上只需要对Auth DynamoDB数据源运行一个<strong class="it hv"> GetItem </strong>,没有其他参数:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="7f5a" class="mb kt hu lx b fv mc md l me mf">{ <br/>  "version": "2017-02-28",</span><span id="5461" class="mb kt hu lx b fv mg md l me mf">  "operation": "GetItem",</span><span id="b908" class="mb kt hu lx b fv mg md l me mf">  "key": {</span><span id="cefd" class="mb kt hu lx b fv mg md l me mf">    "id": $util.dynamodb.toDynamoDBJson($ctx.args.id),</span><span id="9d2f" class="mb kt hu lx b fv mg md l me mf">  }</span><span id="99e9" class="mb kt hu lx b fv mg md l me mf">}</span></pre><p id="5418" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">响应模板只是传递数据:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="1bff" class="mb kt hu lx b fv mc md l me mf">$util.toJson($context.result)</span></pre><p id="31b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为返回的是整个结果，所以来自<strong class="it hv"> Auth </strong>表(在本例中为<strong class="it hv"> Owner </strong>)的任何属性都将被返回，并可用于子字段，以便通过<strong class="it hv"> $context.source </strong>对象(别名为<strong class="it hv"> $ctx.source </strong>)在解析器模板中使用。</p><p id="1b86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是事情变得有趣的地方。在<strong class="it hv"> data: Data </strong>上设置一个解析器，并再次使用一个<strong class="it hv"> GetItem，</strong>，但是现在使用解析器请求模板中带有<strong class="it hv"> $ctx.source.id </strong>的父级的ID:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="9e7b" class="mb kt hu lx b fv mc md l me mf">{</span><span id="e145" class="mb kt hu lx b fv mg md l me mf">  "version" : "2017-02-28",</span><span id="d8b9" class="mb kt hu lx b fv mg md l me mf">  "operation" : "GetItem",</span><span id="b211" class="mb kt hu lx b fv mg md l me mf">  "key" : {</span><span id="b4f7" class="mb kt hu lx b fv mg md l me mf">    "id" : { "S" : "${ctx.source.id}" }</span><span id="bbf7" class="mb kt hu lx b fv mg md l me mf">  }</span><span id="d0c8" class="mb kt hu lx b fv mg md l me mf">}</span></pre><p id="d411" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一点很重要，因为您实际上是在确保来自父检查的授权元数据与您正在执行验证的数据相匹配，这只是传递到GraphQL查询中的一个参数。现在，如果<strong class="it hv">所有者</strong>(在来自Auth表的<strong class="it hv"> $context.source.Owner </strong>中可用)等于当前用户，您可以过滤<strong class="it hv">数据:数据</strong>解析器的响应模板中的结果，只返回数据表中的值，如下面的解析器响应模板所示:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="6e72" class="mb kt hu lx b fv mc md l me mf">#if ($context.source.Owner == $context.identity.username)</span><span id="8984" class="mb kt hu lx b fv mg md l me mf">  $util.toJson($ctx.result)</span><span id="f495" class="mb kt hu lx b fv mg md l me mf">#else</span><span id="dae6" class="mb kt hu lx b fv mg md l me mf">  $utils.unauthorized()</span><span id="c721" class="mb kt hu lx b fv mg md l me mf">#end</span></pre><p id="df23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，可以运行对<strong class="it hv"> getData(id:1) </strong>或<strong class="it hv"> getData(id:3) </strong>的GraphQL查询，如果Nadia登录，她将看到她的数据。该查询类似于以下内容:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="ced8" class="mb kt hu lx b fv mc md l me mf">query {<br/>  getData(id:1){<br/>    data{<br/>      id<br/>      title<br/>      content<br/>    }<br/>  }<br/>}</span></pre><p id="d076" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果Nadia运行一个<strong class="it hv"> getData(id:2) </strong>的查询，她将得到一个未授权的消息，但是如果Shaggy运行那个查询，他将看到数据，因为他在Auth表中被列为所有者。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/b95994f956be631b063a540054b3bfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*vJX8xNd3fB66j7R1WSvPRw.png"/></div></figure><h1 id="0220" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">AWS Lambda授权器</h1><p id="1487" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">假设您有更复杂的授权、令牌验证业务逻辑，或者您需要与AWS AppSync尚不支持的数据源进行交互。但是，如果授权检查通过，您希望从DynamoDB表返回结果。您可以使用与之前相同的架构，但是这一次，让<strong class="it hv"> getData() </strong>解析器在第一层访问中使用AWS Lambda函数来执行授权，并将结果传递给DynamoDB解析器。</p><p id="dd3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要设置它，使用前面的相同模式，但是现在添加一个AWS Lambda函数的新AppSync数据源。如果你不熟悉在AWS AppSync中设置和使用<a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/tutorial-lambda-resolvers.html" rel="noopener ugc nofollow" target="_blank"> Lambda函数，先看看这个教程</a>。在AppSync中使用Lambda函数之前，您需要先创建它，对于本例，使用Node中编写的以下函数。JS:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="ba59" class="mb kt hu lx b fv mc md l me mf">'use strict';</span><span id="e634" class="mb kt hu lx b fv mg md l me mf">exports.handler = (event, context, callback) =&gt; {<br/>    console.log(event);<br/>    <br/>    let valid = allow(event);<br/>    <br/>    switch(event.field) {<br/>        case "getData":<br/>            var id = event.arguments.id;<br/>            if (valid) {<br/>                callback(null, {id: event.arguments.id});<br/>            } else {<br/>              let result = {};<br/>              result.errorMessage = "Error with the authorization";<br/>              result.errorType = "AUTHORIZATION_ERROR";<br/>              callback(null, result);<br/>            }<br/>            break;<br/>        case "addData":<br/>            // Write similar authorization check here<br/>            callback(null, event.arguments);<br/>            break;<br/>        default:<br/>            callback("Unknown field, unable to resolve" + event.field, null);<br/>            break;<br/>    }<br/>};</span><span id="b156" class="mb kt hu lx b fv mg md l me mf">function allow(event) {<br/>    const allowedKeys = ["abcdef", "ghijkl"];<br/>    const allowedUsers = ["Nadia", "Caesar"];<br/>    const allowedIps = ["192.168.0.1"];<br/>    <br/>    if (allowedUsers.includes(event.identity.username))<br/>      return true;<br/>    else if (allowedKeys.includes(event.request.headers.x-api-key))<br/>      return true;<br/>    else if (allowedIps.includes(event.identity.sourceIp))<br/>      return true;<br/>    else<br/>      return false;<br/>}</span></pre><p id="718a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码有一个<strong class="it hv"> allow() </strong>函数，它授权来自一组用户、API密钥或IP地址的请求。如果其中任何一个匹配，那么将允许授权。例如，如果一个客户端传入一个有效的API密钥，在一个白名单IP地址列表中，或者是一个有效的用户列表中的一个，那么访问将被授予。<a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html" rel="noopener ugc nofollow" target="_blank">您可以在这里</a>看到线程化到AppSync请求的上下文对象中的身份对象的完整列表。如果调用GraphQL API的客户端没有通过这些检查，那么Lambda将返回一个<strong class="it hv">ERROR type</strong>of<strong class="it hv">AUTHORIZATION _ ERROR</strong>。这是一个虚构的例子，但重点是您可以在Lambda中执行自定义授权逻辑，并将数据获取调用级联到其他解析器，这是您接下来要做的，而不需要将所有内容都放在Lambda函数中。</p><p id="3631" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更改<strong class="it hv"> getData(): AuthCheckData </strong>上的解析器以使用这个AWS Lambda数据源。解析器请求模板需要指定被调用的GraphQL字段，以及标识和参数:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="ab82" class="mb kt hu lx b fv mc md l me mf">{<br/>    "version" : "2017-02-28",<br/>    "operation": "Invoke",<br/>        "payload": {<br/>        "field": "getData",<br/>        "identity" : $utils.toJson($context.identity),<br/>        "arguments":  $utils.toJson($context.arguments)<br/>    }<br/>}</span></pre><p id="9acc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，与前面的场景不同，在前面的场景中，您从父节点传递了<strong class="it hv"> $context.source.Owner </strong>并在子节点中进行授权检查，Lambda直接返回<strong class="it hv"> result.errorType </strong>，您可以检查<strong class="it hv"> getData() </strong>本身的解析器响应模板:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="d5d5" class="mb kt hu lx b fv mc md l me mf">#if ($context.result.get("errorType") == "AUTHORIZATION_ERROR")<br/>  $util.unauthorized()<br/>#else<br/>  $util.toJson($context.result)<br/>#end</span></pre><p id="8b51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这样的模式，您实际上是将所有的验证逻辑“包装”在父解析器<strong class="it hv"> getData() </strong>中，以便子解析器严格地专注于数据获取，并且关注点的分离更加清晰。现在，字段<strong class="it hv"> AuthCheckData:data </strong>上的解析器请求模板仍然使用<strong class="it hv"> $ctx.source.id </strong>在“数据”表上查找数据源(因为这是Lambda在有效授权情况下返回的内容)，但是响应模板只是:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="802b" class="mb kt hu lx b fv mc md l me mf">$util.toJson($ctx.result)</span></pre><p id="4012" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个模式的优点是父解析器，<strong class="it hv"> getData() </strong>，本质上“包装”了授权逻辑，只有通过有效性检查时才调用子解析器返回数据。</p><h1 id="ab94" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">只让我的朋友阅读</h1><p id="241d" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">授权的另一个非常常见的用例是，一个实体允许几个其他实体以一对多的方式访问一个资源。在社交媒体应用中，这可能被声明为“仅允许Nadia的朋友查看她的信息”。使用DynamoDB进行建模的典型方式是使用一个“友谊表”在访问实际记录之前进行检查。友谊表会有一个由用户ID和朋友ID组成的组合键。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff mj"><img src="../Images/2c49aadec71b39721f10498ef74a7613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBZmlEsXNDuXmPSNZOHHXA.png"/></div></div></figure><p id="4414" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在DynamoDB中创建一个“朋友”表，主键为<strong class="it hv">用户名</strong>，排序键为<strong class="it hv">朋友</strong>。两者都使用字符串。为了方便起见，还添加了一列<strong class="it hv">有效</strong>，以便您可以快速切换到某人不再是朋友(您也可以随时删除该行)。将该表添加为AWS AppSync数据源，并编辑您的模式，使查询类型为<strong class="it hv"> friendGetData(id:ID！，朋友:串串！)</strong>如下图。</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="c085" class="mb kt hu lx b fv mc md l me mf">type Query {<br/>  getData(id: ID!): AuthCheckData<br/>  friendGetData(id: ID!, friend: String!): AuthCheckData<br/>}</span></pre><p id="c4ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个想法是用户可以访问一个记录，如果他们碰巧是某人的朋友。为了简单起见，我们将传入一个记录的ID，我们希望像以前一样从同一个<strong class="it hv">数据</strong>表中接收该记录，但是首先根据新的<strong class="it hv">朋友</strong>表进行友谊检查。<strong class="it hv"> friendGetData() </strong>的请求模板如下所示:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="0bf6" class="mb kt hu lx b fv mc md l me mf">{<br/>    "version" : "2017-02-28",<br/>    "operation" : "GetItem",<br/>    "key" : {<br/>        "Username" : { "S" : "${ctx.identity.username}" },<br/>        "Friend" : { "S" : "${ctx.args.friend}" }<br/>    }<br/>}</span></pre><p id="2527" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是这个人的朋友，这将从你的表中返回有效的属性。像上一个例子一样，我们将授权逻辑保留在顶级解析器的响应模板中，以保持职责分离。然而，与前两种情况不同的是，“<strong class="it hv"> Friend </strong>”表没有主键“ID ”,所以它不会在源对象中自动传递。由于我们希望在调用子解析器时使用作为参数传递的<strong class="it hv"> id </strong>在“<strong class="it hv">数据”</strong>表中进行键查找，我们还将其添加到响应模板中的上下文对象:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="5b8f" class="mb kt hu lx b fv mc md l me mf">$util.qr($context.result.put("id", "$context.arguments.id"))<br/>#if ($context.result.get("Valid") == "TRUE")<br/>  $util.toJson($context.result)<br/>#else<br/>  $util.unauthorized()<br/>#end</span></pre><p id="7364" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以像在其他示例中一样，通过<strong class="it hv"> $context.source.id </strong>来访问<strong class="it hv"> id </strong>。如果运行查询:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="4105" class="mb kt hu lx b fv mc md l me mf">query friend {<br/>  friendGetData(id:1 friend:"Nadia"){<br/>    data{<br/>      title<br/>      content<br/>    }<br/>  }<br/>}</span></pre><p id="6a39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这对Nadia是朋友的登录用户来说运行成功。</p><h1 id="af30" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">突变</h1><p id="b66a" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">到目前为止，所有的例子都涵盖了概念上的查询，我想展示GraphQL为您提供的操纵授权模式的控件。您也可以将这些技术应用于突变，但是有一个细微的区别，您可能需要在解析器的请求管道中执行条件检查，而不是在响应上执行过滤器。您控制这一点的方式将非常特定于用于您的变异的数据源实现。</p><p id="17d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，AWS AppSync支持几个数据源，包括Amazon DynamoDB，它支持可以由数据库引擎本身评估的<a class="ae jq" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html" rel="noopener ugc nofollow" target="_blank">条件表达式</a>。回想一下本文中展示的模式，其中一个展示了如何将授权元数据从父级传递到子级并做出决策，而不是将所有授权决策“包装”在父级解析器中。如果您的设计使用第一种技术，那么您将无法对数据库操作的响应应用授权逻辑，因为写操作已经发生了。相反，您需要使用数据库引擎的执行标准以及从父解析器传递的元数据。在带有AppSync的DynamoDB解析器中，您可以向解析器请求模板添加类似以下内容的内容:</p><pre class="kg kh ki kj fq lw lx ly lz aw ma dt"><span id="76ba" class="mb kt hu lx b fv mc md l me mf">"operation" : "UpdateItem",<br/>"condition" : {         <br/>  "expression" : "contains(Edit,:canEdit)",<br/>  "expressionValues" : {             <br/>  ":canEdit" : { "S" : "${context.source.canedit}" }<br/>  }<br/>}</span></pre><p id="2514" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面使用了父解析器的所有者，并且在运行时，如果<strong class="it hv">的属性canedit </strong>被传递给子解析器。<a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/security-authorization-use-cases.html#writing-data" rel="noopener ugc nofollow" target="_blank">这里可以找到几个例子</a>。当然，也有可能您的数据库实现不支持这些功能，对这些类型的运行时评估没有性能，或者您的模式设计只是将授权逻辑分离到父类中，在这种情况下仍然可以使用其他方法。</p><h1 id="8c8d" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">额外收获:嘲笑和测试</h1><p id="c68c" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">在构建授权方案时，模拟场景并为多个用户或组测试不同的流程，以了解授权规则在生产中实际上是如何运行的，这可能会很棘手。对于任何将数据返回给客户端的系统，您都应该考虑实现模拟和仿真技术来进行授权。AWS AppSync为此提供了一些不同的<a class="ae jq" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>。首先，AppSync <a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/test-debug-resolvers.html" rel="noopener ugc nofollow" target="_blank">支持完整的测试和调试流程</a>，允许您模拟GraphQL请求&amp;响应上下文。您可以使用它来查看不同场景下的行为，以及在解析器中传递或接收的信息。例如，如果我从AppSync控制台编辑<strong class="it hv"> getData </strong>解析器，并选择<strong class="it hv">选择测试上下文</strong>按钮，我可以创建一个模拟上下文对象来模拟用户以及任何响应。使用前面的Lambda解析器，我将传入<strong class="it hv"> AUTHORIZATION_ERROR </strong>结果来模拟一个未授权的请求:</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/ddfe10d80a3ec3b65f89ff68ac050673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*wlyy2KaM6Z-tik9lp13w2g.png"/></div></figure><p id="a587" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">按下控制台中的<strong class="it hv">测试</strong>按钮将评估请求对象，包括字段和身份信息，以及执行任何条件检查。如果逻辑导致将被打印到屏幕上的未授权请求:</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff ml"><img src="../Images/fbc9f049c87666b6080af66ae36ed057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwbdZOP_WYLOcyJo7KRh-w.png"/></div></div></figure><p id="70a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在模仿你的数据之后，你还可以从AppSync控制台的<strong class="it hv">查询</strong>页面运行这个“直播”，它可以从亚马逊CloudWatch日志中<a class="ae jq" href="https://docs.aws.amazon.com/appsync/latest/devguide/test-debug-resolvers.html#debugging-a-live-query" rel="noopener ugc nofollow" target="_blank">直播结果。但是不要止步于此，控制台还允许您使用Amazon Cognito用户池中的有效用户帐户登录，以执行真正的授权检查:</a></p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/01fbfc6ac16eb28bf53b59746497fed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*8c8ReFt8jR7e-uz31SQ5Ug.png"/></div></figure><p id="0b9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用它来针对用户帐户、组、声明或身份上下文对象的其他属性测试条件规则。</p><h1 id="6dca" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">摘要</h1><p id="e7e4" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">这些只是使用GraphQL和现有的AWS AppSync授权用例及技术的几个例子。一般来说，安全控制可能是一个复杂的主题，因此最好看一看所有选项，并在可能的情况下，从简单的开始，只在您的业务需求发生变化时添加更多选项。</p><p id="120d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">Richard Threlkeld(</em><a class="ae jq" href="https://twitter.com/undef_obj" rel="noopener ugc nofollow" target="_blank"><em class="jp">@ undef _ obj</em></a><em class="jp">)在</em><a class="ae jq" href="https://aws.amazon.com/mobile/" rel="noopener ugc nofollow" target="_blank"><em class="jp">AWS Mobile</em></a><em class="jp">工作，是推出</em><a class="ae jq" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"><em class="jp">AWS app sync</em></a><em class="jp">和</em><a class="ae jq" href="https://github.com/aws/aws-amplify" rel="noopener ugc nofollow" target="_blank"><em class="jp">AWS</em></a><a class="ae jq" href="https://github.com/aws/aws-amplify" rel="noopener ugc nofollow" target="_blank"><em class="jp">Amplify</em></a>的团队的一员</p><p id="b5e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文表达的所有观点均为我个人观点。</p><figure class="kg kh ki kj fq kk"><div class="bz el l di"><div class="mn mo l"/></div></figure></div></div>    
</body>
</html>