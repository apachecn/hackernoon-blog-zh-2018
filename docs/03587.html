<html>
<head>
<title>URL-Shortening Service in Java, Spring Boot and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java、Spring Boot和Redis中的URL缩短服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/url-shortening-service-in-java-spring-boot-and-redis-d2a0f8848a1d?source=collection_archive---------1-----------------------#2018-04-25">https://medium.com/hackernoon/url-shortening-service-in-java-spring-boot-and-redis-d2a0f8848a1d?source=collection_archive---------1-----------------------#2018-04-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="b7f4" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用Java、Spring Boot和Redis从头开始构建URL缩短服务</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/953096282b9da1823e3e87b1abf97a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoJY43Bruijn2mAWyniuGg.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Url Shortening with Java, Spring Boot, and Redis</figcaption></figure><p id="236d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你有没有想过网址缩写是如何工作的？一个奇怪的问题让我看到了几个关于实现的StackOverflow 帖子。出于好奇，我决定实现一个并写下我的经历。</p><p id="cf95" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">今天我们就用<a class="ae kv" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>，Spring Boot，<a class="ae kv" href="https://hackernoon.com/tagged/redis" rel="noopener ugc nofollow" target="_blank"> Redis </a>来搭建一个。对于没有耐心的人，请直接跳到<strong class="kb hv">实现</strong>。拿出你最喜欢的编辑器，跟我来！</p><h1 id="d9e3" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">URL缩写的来源</h1><p id="fcd9" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">第一个URL Shortener是由TinyURL的创始人Kevin Gilbertson在2002年创建的。Kevin对在论坛上发送长链接感到恼火，他决定做些事情来改善他的用户体验。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/6e57aee4160964e8a248541d4c2f30e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*3iJXebP-AonMVuRnpZX2Fg.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Kevin probably did not enjoy sending links like these</figcaption></figure><p id="5b07" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如今，链接缩短不仅用于改善链接共享体验。随着Twitter的发展(有着烦人的140个字符的限制)，URL缩短达到了顶点。2011年，Twitter宣布自动将链接缩短至23个字符。我们并不总是想到网址缩写，但它们在改善我们的在线体验方面发挥了重要作用。</p><h1 id="2be5" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">URL缩短背后的理论</h1><p id="fc2b" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">现在我们已经讨论了URL缩短的起源及其动机，让我们来讨论它们是如何实现的。</p><h2 id="8405" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">编写记录词典</h2><p id="acaa" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">字典解释单词的意思。让我们把这些词定义为“关键”，把这个词的意义定义为“价值”。你们中的一些人可能会问，字典是如何帮助我们缩短URL的？</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mi"><img src="../Images/89cc9d925742ba27f19f42b45e0ea064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8eAiXf6Mk_1qR-klCYq4AA.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Are my URLs shorter yet?</figcaption></figure><p id="d86e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请这样想:</p><ol class=""><li id="7aa7" class="mj mk hu kb b kc kd kf kg ki ml km mm kq mn ku mo mp mq mr dt translated">每次URL Shortener收到要缩短的链接时，它会将该链接保存到字典中，并向请求该URL的个人返回一个短URL。</li><li id="007e" class="mj mk hu kb b kc ms kf mt ki mu km mv kq mw ku mo mp mq mr dt translated">当一个缩短的URL被提供给URL缩短器时，URL缩短器查看字典并检索原始链接。</li></ol><p id="1502" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们直观地看看这个:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mx"><img src="../Images/1a6646472ce99c67b26eb0f5433fb4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkdmskLWL8qj76A2rHWgDA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A visual representation of how URL shortens</figcaption></figure><p id="71d3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">URL缩短程序为它收到的每个请求创建一个新的ID(也称为密钥)。那么URL缩短器如何为它接收到的每个URL创建一个新的密钥呢？嗯…</p><h2 id="c27b" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">唯一密钥生成</h2><p id="6020" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">为了简单起见，让我们假设URL Shortener使用请求号作为字典的键。我们可以使用请求编号，因为我们可以保证每个请求编号都是唯一的(我们不能让请求编号1出现两次)。然后，我们可以通过将请求编号直接转换为缩短的链接来缩短URL:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mx"><img src="../Images/8f9e3803cb080c42e7edccc3dcd945f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgY1ABE-uMqjkTZbcTEx_Q.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">URLs grow so fast sometimes</figcaption></figure><p id="8bb7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，如果许多用户开始使用URL Shortener，这些方法将无法扩展。例如，在撰写本文时，Twitter平均每天有3.3亿用户。即使一小部分用户在一天内发送链接，这种方法也会很快产生比原始链接更长的链接。解决这个问题的一个方法是使用<strong class="kb hv">基转换</strong>将请求数转换成一个更短的表示。</p><h2 id="8fa3" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">使用基本转换缩放URL缩写</h2><p id="d0d2" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">碱基转换是什么意思？基数转换是从不同的数字基数转换数字的过程。我们习惯看到的数字被称为十进制数。基数10仅仅意味着我们有10种方法来表示数字(0-9)。假设来说，我们可以把数字转换成任意的基数。例如，如果我们要使用字母(a-z-A-Z)和数字(0–9)来表示数字，那么我们的基数是62(26个小写字母+ 26个大写字母+10个数字的总和)。使用以下算法，我们可以在基数10和基数62之间进行转换:</p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="2123" class="lu kx hu mz b fv nd ne l nf ng">Let x be the base10_number<br/>While x is greater than 0:<br/>  Take x and divide by 62. Store the remainder and let x = quotient<br/>Take the remainders from bottom-up (Last-In-First-Out)</span></pre><p id="29f6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">使用62进制数，我们可以通过使用下面显示的转换表将每个单独的数字转换成相应的字符来产生一个唯一的ID。观察一个通过基数转换过程将十进制数转换为唯一ID的示例:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nh"><img src="../Images/3b6e78b7283baa484ec1744871f631bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6eQaQX_tIU0zWMgzPnXJQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Base10 conversion of ID 125 to base62</figcaption></figure><p id="a791" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">既然我们已经缩短了URL，检索URL的步骤就更加简单了。我们可以使用下面的算法来获取要从字典中检索的十进制数:</p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="704c" class="lu kx hu mz b fv nd ne l nf ng">Let x represents the length of the shortened url<br/>Let base10_id equal 0<br/>For each character c in the url starting from the first:<br/>  val = value of c from the chart provided above<br/>  base10_id plus(val * pow(62, x))<br/>  Minus x by 1<br/>return base10_id</span></pre><p id="5247" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们看一个这样转换的例子:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nh"><img src="../Images/2615df9e21dc1ceaeaf655d3d3c27d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ySwD5PkIQovLRav98XPTcQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">An example for retrieval of shortened url ABC</figcaption></figure><p id="88bb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">观察我们如何仅用3个字符(ABC)来表示第100，000个请求。使用这种方法将允许我们更好地扩展我们的Shortener。</p><h1 id="b2f0" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">履行</h1><p id="7dae" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">言归正传！让我们先来看看<a class="ae kv" href="https://projects.spring.io/spring-boot/" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>:</p><h2 id="cb31" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">Spring Boot</h2><p id="6a86" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">Spring Boot是一种让Spring应用程序运行的自以为是的方式:它允许我们在短时间内让代码在web上运行。让我们从官方<a class="ae kv" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">网站</a>生成一个Gradle Spring项目开始。请确保将Web添加为依赖项。</p><p id="705c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，让我们将上面介绍的基本转换方法翻译成代码。在<code class="eh ni nj nk mz b">src/java/main/urlshortener.app</code>中创建一个名为<code class="eh ni nj nk mz b">common</code>的包，并创建一个名为<code class="eh ni nj nk mz b">IDConverter.java</code>的Java类</p><h2 id="acca" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">IDConverter.java</h2><p id="463b" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">我们将使用<code class="eh ni nj nk mz b">IDConverter</code>来抽象获取缩短后的URL的惟一ID的逻辑，以及将惟一的URL转换回字典键。因为我们只需要一个<code class="eh ni nj nk mz b">IDConverter</code>的实例，所以让它成为一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank"> Singleton </a>。</p><p id="f093" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">首先，让我们用一个列表和一个散列表来初始化这个类，以映射基数10和62之间的表示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="0f6a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">indexToCharTable</code>代表上述base10到base62示例中的转换图表，而<code class="eh ni nj nk mz b">charToIndexTable</code>代表将缩短的URL转换回字典键的示例中显示的图表。</p><p id="7a87" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，让我们创建一个函数，它接收一个请求号(ID ),并将其转换成一个唯一的URL:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="5e9c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">createUniqueID</code>接受一个id (base10)并使用上面定义的帮助函数将其转换为base62。然后，该函数使用<code class="eh ni nj nk mz b">indexToCharTable</code>转换将base62数字的每个组成部分转换为一个字符，以返回一个唯一的URL。</p><p id="2495" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，让我们创建一个相反的函数:接收一个惟一的URL并返回请求号(id):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="4845" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">getDictionaryKeyFromUniqueID</code>接收唯一的URL ID，并将其转换回base62数字对应项。然后，该函数获取base62数，并执行算法来计算请求数(id)。</p><p id="faeb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，我们将实现字典来存储URL。在此之前，我们先绕道说一下Redis。</p><h2 id="6d20" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">雷迪斯</h2><blockquote class="nn"><p id="ed54" class="no np hu bd nq nr ns nt nu nv nw ku ek translated">Redis是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理</p></blockquote><p id="ef63" class="pw-post-body-paragraph jz ka hu kb b kc nx iv ke kf ny iy kh ki nz kk kl km oa ko kp kq ob ks kt ku hn dt translated">对于服务，我们应该使用数据库来实现持久性。在筛选了从SQL到NoSQL的各种选项之后，Redis似乎是一个很好的选择，因为它能够用作内存中的数据结构。我们需要的字典功能可以从Redis' <code class="eh ni nj nk mz b"><a class="ae kv" href="https://redis.io/commands/hset" rel="noopener ugc nofollow" target="_blank">hset</a></code>获得。</p><p id="28cc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了使用Redis，我们必须首先从<a class="ae kv" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank">官方网站</a>安装它。我强烈建议在继续之前跟随网站上的15分钟教程，以便更好地理解Redis。</p><p id="3d52" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，我们将把Jedis纳入我们的<code class="eh ni nj nk mz b">build.gradle</code>。<br/> Jedis是一个Redis Java客户端:它允许我们直接从Java使用Redis的功能。</p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="8396" class="lu kx hu mz b fv nd ne l nf ng">compile group: 'redis.clients', name: 'jedis', version: '2.9.0'</span></pre><h2 id="67fc" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">URLRepository.java</h2><p id="e0ad" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">接下来，我们将在<code class="eh ni nj nk mz b">src/main/java/urlshortener.app</code>中创建一个名为repository的新包。存储库是一种“封装存储、检索和搜索行为的机制”。抽象数据库细节是一个很好的实践，所以我们将在这里创建<code class="eh ni nj nk mz b">URLRepository</code>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="f3ff" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">@Repository</code>注释允许Spring检测该类，并将其包含在构建路径中。稍后我会更详细地解释这一点。</p><p id="bf75" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这些函数在很大程度上是不言自明的。<code class="eh ni nj nk mz b">incrementID</code>增加一个id(请求编号)并增加它。<code class="eh ni nj nk mz b">saveUrl</code>获取一个密钥和原始url，并使用<code class="eh ni nj nk mz b">jedis.hset</code>将其存储到Redis中。<code class="eh ni nj nk mz b">getUrl</code>获取一个id (key)并使用<code class="eh ni nj nk mz b">jedis.hget</code>从Redis中检索它。</p><p id="23ac" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，让我们在<code class="eh ni nj nk mz b">src/main/java</code>中创建一个服务包，并创建一个Java类<code class="eh ni nj nk mz b">URLConverterService</code>。</p><h2 id="467c" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">URLConverterService.java</h2><p id="93f0" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">我们将使用<code class="eh ni nj nk mz b">URLConverterService</code>通过调用我们之前创建的存储库和助手来抽象缩短URL的请求。<br/>在高层次上，服务应该能够:<br/> 1。获取原始URL并返回一个缩短的URL <br/> 2。获取缩短的URL并返回原始URL</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="71cf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">@Service</code>注释允许Spring将类包含到它的构建路径中。<code class="eh ni nj nk mz b">@Autowired</code>注释允许Spring通过在它的构建路径中查找它所依赖的类(URLRepository)来解析类的依赖性。因为我们已经用<code class="eh ni nj nk mz b">@Repository</code>标记了URLRepository，所以可以自动解析依赖关系。</p><p id="db29" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">shortenURL</code>接受要缩短的URL，调用存储库保存原始URL，并使用基本URL执行字符串操作以返回缩短的URL。<code class="eh ni nj nk mz b">formatLocalURLFromShortener</code>获取用于执行POST请求的URL，并获取主机名和端口号。<code class="eh ni nj nk mz b">getLongURLFromID</code>从URL获取uniqueID，并使用存储库检索原始URL。</p><p id="f413" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">到目前为止一切顺利！下一步将是在网络上提供这种服务。接下来，在<code class="eh ni nj nk mz b">src/main/java/urlshortener.app</code>中创建一个名为controller的包，并创建一个<code class="eh ni nj nk mz b">URLController</code>类。</p><h2 id="cac9" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">URLController.java</h2><p id="6706" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在高层次上，<code class="eh ni nj nk mz b">URLController</code>是我们的web应用程序的入口点。我们希望我们的<code class="eh ni nj nk mz b">URLController</code>做两件事:</p><ol class=""><li id="7789" class="mj mk hu kb b kc kd kf kg ki ml km mm kq mn ku mo mp mq mr dt translated">接收缩短URL的请求，并使用缩短的URL进行响应</li><li id="1635" class="mj mk hu kb b kc ms kf mt ki mu km mv kq mw ku mo mp mq mr dt translated">接收一个缩短的URL，并自动将用户重定向到原始网站</li></ol><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="7420" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">@RestController</code>注释自动为所有带有<code class="eh ni nj nk mz b">@RequestMapping</code>注释的函数添加一个<code class="eh ni nj nk mz b">@ResponseBody</code>注释。这授予他们接收和响应请求的功能。标有<code class="eh ni nj nk mz b">@RequestMapping</code>注释的函数能够响应由注释中的值映射的特定URI。</p><p id="3a44" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">shortenURL</code>功能被映射到<code class="eh ni nj nk mz b">/shortener</code>端点，并对应于由<code class="eh ni nj nk mz b">method</code>参数指示的POST请求。<code class="eh ni nj nk mz b">“consumes”</code>指函数期望接收的请求类型。该函数接收一个<code class="eh ni nj nk mz b">ShortenRequest</code>类和一个<code class="eh ni nj nk mz b">HttpServletRequest</code>作为参数，使用<code class="eh ni nj nk mz b">URLConverterService</code>处理它们并返回一个缩短的URL。我们接受<code class="eh ni nj nk mz b">HttpServletRequest</code>,因为我们需要请求的主机名和端口号，以便执行我们的字符串操作来产生一个缩短的URL。我们可以使用<code class="eh ni nj nk mz b">ShortenRequest</code>作为参数，因为我们将ShortenRequest声明为一个类，并将其标记为<code class="eh ni nj nk mz b">@JsonCreator</code>，从而允许Jackson(一个JSON序列化程序)检测我们的请求并将其转换为一个类对象。这是一个很好的实践，因为它允许我们避免从URL硬编码get请求。</p><p id="a543" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">redirectURL</code>功能映射到<code class="eh ni nj nk mz b">/{id}</code>。这意味着函数被映射到一个动态地址(这是有意义的，因为缩短的URL是惟一的)。然后，该函数使用<code class="eh ni nj nk mz b">@PathVariable</code>注释获取ID，并使用<code class="eh ni nj nk mz b">URLConverterService</code>检索原始URL。最后，我们使用一个<code class="eh ni nj nk mz b">RedirectView</code>将浏览器重定向到原来的URL。</p><p id="71f6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">看起来不错！但是，我们应该处理传递给shortenUrl函数的URL无效的情况。为此，我们将在<code class="eh ni nj nk mz b">src/main/java/urlshortener.app/common</code>中创建一个名为<code class="eh ni nj nk mz b">URLValidator</code>的助手类。</p><h2 id="1465" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">URLValidator.java</h2><p id="3abf" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在缩短URL之前，我们将使用<code class="eh ni nj nk mz b">URLValidator</code>来验证它们。让我们把它做成单例，以确保只有类的实例被共享。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="5125" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">validateURL</code>接收一个URL并将其与正则表达式匹配。如果URL匹配任何被识别为URL的模式，则该函数返回true。</p><p id="2c5f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后我们重构<code class="eh ni nj nk mz b">URLController’s</code> shortenUrl如下:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="ff13" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，我们来创建一个app的入口。在<code class="eh ni nj nk mz b">src/main/java/urlshortener.app</code>中创建一个名为<code class="eh ni nj nk mz b">URLShortenerApplication</code>的类</p><h2 id="c902" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">URLShortenerApplication.java</h2><p id="44ea" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">URLShortenerApplication是我们的Web应用程序的入口点。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="9f7f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ni nj nk mz b">@SpringBootApplication</code>表示该类是应用程序的起点。这将扫描我们的配置并解决类的依赖性。</p><p id="6af3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，我们必须用主类的位置来更新我们的build.gradle。</p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="f0cf" class="lu kx hu mz b fv nd ne l nf ng">mainClassName = "urlshortener.app.URLShortenerApplication"</span></pre><p id="c2ac" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这允许我们使用gradle来构建和运行我们的项目。</p><h2 id="b916" class="lu kx hu bd ky lv lw lx lc ly lz ma lg ki mb mc li km md me lk kq mf mg lm mh dt translated">测试</h2><p id="729a" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">既然基本功能已经完成，我们应该测试它。为了避免文章太长，我将描述如何运行手动测试而不是自动化测试。</p><p id="6e67" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">要运行应用程序，请确保安装了<a class="ae kv" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank"> gradle </a>。首先，在终端中键入<code class="eh ni nj nk mz b">redis-server</code>来启动我们的Redis实例。接下来，在项目所在的终端中键入<code class="eh ni nj nk mz b">gradle build</code>，然后键入<code class="eh ni nj nk mz b">gradle run</code>。</p><p id="4cb1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">一旦运行，我们可以使用<a class="ae kv" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>进行测试。打开Postman，输入URL为<a class="ae kv" href="http://localhost:8080/shortener" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/shortener</a>，切换方法为POST，设置主体为<code class="eh ni nj nk mz b">application/json</code>。以下是Postman应该如何看待这一点的示例:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oc"><img src="../Images/e9eb6c75f15c3c11aa61ac30bb179f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMfpcR0Y9zPGi80hm6OyeA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Set the url to anything you would like to try with</figcaption></figure><p id="fea7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">按Send，我们应该会看到一个字符串形式的URL返回。尝试将该URL粘贴到浏览器中。如果你已经照着教程做了，它应该会成功！</p><p id="ec26" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">作为参考，<a class="ae kv" href="https://github.com/DenimMazuki/URLShortener" rel="noopener ugc nofollow" target="_blank">这里的</a>是程序的完整源代码！</p><h1 id="d560" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">结论</h1><p id="4c46" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">恭喜你走到这一步！我希望你能从这个教程中获得乐趣，并学到一些关于URL缩短的新知识。</p><p id="4ce5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">本教程只是触及了Spring Boot和Redis功能的皮毛。如果你觉得它们有趣，我强烈建议你多花些时间在上面！</p><p id="5c44" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢您的阅读！如果您有任何反馈、问题或者您希望我写的任何未来主题或项目，请随时联系我:)。</p><p id="e9e0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">再见。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="od nm l"/></div></figure></div></div>    
</body>
</html>