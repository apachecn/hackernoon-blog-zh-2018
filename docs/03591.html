<html>
<head>
<title>Lambda Internals: Exploring AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lambda内部:探索AWS Lambda</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lambda-internals-exploring-aws-lambda-462f05f74076?source=collection_archive---------5-----------------------#2018-04-25">https://medium.com/hackernoon/lambda-internals-exploring-aws-lambda-462f05f74076?source=collection_archive---------5-----------------------#2018-04-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c85568f4046f7b97e2e30a4c4c08ad3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OSjYe_IRlfsfJFQ2."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Diving deep down. Photo by <a class="ae jg" href="https://unsplash.com/@taliacohen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Talia Cohen</a></figcaption></figure><p id="f668" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本文是两部分系列的第一部分。下一部分是<a class="ae jg" rel="noopener" href="/epsagon/aws-lambda-internals-part-2-going-deeper-1e12b9d2515f">就在这里！</a></p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><p id="d652" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>是一个快速可伸缩开发的优秀环境。作为一名开发人员，我喜欢使用它。Lambda的主要优势是你可以专注于你的代码。不用再考虑网络服务器、机器、可伸缩性和其他你不关心的问题。上传你的代码，说出咒语(又名无服务器调用)，你的代码就被执行了。但是，你可以忽略那些东西，并不代表你必须要忽略，对吧？</p><p id="a832" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我相信了解您的环境会是一个方便的工具，而且也会很有趣，所以我决定探索Lambda环境。有几个故事回顾了Lambda环境的规范，但我的最终目标是不仅分析Lambda的容器，还要分析Lambda本身的代码。我想完全理解负责执行我的代码的代码。</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff km"><img src="../Images/e00c0a5d631eee7f4d6bbdc08f6609e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIHErwIINhL0eRp1xee4_Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Focus sometimes means blurring out the rest. Is that really what we want? Image:<a class="ae jg" href="https://unsplash.com/@pawelskor" rel="noopener ugc nofollow" target="_blank"> Paul Skorupska</a></figcaption></figure><p id="700c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管我从事了多年的安全研究，我还是决定以开发人员的心态来解决这个问题。为什么？我想更好地了解Lambda，以便更有效地使用它，并从中获得一些乐趣。</p><h1 id="2dbb" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">入门指南</h1><p id="94ae" class="pw-post-body-paragraph jh ji hu jj b jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">为了开始我的研究，我首先必须进入Lambda的容器。此外，我必须找到执行我的Lambda的代码。如果你不关心这个，想直接跳到我发现的内容，你可以跳到<a class="ae jg" href="#931f" rel="noopener ugc nofollow"> Lambda Internals </a>。</p><h2 id="8eef" class="lu ks hu bd kt lv lw lx kx ly lz ma lb js mb mc lf jw md me lj ka mf mg ln mh dt translated">得到一个壳</h2><p id="6993" class="pw-post-body-paragraph jh ji hu jj b jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">我发现获取Lambda容器外壳的最简单方法是使用一个Lambda，它向服务器打开一个反向外壳。让Lambda连接一个有公共IP的服务器的最简单的方法是什么？当然是部署一个有弹性IP的<a class="ae jg" href="https://aws.amazon.com/ec2/" rel="noopener ugc nofollow" target="_blank"> EC2 </a>！谢谢你，亚马逊。</p><p id="d279" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是Lambda的代码:</p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="8629" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我使用netcat: <code class="eh mk ml mm mn b">nc -l 1234</code>在我的EC2上设置了一个监听服务器</p><p id="d73a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我创建了一个包含我的IP和端口的事件(称为event.json ),并使用<a class="ae jg" href="https://serverless.com" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>触发了我的Lambda:</p><pre class="kn ko kp kq fq mo mn mp mq aw mr dt"><span id="020a" class="lu ks hu mn b fv ms mt l mu mv">cat event.json | serverless invoke -f shell</span></pre><p id="7338" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不出所料，我们成功了！</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/c3b83ae1c1b6d83d220fdc83ad0848fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*8VLZ_mMyox1nJ7NGx-WuTA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Simple Lambda shell</figcaption></figure><h2 id="abba" class="lu ks hu bd kt lv lw lx kx ly lz ma lb js mb mc lf jw md me lj ka mf mg ln mh dt translated">下载运行时</h2><p id="7d50" class="pw-post-body-paragraph jh ji hu jj b jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">好吧，得到一个壳很容易。毕竟，Lambda让我们几乎可以做任何我们想做的事情，包括在Lambda中执行bash命令。接下来，我想检查执行我的代码的代码放在哪里，下载它并开始评估它。</p><p id="0acf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我做的第一件事是运行<code class="eh mk ml mm mn b">ps</code>命令来检查哪些进程正在运行:</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/7335cc5326ddee9764a53e355972cd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKN75BN-Ru8Jq80WUgr2Ow.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Process running on a Lambda container</figcaption></figure><p id="e08c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh mk ml mm mn b">ps</code>中，我们可以看到，我们运行的用户可以访问的唯一进程(除了我们从Lambda中调用的shell和<code class="eh mk ml mm mn b">ps</code>)是位于/var/runtime/awslambda中的<a class="ae jg" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> python </a>脚本。这可能就是执行我们代码的脚本！所以我做的下一件事是检查该目录的内容:</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/dbedd386f781d8091de37a9be4a7cfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhnvtNbu3chdJbjFyG8bnQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The content of the /var/runtime and the /var/runtime/awslambda directories</figcaption></figure><p id="ab8a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">目录内容看起来很有前景，就下载吧！如果你的背景和我一样是安全研究，你可以考虑用hex / base64 /将文件打印出来，上传到FTP服务器上，以便获得它们。但是等一下——我们正在AWS上运行！有一个简单得多的方法。</p><p id="548f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我们有内置Lambda的boto3(或者aws-sdk，如果你运行node的话),获取代码最简单的方法就是把它上传到一个<a class="ae jg" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>桶！下面是我用来下载Lambda运行时环境的所有代码的Lambda:</p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="a5d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在创建一个包含bucket名称的事件并执行Lambda之后，我们得到的是:</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/4c6d4758ff1d3e38c6f22ffcd5e48d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQ0CUpfeM_dNVbPHnhdBWg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">AWS S3 interface. We can see the tar we uploaded from the Lambda</figcaption></figure><p id="ffaa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以现在我们有了Lambda的运行时代码。让我们看看我们能从中学到什么。</p><h1 id="931f" class="kr ks hu bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">λ内部构件</h1><p id="0902" class="pw-post-body-paragraph jh ji hu jj b jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">通过快速浏览我们下载的代码和二进制文件，我们已经对系统有了很好的了解。我们接触到管理Lambda执行的三个主要组件:</p><ol class=""><li id="ae76" class="na nb hu jj b jk jl jo jp js nc jw nd ka ne ke nf ng nh ni dt translated">awslambda/bootstrap.py —控制lambda调用的Python包装器。等待第一个触发器初始化Lambda，然后初始化并调用它。之后，进入等待事件和调用Lambda的循环(如果需要，再次初始化模块)</li><li id="31cb" class="na nb hu jj b jk nj jo nk js nl jw nm ka nn ke nf ng nh ni dt translated">AWS lambda/runtime . so—bootstrap . py导入的Python兼容共享对象。充当包含Lambda运行时管理核心的其他共享对象的pythonic接口。</li><li id="1819" class="na nb hu jj b jk nj jo nk js nl jw nm ka nn ke nf ng nh ni dt translated">liblambda*。so——负责IO、IPC、log和Lambda运行时的四个库。最有趣的一个是liblambdaruntime.so，它负责管理Lambda的所有繁重工作:接收触发事件，在Lambda执行开始/停止时向<em class="no">切片器</em>(负责为我们的Lambda分配CPU时间的组件)发送事件，解析X射线的跟踪id等等。</li></ol><p id="43fa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在对系统有了一个大概的了解之后，让我们开始玩我们发现的组件吧！在本文中，我将深入一个利用bootstrap.py满足我们需求的例子。</p><h2 id="5b72" class="lu ks hu bd kt lv lw lx kx ly lz ma lb js mb mc lf jw md me lj ka mf mg ln mh dt translated">检测bootstrap.py</h2><p id="a6b3" class="pw-post-body-paragraph jh ji hu jj b jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">想象一下，你想有一个监控系统，收集你所有的Lambdas，并显示在一个集中的位置。您可能希望在所有调用中将给定格式的附加消息打印到Cloudwatch日志中；或者所有的Lambda在每个Lambda的开头从S3下载一个共享资源。这些只是你必须通过使用函数调用或装饰器在每个Lambdas的开头添加代码的几种情况。</p><p id="7f2c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是如果有其他方法呢？在这里的<a class="ae jg" href="https://epsagon.com" rel="noopener ugc nofollow" target="_blank"> Epsagon </a>，我们开发了一个为无服务器<a class="ae jg" href="https://hackernoon.com/tagged/architecture" rel="noopener ugc nofollow" target="_blank">架构</a>量身定制的监控工具，我们想要找出是否有更好的方法来检测每个Lambda调用。我们的目标是实现100%的调用覆盖率，同时对插装Lambda的现有代码进行最小的更改。</p><p id="e900" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在查看bootstrap.py时，我发现有两个函数依次调用我的Lambda: <code class="eh mk ml mm mn b">handle_event_request</code>和<code class="eh mk ml mm mn b">handle_http_request</code>。我选择把重点放在<code class="eh mk ml mm mn b">handle_event_request</code>上，但是你可以把同样的原则应用到<code class="eh mk ml mm mn b">handle_http_request</code>上。我创建了一个叫做<code class="eh mk ml mm mn b">instrumenter.py</code>的Python模块。在导入时，该模块指示每个Lambda调用在开始时打印一个日志(当然，这可以根据需要进行更改)。</p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="4c70" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是可能的最简单的包装器(例如，应该使用更好的参数处理),但是对于本研究的目的来说，这已经足够了。我做的下一件事是定义一个简单的Lambda来导入这个库:</p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="e016" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">而且成功了！</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff np"><img src="../Images/e10fbe0737987aa746e83357fd94e41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ylt0s_j0rt7FOmq1UnuldA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Our wrapper instrumented the Lambda invocation and added the log</figcaption></figure><p id="ee8a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种新方法允许库跟踪和处理Lambda调用，只需对代码做很小的修改:一行<code class="eh mk ml mm mn b">import</code>！这对我们Epsagon非常有用，希望对其他人也是如此。</p><h2 id="4206" class="lu ks hu bd kt lv lw lx kx ly lz ma lb js mb mc lf jw md me lj ka mf mg ln mh dt translated">结论</h2><p id="17ee" class="pw-post-body-paragraph jh ji hu jj b jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka lt kc kd ke hn dt translated">探索Lambda内部既有趣又有成效。我们设法在Lambda的容器上执行命令，下载Lambda的运行时环境，甚至检测任何Lambda调用！我将继续探索Lambda的环境，接下来深入研究二进制库。如果你想阅读更多关于无服务器的话题，请告诉我，敬请关注！</p><p id="1727" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是<a class="ae jg" href="https://github.com/epsagon/lambda-internals" rel="noopener ugc nofollow" target="_blank">链接</a>到一个开源项目，包含我在探索中使用的所有代码。对于整篇文章中的大多数例子，我使用Python，但是在项目中也有一些匹配的Node.js实用程序。如果你觉得有用，请告诉我！</p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="nq mj l"/></div></figure></div></div>    
</body>
</html>