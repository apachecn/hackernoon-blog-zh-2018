<html>
<head>
<title>Creating a Progressive Web App with a Headless CMS — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无头CMS创建渐进式Web应用程序——第3部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-progressive-web-app-with-a-headless-cms-part-3-a6bb538084?source=collection_archive---------18-----------------------#2018-04-25">https://medium.com/hackernoon/creating-a-progressive-web-app-with-a-headless-cms-part-3-a6bb538084?source=collection_archive---------18-----------------------#2018-04-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e3675097942b4c0a1c6be088f9724b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Exgo3UD4nuQqA2eCujfOoQ.jpeg"/></div></div></figure><p id="1da2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-1-85ede9dba59b" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第一部分</strong> </a> <strong class="je hv"> | </strong> <a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-2-88ffee198ff6" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第二部分</strong> </a> |第三部分</p><p id="e58f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">欢迎学习第3部分！如果你没有关注这个系列，我已经使用一个无头CMS创建了一个渐进式Web应用程序(PWA)。而且激动的心情已经无法忍受了！一直有悬念！戏剧！开拍！浪漫？是的，我们已经在第1部分和第2部分中看到了很多，所以是时候通过下一个令人兴奋的部分来继续这个系列了。抓住牛奶球。</p><p id="3a0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在前两篇文章中，我介绍了创建PWA的基础知识以及如何将一个无头CMS集成到组合中。我概述了PWA架构，详细介绍了一些重要的组件，并向您展示了如何创建一个工作示例。因为pwa都是关于提供动态体验的，所以提取和显示内容是一件非常重要的事情。如何以及何时获取内容同样重要，所以我想分解一下如何在应用程序中缓存内容。看到了吗？我告诉过你这会变得更加令人兴奋。</p><h1 id="4482" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为什么要缓存？</h1><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kz"><img src="../Images/8e951e05fba41044a84f3477d82be4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ou0WCvYN67oOH82w7h52Wg.jpeg"/></div></div></figure><p id="685b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您曾经构建过使用第三方服务的应用程序，您会知道这不会使用魔法来实现。当系统通信时，总是有API来回调用。这可能意味着提取数据，验证信息，或者记录你刚刚点的拿铁的味道。关键是，当用户与你的应用程序交互时，这种交流会很快增加。学习如何明智地打这些电话将有助于你的应用程序更好地运行，并防止公司知道你的一举一动。</p><p id="6ef1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到处都在使用缓存来减少调用和提高速度。但是，这是有代价的，因为当显示数据时，缓存的数据必须仍然有效。对于少数幸运的人来说，这意味着你可以缓存应用程序的每个方面，并获得惊人的加载时间。对于我们其余的人来说，需要做一些计划来决定什么是最有意义的。因为有太多的方法可以进行缓存，所以选择过程可能会令人望而生畏，尤其是当您发现您将根据数据使用不同的技术时。</p><p id="ca69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">什么是最适合你的应用程序的解决方案完全取决于你。请记住，缓存在PWA中可以(应该)发挥多大的作用，以帮助它尽可能平稳地运行。这一切都是为了给用户一个很好的体验，并提供最相关的内容。</p><h1 id="fa7d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">缓存解决方案</h1><p id="fa21" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">说到缓存，您可以利用许多现有的库，或者开发自己的库。如果你真的喜欢使用底层组件(或者喜欢Crossfit ),那就自己动手为你的应用程序做一个可爱的新解决方案(同时翻转轮胎或其他东西)。如果您像我一样，那么您可能更倾向于利用现有的库来完成繁重的工作。只要做好功课，找到最符合你需求的解决方案。</p><p id="a2f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Google Offline Cookbook 是学习PWAs中缓存的一个很好的资源。我强烈建议您查看它，了解流程工作流、场景，并深入了解数据如何在您的应用程序中移动。</p><p id="2872" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">阅读更多关于谷歌离线食谱</strong> </a></p><p id="be56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的打包演示，我们选择了<strong class="je hv">工具箱</strong>。Workbox是一个JS库，为PWAs和其他应用程序提供离线支持。通过预缓存，Workbox允许您从内存中快速加载代码的各个方面，同时定义何时从外部源中检索哪些区域。更好的是，它用最少的代码和配置做到了这一点，使实现变得轻而易举。所以，赢/赢，对吧？</p><p id="6bda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developers.google.com/web/tools/workbox/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">阅读更多关于工具箱的信息</strong> </a></p><h1 id="a0f2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">缓存策略</h1><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/9b84eb669172824d58e0efd89ad048b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ImTEATVn6oNzMlVL.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">NetworkFirst process (from the Google Offline Cookbook)</figcaption></figure><p id="adc0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那些多重缓存方法？是的，大约有十亿种，这取决于您的平台、库、组件和喜欢的颜色。无论选择哪种类型，PWAs都要记住缓存的“类型”。以下是最常见选项的简要概述:</p><p id="ed6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">cache first</strong>T14】从缓存中取。如果不可用，从网络中获取并更新缓存。</p><p id="3255" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> CacheOnly </strong> <br/>只从缓存中取，不从网络中取。</p><p id="64ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">network first</strong>T20】从网络中获取。如果失败，那么从缓存中获取。</p><p id="873c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> NetworkOnly </strong> <br/>只从网络上取，从不从缓存中取。</p><p id="cb4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">stalewhirelvalidate</strong><br/>从两者中提取。如果可用，从缓存返回。如果不成功，从网络返回并更新缓存。</p><p id="1241" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://developers.google.com/web/tools/workbox/reference-docs/latest/workbox.strategies" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">阅读更多关于缓存方法的内容</strong> </a></p><p id="b40f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您将在开发的不同阶段使用一些(如果不是全部),这取决于您如何组织数据和应用程序。请务必仔细阅读每个选项，准确理解如何处理请求，以便您的应用程序按照您的要求执行。</p><p id="54bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的演示中，我们有两种不同类型的内容。</p><p id="5c9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">1.AppShell(图像、样式、标题等。)</p><p id="cb27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.来自Kentico Cloud的兴趣点内容</p><p id="e4bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们的“主”文件很少改变，所以我们选择了<strong class="je hv"> CacheFirst </strong>选项。这将从缓存中加载我们的<strong class="je hv"> AppShell </strong>和支持文件(在第一次加载之后),以便快速显示界面。看到这些文件很少被修改，这是最有意义的，并给了我们很大的加载时间。</p><p id="fb9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的兴趣点内容，我们将使用<strong class="je hv"> Kentico Cloud API </strong>加载这些内容。因为这些信息会经常变化，所以这些内容需要更加动态。为了满足这一需求，我们采用了<strong class="je hv">网络优先</strong>策略。该选项允许应用程序始终从我们的Kentico云项目加载最新信息。如果网络因为任何原因中断，我们将会回到缓存版本。</p><h1 id="f4c1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">服务行业人员</h1><p id="7156" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">无论您选择哪种缓存方式，您的旅程都将从您的服务人员开始。作为通信的<a class="ae ka" href="http://marvel.com/universe/Heimdall#axzz5CxRSzyKT" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Heimdal </strong> </a>，您的服务人员将在那里注册您的缓存并确定何时调用它。因为你的服务人员是应用程序和互联网之间的代理，它可以拦截每一个请求。它可以访问您实现的缓存存储库，并使所有组件协同工作。让冰霜巨魔远离彩虹桥，进入他们自己的社区。</p><h1 id="ff87" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">缓存打包</h1><p id="88f5" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">现在您已经了解了使用PWAs进行缓存，让我告诉您我们是如何在我们的打包示例应用程序中实现它的。如果您一直在关注这个系列，您可能还记得在我们的<strong class="je hv"> service-worker.js </strong>文件中有很多代码，用于定义立即缓存哪些文件，以及何时缓存对Kentico Cloud API的调用。Workbox 通过将所有东西打包到一个预建的库中来处理所有的代码。这使得配置超级简单和干净，同时提供相同的功能。</p><p id="eab0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们将workbox插件添加到我们的<strong class="je hv"> package.json </strong>文件中。</p><pre class="la lb lc ld fq lo lp lq lr aw ls dt"><span id="bb3a" class="lt kc hu lp b fv lu lv l lw lx">“devDependencies”: {<br/>   …<br/>   “workbox-webpack-plugin”: “³.0.1”<br/>},</span></pre><p id="b0e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们在节点应用程序中注册了Workbox。在我们的<strong class="je hv"> webpack.config.js </strong>文件中，我们添加了一个新的<strong class="je hv">常量</strong>和对<strong class="je hv">工具箱插件</strong>的引用。这包括缓存匹配一组扩展名的文件的代码。这取代了以前版本应用程序中服务工作者文件中的<strong class="je hv"> AppShell </strong>文件定义。<strong class="je hv">工具箱</strong>还处理<strong class="je hv"> AppShell </strong>文件的版本控制。</p><pre class="la lb lc ld fq lo lp lq lr aw ls dt"><span id="de91" class="lt kc hu lp b fv lu lv l lw lx">const workboxPlugin = require(‘workbox-webpack-plugin’);</span><span id="06ea" class="lt kc hu lp b fv ly lv l lw lx">new workboxPlugin.InjectManifest({<br/>   swSrc: ‘./src/public/service-worker.js’,<br/>   globDirectory: ‘./src/public/’,<br/>   globPatterns: [‘**/*.{html,js,css,svg,png,ico,woff,woff2,ttf}’],<br/>});</span></pre><p id="5cf2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的<strong class="je hv"> serviceworker.js </strong>文件中，我们定义了如何缓存对Kentico Cloud API的调用。我们向API注册了具体的路由，并选择了<strong class="je hv"> networkFirst </strong>选项。这段代码取代了之前版本应用程序中的<strong class="je hv"> addEventListener </strong>代码。这要简单得多，因为默认情况下，监听器的注册是由<strong class="je hv"> Workbox </strong>处理的。</p><pre class="la lb lc ld fq lo lp lq lr aw ls dt"><span id="0332" class="lt kc hu lp b fv lu lv l lw lx">if (workbox) {<br/>   console.log(`Yay! Workbox is loaded 🎉`);<br/>   workbox.routing.registerRoute(<br/>      /https:\/\/deliver\.kenticocloud\.com\/66ab95de-6599–0018-f141–3c9dc08fe797\/items/,<br/>      workbox.strategies.networkFirst()<br/>   );<br/>   workbox.precaching.precacheAndRoute(self.__precacheManifest || []);<br/>} else {<br/>   console.log(`Boo! Workbox didn’t load 😬`);<br/>}</span></pre><h1 id="703b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">测试</h1><p id="df1f" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">注册并配置好<strong class="je hv">工具箱</strong>后，您应该准备好测试您的PWA了。对于我们的演示，我们在本地启动了站点，并确认了站点加载正确。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/ccd63e008cb4b39b1d6077ae1e7ae515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_0AUbluvUPSgNY8Hun9IA.png"/></div></div></figure><p id="27a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看<strong class="je hv"> Chrome开发者工具</strong>，我们可以看到<strong class="je hv">工具箱</strong>正在被注册并正确缓存响应。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/7212ae8badaedde628ee32a3f6b8a419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Apge6BIUfrtdRetFNv_7QA.png"/></div></div></figure><p id="0a0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们将该网站部署到Azure应用服务中，并在那里进行测试。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/5fa6db1d6e8bbb5d1bd9419556c44f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mr4T-IYRPwbFPpnEa4J68A.png"/></div></div></figure><p id="9a73" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想看现场演示，请访问我的网站。</p><p id="f4b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想看完整的代码，可以查看一下<strong class="je hv"> Kentico Cloud Pack和Go GitHub项目</strong>。确保使用我们今天讨论的<strong class="je hv"> v2缓存</strong>分支。我们将继续用新的特性更新这个项目，我们将在以后的文章中介绍这些特性。</p><p id="82ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/Kentico/cloud-sample-pwa-app/tree/v2-caching" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">查看Kentico Cloud Pack and Go GitHub项目</strong> </a></p><h1 id="b5bd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">包扎</h1><p id="49ee" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">构建一个在任何情况下都表现出色的应用程序是一个巨大的挑战。您必须考虑用户的环境、连接、偏好和许多其他因素。通过利用PWAs中的缓存，您可以确保快速正确地加载内容。这将提高用户满意度，并减少系统间的呼叫。</p><p id="13ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我还向您展示了Kentico Cloud的许多强大功能。通过使用这种无头CMS，您可以集中您的内容，并利用技术无关的API将它交付到您需要的任何地方。这有助于您在任何语言中以您想要的方式构建应用程序，同时为您的编辑人员提供出色的内容管理体验。</p><p id="ca30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://kenticocloud.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">了解更多关于Kentico Cloud </strong> </a></p><p id="d771" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章总结了我关于用一个无头CMS创建一个渐进式Web应用程序的系列文章。我希望您学到了很多关于这种令人兴奋的新开发技术的知识。有了它，你可以为你的观众建立一个惊人的用户体验，不管他们的平台。</p><p id="7f94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的打包PWA，我们有大计划！寻找未来关于过渡到Angular、添加搜索和其他利用应用程序的设备功能的博客。下次见！</p><p id="8d7d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-1-85ede9dba59b" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第一部分</strong> </a> <strong class="je hv"> | </strong> <a class="ae ka" href="https://hackernoon.com/creating-a-progressive-web-app-with-a-headless-cms-part-2-88ffee198ff6" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">第二部分</strong> </a> |第三部分</p></div></div>    
</body>
</html>