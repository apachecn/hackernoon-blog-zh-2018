<html>
<head>
<title>How We Streamlined Serverless Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何简化无服务器测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-we-streamlined-serverless-testing-8f5e0bbdc7e5?source=collection_archive---------19-----------------------#2018-04-25">https://medium.com/hackernoon/how-we-streamlined-serverless-testing-8f5e0bbdc7e5?source=collection_archive---------19-----------------------#2018-04-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d8dfe434b1b071c95d88d40cd374343a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x26QEuZjUtIYzwk4z3x5bQ.png"/></div></div></figure><p id="b76b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt ka translated"><span class="l kb kc kd bm ke kf kg kh ki di">如果</span>这不是你第一次听说<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>和<a class="ae kj" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>的话，你可能已经见过<a class="ae kj" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>控制台中的橙色测试按钮，当你想在你的无服务器项目中使用第三方依赖时，或者如果你上传的包的大小大于某个大小限制时，它就变得无用了。</p><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/b3f08a88b2a579f10878cc77fe536cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*u9h62AaNaTAwLdbRs3TduA.png"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">AWS Lambda Test Button</figcaption></figure><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kt"><img src="../Images/8f97a3d16aea499221106a6cfa75b0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HY7j9NP_0ogeNaRqSNAIw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Okay. 🙄 Thanks for the information!</figcaption></figure><p id="a69b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于这个<strong class="je hv">完全打破了开发者</strong>的节奏，对于<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>我们建立了一个测试按钮，它看起来&amp;表现有点不同。</p><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/729dc2fdb30290d58c39047f2bd2ec28.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*hXJOTedUtNgqJvlQMU9gCg.png"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Sigma’s Test button</figcaption></figure><p id="4854" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个按钮，</p><ul class=""><li id="383a" class="kv kw hu je b jf jg jj jk jn kx jr ky jv kz jz la lb lc ld dt translated">作品<strong class="je hv">更快</strong>！</li><li id="23fe" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">当你想添加依赖项时，不会变得无用。</li><li id="45ae" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">当你的lambda代码更大的时候不会变得没用。</li><li id="381c" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated"><strong class="je hv">对于代码变更&amp;运行时异常，尽量避免冷启动。</strong></li><li id="9c8c" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">允许您更有效地管理测试事件。</li></ul><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/1fa0bbd9075a84969eb03207e5c5fc94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KrrdykMPjyR2P9PGNMUPuQ.gif"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Testing Your Code in Sigma</figcaption></figure><p id="76ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们通过利用我在《》中提到的简单技巧的基本概念，</p><div class="lk ll fm fo lm ln"><a href="https://hackernoon.com/writing-a-self-sufficient-aws-lambda-function-da6c0586f48c" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">编写自给自足的AWS Lambda函数</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">如果你已经浏览了SLAppForge的新闻文章和博客，你可能已经知道那群…</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">hackernoon.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb ja ln"/></div></div></a></div><h2 id="c562" class="mc md hu bd me mf mg mh mi mj mk ml mm jn mn mo mp jr mq mr ms jv mt mu mv mw dt translated"><strong class="ak">在</strong> <a class="ae kj" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> AWS </strong> </a>上部署测试环境</h2><p id="356d" class="pw-post-body-paragraph jc jd hu je b jf mx jh ji jj my jl jm jn mz jp jq jr na jt ju jv nb jx jy jz hn dt translated">为了实现上述所有功能，<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>在用户首次注册时在<a class="ae kj" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>上创建了一个测试环境。这个测试环境主要有三个主要组件。</p><ol class=""><li id="f6d9" class="kv kw hu je b jf jg jj jk jn kx jr ky jv kz jz nc lb lc ld dt translated"><em class="nd">依赖下载器</em>λ函数</li></ol><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/730db6525a30a4d06c747edf4c88726d.png" data-original-src="https://miro.medium.com/v2/resize:fit:156/format:webp/1*JoEjTvUhZm-IcpHOt4Nsmg.png"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Dependency Downloader</figcaption></figure><p id="3097" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个lambda负责处理所有的节点依赖关系更新。稍后，我将详细解释这个函数的功能。</p><p id="b4e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.<em class="nd">测试转轮</em>λ</p><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/af82c6b2dbded655ca47d99afca61953.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*gsJBPldK-PkBQXgt1Xg4qQ.png"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Test Runner Lambda</figcaption></figure><p id="85fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个lambda将被<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a> IDE直接调用来执行项目lambda文件上的测试事件。</p><p id="f37e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3.代码桶</p><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/e4edc3810add1490e48332adf81589f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:156/format:webp/1*-EifQ44Q1dZW0M_zhwjWgg.png"/></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Code Bucket</figcaption></figure><p id="3098" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个桶将被<em class="nd">依赖下载器</em> Lambda直接用来保存下载的依赖项，并被<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a> IDE的<em class="nd">测试服务</em>用来保存项目的源文件。</p><h2 id="bc1b" class="mc md hu bd me mf mg mh mi mj mk ml mm jn mn mo mp jr mq mr ms jv mt mu mv mw dt translated">处理相关性更新</h2><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/ed0de8df7adbbf7f9f3892f51dec8409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCrMCWMUDPpyk9NdhuSlfg.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Dependency Update Flow</figcaption></figure><p id="d1a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与其他<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>框架不同，在<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>中，添加依赖项并不是一个痛苦的过程。</p><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/67146042c099657f93424040e76d1faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*t4Q62dzHT37hBjG8k4WYBA.gif"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Adding a dependency in Sigma</figcaption></figure><p id="682e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你给项目添加了一个依赖项，<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>会在后台把这个更新发送给<em class="nd">依赖下载器</em>函数<strong class="je hv">，它已经部署在你自己的AWS账户</strong>中。</p><p id="97cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nd">依赖下载器</em>请求的有效载荷采用以下格式。</p><pre class="kl km kn ko fq ni nj nk nl aw nm dt"><span id="ed81" class="mc md hu nj b fv nn no l np nq">{<br/>        "project": "${projectName}",<br/>        "bucketName":"${bucketName}",<br/>        "dependencies": {<br/>             "dependency1": "version1",<br/>             "dependency2": "version2",<br/>             "dependency3": "version3",<br/>         }<br/>}</span></pre><p id="6132" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nd">依赖下载器</em>使用上述事件负载的<em class="nd">依赖</em>属性在其容器的/tmp/{project_id}目录下创建一个package.json文件。</p><blockquote class="nr ns nt"><p id="45e6" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">对于每个lambda容器(函数的每个实例),在/tmp目录下可以获得512MB的可写非持久磁盘容量。</p></blockquote><p id="3ef2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后执行带有<a class="ae kj" href="https://docs.npmjs.com/misc/config#prefix" rel="noopener ugc nofollow" target="_blank">前缀标志</a>的npm命令，将依赖项下载到<strong class="je hv">/tmp/{ project name }/node _ modules</strong>目录</p><pre class="kl km kn ko fq ni nj nk nl aw nm dt"><span id="8965" class="mc md hu nj b fv nn no l np nq">npm --prefix /tmp/projectName install /tmp/projectName</span></pre><blockquote class="nr ns nt"><p id="0fab" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">由于这个lambda并发地没有其他事情要做，我们使用<a class="ae kj" href="https://nodejs.org/api/child_process.html#child_process_child_process_execsync_command_options" rel="noopener ugc nofollow" target="_blank"> syncExec </a>函数来产生所有子进程。</p></blockquote><p id="fa79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦<a class="ae kj" href="https://nodejs.org/api/child_process.html#child_process_child_process_execsync_command_options" rel="noopener ugc nofollow" target="_blank"> syncExec </a>返回到父进程，<a class="ae kj" href="https://www.npmjs.com/package/archiver" rel="noopener ugc nofollow" target="_blank"> archiver </a>用于生成一个新创建的<em class="nd"> node_modules </em>目录的zip文件。</p><p id="acd7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">生成的归档文件(<em class="nd"> node_modules.zip </em>，然后上传到您的<a class="ae kj" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>帐户中的S3存储桶(<em class="nd">代码存储桶)</em>，密钥为{projectName}/node_modules.zip</p><blockquote class="nr ns nt"><p id="9ff6" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">在S3什么是钥匙？</p><p id="a5f2" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">当您创建一个对象时，您指定一个键名，该键名唯一地标识存储桶中的对象。<a class="ae kj" href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html" rel="noopener ugc nofollow" target="_blank">阅读更多</a>。</p></blockquote><h2 id="9443" class="mc md hu bd me mf mg mh mi mj mk ml mm jn mn mo mp jr mq mr ms jv mt mu mv mw dt translated">测试项目功能代码</h2><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/15980928daf19f1d3f3c027cf1f39b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XrZ8wwsKnHwjhG9t8p_rw.png"/></div></figure><p id="f0f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当用户点击▶️按钮时，以下事情按顺序发生。</p><ol class=""><li id="c7ba" class="kv kw hu je b jf jg jj jk jn kx jr ky jv kz jz nc lb lc ld dt translated"><strong class="je hv">调用<em class="nd">调用功能</em>命令</strong></li></ol><p id="3b15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>的测试服务接收<em class="nd">测试事件</em>的有效载荷，以及要调用的lambda函数的名称。</p><p id="43d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2/3。检查源代码差异&amp;更新差异</strong> <a class="ae kj" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> S3 </strong> </a></p><p id="26ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">测试服务定期在<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>编辑器中检查源javascript文件的更新。如果发现更新的文件，它将该文件标记为<em class="nd">已更新</em>，并等待任何其他后续更新。如果它在一段时间内没有看到任何后续更新，该特定文件的内容将被推送到<a class="ae kj" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>(代码桶)。</p><p id="bc91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除此之外，当一个测试事件被调用时，它会立即检查项目中的所有JS文件是否有更新，如果有任何更新，它会立即将它们推送到<a class="ae kj" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>。由于我上面提到的定期更新检查，在大多数情况下，在测试调用时检测到的更新文件的数量将是1。</p><p id="49e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">源文件将被上传到关键字为{projectName}/{fileName}的<a class="ae kj" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>。因此，这将在<a class="ae kj" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>中创建项目文件结构的镜像。</p><p id="ba51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 4。调用测试运行器</strong></p><p id="5fd5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一步，<em class="nd">测试服务</em>向测试事件&amp;发送要调用的Lambda文件的名称给<em class="nd">测试运行程序</em> Lambda。该调用的有效负载采用以下格式。</p><pre class="kl km kn ko fq ni nj nk nl aw nm dt"><span id="1a70" class="mc md hu nj b fv nn no l np nq">{<br/>        "project": "${projectName}",<br/>        "type": "RUN",<br/>        "lambda": "${path of file relative to the project root}",<br/>        "bucketName":"${bucketName}",<br/>        "testEvent": ${event}<br/>}</span></pre><p id="48a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 5。检查代码更新</strong></p><p id="3d0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nd">测试运行器</em>函数通过检查前缀为{projectName}的<a class="ae kj" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>对象的ETag来检查代码更新。</p><blockquote class="nr ns nt"><p id="61ff" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">ETag是什么？</p><p id="43a5" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">在AWS S3中，实体标签是对象的散列。ETag只反映对象内容的变化，不反映其元数据。ETag可能是也可能不是对象数据的MD5摘要。</p></blockquote><p id="cc57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，带有更新内容的源文件被下载到lambda容器的/tmp/{projectName}目录中。</p><blockquote class="nr ns nt"><p id="685e" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">对于每个lambda实例，您会在lambda容器的/tmp 位置获得一个<strong class="je hv">512 MB的非持久空间。</strong></p></blockquote><p id="90c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同时；<em class="nd">测试运行程序</em>生成(或更新)一组{FileName:ETag}元组，并将其分配给在<em class="nd">测试运行程序</em>函数中声明的一个全局变量。因为只要lambda容器运行，全局变量的值就会被保留，所以这些值在下一次测试调用中也是可用的。因此，在即将到来的调用中应该下载的文件数量将被最小化。</p><p id="b1cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一步的最后，<em class="nd">测试运行程序</em>将在容器的/tmp/{projectName}目录中拥有一个完全相似的项目文件结构副本。</p><p id="fc5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 6。检查依赖性更新</strong></p><p id="236c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在{ S3 bucket }/{ project name }/node _ mdoules . zip中已经有了项目的依赖包。</p><p id="9169" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Test Runner应用上面解释的相同过程来检查node_modules.zip自上次调用以来是否有任何更新。</p><p id="dfa3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果在node_modules.zip的Etag中发现任何不匹配，<em class="nd"> Test Runner </em>会下载node_modules.zip并将其提取到lambda容器的/tmp/{projectName}中。</p><blockquote class="nr ns nt"><p id="c4d3" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated">与依赖下载器功能不同，上述步骤5和6同时发生，所有S3获取操作也同时执行。</p></blockquote><p id="7c96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 7。调用lambda函数</strong></p><p id="2398" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在以上6个步骤的最后，在lambda容器的/tmp/{projectName}目录中，我们有了一个功能完整的node.js项目，其中包含所有必需的依赖项。</p><p id="3fac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nd">测试运行程序</em> Lambda现在调用预期的Lambda处理程序，如下所示。</p><figure class="kl km kn ko fq iv"><div class="bz el l di"><div class="ny nz l"/></div></figure><p id="5085" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有必要用try/catch块包装上述处理程序调用，以便在出现运行时异常时保留<em class="nd">测试运行器</em> lambda容器实例。</p></div><div class="ab cl oa ob hc oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="hn ho hp hq hr"><p id="162b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了上述类型为<em class="nd"> RUN </em>的事件外，<em class="nd"> Test Runner </em> lambda还支持另一种事件类型，<em class="nd"> WARM_UP </em>。</p><pre class="kl km kn ko fq ni nj nk nl aw nm dt"><span id="ab6c" class="mc md hu nj b fv nn no l np nq">{<br/>       "project": "${projectName}",<br/>       "type": "WARM_UP",<br/>       "bucketName":"${bucketName}",<br/>       "testEvent": {}<br/>}</span></pre><p id="2352" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>定期向<em class="nd">测试运行器</em>发送预热事件<em class="nd">、</em>以保持其容器更热。除了保持容器更热之外，在这种情况下；<em class="nd">测试运行程序</em>执行上面的第5步和第6步，以使/tmp目录与项目保持同步。</p><p id="a2ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">甚至在执行了依赖项更新之后，<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>向<em class="nd">测试运行器</em>发送一个预热请求，通过保持容器准备好依赖项，<em class="nd"> </em>使<em class="nd">更快地运行</em>事件。</p><p id="9807" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在大多数测试调用中，<em class="nd">测试运行器</em> lambda可以跳过上面的第6步，因为WARM_UP请求做了大量的工作。</p></div><div class="ab cl oa ob hc oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="hn ho hp hq hr"><blockquote class="nr ns nt"><p id="0da4" class="jc jd nd je b jf jg jh ji jj jk jl jm nu jo jp jq nv js jt ju nw jw jx jy jz hn dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>，在应用层，避免并行<em class="hu">测试运行程序</em>调用，以防止AWS产生<em class="hu">测试运行程序</em>的多个实例。这使得每个后续的测试调用非常快。然而，这并不是一个有保证的行为。如果AWS通过偶然的并发调用产生了一个额外的容器，适马将会经历一个冷启动延迟，仅仅是因为一个单独的测试调用。但是这种情况很少发生。</p></blockquote><p id="d534" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我们如何<strong class="je hv">精简</strong> <a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">无服务器</strong> </a> <strong class="je hv">测试</strong> &amp;如果你和我一起走了这么远，你可能会想知道<a class="ae kj" href="https://sigma.slappforge.com/" rel="noopener ugc nofollow" target="_blank">适马</a>是什么。所以这是了解适马的最好时机！！</p><h1 id="92b4" class="oh md hu bd me oi oj ok mi ol om on mm oo op oq mp or os ot ms ou ov ow mv ox dt translated">什么是<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>？</h1><p id="b5c8" class="pw-post-body-paragraph jc jd hu je b jf mx jh ji jj my jl jm jn mz jp jq jr na jt ju jv nb jx jy jz hn dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>于2018年2月6日在<a class="ae kj" href="http://www.srilanka.travel/" rel="noopener ugc nofollow" target="_blank">斯里兰卡</a>的<a class="ae kj" href="https://www.slappforge.com/" rel="noopener ugc nofollow" target="_blank">斯拉普佛格</a>诞生，其设计&amp;的愿景是让<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>开发者的生活更轻松。</p><p id="d745" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你对适马很陌生，让我给你简单介绍一下。</p><p id="8a73" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>是一个让<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>开发更加顺畅的工具。</p><ul class=""><li id="a5b7" class="kv kw hu je b jf jg jj jk jn kx jr ky jv kz jz la lb lc ld dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>不是一个老式的命令行工具。</li><li id="b046" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">你不必在你的电脑上安装适马。</li><li id="2856" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">适马完全在你的浏览器上运行(因为chrome不是世界上唯一的浏览器，我们支持所有现代的网络浏览器)。</li><li id="de97" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>给你现代集成开发环境(IDE)的丰富体验。</li><li id="cae9" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>自动更新。</li></ul><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oy"><img src="../Images/1e02caa0b5f22fc4817ef0df9170a488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4sjAHj96yUOB3MYdlwGTYw.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">You won’t see this in Sigma.</figcaption></figure><ul class=""><li id="cfb1" class="kv kw hu je b jf jg jj jk jn kx jr ky jv kz jz la lb lc ld dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>为你生成代码(API调用其他<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>服务)。这样开发者就不用费心去阅读API文档了。</li><li id="addb" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated"><a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>为你管理资源(资源= DynamoDB表，AWS中的S3桶等)。</li></ul><p id="0179" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谈到<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>开发，<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>提供从头开始部署无服务器应用所需的一切。我们的主要目标是让您在同一个浏览器选项卡中从头到尾开发您的应用程序。</p><p id="400b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是关于适马的，既然我们已经谈论了适马的测试框架，让我给你介绍测试框架的其他组件，让你的生活更轻松。</p><h1 id="6a33" class="oh md hu bd me oi oj ok mi ol om on mm oo op oq mp or os ot ms ou ov ow mv ox dt translated">适马测试框架的组成</h1><h2 id="2f87" class="mc md hu bd me mf mg mh mi mj mk ml mm jn mn mo mp jr mq mr ms jv mt mu mv mw dt translated">测试事件管理器</h2><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oz"><img src="../Images/01698eaa2007cdc4c1a563387b97c70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZqYvfgXVUptDwK7O1uC5Q.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Sigma Test Event Manager</figcaption></figure><p id="a121" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">适马的测试活动管理器让您能够，</p><ul class=""><li id="3450" class="kv kw hu je b jf jg jj jk jn kx jr ky jv kz jz la lb lc ld dt translated">为项目中的单个函数定义事件有效负载</li><li id="2e5d" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">复制现有事件，为同一功能或不同功能创建新的测试事件</li><li id="06fe" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">用期望的测试事件直接调用函数</li></ul><h2 id="c5ff" class="mc md hu bd me mf mg mh mi mj mk ml mm jn mn mo mp jr mq mr ms jv mt mu mv mw dt translated">SigmaTrail</h2><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pa"><img src="../Images/8f3a93094473f9d2abd47f52832f3536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bfamoqI-MIChX2VZrogEA.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">Sigma Trail</figcaption></figure><p id="0917" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">SigmaTrail实时显示所有的测试调用结果。除了[测试]日志，SigmaTrail还显示每个功能的[生产]日志，当您的功能实际部署在AWS上时，这些日志将在生产环境中生成。多亏了SigmaTrail，再也不用检查<a class="ae kj" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>的<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>日志了。</p><p id="28a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你喜欢！快乐编码<a class="ae kj" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器</a>与<a class="ae kj" href="https://sigma.slappforge.com" rel="noopener ugc nofollow" target="_blank">适马</a>。</p><h1 id="7352" class="oh md hu bd me oi oj ok mi ol om on mm oo op oq mp or os ot ms ou ov ow mv ox dt translated">行动呼吁</h1><ul class=""><li id="ad6b" class="kv kw hu je b jf mx jj my jn pb jr pc jv pd jz la lb lc ld dt translated"><strong class="je hv">拍手。</strong>欣赏并让别人发现这篇文章。</li><li id="28e6" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated"><strong class="je hv">评论。分享你对这篇文章的看法。</strong></li><li id="3daa" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">跟我来。<a class="ae kj" rel="noopener" href="/@cwidanage">Chathura wid anage</a><strong class="je hv">T5】接收类似文章的更新。</strong></li><li id="5b87" class="kv kw hu je b jf le jj lf jn lg jr lh jv li jz la lb lc ld dt translated">保持联系。 <a class="ae kj" href="https://www.linkedin.com/in/cwidanage/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>，<a class="ae kj" href="https://twitter.com/cwidanage" rel="noopener ugc nofollow" target="_blank"> Twitter </a></li></ul><div class="lk ll fm fo lm ln"><a href="https://slappforge.com/" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">SLAppForge</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">SLAppForge将无服务器计算和应用程序带入最终用户商业成功的主流使用</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">slappforge.com</p></div></div><div class="lw l"><div class="pe l ly lz ma lw mb ja ln"/></div></div></a></div><div class="lk ll fm fo lm ln"><a href="https://hackernoon.com/tagged/serverless" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">无服务器-黑客正午</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">阅读黑客午间关于无服务器的文章。黑客如何开始他们的下午？</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">hackernoon.com</p></div></div><div class="lw l"><div class="pf l ly lz ma lw mb ja ln"/></div></div></a></div></div></div>    
</body>
</html>