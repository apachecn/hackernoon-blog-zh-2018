<html>
<head>
<title>How can you create flexible enums with different behaviors and associated values?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建具有不同行为和相关值的灵活枚举？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-can-you-create-flexible-enums-with-different-behaviors-and-associated-values-ed42c69be02e?source=collection_archive---------8-----------------------#2018-04-27">https://medium.com/hackernoon/how-can-you-create-flexible-enums-with-different-behaviors-and-associated-values-ed42c69be02e?source=collection_archive---------8-----------------------#2018-04-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/08683758036c93f07c2ff5d77fa029ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*ayMH5GuvRUGPyzm3AW8aPQ.png"/></div></figure><div class=""/><div class=""><h2 id="cd4c" class="pw-subtitle-paragraph iy ia ib bd b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp ek translated">科特林密封类的力量</h2></div><p id="745f" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">枚举对于分组具有相似行为的对象非常有用。它们的效率也很高，因为只需要创建它们的一个实例。然而，很难为行为稍有不同的类实现枚举。我举个例子说明一下。</p><h2 id="484d" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">示例:统计计算器</h2><p id="fb35" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">假设我们想写一个统计计算器来计算数值列表的数理统计，例如<code class="eh lm ln lo lp b">SUM</code>、<code class="eh lm ln lo lp b">COUNT</code>、<code class="eh lm ln lo lp b">AVG</code>、<code class="eh lm ln lo lp b">QUANTILES</code>。让我们首先定义一个接口。</p><figure class="lq lr ls lt fq hw"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="be07" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在，我们可以很容易地将不同的统计数据表示为如下枚举:</p><figure class="lq lr ls lt fq hw"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="6edb" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我们可以这样使用它:</p><figure class="lq lr ls lt fq hw"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="02e5" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">这很容易，但是一旦想要支持<code class="eh lm ln lo lp b">QUANTILE</code> stat就变得很难了，它需要存储<em class="lw">百分点</em>以便在enum实例中计算。对于例<code class="eh lm ln lo lp b">QUANTILE(90).calculate(values)</code>应计算第90个<strong class="js ic"><em class="lw"/></strong>百分位值。</p><h1 id="2433" class="lx kn ib bd ko ly lz ma ks mb mc md kw jh me ji kz jk mf jl lc jn mg jo lf mh dt translated">用不同的行为实现枚举的问题</h1><ul class=""><li id="6e4b" class="mi mj ib js b jt lh jw li jz mk kd ml kh mm kl mn mo mp mq dt translated">由于Java枚举必须有相同的字段，我们必须给所有枚举添加百分点字段，尽管这与<code class="eh lm ln lo lp b">AVG</code>、<code class="eh lm ln lo lp b">SUM</code>、<code class="eh lm ln lo lp b">COUNT</code>无关。</li><li id="b6d7" class="mi mj ib js b jt mr jw ms jz mt kd mu kh mv kl mn mo mp mq dt translated">我们事先不知道百分比值来静态创建分位数的实例。所以不能再枚举了。</li><li id="84e6" class="mi mj ib js b jt mr jw ms jz mt kd mu kh mv kl mn mo mp mq dt translated">一旦我们将它们转换成常规类，我们将失去它的默认单例行为。</li></ul><p id="4798" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我们基本上想要简单的统计数据<code class="eh lm ln lo lp b">AVG</code>、<code class="eh lm ln lo lp b">SUM</code>、<code class="eh lm ln lo lp b">COUNT</code>作为单件，但是<code class="eh lm ln lo lp b">QUANTILE</code>作为给定百分比值的动态创建的类。我们必须编写大量的boiler plate代码来支持这种行为上的差异，他就是这样做的一种方式。</p><figure class="lq lr ls lt fq hw"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="e3ee" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">那是许多工作。</p><figure class="lq lr ls lt fq hw fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/6da24bd80a809fdb09e72bdf34d7e4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*BPp8wgj0lR9NnRPD_iz1nA.gif"/></div></figure><h2 id="9248" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">科特林的密封类拯救</h2><p id="090d" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">Kotlin有强大的密封类来轻松解决这类用例。</p><p id="a683" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我们先来了解一下什么是密封类:</p><blockquote class="mx my mz"><p id="f58f" class="jq jr lw js b jt ju jc jv jw jx jf jy na ka kb kc nb ke kf kg nc ki kj kk kl hn dt translated">密封类用于表示受限的类层次结构。在某种意义上，它们是enum类的扩展。<br/> <br/>一个密封的类可以有子类，但是所有的子类必须在同一个文件中声明。密封类的子类可以有多个包含状态的实例。<br/> <br/>你可以在密封类内部或者外部声明子类，但是它们必须在同一个文件中声明。</p><p id="ca42" class="jq jr lw js b jt ju jc jv jw jx jf jy na ka kb kc nb ke kf kg nc ki kj kk kl hn dt translated">密封类本身是抽象的，它不能被直接实例化，并且可以有抽象成员。</p><p id="4bee" class="jq jr lw js b jt ju jc jv jw jx jf jy na ka kb kc nb ke kf kg nc ki kj kk kl hn dt translated">密封类不允许有非私有构造函数(默认情况下，它们的构造函数是私有的)。</p></blockquote><p id="0b07" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在，我们知道了密封类，让我们看看如何使用密封类来实现StatsCalculator</p><p id="8d33" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们像这样为每个属性创建一个密封的属性类和子类。</p><figure class="lq lr ls lt fq hw"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="1f50" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">Kotlin支持在单行中创建单例的对象声明。语言本身支持准确定义我们想要的东西:</p><ul class=""><li id="b026" class="mi mj ib js b jt ju jw jx jz nd kd ne kh nf kl mn mo mp mq dt translated">简单的统计数据<code class="eh lm ln lo lp b">AVG</code>、<code class="eh lm ln lo lp b">COUNT</code>、<code class="eh lm ln lo lp b">SUM</code>使用对象声明作为单例。</li><li id="6652" class="mi mj ib js b jt mr jw ms jz mt kd mu kh mv kl mn mo mp mq dt translated"><code class="eh lm ln lo lp b">QUANTILE</code>被定义为存储百分位值的常规类。</li><li id="a109" class="mi mj ib js b jt mr jw ms jz mt kd mu kh mv kl mn mo mp mq dt translated">所有这些类都组合在一个密封基类<code class="eh lm ln lo lp b">Stats</code>中。</li></ul><p id="ab05" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在，这种计算方法可以用简洁明了的方式实现了。</p><figure class="lq lr ls lt fq hw"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="d2c1" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">代码不仅简洁，当 表达式时<strong class="js ic"> <em class="lw">的美丽帮助我们避免运行时潜在的错误。</em></strong></p><p id="96d1" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">由于<strong class="js ic"> <em class="lw">当</em> </strong>表达式用于直接返回值时，如果我们添加一个新的stats比如说<code class="eh lm ln lo lp b">MAX</code>扩展<code class="eh lm ln lo lp b">Stats</code>但是忘记更新calculate方法，编译器就会抛出错误。</p><blockquote class="mx my mz"><p id="cbac" class="jq jr lw js b jt ju jc jv jw jx jf jy na ka kb kc nb ke kf kg nc ki kj kk kl hn dt translated">“when”表达式必须是详尽的，请添加必要的“Max”分支或“else”分支。</p></blockquote><p id="306a" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">这对于密封类是可能的，因为所有的子类都在同一个文件中声明，所以编译器知道所有可能的值。</p><h2 id="ca26" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">密封类什么时候有用？</h2><p id="2cd7" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">密封类的概念并不新鲜。密封的类允许我们轻松地处理代数数据类型。类似的功能在其他语言中也可用，如</p><ul class=""><li id="52bc" class="mi mj ib js b jt ju jw jx jz nd kd ne kh nf kl mn mo mp mq dt translated"><a class="ae ng" href="https://docs.scala-lang.org/tour/case-classes.html" rel="noopener ugc nofollow" target="_blank">Scala中的案例类</a></li><li id="bd2c" class="mi mj ib js b jt mr jw ms jz mt kd mu kh mv kl mn mo mp mq dt translated"><a class="ae ng" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html" rel="noopener ugc nofollow" target="_blank">Swift中带有关联值</a>的枚举</li><li id="01ed" class="mi mj ib js b jt mr jw ms jz mt kd mu kh mv kl mn mo mp mq dt translated"><a class="ae ng" href="https://wiki.haskell.org/Algebraic_data_type" rel="noopener ugc nofollow" target="_blank">Haskell中的数据类型</a></li></ul><p id="80eb" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">所以我们可以使用Kotlin的密封类来解决那些需要代数数据类型的问题。</p><p id="1a9d" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">如果你没有足够的时间使用Kotlin，你可以用普通的Java语言查看Spotify的数据清单。</p></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><p id="5103" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><strong class="js ic"><em class="lw">2018年12月3日更新:</em> </strong></p><p id="9234" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">代码示例更新为使用<a class="ae ng" href="https://doculet.net/" rel="noopener ugc nofollow" target="_blank"> Doculet </a>。</p></div></div>    
</body>
</html>