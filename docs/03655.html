<html>
<head>
<title>Deploying Rock Solid Applications with Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes部署坚如磐石的应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deploying-rock-solid-applications-with-kubernetes-230fd9bb61f4?source=collection_archive---------9-----------------------#2018-04-27">https://medium.com/hackernoon/deploying-rock-solid-applications-with-kubernetes-230fd9bb61f4?source=collection_archive---------9-----------------------#2018-04-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3f8ffadb4382b4db074f8664a6757e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdiRCurpsa5c5vY2lazAyw.png"/></div></div></figure><blockquote class="jc jd je"><p id="1f80" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">披露:<a class="ae ke" href="https://goo.gl/cF8TcH" rel="noopener ugc nofollow" target="_blank"> <em class="hu">流形</em> </a> <em class="hu">，独立开发者服务的市场</em>，之前赞助过黑客正午。<a class="ae ke" href="https://goo.gl/cF8TcH" rel="noopener ugc nofollow" target="_blank"> <em class="hu">使用code HACKERNOON2018获得任何服务10美元的折扣。</em>T9】</a></p></blockquote><p id="7630" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在之前的博客文章中，我们描述了如何建立我们的<a class="ae ke" href="https://hackernoon.com/tagged/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群。我们还检查了支持我们的应用程序的初始配置。现在我们已经启动并运行了集群，是时候开始部署这些应用程序了。</p><p id="22dd" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在这篇博文中，我们将看看我们在<a class="ae ke" href="https://hackernoon.com/tagged/application" rel="noopener ugc nofollow" target="_blank">应用</a>层面所做的一些改变。</p><h1 id="c004" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">健康检查</h1><p id="5c1e" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">迁移到Kubernetes让我们有机会设置<a class="ae ke" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="noopener ugc nofollow" target="_blank">活跃度和就绪性探测器</a>。如果您的应用程序需要进行一些引导，准备就绪检查是有用的。活性检查对于长时间运行的服务特别有用。</p><p id="d083" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">为了简化，我们创建了<a class="ae ke" href="https://github.com/manifoldco/healthz" rel="noopener ugc nofollow" target="_blank"> healthz包</a>。我们将这一点与我们的框架挂钩，默认情况下为我们的所有服务和工作人员启用这一点。</p><h2 id="2f5c" class="ll kj hu bd kk lm ln lo ko lp lq lr ks kf ls lt kw kg lu lv la kh lw lx le ly dt translated">警告:循环依赖</h2><p id="9007" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">当一个服务与另一个服务对话时，对此进行检查是明智的。这伴随着建立循环依赖的风险。发生这种情况时，您可能会面临难以恢复的完全集群中断。为了减轻这种情况，使用“<em class="jh">降级</em>状态。这可以让您知道有问题，但不会将您的服务标记为不可用。</p><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/ef03bbf79485218f327521b2a0614179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITFPUOmWgFRnWPkQr5nqDw.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">3 applications which depend on each other</figcaption></figure><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/71febe6b4a2955808d0e5b995ab5a964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jf9dR0J2tbcqeBXe3fp8_Q.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Outage in Application C</figcaption></figure><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/3d06f122b32a8b16759c735cd362a918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVtSNtGuqWuY5_3585y7eg.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Due to the Application C dependency in Application A, Application A becomes unavailable</figcaption></figure><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/0dc085378ff73deaf5970d7045fe1e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYpbnvx5n6hkTnRTez410Q.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Application A is now unavailable, making Application B unavailable. None of the apps can reboot.</figcaption></figure><h1 id="3f95" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">保护Docker图像</h1><p id="d406" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">在迁移的同时，我们还决定提高我们的<a class="ae ke" href="https://docs.docker.com/engine/reference/commandline/images/" rel="noopener ugc nofollow" target="_blank"> Docker映像</a>的安全性。我们通过确保我们的容器<a class="ae ke" rel="noopener" href="/@lizrice/non-privileged-containers-based-on-the-scratch-image-a80105d6d341">运行无特权</a>来做到这一点。</p><p id="6963" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">为了更进一步，我们还研究了在Kubernetes中建立<a class="ae ke" href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" rel="noopener ugc nofollow" target="_blank"> Pod安全策略</a>。有了这些策略，我们将强制用户作为非根用户运行他们的容器。遗憾的是，我们还没有设法让<a class="ae ke" href="https://kubernetes.io/docs/admin/admission-controllers/" rel="noopener ugc nofollow" target="_blank">准入控制器</a>工作。在我们的遗留系统中没有这种强制措施，所以我们同意推迟这一点。</p><p id="7e36" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><em class="jh"> PS: </em>谷歌已经<a class="ae ke" href="https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies" rel="noopener ugc nofollow" target="_blank">宣布在他们的</a><a class="ae ke" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Kubernetes引擎</a>上支持这个。</p><h1 id="1a69" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">网络策略</h1><p id="c6a1" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">一些服务应该只接收来自一组特定源的请求。您的日志聚合器不需要与您的用户服务对话。这就是网络政策发挥作用的地方。</p><p id="40cc" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">默认情况下，我们的任何服务都不能从集群外部获得。与这些服务之一对话的唯一方式是通过我们的<a class="ae ke" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> Nginx入口</a>。</p><p id="1a9f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在我们自己的应用程序网络中，我们已经建立了一个规则，以便所有服务都可以相互通信。为此，我们用组件标签标记每个应用程序，如<em class="jh">组件:市场</em>。现在我们可以为这个特定的组件设置一个选择器。</p><p id="8322" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">通过添加服务标签，您还可以创建更细粒度的策略。其中一个策略可能是只允许流量从您的<em class="jh">计费服务</em>流向您的<em class="jh">货币服务</em>。</p><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/374728dbee19faf2cb9a865aa83ad487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVeo0KA8a1QISPrYZqeLAA.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">We can restrict Ingress and Egress traffic as well as inter-application traffic with Network Policies.</figcaption></figure><h1 id="52fd" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">容忍节点故障</h1><p id="a275" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">在我们之前的博文中，我们讨论了如何为实例设置高可用性(HA)。这并不能保证我们的应用程序以高可用性的方式运行。</p><h2 id="cef1" class="ll kj hu bd kk lm ln lo ko lp lq lr ks kf ls lt kw kg lu lv la kh lw lx le ly dt translated">行程安排</h2><p id="8c68" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">首先，您需要运行Kubernetes部署的多个副本。这将确保当其中一个副本出现故障时，其他副本仍然可以为流量提供服务。然后，一个新的健康副本将替换不健康的副本。</p><p id="1c46" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最常见的设置是有几个可用性区域。每个可用性区域也有一组节点。在理想情况下，副本分布在这些实例中。</p><p id="1136" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">通过使用<a class="ae ke" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank">部署关系</a>，我们完全可以做到这一点。我们可以要求<a class="ae ke" href="https://kubernetes.io/docs/reference/generated/kube-scheduler/" rel="noopener ugc nofollow" target="_blank"> Kubernetes调度器</a>寻找这种类型的服务还没有运行的实例。我们还可以要求找到一个该服务尚未激活的可用区域。然后Kubernetes将决定一个节点，并在那里部署应用程序。</p><p id="1d96" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">你可以在这里看到完整的例子:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mj mk l"/></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">podAntiAffinity example to spread load across multiple instances and zones.</figcaption></figure><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/f528b27a30c5aa1f52ed89d1806b091e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omaQ0g93T-VyqOBvkeMyAQ.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">2 different applications are deployed across different zones and nodes</figcaption></figure><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/df266dc2d97d241fe7f32312e148193e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKqutSY5pZ80fqQ4Q4UKgw.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">One of the nodes becomes unavailable, marking all the applications within unhealthy.</figcaption></figure><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/0524517b90336f6923404eaa5399ac15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L59SFnTFysBoubRZNCLzCQ.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">The unhealthy applications are rescheduled on healthy nodes.</figcaption></figure><p id="c13a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">通过这样配置，可以降低在同一个实例上安排pod的可能性。这反过来增加了你的可用性。我们已经将集群配置为使用preferedDuringScheduling节。这告诉Kubernetes尝试这样做，但是如果没有满足要求的实例，就不要强制执行。</p><h2 id="cc98" class="ll kj hu bd kk lm ln lo ko lp lq lr ks kf ls lt kw kg lu lv la kh lw lx le ly dt translated">重新安排</h2><p id="3fe2" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">当Kubernetes第一次看到吊舱时，它会决定在哪里发射吊舱。如上所述，我们也可以对此进行一些约束。</p><p id="afe9" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">鉴于集群是动态的——pod来来去去——而调度是静态的，随着时间的推移，这些约束可能会被违反。例如，这可能是由于其他实例上缺少资源或由于实例失败。</p><p id="054b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我们通过在集群中安装一个<a class="ae ke" href="https://github.com/kubernetes-incubator/descheduler" rel="noopener ugc nofollow" target="_blank">调度器</a>解决了这个问题。这可以做几件事。其中之一是确保实例间的负载在给定的范围内。另一个是取消违反它们的相似性规则的pod。</p><p id="3b13" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">如果我们继续前面的例子，看起来是这样的:</p><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/419a811be0f9956d4ff93c591af7ecf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcRnrVz-iEa3_CDk9bRvnA.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">The AutoScaling Group creates a new instance</figcaption></figure><figure class="ma mb mc md fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/1b0e76d83af81b57bf841bb5203cb717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObGjJBNLLvkoNqTmbBXIWQ.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Once the new node becomes available, apps get rescheduled on the new node.</figcaption></figure><p id="8f54" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">需要注意的一件重要事情是，去调度器尊重<a class="ae ke" href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" rel="noopener ugc nofollow" target="_blank">podisruption budgets</a>。如果没有配置，特定部署的所有副本可能会同时取消调度。这可能会导致意外的服务中断。</p><h1 id="0fe2" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结论</h1><p id="4763" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">Kubernetes做了很好的现成工作。然而，它需要一些帮助，让它知道你的应用程序设置。一旦你知道了这一点，你将能够使用一套强大的工具:</p><ul class=""><li id="7e78" class="ml mm hu ji b jj jk jn jo kf mn kg mo kh mp kd mq mr ms mt dt translated"><a class="ae ke" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="noopener ugc nofollow" target="_blank">健康检查</a></li><li id="d493" class="ml mm hu ji b jj mu jn mv kf mw kg mx kh my kd mq mr ms mt dt translated"><a class="ae ke" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank"> Pod(反)亲和力</a></li><li id="3602" class="ml mm hu ji b jj mu jn mv kf mw kg mx kh my kd mq mr ms mt dt translated"><a class="ae ke" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a></li><li id="4051" class="ml mm hu ji b jj mu jn mv kf mw kg mx kh my kd mq mr ms mt dt translated"><a class="ae ke" href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" rel="noopener ugc nofollow" target="_blank">安全策略</a></li><li id="e7a2" class="ml mm hu ji b jj mu jn mv kf mw kg mx kh my kd mq mr ms mt dt translated"><a class="ae ke" href="https://github.com/kubernetes-incubator/descheduler" rel="noopener ugc nofollow" target="_blank">重新安排</a></li><li id="32e2" class="ml mm hu ji b jj mu jn mv kf mw kg mx kh my kd mq mr ms mt dt translated"><a class="ae ke" href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" rel="noopener ugc nofollow" target="_blank"> PodDisruptionBudgets </a></li></ul><p id="a7d9" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">为了使这更容易，我们开始建造<a class="ae ke" href="https://heighliner.com/" rel="noopener ugc nofollow" target="_blank">高度线</a>。它会为你设置一堆合理的默认值。如果您愿意，可以覆盖这些内容。</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mz mk l"/></div></figure></div></div>    
</body>
</html>