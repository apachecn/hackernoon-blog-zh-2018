<html>
<head>
<title>Ethereum Smart Contract Upgradeability: Hands-On</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊智能合约可升级性:动手操作</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ethereum-smart-contract-upgradeability-hands-on-ceaf98be070f?source=collection_archive---------19-----------------------#2018-04-27">https://medium.com/hackernoon/ethereum-smart-contract-upgradeability-hands-on-ceaf98be070f?source=collection_archive---------19-----------------------#2018-04-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ce16fbbe8bc397cbff7d8bdfa8fb3e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfyyFQ5Y2fE_SXpGoTkSGA.jpeg"/></div></div></figure><p id="15d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像每一种新材料一样，理解智能合同的可升级性需要花费大量时间。让我们试着缩短这个学习曲线:)</p><p id="80fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近有很多关于这个主题的文章和资源发表，<a class="ae ka" href="https://zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank"> Zeppelin </a>团队(<a class="ae ka" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>和<a class="ae ka" href="https://zeppelinos.org/" rel="noopener ugc nofollow" target="_blank"> zeppelinOS </a>)真正推动了可升级智能合同的概念。</p><p id="6c21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，我感觉在这些讨论中缺少一个简单的例子，这就是我想与你分享的。</p><p id="2554" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不打算在这里总结或概述可升级性模式。正如我所说，我认为互联网上已经有足够多的惊人资源，无论如何<em class="kb">你都需要花时间学习和研究</em> ( <a class="ae ka" href="https://blog.zeppelinos.org/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">这是一个很好的起点</a>)。尽管如此，我还是想为你提供一个简单的开始。一个简单的可升级智能合同。</p><p id="5ed2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但在此之前，让我们总结一些要点:</p><ol class=""><li id="2ac9" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><a class="ae ka" href="https://hackernoon.com/tagged/upgradeability" rel="noopener ugc nofollow" target="_blank">可升级性</a>依赖于<a class="ae ka" href="http://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries" rel="noopener ugc nofollow" target="_blank">坚固性方法</a> <code class="eh kl km kn ko b">delegatecall</code>。</li><li id="0a32" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">最基本的解决方案依赖于两个契约。一个<a class="ae ka" href="https://hackernoon.com/tagged/proxy-contract" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">代理契约</strong> </a>(用于存储)，将调用委托给一个<strong class="je hv">逻辑契约</strong>(逻辑契约可以升级。不是代理)。</li><li id="2d1f" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated"><code class="eh kl km kn ko b">delegatecall</code>将从接收调用的合同中加载代码。<strong class="je hv">在调用合同</strong>上完成存储。同样，存储是在调用契约上完成的！因此，代理合同将保持我们的可升级合同的状态。</li><li id="1805" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">调用一个不存在的智能合约函数会触发其<a class="ae ka" href="http://solidity.readthedocs.io/en/v0.4.21/contracts.html#fallback-function" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">回退函数</strong> </a>(当然前提是回退函数实现了)。代理契约使用这种机制。</li></ol><p id="5da6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意</strong>:在这个例子中，我使用了从zeppelinos继承的存储模式。代码改编自他们的<a class="ae ka" href="https://github.com/zeppelinos/labs/tree/master/upgradeability_using_inherited_storage" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><h1 id="c9e2" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">1.概观</h1><p id="8265" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">让我们考虑下面的智能合约和这个场景:<code class="eh kl km kn ko b">TokenVersion1</code>已经部署，但是突然你意识到它包含一个bug…太糟糕了。bug在<code class="eh kl km kn ko b">mint</code>函数里。</p><pre class="lx ly lz ma fq mb ko mc md aw me dt"><span id="47db" class="mf kv hu ko b fv mg mh l mi mj">pragma solidity ^0.4.21;<br/><br/>contract TokenVersion1 {<br/>    mapping (address =&gt; uint) balances;<br/><br/>    event Transfer(address _from, address _to, uint256 _value);<br/><br/>    function balanceOf(address _address) public view returns (uint) {<br/>        return balances[_address];<br/>    }<br/><br/>    function transfer(address _to, uint256 _value) public {<br/>        require(balances[msg.sender] &gt;= _value);<br/>        balances[msg.sender] -= _value;<br/>        balances[_to] += _value;<br/>        emit Transfer(msg.sender, _to, _value);<br/>    }<br/><br/>    // there is a bug in this function: value should not<br/>    // be multiplied by 2<br/>    function mint(address _to, uint256 _value) public {<br/>        balances[_to] += _value * 2;<br/>        emit Transfer(0x0, _to, _value);<br/>    }<br/>}<br/><br/>contract TokenVersion2 is TokenVersion1 {<br/><br/>    // bug corrected here: multiplication by 2 removed<br/>    function mint(address _to, uint256 _value) public {<br/>        balances[_to] += _value;<br/>        emit Transfer(0x0, _to, _value);<br/>    }<br/>}</span></pre><p id="2ea8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你不想铸造双倍的权利？(或者也许你做^^).如果您的系统被设计为支持可升级的智能合约，被窃听的合约<code class="eh kl km kn ko b">TokenVersion1</code>可以通过部署合约<code class="eh kl km kn ko b">TokenVersion2</code>来修复。但是要实现这一点，您需要一个所谓的代理契约，用于将调用委托给您的令牌契约:</p><pre class="lx ly lz ma fq mb ko mc md aw me dt"><span id="6515" class="mf kv hu ko b fv mg mh l mi mj">pragma solidity ^0.4.21;<br/><br/>/**<br/> * @title Proxy<br/> * @dev Gives the possibility to delegate any call to a foreign implementation.<br/> */<br/>contract Proxy {<br/><br/>    address public implementation;<br/><br/>    function upgradeTo(address _address) public {<br/>        implementation = _address;<br/>    }<br/><br/>    /**<br/>    * @dev Fallback function allowing to perform a delegatecall to the given implementation.<br/>    * This function will return whatever the implementation call returns<br/>    */<br/>    function () payable public {<br/>        address _impl = implementation;<br/>        require(_impl != address(0));<br/><br/>        assembly {<br/>            let ptr := mload(0x40)<br/>            calldatacopy(ptr, 0, calldatasize)<br/>            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)<br/>            let size := returndatasize<br/>            returndatacopy(ptr, 0, size)<br/><br/>            switch result<br/>            case 0 { revert(ptr, size) }<br/>            default { return(ptr, size) }<br/>        }<br/>    }<br/>}</span></pre><p id="4f97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">交易流程如下:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/8a697da062aab494a53316ee977bd09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*JxPeU5WGIvMM6sqdesr1dA.png"/></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">transaction flow</figcaption></figure><h1 id="34c3" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">2.亲自动手</h1><p id="528d" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">让我们浏览一下交易流程(上图)以及如何使用可升级性:</p><ol class=""><li id="5e23" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated">你开始部署你的代理合同<code class="eh kl km kn ko b">Proxy</code>。</li><li id="b9cf" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">然后部署您的逻辑契约。这就是<code class="eh kl km kn ko b">TokenVersion1</code></li><li id="1d71" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">您通过调用函数<code class="eh kl km kn ko b">upgradeTo(address of TokenVersion1)</code>告诉您的代理契约指向<code class="eh kl km kn ko b">TokenVersion1</code></li><li id="950c" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">棘手的部分来了:让我们试着铸造一些代币。但是我们不会直接调用<code class="eh kl km kn ko b">TokenVersion1</code>契约上的<code class="eh kl km kn ko b">mint</code>函数(我们这样做会绕过代理，破坏可升级性模式)。相反，我们将直接在代理上调用<code class="eh kl km kn ko b">mint(address, value)</code>,因为这个函数不存在，它将触发回退函数，向保存在<code class="eh kl km kn ko b">implementation</code>变量中的<code class="eh kl km kn ko b">TokenVersion1</code>契约的地址触发一个<code class="eh kl km kn ko b">deletagecall</code>。</li><li id="1bef" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">代理契约<strong class="je hv">将从</strong> <code class="eh kl km kn ko b">tokenVersion1</code>加载<code class="eh kl km kn ko b">mint</code>函数的代码(感谢<a class="ae ka" href="http://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries" rel="noopener ugc nofollow" target="_blank"> delegatecall </a> ) <strong class="je hv">并执行。执行<code class="eh kl km kn ko b">mint</code>函数的<code class="eh kl km kn ko b">balances</code>映射和<code class="eh kl km kn ko b">Transfer</code>事件，并存储在代理契约中。<code class="eh kl km kn ko b">TokenVersion1</code> <strong class="je hv">不会存储任何数据，也不会触发任何事件</strong>！代理合同有。这也正是你可以升级这个合同的原因:)</strong></li><li id="66d8" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">如果成功执行了<code class="eh kl km kn ko b">mint</code>函数，通过代理调用<code class="eh kl km kn ko b">balanceOf(luckyAddress)</code>将返回正确的余额(乘以2)。但是，直接调用<code class="eh kl km kn ko b">balanceOf(luckyAddress)</code>到<code class="eh kl km kn ko b">TokenVersion1</code>契约会返回0(是零)。记住，<code class="eh kl km kn ko b">token</code>合同没有执行任何代码…</li><li id="5e39" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">此时，您注意到您的<code class="eh kl km kn ko b">mint</code>函数有一个bug :( <code class="eh kl km kn ko b">luckyAddress</code>得到了两倍于您预期的金额。因此，您创建了一个从<code class="eh kl km kn ko b">TokenVersion1</code>继承(<a class="ae ka" href="https://blog.zeppelinos.org/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">继承存储</a>)的<code class="eh kl km kn ko b">TokenVersion2</code>契约，并更正了<code class="eh kl km kn ko b">mint</code>函数。</li><li id="41be" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">然后你部署你的令人敬畏的和无错误的<code class="eh kl km kn ko b">TokenVersion2</code>合同。</li><li id="b243" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">您通过调用<code class="eh kl km kn ko b">upgradeTo(address of TokenVersion2)</code>告诉代理指向这个新合同</li><li id="2957" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated">瞧啊！:)您的代理现在正在将呼叫委托给新版本的令牌合约。因为状态存储在代理契约中，所以没有数据丢失！(是的<code class="eh kl km kn ko b">luckyAddress</code>仍然有来自<code class="eh kl km kn ko b">tokenVersion1</code>中bug的双倍硬币——状态在你的更新中是持久的，这是重点。)</li></ol><h1 id="9f7a" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">3.密码</h1><p id="46ba" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">您将在我的github repo中找到一个完整的工作示例:</p><div class="mp mq fm fo mr ms"><a href="https://github.com/salanfe/ethereum_contract_upgradeablitiy_simple_example" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hv fv z el mx eo ep my er et ht dt translated">sa lanfe/ether eum _ contract _ upgrade ablity _ simple _ example</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">以太坊_ contract _ upgradability _ simple _ example-智能合约可升级性机制的死简单例子…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ja ms"/></div></div></a></div><p id="3531" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh kl km kn ko b">/python</code>文件夹中有一个独立的<strong class="je hv"> python </strong>脚本。关于如何运行它，请参见文件头。在坚果壳中启动ganache并运行它:)。</p><p id="4651" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你更喜欢<strong class="je hv"> javascript </strong>，你会在<code class="eh kl km kn ko b">/test</code>中找到一个测试文件。同样，说明在它的标题里。</p><h1 id="95ba" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">4.资源</h1><p id="ed65" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">不要就此打住:)这个“虚拟”例子只是为了让你入门。继承存储是其中的一种模式。该社区已经提出了至少2种其他模式:<a class="ae ka" href="https://blog.zeppelinos.org/smart-contract-upgradeability-using-eternal-storage/" rel="noopener ugc nofollow" target="_blank">永久存储</a>和<a class="ae ka" href="https://blog.zeppelinos.org/upgradeability-using-unstructured-storage/" rel="noopener ugc nofollow" target="_blank">非结构化存储</a>。这里有一些很棒的资源(排序如下):</p><ol class=""><li id="d9bf" class="kc kd hu je b jf jg jj jk jn ke jr kf jv kg jz kh ki kj kk dt translated"><a class="ae ka" href="https://blog.zeppelinos.org/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">https://blog.zeppelinos.org/proxy-patterns/</a></li><li id="d8c7" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated"><a class="ae ka" href="https://github.com/zeppelinos/labs" rel="noopener ugc nofollow" target="_blank">https://github.com/zeppelinos/labs</a></li><li id="e541" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated"><a class="ae ka" href="https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd" rel="noopener ugc nofollow" target="_blank">https://blog . zeppelin . solutions/proxy-libraries-in-solidity-79 FBE 4b 970 FD</a></li><li id="10b7" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated"><a class="ae ka" href="https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88" rel="noopener ugc nofollow" target="_blank">https://blog . colony . io/writing-upgradable-contracts-in-solidity-6743 f 0 eecc 88</a></li><li id="bbc3" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated"><a class="ae ka" href="https://vomtom.at/upgrade-smart-contracts-on-chain/" rel="noopener ugc nofollow" target="_blank">https://vomtom.at/upgrade-smart-contracts-on-chain/</a></li><li id="2618" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated"><a class="ae ka" rel="noopener" href="/aigang-network/upgradable-smart-contracts-what-weve-learned-at-aigang-b181d3d4b668">https://medium . com/aigang-network/upgradable-smart-contracts-what-we-ve-learn-at-aigang-b 181d 3d 4b 668</a></li><li id="f3a0" class="kc kd hu je b jf kp jj kq jn kr jr ks jv kt jz kh ki kj kk dt translated"><a class="ae ka" href="https://blog.indorse.io/ethereum-upgradeable-smart-contract-strategies-456350d0557c" rel="noopener ugc nofollow" target="_blank">https://blog . indorse . io/ether eum-upgradable-smart-contract-strategies-456350d 0557 c</a></li></ol><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>