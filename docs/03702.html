<html>
<head>
<title>Serverless Architecture Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器架构语言</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/documenting-serverless-architectures-69bf63fc67b0?source=collection_archive---------2-----------------------#2018-04-29">https://medium.com/hackernoon/documenting-serverless-architectures-69bf63fc67b0?source=collection_archive---------2-----------------------#2018-04-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="f89c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">有什么问题？</h1><p id="688f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">有了<a class="ae kn" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>计算平台，我们，<a class="ae kn" href="https://hackernoon.com/tagged/software" rel="noopener ugc nofollow" target="_blank">软件</a>开发者，终于可以抛开所有不相关的技术细节，开始交付我们所需要的东西——业务特性。事实上，这是软件行业潜在的结构性转变(S. Wardley提出了一些关于这个主题的重要的<a class="ae kn" href="https://hackernoon.com/why-the-fuss-about-serverless-4370b1596da0" rel="noopener ugc nofollow" target="_blank">战略见解</a>)。</p><div class="ko kp fm fo kq kr"><a href="https://hackernoon.com/why-the-fuss-about-serverless-4370b1596da0" rel="noopener  ugc nofollow" target="_blank"><div class="ks ab ej"><div class="kt ab ku cl cj kv"><h2 class="bd hv fv z el kw eo ep kx er et ht dt translated">为什么对无服务器大惊小怪？</h2><div class="ky l"><h3 class="bd b fv z el kw eo ep kx er et ek translated">为了解释这一点，我将不得不回顾一些旧的工作，特别关注共同进化。</h3></div><div class="kz l"><p class="bd b gc z el kw eo ep kx er et ek translated">hackernoon.com</p></div></div><div class="la l"><div class="lb l lc ld le la lf lg kr"/></div></div></a></div><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/e47e878ee3473b55f491349bb6ebf6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*Rnuly_x-3GCXqT4CkiUGIQ.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">What does this picture mean and why we call it “Architecture”?</figcaption></figure><p id="a149" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">但是看看上图。这是我们通常记录无服务器架构的方式。不可能给单个元素或整个图赋予精确和明确的含义。这个图太模糊了。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/980b16063c8773f9d5a563d58c134591.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*mNPG72g-XS_UREiL9EKrPw.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Which one to use and when?</figcaption></figure><p id="bb88" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">通常，很难决定在什么情况下选择哪种图标变体。是不是都是一个意思，只是口味问题？或者它们都是不同的，选择取决于上下文。那么，如何找到正确的上下文呢？</p><p id="e6ca" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这是来自官方的AWS无服务器Web应用研讨会的图表:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff ly"><img src="../Images/19dd786673256c3f617b1b0fcda94c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gj-FLBS27Xl7jw3D.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">AWS Serverless Web Application Workshop Architecture</figcaption></figure><p id="5dd8" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这个图似乎告诉我们，有五个<a class="ae kn" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>服务，原则上它们可以相互对话，Web浏览器也可以与其中一些对话。然而，它很少传达应用程序是如何构建的以及它是做什么的。</p><p id="4b80" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">该图对于进行延迟、吞吐量、安全性、可用性、成本或生产率的架构分析不是很有用。没有办法将核心业务功能与通用或辅助组件分开。没有办法识别分散在多个应用程序中的重复。没有办法比较多种选择，也没有办法证明选择一种比另一种更合理。</p><p id="4875" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">此外，这种图表样式不会超出非常简单的应用程序的范围。当应用程序变大时，通常会失去对其结构的智能控制。在无服务器的会议上，经常会听到一些关于初创公司的令人担忧的故事，这些公司在6个月的开发时间内产生了大约500个Lambda函数；而现在，没有人知道发生了什么以及如何维护它们。有时给人的印象是，无服务器计算只是一种把我们自己搞得面目全非的新奇方式。</p><p id="8bd7" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这里有一些更高级的主题。软件架构蓝图必须构成系统可观测性的坚实基础。相同的蓝图必须有助于战略规划:我们的应用程序的哪些部分最有可能被can供应商商品化(使用<a class="ae kn" href="http://blog.gardeviance.org/2014/03/understanding-ecosystems-part-i-of-ii.html" rel="noopener ugc nofollow" target="_blank"> ILC模型</a>)以及我们的开源战略应该是什么样子(为了正确理解，你可能需要阅读整本<a class="ae kn" href="https://medium.com/wardleymaps" rel="noopener">书</a>)。使用没有精确语义的图片怎么可能做到这一切？</p><div class="ko kp fm fo kq kr"><a href="https://medium.com/wardleymaps" rel="noopener follow" target="_blank"><div class="ks ab ej"><div class="kt ab ku cl cj kv"><h2 class="bd hv fv z el kw eo ep kx er et ht dt translated">沃德里地图</h2><div class="ky l"><h3 class="bd b fv z el kw eo ep kx er et ek translated">地形情报在商业战略中的应用</h3></div><div class="kz l"><p class="bd b gc z el kw eo ep kx er et ek translated">medium.com</p></div></div><div class="la l"><div class="md l lc ld le la lf lg kr"/></div></div></a></div><p id="3f86" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">今天，我们没有一个适当的、丰富的、但一致的语言来解决所有这些问题；我们非常需要它。</p><h1 id="7ae2" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">对此能做些什么呢？</h1><p id="f4ae" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">作为一个运行示例，我将使用AWS solution architects在最近在特拉维夫举行的2018年AWS峰会的“使用无服务器基础设施的快速开发”主题中展示的示例应用程序。</p><p id="2526" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">该应用程序被称为MakirOto(希伯来语中的“认识他”)。这是一个可爱的应用程序，展示了许多AWS无服务器功能。以下是MakirOto整体架构在舞台上的展示方式:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff me"><img src="../Images/93ddd83b04cfaf09e3975a638621f15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/0*VKJmL_tWMi3n-Dv3."/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Architecture</figcaption></figure><p id="a9f7" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在这个图中，混合了表示AWS服务的图标，如Rekognition和API网关，以及单独的资源，如Lambda函数和S3桶。目前还不清楚代表Lambda Function的图标是指实例、Lambda Function规范(又名<a class="ae kn" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank"> SAM模板</a>)还是特定AWS区域内的个别部署。</p><p id="49ad" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在我们开始改进之前，我们首先需要理解并准确记录系统做了什么。更具体地说，系统如何与其外部参与者交互(用例模型)，以及这些用例如何由系统内部组件实现(逻辑模型)。</p><h1 id="2c2b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">用例模型</h1><p id="9c0d" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是MakirOto的一个用例模型，我从演示文稿中理解了它(在<a class="ae kn" href="https://www.youtube.com/watch?v=OAo1qwXMqug&amp;t=3s&amp;index=10&amp;list=PLhr1KZpdzukcpd__tGf2QNsnjyachcXEI" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上有希伯来语版本):</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/87672474632f6072893922b368f00640.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/0*_lu5vbZYF9HUKvt-."/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto UseCase Model</figcaption></figure><p id="5ad0" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">架构上基本用例的正确建模通常被忽略，导致任何随后的技术争论缺乏由用户需求定义的合理起点。如今,“用例”这个术语经常被错误地应用于任何可能带有一丝<em class="mg">使用</em>味道的事物。</p><p id="0231" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">为了保持本文的独立，这里是我通常使用的术语“用例”的半正式定义:“用例是外部参与者和系统之间的封闭交互，通常由一些参与者发起以完成特定的目标”。</p><p id="fecb" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">上面的用例模型没有说太多，但是它确实为我们讨论架构决策提供了合适的上下文。这非常重要，我想再强调一次:</p><p id="025c" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在我们对系统如何与其外部参与者交互以交付某种价值有了清晰一致的认识之前，我们不应该开始任何关于系统内部如何组织的技术讨论。</p><p id="02ee" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">第一个用例“注册”，是许多交互系统的典型用例。在MakirOto中，注册新用户需要通过电子邮件发送确认码，上传用户照片，并从社交网络中提取额外的个人信息。</p><p id="6d0a" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">第二个用例，“识别”，反映了系统的主要价值主张——它是主要的架构上重要的用例，证明了系统首先要被开发。其余的，包括“注册”用例，将只需要支持“识别”用例。支持用例可能在技术上非常具有挑战性(或者有趣)，但是它们并不反映系统的真实性质，因此，只有在我们清楚地掌握了系统的主要用例之后，才应该进行分析。</p><p id="9beb" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">那么，在“识别”用例的过程中会发生什么呢？典型的事件流可以用下面的序列图来说明:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/e242b655e7727ad8ec70ddae113d6507.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*FHN-yaadRJ42IyvU."/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto “Recognize” Use Case Typical Event Sequence</figcaption></figure><p id="3586" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">序列图对于架构分析来说是一个非常强大的工具，但是经常没有被充分利用。我将在另一篇文章中讨论序列建模的一些重要的微妙之处，但是现在可以说所有的性能(延迟、吞吐量)和可用性需求分析都将从这里开始。</p><p id="8c9d" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在MakirOto的例子中，有另一个场景，当识别请求被提交给现场摄像机时，但是由于这是第一个场景的一个小变化，我们将在这里跳过它。</p><p id="a2af" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">前几个步骤，直到“加载图片”命令，对于任何用户识别过程都是常见的，它们本身并不十分有趣。成功登录后，用户上传一张照片，对照片上的人进行面部识别。之后，用户可以询问关于已识别的个人的附加信息:他可能在过去何时何地遇到过他们，他们的兴趣是什么，以及什么讨论主题将更好地用于开始对话。这是系统的核心，也是我们应该关注的地方。</p><h1 id="a1fc" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">逻辑模型</h1><p id="13ec" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">到目前为止，我们将该系统视为一个黑匣子——在深入研究细节之前，我们想知道外部发生了什么。下一步是看看系统内部做了什么来支持这些交互。为此，我们需要放大相应的序列图:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/e0008457053b70077f4f29fcfa14ff2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*3JLeLePl1mPeug43V95ZIw.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto “Recognize” Use Case, Login Sequence</figcaption></figure><p id="2c4e" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在无服务器架构的上下文中，这种类型的模型旨在回答以下问题:“系统逻辑的哪些部分需要定制开发，哪些可以委托给托管服务？”</p><p id="61b4" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">考虑到这个非常具体的问题，我们现在可以绝对精确地指定该图中每个AWS图标的语义——它将指定一些AWS完全托管服务的SDK，我们将向其委派一些活动。</p><p id="d7de" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">上面的序列图告诉我们的是，整个用户识别过程被委托给Amazon Cognito，在成功认证结束时，它会将浏览器重定向到AWS S3托管的单页面应用程序(SPA)。这是一个完全商业化的服务，我们可以预计，在未来，这种功能将被打包在一些可重用的组件中，这些组件位于AWS无服务器应用程序库(参见T2西蒙·沃德利对未来无服务器开发过程的预测)。</p><p id="fc08" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">现在让我们来看看当用户点击“加载图片”按钮时会发生什么(为了节省空间，省略了浏览器图标):</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff mj"><img src="../Images/fa3b8ae258b00adc28cd3cd5032ed04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRZNaOW1-38Vr0hnGIOqnQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto “Reconginze” Use Case, Upload Picture Sequence</figcaption></figure><p id="e9e3" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">显然，这是关于用名字标记所有在照片上被认出的脸。这里我们做一个隐含的假设，系统将只识别注册用户的脸。实际步骤非常简单:</p><ul class=""><li id="78ab" class="mk ml hu jr b js ls jw lt ka mm ke mn ki mo km mp mq mr ms dt translated">生成随机字符序列</li><li id="2706" class="mk ml hu jr b js mt jw mu ka mv ke mw ki mx km mp mq mr ms dt translated">要求AWS S3从这个随机序列加上一些固定前缀创建一个预签名的URI</li><li id="1f29" class="mk ml hu jr b js mt jw mu ka mv ke mw ki mx km mp mq mr ms dt translated">使用这个预先签名的URI将图片上传到S3</li><li id="14e8" class="mk ml hu jr b js mt jw mu ka mv ke mw ki mx km mp mq mr ms dt translated">请亚马逊Rekognition服务识别图片上的人脸</li><li id="373f" class="mk ml hu jr b js mt jw mu ka mv ke mw ki mx km mp mq mr ms dt translated">检索关于每个被识别面部的附加信息(特别是姓名)</li><li id="5f82" class="mk ml hu jr b js mt jw mu ka mv ke mw ki mx km mp mq mr ms dt translated">显示带注释的图片</li></ul><p id="1eb0" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这也是一项非常常见的任务——有许多应用程序可能需要面部标签服务。因此，它是放置在<a class="ae kn" href="https://aws.amazon.com/serverless/serverlessrepo/" rel="noopener ugc nofollow" target="_blank"> AWS无服务器应用程序库</a>的又一个很好的候选者。这仍然不是MakirOto系统的核心。</p><p id="e6a2" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">为此，我们需要另一个序列图:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff my"><img src="../Images/c7eb1c6c73c0d6b32410bb66da49a01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCq1Ip2lLZzZBcmoN6S0eg.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto “Recognize” Use Case, Select Face Sequence</figcaption></figure><p id="119d" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">当用户在图片上选择一个被标记的脸时，SPA将检索一个连接当前用户和被选择的人的子图。这些联系可能是他们都去过的一些地方(比如学校、军队服务、大学、工作场所或度假旅行)、兴趣和潜在的许多其他事情。下一步是要求定制的人工智能服务(称为Icebreaker)建议哪些主题最适合作为对话的开始。</p><p id="a7f7" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这是系统的核心领域和核心价值主张——根据可用的个人信息提出讨论主题，其余都是次要的，旨在支持核心。</p><p id="ed8d" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在这里，我们需要社会学家、心理学家、数据科学家和软件工程师之间的密切合作。在这里，我们将需要花一些时间与产品经理和业务发展，看看整个结构是否导致一个有吸引力的投资回报率，并适应潜在的竞争。此时，我们可能会考虑相同核心<a class="ae kn" href="https://hackernoon.com/tagged/technology" rel="noopener ugc nofollow" target="_blank">技术</a>的其他用例(例如，会议准备)。</p><p id="eb1f" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">上图中反映了一些具体的架构决策，即AWS Neptune将用于存储和检索连接图，整个过程将由SPA协调。这张图表反映了我对MakirOto团队基于可用演示材料所做工作的理解。这种理解可能不准确或完全错误，但我认为它以一种非常精确的形式反映出来，这比我们今天所拥有的有了很大的进步。</p><h1 id="452d" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">过程结构</h1><p id="cd78" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们已经花费了大量的时间和精力来分析系统交互和核心价值主张。这是绝对必要的一步，不能绕过——没有这一步，所有随后的步骤都将失去意义。现在，我们可以开始考虑我们需要哪些盒子来实现系统逻辑:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff mz"><img src="../Images/7d133bdc8ba0898dbcdc86afaa042e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GlgqavE00wb37ZVJUhUNgA.jpeg"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Process Structure, v1</figcaption></figure><p id="b239" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这里，每个图标表示一个计算过程实例(例如Lambda函数)或来自AWS托管服务的资源:S3桶、DynamoDB表、Rekognition图像集合、API、Route 53托管区域。所有连接线都有标准的UML语义，即指针或聚合。属于同一个子系统(即微服务)的计算和资源被打包在一个CloudFormation堆栈中。</p><p id="1bfb" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">就精确度而言，这比stage中呈现的图表有所改进，在stage中，资源图标与服务图标混在一起，并且缺少许多重要的细节:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff na"><img src="../Images/882f5eba3283f7b8137f97472831dbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*Bp3AoQtn0oQJUUV0."/></div></figure><p id="8c52" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">现在，如果我们愿意，我们可以用一些重要的容量细节(例如RAM的数量和Lambda函数的最大并发性)来注释每个图标，并用最小的访问权限来注释每个箭头。</p><p id="dbe8" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">该图仍不完善——难以理解，因此难以用于吞吐量、成本或安全性的架构分析。问题不仅在于在一个小地方挤在一起的盒子和连接的数量，还在于把太多不相关的概念放在一起。换句话说，提议的架构缺乏内聚力。让我们看看是否可以通过一些温和的重构来改进它。</p><p id="8659" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">从对系统逻辑的初步分析中，我们已经知道哪些部分构成了它的核心，哪些部分只是起辅助作用。我们可以利用这些线索将系统分解成更小、更易管理的部分。</p><p id="24c9" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">首先，让我们将与用户认证相关的所有元素提取到一个单独的微服务中:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff nb"><img src="../Images/aae2dec722ef9878dad474c22ce0e41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJoQ9tIfq2KPebEmsc-BMw.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Authentication Microservice</figcaption></figure><p id="57e0" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">现在，我们不仅精确，而且更加清晰。MakirOto认证微服务的这张图清楚地讲述了它的故事。AWS认知用户和身份池链接在一起(正常认知实践)。我添加了身份池来支持与流行的社交网络(如脸书和Twitter)联合的身份验证，从而使直接注册过程成为可选的。</p><p id="143f" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">移动应用程序将直接根据MakirOto用户池认证或注册用户，而Web应用程序用户将使用在亚马逊Route 53托管区域注册的makiroto.com域名来访问它。身份池将定义两个IAM角色:一个用于未经身份验证的用户，一个用于经过身份验证的用户。为了取悦我们的CISO，我们可能需要详细说明每个角色的具体政策，但这是另一篇文章的主题。</p><p id="30f4" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">用户池将被配置为将Web应用程序用户重定向到AWS S3托管的静态网站(同样，正常的AWS认知实践)。</p><p id="bb50" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">现在让我们提取下一个支持功能，即MakirOto Pictures微服务:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/cb7e564eb21f228d120d3478b49c92ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*c39PL7mtiOWWVnBCvxrT_w.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Pictures Microservice</figcaption></figure><p id="2456" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">我认为高内聚和松耦合是主要的架构准则。因此，我决定将所有处理图片上传和处理(URI生成、照片索引、注释)的Lambda函数放在一起，并使用一个AWS Rekognition集合来备份这个过程。不错，但是有几个问题需要考虑。</p><p id="f228" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">首先，两个Lambda函数使用AWS API Gateway包装在一个REST API中，而第三个函数(indexPhoto)应该由S3 PutObject触发器调用。这种缺乏一致性真的有道理吗？我不确定，但是为了形成我自己的观点，我需要了解MakirOto团队所做决定背后的基本原理，所以让我们暂时保持现状。</p><p id="6033" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">下一个问题是，S3桶是否应该包含在这个微服务中，通过保持上传区域与系统的其余部分完全隔离，使其更加独立，更加安全？这听起来是个合理的主意。</p><p id="42ff" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">最后一个问题是图片微服务对用户微服务的依赖性。这是一个更大的问题，因为微服务之间的直接依赖被认为是一种反模式，最终导致所谓的<a class="ae kn" href="https://books.google.co.il/books?id=oyZKDwAAQBAJ&amp;pg=PA51&amp;lpg=PA51&amp;dq=microservices+death+star+pattern&amp;source=bl&amp;ots=R63x6znfmG&amp;sig=1q-LcwdF9KrYF3F7NG9qD7OuVJU&amp;hl=iw&amp;sa=X&amp;ved=0ahUKEwjq9bjFqsjaAhXGL1AKHduABRcQ6AEIVzAJ#v=onepage&amp;q=microservices%20death%20star%20pattern&amp;f=false" rel="noopener ugc nofollow" target="_blank">死星</a>结构。我们真的需要它吗？为了理解它，让我们看看用户微服务的内部:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/e9adee0148c186840edf6fe8097e1bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*C8kYI86Jw842Be_LzLkPKA.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Users Microservice</figcaption></figure><p id="7454" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这是一个所谓的CRUD微服务，封装了对MakirOto用户记录的基本创建、检索、更新、删除操作。看起来MakirotoUsers DynamoDB表的全部目的是保存关于用户的附加信息。首先，这是用户的全名，AWS Rekognition系统不保存。第二，这些是通过Rekognition从面部提取的属性，如年龄组和性别，缓存这些属性是为了加快将来的访问。</p><p id="5f7c" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">由于annotatePhoto函数应该返回真实姓名，而不是用户id，所以在Faces(根据图片重命名，以更好地表达其主要目的)中包含该表可能是有意义的。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/9e72fb355d40bbae8c323d748e16a127.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*EoJgokp3QHsGrxZr8tW7eA.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Faces Mciroservice</figcaption></figure><p id="8c44" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">现在，我们有了更有凝聚力、更独立的微服务，这也是进一步统一的一个很好的候选。</p><p id="f8fa" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在我们将所有东西放回一起之前，让我们简单地看一下剩下的两个微服务。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/f1b37ce28534261c4ca74345c29bf418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*-gqlgL6MGnErlnKEuJqYlA.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Connections Microservice</figcaption></figure><p id="a9ca" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在这里，我决定将每个更新和检索操作包装到一个单独的Lambda函数中，以便允许细粒度的访问控制。这不一定是最佳解决方案，可能需要额外的用例分析。Lambda函数粒度是一个重要且具有挑战性的架构主题。最好将它推迟到一个单独的博客帖子。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/73b6e2b9db0f67359f7bf856bfd88e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*hdMqDwiGGlQQLipd7VQXgA.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Icebreaker Microservice</figcaption></figure><p id="02f7" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">一些技术细节仍然缺失:社交网络抓取连接，AWS SageMaker破冰船模型培训，以及维护MakirOto数据湖，但这些都是高级主题，最好推迟到单独的帖子。</p><p id="3d57" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">现在我们可以把一切都恢复原状:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff nh"><img src="../Images/3c9043d20dd11b382d65898eca700e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsDMY-ajV2sPAklcyWLyXQ.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Frontend Microservice</figcaption></figure><p id="e460" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">希望现在事情在智力上更容易管理。请记住，在这个上下文中，箭头表示具有特定访问权限的指针，仅此而已。例如，它不表示两个元件之间可能的命令或数据流动。当我们谈到无服务器应用程序的可观察性时，这种区别将会很重要。</p><p id="5d01" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">我们可能还没有完全完成。目前，每个后端微服务都有自己的API，通过AWS API Gateway公开。真的有道理吗？为什么不将后端微服务保持在Lambda级别，并将其全部包装在一个API Facade中？AWS API网关有哪些替代方案，哪些考虑因素会导致选择其中一个？好问题将在一个单独的职位。</p><h1 id="1bce" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">实现模型</h1><p id="dcdf" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">现在，我们可能想要指定一些微服务是如何在内部构建的。很可能不是每个微服务都值得这样的关注，只有那些我们认为不重要的微服务才值得关注。在我们的例子中，这就是Faces微服务:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff ni"><img src="../Images/f8ea10cd3662d0134bbcd44dab193179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMxuCKnO0Ur3yoJDFRxhwA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Faces Microservice Implementation</figcaption></figure><p id="a4d8" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这里，盒子意味着源文件和构建工件:共享模块(例如Python Eggs)、Zip文件、Lambda函数等。而箭头意味着构建依赖关系:“为了构建这个，我们需要那个。”</p><p id="f8ec" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">这个图表很有趣，有几个原因。首先，为了避免混乱，我故意决定省略许多细节，如上传的S3桶、API网关资源、Rekognition图像集合和DynamoDB表。正如经常发生的那样，不同类型的模型会重叠。当我们查看Faces微服务的流程结构时，已经记录了所有这些细节。手动复制相同的信息会非常烦人，而且我们还没有合适的工具。</p><p id="6719" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">第二，这个图反映了一个重要的架构决策，即带有Lambda函数代码的ZIP文件应该放在哪里。将源保存在上传桶中可能很有诱惑力。然而，从安全角度来看，这似乎不是正确的解决方案。将Lambda函数代码保存在一个S3桶中并不是一个好主意，外部用户可以通过这个桶进行上传。这个特殊的决定并不仅仅针对Faces微服务，而是针对所有微服务。</p><p id="4224" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">第三，这个图揭示了一些容易被忽略的东西:所有三个Lambda函数都需要在某种程度上与URI格式相协调。保持这种隐性的协调将是最有问题的选择。在这种情况下，我决定将公共逻辑提取到Python egg包中。另一种解决方案是放弃三个独立的Lambda函数，将所有计算放在一个Lambda函数中。还要记住——URI结构上的协调是决定在URI直接编码一些重要信息的结果。如果使用S3元数据，这些内部结构会有所不同。</p><h1 id="a8d4" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">部署模型</h1><p id="2f5e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们需要分析的系统架构的最后一个方面是，我们的系统将如何跨多个区域部署。为此，我们需要生产另一个模型:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff mz"><img src="../Images/3ff9c7f2935a689e8f2e33c2a6f25454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZx1wqSnk2DoVpZhzn9qrA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">MakirOto Deployment Model</figcaption></figure><p id="b230" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">上面的部署模型图展示了一个相对简单的设置，有两个区域:一个用于主要生产操作、测试和试运行，另一个用于灾难恢复备份。IP路由表仅指向Cognito认证入口点，其余部分在区域级别直接连接。除了前端，每个微服务都负责其全局复制。对于S3桶和DynamoDB表，开箱即用地支持跨区域复制；然而，对于Cognito用户池，需要采取一些特殊的措施(例如，通过Lambda函数触发器)。此外，需要以某种方式实现将生产数据导出到临时区域。反过来，这可能会带来其他模型(逻辑、流程、实现)中需要解决的额外需求。通常情况下——架构过程很少是线性的。</p><p id="4446" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">上面介绍的部署策略可能会引起争论，争论的焦点是它是否正确，或者更有可能的是，它是否为安全性、可用性和成本需求提供了足够的解决方案。机会是<strong class="jr hv">，</strong>它还不是最优的。然而，重要的是，在其目前的状态下，它以一种明确和精确的形式得到反映，使其更有利于额外的审查。</p><h1 id="7984" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结束语</h1><p id="fc55" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">软件架构更多的是关于最简单的可能解决方案的清晰交流，而不是发明一些过于复杂的东西来消化。一般来说，软件架构的当前状态，尤其是无服务器架构，远非理想——我们在日常实践中仍然没有使用一致的架构建模语言。一个主要的原因似乎是我们总是试图在一个图表或图片中放入超过它所能承受的东西。维护语义一致性是困难的，并且只有在定义明确的狭窄上下文中才可能有效。任何重要的系统都需要不止一个模型，每个模型都反映一个特定的系统方面。此外，所有这些模型必须在逻辑上相互映射，以保持整个系统的一致性。</p><p id="4511" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在这篇文章中，我使用了5种不同的模型:用例、逻辑、过程、实现和部署。事实上，我采用了P. Krutchen开发的所谓的软件架构的<a class="ae kn" href="https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf" rel="noopener ugc nofollow" target="_blank"> 4+1视图</a>方法。在最初的论文中，不同的模型被称为视图，并且整体结构使用这个图来表示:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff mz"><img src="../Images/6ab4a57104efc414e81b9eea5aca8afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9OjdUCA38kBgz50b."/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">“4+1 Views of Software Architecture”</figcaption></figure><p id="edb8" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">下表总结了视图的定义和职责:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff nj"><img src="../Images/dde7b86a8c72e4f98c46e33a6efcbf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1pWaR4pzf02uSS_fv8r-w.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Views Definitions and Responsibilities</figcaption></figure><p id="b2ac" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">在现实生活中，架构过程不太可能是线性的。更有可能的是，它会在多个视图之间来回“振荡”。例如，在MakirOto Deployment视图上工作时，我们发现我们需要一些定制的Cognito用户池复制解决方案(AWS目前还没有)。我们还发现，我们需要将生产数据导出到暂存区。这很可能会将我们带回流程视图，并且整个流程很可能需要多次迭代，直到它稳定下来。视图之间的这种来回动态如下图所示:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff nk"><img src="../Images/01c35bca516f542a38c28666b04a3d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*btv27sVefOynAjVs."/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">“4+1 Views” Interactions</figcaption></figure><p id="1e6c" class="pw-post-body-paragraph jp jq hu jr b js ls ju jv jw lt jy jz ka lu kc kd ke lv kg kh ki lw kk kl km hn dt translated">“4+1视图”模型提出了一种一致的语言来从多个角度描述软件架构，并将它们相互映射，以保持整个结构的一致性。这确实是一种基于坚实科学基础的非常强大的建模方法。有了这种语言，我们现在可以系统地推理无服务器架构的各个方面，无论是功能粒度、可观察性、性能、安全性、生产率、API还是开源策略。我们还可以评估多种架构选择，而不会陷入“你的架构对我的架构”的激烈争论。我计划在以后的文章中讨论这些话题。敬请关注。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="nl nm l"/></div></figure></div></div>    
</body>
</html>