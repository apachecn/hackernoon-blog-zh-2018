<html>
<head>
<title>Binary Exploitation ELI5– Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二进制开发Eli 5–第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/binary-exploitation-eli5-part-1-9bc23855a3d8?source=collection_archive---------3-----------------------#2018-04-30">https://medium.com/hackernoon/binary-exploitation-eli5-part-1-9bc23855a3d8?source=collection_archive---------3-----------------------#2018-04-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/af5b06ca7d34ddf8b016a19b5c20b737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgpZw68RY9MjyBCZfT6vkg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Binary Exploitation ELI5 — Part 1</figcaption></figure><h1 id="e7bb" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">0x00 —前言</h1><p id="c9fa" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">在本系列文章中，我将详细介绍不同类型的二进制漏洞，解释它们是什么，它们是如何工作的，它们背后的技术，以及针对它们的一些防御措施。在整个系列中，我将尽我所能以任何人，从初学者到1337 h4x0r，都能理解的方式解释这些攻击、防御、技术和概念。</p><p id="a3a5" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">请注意:虽然我将添加一些关键的先决知识部分，希望使这些攻击的更多技术解释更容易理解，但本系列文章不会介绍精通二进制开发领域所需的所有信息/概念/技术。</p><p id="a147" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在本文中，我们将讨论:</p><p id="e4bb" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><em class="lh"> 0x01。必备知识:应用内存<br/> 0x02。必备知识:堆栈<br/> 0x03。必备知识:函数调用并返回<br/> 0x04。攻击:堆栈缓冲区溢出<br/> 0x05。攻击:返回到libc (ret2libc)攻击</em></p><p id="5b85" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">点击下面阅读本系列的下一部分:</p><p id="f07a" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><a class="ae li" rel="noopener" href="/@danielabloom/binary-exploitation-eli5-part-2-8fd71bf214b9">二进制开发ELI5 —第二部分</a></p><h1 id="0280" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">0x01—必备知识:应用存储器</h1><p id="7310" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">当执行时，应用程序被加载到内存中，然而，众所周知，计算机的内存量是有限的，因此，在加载内容时必须非常小心，以免覆盖任何其他应用程序。为了做到这一点，计算机使用了一个叫做<em class="lh">虚拟内存</em>的概念，这个概念可以用21世纪初的电视节目<a class="ae li" href="https://www.imdb.com/title/tt0363328/?ref_=tt_ov_inf" rel="noopener ugc nofollow" target="_blank"> <em class="lh">德雷克和乔希</em></a><em class="lh"/>中的场景来完美地总结，在这个场景中，德雷克和乔希<a class="ae li" href="https://www.imdb.com/title/tt0838736/" rel="noopener ugc nofollow" target="_blank">负责将寿司组织到容器中</a>:</p><blockquote class="lj lk ll"><p id="57a2" class="ke kf lh kg b kh lc kj kk kl ld kn ko lm le kr ks ln lf kv kw lo lg kz la lb hn dt translated">在场景中，德雷克和乔希得到一份工作，他们拿着通过传送带送来的寿司，他们必须将寿司碎片整理到容器中。此外，虽然所有的寿司容器看起来完全一样，但每个容器只装一种寿司是至关重要的。</p></blockquote><p id="2100" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">所以，让我们打破类比，把它和<em class="lh">虚拟内存的概念联系起来:</em></p><p id="642b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">寿司传送带:正如我在上面所说的，计算机必须非常小心和精确地将应用程序数据放在内存中的什么位置，这样才不会被覆盖。虽然一台计算机<em class="lh">可以</em>只是简单地小心翼翼地将应用程序放入物理内存，但这最终会导致问题，因为应用程序碎片会很快填满整个空间。在上面的例子中，单个的寿司可以看作是应用程序的碎片或应用程序分配的内存块，而整个寿司集(每个容器6个)可以看作是应用程序本身。</p><p id="7b69" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><strong class="kg hv">德雷克和乔希:</strong>为了避免在传送带上塞满一块块寿司，德雷克和乔希将它们放入单独的容器中，然后让它们沿着传送带向下移动。与Drake和Josh非常相似，您的计算机也将应用程序组织和设置到称为虚拟内存位置的容器中。这些虚拟内存位置(或<em class="lh">虚拟地址空间</em>)允许应用程序认为它拥有对整个内存范围的完全控制。然而，当应用程序调用一个位置或试图在其虚拟地址空间内分配内存，而不是被授权访问任意物理内存时，计算机CPU(中央处理单元)中一个很小但极其重要的硬件MMU(内存管理单元)将应用程序的调用映射到物理内存的特定区域，并方便任何内存操作。这种内存映射允许计算机通过集中组织的查找表来组织和处理具有动态内存需求的多个应用程序。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/1e0d8f5cad398d1369bce766e1138700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78XGVWH-dajYJoaEuDiQIQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">An ASCII Diagram of the Virtual Memory Process</figcaption></figure><p id="9e1b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">同样重要的是要注意，虽然应用程序的所有代码都包含在它的虚拟地址空间中，但应用程序通常使用动态链接库(DLL)，如<em class="lh"> libc </em>或<em class="lh"> kernel32。</em>这些dll只是<strong class="kg hv">外部</strong>(不存储在应用程序的地址空间内)系统应用程序或程序从中导入代码的其他自定义应用程序。以下面的代码为例:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/be71cde3c6527cd29e09f1a5f23c050b.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*FbdRnTcxw4C6o03c1RrgnA.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A Basic C function</figcaption></figure><p id="0875" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如你所见，在这个6行程序中，我没有真正定义什么是<em class="lh"> printf </em>。但是，该程序仍将正常运行，并打印出“Hello World”。这是因为<em class="lh"> printf </em>函数是在标准C库<em class="lh"> libc、</em>中定义的系统函数。在编译过程中，<em class="lh"> libc </em>从外部链接到可执行文件。在linux系统上，您可以使用<em class="lh"> ldd </em>命令查看程序的共享库依赖关系。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/5987c39bfde79e01228bd3bac3e8d765.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*fxpwzpHW-645nEfEoxR3pg.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Displaying a program’s shared library dependencies with <strong class="bd lw">ldd</strong></figcaption></figure><p id="eae1" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如果你正在看上面的截图，并想知道<em class="lh">0xb7e 99000</em>到底是什么，嗯，那是内存中<em class="lh"> libc </em>库的地址。内存地址以十六进制格式表示。请<a class="ae li" href="https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/hexadecimal-number-system" rel="noopener ugc nofollow" target="_blank">点击这里获取更多关于十六进制数字系统</a>的信息。</p><h1 id="f5a2" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">0x02—必备知识:堆栈</h1><p id="4304" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">堆栈只是一个大型数据结构，用于在运行时存储应用程序信息和数据。堆栈的功能可以通过以下类比来简单解释:</p><blockquote class="lj lk ll"><p id="d765" class="ke kf lh kg b kh lc kj kk kl ld kn ko lm le kr ks ln lf kv kw lo lg kz la lb hn dt translated">鲍勃是一家高级餐厅的洗碗工，每天晚上他都有一堆盘子要洗。此外，在整个晚上，每当桌子被清理干净时，更多的盘子可以被添加到鲍勃的堆栈中。如果鲍勃从盘子堆的顶部以外的任何地方拿走一个盘子，它上面的所有盘子都会掉下来摔碎。</p></blockquote><p id="27f6" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">现在，简单地想象一台计算机和一堆数据对象，而不是鲍勃和一堆盘子。每当有东西<em class="lh">被推</em>到堆栈上时，它就被添加到堆栈的顶部，每当有东西<em class="lh">弹出</em>堆栈时，它就被从堆栈的顶部移除，使其成为一个<strong class="kg hv">L</strong>ast<strong class="kg hv">I</strong>n<strong class="kg hv">F</strong>first<strong class="kg hv">O</strong>ut(LIFO)机制。</p><p id="b186" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">程序使用堆栈来保存各种东西，比如函数指针(函数在内存中的位置)和变量。</p><h1 id="9976" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">0x03 —必备知识:函数调用和返回</h1><p id="a17a" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">看看下面的代码:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/5a148cd6bab51dac4f5764a3e32a1b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*uoVHyrl8ud_q1yxZf5M3CA.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A basic C program</figcaption></figure><p id="2c2b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在这个代码片段中，我们看到函数<em class="lh"> add </em>有两个整型参数，分别叫做<em class="lh"> A </em>和<em class="lh"> B </em>。在<em class="lh">主</em>函数中，我们可以看到我们调用了<em class="lh"> Add </em>，其中参数<em class="lh"> A </em>的编号为1，参数<em class="lh"> B </em>的编号为2。如果我们将这段代码分解成它的底层机器代码，我们会看到:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/b9944fd64d4e63c9bda925d23e8335c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:168/format:webp/1*kbLiqTDN5IHu2ubeMgiNVA.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Calling the add function with 2 arguments</figcaption></figure><p id="da7b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如你所见，当调用带参数的函数时，程序首先将两个参数都推到堆栈上，然后执行一个<em class="lh"> call </em>语句。这个<em class="lh">调用</em>语句重定向了程序的指令指针(指令指针就像你用来记录你正在阅读的单词的小铅笔。指令指针总是指向即将被执行的指令(即将被读取的字)，指向被调用函数的地址。然而，在导航到被调用的函数之前，<em class="lh"> call </em>语句将它下面的下一条指令的地址推到堆栈中，这样当<em class="lh"> add </em>函数返回时，它将知道从哪里继续处理。函数应该返回的位置的地址被称为函数返回指针。</p><h1 id="ec5a" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">0x04 —攻击:堆栈缓冲区溢出</h1><p id="e486" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">在深入了解什么是堆栈缓冲区溢出以及它们如何工作的技术细节之前，让我们先来看一个快速、易于理解的类比:</p><blockquote class="lj lk ll"><p id="c3d3" class="ke kf lh kg b kh lc kj kk kl ld kn ko lm le kr ks ln lf kv kw lo lg kz la lb hn dt translated">爱丽丝和鲍勃曾经约会过，但是爱丽丝最终和鲍勃分手了。随着时间的推移，爱丽丝继续前进，但鲍勃从未真正走出心碎的阴影。现在，爱丽丝要和鲍勃的死对头罗伯特·哈克曼结婚了。鲍勃是一个令人毛骨悚然的怪人，他通过秘密进入爱丽丝的电子邮件帐户窥探爱丽丝的所有婚礼计划。Bob发现Alice雇佣了一位著名的婚礼蛋糕设计师，这位设计师希望Alice根据自己的口味偏好修改部分食谱。设计师给了爱丽丝一份推荐的配料清单，但说他会准确地做她想要的任何事情。Bob打开了附在设计师电子邮件中的文档，看到配方的自定义行如下所示:</p></blockquote><p id="1927" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><em class="lh"> …然后，我们将通过添加______来增加糖霜的味道。之后，我们会加一些巧克力…</em></p><blockquote class="lj lk ll"><p id="b867" class="ke kf lh kg b kh lc kj kk kl ld kn ko lm le kr ks ln lf kv kw lo lg kz la lb hn dt translated">Bob注意到，如果您在行中输入“Banana ”,文本看起来会像这样:</p></blockquote><p id="c08c" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">然后，我们会加入香蕉来增加糖霜的味道。之后，我们会加入一些巧克力… </p><blockquote class="lj lk ll"><p id="1b8e" class="ke kf lh kg b kh lc kj kk kl ld kn ko lm le kr ks ln lf kv kw lo lg kz la lb hn dt translated">但是，如果Bob在该行中输入“Strawberry ”,文本将看起来像这样:</p></blockquote><p id="2d97" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><em class="lh"> …然后，我们会加入草莓来增加糖霜的味道，然后，我们会加入一些巧克力… </em></p><blockquote class="lj lk ll"><p id="1648" class="ke kf lh kg b kh lc kj kk kl ld kn ko lm le kr ks ln lf kv kw lo lg kz la lb hn dt translated">鲍勃意识到这将是破坏爱丽丝婚礼的完美方式，他所要做的就是用他自己恶心的版本覆盖食谱的其余部分！在爱丽丝结婚那天，设计师终于展示了他做的蛋糕——上面爬满了虫子，是用冷冻蛋黄酱做的！</p></blockquote><p id="0924" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">堆栈缓冲区溢出很像Bob的攻击，会覆盖开发人员不想覆盖的数据，从而完全控制程序及其输出。</p><p id="ad63" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">那么，现在让我们在现实世界中看看。看看下面这段来自<a class="ae li" href="https://exploit-exercises.com/protostar/stack0/" rel="noopener ugc nofollow" target="_blank">exploit-exercises.com</a>的代码:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/a3ce14fb13c19b069abfe277f56da129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6KnBsIUSkZ9nv4_8285JQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Exploit-Exercises.com Protostar Stack0 Code</figcaption></figure><p id="0538" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在上面的函数中，我们看到创建了一个名为<em class="lh"> buffer </em>的字符类型数组，大小为64。然后，我们看到<em class="lh">修改的</em>变量被设置为0，并且<em class="lh">获取</em>函数被调用，其中<em class="lh">缓冲</em>变量作为参数。最后，我们看到一个IF语句，它检查modified是否不为0。很明显，在这个应用程序中没有将<em class="lh">修改后的</em>变量设置为除0以外的任何值，那么我们要如何改变它呢？</p><p id="a2a8" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">好吧，我们先来看看<em class="lh">获取</em>函数的文档:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/8e23249fbf105ebbeaf46d7a4a40b4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kOoA6trsMdkeR-Uk_6fIg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">gets function defined</figcaption></figure><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/f4e2678a2a26e63bf2f7788917a226a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjlML0a-61Xs2XqWVjhSCw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">gets function bugs section</figcaption></figure><p id="1d97" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如您所见，<em class="lh"> gets </em>函数只是接收用户输入。然而，该函数不检查用户输入是否真正适合我们存储它的数据结构(在本例中，是<em class="lh"> buffer </em>),因此，我们能够溢出数据结构并影响堆栈上的其他变量/数据。此外，因为我们知道所有变量都存储在堆栈中，并且我们知道修改的变量是什么(0)，所以我们所要做的就是输入足够的输入来覆盖修改的变量。让我们来看一个图表:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/67606e91acdd20e385e3df3cae1d2f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*WMDKWlMeYB13xXUxT2Gc7w.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">an ASCII diagram of a stack buffer overflow</figcaption></figure><p id="a15b" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如您所见，如果恶意用户输入了太多的文本，他们可以覆盖修改后的变量和堆栈上的任何内容，包括返回指针。这意味着，如果一个恶意代理能够控制一个程序堆栈，他们就能够有效地控制整个程序，并使它为所欲为。他们可以简单地将堆栈上的函数返回指针改写为指向恶意负载的自定义指针。</p><h1 id="1809" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">0x05 —攻击:ret2libc</h1><p id="d0df" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">在我们讨论ret-to-libc(ret 2 libc)攻击之前，让我们花点时间更深入地讨论一下<em class="lh"> libc </em>。</p><p id="042c" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">我们知道(从0x01节)，<em class="lh"> libc </em>是标准的C库。这意味着它包含了C编程语言中所有的通用系统函数。现在，如果一个恶意用户能够控制程序来执行这些功能，那会怎么样呢？</p><p id="c946" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">嗯，ret2libc就是这么回事。ret2libc的后果的一个完美类比是<a class="ae li" href="https://www.imdb.com/title/tt0133093/" rel="noopener ugc nofollow" target="_blank">黑客帝国系列</a>。回想一下经典的“枪，很多枪”场景。坦克，操作员，能够完全绕过并重新编程矩阵，让一吨的枪凭空出现。</p><p id="f38e" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">你可以这样想回到libc，我们能够控制matrix(标准C库),让它做我们想做的任何事情。</p><p id="f88e" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">从根本上说，ret2libc攻击实际上是基于堆栈缓冲区溢出。回想一下我在第0x04节末尾说过的话，如果恶意代理可以覆盖堆栈上的数据，他们可以简单地覆盖返回指针以指向libc中的特定函数，并向其传递传递有效负载所需的任何参数。</p><p id="448f" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">ret2libc攻击最常用的函数之一是<em class="lh">系统</em>函数。让我们看看它的文档:</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/cdd67467ea2bfdca85122e9a11efa12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJlp_wsD8OpdOMiPIU6L0A.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">the system command’s documentation</figcaption></figure><p id="d2e9" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如您所见，系统命令只是执行shell命令(T2 shell T3是linux命令行)。此外，如果我们仔细阅读描述，我们可以看到系统只是简单地执行了<em class="lh"> /bin/sh -c &lt;命令&gt; (/bin/sh </em>是实际的shell命令)，并且该命令是通过一个参数传递给函数的。</p><p id="5610" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">因此，要获得对运行有漏洞的应用程序的<strong class="kg hv">机器</strong>的<strong class="kg hv">命令行访问权，我们所要做的就是将“/bin/sh”作为参数推送到堆栈上，然后用系统函数的内存地址替换返回或调用指针，这样就可以使用/bin/sh作为参数来调用函数，启动shell并授予我们对系统的完全访问权。</strong></p><p id="3309" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><em class="lh">战功，很多战功。</em></p><h1 id="05dc" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">0x06 —第1部分结论</h1><p id="f8db" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">在本文中，我们讨论了:</p><p id="1805" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><em class="lh"> 0x01。虚拟内存以及如何在内存中处理应用程序<br/> 0x02。动态链接库和libc <br/> 0x03。堆栈<br/> 0x04。函数如何被调用以及从函数返回如何工作<br/> 0x05。堆栈缓冲区溢出<br/> 0x06。返回到libc (ret2libc)攻击</em></p><p id="9bce" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">我希望这篇文章是有帮助的。点击下面继续阅读本系列的第2部分:</p><p id="b9ac" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><a class="ae li" rel="noopener" href="/@danielabloom/binary-exploitation-eli5-part-2-8fd71bf214b9">二进制开发ELI5 —第二部分</a></p><p id="b29c" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">另外，如果你对逆向工程感兴趣，请查看我的<em class="lh">博洛:逆向工程</em>文章系列:</p><p id="bcb6" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><a class="ae li" rel="noopener" href="/bugbountywriteup/bolo-reverse-engineering-part-1-basic-programming-concepts-f88b233c63b7"> BOLO:逆向工程—第一部分(基本编程概念)</a> <br/> <a class="ae li" rel="noopener" href="/@danielabloom/bolo-reverse-engineering-part-2-advanced-programming-concepts-b4e292b2f3e"> BOLO:逆向工程—第二部分(高级编程概念)</a></p><p id="c847" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">而且，如果你正在寻找更多的ELI5内容，请查看我的<a class="ae li" href="https://hackernoon.com/explain-spectre-and-meltdown-like-im-5-494a6ba61061" rel="noopener ugc nofollow" target="_blank">解释Spectre和Meltdown Like I 5</a>文章。</p><p id="ba42" class="pw-post-body-paragraph ke kf hu kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><strong class="kg hv"> <em class="lh">推【感谢】<br/>推【感谢】<br/>呼唤阅读</em> </strong></p></div></div>    
</body>
</html>