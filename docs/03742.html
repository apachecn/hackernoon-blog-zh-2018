<html>
<head>
<title>Dockerizing our Haskell App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整理我们的Haskell应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dockerizing-our-haskell-app-d910c1362d12?source=collection_archive---------26-----------------------#2018-04-30">https://medium.com/hackernoon/dockerizing-our-haskell-app-d910c1362d12?source=collection_archive---------26-----------------------#2018-04-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a68c82d4d88aa66da8d7be85b0f6d550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T95_ade63KQINMYmlgjirg.jpeg"/></div></div></figure><p id="cc34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://mmhaskell.com/blog/2018/4/23/deploying-confidently-haskell-and-circle-ci" rel="noopener ugc nofollow" target="_blank">上周</a>，我们探索了如何用Circle CI自动部署我们的Haskell应用程序。每当我们推出一个分支时，Circle CI会将我们的代码加载到一个容器中，构建它，并运行我们的任何测试。我们还配置Heroku在主分支通过构建时部署我们的新代码。</p><p id="a6b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的系统有几个弱点。首先，我们的配置要求我们每次都要下载堆栈程序，这有点麻烦。设置堆栈需要我们Circle配置中大约一半的命令！第二个缺点是我们在每次部署时都构建了两次代码。首先，Circle容器会构建它。然后Heroku也会编译它。本周，我们将使用Docker图像解决这些问题。</p><h1 id="f78e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用Docker图像</h1><p id="7c6e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">上周我们用了一个香草圆形容器。我们可以通过使用预先存在的Docker映像来简化我们的配置。还记得我们<code class="eh le lf lg lh b">build_project</code>部分的开头吗？它看起来像这样:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="54c0" class="lq kc hu lh b fv lr ls l lt lu">jobs:<br/>  build_project:<br/>    machine: true</span></pre><p id="ea27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关键字<code class="eh le lf lg lh b">machine</code>告诉Circle使用一个未配置的Linux机器。因为上面什么都没有，我们需要自己下载并安装Stack。然而，Circle也允许我们使用Docker图像作为我们机器的起点。我们将使用来自<a class="ae ka" href="https://hub.docker.com/r/library/haskell/tags/" rel="noopener ugc nofollow" target="_blank"> Haskell Docker库</a>的图像。这些都有一个特定版本的GHC安装，后来的也有堆栈。这些图片比GHC发布的稍晚一些。因此，我们将使用GHC 8.0.2，并更新我们的<code class="eh le lf lg lh b">stack.yaml</code>文件，以使用LTS 9.21，这是GHC的最新版本。下面是我们如何编写我们的圆配置来使用这个图像:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="2f68" class="lq kc hu lh b fv lr ls l lt lu">jobs:<br/>  build_project:<br/>    docker:<br/>      - image: haskell:8.0.2</span></pre><p id="3831" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以从根本上简化文件的其余部分！堆栈和GHC将预装，所以我们可以删除所有相关的步骤。我们还将删除已安装的堆栈目录上的缓存步骤。这留给我们以下配置文件:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="6002" class="lq kc hu lh b fv lr ls l lt lu">version: 2<br/>jobs:<br/>  build_project:<br/>    docker:<br/>      - image: haskell:8.0.2<br/>    steps:<br/>      - checkout<br/>      - restore-cache:<br/>        keys:<br/>          - stack-work-{{checksum “stack.yaml”}}-\<br/>                       {{checksum “HaskellTestApp.cabal”}}<br/>      - run: stack setup<br/>      - run: stack build<br/>      - run: stack test<br/>      - save_cache:<br/>        key: stack-work-{{checksum “stack.yaml”}}-\<br/>                        {{checksum “HaskellTestApp.cabal”}}<br/>        paths:<br/>          - “.stack-work”</span><span id="0e8a" class="lq kc hu lh b fv lv ls l lt lu">workflows:<br/>  version: 2<br/>  build_and_test:<br/>    jobs:<br/>      - build_project</span></pre><h1 id="6385" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">打造我们自己的码头工人形象</h1><p id="681a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在我们的构建更有效率了，但是我们还没有解决系统中更大的问题。在本文的其余部分，我们将使用Docker创建一个新的图像，并在其上构建我们的代码。然后我们可以将这个映像推送到Heroku，而不是用buildpack重新构建我们的代码。</p><p id="f813" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为此，我们将把一些现有的Circle配置工作并入Docker本身。首先，我们需要在项目的根处定义一个<code class="eh le lf lg lh b">Dockerfile</code>。这个文件指定了Docker需要运行的命令，以便用我们的代码创建一个映像并运行服务器。这是我们的样子:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="09b4" class="lq kc hu lh b fv lr ls l lt lu"># Use the existing Haskell image as our base<br/>FROM haskell:8.0.2</span><span id="19c5" class="lq kc hu lh b fv lv ls l lt lu"># Checkout our code onto the Docker container<br/>WORKDIR /app<br/>ADD . /app</span><span id="e5ea" class="lq kc hu lh b fv lv ls l lt lu"># Build and test our code, then install the “run-server” executable<br/>RUN stack setup<br/>RUN stack build --test --copy-bins</span><span id="f3f5" class="lq kc hu lh b fv lv ls l lt lu"># Expose a port to run our application<br/>EXPOSE 80</span><span id="ae7e" class="lq kc hu lh b fv lv ls l lt lu"># Run the server command<br/>CMD [“run-server”]</span></pre><p id="fe21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个重要的部分是我们将“继承”我们在Circle和<code class="eh le lf lg lh b">FROM</code>上使用的Haskell Docker图像。然后，我们将运行安装命令，并构建项目。我们将把参数传递给<code class="eh le lf lg lh b">build</code>，它将运行测试，并安装我们的可执行文件。然后，我们将从容器中运行服务器。</p><h1 id="67c4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">在Circle上建立我们的码头工人形象</h1><p id="bb67" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了在远程存储库上实际保存Docker映像，我们需要创建一个Docker帐户。我们不需要创建自己的存储库，因为我们最终会将我们的图像存储在Heroku存储库中。</p><p id="0866" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们不再需要运行堆栈命令作为循环配置的一部分。码头工人替我们处理。我们可以回到使用普通机器，因为Docker也处理使用Haskell映像。以下是我们在Circle上的核心配置:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="2c35" class="lq kc hu lh b fv lr ls l lt lu">jobs:<br/>  build_project:<br/>    machine: true<br/>    steps:<br/>      - checkout<br/>      - run: echo $DOCKER_PASSWORD | docker login \<br/>                                     --username=$DOCKER_USERNAME \<br/>                                     --password-stdin<br/>      - run: docker pull \                <br/>               registry.heroku.com/$HEROKU_APP/web:$CIRCLE_BRANCH<br/>      - run: docker build -t \<br/>               registry.heroku.com/$HEROKU_APP/web:$CIRCLE_BRANCH<br/>      - run: docker push \<br/>               registry.heroku.com/$HEROKU_APP/web:$CIRCLE_BRANCH</span></pre><p id="48db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关键命令显然是四个<code class="eh le lf lg lh b">docker</code>命令。首先，我们使用凭据作为环境变量登录Docker帐户。接下来，我们将从与我们的应用程序相关的Heroku图像库中提取现有图像。我们不需要做任何事情来设置这个存储库，但我们需要配置应用程序来使用它。然后我们构建我们的容器并用我们当前的分支名称标记它。只要成功了，我们就会把这个新图像推回我们的Docker存储库。</p><h1 id="4a27" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Heroku集成</h1><p id="dcbd" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了在Heroku上使用这个图像，我们需要从仪表板再次更新应用程序的“部署”部分。我们将使用Heroku注册表选项，而不是使用Circle CI。现在，我们成功的构建将把我们的代码上传到我们的Heroku注册表。然后Heroku自动更新我们的app！另外，我们现在也不需要在Heroku上重建代码了！</p><p id="a3a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过，还有一点需要注意。为了从Heroku注册表进行推和拉，我们还需要从我们的circle机器登录Heroku。Circle CI版本2还没有对此的内置支持，所以有点棘手。在我们自己的机器上，我们将使用带有<code class="eh le lf lg lh b">heroku login</code>命令的CLI登录Heroku。但是我们不能像使用Docker的login命令那样使用<code class="eh le lf lg lh b">stdin</code>命令。</p><p id="b545" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我们可以用一个小脚本复制登录的最终结果。登录Heroku会创建一个名为<code class="eh le lf lg lh b">~/.netrc</code>的文件来存储我们的凭证。我们可以编写这样的脚本来输出所有的信息:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="57c7" class="lq kc hu lh b fv lr ls l lt lu">#! /bin/bash</span><span id="331d" class="lq kc hu lh b fv lv ls l lt lu">cat &gt; ~/.netrc &lt;&lt; EOF<br/>machine api.heroku.com<br/>  login $HEROKU_LOGIN<br/>  password $HEROKU_PASSWORD<br/>machine git.heroku.com<br/>  login $HEROKU_LOGIN<br/>  password $HEROKU_PASSWORD<br/>EOF</span><span id="a7f8" class="lq kc hu lh b fv lv ls l lt lu">heroku container:login</span></pre><p id="d964" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们运行最后的<code class="eh le lf lg lh b">heroku container</code>命令来实际连接到存储库。注意<code class="eh le lf lg lh b">$HEROKU_PASSWORD</code>环境变量应该使用您的Heroku API密钥，而不是您的Heroku密码。我们称该变量为<code class="eh le lf lg lh b">PASSWORD</code>，因为<code class="eh le lf lg lh b">HEROKU_API_KEY</code>环境变量是特殊的。过早设置它可能会导致CLI出现问题。</p><p id="bda2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个脚本保存为<code class="eh le lf lg lh b">setup_heroku.sh</code>，我们可以像这样从我们的Circle脚本中调用它:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="f1d9" class="lq kc hu lh b fv lr ls l lt lu">jobs:<br/>  build_project:<br/>    machine: true<br/>    steps:<br/>      - checkout<br/>      - bash .circleci/setup_heroku.sh<br/>      ...</span></pre><p id="bed6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在一切都应该工作了！我们的应用程序应该会自动部署到Heroku，无需重新编译！</p><h1 id="aaae" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="07a5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们现在已经大大提高了部署流程的效率。首先，我们使用Docker Haskell映像来避免手动下载Stack。然后，我们在此基础上创建了自己的Docker映像，并将其推送到注册表中。一旦我们将Heroku应用程序连接到这个注册表，我们就不再需要在那里编译它了。下周，我们将通过使用类似的过程将我们的代码推送到AWS而不是Heroku来结束这个系列。</p><p id="6fef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在您可以部署您的代码，您可以创建任何您想要的Haskell应用程序！下载我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">制作清单</a>，获得更多可以在应用中使用的库的想法。</p><p id="f1ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你以前从未使用过Haskell，下载我们的<a class="ae ka" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>开始吧！</p></div></div>    
</body>
</html>