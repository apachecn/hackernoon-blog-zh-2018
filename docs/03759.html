<html>
<head>
<title>Practical Data Structures for Frontend Applications: When to use Segment Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端应用的实用数据结构:何时使用段树</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/practical-data-structures-for-frontend-applications-when-to-use-segment-trees-9c7cdb7c2819?source=collection_archive---------1-----------------------#2018-05-01">https://medium.com/hackernoon/practical-data-structures-for-frontend-applications-when-to-use-segment-trees-9c7cdb7c2819?source=collection_archive---------1-----------------------#2018-05-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/39b53dc5f0b3755e32c8413455fb62b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*uouuqiYFxIoBZFFWb3pN0w.png"/></div></figure><p id="6f60" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">网上有很多教程向开发者展示如何编写各种数据结构。没有很多教程显示如何、何时或是否使用它们。在本系列中，我将介绍数据结构在前端应用程序中的实际用途和含义。在本期中，我们将回顾细分市场树。</p><h1 id="ae66" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">什么是细分树</h1><p id="d851" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">细分树是一种数据结构，可用于执行范围查询和范围更新。它是一个高度平衡的二叉树，通常建立在数组之上。分段树可用于在O(log n)时间内解决范围最小/最大&amp;和查询和范围更新查询。</p><p id="58d9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">分段树的工作方式类似于其他树数据结构。它创建的查询路径限制了返回数据所需的处理量。树的每个中间节点代表数据集的一个<em class="la">段</em>。根节点包含树中所有数字的总和。其子节点包含各自范围内所有数字的总和，依此类推，沿树向下到叶节点。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/d1138d9468ebcb8d2576e93c17059a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*A5pXA5_8iuxHYbgTqltLGA.png"/></div></figure><h1 id="c3f1" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">何时使用细分树</h1><p id="9257" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">当你经常使用大量的数字数据时，分段树是很有用的。细分树最常见的使用案例有:</p><ol class=""><li id="f5aa" class="lg lh hu ja b jb jc jf jg jj li jn lj jr lk jv ll lm ln lo dt translated">对一个范围内的所有元素求和。</li><li id="4b9e" class="lg lh hu ja b jb lp jf lq jj lr jn ls jr lt jv ll lm ln lo dt translated">查找一个范围内元素的最小值或最大值。</li><li id="94ac" class="lg lh hu ja b jb lp jf lq jj lr jn ls jr lt jv ll lm ln lo dt translated">更新一个范围内的所有元素。</li></ol><p id="73fa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这并不意味着使用段树仅限于处理数字。例如，您可以使用段树来查找符合特定标准的所有区间(或范围)。这方面的经典例子是<a class="ae kz" href="https://www.geeksforgeeks.org/range-queries-longest-correct-bracket-subsequence/" rel="noopener ugc nofollow" target="_blank">支架问题</a>。</p><h1 id="d2e6" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">在前端应用程序中使用分段树</h1><p id="5992" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">注意:<em class="la">各种JavaScript引擎都会实现JavaScript规范。不一样。因此，不同环境的性能结果可能会有所不同。</em></p><p id="1822" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">JavaScript中表示集合的最常见方式是使用数组。为了找出在前端应用中使用段树是否有意义，让我们对比一下在相同的任务中使用段树和数组。以下是我们用来评估他们的标准:</p><ul class=""><li id="64f4" class="lg lh hu ja b jb jc jf jg jj li jn lj jr lk jv lu lm ln lo dt translated">性能(运行时间和加载时间)</li><li id="61bb" class="lg lh hu ja b jb lp jf lq jj lr jn ls jr lt jv lu lm ln lo dt translated">易用性和可读性</li></ul><h2 id="14fe" class="lv jx hu bd jy lw lx ly kc lz ma mb kg jj mc md kk jn me mf ko jr mg mh ks mi dt translated">设置</h2><ul class=""><li id="3ae1" class="lg lh hu ja b jb ku jf kv jj mj jn mk jr ml jv lu lm ln lo dt translated">我在Vue中用<code class="eh mm mn mo mp b">vue cli</code>写了一个快速投标表格。它看起来是这样的:</li></ul><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mq"><img src="../Images/8362e22efd68213da6da29531807471d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aGNKq41tkxR7QY6TVI99Lg.gif"/></div></div></figure><ul class=""><li id="5a2c" class="lg lh hu ja b jb jc jf jg jj li jn lj jr lk jv lu lm ln lo dt translated">我找不到我喜欢的JavaScript中的段树实现。所以，在<a class="ae kz" href="https://algs4.cs.princeton.edu/home/" rel="noopener ugc nofollow" target="_blank">算法书</a>网站的一点帮助下，我<a class="ae kz" href="https://github.com/joe-crick/practical-data-structures" rel="noopener ugc nofollow" target="_blank">推出了自己的</a>。</li><li id="5539" class="lg lh hu ja b jb lp jf lq jj lr jn ls jr lt jv lu lm ln lo dt translated">我用<code class="eh mm mn mo mp b"><a class="ae kz" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank">faker</a></code>生成了一组10000的出价。</li></ul><h2 id="a855" class="lv jx hu bd jy lw lx ly kc lz ma mb kg jj mc md kk jn me mf ko jr mg mh ks mi dt translated">密码</h2><p id="4923" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">这是网格的基本代码。注意，它不使用任何特定的集合数据结构。分段树和阵列的实现细节如下。</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure><p id="0285" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以下是基于数组的代码:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure><p id="5bf3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以下是基于细分树的代码:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure><h2 id="baa3" class="lv jx hu bd jy lw lx ly kc lz ma mb kg jj mc md kk jn me mf ko jr mg mh ks mi dt translated">表演</h2><p id="2e88" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">我测试了三样东西的性能:</p><ol class=""><li id="1642" class="lg lh hu ja b jb jc jf jg jj li jn lj jr lk jv ll lm ln lo dt translated">将数据项加载到数据结构中。</li><li id="c35d" class="lg lh hu ja b jb lp jf lq jj lr jn ls jr lt jv ll lm ln lo dt translated">在数据结构中搜索一个范围内的最小值。</li><li id="078a" class="lg lh hu ja b jb lp jf lq jj lr jn ls jr lt jv ll lm ln lo dt translated">对一个范围内的值求和。</li></ol><p id="99bd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所有测试都是使用Chrome 65.x进行的。每个查询使用的数据范围是1-3000。</p><p id="0c50" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">加载数据项<br/>T5】段树初始化时间为O(n*log(n))。为了让您实际了解这一点，向细分树添加10，000个项目平均需要2.6秒。</strong></p><p id="7e0f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在大多数情况下，在前端，类似BidGrid中的数据将从数组中的后端API提供给应用程序。在这种情况下，我们的数据结构中已经有了数据；没必要讨论加载时间。</p><p id="cdb3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">范围最小值查询</strong> : <br/>该查询查找范围内的最小值。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/176e861c197e63be78b3822a75a5ba36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*IZjXMPMq6XX96N1MqR908Q.png"/></div></figure><p id="42ef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">基于段树的查询比基于数组的查询快得多。速度快了2250%。</p><p id="1de1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">范围求和</strong> : <br/>该查询对范围内的所有值求和。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/386f8124a654e04b77aeecf8065d7ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*vgq6Vzo3PcXF3jHHhDhQww.png"/></div></figure><p id="4203" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">再次，细分树是惊人的。它比数组方法快2140%。</p><p id="f733" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="la">注意</em>:在上面的测试中，最初的sum查询花费了大约1秒钟。所有后续的sum查询大约都是0.25秒，即使查询范围发生了变化。</p><h2 id="c684" class="lv jx hu bd jy lw lx ly kc lz ma mb kg jj mc md kk jn me mf ko jr mg mh ks mi dt translated">易用性</h2><p id="3b13" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">使用段树完成这项任务比使用数组更容易。没有必要创建<code class="eh mm mn mo mp b">filter </code>或<code class="eh mm mn mo mp b">reduce </code>方法来获得想要的结果。细分树内置了所有的查询方法。</p><p id="bc4c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面的代码片段对比了段树和数组所需的代码:</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure><h1 id="4e13" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">结论</h1><p id="5bdd" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">当您有一个搜索密集型应用程序对数据集执行大量特定范围的查询(例如，sum、min和max查询)时，细分树是一个<em class="la">惊人的</em>数据结构。如果应用程序需要，在前端应用程序中使用段树肯定是有意义的。</p><p id="7aba" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用段树而不是数组可能会有一些性能成本，例如:</p><ul class=""><li id="ad80" class="lg lh hu ja b jb jc jf jg jj li jn lj jr lk jv lu lm ln lo dt translated">段树初始化。这是每个细分树的一次性成本。因此，建议您将段树的初始化推迟到页面加载之后。</li></ul></div></div>    
</body>
</html>