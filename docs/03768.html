<html>
<head>
<title>Generating the Nth Cartesian Product</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成第n个笛卡尔乘积</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/generating-the-nth-cartesian-product-e48db41bed3f?source=collection_archive---------10-----------------------#2018-05-01">https://medium.com/hackernoon/generating-the-nth-cartesian-product-e48db41bed3f?source=collection_archive---------10-----------------------#2018-05-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2d4a607814eba736bcba544faba03a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JRK5dvPFXQwphzhU.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image courtesy of <a class="ae jg" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="39d3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">注:本文更新时间为2018-11-12。有关更多信息，请参见本文末尾的“更新”一节。</strong></p><p id="14d0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近在我的工作中，我们遇到了一个问题:我们需要生成一组问题和答案的一些可能的组合，但我们只需要这些组合的一个小子集。另外，我们需要这个子集随机分布在各种可能性中(同时保持均匀分布)。这样，在基于我们的组合运行一些统计数据后，我们可以生成一个强大的数据模型。</p><p id="b492" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，我们可以生成所有可能的组合，并使用内置的库随机选择一些可能的组合。当您的可能组合范围相对较小时(少于1，000，000；给或拿)。但是当你有<strong class="jj hv"> 197，074，944 </strong>种可能的组合时呢？是的，这是我们的一小组问题和答案的可能组合。</p><p id="58f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">如果您想跳到实际实现，请随意向下滚动到章节:</em> <strong class="jj hv"> <em class="kf">使用Python的解决方案</em> </strong></p><h1 id="06fb" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">如何不去处理这个问题</h1><p id="5b3a" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我尝试做的第一件事是使用Python的<code class="eh lj lk ll lm b">itertools</code>库一次生成所有的组合，然后从列表中选择一个随机子集。关于<code class="eh lj lk ll lm b">itertools</code>的好处是它会很快生成这些组合<strong class="jj hv"/>。不太好的是，它将生成所有197，074，944个组合<strong class="jj hv">非常快</strong>，这意味着在一眨眼的时间里，我看到我的RAM消耗在大约5秒内从大约2GB增加到我的机器的最大值。在那之后，脚本一直试图使用分页内存来建立这些组合，我不得不做一个硬复位来让我的机器复活。</p><p id="b0c5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">显然，这种方法不适用于如此大的一组组合。</p><p id="95ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要找到一种方法来避免填满内存空间，同时保持合理的性能。</p><h1 id="be1e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">输入:懒惰的笛卡尔积</h1><p id="fccc" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">花了几个小时研究这个话题，我终于看到了这篇精彩的文章:<a class="ae jg" href="http://phrogz.net/lazy-cartesian-product" rel="noopener ugc nofollow" target="_blank">http://phrogz.net/lazy-cartesian-product</a>。作者在解释一些理论以及用JavaScript实现方面做得非常出色。</p><p id="cab3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">TL；DR:你可以在索引<em class="kf"> n </em>找到笛卡尔乘积的任意组合，而不需要计算每一个组合。</p><p id="2020" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这个算法，您现在几乎可以消除内存空间的问题，在计算一个条目时大致保持<em class="kf"> O(1) </em>的性能，如果存储组合，只需要担心磁盘空间。</p><p id="f8ca" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另外，我们现在可以找到条目的子集，而不需要计算所有可能的组合。</p><h1 id="cee0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">Python解决方案</h1><p id="de8a" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">使用上面链接中的伪代码，生成的Python代码如下:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="f0c3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是一个展示代码如何运行的示例:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="8ff5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们在终端中运行这个程序，我们将得到以下结果:</p><pre class="ln lo lp lq fq lt lm lu lv aw lw dt"><span id="c769" class="lx kh hu lm b fv ly lz l ma mb">$ python example.py<br/>[1, 'foo', 'z', 'three']<br/>[2, 'bar', 'y', 'three']<br/>[4, 'bar', 'y', 'two']<br/>$</span></pre><h1 id="da74" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">最终结果</h1><p id="741f" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在我的工作中，我们将它包装在一个脚本中，这样我们可以生成大约1，000，000个记录的随机子集(从197，074，944个可能的组合中)，并将这些组合保存到一个<code class="eh lj lk ll lm b">.csv</code>文件中。总之，在我的机器上，该脚本只花了大约10秒钟就完成了(很可能是由于文件I/O)。</p><p id="6bd0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最终，该算法可以根据需要用任何其他语言实现。对于我的工作，我也用C#编写了一个桌面应用程序的算法，我可以想象用C/Rust编写的东西会产生更高性能的结果。</p><h1 id="eb0b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">更新</h1><p id="74aa" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">经过进一步检查，当生成的组合数量开始增加时，上面的当前代码开始失效。简而言之就是:Python执行浮点除法的方式导致算法在试图计算下一个要选择的元素的索引时失败。感谢<a class="ae jg" href="https://github.com/wouda" rel="noopener ugc nofollow" target="_blank"> woudsma </a>使用<a class="ae jg" href="https://pypi.org/project/bigfloat/" rel="noopener ugc nofollow" target="_blank"> bigfloat </a>软件包找到了解决方案:</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="97c9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您发现您的结果不正确，我强烈推荐使用这个优秀的代码分支。</p><p id="e8dc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关于进一步的讨论，请参见下面详细介绍这些发现的回复。</p></div></div>    
</body>
</html>