<html>
<head>
<title>Flutter + Redux — How to make Shopping List App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter + Redux —如何制作购物清单App</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/flutter-redux-how-to-make-shopping-list-app-1cd315e79b65?source=collection_archive---------1-----------------------#2018-05-02">https://medium.com/hackernoon/flutter-redux-how-to-make-shopping-list-app-1cd315e79b65?source=collection_archive---------1-----------------------#2018-05-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/def071f1e8eb6777d963c9a6fecf4aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogNimrTnf_COR7ImVFr3-A.png"/></div></div></figure><div class=""/><p id="a3d3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大家好！在这篇文章中，我将向你展示如何使用<strong class="je ig"> Redux </strong>创建<strong class="je ig"> Flutter </strong>应用程序。如果你不知道什么是Flutter，我鼓励你阅读我的文章<a class="ae ka" rel="noopener" href="/@pszklarska/flutter-5-reasons-why-you-may-love-it-55021fdbf1aa">Flutter——你可能会喜欢它的5个理由</a>。然而，如果你知道什么是Flutter，并且你想创建一个设计良好、易于测试、行为可预测的应用程序，那么继续阅读吧！</p><h1 id="c476" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Redux是什么？</h1><p id="59e5" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">首先，让我们从解释什么是<strong class="je ig"> Redux </strong>开始。<a class="ae ka" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>是一个应用架构，最初是为JavaScript做的，现在用在用<strong class="je ig">反应式框架</strong>构建的应用中(比如React Native或者Flutter)。Redux是简化版的<a class="ae ka" href="https://facebook.github.io/flux/docs/overview.html" rel="noopener ugc nofollow" target="_blank"> Flux </a>架构，由脸书制造。但是Redux是怎么回事呢？基本上，你需要知道三件事:</p><ol class=""><li id="11d2" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">有一个<strong class="je ig">真实的单一来源</strong>——您的整个应用程序状态只保存在一个地方(称为store)</li><li id="8a7a" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><strong class="je ig">状态是只读的</strong>——要更改应用程序状态，您需要分派一个动作，然后创建新状态</li><li id="1b84" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">用<strong class="je ig">纯函数</strong>做了改变——一个纯函数(简单来说，它是一个没有副作用的函数)接受先前的状态和一个动作，并返回新的状态</li></ol><p id="8b88" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">听起来很酷，但是这种解决方案的优势是什么？</p><ul class=""><li id="159f" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz ls lk ll lm dt translated">我们拥有对状态的控制——这意味着我们确切地知道是什么导致了状态变化，我们没有重复的状态，并且我们可以轻松地跟踪数据流</li><li id="5f19" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated">纯粹的<strong class="je ig">减速器功能很容易测试</strong>——如果结果正确，我们可以通过状态、动作和测试</li><li id="d4ab" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated">应用程序是<strong class="je ig">结构清晰的</strong>——我们有不同的动作层、模型层、业务逻辑层等等。—所以你确切地知道在哪里放置另一个新特性</li><li id="6f86" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated">对于更复杂的应用程序来说，这是一个很好的架构——你不需要在整个视图树中从父节点传递到子节点</li><li id="f20f" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated">还有一个…</li></ul><h2 id="7677" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated">Redux时间旅行</h2><p id="5c83" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Redux可能有一个很酷的功能🎉<strong class="je ig">时间旅行</strong>！使用Redux和<a class="ae ka" href="https://pub.dartlang.org/packages/flutter_redux_dev_tools" rel="noopener ugc nofollow" target="_blank">适当的工具</a>，您可以<strong class="je ig">跟踪您的应用程序状态</strong>，检查实际状态并且<strong class="je ig">随时重新创建它</strong>。查看该功能的实际应用:</p><figure class="mi mj mk ml fq hw fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/029d6b4d02536ab548258eddf9325d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*KL-z2sJRBYEHrnzFASVvVw.gif"/></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">Time Travel in action — how cool is that?</figcaption></figure></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><h1 id="4585" class="kb kc if bd kd ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky dt translated">一个简单例子中的Redux小部件</h1><p id="3c80" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">以上所有规则使得Redux <strong class="je ig">中的数据流是单向的</strong>。但这意味着什么呢？实际上，这都是通过<strong class="je ig">动作、减速器、存储和状态</strong>来完成的。让我们想象一下显示按钮计数器的应用程序:</p><figure class="mi mj mk ml fq hw fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/7fa56be3cf3e1fcc605aff75b732aaee.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*vM852avXATOs1_1Mq7Bn7w.png"/></div></figure><ol class=""><li id="1f5a" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">您的应用程序在开始时有一些<strong class="je ig">状态</strong>(点击次数，为0)</li><li id="1d64" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">基于该状态，视图<strong class="je ig">被渲染。</strong></li><li id="de4b" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">如果用户点击按钮，会有<strong class="je ig">动作</strong>发送(如增量计数器)</li><li id="5285" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><strong class="je ig">缩减器</strong>接收动作，缩减器知道前一状态(计数器0)，接收动作(IncrementCounter)并能返回新状态(计数器1)</li><li id="7a6f" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">您的应用程序具有新的<strong class="je ig">状态</strong>(计数器1)</li><li id="20d2" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">基于新的状态，<strong class="je ig">视图</strong>被再次渲染</li></ol><p id="6ec9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如你所见，一般来说，这都是关于状态的。你有单个app <strong class="je ig">状态</strong>，<strong class="je ig">状态</strong>只读查看，要创建新的<strong class="je ig">状态</strong>你需要发送动作。发送动作触发创建并发出新应用程序<strong class="je ig">状态</strong>的缩减器。历史会重演。</p><figure class="mi mj mk ml fq hw fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/40ab4d92dbae705d83df980560b64cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*S_BZUDym3j0Vxjfi8D21Zg.png"/></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">Redux Data Flow</figcaption></figure><h1 id="3509" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Redux购物清单应用示例</h1><p id="b678" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">让我在更多的高级例子中展示Redux是如何工作的。我们将创建一个简单的购物车应用程序。在该应用中，将有以下功能:</p><ul class=""><li id="9a48" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz ls lk ll lm dt translated">添加项目</li><li id="7e29" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated">将项目标记为选中</li><li id="61c5" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated">基本上就这些了😎</li></ul><p id="7b07" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用程序将如下所示:</p><figure class="mi mj mk ml fq hw fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/d6566602ee723f5bf1ce9baddc0ffc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*F_VsjS0EfcjFI5S-fsTvRQ.png"/></div></figure><p id="f19e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在GitHub上看到完整的应用程序代码:</p><div class="ht hu fm fo hv ne"><a href="https://github.com/pszklarska/FlutterShoppingCart" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab ej"><div class="ng ab nh cl cj ni"><h2 class="bd ig fv z el nj eo ep nk er et ie dt translated">pszklarska/FlutterShoppingCart</h2><div class="nl l"><h3 class="bd b fv z el nj eo ep nk er et ek translated">FlutterShoppingCart -使用Redux架构的购物应用程序的Flutter示例</h3></div><div class="nm l"><p class="bd b gc z el nj eo ep nk er et ek translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ib ne"/></div></div></a></div><p id="abe9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">先说编码吧！👇</p><h2 id="659f" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated">先决条件</h2><p id="78c6" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在本文中，我不会展示如何为这个应用程序创建UI。您可以在这里 实现Redux之前查看<a class="ae ka" href="https://github.com/pszklarska/FlutterShoppingCart/tree/a8120a23232a05d380384bb377f3994ef65ad221" rel="noopener ugc nofollow" target="_blank"> <strong class="je ig">这个购物清单应用的代码。我们将从这一点开始编码，并将Redux添加到这个应用程序中。</strong></a></p><p id="9ee0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你以前从未使用过Flutter，我鼓励你试试Google 的<a class="ae ka" href="https://codelabs.developers.google.com/codelabs/flutter/" rel="noopener ugc nofollow" target="_blank"> Flutter Codelabs。</a></p><h2 id="0bfe" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated"><strong class="ak">设置</strong></h2><p id="9e71" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">要在Flutter上运行Redux，您需要向您的<code class="eh nt nu nv nw b">pubspec.yaml</code>文件添加依赖项:</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="b91e" class="lt kc if nw b fv ob oc l od oe">flutter_redux: ^0.5.2</span></pre><p id="32f4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以在<a class="ae ka" href="https://pub.dartlang.org/packages/flutter_redux" rel="noopener ugc nofollow" target="_blank"> flutter_redux </a>包页面查看最新版本。</p><h2 id="67ff" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated">模型</h2><p id="0d97" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们的应用程序需要管理项目的添加和更改，所以我们将使用简单的<code class="eh nt nu nv nw b">CartItem</code>模型来存储单个项目的状态。<strong class="je ig">我们的整个应用状态将只是CartItems的列表</strong>。如你所见，CartItem只是一个普通的Dart对象。</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="4fab" class="lt kc if nw b fv ob oc l od oe">class <strong class="nw ig">CartItem</strong> {<br/>  String name;<br/>  bool checked;<br/><br/>  <strong class="nw ig">CartItem</strong>(this.name, this.checked);<br/>}</span></pre><blockquote class="of og oh"><p id="831f" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated">注意:这是这个文件的完整源代码。</p></blockquote><h2 id="081c" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated">行动</h2><p id="667c" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">首先，我们需要声明<strong class="je ig">动作</strong>。动作基本上是任何可以被调用来改变应用程序状态的<strong class="je ig">意图。在我们的应用程序中，我们将有两个动作，用于添加和更改项目:</strong></p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="f6a3" class="lt kc if nw b fv ob oc l od oe">class <strong class="nw ig">AddItemAction</strong> {<br/>  final CartItem item;<br/><br/>  <strong class="nw ig">AddItemAction</strong>(this.item);<br/>}<br/><br/>class <strong class="nw ig">ToggleItemStateAction</strong> {<br/>  final CartItem item;<br/><br/>  <strong class="nw ig">ToggleItemStateAction</strong>(this.item);<br/>}</span></pre><blockquote class="of og oh"><p id="1690" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/redux/actions.dart" rel="noopener ugc nofollow" target="_blank">注意:这里是这个文件的完整源代码</a></p></blockquote><h2 id="e318" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated">还原剂</h2><p id="e492" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">然后，我们需要告诉我们的应用程序应该如何处理这些动作。这就是为什么<strong class="je ig">还原器</strong>的作用——它们简单地<strong class="je ig">获取当前的应用程序状态和动作，然后它们创建并返回新的应用程序状态</strong>。我们有两个reducers方法:</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="1cc2" class="lt kc if nw b fv ob oc l od oe">List&lt;CartItem&gt; <strong class="nw ig">appReducers</strong>(List&lt;CartItem&gt; items, dynamic action) {<br/>  if (action is AddItemAction) {<br/>    return <strong class="nw ig">addItem(items, action)</strong>;<br/>  } else if (action is ToggleItemStateAction) {<br/>    return <strong class="nw ig">toggleItemState(items, action)</strong>;<br/>  } <br/>  return items;<br/>}<br/><br/>List&lt;CartItem&gt; <strong class="nw ig">addItem</strong>(List&lt;CartItem&gt; items, AddItemAction action) {<br/>  return List.from(items)..add(action.item);<br/>}<br/><br/>List&lt;CartItem&gt; <strong class="nw ig">toggleItemState</strong>(List&lt;CartItem&gt; items, ToggleItemStateAction action) {<br/>  return items.map((item) =&gt; item.name == action.item.name ?<br/>    action.item : item).toList();<br/>}</span></pre><blockquote class="of og oh"><p id="2d11" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/redux/reducers.dart" rel="noopener ugc nofollow" target="_blank">注意:这里是这个文件的完整源代码。</a></p></blockquote><p id="c5fb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">方法<code class="eh nt nu nv nw b">appReducers()</code>将动作委托给适当的方法。方法<code class="eh nt nu nv nw b">addItem()</code>和<code class="eh nt nu nv nw b">toggleItemState()</code>都返回新的列表——这是我们新的应用程序状态。如你所见，<strong class="je ig">你不应该修改当前列表</strong>。相反，我们每次都创建新的列表。</p><h2 id="0dda" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated">商店提供商</h2><p id="62f3" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在，当我们有了actions和reducers，我们需要提供存储应用程序状态的地方。在Redux中，它被称为<strong class="je ig"> store </strong>，对于我们的应用程序来说，它是<strong class="je ig">真实的单一来源</strong>。</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="5807" class="lt kc if nw b fv ob oc l od oe">void main() {<br/>  <strong class="nw ig">final store = new Store&lt;List&lt;CartItem&gt;&gt;(<br/>      appReducers,<br/>      initialState: new List());</strong><br/><br/>  runApp(new FlutterReduxApp(store));<br/>}</span></pre><blockquote class="of og oh"><p id="a4a4" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated">注意:这是这个文件的完整源代码。</p></blockquote><p id="d1ff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要创建store，我们需要通过<strong class="je ig"> reducers </strong>方法和<strong class="je ig">初始应用状态</strong>。如果我们创建了商店，我们必须将它传递给<strong class="je ig"> StoreProvider </strong>来告诉我们的应用程序，任何想要请求应用程序状态的人都可以使用它:</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="556f" class="lt kc if nw b fv ob oc l od oe">class FlutterReduxApp extends StatelessWidget {<br/>  final Store&lt;List&lt;CartItem&gt;&gt; store;<br/><br/>  FlutterReduxApp(this.store);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    <strong class="nw ig">return new StoreProvider&lt;List&lt;CartItem&gt;&gt;(<br/>      store: store,<br/>      child: new ShoppingCartApp(),<br/>    );</strong><br/>  }<br/>}</span></pre><blockquote class="of og oh"><p id="441d" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/main.dart" rel="noopener ugc nofollow" target="_blank">注意:这里是这个文件的完整源代码。</a></p></blockquote><p id="850c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中,<code class="eh nt nu nv nw b">ShoppingCartApp()</code>是主应用程序小部件。</p><h2 id="f4b5" class="lt kc if bd kd lu lv lw kh lx ly lz kl jn ma mb kp jr mc md kt jv me mf kx mg dt translated">存储连接器</h2><p id="5c78" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">目前，我们有一切，除了…实际增加和改变项目。怎么做呢？为此，我们需要使用<strong class="je ig"> StoreConnector </strong>。这是一种<strong class="je ig">获取商店并对其进行操作或读取其状态</strong>的方法。</p><p id="1bff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们希望<strong class="je ig">读取当前数据并将其显示在列表中</strong>:</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="d159" class="lt kc if nw b fv ob oc l od oe">class<strong class="nw ig"> </strong>ShoppingList<strong class="nw ig"> </strong>extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return new <strong class="nw ig">StoreConnector&lt;List&lt;CartItem&gt;, List&lt;CartItem&gt;&gt;</strong>(<br/>      <strong class="nw ig">converter: (store) =&gt; store.state,<br/>      builder: (context, list)</strong> {<br/>        return new ListView.builder(<br/>            itemCount: list.length,<br/>            itemBuilder: (context, position) =&gt;<br/>                <strong class="nw ig">new ShoppingListItem(list[position]));</strong><br/>      },<br/>    );<br/>  }<br/>}</span></pre><blockquote class="of og oh"><p id="bcbd" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated">注意:这是这个文件的完整源代码。</p></blockquote><p id="182b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码用<code class="eh nt nu nv nw b">StoreConnector</code>包装了默认的<code class="eh nt nu nv nw b">ListView.builder</code>。StoreConnector可以获取当前的应用程序状态(即<code class="eh nt nu nv nw b">List&lt;CartItem&gt;</code>，并使用<code class="eh nt nu nv nw b">converter</code>函数将其映射到任何东西。出于这个例子的目的，它将是相同的状态(<code class="eh nt nu nv nw b">List&lt;CartItem&gt;</code>)，因为我们在这里需要整个列表。</p><p id="af74" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，在<code class="eh nt nu nv nw b">builder</code>函数中我们得到<code class="eh nt nu nv nw b">list</code>——这基本上是来自<code class="eh nt nu nv nw b">store</code>的CartItems列表，我们可以用它来构建ListView。</p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="1367" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好的，酷——我们这里有阅读数据。现在<strong class="je ig">如何设置一些数据？</strong></p><p id="eac7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为此，我们也将使用<strong class="je ig"> StoreConnector </strong>，但方式略有不同。</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="c78f" class="lt kc if nw b fv ob oc l od oe">class AddItemDialog extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return new StoreConnector&lt;List&lt;CartItem&gt;, OnItemAddedCallback&gt;(<br/>        converter: (store) {<strong class="nw ig"><br/>      return (itemName) =&gt;<br/>          store.dispatch(AddItemAction(CartItem(itemName, false)));<br/>   </strong> }<strong class="nw ig">,</strong> builder: (context, callback) {<br/>      return new AddItemDialogWidget(<strong class="nw ig">callback</strong>);<br/>    });<br/>  }<br/>}</span><span id="54ad" class="lt kc if nw b fv om oc l od oe"><strong class="nw ig">typedef OnItemAddedCallback = Function(String itemName);</strong></span></pre><blockquote class="of og oh"><p id="cfe8" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated">注意:这是这个文件的完整源代码。</p></blockquote><p id="cc24" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看代码。和前面的例子一样，我们使用了<strong class="je ig"> StoreConnector </strong>，但是这一次，我们没有将CartItems的列表映射到同一个列表，而是将它映射到<code class="eh nt nu nv nw b">OnItemAddedCallback</code>。这样我们可以将回调传递给<code class="eh nt nu nv nw b">AddItemDialogWidget</code>，并在用户添加新项目时调用它:</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="f228" class="lt kc if nw b fv ob oc l od oe">class AddItemDialogWidgetState extends State&lt;AddItemDialogWidget&gt; {<br/>  String itemName;<br/><br/>  <strong class="nw ig">final OnItemAddedCallback callback;<br/>  AddItemDialogWidgetState(this.callback);</strong><br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return new AlertDialog(<br/>      ...<br/>      actions: &lt;Widget&gt;[<br/>        ...<br/>        new FlatButton(<br/>            child: const Text('ADD'),<br/>            <strong class="nw ig">onPressed: () {<br/>              </strong>...<strong class="nw ig"><br/>              callback(itemName);<br/>            })</strong><br/>      ],<br/>    );<br/>  }<br/>}</span></pre><blockquote class="of og oh"><p id="5493" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated">注意:这是这个文件的完整源代码。</p></blockquote><p id="996d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，每次用户按下“添加”按钮，回调将调度<code class="eh nt nu nv nw b">AddItemAction()</code>事件。</p><p id="f7f3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们可以做非常类似的事情来切换项目状态:</p><pre class="mi mj mk ml fq nx nw ny nz aw oa dt"><span id="37d4" class="lt kc if nw b fv ob oc l od oe">class ShoppingListItem extends StatelessWidget {<br/>  final CartItem item;<br/><br/>  ShoppingListItem(this.item);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return new <strong class="nw ig">StoreConnector&lt;List&lt;CartItem&gt;, OnStateChanged&gt;</strong>(<br/>        converter: (store) {<br/>      <strong class="nw ig">return (item) =&gt; store.dispatch(ToggleItemStateAction(item));</strong><br/>    }, builder: (context, callback) {<br/>      return new ListTile(<br/>        title: new Text(item.name),<br/>        leading: new Checkbox(<br/>            value: item.checked,<br/>            <strong class="nw ig">onChanged: (bool newValue) {<br/>              callback(CartItem(item.name, newValue));<br/>            }),</strong><br/>      );<br/>    });<br/>  }<br/>}<br/><br/><strong class="nw ig">typedef OnStateChanged = Function(CartItem item);</strong></span></pre><blockquote class="of og oh"><p id="6d4d" class="jc jd oi je b jf jg jh ji jj jk jl jm oj jo jp jq ok js jt ju ol jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/list/shopping_list_item.dart" rel="noopener ugc nofollow" target="_blank">注意:这里是这个文件的完整源代码。</a></p></blockquote><p id="1ba8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和前面的例子一样，我们使用<strong class="je ig"> StoreConnector </strong>将<code class="eh nt nu nv nw b">List&lt;CartItem&gt;</code>映射到<code class="eh nt nu nv nw b">OnStateChanged</code>回调。现在每次复选框被改变时(在<code class="eh nt nu nv nw b">onChanged</code>方法中)，回调触发<code class="eh nt nu nv nw b">ToggleItemStateAction</code>事件。</p><h1 id="35b0" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">摘要</h1><p id="51e3" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">仅此而已！在本文中，我们使用Redux架构创建了一个简单的购物清单应用程序。在我们的应用程序中，我们可以添加一些项目并改变它们的状态。<strong class="je ig">向该应用程序添加新功能就像添加新动作和减少器一样简单。</strong></p><p id="9914" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您可以查看该应用程序的完整源代码，包括<strong class="je ig">时间旅行</strong>小部件:</p><div class="ht hu fm fo hv ne"><a href="https://github.com/pszklarska/FlutterShoppingCart" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab ej"><div class="ng ab nh cl cj ni"><h2 class="bd ig fv z el nj eo ep nk er et ie dt translated">pszklarska/FlutterShoppingCart</h2><div class="nl l"><h3 class="bd b fv z el nj eo ep nk er et ek translated">FlutterShoppingCart -使用Redux架构的购物应用程序的Flutter示例</h3></div><div class="nm l"><p class="bd b gc z el nj eo ep nk er et ek translated">github.com</p></div></div><div class="nn l"><div class="on l np nq nr nn ns ib ne"/></div></div></a></div><p id="a01e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你喜欢这篇文章，并继续关注！🙌</p></div></div>    
</body>
</html>