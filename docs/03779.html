<html>
<head>
<title>How to build your first app with Mobx and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Mobx构建你的第一个应用并做出反应</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-build-your-first-app-with-mobx-and-react-aea54fbb3265?source=collection_archive---------3-----------------------#2018-05-02">https://medium.com/hackernoon/how-to-build-your-first-app-with-mobx-and-react-aea54fbb3265?source=collection_archive---------3-----------------------#2018-05-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/59ddf0728dcf69c588ed0d6f29a80006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmGHmtKY-LV1UF0yTOOgIg.png"/></div></div></figure><p id="e927" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你在React世界，你很有可能听说过Mobx。Mobx是由<a class="ae ka" href="https://twitter.com/mweststrate" rel="noopener ugc nofollow" target="_blank"> Michel Weststrate </a>开发的轻量级且易于学习的状态管理库。<a class="ae ka" rel="noopener" href="/@mweststrate/mobx-4-better-simpler-faster-smaller-c1fbc08008da">它的第四版</a>几周前发布了，它有很多很酷的新功能。</p><p id="725d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将通过构建一个小项目开始我们在Mobx世界中的旅程:一个简单的表管理器，它将管理一些雇员的工资数据。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/efeaf74300a959cfd61cc39940826167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bis807OC3hLTV6E0Y48n4w.png"/></div></div></figure><p id="b53f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从功能角度来看，我们的应用将能够:</p><ul class=""><li id="de08" class="kg kh hu je b jf jg jj jk jn ki jr kj jv kk jz kl km kn ko dt translated">在表格中呈现雇员列表(雇员由姓名和薪水组成)</li><li id="2f64" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">添加新员工</li><li id="e719" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">清除员工列表</li><li id="28b6" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">计算工资的总成本</li><li id="1a61" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">显示有多少员工每天收入超过500美元</li></ul><p id="5c15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也许，最重要的“特性”是我们将通过管理Mobx的应用状态来做任何事情。</p><h1 id="9017" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">项目的基本设置</h1><p id="ab42" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">我们将从以下基本设置开始。我们只有一些非常基本的组件，主要是返回一些带有一些基本HTML标签的div。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="dd88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本组件架构如下所示:</p><ul class=""><li id="4f4e" class="kg kh hu je b jf jg jj jk jn ki jr kj jv kk jz kl km kn ko dt translated">应用程序组件</li><li id="6707" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">控件组件</li><li id="9403" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">表格组件</li><li id="6e05" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">行无状态组件</li></ul><h1 id="3123" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">向我们的应用程序添加商店</h1><p id="42da" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在这个阶段，我们的应用程序没有任何数据支持。只有一些空的组件。我们的应用程序的初始数据将是一个带有姓名和日薪的雇员对象数组</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="c66c" class="me kv hu ma b fv mf mg l mh mi">employeesList = [<br/>    {name: "John Doe", salary: 150},<br/>    //... <br/>]</span></pre><p id="1d02" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些数据必须在多个组件中使用:<br/> —在表中(为了列出雇员)<br/> —以及在控件组件中，用于添加新雇员或清除列表</p><p id="7fa4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">鉴于<a class="ae ka" href="https://www.reddit.com/r/reactjs/comments/4v3mcb/passing_down_too_many_props_to_child_components/" rel="noopener ugc nofollow" target="_blank">通过props发送数据和回调对于应用的核心数据来说并不是最具可伸缩性的解决方案</a>，我们可以尝试将一个<strong class="je hv"> appStore </strong>对象放在一起，来封装和管理这些核心数据。这样，最初，我们只需通过这个应用商店。</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="ac0d" class="me kv hu ma b fv mf mg l mh mi">class Store {<br/>  employeesList = [<br/>    {name: "John Doe", salary: 150},<br/>    {name: "Richard Roe", salary: 225},<br/>  ]<br/>}<br/>const appStore = new Store()</span></pre><p id="f257" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建AppStore后，我们现在可以将其发送到主要组件:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="fe90" class="me kv hu ma b fv mf mg l mh mi">&lt;Controls store={appStore} /&gt;<br/>&lt;Table store={appStore} /&gt;</span></pre><p id="7998" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们可以在表格组件中列出联系人:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="97b7" class="me kv hu ma b fv mf mg l mh mi">class Table extends Component {<br/>    render() {<br/>        &lt;tbody&gt;<br/>          {store.employeesList.map((e, i) =&gt;<br/>            &lt;Row <br/>              key={i} <br/>              data={e}<br/>            /&gt;<br/>          )}<br/>        &lt;/tbody&gt;<br/>    }<br/>}</span></pre><p id="14f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止一切顺利。但是，如果我们试图通过向<strong class="je hv"> appStore.employeesList </strong>中推送一个新项目来添加新员工，或者如果我们试图清除该列表:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="be5b" class="me kv hu ma b fv mf mg l mh mi">class Controls extends Component {<br/>  addEmployee = ()=&gt; {<br/>    const name = prompt("The name:")<br/>    const salary = prompt("The salary:")<br/>    this.props.store.employeesList.push({name, email})<br/>    // ERROR !!! this will not update the view <br/>  }<br/><br/>  clearList = ()=&gt; {<br/>    this.props.store.employeesList = []<br/>    // ERROR !!! this will not update the view <br/>  }<br/><br/>  render() {<br/>    return(&lt;div className="controls"&gt;<br/>      &lt;button onClick=&gt;clear table&lt;/button&gt;<br/>      &lt;button&gt;add record&lt;/button&gt;<br/>    &lt;/div&gt;)<br/>  }<br/>}</span></pre><p id="a730" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们不会对视图进行任何更新，即使事情看起来像它们应该的那样工作:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="571d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你也可以试着做一个数据的控制台日志，你会发现一切似乎都没问题。问题在于React在对象改变时没有得到通知，所以它可以开始重新渲染。</p><h1 id="73ce" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">正在安装Mobx</h1><p id="cf0b" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">Mobx处理的正是这些类型的情况。当数据状态发生变化时，它是通知React的完美工具。</p><p id="9d57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是首先，让我们先把它添加到我们的应用程序中。安装Mobx最快的方法是使用NPM。除了<strong class="je hv"> mobx </strong>之外，我们还将添加<strong class="je hv"> mobx-react </strong>，我们将使用它将mobx和react粘合在一起。</p><p id="4bd4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，打开一个控制台，键入:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="aa52" class="me kv hu ma b fv mf mg l mh mi">npm install -save mobx mobx-react</span></pre><p id="ffa3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装完成后，我们将在App.js中添加一些新的导入内容:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="6dc6" class="me kv hu ma b fv mf mg l mh mi">import {decorate, observable} from "mobx"<br/>import {observer} from "mobx-react"</span></pre><h1 id="5974" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">Mobx基础知识介绍:观察者—可观察的</h1><p id="47d6" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">简而言之，mobx工作在可观察的——观察者流程上。你声明一些数据是可观察的，当这些数据改变时，所有使用这些数据的观察者都会得到通知。</p><p id="b9ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的示例中，更改的数据是employeesList。在mobx中有<a class="ae ka" href="https://www.robinwieruch.de/create-react-app-mobx-decorators/" rel="noopener ugc nofollow" target="_blank">几个</a> <a class="ae ka" href="https://mobx.js.org/refguide/observable.html" rel="noopener ugc nofollow" target="_blank">不同的</a> <a class="ae ka" rel="noopener" href="/@mweststrate/mobx-4-better-simpler-faster-smaller-c1fbc08008da">选择</a>来声明一些数据是可观测的。我们将使用最新的，因为在我看来，它是最优雅和最容易使用的。它是在Mobx4中添加的，大概是这样的:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="dd70" class="me kv hu ma b fv mf mg l mh mi">class Store {<br/>  //...<br/>}<br/><br/>decorate(Store, {<br/>  employeesList: observable<br/>})<br/><br/>const appStore = new Store()</span></pre><p id="0d20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，为了完成这个流程，我们必须让Table组件成为一个<strong class="je hv">观察者</strong>:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="ae21" class="me kv hu ma b fv mf mg l mh mi">class Table extends Component {<br/>  //...<br/>}<br/>Table = observer(Table)</span></pre><p id="1b12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这些新的变化，我们应该一切正常:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><h1 id="1f36" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">在Mobx中使用操作和配置-强制操作</h1><p id="b456" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">尽管看起来一切正常，但我们违反了Mobx的一条非常重要的规则:<strong class="je hv">状态数据只能通过动作</strong>来修改。这将使代码更具可伸缩性，并改进数据流管理。</p><p id="5358" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Mobx甚至提供了一种机制来确保这条规则得到遵守。如果我们将以下两行添加到应用程序中:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="78f2" class="me kv hu ma b fv mf mg l mh mi">import {configure} from "mobx"<br/>configure({enforceActions: true})</span></pre><p id="94a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们按下clear employeesList按钮或添加新员工时，我们将结束this: <strong class="je hv">错误:[mobx]由于启用了严格模式，不允许在操作之外更改观察到的值</strong>:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/79dd4a043534c81f837c2efd506dc95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uROWs57bQ1UsDyFQUXgjhA.png"/></div></div></figure><p id="8b5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是因为我们试图在函数之外改变状态。要解决这个问题，我们首先必须导入<strong class="je hv">动作</strong>，向存储中添加两个新函数，并将它们声明为动作:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="892b" class="me kv hu ma b fv mf mg l mh mi">import {action} from "mobx"<br/><br/>class Store {<br/>  //...<br/>  clearList() {<br/>    this.employeesList = []<br/>  }<br/><br/>  pushEmployee(e) {<br/>    this.employeesList.push(e)<br/>  }<br/>}<br/><br/>decorate(Store, {<br/>  clearList: action,<br/>  pushEmployee: action<br/>})</span></pre><p id="97a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这些动作，我们现在可以用对这些动作的调用来替换<em class="mk">不安全的</em>数据操作:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="9065" class="me kv hu ma b fv mf mg l mh mi">class Controls extends Component {<br/>  addEmployee = ()=&gt; {<br/>    const name = prompt("The name:")<br/>    const salary = parseInt(prompt("The salary:"), 10)<br/>    this.props.store.pushEmployee({name, salary})<br/>  }<br/><br/>  clearList = ()=&gt; {<br/>    this.props.store.clearList()<br/>  }<br/>  //...<br/>}</span></pre><p id="0fbb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，一切都应该恢复正常，我们的数据管理现在完全封装在Mobx存储中:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="1fb3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，总结一下:</p><ul class=""><li id="2538" class="kg kh hu je b jf jg jj jk jn ki jr kj jv kk jz kl km kn ko dt translated">在需要的地方，让你的数据<strong class="je hv">可见</strong></li><li id="836e" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">将<strong class="je hv">观察器</strong>设置为使用<strong class="je hv">可观察数据</strong>的组件</li><li id="e9eb" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated">仅通过<strong class="je hv">动作</strong>改变<strong class="je hv">可观察</strong></li></ul><p id="bdac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mk">我希望你喜欢这个教程，如果你想看更多Mobx或React的例子，你可以随时订阅</em> <a class="ae ka" href="http://www.js-craft.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="mk">我的电子邮件列表</em> </a>。</p><h1 id="aafc" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">在Mobx中使用计算值</h1><p id="462a" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">Mobx的另一个核心概念是，<strong class="je hv">计算值</strong>。基本上，我们可以将计算值定义为通过对核心数据进行计算而生成的数据。您可以将它们视为Excel中公式生成的数据。</p><p id="5e34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个完美的例子是个人工资总额。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/d19b23e4ecbfaa65129bcef1766b4bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KR8fEw6LnjnXt6Vfe8M20A.png"/></div></div></figure><p id="e85a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了创建一个计算值，我们将导入<strong class="je hv">计算的</strong>概念，并将一个新的属性getter添加到Mobx存储中。新的属性将存储工资总额。</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="0a7a" class="me kv hu ma b fv mf mg l mh mi">import {computed} from "mobx"<br/>class Store {<br/>  //...<br/>  get totalSum() {<br/>    let sum = 0<br/>    this.employeesList.map( e =&gt; sum = sum + e.salary)<br/>    return sum<br/>  }<br/>}<br/>decorate(Store, {<br/>  //...<br/>  totalSum: computed<br/>})</span></pre><p id="7bf9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们只需要在表中添加一个页脚，并使用计算出的值。</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="b004" class="me kv hu ma b fv mf mg l mh mi">class Table extends Component {<br/>  render() {<br/>    const {store} = this.props<br/>    return(&lt;table&gt;<br/>      //...<br/>      &lt;tfoot&gt;<br/>        &lt;tr&gt;<br/>          &lt;td&gt;TOTAL:&lt;/td&gt;<br/>          &lt;td&gt;{store.totalSum}&lt;/td&gt;<br/>        &lt;/tr&gt;<br/>      &lt;/tfoot&gt;<br/>    &lt;/table&gt;)<br/>  }<br/>}</span></pre><p id="7e69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们清除或添加到employeesList时，这个总数也将被更新。</p><p id="6c45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Mobx的一个黄金法则就是<strong class="je hv">存储最少的所需数据量，尽可能多的进行计算</strong>。这将为您提供良好的性能和重新渲染速度。</p><p id="475f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，<strong class="je hv"> Mobx计算值</strong>的另一个可能的用例是计数&amp;跟踪有多少记录满足特定条件。比方说，我们想添加一个应用页脚，我们将显示每天收入超过500美元的员工总数。</p><p id="f258" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与totalSum类似，在这种情况下，我们也将添加一个计算值，只是现在我们将使用数组过滤器的长度:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="4f82" class="me kv hu ma b fv mf mg l mh mi">class Store {<br/>  //...<br/>  get highEarnersCount () {<br/>    return this.employeesList.filter( e =&gt; e.salary &gt; 500).length<br/>  }<br/>}</span></pre><p id="5c0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了在表格组件中显示结果，我们将添加一个新的div:</p><pre class="kc kd ke kf fq lz ma mb mc aw md dt"><span id="c11a" class="me kv hu ma b fv mf mg l mh mi">class Table extends Component {<br/>  render() {<br/>    return (&lt;div&gt;<br/>      //...<br/>      &lt;div className="fade"&gt;<br/>        You have &lt;u&gt;{store.highEarnersCount} team members &lt;/u&gt;that earn more that 500$/day.<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;)<br/>  }<br/>}</span></pre><p id="9287" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应该就是这个了。您可以在下面的codesandbox中体验完整的示例:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="44d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我怎么强调Mobx中计算值的重要性都不为过。它们在很多情况下都非常有用。你也可以在Mobx的创造者Michel Weststrate 的<a class="ae ka" href="https://egghead.io/courses/manage-complex-state-in-react-apps-with-mobx" rel="noopener ugc nofollow" target="_blank"> egghead课程中看到一个很好的例子。</a></p><p id="9cbf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多Mobx特性没有在本教程中介绍。比如提供者、进行HTTP调用或使用带有路由器的Mobx等等。但是现在你已经掌握了基本原理:动作-&gt;可观察-&gt;观察者-&gt;反应再现。Mobx文档写得很好，包含了很多最佳实践。</p><p id="76ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mk">我希望你喜欢这个教程，如果你想看更多Mobx或React的例子，你可以随时订阅</em> <a class="ae ka" href="http://www.js-craft.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="mk">我的电子邮件列表</em> </a>。</p></div></div>    
</body>
</html>