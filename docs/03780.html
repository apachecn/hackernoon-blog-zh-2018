<html>
<head>
<title>Async-Await ≈ Generators + Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步等待≈发电机+承诺</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/async-await-generators-promises-51f1a6ceede2?source=collection_archive---------4-----------------------#2018-05-02">https://medium.com/hackernoon/async-await-generators-promises-51f1a6ceede2?source=collection_archive---------4-----------------------#2018-05-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e997" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我将描述ES2017 <code class="eh jp jq jr js b">async</code>函数本质上是两个旧的<a class="ae jt" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>特性:<code class="eh jp jq jr js b">generators</code>和<code class="eh jp jq jr js b">promises</code>之间的游戏，这两个特性都是在ES2016规范中较早添加到语言中的。</p><h2 id="7b5b" class="ju jv hu bd jw jx jy jz ka kb kc kd ke jc kf kg kh jg ki kj kk jk kl km kn ko dt translated">在你开始阅读之前..</h2><ul class=""><li id="cc86" class="kp kq hu it b iu kr iy ks jc kt jg ku jk kv jo kw kx ky kz dt translated">本文<strong class="it hv">不是</strong>对<code class="eh jp jq jr js b">promises</code>、<code class="eh jp jq jr js b">generators</code>或<code class="eh jp jq jr js b">async</code>功能的介绍。</li><li id="e615" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">这篇文章的唯一目标是描述如何使用<code class="eh jp jq jr js b">promises</code>和<code class="eh jp jq jr js b">generators</code>实现<code class="eh jp jq jr js b">async</code>功能。</li><li id="f2e7" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">它不<strong class="it hv">也不</strong>提供任何关于<code class="eh jp jq jr js b">async</code>函数比其他方法更好还是更差的意见。</li><li id="18b0" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">为了便于解释，本文中使用的代码示例设计得非常巧妙。它们不是用于任何严肃用途的。</li></ul><h2 id="5405" class="ju jv hu bd jw jx jy jz ka kb kc kd ke jc kf kg kh jg ki kj kk jk kl km kn ko dt translated">但是为什么呢..？</h2><p id="649a" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">既然<code class="eh jp jq jr js b">async</code>函数现在已经被本地支持，那么理解它们是如何工作的又有什么必要呢？</p><p id="312a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，除了<strong class="it hv"> <em class="li">好奇心</em> </strong>这个明显的原因外，一个重要的原因就是支持更老的平台。如果您想让使用这些新特性的代码在旧版本的浏览器或旧版本的Node.js上运行，您需要使用<a class="ae jt" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>，如<a class="ae jt" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>来将这些新特性转换成旧特性。</p><p id="8e75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，对<code class="eh jp jq jr js b">async</code>函数如何分解成<code class="eh jp jq jr js b">generators</code>和<code class="eh jp jq jr js b">promises</code>的透彻理解在阅读/调试转换后的代码时会派上用场。例如，下面是一个简单的<code class="eh jp jq jr js b">async</code>函数示例:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff lj"><img src="../Images/a0d361d44b074b905afad367f1e9d21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkgyvsWnvaGmyjWAUPnHUA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">An async function (ES2017)</figcaption></figure><p id="3d4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个函数被Babel转换成下面的ES2016代码(现在不要担心理解它，我们稍后会介绍它) :</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff lz"><img src="../Images/92c5a9706d78f518eb39e041027a55c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a26tao0MegMv2mrmqpsOnA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Babel output for the previous async function (ES2016)</figcaption></figure><p id="36e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他们看起来真的不一样！然而，如果您理解<code class="eh jp jq jr js b">async</code>函数实际上是如何工作的，那么这种转换是相当明显的。</p><p id="a5ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个有趣的事实是，浏览器也以类似的方式实现<code class="eh jp jq jr js b">async</code>功能，即它们<a class="ae jt" href="https://www.reddit.com/r/javascript/comments/44b6y9/question_how_are_generators_and_asyncawait/czp1lxr/" rel="noopener ugc nofollow" target="_blank">转换</a>代码以使用<code class="eh jp jq jr js b">generators</code>和<code class="eh jp jq jr js b">promises</code>非常类似于巴别塔。</p></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="14ab" class="mh jv hu bd jw mi mj mk ka ml mm mn ke mo mp mq kh mr ms mt kk mu mv mw kn mx dt translated">好吧，那它是怎么发生的？</h1><p id="9eab" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">有时候为了理解某样东西是如何工作的，最好的方法是自己动手制作。所以让我们来翻转这个问题:</p><blockquote class="my mz na"><p id="02ca" class="ir is li it b iu iv iw ix iy iz ja jb nb jd je jf nc jh ji jj nd jl jm jn jo hn dt translated">想象一下，给我们一段使用<code class="eh jp jq jr js b">async</code>函数的代码，我们如何只用<code class="eh jp jq jr js b">promises</code>和<code class="eh jp jq jr js b">generator</code>函数重写它？</p></blockquote><p id="95ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个<code class="eh jp jq jr js b">async</code>函数:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff ne"><img src="../Images/7e7d883099fd7952326ecc43da0cb468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kyl2NKektJH_XsyjciS1BA.png"/></div></div></figure><p id="e705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它执行三个异步任务，一个接一个，每个任务依赖于前一个任务的完成。最后，它返回上一个任务的结果。</p><h2 id="5826" class="ju jv hu bd jw jx jy jz ka kb kc kd ke jc kf kg kh jg ki kj kk jk kl km kn ko dt translated">我们如何使用生成器来编写它？</h2><p id="f04a" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated"><a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function%2A" rel="noopener ugc nofollow" target="_blank">发电机是可以退出并在以后重新进入的功能。让我们快速回顾一下它们是如何工作的。下面是一个简单的生成器函数:</a></p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff nf"><img src="../Images/3ece605249ac366f626213ce4274ede8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xodxu71lHFpCBEJpo4jvfg.png"/></div></div></figure><p id="26b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个生成器函数<code class="eh jp jq jr js b">gen</code>有一些有趣的方面(摘自<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank"> MDN </a>文档) :</p><ol class=""><li id="8df7" class="kp kq hu it b iu iv iy iz jc ng jg nh jk ni jo nj kx ky kz dt translated">当一个生成器函数被调用时，它的主体不会被立即执行。相反，它返回一个遵循<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="noopener ugc nofollow" target="_blank">迭代器协议</a>的迭代器对象，即它有一个<code class="eh jp jq jr js b">next</code>方法。</li><li id="df75" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo nj kx ky kz dt translated">执行<code class="eh jp jq jr js b">gen</code>主体的唯一方法是调用迭代器对象上的<code class="eh jp jq jr js b">next</code>方法。每次调用<code class="eh jp jq jr js b">next</code>方法时，都会执行其主体，直到下一个<code class="eh jp jq jr js b"><a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="noopener ugc nofollow" target="_blank">yield</a></code>表达式。这个表达式的值从迭代器返回。</li><li id="ad93" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo nj kx ky kz dt translated">这个<code class="eh jp jq jr js b">next</code>方法也接受一个参数。用参数调用它会用参数替换当前的<code class="eh jp jq jr js b">yield</code>表达式，并继续执行，直到下一个<code class="eh jp jq jr js b">yield</code>表达式。</li></ol><h2 id="0ca2" class="ju jv hu bd jw jx jy jz ka kb kc kd ke jc kf kg kh jg ki kj kk jk kl km kn ko dt translated">阐明(非常、非常粗略地)..</h2><ul class=""><li id="79bc" class="kp kq hu it b iu kr iy ks jc kt jg ku jk kv jo kw kx ky kz dt translated">生成器函数通过其迭代器(<code class="eh jp jq jr js b">next</code>方法)执行<code class="eh jp jq jr js b">yield-by-yield</code>(即一次一个产出表达式)。</li><li id="5b76" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">每一个<code class="eh jp jq jr js b">yield</code> <em class="li"> </em>都有一个<em class="li">给予</em> → <em class="li">停止</em> → <em class="li">采取</em>的行为，可以这么说。</li><li id="304f" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">它<em class="li">向迭代器给出</em>当前yield表达式的值。</li><li id="c525" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">然后<em class="li">在这一点上停止</em>，直到迭代器的<code class="eh jp jq jr js b">next</code>方法被再次调用。</li><li id="4703" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">当再次调用<code class="eh jp jq jr js b">next</code>方法时，它<em class="li">从它那里获取</em>参数，并用它替换当前暂停的yield-expression。然后移动到下一个<code class="eh jp jq jr js b">yield</code>。</li></ul><p id="c76d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="li">你可能想再读一遍上面的总结或者参考一下</em> <a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank"> <em class="li">百变MDN文档</em> </a> <em class="li">！</em></p><h2 id="c631" class="ju jv hu bd jw jx jy jz ka kb kc kd ke jc kf kg kh jg ki kj kk jk kl km kn ko dt translated">但是这对我们有什么帮助呢？</h2><p id="bac2" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">现在你可能会想，生成器函数对我们的情况有什么帮助？我们需要建模一个异步流，在这个异步流中，我们必须等待某些任务完成，然后才能继续。但到目前为止，在我们的讨论中，一切都是同步的。我们如何做到这一点？</p><blockquote class="nk"><p id="6f8d" class="nl nm hu bd nn no np nq nr ns nt jo ek translated">这里最重要的一点是，生成函数也可以产生<code class="eh jp jq jr js b">promises</code>。</p></blockquote><p id="a9f3" class="pw-post-body-paragraph ir is hu it b iu nu iw ix iy nv ja jb jc nw je jf jg nx ji jj jk ny jm jn jo hn dt translated">一个<code class="eh jp jq jr js b">generator</code>函数可以<code class="eh jp jq jr js b">yield</code>一个<code class="eh jp jq jr js b">promise</code>(例如一个异步任务)，并且它的迭代器可以被控制为<em class="li"> halt </em>以便这个<code class="eh jp jq jr js b">promise</code>解析(或拒绝)，然后继续解析(或拒绝)的值。这种用yielded <code class="eh jp jq jr js b">promises</code>编织迭代器的模式允许我们像这样建模我们的需求:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff nz"><img src="../Images/82ddfb560de412b07e288129ccbf20f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6f3QQcaIkWN28CF5tU1gw.png"/></div></div></figure><p id="a2c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="li">(注意这个生成器函数与我们的</em> <code class="eh jp jq jr js b"><em class="li">async</em></code> <em class="li">函数多么相似！)</em></p><p id="cb10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这只是故事的一半。现在我们需要一种方法来执行它的身体。我们需要一个函数，它可以控制这个<code class="eh jp jq jr js b">generator</code>函数的迭代器在每次产生一个<code class="eh jp jq jr js b">promise</code>时<em class="li">停止</em>并在它解决(或拒绝)时继续。这听起来很复杂，但实现起来非常简单，如下所示:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff oa"><img src="../Images/f9ac5f5ef508aba96241c474363fb70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5UJ7gtX6-G_z5TdECl0UA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">A function that executes a generator function. (Only for explanation, <strong class="bd ob">do not use it !</strong>)</figcaption></figure><p id="e1d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以使用这个<code class="eh jp jq jr js b">runner</code>函数来执行我们的<code class="eh jp jq jr js b">generator</code>函数<code class="eh jp jq jr js b">init</code>，如下所示:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff ne"><img src="../Images/5e401511f13664f83fc043938365bb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoQvqR-onJVgZW0m08G2GA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Use `runner` to execute the body of `init`.</figcaption></figure><p id="d721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！这个<code class="eh jp jq jr js b">runner</code>函数和我们的<code class="eh jp jq jr js b">generator</code>函数的组合实现了与原始<code class="eh jp jq jr js b">async</code>函数相似的结果。</p><p id="9616" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="li">请注意，此</em> <code class="eh jp jq jr js b">runner</code> <em class="li">功能仅用于演示概念。是</em> <strong class="it hv"> <em class="li">不是</em> </strong> <em class="li">适合任何正经使用。如果你正在寻找一个合适的实现，你可以在这里找到</em><a class="ae jt" href="https://gist.github.com/jakearchibald/31b89cba627924972ad6" rel="noopener ugc nofollow" target="_blank"><em class="li"/></a><em class="li">。</em></p></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="8d40" class="mh jv hu bd jw mi mj mk ka ml mm mn ke mo mp mq kh mr ms mt kk mu mv mw kn mx dt translated">总结一下</h1><p id="5fe4" class="pw-post-body-paragraph ir is hu it b iu kr iw ix iy ks ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们从一个<code class="eh jp jq jr js b">async</code>函数开始，然后使用<code class="eh jp jq jr js b">generators</code>和<code class="eh jp jq jr js b">promises</code>编写了一个相同的实现。也就是说，下面两段代码将具有类似的效果:</p><figure class="lk ll lm ln fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff oc"><img src="../Images/74235fccca49fd12a31bb5764542382c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rNhPf1WeuVIB_qwtlKmUQ.png"/></div></div></figure><h2 id="0858" class="ju jv hu bd jw jx jy jz ka kb kc kd ke jc kf kg kh jg ki kj kk jk kl km kn ko dt translated">进一步练习</h2><ul class=""><li id="6be7" class="kp kq hu it b iu kr iy ks jc kt jg ku jk kv jo kw kx ky kz dt translated">在本文的开头，我们看了Babel如何使用<code class="eh jp jq jr js b">generators</code>和<code class="eh jp jq jr js b">promises</code>将<code class="eh jp jq jr js b">async</code>代码转换成ES2016代码。您现在可以重新访问转换后的代码，并比较我们的<code class="eh jp jq jr js b">runner</code>函数与<code class="eh jp jq jr js b">_asyncToGenerator</code>函数是如何相似的。事实上，<code class="eh jp jq jr js b">_asyncToGenerator</code>函数是我们极其简单的<code class="eh jp jq jr js b">runner</code>函数的简单版本。</li><li id="5999" class="kp kq hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">如果您仍然感兴趣，您可以更进一步，即将<code class="eh jp jq jr js b">async</code>功能转换为ES2015代码，即没有<code class="eh jp jq jr js b">generators</code>。为此，您必须模拟<code class="eh jp jq jr js b">generators</code>本身(使用带有<code class="eh jp jq jr js b">switch</code>情况的有状态繁忙循环，例如参见<a class="ae jt" href="http://facebook.github.io/regenerator/" rel="noopener ugc nofollow" target="_blank">再生器项目</a>)。</li></ul><p id="ee62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这个解释能解开<code class="eh jp jq jr js b">async</code>函数背后的谜团。它们提供了更简单的语法，因此代码噪音更少。关于<code class="eh jp jq jr js b">async</code>功能的建议指出:</p><blockquote class="my mz na"><p id="b09e" class="ir is li it b iu iv iw ix iy iz ja jb nb jd je jf nc jh ji jj nd jl jm jn jo hn dt translated">ECMAScript中承诺和生成器的引入提供了一个机会，可以极大地改进在ECMAScript中编写异步代码的语言级模型。</p></blockquote><p id="8d13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢<a class="ae jt" href="https://github.com/kittaakos" rel="noopener ugc nofollow" target="_blank">阿科斯</a>、<a class="ae jt" href="https://github.com/alisa-lisovskaya" rel="noopener ugc nofollow" target="_blank">亚里沙</a> &amp; <a class="ae jt" href="https://twitter.com/kristianduske" rel="noopener ugc nofollow" target="_blank">克里斯蒂安</a>为改进本文提供反馈。</p><figure class="lk ll lm ln fq lo"><div class="bz el l di"><div class="od oe l"/></div></figure></div></div>    
</body>
</html>