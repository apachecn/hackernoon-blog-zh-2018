<html>
<head>
<title>How we built a cloud-based programming language: ASTs in the Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何构建基于云的编程语言:云中的ASTs</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-we-built-a-cloud-based-programming-language-asts-in-the-cloud-bb5c45c32bab?source=collection_archive---------28-----------------------#2018-05-02">https://medium.com/hackernoon/how-we-built-a-cloud-based-programming-language-asts-in-the-cloud-bb5c45c32bab?source=collection_archive---------28-----------------------#2018-05-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="11fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jp">建筑泡沫。</em> </strong> <em class="jp">在这一系列的帖子中，我们的工程团队谈论了Bubble的内部工作原理，这是一种基于云的可视化编程语言，它让编程变得人人都可以使用。</em></p><p id="8442" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你曾经试图构建一个编译器或解释器，你可能熟悉抽象语法树，通常缩写为ASTs。AST代表代码在计算机看来的样子。它是程序的赤裸裸的结构，去掉了所有的标点和空格，按层次组织成一棵树。</p><p id="fb91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在Javascript中，代码</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="70dc" class="jz ka hu jv b fv kb kc l kd ke">if (x === 3) {<br/> alert('hi!');<br/>}</span></pre><p id="553a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可能会变成这样的图表</p><figure class="jq jr js jt fq kf fe ff paragraph-image"><div class="ab fr cl kg"><img src="../Images/e35e162b769ee58b944c860aa3965948.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7ZDySNs0GL4ufGzw03Gg3A.png"/></div></figure><p id="361c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当计算机编译或运行计算机程序时，它首先将程序员键入的代码转换成AST，然后导航AST来实际执行它。</p><p id="e258" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kj" href="https://bubble.is" rel="noopener ugc nofollow" target="_blank">泡泡</a>不像传统的编程语言，没有代码。它只是一个AST，没有任何语法。我们不是将Bubble应用程序存储为代码，而是存储树本身。我们基于web的可视化编辑器直接操纵AST。</p><p id="b522" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为Bubble应用程序被存储为ast而不是代码，所以随着时间的推移，我们比传统编程语言更容易发展Bubble语言。我们可以对Bubble程序员使用的用户界面进行彻底的修改，而不会破坏与现有用户应用程序的兼容性，因为我们可以编写代码来解释现有的ast并将它们转换为新的格式。</p><p id="5ad9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于这个原因，Bubble是解释的，而不是编译的:当运行Bubble应用程序时，我们将原始AST提供给一个知道如何执行它的解释器，这意味着当我们改变Bubble的工作方式时，没有必要重新编译现有的应用程序。</p><p id="1118" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，因为ASTs是泡沫语言的核心——它们基本上是泡沫语言——我们在构建泡沫时面临的第一个决定就是使用什么技术来存储和传输它们。</p><p id="0d77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">剧透提示:我们选了JSON。</p><p id="ca26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSON是在基于web的环境中表示数据树的明显选择，原因有两个。首先，它是一种标准格式，可以很容易地作为纯文本在互联网上发送。第二，它非常灵活且易于构建树:您只需嵌套对象，使用键和值的任意组合。最后，Bubble是用Javascript编写的(确切地说，是CoffeeScript，但我们将在另一篇文章中讨论)，因此JSON文档可以直接转换为Javascript对象图，没有任何奇怪的阻抗不匹配。</p><p id="faf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们第一次开始开发Bubble时，我们设想每个Bubble应用程序都是一个JSON文档，我们可以根据需要在网络上发送。我们认为我们可以把所有东西都存储在内存中，要么在用户的浏览器中，要么在服务器上。哈！现在回想起来，这真是天真得令人眼花缭乱。</p><p id="3e39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们第一次看到一个5 MB文档的应用程序时，我们有一个“哦，该死”的瞬间。我们的代码将整个5 MBs加载到内存中来做<em class="jp">任何事情</em>，我们开始观察Bubble平台爬行到一个令人讨厌的停顿(今天，有超过100 MBs的Bubble应用程序)。</p><p id="3e60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显然，我们必须以某种方式将应用程序分成块，并且只发送执行任何给定操作所需的块。在某些情况下，这相当容易。例如，当在服务器上运行Bubble工作流时，表示该工作流的所有代码都在AST的单个分支中。</p><p id="01cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，在其他情况下，事情会变得更难。Bubble中有很多东西引用了应用程序的其他部分:例如，元素引用样式，动作引用元素，表达式引用用户定义的类型。</p><p id="a071" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，弄清楚我们需要加载应用程序的哪一部分来做某件事会变得很复杂。通常我们需要在应用程序的一部分加载数据，这些数据将包含对应用程序另一部分的引用，我们也需要加载另一部分，但在加载第一部分之前我们不会知道。</p><p id="a790" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某些情况下，高效的做法是预先加载一大块应用程序。当用户在web浏览器中显示气泡页面时，我们知道我们需要AST来呈现页面上的所有元素，因此将它们捆绑在一起并发送是有意义的。</p><p id="2c04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在其他情况下，当我们发现需要数据时，延迟加载数据会更有效:当在服务器上运行工作流时，如果服务器操作引用了应用程序中的其他内容，我们希望能够将它引用的节点(通常只有几个字节的数据)临时拉入内存。</p><p id="fe9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让这样一个混乱的问题如此接近我们产品的核心机制是不好的。我们希望能够开发Bubble，而不必不断地处理什么数据在何时何地可用的问题。所以，当我们遇到一个我们不想处理的棘手问题时，我们做了我们经常做的事情:我们发明了一个抽象层。</p><p id="a1d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们称这个层为JSON base——有点缺乏创造性。它是对JSON文档中一个节点的抽象。从JSONBase继承的每个对象都有一个应用程序名称和应用程序版本，用于标识它属于哪个文档，它还有一个路径，用于指示它指向文档中的哪个节点。例如，路径“a.b.c”指的是</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="a4d0" class="jz ka hu jv b fv kb kc l kd ke">{<br/> a: {<br/> b: {<br/> c: ← THIS<br/> }<br/> }<br/>}</span></pre><p id="eb72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSONsBase(或简称为JSON)完全是抽象的。JSON指向的键，甚至整个子树，可能实际存在，也可能不存在。这意味着我们可以使用它们，而不用担心空引用的错误，也不用担心数据是否被加载。我们已经从实际的JSON对象本身抽象出了JSON文档中的位置。</p><p id="4591" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSONs公开了导航树和访问数据的方法。例如，在代表‘a . b . c’的json上调用<code class="eh kk kl km jv b">json.child('d')</code>会产生JSON‘a . b . c . d’；调用<code class="eh kk kl km jv b">json.parent()</code>产生‘a . b’。<code class="eh kk kl km jv b">json.raw()</code>返回一个javascript对象，表示存储在树中这个位置的数据；<code class="eh kk kl km jv b">json.exists()</code>返回一个布尔值，表明是否有任何数据存储在那里。</p><p id="68ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSONBase是一个抽象基类；它定义了一个接口和一些功能，但是没有说明数据是如何存储或加载的。我们实际上有三个单独的JSONBase实现，对应于Bubble代码运行的三个主要环境:在Bubble可视化编辑器中，在用户访问基于Bubble构建的页面时在用户的web浏览器中，以及在我们的web服务器上。</p><p id="0d64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最简单的是RuntimeJSON:这是我们在浏览器中渲染泡泡app时使用的。RuntimeJSON是关于速度的:当我们渲染一个页面时，我们希望它尽可能的快。RuntimeJSON根本没有取数据的能力。我们在服务器上预先计算需要应用程序的哪些部分来呈现页面，然后将它们发送过来:RuntimeJSON是内存中加载的实际数据的一个薄薄的包装器。</p><p id="ee82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相比之下，我们在web浏览器中使用的EditorJSON是气泡编辑器的一部分，它非常灵活。当有人使用气泡编辑器时，我们需要的应用程序数据子集会随着他们导航到应用程序的不同部分而动态变化，因此EditorJSON能够根据需要动态查询服务器以获得更多数据。</p><p id="472d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">EditorJSON还能够处理对应用程序对象的更改。每个EditorJSON对象都有一个<code class="eh kk kl km jv b">.set(data)</code>方法来覆盖应用程序树的这一部分。当调用<code class="eh kk kl km jv b">set</code>时，EditorJSON将它保存在web浏览器的内存中，并向服务器发送一个请求，将它永久保存到我们的数据库中。</p><p id="4b8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，EditorJSON有一个通知机制，让依赖该数据的编辑器代码的其他部分知道已经有了更新，这样他们就可以根据需要重新绘制UI。(我们使用与React类似的数据绑定方式……这是另一篇文章的主题！)因为多个用户可能会同时编辑同一个应用程序，EditorJSON会定期向服务器轮询其他用户所做的任何更新，以便我们可以实时显示这些编辑。</p><p id="ae2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您可能想象的那样，EditorJSON的代码比RuntimeJSON的代码复杂得多，而且性能也不如后者。但由于它们共享相同的JSONBase接口，我们的大部分代码不需要知道它在处理两者中的哪一个:我们可以编写与其中任何一个兼容的代码，然后在运行一个app时获得RuntimeJSON的性能(我们称之为“运行模式”)，或者Bubble可视化编辑器中实时数据更新的灵活性(“编辑模式”)。</p><p id="bbba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ServerJSON在Bubble服务器的运行模式下使用，介于RuntimeJSON和EditorJSON之间。我们在服务器上加载数据，以便为页面构建HTML，计算我们需要将应用程序树的哪些部分发送到web浏览器，以及执行在服务器上运行的工作流。</p><p id="8ee2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，像EditorJSON一样，我们需要在需要时动态加载数据，因为在任何时候我们的服务器都可能需要执行任何用户应用程序的任何部分。然而，与EditorJSON相比，性能是重中之重，因为当运行一个应用程序时，我们希望尽可能快。幸运的是，我们可以让它比EditorJSON更简单、更快，不用担心应用程序所有者会做出改变。在执行单个页面或工作流时，我们希望呈现应用程序的一致视图，因此我们既不需要也不想考虑更改。</p><p id="253f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSONBase证明了抽象的力量。通过在代表Bubble应用程序AST的原始JSON文档周围包装一层，我们能够编写管理数兆字节文档的代码，只将我们实际需要的部分加载到内存中，而不会将该企业的复杂性泄漏到我们代码库的其余部分。</p><p id="52ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSONs不是Bubble语言解释器中唯一的抽象层次。原始的AST很好，但是就其本身而言，我们不知道所有这些JSON树<em class="jp">意味着什么</em>。你可以在我们系列的下一篇文章《云中的树，第二部分》中读到。</p><p id="9b12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">觉得这个有意思？</em> <a class="ae kj" href="https://bubble.is/jobs" rel="noopener ugc nofollow" target="_blank"> <em class="jp">我们一直在寻找优秀的工程师加入我们</em>！</a></p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="f8eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">原载于2018年5月2日</em><a class="ae kj" href="https://blog.bubble.is/trees-in-the-clouds-a09b83668d10" rel="noopener ugc nofollow" target="_blank"><em class="jp">blog . bubble . is</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>