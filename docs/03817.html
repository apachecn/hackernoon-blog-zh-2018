<html>
<head>
<title>How to structure your react app.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建你的react应用？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-structure-your-react-app-98c48e102aad?source=collection_archive---------1-----------------------#2018-05-03">https://medium.com/hackernoon/how-to-structure-your-react-app-98c48e102aad?source=collection_archive---------1-----------------------#2018-05-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e38a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你在一个大团队中工作时，拥有一个风格指南总是好的，不仅对于CSS和JS，而且对于构建组件和文件夹也是如此。我决定写我自己的来展示我如何以及在哪里放置我的文件和文件夹。开始吧！</p><p id="59f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://itnext.io/how-to-structure-your-react-app-2-2cf3b8040634" rel="noopener ugc nofollow" target="_blank">链接到第二部分。</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/b1e0795ee17559af7611610b727a0595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmvaZRzOoAOrCqER4FgHpQ.jpeg"/></div></div></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff kj"><img src="../Images/04a0c4cf3d554af5ba705092f5a592a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*JgY30hiRSnk5qP5K07b5EA.png"/></div></figure><p id="7beb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我总是根据商业价值来划分我的组件。我称之为<code class="eh kk kl km kn b">bundle</code>。</p><p id="20e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，我曾经构建的每一个<a class="ae jp" href="https://hackernoon.com/tagged/application" rel="noopener ugc nofollow" target="_blank">应用程序</a>都有一个公共包，它包含了所有的公共组件，比如页眉、页脚、按钮、模态等等。如果你有一个用户页面(设置，照片，个人资料)，它将是一个用户捆绑包，其中将有特定于一个用户的所有组件。拥有这样的结构真的很方便，因为无论何时你在浏览器中看到一个页面，你都可以说你需要去哪里找到那个组件。对于那些不知道你是如何构建组件的新手来说，这也是一件好事。他们能够猜出这是什么包。例如:<code class="eh kk kl km kn b">/user/22/preview</code>页面将显示用户包中的一个组件。很容易猜到。</p><p id="a858" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个包都有几个文件夹:</p><ol class=""><li id="6bef" class="ko kp hu it b iu iv iy iz jc kq jg kr jk ks jo kt ku kv kw dt translated"><code class="eh kk kl km kn b"><strong class="it hv">actionCreators</strong></code>举行redux-actions。</li></ol><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kx"><img src="../Images/8367b26dd5d9c79dd99b6649ce80aef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTXxOewWUEN8lhP9C75n4Q.png"/></div></div></figure><p id="f5e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<code class="eh kk kl km kn b"><strong class="it hv">Components</strong></code>是一个包中所有组件的文件夹。组件文件夹中的每个文件夹都应该以第一个大写字母命名，作为所有组件的文件。我总是使用第一个大写字母的原因是，当你在你的项目中通过名字搜索一个文件时，你总是可以通过名字<code class="eh kk kl km kn b">header</code>和<code class="eh kk kl km kn b">Header</code>识别组件，你总是知道第二个是一个组件。在你开始进一步阅读之前，请考虑阅读这篇<a class="ae jp" rel="noopener" href="/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">文章</a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/d32c3edac4e67f1aca2fec7f1e0b703f.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*rSYMQqfBxcRB28C1Zm-zmw.png"/></div></figure><p id="de3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在来说说为什么有三个文件而不是一个。</p><p id="4122" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kk kl km kn b">Header.js</code>只是一个普通的视图。它可能是一个无状态的组件(函数)或者一个类。我更喜欢使用类，因为类可以和HMR一起开箱即用，但这取决于你。你应该知道的唯一一件事是视图是一个愚蠢的组件，它只能渲染道具，不应该有任何业务逻辑。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kz"><img src="../Images/9f051d23d9059597fb46edf826df8b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQVUjt3Zrb6RiASrsc6Ifw.png"/></div></div></figure><p id="5db4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kk kl km kn b">HeaderContainer.js </code>是一个“智能”组件。这类组件总是进行数据提取、准备数据、从redux-store/ <a class="ae jp" href="https://hackernoon.com/tagged/relay" rel="noopener ugc nofollow" target="_blank"> relay </a>获取数据、定义动作、注入intl或jss。这是组合<a class="ae jp" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>的好地方。通常，您不会在智能组件中导入react，因为您不应该在那里呈现任何内容。它应该是这样的:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff la"><img src="../Images/7100915a778f590627f2bb3a20042006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFl1J36-QF_fhQEHwbiEBw.png"/></div></div></figure><p id="a7c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kk kl km kn b">index.js</code>只需再出口组件。如果你在应用程序的某个地方导入你的组件，你会这样做<code class="eh kk kl km kn b">import Header from 'bundles/common/components/Header/Header.js’</code>。为了避免重复<code class="eh kk kl km kn b">Header/Header.js</code>，我们可以在index.js中重新导出我们的Header组件。把它放在这里也很好，因为你可能有两个容器和一个视图，例如:<code class="eh kk kl km kn b">CreateUserFormContainer.js</code> <code class="eh kk kl km kn b">UpdateUserFormContainer.js</code>和一个视图<code class="eh kk kl km kn b">UserForm.js</code>。当然你有两条不同的路线:<code class="eh kk kl km kn b">update-user</code> &amp; <code class="eh kk kl km kn b">create-user</code>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lb"><img src="../Images/3adc249c6fb688efe62c79dbd8155747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzzR-Qrc9rCNFu33dHYD5Q.png"/></div></div></figure><p id="0be6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以像<code class="eh kk kl km kn b">import { Header, HeaderContainer } from 'bundles/common/components/Header';</code>一样导入我们的组件</p><p id="5fbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<code class="eh kk kl km kn b"><strong class="it hv">reducers</strong></code> <strong class="it hv"> </strong>是一个用于一个束的所有异径管的文件夹。intl.js的Reducer如下所示:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lc"><img src="../Images/a48531488c1879854300e3ffbb60732c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EX8wWKgQ5b56m636z-06w.png"/></div></div></figure><p id="921f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.<code class="eh kk kl km kn b"><strong class="it hv">routes</strong></code>文件夹保存当前束的所有路线。同一个包可以有几个路由文件。对于公共包，有任何路由是不正常的，因为它是公共包，但是假设我们有一个路由显示我们的头:<code class="eh kk kl km kn b">/header</code>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ld"><img src="../Images/52dffc1ec0a795fb539fb2f4f2120373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBJtnmUIVr4gHHpC0M44MA.png"/></div></div></figure><p id="fddb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我收集了每个路由文件中的所有路由，并将它们导出为一个数组。后来，在我的应用程序的入口点，我导入所有的路线，将它们合并成一个数组，并在<code class="eh kk kl km kn b">Router</code>中渲染。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff le"><img src="../Images/edbeaffd4b9277786c5e6bb6db401b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Xq4ZIrBwuRThHnWH-uR9A.png"/></div></div></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="9ede" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结论。唯一重要的是你和你的团队之间的合作有多愉快。风格指南只是你和你的团队定义的一个约定。希望你喜欢这篇文章。喜欢请点赞&amp;分享。和平。</p><p id="0381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://itnext.io/how-to-structure-your-react-app-2-2cf3b8040634" rel="noopener ugc nofollow" target="_blank">链接到第二部分</a>。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lf lg l"/></div></figure></div></div>    
</body>
</html>