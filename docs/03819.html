<html>
<head>
<title>First experiences with React Native: bridging an Android native module for app authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native的第一次体验:为应用程序认证桥接Android原生模块</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/first-experiences-with-react-native-bridging-an-android-native-module-for-app-authentication-501fec247b2b?source=collection_archive---------3-----------------------#2018-05-03">https://medium.com/hackernoon/first-experiences-with-react-native-bridging-an-android-native-module-for-app-authentication-501fec247b2b?source=collection_archive---------3-----------------------#2018-05-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/545b36da50f583408f8b2514b68f2dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCRKASu5K5ZEHcEjTUaRzQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/B76nvP51iew?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NGO TUNG</a> on <a class="ae jg" href="https://unsplash.com/search/photos/bridging?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dfa8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的公司CriticalBlue提供名为<a class="ae jg" href="https://www.approov.io/" rel="noopener ugc nofollow" target="_blank">approv</a>的远程移动应用认证服务。Approov SDK作为嵌入式库提供给原生iOS和Android应用程序开发人员。</p><p id="0c6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随着我们的许多客户使用或试验React Native，我希望提供一个方便的Javascript模块，向React Native开发人员公开native Approov SDK功能。</p><p id="2857" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总的来说，创建我的第一个React原生模块非常简单。我最初的概念验证的所有代码都可以在<a class="ae jg" href="https://github.com/approov/rndemo" rel="noopener ugc nofollow" target="_blank"> github库</a>中找到。</p><h1 id="fb61" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">反应本地桥</h1><p id="00d4" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">对于react Native，脸书提供了一个坚实的入门指南,介绍了基础知识，包括如何设置应用程序，以及底层UI组件与常见的React web元素有何不同。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/54a775df417a746fbe1a3118e2836c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3pavpyOh_BCxYVpnyGD6A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">from <a class="ae jg" href="https://www.reactnative.guide/3-react-native-internals/3.1-react-native-internals.html" rel="noopener ugc nofollow" target="_blank">React Made Native Easy</a></figcaption></figure><p id="43b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在架构上，每个React本机应用程序中都运行着两个重要的线程——一个是主UI线程，另一个运行Javascript VM。这两个线程通过一个桥进行交互，这个桥的通信是异步的、序列化的和批处理的，尽可能地将两个系统解耦。</p><p id="5313" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然React本机应用程序的大部分是在React中描述的，并在Javascript VM上运行，但用户界面是使用本机平台的用户界面元素呈现的，改变应用程序用户界面的操作作为消息通过桥从VM传递到应用程序的主用户界面线程。</p><p id="4b25" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为原生设备环境开发的系统功能和库可以使用React Native的原生模块接口向Javascript VM公开，并通过React Native桥访问。</p><h1 id="7b71" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Approov原生SDK</h1><p id="f2c1" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Approov SDK是一个嵌入式原生iOS或Android库。它与基于云的Approov认证服务进行交互，该服务验证应用程序是真实的、未经篡改的，并且不是机器人。从身份验证服务返回一个应用程序完整性令牌，该令牌随每个API调用一起发送，以确保后端API服务正在处理一个已知的真实前端请求。</p><p id="7567" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将在本机模块概念验证中公开的基本操作是<code class="eh ln lo lp lq b">fetchApproovToken()</code>，这是本机SDK中的一个异步操作。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lr"><img src="../Images/bf5ce807470c4aebec328fd6bca69997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djbl-cSEqRQW_B2z0bbs5Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Approov-protected API call</figcaption></figure><p id="ef2a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在每个需要应用程序身份验证的后端API调用之前，客户端应用程序都会发出一个获取令牌的请求。如果需要新令牌，SDK会发出远程证明请求，证明服务会对应用进行加密身份验证，并使用应用完整性令牌进行响应。</p><p id="7855" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">令牌的生命周期很短，并且由只有Approov服务和应用程序后端服务知道的秘密签名。应用程序中没有存储任何秘密，事实上，应用程序不知道返回的令牌是否有效。该应用程序只需将完整性令牌添加到后端API调用中，后端服务器在处理请求之前验证令牌是否已过期并正确签名。</p><h1 id="82a6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Approov演示服务</h1><p id="a2ea" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Approov提供了一个<a class="ae jg" href="https://approov.io/demo-reg.html" rel="noopener ugc nofollow" target="_blank">可下载演示</a>，它提供了演示iOS和Android SDKs以及一个具有两个端点的后端服务:</p><ul class=""><li id="5ad8" class="ls lt hu jj b jk jl jo jp js lu jw lv ka lw ke lx ly lz ma dt translated">https://demo-server.approovr.io/hello<a class="ae jg" href="https://demo-server.approovr.io/hello" rel="noopener ugc nofollow" target="_blank">，提供一个公共可访问的测试点。</a></li><li id="06ef" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated"><a class="ae jg" href="https://demo-server.approovr.io/hello" rel="noopener ugc nofollow" target="_blank">https://demo-server.approovr.io/shapes</a>，仅当请求包含有效的完整性令牌时，它才提供随机形状。</li></ul><p id="78fa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用Android SDK和后端服务来演示一个使用Approov的简单React本地应用程序。还提供了使用iOS SDK和React native的示例版本。</p><h1 id="819f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">打招呼</h1><p id="7f4d" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我使用create-react-native-app (CRNA)开始了我的React Native项目。按照<a class="ae jg" href="https://github.com/react-community/create-react-native-app" rel="noopener ugc nofollow" target="_blank"> CRNA安装说明</a>设置React本地环境，然后:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="0450" class="mk kg hu lq b fv ml mm l mn mo">$ create-react-native-app rndemo</span></pre><p id="cec9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将在应用程序中添加本机代码，所以现在就从create-react-native-app中退出:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="1fbb" class="mk kg hu lq b fv ml mm l mn mo">$ cd rndemo<br/>$ yarn eject<br/>...</span><span id="f695" class="mk kg hu lq b fv mp mm l mn mo">Ejecting is permanent! Please be careful with your selection.</span><span id="11e9" class="mk kg hu lq b fv mp mm l mn mo">? How would you like to eject from create-react-native-app? React Native: I’d like a regular React Native project.<br/>We have a couple of questions to ask you about how you’d like to name your app:<br/>? What should your app appear as on a user’s home screen? RN Demo<br/>? What should your Android Studio and Xcode projects be called? rndemo</span><span id="923b" class="mk kg hu lq b fv mp mm l mn mo">Wrote to app.json, please update it manually in the future.<br/>Generating the iOS folder.<br/>Generating the Android folder.<br/>...</span></pre><p id="3c81" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">选择一个常规的React原生项目，并随意命名。iOS和Android项目已经生成，您需要安装<a class="ae jg" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>和/或<a class="ae jg" href="https://developer.android.com/studio/" rel="noopener ugc nofollow" target="_blank"> Android Studio </a>构建环境。稍后，原生代码将添加到原生Android项目中。</p><p id="68b4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用一个非常简单的概念验证应用程序进行实验，该应用程序将使用演示服务器hello endpoint来验证我们的网络连接。</p><p id="0108" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React Native实现了用于联网的<a class="ae jg" href="https://facebook.github.io/react-native/docs/network.html" rel="noopener ugc nofollow" target="_blank">获取API </a>。我们将连接检查、UI呈现和样式化全部结合在<code class="eh ln lo lp lq b">App.js</code>文件中:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="89fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">顶层App组件注册在<code class="eh ln lo lp lq b">index.js</code>文件中。</p><p id="ccad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">主视图由无状态视图组件呈现，该组件显示图像选项和状态消息:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="fca3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在这些例子中使用的是Android，但是在iOS上也是一样的。启动一个Android模拟器(为此你可能需要启动Android Studio)或者通过<code class="eh ln lo lp lq b">adb</code>连接一部手机。在<code class="eh ln lo lp lq b">rndemo</code>目录中，启动应用程序:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="7cde" class="mk kg hu lq b fv ml mm l mn mo">$ cd rndemo<br/>$ yarn run android</span></pre><p id="2ccc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您应该会看到这样的屏幕:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/f32b54fd711fdf4a8a5224cb34dfee8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*FNmo4eKph5zdRwchKrOzJQ.png"/></div></figure><p id="332d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">按下<code class="eh ln lo lp lq b">TEST HELLO</code>按钮，如果一切正常，你应该会看到一条连接信息:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/9352ebec0a7c6c096e69c796e31240b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*6bluN2w3sFgby02Lb7m0Cw.png"/></div></figure><p id="e625" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这验证了React本地应用程序和演示服务器之间的网络通信。您可以在手机或模拟器上设置飞行模式，然后再次按下测试按钮来验证是否不再有连接。</p><h1 id="d955" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Approov本机模块</h1><p id="1a45" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">approv演示包包括一个自述文件、iOS和Android Approov演示库、示例客户端和应用程序注册工具。下载<a class="ae jg" href="https://approov.io/demo-reg.html" rel="noopener ugc nofollow" target="_blank">演示包</a>，保存下载邮件中包含的应用注册令牌。</p><p id="df1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Approov SDK包含了我们想要公开的本机代码，以实现React Native。它必须包含在我们弹出create-react-native-app时生成的iOS或Android原生项目中。对于Android，这个项目位于<code class="eh ln lo lp lq b">rndemo/android</code>。按照<a class="ae jg" href="https://approov.io/docs" rel="noopener ugc nofollow" target="_blank">approv文档</a>中的这些<a class="ae jg" href="https://approov.io/docs/androidclientapiuserguide.html#importing-the-approov-sdk-into-android-studio" rel="noopener ugc nofollow" target="_blank">指令</a>将Approov SDK导入Android项目。</p><p id="6d11" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过扩展<code class="eh ln lo lp lq b">ReactContextBaseJavaModule</code>类，用Java描述了一个Android原生模块。必须实现<code class="eh ln lo lp lq b">getName()</code>方法，并将模块的名称提供给Javascript。</p><p id="6756" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">暴露给React Native的方法用<code class="eh ln lo lp lq b">@ReactMethod</code>修饰，可能提供Javascript回调或承诺机制。我们将在例子中使用承诺。脸书的<a class="ae jg" href="https://facebook.github.io/react-native/docs/native-modules-android.html" rel="noopener ugc nofollow" target="_blank">原生模块页面</a>描述了其他功能，比如向Javascript发送事件和监听生命周期事件。</p><p id="0bbe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在本机模块构造函数中初始化approv身份验证的默认配置，并在<code class="eh ln lo lp lq b">getName()</code>调用中定义‘approv’。</p><p id="d4a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">公开的<code class="eh ln lo lp lq b">fetchApproovToken()</code>调用包装异步本机<code class="eh ln lo lp lq b">fetchApproovToken()</code>并在令牌获取完成时完成承诺。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="78b0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个<code class="eh ln lo lp lq b">ReactPackage</code>捆绑并创建一个或多个本机模块:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="ec3e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">项目的主应用程序实现<code class="eh ln lo lp lq b">ReactApplication</code>，并创建和返回一个模块包列表。我们将Approov包添加到<code class="eh ln lo lp lq b">getPackages()</code>的列表中。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="0163" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Javascript方面，Approov原生模块现在将包含在从<code class="eh ln lo lp lq b">react-native</code>导入的<code class="eh ln lo lp lq b">NativeModules</code>中。在我们的实现中，<code class="eh ln lo lp lq b">Approov.fetchApproovToken()</code>返回一个普通的javascript承诺:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="c13c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将原生环境和Javascript环境联系起来出人意料地简单。</p><h1 id="5c3e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">截击机</h1><p id="491e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">许多网络库，如<a class="ae jg" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>和<a class="ae jg" href="http://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> OkHt </a> tp，都包含了拦截器的概念。拦截器可以用来拦截网络请求和响应，并注入一些额外的处理。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/f95b911fe6dd83117f23fae1e7b31559.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*mO-GLi118Zrnvm_GYX1dlA.png"/></div></figure><p id="31d2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当使用Android SDK本地实现时，大多数客户使用拦截器来获取Approov令牌并将其添加到每个API请求的头中，因此我们希望在生产模块中完全实现这一抽象。对于这个简单的例子，我们将在一个<code class="eh ln lo lp lq b">fetchWithToken()</code>调用中硬连接拦截。</p><p id="b672" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh ln lo lp lq b">fetchWithToken()</code>方法中，当本地获取令牌调用完成时，如果承诺被解析，我们将令牌添加到输入请求头，并使用增强的输入请求进行<code class="eh ln lo lp lq b">fetch()</code>调用。完成后，fetch返回一个包含API服务器响应的解析承诺。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="53f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了方便起见，我们从<code class="eh ln lo lp lq b">NativeModules.Approov</code>对象创建了一个<code class="eh ln lo lp lq b">Approov</code>对象，添加了一个<code class="eh ln lo lp lq b">fetch()</code>方法，它实际上是<code class="eh ln lo lp lq b">fetchWithToken()</code>方法，然后我们将其导出为<code class="eh ln lo lp lq b">Approov</code>模块。</p><h1 id="5ccc" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">获取形状</h1><p id="1602" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在我们准备使用<code class="eh ln lo lp lq b">Approov</code>对象进行认证。我们在我们的<code class="eh ln lo lp lq b">App</code>中添加了一个<code class="eh ln lo lp lq b">getShape()</code>方法，该方法调用<code class="eh ln lo lp lq b">Approov.fetch(request)</code>来验证和请求一个随机的形状值。一旦获取完成，<code class="eh ln lo lp lq b">App</code>组件状态更新，触发<code class="eh ln lo lp lq b">render()</code>调用，导致<code class="eh ln lo lp lq b">ShapeView</code>显示更新的形状和状态信息。</p><p id="5c4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">按钮栏中添加了一个<code class="eh ln lo lp lq b">GET SHAPES</code>按钮，用于请求新的形状。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="a874" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一切看起来都很好，但是当我们请求一个新的形状时，我们看到一个带有400状态代码的失败，表明客户端请求有问题。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/8ae6d1c8e78f0bade41843cb3440619a.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*BL7oJgXjxS4efSkO3fMWPA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Failure to fetch a shape</figcaption></figure><p id="f80b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">调用失败，因为Approov添加的完整性令牌无效。在我们的示例应用程序正确注册到Approov服务之前，<code class="eh ln lo lp lq b">fetchWithToken()</code>调用将始终无法通过身份验证检查。</p><p id="6276" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">演示下载中包含命令行注册工具。要注册应用程序，请发出注册请求，指定应用程序的APK捆绑包和您从演示下载电子邮件中保存的应用程序注册令牌。出于对其他演示用户的礼貌，请使用<code class="eh ln lo lp lq b">-e</code>标志将您的注册设置为几小时后到期:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="a777" class="mk kg hu lq b fv ml mm l mn mo">$ cd &lt;&lt;approov-demo-package&gt;&gt;/registration-tools/Android/Mac/<br/>$ ./registration <br/>   -a &lt;&lt;rndemo-project&gt;&gt;/android/app/build/outputs/apk/app-debug.apk <br/>   -t &lt;registration-token&gt;<br/>   -e 2h</span><span id="6efb" class="mk kg hu lq b fv mp mm l mn mo">Submitting data…<br/>Success: new app signature added to database.always be done. </span></pre><p id="8611" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦应用程序被注册并被正确认证，按下<code class="eh ln lo lp lq b">GET SHAPES</code>按钮应该会返回以下形状之一:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/98b206cd5a26c6fe2f017ad0c116bcdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTfR5RqMMeNKBYBne0Le9g.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Successfully fetching random shapes</figcaption></figure><h1 id="3bf6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">中间的人攻击</h1><p id="0070" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在API调用期间，通信通道的安全性非常重要。如果通道不安全，API调用可能会被拦截和修改。尽管完整性令牌的生命周期很短，但它可能会在不安全的通道中被观察到，并被用来进行恶意的API调用而不受惩罚。</p><p id="3897" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管在发出API请求时使用HTTPS/TLS，但同时控制网络和移动设备的攻击者可以轻松设置<a class="ae jg" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人(MitM)攻击</a>，在Approov令牌过期前窃取并快速重用它们。</p><p id="745d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了应对MitM攻击，移动客户端应使用<a class="ae jg" href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank">证书或公钥“锁定”</a>，检查后端服务提供的证书或公钥是否为客户端应用程序所知。其他证书虽然看起来可信，但会被客户端拒绝，并且不会进行API调用。</p><p id="5274" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在React Native中实现锁定有点复杂，将在另一篇文章中描述，并集成到这个示例的代码库中。</p><h1 id="1d7c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">更进一步</h1><p id="275e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们已经在React Native中演示了一个本机模块实现，其中一个硬连线的拦截器成功地提供了应用程序验证和API保护。</p><p id="2511" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React Native的产品质量本机模块实现将概括拦截器功能，添加方便的配置方法，并提供完整的MitM保护。相比之下，<a class="ae jg" href="https://cordova.apache.org/" rel="noopener ugc nofollow" target="_blank"> Cordova </a>和<a class="ae jg" href="https://ionicframework.com/framework" rel="noopener ugc nofollow" target="_blank"> Ionic </a>混合应用已经有了类似的<a class="ae jg" href="https://github.com/approov/cordova-plugin-approov-http" rel="noopener ugc nofollow" target="_blank">approv插件库</a>。</p><p id="e412" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个例子的所有代码都位于<a class="ae jg" href="https://github.com/approov/rndemo" rel="noopener ugc nofollow" target="_blank"> github </a>上。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="3df0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢阅读！有关移动API安全性的更多信息，请查看。</p><p id="cc4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你推荐这篇文章(点击👏按钮)以便其他人可以找到它。</p></div></div>    
</body>
</html>