<html>
<head>
<title>Retrofit Converter for wrapped responses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于包装响应的改装转换器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/retrofit-converter-for-wrapped-responses-8919298a549c?source=collection_archive---------3-----------------------#2018-05-04">https://medium.com/hackernoon/retrofit-converter-for-wrapped-responses-8919298a549c?source=collection_archive---------3-----------------------#2018-05-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5c404431d24be02390fb4db7b4e1f00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IEPWfpFr0ESLLCNUrRqmw.png"/></div></div></figure><p id="3168" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很多时候，API响应被包装在一个包装类中，响应中包含自定义的状态代码。一种常见的格式如下</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="4be4" class="kj kk hu kf b fv kl km l kn ko">{<br/>   "data" : {...}<br/>   "status_code" : 0<br/>   "error_message" : null<br/>}</span></pre><p id="f4d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们使用预先打包的json转换器(gson/jackson)进行改造，我们将不得不在进行api调用的任何地方提取底层数据对象。这导致数据对象提取和错误检查逻辑的重复。类似于跟随</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="e145" class="kj kk hu kf b fv kl km l kn ko">data class Data&lt;T&gt;(<br/>       var statusCode: Int = 0,<br/>       var data: T? = null,<br/>       var message: String? = null<br/>)</span><span id="19bd" class="kj kk hu kf b fv kp km l kn ko">interface Api {<br/>    @POST("user/login/")<br/>    fun login(@Body request: LoginRequest): Single&lt;Data&lt;User&gt;&gt;<br/>}</span><span id="5e65" class="kj kk hu kf b fv kp km l kn ko">class UserManager {<br/>    fun login(userName: String, password: String){<br/>         api.login(LoginRequest(userName, password))<br/>            .subscribeOn(schedulerProvider.getIoScheduler())<br/>            .observeOn(schedulerProvider.getUiScheduler())<br/>            .map {if(it.statusCode ==0) then response.data else throw ApiException(it.error_message)}<br/>            .subscribe{...}  <br/>     }<br/>     ...</span><span id="f632" class="kj kk hu kf b fv kp km l kn ko">}</span></pre><p id="d482" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，我们可以使用自己的定制转换器进行改造，它只是普通Gson转换器的一个包装器，这样就可以在一个地方处理数据提取和错误处理逻辑。我们基本上需要两节课</p><ul class=""><li id="ba40" class="kq kr hu je b jf jg jj jk jn ks jr kt jv ku jz kv kw kx ky dt translated"><code class="eh kz la lb kf b">CustomConverter</code>实现改型的<code class="eh kz la lb kf b">Converter&lt;F,T&gt;</code>接口。</li><li id="00b9" class="kq kr hu je b jf lc jj ld jn le jr lf jv lg jz kv kw kx ky dt translated"><code class="eh kz la lb kf b">CustomConverterFactory</code>实现改造的<code class="eh kz la lb kf b">Converter#Factory</code>接口。这负责为每种类型创建<code class="eh kz la lb kf b">CustomConverter</code>。</li></ul><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="6b73" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的要点中，我们使用由“GsonConverterFactory”创建的实际转换器来解析响应，因此我们不必重写任何json编组代码。我们的CustomConverter只是通过提供包装的“类型”而不是实际的“类型”来解析包装的类。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="fbad" class="kj kk hu kf b fv kl km l kn ko">interface Api {<br/>    @POST("user/login/")<br/>    fun login(@Body request: LoginRequest): Single&lt;User&gt;<br/>}</span><span id="86fc" class="kj kk hu kf b fv kp km l kn ko">class UserManager {<br/>    fun login(userName: String, password: String){<br/>         api.login(LoginRequest(userName, password))<br/>            .subscribeOn(schedulerProvider.getIoScheduler())<br/>            .observeOn(schedulerProvider.getUiScheduler())<br/>            .subscribe{...}  <br/>     }<br/>     ...</span><span id="0457" class="kj kk hu kf b fv kp km l kn ko">}</span></pre><p id="b543" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我们的Api接口和逻辑现在的样子。注意Api接口登录方法的<strong class="je hv">返回类型</strong>的变化。</p><p id="c3a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>这个转换器假设所有的响应都是包装格式的，对于任何未包装格式的响应都将失败</p></div></div>    
</body>
</html>