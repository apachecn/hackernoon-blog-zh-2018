<html>
<head>
<title>CircleCI Performance Difference Between Cache and Workspace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存和工作区之间的CircleCI性能差异</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/circleci-performance-difference-between-cache-and-workspace-5567679c3601?source=collection_archive---------4-----------------------#2018-05-07">https://medium.com/hackernoon/circleci-performance-difference-between-cache-and-workspace-5567679c3601?source=collection_archive---------4-----------------------#2018-05-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="bfeb" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">坚持~快70%；恢复速度提高约80%，您的里程数可能会有所不同</h2></div><p id="d96c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">访问https://www.mikenikles.com<a class="ae kf" href="https://www.mikenikles.com" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv"/></a><strong class="jl hv">获取我的最新博文。</strong></p><p id="d195" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">几天前，<a class="kg kh gr" href="https://medium.com/u/25e2a0e23a81?source=post_page-----5567679c3601--------------------------------" rel="noopener" target="_blank"> Andrew Stiegmann </a>评论了<a class="ae kf" href="https://hackernoon.com/a-mostly-automated-release-process-63bb9516985a" rel="noopener ugc nofollow" target="_blank">我的一篇博客文章</a>，其中我分享了我们如何与<a class="ae kf" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>一起自动化我们的发布过程。<a class="ae kf" rel="noopener" href="/@stieg/hey-mike-9435e4633150"> Andrew的评论</a>可以用“<strong class="jl hv">嘿，你有什么理由使用CircleCI缓存而不是工作区？</strong></p><p id="0535" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我阅读了CircleCI的博客文章，它解释了缓存和工作空间的区别。他们的图表很好地解释了这一切:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff ki"><img src="../Images/3c4d98d5908756ff451ca3ca584a1df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bD2zyZAYhYO_ybEG.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">CircleCI cache vs workspace. Source: <a class="ae kf" href="https://circleci.com/blog/persisting-data-in-workflows-when-to-use-caching-artifacts-and-workspaces/" rel="noopener ugc nofollow" target="_blank">CircleCI blog post</a></figcaption></figure><p id="1500" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的CircleCI工作流包含五个作业，每个作业都需要访问<code class="eh ky kz la lb b">node_modules</code>和<code class="eh ky kz la lb b">dist</code>文件夹中的一堆生成文件。图表中描述的“构建工作”是我们安装所有npm包并在<code class="eh ky kz la lb b">dist</code>文件夹中生成文件。我们使用一个monorepo(更多关于这个<a class="ae kf" href="https://hackernoon.com/one-vs-many-why-we-moved-from-multiple-git-repos-to-a-monorepo-and-how-we-set-it-up-f4abb0cfe469" rel="noopener ugc nofollow" target="_blank">这里是</a>)，这导致很多包被提升到根<code class="eh ky kz la lb b">node_modules</code>目录。</p><h1 id="e3cf" class="lc ld hu bd le lf lg lh li lj lk ll lm ja ln jb lo jd lp je lq jg lr jh ls lt dt translated">从缓存迁移到工作区</h1><p id="f38b" class="pw-post-body-paragraph jj jk hu jl b jm lu iv jo jp lv iy jr js lw ju jv jw lx jy jz ka ly kc kd ke hn dt translated">这里的主要变化在<code class="eh ky kz la lb b">.circleci/config.yml</code>文件中。首先，<code class="eh ky kz la lb b"><a class="ae kf" href="https://circleci.com/docs/2.0/configuration-reference/#save_cache" rel="noopener ugc nofollow" target="_blank">save_cache</a></code>指令需要替换为<code class="eh ky kz la lb b"><a class="ae kf" href="https://circleci.com/docs/2.0/configuration-reference/#persist_to_workspace" rel="noopener ugc nofollow" target="_blank">persist_to_workspace</a></code>。同样，任何出现的<code class="eh ky kz la lb b"><a class="ae kf" href="https://circleci.com/docs/2.0/configuration-reference/#restore_cache" rel="noopener ugc nofollow" target="_blank">restore_cache</a></code>都需要用<code class="eh ky kz la lb b"><a class="ae kf" href="https://circleci.com/docs/2.0/configuration-reference/#attach_workspace" rel="noopener ugc nofollow" target="_blank">attach_workspace</a></code>指令替换。</p><p id="9251" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的例子中，仅这一更改就将数据的持久性提高了约60%(从67秒写入缓存到27秒持久保存到工作区)，而在后续作业中恢复数据从35秒(使用缓存)下降到12秒(使用工作区)(大约65%的性能提升)。</p><h1 id="809f" class="lc ld hu bd le lf lg lh li lj lk ll lm ja ln jb lo jd lp je lq jg lr jh ls lt dt translated">奖金提高—修剪<code class="eh ky kz la lb b">node_modules</code></h1><p id="aade" class="pw-post-body-paragraph jj jk hu jl b jm lu iv jo jp lv iy jr js lw ju jv jw lx jy jz ka ly kc kd ke hn dt translated">到目前为止还不错，但是当我在做的时候，我挖得更深了一点。一段时间以来，我一直在关注我们的<code class="eh ky kz la lb b">node_modules</code>目录大小…🙀你检查过你的吗？如果是这样，我很肯定你会支持我。如果没有，继续检查你的，然后回到这里——我会等着。</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff lz"><img src="../Images/fd94759bda0f6faec7dede9a9c246bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i5S2tUk0CQBh1Euc."/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Heaviest objects in the universe — based on estimates</figcaption></figure><p id="a6ea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好了，现在所有的读者都明白我的意思了，让我们继续。在我们的例子中，<code class="eh ky kz la lb b">node_modules</code>的大小是553 MB。一定要这样吗？肯定不是！不需要有<code class="eh ky kz la lb b">*.md</code>文件、文档资产、测试、临时文件等。当我们在CircleCI上跨作业共享这些文件时，无论我们使用的是缓存还是工作空间，所有这些文件都必须被压缩和解压缩。</p><p id="930f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我知道有两个选项，所以我实现了这两个选项，并对它们进行了比较，以做出明智的选择。</p><h2 id="3b30" class="ma ld hu bd le mb mc md li me mf mg lm js mh mi lo jw mj mk lq ka ml mm ls mn dt translated"><code class="eh ky kz la lb b">node-prune</code></h2><p id="5cd9" class="pw-post-body-paragraph jj jk hu jl b jm lu iv jo jp lv iy jr js lw ju jv jw lx jy jz ka ly kc kd ke hn dt translated">TJ Holowaychuk为他的一个产品制作了这个，并在https://github.com/tj/node-prune开源。这是一个很小的Go命令，可以安装在一行中。在我们的例子中，安装和运行该命令需要3秒钟。该命令的输出如下所示:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff mo"><img src="../Images/21e31bcdada3795c66df3ef8ddf452fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rb_u6hrt56xMFxTdT_mnmA.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">node-prune doing its job on CircleCI</figcaption></figure><p id="b7f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从<code class="eh ky kz la lb b">node_modules</code>目录中删除了136 MB不必要的文件。在将数据从一个CircleCI作业传递到下一个作业时，需要压缩和解压缩的数据也减少了136 MB。</p><p id="a5c7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，将数据保存到工作区需要20秒，与使用缓存的原始实现相比，大约提高了70%。恢复这些数据只需7秒钟，比我们原来的速度快了80%。</p><h2 id="5a2c" class="ma ld hu bd le mb mc md li me mf mg lm js mh mi lo jw mj mk lq ka ml mm ls mn dt translated">纱线自动清洁</h2><p id="46ba" class="pw-post-body-paragraph jj jk hu jl b jm lu iv jo jp lv iy jr js lw ju jv jw lx jy jz ka ly kc kd ke hn dt translated">我不满足于只有一个选项可以修剪。只要有可能，拥有一些额外的数据点是一个好主意。</p><p id="31b3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在<a class="ae kf" href="https://yarnpkg.com/lang/en/docs/cli/autoclean/" rel="noopener ugc nofollow" target="_blank">https://yarnpkg.com/lang/en/docs/cli/autoclean/</a>找到了记录的<code class="eh ky kz la lb b">yarn autoclean</code>。作为<code class="eh ky kz la lb b">yarn install</code>命令的一部分，该命令清理<code class="eh ky kz la lb b">node_modules</code>。</p><p id="5d12" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">与<code class="eh ky kz la lb b">node-prune</code>相比，运行速度稍慢。<code class="eh ky kz la lb b">yarn install</code>多花了大约20秒(因为它运行了<code class="eh ky kz la lb b">autoclean</code>),这比<code class="eh ky kz la lb b">node-prune</code>安装和删除依赖项所需的时间多了17秒。将存储库保存到工作区需要23秒(比缓存快65%)，恢复工作区“只”快70%。</p><h1 id="a24a" class="lc ld hu bd le lf lg lh li lj lk ll lm ja ln jb lo jd lp je lq jg lr jh ls lt dt translated">结论</h1><p id="8f8b" class="pw-post-body-paragraph jj jk hu jl b jm lu iv jo jp lv iy jr js lw ju jv jw lx jy jz ka ly kc kd ke hn dt translated">这张表格摘自我在工作中打开的PR，它总结了结果:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/15befe478d89f5ada8f43272ad92ba70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*PGnEoVGk4Hs6miTq3kQWsA.png"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">CircleCI cache vs workspace</figcaption></figure><p id="221d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我现在完全放弃了缓存，主要是为了保持较小的PR和可管理性。我想看看缓存是否有助于加速多个工作流的运行。</p><p id="066a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的例子中，我们为CircleCI上的整个工作流程节省了2.6分钟。</p><p id="c624" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你有类似的结果，或者完全不同的经历，我很想听听你的看法。如果你觉得这很有趣，请留下评论或鼓掌(这些掌声鼓励你写下并分享更多😀).</p></div></div>    
</body>
</html>