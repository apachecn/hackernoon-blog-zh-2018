<html>
<head>
<title>First experiences with React Native: bridging an iOS native module for app authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native的初步体验:桥接iOS原生模块进行应用程序认证</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/first-experiences-with-react-native-bridging-an-ios-native-module-for-app-authentication-7a20b7180fc9?source=collection_archive---------1-----------------------#2018-05-10">https://medium.com/hackernoon/first-experiences-with-react-native-bridging-an-ios-native-module-for-app-authentication-7a20b7180fc9?source=collection_archive---------1-----------------------#2018-05-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/640780278ea9d233995a5e0d657ee54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKVYgYKmf6rILLCa5GW7Pg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/rlrV5RNpqDI?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Liu Zai Hou</a> on <a class="ae jg" href="https://unsplash.com/search/photos/bridging?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9a40" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的公司CriticalBlue提供名为<a class="ae jg" href="https://www.approov.io/" rel="noopener ugc nofollow" target="_blank">approv</a>的远程移动应用认证服务。Approov SDK作为嵌入式库提供给原生iOS和Android应用程序开发人员。</p><p id="0c6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随着我们的许多客户使用或试验React Native，我希望提供一个方便的Javascript模块，向React Native开发人员公开native Approov SDK功能。</p><p id="2857" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总的来说，创建我的第一个React原生模块非常简单。我最初的概念验证的所有代码都可以在<a class="ae jg" href="https://github.com/approov/rndemo" rel="noopener ugc nofollow" target="_blank"> github库</a>中找到。</p><p id="0ad4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个故事描述了对iOS原生模块的桥接。对于针对Android的相同示例，请参见【React Native的首次体验:桥接Android原生模块进行应用程序认证。</p><h1 id="fb61" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">反应本地桥</h1><p id="00d4" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">对于React Native，脸书提供了一个可靠的入门指南,介绍了基础知识，包括如何设置应用程序，以及底层UI组件与常见的React web元素有何不同。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/54a775df417a746fbe1a3118e2836c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3pavpyOh_BCxYVpnyGD6A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">from <a class="ae jg" href="https://www.reactnative.guide/3-react-native-internals/3.1-react-native-internals.html" rel="noopener ugc nofollow" target="_blank">React Made Native Easy</a></figcaption></figure><p id="43b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在架构上，每个React本机应用程序中都运行着两个重要的线程——一个是主UI线程，另一个运行Javascript VM。这两个线程通过一个桥进行交互，这个桥的通信是异步的、序列化的和批处理的，尽可能地将两个系统解耦。</p><p id="5313" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然React本机应用程序的大部分是在React中描述的，并在Javascript VM上运行，但用户界面是使用本机平台的用户界面元素呈现的，改变应用程序用户界面的操作作为消息通过桥从VM传递到应用程序的主用户界面线程。</p><p id="4b25" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为原生设备环境开发的系统功能和库可以使用React Native的原生模块接口向Javascript VM公开，并通过React Native桥访问。</p><h1 id="7b71" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Approov原生SDK</h1><p id="f2c1" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Approov SDK是一个嵌入式原生iOS或Android库。它与基于云的Approov认证服务进行交互，该服务验证应用程序是真实的、未经篡改的，并且不是机器人。从身份验证服务返回一个应用程序完整性令牌，该令牌随每个API调用一起发送，以确保后端API服务正在处理一个已知的真实前端请求。</p><p id="7567" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将在本机模块概念验证中公开的基本操作是<code class="eh ln lo lp lq b">fetchApproovToken()</code>，这是本机SDK中的一个异步操作。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lr"><img src="../Images/bf5ce807470c4aebec328fd6bca69997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djbl-cSEqRQW_B2z0bbs5Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Approov-protected API call</figcaption></figure><p id="ef2a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在每个需要应用程序身份验证的后端API调用之前，客户端应用程序都会发出一个获取令牌的请求。如果需要新令牌，SDK会发出远程证明请求，证明服务会对应用进行加密身份验证，并使用应用完整性令牌进行响应。</p><p id="7855" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">令牌的生命周期很短，并且由只有Approov服务和应用程序后端服务知道的秘密签名。应用程序中没有存储任何秘密，事实上，应用程序不知道返回的令牌是否有效。该应用程序只需将完整性令牌添加到后端API调用中，后端服务器在处理请求之前验证令牌是否已过期并正确签名。</p><h1 id="82a6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Approov演示服务</h1><p id="a2ea" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Approov提供了一个<a class="ae jg" href="https://approov.io/demo-reg.html" rel="noopener ugc nofollow" target="_blank">可下载演示</a>，它提供了演示iOS和Android SDKs以及一个具有两个端点的后端服务:</p><ul class=""><li id="5ad8" class="ls lt hu jj b jk jl jo jp js lu jw lv ka lw ke lx ly lz ma dt translated">https://demo-server.approovr.io/hello的<a class="ae jg" href="https://demo-server.approovr.io/hello" rel="noopener ugc nofollow" target="_blank"/>，提供一个公共可访问的测试点。</li><li id="06ef" class="ls lt hu jj b jk mb jo mc js md jw me ka mf ke lx ly lz ma dt translated">https://demo-server.approovr.io/shapes<a class="ae jg" href="https://demo-server.approovr.io/hello" rel="noopener ugc nofollow" target="_blank">，仅当请求包含有效的完整性令牌时才提供随机形状。</a></li></ul><p id="78fa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用iOS SDK和后端服务来演示一个使用Approov的简单React本机应用程序。对于此示例的Android版本，请参见【React Native的首次体验:桥接Android原生模块进行应用程序认证。</p><h1 id="819f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">打招呼</h1><p id="7f4d" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我使用create-react-native-app (CRNA)开始了我的React Native项目。按照<a class="ae jg" href="https://github.com/react-community/create-react-native-app" rel="noopener ugc nofollow" target="_blank"> CRNA安装说明</a>设置React本地环境，然后:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="0450" class="mk kg hu lq b fv ml mm l mn mo">$ create-react-native-app rndemo</span></pre><p id="cec9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将在应用程序中添加本机代码，所以现在就从create-react-native-app中退出:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="1fbb" class="mk kg hu lq b fv ml mm l mn mo">$ cd rndemo<br/>$ yarn eject<br/>...</span><span id="f695" class="mk kg hu lq b fv mp mm l mn mo">Ejecting is permanent! Please be careful with your selection.</span><span id="11e9" class="mk kg hu lq b fv mp mm l mn mo">? How would you like to eject from create-react-native-app? React Native: I’d like a regular React Native project.<br/>We have a couple of questions to ask you about how you’d like to name your app:<br/>? What should your app appear as on a user’s home screen? RN Demo<br/>? What should your Android Studio and Xcode projects be called? rndemo</span><span id="923b" class="mk kg hu lq b fv mp mm l mn mo">Wrote to app.json, please update it manually in the future.<br/>Generating the iOS folder.<br/>Generating the Android folder.<br/>...</span></pre><p id="3c81" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">选择一个常规的React原生项目，并随意命名。iOS和Android项目已经生成，您需要安装<a class="ae jg" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>和/或<a class="ae jg" href="https://developer.android.com/studio/" rel="noopener ugc nofollow" target="_blank"> Android Studio </a>构建环境。本地代码将在稍后添加到我们的本地iOS项目中。</p><p id="68b4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用一个非常简单的概念验证应用程序进行实验，该应用程序将使用演示服务器hello endpoint来验证我们的网络连接。</p><p id="0108" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React Native实现了用于联网的<a class="ae jg" href="https://facebook.github.io/react-native/docs/network.html" rel="noopener ugc nofollow" target="_blank">获取API </a>。我们将连接检查、UI呈现和样式化全部结合在<code class="eh ln lo lp lq b">App.js</code>文件中:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="89fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">顶层App组件注册在<code class="eh ln lo lp lq b">index.js</code>文件中。</p><p id="ccad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">主视图由无状态视图组件呈现，该组件显示图像选项和状态消息:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="fca3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些例子我使用的是iOS，但这在Android上同样适用。启动一个iOS模拟器(为此，您可能需要启动Xcode)。在<code class="eh ln lo lp lq b">rndemo</code>目录下，启动app:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="7cde" class="mk kg hu lq b fv ml mm l mn mo">$ cd rndemo<br/>$ yarn run ios</span></pre><p id="2ccc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您应该会看到这样的屏幕:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/9834322b741eec91186fa5fa735b7088.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*iG2MSM-JjU2sy7Rf8sTAlQ.png"/></div></figure><p id="332d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">按下<code class="eh ln lo lp lq b">Test Hello</code>按钮，如果一切正常，您应该会看到一条连接信息:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/f492e4cddeb0b08afe6c38b022ee7e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*roLOFhH34kSvY4jYzT6plQ.png"/></div></figure><p id="e625" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这验证了React本地应用程序和演示服务器之间的网络通信。</p><p id="6fc0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">若要在实际的iPhone上运行，请将iPhone连接到Mac。在Xcode中，打开React Native iOS项目，选择iPhone作为目标并运行应用程序。</p><p id="2a34" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要测试无连接，如果在模拟器上运行，禁用Mac的WiFi或网络并按下<code class="eh ln lo lp lq b">Test Hello</code>按钮。如果在手机上运行，设置飞行模式，然后按下<code class="eh ln lo lp lq b">Test Hello</code>按钮。</p><h1 id="3ffa" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Approov本机模块</h1><p id="1a45" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">approv演示包包括一个自述文件、iOS和Android Approov演示库、示例客户端和应用程序注册工具。下载<a class="ae jg" href="https://approov.io/demo-reg.html" rel="noopener ugc nofollow" target="_blank">演示包</a>，保存下载邮件中包含的应用注册令牌。</p><p id="df1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Approov SDK包含了我们想要公开的本机代码，以实现React Native。它必须包含在我们弹出create-react-native-app时生成的iOS或Android原生项目中。对于iOS，这个项目位于<code class="eh ln lo lp lq b">rndemo/ios</code>。按照<a class="ae jg" href="https://approov.io/docs" rel="noopener ugc nofollow" target="_blank">approv文档</a>中的这些<a class="ae jg" href="https://approov.io/docs/iosframeworkreference.html#adding-the-framework-to-an-app" rel="noopener ugc nofollow" target="_blank">指令</a>将Approov SDK框架添加到iOS项目中。</p><p id="4437" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">iOS Approov SDK目前不支持位代码，所以您应该在Xcode项目设置中将<code class="eh ln lo lp lq b">Build Settings -&gt; Build Options -&gt; Enable Bitcode</code>设置为<code class="eh ln lo lp lq b">No</code>。</p><p id="6d11" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在iOS中，原生模块是实现<code class="eh ln lo lp lq b">RCTBridgeModule</code>协议的Objective-C类。我们的示例将混合Objective-C和Swift来注册和实现到本机代码的桥梁。</p><p id="16f8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们首先在Swift中用一个<code class="eh ln lo lp lq b">fetchApproovToken()</code>调用创建<code class="eh ln lo lp lq b">Approov</code>桥类，该调用包装异步本地<code class="eh ln lo lp lq b">fetchApproovToken()</code>调用，并在令牌获取完成时完成一个承诺。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="1b27" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh ln lo lp lq b">fetchApproovToken()</code>呼叫中，通过呼叫解决<code class="eh ln lo lp lq b">RCTPromiseResolveBlock</code>或拒绝<code class="eh ln lo lp lq b">RCTPromiseRejectBlock</code>来解决承诺。如果成功，我们的实现简单地使用提取的令牌进行解析，如果失败，则使用<code class="eh ln lo lp lq b">NO_TOKEN</code> sentinel。两个闭包块都标有<code class="eh ln lo lp lq b">@escaping</code>属性，表示它们可以在<code class="eh ln lo lp lq b">fetchApproovToken()</code>调用完成后完成。<code class="eh ln lo lp lq b">@objc</code>修饰符用于将类和函数导出到Objective-C运行时。</p><p id="540a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Objective-C实现将Objective-C公开的Swift类连接到React本机桥。<code class="eh ln lo lp lq b">RCT_EXTERN_MODULE()</code>宏注册<code class="eh ln lo lp lq b">Approov</code>类，<code class="eh ln lo lp lq b">RCT_EXTERN_METHOD()</code>宏公开<code class="eh ln lo lp lq b">fetchApproovToken()</code>调用。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="2fa9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每当您在同一个项目中混合使用Swift和Objective-C时，您都需要一个桥接头来向Swift公开Objective-C文件。它必须包括React本机桥头。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="4d50" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Javascript方面，Approov原生模块现在将包含在从<code class="eh ln lo lp lq b">react-native</code>导入的<code class="eh ln lo lp lq b">NativeModules</code>中。在我们的实现中，<code class="eh ln lo lp lq b">Approov.fetchApproovToken()</code>返回一个普通的javascript承诺:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="c13c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当混合使用Swift和Objective-C时，桥接本地和Javascript环境有点令人困惑，但最终它只需要少量代码。</p><h1 id="5c3e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">截击机</h1><p id="491e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">许多网络库，比如Axios和T21，都包含了拦截器的概念。拦截器可以用来拦截网络请求和响应，并注入一些额外的处理。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/f95b911fe6dd83117f23fae1e7b31559.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*mO-GLi118Zrnvm_GYX1dlA.png"/></div></figure><p id="31d2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当使用Android SDK本地实现时，大多数客户使用拦截器来获取Approov令牌并将其添加到每个API请求的头中，因此我们希望在生产模块中完全实现这一抽象。对于这个简单的例子，我们将在一个<code class="eh ln lo lp lq b">fetchWithToken()</code>调用中硬连接拦截。</p><p id="b672" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh ln lo lp lq b">fetchWithToken()</code>方法中，当本地获取令牌调用完成时，如果承诺被解析，我们将令牌添加到输入请求头中，并使用增强的输入请求进行<code class="eh ln lo lp lq b">fetch()</code>调用。完成后，fetch返回一个包含API服务器响应的解析承诺。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="53f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了方便起见，我们从<code class="eh ln lo lp lq b">NativeModules.Approov</code>对象创建了一个<code class="eh ln lo lp lq b">Approov</code>对象，添加了一个<code class="eh ln lo lp lq b">fetch()</code>方法，实际上是<code class="eh ln lo lp lq b">fetchWithToken()</code>方法，然后我们将其导出为<code class="eh ln lo lp lq b">Approov</code>模块。</p><h1 id="5ccc" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">获取形状</h1><p id="1602" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在我们准备使用<code class="eh ln lo lp lq b">Approov</code>对象进行认证。我们在我们的<code class="eh ln lo lp lq b">App</code>中添加了一个<code class="eh ln lo lp lq b">getShape()</code>方法，该方法调用<code class="eh ln lo lp lq b">Approov.fetch(request)</code>来验证和请求一个随机的形状值。一旦获取完成，<code class="eh ln lo lp lq b">App</code>组件状态更新，触发<code class="eh ln lo lp lq b">render()</code>调用，导致<code class="eh ln lo lp lq b">ShapeView</code>显示更新的形状和状态信息。</p><p id="5c4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">按钮栏中添加了一个<code class="eh ln lo lp lq b">Get Shapes</code>按钮，用于请求新的形状。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="a874" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一切看起来都很好，但是当我们请求一个新的形状时，我们看到一个带有400状态代码的失败，表明客户端请求有问题。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/48c4a7c8ab14429366177bc6755c1b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*eNOdDUXjhPeGK4Pp8ANgbw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Failure to fetch a shape</figcaption></figure><p id="f80b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">调用失败，因为Approov添加的完整性令牌无效。在我们的示例应用程序正确注册到Approov服务之前，<code class="eh ln lo lp lq b">fetchWithToken()</code>调用将始终无法通过身份验证检查。</p><p id="6276" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">演示下载中包含命令行注册工具。要注册应用程序，请发出注册请求，指定应用程序的IPA归档和您从演示下载电子邮件中保存的应用程序注册令牌。您可以从Xcode中的<code class="eh ln lo lp lq b">rndemo.app</code>产品生成IPA归档文件。出于对其他演示用户的礼貌，请使用<code class="eh ln lo lp lq b">-e</code>标志将您的注册设置为几小时后到期:</p><pre class="lj lk ll lm fq mg lq mh mi aw mj dt"><span id="a777" class="mk kg hu lq b fv ml mm l mn mo">$ cd &lt;&lt;approov-demo-package&gt;&gt;/registration-tools/Android/Mac/<br/>$ ./registration <br/>   -a &lt;&lt;your-rndemo.ipa&gt;&gt;<br/>   -t &lt;registration-token&gt;<br/>   -e 2h</span><span id="6efb" class="mk kg hu lq b fv mp mm l mn mo">Submitting data…<br/>Success: new app signature added to database.</span></pre><p id="8611" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦应用程序被注册并被正确认证，按下<code class="eh ln lo lp lq b">Get Shapes</code>按钮将返回以下图形之一:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/bf3f58a0a00deae5d2d1b545254890c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obgDakUEXFnqp8RH_PWOmA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Successfully fetching random shapes</figcaption></figure><h1 id="3bf6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">中间的人攻击</h1><p id="0070" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在API调用期间，通信通道的安全性非常重要。如果通道不安全，API调用可能会被拦截和修改。尽管完整性令牌的生命周期很短，但它可能会在不安全的通道中被观察到，并被用来进行恶意的API调用而不受惩罚。</p><p id="3897" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管在发出API请求时使用HTTPS/TLS，但同时控制网络和移动设备的攻击者可以很容易地设置<a class="ae jg" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人(MitM)攻击</a>来窃取并快速重用过期的Approov令牌。</p><p id="745d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了对抗MitM攻击，移动客户端应使用<a class="ae jg" href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank">证书或公钥“锁定”</a>，检查后端服务提供的证书或公钥是否为客户端应用程序所知。其他证书虽然看起来可信，但会被客户端拒绝，并且不会进行API调用。</p><p id="5274" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在React Native中实现锁定有点复杂，将在另一篇文章中描述，并集成到这个示例的代码库中。</p><h1 id="1d7c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">更进一步</h1><p id="275e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们已经在React Native中演示了一个本机模块实现，其中一个硬连线的拦截器成功地提供了应用程序验证和API保护。</p><p id="2511" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React Native的产品质量本机模块实现将概括拦截器功能，添加方便的配置方法，并提供完整的MitM保护。相比之下，类似的<a class="ae jg" href="https://github.com/approov/cordova-plugin-approov-http" rel="noopener ugc nofollow" target="_blank">approv插件库</a>已经存在于<a class="ae jg" href="https://cordova.apache.org/" rel="noopener ugc nofollow" target="_blank"> Cordova </a>和<a class="ae jg" href="https://ionicframework.com/framework" rel="noopener ugc nofollow" target="_blank"> Ionic </a>混合应用中。</p><p id="e412" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本例的所有代码都位于<a class="ae jg" href="https://github.com/approov/rndemo" rel="noopener ugc nofollow" target="_blank"> github </a>上。</p></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="3df0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢阅读！有关移动API安全性的更多信息，请查看。</p><p id="cc4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你推荐这篇文章(点击👏按钮)以便其他人可以找到它。</p></div></div>    
</body>
</html>