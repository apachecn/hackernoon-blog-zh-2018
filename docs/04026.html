<html>
<head>
<title>Interface Segregation Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">界面分离原理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/interface-segregation-principle-bdf3f94f1d11?source=collection_archive---------2-----------------------#2018-05-11">https://medium.com/hackernoon/interface-segregation-principle-bdf3f94f1d11?source=collection_archive---------2-----------------------#2018-05-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a9ed" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">以及如何解读</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/26ef161bdd68828759333cef7be68bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6wTeJdunvYQdcjD_AfZ4Q.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">I wish all of my interfaces were segregated as good as this fish at Catania fish market</figcaption></figure><p id="9fab" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是第四篇关于坚实原则的文章。检查前一个，<a class="ae kv" href="https://hackernoon.com/liskov-substitution-principle-a982551d584a" rel="noopener ugc nofollow" target="_blank">里斯科夫替代原则</a>，如果你错过了它。</p><h2 id="913a" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">定义</h2><p id="7e75" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">根据罗伯特·马丁的说法，</p><blockquote class="lw lx ly"><p id="e8eb" class="jz ka lz kb b kc kd iv ke kf kg iy kh ma kj kk kl mb kn ko kp mc kr ks kt ku hn dt translated"><strong class="kb hv">接口分离原则</strong> ( <strong class="kb hv"> ISP </strong>)声明，任何客户端都不应该被迫依赖它不使用的方法。</p></blockquote><p id="9b64" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">此外，<a class="ae kv" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank"> Wikipedia </a>有一个简明的实践描述，引导你到一个你的代码符合ISP的情况:</p><blockquote class="lw lx ly"><p id="02ab" class="jz ka lz kb b kc kd iv ke kf kg iy kh ma kj kk kl mb kn ko kp mc kr ks kt ku hn dt translated">ISP将非常大的接口分成更小、更具体的接口，这样客户只需知道他们感兴趣的方法。这种收缩的接口也称为角色接口。</p></blockquote><p id="3cb4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我相信这个原则背后有一个很深的基础，就像Kent Beck的XP价值观是他的XP原则的基础一样。</p><h2 id="4961" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">正确的抽象是接口分离原则的关键</h2><p id="5a26" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">Wiki的定义只说明了你的抽象应该是正确的，因此实现它们的类最终应该是小的、内聚的、可靠的。</p><p id="ee87" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">找到正确的抽象更像是一门艺术。毫无疑问，你应该探索你的领域，可能建立一些语义网络，提出一组用户故事，绘制交互图——所有这些不一定会引导你找到正确的抽象。错误的抽象比根本没有抽象更糟糕，所以不要忘记三条规则。</p><p id="d200" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当你认为你已经完成了一些抽象的时候，把它们表现为接口。上面提到的技术加强了它们成为<a class="ae kv" href="https://martinfowler.com/bliki/RoleInterface.html" rel="noopener ugc nofollow" target="_blank">角色接口</a>。使用这种方法，具体的类只实现那些抽象所要求的。所以我们最终满足了界面分离原则，即使我们不知道它的存在。</p><h2 id="f0aa" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">违反界面分离原则</h2><p id="eb40" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">当客户端依赖于它不使用的方法时，这意味着你的抽象是错误的。马丁·福勒的<a class="ae kv" href="https://martinfowler.com/bliki/RoleInterface.html" rel="noopener ugc nofollow" target="_blank">角色接口</a>的例子(这是应用ISP的自然结果)恰恰暴露了错误的初始对象分解。这并不需要一个独立的原则。这段代码显然不够连贯。所以不要考虑你的代码是否违反了接口分离原则，想想你的抽象是否正确。</p><h2 id="828c" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">代码示例？</h2><p id="2d0b" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">没有，在里面没多大意义。给出一些随机的代码不会告诉你太多领域抽象和他们遵循的契约。不管怎样，互联网上有很多例子，一些类不得不实现一些胖接口的行为，而这是不应该的。</p><h2 id="ec9f" class="kw kx hu bd ky kz la lb lc ld le lf lg ki lh li lj km lk ll lm kq ln lo lp lq dt translated">最后的话</h2><p id="c2e1" class="pw-post-body-paragraph jz ka hu kb b kc lr iv ke kf ls iy kh ki lt kk kl km lu ko kp kq lv ks kt ku hn dt translated">当你开始<a class="ae kv" href="https://hackernoon.com/how-to-avoid-anemic-domain-model-5e1c3e6fe4d0" rel="noopener ugc nofollow" target="_blank">分解你的问题空间</a>并确定参与你领域的主要角色时，这个原则就自然而然地出现了。而且从来都不是机械动作。没有一个原则能自动引导你找到正确的对象模型。</p><p id="19fe" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所以ISP在设计软件的时候是一个很差的指导，但却是一个很好的健康与否的指标。设计软件的时候不要考虑ISP。考虑你的抽象是否是可重用的和可组合的，你的对象是否是封装的和内聚的。</p></div></div>    
</body>
</html>