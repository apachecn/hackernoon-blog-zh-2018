<html>
<head>
<title>Unit Testing: A Simplistic and Language-Agnostic Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试:一种简单化和语言无关的方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/unit-testing-a-simplistic-and-language-agnostic-approach-918edff86d11?source=collection_archive---------10-----------------------#2018-05-11">https://medium.com/hackernoon/unit-testing-a-simplistic-and-language-agnostic-approach-918edff86d11?source=collection_archive---------10-----------------------#2018-05-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/f1a8f38d24b54b53c5b816a135e5525e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*dyINNe_2rzyagt0e7scQ3w.gif"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">“No problem thumbs up” via <a class="ae jc" href="https://giphy.com/gifs/rad-sooziq-capture-5xrkJe3IJKSze" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="3ba5" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如今，单元测试是软件工程师的必备技能。但是，他们中的许多人不知道这一点，并认为这是来自另一个世界的东西。</p><p id="85df" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">事实是:</p><blockquote class="kb"><p id="b51f" class="kc kd hu bd ke kf kg kh ki kj kk ka ek translated">单元测试只是为了确保其他代码行按预期工作而编写的一些代码行。</p></blockquote><p id="cfc9" class="pw-post-body-paragraph jd je hu jf b jg kl ji jj jk km jm jn jo kn jq jr js ko ju jv jw kp jy jz ka hn dt translated">这些经过测试的代码行是您的应用程序的特性。就是这样，没有任何魔法。</p><p id="ccb8" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我不想吓到任何人。所以，我不会使用库、标准、类和关键字。我将尝试用一种简单的方式来解释单元测试。使用纯代码，不导入任何类或库。这些例子是用Python写的。</p><h1 id="1974" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">动机</h1><p id="cda4" class="pw-post-body-paragraph jd je hu jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hn dt translated">为什么我们必须做单元测试？单元测试是避免或警告您问题的最简单的方法。比如当一些代码改变破坏了应用程序的另一个功能时。</p><p id="518e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">让我们看一个代码的例子:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="ef77" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">正如我们所料，函数<strong class="jf hv"> get_company_as_string </strong>工作正常。以下是一些价值和相应回报的示例:</p><pre class="lt lu lv lw fq lz ma mb mc aw md dt"><span id="2029" class="me kr hu ma b fv mf mg l mh mi">In [1]: get_company_as_string('Samsung')<br/>Out[1]: 'Name: Samsung | Founders: Lee Byung-chul.'</span><span id="0c03" class="me kr hu ma b fv mj mg l mh mi">In [2]: get_company_as_string('Apple Inc.')<br/>Out[2]: 'Name: Apple Inc. | Founders: Steve Jobs, Steve Wozniak and Ronald Wayne.'</span><span id="b7e0" class="me kr hu ma b fv mj mg l mh mi">In [3]: get_company_as_string('Microsoft')<br/>Out[3]: 'Name: Microsoft | Founders: Bill Gates, Paul Allen.'</span><span id="e113" class="me kr hu ma b fv mj mg l mh mi">In [4]: get_company_as_string('XPTO')</span><span id="4a5a" class="me kr hu ma b fv mj mg l mh mi">In [5]:</span></pre><p id="d76e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">但是，如果，我们需要创建一个函数，返回公司基金会创始人的年龄总和？所以，我们需要调整数据结构，使创始人名单保持他们的年龄。</p><p id="1c7a" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">之后，我们有下面的代码。这是前面代码的基础，对founders结构进行了修改，并增加了一个新功能:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="d449" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">并且，当我们运行我们的新函数时，我们得到这样的结果:</p><pre class="lt lu lv lw fq lz ma mb mc aw md dt"><span id="8289" class="me kr hu ma b fv mf mg l mh mi">In [1]: get_sum_ages_of_company_founders('Samsung')<br/>Out[1]: 26</span><span id="ad4f" class="me kr hu ma b fv mj mg l mh mi">In [2]: get_sum_ages_of_company_founders('Apple Inc.')<br/>Out[3]: 87</span><span id="1206" class="me kr hu ma b fv mj mg l mh mi">In [3]: get_sum_ages_of_company_founders('Microsoft')<br/>Out[3]: 41</span><span id="d65d" class="me kr hu ma b fv mj mg l mh mi">In [4]: get_sum_ages_of_company_founders('XPTO')</span><span id="4be5" class="me kr hu ma b fv mj mg l mh mi">In [5]:</span></pre><p id="a0d6" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">因此，新特性的实现是成功的，我们可以部署新版本的应用程序了。是吗？不不不。</p><p id="3a92" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">让我们执行函数<strong class="jf hv"> get_company_as_string </strong>。请注意，我们没有更改该函数，并且我们已经验证了它工作正常。让我们看看它是否会继续发展:</p><pre class="lt lu lv lw fq lz ma mb mc aw md dt"><span id="acd8" class="me kr hu ma b fv mf mg l mh mi">In [6]: get_company_as_string('Apple Inc.')<br/>Out[6]: "Name: Apple Inc. | Founders: [{'name': 'Steve Jobs', 'age': 21}, {'name': 'Steve Wozniak', 'age': 25}, {'name': 'Ronald Wayne', 'age': 41}]."</span></pre><p id="8063" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">惊喜！结果是不一样的，函数不再像我们预期的那样工作。</p><p id="ca0b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">是的，这是一个简单的例子，但是，想象一下，如果我们的应用程序有超过100或1000个函数。我们如何确保所有功能都按照我们的预期运行？或者在出现问题时收到警报？</p><p id="c2d4" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">你知道答案:单元测试！</p><h1 id="62de" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">断言/期望</h1><p id="2104" class="pw-post-body-paragraph jd je hu jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hn dt translated">这是单元测试的基础，也可能是最简单的东西。这是一个关于函数的小对话。我们告诉函数一些东西，并验证响应是否是它应该的。</p><p id="7fbd" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">例如，我们如何测试两个数相加的函数？给这个函数两个数字。将收益与这两个数字的和进行比较，这是我们已经知道的。如果函数是错误的，比较将会失败。</p><p id="4768" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我们知道2 + 2是4，-3+-2是-5，-1+3是2。因此，如果我们向函数发送2和2，我们期望接收4。如果我们发送-3和-2，我们期望接收-5，如果我们发送-1和3，我们期望接收2。如果其中一个与我们预期的不同，那么这个函数就是错误的。很简单吧？</p><p id="25da" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">让我们看看单元测试在之前的重构中是如何帮助我们的。记住:我没有使用任何特定的库或类。我想简化解释并保持不可知论。</p><p id="62b5" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">在旧版本的应用程序代码中，函数<strong class="jf hv"> get_company_as_string </strong>工作正常。在这一点上，我们知道一些东西:</p><ul class=""><li id="b318" class="mk ml hu jf b jg jh jk jl jo mm js mn jw mo ka mp mq mr ms dt translated">如果我们告诉<em class="mt">“苹果公司”</em>这个函数，我们期望得到<em class="mt">“姓名:苹果公司|创始人:史蒂夫·乔布斯、史蒂夫·沃兹尼亚克和罗纳德·韦恩。”，以及</em></li><li id="65be" class="mk ml hu jf b jg mu jk mv jo mw js mx jw my ka mp mq mr ms dt translated">如果我们告诉<em class="mt">‘XPTO’</em>，我们期望收到<em class="mt"> None </em>。</li></ul><p id="0445" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">所以，用编码的方式:</p><ul class=""><li id="1a4d" class="mk ml hu jf b jg jh jk jl jo mm js mn jw mo ka mp mq mr ms dt translated"><strong class="jf hv"> get_company_as_string('苹果公司')<em class="mt"> </em> </strong> <em class="mt">应该等于</em> <strong class="jf hv">'名称:苹果公司|创始人:史蒂夫·乔布斯、史蒂夫·沃兹尼亚克、罗纳德·韦恩。'</strong> <em class="mt">和</em></li><li id="074a" class="mk ml hu jf b jg mu jk mv jo mw js mx jw my ka mp mq mr ms dt translated"><strong class="jf hv">get _ company _ as _ string(' XPTO ')</strong>应该等于<strong class="jf hv"> None </strong>。</li></ul><p id="371f" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">代码如下:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Minimalist test example without classes and libraries</figcaption></figure><p id="bed7" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">…以及测试的执行:</p><pre class="lt lu lv lw fq lz ma mb mc aw md dt"><span id="d0e7" class="me kr hu ma b fv mf mg l mh mi">In [1]: <br/>   ...: if get_company_as_string('Apple Inc.') == 'Name: Apple Inc. | Founders: Steve Jobs, Steve Wozniak<br/>   ...:  and Ronald Wayne.':<br/>   ...:     print('Success on test #1.')<br/>   ...: else:<br/>   ...:     print('Error on test #1.')<br/>   ...: <br/>   ...: if get_company_as_string('XPTO') is None:<br/>   ...:     print('Success on test #2.')<br/>   ...: else:<br/>   ...:     print('Error on test #2.')<br/>   ...:     <br/>Success on test #1.<br/>Success on test #2.</span></pre><p id="8eae" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">现在，我们有了确保函数正常运行的代码。因此，我们可以在实现新功能后测试功能。</p><pre class="lt lu lv lw fq lz ma mb mc aw md dt"><span id="1b78" class="me kr hu ma b fv mf mg l mh mi">In [1]: <br/>    ...: if get_company_as_string('Apple Inc.') == 'Name: Apple Inc. | Founders: Steve Jobs, Steve Woznia<br/>    ...: k and Ronald Wayne.':<br/>    ...:     print('Success on test #1.')<br/>    ...: else:<br/>    ...:     print('Error on test #1.')<br/>    ...: <br/>    ...: if get_company_as_string('XPTO') is None:<br/>    ...:     print('Success on test #2.')<br/>    ...: else:<br/>    ...:     print('Error on test #2.')<br/>    ...:     <br/>Error on test #1.<br/>Success on test #2.</span></pre><p id="b55b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我们出错了。或者这会是一个成功吗？我们在实现新功能时所做的更改破坏了函数<strong class="jf hv"> get_company_as_string。但是，我们的测试可以识别这个问题，现在，我们可以解决这个问题。</strong></p><p id="1b21" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">因此，只需对功能稍作修改，我们就可以验证所有测试都已通过，并确保我们软件的质量:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Function get_company_as_string refactored to work after changes in data structure of companies founders.</figcaption></figure></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="be43" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这是一种简单的单元测试方法。在这篇文章中，我试图解释这种技能的巨大重要性，并帮助那些不知道如何开始软件测试的人。</p><p id="8df2" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">通过单元测试，你可以提高软件的质量。防止对现有代码的维护产生不必要的副作用是非常有用的。单元测试可以防止很多问题，比如软件崩溃和调试时间的浪费。并且帮助你和你的队友维护一个高质量的软件。所有这一切，不费吹灰之力。</p><p id="66a2" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我打算在这篇文章中谈一点TDD和Mock，但是，这篇文章已经太大了。所以，这将是另一篇文章。</p><p id="2202" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如果你觉得这篇文章有帮助，给我一些掌声👏。</p></div></div>    
</body>
</html>