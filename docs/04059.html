<html>
<head>
<title>A Practical Introduction to Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker编写实用介绍</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/practical-introduction-to-docker-compose-d34e79c4c2b6?source=collection_archive---------1-----------------------#2018-05-13">https://medium.com/hackernoon/practical-introduction-to-docker-compose-d34e79c4c2b6?source=collection_archive---------1-----------------------#2018-05-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0b067d081efd6cad8156e7f05b65f91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JK4VDnsrF6YnAb2nyhMsdQ.png"/></div></div></figure><h1 id="9071" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="3a3d" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Docker containers为技术社区打开了一个可能性的世界，设置新软件的麻烦减少了，不像过去那样需要通过一种令人悲伤的格式来整理混乱的局面，它减少了设置和使用新软件的时间，这最终为技术人员学习新东西、在容器中推出新软件并在完成后将其废弃发挥了重要作用。事情变得容易了，最好的事情是它的开源，任何人都可以使用它，尽管需要一点学习曲线。</p><p id="47ab" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在无数的可能性中，有一种可能性是为我们的应用程序实现复杂的技术堆栈，这在以前是专家的领域。今天，在容器的帮助下，对底层系统有良好理解的软件工程师可以实现一个复杂的堆栈，为什么不呢？这是当前的需要，比喻“万金油”得到了一个奇特的升级；根据时代的需要“掌握一些”。简单说就是“T”形技能。</p><p id="5971" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在一个文件中定义一个复杂的堆栈并用一个命令运行它的可能性，很诱人吧。Docker公司的人选择称之为Docker compose。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ld"><img src="../Images/d82c33c3c6fe76bce084ef1d5f6ea1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1g8v7eeFV2OWt1Tkmoc-4A.jpeg"/></div></div></figure><p id="c772" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在本文中，我们将使用Docker的示例投票应用程序，并使用Docker compose部署它。</p></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="5090" class="jc jd hu bd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz dt translated">Docker撰写</h1><p id="f239" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">用Docker公司的话说。</p><blockquote class="lu lv lw"><p id="61b7" class="ka kb lx kc b kd ky kf kg kh kz kj kk ly la kn ko lz lb kr ks ma lc kv kw kx hn dt translated">Compose是一个定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。</p></blockquote></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="ab57" class="jc jd hu bd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz dt translated">投票应用程序</h1><p id="1aa6" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">介绍Docker社区最喜欢的演示应用程序“投票应用程序”，好像它根本不需要介绍。这是一个基于微服务架构的简单应用程序，由5个简单的服务组成。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/7b8109097462a193902e76a48aee4e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIZdPFJO4EQbPNq0pR_b8g.png"/></div></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Voting app architecture [<a class="ae mg" href="https://github.com/docker/example-voting-app" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/example-voting-app</a>]</figcaption></figure><ol class=""><li id="6f4a" class="mh mi hu kc b kd ky kh kz kl mj kp mk kt ml kx mm mn mo mp dt translated"><strong class="kc hv"> Voting-App </strong>:用Python编写的应用程序前端，供用户投票使用。</li><li id="cefe" class="mh mi hu kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp dt translated"><strong class="kc hv"> Redis </strong>:内存数据库，用作中间存储。</li><li id="20bb" class="mh mi hu kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp dt translated"><strong class="kc hv">工人</strong>:。Net服务，用于从Redis获取选票并存储在Postres数据库中。</li><li id="5434" class="mh mi hu kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp dt translated"><strong class="kc hv"> DB </strong> : PostgreSQL数据库，用作数据库。</li><li id="f6d2" class="mh mi hu kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp dt translated"><strong class="kc hv">Result-App</strong>:node . js编写的应用程序前端，显示投票结果。</li></ol><p id="e66a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">投票报告有一个名为<code class="eh mv mw mx my b">docker-compose.yml</code>的文件。该文件包含用于创建容器、公开端口、绑定卷和通过网络连接容器的配置，投票应用程序需要这些配置才能工作。听起来像很多很长的<code class="eh mv mw mx my b">docker run</code>和<code class="eh mv mw mx my b">docker network create</code>命令，否则，docker compose允许我们将所有这些东西放在一个docker-compose文件中，格式为<a class="ae mg" href="http://yaml.org/start.html" rel="noopener ugc nofollow" target="_blank"> yaml </a>。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="1752" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">Git <code class="eh mv mw mx my b">clone</code>和<code class="eh mv mw mx my b">cd</code>进入投票app repo。</p><div class="nb nc fm fo nd ne"><a href="https://github.com/dockersamples/example-voting-app" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab ej"><div class="ng ab nh cl cj ni"><h2 class="bd hv fv z el nj eo ep nk er et ht dt translated">docker samples/示例投票应用程序</h2><div class="nl l"><h3 class="bd b fv z el nj eo ep nk er et ek translated">示例-投票-应用-示例Docker编写应用</h3></div><div class="nm l"><p class="bd b gc z el nj eo ep nk er et ek translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ja ne"/></div></div></a></div></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="17e4" class="jc jd hu bd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz dt translated">作曲时间</h1><p id="5292" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">由于我们所有的应用程序都定义在一个单独的compose文件中，我们可以松一口气，放松下来，简单地运行应用程序。compose的美妙之处在于，一个简单的命令就可以创建所有的服务，连接网络(字面意思)，装载所有的卷并公开端口。是时候欢迎<code class="eh mv mw mx my b">up</code>命令了，它执行所有前述的任务。</p><pre class="le lf lg lh fq nt my nu nv aw nw dt"><span id="1eb2" class="nx jd hu my b fv ny nz l oa ob">$ docker-compose up </span></pre><p id="6921" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在大量的“拉取完成”之后，几百兆字节和几分钟(也许更多)。。。</p><p id="4296" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">瞧，我们有了投票应用程序并开始运行。</p><p id="2b66" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">命令<code class="eh mv mw mx my b">docker ps</code>列出了所有正在运行的容器</p><pre class="le lf lg lh fq nt my nu nv aw nw dt"><span id="8bd6" class="nx jd hu my b fv ny nz l oa ob">$ docker ps -a --format="table {{.Names}}\t{{.Image}}\t{{.Ports}}" <br/>NAMES               IMAGE               PORTS<br/>voting_worker_1     voting_worker      <br/>db                  postgres:9.4        5432/tcp<br/>voting_vote_1       voting_vote         0.0.0.0:5000-&gt;80/tcp<br/>voting_result_1     voting_result       0.0.0.0:5858-&gt;5858/tcp, 0.0.0.0:5001-&gt;80/tcp<br/>redis               redis:alpine        0.0.0.0:32768-&gt;6379/tcp</span></pre><p id="226f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">上面的命令显示所有正在运行的容器、各自的映像和公开的端口号。</p><p id="d330" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">投票应用程序可在<a class="ae mg" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>上访问</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oc"><img src="../Images/b4b6a182488a2bcc5056dbd2fc380fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2OBAYVFG35tX6dHI08TWPg.png"/></div></div></figure><p id="0cb0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">同样，投票结果应用程序可以在<a class="ae mg" href="http://localhost:5001" rel="noopener ugc nofollow" target="_blank"> http://localhost:5001 </a>上访问</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oc"><img src="../Images/2e46e7b63f6b32cdfaffd01e179d091e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-WleHhSji49ZLIafS8xgQ.png"/></div></div></figure><p id="2197" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">投票应用程序上的每一张选票首先存储在Redis内存数据库中。Net worker服务获取投票并将其存储在Postgres数据库中，该数据库由Node.js前端访问。</p></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="72d7" class="jc jd hu bd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz dt translated">合成特征</h1><p id="96d6" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Compose提供了使用项目名称将环境相互隔离的灵活性，项目名称是包含项目的目录的基本名称。在我们的投票应用程序中，这由容器的名称<code class="eh mv mw mx my b">voting_worker_1</code>表示，其中<code class="eh mv mw mx my b">voting</code>是目录的基本名称。我们可以使用<code class="eh mv mw mx my b">-p</code>标志后跟自定义名称来设置自定义项目名称。</p><p id="a051" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">Compose保留了compose文件中定义的服务使用的所有卷，因此当使用<code class="eh mv mw mx my b">docker-compose up</code>重新创建容器时，不会丢失任何数据。另一个很酷的特性是只重新创建已经改变的容器，状态没有改变的容器保持不变。</p><p id="c2d4" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">另一个很酷的特性是支持组合文件中的变量，我们可以在一个<code class="eh mv mw mx my b">.env</code>文件中定义变量，并在docker-compose文件中使用它们。这里的<code class="eh mv mw mx my b">POSTGRES_VERSION=9.4</code>可以在环境文件中定义，也可以在shell中定义。它在合成文件中的使用方式如下:</p><pre class="le lf lg lh fq nt my nu nv aw nw dt"><span id="5365" class="nx jd hu my b fv ny nz l oa ob">db:<br/>  image: "postgres:${POSTGRES_VERSION}"</span></pre></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="32c1" class="jc jd hu bd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz dt translated">命令备忘单</h1><p id="6b17" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">使用compose可以轻松启动、停止和弹奏。</p><pre class="le lf lg lh fq nt my nu nv aw nw dt"><span id="5246" class="nx jd hu my b fv ny nz l oa ob">$ docker-compose up -d<br/>$ docker-compose down<br/>$ docker-compose start<br/>$ docker-compose stop<br/>$ docker-compose build<br/>$ docker-compose logs -f db<br/>$ docker-compose scale db=4<br/>$ docker-compose events<br/>$ docker-compose exec db bash</span></pre></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="e146" class="jc jd hu bd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv lt jx jy jz dt translated">摘要</h1><p id="5270" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Docker Compose是一个快速部署和废弃容器的伟大工具，Compose文件可以在任何安装了docker-compose的机器上无缝运行。实验和学习技术只是一个组合文件；).</p><p id="4c2c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我希望这篇文章有助于理解Docker Compose。我很想听听你是如何在项目中使用Docker Compose的。鼓掌如果它增加了你的知识，帮助它接触到更多的人。</p></div></div>    
</body>
</html>