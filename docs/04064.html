<html>
<head>
<title>Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从属倒置原则</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dependency-inversion-principle-e402e5b69e70?source=collection_archive---------6-----------------------#2018-05-13">https://medium.com/hackernoon/dependency-inversion-principle-e402e5b69e70?source=collection_archive---------6-----------------------#2018-05-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="fc9f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">解耦、模块化和干净的架构</h2></div><p id="04b1" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是第五篇，也是最后一篇关于<a class="ae kf" href="https://hackernoon.com/solid-principles-530b2cc2badf" rel="noopener ugc nofollow" target="_blank">坚实</a>原则的文章。查上一条，界面偏析原理，<a class="ae kf" rel="noopener" href="/@wrong.about/interface-segregation-principle-bdf3f94f1d11">此处</a>。</p><h2 id="374d" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">定义</h2><p id="08f3" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">像往常一样，我从<a class="ae kf" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">维基百科</a>的引文开始:</p><blockquote class="lg lh li"><p id="f7ae" class="jj jk lj jl b jm jn iv jo jp jq iy jr lk jt ju jv ll jx jy jz lm kb kc kd ke hn dt translated">A.高层模块不应该依赖低层模块。两者都应该依赖于<a class="ae kf" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)" rel="noopener ugc nofollow" target="_blank">抽象</a>。抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="46c4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">罗伯特·马丁原著中并没有对<em class="lj"> A </em>和<em class="lj"> B </em>项进行这样的划分。维基百科有，可惜没有详细说明为什么会这样。此外，不清楚高级和低级模块承担的是什么。我认为它值得一些注释。</p><p id="a793" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对象的存在是为了完成一些工作。他们可以自己做，或者借助一些其他物体。这些“助手”对象很可能代表一些有用的抽象，也就是说，有不止一个类能够实现特定的契约。所以我想在代码中反映这个事实:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="9992" class="kg kh hu ls b fv lw lx l ly lz"><strong class="ls hv">class </strong>A<br/>{<br/>    <strong class="ls hv">private $b</strong>;<br/><br/>    <strong class="ls hv">public function </strong>__construct(B $b)<br/>    {<br/>        $this-&gt;<strong class="ls hv">b </strong>= $b;<br/>    }<br/>}</span></pre><p id="3886" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对象<em class="lj"> $b </em>是类<em class="lj"> A </em>对象的实现细节。因此，接口<em class="lj"> B </em>是，或者<em class="lj">应该按照<em class="lj"> A </em>来定义，并且与<em class="lj"> A </em>在同一个包中。这就是为什么任何实现接口<em class="lj"> B </em>的对象都被认为是相对于<em class="lj"> A </em>的较低层次。</em></p><p id="5081" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以根据它的定义，依赖反转原理讲的就是两件事:解耦和<a class="ae kf" href="https://hackernoon.com/how-to-decompose-a-system-into-modules-796bd941f036" rel="noopener ugc nofollow" target="_blank">正确模块化</a>。</p><h2 id="771d" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">让我们进一步阐述一下</h2><p id="0e0a" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">在美好的过去，当没有人使用接口时，对象就在使用它们的类中被实例化。所以他们直接依赖于那些实现细节(下图中的图1)。今天，我们重视解耦和多态，所以我们使用接口来<a class="ae kf" href="https://codeburst.io/static-classes-are-evil-or-make-your-dependencies-explicit-af3e73bd29dd" rel="noopener" target="_blank">明确我们的依赖关系</a>。这还不是依赖反转原理，这只是一个<a class="ae kf" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。为了使它成为一个倒置，我们必须声明消费者类拥有他的依赖抽象。现在，表示实现细节的模块依赖于更抽象的模块(下图中的图2)。因此，依赖倒置原则颠倒了消费者代码和依赖实现代码之间的依赖方向。</p><figure class="ln lo lp lq fq mb fe ff paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="fe ff ma"><img src="../Images/e4a7c26e79f1fa4584641e957c48625f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbNXFBR349mN0x49gnpW_g.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Source: <a class="ae kf" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">en.wikipedia.org/wiki/Dependency_inversion_principle</a></figcaption></figure><h2 id="5fe9" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">向清洁建筑发展</h2><p id="612c" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">作为一个特例和进一步的发展，DIP声明业务逻辑不应该直接依赖于技术细节。相反，它应该定义一个自己拥有的接口，这样所有的实现代码(例如，数据库查询、http通信、电子邮件发送和几乎所有的基础设施逻辑)都依赖于这个中心层——策略层。对我来说，这听起来像是一个<a class="ae kf" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">清洁建筑</a>的先兆:</p><figure class="ln lo lp lq fq mb fe ff paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="fe ff mm"><img src="../Images/76080b31c8b1ffed64f29a6d4e392e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7LkQDyDqLN3rRSrNYkETA.jpeg"/></div></div></figure><h2 id="47d8" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">最后的想法</h2><p id="d9dc" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">嗯，这个原则基本上可以归结为一个古老的松耦合的东西，它已经存在了至少50年。David Parnas已经说了关于如何定义模块的所有必要内容。我想依赖倒置原则的唯一优势是它比其他的在稳固家庭中更少的模糊性。</p></div></div>    
</body>
</html>