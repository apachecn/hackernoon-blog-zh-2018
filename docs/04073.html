<html>
<head>
<title>Replacing ‘componentWillReceiveProps’ with ‘getDerivedStateFromProps’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将“componentWillReceiveProps”替换为“getDerivedStateFromProps”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/replacing-componentwillreceiveprops-with-getderivedstatefromprops-c3956f7ce607?source=collection_archive---------0-----------------------#2018-05-14">https://medium.com/hackernoon/replacing-componentwillreceiveprops-with-getderivedstatefromprops-c3956f7ce607?source=collection_archive---------0-----------------------#2018-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0cd673843e8cccbd6d850602efc6661b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2QwxPF2TvWXzRUnA4axoA.png"/></div></div></figure><p id="5ed0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a> 16.3的发布，引入了一些新的<a class="ae ka" href="https://hackernoon.com/tagged/lifecycle" rel="noopener ugc nofollow" target="_blank">生命周期</a>方法，React 17的发布将弃用一些生命周期方法。</p><p id="3821" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">getDerivedStateFromProps</code>是取代<code class="eh kb kc kd ke b">componentWillReceiveProps</code>的新引入的生命周期方法之一，T1现已成为<code class="eh kb kc kd ke b">UNSAFE_componentWillReceiveProps</code>。</p><p id="10eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">getDerivedStateFromProps</code>是一个静态方法，在组件被实例化后以及当它接收到新的props时被调用。因为它是一个静态方法，你不能在这个方法中访问<code class="eh kb kc kd ke b">this</code>,也不能访问任何其他的类方法。不像<code class="eh kb kc kd ke b">componentWillReceiveProps</code>你不能在这个方法中设置状态，所以更新状态的唯一方法是返回一个对象。如果不想更新任何状态，只需返回<code class="eh kb kc kd ke b">null</code>。</p><h2 id="f741" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">让我们深入一些代码</h2><p id="12a9" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">这就是<code class="eh kb kc kd ke b">componentWillReceiveProps</code>的工作方式。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="55d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们比较<code class="eh kb kc kd ke b">nextProps.someValue</code>和<code class="eh kb kc kd ke b">this.props.someValue</code>，如果两者不同，那么我们执行一些操作，<code class="eh kb kc kd ke b">setState</code>并调用<code class="eh kb kc kd ke b">this.classMethod();</code>。</p><p id="d2ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们看看<code class="eh kb kc kd ke b">getDerivedStateFromProps</code>是如何工作的。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="7833" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它接收两个参数<code class="eh kb kc kd ke b">nextProps</code>和<code class="eh kb kc kd ke b">prevState</code>。如前所述，你不能在这个方法中访问<code class="eh kb kc kd ke b">this</code>,所以你必须将道具存储在状态中，以便将<code class="eh kb kc kd ke b">nextProps</code>与之前的道具进行比较。在上面的代码中，比较了<code class="eh kb kc kd ke b">nextProps</code>和<code class="eh kb kc kd ke b">prevState</code>，如果两者不同，那么将返回一个对象来更新状态，否则将返回<code class="eh kb kc kd ke b">null</code>来指示不需要状态更新。如果状态改变，那么<code class="eh kb kc kd ke b">componentDidUpdate</code>被调用，我们可以像在<code class="eh kb kc kd ke b">componentWillReceiveProps</code>中那样执行所需的操作。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h2 id="740b" class="kf kg hu bd kh ki kj kk kl km kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky kz dt translated">让我们用一个例子来说明这一点</h2><p id="1dfc" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">假设我们从firebase获得一些数据，并以stats的形式显示出来。这是相同的代码。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="9936" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的例子用的是<code class="eh kb kc kd ke b">componentWillReceiveProps</code>。最初，<code class="eh kb kc kd ke b">displayStat.js</code>组件将监听<code class="eh kb kc kd ke b">path-1</code>上的firebase，当用户点击改变路径按钮时，状态将在<code class="eh kb kc kd ke b">App.js</code>文件中改变，而<code class="eh kb kc kd ke b">componentWillReceiveProps</code>将在<code class="eh kb kc kd ke b">displayStat.js</code>文件中被调用。以前到firebase path的连接将被关闭，并将创建一个新的。注意，我们将firebase引用作为参数传递给<code class="eh kb kc kd ke b">getDate()</code>来监听firebase。</p><p id="c8b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们用<code class="eh kb kc kd ke b">getDerivedStateFromProps</code>做同样的事情。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="c2d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意在<code class="eh kb kc kd ke b">getDerivedStateFromProps</code>中返回一个对象来更新状态，并且没有调用任何类方法。我们使用<code class="eh kb kc kd ke b">componentDidUpdate</code>来检查路径是否被更改，并相应地创建一个新的firebase连接并监听新路径。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><p id="97ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">感谢阅读本文。如果你喜欢，请点击<em class="ls">拍手</em>按钮。<br/> </strong>在<a class="ae ka" href="https://www.linkedin.com/in/amanshu-kataria/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。<br/>你也可以在<a class="ae ka" href="http://twitter.com/amanshu_kataria" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ka" href="https://www.quora.com/profile/Amanshu-Kataria" rel="noopener ugc nofollow" target="_blank"> Quora </a>和<a class="ae ka" href="https://github.com/amanshu-kataria" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lt lk l"/></div></figure></div></div>    
</body>
</html>