<html>
<head>
<title>Building a chat bot using Nest.js and Telegram</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nest.js和Telegram构建聊天机器人</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-chat-bot-using-nest-js-and-telegram-7d043f68b5d3?source=collection_archive---------6-----------------------#2018-05-14">https://medium.com/hackernoon/building-a-chat-bot-using-nest-js-and-telegram-7d043f68b5d3?source=collection_archive---------6-----------------------#2018-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9c672ecdd4ac1568f8eb9c240cc400aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zZ09keEm0AKHSHargUeVQ.jpeg"/></div></div></figure><h1 id="8d74" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="9da7" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在本教程中，我将向你展示如何使用<a class="ae ky" href="https://hackernoon.com/tagged/nestjs" rel="noopener ugc nofollow" target="_blank"> Nest.js </a>为<a class="ae ky" href="https://hackernoon.com/tagged/telegram" rel="noopener ugc nofollow" target="_blank"> Telegram </a>构建一个基本的聊天机器人。这将会给你一个电报机器人如何工作以及你能用它们做什么的概述。</p><p id="07bb" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">电报机器人是简单的帐户，不需要额外的电话号码来设置。用户可以通过命令与他们交互:直接打开聊天或通过键入bot的@username直接从聊天输入字段发送请求。</p><h1 id="6e04" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">我们将会建造什么</h1><p id="3367" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们将建立一个用户名为<code class="eh le lf lg lh b">new-nest-bot</code>的电报机器人，你可以在注册一个新的电报机器人时选择你自己喜欢的名字。</p><p id="f30a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="https://www.youtube.com/watch?v=qBQaX3eVsdk&amp;" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=qBQaX3eVsdk&amp;T6】</a></p><p id="98b2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这个bot被构建为使用来自应用程序后端实现的逻辑的预定义响应来响应直接发送给它的文本消息。</p><h1 id="325b" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">先决条件</h1><p id="6e6e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">对TypeScript和Node.js的基本理解将有助于您充分利用本教程。我假设您已经安装了Node和npm，否则请快速查看<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>以获得进一步的说明和安装步骤。</p><p id="c3d9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">此外，还需要一个电报帐户来访问电报服务，以便开始聊天或创建机器人。如果你没有账户，我推荐你使用<a class="ae ky" href="https://web.telegram.org/#/login" rel="noopener ugc nofollow" target="_blank">电报网络客户端</a></p><p id="b9e2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">最后，这里有一个我们将在这篇文章中使用的技术的快速概述。</p><ul class=""><li id="1a50" class="li lj hu kc b kd kz kh la kl lk kp ll kt lm kx ln lo lp lq dt translated"><a class="ae ky" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest.js </a> : <strong class="kc hv"> </strong>构建高效可扩展的服务器端应用的渐进式框架；旨在利用现代JavaScript的优势，但仍然保持与纯JavaScript的兼容性。</li></ul><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div class="ab fr cl lv"><img src="../Images/a2b8a2c902428db7030b8222b6a6d3fd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8_uUnP2g8H8Zj3N_KktFtw.png"/></div></figure><ul class=""><li id="f4dd" class="li lj hu kc b kd kz kh la kl lk kp ll kt lm kx ln lo lp lq dt translated"><a class="ae ky" href="https://github.com/yagop/node-telegram-bot-api" rel="noopener ugc nofollow" target="_blank"> Node-telegram-bot-api </a>:与官方<a class="ae ky" href="https://core.telegram.org/bots/api" rel="noopener ugc nofollow" target="_blank"> Telegram Bot API </a>交互的Node.js模块。</li></ul><h1 id="324a" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">设置项目</h1><p id="a165" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">首先，你需要使用Git在Github 上安装<a class="ae ky" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest.js </a> starter项目。为此，让我们运行一个命令，将starter存储库克隆到机器上一个名为<code class="eh le lf lg lh b">nest-telegram-chat-bot</code>的新项目文件夹中。打开终端或命令提示符，运行以下命令:</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="c70d" class="ma jd hu lh b fv mb mc l md me">$ git clone https://github.com/nestjs/typescript-starter.git nest-telegram-chat-bot</span></pre><p id="6512" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">继续将目录更改到新创建的文件夹中，并安装项目的所有依赖项。</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="7e1b" class="ma jd hu lh b fv mb mc l md me">// change directory<br/>cd nest-telegram-chat-bot<br/></span><span id="d09b" class="ma jd hu lh b fv mf mc l md me">// install dependencies<br/>npm install<!-- --> </span></pre><h1 id="cc5c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">安装服务器依赖项</h1><p id="ef92" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这个应用程序唯一需要的服务器依赖是<a class="ae ky" href="https://github.com/yagop/node-telegram-bot-api" rel="noopener ugc nofollow" target="_blank"> node-telegram-bot-api </a>。运行以下命令进行安装:</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="5c17" class="ma jd hu lh b fv mb mc l md me">$ npm install --save node-telegram-bot-api</span></pre><h1 id="b5b1" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">创建一个电报机器人</h1><p id="d6a3" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们基本上会与Telegram bot API进行交互。为此，您需要获得一个访问令牌。打开一个<a class="ae ky" href="https://web.telegram.org/" rel="noopener ugc nofollow" target="_blank">电报app </a>，搜索<code class="eh le lf lg lh b">@BotFather</code>，开始聊天。使用/newbot命令创建一个新的bot。在生成访问令牌之前，僵尸父亲会问你几个问题，比如名字和用户名。</p><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/b8429bb90ee9d1e961900ea990eb9b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*uA1JKceuZv7b0l5_.png"/></div></figure><p id="7c4e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">按照所有说明操作，一旦完成，将为您生成一个向Telegram Bot API发送请求所需的令牌。如下图所示:</p><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/c880e8c39bd010b3f9bf57248611b501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPP_fA5Qb1_SPRktYuuwWw.jpeg"/></div></div></figure><p id="e5b7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在，我们已经成功地创建了一个机器人，但它目前是被动的，因为它尚未配置为响应聊天。</p><h1 id="129b" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">提出请求</h1><p id="e0a0" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在浏览器中打开一个新标签，通过使用以下URL向Telegram bot API发出HTTPS请求来测试新Bot:</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="5f89" class="ma jd hu lh b fv mb mc l md me">https://api.telegram.org/bot&lt;YOUR_ACCESS_TOKEN&gt;/getMe</span></pre><p id="50a9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这将返回一个JSON格式的响应，其中包含bot的id、名称和用户名。</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="3ef4" class="ma jd hu lh b fv mb mc l md me">{"ok":true,"result":{"id":591836832,"is_bot":true,"first_name":"new-nest-bot","username":"nest_demo_bot"}}</span></pre><h1 id="14e4" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">初始化应用程序控制器</h1><p id="f212" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">当用户在Telegram上与我们的机器人交互时，<a class="ae ky" href="https://core.telegram.org/bots/api" rel="noopener ugc nofollow" target="_blank"> Telegram机器人API </a>通过HTTP请求向我们的Nest.js应用程序发送关于交互的详细信息，并且将会发回一个响应，其中包含机器人应该如何响应的指令。让我们配置我们的应用程序逻辑。</p><p id="90a6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">Nest.js starter项目安装了一个名为app.controller.ts的默认控制器，打开该文件并用下面的代码更新它:</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="a598" class="ma jd hu lh b fv mb mc l md me">// ./src/app.controller.ts</span><span id="fc20" class="ma jd hu lh b fv mf mc l md me"><strong class="lh hv">import </strong>{ BotService } from './bot/bot.service';<br/><strong class="lh hv">import </strong>{ Get, Controller, Res, HttpStatus } from '@nestjs/common';<br/><br/>@Controller()<br/><strong class="lh hv">export class </strong>AppController {<br/>  constructor(<strong class="lh hv">private </strong>botService:BotService) {}<br/><br/>  @Get()<br/>  getBotDialog(@Res() res) {<br/>    <strong class="lh hv">this</strong>.botService.botMessage();<br/>    res.status(HttpStatus.OK).send("Bot service started");<br/>  }<br/>}</span></pre><p id="6cb3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一旦我们启动了应用程序，这个控制器就会处理传入的请求并返回适当的响应。如上图，我们导入了<code class="eh le lf lg lh b">BotService</code>，并通过构造函数将其注入控制器。这是为了确保<code class="eh le lf lg lh b">app.controller.ts</code>只处理HTTP请求，并将复杂的逻辑抽象为服务。我们将在下一节中对此进行设置</p><h1 id="6b9c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">配置bot服务</h1><p id="8f49" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们的<code class="eh le lf lg lh b">AppController</code>依赖于一个名为<code class="eh le lf lg lh b">BotService</code>的服务，根据特定的逻辑来响应与我们的电报机器人的交互。让我们创建这个服务。在<code class="eh le lf lg lh b">src</code>中创建一个<code class="eh le lf lg lh b">bot</code>文件夹，并在其中创建一个名为<code class="eh le lf lg lh b">bot.service.ts</code>的新文件。接下来，打开新创建的文件，将下面的代码粘贴到其中:</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="75e3" class="ma jd hu lh b fv mb mc l md me">// ./src/bot/bot.service.ts</span><span id="61c8" class="ma jd hu lh b fv mf mc l md me"><strong class="lh hv">import </strong>{ Component} <strong class="lh hv">from </strong>'@nestjs/common';<br/><br/>@Component()<br/><strong class="lh hv">export class </strong>BotService {<br/><br/>    botMessage() {        <br/>        process.env.NTBA_FIX_319 = "1";<br/>        <strong class="lh hv">const </strong>TelegramBot = require('node-telegram-bot-api');<br/>        <br/>        <strong class="lh hv">const </strong>token = 'YOUR_ACCESS_TOKEN';<br/>        <br/>        <strong class="lh hv">const </strong>bot = <strong class="lh hv">new </strong>TelegramBot(token, { polling: <strong class="lh hv">true </strong>});<br/>    <br/>        bot.on('message', (msg) =&gt; {<br/>            <strong class="lh hv">let </strong>Hi = "hi";<br/>            <strong class="lh hv">if </strong>(msg.text.toString().toLowerCase().indexOf(Hi) === 0) {<br/>                bot.sendMessage(msg.from.id, "Hello " + msg.from.first_name + " what would you like to know about me ?");<br/>            }<br/>    }<br/>}</span></pre><p id="fb82" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这里，我们创建了一个名为<code class="eh le lf lg lh b">botMessage()</code>的方法，在这个方法中，我们需要<code class="eh le lf lg lh b">node-telegram-bot-api </code>模块，然后将从BotFather收到的<code class="eh le lf lg lh b">access_token</code>分配给一个令牌变量。这个令牌后来被用作创建新的<code class="eh le lf lg lh b">TelegramBot()</code>的参数。注意传递给新的<code class="eh le lf lg lh b">TelegramBot()</code>的第二个参数？我们在这里所做的是通过将<a class="ae ky" href="https://en.wikipedia.org/wiki/Push_technology#Long_polling" rel="noopener ugc nofollow" target="_blank">长轮询</a>配置设置为true来创建我们的bot。</p><p id="e3e6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">值得一提的是，您实际上可以通过两种方式与服务器进行交互:</p><ol class=""><li id="141d" class="li lj hu kc b kd kz kh la kl lk kp ll kt lm kx mi lo lp lq dt translated"><a class="ae ky" href="https://sendgrid.com/blog/whats-webhook/" rel="noopener ugc nofollow" target="_blank"> Webhook </a>:专用URL或者也可以称为web回调。</li><li id="8f5a" class="li lj hu kc b kd mj kh mk kl ml kp mm kt mn kx mi lo lp lq dt translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Push_technology#Long_polling" rel="noopener ugc nofollow" target="_blank">长轮询</a>:这允许我们在本地运行我们的应用程序，而不需要专用服务器或外部地址。</li></ol><h1 id="ab61" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">注册组件</h1><p id="c9b1" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">目前，我们的应用程序不能识别新创建的服务。让我们通过编辑我们的模块文件<code class="eh le lf lg lh b">app.module.ts</code>来改变这一点。为此，将服务放入<code class="eh le lf lg lh b">@Module()</code>装饰器的“组件”数组中。</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="cc6a" class="ma jd hu lh b fv mb mc l md me">// ./src/app.module.ts</span><span id="d575" class="ma jd hu lh b fv mf mc l md me"><strong class="lh hv">import </strong>{ Module } <strong class="lh hv">from </strong>'@nestjs/common';<br/><strong class="lh hv">import </strong>{ AppController } <strong class="lh hv">from </strong>'./app.controller';<br/><strong class="lh hv">import </strong>{ BotService } <strong class="lh hv">from </strong>'bot/bot.service';<br/><br/>@Module({<br/>  imports: [],<br/>  controllers: [AppController],<br/>  components: [BotService],<br/>})<br/><strong class="lh hv">export class </strong>AppModule {}</span></pre><h1 id="3993" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">运行应用程序</h1><p id="d63a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">使用以下内容启动应用程序:</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="047c" class="ma jd hu lh b fv mb mc l md me">$ npm start</span></pre><p id="db23" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这将在Nest.js使用的默认端口上启动应用程序。打开浏览器并导航到<a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>。</p><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/0ee6599f8b8f112cd49c7c3e061f2f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZTnkRysk-zkqei24.png"/></div></div></figure><p id="42e3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">接下来，打开一个<a class="ae ky" href="https://web.telegram.org/#/im" rel="noopener ugc nofollow" target="_blank">电报应用</a>，搜索<code class="eh le lf lg lh b">new-nest-bot</code>或者你的电报机器人的名字，如果你碰巧选择了一个不同的名字。</p><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/c596e49439966829649bf77d783803af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g0EggNgYipgx4YtK.png"/></div></div></figure><p id="74c8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在，您可以点击开始按钮开始聊天。</p><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/14cd48e749974e533a1f27743fb87b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TACZqrOgmoK_0SOr.png"/></div></div></figure><p id="8cf3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果您目前没有得到响应，不要担心，如果您在不同的选项卡中打开应用程序，只需刷新它。</p><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/e96a11d7a5053b1f96cb7e259608c436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rJybkJUQ4EeURg6O.png"/></div></div></figure><h1 id="4ba0" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">更新服务</h1><p id="2864" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">为了避免一直刷新页面，我们将在组件中使用Nest.js中名为<code class="eh le lf lg lh b">OnModuleInit</code>的生命周期事件来初始化僵尸消息方法。</p><pre class="lr ls lt lu fq lw lh lx ly aw lz dt"><span id="94b4" class="ma jd hu lh b fv mb mc l md me">// ./src/bot/bot.service.ts</span><span id="9784" class="ma jd hu lh b fv mf mc l md me"><strong class="lh hv">import </strong>{ Component, OnModuleInit } <strong class="lh hv">from </strong>'@nestjs/common';<br/><br/>@Component()<br/><strong class="lh hv">export class </strong>BotService <strong class="lh hv">implements </strong>OnModuleInit {<br/><br/>    onModuleInit() {<br/>        <strong class="lh hv">this</strong>.botMessage();<br/>    }<br/><br/>    botMessage() {        <br/>       ...<br/>    }<br/>}</span></pre><p id="299a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果开发服务器当前正在运行，重启它，然后继续尝试新的nest-bot</p><figure class="lr ls lt lu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/276a503377a3a66937ad709536592579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HlU0qbVBhIijVRC1.png"/></div></div></figure><p id="53d0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你可以在GitHub的完整对话框中找到完整的<code class="eh le lf lg lh b">bot.service.ts</code>文件<a class="ae ky" href="https://github.com/yemiwebby/nest-telegram-chat-bot/blob/master/src/bot/bot.service.ts" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="2957" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">结论</h1><p id="5193" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在这里，我们已经能够构建一个电报聊天机器人，它对来自其他用户的聊天进行预定义的响应。目的是给你一个可以改进的通用构建模块，并构建可以做更多事情的神奇聊天机器人。</p><p id="8fa4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我希望本教程对您有所帮助，并为您提供了足够的信息，以便在您的组织中开始构建适合其他用例的bot。</p><p id="f425" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">本教程的源代码可以在Github的<a class="ae ky" href="https://github.com/yemiwebby/nest-telegram-chat-bot" rel="noopener ugc nofollow" target="_blank">这里</a>找到。随意探索。</p><figure class="lr ls lt lu fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>