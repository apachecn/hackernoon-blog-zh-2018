<html>
<head>
<title>React 16.0–16.6 new features for every day use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react 16.0–16.6日常使用的新功能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-16-0-16-3-new-features-for-every-day-use-f397da374acf?source=collection_archive---------1-----------------------#2018-05-15">https://medium.com/hackernoon/react-16-0-16-3-new-features-for-every-day-use-f397da374acf?source=collection_archive---------1-----------------------#2018-05-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/115162be89823a33675d78ffc806134e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kUv3w5Zs6kxhqUMb."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="92cd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个简短的备忘单，适用于从React 15迁移到React 16，或者从更早的16.x版本迁移到16.6的开发人员。它侧重于您经常使用的功能。</p><h2 id="d9bd" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">从带有片段的组件中返回多个元素</h2><p id="cd07" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">将UI分割成小的可重用组件可能会导致创建不必要的DOM元素，比如当您需要从一个组件返回多个元素时。React 16有几个选项可以避免这种情况:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="4ad4" class="kf kg hu lk b fv lo lp l lq lr">// React 15: extra wrapper element<br/>const Breakfast = () =&gt; (<br/>  &lt;ul&gt;<br/>    &lt;li&gt;Coffee&lt;/li&gt;<br/>    &lt;li&gt;Croissant&lt;/li&gt;<br/>    &lt;li&gt;Marmalade&lt;/li&gt;<br/>  &lt;/ul&gt;<br/>);<br/><br/>// React 16.0: array (note that keys are required)<br/>const Breakfast = () =&gt; [<br/>  &lt;li key="coffee"&gt;Coffee&lt;/li&gt;,<br/>  &lt;li key="croissant"&gt;Croissant&lt;/li&gt;,<br/>  &lt;li key="marmalade"&gt;Marmalade&lt;/li&gt;<br/>];<br/><br/>// React 16.2: fragment<br/>const Breakfast = () =&gt; (<br/>  &lt;React.Fragment&gt;<br/>    &lt;li&gt;Coffee&lt;/li&gt;<br/>    &lt;li&gt;Croissant&lt;/li&gt;<br/>    &lt;li&gt;Marmalade&lt;/li&gt;<br/>  &lt;/React.Fragment&gt;<br/>);<br/><br/>// React 16.2: fragment (short syntax)<br/>const Breakfast = () =&gt; (<br/>  &lt;&gt;<br/>    &lt;li&gt;Coffee&lt;/li&gt;<br/>    &lt;li&gt;Croissant&lt;/li&gt;<br/>    &lt;li&gt;Marmalade&lt;/li&gt;<br/>  &lt;/&gt;<br/>);<br/><br/>// React 16: fragments composition<br/>const Meals = (<br/>  &lt;ul&gt;<br/>    &lt;Breakfast /&gt;<br/>    &lt;Lunch /&gt;<br/>    &lt;Dinner /&gt;<br/>  &lt;/ul&gt;<br/>);</span></pre><p id="58f1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，您正在使用的工具<a class="ae jg" href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html#support-for-fragment-syntax" rel="noopener ugc nofollow" target="_blank">可能不支持短语法。</a></p><h2 id="a2f8" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">从组件返回字符串和数字</h2><p id="3144" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在React 16中，组件可以返回字符串和数字。这对于不需要任何标记的组件很有用，比如国际化或格式化:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="770f" class="kf kg hu lk b fv lo lp l lq lr">// React 15<br/>const LocalDate = ({ date }) =&gt; (<br/>  &lt;span&gt;<br/>    {date.toLocaleDateString('de-DE', {<br/>      year: 'numeric',<br/>      month: 'long',<br/>      day: 'numeric'<br/>    })}<br/>  &lt;/span&gt;<br/>);<br/><br/>// React 16<br/>const LocalDate = ({ date }) =&gt;<br/>  date.toLocaleDateString('de-DE', {<br/>    year: 'numeric',<br/>    month: 'long',<br/>    day: 'numeric'<br/>  });</span></pre><h2 id="1c2d" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">取消setState()以避免重新呈现</h2><p id="9113" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在React 15中，如果你的下一个状态是基于上一个状态，那么取消<code class="eh ls lt lu lk b">setState()</code>并避免重新渲染是不可能的。在React 16中，你可以在<code class="eh ls lt lu lk b">setState()</code>的回调中返回<code class="eh ls lt lu lk b">null</code>:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="fa6e" class="kf kg hu lk b fv lo lp l lq lr">// React 16<br/>handleChange = event =&gt; {<br/>  const city = event.target.value;<br/>  this.setState(<br/>    prevState =&gt; (prevState.city !== city ? { city } : null)<br/>  );<br/>};</span></pre><p id="701a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个例子中，使用与州名相同的城市名调用<code class="eh ls lt lu lk b">handleChange()</code>不会导致重新提交。</p><h2 id="6152" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">使用官方上下文API (16.3)避免钻柱</h2><p id="7858" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><a class="ae jg" href="https://blog.kentcdodds.com/prop-drilling-bb62e02cb691" rel="noopener ugc nofollow" target="_blank"> prop drilling </a>是当你使用一个Prop将一些数据传递给一个深度嵌套的组件时，所以你必须将这个Prop添加到React组件树的每一层，在拥有数据的组件和消费数据的组件之间。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="35f7" class="kf kg hu lk b fv lo lp l lq lr">class Root extends React.Component {<br/>  state = { theme: THEME_DARK };<br/>  handleThemeToggle = theme =&gt;<br/>    this.setState(({ theme }) =&gt; ({<br/>      theme: theme === THEME_DARK ? THEME_LIGHT : THEME_DARK;<br/>    }));<br/>  render() {<br/>    return (<br/>      &lt;Page<br/>        onThemeToggle={this.handleThemeToggle}<br/>        {...this.state}<br/>        {...this.props}<br/>      /&gt;<br/>    );<br/>  }<br/>}</span><span id="21e4" class="kf kg hu lk b fv lv lp l lq lr">// Each layer will have to pass theme and theme toggle handler props<br/>&lt;SomeOtherComponent<br/>  onThemeToggle={props.onThemeToggle}<br/>  theme={props.theme}<br/>/&gt;;</span><span id="ef81" class="kf kg hu lk b fv lv lp l lq lr">// Many layers below<br/>const Header = ({ theme, onThemeToggle }) =&gt; (<br/>  &lt;header className={cx('header', `header--${theme}`)}&gt;<br/>    ...<br/>    &lt;button onClick={onThemeToggle}&gt;Toggle theme&lt;/button&gt;<br/>  &lt;/header&gt;<br/>);</span></pre><p id="845c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一大堆样板代码！通过<a class="ae jg" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>，我们可以在组件树的任何地方访问我们的主题道具:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="13e2" class="kf kg hu lk b fv lo lp l lq lr">const ThemeContext = React.createContext(THEME_DARK);</span><span id="8ce3" class="kf kg hu lk b fv lv lp l lq lr">// We should wrap our app in this component<br/>class ThemeProvider extends React.Component {<br/>  state = { theme: THEME_DARK };<br/>  handleThemeToggle = theme =&gt;<br/>    this.setState(({ theme }) =&gt; ({<br/>      theme: theme === THEME_DARK ? THEME_LIGHT : THEME_DARK<br/>    }));<br/>  render() {<br/>    return (<br/>      &lt;ThemeContext.Provider<br/>        value={{<br/>          onThemeToggle: this.handleThemeToggle,<br/>          theme: this.state.theme<br/>        }}<br/>      &gt;<br/>        {this.props.children}<br/>      &lt;/ThemeContext.Provider&gt;<br/>    );<br/>  }<br/>}</span><span id="49d4" class="kf kg hu lk b fv lv lp l lq lr">// And then use theme consumer anywhere in the component tree<br/>const Header = () =&gt; (<br/>  &lt;ThemeContext.Consumer&gt;<br/>    {({ theme, onThemeToggle }) =&gt; (<br/>      &lt;header className={cx('header', `header--${theme}`)}&gt;<br/>        ...<br/>        &lt;button onClick={onThemeToggle}&gt;Toggle theme&lt;/button&gt;<br/>      &lt;/header&gt;<br/>    )}<br/>  &lt;/ThemeContext.Consumer&gt;<br/>);</span></pre><p id="44d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://codesandbox.io/s/l43j6j2n7z" rel="noopener ugc nofollow" target="_blank">在CodeSandbox上查看一个例子</a>。</p><h2 id="1af5" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">使用getDerivedStateFromProps()基于属性更新状态(16.3)</h2><p id="f3fc" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><code class="eh ls lt lu lk b">getDerivedStateFromProps()</code>生命周期方法是对<code class="eh ls lt lu lk b">componentWillReceiveProps()</code>的替代。当您有一个带有状态属性默认值的属性，但您想在该属性改变时重置状态时，这很有用。例如，一个模态有一个属性表示它最初是否打开，还有一个状态表示一个模态现在是否打开:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="3dcc" class="kf kg hu lk b fv lo lp l lq lr">// React 15<br/>class Modal extends React.Component {<br/>  state = {<br/>    isOpen: this.props.isOpen<br/>  };<br/>  componentWillReceiveProps(nextProps) {<br/>    if (nextProps.isOpen !== this.state.isOpen) {<br/>      this.setState({<br/>        isOpen: nextProps.isOpen<br/>      });<br/>    }<br/>  }<br/>}<br/><br/>// React 16.3<br/>class Modal extends React.Component {<br/>  state = {};<br/>  static getDerivedStateFromProps(nextProps, prevState) {<br/>    if (nextProps.isOpen !== prevState.isOpen) {<br/>      return {<br/>        isOpen: nextProps.isOpen<br/>      };<br/>    }<br/>  }<br/>}</span></pre><p id="4bde" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当一个组件被创建并且当它接收到新的属性时，<code class="eh ls lt lu lk b">getDerivedStateFromProps()</code>方法被调用，所以你不必两次将属性转换为状态(在初始化时和在<code class="eh ls lt lu lk b">componentWillReceiveProps()</code>)。</p><h2 id="092f" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">用React.memo() (16.6)重新渲染道具上的功能组件变化</h2><p id="89cd" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><a class="ae jg" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> React.memo() </a>对函数组件的操作与<a class="ae jg" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank"> PureComponent </a>对类组件的操作相同:只有当属性改变时才重新呈现组件。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="a13f" class="kf kg hu lk b fv lo lp l lq lr">const MyComponent = React.memo(props =&gt; {<br/>  /* Only rerenders if props change */<br/>});</span></pre><h2 id="367d" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">使用contextType (16.6)更容易访问类组件中的上下文</h2><p id="bea1" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated"><a class="ae jg" href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#static-contexttype" rel="noopener ugc nofollow" target="_blank"> Class.contextType </a>简化了对类组件中React上下文<em class="lw">的访问:</em></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="383f" class="kf kg hu lk b fv lo lp l lq lr">class App extends React.Component {<br/>  static contextType = ThemeContext;<br/>  componentDidMount() {<br/>    const { theme } = this.context;<br/>    /* ... */<br/>  }<br/>  componentDidUpdate() {<br/>    const { theme } = this.context;<br/>    /* ... */<br/>  }<br/>  componentWillUnmount() {<br/>    const { theme } = this.context;<br/>    /* ... */<br/>  }<br/>  render() {<br/>    const { theme } = this.context;<br/>    return (<br/>      &lt;h1&gt;<br/>        {theme === THEME_DARK<br/>          ? 'Welcome to the dark side!'<br/>          : 'Welcome to the light side!'}<br/>      &lt;/h1&gt;<br/>    );<br/>  }<br/>}</span></pre><h2 id="0090" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">其他新功能</h2><p id="1dad" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">React 16.x还有许多其他有用的特性:</p><ul class=""><li id="2192" class="lx ly hu jj b jk jl jo jp js lz jw ma ka mb ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">误差边界</a>；</li><li id="b5cd" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">门户</a>；</li><li id="009a" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">转发参考</a>(16.3)；</li><li id="883c" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">新的上下文API</a>(16.3)；</li><li id="9a07" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate" rel="noopener ugc nofollow" target="_blank"> getSnapshotBeforeUpdate()生命周期方法</a>(16.3)；</li><li id="6f57" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" rel="noopener ugc nofollow" target="_blank">严格模式组件</a>(16.3)；</li><li id="5c99" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/blog/2018/05/23/react-v-16-4.html#pointer-events" rel="noopener ugc nofollow" target="_blank">指针事件</a>(16.4)；</li><li id="42c7" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener ugc nofollow" target="_blank">剖面仪</a>(16.5)；</li><li id="4955" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense" rel="noopener ugc nofollow" target="_blank">react . lazy</a>(16.6)；</li><li id="94ad" class="lx ly hu jj b jk mg jo mh js mi jw mj ka mk ke mc md me mf dt translated"><a class="ae jg" href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#static-getderivedstatefromerror" rel="noopener ugc nofollow" target="_blank">静态getDerivedStateFromError()</a>(16.6)。</li></ul><p id="99d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我也强烈推荐尼克·格拉芙在Egghead开设的React 16 课程。</p><p id="00a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">订阅我的简讯:</strong><a class="ae jg" href="https://tinyletter.com/sapegin" rel="noopener ugc nofollow" target="_blank"><strong class="jj hv">https://tinyletter.com/sapegin</strong></a></p></div></div>    
</body>
</html>