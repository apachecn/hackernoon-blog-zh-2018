<html>
<head>
<title>Build a realtime map using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin构建实时地图</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-realtime-map-using-kotlin-8f99ebd15fc?source=collection_archive---------16-----------------------#2018-05-15">https://medium.com/hackernoon/build-a-realtime-map-using-kotlin-8f99ebd15fc?source=collection_archive---------16-----------------------#2018-05-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="dc3d" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">要阅读本教程，需要对Kotlin和Node.js有基本的了解。</p></blockquote><p id="a8a0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">顾名思义，本文的目的是显示地图上标记的实时移动。此功能在位置跟踪应用中很常见。我们看到打车应用和订餐应用利用了这样的功能。Google提供了一个非常简单的地图API，我们将利用它，而实时功能将由Pusher负责。</p><h1 id="1c8a" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">我们将建造什么</h1><p id="909b" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">我们将构建一个应用程序，该应用程序将基于我们注入其中的初始坐标从服务器接收坐标。收到这些坐标后，我们会在应用程序上更新地图。</p><figure class="la lb lc ld fq le fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/64546f6f7e976743e782e20d792e4ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*V1Z-O_yCf5KrrXTGJBpaAw.gif"/></div></figure><h1 id="cdd1" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">要求</h1><p id="ea9f" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">对于本教程，我们需要以下内容:</p><ul class=""><li id="7e32" class="lh li hu ix b iy iz jc jd jt lj ju lk jv ll js lm ln lo lp dt translated"><a class="ae lq" href="https://developer.android.com/studio/archive.html" rel="noopener ugc nofollow" target="_blank">安卓工作室</a> —推荐3.0.1以上版本。</li><li id="b88e" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated"><a class="ae lq" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">安装在您机器上的节点JS </a>和npm。</li><li id="92fc" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated">一个<a class="ae lq" href="https://dashboard.pusher.com" rel="noopener ugc nofollow" target="_blank">推杆</a>应用。</li><li id="27fc" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated"><a class="ae lq" href="https://developers.google.com/maps/documentation/android-api/signup" rel="noopener ugc nofollow" target="_blank">谷歌地图API键</a>。</li><li id="0e01" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated">安装了Google Play服务的Android设备。</li></ul><h1 id="acd2" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">构建我们的服务器</h1><p id="9596" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">我们将使用节点JS构建我们的服务器。服务器会为我们生成随机坐标。首先，创建一个新文件夹。在其中，创建一个名为<code class="eh lw lx ly lz b">package.json</code>的新文件，并粘贴如下内容:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="059f" class="me jx hu lz b fv mf mg l mh mi">{<br/>    "main": "index.js",<br/>    "dependencies": {<br/>        "body-parser": "^1.16.0",<br/>        "express": "^4.14.1",<br/>        "pusher": "^1.5.1"<br/>    }<br/>}</span></pre><p id="4d9f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，在根目录下创建名为<code class="eh lw lx ly lz b">index.js</code>的文件并粘贴:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="0c36" class="me jx hu lz b fv mf mg l mh mi">// Load the required libraries<br/>let Pusher = require('pusher');<br/>let express = require('express');<br/>let bodyParser = require('body-parser');</span><span id="a390" class="me jx hu lz b fv mj mg l mh mi">// initialize express and pusher<br/>let app = express();<br/>let pusher = new Pusher(require('./config.js'));</span><span id="1063" class="me jx hu lz b fv mj mg l mh mi">// Middlewares<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: false }));</span><span id="0e63" class="me jx hu lz b fv mj mg l mh mi">// Generates 20 simulated GPS coords and sends to Pusher<br/>app.post('/simulate', (req, res, next) =&gt; {<br/>    let loopCount = 0<br/>    let operator  = 0.001000  <br/>    let longitude = parseFloat(req.body.longitude)<br/>    let latitude  = parseFloat(req.body.latitude)<br/>    <br/>    let sendToPusher = setInterval(() =&gt; {<br/>        loopCount++;</span><span id="513f" class="me jx hu lz b fv mj mg l mh mi">        // Calculate new coordinates and round to 6 decimal places...<br/>        longitude = parseFloat((longitude + operator).toFixed(7))<br/>        latitude  = parseFloat((latitude - operator).toFixed(7))</span><span id="0d7f" class="me jx hu lz b fv mj mg l mh mi">        // Send to pusher<br/>        pusher.trigger('my-channel', 'new-values', {longitude, latitude})</span><span id="3568" class="me jx hu lz b fv mj mg l mh mi">        if (loopCount === 20) {<br/>            clearInterval(sendToPusher)<br/>        }<br/>    }, 2000);</span><span id="7a22" class="me jx hu lz b fv mj mg l mh mi">    res.json({success: 200})<br/>})</span><span id="8969" class="me jx hu lz b fv mj mg l mh mi">// Index<br/>app.get('/', (req, res) =&gt; res.json("It works!"));</span><span id="387b" class="me jx hu lz b fv mj mg l mh mi">// Serve app<br/>app.listen(4000, _ =&gt; console.log('App listening on port 4000!'));</span></pre><p id="ef3f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面的代码是一个快速应用程序。在<code class="eh lw lx ly lz b">/simulate</code>路线中，我们正在模拟经度和纬度值，然后将它们发送给Pusher。这些将由我们的应用程序选择。</p><blockquote class="ir is it"><p id="3f72" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡经度和纬度值通常从现实场景中被跟踪的设备获得。</em></p></blockquote><p id="8338" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，我们将创建名为<code class="eh lw lx ly lz b">config.js</code>的配置文件。将此片段粘贴到此处:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="fca9" class="me jx hu lz b fv mf mg l mh mi">module.exports = {<br/>    appId: 'PUSHER_APP_ID',<br/>    key: 'PUSHER_APP_KEY',<br/>    secret: 'PUSHER_APP_SECRET',<br/>    cluster: 'PUSHER_APP_CLUSTER',<br/>};</span></pre><p id="02bf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">用推动器仪表板上的键替换那里的值。然后，通过在根目录下运行以下命令来安装我们的服务器所需的模块:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="81c3" class="me jx hu lz b fv mf mg l mh mi">$ npm install</span></pre><p id="9806" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们的服务器应该在端口<strong class="ix hv"> 4000 </strong>上启动并运行。</p><h1 id="c2ab" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">在Android Studio中构建我们的实时地图</h1><h1 id="0329" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">创建新的Android项目</h1><p id="3153" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">打开Android studio并创建一个新项目。输入您的应用程序详细信息，包括Kotlin支持，选择一个最低的SDK(这不应该低于API 14)，选择一个空活动，并完成该过程。下面是这个过程的快速GIF:</p><figure class="la lb lc ld fq le fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/4283e3862faaa54e7157b28fba57ef47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*50_QA8_AwbFF_fBmBq7j7Q.gif"/></div></figure><h1 id="88f5" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">添加应用程序依赖项</h1><p id="bb5c" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">这个演示有几个依赖项。我们需要实时功能的Pusher依赖，轻松将地图集成到我们的应用程序中的Google Maps API，以及轻松访问我们的服务器的改进。</p><p id="4623" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开您的应用程序模块<code class="eh lw lx ly lz b">build.gradle</code>文件并粘贴以下依赖项:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="8fe5" class="me jx hu lz b fv mf mg l mh mi">// Pusher dependency<br/>implementation 'com.pusher:pusher-java-client:1.5.0'</span><span id="a990" class="me jx hu lz b fv mj mg l mh mi">// Google maps API<br/>implementation 'com.google.android.gms:play-services-maps:11.8.0'</span><span id="224a" class="me jx hu lz b fv mj mg l mh mi">// Retrofit dependencies<br/>implementation 'com.squareup.retrofit2:retrofit:2.3.0'<br/>implementation 'com.squareup.retrofit2:converter-scalars:2.3.0'</span></pre><p id="e0f5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">同步您的Gradle文件，以便可以下载库并使其可用。</p><h1 id="34d1" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">构建我们的布局</h1><p id="9e70" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">打开<code class="eh lw lx ly lz b">activity_main.xml</code>并粘贴这个:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="13c4" class="me jx hu lz b fv mf mg l mh mi">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;FrameLayout xmlns:android="<a class="ae lq" href="http://schemas.android.com/apk/res/android" rel="noopener ugc nofollow" target="_blank">http://schemas.android.com/apk/res/android</a>"<br/>    xmlns:tools="<a class="ae lq" href="http://schemas.android.com/tools" rel="noopener ugc nofollow" target="_blank">http://schemas.android.com/tools</a>"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:orientation="vertical"&gt;<br/>    &lt;fragment xmlns:android="<a class="ae lq" href="http://schemas.android.com/apk/res/android" rel="noopener ugc nofollow" target="_blank">http://schemas.android.com/apk/res/android</a>"<br/>        xmlns:tools="<a class="ae lq" href="http://schemas.android.com/tools" rel="noopener ugc nofollow" target="_blank">http://schemas.android.com/tools</a>"<br/>        android:layout_marginTop="50dp"<br/>        android:id="@+id/map"<br/>        android:name="com.google.android.gms.maps.SupportMapFragment"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        tools:context="com.example.mapwithmarker.MapsMarkerActivity" /&gt;<br/>    &lt;Button<br/>        android:id="@+id/simulateButton"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:text="Simulate" /&gt;<br/>&lt;/FrameLayout&gt;</span></pre><p id="3e2a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码片段中，我们有一个包含地图和按钮的片段。</p><h1 id="8641" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">设置Google地图API密钥</h1><p id="05ce" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">此时，您应该已经获得了API密钥。你可以按照这里<a class="ae lq" href="https://developers.google.com/maps/documentation/android-api/signup" rel="noopener ugc nofollow" target="_blank">的步骤</a>去拿。我们现在想用我们的密钥配置应用程序。打开你的<code class="eh lw lx ly lz b">strings.xml</code>文件并粘贴进去。这位于<code class="eh lw lx ly lz b">name-of-project/app/src/main/res/values</code>:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="72ff" class="me jx hu lz b fv mf mg l mh mi">&lt;resources&gt;<br/>    &lt;!-- ... --&gt;<br/>    &lt;string name="google_maps_key"&gt;GOOGLE_MAPS_KEY&lt;/string&gt;<br/>&lt;/resources&gt;</span></pre><blockquote class="ir is it"><p id="73b8" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️将</em> <code class="eh lw lx ly lz b"><em class="hu">GOOGLE_MAPS_KEY</em></code> <em class="hu">占位符替换为谷歌的实际关键字。</em></p></blockquote><p id="cc1d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">该文件包含应用程序开发过程中使用的所有字符串。应用程序中的所有原始字符串都保存在这里。当需要将您的应用程序翻译成多种语言时，这是必需的。</p><p id="29e6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，打开<code class="eh lw lx ly lz b">AndroidManifest.xml</code>文件并将它们粘贴到<code class="eh lw lx ly lz b">&lt;application&gt;</code>标签下:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="4593" class="me jx hu lz b fv mf mg l mh mi">&lt;meta-data<br/>    android:name="com.google.android.gms.version"<br/>    android:value="<a class="ae lq" href="http://twitter.com/integer/google_play_services_vers" rel="noopener ugc nofollow" target="_blank">@integer/google_play_services_vers</a>ion" /&gt;<br/>&lt;meta-data<br/>    android:name="com.google.android.geo.API_KEY"<br/>    android:value="<a class="ae lq" href="http://twitter.com/string/google_maps_key" rel="noopener ugc nofollow" target="_blank">@string/google_maps_key</a>" /&gt;</span></pre><p id="f595" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">有了这个，我们的应用程序就知道如何以及在哪里获取我们的密钥。</p><h1 id="f9d0" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">安装改装</h1><p id="fd0d" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">我们已经有了作为依赖项的改型，但是我们还需要两样东西——一个显示要访问的端点/路由的接口和我们的改型对象。首先创建一个新的Kotlin文件名<code class="eh lw lx ly lz b">ApiInterface.kt</code>并粘贴它:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="c12a" class="me jx hu lz b fv mf mg l mh mi">import okhttp3.RequestBody<br/>import retrofit2.Call<br/>import retrofit2.http.Body<br/>import retrofit2.http.POST<br/>interface ApiInterface {<br/>    <a class="ae lq" href="http://twitter.com/POST" rel="noopener ugc nofollow" target="_blank">@POST</a>("/simulate")<br/>    fun sendCoordinates(<a class="ae lq" href="http://twitter.com/Body" rel="noopener ugc nofollow" target="_blank">@Body</a> coordinates: RequestBody): Call&lt;String&gt;<br/>}</span></pre><p id="0e41" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">因为我们在这个演示中只提出一个请求，所以我们将改造对象的范围限制在<code class="eh lw lx ly lz b">MainActivity.kt</code>类。这意味着我们将在一个类中为它创建一个函数。将此函数粘贴到类中:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="5f44" class="me jx hu lz b fv mf mg l mh mi">fun getRetrofitObject(): ApiInterface {<br/>    val httpClient = OkHttpClient.Builder()<br/>    val builder = Retrofit.Builder()<br/>            .baseUrl("<a class="ae lq" href="http://10.0.3.2:4000/" rel="noopener ugc nofollow" target="_blank">http://10.0.3.2:4000/</a>")<br/>            .addConverterFactory(ScalarsConverterFactory.create())<br/>    val retrofit = builder<br/>            .client(httpClient.build())<br/>            .build()<br/>    return retrofit.create(ApiInterface::class.java)<br/>}</span></pre><p id="a4b4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我使用了一个Genymotion模拟器，它的本地主机地址是<code class="eh lw lx ly lz b">10.0.3.2</code>。</p><p id="4f7f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">将互联网权限添加到<code class="eh lw lx ly lz b">AndroidManifest.xml</code>文件:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="1d3d" class="me jx hu lz b fv mf mg l mh mi">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</span></pre><h1 id="a284" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">配置我们的地图并获得实时更新</h1><p id="4ad2" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">为了初始化和使用映射，我们的<code class="eh lw lx ly lz b">MainActivity.kt</code>类必须实现<code class="eh lw lx ly lz b">OnMapReadyCallback</code>接口并覆盖<code class="eh lw lx ly lz b">onMapReady</code>方法。我们还需要设置Pusher来实时监听事件和接收模拟坐标。打开你的<code class="eh lw lx ly lz b">MainActivity.kt</code>并粘贴这个:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="0009" class="me jx hu lz b fv mf mg l mh mi">import android.support.v7.app.AppCompatActivity<br/>import android.os.Bundle<br/>import android.util.Log<br/>import com.google.android.gms.maps.*<br/>import com.google.android.gms.maps.model.MarkerOptions<br/>import com.google.android.gms.maps.model.LatLng<br/>import com.pusher.client.Pusher<br/>import com.pusher.client.PusherOptions<br/>import kotlinx.android.synthetic.main.activity_main.*<br/>import okhttp3.MediaType<br/>import okhttp3.OkHttpClient<br/>import org.json.JSONObject<br/>import retrofit2.Call<br/>import retrofit2.Callback<br/>import retrofit2.Response<br/>import retrofit2.Retrofit<br/>import retrofit2.converter.scalars.ScalarsConverterFactory<br/>import okhttp3.RequestBody<br/>import com.google.android.gms.maps.model.CameraPosition<br/>import com.google.android.gms.maps.model.Marker</span><span id="bcf6" class="me jx hu lz b fv mj mg l mh mi">class MainActivity : AppCompatActivity(), OnMapReadyCallback {</span><span id="ca48" class="me jx hu lz b fv mj mg l mh mi">    private lateinit var markerOptions:MarkerOptions</span><span id="cc2c" class="me jx hu lz b fv mj mg l mh mi">    private lateinit var marker:Marker</span><span id="92f0" class="me jx hu lz b fv mj mg l mh mi">    private lateinit var cameraPosition:CameraPosition</span><span id="bfde" class="me jx hu lz b fv mj mg l mh mi">    var defaultLongitude = -122.088426</span><span id="d84a" class="me jx hu lz b fv mj mg l mh mi">    var defaultLatitude  = 37.388064</span><span id="832c" class="me jx hu lz b fv mj mg l mh mi">    lateinit var googleMap:GoogleMap</span><span id="2fcc" class="me jx hu lz b fv mj mg l mh mi">    lateinit var pusher:Pusher</span><span id="8615" class="me jx hu lz b fv mj mg l mh mi">    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)</span><span id="90ca" class="me jx hu lz b fv mj mg l mh mi">        setContentView(R.layout.activity_main)</span><span id="053a" class="me jx hu lz b fv mj mg l mh mi">        markerOptions = MarkerOptions()</span><span id="1837" class="me jx hu lz b fv mj mg l mh mi">        val latLng = LatLng(defaultLatitude,defaultLongitude)</span><span id="8724" class="me jx hu lz b fv mj mg l mh mi">        markerOptions.position(latLng)</span><span id="f88a" class="me jx hu lz b fv mj mg l mh mi">        cameraPosition = CameraPosition.Builder()<br/>                .target(latLng)<br/>                .zoom(17f).build()<br/>    }</span><span id="9665" class="me jx hu lz b fv mj mg l mh mi">    override fun onMapReady(googleMap: GoogleMap?) {<br/>        this.googleMap = googleMap!!</span><span id="b9f8" class="me jx hu lz b fv mj mg l mh mi">        marker = googleMap.addMarker(markerOptions)<br/>        googleMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition))<br/>    }<br/>}</span></pre><p id="8ca7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们首先创建了一些类变量来保存我们的初始坐标和其他地图工具，比如相机位置和标记位置。我们在<code class="eh lw lx ly lz b">onCreate</code>函数中初始化了它们。接下来，我们向模拟按钮添加了一个点击监听器。</p><p id="8948" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来要做的事情还是在<code class="eh lw lx ly lz b">MainActivity.kt</code>类。在<code class="eh lw lx ly lz b">onCreate</code>方法中，粘贴这个:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="15ae" class="me jx hu lz b fv mf mg l mh mi">simulateButton.setOnClickListener {<br/>    callServerToSimulate()<br/>}</span></pre><p id="d1d5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">点击按钮时，调用<code class="eh lw lx ly lz b">callServerToSimulate</code>函数。像这样在类内创建一个函数<code class="eh lw lx ly lz b">callServerToSimulate</code>:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="922a" class="me jx hu lz b fv mf mg l mh mi">private fun callServerToSimulate() {<br/>    val jsonObject = JSONObject()<br/>    jsonObject.put("latitude",defaultLatitude)<br/>    jsonObject.put("longitude",defaultLongitude)<br/>    val body = RequestBody.create(<br/>        MediaType.parse("application/json"), <br/>        jsonObject.toString()<br/>    )<br/>    getRetrofitObject().sendCoordinates(body).enqueue(object:Callback&lt;String&gt;{<br/>        override fun onResponse(call: Call&lt;String&gt;?, response: Response&lt;String&gt;?) {<br/>            Log.d("TAG",response!!.body().toString())<br/>        }<br/>        override fun onFailure(call: Call&lt;String&gt;?, t: Throwable?) {<br/>            Log.d("TAG",t!!.message)<br/>        }<br/>    })<br/>}</span></pre><p id="da2b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在这个函数中，我们将初始坐标发送到服务器。然后，服务器生成二十个类似于最初发送的坐标，并使用Pusher将它们发送到通道<code class="eh lw lx ly lz b">my-channel</code>，触发<code class="eh lw lx ly lz b">new-values</code>事件。</p><p id="4156" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们用地图的视图ID创建并初始化一个<code class="eh lw lx ly lz b">SupportMapFragment</code>对象:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="1e22" class="me jx hu lz b fv mf mg l mh mi">val mapFragment = supportFragmentManager.findFragmentById(R.id.map)  as  SupportMapFragment<br/>mapFragment.getMapAsync(this)<br/>setupPusher()</span></pre><p id="e7af" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来将<code class="eh lw lx ly lz b">setupPusher</code>函数添加到该类中，它看起来应该是这样的:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="2f7e" class="me jx hu lz b fv mf mg l mh mi">private fun setupPusher() {<br/>    val options = PusherOptions()<br/>    options.setCluster(PUSHER_CLUSTER)<br/>    pusher = Pusher(PUSHER_API_KEY, options)</span><span id="1696" class="me jx hu lz b fv mj mg l mh mi">    val channel = pusher.subscribe("my-channel")</span><span id="218d" class="me jx hu lz b fv mj mg l mh mi">    channel.bind("new-values") { channelName, eventName, data -&gt;<br/>        val jsonObject = JSONObject(data)<br/>        val lat:Double = jsonObject.getString("latitude").toDouble()<br/>        val lon:Double =  jsonObject.getString("longitude").toDouble()<br/>        <br/>        runOnUiThread {<br/>            val newLatLng = LatLng(lat, lon)<br/>            marker.position = newLatLng<br/>            cameraPosition = CameraPosition.Builder()<br/>                    .target(newLatLng)<br/>                    .zoom(17f).build()<br/>            googleMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition))<br/>        }<br/>    }<br/>}</span></pre><p id="ab02" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们在这里初始化Pusher并监听坐标更新。当我们接收到任何更新时，我们更新我们的标记并将摄像机视图移向新的点。您需要用Pusher仪表盘上的按键和详细信息替换Pusher参数。</p><p id="b102" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后我们在类中分别调用<code class="eh lw lx ly lz b">onPause</code>和<code class="eh lw lx ly lz b">onResume</code>函数中的disconnect和connect函数。这些函数继承自父类<code class="eh lw lx ly lz b">AppCompatActivity</code>:</p><pre class="la lb lc ld fq ma lz mb mc aw md dt"><span id="4b3e" class="me jx hu lz b fv mf mg l mh mi">override fun onResume() {<br/>    super.onResume()<br/>    pusher.connect()<br/>}</span><span id="5d8b" class="me jx hu lz b fv mj mg l mh mi">override fun onPause() {<br/>    super.onPause()<br/>    pusher.disconnect()<br/>}</span></pre><h1 id="2d37" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">结论</h1><p id="25ae" class="pw-post-body-paragraph iu iv hu ix b iy ku ja jb jc kv je jf jt kw ji jj ju kx jm jn jv ky jq jr js hn dt translated">我们已经能够利用Pusher、Kotlin和谷歌地图API的力量来创建一个实时位置跟踪应用程序。希望你已经从教程中学到了一些东西，并且可以利用这些知识用Pusher和Kotlin构建漂亮的实时应用程序。</p><p id="ab44" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这篇文章最初出现在<a class="ae lq" href="https://pusher.com/tutorials/realtime-map-kotlin" rel="noopener ugc nofollow" target="_blank">推手</a>的博客上。</p></div></div>    
</body>
</html>