<html>
<head>
<title>7 tips for effective microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效微服务的7个技巧</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/7-tips-for-effective-microservices-113fb9beaa1?source=collection_archive---------21-----------------------#2018-05-16">https://medium.com/hackernoon/7-tips-for-effective-microservices-113fb9beaa1?source=collection_archive---------21-----------------------#2018-05-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fd6d308ff79e2d75d7f3778c499ff82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RV5PZIr_cnLif9hi."/></div></div></figure><p id="1f19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">设计良好的微服务可以让我们的生活变得更加轻松。从设计到开发到推广到生产，它可以帮助改善所有方面。虽然微服务已经存在多年，并且最佳实践也在不断发展，但是大规模处理微服务并不容易。对于刚接触微服务的团队来说，有时复杂性可能会让人不知所措。</p><p id="ce36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是充分利用微服务的一些简单技巧:</p><h2 id="7999" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak"> 1。每个请求都有一个请求标识/关联标识</strong></h2><p id="bcec" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">Request-id或correlation-id是分配给每个客户请求的唯一id。这有助于跟踪端到端的流动。虽然这似乎是一个微不足道的想法，但在实践中，这是非常有用的。它真正出彩的几个场景:a)调试b)测试c)使请求幂等</p><h2 id="5519" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak"> 2。维护接口的向后兼容性</strong></h2><p id="041f" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">同样，这似乎是一个非常琐碎和常识性的方法，但在实践中，当快速添加新功能时，这变得很困难。一个简单的元素重命名实际上会破坏向后兼容性。一些简单的规则会有所帮助:</p><p id="8cbc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">a)不允许从请求正文中删除强制元素</p><p id="7460" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">b)不允许在以后的版本中强制使用新的请求元素</p><p id="4672" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">c)为不再有效的元素定义标准折旧流程</p><h2 id="5d51" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak"> 3。有一个集中的记录系统</strong></h2><p id="ac96" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">微服务中的测试和调试要难得多。有一个单一的地方来可视化正在发生的事情真的很有帮助。虽然每个应用程序可能记录不同种类的内容，但是定义每个服务必须记录的最少公共信息是很重要的。使用request-id跨服务搜索日志的能力在调试会话期间非常有用。</p><h2 id="f69e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak"> 4。实现等幂和重试</strong></h2><p id="f946" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">一个好的设计的关键是理解系统的局限性并接受它。分布式系统容易出现许多故障点，一种简单的处理方法是等幂。幂等性帮助客户端在失败的情况下进行重试，而不会错误地影响系统状态。幂等性在许多情况下可能不是微不足道的，在设计时可能需要认真考虑。</p><h2 id="0ba0" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak"> 5。注意语言限制</strong></h2><p id="5b08" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">微服务架构的一个关键优势是我们可以用不同的语言编写不同的服务，这为特定的工作选择正确的工具提供了灵活性。虽然这在大多数情况下都很有效，但我们仍然需要考虑并意识到这也会导致每一层对信息的不同解释。对于用Java编写的服务来说，像unsigned int(c++世界中非常流行的概念)这样的一些非常基本的概念可能会变得太有问题，因为在Java中不存在这个概念。</p><p id="9335" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，我们为服务间通信定制了序列化协议，它主要是在考虑C++的情况下构建的。后来Java中加入了新的服务。虽然大多数东西工作得相当顺利，但我们遇到了无符号int的问题，它在Java中被映射到int，导致整数溢出(翻转)。</p><h2 id="8189" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak"> 6。拥有单一服务来管理系统状态</strong></h2><p id="ab82" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">很多时候，为了提供更快、更流畅的体验，一些服务需要成功响应，即使实际的工作将在以后完成/处理。一个例子是，为了扩展系统，支付系统返回成功的响应，尽管卡上的实际收费将在以后发生。多个系统试图操纵系统状态有时会导致不一致。在这种情况下，正确管理状态很重要，明智的做法是只让一个服务来读/写/更新系统状态。</p><h2 id="a7e6" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak"> 7。在内存数据和数据库持久性之间取得平衡</strong></h2><p id="2156" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">对于经历不同状态的系统，例如支付系统，需要多个状态变化来提供特定的功能。其中许多可能分布在多个服务中，并且需要以某种形式存储修改后的状态。使用db作为持久层可能有助于一致性和事务性，但可能会导致更大规模的瓶颈。内存缓存可能有助于提高速度和规模，但维护事务性和可用性可能并不容易。这两种解决方案之间更好的平衡是成功的可扩展解决方案的关键。</p></div></div>    
</body>
</html>