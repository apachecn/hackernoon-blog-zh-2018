<html>
<head>
<title>Optimizing Single-Page Applications: Top 3 Approaches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化单页应用程序:三大方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/optimizing-single-page-applications-top-3-approaches-3cf91b85a052?source=collection_archive---------8-----------------------#2018-05-17">https://medium.com/hackernoon/optimizing-single-page-applications-top-3-approaches-3cf91b85a052?source=collection_archive---------8-----------------------#2018-05-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/e92e58c524d09d0b68dfed55ba737a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hS2uGg93HOeAjZpTGRPBHw.jpeg"/></div></div></figure><div class=""/></div><div class="ab cl jc jd hc je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><p id="6430" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">在本教程中，我们将向您展示三种优化单页应用程序的好方法，并使用Webpack使其快速运行。</p><p id="c778" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">随着单页面应用程序的发展趋势，服务器端呈现已经开始失去其流行性。因为所有的逻辑都转移到了前端，所以它仍然主要是一种服务。这种方法现在非常流行，因为它有助于开发人员设计一个可理解的架构，并保持清晰的扩展和支持能力。但是没有什么是完美的。</p><p id="14dc" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">SPAs的一个主要缺点是加载速度慢。第一次加载包含整个应用程序的单个包文件需要时间(特别是对于大型应用程序)，因为没有人喜欢等待，所以您可能会因此失去客户。但这实际上不再是Webpack的问题了。Webpack可以非常灵活地配置，允许您在大多数情况下摆脱加载缓慢的问题。在本教程中，我们将使用Webpack 3.11.0。</p><p id="678b" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">阅读我们的<a class="ae kh" href="https://steelkiwi.com/projects/improving-website-performance-for-a-photo-blogging/" rel="noopener ugc nofollow" target="_blank">案例研究图片博客</a>，了解我们如何优化网站性能和提高页面加载速度。</p><h1 id="d441" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">通过使用Webpack将包分成几个部分来加速应用程序的方法</h1><h1 id="b9e9" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">1.使用CommonsChunkPlugins插件</h1><p id="d60c" class="pw-post-body-paragraph jj jk if jl b jm lg jo jp jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg hn dt translated">这个插件由Webpack提供，允许您在一个文件中查找和存储常用的脚本。这对单页和多页应用程序都非常有用。</p><p id="ecda" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl ig"> CommonsChunkPlugins </strong>找到并剪切掉常用的脚本，把你的脚本拆分出来，产生一个<strong class="jl ig"> common.js </strong>文件，让整个应用更轻便。</p><p id="44a3" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">假设我们有以下项目:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/41ac81cbd2f02a37c3948d78fc684bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m-qDKgg4H7OetXOf.png"/></div></div></figure><p id="b043" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这里我们有<strong class="jl ig"> index.js，profile.js，</strong>和<strong class="jl ig"> user.js. </strong>假设<strong class="jl ig"> index.js </strong>和<strong class="jl ig"> profile.js </strong>需要<strong class="jl ig"> user.js. </strong></p><p id="64a5" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们希望index.js和profile.js分别在不同的页面上工作。通常，我们会这样写:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="974f" class="lv kj if lr b fv lw lx l ly lz">const webpack = require('webpack');<br/><br/>module.exports = {<br/><br/>    context: __dirname + '/scripts',<br/><br/>    entry: {<br/>        index: './index',<br/>        profile: './profile'<br/>    },<br/><br/>    output: {<br/>        path: __dirname + '/app/public',<br/>        filename: '[name].js'<br/>    }<br/><br/>};</span></pre><p id="2953" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这将在公共文件夹中产生以下结构:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/55acaf3079d7363fffb9146f44bbe602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gSihTiRcaApAyo_H.png"/></div></div></figure><p id="e623" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">如果index.js和profile.js中都需要user.js，那么在这种配置下，Webpack会将user.js插入到这两个文件中，并且最终应用程序中的代码会重复，这并不好。我们希望将常用的部分放在一个单独的文件中，这样浏览器就能够加载并缓存该文件。</p><p id="efec" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">让我们用<strong class="jl ig"> CommonsChunkPlugins </strong>对此进行优化。为此，我们的Webpack配置将是:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="a1c5" class="lv kj if lr b fv lw lx l ly lz">const webpack = require('webpack');<br/><br/>module.exports = {<br/><br/>    context: __dirname + '/app/scripts',<br/><br/>    entry: {<br/>        index: './index.js',<br/>        profile: './profile.js'<br/>    },<br/><br/>    output: {<br/>        path: __dirname + '/app/public',<br/>        filename: '[name].js'<br/>    },<br/><br/>    plugins: [<br/>        new webpack.optimize.CommonsChunkPlugin({<br/>            name: 'common'<br/>        })<br/>    ]<br/><br/>};</span></pre><p id="0a93" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">让我们看看发生了什么变化:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/ac2a4ce906ff9a5aeb773aa1e71f1978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PJWXdQqpYebfDLeQ.png"/></div></div></figure><p id="0b66" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">现在可以看到出现了一个<strong class="jl ig"> common.js </strong>文件。这个文件包含了我们所有脚本的所有常见的<strong class="jl ig"> require() </strong>。此外，文件的大小已经大大减少。</p><p id="8320" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">当然，一个真实的项目会更复杂，所以当你为应用程序的不同部分使用不同的库时，你会发现这个插件非常有用。</p><p id="a29f" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">它也是非常可配置的，你可以在同一个应用程序中多次使用它。</p><p id="d899" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">https://webpack.js.org/plugins/commons-chunk-plugin/<a class="ae kh" href="https://webpack.js.org/plugins/commons-chunk-plugin/" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="b79d" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">2.动态需求()</h1><p id="3741" class="pw-post-body-paragraph jj jk if jl b jm lg jo jp jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg hn dt translated">无论是否会用到，加载所有的功能都不是一个好主意。我们更喜欢根据要求装载东西。当您的应用程序变得非常大时，您绝对应该考虑拆分您的脚本并在需要时加载部分。在JavaScript实现自动化之前，我们需要开发自己的方法，将带有<code class="eh ma mb mc lr b">&lt;script&gt;</code>标签的新文件动态插入到<strong class="jl ig">文档</strong>中。幸运的是，Webpack现在可以服务于这个目的，而且是相当自动化的。但是记住，普通的<strong class="jl ig"> require() </strong>不允许你基于规则加载文件。Webpack会简单地将它添加到包中或者全部删除。</p><p id="19ca" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">所以如果你写下这样的话:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="7e04" class="lv kj if lr b fv lw lx l ly lz">const location = window.location.pathname;<br/><br/>switch(location) {<br/><br/>    case 'user':<br/>        const user = require('./user');<br/>        user();<br/>        break;<br/><br/>    case 'profile':<br/>        const profile = require('./profile');<br/>        profile();<br/>        break;<br/><br/>    default: alert('No match'); break;<br/><br/>}</span></pre><p id="b75d" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">您可能期望文件会在<strong class="jl ig"> request()，</strong>上动态加载，但是它们不会。相反，这将创建一个包含所有必需脚本的文件，而不考虑规则，因为Webpack不会分析<strong class="jl ig">开关</strong>和规则本身。</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/2153a478885f35978fac672e389f67ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mqep899WJo6dxtYj.png"/></div></div></figure><p id="9474" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">幸运的是，出于这个目的，Webpack提供了一个原始的require with<strong class="jl ig">assure()</strong>函数，其语法如下:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="e579" class="lv kj if lr b fv lw lx l ly lz">const location = window.location.pathname;<br/><br/>switch(location) {<br/><br/>    case 'user':<br/>        require.ensure(['./user'], function(require) {<br/>            const user = require('./user');<br/>            user();<br/>        });<br/>        break;<br/><br/>    case 'profile':<br/>        require.ensure(['./profile'], function(require) {<br/>            const profile = require('./profile');<br/>            profile();<br/>        });<br/>        break;<br/><br/>    default: alert('No match'); break;<br/><br/>}</span></pre><p id="e78b" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">组装后，我们得到:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/080ea7f3c2b15b730f4ff8037a60078c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zwQpwS-DmN38NpNZ.png"/></div></div></figure><p id="a90e" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">Webpack创建块文件<strong class="jl ig"> 0.js </strong>和<strong class="jl ig"> 1.js </strong>。Main.js将不包含这些文件，它们将只在请求时加载——在我们的例子中，如果文件名与URL匹配。因为它们在服务器上，所以不要忘记在config中为outputparameter指定publicpath。</p><p id="be85" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们还将为使用<strong class="jl ig">路由器</strong>库来管理渲染的<strong class="jl ig"> React </strong>开发者描述这种情况。如果组件与URL的某个部分匹配，那么加载带有组件的文件会很棒。问题是没有方便的方法来使用<code class="eh ma mb mc lr b">&lt;Route&gt;</code>组件中的<strong class="jl ig">require . assure()</strong>。为此，我们使用react-loadable<a class="ae kh" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank">(https://github.com/jamiebuilds/react-loadable</a>)。有了这个库，您的路线将如下所示:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="a9b4" class="lv kj if lr b fv lw lx l ly lz">&lt;Router&gt;<br/>    &lt;Route path="/profile" render={() =&gt; {<br/>        const Profile = Loadable({<br/>            loader: () =&gt; import('./profile'),<br/>            loading: Loading<br/>    });<br/>        return &lt;Profile/&gt;;<br/>    }}/&gt;<br/>&lt;/Router&gt;</span></pre><p id="ac59" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">此外，有时您可能喜欢这样写:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="e5d1" class="lv kj if lr b fv lw lx l ly lz">const location = window.location.pathname;<br/><br/>require.ensure(['/somepath/' + location], function(require) {<br/>    const script = require('/somepath/' + location);<br/>    script();<br/>});</span></pre><p id="ac70" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这种情况称为动态需求。因为文件名存储在一个变量中，所以对于Webpack来说，检测该文件并创建块太复杂了。您需要用静态的<strong class="jl ig">require . assure()</strong>创建一个中间文件，或者使用<strong class="jl ig">捆绑加载器</strong>。我们更倾向于第二种选择:【https://github.com/webpack-contrib/bundle-loader T4】</p><h1 id="236a" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">3.分析您的构建</h1><p id="f060" class="pw-post-body-paragraph jj jk if jl b jm lg jo jp jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg hn dt translated">在这一节中，我们将向您展示(或提醒您)如何使用Webpack工具进行分析。</p><p id="435a" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">首先，使用键<strong class="jl ig">显示模块</strong>。这将显示有关您的版本存储模块的方式的信息。如果我们在之前的例子中使用<strong class="jl ig"> CommonsChunkPlugins </strong>，它将显示以下内容:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/e4c0a899d3867e0b5bbd297e5a8cde21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mCN2S7d9kOFqdItj.png"/></div></div></figure><p id="5dd2" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">你可以看到:</p><p id="3d8d" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl ig"> profile.js </strong>转到了<strong class="jl ig"> {0} </strong>块，也就是<strong class="jl ig"> profile.js </strong>条目</p><p id="d6d9" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl ig"> index.js </strong>到了<strong class="jl ig"> {1} </strong> chunk，也就是<strong class="jl ig"> index.js </strong>(也是一个单独的条目)</p><p id="cf88" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl ig"> user.js </strong>转到了<strong class="jl ig"> {2} </strong>块，这是<strong class="jl ig"> common.js </strong>，因为这个脚本同时被<strong class="jl ig"> index.js </strong>和<strong class="jl ig"> profile.js </strong>使用</p><p id="c007" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">但是你可以用<strong class="jl ig">-显示模块——verbose更深入。这个命令还会告诉你为什么构建是这样组装的。</strong></p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/1d6638555c19b2d1fc11cb7db65a1a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n9lzEErFM_fzuzH-.png"/></div></div></figure><p id="5795" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">下面是关于为什么我们得到这样的<strong class="jl ig"> common.js </strong>以及它包含了什么的详细信息。</p><p id="0f92" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们总是使用这个命令来跟踪我们的构建，并确保它尽可能的小并且不包含重复。</p><p id="0f97" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">在大多数情况下，这就足够了。但是对于非常大的项目，其中有上百个模块，从控制台读取所有内容并分析整个应用程序及其所有依赖项是很烦人的。幸运的是，出于这个目的，Webpack有一个带有图形界面的分析器。要使用它，我们需要首先创建一个JSON格式的批量报告:</p><p id="50b2" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">要使用它，我们需要首先创建一个JSON格式的批量报告:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/63fdb45a4abefe7aebd8991b3aba9969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CMZiDTYUQu-TxET2.png"/></div></div></figure><p id="5a8b" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这个<strong class="jl ig"> report.json </strong>文件包含关于您的构建的所有必要信息。</p><p id="f91c" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">接下来，去<a class="ae kh" href="http://webpack.github.io/analyse" rel="noopener ugc nofollow" target="_blank">http://webpack.github.io/analyse</a>上传<strong class="jl ig"> report.json </strong>。</p><p id="c8c0" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">最后你会得到这个:</p><figure class="lm ln lo lp fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/3feddea1284910e68f75f613c15ba13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IhAguO5irfIrtNY2.png"/></div></div></figure><p id="9c62" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这个工具将向您显示关于模块、块、资产、警告和错误的信息。</p><p id="2115" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">该分析有助于您避免重复，并保持一切按预期运行。</p><p id="68e8" class="pw-post-body-paragraph jj jk if jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们也欢迎您访问我们的<a class="ae kh" href="https://steelkiwi.com/projects/" rel="noopener ugc nofollow" target="_blank">案例研究页面。</a>在这里，您可以看到我们如何实施技术解决方案来解决业务问题。您也可以向我们的<a class="ae kh" href="https://steelkiwi.com/contacts/" rel="noopener ugc nofollow" target="_blank">销售团队</a>咨询所有相关问题。</p></div></div>    
</body>
</html>