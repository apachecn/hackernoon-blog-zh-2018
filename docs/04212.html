<html>
<head>
<title>Reason in a Nutshell — Getting Started Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之——入门指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reason-in-a-nutshell-getting-started-guide-78c05ebc5d4?source=collection_archive---------21-----------------------#2018-05-17">https://medium.com/hackernoon/reason-in-a-nutshell-getting-started-guide-78c05ebc5d4?source=collection_archive---------21-----------------------#2018-05-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e43e4d228d6a91264001fdbd82d50cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CbiujFkJkI1UPcVgwKt2cA.png"/></div></div></figure><p id="0136" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本教程旨在提供一个全面的，但相对较短的理性介绍。</p><p id="c128" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank">原因</a>是一种建立在<a class="ae ka" href="https://ocaml.org/" rel="noopener ugc nofollow" target="_blank"> OCaml </a>之上的编程语言。它提供了功能性和面向对象的特性，具有类型安全性，并关注性能。它是在<a class="ae ka" href="https://hackernoon.com/tagged/facebook" rel="noopener ugc nofollow" target="_blank">脸书</a>创建的。它的语法类似于<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>。其目的是使与JavaScript的互操作和JavaScript程序员的采用更容易。Reason可以同时访问JavaScript和OCaml生态系统。OCaml创建于1996年。它是一种带有推断类型的函数式编程语言。</p><p id="22ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">原因网站包含一个<a class="ae ka" href="https://reasonml.github.io/en/try.html" rel="noopener ugc nofollow" target="_blank">在线游乐场</a>。它允许使用这种语言，看看生成的JavaScript是什么样子。它还可以从OCaml转换为Reason。</p><h1 id="4b72" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为什么</h1><ol class=""><li id="7b5f" class="kz la hu je b jf lb jj lc jn ld jr le jv lf jz lg lh li lj dt translated">在JavaScript类型注释中，林挺或统一格式作为外部依赖提供，如Flow、TypeScript、ESLint或appearlier。Reason提供了这些现成的特性。这使得开发过程更加简化和方便。</li><li id="af7d" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">Reason为React with <a class="ae ka" href="https://reasonml.github.io/reason-react/" rel="noopener ugc nofollow" target="_blank"> ReasonReact </a>提供支持。它还支持现成的JSX语法(React中使用的类似HTML的语法)。</li><li id="ce52" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">Reason也有能力生成本地二进制文件。生成的代码是高性能的。没有虚拟机开销。它提供了一个简化部署过程的二进制文件。</li></ol><h1 id="bcf3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">它是如何工作的</h1><p id="d9cd" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">Reason编译成OCaml的抽象语法树。这使得理性成为一个透明的东西。OCaml不能直接在浏览器中运行。AST可以转换成各种目标。BuckleScript可用于将AST编译成JavaScript。它还提供了OCaml和JavaScript生态系统之间的互操作。</p><p id="a53c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">BuckleScript非常快，可以生成可读的JavaScript。它还提供了外部函数接口(FFI ),允许与现有的JavaScript库进行互操作。检查<a class="ae ka" href="https://github.com/neonsquare/bucklescript-benchmark" rel="noopener ugc nofollow" target="_blank"> BuckleScript基准</a>。在脸书，Messanger团队使用BuckleScript，在谷歌，WebAssembly spec interpreter使用BuckleScript。点击此处查看<a class="ae ka" href="http://bloomberg.github.io/bucklescript/js-demo/" rel="noopener ugc nofollow" target="_blank"> Bucklescript演示</a>。BuckleScript是由张洪波创造的。</p><h1 id="246c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">你好原因</h1><p id="a673" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我们将使用BuckleScript来生成一个Reason项目。该工具提供了称为<code class="eh ls lt lu lv b">themes</code>的现成项目模板。</p><p id="5bcb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从全球安装<code class="eh ls lt lu lv b">bs-platform</code>开始:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="40c1" class="me kc hu lv b fv mf mg l mh mi">npm install -g bs-platform</span></pre><p id="bdd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在可以使用由<code class="eh ls lt lu lv b">bs-platform</code>提供的<code class="eh ls lt lu lv b">bsb</code>二进制来生成一个项目支架。我们将使用<code class="eh ls lt lu lv b">basic-reason</code>模板从最基本的原因项目结构开始。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="68f7" class="me kc hu lv b fv mf mg l mh mi">bsb -init reason-1 -theme basic-reason </span><span id="313f" class="me kc hu lv b fv mj mg l mh mi">Making directory reason-1 <br/>Symlink bs-platform in /Users/zaiste/code/reason-1</span></pre><p id="e96a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是通过BuckleScript从<code class="eh ls lt lu lv b">basic-reason</code>模板生成的原因目录结构:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="bd67" class="me kc hu lv b fv mf mg l mh mi">. <br/>├── README.md <br/>├── bsconfig.json <br/>├── lib <br/>├── node_modules <br/>├── package.json <br/>└── src <br/>└── Demo.re</span></pre><p id="9ccb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ls lt lu lv b">bsconfig.json</code>包含原因项目的BuckleScript配置。它允许通过<code class="eh ls lt lu lv b">sources</code>指定要编译的文件，通过<code class="eh ls lt lu lv b">bs-dependencies</code>指定BuckleScript依赖项，编译器的附加标志等等。</p><p id="ceee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一步是构建项目。这将采用Reason代码，并通过BuckleScript来生成JavaScript。默认情况下，编译器会将Node.js作为目标。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="2168" class="me kc hu lv b fv mf mg l mh mi">npm run build </span><span id="a7bc" class="me kc hu lv b fv mj mg l mh mi">&gt; reason-1@0.1.0 build /Users/zaiste/code/reason-1 <br/>&gt; bsb -make-world ninja: Entering directory `lib/bs' <br/>[3/3] Building src/Demo.mlast.d <br/>[1/1] Building src/Demo-MyFirstReasonml.cmj</span></pre><p id="705d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们可以通过对BuckleScript生成的文件使用<code class="eh ls lt lu lv b">node</code>来运行我们的应用程序。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="f9b8" class="me kc hu lv b fv mf mg l mh mi">node src/Demo.bs.js </span><span id="b12e" class="me kc hu lv b fv mj mg l mh mi">Hello, BuckleScript and Reason!</span></pre><h1 id="f7c4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">语法101</h1><p id="d8a2" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">在这一节中，我将回顾我发现的奇特的、新的或不同的语法元素。</p><h1 id="a63d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">模块</h1><p id="8b0a" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">按理说，文件是模块。JavaScript或类似的编程语言中没有<code class="eh ls lt lu lv b">require</code>或<code class="eh ls lt lu lv b">import</code>语句。模块定义必须以模块名为前缀才能在外部工作。这个特性来自OCaml。因此，您可以在文件系统中自由移动模块文件，而无需修改代码。</p><h1 id="acd1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">功能</h1><p id="fca8" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">使用<code class="eh ls lt lu lv b">let</code>和<code class="eh ls lt lu lv b">=&gt;</code>定义功能。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="5e1c" class="me kc hu lv b fv mf mg l mh mi">let greet = name =&gt; <br/>  Js.log("Hello, " ++ name "!"); </span><span id="da46" class="me kc hu lv b fv mj mg l mh mi">greet("Zaiste");</span></pre><p id="ca6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ls lt lu lv b">++</code>操作符用于连接字符串。</p><p id="3dcb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">函数的输入参数可以被标记。这使得函数调用更加明确:传入的值不再需要遵循函数定义中的参数顺序。在参数名前面加上<code class="eh ls lt lu lv b">~</code>会使其带有标签。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="91af" class="me kc hu lv b fv mf mg l mh mi">let greet = (~name, ~location) =&gt; <br/>  Js.log("Hello, " ++ name "! You're in " ++ location); </span><span id="a57c" class="me kc hu lv b fv mj mg l mh mi">greet(~location="Vienna", ~name="Zaiste")</span></pre><h1 id="6575" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">数据结构</h1><h2 id="f78e" class="me kc hu bd kd mk ml mm kh mn mo mp kl jn mq mr kp jr ms mt kt jv mu mv kx mw dt translated">变体</h2><p id="c9c1" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated"><a class="ae ka" href="https://en.wikipedia.org/wiki/Tagged_union" rel="noopener ugc nofollow" target="_blank">变量</a>是一种数据结构，它保存一组固定值中的一个值。这也称为标记或不相交的联合或代数数据类型。变体中的每种情况都必须大写。可选地，它可以接收参数。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="2543" class="me kc hu lv b fv mf mg l mh mi">type animal = <br/>| Dog <br/>| Cat <br/>| Bird;</span></pre><h2 id="77ec" class="me kc hu bd kd mk ml mm kh mn mo mp kl jn mq mr kp jr ms mt kt jv mu mv kx mw dt translated">记录</h2><p id="4f53" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">这是一项记录</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="f3e4" class="me kc hu lv b fv mf mg l mh mi">let p = { <br/>  name: "Zaiste", <br/>  age: 13 <br/>}</span></pre><p id="3494" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记录需要显式类型定义。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="0ab0" class="me kc hu lv b fv mf mg l mh mi">type person = { <br/>  name: string, <br/>  age: int <br/>};</span></pre><p id="201a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在模块的范围内，类型将被继承:<code class="eh ls lt lu lv b">p</code>绑定将被识别为<code class="eh ls lt lu lv b">person</code>类型。在模块之外，您可以通过在类型前面加上文件名来引用它。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="7a2d" class="me kc hu lv b fv mf mg l mh mi">let p: Person.person = { <br/>  name: 'Sean', <br/>  age: 12 <br/>};</span></pre><p id="dac3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">按照惯例，为每种类型创建一个模块，并将该类型命名为<code class="eh ls lt lu lv b">t</code>以避免重复，即<code class="eh ls lt lu lv b">Person.t</code>而不是<code class="eh ls lt lu lv b">Person.person</code>。</p><h1 id="a4bc" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">异步编程和承诺</h1><p id="b3a7" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">通过BuckleScript有一个对承诺的内置支持，作为<code class="eh ls lt lu lv b">JS.Promise</code>模块提供。下面是一个使用<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>进行API调用的例子:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="f3cd" class="me kc hu lv b fv mf mg l mh mi">Js.Promise.( <br/>  Fetch.fetch(endpoint) <br/>  |&gt; then_(Fetch.Response.json) <br/>  |&gt; then_(json =&gt; doSomethingOnResponse(json) |&gt; resolve) <br/>)</span></pre><p id="f573" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你需要使用<code class="eh ls lt lu lv b">then_</code>，因为<code class="eh ls lt lu lv b">then</code>是OCaml中的保留字。</p><h1 id="14d2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">模式匹配</h1><p id="6cd6" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">模式匹配是一种基于所提供值的形状的调度机制。按理说，模式匹配是用<code class="eh ls lt lu lv b">switch</code>语句实现的。它可以用于变体类型或作为析构机制。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="b1d8" class="me kc hu lv b fv mf mg l mh mi">switch pet { <br/>| Dog =&gt; "woof" <br/>| Cat =&gt; "meow" <br/>| Bird =&gt; "chirp" <br/>};</span></pre><p id="f67d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用模式匹配来解构列表:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="c583" class="me kc hu lv b fv mf mg l mh mi">let numbers = ["1", "2", "3", "4"]; <br/>switch numbers { <br/>| [] =&gt; "Empty" <br/>| [n1] =&gt; "Only one number: " ++ n1 <br/>| [n1, n2] =&gt; "Only two numbers" <br/>| [n1, _, n3, ...rest] =&gt; "At least three numbers" <br/>};</span></pre><p id="efa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，我们可以用它来销毁记录</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="1f0a" class="me kc hu lv b fv mf mg l mh mi">let project = {<br/>  name: "Huncwot", <br/>  size: 101101, <br/>  forks: 42, <br/>  deps: [{name: "axios"}, {name: "sqlite3"}]<br/>} </span><span id="6f60" class="me kc hu lv b fv mj mg l mh mi">switch project { <br/>| {name: "Huncwot", deps} =&gt; "Matching by `name`" <br/>| {location, years: [{name: "axios"}, ...rest]} =&gt; "Matching by one of `deps`" <br/>| project =&gt; "Any other situation" }</span></pre><h1 id="6dc5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">可选值</h1><p id="4b13" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated"><code class="eh ls lt lu lv b">option()</code>是Reason中描述“可空”值的内置变量:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="4c59" class="me kc hu lv b fv mf mg l mh mi">type option('a) = None | Some('a);</span></pre><h1 id="e4cc" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">巴利安</h1><ul class=""><li id="a833" class="kz la hu je b jf lb jj lc jn ld jr le jv lf jz mx lh li lj dt translated"><code class="eh ls lt lu lv b">unit</code>表示“一无所有”</li><li id="fbf8" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz mx lh li lj dt translated"><code class="eh ls lt lu lv b">unit =&gt; unit</code>是不接受任何输入参数且不返回任何值的函数的签名；主要用于回调函数</li></ul><h1 id="78bf" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">理智地反应</h1><h1 id="8a62" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">你好，反应</h1><p id="8513" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated"><a class="ae ka" href="https://reasonml.github.io/reason-react/" rel="noopener ugc nofollow" target="_blank">React</a>是一个用于创建React应用程序的React内置特性。</p><p id="419d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们使用BuckleScript及其<code class="eh ls lt lu lv b">react</code>模板创建一个ReasonReact项目。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="e521" class="me kc hu lv b fv mf mg l mh mi">bsb -init reasonreact-1 -theme react</span></pre><p id="cedf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Reason团队建议将这种方法用于搭建ReasonReact项目。也可以使用带有<a class="ae ka" href="https://github.com/reasonml-community/reason-scripts" rel="noopener ugc nofollow" target="_blank">原因脚本</a>模板的yarn来获得更完整的起点。</p><p id="ef42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ReasonReact提供两种类型的组件:<code class="eh ls lt lu lv b">statelessComponent</code>和<code class="eh ls lt lu lv b">reducerComponent</code>。与无状态组件相反，reducer组件是有状态的，提供类似Redux的Redux。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="5d27" class="me kc hu lv b fv mf mg l mh mi">let s = ReasonReact.string </span><span id="83fe" class="me kc hu lv b fv mj mg l mh mi">let component = ReasonReact.statelessComponent("App"); </span><span id="5310" class="me kc hu lv b fv mj mg l mh mi">let make = (~message, _children) =&gt; { <br/>  ...component, <br/>  render: _self =&gt; <br/>    &lt;h1 class="header"&gt;(s(message))&lt;/h1&gt; <br/>};</span></pre><p id="be8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如前所述，<code class="eh ls lt lu lv b">~</code>指定了一个带标签的自变量来自由排序函数的输入参数。绑定名称中的<code class="eh ls lt lu lv b">_</code>告诉编译器该函数的主体中没有使用该参数。在<code class="eh ls lt lu lv b">component</code>旁边的扩展操作符(<code class="eh ls lt lu lv b">...</code>)意味着我们扩展了一个现有的组件。在这个例子中，我们还覆盖了<code class="eh ls lt lu lv b">render</code>函数。</p><p id="9cde" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Reason中的JSX比React中的更严格:我们需要用<code class="eh ls lt lu lv b">ReasonReact.string()</code>显式包装字符串。为了方便起见，我创建了一个名为<code class="eh ls lt lu lv b">s</code>的较短绑定，以便在JSX块中方便地使用它。</p><h1 id="4013" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构建重要的ReactReason应用程序</h1><p id="2857" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">让我们构建一个不仅仅显示预定义数据的ReactReason应用程序。我们将为趋势库创建一个GitHub查看器。目的是展示如何与外部API集成，如何管理状态以及如何使用React的生命周期方法。</p><p id="e8c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于这个例子的目的，我们将使用<a class="ae ka" href="https://github.com/reasonml-community/reason-scripts" rel="noopener ugc nofollow" target="_blank"> reason-scripts </a>来引导我们的reason项目。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="578e" class="me kc hu lv b fv mf mg l mh mi">yarn create react-app reasonreact-github --scripts-version reason-scripts</span></pre><p id="5fce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装依赖项:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="727c" class="me kc hu lv b fv mf mg l mh mi">cd reasonreact-github <br/>yarn</span></pre><p id="3b9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从以下内容开始:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="a433" class="me kc hu lv b fv mf mg l mh mi">yarn start</span></pre><p id="c226" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">存储库</strong>是这个应用程序的核心概念。让我们首先定义一个类型来描述这个实体。我们将把它放在一个名为<code class="eh ls lt lu lv b">Repo</code>的独立模块中。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="f9bd" class="me kc hu lv b fv mf mg l mh mi">type t = { <br/>  name: string, <br/>  size: int, <br/>  forks: int <br/>};</span></pre><p id="bb87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从现在开始，我们可以在应用程序中的任何Reason文件中使用<code class="eh ls lt lu lv b">Repo.t</code>来引用这种类型，而不需要用到它。</p><h1 id="f5c1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">管理状态</h1><p id="c2ca" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我们已经看到了无状态组件。现在让我们创建一个有状态的组件。在我们的上下文中，我们将使用<code class="eh ls lt lu lv b">RepoList</code>组件管理从GitHub的API获取的趋势库列表。</p><p id="fe3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从定义由<code class="eh ls lt lu lv b">RepoList</code>组件管理的状态类型开始。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="a9e7" class="me kc hu lv b fv mf mg l mh mi">type state = { <br/>  repos: list(Repo.t) <br/>};</span></pre><p id="9ab1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，有一个问题。最初，在从GitHub API获取趋势库列表之前，<code class="eh ls lt lu lv b">repos</code>是未定义的。但是原因类型系统不允许我们有未定义的值。我们可以用一个空列表来模拟初始状态，但是这不是最佳的。空列表也可能意味着我们获取趋势库的查询没有返回任何结果。</p><p id="57fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们使用Reason的可选值来处理这种情况。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="1e3d" class="me kc hu lv b fv mf mg l mh mi">type state = { <br/>  repos: option(list(Repo.t)) <br/>}</span></pre><p id="16f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一步是为该组件定义可能的操作。在ReasonReact中，动作被表示为变体。现在我们只有一个动作叫做<code class="eh ls lt lu lv b">ReposFetched</code>。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="5346" class="me kc hu lv b fv mf mg l mh mi">type action = <br/>| ReposFetched(list(Repo.t));</span></pre><p id="5a22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了在ReasonReact中创建有状态的组件，我们需要使用<code class="eh ls lt lu lv b">reducerComponent()</code>函数。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="c8ef" class="me kc hu lv b fv mf mg l mh mi">let component = ReasonReact.reducerComponent("App");</span></pre><p id="fb2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种组件允许定义一个描述状态如何响应动作而转换的缩减器。缩减器将一个动作和当前状态一起作为输入，并将新状态作为输出返回。减速器必须是纯函数。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="74e5" class="me kc hu lv b fv mf mg l mh mi">reducer: (action, _prevState) =&gt; { <br/>  switch action { <br/>  | ReposFetched(repos) =&gt; ReasonReact.Update({repos: Some(repos)}) <br/>  } <br/>}</span></pre><p id="d5c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们正在根据reducer()方法中接收的参数进行模式匹配操作。模式匹配必须是详尽的。所有变量值必须匹配。<code class="eh ls lt lu lv b">reducer</code>定义放在组件的<code class="eh ls lt lu lv b">main</code>函数中。</p><p id="c4a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了完成组件的定义，让我们定义它的初始状态:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="f60a" class="me kc hu lv b fv mf mg l mh mi">initialState: () =&gt; {  <br/>  repos: Some([ {name: "Huncwot", size: 11011, forks: 42} ]) <br/>}</span></pre><h1 id="3fec" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">与API集成</h1><p id="475e" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我们将使用<code class="eh ls lt lu lv b"><a class="ae ka" href="https://github.com/reasonml-community/bs-fetch" rel="noopener ugc nofollow" target="_blank">bs-fetch</a></code>从外部API获取数据。它是一个BuckleScript库，充当Fetch API之上的一个薄层。一旦获取了数据，我们将使用<code class="eh ls lt lu lv b">bs-json</code>来提取我们感兴趣的字段。</p><p id="28d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从安装<code class="eh ls lt lu lv b">bs-fetch</code>和<code class="eh ls lt lu lv b">bs-json</code>开始:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="13f7" class="me kc hu lv b fv mf mg l mh mi">npm i bs-fetch @glennsl/bs-json</span></pre><p id="12e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将它们添加到<code class="eh ls lt lu lv b">bsconfig.json</code>中的<code class="eh ls lt lu lv b">bs-dependencies</code>:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="9c85" class="me kc hu lv b fv mf mg l mh mi">{ <br/>  "bs-dependencies": [ <br/>    ..., <br/>    "bs-fetch", <br/>    "@glennsl/bs-json" <br/>  ] <br/>}</span></pre><p id="c03e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将我们的<code class="eh ls lt lu lv b">Repo</code>类型定义为一组三个字段:<code class="eh ls lt lu lv b">name</code>、<code class="eh ls lt lu lv b">size</code>和<code class="eh ls lt lu lv b">forks</code>。一旦从GitHub API获取了有效载荷，我们就解析它以提取这三个字段。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="6860" class="me kc hu lv b fv mf mg l mh mi">let parse = json =&gt; Json.Decode.{ <br/>  name: json |&gt; field("name", string), <br/>  size: json |&gt; field("size", int), <br/>  forks: json |&gt; field("forks", int), <br/>};</span></pre><p id="fa5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ls lt lu lv b">field</code>是<code class="eh ls lt lu lv b">Json.Decode</code>的一种方法。<code class="eh ls lt lu lv b">Json.Decode.{ ... }</code>(注意圆点)打开<code class="eh ls lt lu lv b">Json.Decode</code>模块。它的属性现在可以在这些花括号中使用，而不需要加上前缀<code class="eh ls lt lu lv b">Json.Decode</code>。</p><p id="7cfd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然GitHub在<code class="eh ls lt lu lv b">items</code>下返回repos，那么让我们定义另一个函数来获得这个列表。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="7090" class="me kc hu lv b fv mf mg l mh mi">let extract = (fields, json) =&gt; Json.Decode.(<br/>  json |&gt; at(fields, list(parse))<br/>);</span></pre><p id="f12a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们可以发出请求，并通过解析函数传递返回的数据:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="0e8e" class="me kc hu lv b fv mf mg l mh mi">let list = () =&gt; Js.Promise.( <br/>  Fetch.fetch(endpoint) <br/>  |&gt; then_(Fetch.Response.json) <br/>  |&gt; then_(text =&gt; extract(["items"], text) |&gt; resolve) <br/>);</span></pre><h1 id="ff30" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">反应生命周期方法</h1><p id="a8f4" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">让我们使用<code class="eh ls lt lu lv b">didMount</code>生命周期方法来触发从GitHub API获取存储库。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="986a" class="me kc hu lv b fv mf mg l mh mi">didMount: self =&gt; { <br/>  let handle = repos =&gt; self.send(ReposFetched(repos)); <br/>  Repo.list() <br/>  |&gt; Js.Promise.then_(repos =&gt; { <br/>    handle(repos); <br/>    Js.Promise.resolve(); <br/>  }) <br/>  |&gt; ignore; <br/>}</span></pre><p id="6741" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ls lt lu lv b">handle</code>是将<code class="eh ls lt lu lv b">ReposFetched</code>动作分派给减速器的方法。一旦承诺被解析，动作将把获取的存储库传送到缩减器。这将更新我们的状态。</p><h1 id="1bbd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">翻译</h1><p id="cbaf" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">因为我们区分了未初始化状态和库的空列表，所以处理初始的<strong class="je hv">正在加载</strong>消息是简单的。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="0afc" class="me kc hu lv b fv mf mg l mh mi">render: self =&gt; <br/>  &lt;div&gt; ( <br/>    switch self.state.repos { <br/>    | None =&gt; s("Loading repositories..."); <br/>    | Some([]) =&gt; s("Emtpy list") <br/>    | Some(repos) =&gt; &lt;ul&gt; ( <br/>      repos <br/>      |&gt; List.map((repo: Repo.t) =&gt; &lt;li&gt; (s(repo.name)) &lt;/li&gt;) <br/>      |&gt; Array.of_list <br/>      |&gt; ReasonReact.array ) <br/>    &lt;/ul&gt; <br/>    } <br/>  ) <br/>  &lt;/div&gt; <br/>};</span></pre><h1 id="9864" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">错误处理</h1><p id="9949" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">TBW</p><h1 id="2d56" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">CSS中的类型</h1><p id="598b" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">使用<code class="eh ls lt lu lv b"><a class="ae ka" href="https://github.com/SentiaAnalytics/bs-css" rel="noopener ugc nofollow" target="_blank">bs-css</a></code>的CSS类型。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="48b1" class="me kc hu lv b fv mf mg l mh mi">yarn add bs-css </span><span id="4c85" class="me kc hu lv b fv mj mg l mh mi">"bs-dependencies": [ <br/>  ..., <br/>  "bs-css" <br/>] </span><span id="24a2" class="me kc hu lv b fv mj mg l mh mi">let style = <br/>  Css.( <br/>    { <br/>      "header": style([backgroundColor(rgba(111, 37, 35, 1.0)), display(Flex)]), <br/>      "title": style([color(white), fontSize(px(28)), fontWeight(Bold)]), <br/>    } <br/>  ); </span><span id="9043" class="me kc hu lv b fv mj mg l mh mi">let make = _children =&gt; { <br/>  ...component, <br/>  render: _self =&gt; <br/>    &lt;header className=style##header&gt; <br/>      &lt;h1 className=style##title&gt; (s("This is title")) &lt;/h1&gt; <br/>    &lt;/header&gt; <br/>};</span></pre><h1 id="0db9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">词汇</h1><ul class=""><li id="0994" class="kz la hu je b jf lb jj lc jn ld jr le jv lf jz mx lh li lj dt translated"><code class="eh ls lt lu lv b">rtop</code>是一个交互式命令行。</li><li id="436d" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz mx lh li lj dt translated">Merlin是OCaml和Reason的自动补全服务文件。</li><li id="2ed0" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz mx lh li lj dt translated"><code class="eh ls lt lu lv b">[@bs...]</code>FFI的Bucklescript注释</li></ul><h1 id="b7a5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">额外资源</h1><h1 id="3f5a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">TBD</h1><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="db60" class="me kc hu lv b fv mf mg l mh mi">module History = { <br/>  type h; <br/>  [@bs.send] external goBack : h =&gt; unit = ""; <br/>  [@bs.send] external goForward : h =&gt; unit = ""; <br/>  [@bs.send] external go : (h, ~jumps: int) =&gt; unit = "";  <br/>  [@bs.get] external length : h =&gt; int = ""; <br/>};</span></pre><p id="a32a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">BuckleScript允许我们将原始JavaScript与原因代码混合使用。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="7172" class="me kc hu lv b fv mf mg l mh mi">[%bs.raw {|require('./app.css')|}];</span></pre></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="fd18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nf">最初发表于</em><a class="ae ka" href="https://zaiste.net/reason_in_nutshell_getting_started_guide/" rel="noopener ugc nofollow" target="_blank"><em class="nf">zaiste.net</em></a><em class="nf">。</em></p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>