<html>
<head>
<title>Part I: Getting started with Fn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第一部分:Fn入门</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/playing-with-the-fn-project-8c6939cfe5cc?source=collection_archive---------6-----------------------#2018-05-18">https://medium.com/hackernoon/playing-with-the-fn-project-8c6939cfe5cc?source=collection_archive---------6-----------------------#2018-05-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/cd195e2d112f41c6470700fd652ac36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LnDorARw86Vx6Pji."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“A massive white cloud over a snow-capped mountain ridge” by <a class="ae jg" href="https://unsplash.com/@bchild311?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Benjamin Child</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6320" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">目录</strong></p><ul class=""><li id="a522" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated"><strong class="jj hv">第一部分:Fn项目入门(本帖)</strong></li><li id="e3a9" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated"><a class="ae jg" rel="noopener" href="/@pjausovec/part-ii-fn-load-balancer-585babd90456">第二部分:Fn负载均衡器(本岗位)</a></li></ul><p id="e1fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我不是那种可以简单地阅读白皮书/代码/文档，不需要在实践中尝试就能快速弄清楚事情是如何工作的幸运儿。我需要安装一些东西，运行一些东西，玩一些东西，来感受一下这些东西是如何工作的。如果我卡住了，那就是我要阅读文档和代码来看看我错过了什么的时候。</p><p id="7d6e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个版本中，我决定弄清楚<a class="ae jg" href="https://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn项目</a>是如何工作的，如何运行它，使用它，甚至扩展它。<a class="ae jg" href="http://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn项目</a>是容器原生的、云不可知的无服务器平台。</p><p id="62ae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为本文的一部分，我为Fn服务器创建了三个不同的示例扩展——你可以在<a class="ae jg" href="https://github.com/peterj/fn-extensions" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得它们。</p><h1 id="9838" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">基础知识—安装和运行</h1><p id="7ee2" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">本节将介绍如何安装Fn服务器，启动它，然后创建一个简单的函数并调用它。</p><p id="ac56" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你需要在你的机器上安装Docker来运行Fn，一旦你有了Docker，你就可以用<a class="ae jg" href="https://brew.sh" rel="noopener ugc nofollow" target="_blank"> brew </a>来安装Fn:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="ec7b" class="mf ku hu mb b fv mg mh l mi mj">brew install fn</span></pre><blockquote class="mk ml mm"><p id="914c" class="jh ji mn jj b jk jl jm jn jo jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd ke hn dt translated">显然，我以前安装过Fn，而我机器上的Docker镜像是陈旧的，导致启动时Fn失败——运行<code class="eh mr ms mt mb b">fn update server</code>将确保你的机器上有最新的Fn服务器镜像。</p></blockquote><p id="9b51" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，安装Fn并更新映像后，您可以使用以下命令运行Fn服务器:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="a5d4" class="mf ku hu mb b fv mg mh l mi mj">fn start</span></pre><p id="ac12" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以上命令在单服务器模式下运行Fn，并嵌入数据库和队列。在后台，<code class="eh mr ms mt mb b">fn start</code>命令以特权模式运行一个名为<code class="eh mr ms mt mb b">fnproject/fnserver</code>的Docker映像。它还将Docker套接字装入容器以及当前工作目录中的<code class="eh mr ms mt mb b">/data</code>文件夹(这是存储数据库和队列信息的地方)。最后，它将端口<code class="eh mr ms mt mb b">8080</code>暴露给主机，因此您可以在该端口上调用它。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/5a2d3890568803c9e9bbd2f5195efd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3us6YbBtLWWHPQ-OVHckg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">fnserver image running locally</figcaption></figure><p id="dca9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在您已经运行了Fn服务器，您可以创建一个新的函数。</p><h1 id="8b1b" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">第一功能</h1><p id="4629" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">Fn CLI带有一个用于创建新功能的<code class="eh mr ms mt mb b">init</code>命令。</p><blockquote class="mk ml mm"><p id="23fb" class="jh ji mn jj b jk jl jm jn jo jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd ke hn dt translated">在撰写本文时，这些是支持的函数运行时:dotnet、go、java8、java9、java、lambda-nodejs4.3、lambda-node-4、node、php、python、python3.6、ruby、rust、kotlin</p></blockquote><p id="8c74" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">开始之前，先简单解释一下Fn使用的不同概念:</p><p id="dea9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">应用</strong> <br/>应用是一种将您的功能以相同的名称进行逻辑分组的方式(例如<code class="eh mr ms mt mb b">greeter-app</code></p><p id="ae2c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">触发器</strong> <br/>每个函数都有一个触发器，触发器有一个源(如<code class="eh mr ms mt mb b">/greeter-app/hello</code>或<code class="eh mr ms mt mb b">/greeter-app/goodbye</code>)和一个目标，目标是函数所在的端点(如<code class="eh mr ms mt mb b">http://localhost:8080/greeter-app/hello</code>)</p><p id="7fdb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是你正在编写并被执行的实际代码</p><p id="7423" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">图片</strong> <br/>打包你的函数的Docker图片；所使用的图像取决于功能的语言(例如<code class="eh mr ms mt mb b">fnproject/go</code>、<code class="eh mr ms mt mb b">fnproject/ruby</code>、<code class="eh mr ms mt mb b">fnproject/node</code>、…)，这里的目标是图像尽可能小，以便更有表现力</p><p id="db90" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> Calls </strong> <br/> Call保存关于对该函数的调用的信息。它包括有关应用程序的信息、通话的创建、开始和完成时间以及通话的状态。</p><p id="5096" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">至此，让我们通过提供运行时(例如Go、Node或其他支持的语言)和函数名来创建一个新函数:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="5d99" class="mf ku hu mb b fv mg mh l mi mj">fn init --runtime go --trigger http hello</span></pre><p id="11f2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上述命令在<code class="eh mr ms mt mb b">hello</code>子文件夹中创建一个Go功能。函数结构如下所示:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="0f0c" class="mf ku hu mb b fv mg mh l mi mj">hello<br/>├── Gopkg.toml<br/>├── func.go<br/>├── func.yaml<br/>└── test.json</span></pre><p id="1f54" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您的函数的源代码位于<code class="eh mr ms mt mb b">func.go</code>文件中，并且有一个函数处理程序以“Hello World”消息作为响应。<code class="eh mr ms mt mb b">func.yaml</code>文件包含诸如版本运行时、名称和函数入口点的信息。</p><p id="f34d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一个有趣的文件是<code class="eh mr ms mt mb b">test.json</code>——这个文件包含一组测试(输入值和预期输出值)，您可以通过运行<code class="eh mr ms mt mb b">fn test</code>用它来测试您的函数。</p><p id="0821" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要运行该功能，您可以使用<code class="eh mr ms mt mb b">fn run</code>命令。在运行该命令之前，确保将<code class="eh mr ms mt mb b">FN_REGISTRY</code>环境变量设置到Docker存储库中。</p><p id="47b2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，当您运行该命令时，Fn将使用该函数构建Docker映像，并像这样运行该函数:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="7842" class="mf ku hu mb b fv mg mh l mi mj">$ fn run<br/>Building image hello:0.0.1 ...........<br/>{"message":"Hello World"}</span></pre><p id="3103" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一切都很好，但我们有本地运行的Fn服务器，所以让我们将我们的功能部署到服务器上，而不只是运行它。</p><p id="7845" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要部署该功能，您可以使用<code class="eh mr ms mt mb b">fn deploy</code>命令，指定应用程序名称并添加<code class="eh mr ms mt mb b">--local</code>，因为Fn服务器正在本地运行:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="e097" class="mf ku hu mb b fv mg mh l mi mj">fn deploy --app myapp --local</span></pre><p id="6328" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">命令将应用程序(名为<code class="eh mr ms mt mb b">myapp</code>)部署到本地Fn服务器，并创建一个名为<code class="eh mr ms mt mb b">/hello</code>(我们的函数名)的路径。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/55ffcdadae11ac69782d7921fad4eabe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*U9UHXdQlrCScQr6wLn4nsg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Deploying the app to local Fn server</figcaption></figure><p id="1024" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这意味着在Fn服务器上，可以在<code class="eh mr ms mt mb b">/myapp/hello</code>路径下访问该函数。应用程序名称用于对功能进行逻辑分组。要查看Fn服务器上定义的触发器的完整列表，请运行以下命令:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="aa80" class="mf ku hu mb b fv mg mh l mi mj"># List all triggers for 'myapp'<br/>$ fn list triggers myapp<br/>FUNCTION        NAME            TYPE    SOURCE          ENDPOINT<br/>hello           hello-trigger   http    /hello-trigger  <a class="ae jg" href="http://localhost:8080/t/myapp/hello-trigger" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/t/myapp/hello-trigger</a></span></pre><p id="e8ca" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，如果您访问端点，您将得到如下“Hello World”消息:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="c8c4" class="mf ku hu mb b fv mg mh l mi mj">$ curl <a class="ae jg" href="http://localhost:8080/t/myapp/hello-trigger" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/t/myapp/hello-trigger</a><br/>{"message":"Hello World"}</span></pre><h2 id="c4ed" class="mf ku hu bd kv mw mx my kz mz na nb ld js nc nd lh jw ne nf ll ka ng nh lp ni dt translated">分组功能</h2><p id="7c1f" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">要将这些功能组合在一起，您可以使用应用程序名称结构——这允许您将不同的路由逻辑地组合在一起(例如，<code class="eh mr ms mt mb b">greeter-app</code>可能有被称为<code class="eh mr ms mt mb b">/hello</code>和<code class="eh mr ms mt mb b">/goodbye</code>的路由)。</p><p id="adb2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，<code class="eh mr ms mt mb b">greeter-app</code>也可以是你的函数所在的文件夹名，子文件夹<code class="eh mr ms mt mb b">/hello</code>和<code class="eh mr ms mt mb b">/goodbye</code>将包含实际的函数。您还可以在应用程序根文件夹中定义<code class="eh mr ms mt mb b">app.yaml</code>文件，以便能够用一个命令部署所有功能。</p><p id="41a4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">按照下面的步骤创建一个带有你好和再见功能的欢迎应用程序:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="de01" class="mf ku hu mb b fv mg mh l mi mj"># Create the greeter-app folder<br/>mkdir greeter-app &amp;&amp; cd greeter-app</span><span id="b792" class="mf ku hu mb b fv nj mh l mi mj"># Create app.yaml that defines the app name<br/>echo "name: greeter-app" &gt; app.yaml</span><span id="302c" class="mf ku hu mb b fv nj mh l mi mj"># Create a hello function in /hello subfolder<br/>fn init --runtime go --trigger http hello</span><span id="3287" class="mf ku hu mb b fv nj mh l mi mj"># Create a goodbye function in /goodbye subfolder<br/>fn init --runtime go --trigger http goodbye</span></pre><p id="6629" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完成所有这些设置并将<code class="eh mr ms mt mb b">app.yaml</code>放在根文件夹中后，您可以使用这个命令将所有功能部署到本地Fn服务器:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="6f74" class="mf ku hu mb b fv mg mh l mi mj">fn deploy --all --local</span></pre><p id="2d50" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上述命令创建以下应用程序和端点:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="56c0" class="mf ku hu mb b fv mg mh l mi mj">$ fn list routes greeter-app<br/>path     image         endpoint<br/>/goodbye goodbye:0.0.2 localhost:8080/r/greeter-app/goodbye<br/>/hello   hello:0.0.2   localhost:8080/r/greeter-app/hello</span></pre><p id="2aa1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您还可以通过从应用程序的根文件夹运行<code class="eh mr ms mt mb b">fn init</code>命令来创建一个位于应用程序根目录下的函数:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="99ea" class="mf ku hu mb b fv mg mh l mi mj">fn init --runtime node --trigger http</span></pre><p id="2dc3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后再次部署它:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="28c3" class="mf ku hu mb b fv mg mh l mi mj">fn deploy --all --local</span></pre><p id="c0f4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们在/greeter-app逻辑组下有三个函数:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="6ff9" class="mf ku hu mb b fv mg mh l mi mj">$ fn list routes greeter-app<br/>path     image             endpoint<br/>/        greeter-app:0.0.2 localhost:8080/r/greeter-app<br/>/goodbye goodbye:0.0.3     localhost:8080/r/greeter-app/goodbye<br/>/hello   hello:0.0.3       localhost:8080/r/greeter-app/hello</span></pre><h1 id="fe71" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">启用用户界面</h1><p id="dd2a" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">如果你更喜欢UI与Fn交互——这里也有适合你的。假设您在本地运行Fn服务器，您可以像这样启动UI:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="63fa" class="mf ku hu mb b fv mg mh l mi mj">docker run --rm -it --link fnserver:api -p 4000:4000 -e "FN_API_URL=<a class="ae jg" href="http://api:8080" rel="noopener ugc nofollow" target="_blank">http://api:8080</a>" fnproject/ui</span></pre><p id="9237" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当图像被下载并且容器执行时，您将能够在<code class="eh mr ms mt mb b"><a class="ae jg" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a></code>上访问UI。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nk"><img src="../Images/7060fee0956f1681764a7de490d5e3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*enzDJZLDo-7DB85i8sBSGQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Fn server UI</figcaption></figure><h1 id="8c00" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">扩展Fn</h1><p id="b242" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">有几个不同的选项可供您扩展Fn服务器。所有选项都要求您重新构建Fn服务器，因为您必须导入您的扩展—您可以使用<code class="eh mr ms mt mb b">build-server</code> CLI命令和<code class="eh mr ms mt mb b">ext.yaml</code>文件来构建带有您的扩展的Fn服务器的新映像，或者您可以派生&amp;克隆Fn repo并在<code class="eh mr ms mt mb b">cmd/fnserver/main.go</code>文件中引用您的扩展，然后重新构建代码并运行它。</p><p id="2fff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于开发，最快的方法是克隆Fn repo并在那里创建和注册您的扩展。如果您使用的是<code class="eh mr ms mt mb b">build-server</code>命令，这可能需要更长的时间，因为该命令将在每次调用时重新构建Fn服务器映像。注意，在这两种情况下，每次都必须构建Fn服务器，但是直接构建要比重建Docker映像快得多。</p><p id="9cc4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Fn服务器上有三个扩展点:监听器、中间件、自定义API端点。请继续阅读，以获得对每个扩展点的更详细的描述，并查看本文后面的一些示例。</p><h2 id="dfca" class="mf ku hu bd kv mw mx my kz mz na nb ld js nc nd lh jw ne nf ll ka ng nh lp ni dt translated">听众</h2><p id="082b" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">您可以监听各种API事件并对它们做出响应。目前有两种类型的监听器:应用程序和呼叫。我想路线听众应该很快也会来…</p><p id="fbfe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在应用程序监听器中，您可以响应以下事件:</p><ul class=""><li id="72c3" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">BeforeAppCreate</li><li id="67b4" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">AfterAppCreate</li><li id="777e" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">在AppUpdate之前</li><li id="52e8" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">AfterAppUpdate</li><li id="3dd3" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">BeforeAppDelete</li><li id="854d" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">AfterAppDelete</li></ul><p id="30d0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些事件在呼叫监听器中可用:</p><ul class=""><li id="6097" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">通话前</li><li id="0778" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">通话后</li></ul><h2 id="4f7e" class="mf ku hu bd kv mw mx my kz mz na nb ld js nc nd lh jw ne nf ll ka ng nh lp ni dt translated">中间件</h2><p id="aa4d" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">使用中间件，您可以为每个到达服务器的API请求添加所需的功能。在这个中间件中，您可以决定是取消请求还是调用链中的下一个中间件。中间件的一个简单例子是检查令牌头的认证中间件，或者为每个请求记录某些事情的中间件。</p><h2 id="ba5b" class="mf ku hu bd kv mw mx my kz mz na nb ld js nc nd lh jw ne nf ll ka ng nh lp ni dt translated">自定义API端点</h2><p id="83d0" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">自定义API端点允许您向Fn服务器添加新端点。例如，您可以添加一个自定义API端点来处理对自定义路由(如<code class="eh mr ms mt mb b">/mycustomroute</code>)的请求，或者用路由<code class="eh mr ms mt mb b">/v1/apps/:app_name/mycustomhandler</code>或<code class="eh mr ms mt mb b">/v1/apps/:app_name/routes/:route_name/mycustomhandler</code>定义一个端点。</p><p id="2ccb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，可以在应用和路线上实现一个名为<code class="eh mr ms mt mb b">stats</code> (so，<code class="eh mr ms mt mb b">/v1/apps/:app_name/stats</code>和<code class="eh mr ms mt mb b">/v1/app:app_name/routes/:route_name/stats</code>)的自定义端点，当调用这些端点时，可以返回应用或路线的一些基本统计数据。</p><h1 id="e5d0" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">示例:使用呼叫监听器的呼叫计数器扩展</h1><p id="9d31" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">我写了一个简单的扩展，计算一个应用程序被调用的次数，并把这个数字输出到stdout。您可以在这里获得扩展<a class="ae jg" href="https://github.com/peterj/fn-extensions/tree/master/callcount" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="de29" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">扩展实现分为两个文件:<code class="eh mr ms mt mb b">callcount.go</code>和<code class="eh mr ms mt mb b">calllistener.go</code>。</p><p id="1905" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在第一个文件(<code class="eh mr ms mt mb b">callcount.go</code>)中，我注册了扩展并像这样设置了调用监听器:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="4b5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh mr ms mt mb b">init</code>函数中，我创建了一个名为<code class="eh mr ms mt mb b">callCountMap</code>的映射，我将使用它来增加对特定应用程序的调用，然后我通过调用<code class="eh mr ms mt mb b">RegisterExtension</code>函数并传入实现<code class="eh mr ms mt mb b">Name</code>和<code class="eh mr ms mt mb b">Setup</code>函数的扩展结构来注册扩展。在name函数中，我只是简单地返回扩展名所在的导入名称，在Setup函数中，我实际上添加了调用监听器，告诉Fn我将监听调用事件(这些事件在<code class="eh mr ms mt mb b">calllistener.go</code>文件中实现):</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="6abb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh mr ms mt mb b">BeforeCall</code>函数中，我们检查地图中是否有带有<code class="eh mr ms mt mb b">AppID</code>的条目，如果没有，我们将调用次数设置为0。类似地，在<code class="eh mr ms mt mb b">AfterCall</code>函数中，我们增加了对<code class="eh mr ms mt mb b">AppID</code>的调用次数，并打印出这个数字。</p><p id="70db" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">扩展就绪后，我们可以修改Fn服务器来包含我们的扩展。在cmd/fnserver/main.go文件中，我们需要做两件事:</p><ol class=""><li id="741f" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke nn kl km kn dt translated">像这样导入扩展(粗体行):</li></ol><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="b303" class="mf ku hu mb b fv mg mh l mi mj">import (<br/>    "context"<br/>    "github.com/fnproject/fn/api/server"<br/>  <strong class="mb hv">  _ "github.com/peterj/fn-extensions/callcount"</strong><br/>)</span></pre><p id="69f8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.调用<code class="eh mr ms mt mb b">main</code>函数中的<code class="eh mr ms mt mb b">AddExtensionByName</code>:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="b21a" class="mf ku hu mb b fv mg mh l mi mj">func main() {<br/>    ctx := context.Background()<br/>    funcServer := server.NewFromEnv(ctx)<br/><strong class="mb hv">    funcServer.AddExtensionByName("github.com/peterj/fn-    extensions/callcount")</strong><br/>    funcServer.Start(ctx)<br/>}</span></pre><p id="5c01" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们可以构建fnserver并运行它来测试扩展。</p><h2 id="3bce" class="mf ku hu bd kv mw mx my kz mz na nb ld js nc nd lh jw ne nf ll ka ng nh lp ni dt translated">尝试扩展</h2><p id="6fa7" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">让我们运行下面的命令来重建<code class="eh mr ms mt mb b">fnserver</code>:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="d817" class="mf ku hu mb b fv mg mh l mi mj">go build -o fnserver ./cmd/fnserver</span></pre><p id="d857" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，运行<code class="eh mr ms mt mb b">./fnserver</code>，当它启动时，尝试调用您之前部署的函数。您应该在Fn服务器输出中看到“Call number: X ”:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff no"><img src="../Images/6b4211d66bd2417d54f4ec7c01bf7e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a39UiIt0-gCOtmAMS79y8Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Extension in action!</figcaption></figure><p id="1570" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就像我们实现调用监听器一样，我们可以类似地添加应用监听器、中间件或自定义API端点。添加应用程序监听器类似于添加调用监听器——我们需要在我们的扩展结构上创建方法来满足应用程序监听器接口，然后调用<code class="eh mr ms mt mb b">AddAppListener</code>函数。</p><h1 id="4746" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">示例:取消呼叫中间件</h1><p id="17ce" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">让我们展示如何实现一个中间件功能，它检查某个报头是否存在(<code class="eh mr ms mt mb b">fn-cancel-call</code>)并取消调用链——也就是说，它不执行该功能。</p><p id="5470" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有两种不同的方法来注入定制中间件。一个是使用<code class="eh mr ms mt mb b">AddAPIMiddleware</code>——这个函数将中间件注入到所有API端点，例如:</p><ul class=""><li id="5a32" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">/v1/应用程序</li><li id="c2b4" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">/v1/apps/:app</li><li id="2f4b" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">/v1/apps/:应用程序/路线</li><li id="65a7" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt">…</li></ul><p id="e1d6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一个函数——<code class="eh mr ms mt mb b">AddRootMiddleware</code>——将中间件注入API和您的应用程序调用。</p><p id="f231" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了创建一个定制的中间件，我们需要在我们的扩展结构上实现一个<code class="eh mr ms mt mb b">Handle(next http.Handler) http.Handler</code>函数。和以前一样，扩展的源代码可以在<a class="ae jg" href="https://github.com/peterj/fn-extensions/tree/master/cancelmiddleware" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="9187" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">扩展注册和设置部分与之前相同，唯一的区别是中间件的实现，以及我们调用了<code class="eh mr ms mt mb b">AddRootMiddleware</code>函数，而不是<code class="eh mr ms mt mb b">AddCallListener</code>函数:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="1c16" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">中间件的逻辑在第30–40行。我们得到名为<code class="eh mr ms mt mb b">fn-cancel-call</code>的头，如果该头的值被设置为1，我们输出一条消息并从函数返回，取消剩余的中间件链。如果没有设置cancel头，我们调用下一个要执行的处理程序(<code class="eh mr ms mt mb b">next.ServeHTTP</code>)并继续执行。</p><h1 id="4f88" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">示例:使用自定义API端点的呼叫日志</h1><p id="b566" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">在最后一个示例中，我们将实现一个自定义API应用程序端点<code class="eh mr ms mt mb b">/v1/apps/:app/logs</code>，它连接到Fn服务器数据库，并返回对应用程序的调用列表。我们将把数组中的几个字段返回给用户。</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="1622" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您浏览了其他示例，那么上面的代码应该看起来很熟悉。只有几处不同——在我们设置扩展的第23行，我们添加了对扩展结构的<code class="eh mr ms mt mb b">Datastore</code>引用，这样我们可以稍后在<code class="eh mr ms mt mb b">ServeHTTP</code> func中使用它，并获得关于调用的信息。我们还调用<code class="eh mr ms mt mb b">AddAppEndpoint</code>在/logs路径上设置我们的自定义API端点，并指定<code class="eh mr ms mt mb b">GET</code> HTTP方法。</p><p id="3994" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">扩展的功能在第35行的<code class="eh mr ms mt mb b">ServerHTTP</code> func中。这里，我们首先设置一个<code class="eh mr ms mt mb b">CallFilter</code>，然后将它传递给数据存储上的<code class="eh mr ms mt mb b">GetCalls</code> func，以检索对应用程序的调用。</p><p id="554b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在第43行，我们使用来自Fn服务器包的func来发送错误响应，以防我们无法检索调用。</p><p id="ab61" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们收到呼叫，我们就仔细检查每一个呼叫，并将呼叫ID、状态、路径和呼叫开始时间写入响应编写器。</p><p id="0fd5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">重新构建并运行Fn服务器，然后调用例如<code class="eh mr ms mt mb b">localhost:8080/v1/apps/myapp/logs</code> —您将得到类似下图的输出(假设您调用了该应用程序)。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff np"><img src="../Images/f5dd270331cf36bcb6217484eda464bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*-9Ux5ZLlznpHM41bcd3kdg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Sample output from the call to the /logs custom API endpoint</figcaption></figure><h1 id="5a8f" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">结论</h1><p id="1b9f" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">这篇文章应该为你提供一个很好的介绍和入门文档。它给了你在本地机器上开始玩无服务器游戏所需要的基础知识，并让你思考可以扩展它的不同方法。</p><p id="1d1f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我可能会写一篇后续文章，在那里我会谈到<a class="ae jg" href="https://github.com/fnproject/flow" rel="noopener ugc nofollow" target="_blank"> Fn流服务器</a>、<a class="ae jg" href="https://github.com/fnproject/lb" rel="noopener ugc nofollow" target="_blank"> Fn负载平衡器</a>以及如何让Fn在Kubernetes上运行。</p><h1 id="d61d" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">感谢阅读！</h1><p id="2b63" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">欢迎对本文的任何反馈！你也可以在<a class="ae jg" href="http://twitter.com/pjausovec" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae jg" href="http://github.com/peterj" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。如果你喜欢这个并且想在我写更多东西的时候得到通知，你应该订阅<a class="ae jg" href="https://tinyletter.com/pjausovec" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>