<html>
<head>
<title>Get Reason-able with ReasonML — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Reason ml-第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/get-reason-able-with-reasonml-part-1-ac950188141b?source=collection_archive---------11-----------------------#2018-05-18">https://medium.com/hackernoon/get-reason-able-with-reasonml-part-1-ac950188141b?source=collection_archive---------11-----------------------#2018-05-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a360" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">RTOP、数据类型、字母绑定、词法范围、If-Else和开关、记录和变量</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/3209d050a2d115e34d0a6afc4a3a4c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cErheM348WFKd444QtgHSw.png"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="2e4f" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">不仅仅是一种新语言，<a class="ae kt" href="https://reasonml.github.io/" rel="noopener ugc nofollow" target="_blank"> ReasonML </a>(简称Reason)是一种由<a class="ae kt" href="https://ocaml.org/" rel="noopener ugc nofollow" target="_blank"> OCaml </a>支持的语法和工具链。它为OCaml提供了一种熟悉的语法，这种语法是面向JavaScript程序员的，同时也迎合了NPM的工作流程。</p><p id="3692" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">在<a class="ae kt" href="https://github.com/BuckleScript/bucklescript" rel="noopener ugc nofollow" target="_blank"> BuckleScript </a>的帮助下，Reason可以编译成可读的JavaScript代码。它也可以被编译成一个快速、简单的程序集。</p><p id="7945" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">Reason是静态类型的，在改进代码库的同时为我们提供了更好的清晰度。编译器本身可以推断出大多数类型，而不是一直编写所有类型。</p><p id="93de" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这是<strong class="jz hv"> 3部分系列</strong>的<strong class="jz hv">第1部分</strong>，在这里我将帮助你理解ReasonML及其所有的语法和语义。我将介绍从基本的<strong class="jz hv">数据类型</strong>到在ReasonML中声明<strong class="jz hv">函数</strong>的所有内容。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="2512" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">设置和RTOP</h1><h2 id="981b" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">原因CLI</h2><p id="d47c" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">在我们开始之前，请确保您已经在系统上安装了最新版本的<a class="ae kt" href="https://github.com/reasonml/reason-cli" rel="noopener ugc nofollow" target="_blank"> Reason CLI </a>。</p><p id="ba0a" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果您使用的是macOS，请打开终端并输入以下命令。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="1e8b" class="lt lc hu mn b fv mr ms l mt mu">npm install -g reason-cli@3.1.0-darwin</span></pre><p id="ae45" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这将在您的系统上安装Reason CLI，以及format和Merlin。你还会得到RTOP，一个交互式命令行工具。这个工具将使我们的事情变得非常容易。</p><h2 id="7bc2" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">使用RTOP</h2><p id="86c7" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">如果您在命令终端中键入<code class="eh mv mw mx mn b">rtop</code>,您将看到如下内容:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff my"><img src="../Images/afa1773d8ffe16cb3840ffa70689f24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAJ1k0zxiv4fnelDJ7YMmw.png"/></div></div></figure><p id="d55d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果你输入一些像<code class="eh mv mw mx mn b">1 + 1;</code>这样的基本数学，RTOP会对它进行评估并给你结果。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="9fb9" class="lt lc hu mn b fv mr ms l mt mu">Reason # 1 + 1;<br/>- : int = 2</span></pre><p id="56f8" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">RTOP的产出由三部分组成。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="69b5" class="lt lc hu mn b fv mr ms l mt mu">let binding: type definition = result</span></pre><p id="7ff8" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果您不在<code class="eh mv mw mx mn b">1 + 1</code>后键入分号，RTOP将不会触发评估。</p><p id="17e7" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">你可能已经注意到在终端的底部有一个列表。这个列表会给我们一组可能的模块和函数，我们可以使用。</p><p id="8316" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">当我们<code class="eh mv mw mx mn b">print</code>出值时，我们将看到值和输出的评价。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="fe9d" class="lt lc hu mn b fv mr ms l mt mu">Reason # print_int(42);<br/>42- : unit = ()</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="0635" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">数据类型和运算符</h1><h2 id="5bc9" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">整数和浮点</h2><p id="0989" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">如果你试图用RTOP做<code class="eh mv mw mx mn b">1.1 + 2.2</code>，你会得到一个错误消息，因为Reason有一个特殊的操作符来处理浮点值。</p><p id="1451" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">为了执行浮点值的运算，我们需要在运算符旁边添加一个<code class="eh mv mw mx mn b">.</code>。所以<code class="eh mv mw mx mn b">1.1 + 2.2</code>会变成:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="63ce" class="lt lc hu mn b fv mr ms l mt mu">Reason # 1.1 +. 2.2<br/>- : float = 3.30000000000000027</span></pre><h2 id="aeea" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">比较值</h2><p id="020a" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">为了比较值，我们可以使用几个关系运算符，或者使用<code class="eh mv mw mx mn b">==</code>的结构等式。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="fc2b" class="lt lc hu mn b fv mr ms l mt mu">Reason # 2 &gt; 3;<br/>- : bool = false<br/>Reason # 2 == 3;<br/>- : bool = false</span></pre><p id="5261" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">不能直接比较int值和float值。为此，我们需要首先将int转换成float。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="cadd" class="lt lc hu mn b fv mr ms l mt mu">Reason # float_of_int(2) &gt; 3.1;<br/>- : bool = false</span></pre><p id="b675" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">Reason附带了许多这样的实用函数，可以帮助我们转换类型。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="4820" class="lt lc hu mn b fv mr ms l mt mu">Reason # bool_of_string(“true”);<br/>- : bool = true;</span></pre><h2 id="d4ad" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">布尔代数学体系的</h2><p id="368f" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">由于布尔只能为真或假，这与我们通常在JavaScript中所做的没有太大的区别。布尔运算符为<code class="eh mv mw mx mn b">!</code>代表<strong class="jz hv">而非</strong>，<code class="eh mv mw mx mn b">&amp;&amp;</code>代表<strong class="jz hv">和</strong>，<code class="eh mv mw mx mn b">||</code>代表<strong class="jz hv">或</strong>。</p><h2 id="112c" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">用线串</h2><p id="153c" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">字符串也是直截了当的。它们只受到使用<code class="eh mv mw mx mn b">""</code>的限制。可以使用<code class="eh mv mw mx mn b">++</code>连接字符串。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="fb30" class="lt lc hu mn b fv mr ms l mt mu">Reason # "Hello" ++ "World"<br/>- : string = "HelloWorld"</span></pre><p id="101e" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">Reason还为单字母字符串提供了一种特殊的数据类型。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="44a2" class="lt lc hu mn b fv mr ms l mt mu">Reason # 'a';<br/>- : char = 'a';</span></pre><h2 id="e0fb" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">空</h2><p id="a309" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">在Reason中传递空值类似于我们在JavaScript中的做法。Null是用<code class="eh mv mw mx mn b">()</code>定义的，有自己的类型叫做unit。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="dbc3" class="lt lc hu mn b fv mr ms l mt mu">Reason # ();<br/>- : unit = ()</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="a6ac" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">字母绑定、类型推断和类型别名</h1><h2 id="9fd0" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">让绑定</h2><p id="9086" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">Let绑定允许我们以一种非常类似于其他语言中变量声明的方式将值绑定到名称。</p><p id="a02c" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用<code class="eh mv mw mx mn b">let</code>，我们可以像这样将一个字符串值绑定到一个变量:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="82e6" class="lt lc hu mn b fv mr ms l mt mu">Reason # let name: string = "Rajat";<br/>let name: string = "Rajat";</span></pre><p id="c534" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><code class="eh mv mw mx mn b">let</code>绑定的一般模式看起来是这样的:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="1997" class="lt lc hu mn b fv mr ms l mt mu">Reason # let &lt;name&gt;: &lt;type&gt; = &lt;expression&gt;;</span></pre><p id="c7a9" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果您来自JavaScript背景，那么您可能想知道为什么我们需要提供<code class="eh mv mw mx mn b">type</code>。这是因为Reason是静态类型的，与JavaScript这样的动态类型的语言有很大的不同。静态类型语言要求我们在编译时声明或推断类型。</p><h2 id="24a8" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">类型推理</h2><p id="30c0" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">我们已经看到了如何声明我们的类型。现在我们来看看如何推断它们。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="e617" class="lt lc hu mn b fv mr ms l mt mu">Reason # let rajat = "Rajat";<br/>let rajat: string = "Rajat";</span></pre><p id="2879" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">原因编译器推断值的类型是字符串。这是一个很好的特性，因为它允许我们拥有完全的类型安全，而不用一直声明类型。这意味着类型在理论上是可选的，但是如果你想的话，你也可以显式地写下来。</p><h2 id="4a33" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">不变</h2><p id="785b" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated"><code class="eh mv mw mx mn b">let</code>绑定是不可变的。因此，如果我们将一个值绑定到一个变量，我们就不能在以后更改它。</p><p id="cd42" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">但是，我们可以创建一个新的同名的<code class="eh mv mw mx mn b">let</code>绑定。这个新的绑定将覆盖先前的绑定，并且绑定现在将引用新分配的值。</p><h2 id="10c1" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">键入别名</h2><p id="afdf" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">隐藏一个<code class="eh mv mw mx mn b">let</code>绑定后，它与前一个绑定不再有任何关系。所以我们甚至可以为新的绑定使用不同的类型。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="a4ce" class="lt lc hu mn b fv mr ms l mt mu">Reason # type score = int;<br/>type score = int;<br/>Reason # let x: score = 10;<br/>let x: score = 10;</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="d6d8" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">词法范围</h1><p id="0476" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">Reason有词法范围。这将设置变量的作用域(功能范围),以便只能从定义它的代码块中引用它。像这样声明的变量有时被称为私有变量。</p><p id="9b7e" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">首先，我将使用RTOP在Reason中创建一个局部范围。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="7a34" class="lt lc hu mn b fv mr ms l mt mu">Reason # { 100; };<br/>- : int = 100</span></pre><p id="06cb" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">该范围可以包含多个命令性语句。最后一条语句将自动返回。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="45a9" class="lt lc hu mn b fv mr ms l mt mu">Reason # <br/>{ print_endline("Rajat"); 100; };<br/>Rajat<br/>- : int = 100</span></pre><p id="6e4c" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">在范围内，我们可以访问当前范围之外的绑定。但是在作用域内部定义的绑定不能从外部访问。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="eb93" class="lt lc hu mn b fv mr ms l mt mu">Reason # 100;<br/>- : int = 100<br/>Reason # let x = 10;<br/>let x: int = 10;<br/>Reason # {100 + x; };<br/>- : int = 110<br/>Reason #<br/>{<br/>  let y = 1;<br/>  110 + y;<br/>};<br/>- : int = 111</span></pre><p id="da9a" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们也可以在一个作用域内隐藏一个<code class="eh mv mw mx mn b">let</code>绑定，这不会影响这个局部作用域外的<code class="eh mv mw mx mn b">let</code>绑定，即使是不同的类型。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="8d8f" class="lt lc hu mn b fv mr ms l mt mu">Reason # let rajat = "Rajat";<br/>let rajat: string = "Rajat";<br/>Reason #<br/>{<br/>  let rajat = 100;<br/>  rajat;<br/>};<br/>- : int = 2<br/>Reason # rajat;<br/>- : string = "Rajat"</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="7918" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">If-Else和开关</h1><h2 id="502a" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">如果-否则</h2><p id="dc40" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated"><code class="eh mv mw mx mn b">if-else</code>允许我们根据提供的条件执行不同的表达式。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="915a" class="lt lc hu mn b fv mr ms l mt mu">Reason # let isHungry = true;<br/>let isHungry: bool = true;<br/>Reason # if (isHungry) {"Pizza!"} else {"Still Pizza!"};<br/>- : string = "Pizza"</span></pre><p id="166b" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这里，<code class="eh mv mw mx mn b">if</code>是一个表达式，因此可以简化为一个值。这意味着它可以绑定到一个<code class="eh mv mw mx mn b">let</code>绑定。在JavaScript这样的语言中，<code class="eh mv mw mx mn b">if</code>是一个语句，而不是一个表达式。试图将它绑定到一个名称会抛出一个语法错误。</p><p id="b49c" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">事实上,<code class="eh mv mw mx mn b">if</code>是理性的一种表达，这可能非常有用。但是它也有其局限性。<code class="eh mv mw mx mn b">if-else</code>的每一个分支都需要被求值为相同的类型，所以我们不能做如下操作:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="e477" class="lt lc hu mn b fv mr ms l mt mu">Reason # let food = if (isHungry) {"Pizza"};<br/>Error: This expression has type string but an expression was expected of type unit</span></pre><p id="e032" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">所以我们仍然可以使用<code class="eh mv mw mx mn b">if</code>来打印一个值，只要最后一个语句返回类型单元。<code class="eh mv mw mx mn b">print_endline</code>确实如此。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="c99e" class="lt lc hu mn b fv mr ms l mt mu">Reason # if (isHungry) {print_endline("isHungry is set to true")};<br/>isHungry is set to true<br/>- : int = ()</span></pre><h2 id="fa2e" class="lt lc hu bd ld lu lv lw lh lx ly lz ll kg ma mb ln kk mc md lp ko me mf lr mg dt translated">转换</h2><p id="1196" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">开关接受一个值并将其与<code class="eh mv mw mx mn b">pattern</code>匹配。然后计算匹配的大小写，它必须是一个表达式。最简单的形式是，<code class="eh mv mw mx mn b">pattern</code>只匹配结构相等。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="f1dc" class="lt lc hu mn b fv mr ms l mt mu">Reason # let lamp =<br/>  switch (1) {<br/>  | 0 =&gt; "off"<br/>  | 1 =&gt; "on"<br/>  | _ =&gt; "off"<br/>};<br/>let lamp: string = "on";<br/>Reason # lamp;<br/>- : string = "on"</span></pre><p id="c5a2" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果您没有为<code class="eh mv mw mx mn b">_</code>添加switch语句，那么Reason将继续向您抛出关于情况<code class="eh mv mw mx mn b">2</code>的警告，然后是<code class="eh mv mw mx mn b">3</code>，以此类推。<code class="eh mv mw mx mn b">_</code>类似于JavaScript中switch的<code class="eh mv mw mx mn b">default</code>情况。</p><p id="a8ab" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">任何类型的数据都可以进行模式匹配。对于字符串:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="8c3e" class="lt lc hu mn b fv mr ms l mt mu">switch ("Evie") {<br/>| "Altair" =&gt; "One"<br/>| "Ezio" =&gt; "Two"<br/>| "Connor" =&gt; "Three"<br/>| "Edward" =&gt; "Black Flag"<br/>| "Arno" =&gt; "Unity"<br/>| "Jacob" =&gt; "Syndicate"<br/>| _ =&gt; "Unknown"<br/>};<br/>_ : string = "Unknown"</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="e0b9" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">记录</h1><p id="a563" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">记录允许我们将各种类型的数据存储到一个结构中，并通过名称引用它们。</p><p id="1e0d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">要创建一个记录，我们首先必须定义它的结构。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="fd6b" class="lt lc hu mn b fv mr ms l mt mu">type super = {<br/>  hero: string,<br/>  alias: string,<br/>};</span></pre><p id="5989" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">一旦定义完毕，我们就可以为这样的超级英雄创造一个记录:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="d69d" class="lt lc hu mn b fv mr ms l mt mu">{ hero: "Superman", alias: "Clark Kent" };<br/>- : super = {hero: "Superman", alias: "Clark Kent"}</span></pre><p id="33d5" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">默认情况下，类型是推断出来的，我们不需要指定它。我们还可以像这样访问记录的特定字段:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="6e0e" class="lt lc hu mn b fv mr ms l mt mu"># let super = { hero: "Superman", alias: "Clark Kent"};<br/>let super: super = {hero: "Superman", alias: "Clark Kent"};<br/># super.hero;<br/>- : string = "Superman"</span></pre><p id="578f" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果你试图访问一个记录中不存在的字段，Reason会抛出一个错误。</p><p id="7c7d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">或者，您可以结合使用结构化和<code class="eh mv mw mx mn b">let</code>绑定。我们从一个<code class="eh mv mw mx mn b">let</code>绑定开始，然后描述如何映射字段，并放置要结构化的记录。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="215e" class="lt lc hu mn b fv mr ms l mt mu"># let {hero: heroName, alias: aliasName} = super;<br/>let heroName: string = "Superman";<br/>let aliasName: string = "Clark Kent";</span></pre><p id="a42c" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们还可以重组记录的特定字段。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="9818" class="lt lc hu mn b fv mr ms l mt mu"># let {hero: heroName} = super;<br/>let heroName: string = "Superman";</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="84f3" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">变体</h1><p id="ad7d" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">变体允许我们表达数据结构独有的模块选项。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="af8d" class="lt lc hu mn b fv mr ms l mt mu"># type answer = Yes | No | Maybe;</span></pre><p id="7177" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这是一个引用一组标记的变体。注意，变体中的标签需要大写。</p><p id="0e3c" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们使用<code class="eh mv mw mx mn b">let</code>来绑定这些标签:</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="ceca" class="lt lc hu mn b fv mr ms l mt mu"># let isItRaining: Yes;<br/>let isItRaining: answer = Yes;</span></pre><p id="88c6" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用变体，我们可以用任意多的选项来表达任何东西。Variant对于<code class="eh mv mw mx mn b">switch</code>表达式最有用。它允许我们检查变体的每一种可能的情况。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="0022" class="lt lc hu mn b fv mr ms l mt mu"># let message = <br/>  switch(isItRaining) {<br/>  | Yes =&gt; "Better take an umbrella"<br/>  | No =&gt; "Ok then"<br/>  | Maybe =&gt; "So take an umbrella to be safe"<br/>  };<br/>let message: string = "Better take an umbrella";</span></pre><p id="0e5d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用<code class="eh mv mw mx mn b">if-else</code>表达式也可以达到同样的效果。但是通过使用带有开关的变体，我们可以获得大量的类型系统助手。例如，如果我们忘记覆盖一个case，编译器会给我们一个类型错误。</p><p id="bc75" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">变体的每个标签可以保存额外的数据。比方说，你想开发一款既能记笔记又能做待办事项的应用。注释只需要一个字符串输入，而todo需要一个字符串和一个布尔输入来指示任务是否完成。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="5ac8" class="lt lc hu mn b fv mr ms l mt mu"># type item = Note(string) | Todo(string, bool);<br/># let myItem = Todo("write article", false);</span></pre><p id="10ef" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以使用析构来做到这一点。这样，我们可以给出参数的名称，并在箭头后面使用它们。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="f61e" class="lt lc hu mn b fv mr ms l mt mu"># switch (myItem) {<br/>| Note(text) =&gt; text<br/>| Todo(text, checked) =&gt; text ++ " is done: " ++ string_of_bool(checked)<br/>};<br/>- : string = "write article: false"</span></pre><p id="9dcf" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以给它们取名字，但不一定非要取。我们还可以匹配标签的精确值。</p><p id="bbbe" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以添加一个与重新设计的网站完全匹配的模式，布尔值设置为<code class="eh mv mw mx mn b">false</code>。</p><pre class="jk jl jm jn fq mm mn mo mp aw mq dt"><span id="a4ae" class="lt lc hu mn b fv mr ms l mt mu"># switch(myItem) {<br/>  | Note(text) =&gt; text<br/>  | Todo("redesign website", false) =&gt; "Please first fix the app"<br/>  | Todo(text, checked) =&gt; text ++ " is done: " ++ string_of_bool(checked)<br/>};</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="32a9" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">未完待续…</h1><p id="a2a4" class="pw-post-body-paragraph jx jy hu jz b ka mh iv kc kd mi iy kf kg mj ki kj kk mk km kn ko ml kq kr ks hn dt translated">本系列的第1部分到此结束。对于<strong class="jz hv">第2部分，</strong>请点击此处:</p><div class="mz na fm fo nb nc"><a href="https://hackernoon.com/get-reason-able-with-reasonml-part-2-65d3ab851570" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">使用Reason ml-第2部分</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">非法状态、选项类型、函数、元组、列表、数组和等式</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">hackernoon.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq jt nc"/></div></div></a></div></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="d81b" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我是Rajat S .有抱负的程序员，还有很长的路要走。一个热爱漫威电影的铁杆DC漫画迷。以多任务处理著称。</p><p id="aa69" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">感谢阅读，希望这是有帮助的！请👏如果你喜欢这篇文章，请在这里和/或Twitter上关注我，了解我的最新文章！</p></div></div>    
</body>
</html>