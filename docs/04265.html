<html>
<head>
<title>Get Reason-able with ReasonML — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Reason ml-第2部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/get-reason-able-with-reasonml-part-2-65d3ab851570?source=collection_archive---------13-----------------------#2018-05-19">https://medium.com/hackernoon/get-reason-able-with-reasonml-part-2-65d3ab851570?source=collection_archive---------13-----------------------#2018-05-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e4b3" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">非法状态、选项类型、函数、元组、列表、数组和等式</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/3209d050a2d115e34d0a6afc4a3a4c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cErheM348WFKd444QtgHSw.png"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="7766" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这是<strong class="jz hv"> 3部分系列</strong>的第2部分，在这里我将帮助你理解ReasonML及其所有的语法和语义。我将介绍从基本的<strong class="jz hv">数据类型</strong>到在ReasonML中声明<strong class="jz hv">函数</strong>的所有内容。</p><p id="e728" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果你还没有读第一部分，我建议你先读一读，因为这个系列的所有文章都是相互关联的。</p><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/@geeky_writer_/get-reason-able-with-reasonml-part-1-ac950188141b"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">使用Reason ml-第1部分</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">RTOP、数据类型、字母绑定、词法范围、If-Else和开关、记录和变量</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jt kw"/></div></div></a></div></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="2512" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">用变体消除非法状态</h1><p id="6bc9" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">将多个互斥选项表示为一个数据结构是ReasonML的强大概念之一。但是为了明智地使用它，我们需要重新思考如何对我们的数据建模。</p><p id="09a0" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">首先，我将创建一个简单的应用程序来获取和呈现一些数据。对于这个应用程序，我首先需要定义UI状态。我希望应用程序在等待数据时打印一个加载文本，并在应用程序成功或不成功获取数据时打印一些文本。</p><p id="5650" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们首先宣布你的记录<code class="eh mp mq mr ms b">type request</code>。我们添加了一个类型为<code class="eh mp mq mr ms b">bool</code>的字段<code class="eh mp mq mr ms b">loading</code>来指示请求是否正在加载。对<code class="eh mp mq mr ms b">error</code>字段进行同样的操作。我还需要添加一个类型为<code class="eh mp mq mr ms b">string</code>的<code class="eh mp mq mr ms b">name</code>字段。<code class="eh mp mq mr ms b">name</code>是我希望我的应用程序获取的数据。</p><p id="0125" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">逻辑很简单。如果请求当前正在加载，我们返回<code class="eh mp mq mr ms b">loading</code>。万一失败，我们打印<code class="eh mp mq mr ms b">Something went wrong</code>。当请求成功时，我们将打印<code class="eh mp mq mr ms b">name</code>。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="23a3" class="mx lt hu ms b fv my mz l na nb"># type request = {<br/>  loading: bool,<br/>  error: bool,<br/>  name: string,<br/>};<br/># let myRequest = {<br/>  loading: false,<br/>  error: false,<br/>  name: "Rajat"<br/>};<br/>- : string = "Rajat"</span></pre><p id="4d6b" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">但是仍然有很多可能出错的地方。比如有人把<code class="eh mp mq mr ms b">loading</code>和<code class="eh mp mq mr ms b">error</code>都设为<code class="eh mp mq mr ms b">true</code>怎么办？</p><p id="b645" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><code class="eh mp mq mr ms b">if/else</code>表达式呈现了<code class="eh mp mq mr ms b">loading</code>，但是根据定义，这不应该发生。由于我们的数据结构的方式，它提出了一个问题，在这种情况下我们的UI代码应该做什么？也许显示的是<code class="eh mp mq mr ms b">error</code>而不是<code class="eh mp mq mr ms b">loading</code>？</p><p id="d326" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以使用变体来处理这个问题。我将用一个变量重新创建类型请求。每个标签代表一种状态，<code class="eh mp mq mr ms b">loading</code>、<code class="eh mp mq mr ms b">error</code>、<code class="eh mp mq mr ms b">success</code>。成功是同样的一个额外的字符串。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="3a1f" class="mx lt hu ms b fv my mz l na nb"># type request = Loading | Error | Success(string);</span></pre><p id="f793" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">为要呈现的文本设置状态并编写开关表达式:</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="b376" class="mx lt hu ms b fv my mz l na nb"># let state = Loading;<br/># let ui = <br/>  | Loading =&gt; "Loading..."<br/>  | Error =&gt; "Something went wrong"<br/>  | Success =&gt; "Your name is " ++ name<br/>};</span></pre><p id="ab17" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以改变状态并重新运行我们的开关表达式。所有情况都按预期工作。这样做的好处是，如果我们添加一个<code class="eh mp mq mr ms b">request</code>变体，我们永远不会同时拥有<code class="eh mp mq mr ms b">loading</code>、<code class="eh mp mq mr ms b">error</code>和<code class="eh mp mq mr ms b">success</code>。</p><p id="0e46" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用带有变体的<code class="eh mp mq mr ms b">switch</code>表达式将防止我们忘记一个状态。如果你错过了一个状态，Reason会抛出一个错误。</p><p id="2b60" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这将解决我们的大部分问题。但是我们还有一个案子要处理。如果你的后端没有存储任何数据怎么办？然后应用程序将返回一个空字符串，输出类似于<code class="eh mp mq mr ms b">Your name is </code>。</p><p id="9f23" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">为了处理这个损坏的UI，我们将匹配一个空字符串并返回一个适当的案例。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="1893" class="mx lt hu ms b fv my mz l na nb"># let ui =<br/>  switch(state) {<br/>  | Loading =&gt; "Loading..."<br/>  | Error =&gt; "Something went wrong"<br/>  | Success("") =&gt; "Your name is missing"<br/>  | Success =&gt; "Your name is " ++ name<br/>  };</span></pre><p id="3e77" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">在现实世界中，<code class="eh mp mq mr ms b">Success</code>构造函数将包含另一个数据结构，如另一个变量，如<code class="eh mp mq mr ms b">Record</code>或<code class="eh mp mq mr ms b">List</code>。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="316d" class="mx lt hu ms b fv my mz l na nb"># type userResponse = {<br/>  id: int,<br/>  name: string,<br/>  age: int,<br/>};<br/># type request = Loading | Error | Success(userResponse);<br/># let state = Success({id: 1, name: "Rajat", age: 22});</span></pre><p id="2d1f" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><strong class="jz hv">注意:</strong>类型系统不消除bug。它只能指出未处理的情况，要求你覆盖。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="abc4" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">选项类型</h1><p id="fb30" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">理智不做<code class="eh mp mq mr ms b">null</code>。如果你试图将<code class="eh mp mq mr ms b">null</code>与类型为<code class="eh mp mq mr ms b">int</code>的<code class="eh mp mq mr ms b">age</code>绑定，将无法工作。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="9e31" class="mx lt hu ms b fv my mz l na nb"># let age: int = null;<br/>Error Unbound value null</span></pre><p id="504b" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">有些人可能会说这很棒。<code class="eh mp mq mr ms b">null</code>是我们应用程序中许多许多错误的原因。但是<code class="eh mp mq mr ms b">null</code>确实有它的用途。例如，你想在你的应用程序中引用一些东西，但是你还不知道相应的值是否可用。</p><p id="03c9" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这就是为什么理性为我们提供了一个叫做<code class="eh mp mq mr ms b">option</code>的变体。这个变体有两个标签:</p><ul class=""><li id="6476" class="nc nd hu jz b ka kb kd ke kg ne kk nf ko ng ks nh ni nj nk dt translated"><strong class="jz hv">无</strong> —这表示没有可用的值。</li><li id="6cc3" class="nc nd hu jz b ka nl kd nm kg nn kk no ko np ks nh ni nj nk dt translated"><strong class="jz hv">有的</strong> —这是表示有值。</li></ul><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="e0e8" class="mx lt hu ms b fv my mz l na nb"># None;<br/>- : option('a) = None<br/># Some(42);<br/>- : option(int) = Some(42)</span></pre><p id="256f" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以像这样使用<code class="eh mp mq mr ms b">name</code>:</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="a738" class="mx lt hu ms b fv my mz l na nb"># let name = None;<br/>let name: option('a) = None;<br/># let name = Some("Rajat");<br/>let name: option(string) = Some("Rajat")</span></pre><p id="f91e" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">像任何其他变体一样，我们也可以将它与一个<code class="eh mp mq mr ms b">switch</code>表达式一起使用。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="11c8" class="mx lt hu ms b fv my mz l na nb">let message = <br/>  switch (name) {<br/>  | None =&gt; Sadly I don't know"<br/>  | Some(value) =&gt; "The meaning of life is: " ++ value<br/>  };</span></pre><p id="a6c5" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">有了option，我们就有了一个工具，它允许我们模拟一个新的值，同时仍然是类型安全的，这意味着纯推理程序没有空错误。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="56b8" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">功能</h1><p id="4acc" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">在Reason中声明和使用函数非常简单。匿名函数看起来像这样:</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="235d" class="mx lt hu ms b fv my mz l na nb"># (x) =&gt; x + 1;<br/>- : int =&gt; int = &lt;fun&gt;</span></pre><p id="16b0" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">Reason中的函数由括号中的一个或多个参数定义。如果只有一个参数，可以省略括号。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="8592" class="mx lt hu ms b fv my mz l na nb"># let plusOne = x =&gt; x + 1;<br/># plusOne(4);<br/>- : int = 5</span></pre><p id="1e29" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">要编写一个将整数加到浮点数上的函数，我们可以这样做:</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="9a05" class="mx lt hu ms b fv my mz l na nb"># let add = (x, y) =&gt; {<br/>  let z = float_of_int(x);<br/>  y + z;<br/>};</span></pre><p id="a2a9" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这种语言的另一个特点是它对参数的局部应用。我们可以通过调用带有两个参数的函数将两个整数相加。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="4605" class="mx lt hu ms b fv my mz l na nb"># let add = (x, y) =&gt; x + y;<br/># add(3, 2);<br/>- : int = 5</span></pre><p id="5e3c" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">提供一个参数也是可能的。它不是抛出一个错误，而是作为一个函数返回，其中只需要提供一个参数，在我们的例子中是第二个参数。让我们将函数绑定到一个名称并使用它。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="3d83" class="mx lt hu ms b fv my mz l na nb"># let addThree = add(3);<br/># addThree(2);<br/>- : int = 5;</span></pre></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="1951" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">链接功能</h1><p id="022f" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">简洁易读的代码是良好质量和可维护性的一个重要方面。反向应用操作符<code class="eh mp mq mr ms b">|</code>允许我们将函数链接在一起，而没有创建中间绑定或复杂嵌套的麻烦。</p><p id="6af4" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我将创建一个函数列表，当一起使用时，将获取一个字符串，将其大写，然后将其转换为小写元素。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="e41d" class="mx lt hu ms b fv my mz l na nb"># let info = String.capitalize(String.lowercase("ALERT"));</span></pre><p id="7e9d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用反向应用操作符<code class="eh mp mq mr ms b">|</code>，我们可以这样做:</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="51a7" class="mx lt hu ms b fv my mz l na nb"># let info = "ALERT" |&gt; String.lowercase |&gt; String.capitalize;</span></pre><p id="d2ea" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">结合参数的局部应用，这种语法会非常有用。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="1492" class="mx lt hu ms b fv my mz l na nb"># [8, 3, 6, 1] <br/>  |&gt; List.sort(compare)<br/>  |&gt; List.rev<br/>  |&gt; List.find(x =&gt; x &lt; 4);<br/>- : int = 3</span></pre></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="1ea4" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">递归函数</h1><p id="e831" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">函数递归要求<code class="eh mp mq mr ms b">let</code>绑定在它自己的局部范围内是可访问的。使用<code class="eh mp mq mr ms b">rec</code>关键字，我们可以启用这种可见性来声明递归函数。</p><p id="0376" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我正在创建一个函数，它会数到10，并在每次递增后显示参数。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="0ca8" class="mx lt hu ms b fv my mz l na nb"># let countUntilTen = x =&gt; {   <br/>  if (x &lt; 10) {     <br/>    print_int(x)     <br/>    countUntilTen(x + 1);   <br/>  }; <br/>};</span><span id="92fd" class="mx lt hu ms b fv nq mz l na nb">Error: Unbound value countUntilTen</span></pre><p id="07f7" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们得到这个错误的原因是函数体不能访问函数指向的<code class="eh mp mq mr ms b">let</code>绑定。但是包含<code class="eh mp mq mr ms b">rec</code>关键字使之成为可能。这将允许函数看到并调用它们自己，从而为我们提供递归的能力。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="d232" class="mx lt hu ms b fv my mz l na nb"># let rec countUntilTen = x =&gt; {<br/>  if (x &lt; 10) {<br/>    print_int(x)<br/>    countUntilTen(x + 1);<br/>  };<br/>};<br/>let countUntilTen: int =&gt; unit = &lt;fun&gt;;</span><span id="a6ac" class="mx lt hu ms b fv nq mz l na nb"># countUntilTen(6);<br/>6789- : unit = ()</span></pre><p id="b8df" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果我们想要创建相互递归的函数，我们可以从使用<code class="eh mp mq mr ms b">rec</code>关键字的单个递归函数开始，然后使用<code class="eh mp mq mr ms b">and</code>关键字添加第二个递归函数。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="2571" class="mx lt hu ms b fv my mz l na nb"># let rec add = x =&gt; ! even(x)<br/>  and even = x =&gt; {<br/>    if(x == 0) {<br/>      true;<br/>    } else {<br/>      odd(x - 1);<br/>    };<br/>  };<br/>  let odd: int =&gt; bool = &lt;fun&gt;;<br/>  let even: int =&gt; bool = &lt;fun&gt;;</span></pre></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="3687" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">元组、列表和数组</h1><h2 id="f516" class="mx lt hu bd lu nr ns nt ly nu nv nw mc kg nx ny me kk nz oa mg ko ob oc mi od dt translated">元组</h2><p id="d79c" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">元组是一种数据结构，它允许我们存储任何类型的固定数量的值。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="75b0" class="mx lt hu ms b fv my mz l na nb"># ("Anna", 24);<br/>- : (string, int) = ("Anna", 24)</span></pre><p id="ed57" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">每个元素都由其位置而不是其名称来标识。我们也可以嵌套一个元组。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="30eb" class="mx lt hu ms b fv my mz l na nb"># type point = (int, int);<br/># let myPoint: point = (4, 3);</span></pre><p id="2bd3" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">为了访问一个元组的元素，Reason为我们提供了两个方便的函数来访问前两个元素。<code class="eh mp mq mr ms b">fst</code>将访问第一项，而<code class="eh mp mq mr ms b">snd</code>将访问第二项。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="3d5d" class="mx lt hu ms b fv my mz l na nb"># fst((0,2));<br/>- : int = 0<br/># snd((0,2));<br/>- : int = 2</span></pre><p id="cf60" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">让我们来看看另一个元组:</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="776a" class="mx lt hu ms b fv my mz l na nb"># let (a,b,c) = ("Rajat","Writer",23);<br/>let a: string = "Rajat";<br/>let b: string = "Writer";<br/>let c: int = 23;</span></pre><p id="58f2" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这里，如果您不想给每个位置分配一个值，您可以简单地用<code class="eh mp mq mr ms b">_</code>替换该值。</p><p id="b652" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">每个元组都是不可变的。所以我们不能更新元组，只能创建新的元组。</p><h2 id="66be" class="mx lt hu bd lu nr ns nt ly nu nv nw mc kg nx ny me kk nz oa mg ko ob oc mi od dt translated">列表</h2><p id="d481" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">与元组不同，列表是同质的和不可变的。所以我们不能在一个列表中存储不同类型的条目。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="4a28" class="mx lt hu ms b fv my mz l na nb"># let List = ["Rajat", "Writer"];</span></pre><p id="59dd" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">但是，Reason允许我们使用一个变量来保存不同的类型，并创建一个标签列表。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="b683" class="mx lt hu ms b fv my mz l na nb"># type rajat = Name(string) | Age(int);<br/># [Name("Rajat"), Age(23)];</span></pre><p id="0dc0" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">由于是不可变的，我们可以<code class="eh mp mq mr ms b">append</code>、<code class="eh mp mq mr ms b">prepend</code>，甚至替换列表中的一项。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="8f71" class="mx lt hu ms b fv my mz l na nb"># List.append(["Rajat"],["Writer"]);<br/>- : list(string) = ["Rajat", "Writer"]<br/># ["Rajat"] @ ["Writer"]<br/>- : list(string) = ["Rajat", "Writer"]</span></pre><p id="0521" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">要将一个或多个元素添加到列表中，使用<code class="eh mp mq mr ms b">...</code>操作符。注意<code class="eh mp mq mr ms b">...</code>只能用于前置元素。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="e44e" class="mx lt hu ms b fv my mz l na nb"># [0, ...[1, 2, 3]];<br/>- : list = [0, 1, 2, 3]</span></pre><p id="8e84" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">要访问一个列表，你需要使用<code class="eh mp mq mr ms b">switch</code>表达式。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="1188" class="mx lt hu ms b fv my mz l na nb"># let list = ["Rajat", "Writer"];<br/># let message = <br/>  switch(list) {<br/>  | [] =&gt; "There is no data"<br/>  | [head, ...rest] =&gt; "My name is " ++ head<br/>};<br/>let message: string = "My name is Rajat";</span></pre><p id="5b56" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这可能会变得相当复杂。我们可以使用<code class="eh mp mq mr ms b">List.nth</code>来访问列表中的元素。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="1679" class="mx lt hu ms b fv my mz l na nb"># List.nth([2, 3], 0);<br/>- : int = 2</span></pre><p id="6fc3" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">但是同样，如果列表太小，这个方法会引发异常。</p><p id="ae00" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">相反，我们可以使用<code class="eh mp mq mr ms b">List.map</code>来操作列表中的每一项。<code class="eh mp mq mr ms b">List.map</code>也可以接受一个函数作为它的第一个参数，本地列表作为第二个参数。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="c7d5" class="mx lt hu ms b fv my mz l na nb"># List.map(x =&gt; x * 5, [2, 4]);<br/>- : list(int) = [10, 20]</span></pre><p id="0d91" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们在Reason中还有其他的函数，比如<code class="eh mp mq mr ms b">find</code>、<code class="eh mp mq mr ms b">filter</code>、<code class="eh mp mq mr ms b">sort</code>、<code class="eh mp mq mr ms b">exist</code>、<code class="eh mp mq mr ms b">split</code>来帮助列表做更多的事情。</p><h2 id="39e0" class="mx lt hu bd lu nr ns nt ly nu nv nw mc kg nx ny me kk nz oa mg ko ob oc mi od dt translated">数组</h2><p id="b86a" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">数组类似于列表，除了数组的内容被包装在管道和括号中，与列表不同，数组是可变的。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="9560" class="mx lt hu ms b fv my mz l na nb"># let array = [|2, 3|];<br/># array[0];<br/>- : int = 2<br/># let array[0] = 3;</span></pre></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="3ee5" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">平等</h1><p id="1bf3" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">在任何编程语言中，通常有两种类型的等式:</p><ul class=""><li id="3cc9" class="nc nd hu jz b ka kb kd ke kg ne kk nf ko ng ks nh ni nj nk dt translated"><strong class="jz hv">结构相等</strong> —比较两个值的内容是否相同。</li><li id="98ce" class="nc nd hu jz b ka nl kd nm kg nn kk no ko np ks nh ni nj nk dt translated"><strong class="jz hv">引用等式</strong> —检查两个值是否指向内存中的同一个表示。</li></ul><h2 id="b4cf" class="mx lt hu bd lu nr ns nt ly nu nv nw mc kg nx ny me kk nz oa mg ko ob oc mi od dt translated">结构平等</h2><p id="9f92" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">结构相等用于比较数据结构、布尔值、元组、列表和记录。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="7cbb" class="mx lt hu ms b fv my mz l na nb"># "Rajat" == "Rajat";<br/>- : bool = true<br/># true == false;<br/>- : bool = false;</span></pre><p id="45b0" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">按理说，我们甚至可以使用结构等式来比较嵌套结构，并检查如下所示的不相等性:</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="bba6" class="mx lt hu ms b fv my mz l na nb"># (false, [{name: "Rajat", job: "writer"}]) != (true, [(name: "Rajat", job: "writer"}]);<br/>- : bool = false</span></pre><h2 id="1709" class="mx lt hu bd lu nr ns nt ly nu nv nw mc kg nx ny me kk nz oa mg ko ob oc mi od dt translated"><strong class="ak">参考等式</strong></h2><p id="12a7" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">与结构相等不同，引用相等不比较存储在值中的内容。相反，它检查这些值是否指向内存中的相同表示。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="747e" class="mx lt hu ms b fv my mz l na nb"># let rajat = {name: "Rajat", job: "Writer"};<br/># rajat === rajat;<br/>- : bool = true<br/># rajat === {name: "Rajat", job: "Writer"};<br/>- : bool false</span></pre><p id="95b2" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">只有少数情况下你会用到引用相等。虽然这是一个非常快速的检查，但如果传入了具有相同内容的值，它也可能导致我们的应用程序错过。通过引用比较两个整数，总会发现它们是如何实现的。</p><pre class="jk jl jm jn fq mt ms mu mv aw mw dt"><span id="f538" class="mx lt hu ms b fv my mz l na nb"># 24 === 24;<br/>- : bool = true</span></pre></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="efa3" class="ls lt hu bd lu lv lw lx ly lz ma mb mc ja md jb me jd mf je mg jg mh jh mi mj dt translated">未完待续…</h1><p id="a2a4" class="pw-post-body-paragraph jx jy hu jz b ka mk iv kc kd ml iy kf kg mm ki kj kk mn km kn ko mo kq kr ks hn dt translated">本系列<strong class="jz hv"> 3 </strong>的<strong class="jz hv">部分2 </strong>到此结束。<strong class="jz hv">第三部</strong>马上就要出了，抓紧了:)</p><p id="f4be" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这里是<strong class="jz hv">第一部</strong>，如果你还没看的话。</p><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/@geeky_writer_/get-reason-able-with-reasonml-part-1-ac950188141b"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hv fv z el lb eo ep lc er et ht dt translated">使用Reason ml-第1部分</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">RTOP、数据类型、字母绑定、词法范围、If-Else和开关、记录和变量</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jt kw"/></div></div></a></div></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><p id="d81b" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我是Rajat S，<a class="ae oe" href="https://geekyants.com/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"> GeekyAnts </a>的技术内容作者。有抱负的程序员还有很长的路要走。一个热爱漫威电影的铁杆DC漫画迷。以多任务处理著称。</p><p id="aa69" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">感谢阅读，希望这是有帮助的！请👏如果你喜欢这篇文章，请在这里和/或在<a class="ae oe" href="https://twitter.com/geeky_writer_" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，了解我的新文章！</p></div></div>    
</body>
</html>