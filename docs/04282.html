<html>
<head>
<title>Semantic Segmentation and Transposed Convolution.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">语义分割和转置卷积。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/semantic-segmentation-and-transposed-convolution-4b1dd964a14b?source=collection_archive---------8-----------------------#2018-05-20">https://medium.com/hackernoon/semantic-segmentation-and-transposed-convolution-4b1dd964a14b?source=collection_archive---------8-----------------------#2018-05-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/4c41d62cb7c2509f9c1b409c039ccb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*y9tEWT21B3Vc3414mI6sQg.gif"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Identifying motorable areas using FCN8</figcaption></figure><p id="03da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">分割对于图像分析任务是必不可少的。<em class="ka">语义分割</em>描述的是将一幅图像的每个像素点与一个类别标签关联起来的过程，(比如<em class="ka">花</em>、<em class="ka">人</em>、<em class="ka">路</em>、<em class="ka">天</em>、<em class="ka">洋</em>，或者<em class="ka">车</em>)。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/fee79534d67a0c9d60dc31c734f36ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*JMIdlC6SitUNT4pAPzolGQ.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">image source: <a class="ae kg" href="https://www.mathworks.com/help/vision/ug/semantic-segmentation-basics.html" rel="noopener ugc nofollow" target="_blank">Mathworks</a></figcaption></figure><p id="f0af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在语义分割方法中，有许多领域有很大的潜力。其中显然包括自动驾驶、锅炉的工业检查、热图表等。卫星图像中可见地形的分类、医学成像分析。出于个人兴趣，我还研究了通过植物的叶子来检测植物中的疾病。这也包括从实际疾病标记中分离出静脉或叶片的分割。这也使得疾病的处理和检测更容易和更准确。</p><p id="41a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">但是什么是语义分割呢？</strong></p><p id="8b59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">语义分割是在像素级别理解图像，也就是说，我们希望给图像中的每个像素分配一个对象类。例如，看看下面的图片。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kh"><img src="../Images/ca7cc39e806f7439b05efe5348452485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rwhmCSPaVrpsSR29d-TwHw.jpeg"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Input Image <a class="ae kg" href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/segexamples/index.html" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kh"><img src="../Images/b0d32fccdacc28482b4e541d5e130c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*RkgTp8B_ngPJ09sd3GMvFA.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">semantic segmentation. <a class="ae kg" href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/segexamples/index.html" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="f313" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的图片中，只有三个类，人类，自行车和其他东西。FCN可以被训练来探测道路、植物和天空。<a class="ae kg" href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/" rel="noopener ugc nofollow" target="_blank"> VOC2012 </a>和<a class="ae kg" href="http://mscoco.org/explore/" rel="noopener ugc nofollow" target="_blank"> MSCOCO </a>是语义分割最重要的数据集。</p><p id="b480" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2014年，来自Berkeley的Long等人的<a class="ae kg" href="http://blog.qure.ai/notes/semantic-segmentation-deep-learning-review#fcn" rel="noopener ugc nofollow" target="_blank">全卷积网络(FCN) </a>推广了用于无任何全连接层的密集预测的CNN架构。这允许为任何大小的图像生成分割图，并且与先前使用的补丁分类方法相比也快得多。几乎所有后来的语义分割方法都采用了这种模式。</p><p id="3d91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了完全连接的层，使用CNN进行分割的一个主要问题是<em class="ka">汇集层</em>。池层扩大了视野，能够在丢弃“在哪里”信息的同时聚合上下文。然而，语义分割需要类别图的精确对齐，因此需要保留空间信息。为了解决这个问题，文献中发展了两种不同的体系结构。</p><p id="54d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个是编码器-解码器架构。编码器通过合并层逐渐降低空间维度，解码器逐渐恢复对象细节和空间维度。<strong class="je hv"> <em class="ka">从编码器到解码器通常有捷径连接，帮助解码器更好地还原物体细节。</em>T3】</strong></p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ki"><img src="../Images/737121535f45ac41efaacea0c0ce0062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*LeETJKay90taXAD8dt3dhg.png"/></div></figure><p id="ee76" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里不讨论第二种方法。</p><p id="4ff9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在经历转置卷积中的填充差异时，我学到了一些关于相同和有效填充的真正有趣的东西。这里要理解的最重要的事情是，滤波器核不会超出有效填充中的输入图像尺寸，这对于卷积和转置卷积都是如此。同样在同样的填充内核中可以走出图像的维度。</p><p id="1b54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再谈<strong class="je hv">有效填充。</strong>随着内核步幅的增加，输入图像会在像素之间填充。如果跨距为2，则在每个现有的行和列之间将填充一个行和列。如果步幅为1，则不会有任何填充。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kj"><img src="../Images/43be766adef879f9d180039415ef07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*TfPbpyiiqzq0RqdWcxCkkA.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Stride:1, kernel:3x3, <a class="ae kg" href="https://distill.pub/2016/deconv-checkerboard/" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/33dc908e2b73a607ab00b68a079a89b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*3X92MfH08VH4hU56cLY_Aw.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Stride:2, kernel:3x3, <a class="ae kg" href="https://distill.pub/2016/deconv-checkerboard/" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="9048" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">保持k不变并增加步幅会减少重叠。这种重叠指的是由相邻内核操作计算的公共区域。让我们也想象一下相反的效果。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/fba96de476d407dadaf553f5dc2ca60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*jcoxT1Q1Ijh6QZ27EtxSlg.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Stride:2, kernel:4x4, <a class="ae kg" href="https://distill.pub/2016/deconv-checkerboard/" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="7265" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，填充的输入图像取决于步幅</p><blockquote class="km kn ko"><p id="024e" class="jc jd ka je b jf jg jh ji jj jk jl jm kp jo jp jq kq js jt ju kr jw jx jy jz hn dt translated">Ip_d= (I-1)*s</p><p id="fcf4" class="jc jd ka je b jf jg jh ji jj jk jl jm kp jo jp jq kq js jt ju kr jw jx jy jz hn dt translated">其中，s =步幅，I=输入尺寸，Ip_d为填充输入尺寸。</p></blockquote><p id="d444" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并且输出图像尺寸取决于填充的输入图像尺寸和内核尺寸，如下所示:</p><blockquote class="km kn ko"><p id="ca22" class="jc jd ka je b jf jg jh ji jj jk jl jm kp jo jp jq kq js jt ju kr jw jx jy jz hn dt translated">o _ d = Ip _ d+k；</p><p id="61ac" class="jc jd ka je b jf jg jh ji jj jk jl jm kp jo jp jq kq js jt ju kr jw jx jy jz hn dt translated">o _ d =(I-1)* s+k；其中k是内核大小。</p></blockquote><p id="5ae9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无论内核大小是大于还是小于步幅，这个等式都成立，并且可以在这里得到验证<a class="ae kg" href="https://distill.pub/2016/deconv-checkerboard/" rel="noopener ugc nofollow" target="_blank"/>。然而，我的同事<a class="ks kt gr" href="https://medium.com/u/efb9f9c5c826?source=post_page-----4b1dd964a14b--------------------------------" rel="noopener" target="_blank"> Keshav Aggarwal </a>在tensorflow上玩一些代码时推导出了一个<a class="ae kg" href="https://towardsdatascience.com/transpose-convolution-77818e55a123" rel="noopener" target="_blank">更好的等式</a>，它说。</p><blockquote class="km kn ko"><p id="19e8" class="jc jd ka je b jf jg jh ji jj jk jl jm kp jo jp jq kq js jt ju kr jw jx jy jz hn dt translated">O_d <em class="hu"> = I * s+ max(k — s，0)；其中所有变量同上。</em></p></blockquote><p id="3a02" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我建议稍微修改一下代码。</p><p id="eeb2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">同样的填充</strong>更简单但相当神秘。相同的填充总是填充图像外部的空行和空列。在正常卷积中，即使填充是相同的，并且内核可以用所提到的步幅适当地扫描整个图像，实际上在输入图像上没有进行填充。然而，如果由于内核大小和步幅值而留下一些行或列，则添加一些额外的列和行来覆盖整个图像。</p><p id="428c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在转置卷积中情况并非如此。输出图像尺寸不依赖于滤波器的核心尺寸，而是增加所述步幅的次数。</p><blockquote class="km kn ko"><p id="bcee" class="jc jd ka je b jf jg jh ji jj jk jl jm kp jo jp jq kq js jt ju kr jw jx jy jz hn dt translated">o _ d = I _ d * s；</p><p id="e22e" class="jc jd ka je b jf jg jh ji jj jk jl jm kp jo jp jq kq js jt ju kr jw jx jy jz hn dt translated">其中s =步幅，I_d=输入尺寸，O_d为填充输入尺寸。</p></blockquote><p id="6b8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，输出尺寸由系统预先计算，然后在应用滤波器以保持输出尺寸之前，在外部对图像进行相应的填充，与去卷积后计算的尺寸相同。优先添加列，在图像的两侧相等。然而，如果它们不能相等地相加，则剩余的额外列被添加到右侧。</p><p id="9937" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，我如何使用这两种滤镜对图像进行上采样呢？</p><p id="a112" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很简单，因为现在我们有了方程。假设我们想将一幅图像放大到原来的两倍。</p><p id="fe1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于<strong class="je hv">相同的填充</strong>你可以设置内核为任何合适的值，步幅为2。</p><p id="884f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于<strong class="je hv">有效填充</strong>，您可以将内核和步幅值都设置为2。</p><p id="0c90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，这些过滤器的性能是一个实验领域。我发现相同的填充比这里的有效填充效果更好。将内核大小设置为偶数并不是一个好的做法，但是如果您想使用有效的填充将内核大小提高2倍，似乎没有其他方法。</p><p id="3040" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以访问我的<a class="ae kg" href="https://github.com/UjjwalSaxena" rel="noopener ugc nofollow" target="_blank"> Github </a>个人资料中的一些项目，更多文章请访问我的媒体账户或<a class="ae kg" href="https://erujjwalsaxena.wordpress.com/" rel="noopener ugc nofollow" target="_blank"> Wordpress </a>。</p></div></div>    
</body>
</html>