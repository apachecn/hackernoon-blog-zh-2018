<html>
<head>
<title>When to Use Git Reset, Git Revert &amp; Git Checkout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用Git重置、Git恢复和Git检验</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/when-to-use-git-reset-git-revert-git-checkout-dc4824795d9?source=collection_archive---------4-----------------------#2018-05-21">https://medium.com/hackernoon/when-to-use-git-reset-git-revert-git-checkout-dc4824795d9?source=collection_archive---------4-----------------------#2018-05-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1dfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git工具箱提供了多种独特的工具来修复开发过程中的错误。像<code class="eh jp jq jr js b">git reset</code>、<code class="eh jp jq jr js b">git checkout</code>和<code class="eh jp jq jr js b">git revert</code>这样的命令允许您<strong class="it hv">撤销存储库中的</strong>错误变更。</p><p id="46fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为它们执行相似的操作，所以很容易混淆。对于何时应该使用和不应该使用每个命令，有一些指导原则和规则。我们来看看吧！</p><blockquote class="ju jv jw"><p id="5198" class="ir is jt it b iu iv iw ix iy iz ja jb jx jd je jf jy jh ji jj jz jl jm jn jo hn dt translated"><em class="hu">小心！您不能总是在一个</em> <a class="ae ka" href="https://git-scm.com/book/en/v2/Git-Basics-Undoing-Things" rel="noopener ugc nofollow" target="_blank"> <em class="hu">撤销</em> </a> <em class="hu">后重做。这是Git中少数几个如果做错了可能会丢失一些工作的领域之一。</em></p></blockquote><h1 id="f696" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用Git命令撤销</h1><p id="e12a" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">让我们首先阐明这三个命令之间的主要区别。</p><h1 id="29f3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结账:</h1><ul class=""><li id="a6a6" class="le lf hu it b iu kz iy la jc lg jg lh jk li jo lj lk ll lm dt translated">用这个来移动<a class="ae ka" href="https://kolosek.com/git-branches/" rel="noopener ugc nofollow" target="_blank">头指针</a>到一个特定的提交或者<strong class="it hv">分支之间的切换</strong>。</li><li id="4228" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">它<strong class="it hv">回滚</strong>任何特定提交的内容更改。</li><li id="9789" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">这将<strong class="it hv">而不是</strong>对提交历史进行更改。</li><li id="dc9e" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">有可能<strong class="it hv">覆盖工作目录中的</strong>文件。</li></ul><h1 id="86f0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">还原:</h1><ul class=""><li id="aca7" class="le lf hu it b iu kz iy la jc lg jg lh jk li jo lj lk ll lm dt translated">回滚您已提交的更改。</li><li id="df1e" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">通过反转指定的提交来创建一个新的提交。因此，会将新的提交历史记录添加到项目中，但不会修改现有的提交历史记录。</li><li id="449b" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">有可能覆盖工作目录中的文件。</li></ul><h1 id="e0ff" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">重置:</h1><ul class=""><li id="6f9e" class="le lf hu it b iu kz iy la jc lg jg lh jk li jo lj lk ll lm dt translated">用这个来<strong class="it hv">返回</strong>整个<em class="jt">工作树到最后提交的状态。这将丢弃私有分支中的提交或丢弃未提交的更改！</em></li><li id="c282" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">提交分支头当前指向的更改。它改变了现有的提交历史。</li><li id="15f8" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">可用于<strong class="it hv">卸载</strong>一个文件。</li></ul><p id="04c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ka" href="https://kolosek.com/git-commands-tutorial-part1/" rel="noopener ugc nofollow" target="_blank">每个命令</a>都让你<strong class="it hv">撤销</strong>你的存储库中的某种改变，只有签出和重置可以用来操作提交或单个文件。</p><h1 id="60c2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用命令</h1><p id="7fe9" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">有很多不同的方法可以<strong class="it hv">撤销你的更改</strong>，这完全取决于当前的场景。选择适当的方法取决于您是否错误地提交了变更，如果您提交了变更，则取决于您是否共享了变更。</p><h1 id="d7ec" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">撤消公共更改</h1><p id="a727" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><em class="jt">场景:</em>您在hotfix分支中为您还不想执行的提交所做的<code class="eh jp jq jr js b"><a class="ae ka" href="https://kolosek.com/git-commands-tutorial-part2/" rel="noopener ugc nofollow" target="_blank">git push</a></code>映像。</p><p id="ea80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">解决方案:</em>解决这个问题最安全的方法是通过<strong class="it hv">恢复</strong>您的更改，因为它不会重写提交历史。</p><pre class="ls lt lu lv fq lw js lx ly aw lz dt"><span id="e37b" class="ma kc hu js b fv mb mc l md me">git checkout<br/>hotfix git revert HEAD~1</span></pre><p id="907e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">结果:</em>您已成功撤消已提交的更改！旧提交中更改的所有内容都将被新提交还原。Git强制您提交或<a class="ae ka" href="https://kolosek.com/git-stash/" rel="noopener ugc nofollow" target="_blank">隐藏</a>工作目录中的任何更改，这些更改将在签出过程中丢失。</p><figure class="ls lt lu lv fq mg fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/66f2cf64cf82b4ac16fda2b95cee3ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*qYgWOWFHYDUxQH3I.png"/></div></figure><blockquote class="ju jv jw"><p id="0d9b" class="ir is jt it b iu iv iw ix iy iz ja jb jx jd je jf jy jh ji jj jz jl jm jn jo hn dt translated"><em class="hu">你可以把</em> <code class="eh jp jq jr js b"><em class="hu">git revert</em></code> <em class="hu">想象成一个撤销</em> <strong class="it hv"> <em class="hu">已提交</em> </strong> <em class="hu">变更的工具，而</em> <code class="eh jp jq jr js b"><em class="hu">git reset HEAD</em></code> <em class="hu">则是用来撤销</em> <strong class="it hv"> <em class="hu">未提交</em> </strong> <em class="hu">变更的。</em></p></blockquote><h1 id="62fb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">撤消本地更改</h1><p id="1cbf" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><em class="jt">场景:</em>你开始着手一个特性，但是你不喜欢最终的结果。这些变化还没有<strong class="it hv">与其他任何人</strong>分享。</p><p id="731e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">解决方案:</em>你想要<strong class="it hv">撤销文件中所有</strong>到之前的状态，就像上次<a class="ae ka" href="https://kolosek.com/git-commands-tutorial-part2/" rel="noopener ugc nofollow" target="_blank">提交</a>时的样子。</p><pre class="ls lt lu lv fq lw js lx ly aw lz dt"><span id="62f7" class="ma kc hu js b fv mb mc l md me">git checkout file_name.rb</span></pre><p id="5eaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">结果:</em>文件<code class="eh jp jq jr js b">file_name.rb</code>已被<strong class="it hv">恢复到</strong>Git先前已知的状态。请注意，这将删除文件的所有后续更改！</p><blockquote class="ju jv jw"><p id="58c2" class="ir is jt it b iu iv iw ix iy iz ja jb jx jd je jf jy jh ji jj jz jl jm jn jo hn dt translated"><em class="hu">您可以使用</em> <code class="eh jp jq jr js b"><em class="hu">git checkout branch_name</em></code> <em class="hu">在分支之间切换。Git强制您提交或隐藏工作目录中的任何更改，这些更改将在签出操作中丢失。</em></p></blockquote><h1 id="bdb5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">撤消私有更改</h1><p id="aad9" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><em class="jt">场景:</em>你已经在<a class="ae ka" href="https://kolosek.com/git-branches/" rel="noopener ugc nofollow" target="_blank">热修复分支</a>本地提交了一些东西，但是一切都很糟糕！您希望从当前分支中删除最后两次提交。</p><p id="eef4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">解决方案:</em> <strong class="it hv">重置</strong>修复分支向后两次提交，就好像这些提交从未发生过一样。</p><pre class="ls lt lu lv fq lw js lx ly aw lz dt"><span id="c660" class="ma kc hu js b fv mb mc l md me">git checkout hotfix<br/>git reset HEAD~2</span></pre><p id="c95e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">结果:</em>我们的git存储库已经被<strong class="it hv">倒回</strong>指定的提交。那些被遗漏的提交现在是孤立的，将在下次Git执行垃圾收集时被移除。现在，它们的内容仍然在磁盘上。</p><figure class="ls lt lu lv fq mg fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/1754424f9280a319840f1bf318a61c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*WwOvMahMefnzmjaS.png"/></div></figure><p id="bc83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当执行<code class="eh jp jq jr js b"><a class="ae ka" href="https://kolosek.com/git-commands-tutorial-part2/" rel="noopener ugc nofollow" target="_blank">git reset</a></code> <a class="ae ka" href="https://kolosek.com/git-commands-tutorial-part2/" rel="noopener ugc nofollow" target="_blank"> </a>时，您可以使用其中一个参数告诉Git如何处理您的<strong class="it hv">索引</strong>(将成为下一次提交的文件集)和<strong class="it hv">工作目录</strong>:</p><ul class=""><li id="f3ee" class="le lf hu it b iu iv iy iz jc mj jg mk jk ml jo lj lk ll lm dt translated"><code class="eh jp jq jr js b">--soft</code>:告诉Git将HEAD重置为另一个提交，这样索引和工作目录将不会以任何方式被改变。在原始文件头和提交之间更改的所有文件都将被转移。</li><li id="142d" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated"><code class="eh jp jq jr js b">--mixed</code>:就像软键一样，这个会重置HEAD到另一个提交。它还会重置<strong class="it hv">索引</strong>与之匹配，而工作目录不会被触动。所有的<strong class="it hv">变更</strong>将保留在工作目录中，并显示为已修改，但不是暂存的。</li></ul><blockquote class="ju jv jw"><p id="016a" class="ir is jt it b iu iv iw ix iy iz ja jb jx jd je jf jy jh ji jj jz jl jm jn jo hn dt translated"><em class="hu"/><code class="eh jp jq jr js b"><em class="hu">--mixed</em></code><em class="hu">和</em> <code class="eh jp jq jr js b"><em class="hu">--soft</em></code> <em class="hu">的主要区别在于你的指数是否也修改。查看更多关于</em><a class="ae ka" href="https://gist.github.com/tnguyen14/0827ae6eefdff39e452b" rel="noopener ugc nofollow" target="_blank"><em class="hu">git-reset-guide</em></a><em class="hu">。</em></p></blockquote><ul class=""><li id="eff3" class="le lf hu it b iu iv iy iz jc mj jg mk jk ml jo lj lk ll lm dt translated"><code class="eh jp jq jr js b">--hard</code>:这将重置一切——它将HEAD重置回另一个提交，重置索引以匹配它，并重置工作目录以匹配它。</li></ul><h1 id="08e7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">提示和技巧</h1><p id="f352" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我将介绍另外两个在您的Git冒险中可以派上用场的东西。</p><h1 id="fec7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">修复以前的提交消息</h1><p id="94d5" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><em class="jt">场景:</em>每个人在写提交时都会犯打字错误，这完全没问题！在你做一个<code class="eh jp jq jr js b">git push</code>之前，它可以很容易地被修复。</p><p id="bd05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">解决方法:</em>运行<code class="eh jp jq jr js b">git commit --amend</code>或<code class="eh jp jq jr js b">git commit --amend -m 'The new message'</code>即可。这将更新并用新的提交替换最近的提交。</p><h1 id="e516" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">撤消后重做</h1><p id="dc4a" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><em class="jt">场景:</em>你对一些不想要的改变做了一个<code class="eh jp jq jr js b">git reset --hard</code>，但是后来你意识到你其实需要它们。</p><p id="fa5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">解决:</em> <code class="eh jp jq jr js b">git reflog</code>来救你了！这是一个恢复项目历史的惊人命令，它可以恢复<em class="jt">几乎</em>任何东西。</p><p id="841d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">希望这三个工具能在你需要撤销最近的更改时帮到你。</em></p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="5f59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">原载于2018年5月21日</em><a class="ae ka" href="https://kolosek.com/git-reset-revert-and-checkout/?utm_source=me" rel="noopener ugc nofollow" target="_blank"><em class="jt">kolosek.com</em></a><em class="jt">。</em></p></div></div>    
</body>
</html>