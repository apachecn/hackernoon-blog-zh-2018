<html>
<head>
<title>Nix: Haskell Concepts for Package Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nix:包管理的Haskell概念</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/nix-haskell-concepts-for-package-management-65830ac89659?source=collection_archive---------7-----------------------#2018-05-21">https://medium.com/hackernoon/nix-haskell-concepts-for-package-management-65830ac89659?source=collection_archive---------7-----------------------#2018-05-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/81ebd273a6d5fb6745f879c513edcdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4BvMFtQaASkKn-oO--pNQ.png"/></div></div></figure><p id="1434" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到我的BayHac文章中，我讨论了我和T2尼克斯和T4尼克斯的一些冒险经历。我没做多少事。但我仍然很好奇，想了解更多关于这些系统的知识。我在以前的工作中“使用”了一点Nix。我说的“用过”是指我已经学会了足够的基本命令来编写代码，继续我的生活。但我从未对“为什么选择Nix”或“Nix有什么好处”有充分的理解。所以我要花几周时间对这个项目做一个高层次的概述，以及它为什么这么酷。</p><p id="9e60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为介绍，Nix是一个纯粹的功能包管理器。它的目标是成为一个语言无关的系统，以实现确定性的构建。我们将在下面讨论成为一个“纯粹功能性的”包管理器意味着什么。但是使Nix成为现在这个样子的许多属性在Haskell中也存在。因此，虽然您可以将Nix用于任何语言，但是到目前为止，大多数开发工作都来自Haskellers。同时，<a class="ae ka" href="https://nixos.org/" rel="noopener ugc nofollow" target="_blank"> NixOS </a>是一个linux发行版，它试图在操作系统级别应用Nix的主要原则。</p><p id="a80a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一篇文章将讨论Nix的基础知识，它的优点和缺点。下周，我们将看看HNix项目，它试图在Haskell中实现Nix。尽管Nix绝对不是Haskell最容易使用的包管理器，但理解这一点很重要。目前，我仍然推荐从<a class="ae ka" href="https://docs.haskellstack.org/en/stable/README/" rel="noopener ugc nofollow" target="_blank">栈</a>开始。您可以阅读文档或查看我们的免费<a class="ae ka" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank">堆栈迷你课程</a>以了解更多信息！如果你以前从未使用过Haskell，下载我们的<a class="ae ka" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>开始吧！</p><p id="3d70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，为了激励Nix的使用，让我们考虑一些关于包管理的更广泛的问题。</p><h1 id="d245" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">包装问题</h1><p id="ca0a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在最基本的层面上，一个包管理器应该能让你用少量的命令(~3)就能让一个程序启动并运行。大多数人都完成了这项任务，但总有一些复杂的问题。我们将关注两个主要问题。一个是版本控制。这包括版本化您自己的项目和版本化依赖项。另一个问题与应用程序的可移植性有关。</p><p id="a339" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当Cabal还年轻的时候，版本问题就一直困扰着Haskell开发者。默认情况下，Cabal会在系统范围内安装依赖项。但是假设您的机器上有许多项目。这些可能依赖于同一个库的不同版本。这可能会导致系统中的冲突，从而导致多个项目不可用。</p><p id="7fc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Cabal沙盒和Stack程序的加入缓解了这个问题。这两个系统都在项目特定的位置安装依赖项。但是仍然存在一个问题，即很难回滚到项目的前一个版本。卸载和降级软件包的命令并不直观。如果你不小心，他们很容易打碎东西。</p><p id="1732" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同时，看不见的依赖威胁着我们的便携性。这在构建C或C++程序时比Haskell程序更常见。c库通常仍然安装在系统范围内。结果之一是，您的系统上可能有来自另一个项目的库。然后一个新的项目也依赖于它，但是你忘记列出这种依赖。它在您的本地机器上运行良好。但是当你把你的代码放到其他地方时，这种依赖就找不到了。这可能会很麻烦。</p><h1 id="a150" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Nix功能方法</h1><p id="44c5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Nix(包管理器)试图通过使用功能性的包管理方法来避免这些问题。它将每个包视为一个由函数构造的值。任何包的函数的关键输入是它的依赖图。也就是说，一个包是最终的输出，而其他(版本化的)库是输入。您构建的包的每个<strong class="je hv">版本</strong>都有一个唯一的标识符。该标识符是依赖图的加密散列。因此，如果程序的任何依赖关系发生变化，您将重新构建并创建一个全新版本的包。这意味着添加依赖项、删除依赖项或更改版本。</p><p id="66a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Nix将其所有包存储在<code class="eh le lf lg lh b">/nix/store</code>目录中。因此，您可能会构建项目的一个版本，该版本位于以下目录中:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="f49c" class="lq kc hu lh b fv lr ls l lt lu">/nix/store/2gk7rk2sxx2dkmsjr59gignrfdmya8f6s-my-project-1.0.1</span></pre><p id="4fbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，您可能会更改依赖关系，并最终使用另一个目录。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="88ad" class="lq kc hu lh b fv lr ls l lt lu">/nix/store/lg5mkbclaphyayzsxnjlxcko3kll5nbaie-my-project-1.0.2</span></pre><p id="b9b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样做的后果是什么？</p><p id="aab1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，对我们的项目进行版本控制非常容易！如果我们决定回滚到以前的依赖集，那个版本将仍然存在于我们的机器上！我们将更新依赖集。然后它计算依赖图的散列，这将匹配一个旧的配置。所以我们都准备好了！这也适用于我们的任何依赖关系。</p><p id="5345" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，存在与回滚相关的特定命令。这意味着你可以升级软件包，而不用担心任何困难。</p><p id="8978" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Nix也解决了我们上面提到的第二个问题。首先，我们显式地将所有依赖项声明为输入。第二，我们只使用从Nix商店获得的依赖项，而不是任何系统范围的位置。这意味着我们的推导是完整的。因此，其他人应该能够接受这个定义并自己构建它。</p><h1 id="236c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Nix操作系统</h1><p id="b674" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">NixOS试图从Nix包管理器中吸取许多经验教训，并将它们应用于操作系统级别。困扰软件包管理的许多问题也困扰着操作系统管理。例如，用<code class="eh le lf lg lh b">sudo apt-get install</code>升级软件包可能是一个有风险的操作。回滚可能很困难，而且在升级之前测试将要发生的事情几乎是不可能的。NixOS修复了这些。它允许您拥有版本化的、可复制的系统配置。您可以轻松地回滚到某个配置。它还为您提供了关于系统修改的原子事务。这样，即使出现问题，您也可以完全恢复到原来的系统状态。</p><h1 id="e13f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Nix的缺点</h1><p id="9040" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Nix的一个潜在弱点是它默认从源代码构建。这意味着你经常会有<strong class="je hv">长的构建时间</strong>，即使是对你的代码或者依赖关系的小的改变。如果幸运的话，您可以将Nix缓存用于您的特定库。它存储了您可以使用的预构建的二进制文件。但是根据我使用Nix的经验，构建时间的长度是阻碍它的最大因素之一。特别是<strong class="je hv">很难</strong>将Nix整合到CI系统中，因为它容易导致超时。</p><h1 id="cb56" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="bb09" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">所以希望这能给你一些关于Nix的概念。下周，我们将研究HNix。这个开源项目正在寻求在Haskell中重新实现Nix。我们将在对项目的探索中了解原因。同时，查看我们关于Haskell 入门的一些资源，这样你就可以学习如何开始了！如果您想体验一下Haskell中的包管理，一定要试试Stack！查看我们免费的<a class="ae ka" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>来了解如何操作！</p></div></div>    
</body>
</html>