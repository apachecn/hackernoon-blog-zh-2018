<html>
<head>
<title>Part II: Fn Load Balancer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二部分:Fn负载平衡器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/part-ii-fn-load-balancer-585babd90456?source=collection_archive---------12-----------------------#2018-05-21">https://medium.com/hackernoon/part-ii-fn-load-balancer-585babd90456?source=collection_archive---------12-----------------------#2018-05-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/304714330afb842cf8482847a0011619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3cUYkRkfWrowagTG."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@acharki95?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aziz Acharki</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b18f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">目录</strong></p><ul class=""><li id="a522" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated"><a class="ae jg" href="https://hackernoon.com/playing-with-the-fn-project-8c6939cfe5cc" rel="noopener ugc nofollow" target="_blank">第一部分:Fn项目入门</a></li><li id="e3a9" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated"><strong class="jj hv">第二部分:Fn负载均衡器(本帖)</strong></li></ul><p id="fd88" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt kt translated"><span class="l ku kv kw bm kx ky kz la lb di">如果</span>你正在寻找启动和运行<a class="ae jg" href="https://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn项目</a>，看看这个系列的第一篇文章。在这篇文章中，我将讨论Fn负载平衡器——它是什么，如何在本地运行它，以及如何将其部署到Kubernetes集群。</p></div><div class="ab cl lc ld hc le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hn ho hp hq hr"><p id="88e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt kt translated"><span class="l ku kv kw bm kx ky kz la lb di">T</span><a class="ae jg" href="https://github.com/fnproject/lb" rel="noopener ugc nofollow" target="_blank">Fn负载均衡器</a>的用途是智能地将流量路由到Fn服务器集群。这不是一个简单的循环路由，因为它有一些逻辑来根据传入的请求确定将流量路由到哪些节点。例如，如果您的函数在node2上是“热”的，负载平衡器将确保它被路由到该节点，而不是没有加载该函数的另一个节点。这样你可以获得更好的性能。</p><p id="9676" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">查看下面的简单图表，了解负载平衡器如何与Fn服务器和Fn数据库相适应。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/5e84d1cd0fb23ca4e9ae2444ef4fbc25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*e0P5kgq0kGHsghzGjsngVw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Fn Load Balancer diagram</figcaption></figure><p id="0ee4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">负载平衡器还会收集有关整个集群的信息，并显示节点列表及其状态，因此您可以使用这些信息通过添加更多Fn服务器来扩展集群，或者通过减少集群中的服务器数量来扩展集群。</p><h1 id="fbc5" class="lo lp hu bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">本地运行</h1><p id="d85d" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt kt translated">让多个Fn服务器在负载均衡器后面启动并运行并进行试验的最快方法是使用Docker在您的机器上本地运行它。</p><p id="987c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你要拉跑的图像叫做<code class="eh mr ms mt mu b">fnproject/fnlb</code>。在撰写本文时，最新的版本/标签是<code class="eh mr ms mt mu b">0.0.268</code>。</p><p id="2f09" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们试着运行几个Fn服务器和一个负载平衡器。我们将在容器中运行Fn服务器和负载平衡器——我们将负载平衡器链接到Fn服务器实例，以便它可以发现它。</p><p id="fe8e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您不想手动复制/粘贴本节中的命令，您可以获得下面的脚本—该脚本将自动启动N个Fn服务器容器和一个Fn负载平衡器。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure><blockquote class="mx my mz"><p id="12ad" class="jh ji na jj b jk jl jm jn jo jp jq jr nb jt ju jv nc jx jy jz nd kb kc kd ke hn dt translated"><strong class="jj hv">注意</strong>:确保在你计划运行上面脚本的同一个文件夹中运行<code class="eh mr ms mt mu b">fn start</code>。原因是，Fn可以为我们创建数据库文件。如果不这样做，启动Fn服务器容器时会出现错误。</p></blockquote><p id="b608" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先运行几个Fn服务器容器。我们不需要向主机公开任何端口，因为我们将通过负载平衡器访问Fn服务器:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="92e2" class="ni lp hu mu b fv nj nk l nl nm">docker run -it --rm --name fnserver1 -v $PWD/data/fn.db:/app/data/fn.db  -v /var/run/docker.sock:/var/run/docker.sock fnproject/fnserver:latest</span></pre><p id="1101" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，在新的终端窗口中运行第二台Fn服务器。<strong class="jj hv">确保从相同的文件夹运行第二台服务器，因为它们需要共享相同的数据库</strong>:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="155c" class="ni lp hu mu b fv nj nk l nl nm">docker run -it --rm --name fnserver2 -v $PWD/data/fn.db:/app/data/fn.db  -v /var/run/docker.sock:/var/run/docker.sock fnproject/fnserver:latest</span></pre><blockquote class="mx my mz"><p id="8b9f" class="jh ji na jj b jk jl jm jn jo jp jq jr nb jt ju jv nc jx jy jz nd kb kc kd ke hn dt translated"><strong class="jj hv">注意</strong>:如果你不想打开多个新的终端窗口，你可以在每个Docker命令中添加<code class="eh mr ms mt mu b"><em class="hu">-d</em></code>来以分离模式运行容器。我更喜欢在尝试时查看所有容器的日志。</p></blockquote><p id="2610" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，让我们运行负载平衡器，并链接到我们正在运行的Fn服务器:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="4c92" class="ni lp hu mu b fv nj nk l nl nm">docker run -it --rm --name fnlb --link fnserver1 --link fnserver2 -p 8080:8081 fnproject/fnlb:latest --nodes fnserver1:8080, fnserver2:8080</span></pre><p id="cea2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用<code class="eh mr ms mt mu b">--link</code>将容器链接在一起——这使得Fn服务器容器可以使用它们的名称(<code class="eh mr ms mt mu b">fnserver1</code>和<code class="eh mr ms mt mu b">fnserver2</code>)从Fn负载平衡器容器访问。我们还将端口8080暴露给主机，并将其链接到容器内部的端口8081(即端口1b可从容器内部访问)。</p><p id="ae0a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果一切正常，您应该会看到负载平衡器容器的以下输出，告诉您两个Fn服务器都在运行，状态良好，并且可以从负载平衡器访问:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/7f281ed0fd631348314d847435375e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JkMGs6b50ZeDf5XpjXeCw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Fn load balancer with 2 Fn servers</figcaption></figure><p id="3072" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们试试这个！由于负载平衡器暴露在端口8080上，我们可以简单地运行<code class="eh mr ms mt mu b">fn</code> CLI命令来部署应用程序(我们可以为负载平衡器使用不同的端口，然后设置<code class="eh mr ms mt mu b">FN_API_URL</code>环境变量来指向实际的主机和端口)。</p><p id="fb10" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此时，您可以创建和部署几个新功能:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="9d84" class="ni lp hu mu b fv nj nk l nl nm">fn init --runtime go testapp1<br/>fn init --runtime go testapp2<br/>fn init --runtime go testapp3</span><span id="22ca" class="ni lp hu mu b fv no nk l nl nm">cd testapp1<br/>fn deploy --local --app testapp1<br/>cd .. </span><span id="7770" class="ni lp hu mu b fv no nk l nl nm">cd testapp2<br/>fn deploy --local --app testapp2<br/>cd ..</span><span id="ea0e" class="ni lp hu mu b fv no nk l nl nm">cd testapp3<br/>fn deploy --local --app testapp3<br/>cd ..</span></pre><p id="db77" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后尝试调用它们，查看调用是否被路由到两个Fn服务器实例。我使用这个命令从多个终端窗口连续调用端点:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="72b2" class="ni lp hu mu b fv nj nk l nl nm">while true; do sleep 1; curl <a class="ae jg" href="http://localhost:8080/r/testapp3/testapp3" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/r/testapp3/testapp3</a>; echo $(date);done</span></pre><p id="c6c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">确保您替换了app和func名称(testappX ),最终您应该看到日志从两个Fn服务器实例输出。</p><h2 id="3995" class="ni lp hu bd lq np nq nr lu ns nt nu ly js nv nw mc jw nx ny mg ka nz oa mk ob dt translated">管理端点</h2><p id="4385" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">Fn负载平衡器还公开了一个可在路径<code class="eh mr ms mt mu b">/1/lb/nodes</code>上访问的管理端点，并支持<code class="eh mr ms mt mu b">PUT</code>、<code class="eh mr ms mt mu b">DELETE</code>和<code class="eh mr ms mt mu b">GET</code>方法。使用<code class="eh mr ms mt mu b">PUT</code>您可以动态地将一个节点添加到负载平衡器维护的节点列表中，<code class="eh mr ms mt mu b">DELETE</code>方法将删除一个指定的节点，而使用<code class="eh mr ms mt mu b">GET</code>您可以获得一个节点及其状态的列表。您可以想象实现某种使用特定事件从负载平衡器添加/删除节点的监视器。</p><h1 id="981e" class="lo lp hu bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">在Kubernetes上运行</h1><p id="29b9" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt kt translated">我们如何复制一个类似的设置，但不是在本地运行，而是在Kubernetes上运行？</p><p id="8361" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Fn负载平衡器支持Kubernetes操作模式，可以通过传入<code class="eh mr ms mt mu b">-db=k8s</code>标志来激活该模式——在该模式下，<code class="eh mr ms mt mu b">--nodes</code>标志将被忽略，您将能够使用标签和标签选择器来挑选运行Fn服务器的pod。您可以手动创建在Kubernetes上部署所有这些所需的文件，但好消息是Fn团队已经为您完成了这项工作！</p><p id="acb6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有一个<a class="ae jg" href="https://github.com/fnproject/fn-helm" rel="noopener ugc nofollow" target="_blank"> Fn舵图可用</a>，你可以用它在你的Kubernetes集群上安装Fn。</p><p id="419c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面链接中的Helm chart还将在您的集群上安装MySQL和Redis的一个实例，以及UI和Fn流——因此您可以通过一个Helm命令获得完整的处理。</p><p id="9e01" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关于如何安装它的说明在<a class="ae jg" href="https://github.com/fnproject/fn-helm" rel="noopener ugc nofollow" target="_blank">这里</a>，但简而言之，一旦你安装了<a class="ae jg" href="https://helm.sh" rel="noopener ugc nofollow" target="_blank"> Helm </a>，你运行以下命令来初始化Helm，克隆repo，安装图表依赖项，最后安装Fn图表:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="dcc6" class="ni lp hu mu b fv nj nk l nl nm">helm init<br/>git clone git@github.com:fnproject/fn-helm.git &amp;&amp; cd fn-helm<br/>helm dep build fn<br/>helm install --name myfn fn</span></pre><p id="161a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">安装完成后，您还会看到如何设置指向负载平衡器的<code class="eh mr ms mt mu b">FN_API_URL</code>环境变量的说明。如果您正在使用Docker for Mac，您可以访问<code class="eh mr ms mt mu b">http://localhost:80</code>上的负载平衡器。</p><p id="d57f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您正在查看Fn负载平衡器(作为部署<code class="eh mr ms mt mu b">fn-fnlb-depl</code>的一部分而创建的pod)的日志，您应该会看到一系列活动，表明检测到了新的pod，并且应该有一行如下所示:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="5dfd" class="ni lp hu mu b fv nj nk l nl nm">time="2018-05-21T22:31:49Z" level=info msg="is healthy" node="10.1.0.23:80"</span></pre><p id="6862" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">并指示Fn负载平衡器能够连接到Fn服务器。</p><p id="a3d3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你使用的是属于Mac Docker的Kubernetes，最好的事情是Fn负载平衡器服务可以通过<code class="eh mr ms mt mu b"><a class="ae jg" href="http://localhost:80," rel="noopener ugc nofollow" target="_blank">http://localhost:80</a></code>访问:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="cde9" class="ni lp hu mu b fv nj nk l nl nm">$ curl localhost:80/version<br/>{"version":"0.3.455"}</span></pre><p id="b2d0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:如果您将它部署到一个“真正的”集群，您可以通过运行<code class="eh mr ms mt mu b">kubectl get svc</code>并检查<code class="eh mr ms mt mu b">EXTERNAL-IP</code>列来查找<code class="eh mr ms mt mu b">fn-fn-api</code>服务的外部IP。</p><h2 id="b404" class="ni lp hu bd lq np nq nr lu ns nt nu ly js nv nw mc jw nx ny mg ka nz oa mk ob dt translated">连接Fn CLI</h2><p id="cc29" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt kt translated"><span class="l ku kv kw bm kx ky kz la lb di">答</span>假设您没有任何Fn服务器在本地运行，您将在尝试运行Fn CLI命令时得到一个错误。例如:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="a1af" class="ni lp hu mu b fv nj nk l nl nm"># Try to get the list of apps<br/>$ fn list apps<br/>ERROR: Get <a class="ae jg" href="http://localhost:8080/v1/apps" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/apps</a>: dial tcp [::1]:8080: connect: connection refused</span></pre><p id="f72f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于我们在本地主机端口80上公开了Fn负载平衡器，因此我们可以通过设置环境变量<code class="eh mr ms mt mu b">FN_API_URL</code>或运行带有前置变量的CLI来将其与CLI连接起来:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="14b2" class="ni lp hu mu b fv nj nk l nl nm">FN_API_URL=<a class="ae jg" href="http://localhost:80" rel="noopener ugc nofollow" target="_blank">http://localhost:80</a> fn list apps</span></pre><p id="4a44" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我们还没有部署任何东西，所以上面的命令将返回“没有找到应用程序”。将<code class="eh mr ms mt mu b">FN_REGISTRY</code>设置到Docker hub存储库中，然后部署前面的testapp1:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="cc75" class="ni lp hu mu b fv nj nk l nl nm">FN_API_URL=http://localhost:80 fn deploy --app testapp1</span></pre><blockquote class="mx my mz"><p id="a8d3" class="jh ji na jj b jk jl jm jn jo jp jq jr nb jt ju jv nc jx jy jz nd kb kc kd ke hn dt translated"><strong class="jj hv">注意</strong>:我们必须设置FN_REGISTRY，因为我们不会像以前那样将应用程序部署到“本地”FN服务器上。我们将实际构建映像并将其推送到Docker hub，这样运行在Kubernetes集群中的Fn服务器就可以提取并运行它。</p></blockquote><p id="fc96" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后要做的事情是尝试运行部署的函数。您可以列出我们为获得完整端点(例如<code class="eh mr ms mt mu b">http://localhost:80/r/testapp1/testapp1</code>)而部署的应用程序的路由，或者使用Fn CLI调用如下函数:</p><pre class="lk ll lm ln fq ne mu nf ng aw nh dt"><span id="b19a" class="ni lp hu mu b fv nj nk l nl nm">$ FN_API_URL=<a class="ae jg" href="http://localhost:80" rel="noopener ugc nofollow" target="_blank">http://localhost:80</a> fn call testapp1 testapp1<br/>{"message1":"Hello World"}</span></pre><h1 id="2e66" class="lo lp hu bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">结论</h1><p id="9cf5" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">在本文中，我讨论了Fn负载平衡器，以及如何在本地设置它以进行开发和尝试，以及如何在Kubernetes集群上使用Helm chart部署它。</p><p id="dca7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">利用前一篇文章中的知识，您可以创建自定义的Fn服务器映像(包括自定义的扩展)，然后在Kubernetes集群中部署和运行它，或许还可以向最终用户公开该功能，并允许他们使用您的平台来部署他们的服务。</p><h1 id="91b1" class="lo lp hu bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">感谢阅读！</h1><p id="2b63" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js mo ju jv jw mp jy jz ka mq kc kd ke hn dt translated">欢迎对本文的任何反馈！你也可以在<a class="ae jg" href="http://twitter.com/pjausovec" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae jg" href="http://github.com/peterj" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。如果你喜欢这个并且想在我写更多东西的时候得到通知，你应该订阅<a class="ae jg" href="https://tinyletter.com/pjausovec" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>