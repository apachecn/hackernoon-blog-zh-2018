<html>
<head>
<title>Get Reason-able with ReasonML — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用理性变得理性——第3部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/get-reason-able-with-reasonml-part-3-6e2f3f61f959?source=collection_archive---------15-----------------------#2018-05-21">https://medium.com/hackernoon/get-reason-able-with-reasonml-part-3-6e2f3f61f959?source=collection_archive---------15-----------------------#2018-05-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7ee4" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">模式匹配、类型参数、异常、循环、模块和BuckleScript</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/3209d050a2d115e34d0a6afc4a3a4c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cErheM348WFKd444QtgHSw.png"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="f04d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这是<strong class="jz hv"> 3部分系列</strong>的<strong class="jz hv">第2部分</strong>，在这里我将帮助你理解ReasonML及其所有的语法和语义。我将介绍从基本的<strong class="jz hv">数据类型</strong>到在ReasonML中声明<strong class="jz hv">函数</strong>的所有内容。</p><p id="bdff" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">在继续之前，请确保您已经阅读了本系列的<a class="ae kt" href="https://hackernoon.com/get-reason-able-with-reasonml-part-1-ac950188141b" rel="noopener ugc nofollow" target="_blank"> <strong class="jz hv">第1部分</strong> </a>和<a class="ae kt" href="https://hackernoon.com/get-reason-able-with-reasonml-part-2-65d3ab851570" rel="noopener ugc nofollow" target="_blank"> <strong class="jz hv">第2部分</strong> </a>。都是有联系的。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="aaf8" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">使用开关的模式匹配</h1><p id="2d26" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">模式匹配是这种语言最好的特性之一。它主要做两件事:</p><ul class=""><li id="4a20" class="ly lz hu jz b ka kb kd ke kg ma kk mb ko mc ks md me mf mg dt translated">检查值的特定结构。</li><li id="0c97" class="ly lz hu jz b ka mh kd mi kg mj kk mk ko ml ks md me mf mg dt translated">提取部分值。</li></ul><p id="7b9a" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">有了模式匹配，我们可以做很多很棒的事情，比如将多个模式整合到一个案例中！</p><p id="3232" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">由于结构相等，模式匹配可以很好地处理元组、列表、变量和记录等数据结构。</p><h2 id="7bad" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">模式匹配元组</h2><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="086b" class="mm lc hu nb b fv nf ng l nh ni"># switch (rajat) {<br/>  | ("Learn ReasonML", false) =&gt; "It's Awesome"<br/>  | ("Learn ReasonML", true) =&gt; "It really is awesome"<br/>};</span></pre><p id="fe25" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">但这将使我们的应用程序详尽无遗。我们需要使用<code class="eh nj nk nl nb b">_</code>来匹配这个类型的不匹配值。使用名称代替下划线允许我们提取部分元组。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="a77a" class="mm lc hu nb b fv nf ng l nh ni"># switch (rajat) {<br/>  | (_, true) =&gt; "Its Awesome"<br/>  | (text, false) =&gt; "It really is awesome. " ++ text<br/>};<br/>- string = "It really is awesome. Learn ReasonML"</span></pre><h2 id="1da2" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">模式匹配列表</h2><p id="a1ac" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">在列表的情况下，我们可以在精确的列表上执行模式匹配。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="3cd9" class="mm lc hu nb b fv nf ng l nh ni"># switch (["a", "b", "c"]) {<br/>  | ["a", "b", "c"] =&gt; true<br/>  | _ =&gt; false<br/>};</span></pre><p id="7184" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">关于列表的模式匹配，最好的事情是<code class="eh nj nk nl nb b">...</code>可以用来提取列表的第一个和最后一个元素。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="bd2c" class="mm lc hu nb b fv nf ng l nh ni"># switch (["x", "y", "z"]) {<br/>  | [head, ...tail] =&gt; print_endline(head)<br/>  | [] =&gt; print_endline("Empty list")<br/>};</span></pre><h2 id="5c03" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">模式匹配数组</h2><p id="6986" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">当模式匹配数组时，我们只能对特定长度的数组这样做。数组中的值使用结构等式进行匹配。我们可以使用下划线，也可以使用名称提取数组元素。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="4c4a" class="mm lc hu nb b fv nf ng l nh ni"># switch ([|"a", "b", "c"|]) {<br/>  | [|"a", "b", _|] =&gt; print_endline("a, b and something")<br/>  | [|_, "x", "y"|] =&gt; print_endline("something, " ++ x ++ y)<br/>  | _ =&gt; print_endline("An Array")<br/>};</span></pre><h2 id="d075" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">模式匹配记录</h2><p id="e238" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">首先，我将通过声明类型来创建一个记录，然后将它绑定到一个<code class="eh nj nk nl nb b">name</code>。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="a6e4" class="mm lc hu nb b fv nf ng l nh ni"># type todo = { text: string, checked: bool};<br/># let myTodo = { text: "Learn ReasonML", checked: true};</span></pre><p id="738c" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">现在，我可以通过匹配精确的值来提取文本。但是相反，我将尝试其他方法，并使用名称描述提取文本。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="67ae" class="mm lc hu nb b fv nf ng l nh ni"># switch (myTodo) {<br/>  | {text, checked: true} =&gt; "It is awesome: " ++ text<br/>  | {text, checked: false} =&gt; "You won't regret it!" ++ text<br/>};<br/>- : string = "It is awesome: Learn ReasonML"</span></pre><h2 id="adcd" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">模式匹配变体</h2><p id="c39e" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">让我们创建一个名为<code class="eh nj nk nl nb b">hero</code>的变体，标签为<code class="eh nj nk nl nb b">DC</code>和<code class="eh nj nk nl nb b">Marvel</code>。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="8a71" class="mm lc hu nb b fv nf ng l nh ni"># type hero = DC(string) | Marvel(string);<br/># let dc = DC("Batman");<br/># let marvel = Marvel("Iron Man");</span></pre><p id="d368" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用模式匹配，我可以检查标签并提取变体的任何部分。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="6efa" class="mm lc hu nb b fv nf ng l nh ni"># switch (dc) {<br/>  | DC(text) =&gt; "I am " ++ text<br/>  | Marvel(text) =&gt; "I am " ++ text<br/>};<br/>- : string = "I am Batman"</span></pre><p id="c082" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果您想匹配多个项目并返回结果，您可以这样做:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="f266" class="mm lc hu nb b fv nf ng l nh ni"># switch ("Batman") {<br/>  | "Superman" | "Batman" | "The Flash" =&gt; "DC Comics"<br/>  | _ =&gt; "Marvel Comics"<br/>};<br/>- : string = "DC Comics"</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="4890" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">类型参数</h1><p id="92ee" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">类型也可以接受参数。参数可以与其他语言中的泛型进行比较。创建列表时，首先需要创建一个接收数据类型的类型列表。这里，数据类型是一个类型参数。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="b715" class="mm lc hu nb b fv nf ng l nh ni"># let rajat: list(string) = ["Batman", "Superman"];</span></pre><p id="d3bc" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">编译器甚至可以反转列表的类型参数。</p><blockquote class="nm nn no"><p id="5671" class="jx jy np jz b ka kb iv kc kd ke iy kf nq kh ki kj nr kl km kn ns kp kq kr ks hn dt translated">但是我们为什么需要这个呢？</p></blockquote><p id="9ae9" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用类型参数，我们可以创建一个新的类型，它可以接受任意多的参数。</p><p id="6913" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">基本上，<code class="eh nj nk nl nb b">type</code>可以变成一个接受参数并返回新类型的函数。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="68fb" class="mm lc hu nb b fv nf ng l nh ni"># type hero('a) = ('a, 'a);<br/># let heroOne: hero(string) = ("Superman", "Clark Kent"); </span></pre><p id="c518" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这样我们可以在创建更多类型的同时避免重复。</p><p id="355a" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">还要注意，类型参数只有在以<strong class="jz hv">“`”、</strong>开头，后面跟一个字符或单词时才有效。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h2 id="282c" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">字母绑定可变性</h2><p id="26df" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated"><code class="eh nj nk nl nb b">let</code>默认情况下，绑定是不可变的。一旦绑定引用了一个值，它就不能引用其他任何值。但是你可以通过创建一个新的绑定来避免这个问题，这个新的绑定有相同的名字并且<em class="np">隐藏</em>以前的绑定。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="9377" class="mm lc hu nb b fv nf ng l nh ni"># let person = "Clark Kent";<br/># print_endline(person); /* Prints "Clark Kent" */<br/># let person = "Superman";<br/># print_endline(person); /* Print "Superman" */</span></pre><p id="ec89" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">还有一种方法可以通过使用引用包装实际值来使<code class="eh nj nk nl nb b">let</code>绑定变得可变。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="257b" class="mm lc hu nb b fv nf ng l nh ni"># let foo = ref(5);<br/>let foo: ref(int) = {contents: 5};</span></pre><p id="d0e9" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">现在，如果我想更改<code class="eh nj nk nl nb b">foo</code>中的数据，我会这样做:</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="3806" class="mm lc hu nb b fv nf ng l nh ni"># foo := 6;<br/>- : unit = ()<br/># foo;<br/>- : ref(int) = {contents: 6}</span></pre><p id="93fe" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><code class="eh nj nk nl nb b">foo</code>的值从5变为6。为了检索引用的值，我需要使用<code class="eh nj nk nl nb b">^</code>字符。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="f528" class="mm lc hu nb b fv nf ng l nh ni"># foo^;<br/>- : int = 6</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="af95" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">例外</h1><p id="f775" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">按理说，Exception是一种变体，当您试图在空列表中查找内容时会遇到这种变体。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="8390" class="mm lc hu nb b fv nf ng l nh ni"># List.find(x =&gt; x == "Rajat", []);<br/>Exception: Not_found.</span></pre><p id="3a56" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">还没完呢！您可以使用<code class="eh nj nk nl nb b">raise</code>功能创建自己的异常。要捕获应用程序中的异常，请使用模式匹配。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="72be" class="mm lc hu nb b fv nf ng l nh ni"># raise(Not_found);<br/>Exception: Not_found.<br/># try (raise(Not_found)) {<br/>  | Not_found =&gt; "Oh Oh!"<br/>};<br/>= : string = "Oh Oh!"</span></pre><p id="82f2" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以使用<code class="eh nj nk nl nb b">exception</code>直接匹配<code class="eh nj nk nl nb b">switch</code>表达式中的异常。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="ca7c" class="mm lc hu nb b fv nf ng l nh ni"># switch (List.find(x =&gt; x == "rajat", [])) {<br/>  | name =&gt; "Obtained"<br/>  | exception Not_Fount =&gt; "Not found"<br/>  };<br/>  - : string = "Not found"<br/># switch (List.find(x =&gt; x == "rajat", ["rajat"])) {<br/>  | item =&gt; "Obtained"<br/>  | exception Not_found =&gt; "Not found"<br/>  };<br/>- : string = "Obtained"</span></pre><p id="61d9" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><code class="eh nj nk nl nb b">exception</code>的用处不多。事实上，你可以用<code class="eh nj nk nl nb b">option</code>来代替。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="f189" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">环</h1><h2 id="a520" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">For循环</h2><p id="1645" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated"><code class="eh nj nk nl nb b">for</code>循环用于从数据结构的第一个值迭代到最后一个值。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="b945" class="mm lc hu nb b fv nf ng l nh ni"># for (x in 1 to 5) {<br/>    print_int(x * 2);<br/>    print_string(" ");<br/>  };<br/>2 4 6 8 10 - : unit = ()</span></pre><p id="a92a" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">该范围必须有效，并且从较低值到较高值。如果你试着用另一种方式去做，<code class="eh nj nk nl nb b">for</code>什么都不会做。为了使<code class="eh nj nk nl nb b">for</code>反向工作，将<code class="eh nj nk nl nb b">to</code>换成<code class="eh nj nk nl nb b">downto</code>。</p><h2 id="ea97" class="mm lc hu bd ld mn mo mp lh mq mr ms ll kg mt mu ln kk mv mw lp ko mx my lr mz dt translated">While循环</h2><p id="9e33" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">只要给定的条件为<code class="eh nj nk nl nb b">true</code>，则<code class="eh nj nk nl nb b">while</code>回路将保持运行。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="5910" class="mm lc hu nb b fv nf ng l nh ni"># let x = ref(0);<br/>let x: ref(int) = { contents: 0};<br/># while (x^ &lt; 5) {<br/>  print_int(x^);<br/>  x := x^ + 1;<br/>};<br/>01234- : unit = ()</span></pre></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="ec0d" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">模块</h1><p id="f14a" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">模块可以被描述为代码中的小块。它们允许我们将像<code class="eh nj nk nl nb b">let</code>绑定和<code class="eh nj nk nl nb b">types</code>这样的东西封装到逻辑实体中。</p><p id="fc85" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">Reason中的每个文件都是一个模块。这就是为什么<code class="eh nj nk nl nb b">name</code>需要在每个项目中都是独一无二的。</p><p id="c756" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">使用<code class="eh nj nk nl nb b">module</code>关键字在你的推理项目中创建一个模块。确保你的模块名是大写的。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="baae" class="mm lc hu nb b fv nf ng l nh ni"># module Rajat = {};<br/>`module Math` : { };<br/># module Math = {<br/>  let name = "rajat";<br/>  let age = 24;<br/>};<br/>`module Math`: { let name: string; let age: int };</span></pre><p id="d5f3" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">要访问模块内部的任何东西，使用<code class="eh nj nk nl nb b">.</code>符号。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="53c9" class="mm lc hu nb b fv nf ng l nh ni"># Rajat.name;<br/>- : string = "rajat"<br/># Rajat.age;<br/>- : int = 24;</span></pre><p id="8247" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><code class="eh nj nk nl nb b">.</code>符号在这里非常有用，因为我们也可以访问存储在模块中的类型。这样，编译器将只查看当前模块或其父模块。</p><p id="f11e" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">Reason也允许我们打开一个模块的定义并引用它的内容，而不需要在名字前加前缀。</p><p id="8660" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">为此，我们使用了<code class="eh nj nk nl nb b">open</code>关键字。这将全局打开该模块，并在当前范围内导入其定义。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="44b1" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">BuckleScript</h1><p id="d40b" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">回到本系列的第1部分  <strong class="jz hv"> </strong>中，我说过可以使用一种叫做<strong class="jz hv">的东西将Reason编译成JavaScript。让我们看看这实际上是怎么做的。</strong></p><p id="70e9" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">首先我们需要在我们的系统中安装<strong class="jz hv"> BuckleScript </strong>。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="c589" class="mm lc hu nb b fv nf ng l nh ni">npm install -g bs-platform</span></pre><p id="7419" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">安装了这个包，我不仅可以将我的代码编译成JavaScript，还可以编译成本地二进制代码。</p><p id="eb77" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">现在我需要使用<code class="eh nj nk nl nb b">bs-platform</code>建立一个新项目</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="0d17" class="mm lc hu nb b fv nf ng l nh ni">bsb -init reason-project -theme basic-reason</span></pre><p id="8f3e" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这个命令将在你的系统中创建一个名为<code class="eh nj nk nl nb b">reason-project</code>的新目录。如果您看一下这个目录的内容，您会注意到它与典型的JavaScript项目有一些相似之处。</p><p id="00e5" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这里唯一独特的是<code class="eh nj nk nl nb b">bsconfig.json</code>文件。我们可以在这个文件中为这个项目配置BuckleScript。</p><p id="e7a5" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果你查看这个项目的<code class="eh nj nk nl nb b">src</code>目录，你会看到它包含了一个<code class="eh nj nk nl nb b">Demo.re</code>文件。让我们删除它并创建一个名为<code class="eh nj nk nl nb b">Main.re</code>的新文件。您可以在这里编写任何ReasonML代码，并使用NPM/Yarn运行<code class="eh nj nk nl nb b">build</code>脚本。这将把任何扩展名为<code class="eh nj nk nl nb b">.re</code>的文件编译成一个匹配的JavaScript文件。所以我们的<code class="eh nj nk nl nb b">Main.re</code>文件会编译成<code class="eh nj nk nl nb b">Main.bs.js</code>。</p><p id="337b" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">您可以使用<code class="eh nj nk nl nb b">node</code>运行这个JavaScript文件。</p><pre class="jk jl jm jn fq na nb nc nd aw ne dt"><span id="0610" class="mm lc hu nb b fv nf ng l nh ni">node src/Main.bs.js</span></pre><p id="ea9f" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">您也可以使用<code class="eh nj nk nl nb b">start</code>脚本来手动构建它。这个脚本将监视文件的变化并相应地编译。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="0584" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">下一步是什么？</h1><p id="b19b" class="pw-post-body-paragraph jx jy hu jz b ka lt iv kc kd lu iy kf kg lv ki kj kk lw km kn ko lx kq kr ks hn dt translated">这个系列应该足以让你开始使用ReasonML。但是如果你还想知道更多，看看Reason的官方文档:</p><div class="nt nu fm fo nv nw"><a href="https://reasonml.github.io/docs/en/quickstart-javascript.html" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab ej"><div class="ny ab nz cl cj oa"><h2 class="bd hv fv z el ob eo ep oc er et ht dt translated">快速入门原因</h2><div class="od l"><h3 class="bd b fv z el ob eo ep oc er et ek translated">嘘</h3></div><div class="oe l"><p class="bd b gc z el ob eo ep oc er et ek translated">reasonml.github.io</p></div></div></div></a></div><p id="f774" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">你也可以看看<a class="of og gr" href="https://medium.com/u/ff3f225e7f5c?source=post_page-----6e2f3f61f959--------------------------------" rel="noopener" target="_blank">尼克·格拉芙</a>在Egghead上的课程。对我帮助很大！</p><div class="nt nu fm fo nv nw"><a href="https://egghead.io/courses/get-started-with-reason" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab ej"><div class="ny ab nz cl cj oa"><h2 class="bd hv fv z el ob eo ep oc er et ht dt translated">从理性开始</h2><div class="od l"><h3 class="bd b fv z el ob eo ep oc er et ek translated">这门课程首先会教你关于编程语言的语法和语义的知识</h3></div><div class="oe l"><p class="bd b gc z el ob eo ep oc er et ek translated">蛋头</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om jt nw"/></div></div></a></div></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="2144" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我是Rajat S，<a class="ae kt" href="https://geekyants.com/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=blog" rel="noopener ugc nofollow" target="_blank"> GeekyAnts </a>的技术内容作者。有抱负的程序员还有很长的路要走。一个热爱漫威电影的铁杆DC漫画迷。以多任务处理著称。</p><p id="aa69" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">感谢阅读，希望这是有帮助的！请👏如果你喜欢这篇文章，请在这里和/或在<a class="ae kt" href="https://twitter.com/geeky_writer_" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，了解我的新文章！</p></div></div>    
</body>
</html>