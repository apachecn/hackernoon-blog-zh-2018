<html>
<head>
<title>GraphQL APIs for backend devs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后端开发的GraphQL APIs</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphql-apis-for-backend-devs-bba579e72eba?source=collection_archive---------8-----------------------#2018-05-22">https://medium.com/hackernoon/graphql-apis-for-backend-devs-bba579e72eba?source=collection_archive---------8-----------------------#2018-05-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/37d4fa0cd8f52d2023a13783b0dcb8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*FnsL3hkbTOPm5Eto9g4Zwg.jpeg"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">From SOAP to REST and probably GraphQL</figcaption></figure><p id="ad28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的软件开发生涯中，我构建并使用了大量的web服务。通常，它们是通过构建的服务器端应用程序使用的。NET，我做过的最大的项目之一是一个平台，在这个平台上，我们合并了来自不同来源的大量数据，并在web界面上向用户显示结果(是的，当时我在一家经纪公司工作)。</p><h2 id="13aa" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">SOAP Web服务—与XSD</h2><p id="e18f" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">几乎所有这些web端点都使用SOAP，并且它们很容易查询，因为我们总是从我们的合作伙伴那里得到一个模式(XSD)文件。接收XSD是一个非常好的开始，因为客户端是由工具为您生成的。另一方面，这不是最好的解决方案，有时我们不得不手动更改生成的代码，因为客户端和服务器之间的堆栈不同。这可能会导致升级到新版本时出现问题，因为您可能会覆盖这些更改，所以我们不得不花一些时间来比较源代码控制中的更改，最后我们手动进行升级，一个更改一个更改。c#中生成的代码使用分部类，因此理论上您需要做的任何更改都可以在生成的代码之外完成。但是我仍然记得一些情况，当变化如此之大，以至于我们不能在另一个文件中完成它。</p><figure class="lb lc ld le fq iv fe ff paragraph-image"><div class="fe ff la"><img src="../Images/12a34b84db22230625a2f8ca29ce974c.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*qobC5Tck5kuytV5GKH1YyQ.jpeg"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">XSD code generation in action</figcaption></figure><h2 id="30d2" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">REST——松散耦合的web服务</h2><p id="aaf1" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">但是没有什么比得上我们第一次使用REST端点。这家公司为他们新的<em class="lf">闪亮的尖端API做了广告。一切看起来都很好，直到我们开始真正建立我们的。NET客户端。想象一下，有5或6个端点，每个端点返回几十个，也许几百个参数，有几层嵌套。你不得不一个接一个地写那些样板属性，浏览例子，想知道哪个是数组，它是否可以是一个int或者保留为string等等。</em></p><p id="1420" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后他们问你为什么需要3个月才能连接到他们的新API？<em class="lf">啊啊啊……</em></p><p id="a7e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以XSD在第一天就帮了你很多:让你的客户端快速进入运行状态，然后再担心将来的升级和版本控制。大多数时候，我们会消耗比所需多得多的数据。我不记得花时间删除了我们不需要的字段，以使过程更轻松。而在REST端，有许多代码需要编写，这很重要，因为在那里出错，所有的反序列化都会失败。事实上，通过只添加需要的字段，我们最终可以得到更灵活的客户端，但是这是一个容易出错的过程。</p><p id="c614" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">SOAP仍然将客户机和服务器与模式生成耦合在一起，而REST实现了真正的松散耦合，只是我们还没有为此做好准备(至少在后端)。因为这个问题是真实的，像<a class="ae lg" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> SWAGGER </a>这样的项目出现了，它把你的api翻译成其他客户端可以自动使用的开源DSL。最近，为REST端点提供某种SDK和API的情况越来越多，这需要额外的努力，但这是朝着正确方向迈出的一步，因为客户端可以更快地连接到您。但仍有许多公司缺乏这种理解。</p><h2 id="96fe" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">输入GraphQL</h2><p id="2e77" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">现在当你听说GraphQL时，你读到的主要内容是你可以选择可以从服务器返回的列。这对于构建您的移动和web客户端来说有多棒，而不需要创建几个REST端点，因为它们需要不同的字段来操作和显示。如果你浏览以GraphQL为要求的工作，你会看到几乎所有的前端和移动开发。那才是真正受欢迎的地方。</p><p id="09a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">后端开发呢？如果您正在为您的产品构建外部API，GraphQL会是一个合理的选择吗？从带有Swagger的REST API切换到graph QL API有什么优势吗？</p><h2 id="8e83" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">GraphQL模式</h2><p id="ecf5" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">对于作为API构建者和消费者的我来说，创建GraphQL API最重要的好处是模式和它为您提供的所有现成的版本控制工具。</p><p id="8d1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL提供了一个现成的模式，包括标量和复杂类型(由其他复杂类型或标量类型组成)、查询、突变(也是一些特殊类型)和许多其他元素，可以帮助您定义API。</p><p id="e95c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下图中(截图来自Twitter API的https://www.graphqlhub.com<a class="ae lg" href="https://www.graphqlhub.com" rel="noopener ugc nofollow" target="_blank">——非官方)你可以看到一个Tweet对象，由一些标量类型组成，如String、Int、ID和一些对象类型，如TwitterUser或Retweet。</a></p><figure class="lb lc ld le fq iv fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/0c61a0577ac9be87d8e79d6c832b9019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*d1oMk0u0DEHgv6ZU-LdLeQ.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">TwitterAPI defined at GraphQLHub.com seen in a Graphiql UI</figcaption></figure><p id="5c91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当行业从SOAP转向REST时，需要一段时间来理解这个新概念。协议上不再公开任何方法，但是模式是关于创建端点和公开这些端点周围的数据。REST是关于使用统一资源标识符以及如何将HTTP动词转换成动作。这条路同样适用于向GraphQL的过渡。就像我说的，当你第一次读到它的时候，你会发现你可以在客户端选择你的专栏。然后你发现它有一个带类型的模式，这是REST的一大优势。或许在那之后，或者再多走几步，你就会意识到，为了构建一个GraphQL API，一切都是为了将数据视为图形。当您开始定义一个新的模式时，它不是关于公开方法或创建端点，它实际上是关于如何连接您的数据，因为它总是这样。</p><h2 id="a56c" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">这是一路向下的图表</h2><p id="d25c" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">让我们举一个简单但足够复杂的例子来解释这个概念:书籍和作者。在REST架构中，您将构建两个端点，一个用于作者，一个用于书籍。考虑一下GraphQL模式，很明显会有两种类型:Author和Book，以及一个公开这两种类型的查询。但是这些对象是密切相关的，因为一个作者写了一本或多本书。因此，在作者类型上，我们将添加一个图书列表。</p><figure class="lb lc ld le fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff li"><img src="../Images/7bc484486a750b8ffd8416c02807770a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKDttmmI918jevWuFMf_Dw.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">authors query — an author has a list of books</figcaption></figure><p id="d50a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">甚至，作者和书之间的关系是n对n的，因为一本书可以有多个作者。这正是我们的例子，《起源:140亿年的宇宙进化》这本书是由两位作者写的:尼尔·德格拉斯·泰森和唐纳德·戈德史密斯。这意味着我们将向我们的图书类型添加一个作者列表，并且我们的图表中已经有一个循环。</p><figure class="lb lc ld le fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff ln"><img src="../Images/f58f9a17aa83686991018de2ca3fb212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6AS412biFRQEWVF7MEaOg.png"/></div></div></figure><p id="6a82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们在一个查询中就有了完整的信息:我们有作者和他的书，如果我们需要信息，我们还可以包括一本书的所有作者。因此，它不再与端点和URI有关，而是与数据和数据节点之间的连接有关。在我们的GraphQL查询中，我们可以清楚地看到我们的类型之间的关系。</p><p id="bc06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lf">感谢阅读。顺便说一句，如果你来自罗马尼亚的雅西，你可以加入我的免费的</em> <a class="ae lg" href="https://www.meetup.com/Microservices-Iasi/events/249451432/" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> GraphQL。6月5日举行的NET Core研讨会</em> </a> <em class="lf">。作为一个工作坊，名额有限，但如果有更多的人感兴趣，我们可以进行第二轮。</em></p><p id="8aaf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae lg" href="https://mailchi.mp/c6f9b64a7def/dotnet-newsletter" rel="noopener ugc nofollow" target="_blank"> <em class="lf">您也可以注册我的软件开发者感兴趣的简讯。NET技术</em> </a> <em class="lf">。我计划从2018年6月开始，每月发送两次。</em></p></div></div>    
</body>
</html>