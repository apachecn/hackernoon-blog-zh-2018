<html>
<head>
<title>Getting Started with React-Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-Redux入门</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-started-with-react-redux-1baae4dcb99b?source=collection_archive---------1-----------------------#2018-05-23">https://medium.com/hackernoon/getting-started-with-react-redux-1baae4dcb99b?source=collection_archive---------1-----------------------#2018-05-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e166256f3ae408bf7209111f564eed3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VeM-5lsAtrrJ4jXH96h5kg.png"/></div></div></figure><p id="7a1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我来做个铺垫:你想出了一个web应用程序的好主意，你决定用React来构建它。举个完全随意的例子，假设它是一个带有交互式吉他琴颈和提交表单的吉他和弦查找器(比如说，<a class="ae ka" href="https://rechord-progression-builder.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">这个</a>)。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/8ecc8a1fa376e6d1fcdc243020cc9183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49Zy6ghqyoX-oyltywDNhw.png"/></div></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Shameless self-promotion!</figcaption></figure><p id="9076" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你已经列了几个任务清单，看了几个教程，你认为你已经掌握了所有这些“道具”的窍门，所以你马上投入进去。进展得足够好——你已经有了顶级的应用程序组件，可能是一个表单，一个吉他组件……然后，它开始向你展示。你将需要一把吉他…有六根弦…每根弦有十二个品…它们都需要传达关于它们是否静音、按下或打开的信息…它们需要能够与形式交流并表达和弦…在你知道它之前，六个小时已经过去了，到处都是纱线，你很确定你已经发现了一个莫名其妙地牵连完全虚构的人和美国邮政署​的阴谋。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/597c041fcefc3dc3c434a0b7423b5253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbjL9SvCRtXsjKZYhbnj8w.jpeg"/></div></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Side note for Always Sunny fans, did you ever notice that “Pepe Sylvia” sounds an awful lot like how an illiterate person would try to read “Pennsylvania”? That’s the sort of subtle comedy we need.</figcaption></figure><p id="0819" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是不要担心(双关语)！有一个很酷的工具叫做Redux，你可能听说过，它是为这样的场景设计的，当你的组件嵌套失控，道具被左右传递的时候。由于React最近重组的Context API和其他竞争库，它可能会被淘汰，它可能会激起开发人员的热情，他们可能会认为它是自切片面包以来最好的东西，也可能是令人困惑的混乱，但它肯定仍然有它的位置。</p><p id="778d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于Redux使用的黄金法则，来自它的创造者和全世界的开发者，是类似于“如果你不确定你是否需要Redux，你可能不需要。”对那些人，我说…嗯，你可能是对的。Redux <em class="kl">是否为简单的任务增加了很多复杂性和样板，我们很快就会发现。事实上，我<em class="kl">用普通的旧React做了</em>这个吉他应用程序，它运行得很好。但是，那时(两个月前)我还年轻天真，所以为了解释起见，让我们来看看它是如何让我们的生活变得更容易的。一旦我们解决了样板文件，Redux就有能力让您的应用程序更具可伸缩性、更高性能、更易于调试和推理。另外，我真的很喜欢！</em></p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff km"><img src="../Images/f2e0dea504fc579d237c9b6fb4db0687.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*njPXeKDlnGE4h0p0jh3q3A.jpeg"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">An artist’s rendering of a React app. Who’s got time for all that nesting?</figcaption></figure></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="359a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，让我们假设您已经构建了一个React应用程序。如果没有，可以查看其中一个<a class="ae ka" href="https://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/" rel="noopener ugc nofollow" target="_blank">多</a> <a class="ae ka" href="http://buildwithreact.com/tutorial" rel="noopener ugc nofollow" target="_blank">大</a> <a class="ae ka" href="https://ihatetomatoes.net/react-tutorial-for-beginners/" rel="noopener ugc nofollow" target="_blank">教程</a> <a class="ae ka" href="https://egghead.io/courses/the-beginner-s-guide-to-react" rel="noopener ugc nofollow" target="_blank">出</a> <a class="ae ka" href="https://github.com/enaqx/awesome-react" rel="noopener ugc nofollow" target="_blank">出</a>。如果你愿意，甚至可以尝试<a class="ae ka" href="https://www.npmjs.com/package/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>。一旦你开始运行，我们要做的第一件事就是安装我们的软件包！</p><pre class="kc kd ke kf fq ku kv kw kx aw ky dt"><span id="baef" class="kz la hu kv b fv lb lc l ld le">sudo npm install redux<br/>sudo npm install react-redux</span></pre><p id="aebb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">敏锐的读者可能会注意到，我们同时安装了Redux和一个特定于React的版本——这是怎么回事？！Redux实际上是一个框架无关的库。你可以使用它与骨干，或秘银，或角，或流星，或Vue它将与他们所有的工作！不过，React的特定版本有一些方法，当我们在组件中进行设置时，这些方法会变得非常有用。</p><p id="14cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装完成后，我们将设置我们的文件结构，这比我们在传统的React应用程序中使用的文件结构多一些。每个人的做法都有所不同，但通常我喜欢在我的react-client/src目录中创建一个<strong class="je hv"> actions </strong>文件夹、一个<strong class="je hv"> reducers </strong>文件夹和一个<strong class="je hv"> store </strong>文件夹，如下所示:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/f8bf63ea43dde1e7383b5663afdb78da.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*wA0K2ScqFXvIwK-mvtCDXA.png"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">You may see some folks use constants, I don’t bother with those.</figcaption></figure></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="7ee5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了！所以让我们从<strong class="je hv">商店</strong>开始——这是Redux工作的原因。你可以把它想象成一个外部状态容器，React组件可以通过一些特殊的方法直接与之交互，而不管它们在项目层次结构中的嵌套层次。需要一些状态吗？去<strong class="je hv">店</strong>！需要更新状态？向<strong class="je hv">商店</strong>派遣行动！一切都是相通的！</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff km"><img src="../Images/bac4434a2c06ec263085d3a203398a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*pFxhA5OUN8A_W_IQRFFDuw.jpeg"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">That’s right, I used the same reference twice in one article. It’s… a metaphor for how Redux makes you write the same thing in a few places in your app… or something.</figcaption></figure><p id="3eeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们在我们的<strong class="je hv">商店</strong>文件夹中创建一个<strong class="je hv"> index.js </strong>文件。首先，我们将导入React，这样我们就可以访问它——这是有意义的。接下来，我们将直接从Redux导入两个方法:<em class="kl"> createStore </em>和<em class="kl"> combineReducers。这些听起来就像是真的一样！什么是<strong class="je hv">减速器</strong>，为什么我们要把它们结合在一起？让我们暂时搁置这个问题，只是说我们还将导入我们的<strong class="je hv"> reducers.js </strong>文件，我们还没有在我们的<strong class="je hv"> reducers </strong>文件夹中创建这个文件。在我们所有的导入语句之后，我们将创建一个名为<em class="kl"> store </em>的变量，并将其中的<strong class="je hv">reducer</strong>与<em class="kl"> combineReducers、</em>组合，后者将一个对象作为参数，并将成为我们的全局应用程序状态<em class="kl">。</em>把所有这些放在一起，它看起来像下面的。</em></p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lg"><img src="../Images/a4aecbddff9459a761aa5e2be65af632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOOBQmv_lb3JAdhUc3VkTQ.png"/></div></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Line 9 is exclusively for using Redux’s excellent browser extension. I highly recommend it, but it’s not mandatory.</figcaption></figure><p id="9185" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有一个缺失的部分:Redux的<em class="kl">提供者</em>组件<strong class="je hv">。这是一个上下文包装器，它需要包围你的整个应用程序，并接收<strong class="je hv">存储</strong>作为属性，允许你的所有其他<strong class="je hv">组件</strong>通过Redux的方法访问它。在我们应用程序的最高层，我们附加的<strong class="je hv"> index.jsx <em class="kl"> </em> </strong>文件对DOM作出反应，我们将简单地导入<strong class="je hv">商店</strong>、<em class="kl">提供者</em>和我们的<strong class="je hv">应用程序组件</strong>(我们将在一秒钟内构建)并将所有东西打包，就像这样。</strong></p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/a4a963d5e794cfa928d7e7b671a9ff59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*QmKsLfrmiY5PcrsLzho33w.png"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">This way, our entire application has access to our store!</figcaption></figure></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="30e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经建立了我们的<strong class="je hv">商店</strong>，让我们来谈谈Redux生态系统的其余部分。这是最复杂的部分，所以请耐心听我说。实际上，您有一个循环关系，即<strong class="je hv">存储</strong>-&gt;-<strong class="je hv">组件</strong>-&gt;-<strong class="je hv">动作</strong>-&gt;-<strong class="je hv">减速器</strong>-&gt;-<strong class="je hv">存储</strong>(见下图)。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff li"><img src="../Images/b47173610577d4887dc48c2d747d365e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*Kem91lwpqWk4iTyEmLs3AQ.png"/></div></figure><p id="7e09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过一个名为<em class="kl"> mapStateToProps </em>的小函数，将<strong class="je hv">商店</strong>的状态映射到<strong class="je hv">组件</strong>——你可以将此视为订阅服务。事实上，它使用的本地Redux方法叫做<em class="kl"> subscribe </em>(尽管在本教程中我们不会直接使用它)。对<strong class="je hv">商店</strong>所做的任何更改都将向下传递到已经订阅了<strong class="je hv">商店</strong>中该属性的任何<strong class="je hv">组件</strong>，从而触发重新渲染。很整洁，是吧？</p><p id="691b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，为了真正影响应用程序的状态，一个<strong class="je hv">组件</strong>必须使用一个单独的函数:<em class="kl"> mapDispatchToProps </em>。<em class="kl"> Dispatch </em>是另一个<strong class="je hv"> store </strong>方法，它接受一个<strong class="je hv">动作</strong>(我们导入的)并将其发送给一个<strong class="je hv"> reducer </strong>，后者接收那个<strong class="je hv">动作</strong>，并实际改变应用程序的状态。我知道这有点拗口，但是让我们一步步来，从一个超级简单的<strong class="je hv">组件</strong>开始。这将是我们最高级的<strong class="je hv">应用组件</strong>，它还将从Redux导入一个名为<em class="kl"> bindActionCreators </em>的方法，以及从React-Redux导入一个名为<em class="kl"> connect </em>的方法。前者只是让编写我们的<em class="kl"> mapDispatchToProps </em>函数更加简洁，而后者是一个<strong class="je hv">高阶组件</strong>，它将<em class="kl">我们的</em> <strong class="je hv">组件</strong>与<em class="kl"> mapStateToProps </em>和<em class="kl"> mapDispatchToProps </em>捆绑在一起，以便这些方法可以访问<strong class="je hv">存储库</strong>。也就是说:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/5251fbbb8add382bd108d0e0e99a20f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcBFLWsXvsbIsGsPB__Zcw.png"/></div></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Notice how we’re importing our action on line 5<em class="lk">.</em></figcaption></figure><p id="bdb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里还有几个其他的小问题——注意<em class="kl"> mapStateToProps </em>如何将应用程序状态作为参数，以及我们如何从该状态中提取单个属性。这些属性可以在那个<strong class="je hv">组件</strong>的<em class="kl">道具</em>上访问，所以如果我们想获得<em class="kl">示例比例</em>，我们可以在<strong class="je hv">组件</strong>的渲染函数中这样做(注意&lt; p &gt;标签):</p><pre class="kc kd ke kf fq ku kv kw kx aw ky dt"><span id="433e" class="kz la hu kv b fv lb lc l ld le">render() {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Hello world, this is a Redux tutorial!&lt;/h1&gt;<br/>            &lt;p&gt;Here is our property: {this.props.examplePropOne}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="21bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，对<em class="kl">示例对象</em>所做的任何更改，即使来自另一个<strong class="je hv">组件</strong>，也将流经并呈现在这个<strong class="je hv">组件</strong>中。您不必从您的<em class="kl"> mapStateToProps </em>函数中的state对象中挑选出所有属性——只引入您的<strong class="je hv">组件</strong>关心的那些属性！</p><p id="4699" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kl"> mapDispatchToProps </em>类似地，将<em class="kl">调度</em>作为参数。<em class="kl"> Dispatch </em>是Redux <strong class="je hv"> store </strong>的一个特殊方法，通过<em class="kl"> bindActionCreators </em>将我们的<strong class="je hv">动作</strong>与它关联起来，我们都将它附加到<strong class="je hv">组件</strong>的props上，并且说，每当它被调用时，它将把有问题的<strong class="je hv">动作</strong>分派给要被调用的<strong class="je hv">缩减器</strong></p><p id="2da0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个关于<em class="kl">和</em>如何在同一个组件的函数中出现的例子:</p><pre class="kc kd ke kf fq ku kv kw kx aw ky dt"><span id="84cf" class="kz la hu kv b fv lb lc l ld le">exampleFunction() {<br/>    this.props.exampleAction();<br/>}</span></pre><p id="cf55" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还和我在一起吗？在<strong class="je hv">组件</strong>中要注意的最后一件事是<em class="kl">连接</em>方法的语法——它将总是带有两个参数，并且它们将总是按照顺序是<em class="kl"> mapStateToProps </em>和<em class="kl"> mapDispatchToProps </em>。您可以很容易地省略<em class="kl"> mapDispatchToProps </em>，但是如果您想要省略特定<strong class="je hv">组件</strong>上的<em class="kl"> mapStateToProps </em>，请确保在其位置保留一个<em class="kl"> null </em>值。应该在<em class="kl">连接</em>语句的最后调用<strong class="je hv">组件</strong>本身的名称。下面是另一个例子，这次没有使用<em class="kl"> mapStateToProps </em>，而是使用了一个叫做<strong class="je hv"> List </strong>的<strong class="je hv">组件</strong>:</p><pre class="kc kd ke kf fq ku kv kw kx aw ky dt"><span id="7cd4" class="kz la hu kv b fv lb lc l ld le">export default connect(null, mapDispatchToProps)(List);</span></pre></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="f864" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，我们已经处理了Redux生命周期中的<strong class="je hv">商店</strong>和<strong class="je hv">组件</strong>部分。这样就剩下<strong class="je hv">动作</strong>和<strong class="je hv">减速器</strong>了。</p><p id="a17f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">动作</strong>是简单的部分——它们只是创建JavaScript对象的函数，有一个强制属性叫做<em class="kl">类型</em>。按照惯例，<em class="kl">类型</em>通常全部用大写字母书写，非常能描述<strong class="je hv">动作</strong>实际做的事情。它通常有另一个名为<em class="kl">有效载荷</em>的属性，在这个属性中，我们将任何实际的数据传递到<strong class="je hv">动作</strong>中。一般来说，我们希望避免在这些<strong class="je hv">动作</strong>中包含任何实际的应用程序逻辑:它们应该简单地传递一个<em class="kl">类型</em>和一些潜在的数据。下面是我们的<strong class="je hv"> actions/actions.js </strong>文件可能的样子:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/07209da5a6e935f34a18594b6a3f4b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*3Ng9KuaT60MIAa2PHM-vWA.png"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Notice how the second action receives an argument, which it passes along as a payload.</figcaption></figure><p id="94b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是<strong class="je hv">行动</strong>的全部内容！</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="cd3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，我们的生命周期中只剩下一个项目:<strong class="je hv">减速器</strong>。一个<strong class="je hv">缩减器</strong>实际上是一个巨大的开关语句，它接受一个<strong class="je hv">动作</strong>，并根据其<em class="kl">类型</em>，更新应用程序的状态。如果您还记得，当我们在上面创建我们的<strong class="je hv">存储</strong>时，我们导入了我们的<strong class="je hv">reducer</strong>并在我们的<em class="kl"> createStore </em>函数中通过<em class="kl">combiner reducer</em>传递它们，这意味着无论从我们的<strong class="je hv">reducer</strong>返回什么，都将更新<strong class="je hv">存储</strong>的状态。然后，这些更改将通过我们放在<strong class="je hv">组件</strong>中的任何<em class="kl"> mapStateToProps </em>函数向下流动，以订阅<strong class="je hv">存储</strong>，我们的数据将被完全链接。那是Redux！我们做到了！</p><p id="9f68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，有一个重要的概念我已经忽略了——事实上，它是Redux中最重要、最基本的概念之一:<em class="kl">不变性</em>。简而言之，使用Redux，为了更容易的调试、干净的单例代码和更高性能的应用程序，我们实际上从不直接改变应用程序的状态。相反，每一个单独的状态改变都被记录为及时的快照，并且每一个改变都是对状态的拷贝版本进行的。举一个最明显的例子来说明这一点是如何有用的，以前面提到的Redux dev工具为例:它在整个应用程序的生命周期中保存了<em class="kl">状态的全部历史记录，这样你就可以一步步地看到事情是如何以及何时发生变化的。超级有用！如果你有时间的话，我强烈推荐你使用它。</em></p><p id="ac9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">话虽如此，这里有一个<strong class="je hv">缩减器</strong>可能看起来像什么的例子——也就是说，一个函数接受应用程序的状态，以及传入的<strong class="je hv">动作</strong>，通过一个switch语句运行它，并返回状态的更新版本以传送到<strong class="je hv">存储</strong>:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/464e703591fc11d457a7fac712ebcf63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*M6pMiEsrWyj-P_ojGcdN9w.png"/></div></figure><p id="1cc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们不必像我在这个例子中那样提供默认状态——在一些应用程序中，您将在不同的文件中定义一个默认状态，赋予它初始化属性，然后将其导入到您的<strong class="je hv"> reducer </strong>中。在其他应用程序中，您可以使用ES6的默认参数简单地将状态初始化为空对象。初始化状态没有严格的规则，除了它必须被定义，你的<strong class="je hv">减速器</strong>必须<em class="kl">总是</em>返回一个状态。为此，我们不要忘记第18行的默认情况，这也很重要。</p><p id="223c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至关重要的是，<strong class="je hv"> reducer </strong>应该接受一个状态对象和一个<strong class="je hv">动作</strong>作为参数，在<strong class="je hv">动作</strong>的<strong class="je hv"> </strong> <em class="kl">类型</em>属性上设置一个开关，然后返回一个复制版本的状态，并带有所需的更新属性。请注意第10行和第15行的扩展操作符:这些操作符在添加和/或修改所需属性之前扩展了先前的状态，这意味着您最终将通过每个<strong class="je hv">操作</strong>向<strong class="je hv">存储库</strong>返回一个复制的、稍微修改过的状态版本。您也可以使用Object.assign来实现这一点，但是我发现spread操作符更优雅。还要注意在第16行我们如何使用<strong class="je hv">动作的</strong> <em class="kl">有效负载</em>属性将数据传递到我们的状态，而在第11行我们硬编码了对<em class="kl">example propene</em>的修改。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="0b51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当谈到React-Redux时，我们可以谈论更多的内容。举个例子，异步动作:传递API调用的结果，这种大多数时候都很轻松的操作，如果你有<strong class="je hv">个动作</strong>需要在执行前满足一定的标准，可能会引起麻烦。有一个名为<em class="kl"> redux-thunk </em>的库可以帮助处理这个问题。你也可以在一个项目中有多个<strong class="je hv">减速器</strong>，然后你可以通过<strong class="je hv">存储</strong>文件中的<em class="kl">组合减速器</em>函数来传递。此外，局部状态在单独的<strong class="je hv">组件</strong>中仍然非常有用，并且您应该只在嵌套的<strong class="je hv">组件之间传递状态的情况下才使用<strong class="je hv">存储</strong>。</strong>我鼓励您阅读更多内容，并开始尝试学习Redux的所有优点，并阅读竞争状态管理解决方案，包括mobx和前面提到的Context API。</p><p id="f84d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过，在这一点上，我希望你能看到Redux如何让我们的吉他应用程序变得简单一点。假设用户点击一个品，我们需要更新它所在的弦、吉他组件、应用组件<strong class="je hv">和表单组件<strong class="je hv"/>。与其到处传递<em class="kl">道具</em>，通过可能根本用不到的多个关卡，我们可以改为发送一个<strong class="je hv">动作</strong>并设置几个订阅，我们就可以开始了！在有大量嵌套和大量状态要管理的特别大的应用程序中，这可以使你的生活简单很多，并且是一个非常棘手的问题的一个可能的解决方案。</strong></p><p id="9a62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你做到了这一步，感谢你的阅读！这是一只可爱的雪貂作为感谢。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/8a57da9dc2e1228b5a55031c09d2799d.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*sOjF9WVN7gz08UDk8miS6Q.jpeg"/></div></figure></div></div>    
</body>
</html>