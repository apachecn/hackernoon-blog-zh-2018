<html>
<head>
<title>Showdown: MySQL 8 vs PostgreSQL 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">摊牌:MySQL 8 vs PostgreSQL 10</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/showdown-mysql-8-vs-postgresql-10-3fe23be5c19e?source=collection_archive---------3-----------------------#2018-05-23">https://medium.com/hackernoon/showdown-mysql-8-vs-postgresql-10-3fe23be5c19e?source=collection_archive---------3-----------------------#2018-05-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/10384d3b9dd39020628edf0aaa7cd46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eojT2CVjYsQNtaLFxvKUuw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/8TJbrQGKFyU" rel="noopener ugc nofollow" target="_blank">David Marcu</a></figcaption></figure><p id="4d7e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在<a class="ae jg" href="https://mysqlserverteam.com/whats-new-in-mysql-8-0-generally-available/" rel="noopener ugc nofollow" target="_blank">的MySQL 8 </a>和<a class="ae jg" href="https://www.postgresql.org/about/news/1786/" rel="noopener ugc nofollow" target="_blank">的PostgreSQL 10 </a>已经发布，这是一个重新审视这两个主要开源关系数据库如何相互竞争的好时机。</p><p id="d3bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这些版本之前，普遍的看法是，虽然Postgres在功能集和谱系方面更胜一筹，但MySQL在大规模并发读/写方面更经得起考验。</p><p id="8dff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但随着最新版本的发布，两者之间的差距已经明显缩小。</p><h1 id="1f4a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">特征比较</h1><p id="1a74" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">让我们来看看那些我们都爱谈论的“新潮”特征。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/011c1f36d48f5450c818529877e35624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RM4sMrIn4L7bcPywZWJRuw.png"/></div></div></figure><p id="ad4c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">过去很容易说MySQL最适合在线交易，PostgreSQL最适合分析过程。但现在不是了。</p><p id="cea6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通用表表达式(cte)和窗口函数是选择PostgreSQL的主要原因。但是现在，递归地遍历一个<code class="eh ln lo lp lq b">employees</code>表并引用同一个表中的<code class="eh ln lo lp lq b">boss_id</code>，或者在一个排序结果中找到一个中值(或者50%)在MySQL上不再是一个问题。</p><p id="6e56" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">PostgreSQL缺乏配置灵活性是<a class="ae jg" href="https://eng.uber.com/mysql-migration/" rel="noopener ugc nofollow" target="_blank">优步转向MySQL </a>的原因。但是现在有了逻辑复制，通过用新版本的Postgres创建一个副本并切换到它，零停机升级成为可能。在一个巨大的时序事件表中截断一个陈旧的分区也容易得多。</p><p id="4d4e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就功能而言，这两个数据库现在不相上下。</p><h1 id="8921" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">区别在哪里？</h1><p id="de2a" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在，我们只剩下一个问题——那么，选择一个而不是另一个的理由是什么？</p><p id="a078" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">生态系统是其中一个因素。MySQL有一个充满活力的生态系统，有MariaDB、Percona、Galera等变种。以及除InnoDB之外的存储引擎，但这也可能令人不知所措。Postgres的高端选项有限，但随着最新版本推出的新功能，这种情况将会改变。</p><p id="ccb0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">治理是另一个因素。当甲骨文(或最初的SUN)收购MySQL时，每个人都担心他们会毁了这个产品，但在过去的十年里，情况并非如此。事实上，收购后发展加速了。Postgres在工作治理和协作社区方面有着坚实的历史。</p><p id="5f82" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">架构基础</strong>不会经常改变，值得重温一下，因为这些现在没有被详细讨论。</p><p id="ce66" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个复习:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/40932615b73e2ac24a9154ef6c598b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtiA09xS90-5qbLdHquGiA.png"/></div></div></figure><h2 id="fe45" class="lr kg hu bd kh ls lt lu kl lv lw lx kp js ly lz kt jw ma mb kx ka mc md lb me dt translated">进程与线程</h2><p id="5c40" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">当<a class="ae jg" href="https://www.postgresql.org/docs/10/static/tutorial-arch.html" rel="noopener ugc nofollow" target="_blank"> Postgres派生出一个子进程</a>来建立一个连接时，每个连接会占用<a class="ae jg" href="https://www.citusdata.com/blog/2017/05/10/scaling-connections-in-postgres/" rel="noopener ugc nofollow" target="_blank">10mb。与MySQL的每连接线程模型相比，内存压力更大，在64位平台上，线程</a>的默认<a class="ae jg" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_thread_stack" rel="noopener ugc nofollow" target="_blank">堆栈大小为256KB。(当然还有线程本地排序缓冲区等。使这种开销不那么重要，如果不是可以忽略的话，但仍然。)</a></p><p id="8317" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管<a class="ae jg" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">写时复制</a>保存了父进程的一些共享的、不可变的内存状态，但是当您有1000多个并发连接时，作为基于进程的架构的基本开销是很大的，并且它可能是容量规划的最重要因素之一。</p><p id="cabd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">也就是说，假设您在30台服务器上运行一个Rails应用程序，每台服务器有16个CPU内核和32个Unicorn workers，那么您就有960个连接。可能只有不到0.1%的应用程序会达到这个规模，但这是需要记住的。</p><h2 id="a0ec" class="lr kg hu bd kh ls lt lu kl lv lw lx kp js ly lz kt jw ma mb kx ka mc md lb me dt translated">聚集索引与堆表</h2><p id="e540" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated"><a class="ae jg" href="https://docs.microsoft.com/en-us/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-2017" rel="noopener ugc nofollow" target="_blank">聚集索引</a>是一种表结构，其中的行直接嵌入到其主键的B树结构中。(非聚集的)堆是一种常规的表结构，由独立于索引的数据行填充。</p><p id="fdff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于聚集索引，当您通过主键查找记录时，单个I/O将检索整行，而非聚集索引总是需要至少两个I/O才能进行引用。由于外键引用和连接将触发主键查找，这种影响可能很大，而主键查找占了绝大多数查询。</p><p id="e98e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">聚集索引的一个理论上的缺点是，当使用辅助索引进行查询时，它需要两倍的树节点遍历，因为您首先扫描辅助索引，然后遍历聚集索引，聚集索引也是一棵树。</p><p id="680e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是考虑到现代的<a class="ae jg" href="https://en.wikipedia.org/wiki/Convention_over_configuration" rel="noopener ugc nofollow" target="_blank">惯例</a>将自动递增的整数作为主键——它被称为<a class="ae jg" href="https://en.wikipedia.org/wiki/Surrogate_key" rel="noopener ugc nofollow" target="_blank">代理键</a>—<a class="ae jg" href="https://www.mssqltips.com/sqlservertutorial/3209/make-sure-all-tables-have-a-clustered-index-defined/" rel="noopener ugc nofollow" target="_blank">几乎总是希望拥有聚集索引</a>。如果您做了大量的<code class="eh ln lo lp lq b">ORDER BY id</code>来检索最近的(或最老的)N条记录，情况就更是如此，我相信这适用于大多数记录。</p><blockquote class="mf mg mh"><p id="d4bf" class="jh ji mi jj b jk jl jm jn jo jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd ke hn dt translated">[1]顺便说一下，将UUID作为主键是一个糟糕的想法——密码随机性完全是为了消除引用的局部性而设计的，因此会带来性能损失。</p></blockquote><p id="61c7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Postgres不支持聚集索引，而MySQL (InnoDB)不支持堆。但是不管怎样，如果你有大量的内存，这种差别应该是很小的。</p><h2 id="1ca5" class="lr kg hu bd kh ls lt lu kl lv lw lx kp js ly lz kt jw ma mb kx ka mc md lb me dt translated">页面结构和压缩</h2><p id="66dc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Postgres和MySQL都有基于页面的物理存储。(8KB对16KB)</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/8ae1d0dd29b12efd201b26c0d109dbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5t5c-FGHhdtwz1z2cmeOEQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">From <a class="ae jg" href="http://rachbelaid.com/introduction-to-postgres-physical-storage/" rel="noopener ugc nofollow" target="_blank">Introduction to PostgreSQL physical storage</a></figcaption></figure><p id="4ac8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在PostgreSQL上，页面结构看起来像左边的图像。</p><p id="a7cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它包含了一些我们在这里不打算讨论的标题，但是它们包含了关于页面的元数据。头后面的条目是一个由指向元组或数据行的<code class="eh ln lo lp lq b">(offset, length) </code>对组成的数组标识符。请记住，在Postgres上，同一记录的多个版本可以以这种方式存储在同一页面中。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/13b4e45d0c47faab4fc59e6c757968fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKTHGq1eJEP4xCQN9GJUgg.jpeg"/></div></div></figure><p id="4137" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">MySQL的表空间结构类似于Oracle的表空间结构，它有多个层次，包括段、范围、页和行。</p><p id="9a9a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它还有一个单独的撤销段，称为“回滚段”与Postgres不同，MySQL将同一记录的多个版本保存在单独的区域。</p><p id="28b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一行必须适合两个数据库的单个页面，这意味着一行必须小于8KB。(在MySQL上，一个页面至少要有2行，恰好是16KB / 2 = 8KB)</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/717fd307e27a72d8dd2a1c9304a3d1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDibjX9OFPupE-OMybsTQg.png"/></div></div></figure><p id="4bab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么当一个列中有一个大型JSON对象时会发生什么呢？</p><p id="4cb9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Postgres使用<a class="ae jg" href="https://wiki.postgresql.org/wiki/TOAST" rel="noopener ugc nofollow" target="_blank"> TOAST </a>，一个专用的影子表存储。当且仅当行和列被选择时，大对象被拉出。换句话说，一大块黑盒不会污染你宝贵的缓存内存。它还支持烘烤物体上的压缩。</p><p id="5c08" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">MySQL有一个更复杂的功能，称为<a class="ae jg" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-page-compression.html" rel="noopener ugc nofollow" target="_blank">透明页面压缩</a>，这要感谢高端SSD存储供应商<a class="ae jg" href="https://en.wikipedia.org/wiki/Fusion-io" rel="noopener ugc nofollow" target="_blank"> Fusion-io </a>的贡献。它是专为更好地与固态硬盘配合使用而设计的，固态硬盘的写入量与设备的寿命直接相关。</p><p id="f23d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">MySQL上的压缩不仅适用于离页大对象，还适用于所有页面。这是通过在一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Sparse_file" rel="noopener ugc nofollow" target="_blank">稀疏文件</a>中打孔来实现的，现代文件系统如<a class="ae jg" href="https://en.wikipedia.org/wiki/Ext4" rel="noopener ugc nofollow" target="_blank"> ext4 </a>或<a class="ae jg" href="https://en.wikipedia.org/wiki/Btrfs" rel="noopener ugc nofollow" target="_blank"> btrfs </a>都支持这个文件系统。</p><p id="442b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有关更多详细信息，请参见:<a class="ae jg" href="https://mariadb.org/significant-performance-boost-with-new-mariadb-page-compression-on-fusionio/" rel="noopener ugc nofollow" target="_blank">fusion io上新的MariaDB页面压缩带来的显著性能提升</a></p><h2 id="0162" class="lr kg hu bd kh ls lt lu kl lv lw lx kp js ly lz kt jw ma mb kx ka mc md lb me dt translated">更新开销</h2><p id="7020" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">另一个经常被忽略的特性是更新，它对性能有很大的影响，也可能是最有争议的话题。</p><p id="a730" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是优步放弃Postgres的另一个原因，这引起了许多Postgres倡导者的反驳。</p><ul class=""><li id="1efd" class="mp mq hu jj b jk jl jo jp js mr jw ms ka mt ke mu mv mw mx dt translated"><a class="ae jg" href="https://dzone.com/articles/on-ubers-choice-of-databases" rel="noopener ugc nofollow" target="_blank"> MySQL可能适合优步，但不适合你</a></li><li id="0848" class="mp mq hu jj b jk my jo mz js na jw nb ka nc ke mu mv mw mx dt translated"><a class="ae jg" href="http://thebuild.com/presentations/uber-perconalive-2017.pdf" rel="noopener ugc nofollow" target="_blank">对优步的PostgreSQL响应(PDF) </a></li></ul><p id="9ed0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">两者都是<a class="ae jg" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" rel="noopener ugc nofollow" target="_blank"> MVCC </a>数据库，为<a class="ae jg" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)" rel="noopener ugc nofollow" target="_blank">隔离</a>保存多个版本的数据。</p><p id="5d60" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为此，Postgres将旧数据保留在堆中，直到清空，而MySQL将旧数据移动到一个称为回滚段的独立区域。</p><p id="0893" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Postgres上，当您尝试更新时，必须复制整行，以及指向它的索引条目。这部分是因为Postgres不支持聚集索引，从索引引用的行的物理位置不是由逻辑键抽象出来的。</p><p id="1d05" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了解决这个问题，Postgres使用<a class="ae jg" href="http://www.interdb.jp/pg/pgsql07.html" rel="noopener ugc nofollow" target="_blank"> Heap Only Tuples (HOT) </a>在可能的情况下不更新索引。但是如果更新足够频繁(或者如果一个元组很大)，元组的历史可以很容易地流出8KB的页面大小，跨越多个页面并限制该特性的有效性。修剪和/或碎片整理的时间取决于试探法。此外，将<a class="ae jg" href="https://www.postgresql.org/docs/10/static/sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS" rel="noopener ugc nofollow" target="_blank"> fillfactor </a>设置为小于100会降低空间效率——这是一个艰难的权衡，在创建表时不应该担心。</p><p id="10c3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种限制甚至更深；因为索引元组没有任何关于事务的信息，所以在9.2之前，很久以来都不可能支持<a class="ae jg" href="https://use-the-index-luke.com/sql/clustering/index-only-scan-covering-index" rel="noopener ugc nofollow" target="_blank">仅索引扫描</a>。这是最古老、最重要的优化方法之一，受到所有主流数据库的支持，包括MySQL、Oracle、IBM DB2和Microsoft SQL Server。但即使是最新版本，当有一堆更新在<a class="ae jg" href="http://www.interdb.jp/pg/pgsql06.html#_6.2." rel="noopener ugc nofollow" target="_blank">可见性映射</a>中设置脏位时，Postgres也无法完全支持仅索引扫描，并且经常在我们不希望的时候选择Seq Scan。</p><p id="4622" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在MySQL上，更新就地进行，旧的行数据存储在一个称为回滚段的独立区域中。结果是您不需要真空，提交非常快，而回滚相对较慢，这对大多数用例来说是一个更好的折衷。</p><p id="613c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">也是<a class="ae jg" href="https://www.percona.com/blog/2011/01/12/innodb-undo-segment-siz-and-transaction-isolation/" rel="noopener ugc nofollow" target="_blank">足够聪明</a>尽快清洗历史。如果事务的隔离级别设置为<strong class="jj hv"> READ-COMMITTED </strong>或更低，则当语句完成时，历史将被清除。</p><p id="fbe4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">交易历史的大小不影响主页。分裂不是问题。因此，MySQL的整体性能更好、更可预测。</p><h2 id="ecd7" class="lr kg hu bd kh ls lt lu kl lv lw lx kp js ly lz kt jw ma mb kx ka mc md lb me dt translated">碎片帐集</h2><p id="a100" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Postgres上的VACUUM是非常昂贵的，因为它在主堆区域中工作，产生了直接的资源争用。这感觉就像编程语言中的垃圾收集——它碍手碍脚，让你随意停顿。</p><p id="8ddb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://www.citusdata.com/blog/2016/11/04/autovacuum-not-the-enemy/" rel="noopener ugc nofollow" target="_blank">为拥有数十亿条记录的表配置autovacuum </a>仍然是一个挑战。</p><p id="d5fd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">MySQL上的清除也可能很繁重，但是因为它在单独的回滚段中使用专用线程运行，所以不会对读取并发性产生任何负面影响。膨胀的回滚段降低速度的可能性要小得多，即使使用默认设置。</p><p id="35f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个拥有数十亿条记录的繁忙的表不会导致MySQL上的历史膨胀，并且诸如存储上的文件大小和查询性能之类的事情是非常可预测和稳定的。</p><h2 id="9f0f" class="lr kg hu bd kh ls lt lu kl lv lw lx kp js ly lz kt jw ma mb kx ka mc md lb me dt translated">日志和复制</h2><p id="b9d0" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Postgres对于交易历史有一个单一的真实来源，称为<a class="ae jg" href="http://www.interdb.jp/pg/pgsql09.html" rel="noopener ugc nofollow" target="_blank">提前写日志(WAL) </a>。它还用于复制，名为逻辑复制的新功能可以动态地将二进制内容解码为更容易理解的逻辑语句，从而允许对数据进行细粒度控制。</p><p id="0584" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">MySQL维护两个独立的日志:1。用于崩溃恢复的InnoDB特定的<a class="ae jg" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html" rel="noopener ugc nofollow" target="_blank">重做日志</a>，以及2 .<a class="ae jg" href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html" rel="noopener ugc nofollow" target="_blank">用于复制和增量备份的二进制日志</a>。</p><p id="2338" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">与Oracle一样，InnoDB上的重做日志是一个免维护的<a class="ae jg" href="https://en.wikipedia.org/wiki/Circular_buffer" rel="noopener ugc nofollow" target="_blank">循环缓冲区</a>，不会随着时间的推移而增长，只会在启动时以固定的大小创建。这种设计保证在物理设备上保留连续的区域，从而提高性能。较大的重做日志产生较高的性能，但代价是从崩溃中恢复的时间。</p><p id="1b76" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Postgres增加了新的复制特性，我称之为平局。</p><h1 id="f7fb" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="35cd" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">令人惊讶的是，事实证明，普遍的看法仍然成立；MySQL最适用于在线交易，PostgreSQL最适用于仅附加的分析过程，如数据仓库。</p><blockquote class="mf mg mh"><p id="18d2" class="jh ji mi jj b jk jl jm jn jo jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd ke hn dt translated">[2]当我说Postgres对分析很有帮助时，我是认真的。如果您不知道<a class="ae jg" href="https://blog.timescale.com/timescaledb-vs-6a696248104e" rel="noopener ugc nofollow" target="_blank"> TimescaleDB </a>，它是PostgreSQL之上的一个包装器，允许您每秒插入100万条记录，每台服务器1000多亿行。疯狂的事情。难怪<a class="ae jg" href="https://docs.aws.amazon.com/redshift/latest/dg/c_redshift-and-postgres-sql.html" rel="noopener ugc nofollow" target="_blank">亚马逊选择PostgreSQL作为红移</a>的基础。</p></blockquote><p id="000b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如我们在本文中看到的，Postgres的大部分复杂性源于其仅附加的、过度冗余的堆架构。</p><p id="1c49" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Postgres的未来版本可能需要对其存储引擎进行重大改进。你不必相信我的话——这实际上是在官方维基上讨论的<a class="ae jg" href="https://wiki.postgresql.org/wiki/Future_of_storage" rel="noopener ugc nofollow" target="_blank">，这表明是时候从InnoDB带回一些好的想法了。</a></p><p id="d8fd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">人们一次又一次地说MySQL正在追赶Postgres，但这一次，潮流变了。</p></div><div class="ab cl nd ne hc nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hn ho hp hq hr"><p id="8800" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mi">如果你想阅读更多这样的内容，请访问</em> <a class="ae jg" href="https://blog.dumper.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> Dumper博客</em> </a> <em class="mi">并订阅邮件列表。也可以在Twitter上</em> <a class="ae jg" href="https://twitter.com/@kenn" rel="noopener ugc nofollow" target="_blank"> <em class="mi">关注我</em> </a> <em class="mi">。除非您100%确定您的备份脚本正在运行，否则请查看</em> <a class="ae jg" href="https://dumper.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mi">转储器</em> </a> <em class="mi">，异地备份即服务。</em></p></div></div>    
</body>
</html>