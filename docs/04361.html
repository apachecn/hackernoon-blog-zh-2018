<html>
<head>
<title>Design Autocomplete System in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python设计自动完成系统</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/design-auto-complete-system-in-python-8fab1470cd92?source=collection_archive---------7-----------------------#2018-05-23">https://medium.com/hackernoon/design-auto-complete-system-in-python-8fab1470cd92?source=collection_archive---------7-----------------------#2018-05-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e58c3503a3af4edd746ee624d067234d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bk8PBgPSpbya0T4xpHeUlg.png"/></div></div></figure><p id="d5ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自动完成是许多web服务的关键特性。当你在谷歌中输入一些短语时，它会显示一个搜索建议列表。有时这些结果使用您的输入作为前缀，有时不使用。谷歌是如何做到如此快速准确的呢？我们如何用Python设计一个简化的自动完成系统？</p><p id="51d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们正在设计web服务的后端，所以我们需要考虑服务器和数据库之间的数据流，以及服务器停机时的恢复机制。下面是从分布式系统基础设施角度来看的特性列表。</p><ul class=""><li id="4d03" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">可以从数据库构建新的和恢复的应用服务器。</li><li id="9538" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">复制和分区数据库的选项。</li><li id="1297" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">应用服务器应该能够用最新的使用数据更新数据库。</li><li id="0413" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">应用服务器能够从头开始构建数据库。</li></ul><p id="3402" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从服务器的角度来看，我们需要考虑如何优化性能。</p><ul class=""><li id="1d75" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">我们如何更新排名靠前的结果？如果我们要每秒处理数千个请求，延迟必须最小化。</li><li id="f7b8" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">我们多久执行一次更新？我们假设最终的一致性吗？</li><li id="449d" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">如果有必要，我们如何从服务器上删除短语？</li></ul><h2 id="a082" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">数据结构和算法</h2><p id="d16b" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">为了处理大量数据，服务器应该能够快速搜索、插入和删除短语。此外，我们应该优化更新操作。</p><p id="f540" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑所有建议都具有用户输入的相同前缀的基本情况。那么存储数据最省时的数据结构就是前缀树，也称为<strong class="je hv"> Trie </strong>。我们不打算详细说明Trie是如何工作的，因为有大量的<a class="ae lo" rel="noopener" href="/basecs/trying-to-understand-tries-3ec6bede0014">文章</a>是用于这个目的的。基本上给定一个最长长度为M的短语列表，在Trie中搜索任何短语需要O(M)时间。多亏了Trie，<code class="eh lp lq lr ls b">search</code>操作本来就很快。</p><p id="c9e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，我们仍然需要精心设计架构来支持其他操作。Trie节点设计如下。TrieNode是具有前缀字符串和指向子/父节点的指针的节点。它使用Python计数器存储热门建议。我们可以使用<code class="eh lp lq lr ls b">most_common()</code>内置方法高效地访问最常访问的结果。还要注意，它有一个标志，指示节点中的前缀是否是一个完整的单词，支持各种方法的逻辑是极其重要的。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="46cb" class="ko kp hu ls b fv mb mc l md me"><em class="mf">class </em>TrieNode:<br/>    <em class="mf">def </em>__init__(self, <em class="mf">prefix</em>=None, <em class="mf">parent</em>=None, <em class="mf">is_word</em>=False):<br/>        """<br/><br/>        :param prefix: prefix of this node<br/>        :param parent: parent node in the trie<br/>        :param is_word: True if the node stores a node<br/>        """<br/>        self.prefix = <em class="mf">prefix<br/>        </em>self.children = dict()<br/>        self.parent = <em class="mf">parent<br/>        </em>self.count = 0      <br/>        self.top_results = Counter()<br/>        <em class="mf">if is_word</em>:<br/>            self.top_results[self.prefix] = 1<br/>        self.isWord = <em class="mf">is_word</em></span></pre><p id="fd92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为服务器的主要结构是基于Trie的，所以涉及的基本算法是图算法。当我们需要遍历整个图时，基本的图遍历算法如深度优先搜索(DFS)和广度优先搜索(BFS)在代码中被广泛使用。当然，细节因函数而异，比如DFS函数签名。</p><p id="7f29" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为BFS的一个简单例子，删除短语的<code class="eh lp lq lr ls b">__delete_helper</code>方法查找子树中的所有短语。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="6237" class="ko kp hu ls b fv mb mc l md me"><em class="mf">def </em>__delete_helper(self, <em class="mf">node</em>):<br/>    """<br/>    Breadth-first search to find all children nodes that are words<br/>    :param node: TrieNode, subtree root<br/>    :return: set(str)<br/>    """<br/>    q = deque([<em class="mf">node</em>])<br/>    res = set()<br/>    <em class="mf">while </em>q:<br/>        cur = q.popleft()<br/>        <em class="mf">if </em>cur.isWord:<br/>            res.add(cur.prefix)<br/>        <em class="mf">for </em>_, child <em class="mf">in </em>cur.children.items():<br/>            q.append(child)<br/>    <em class="mf">return </em>res</span></pre><p id="f61d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lp lq lr ls b">__search_helper</code>方法使用DFS搜索错误拼写的替换。它遍历一个<code class="eh lp lq lr ls b">word_list</code>对象，这是一个嵌套的字符串列表，并返回所有单词的组合。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="81d8" class="ko kp hu ls b fv mb mc l md me">@staticmethod<br/><em class="mf">def </em>__search_helper(<em class="mf">word_list</em>, <em class="mf">idx</em>, <em class="mf">path</em>, <em class="mf">res</em>):<br/>    <em class="mf">if idx </em>== len(<em class="mf">word_list</em>):<br/>        <em class="mf">res</em>.append(list(<em class="mf">path</em>))<br/>        <em class="mf">return<br/>    for </em>word <em class="mf">in word_list</em>[<em class="mf">idx</em>]:<br/>        <em class="mf">path</em>.append(word)<br/>        Server.__search_helper(<em class="mf">word_list</em>, <em class="mf">idx</em>+1, <em class="mf">path</em>, <em class="mf">res</em>)<br/>        <em class="mf">path</em>.pop()</span></pre><h2 id="a75e" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">数据库ˌ资料库</h2><p id="917e" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">我们想建立一个连接到数据库的自动完成服务器。数据库的选择是Neo4j，这是一个在图形中表达复杂关系的绝佳选择。我们使用<a class="ae lo" rel="noopener" href="/labcodes/graph-databases-talking-about-your-data-relationships-with-python-b438c689dc89"> py2neo </a> Python包，它提供了与数据库通信所需的所有API。这是在插入4个词{尝试，平局，时间，计时}后，数据在Neo4j浏览器中的可视化效果。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/73d48979ad39fadbe6eefd33b198e791.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*U6bN6JXGoeSy5gIcEIJnlA.png"/></div></figure><h2 id="8e69" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">组件设计</h2><p id="df16" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">对于更新操作，我们不是搜索子树中的所有节点，而是使用从树叶一直到根的遍历来更新顶部的搜索结果。这种优化将时间复杂度从指数级降低到多项式级。</p><p id="1f35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，当服务器存储数百万个短语时，更新顶级搜索结果需要很长时间。我们应该找到一个合理的更新频率，以便在一致性和延迟之间取得平衡。可以通过类属性配置服务器更新频率。</p><p id="5ebc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在设计服务器类时遇到了无数的挑战。我想分享一下解决这些问题的思路。</p><p id="85f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个设计挑战是如何更新数据库。术语的子集可能已经存储在数据库中，而其他的是新术语。当遍历图形数据库时，我们必须区分节点是否存在。如果节点存在，则添加新的计数；如果没有，则在正确的位置创建新的节点。但是如何更新数据库中每个短语的计数呢？这个想法是每个节点应该保持自己的短语计数不变。更新数据库时，我们总是使用这个值来保持一致性。</p><p id="4ef0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你使用谷歌搜索时，请注意，即使你键入一些胡言乱语，系统也会自动纠正你的输入，并返回合理的搜索结果。我们希望实现类似的目标。从<a class="ae lo" href="https://norvig.com/spell-correct.html" rel="noopener ugc nofollow" target="_blank">彼得·诺维格</a>扩展经典的自动纠正器，我们创建了一个<code class="eh lp lq lr ls b">Spell</code>类，在拼写错误的情况下返回大量自动纠正结果。这个想法是，如果输入的单词不在英语词汇表中(大约40K个单词)，它的替换词将被搜索并插入到服务器中。然而，这种设计产生了另一个问题。如果我们有太多的替换，那么排序和排名将大大增加延迟。因此，在当前版本中，我们将每个拼写错误的单词的替换限制在一个较小的数字内，比如2。</p><p id="67b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">序列化对于将对象转换为字节序列以便存储在磁盘中或通过网络传输是必不可少的。序列化Trie服务器这样的复杂对象并不是一件容易的事情。我们必须考虑哪些是最需要压缩的数据，以及如何在给定序列化表示的情况下重建应用服务器。为了尽可能准确地重建TrieNode，我们必须序列化<code class="eh lp lq lr ls b">prefix, number_children, top_results and is_word</code>。序列化和反序列化应用服务器序列成对出现。我们决定使用深度优先搜索序列进行序列化。有了所有这些设计决策，我们能够序列化一个应用服务器并反序列化以创建一个新的应用服务器。下面是一个用单个单词“time”进行服务器序列化的例子。列表中的序列是DFS序列，每一项都对我们上面描述的数据进行编码。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="0b03" class="ko kp hu ls b fv mb mc l md me">[['', '0', 'time 1', '1'],<br/> ['t', '0', 'time 1', '1'],<br/> ['ti', '0', 'time 1', '1'],<br/> ['tim', '0', 'time 1', '1'],<br/> ['time', '1', 'time 1', '0']]</span></pre><h2 id="0dd0" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">未来的工作</h2><p id="99db" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">目前用户通过运行基于Python标准库中Tkinter包的<code class="eh lp lq lr ls b">app.py</code>来访问服务器。未来的计划包括使用Flask提供一个REST API来访问服务。我们还可以添加功能来重定向用户选择。</p><h2 id="12f2" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">开放源码</h2><p id="d719" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">请随时查看GitHub的实现细节，我们欢迎任何改进建议。</p><div class="mh mi fm fo mj mk"><a href="https://github.com/weihesdlegend/Auto-complete-System" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hv fv z el mp eo ep mq er et ht dt translated">weihesdlegend/自动完成系统</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">使用Neo4j图形数据库进行数据存储和检索的自动完成系统。搜索API…</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ja mk"/></div></div></a></div></div></div>    
</body>
</html>