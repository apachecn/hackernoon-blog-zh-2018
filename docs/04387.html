<html>
<head>
<title>Flask Web Programming from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始Flask Web编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/flask-web-programming-from-scratch-9ada8088fde1?source=collection_archive---------0-----------------------#2018-05-24">https://medium.com/hackernoon/flask-web-programming-from-scratch-9ada8088fde1?source=collection_archive---------0-----------------------#2018-05-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2adb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SQLAlchemy和Postgres的Flask 1.0完全指南。</p><p id="29a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">选择web框架是构建动态网站最重要也是最令人沮丧的任务之一。有数千种不同编程语言的web框架。我们基于不同的用例使用这些web框架。例如，Whatsapp使用擅长并发的Erlang编程语言，因此对于Whatsapp这样的应用程序，我们需要选择一个足够并发的框架来处理多个连接。因此，在开始web编程或建立网站之前，有一个能够处理所有类型功能的健壮框架是至关重要的。在本文中，我们将了解最常用和最著名的web框架之一“Flask”</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/6c2f7fec38b400cf35d19268506d9ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fD3qqMWNyfJ85XST9c1H2g.png"/></div></div></figure><blockquote class="kb kc kd"><p id="db8f" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">web框架(<strong class="it hv"> WF </strong>)或web应用框架(WAF)是一种软件框架，旨在支持包括web服务、web资源和web APIs在内的web应用的开发。</p></blockquote><h2 id="bffd" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated"><strong class="ak">关于&amp;为什么要烧瓶？</strong></h2><p id="285b" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">这是一个微观层次的网络框架，由阿明·罗纳彻和几个开源贡献者用<a class="ae li" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>编写。Flask基于Werkzeug(实用程序和请求)，Jinja 2(模板)。</p><p id="2b1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是官方<a class="ae li" href="http://flask.pocoo.org/docs/1.0/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> </strong> <em class="ke"> Flask 1.0文档</em> </a>的链接。</p><p id="2093" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flask社区最近发布了它的稳定版本“Flask 1.0”，这是一个生产就绪的版本，包含了几个新的特性和更新。</p><p id="9fa8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="ke">优点</em> </strong> — Flask提供了极度的简单性、灵活性和细粒度的控制。它实现了最基本的东西，并把多余的东西留给了附加组件或开发人员。路由URL很简单。所需的<a class="ae li" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>连接可以显式同步。它更容易学习和实现，因此对于那些渴望开始web开发之旅的人来说是一个很好的起点。</p><p id="d065" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="ke">缺点</em> </strong> —非异步。缺少数据库和ORM(对象关系映射——这是一种编程技术，其中使用元数据描述符将对象代码连接到关系数据库)。</p><p id="7710" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt lj translated">最后，Flask是所有web程序员从头开始构建极简web应用程序的最佳选择。使用Flask的另一个优势是，你可以轻松地将机器学习算法(基于Python)集成到函数中，这使得你的应用程序更加智能和具有认知能力。</p><h2 id="0600" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated"><strong class="ak">你能用烧瓶做什么？</strong></h2><p id="f251" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">从博客应用到克隆facebook/twitter，Flask中几乎一切皆有可能。有很多像flask-sockets，flask-google-maps等库。您可以在应用程序中嵌入一些特性。Flask支持MySQL、Postgresql、MongoDB和其他一些数据库，我们需要根据用例选择最合适的数据库。</p><p id="7f9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="ke">这里有几个你可以用Flask搭建的网站模型:</em> </strong></p><p id="4d25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">博客应用，聊天应用，数据可视化，仪表盘，REST应用，管理页面，电子邮件服务。</p><h1 id="e377" class="ls kj hu bd kk lt lu lv ko lw lx ly ks lz ma mb kv mc md me ky mf mg mh lb mi dt translated">开始使用Flask 1.0</h1><p id="d138" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated"><strong class="it hv"> <em class="ke">先决条件</em> </strong>:在开始使用flask之前，你应该对Python有所了解，如果你正在学习Python，请参考<a class="ae li" href="https://towardsdatascience.com/python-programming-in-15-min-part-1-3ad2d773834c" rel="noopener" target="_blank">这篇关于Python的</a>文章或文档<a class="ae li" href="https://docs.python.org/3/" rel="noopener ugc nofollow" target="_blank">这里</a>。在电脑上安装Python &gt; =3，配置PIP (Python包索引)。</p><h2 id="b95f" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">安装烧瓶</h2><p id="957f" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">要安装flask，你需要做的只是在你的命令提示符下运行这个命令，如果你使用的是windows，终端，如果你使用的是MacOS或Linux。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="4dc8" class="ki kj hu mk b fv mo mp l mq mr">$ pip install flask</span></pre><p id="3501" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下软件包也将使用该命令安装:Werkzeug、Jinja、MarkupSafe、ItsDangerous、Click，它们是运行应用程序所必需的。我们现在不用担心这个，弗拉斯克会在后面处理的。</p><h2 id="525d" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">写出第一个传统节目“你好，世界！”</h2><p id="6179" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">要启动我们的第一个flask“Hello World”应用程序，需要遵循以下几个步骤。创建一个新的app.py文件，并按照相应的步骤操作。</p><ol class=""><li id="1168" class="ms mt hu it b iu iv iy iz jc mu jg mv jk mw jo mx my mz na dt translated">首先，我们需要从我们之前安装的flask模块中导入Flask类，这个Flask类将包含我们在编写应用程序时使用的所有方法和属性，所以这将是我们程序中的第一行。</li></ol><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="afbe" class="ki kj hu mk b fv mo mp l mq mr">from flask import Flask</span></pre><p id="d98a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.其次，我们需要声明一个包含flask对象的变量。这个变量将用于运行和配置我们的应用程序。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="ca12" class="ki kj hu mk b fv mo mp l mq mr">app = Flask(__name__)</span></pre><blockquote class="kb kc kd"><p id="c514" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">“__name__”是Python中的一个特殊变量。如果源文件作为主程序执行，解释器将__name__变量设置为值“__main__”。如果该文件是从另一个模块导入的，__name__将被设置为该模块的名称。</p></blockquote><p id="b9be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.写主函数。</p><p id="4bf8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的主函数中，我们需要运行flask变量，为此我们需要使用我们之前声明的app变量，并对它使用run方法。这个run方法在您的机器上启动一个本地服务器。通常，默认地址是“localhost:5000”要更改端口地址，我们可以向run方法传递一个参数，将它分配给任何所需的端口号。每当我们更改应用程序中的代码时，我们都需要重新启动我们的服务器，为了克服这一点，我们可以使用给定的调试参数来运行方法，并将其设置为“True”。现在，只要对源代码做了任何更改，服务器就会自动重启。调试器还用于跟踪错误(如果有的话)。下面是main函数的代码片段。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="e767" class="ki kj hu mk b fv mo mp l mq mr">if __name__ =="__main__":<br/>    app.run(debug=True, port=8080)</span></pre><p id="5a0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.按指定路线发送</p><p id="d596" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们使用app变量上的<strong class="it hv"> route() decorator </strong>来告诉Flask哪个URL应该触发我们的函数。所需的URL模式应该以字符串的形式写入路由装饰器。应该由路由触发的功能将在它下面声明。下面是如何声明路由的代码片段。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="a755" class="ki kj hu mk b fv mo mp l mq mr">@app.route('/')<br/>def hello_world():<br/>    return 'Hello, World!'</span></pre><blockquote class="kb kc kd"><p id="1c6d" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">“/”是主路径，只要您运行服务器，它就会首先触发。</p></blockquote><p id="d517" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">5.运行烧瓶应用程序。</p><p id="8a5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦上述所有步骤完成，现在我们的源代码看起来像这样。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="dfaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行flask应用程序类似于执行python程序。一旦服务器开始运行，您可以看到以下信息。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="191e" class="ki kj hu mk b fv mo mp l mq mr">$ python app.py</span><span id="ec58" class="ki kj hu mk b fv nd mp l mq mr">* Serving Flask app "app" (lazy loading)<br/>* Environment: production<br/>* Debug mode: on<br/>* Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)<br/>* Restarting with stat<br/>* Debugger is active!<br/>* Debugger PIN: 770-937-705</span></pre><p id="f81f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，打开你的网页浏览器，点击网址:<em class="ke"> http://127.0.0.1:8080/ </em>你可以看到“Hello World！”印在那里。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ne"><img src="../Images/ebf9ccd479b5da389a2e802af1fdf181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yH30E28cDBJ6tYaeb_0JCg.png"/></div></div></figure><h1 id="7be0" class="ls kj hu bd kk lt lu lv ko lw lx ly ks lz ma mb kv mc md me ky mf mg mh lb mi dt translated"><strong class="ak">烧瓶模板(金贾2) </strong></h1><p id="ffca" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">那么，如何在Flask应用程序中插入普通的HTML代码呢？</p><p id="307c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们创建了一个包含用户名和年龄的字典，稍后在HTML代码中提取这些值。</p><p id="87ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解释模板的代码片段。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="4149" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这给出了输出:你好，John！，你已经20岁了。</p><p id="8fb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ke">http://127 . 0 . 0 . 1:8080/greet</em></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nf"><img src="../Images/2a8fe39f3d791edb252592ecc47c7f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhjbdRQFAEc5u5-mixT26A.png"/></div></div></figure><p id="2546" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果HTML代码必须定期更改，这是非常麻烦的。因此，它不是真正可行和可扩展的。如果把逻辑部分从表现中分离出来会更好。因此，Flask会自动为我们配置Jinja2模板引擎。我们可以使用render_template()函数插入HTML文件，而不是将HTML硬编码到Flask中。</p><p id="90a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">放置HTML文件时必须遵循的层次结构。py文件被放在名为“Apps”的模块中</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="9f91" class="ki kj hu mk b fv mo mp l mq mr">Apps folder<br/>/app.py<br/>templates<br/>   |-/index.html</span></pre><p id="a539" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，创建一个名为templates的文件夹，并将HTML文件添加到其中。</p><p id="7bf4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">视图/函数必须返回render_template()和应该呈现的html页面的名称。下面是代码片段，你如何从视图渲染模板。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="1b82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在HTML页面中，我们呈现传递的模板，变量名也在HTML页面上返回。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="a2f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ke">http://127 . 0 . 0 . 1:8080/hello/亚历克斯</em></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ng"><img src="../Images/aa10df4bc9610a676a3e937348f5f7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPCpjg9h3JLebeACOVmptQ.png"/></div></div></figure><p id="44bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码片段清楚地解释了如何插入由条件语句组成的HTML文件，在本例中为‘if’。{{ }}表示变量的占位符。</p><p id="7aa3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">{% %}是用于插入控制语句的容器。</p><h1 id="dc84" class="ls kj hu bd kk lt lu lv ko lw lx ly ks lz ma mb kv mc md me ky mf mg mh lb mi dt translated"><strong class="ak">烧瓶的形式和要求。</strong></h1><p id="98c0" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">表单是每个web应用程序的构建块，使用这些表单，我们接受几个类别的输入，如用户名表单和电子邮件表单。这些帮助我们接收来自用户/客户的信息，并将它们存储到数据库中。</p><p id="b8da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们创建一个简单的生物数据表单，它在Flask中接受一些输入，如姓名、年龄、电子邮件和爱好，并将其呈现在HTML页面上。表单的HTML代码如下——“bio _ form . HTML”。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="42fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们使用请求库从表单输入字段中检索提交的数据。首先，我们需要知道请求-响应在互联网上是如何工作的。每当一个表单被提交时，它都在POST方法下，它被请求将所有的页面加载到互联网上。我们需要创建一个视图来请求表单中的信息。表单一提交，视图就与POST方法进行比较，并从输入标签中请求数据。表单的索引应该等于输入标记的name属性。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="3045" class="ki kj hu mk b fv mo mp l mq mr">--HTML--<br/>&lt;input type="text" name="username" placeholder="Your Name"/&gt;</span><span id="643d" class="ki kj hu mk b fv nd mp l mq mr">--Python--<br/>if request.method == "POST":<br/>    username = request.form['username']</span></pre><p id="f5b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在对于上面的HTML表单，让我们声明一个视图bio_data_form()来将输入存储到Python变量中。— <em class="ke">该视图呈现了上面的“bio _ form . html”</em></p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="7e88" class="ki kj hu mk b fv mo mp l mq mr">@app.route('/form', methods=['POST', 'GET'])<br/>def bio_data_form():    <br/>    if request.method == "POST":<br/>        username = request.form['username']        <br/>        age = request.form['age']        <br/>        email = request.form['email']        <br/>        hobbies = request.form['hobbies']        <br/>        return redirect(url_for('showbio',                              <br/>                                username=username,<br/>                                age=age,<br/>                                email=email,   <br/>                                hobbies=hobbies))    <br/>    return render_template("bio_form.html")</span></pre><p id="1a12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦表单中的所有变量被请求，这些变量将被发送到'<strong class="it hv"> showbio </strong>'视图，以便在HTML页面中呈现信息。我们使用“url_for”重定向到视图。因此，只要请求方法是POST，表单就被提交，数据以参数的形式被发送，这些参数从url获取并呈现在"<strong class="it hv"> show_bio.html </strong>"上</p><p id="5ac2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ke">论点是这样提交的:</em><a class="ae li" href="http://127.0.0.1:8080/showbio?username=Stark&amp;email=stark07%40gmail.com&amp;hobbies=Play%2C+Code" rel="noopener ugc nofollow" target="_blank"><em class="ke">http://127 . 0 . 0 . 1:8080/showbiousername = Stark&amp;email = Stark 07% 40 Gmail . com&amp;业余爱好=Play%2C+Code </em> </a></p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="4414" class="ki kj hu mk b fv mo mp l mq mr">@app.route('/showbio', methods=['GET'])<br/>def showbio():    <br/>    username = request.args.get('username')    <br/>    age = request.args.get('age')    <br/>    email = request.args.get('email')    <br/>    hobbies = request.args.get('hobbies')    <br/>    return render_template("show_bio.html",<br/>                           username=username,                         <br/>                           age=age,                          <br/>                           email=email,                         <br/>                           hobbies=hobbies)</span></pre><p id="9e18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦添加了这两个视图，您的源代码应该是这样的，</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="ed64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用Jinja 2在HTML页面上呈现这些变量，确保这个函数返回获取的变量。如果函数不返回变量，它们就不会呈现在HTML页面上。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="b00f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行您的应用程序，并访问:<a class="ae li" href="http://127.0.0.1:8080/form" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/form</a></p><h1 id="2c64" class="ls kj hu bd kk lt lu lv ko lw lx ly ks lz ma mb kv mc md me ky mf mg mh lb mi dt translated">使用<strong class="ak"> Flask-SQLAlchemy </strong>整合Flask和Postgres(数据库)</h1><p id="8646" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">Flask不能直接连接到数据库，所以我们需要一个媒介来连接它们。我们使用的媒介称为ORM(对象关系映射器)。</p><p id="5f64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们将探讨Flask-SQLAlchemy，它是一个扩展，为流行的<a class="ae li" href="http://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>包提供了一个Flask友好的包装器，这是一个ORM。这允许应用程序使用高级实体(如类、对象和方法)而不是表和SQL来管理数据库。ORM的工作是将高级操作翻译成数据库命令。SQLAlchemy支持一长串数据库引擎，包括流行的MySQL、PostgreSQL和SQLite。</p><p id="1318" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要使用SQLAlchemy和PostgreSQL配置您的应用程序，请执行以下步骤:</p><ol class=""><li id="1b2a" class="ms mt hu it b iu iv iy iz jc mu jg mv jk mw jo mx my mz na dt translated"><strong class="it hv">在你的机器上安装Flask-SQLAlchemy和PostgresQL。</strong></li></ol><p id="27cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用pip安装Flask-SQlAlchemy。在终端或命令提示符下运行以下命令来安装Flask-SQLAlchemy。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="7954" class="ki kj hu mk b fv mo mp l mq mr">$ pip install flask-sqlalchemy</span></pre><p id="d680" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要在MAC上安装PostgreSQL，请使用自制软件</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="01dc" class="ki kj hu mk b fv mo mp l mq mr">brew install postgres</span></pre><p id="3e85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者下载Postgres申请—【https://postgresapp.com/ T4】</p><p id="e06e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在windows中你需要下载并安装Postgres，这里是下载Postgres的链接—<a class="ae li" href="https://www.postgresql.org/download/windows/" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/download/windows/</a></p><p id="84bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2。创建数据库</strong></p><p id="ffa9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">安装并运行Postgres后，创建一个名为“appdb”的数据库，用作我们的本地开发数据库:</p><p id="2397" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在您的终端或命令提示符下，使用以下命令创建Postgres数据库。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="3d13" class="ki kj hu mk b fv mo mp l mq mr">$ createdb appdb</span></pre><p id="87b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个命令在您的本地机器上创建一个Postgres数据库。如果出现任何错误，请尝试重新安装Postgres。</p><p id="eacb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 3。更新应用程序设置。</strong></p><p id="96c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过设置app.config变量，用所有SQlAlchemy和Postgres配置您的源代码。</p><p id="1e1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们需要使用SQLAlchemy作为媒介将我们的应用程序与这个数据库链接起来。在我们的源代码中，将SQLALCHEMY_DATABASE_URI字段添加到app.config中，并声明一个名为db的新变量，该变量是使用SQLALCHEMY对象创建的，在本例中是通过将其传递给名为app的应用程序来创建的。然后，该对象包含来自sqlalchemy和sqlalchemy.orm的所有函数和帮助程序。此外，它还提供了一个名为Model的类，该类是一个声明性基础，可用于声明模型。</p><p id="619d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是配置SQlAlchemy和Postgres的代码。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="5724" class="ki kj hu mk b fv mo mp l mq mr">app.config['DEBUG'] = True<br/>app.config['SQLALCHEMY_DATABASE_URI']='postgresql://localhost/appdb'<br/>SQLALCHEMY_TRACK_MODIFICATIONS = True<br/>db = SQLAlchemy(app)</span></pre><p id="74ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更新app.py后，它应该是这样的，</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="a8b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这三个步骤，将让你连接你的应用程序与Postgres数据库。</p><p id="23d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们创建我们的第一个M <strong class="it hv">模型</strong>。所有模型的基类都称为db.Model，它存储在我们要创建的SQLAlchemy实例中。使用Column定义列。列的名称是您为其指定的名称。</p><p id="3358" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是在flask中声明模型的代码片段。这类似于我们在Python中创建类的方式。在这里，我们声明了一个Post模型，它有三个属性id(primary_key)、文章标题和文章描述(post_text)。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="405f" class="ki kj hu mk b fv mo mp l mq mr">class Post(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    title = db.Column(db.String(80), unique=True)<br/>    post_text = db.Column(db.String(255))<br/>    <br/>    def __init__(self, title, post_text):<br/>        self.title = title<br/>        self.post_text = post_text</span></pre><p id="2c93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将您的模型添加到源代码中。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><h2 id="9ba0" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">烧瓶迁移</h2><p id="1f9e" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">为了跟上现有的修改和应用程序不断变化的需求，必须对数据库进行下一次迁移。必须使用的第二个扩展是Flask-Migrate。这个扩展是一个用于SQLAlchemy的数据库迁移框架<a class="ae li" href="https://bitbucket.org/zzzeek/alembic" rel="noopener ugc nofollow" target="_blank"> Alembic </a>的Flask包装器。</p><p id="235d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用PIP安装flask迁移和flask脚本(具有激活管理器命令的管理器类)包。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="7b6c" class="ki kj hu mk b fv mo mp l mq mr">$ pip install flask-migrate<br/>$ pip install flask_script</span></pre><p id="436b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要在我们的应用程序中设置迁移，我们需要在应用程序中定义Migrate类作为我们的基本实例。在源文件中添加以下行来配置迁移。</p><p id="2655" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先将flask迁移和管理器类导入到源代码中。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="4bb6" class="ki kj hu mk b fv mo mp l mq mr">from flask_script import Manager<br/>from flask_migrate import Migrate, MigrateCommand</span></pre><p id="15eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，使用迁移配置应用程序设置。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="4774" class="ki kj hu mk b fv mo mp l mq mr">migrate = Migrate(app, db)<br/>manager = Manager(app)<br/>manager.add_command('db', MigrateCommand)</span></pre><p id="0a48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了详细说明这一点，我们设置我们的配置来获取我们的场景——基于环境变量——创建一个migrate实例，使用app和db作为参数，并设置一个manager命令来初始化我们的应用程序的Manager实例。最后，我们向管理器添加了db命令，以便我们可以从命令行运行迁移。</p><p id="483a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，由于我们的管理器应用程序有整个应用程序和数据库实例，我们需要运行替换的应用程序变量，它是主函数中的管理器变量。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="e883" class="ki kj hu mk b fv mo mp l mq mr">if __name__ == '__main__':<br/>    manager.run()</span></pre><p id="959c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，配置的源代码(app.py)将如下所示:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="4241" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了运行迁移来初始化Alembic，请使用以下命令。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="e7f3" class="ki kj hu mk b fv mo mp l mq mr">$ python app.py db init<br/>Creating directory /Users/Vihar/Desktop/flask-databases/migrations ... done<br/>...<br/>...<br/>...<br/>Generating /Users/Vihar/Desktop/flask-databases/migrations/alembic.ini ... done</span></pre><p id="099d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行该命令后，管理器会提供上述信息，说明迁移已成功创建。运行数据库初始化后，您将在项目中看到一个名为“migrations”的新文件夹。</p><p id="cce2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过运行migrate命令进行第一次迁移。使用以下命令在数据库中更新和创建表。</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="5fb2" class="ki kj hu mk b fv mo mp l mq mr">$ python app.py db migrate<br/>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.<br/>INFO  [alembic.runtime.migration] Will assume transactional DDL.<br/>INFO  [alembic.autogenerate.compare] Detected added table 'post'</span><span id="d8ce" class="ki kj hu mk b fv nd mp l mq mr">Generating /Users/Vihar/Desktop/flask-databases/migrations/versions/ed3b3a028447_.py ... done</span></pre><p id="7be9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用此命令，如果没有表，现在将创建表，如果有表，则修改表。</p><p id="bea1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将使用<code class="eh nh ni nj mk b">db upgrade</code>命令对数据库进行升级:</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="249c" class="ki kj hu mk b fv mo mp l mq mr">$ python app.py db upgrade</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nk"><img src="../Images/e7c955a9003582d9106e734892231c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pivCBHufwrveAftQnJ1aAQ.png"/></div></div></figure><p id="400a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，您可以看到从Postgres shell向appdb中添加了两行。</p><h2 id="1746" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">Flask-Postgres最小博客。</h2><p id="4e26" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们可以使用Flask-WTF Extension将表单中的信息添加到数据库中，它是WTForms包的包装器。当使用WTForms时，我们必须首先将表单定义为类。因此，要使用PIP安装Flask-WTF，命令是</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="95d4" class="ki kj hu mk b fv mo mp l mq mr">$ pip install flask-wtf</span></pre><p id="499c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你的表单类应该包含所有的字段，对于上面的Post模型，这是我们声明表单类的方式</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="3d68" class="ki kj hu mk b fv mo mp l mq mr">class Post(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    title = db.Column(db.String(80), unique=True)<br/>    post_text = db.Column(db.String(255))</span><span id="d542" class="ki kj hu mk b fv nd mp l mq mr">    def __init__(self, title, post_text):<br/>        self.title = title<br/>        self.post_text = post_text</span><span id="3877" class="ki kj hu mk b fv nd mp l mq mr"># Declaring Flask WTF-Form</span><span id="ce81" class="ki kj hu mk b fv nd mp l mq mr">class PostForm(FlaskForm):<br/>    title = StringField('Title', validators=[DataRequired()])<br/>    post_text = StringField('Post_Text',                            <br/>                             validators=[DataRequired()]<br/>                           )</span></pre><p id="7111" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要声明一个视图，它将所有的表单值发送到HTML模板。</p><p id="c552" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下面的代码片段中，我们在“/add post”route下声明了一个新视图“add_post”。</p><p id="8068" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个视图中，我们呈现了“post_form.html ”,它有表单输入字段。现在在视图中，首先我们需要创建一个PostForm的新实例，这样每当页面刷新或重新加载时，都会创建一个新实例。</p><p id="e2dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们使用Flask请求从表单中获取信息。每当从web页面提交内容时，它都属于POST请求方法。在这个视图中，最初是GET呈现post_form.html，后来当我们提交PostForm时，它将调用post方法，从而从表单中收集数据。</p><p id="e79d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们将数据发布到页面，就应该为信息创建一个会话，以便将数据添加到数据库中。我们使用db.session.add()将数据添加到会话中，使用db.session.commit()将数据推送到数据库中。因此，add_post视图被定义为</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="47bc" class="ki kj hu mk b fv mo mp l mq mr">@app.route('/addpost', methods=['GET', 'POST'])<br/>def add_post():<br/>    postform = PostForm()<br/>        if request.method == 'POST':<br/>            pf = Post(<br/>                postform.title.data,<br/>                postform.post_text.data,<br/>            )<br/>            db.session.add(pf)<br/>            db.session.commit()<br/>        return redirect(url_for('view_posts'))<br/>    return render_template('post_form.html', postform = postform)</span></pre><p id="abb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要将flask-wtf表单呈现到HTML上，我们需要使用postform变量调用，从而将这些作为参数传递给模型post，该模型Post将返回到“post_form.html”</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="c1d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">表单提交到数据库后，我们将页面重定向到view_posts，在这里我们查询所有的帖子并呈现在模板上。下面是“view_posts”的代码片段</p><pre class="jq jr js jt fq mj mk ml mm aw mn dt"><span id="e036" class="ki kj hu mk b fv mo mp l mq mr">@app.route('/posts', methods=['GET', 'POST'])<br/>def view_posts():<br/>    posts = Post.query.all()<br/>    return render_template('view_posts.html', posts=posts)</span></pre><p id="a209" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有的文章都在view_posts中查询并返回view_post.html，并使用jinja循环在html页面中迭代。下面是view_post.html的代码片段，它解释了Jinja 2中的循环变量。</p><p id="ccd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于所有的帖子都是从view_posts返回并呈现在view_posts上的，所以我们遍历一个循环并呈现在HTML上。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="4c82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整的源代码如下所示:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="cada" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">http://localhost:5000/addpost</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nl"><img src="../Images/7ccfc0897e0d5b42968ae78cf0652fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZhvZBO8SkOSNTZCrrngEQ.png"/></div></div></figure><p id="cc20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">http://localhost:5000/post</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nm"><img src="../Images/a3af1f03e4bbae9d526598f5dc7b9af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxTepLVr0JyqFsZTy83hFw.png"/></div></div></figure><p id="6328" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这解释了博客应用程序的最小工作，所有的前端部分可以直接添加到HTML文件中。</p><p id="938b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">祝贺您学习Flask 1.0，有了它，您将能够创建无缝和智能的web应用程序。</p><p id="45ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章的源代码可以在这里找到。</p></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><p id="9a04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读。如果你觉得这个故事有帮助，请点击下面的👏去传播爱。</p><p id="a193" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文由<a class="nu nv gr" href="https://medium.com/u/4ce24554e1d2?source=post_page-----9ada8088fde1--------------------------------" rel="noopener" target="_blank">维哈尔·鞍马</a>和<a class="nu nv gr" href="https://medium.com/u/7e65fabdea53?source=post_page-----9ada8088fde1--------------------------------" rel="noopener" target="_blank">萨姆希塔·阿拉</a>撰写。</p><p id="3b4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请继续关注关于Flask的更多文章。</p><p id="8889" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重要链接:</p><div class="nw nx fm fo ny nz"><a href="https://towardsdatascience.com/python-programming-in-15-min-part-1-3ad2d773834c" rel="noopener follow" target="_blank"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hv fv z el oe eo ep of er et ht dt translated">15分钟Python编程第1部分</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">关于Python</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on jz nz"/></div></div></a></div><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="oo nc l"/></div></figure></div></div>    
</body>
</html>