<html>
<head>
<title>Build a floating hearts effect in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中建立一个浮动的心效果</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-floating-hearts-effect-in-swift-b760fdee6fe9?source=collection_archive---------9-----------------------#2018-05-24">https://medium.com/hackernoon/build-a-floating-hearts-effect-in-swift-b760fdee6fe9?source=collection_archive---------9-----------------------#2018-05-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><blockquote class="iy iz ja"><p id="9e4a" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">遵循本教程需要对Swift和Node.js有基本的了解。</p></blockquote><p id="68ea" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">如果你是Periscope、Instagram和脸书等应用程序的用户，那么你可能已经注意到他们的直播流中有一个功能，每当有人喜欢直播内容时，“喜欢”就会浮在你的屏幕上。本文将向您展示如何使用Swift和Pusher在您的iOS应用程序上实现实时浮动心形功能。</p><p id="b590" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">下面是我们在本教程中使用Swift和Pusher将实现的内容的屏幕记录。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff kd"><img src="../Images/6da560524fe9069ed75052bc2140077a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cB9sGLREEJOZCBf_.gif"/></div></div></figure><p id="eec7" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">从录音中，你可以看到当点击喜欢按钮时，喜欢会浮到顶部，并且它们也会复制到另一个观看正在播放的视频的设备上。</p><p id="0818" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在，让我们开始旅程。</p><h1 id="4b15" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">要求</h1><p id="1381" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">按照本教程，你需要以下东西:</p><ul class=""><li id="9842" class="ls lt hu je b jf jg jj jk ka lu kb lv kc lw jz lx ly lz ma dt translated">了解Swift和Xcode故事板。</li><li id="5099" class="ls lt hu je b jf mb jj mc ka md kb me kc mf jz lx ly lz ma dt translated">Xcode安装在您的机器上。</li><li id="2600" class="ls lt hu je b jf mb jj mc ka md kb me kc mf jz lx ly lz ma dt translated">推送应用程序—您可以在此创建一个免费的推送账户<a class="ae mg" href="https://pusher.com" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="40aa" class="ls lt hu je b jf mb jj mc ka md kb me kc mf jz lx ly lz ma dt translated">Node.js和NPM安装在你的机器上。</li><li id="db24" class="ls lt hu je b jf mb jj mc ka md kb me kc mf jz lx ly lz ma dt translated">安装在机器上的Cocoapods使用Ruby通过运行:<code class="eh mh mi mj mk b">gem install cocoapods</code>来安装它。</li></ul><p id="3923" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">希望你已经检查了所有的需求。让我们开始吧。</p><h1 id="c8c1" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">在Xcode中创建浮动心形应用程序</h1><p id="7f9f" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">启动Xcode，在那里创建一个新项目。我们打算把这个应用叫做<strong class="je hv"> streamlove </strong>(是的，我们知道它很蹩脚)。完成初始设置后，关闭Xcode并启动终端。<code class="eh mh mi mj mk b">cd</code>到你的应用程序的根目录并运行<code class="eh mh mi mj mk b">pod init</code>。这将在根目录中创建一个<code class="eh mh mi mj mk b">Podfile</code>。在文本编辑器中打开它，并用以下代码替换其中的代码:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="b056" class="mp kq hu mk b fv mq mr l ms mt">platform :ios, '9.0'<br/>    target 'streamlove' do<br/>      use_frameworks!<br/>      pod 'PusherSwift', '~&gt; 4.0'<br/>      pod 'Alamofire', '~&gt; 4.4'<br/>    end</span></pre><p id="334f" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">之后保存并关闭文件，运行<code class="eh mh mi mj mk b">pod install</code>命令。这将开始安装我们正在创建的应用程序所需的所有依赖项。现在在Xcode中打开<code class="eh mh mi mj mk b">streamlove.xcworkspace</code>文件。</p><p id="ea46" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">我们需要做的下一件事是设计我们的应用程序故事板。打开<code class="eh mh mi mj mk b">Main.storyboard</code>文件。我们将添加一些模拟视图，因为我们真的不想在它们上面实现任何东西，它们只是为了美观。我们主要关注的是按钮和背景视频。在设计好我们的故事板之后，这是我们希望得到的:</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff mu"><img src="../Images/2eb80a5c1448c22ec259d16b23e97b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q0kSGjqLghpV3Epy.png"/></div></div></figure><p id="6a01" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">在这个故事板中，我们在屏幕的右下角有一个按钮，这个按钮在<code class="eh mh mi mj mk b">ViewController</code>中有一个<code class="eh mh mi mj mk b">@IBAction</code>，所以你需要<code class="eh mh mi mj mk b">ctrl+drag</code>来建立按钮和<code class="eh mh mi mj mk b">ViewController</code>之间的连接。</p><p id="32e2" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">这应该会将<code class="eh mh mi mj mk b">@IBAction</code>添加到<code class="eh mh mi mj mk b">ViewController</code>中，如下所示:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="9ab0" class="mp kq hu mk b fv mq mr l ms mt">@IBAction func hearted(_ sender: Any) {<br/>        // This function will be fired every time the button is tapped!<br/>    }</span></pre><h1 id="55b0" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">使用Swift在iOS中创建背景循环视频</h1><p id="6de6" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">接下来，我们将创建模拟实时流的视频背景(因为创建实际的实时流超出了本文的范围)。打开<code class="eh mh mi mj mk b">ViewController</code>文件并粘贴以下内容:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="8de2" class="mp kq hu mk b fv mq mr l ms mt">import UIKit<br/>    import PusherSwift<br/>    import Alamofire</span><span id="c650" class="mp kq hu mk b fv mv mr l ms mt">    class ViewController: VideoSplashViewController {</span><span id="0d24" class="mp kq hu mk b fv mv mr l ms mt">        override func viewDidLoad() {<br/>            super.viewDidLoad()<br/>            loadVideoStreamSample()<br/>        }</span><span id="5424" class="mp kq hu mk b fv mv mr l ms mt">        private func loadVideoStreamSample() {<br/>            let url = NSURL.fileURL(withPath: Bundle.main.path(forResource: "video", ofType: "mp4")!)<br/>            self.videoFrame = view.frame<br/>            self.fillMode = .resizeAspectFill<br/>            self.alwaysRepeat = true<br/>            self.sound = true<br/>            self.startTime = 0.0<br/>            self.duration = 10.0<br/>            self.alpha = 0.7<br/>            self.backgroundColor = UIColor.black<br/>            self.contentURL = url<br/>            self.restartForeground = true<br/>        }</span><span id="8300" class="mp kq hu mk b fv mv mr l ms mt">        override var prefersStatusBarHidden: Bool {<br/>            return true<br/>        }  </span><span id="0a31" class="mp kq hu mk b fv mv mr l ms mt">        @IBAction func hearted(_ sender: Any) {<br/>            // This function will be called everytime the button is tapped!<br/>        }<br/>    }</span></pre><p id="b455" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">在第一行，我们已经导入了我们需要的库，但是大部分是在教程的后面。现在，让我们把注意力集中在其他人身上。<code class="eh mh mi mj mk b">ViewController</code>扩展了一个我们还没有创建的<code class="eh mh mi mj mk b">VideoSplashViewController</code>。在<code class="eh mh mi mj mk b">viewDidLoad</code>方法中，我们调用了一个方法<code class="eh mh mi mj mk b">loadVideoStreamSample</code>，在这个方法中，我们基本上是加载一个视频并为视频设置一些参数。这些参数将在<code class="eh mh mi mj mk b">VideoSplashViewController</code>中实现。</p><p id="4c4f" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在对于<code class="eh mh mi mj mk b">VideoSplashViewController</code>，我们将使用Github 上的<a class="ae mg" href="https://github.com/svtek/VideoSplashKit/" rel="noopener ugc nofollow" target="_blank">Swift库。然而，由于该库不支持Swift 3，我们将挑选出我们需要的文件，并将其转换为支持Swift 3。第一个是</a><a class="ae mg" href="https://github.com/svtek/VideoSplashKit/blob/master/VideoSplashKit/Source/VideoSplashViewController.swift" rel="noopener ugc nofollow" target="_blank">videossplashviewcontroller</a>。创建一个扩展<code class="eh mh mi mj mk b">UIViewController</code>的新文件<code class="eh mh mi mj mk b">VideoSplashViewController</code>，并在其中粘贴以下内容:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="05cf" class="mp kq hu mk b fv mq mr l ms mt">import UIKit<br/>    import MediaPlayer<br/>    import AVKit</span><span id="23a4" class="mp kq hu mk b fv mv mr l ms mt">    public enum ScalingMode {<br/>        case resize<br/>        case resizeAspect<br/>        case resizeAspectFill<br/>    }</span><span id="b680" class="mp kq hu mk b fv mv mr l ms mt">    public class VideoSplashViewController: UIViewController {</span><span id="b110" class="mp kq hu mk b fv mv mr l ms mt">        private let moviePlayer = AVPlayerViewController()<br/>        private var moviePlayerSoundLevel: Float = 1.0</span><span id="c92a" class="mp kq hu mk b fv mv mr l ms mt">        public var videoFrame: CGRect = CGRect()<br/>        public var startTime: CGFloat = 0.0<br/>        public var duration: CGFloat = 0.0<br/>        public var backgroundColor = UIColor.black { didSet { view.backgroundColor = backgroundColor } }<br/>        public var contentURL: URL = URL(fileURLWithPath: "") { didSet { setMoviePlayer(url: contentURL) } }<br/>        public var sound: Bool = true { didSet { moviePlayerSoundLevel = sound ? 1 : 0 } }<br/>        public var alpha: CGFloat = 1 { didSet { moviePlayer.view.alpha = alpha } }</span><span id="8c86" class="mp kq hu mk b fv mv mr l ms mt">        public var alwaysRepeat: Bool = true {</span><span id="d84d" class="mp kq hu mk b fv mv mr l ms mt">            didSet {</span><span id="5b69" class="mp kq hu mk b fv mv mr l ms mt">                if alwaysRepeat {<br/>                    NotificationCenter.default.addObserver(forName:.AVPlayerItemDidPlayToEndTime, object:nil, queue:nil) { [weak self] (notification) in<br/>                        self?.playerItemDidReachEnd()<br/>                    }<br/>                    return<br/>                }</span><span id="82ea" class="mp kq hu mk b fv mv mr l ms mt">                if !alwaysRepeat {<br/>                    NotificationCenter.default.removeObserver(self, name:.AVPlayerItemDidPlayToEndTime, object: nil)<br/>                }<br/>            }<br/>        }</span><span id="e9b7" class="mp kq hu mk b fv mv mr l ms mt">        public var fillMode: ScalingMode = .resizeAspectFill {<br/>            didSet {<br/>                switch fillMode {<br/>                case .resize:<br/>                    moviePlayer.videoGravity = AVLayerVideoGravityResize<br/>                case .resizeAspect:<br/>                    moviePlayer.videoGravity = AVLayerVideoGravityResizeAspect<br/>                case .resizeAspectFill:<br/>                    moviePlayer.videoGravity = AVLayerVideoGravityResizeAspectFill<br/>                }<br/>            }<br/>        }</span><span id="6469" class="mp kq hu mk b fv mv mr l ms mt">        public var restartForeground: Bool = false {<br/>            didSet {<br/>                if restartForeground {<br/>                    NotificationCenter.default.addObserver(forName:.UIApplicationWillEnterForeground, object:nil, queue:nil) { [weak self] (notification) in<br/>                        self?.playerItemDidReachEnd()<br/>                    }<br/>                }<br/>            }<br/>        }</span><span id="9fa2" class="mp kq hu mk b fv mv mr l ms mt">        override public func viewDidAppear(_ animated: Bool) {<br/>            super.viewDidAppear(animated)<br/>            moviePlayer.view.frame = videoFrame<br/>            moviePlayer.view.backgroundColor = self.backgroundColor;<br/>            moviePlayer.showsPlaybackControls = false<br/>            moviePlayer.view.isUserInteractionEnabled = false<br/>            view.addSubview(moviePlayer.view)<br/>            view.sendSubview(toBack: moviePlayer.view)<br/>        }</span><span id="235b" class="mp kq hu mk b fv mv mr l ms mt">        private func setMoviePlayer(url: URL){<br/>            let videoCutter = VideoCutter()<br/>            videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) { [weak self] (videoPath, error) -&gt; Void in<br/>                guard let path = videoPath, let strongSelf = self else { return }<br/>                strongSelf.moviePlayer.player = AVPlayer(url: path)<br/>                strongSelf.moviePlayer.player?.addObserver(strongSelf, forKeyPath: "status", options: .new, context: nil)<br/>                strongSelf.moviePlayer.player?.play()<br/>                strongSelf.moviePlayer.player?.volume = strongSelf.moviePlayerSoundLevel<br/>            }<br/>        }</span><span id="1ff4" class="mp kq hu mk b fv mv mr l ms mt">        public override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {</span><span id="c89a" class="mp kq hu mk b fv mv mr l ms mt">            guard let player = object as? AVPlayer else {<br/>                super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)<br/>                return<br/>            }</span><span id="1e31" class="mp kq hu mk b fv mv mr l ms mt">            if player.status == .readyToPlay {<br/>                movieReadyToPlay()<br/>            }<br/>        }</span><span id="5512" class="mp kq hu mk b fv mv mr l ms mt">        deinit{<br/>            moviePlayer.player?.removeObserver(self, forKeyPath: "status")<br/>            NotificationCenter.default.removeObserver(self)<br/>        }</span><span id="0b3a" class="mp kq hu mk b fv mv mr l ms mt">        // Override in subclass<br/>        public func movieReadyToPlay() { }</span><span id="b7c8" class="mp kq hu mk b fv mv mr l ms mt">        func playerItemDidReachEnd() {<br/>            moviePlayer.player?.seek(to: kCMTimeZero)<br/>            moviePlayer.player?.play()<br/>        }</span><span id="189c" class="mp kq hu mk b fv mv mr l ms mt">        func playVideo() {<br/>            moviePlayer.player?.play()<br/>        }</span><span id="c997" class="mp kq hu mk b fv mv mr l ms mt">        func pauseVideo() {<br/>            moviePlayer.player?.pause()<br/>        }<br/>    }</span></pre><p id="3b54" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在创建另一个名为<code class="eh mh mi mj mk b">VideoCutter</code>的文件，它扩展了<code class="eh mh mi mj mk b">NSObject</code>并粘贴以下内容:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="14b8" class="mp kq hu mk b fv mq mr l ms mt">import UIKit<br/>    import AVFoundation</span><span id="3236" class="mp kq hu mk b fv mv mr l ms mt">    extension String {<br/>        var convert: NSString { return (self as NSString) }<br/>    }</span><span id="8f23" class="mp kq hu mk b fv mv mr l ms mt">    public class VideoCutter: NSObject {</span><span id="0c0f" class="mp kq hu mk b fv mv mr l ms mt">        /**<br/>         Block based method for crop video url</span><span id="f99b" class="mp kq hu mk b fv mv mr l ms mt">         @param videoUrl Video url<br/>         @param startTime The starting point of the video segments<br/>         @param duration Total time, video length</span><span id="1dff" class="mp kq hu mk b fv mv mr l ms mt">         */<br/>        public func cropVideoWithUrl(videoUrl url: URL, startTime: CGFloat, duration: CGFloat, completion: ((_ videoPath:URL?, _ error: NSError?) -&gt; Void)?) {</span><span id="996d" class="mp kq hu mk b fv mv mr l ms mt">            DispatchQueue.global().async {</span><span id="78c3" class="mp kq hu mk b fv mv mr l ms mt">                let asset = AVURLAsset(url: url, options: nil)<br/>                var outputPath = NSHomeDirectory()<br/>                let documentPaths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)<br/>                if (documentPaths.count &gt; 0) {<br/>                    outputPath = documentPaths.first!<br/>                }<br/>                let fileManager = FileManager.default</span><span id="bb27" class="mp kq hu mk b fv mv mr l ms mt">                guard let exportSession = AVAssetExportSession(asset: asset, presetName: "AVAssetExportPresetHighestQuality") else { return }<br/>                let outputFilePath = outputPath.convert.appendingPathComponent("output.mp4")</span><span id="c107" class="mp kq hu mk b fv mv mr l ms mt">                if fileManager.fileExists(atPath: outputFilePath) {<br/>                    do {<br/>                        try fileManager.removeItem(atPath: outputFilePath)<br/>                    } catch let error {<br/>                        print(error)<br/>                    }<br/>                }</span><span id="f4bd" class="mp kq hu mk b fv mv mr l ms mt">                do {<br/>                    try fileManager.createDirectory(atPath:outputPath, withIntermediateDirectories: true, attributes: nil) }<br/>                catch let error {<br/>                    print(error)<br/>                }</span><span id="b7d9" class="mp kq hu mk b fv mv mr l ms mt">                let start = CMTimeMakeWithSeconds(Float64(startTime), 600)<br/>                let duration = CMTimeMakeWithSeconds(Float64(duration), 600)<br/>                let range = CMTimeRangeMake(start, duration)<br/>                let outputURL = URL(fileURLWithPath: outputFilePath)<br/>                exportSession.outputURL = outputURL<br/>                exportSession.timeRange = range<br/>                exportSession.shouldOptimizeForNetworkUse = true<br/>                exportSession.outputFileType = AVFileTypeMPEG4<br/>                exportSession.exportAsynchronously(completionHandler: {<br/>                    switch exportSession.status {<br/>                    case .completed:<br/>                        DispatchQueue.main.async { completion?(exportSession.outputURL, nil) }<br/>                    default:<br/>                        DispatchQueue.main.async { completion?(nil, nil) }<br/>                    }<br/>                })<br/>            }<br/>        }<br/>    }</span></pre><p id="7ba8" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">在上面我们刚刚创建的文件中，它基本上可以帮助你管理视频背景，并将你选择的视频设置为背景视频，并永远循环播放。这对于应用程序登录页面也很有用。然而，我们只是把它用于一个虚构的视频流。</p><blockquote class="iy iz ja"><p id="b910" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="hu">💡</em> </p></blockquote><p id="08b5" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在，我们需要做的最后一件事是向我们的工作区添加一个mp4文件。你可以使用任何你想使用的mp4文件。将视频文件<code class="eh mh mi mj mk b">video.mp4</code>放入工作区，并<strong class="je hv">确保其被复制</strong>并添加至应用目标。</p><p id="adfc" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">如果您现在构建并预览您的应用程序，您应该会看到视频在后台循环播放。太好了。</p><h1 id="01f5" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">向iOS应用程序添加浮动心形</h1><p id="60f8" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">现在我们已经有了背景中的视频循环，接下来我们要做的是为应用程序添加浮动心脏功能。基本上，每次有人点击心形按钮时，都会有一个心形图标浮到顶部，然后慢慢消失。</p><p id="48bb" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">打开<code class="eh mh mi mj mk b">Main.storyboard</code>文件，在心脏按钮的右下方，添加一个没有背景的视图。这将是浮动的心将旅行的视窗。可以做成250x350左右的长方形。</p><p id="2a13" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">接下来，我们将使用Github的另一个<a class="ae mg" href="https://github.com/ravenshore/iOS-Floaters" rel="noopener ugc nofollow" target="_blank">库</a>为应用程序添加浮动心形功能。我们实际需要的文件是<a class="ae mg" href="https://github.com/ravenshore/iOS-Floaters/blob/master/floaters/Floater.swift" rel="noopener ugc nofollow" target="_blank"> Floater.swift </a>文件。该库还没有任何软件包管理器来安装它，所以我们将复制该文件的内容，并将其添加到我们工作区的一个文件中。</p><p id="73c2" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">我们正在使用Swift 3构建，所以我们需要对该类进行一些修改，所以如果您使用Swift 3，请复制并粘贴下面的代码，如果您不使用，请按原样使用。创建一个新文件<code class="eh mh mi mj mk b">Floater.swift</code>并扩展<code class="eh mh mi mj mk b">UIView</code>对象。将此粘贴到课程中:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="0bdb" class="mp kq hu mk b fv mq mr l ms mt">import UIKit</span><span id="bed4" class="mp kq hu mk b fv mv mr l ms mt">    @IBDesignable public class Floater: UIView {</span><span id="6827" class="mp kq hu mk b fv mv mr l ms mt">        var image1: UIImage?<br/>        var image2: UIImage?<br/>        var image3: UIImage?<br/>        var image4: UIImage?</span><span id="8d70" class="mp kq hu mk b fv mv mr l ms mt">        var isAnimating: Bool = false<br/>        var views: [UIView]!<br/>        var duration: TimeInterval = 1.0<br/>        var duration1: TimeInterval = 2.0<br/>        var duration2: TimeInterval = 2.0<br/>        var floatieSize = CGSize(width: 50, height: 50)<br/>        var floatieDelay: Double = 10<br/>        var delay: Double = 10.0<br/>        var startingAlpha: CGFloat = 1.0<br/>        var endingAlpha: CGFloat = 0.0<br/>        var upwards: Bool = true<br/>        var remove: Bool = true</span><span id="f4dd" class="mp kq hu mk b fv mv mr l ms mt">        @IBInspectable var removeAtEnd: Bool = true {<br/>            didSet {<br/>                remove = removeAtEnd<br/>            }<br/>        }<br/>        @IBInspectable var FloatingUp: Bool = true {<br/>            didSet {<br/>                upwards = FloatingUp<br/>            }<br/>        }<br/>        @IBInspectable var alphaAtStart: CGFloat = 1.0 {<br/>            didSet {<br/>                startingAlpha = alphaAtStart<br/>            }<br/>        }<br/>        @IBInspectable var alphaAtEnd: CGFloat = 0.0 {<br/>            didSet {<br/>                endingAlpha = alphaAtEnd<br/>            }<br/>        }<br/>        @IBInspectable var rotationSpeed: Double = 10 {<br/>            didSet {<br/>                duration2 = 20 / rotationSpeed<br/>            }<br/>        }<br/>        @IBInspectable var density: Double = 10 {<br/>            didSet {<br/>                floatieDelay = 1 / density<br/>            }<br/>        }<br/>        @IBInspectable var delayedStart: Double = 10 {<br/>            didSet {<br/>                delay = delayedStart<br/>            }<br/>        }<br/>        @IBInspectable var speedY: CGFloat = 10 {<br/>            didSet {<br/>                duration = Double(10/speedY)<br/>            }<br/>        }<br/>        @IBInspectable var speedX: CGFloat = 5 {<br/>            didSet {<br/>                duration1 = Double(10/speedX)<br/>            }<br/>        }<br/>        @IBInspectable var floatieWidth: CGFloat = 50 {<br/>            didSet {<br/>                floatieSize.width = floatieWidth<br/>            }<br/>        }<br/>        @IBInspectable var floatieHeight: CGFloat = 50 {<br/>            didSet {<br/>                floatieSize.height = floatieHeight<br/>            }<br/>        }<br/>        @IBInspectable var borderColor: UIColor = UIColor.clear {<br/>            didSet {<br/>                layer.borderColor = borderColor.cgColor<br/>            }<br/>        }</span><span id="0721" class="mp kq hu mk b fv mv mr l ms mt">        @IBInspectable var borderWidth: CGFloat = 0 {<br/>            didSet {<br/>                layer.borderWidth = borderWidth<br/>            }<br/>        }</span><span id="e8c6" class="mp kq hu mk b fv mv mr l ms mt">        @IBInspectable var cornerRadius: CGFloat = 0 {<br/>            didSet {<br/>                layer.cornerRadius = cornerRadius<br/>            }<br/>        }</span><span id="e7c9" class="mp kq hu mk b fv mv mr l ms mt">        @IBInspectable var floaterImage1: UIImage? {<br/>            didSet {<br/>                image1 = floaterImage1<br/>            }<br/>        }<br/>        @IBInspectable var floaterImage2: UIImage? {<br/>            didSet {<br/>                image2 = floaterImage2<br/>            }<br/>        }<br/>        @IBInspectable var floaterImage3: UIImage? {<br/>            didSet {<br/>                image3 = floaterImage3<br/>            }<br/>        }<br/>        @IBInspectable var floaterImage4: UIImage? {<br/>            didSet {<br/>                image4 = floaterImage4<br/>            }<br/>        }</span><span id="6644" class="mp kq hu mk b fv mv mr l ms mt">        override public func awakeFromNib() {<br/>            super.awakeFromNib()<br/>        }</span><span id="6564" class="mp kq hu mk b fv mv mr l ms mt">        func startAnimation() {<br/>            print("Start Animating")<br/>            isAnimating = true<br/>            views = []<br/>            var imagesArray = [UIImage?]()<br/>            var actualImages = [UIImage]()<br/>            let frameW = self.frame.width<br/>            let frameH = self.frame.height<br/>            var startingPoint: CGFloat!<br/>            var endingPoint: CGFloat!<br/>            if upwards {<br/>                startingPoint = frameH<br/>                endingPoint = floatieHeight*2<br/>            } else {<br/>                startingPoint = 0<br/>                endingPoint = frameH - floatieHeight*2<br/>            }<br/>            imagesArray += [image1, image2, image3, image4]<br/>            if !imagesArray.isEmpty {<br/>                for i in imagesArray {<br/>                    if i != nil {<br/>                        actualImages.append(i!)<br/>                    }<br/>                }<br/>            }</span><span id="96eb" class="mp kq hu mk b fv mv mr l ms mt">            let deadlineTime = DispatchTime.now() + .seconds(Int(self.delay * Double(NSEC_PER_SEC)))</span><span id="4491" class="mp kq hu mk b fv mv mr l ms mt">            DispatchQueue.global().asyncAfter(deadline: deadlineTime, execute: {<br/>                var goToNext = true<br/>                while self.isAnimating {<br/>                    if goToNext {<br/>                        goToNext = false</span><span id="4bdf" class="mp kq hu mk b fv mv mr l ms mt">                        DispatchQueue.main.asyncAfter(deadline: .now()+0.3, execute: {<br/>                            let randomNumber = self.randomIntBetweenNumbers(firstNum:1, secondNum: 2)<br/>                            var randomRotation: CGFloat!<br/>                            if randomNumber == 1 {<br/>                                randomRotation = -1<br/>                            } else {<br/>                                randomRotation = 1<br/>                            }<br/>                            let randomX = self.randomFloatBetweenNumbers(firstNum: 0 + self.floatieSize.width/2, secondNum: self.frame.width - self.floatieSize.width/2)<br/>                            let floatieView = UIView(frame: CGRect(x: randomX, y: startingPoint, width: 50, height: 50))<br/>                            self.addSubview(floatieView)</span><span id="71a8" class="mp kq hu mk b fv mv mr l ms mt">                            let floatie = UIImageView(frame: CGRect(x: 0, y: 0, width: self.floatieSize.width, height: self.floatieSize.height))</span><span id="95ff" class="mp kq hu mk b fv mv mr l ms mt">                            if !actualImages.isEmpty {</span><span id="31ef" class="mp kq hu mk b fv mv mr l ms mt">                                let randomImageIndex = (self.randomIntBetweenNumbers(firstNum: 1, secondNum: actualImages.count) - 1 )<br/>                                floatie.image = actualImages[randomImageIndex]<br/>                                floatie.center = CGPoint(x: 0, y: 0)<br/>                                floatie.backgroundColor = UIColor.clear<br/>                                floatie.layer.zPosition = 10<br/>                                floatie.alpha = self.startingAlpha</span><span id="8072" class="mp kq hu mk b fv mv mr l ms mt">                                floatieView.addSubview(floatie)<br/>                                var xChange: CGFloat!<br/>                                if randomX &lt; self.frame.width/2 {<br/>                                    xChange = randomX + self.randomFloatBetweenNumbers(firstNum: randomX, secondNum: frameW-randomX)<br/>                                } else {<br/>                                    xChange = self.randomFloatBetweenNumbers(firstNum: self.floatieSize.width*2, secondNum: randomX)<br/>                                }<br/></span><span id="5fcc" class="mp kq hu mk b fv mv mr l ms mt">                                self.views.append(floatieView)<br/>                                UIView.animate(withDuration: self.duration, delay: 0,<br/>                                               options: [], animations: {<br/>                                                floatieView.center.y = endingPoint<br/>                                                floatie.alpha = self.endingAlpha<br/>                                                goToNext = false<br/>                                }, completion: {(value: Bool) in<br/>                                    if self.remove {<br/>                                        floatieView.removeFromSuperview()<br/>                                    }<br/>                                })<br/>                                UIView.animate(withDuration: self.duration1, delay: 0,<br/>                                               options: [.repeat, .autoreverse], animations: {<br/>                                                floatieView.center.x = xChange<br/>                                }, completion: nil)<br/>                                UIView.animate(withDuration: self.duration2, delay: 0, options: [.repeat, .autoreverse], animations: {                 floatieView.transform = CGAffineTransform(rotationAngle: CGFloat(M_PI_2)*randomRotation)<br/>                                }, completion: nil)<br/>                            }<br/>                        })<br/>                    }<br/>                }<br/>            })<br/>        }</span><span id="12ab" class="mp kq hu mk b fv mv mr l ms mt">        func stopAnimation() {<br/>            print("Stop Animating")<br/>            views = []<br/>            isAnimating = false<br/>            if !views.isEmpty {<br/>                for i in views {<br/>                    i.removeFromSuperview()<br/>                }<br/>            }<br/>        }</span><span id="7147" class="mp kq hu mk b fv mv mr l ms mt">        func randomFloatBetweenNumbers(firstNum: CGFloat, secondNum: CGFloat) -&gt; CGFloat{<br/>            return CGFloat(arc4random()) / CGFloat(UINT32_MAX) * abs(firstNum - secondNum) + min(firstNum, secondNum)<br/>        }</span><span id="be3a" class="mp kq hu mk b fv mv mr l ms mt">        func randomIntBetweenNumbers(firstNum: Int, secondNum: Int) -&gt; Int{<br/>            return firstNum + Int(arc4random_uniform(UInt32(secondNum - firstNum + 1)))<br/>        }<br/>    }</span></pre><p id="9cf5" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">当调用<code class="eh mh mi mj mk b">startAnimation</code>方法时，这个库简单地创建一个浮动的心，当调用<code class="eh mh mi mj mk b">stopAnimation</code>方法时，它停止。现在文件已经创建好了，打开您的<code class="eh mh mi mj mk b">Main.storyboard</code>文件并将<code class="eh mh mi mj mk b">Floater.swift</code>视图添加到我们之前创建的浮动视图中。这应该会在边栏中添加一些新的选项。这些选项源于添加到<code class="eh mh mi mj mk b">Floater.swift</code>类的<code class="eh mh mi mj mk b">@IBDesignable</code>和<code class="eh mh mi mj mk b">@IBInspectable</code>。</p><blockquote class="iy iz ja"><p id="ad82" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="hu">💡</em><code class="eh mh mi mj mk b"><em class="hu">**IBDesignable**</em></code><em class="hu"/><strong class="je hv"><em class="hu"/></strong><em class="hu"/><code class="eh mh mi mj mk b"><em class="hu">**IBInspectable**</em></code><em class="hu"/><strong class="je hv"><em class="hu">，一种创建自定义元素和属性的方式。这可以直接添加到iOS界面生成器中。</em></strong><em class="hu"/><a class="ae mg" rel="noopener" href="/@Anantha1992/ibdesignable-and-ibinspectable-in-swift-3-702d7dd00ca"><strong class="je hv"><em class="hu">阅读更多关于IBDesignable和IBInspectable</em></strong></a><strong class="je hv"><em class="hu">。</em> </strong></p></blockquote><p id="8574" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在，在新的选项字段中，添加以下值:</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff mu"><img src="../Images/c6f3b08702f493abbfbb9253fd16a068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QLPwGbgM2dtTyasz.png"/></div></div></figure><p id="87bf" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">对于浮动图像，将30x30心形图像添加到您的工作区，然后在浮动图像部分选择它。</p><p id="de12" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在打开<code class="eh mh mi mj mk b">ViewController</code>并添加以下方法:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="b0ca" class="mp kq hu mk b fv mq mr l ms mt">@IBOutlet weak var floaterView: Floater!</span><span id="93e7" class="mp kq hu mk b fv mv mr l ms mt">    private func startEndAnimation() {<br/>        floaterView.startAnimation()<br/>        DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: {<br/>            self.floaterView.stopAnimation()<br/>        })<br/>    }</span></pre><p id="6921" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在从<code class="eh mh mi mj mk b">hearted</code>方法中调用<code class="eh mh mi mj mk b">startEndAnimation</code>，这样当按钮被按下时它就会被调用。确保<code class="eh mh mi mj mk b">@IBOutlet floaterView</code>链接到我们在本文前面创建的视图端口。现在，当您构建和预览时，每次单击按钮时，您都应该看到心形浮动。</p><h1 id="f8fa" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">使用Pusher为我们的浮动心脏添加实时功能</h1><p id="1760" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">现在我们已经成功地添加了浮动心脏，接下来要做的是使用Pusher添加实时功能。如果您还没有，<a class="ae mg" href="https://pusher.com" rel="noopener ugc nofollow" target="_blank">创建一个推送账户</a>，创建一个新的应用程序，并在需要时复制凭证。</p><p id="384e" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">打开<code class="eh mh mi mj mk b">ViewController</code>，在那里添加如下内容:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="2c06" class="mp kq hu mk b fv mq mr l ms mt">static let API_ENDPOINT = "http://localhost:4000";</span><span id="645a" class="mp kq hu mk b fv mv mr l ms mt">    var pusher : Pusher!</span><span id="64ac" class="mp kq hu mk b fv mv mr l ms mt">    let deviceUuid : String = UIDevice.current.identifierForVendor!.uuidString</span><span id="9b00" class="mp kq hu mk b fv mv mr l ms mt">    private func listenForNewLikes() {<br/>        pusher = Pusher(key: "PUSHER_KEY", options: PusherClientOptions(host: .cluster("PUSHER_CLUSTER")))</span><span id="fcbc" class="mp kq hu mk b fv mv mr l ms mt">        let channel = pusher.subscribe("likes")<br/>        let _ = channel.bind(eventName: "like", callback: { (data: Any?) -&gt; Void in<br/>            if let data = data as? [String: AnyObject] {<br/>                let uuid = data["uuid"] as! String</span><span id="60cd" class="mp kq hu mk b fv mv mr l ms mt">                if uuid != self.deviceUuid {<br/>                    self.startEndAnimation()<br/>                }<br/>            }<br/>        })<br/>        pusher.connect()<br/>    }</span><span id="e2ea" class="mp kq hu mk b fv mv mr l ms mt">    private func postLike() {<br/>        let params: Parameters = ["uuid": deviceUuid]</span><span id="5b41" class="mp kq hu mk b fv mv mr l ms mt">        Alamofire.request(ViewController.API_ENDPOINT + "/like", method: .post, parameters: params).validate().responseJSON { response in<br/>            switch response.result {</span><span id="a3e6" class="mp kq hu mk b fv mv mr l ms mt">            case .success:<br/>                print("Liked")<br/>            case .failure(let error):<br/>                print(error)<br/>            }<br/>        }<br/>    }</span></pre><p id="3ba8" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">首先，我们定义一些类属性，用于存储API端点基本URL、推送器实例和设备UUID。在<code class="eh mh mi mj mk b">listenForNewLikes</code>中，我们定义了一个侦听器，它等待Pusher发送的事件，然后在接收到事件时触发一个回调。我们将用它来触发浮动红心<code class="eh mh mi mj mk b">startAndEndAnimation</code>方法。在<code class="eh mh mi mj mk b">postLike</code>方法中，我们使用<code class="eh mh mi mj mk b">AlamoFire</code>来达到一个端点(我们将在接下来创建它)。端点将是我们向Pusher发送“like”事件的地方，这样它们就可以被广播给通道上的其他侦听器。</p><p id="8f2d" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">如果一切正常，您的<code class="eh mh mi mj mk b">ViewController</code>现在应该是这样的:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="86f9" class="mp kq hu mk b fv mq mr l ms mt">import UIKit<br/>    import PusherSwift<br/>    import Alamofire</span><span id="5270" class="mp kq hu mk b fv mv mr l ms mt">    class ViewController: VideoSplashViewController {</span><span id="fb54" class="mp kq hu mk b fv mv mr l ms mt">        @IBOutlet weak var floaterView: Floater!</span><span id="c7a1" class="mp kq hu mk b fv mv mr l ms mt">        static let API_ENDPOINT = "http://localhost:4000";</span><span id="8b90" class="mp kq hu mk b fv mv mr l ms mt">        var pusher : Pusher!</span><span id="c9b4" class="mp kq hu mk b fv mv mr l ms mt">        let deviceUuid : String = UIDevice.current.identifierForVendor!.uuidString</span><span id="fea2" class="mp kq hu mk b fv mv mr l ms mt">        override func viewDidLoad() {<br/>            super.viewDidLoad()<br/>            loadVideoStreamSample()<br/>            listenForNewLikes()<br/>        }</span><span id="1625" class="mp kq hu mk b fv mv mr l ms mt">        @IBAction func hearted(_ sender: Any) {<br/>            postLike()<br/>            startEndAnimation()<br/>        }</span><span id="6260" class="mp kq hu mk b fv mv mr l ms mt">        private func startEndAnimation() {<br/>            floaterView.startAnimation()<br/>            DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: {<br/>                self.floaterView.stopAnimation()<br/>            })<br/>        }</span><span id="61a6" class="mp kq hu mk b fv mv mr l ms mt">        private func listenForNewLikes() {<br/>            pusher = Pusher(key: "PUSHER_KEY", options: PusherClientOptions(host: .cluster("PUSHER_CLUSTER")))</span><span id="53ee" class="mp kq hu mk b fv mv mr l ms mt">            let channel = pusher.subscribe("likes")<br/>            let _ = channel.bind(eventName: "like", callback: { (data: Any?) -&gt; Void in<br/>                if let data = data as? [String: AnyObject] {<br/>                    let uuid = data["uuid"] as! String</span><span id="ed6a" class="mp kq hu mk b fv mv mr l ms mt">                    if uuid != self.deviceUuid {<br/>                        self.startEndAnimation()<br/>                    }<br/>                }<br/>            })<br/>            pusher.connect()<br/>        }</span><span id="213d" class="mp kq hu mk b fv mv mr l ms mt">        private func postLike() {<br/>            let params: Parameters = ["uuid": deviceUuid]</span><span id="52ae" class="mp kq hu mk b fv mv mr l ms mt">            Alamofire.request(ViewController.API_ENDPOINT + "/like", method: .post, parameters: params).validate().responseJSON { response in<br/>                switch response.result {</span><span id="1de3" class="mp kq hu mk b fv mv mr l ms mt">                case .success:<br/>                    print("Liked")<br/>                case .failure(let error):<br/>                    print(error)<br/>                }<br/>            }<br/>        }</span><span id="b9a6" class="mp kq hu mk b fv mv mr l ms mt">        private func loadVideoStreamSample() {<br/>            let url = NSURL.fileURL(withPath: Bundle.main.path(forResource: "video", ofType: "mp4")!)<br/>            self.videoFrame = view.frame<br/>            self.fillMode = .resizeAspectFill<br/>            self.alwaysRepeat = true<br/>            self.sound = true<br/>            self.startTime = 0.0<br/>            self.duration = 10.0<br/>            self.alpha = 0.7<br/>            self.backgroundColor = UIColor.black<br/>            self.contentURL = url<br/>            self.restartForeground = true<br/>        }</span><span id="98b1" class="mp kq hu mk b fv mv mr l ms mt">        override var prefersStatusBarHidden: Bool {<br/>            return true<br/>        }  <br/>    }</span></pre><blockquote class="iy iz ja"><p id="f8df" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="hu"> ⚠️ </em> </p></blockquote><p id="4c64" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">这应该可以解决Xcode方面的问题。现在我们需要为我们的应用程序创建一个后端应用程序。这个后端应用程序将从应用程序接收有效载荷，并将其发送到Pusher。</p><h1 id="cb8d" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">为我们的实时浮动心脏应用程序创建Node.js后端</h1><p id="7958" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">为web应用程序创建一个目录，然后创建两个新文件:</p><p id="1504" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated"><strong class="je hv"> index.js </strong>文件…</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="312f" class="mp kq hu mk b fv mq mr l ms mt">let Pusher     = require('pusher');<br/>    let express    = require('express');<br/>    let app        = express();<br/>    let bodyParser = require('body-parser')<br/>    let pusher     = new Pusher(require('./config.js')['config']);</span><span id="6070" class="mp kq hu mk b fv mv mr l ms mt">    app.use(bodyParser.json());<br/>    app.use(bodyParser.urlencoded({ extended: false }));</span><span id="36d1" class="mp kq hu mk b fv mv mr l ms mt">    app.post('/like', (req, res, next) =&gt; {<br/>      let payload = {uuid: req.body.uuid}<br/>      pusher.trigger('likes', 'like', payload)<br/>      res.json({success: 200})<br/>    })</span><span id="2c0b" class="mp kq hu mk b fv mv mr l ms mt">    app.get('/', (req, res) =&gt; {<br/>      res.json("It works!");<br/>    });</span><span id="7de1" class="mp kq hu mk b fv mv mr l ms mt">    app.use((req, res, next) =&gt; {<br/>        let err = new Error('Not Found');<br/>        err.status = 404;<br/>        next(err);<br/>    });</span><span id="8538" class="mp kq hu mk b fv mv mr l ms mt">    app.listen(4000, function() {<br/>        console.log('App listening on port 4000!')<br/>    });</span></pre><p id="20d3" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated"><code class="eh mh mi mj mk b">index.js</code>文件也有一个路由，它从iOS应用程序接收消息并触发应用程序获取的Pusher事件。</p><p id="c734" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">下一个文件是<strong class="je hv"> packages.json </strong>，在这里我们定义了NPM依赖项:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="08ab" class="mp kq hu mk b fv mq mr l ms mt">{<br/>      "main": "index.js",<br/>      "dependencies": {<br/>        "body-parser": "^1.16.0",<br/>        "express": "^4.14.1",<br/>        "pusher": "^1.5.1"<br/>      }<br/>    }</span></pre><p id="3634" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">最后，我们有一个<strong class="je hv"> config.js </strong>，我们将在其中放置我们的Pusher配置:</p><pre class="ke kf kg kh fq ml mk mm mn aw mo dt"><span id="2d76" class="mp kq hu mk b fv mq mr l ms mt">module.exports = {<br/>        appId: 'PUSHER_ID',<br/>        key: 'PUSHER_KEY',<br/>        secret: 'PUSHER_SECRET',<br/>        cluster: 'PUSHER_CLUSTER',<br/>    };</span></pre><p id="aee9" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">现在在目录上运行<code class="eh mh mi mj mk b">npm install</code>，然后在npm安装完成后运行<code class="eh mh mi mj mk b">node index.js</code>。你应该看到<em class="jd"> App监听端口4000！</em>消息。</p><h1 id="ee04" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">测试我们的浮动心脏应用程序</h1><p id="c975" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">一旦您的本地节点web服务器开始运行，您将需要进行一些更改，以便您的应用程序可以与本地web服务器通信。在<code class="eh mh mi mj mk b">info.plist</code>文件中，进行如下修改:</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff mw"><img src="../Images/ec29220f4b5059f3606a9c15324fbb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aGsTY9smkN2x0wOY.png"/></div></div></figure><p id="35e5" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">通过这一更改，您可以构建并运行您的应用程序，它将直接与您的本地web应用程序对话。</p><h1 id="5e30" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">结论</h1><p id="9f2b" class="pw-post-body-paragraph jb jc hu je b jf ln jh ji jj lo jl jm ka lp jp jq kb lq jt ju kc lr jx jy jz hn dt translated">在这篇文章中，我们已经能够复制像脸书、Instagram、Periscope等应用程序所具有的浮动心脏功能。您可以以此为基础，将实际功能扩展到您自己的工作应用程序中。</p><p id="f79d" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm ka jo jp jq kb js jt ju kc jw jx jy jz hn dt translated">这篇文章最初发表在<a class="ae mg" href="https://pusher.com/tutorials/floating-hearts-swift/" rel="noopener ugc nofollow" target="_blank">推送器</a>上</p></div></div>    
</body>
</html>