<html>
<head>
<title>Build live comments using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin构建实时评论</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-live-comments-using-kotlin-45731b39659f?source=collection_archive---------16-----------------------#2018-05-24">https://medium.com/hackernoon/build-live-comments-using-kotlin-45731b39659f?source=collection_archive---------16-----------------------#2018-05-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="e2d7" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">遵循本教程需要对Kotlin有一个基本的了解。</p></blockquote><p id="578b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在构建应用程序时，拥有评论功能并不少见。使用实时评论，添加的评论将在所有设备上实时更新，无需用户刷新页面。像脸书这样的应用已经有了这个功能。</p><p id="b8b5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在这篇文章中，我们将构建一个基本的评论应用程序。我们将假设用户正在对一个虚构的帖子发表评论。这是我们将要构建的内容的屏幕记录:</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div class="ab fr cl kb"><img src="../Images/31573030d1a65a61fbd5e375cc6c1f55.png" data-original-src="https://miro.medium.com/v2/format:webp/1*b31hiO4ynbDLRrXWEFF4aQ.png"/></div></figure><h1 id="01bb" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">要求</h1><p id="f3f4" class="pw-post-body-paragraph iu iv hu ix b iy lc ja jb jc ld je jf jt le ji jj ju lf jm jn jv lg jq jr js hn dt translated">要完成本教程，您需要满足以下要求:</p><ul class=""><li id="f0c2" class="lh li hu ix b iy iz jc jd jt lj ju lk jv ll js lm ln lo lp dt translated">关于<a class="ae lq" href="http://kotlinlang.org/docs/tutorials/" rel="noopener ugc nofollow" target="_blank">科特林</a>编程语言的知识。</li><li id="378e" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated">安装了Android Studio 3.0。<a class="ae lq" href="https://developer.android.com/studio/archive.html" rel="noopener ugc nofollow" target="_blank">在这里下载</a>。</li><li id="30d1" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated">推送应用程序。<a class="ae lq" href="https://pusher.com" rel="noopener ugc nofollow" target="_blank">在这里创建一个</a>。</li><li id="6654" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated">IntelliJ IDEA已安装。<a class="ae lq" href="https://www.jetbrains.com/idea/download/" rel="noopener ugc nofollow" target="_blank">在这里下载</a>。</li></ul><p id="c033" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当你有了所有的要求，让我们开始吧。</p><h1 id="7234" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">在推动器上创建新应用程序</h1><p id="7558" class="pw-post-body-paragraph iu iv hu ix b iy lc ja jb jc ld je jf jt le ji jj ju lf jm jn jv lg jq jr js hn dt translated">登录Pusher仪表盘，选择左侧导航栏上的应用程序，并创建一个新应用程序。输入您的应用程序名称(在我的例子中是test-app)，选择一个集群(在我的例子中是eu-Ireland)。</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/12411c6b65f6c1a7d33be1946d296869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*5J5niCb3itllNO2o.png"/></div></figure><p id="8daa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">创建Pusher应用程序后，我们将继续创建Kotlin应用程序。</p><h1 id="35bd" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">在Kotlin的支持下创建我们的Android项目</h1><p id="32dc" class="pw-post-body-paragraph iu iv hu ix b iy lc ja jb jc ld je jf jt le ji jj ju lf jm jn jv lg jq jr js hn dt translated">打开android studio，创建一个新项目。插入您的应用名称和公司域名，然后选择“包括kotlin支持”复选框以在项目中启用Kotlin。</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/a0c0d66d52656f5179944e715fed5da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/0*gghNBVDeSApvv7WR.png"/></div></figure><p id="c868" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">对于本文，我们将把支持的最低Android版本设置为4.03 (API 15)。接下来，选择一个空的活动模板，然后单击Finish。</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff ly"><img src="../Images/1a87ff088af211d1bc3b9e9d6a2dd044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/0*re5ySD__j6dCs1nH.png"/></div></div></figure><h1 id="fb55" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">让客户端做好准备</h1><p id="15ea" class="pw-post-body-paragraph iu iv hu ix b iy lc ja jb jc ld je jf jt le ji jj ju lf jm jn jv lg jq jr js hn dt translated">在您的app <code class="eh md me mf mg b">build.gradle</code>文件中添加pusher依赖关系:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="2ec2" class="ml kf hu mg b fv mm mn l mo mp">implementation 'com.pusher:pusher-java-client:1.5.0'</span></pre><p id="d906" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们的布局文件将包含:</p><ul class=""><li id="0098" class="lh li hu ix b iy iz jc jd jt lj ju lk jv ll js lm ln lo lp dt translated">回收器视图(显示注释)。</li><li id="7d0c" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated">一个编辑文本视图(输入我们的消息)。</li><li id="0916" class="lh li hu ix b iy lr jc ls jt lt ju lu jv lv js lm ln lo lp dt translated">按钮(触发发送消息的动作)。</li></ul><p id="29c6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">默认项目是使用回收器视图依赖项创建的，但是，请注意这种依赖项:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="b822" class="ml kf hu mg b fv mm mn l mo mp">implementation 'com.android.support:design:26.1.0'</span></pre><p id="6a84" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你没有找到它，添加它。</p><p id="14a7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">以下是我们的布局片段:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="7695" class="ml kf hu mg b fv mm mn l mo mp">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:tools="http://schemas.android.com/tools"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"&gt;</span><span id="4742" class="ml kf hu mg b fv mq mn l mo mp">        &lt;android.support.v7.widget.RecyclerView<br/>            android:id="@+id/recycler_view"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="match_parent" /&gt;<br/>        &lt;FrameLayout<br/>            android:layout_width="match_parent"<br/>            android:layout_height="?attr/actionBarSize"<br/>            android:layout_alignParentBottom="true"&gt;<br/>            &lt;LinearLayout<br/>                android:layout_width="match_parent"<br/>                android:layout_height="wrap_content"<br/>                android:orientation="horizontal"&gt;<br/>                &lt;EditText<br/>                    android:layout_width="match_parent"<br/>                    android:layout_height="wrap_content"<br/>                    android:layout_weight="1" /&gt;<br/>                &lt;Button<br/>                    android:id="@+id/button_send"<br/>                    android:layout_width="wrap_content"<br/>                    android:layout_height="wrap_content"<br/>                        android:text="Send" /&gt;<br/>            &lt;/LinearLayout&gt;<br/>        &lt;/FrameLayout&gt;<br/>    &lt;/RelativeLayout&gt;</span></pre><p id="fc63" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这是我们的应用程序目前的样子。它非常光秃秃，还没有评论:</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/3ca32009cc57393816e984262e228460.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*alhRraGL-UbsPtlz.png"/></div></figure><p id="6773" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后我们创建一个名为<code class="eh md me mf mg b">RecyclerViewAdapter.kt</code>的回收器视图适配器类。这个适配器是一个处理列表中项目显示的类。</p><p id="9859" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">将下面的代码粘贴到我们的新类中:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="9043" class="ml kf hu mg b fv mm mn l mo mp">class RecyclerViewAdapter (private val mContext: Context) <br/>      :RecyclerView.Adapter&lt;RecyclerViewAdapter.MyViewHolder&gt;() {        </span><span id="dd49" class="ml kf hu mg b fv mq mn l mo mp">        // The initial empty list used by the adapter<br/>        private var arrayList: ArrayList&lt;String&gt; = ArrayList()</span><span id="559e" class="ml kf hu mg b fv mq mn l mo mp">        // This updates the adapter list with list from MainActivity.kt which contains the messages.  <br/>        fun setList(arrayList: ArrayList&lt;String&gt;) {<br/>            this.arrayList = arrayList<br/>            notifyDataSetChanged()<br/>        }</span><span id="be12" class="ml kf hu mg b fv mq mn l mo mp">        // The layout design used for each list item<br/>        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {<br/>            val view = LayoutInflater.from(mContext).inflate(android.R.layout.simple_list_item_1, parent, false)<br/>            return MyViewHolder(view)<br/>        }</span><span id="cf75" class="ml kf hu mg b fv mq mn l mo mp">        // This displays the text for each list item<br/>        override fun onBindViewHolder(holder: RecyclerViewAdapter.MyViewHolder, position: Int) { <br/>            holder.text.setText(arrayList.get(position))<br/>        }</span><span id="c178" class="ml kf hu mg b fv mq mn l mo mp">        // This returns the size of the list.<br/>        override fun getItemCount(): Int {<br/>            return arrayList.size<br/>        }</span><span id="1eea" class="ml kf hu mg b fv mq mn l mo mp">        inner class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView), </span><span id="c820" class="ml kf hu mg b fv mq mn l mo mp">        View.OnClickListener {<br/>            var text: TextView = itemView.findViewById&lt;View&gt;(android.R.id.text1) as <br/>            TextView<br/>            init {<br/>                itemView.setOnClickListener(this)<br/>            }</span><span id="20f9" class="ml kf hu mg b fv mq mn l mo mp">            override fun onClick(view: View) {</span><span id="2199" class="ml kf hu mg b fv mq mn l mo mp">            }<br/>        }<br/>    }</span></pre><p id="de4f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将需要<a class="ae lq" href="https://github.com/square/retrofit" rel="noopener ugc nofollow" target="_blank">改进的</a>库(一个“类型安全的HTTP客户端”)来使我们能够将消息发送到我们稍后将构建的远程服务器。</p><p id="dc58" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">添加改造依赖项后，您的应用程序<code class="eh md me mf mg b">build.gradle</code>文件应该如下所示:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="e64e" class="ml kf hu mg b fv mm mn l mo mp">apply plugin: 'com.android.application'<br/>    apply plugin: 'kotlin-android'<br/>    apply plugin: 'kotlin-android-extensions'</span><span id="9084" class="ml kf hu mg b fv mq mn l mo mp">    android {<br/>        compileSdkVersion 26<br/>        defaultConfig {<br/>            applicationId "com.example.android.pushersample"<br/>            minSdkVersion 15<br/>            targetSdkVersion 26<br/>            versionCode 1<br/>            versionName "1.0"<br/>            testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"<br/>        }<br/>        buildTypes {<br/>            release {<br/>                minifyEnabled false<br/>                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'<br/>            }<br/>        }<br/>    }</span><span id="1712" class="ml kf hu mg b fv mq mn l mo mp">    dependencies {<br/>        implementation fileTree(dir: 'libs', include: ['*.jar'])<br/>        implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"<br/>        implementation 'com.android.support:appcompat-v7:26.1.0'<br/>        implementation 'com.android.support:design:26.1.0'</span><span id="6c08" class="ml kf hu mg b fv mq mn l mo mp">        // pusher depencency<br/>        implementation 'com.pusher:pusher-java-client:1.5.0'</span><span id="4001" class="ml kf hu mg b fv mq mn l mo mp">        // retrofit dependencies<br/>        implementation 'com.squareup.retrofit2:retrofit:2.3.0'<br/>        implementation 'com.squareup.retrofit2:converter-scalars:2.3.0'<br/>        implementation 'com.squareup.retrofit2:converter-gson:2.3.0'</span><span id="d15e" class="ml kf hu mg b fv mq mn l mo mp">        // testing dependencies<br/>        testImplementation 'junit:junit:4.12'<br/>        androidTestImplementation 'com.android.support.test:runner:1.0.1'<br/>        androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'<br/>    }</span></pre><p id="a68e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，在名为<code class="eh md me mf mg b">ApiService.kt</code>的<code class="eh md me mf mg b">src/main/kotlin</code>文件夹中创建一个API接口文件。此接口用于定义网络呼叫期间使用的端点。对于这个应用程序，我们将只创建一个端点:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="fb38" class="ml kf hu mg b fv mm mn l mo mp">interface ApiService {<br/>        @GET("/{message}")<br/>        fun sendMessage(@Path("message") title: String):Call&lt;String&gt;<br/>    }</span></pre><p id="dd0a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh md me mf mg b">src/main/kotlin</code>文件夹中创建一个名为<code class="eh md me mf mg b">RetrofitClient.kt</code>的翻新客户端类。这个类为我们的网络调用提供了一个改进的实例:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="4bbb" class="ml kf hu mg b fv mm mn l mo mp">class RetrofitClient {<br/>        fun getClient(): ApiService {<br/>            val httpClient = OkHttpClient.Builder()</span><span id="b6cb" class="ml kf hu mg b fv mq mn l mo mp">            val builder = Retrofit.Builder()<br/>                    .baseUrl("http://10.0.2.2:5000/")<br/>                    .addConverterFactory(ScalarsConverterFactory.create())<br/>                    .addConverterFactory(GsonConverterFactory.create())</span><span id="43d7" class="ml kf hu mg b fv mq mn l mo mp">            val retrofit = builder<br/>                    .client(httpClient.build())<br/>                    .build()</span><span id="2b08" class="ml kf hu mg b fv mq mn l mo mp">            return retrofit.create(ApiService::class.java)<br/>        }<br/>    }</span></pre><blockquote class="ir is it"><p id="0736" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡我们使用地址</em> <code class="eh md me mf mg b"><em class="hu">10.0.2.2</em></code> <em class="hu">，因为这是Android默认仿真器识别本地主机的方式。所以IP地址指的是运行在您机器上的本地服务器。</em></p></blockquote><p id="f87f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们现在移动到我们的<code class="eh md me mf mg b">MainActivity.kt</code>文件，并用下面的方法更新它:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="1c25" class="ml kf hu mg b fv mm mn l mo mp">override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)</span><span id="f217" class="ml kf hu mg b fv mq mn l mo mp">        setContentView(R.layout.activity_main)</span><span id="c599" class="ml kf hu mg b fv mq mn l mo mp">        // list to hold our messages<br/>        var arrayList: ArrayList&lt;String&gt; = ArrayList()</span><span id="246d" class="ml kf hu mg b fv mq mn l mo mp">        // Initialize our adapter<br/>        val adapter = RecyclerViewAdapter(this)</span><span id="6e47" class="ml kf hu mg b fv mq mn l mo mp">        // assign a layout manager to the recycler view<br/>        recycler_view.layoutManager = LinearLayoutManager(this)</span><span id="1621" class="ml kf hu mg b fv mq mn l mo mp">        // assign adapter to the recycler view<br/>        recycler_view.adapter = adapter</span><span id="424c" class="ml kf hu mg b fv mq mn l mo mp">        // Initialize Pusher<br/>        val options = PusherOptions()<br/>        options.setCluster("PUSHER_APP_CLUSTER")<br/>        val pusher = Pusher("PUSHER_APP_KEY", options)</span><span id="4972" class="ml kf hu mg b fv mq mn l mo mp">        // Subscribe to a Pusher channel<br/>        val channel = pusher.subscribe("my-channel")</span><span id="4783" class="ml kf hu mg b fv mq mn l mo mp">        // this listener recieves any new message from the server<br/>        channel.bind("my-event") { channelName, eventName, data -&gt;<br/>            val jsonObject = JSONObject(data)<br/>            arrayList.add(jsonObject.getString("message"))<br/>            runOnUiThread { adapter.setList(arrayList) }<br/>        }<br/>        pusher.connect()</span><span id="00df" class="ml kf hu mg b fv mq mn l mo mp">        // We check for button clicks and if any text was inputed, we send the message<br/>        button_send.setOnClickListener(View.OnClickListener {<br/>            if (edit_text.text.length&gt;0) {<br/>                sendMessage(edit_text.text.toString())<br/>            }<br/>        })</span><span id="b373" class="ml kf hu mg b fv mq mn l mo mp">    } // end of onCreate method</span><span id="90a5" class="ml kf hu mg b fv mq mn l mo mp">    fun sendMessage(message:String) {<br/>        val call = RetrofitClient().getClient().sendMessage(message)</span><span id="f15c" class="ml kf hu mg b fv mq mn l mo mp">        call.enqueue(object : Callback&lt;String&gt; {<br/>            override fun onResponse(call: Call&lt;String&gt;, response: Response&lt;String&gt;) {<br/>                edit_text.setText("")<br/>                hideKeyboard(this@MainActivity)<br/>            }<br/>            override fun onFailure(call: Call&lt;String&gt;, t: Throwable) {</span><span id="6457" class="ml kf hu mg b fv mq mn l mo mp">            }<br/>        })<br/>    } // end of sendMessage method</span><span id="1c78" class="ml kf hu mg b fv mq mn l mo mp">    fun hideKeyboard(activity: Activity) {<br/>        val imm = activity.getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager</span><span id="c0bd" class="ml kf hu mg b fv mq mn l mo mp">        // Find the currently focused view, so we can grab the correct window token from it.<br/>        var view = activity.currentFocus</span><span id="ed7d" class="ml kf hu mg b fv mq mn l mo mp">        // If no view currently has focus, create a new one, just so we can grab a window token from it<br/>        if (view == null) {<br/>            view = View(activity)<br/>        }</span><span id="676a" class="ml kf hu mg b fv mq mn l mo mp">        imm.hideSoftInputFromWindow(view.windowToken, 0)<br/>    } // end of hideKeybnoard method</span></pre><blockquote class="ir is it"><p id="c45c" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️您需要将</em> <code class="eh md me mf mg b"><em class="hu">PUSHER_APP_*</em></code> <em class="hu">键替换为您的Pusher应用仪表板中的凭证。</em></p></blockquote><p id="ea1b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh md me mf mg b">onCreate</code>方法中，我们初始化了保存消息的列表，处理列表上项目显示的回收器视图适配器，并相应地分配了回收器视图。</p><p id="5a63" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后我们用必要的参数初始化<code class="eh md me mf mg b">PusherOptions</code>和<code class="eh md me mf mg b">Pusher</code>对象。记得用您自己的app键设置推动器对象优先参数。您可以在您创建的应用程序的应用程序密钥选项卡上找到您的应用程序密钥。如果您忘记了创建应用程序时选择的集群，您也可以在那里找到它。</p><p id="6601" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们为该通道上的事件创建一个侦听器。当收到新消息时，它将被添加到我们的列表中，更新后的列表将被分配给我们的适配器，以便它可以立即显示。</p><p id="88fc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，我们向布局中的按钮添加了一个侦听器，使我们能够发送消息。消息成功发送后，我们清除文本并隐藏键盘。</p><p id="aaa2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">下一步是在您的<code class="eh md me mf mg b">AndroidManifest.xml</code>文件中添加互联网权限。用下面的代码片段更新文件:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="0303" class="ml kf hu mg b fv mm mn l mo mp">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</span></pre><p id="0bd8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">有了这个改变，我们就完成了客户端应用程序的构建。</p><h1 id="1c16" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">构建我们的Kotlin后端服务器</h1><p id="e569" class="pw-post-body-paragraph iu iv hu ix b iy lc ja jb jc ld je jf jt le ji jj ju lf jm jn jv lg jq jr js hn dt translated">我们的服务器将由Kotlin构建，并在本地托管。您可以按照下面的步骤快速运行您的服务器。</p><p id="2a41" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在IntelliJ IDEA中创建一个新的基于Gradle的Kotlin项目。</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff ms"><img src="../Images/bb7747a40eca5ab89bd7eece4bb8101b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yv7QLKJqWRoqZnfl.png"/></div></div></figure><p id="f56c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为你的应用程序输入“groupId”。groupId可以是一个包名，通常类似于“com.example”。</p><p id="ea87" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，输入一个“artifactId”，它通常类似于“推送服务器”</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff mt"><img src="../Images/2541048d70ebb4ef04f077ad038c9d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sbnOI1cips_e6X6b.png"/></div></div></figure><p id="5d79" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在我们的项目<code class="eh md me mf mg b">build.gradle</code>文件中，我们将添加Ktor和pusher服务器依赖项。Ktor是一个使用Kotlin编程语言在连接系统中构建服务器和客户机的框架。</p><p id="590f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这是我们完整的<code class="eh md me mf mg b">build.gradle</code>文件，包含了我们需要的所有依赖项:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="0c27" class="ml kf hu mg b fv mm mn l mo mp">group 'com.example'<br/>    version '1.0-SNAPSHOT'</span><span id="d836" class="ml kf hu mg b fv mq mn l mo mp">    buildscript {<br/>        // dependency version variables<br/>        ext.kotlin_version = '1.1.4-3'<br/>        ext.ktor_version = '0.2.4'<br/>        repositories {<br/>            mavenCentral()<br/>        }<br/>        dependencies {<br/>            classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"<br/>        }<br/>    }</span><span id="03e4" class="ml kf hu mg b fv mq mn l mo mp">    apply plugin: 'application'<br/>    apply plugin: 'kotlin'</span><span id="0bdf" class="ml kf hu mg b fv mq mn l mo mp">    sourceCompatibility = 1.8</span><span id="bafd" class="ml kf hu mg b fv mq mn l mo mp">    repositories {<br/>        mavenCentral()<br/>        maven {<br/>            url 'http://dl.bintray.com/kotlin/kotlinx.support'<br/>        }<br/>        maven {<br/>            url 'http://dl.bintray.com/kotlin/ktor'<br/>        }<br/>    }</span><span id="696b" class="ml kf hu mg b fv mq mn l mo mp">    mainClassName = 'org.jetbrains.ktor.jetty.DevelopmentHost'</span><span id="6f7b" class="ml kf hu mg b fv mq mn l mo mp">    dependencies {<br/>        compile "org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"<br/>        // ktor dependencies<br/>        compile "org.jetbrains.ktor:ktor-core:$ktor_version"<br/>        compile "org.jetbrains.ktor:ktor-locations:$ktor_version"<br/>        runtime "org.jetbrains.ktor:ktor-jetty:$ktor_version"<br/>        // pusher server dependency<br/>        compile "com.pusher:pusher-http-java:1.0.0"<br/>        testCompile group: 'junit', name: 'junit', version: '4.12'<br/>    }</span><span id="7abd" class="ml kf hu mg b fv mq mn l mo mp">    compileKotlin {<br/>        kotlinOptions.jvmTarget = "1.8"<br/>    }</span><span id="8975" class="ml kf hu mg b fv mq mn l mo mp">    compileTestKotlin {<br/>        kotlinOptions.jvmTarget = "1.8"<br/>    }</span></pre><p id="274f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在您的<code class="eh md me mf mg b">src/main/kotlin</code>文件夹中，创建一个<code class="eh md me mf mg b">Main.kt</code>文件并插入以下代码片段:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="38b3" class="ml kf hu mg b fv mm mn l mo mp">fun Application.main() {</span><span id="69ed" class="ml kf hu mg b fv mq mn l mo mp">        val pusher = Pusher("PUSHER_APP_ID", "PUSHER_APP_KEY", "PUSHER_APP_SECRET")<br/>        pusher.setCluster("PUSHER_APP_CLUSTER")</span><span id="c641" class="ml kf hu mg b fv mq mn l mo mp">        install(DefaultHeaders)<br/>        install(CallLogging)<br/>        install(Routing) {<br/>            get("/{message}") {<br/>                val i = call.parameters["message"]!!<br/>                pusher.trigger("my-channel", "my-event", Collections.singletonMap("message", i))<br/>                call.respond("response sent")<br/>            }</span><span id="41de" class="ml kf hu mg b fv mq mn l mo mp">        }<br/>    }</span></pre><blockquote class="ir is it"><p id="adfa" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️您需要将</em> <code class="eh md me mf mg b"><em class="hu">PUSHER_APP_*</em></code> <em class="hu">键替换为Pusher应用仪表板中的凭证。</em></p></blockquote><p id="669e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码片段中，我们定义了一个处理新消息的路由。当收到消息时，它会将消息发送到推送通道，以便同一通道上的任何事件侦听器都可以获取该消息。</p><p id="5b6f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，打开<code class="eh md me mf mg b">src/main/resources/application.conf</code>文件，将端口设置为<code class="eh md me mf mg b">5000</code>。如果该文件不存在，请创建它并插入以下代码片段:</p><pre class="jw jx jy jz fq mh mg mi mj aw mk dt"><span id="2805" class="ml kf hu mg b fv mm mn l mo mp">ktor {<br/>        deployment {<br/>            environment = development<br/>            port = 5000<br/>        }</span><span id="a9d7" class="ml kf hu mg b fv mq mn l mo mp">        application {<br/>            modules = [com.example.MainKt.main]<br/>        }<br/>    }</span></pre><p id="7437" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">该文件允许您配置服务器参数。</p><p id="e1f6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">之后，在IDE上打开终端，键入<code class="eh md me mf mg b">./gradlew run</code>运行服务器。要测试你的服务器，打开<code class="eh md me mf mg b">http://localhost:5000/message</code>，你应该会看到一个显示“响应已发送”。</p><p id="0ea8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在一切都结束了。多亏了Pusher，我们可以毫无压力地发表评论和接收更新。</p><figure class="jw jx jy jz fq ka fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/b1d56b8b6047ace94d4b4bf8c754e259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*lvFNg0CCqh0vrg9Q.gif"/></div></figure><h1 id="3b7a" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">结论</h1><p id="6c14" class="pw-post-body-paragraph iu iv hu ix b iy lc ja jb jc ld je jf jt le ji jj ju lf jm jn jv lg jq jr js hn dt translated">在本文中，我们展示了在创建评论系统时如何使用Pusher和Kotlin。这是一个非常简单的实现，当然，您还可以做得更多。我很好奇你会想出什么。</p><p id="6559" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这篇文章最初发表于<a class="ae lq" href="https://pusher.com/tutorials/live-comments-kotlin/" rel="noopener ugc nofollow" target="_blank">推手</a></p></div></div>    
</body>
</html>