<html>
<head>
<title>Practical Data Structures for Frontend Applications: When to use Tries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端应用的实用数据结构:何时使用try</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/practical-data-structures-for-frontend-applications-when-to-use-tries-5428a565eba4?source=collection_archive---------7-----------------------#2018-05-25">https://medium.com/hackernoon/practical-data-structures-for-frontend-applications-when-to-use-tries-5428a565eba4?source=collection_archive---------7-----------------------#2018-05-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f9979c17491395bb8aea2033a073d4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*Zexd4HAZeIDBEjXn2E0pCA.jpeg"/></div></div></figure><p id="0864" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Trie(通常读作“try”)是一种针对特定类型的搜索而优化的树形数据结构。当您想要获取部分值并返回一组可能的完整值时，可以使用Trie。这方面的经典例子是自动完成。</p><p id="9c50" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上图显示了Trie的结构，暗示了它的工作原理。您可以将Trie视为一组相关的值。这些值的共同点是它们的前缀。</p><p id="344e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您搜索更具体的前缀时，您会得到更具体的返回值。使用上图所示的Trie，搜索前缀“b”的匹配将返回6个值:be、bear、bell、bid、bull、buy。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ka"><img src="../Images/1f765911312d5b7ed3227a75cf27aaba.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*S9IBjIslaLMBmnuBi8ZEfQ.png"/></div></figure><p id="f939" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">搜索前缀“be”的匹配将返回2个值:bear、bell</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ka"><img src="../Images/81f2a836861e0ea50c545014e8790808.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*pLHNU8YhenWNBe_C4vObLw.png"/></div></figure><h1 id="e22e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">何时使用尝试</h1><p id="76bf" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">每当您想要将前缀与可能的完整值进行匹配时，可以使用Trie。这就是特里这个有趣的名字的由来。单词“Trie”是单词“re <strong class="je hv"> trie </strong> val”的中缀。</p><p id="858c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尝试通常用于实现以下内容:</p><ul class=""><li id="31b4" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated">自动完成/键入标题</li><li id="81c2" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">搜索</li><li id="133c" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">拼写检查器</li><li id="9fd8" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">分类</li></ul><p id="d3ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你不局限于前缀匹配词。尝试可以存储:</p><ul class=""><li id="1a40" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated">IP地址，</li><li id="6e6c" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">电话号码，</li><li id="ce8d" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">对象(您可以搜索对象的属性)，</li><li id="d988" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">还有更多…</li></ul><h1 id="528d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">你应该在前端应用程序中使用Tries吗？</h1><p id="b313" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">在使用非JavaScript自带的数据结构之前，需要考虑一些实际因素，例如:</p><ul class=""><li id="a2df" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated">这种结构能给我带来性能提升吗？性能提升值得吗？</li><li id="d3b4" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">这种结构更容易使用吗——或者至少不会更难？</li><li id="7979" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">这种结构为我的数据提供了更多的语义吗？它让我的代码更容易理解吗？</li><li id="a4e4" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">这个结构对我的建造规模有多大影响？这种建筑规模的增加值得吗？</li></ul><p id="dcd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了回答这些问题，我们将对比尝试和数组——数组是JavaScript中最常用的集合结构。</p><p id="3144" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">对比尝试和数组<br/> </strong>注意:<em class="lw">各种JavaScript引擎都会实现JavaScript规范。不一样。因此，不同环境的性能结果可能会有所不同。</em></p><p id="a188" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是我们用来对比尝试和阵列的标准:</p><ul class=""><li id="64f4" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated">性能(运行时间和加载时间)</li><li id="61bb" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">易用性和可读性</li><li id="0b69" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">构建大小(数组不增加额外的代码。我们会分析特里。)</li></ul><h2 id="73da" class="lx kg hu bd kh ly lz ma kl mb mc md kp jn me mf kt jr mg mh kx jv mi mj lb mk dt translated">设置</h2><ul class=""><li id="3ae1" class="li lj hu je b jf ld jj le jn ml jr mm jv mn jz ln lo lp lq dt translated">我在React中使用<code class="eh mo mp mq mr b">create-react-app</code>编写了一个快速自动完成功能。它看起来是这样的:</li></ul><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/8d29f9cefeef5e4b6a3125f09ba87609.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/1*X1t7eWTWF0u8IcDkvDrxdA.gif"/></div></figure><ul class=""><li id="cddb" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated">我使用Josh Jung的<code class="eh mo mp mq mr b"><a class="ae mt" href="https://www.npmjs.com/package/trie-search" rel="noopener ugc nofollow" target="_blank">trie-search</a></code>作为我的Trie实现。</li><li id="01cf" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">我用<code class="eh mo mp mq mr b"><a class="ae mt" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank">faker</a></code>生成了一组10，000个名字。我不在乎名字是否唯一。</li></ul><h2 id="657f" class="lx kg hu bd kh ly lz ma kl mb mc md kp jn me mf kt jr mg mh kx jv mi mj lb mk dt translated">密码</h2><p id="4923" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">这是自动完成的基本代码。注意，它不使用任何特定的集合数据结构。下面是Trie和数组的实现细节。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="mu mv l"/></div></figure><p id="a4ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是基于数组的代码:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="mu mv l"/></div></figure><p id="38ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是基于TrieSearch的代码:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="mu mv l"/></div></figure><h2 id="f1c4" class="lx kg hu bd kh ly lz ma kl mb mc md kp jn me mf kt jr mg mh kx jv mi mj lb mk dt translated">表演</h2><p id="2e88" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">我测试了代码中的两个地方的性能:</p><ol class=""><li id="1642" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz mw lo lp lq dt translated">将数据项加载到数据结构中。</li><li id="c35d" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz mw lo lp lq dt translated">在数据结构中搜索项目。</li></ol><p id="99bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有测试都是使用Chrome 65.x进行的。</p><p id="0ef3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">加载数据项<br/> </strong>使用Trie，你会经历比数组更长的初始化时间。尝试在O(n*m)时间内初始化。为了让您实际了解这一点，在测试代码中向Trie添加10，000个项目平均需要90毫秒。这是一次性成本。初始化可以(即应该)推迟到页面加载之后。</p><p id="3233" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最常见的是，从数组中初始化Trie。如果需要添加更多数据，可以手动向Trie添加项目。</p><p id="619d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当搜索是一个应用程序的主要焦点之一时，尝试增加好的价值。由于它们的初始化成本，如果用户不经常搜索，使用Trie可能不太适合您的应用程序。</p><p id="8cac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">运行时<br/> </strong>在每次测试中，我在自动完成输入中键入“Cath ”,并测量搜索需要多长时间。</p><p id="bc63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">TrieSearch表现优于<code class="eh mo mp mq mr b">Array.filter</code>。速度快了50%。</p><h2 id="7dfc" class="lx kg hu bd kh ly lz ma kl mb mc md kp jn me mf kt jr mg mh kx jv mi mj lb mk dt translated">易用性</h2><p id="3b13" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">如上面的代码示例所示，使用TrieSearch并不比使用数组复杂。但是，需要记住一些不同之处:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="mu mv l"/></div></figure><p id="167b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有关使用TrieSearch的更多详细信息，请查阅is <a class="ae mt" href="https://www.npmjs.com/package/trie-search" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="0fdd" class="lx kg hu bd kh ly lz ma kl mb mc md kp jn me mf kt jr mg mh kx jv mi mj lb mk dt translated">大小</h2><p id="41ed" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">TrieSearch未混合7.4kb。它有13个依赖项。整个生产版本的大小约为10kb。这是否会对您的应用程序产生重大影响取决于您。</p><h1 id="f4ed" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">摘要</h1><p id="5bdd" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">当你有一个做大量搜索的应用程序时，Trie是一个极好的数据结构。尝试相对容易使用，而且速度很快。</p><p id="7aba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在数组上使用Trie会有一些性能成本，例如:</p><ul class=""><li id="ad80" class="li lj hu je b jf jg jj jk jn lk jr ll jv lm jz ln lo lp lq dt translated">Trie初始化。(因此，建议您将Trie的初始化推迟到页面加载之后)。</li><li id="a85e" class="li lj hu je b jf lr jj ls jn lt jr lu jv lv jz ln lo lp lq dt translated">更大的捆尺寸。</li></ul></div></div>    
</body>
</html>