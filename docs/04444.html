<html>
<head>
<title>SOLID principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的原则</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/solid-principles-530b2cc2badf?source=collection_archive---------2-----------------------#2018-05-26">https://medium.com/hackernoon/solid-principles-530b2cc2badf?source=collection_archive---------2-----------------------#2018-05-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5b6e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">和他们背后的基础</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/b75aadd8ed607296485bc8f8ab85dd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*muYZIN5wxSltVbMr."/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">SOLID design is like a wall made of lots of small, cohesive and loosely coupled bricks. Photo by <a class="ae jz" href="https://unsplash.com/@jeremyforlife?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeremy Galliani</a></figcaption></figure><h2 id="0b0d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">让我们从极限编程开始</h2><p id="ebba" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">我喜欢将坚实的原则与XP原则联系起来。提醒你一下，完整的XP链是由价值观、原则和实践组成的——按照这个顺序，从最基本的元素到衍生产品。价值观驱动着我们，定义着我们和我们的行为。原则是符合价值观的某些规则。实践是一些基于原则的活动。没有价值观，原则和实践都没有意义。</p><h2 id="fb8d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">如果固体只是原则，那么价值观是什么？</h2><p id="be6f" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">在深入这个哲学讨论之前，我想说，当我听到“程序代码”这个词时，我看到了什么心理图像——至少，当我参与领域逻辑实现时。对我来说，程序代码是某种编程语言中业务流程的表示。理想情况下，它们之间有一个<a class="ae jz" href="https://en.wikipedia.org/wiki/Bijection" rel="noopener ugc nofollow" target="_blank">双射体</a>。这是一种<a class="ae jz" href="https://hackernoon.com/why-you-should-split-the-monolith-e946f57db38c" rel="noopener ugc nofollow" target="_blank">的业务-IT </a>对齐，它在比<a class="ae jz" rel="noopener" href="/@wrong.about/how-to-implement-soa-dc6bf08fba9a"> SOA </a>更低的层次上表现出来——在程序代码中。这就是为什么OOP比过程化编程更适合这一点:它拥有所有工具来表示现实生活领域中的实体。对，我说的是<a class="ae jz" href="https://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html" rel="noopener ugc nofollow" target="_blank">对象</a>。所以<a class="ae jz" href="https://hackernoon.com/on-good-domain-decomposition-385ee8ce5a3" rel="noopener ugc nofollow" target="_blank">建模正确的抽象</a>，代表现实生活中的过程，显然是面向对象软件开发中最重要的部分。我会说是它的价值观。</p><h2 id="519e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">坚实的原则是必要的和充分的吗？</h2><p id="6293" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">让我们依次来看一看它们。</p><p id="551d" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">单一责任原则<br/> </strong>比较模糊，<a class="ae jz" href="https://hackernoon.com/the-secret-behind-the-single-responsibility-principle-e2f3692bae25" rel="noopener ugc nofollow" target="_blank">基本上是告诉</a>对象应该是内聚的。如果一个类是内聚的，如果有一个单一的更高层次的目的，如果它的职责符合它的名字，SRP就会自然地出现。</p><p id="fe96" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">开闭原则</strong> <br/>应用<a class="ae jz" href="https://hackernoon.com/the-open-closed-principle-c3dc45419784" rel="noopener ugc nofollow" target="_blank"> OCP </a>的实际结果是，如果任何行为(它是某个类的一部分)可以改变，那么它的实现应该隐藏在一个接口后面，这样你就不必修改那个类的任何代码。这已经有了一个名字——它就是<a class="ae jz" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">松耦合</a>。</p><p id="a289" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">利斯科夫替代原理<br/> </strong>它基本上是一个<a class="ae jz" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态性</a>的定义，更准确地说是——<a class="ae jz" href="https://en.wikipedia.org/wiki/Subtyping" rel="noopener ugc nofollow" target="_blank">分型</a>。我两者都喜欢，但是我也喜欢封装和可组合性。那么为什么固体缩写中没有“e”和“c”字母呢？<br/>总而言之，是关于松耦合的，<a class="ae jz" href="https://hackernoon.com/liskov-substitution-principle-a982551d584a" rel="noopener ugc nofollow" target="_blank">又是</a>。</p><p id="2279" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">接口分离原理<br/> </strong> <a class="ae jz" href="https://hackernoon.com/interface-segregation-principle-bdf3f94f1d11" rel="noopener ugc nofollow" target="_blank">根据定义</a>，它不利于胖接口，那些有很多很多实现类的接口。所以这又是关于松耦合的。</p><p id="2187" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">依赖反转原理<br/> </strong>好了，<a class="ae jz" rel="noopener" href="/@wrong.about/dependency-inversion-principle-e402e5b69e70">这里的</a>，除了松耦合，还有一个具体的(和机械的)关于如何模块化你的软件的指导方针。</p><p id="4f85" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">所以，我在固体中看不到任何革命性的东西。这都是关于低耦合和高内聚的。</p><h2 id="4677" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">固体原理和封装</h2><p id="738f" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">高内聚和低耦合是足够宽泛的概念，因此我认为可以从它们中派生出封装。为了以防万一，我说的<a class="ae jz" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">封装</a>通常也指<a class="ae jz" href="https://en.wikipedia.org/wiki/Information_hiding" rel="noopener ugc nofollow" target="_blank">信息隐藏</a>，这不是普遍存在的<a class="ae jz" href="https://web.archive.org/web/20130307051858/http://www.itmweb.com/essay550.htm" rel="noopener ugc nofollow" target="_blank"/><a class="ae jz" href="http://wiki.c2.com/?EncapsulationIsNotInformationHiding" rel="noopener ugc nofollow" target="_blank">接受的</a>。<br/>看看下面的代码:</p><pre class="jk jl jm jn fq lw lx ly lz aw ma dt"><span id="92d3" class="ka kb hu lx b fv mb mc l md me"><strong class="lx hv">interface </strong>IB<br/>{<br/>    <strong class="lx hv">public function </strong>call(IC $c);<br/>}<br/><br/><strong class="lx hv">interface </strong>IC<br/>{<br/><br/>}<br/><br/><strong class="lx hv">class </strong>A<br/>{<br/>    <strong class="lx hv">private $b</strong>;<br/>    <strong class="lx hv">private $c</strong>;<br/>    <strong class="lx hv">private $d</strong>;<br/><br/>    <strong class="lx hv">public function </strong>__construct(IB $b, IC $c, int $d)<br/>    {<br/>        $this-&gt;<strong class="lx hv">b </strong>= $b;<br/>        $this-&gt;<strong class="lx hv">c </strong>= $c;<br/>        $this-&gt;<strong class="lx hv">d </strong>= $d;<br/>    }<br/><br/>    <strong class="lx hv">public function </strong>someBehavior()<br/>    {<br/>        $this-&gt;<strong class="lx hv">d</strong>++;<br/>        <strong class="lx hv">return </strong>$this-&gt;<strong class="lx hv">b</strong>-&gt;call($this-&gt;<strong class="lx hv">c</strong>);<br/>    }<br/>}</span></pre><p id="8132" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">是什么让类<em class="mf"> A </em>的对象和接口<em class="mf"> IB </em>和<em class="mf"> IC </em>高度封装？它们都没有公开它们的内部结构或纯数据:没有对实例变量的公共访问，<a class="ae jz" href="https://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html" rel="noopener ugc nofollow" target="_blank">没有getter</a>，没有常量，没有公共静态属性。相反，所有的内部数据都在内部使用，导致由类<em class="mf"> A </em>创建的对象非常<a class="ae jz" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">内聚</a>。此外，对象<em class="mf"> A </em>不需要其他对象的数据。相反，它只依赖于接口<em class="mf"> IB </em>和<em class="mf"> IC </em>所公开的行为。而类<em class="mf"> A </em>并不关心它们的具体实现，这显然驻留在某个其他模块中。这使得整个系统非常松散耦合。</p><p id="1f0c" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">我认为一个类被封装的程度是衡量这个类好坏的一个更实际的标准——以防高内聚和松耦合看起来有点抽象的概念。至少在我看来，封装是一个比实体少得多的模糊不清的概念。</p><h2 id="0594" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">坚实的原则和可重用性</h2><p id="69c2" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">最初，OOP从来都不是关于可重用性的。同样，当您的模型被正确分解时，它自然会出现。可重用性是这种分解的结果。把它放在第一位很难导致正确的抽象和可维护的代码。并且你可以通过阅读一些关于Smalltalk的好书来了解OOP最初是什么样子的。别担心，它们更多的是关于好的对象设计，而不是Smalltalk。</p><h2 id="508a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">最后的想法</h2><p id="b30e" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">SOLID并不是整个OOP所基于的一套完整的公理。这是对已经构建好的设计的一个很好的衡量，但可以说不是在实际构建它时要遵循的最佳原则。我认为高内聚和松耦合是更清晰的标志。</p><p id="d816" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">此外，人们不应该忘记，每一个都意味着一个<em class="mf">原则</em>，而不是好软件的核心价值。因此，在没有确定正确的抽象的情况下，完全机械地应用它们是没有任何意义的。</p></div></div>    
</body>
</html>