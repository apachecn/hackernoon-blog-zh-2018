<html>
<head>
<title>Mastering MongoDB — Introducing multi-document transactions in v4.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握MongoDB —在v4.0中引入多文档事务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mongodb-transactions-5654cdb8fd24?source=collection_archive---------3-----------------------#2018-05-28">https://medium.com/hackernoon/mongodb-transactions-5654cdb8fd24?source=collection_archive---------3-----------------------#2018-05-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d2d173628c40eae17afe48cb8bdfc9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9AB2ZkozabS2T4Or."/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@zeldygirl?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Madison Grooms</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jh"><p id="4eda" class="ji jj hu bd jk jl jm jn jo jp jq jr ek translated">对MongoDB中事务的支持是许多人长久以来的愿望。有了MongoDB v4.0，等待就结束了。欢迎使用副本集的多文档事务。</p></blockquote><p id="805b" class="pw-post-body-paragraph jt ju hu jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp jr hn dt translated">在一个<a class="ae jg" href="https://hackernoon.com/tagged/mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB </a> <a class="ae jg" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>应用程序中，当两个实体之间有父子关系时，比如<em class="kq"> orders &amp; order details </em>，通常会将子文档(<em class="kq"> order details </em>)嵌入到父文档(<em class="kq"> order </em>)中。这种模式设计方式不仅有助于更快的读取，还有助于满足原子性。对单个文档的写操作是原子性的。然而，<em class="kq">‘如何在处理多个文档时保持原子性？’</em></p><p id="c2ba" class="pw-post-body-paragraph jt ju hu jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp jr hn dt translated">这是多部分系列文章之一，<a class="ae jg" rel="noopener" href="/p/mastering-mongodb-5544e16df023">掌握MongoDB —一天一个技巧</a>，专为您创建，通过学习<em class="kq">“一天一个技巧”</em>来掌握<a class="ae jg" href="https://www.mongodb.com" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>。在几篇系列文章中，我将给出各种提示来帮助您回答上述问题。本文讨论了<em class="kq">多文档事务</em>，这是MongoDB v4.0中的一个新特性——它的应用程序、用例场景，最后还有一些动手实验练习。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="2edf" class="ld le hu bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma dt translated">母版制作—多文档事务</h1><h1 id="f99b" class="ld le hu bd lf lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma dt translated">什么是交易</h1><p id="95ee" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">在MongoDB中，对单个文档的写操作是原子的，即使该操作修改了单个文档中的多个嵌入式文档。当像<a class="ae jg" href="https://docs.mongodb.com/manual/reference/method/db.collection.updateMany/" rel="noopener ugc nofollow" target="_blank"> updateMany </a>这样的单个写操作修改多个文档时，每个文档的修改是原子的，但是操作整体上不是原子的。一些使用案例可能还要求您将多个写操作作为单个操作的一部分进行修改。在这种情况下，您确实需要<em class="kq">事务</em>来在多个写操作之间实施原子性。</p><h1 id="bd77" class="ld le hu bd lf lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma dt translated">为什么使用事务</h1><p id="4da4" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">在MongoDB v4.0之前，您可以模拟<em class="kq">事务</em>的唯一方式是在您的应用程序中实现<a class="ae jg" href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" rel="noopener ugc nofollow" target="_blank">两阶段提交</a>。<a class="ml mm gr" href="https://medium.com/u/6ee5301c7935?source=post_page-----5654cdb8fd24--------------------------------" rel="noopener" target="_blank"> Emmanuel Olaojo </a>写了一篇文章<a class="ae jg" href="https://codeburst.io/fawn-transactions-in-mongodb-988d8646e564" rel="noopener" target="_blank">“Fawn:<em class="kq">transactions</em>in MongoDB "</a>”，介绍了使用<a class="ae jg" href="https://www.npmjs.com/package/fawn" rel="noopener ugc nofollow" target="_blank"> Fawn </a>模块对<a class="ae jg" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>应用程序进行两阶段提交。请注意，两阶段提交只能提供类似事务的语义。使用两阶段提交时，应用程序可能会在两阶段提交或回滚期间返回中间数据。</p><p id="46ee" class="pw-post-body-paragraph jt ju hu jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp jr hn dt translated">MongoDB v4.0为副本集引入了<em class="kq">多文档事务</em>，并且可以跨多个操作、集合和文档使用。多文档<em class="kq">事务</em>提供了一个全局一致的数据视图，并强制执行全有或全无以维护数据完整性。<em class="kq">交易</em>将具有以下属性</p><ul class=""><li id="5794" class="mn mo hu jv b jw kr ka ks ke mp ki mq km mr jr ms mt mu mv dt translated">提交事务时，将保存事务中所做的所有数据更改。</li><li id="fab0" class="mn mo hu jv b jw mw ka mx ke my ki mz km na jr ms mt mu mv dt translated">如果事务中的任何操作失败，事务将中止</li><li id="4b34" class="mn mo hu jv b jw mw ka mx ke my ki mz km na jr ms mt mu mv dt translated">当事务中止/中止时，事务中所做的所有数据更改都将被丢弃。</li><li id="cdee" class="mn mo hu jv b jw mw ka mx ke my ki mz km na jr ms mt mu mv dt translated">在提交事务之前，事务中的写操作在事务之外是不可见的。</li></ul><h1 id="eda4" class="ld le hu bd lf lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma dt translated">动手实验练习</h1><p id="1ba4" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">这个实验练习帮助您理解如何在MongoDB shell中使用<em class="kq">事务</em>。由于多文档<em class="kq">事务</em>仅适用于副本集，请确保您至少有一个成员副本集，而不是独立的<em class="kq"> mongod </em>。</p><p id="18ea" class="pw-post-body-paragraph jt ju hu jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp jr hn dt translated">在我们开始之前，我希望你注意几点</p><ul class=""><li id="f1d4" class="mn mo hu jv b jw kr ka ks ke mp ki mq km mr jr ms mt mu mv dt translated">您只能在现有集合上指定读/写(CRUD)操作。</li><li id="2e85" class="mn mo hu jv b jw mw ka mx ke my ki mz km na jr ms mt mu mv dt translated">多文档事务不能包含会导致创建新集合的插入操作。</li><li id="2290" class="mn mo hu jv b jw mw ka mx ke my ki mz km na jr ms mt mu mv dt translated">事务与会话相关联。</li><li id="e558" class="mn mo hu jv b jw mw ka mx ke my ki mz km na jr ms mt mu mv dt translated">在任何给定时间，一个会话最多只能有一个打开的事务。</li><li id="3b91" class="mn mo hu jv b jw mw ka mx ke my ki mz km na jr ms mt mu mv dt translated">要将读写操作与打开的事务相关联，需要将会话传递给操作。</li></ul><h2 id="5a51" class="nb le hu bd lf nc nd ne lj nf ng nh ln ke ni nj lr ki nk nl lv km nm nn lz no dt translated">设置环境</h2><p id="d782" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">首先，你需要一个玩耍的环境。如果您已经有了MongoDB v4.0 replicaset环境，可以跳过这一步。</p><figure class="np nq nr ns fq iv"><div class="bz el l di"><div class="nt nu l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A bash script with download MongoDB v4.0 release candidate and create a 1 member replica set</figcaption></figure><p id="5de5" class="pw-post-body-paragraph jt ju hu jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp jr hn dt translated">下一组练习将说明commit transaction/abort transaction是如何工作的，最重要的是，还将涵盖具有<em class="kq">写冲突</em>的多个写操作如何导致<em class="kq"> abortTransaction </em>。为了帮助您更好地理解，我将这些命令的输出作为注释放在了它们的正下方。</p><h2 id="49a4" class="nb le hu bd lf nc nd ne lj nf ng nh ln ke ni nj lr ki nk nl lv km nm nn lz no dt translated">使用commitTransaction保存数据更改</h2><p id="5bef" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">下面的MongoDB shell命令显示了一个包含一些样本数据的<em class="kq"> person </em>集合。注意，<em class="kq">事务</em>中新添加的文档在<em class="kq"> db.person </em>集合对象上不可见，直到<em class="kq"> session1 </em>被提交。</p><figure class="np nq nr ns fq iv"><div class="bz el l di"><div class="nt nu l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">MongoDB commands illustrating the data changes in transaction are save when the transaction is committed.</figcaption></figure><h2 id="69d9" class="nb le hu bd lf nc nd ne lj nf ng nh ln ke ni nj lr ki nk nl lv km nm nn lz no dt translated">用abortTransaction放弃数据更改</h2><p id="75cf" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">下面的MongoDB shell命令显示了一个包含一些样本数据的<em class="kq"> person </em>集合。注意，<em class="kq">事务</em>中新添加的文档在<em class="kq"> db.person </em>集合对象上不可见，直到<em class="kq"> session1 </em>被中止。</p><figure class="np nq nr ns fq iv"><div class="bz el l di"><div class="nt nu l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">MongoDB commands illustrating the data changes in transaction are discarded when the transaction is aborted on the session.</figcaption></figure><h2 id="f3a1" class="nb le hu bd lf nc nd ne lj nf ng nh ln ke ni nj lr ki nk nl lv km nm nn lz no dt translated">可以提交没有写冲突的事务</h2><p id="5815" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">在下面的代码中，您可能会注意到有多个写操作(<em class="kq">插入</em>、<em class="kq">更新</em>和<em class="kq">删除</em>)被从多个作用域调用，在事务内部/外部。只要没有<em class="kq">写冲突</em>，就可以成功提交这些事务。</p><figure class="np nq nr ns fq iv"><div class="bz el l di"><div class="nt nu l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">MongoDB commands illustrating transactions with no write conflicts can successfully commit</figcaption></figure><h2 id="ff5c" class="nb le hu bd lf nc nd ne lj nf ng nh ln ke ni nj lr ki nk nl lv km nm nn lz no dt translated">具有写冲突的事务被中止</h2><p id="5878" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">如果两个或多个写操作从不同的范围修改同一文档，则一个事务中的数据更改会影响其他事务中的数据更改。当存在这种<em class="kq">写冲突</em>时，操作会导致<em class="kq">transient transaction error</em>和<em class="kq"> abortTransaction </em>。这些写入可以是插入/更新/删除操作的任意组合。以下示例显示了在两个不同的事务中调用的对同一文档的两个删除操作。</p><figure class="np nq nr ns fq iv"><div class="bz el l di"><div class="nt nu l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">MongoDB commands illustrating multiple transactions with write conflicts are aborted</figcaption></figure><h1 id="a0c5" class="ld le hu bd lf lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma dt translated">摘要</h1><p id="2292" class="pw-post-body-paragraph jt ju hu jv b jw mg jy jz ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp jr hn dt translated">对副本集的多文档事务<em class="kq">的支持仅仅是个开始。未来的版本可能会跨分片部署和各种隔离级别解决<em class="kq">事务</em>，您可能会从其他关系数据库中暴露这些事务。我想提醒重要的一点——</em></p><blockquote class="jh"><p id="3a8b" class="ji jj hu bd jk jl nv nw nx ny nz jr ek translated">“仅仅因为您现在支持事务，您就不能围绕第三范式设计数据模型。您必须始终拥有一个有效的MongoDB模式设计，以确保您的应用程序是高性能的。</p></blockquote><p id="88ee" class="pw-post-body-paragraph jt ju hu jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp jr hn dt translated">与单个文档写入相比，多文档事务会导致更高的性能成本。那么，“使用事务的性能成本是多少？”。很棒的问题！但那是另一天的话题。</p><p id="9b9a" class="pw-post-body-paragraph jt ju hu jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp jr hn dt translated">希望你今天在通往“<a class="ae jg" rel="noopener" href="/p/mastering-mongodb-5544e16df023">掌握MongoDB——每天一个技巧</a>”的道路上学到了一些新东西。</p><figure class="np nq nr ns fq iv"><div class="bz el l di"><div class="oa nu l"/></div></figure></div></div>    
</body>
</html>