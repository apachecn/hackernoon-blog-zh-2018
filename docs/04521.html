<html>
<head>
<title>Some Thoughts On The Return Statement</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于退货单的几点思考</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/some-thoughts-on-the-return-statement-9d99771f2838?source=collection_archive---------25-----------------------#2018-05-29">https://medium.com/hackernoon/some-thoughts-on-the-return-statement-9d99771f2838?source=collection_archive---------25-----------------------#2018-05-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/7d6cadab144da06d53b471edc64339c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVzwGLvNK8Il14IP7ACUYw.jpeg"/></div></div></figure><div class=""/><p id="2daf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，javascript <strong class="je ig">返回</strong>是一个语句。不是功能。</p><p id="7917" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从表面上看，语句和函数是javascript引擎“做某事”的命令。然而从技术上讲，它们是不同的。一个<strong class="je ig">语句</strong>是一个不返回值的命令。</p><p id="9f46" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个<strong class="je ig">函数</strong>可以在javascript环境中的任何地方被调用——不管它在哪里被定义——并且它经常被用来返回值。程序中的函数是子程序。</p><blockquote class="ka kb kc"><p id="78c0" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><strong class="je ig">子程序</strong>是执行特定任务的程序指令序列，打包成一个单元。这个单元可以在程序中任何需要执行特定任务的地方使用。</p><p id="77b7" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">-维基百科</p></blockquote><p id="ff73" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="kd"> return </em> </strong>语句结束一个函数在JS环境中的执行，并用于指定一个值(对象、数组、变量)返回到该函数的调用者范围。</p><figure class="kh ki kj kk fq hw"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="b55f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这上面会发生什么？</p><p id="7dde" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尤其是我们的退货单。</p><p id="4a7c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">解释功能的伪代码</strong></p><ol class=""><li id="712a" class="kn ko if je b jf jg jj jk jn kp jr kq jv kr jz ks kt ku kv dt translated">我们初始化用户变量，将其声明为用户数组。这些元素是带有道具的物体本身。</li><li id="f7f2" class="kn ko if je b jf kw jj kx jn ky jr kz jv la jz ks kt ku kv dt translated">第二行是一个从零开始的计数器</li><li id="d795" class="kn ko if je b jf kw jj kx jn ky jr kz jv la jz ks kt ku kv dt translated">一个过滤函数，它将根据我们在函数中定义的条件创建一个新的数组。</li><li id="c7b9" class="kn ko if je b jf kw jj kx jn ky jr kz jv la jz ks kt ku kv dt translated">注意到箭头功能了吗？折叠我们的函数，使其易于阅读(如果函数中的条件使用箭头会更简单，那么至少会缩短两行)。不仅如此，它已经能够处理那些怪异的<strong class="je ig">。【绑定(本)】</strong>情况。</li></ol><p id="2235" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来讨论一下箭头函数</p><figure class="kh ki kj kk fq hw"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="a585" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你能看到哪些东西？代码更短，而且没有绑定调用就“工作”。</p><p id="2db6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章的最后，我写了一篇关于ES6箭头功能的短文。</p><p id="6454" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">TL；DR ES6 arrow函数语法将总是覆盖任何先前绑定或动态确定“this”的值，以及它对引擎和代码的重要性。</p><p id="b804" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">**</p><p id="6bff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">5.<strong class="je ig"> <em class="kd">最后</em> </strong>，我们的迭代器根据我们的条件遍历数组，返回少数通过“测试”的元素。网上退货是我们关注的焦点。我们看到两个值被返回给filter方法。用户被返回。但状态为“已丢弃”</p><p id="53a7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">“状态”不一定会被删除，更像是被忽略了。JS引擎为什么要这么做？引擎希望元素“e”返回到过滤器方法，所以事实上，当你用return语句写一些值或表达式，声明时，return语句与这个值无关，但是它将继续返回已经通过指定条件的元素。</p><p id="f0af" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是独特的ES6方法的特殊行为，这种行为不适用于传统函数。</p><p id="fde5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">按照下面的代码。</p><figure class="kh ki kj kk fq hw"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="9dab" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当代码运行时。这个测试的值是“世界”为什么？</p><p id="a8b2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">忽略返回后的所有语句(当然是运行它们)和表达式，但选择最后一个声明的值并返回该值。</p><figure class="kh ki kj kk fq hw"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="f8e5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在函数的末尾，我们返回满足条件的范围内的每个“用户”,但是没有返回state。如果你不感到惊讶，那可能是因为你明白函数显式返回单个变量。</p><p id="3cdc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:“this”上下文通过词法范围起作用。运行代码的JS引擎将查看包含函数的作用域，并在函数中使用该作用域的“this”上下文。有趣的是，箭头函数的“this”上下文不能被覆盖。不能将其绑定到想要绑定函数的对象。一些开发者认为这是一件坏事。但这令人不安，因为JS本应是一种 <strong class="je ig"> <em class="kd">动态</em> </strong> <em class="kd">和</em> <strong class="je ig"> <em class="kd">严格</em> </strong> <em class="kd">语言，同时才能真正意识到这种语言的潜力。在React这样的环境中，使用arrow函数确实有助于避免组件之间尴尬的绑定，在</em> **render ** <em class="kd">函数和</em>函数中绑定这一点以及arrow函数动态做的其他事情。所有这些加起来提高了应用程序的性能。</p></div></div>    
</body>
</html>