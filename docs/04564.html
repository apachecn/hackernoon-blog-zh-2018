<html>
<head>
<title>A pull to refresh you can call your own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可以称之为自己的提神剂</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-pull-to-refresh-you-can-call-your-own-6609870a1806?source=collection_archive---------68-----------------------#2018-05-29">https://medium.com/hackernoon/a-pull-to-refresh-you-can-call-your-own-6609870a1806?source=collection_archive---------68-----------------------#2018-05-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7f23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在22.1.0中引入的SwipeToRefreshLayout已经成为许多现代<a class="ae jp" href="https://hackernoon.com/tagged/android" rel="noopener ugc nofollow" target="_blank"> Android </a>应用程序中的主要部分。这是我利用ValueAnimator和Android Touch框架创建一个简单的SwipeToRefreshLayout克隆的尝试。</p><p id="dedf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们首先总结一下本教程中使用的Android touch框架中的两个函数:<strong class="it hv">oninterceptouchevent</strong>和<strong class="it hv"> onTouchEvent </strong>。</p><ul class=""><li id="2fec" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><strong class="it hv">oninterceptouchevent</strong>允许<a class="ae jp" href="https://hackernoon.com/tagged/viewgroup" rel="noopener ugc nofollow" target="_blank">视图组</a>来“拦截”一个触摸事件，并决定是将其传递给其子对象还是自己消费该事件。因此，这个函数是ViewGroup的一部分，而不是View。</li><li id="987e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv"> onTouchEvent </strong>同时存在于View和ViewGroup类中。在Viewgroup类中，只有当父类决定不将触摸事件传递给它的子类时，才会调用这个函数(例如，它在onInterceptTouchEvent上传递true)。然而，在孩子中，当孩子接收到来自其父母的触摸事件时，这被调用。</li></ul><p id="98a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种从父节点到子节点过滤触摸事件的流程可以用来创建一个非常基本的刷新视图，这在许多应用程序中都可以看到。</p><p id="899b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的定制拉入更新工作方式如下:</p><p id="3527" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果用户在可滚动视图(例如RecycleView)上向下滚动，则不需要刷新视图。因此，父视图组对触摸事件不感兴趣，并将其传递给子视图组。(onInterceptTouchEvent = false)。</p><p id="1b60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，如果用户向上滚动，我们的场景就会分成两部分。第一个更简单的场景是用户还没有到达recycleview的顶部，因此我们不需要“刷新视图”。(onInterceptTouchEvent = false)。</p><p id="f78c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二种情况是当用户到达顶部并试图进一步向上滚动时。这将触发刷新视图出现。因此，仅在这种情况下，父节点对触摸事件感兴趣，不会将其传递给子节点，而是触发自己的onTouchEvent。(onInterceptTouchEvent = true)。</p><p id="b6d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事不宜迟，让我们直入主题吧。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ke"><img src="../Images/b11e686e5d463c15950d7e3df32e0cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*quVkuI0ndTV7_IJNkS-T1A.gif"/></div></figure><p id="2b78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们创建一个自定义拉的框架来刷新父级。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">AnimatedPullToRefreshLayout Skeleton</figcaption></figure><p id="13b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于任何基本的拉至刷新模式，父级(在本例中为:AnimatedPullToRefreshLayout)必须确定可滚动的子级当前是否在顶部。确定这一点的最简单方法是在父级的onLayout回调中将scrollListener附加到子级</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">onLayout Implementation</figcaption></figure><p id="1b54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">setOnScrollListener用于设置onTopReached，它表示子节点的状态(是在顶部还是在其他位置)。</p><p id="10a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，附加一个scrollListener本身是不够的，因为onTopReached也在oninterceptouchevent中使用，并且一旦它在onScrollListener中被设置为true，oninterceptouchevent就不会让触摸事件传播到子节点。因此，我们还必须跟踪触摸事件的y坐标。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">onInterceptTouchEvent Implementation</figcaption></figure><p id="6de2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在父节点决定处理touchEvent的情况下，将在父节点中触发onTouchEvent。onTouchEvent负责呈现自定义拉取以刷新逻辑。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">onTouchEvent Implementation</figcaption></figure><p id="4c1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在前面代码块的ACTION_MOVE事件中，增加子视图的上边距会显示framelayout下层中的“刷新视图”。当用户将手指从设备上松开时，或者当触发UI线程中刷新逻辑的后台任务完成时，必须收回刷新视图。(例如API调用)。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="km kn l"/></div><figcaption class="ko kp fg fe ff kq kr bd b be z ek">stopLoading Implementation</figcaption></figure><p id="251b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">应用程序中使用的xml:</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="km kn l"/></div></figure><p id="938f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个小演示让你大吃一惊。尽情享受吧！</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/1d1ea6808ef2a8450a3b81c91d4a1eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*AV5DrnW1ctMq4f1s0g1rbg.gif"/></div></figure></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><p id="9073" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="la">我希望你喜欢我的定制拉动更新视图。我希望下次能见到你。</em></p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="lb kn l"/></div></figure></div></div>    
</body>
</html>