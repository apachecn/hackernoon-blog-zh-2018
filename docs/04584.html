<html>
<head>
<title>Utilizing Cryptography Libraries to Derive Ethereum Addresses from Private Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用加密库从私钥中导出以太坊地址</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/utilizing-cryptography-libraries-to-derive-ethereum-addresses-from-private-keys-1bedd1a85bd?source=collection_archive---------9-----------------------#2018-05-30">https://medium.com/hackernoon/utilizing-cryptography-libraries-to-derive-ethereum-addresses-from-private-keys-1bedd1a85bd?source=collection_archive---------9-----------------------#2018-05-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/fae0ceddfd2dda73198e540ed60bc869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSdhaTJV0zzq88OAX095JA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="583c" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">对于没有数学倾向的开发人员</h2></div><p id="29bf" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><a class="ae kq" href="https://hackernoon.com/tagged/cryptocurrency" rel="noopener ugc nofollow" target="_blank">密码学</a>是<a class="ae kq" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>和加密货币世界中一切的核心。它用于创建哈希指针，使区块链成为可能，并为钱包创建密钥对！</p><p id="fbf0" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在本教程中，我们将使用'<strong class="jw ig">椭圆</strong>和'<strong class="jw ig"> js-sha3 </strong> ' javascript库，以便利用椭圆曲线加密(ECC)的原理从私钥中导出公钥，然后将公钥转换为其对应的以太坊地址。</p><p id="8061" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">许多在线资源从数学角度介绍了椭圆曲线加密，但没有提供适用的代码示例。作为一名程序员，我发现看到方程被分解成易于理解的代码片段可以将这些原则牢牢记住。在深入研究代码之前，让我们先了解一下什么是椭圆曲线加密，为什么它在以太坊生态系统中被认为是安全的，以及如何使用它来生成密钥对。</p><h1 id="cbed" class="kr ks if bd kt ku kv kw kx ky kz la lb jl lc jm ld jo le jp lf jr lg js lh li dt translated"><strong class="ak">什么是椭圆曲线密码？</strong></h1><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/4ee4b3a8a4c8238fa0fa01ab1abd446b.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*KKdvscN4y-NcGZ8Nnx1ZYQ.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Elliptic Curve Example</figcaption></figure><p id="b0d3" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">椭圆曲线加密是一种非对称加密形式，它利用椭圆曲线的离散对数问题(ECDSA)来创建公钥和私钥对。本质上，在一个方向上执行操作很容易，但在另一个方向上执行操作的计算开销非常大。</p><p id="127e" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><strong class="jw ig">有可能从公钥找到私钥吗？</strong></p><p id="af29" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">公钥是作为使用椭圆曲线乘法将<strong class="jw ig">私钥(k) </strong>乘以<strong class="jw ig">生成点(G) </strong>以获得<strong class="jw ig">公钥(K)的结果而生成的。</strong></p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="c34e" class="lx ks if lt b fv ly lz l ma mb"><strong class="lt ig">K = k * G</strong></span></pre><p id="2910" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在<em class="mc">标准整数运算</em>中，如果我们知道<strong class="jw ig"> K </strong>和<strong class="jw ig"> g，</strong>我们可以简单地将<strong class="jw ig"> K </strong>除以<strong class="jw ig"> g </strong>以得到<strong class="jw ig"> k </strong>。换句话说，将公钥除以生成点将很容易得到私钥。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="e9dc" class="lx ks if lt b fv ly lz l ma mb"><strong class="lt ig">k = K / G</strong></span></pre><p id="cadf" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">椭圆曲线算术<strong class="jw ig">没有</strong> <strong class="jw ig">有除法</strong>，因此被认为是单向数学函数。通过将导致<strong class="jw ig"> K、</strong>的所有可能因子相乘，在技术上有可能找到私钥<strong class="jw ig">T5，但是，涉及的数字越大，计算时间就越长。要了解更多信息，我推荐阅读安德烈亚斯·m·安东诺普洛斯和加文·伍德的书<a class="ae kq" href="https://github.com/ethereumbook/ethereumbook/blob/develop/keys-addresses.asciidoc#elliptic_curve." rel="noopener ugc nofollow" target="_blank">掌握以太坊</a>中的这一部分。</strong></p><h1 id="656f" class="kr ks if bd kt ku kv kw kx ky kz la lb jl lc jm ld jo le jp lf jr lg js lh li dt translated"><strong class="ak">概述</strong></h1><p id="9677" class="pw-post-body-paragraph ju jv if jw b jx md jg jz ka me jj kc kd mf kf kg kh mg kj kk kl mh kn ko kp hn dt translated">如前所述，<strong class="jw ig"> K = k * G </strong>实际上是椭圆曲线上的另一个点。因此，<strong class="jw ig"> K = (x，y) </strong>其中x和y是它的坐标<strong class="jw ig">。</strong></p><p id="c800" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">要将生成的公钥(<strong class="jw ig"> K) </strong>转换成相应的以太坊地址，我们必须通过<strong class="jw ig"> Keccak-256 </strong>加密散列函数来运行它。产生的散列的最后20个字节组成了我们的以太坊地址。</p><h1 id="148b" class="kr ks if bd kt ku kv kw kx ky kz la lb jl lc jm ld jo le jp lf jr lg js lh li dt translated"><strong class="ak">让我们跳进代码里吧！</strong></h1><p id="78a7" class="pw-post-body-paragraph ju jv if jw b jx md jg jz ka me jj kc kd mf kf kg kh mg kj kk kl mh kn ko kp hn dt translated">首先，让我们设置我们的项目。(如果您已经习惯于设置节点项目，可以跳到下一部分。)</p><p id="84b4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">打开我们的终端，为我们的代码创建一个目录。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="35a0" class="lx ks if lt b fv ly lz l ma mb">mkdir deriveEthAddress</span></pre><p id="33b9" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">然后，使用以下命令进入该目录:</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="d7ff" class="lx ks if lt b fv ly lz l ma mb">cd deriveEthAddress</span></pre><p id="746c" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">为了能够npm安装我们将使用的模块，运行</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="51a4" class="lx ks if lt b fv ly lz l ma mb">npm init</span></pre><p id="0802" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">并根据需要填写提示。</p><p id="67b2" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">接下来，让npm安装‘elliptic’和‘js-sha3’库。<strong class="jw ig"> Elliptic </strong>是一个javascript库，具有各种椭圆曲线加密函数，<strong class="jw ig"> js-sha3 </strong>为我们提供了一个我们将要使用的散列函数。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="3301" class="lx ks if lt b fv ly lz l ma mb">npm install elliptic --save &amp;&amp; npm install js-sha3 --save</span></pre><p id="6f30" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">最后，我们创建项目文件。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="a91f" class="lx ks if lt b fv ly lz l ma mb">touch deriveEthAddress.js</span></pre><h2 id="e717" class="lx ks if bd kt mi mj mk kx ml mm mn lb kd mo mp ld kh mq mr lf kl ms mt lh mu dt translated">现在我们的项目已经设置好了，在文本编辑器中打开deriveEthAddress.js。</h2><p id="84a1" class="pw-post-body-paragraph ju jv if jw b jx md jg jz ka me jj kc kd mf kf kg kh mg kj kk kl mh kn ko kp hn dt translated">在deriveEthAddress.js中，我们将需要我们安装的模块。下面，我们使用预设的<strong class="jw ig"> secp256k1 </strong>(以太坊和比特币都使用的特定椭圆曲线)创建一个新的椭圆曲线实例。我们还需要来自<strong class="jw ig"> js-sha3的<strong class="jw ig"> keccak256 </strong>哈希函数。</strong></p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="620c" class="lx ks if lt b fv ly lz l ma mb">// Required Modules<br/><strong class="lt ig">const </strong>EC = require('elliptic').ec;<br/><strong class="lt ig">const </strong>ec = <strong class="lt ig">new </strong>EC('secp256k1');<br/><strong class="lt ig">const </strong>keccak256 = require('js-sha3').keccak256;</span></pre><p id="39d4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">然后，我们将为我们的私钥和以太坊地址创建变量。(该密钥对仅用于测试，不应用于存储实际资金。这是从Ganache CLI中获取的-更多信息请参见<a class="ae kq" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> github repo </a>。)</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="f2cb" class="lx ks if lt b fv ly lz l ma mb">// Private Key and Public Ethereum address (from Ganache)<br/><strong class="lt ig">const </strong>givenPrivateKey = 'c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3';<br/><strong class="lt ig">const </strong>givenEthAddress = '0x627306090abab3a6e1400e9345bc60c78a8bef57';</span></pre><p id="682a" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">接下来，我们将利用等式<strong class="jw ig"> K = k * G. </strong>从secp256k1椭圆曲线实例中获得我们的生成点(<strong class="jw ig"> G) </strong>。<code class="eh mv mw mx lt b">generatorPoint</code>再乘以<code class="eh mv mw mx lt b">privateKey </code> ( <strong class="jw ig"> k </strong>)。这导致了<code class="eh mv mw mx lt b">pubKeyCoordinates</code> ( <strong class="jw ig"> K </strong>)。正如我们之前讨论的，<strong class="jw ig"> K = (x，y)，</strong>所以我们提取坐标x和y，并将其转换为十六进制字符串进行连接。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="b4a7" class="lx ks if lt b fv ly lz l ma mb">// Get secp256k1 generator point<br/><strong class="lt ig">const </strong>generatorPoint = ec.g;<br/><br/>// Public Key Coordinates calculated via Elliptic Curve Multiplication<br/>// PublicKeyCoordinates = privateKey * generatorPoint<br/><strong class="lt ig">const </strong>pubKeyCoordinates = generatorPoint.mul(givenPrivateKey);<br/><br/><strong class="lt ig">const </strong>x = pubKeyCoordinates.getX().toString('hex');<br/><strong class="lt ig">const </strong>y = pubKeyCoordinates.getY().toString('hex');<br/><br/>// Public Key = X and Y concatenated<br/><strong class="lt ig">const </strong>publicKey = x + y;</span><span id="bb50" class="lx ks if lt b fv my lz l ma mb">console.log(publicKey);<br/>//af80b90d25145da28c583359beb47b21796b2fe1a23c1511e443e7a64dfdb27d7434c380f0aa4c500e220aa1a9d068514b1ff4d5019e624e7ba1efe82b340a59</span></pre><p id="1480" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">然后，我们必须通过<strong class="jw ig"> keccak256 </strong>散列函数运行我们的公钥。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="b921" class="lx ks if lt b fv ly lz l ma mb">// Use Keccak-256 hash function to get public key hash<br/><strong class="lt ig">const </strong>hashOfPublicKey = keccak256(<strong class="lt ig">new </strong>Buffer(publicKey, 'hex'));</span><span id="34f5" class="lx ks if lt b fv my lz l ma mb">console.log(hashOfPublicKey);<br/>// 3f704e8b0ee605967f55081f627306090abab3a6e1400e9345bc60c78a8bef57</span></pre><p id="723c" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">如果我们看看我们的散列，最后20个字节(也就是最后40位)组成了我们的以太坊地址！让我们把它转换成一个缓冲区，这样我们就可以截取我们想要使用的字节，并把它转换成一个十六进制字符串。然后我们可以添加十六进制前缀<code class="eh mv mw mx lt b">0x</code>。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="15e6" class="lx ks if lt b fv ly lz l ma mb">// Convert hash to buffer<br/><strong class="lt ig">const </strong>ethAddressBuffer = <strong class="lt ig">new </strong>Buffer(hashOfPublicKey, 'hex');<br/><br/>// Ethereum Address is '0x' concatenated with last 20 bytes<br/>// of the public key hash<br/><strong class="lt ig">const </strong>ethAddress = ethAddressBuffer.slice(-20).toString('hex');<br/><strong class="lt ig">const </strong>ethAddressWithPrefix = `0x${ethAddress}`;</span></pre><p id="33f7" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">最后，让我们将我们的派生地址与我们被告知的私钥对应的地址进行比较。</p><pre class="lk ll lm ln fq ls lt lu lv aw lw dt"><span id="adc1" class="lx ks if lt b fv ly lz l ma mb">// Ethereum Address derived from private key<br/>// is equal to the given address<br/>console.log(ethAddressWithPrefix === givenEthAddress);</span><span id="f0d5" class="lx ks if lt b fv my lz l ma mb">// true</span></pre><p id="f9ea" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">匹配了！这是完整的例子-</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="mz na l"/></div></figure></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><h1 id="a6ba" class="kr ks if bd kt ku ni kw kx ky nj la lb jl nk jm ld jo nl jp lf jr nm js lh li dt translated"><strong class="ak">关闭</strong></h1><p id="a6c0" class="pw-post-body-paragraph ju jv if jw b jx md jg jz ka me jj kc kd mf kf kg kh mg kj kk kl mh kn ko kp hn dt translated">我们只讨论了椭圆曲线加密的基本原理。也就是说，应用于以太网的数学概念非常简单，并且有许多库可以帮助我们！</p><p id="a5a4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><em class="mc">感谢阅读！如果你觉得这个有用，给一个</em> <strong class="jw ig"> <em class="mc">下面拍拍</em> </strong> <em class="mc">和</em> <strong class="jw ig"> <em class="mc">关注</em> </strong> <em class="mc">我，获取更多Javascript和区块链相关文章。</em></p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="nn na l"/></div></figure></div></div>    
</body>
</html>