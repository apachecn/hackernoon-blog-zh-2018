<html>
<head>
<title>5 Advanced Go Testing Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5种高级围棋测试技术</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/5-advanced-go-testing-techniques-7199b686b6c1?source=collection_archive---------6-----------------------#2018-05-31">https://medium.com/hackernoon/5-advanced-go-testing-techniques-7199b686b6c1?source=collection_archive---------6-----------------------#2018-05-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/030d442facc856970d53d56f2dc70b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_Z5dQRwX9SsPS-WTqIBGw.png"/></div></div></figure><h2 id="ab3e" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">工程师艾伦·布莱斯维特</h2><blockquote class="kb kc kd"><p id="19a5" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">这篇文章最初出现在<a class="ae ka" href="https://bit.ly/2J0mhcp" rel="noopener ugc nofollow" target="_blank">板块博客</a>上。<a class="ae ka" href="https://segment.com/?utm_source=hacker%20noon%20blog%20post" rel="noopener ugc nofollow" target="_blank"> Segment </a>，Hacker Noon的每周赞助商，目前提供90天的免费试用——发送电子邮件至friends@segment，并提及Hacker Noon进行兑换。</p></blockquote><p id="f662" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">Go有一个健壮的内置测试库。如果你写Go，你就已经知道这个了。在这篇文章中，我们将讨论一些提高围棋水平的策略。我们从大型Go代码库的经验中了解到，这些策略可以节省维护代码的时间和精力。</p><h1 id="4c82" class="ld jd hu bd je le lf lg ji lh li lj jm lk ll lm jq ln lo lp ju lq lr ls jy lt dt translated">使用测试套件</h1><p id="b1a4" class="pw-post-body-paragraph ke kf hu kh b ki lu kk kl km lv ko kp jn lw ks kt jr lx kw kx jv ly la lb lc hn dt translated">如果你从这篇文章中只学到一件事，那就是:使用测试套件。对于那些不熟悉该模式的人来说，套件测试是针对一个通用接口开发测试的过程，该接口可用于该接口的多个实现。下面，您可以看到我们如何传递多个不同的<code class="eh lz ma mb mc b">Thinger</code>实现，并让它们运行相同的测试。</p><pre class="md me mf mg fq mh mc mi mj aw mk dt"><span id="3670" class="jc jd hu mc b fv ml mm l mn mo">type Thinger interface {<br/>    DoThing(input string) (Result, error)<br/>}</span><span id="7a20" class="jc jd hu mc b fv mp mm l mn mo">// Suite tests all the functionality that Thingers should implement<br/>func Suite(t *testing.T, impl Thinger) {<br/>    res, _ := impl.DoThing("thing")<br/>    if res != expected {<br/>        t.Fail("unexpected result")<br/>    }<br/>}</span><span id="047c" class="jc jd hu mc b fv mp mm l mn mo">// TestOne tests the first implementation of Thinger<br/>func TestOne(t *testing.T) {<br/>    one := one.NewOne()<br/>    Suite(t, one)<br/>}</span><span id="bdf7" class="jc jd hu mc b fv mp mm l mn mo">// TestOne tests another implementation of Thinger<br/>func TestTwo(t *testing.T) {<br/>    two := two.NewTwo()<br/>    Suite(t, two)<br/>}</span></pre><p id="6ad8" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">幸运的读者可能使用过使用这种技术的代码库。经常在基于插件的系统中使用，针对接口编写的测试可被该接口的所有实现使用，以确定是否满足行为要求。</p><p id="1a44" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">使用这个策略可能会节省几个小时、几天，或者甚至足够的时间来解决P对NP的问题。此外，当交换两个底层系统时，您不必编写(许多)额外的测试，并且它提供了这样做不会破坏您的应用程序的信心。这隐含地要求您创建一个定义您正在测试的表面区域的接口。使用依赖注入，您可以从您的包中设置套件，并为包传递实现。</p><p id="1277" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">此处提供了一个完整的示例<a class="ae ka" href="https://github.com/segmentio/testdemo" rel="noopener ugc nofollow" target="_blank">。虽然这个例子是精心设计的，但是您可以想象一个实现是远程数据库，而另一个是内存数据库。</a></p><p id="90a1" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">标准库中另一个极好的例子是<code class="eh lz ma mb mc b">golang.org/x/net/nettest</code>包。它提供了验证<code class="eh lz ma mb mc b">net.Conn</code>是否满足其接口的方法。</p><h1 id="e113" class="ld jd hu bd je le lf lg ji lh li lj jm lk ll lm jq ln lo lp ju lq lr ls jy lt dt translated">避免界面污染</h1><p id="be15" class="pw-post-body-paragraph ke kf hu kh b ki lu kk kl km lv ko kp jn lw ks kt jr lx kw kx jv ly la lb lc hn dt translated">不谈接口，就谈不上Go中的测试。</p><p id="3cc8" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">接口在测试环境中很重要，因为它们是我们测试武器库中最强大的工具，所以正确使用它们很重要。包经常导出一个接口供消费者使用，这反过来导致:a .消费者实现他们自己的包实现的模拟，或者b .包导出他们自己的模拟。</p><blockquote class="mq"><p id="5545" class="mr ms hu bd mt mu mv mw mx my mz lc ek translated"><em class="na">界面越大，抽象性越弱。</em></p><p id="7b45" class="mr ms hu bd mt mu mv mw mx my mz lc ek translated"><em class="na"> —抢长枪，走箴言</em></p></blockquote><p id="7de2" class="pw-post-body-paragraph ke kf hu kh b ki nb kk kl km nc ko kp jn nd ks kt jr ne kw kx jv nf la lb lc hn dt translated">在导出接口之前，应该仔细考虑它们。开发人员通常倾向于导出接口，作为消费者模仿其行为的一种方式。相反，记录您的结构满足哪些接口，这样您就不会在消费者包和您自己的包之间创建硬依赖关系。一个很好的例子就是<a class="ae ka" href="https://godoc.org/github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank">错误包</a>。</p><p id="f3cd" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">当我们的程序中有一个我们不想导出的接口时，可以使用一个<code class="eh lz ma mb mc b"><a class="ae ka" href="https://golang.org/doc/go1.4#internalpackages" rel="noopener ugc nofollow" target="_blank">internal/</a></code> <a class="ae ka" href="https://golang.org/doc/go1.4#internalpackages" rel="noopener ugc nofollow" target="_blank">包子树</a>来保持它在包范围内。通过这样做，我们消除了其他消费者可能依赖它的顾虑，因此可以随着新需求的出现而灵活地发展接口。我们通常围绕外部依赖创建接口，并使用依赖注入，这样我们就可以在本地运行测试。</p><p id="496b" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">这使得消费者能够实现他们自己的小接口，只包装库的消费表面用于他们自己的测试。关于这个概念的更多细节，参见<a class="ae ka" href="https://rakyll.org/interface-pollution/" rel="noopener ugc nofollow" target="_blank"> rakyll关于界面污染的帖子</a>。</p><h1 id="4d35" class="ld jd hu bd je le lf lg ji lh li lj jm lk ll lm jq ln lo lp ju lq lr ls jy lt dt translated">不要导出并发原语</h1><p id="c57e" class="pw-post-body-paragraph ke kf hu kh b ki lu kk kl km lv ko kp jn lw ks kt jr lx kw kx jv ly la lb lc hn dt translated">Go提供了易于使用的并发原语，这有时也会导致它们的过度使用。我们主要关心渠道和<code class="eh lz ma mb mc b">sync</code>包。有时从您的包中导出一个频道供消费者使用是很诱人的。此外，嵌入<code class="eh lz ma mb mc b">sync.Mutex</code>而不使其私有是一个常见的错误。和任何事情一样，这并不总是坏的，但是当测试你的程序时，它确实带来了挑战。</p><p id="c1ab" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">如果您正在导出渠道，您会将软件包的消费者暴露在他们不应该关心的额外复杂性中。一旦从包中导出了一个通道，您就开始了对使用该通道的测试的挑战。为了做好测试，消费者需要知道:</p><ul class=""><li id="f9cb" class="ng nh hu kh b ki kj km kn jn ni jr nj jv nk lc nl nm nn no dt translated">当数据在信道上发送完毕时</li><li id="b2a8" class="ng nh hu kh b ki np km nq jn nr jr ns jv nt lc nl nm nn no dt translated">接收数据时是否有任何错误</li><li id="f442" class="ng nh hu kh b ki np km nq jn nr jr ns jv nt lc nl nm nn no dt translated">如果有的话，包在完成后如何清理通道？</li><li id="e0f8" class="ng nh hu kh b ki np km nq jn nr jr ns jv nt lc nl nm nn no dt translated">如何在包API周围包装一个接口，这样就不用直接调用了？</li></ul><p id="26d9" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">考虑一个读取队列的例子。这是一个示例库，它从队列中读取数据，并公开了一个供消费者读取的通道。</p><pre class="md me mf mg fq mh mc mi mj aw mk dt"><span id="1c4c" class="jc jd hu mc b fv ml mm l mn mo">type Reader struct {...}<br/>func (r *Reader) ReadChan() &lt;-chan Msg {...}</span></pre><p id="08b0" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">现在，您的库的一个用户想要为他们的消费者实现一个测试:</p><pre class="md me mf mg fq mh mc mi mj aw mk dt"><span id="ae3b" class="jc jd hu mc b fv ml mm l mn mo">func TestConsumer(t testing.T) {<br/>    cons := &amp;Consumer{<br/>        r: libqueue.NewReader(),<br/>    }<br/>    for msg := range cons.r.ReadChan() {<br/>        // Test thing.<br/>    }<br/>}</span></pre><p id="af66" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">然后，用户可能会认为依赖注入是一个好主意，并沿着通道编写自己的消息:</p><pre class="md me mf mg fq mh mc mi mj aw mk dt"><span id="cac0" class="jc jd hu mc b fv ml mm l mn mo">func TestConsumer(t testing.T, q queueIface) {<br/>    cons := &amp;Consumer{<br/>        r: q,<br/>    }<br/>    for msg := range cons.r.ReadChan() {<br/>        // Test thing.<br/>    }<br/>}</span></pre><p id="dae2" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">但是等等，错误怎么办？</p><pre class="md me mf mg fq mh mc mi mj aw mk dt"><span id="50bb" class="jc jd hu mc b fv ml mm l mn mo">func TestConsumer(t testing.T, q queueIface) {<br/>    cons := &amp;Consumer{<br/>        r: q,<br/>    }<br/>    for {<br/>        select {<br/>        case msg := &lt;-cons.r.ReadChan():<br/>            // Test thing.<br/>        case err := &lt;-cons.r.ErrChan():<br/>            // What caused this again?<br/>        }<br/>    }<br/>}</span></pre><p id="64bb" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">现在，我们如何生成事件来实际写入这个模拟，充分复制我们正在使用的实际库的行为？如果这个库只是简单地写了一个同步API，那么我们可以在我们的客户端代码中添加所有这些并发性，这样测试起来就简单多了。</p><pre class="md me mf mg fq mh mc mi mj aw mk dt"><span id="5113" class="jc jd hu mc b fv ml mm l mn mo">func TestConsumer(t testing.T, q queueIface) {<br/>    cons := &amp;Consumer{<br/>        r: q,<br/>    }<br/>    msg, err := cons.r.ReadMsg()<br/>    // handle err, test thing<br/>}</span></pre><p id="567d" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">如果有疑问，请记住，在消费包中添加并发总是很容易的，一旦从库中导出，就很难/不可能删除。最后，不要忘记在包文档中提到一个结构/包对于多个goroutines的并发访问是否安全！</p><p id="7a87" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">有时，导出通道仍然是可取的或必要的。为了缓解上面的一些问题，您可以通过访问器而不是直接公开通道，并强制它们在声明中成为只读(<code class="eh lz ma mb mc b">←chan</code>)或只写(<code class="eh lz ma mb mc b">chan←</code>)通道。</p><h1 id="6500" class="ld jd hu bd je le lf lg ji lh li lj jm lk ll lm jq ln lo lp ju lq lr ls jy lt dt translated">使用<code class="eh lz ma mb mc b">net/http/httptest</code></h1><p id="c3bc" class="pw-post-body-paragraph ke kf hu kh b ki lu kk kl km lv ko kp jn lw ks kt jr lx kw kx jv ly la lb lc hn dt translated"><code class="eh lz ma mb mc b">httptest</code>允许你运行你的<code class="eh lz ma mb mc b">http.Handler</code>代码，而不需要实际启动服务器或者绑定端口。这加快了测试的速度，并允许它们以更少的工作量并行运行。</p><p id="d86e" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">这里有一个使用两种方法实现的相同测试的例子。它看起来不怎么样，但是它为您节省了相当多的代码和资源。</p><pre class="md me mf mg fq mh mc mi mj aw mk dt"><span id="4f06" class="jc jd hu mc b fv ml mm l mn mo">func TestServe(t *testing.T) {<br/>    // The method to use if you want to practice typing<br/>    s := &amp;http.Server{<br/>        Handler: http.HandlerFunc(ServeHTTP),<br/>    }<br/>    // Pick port automatically for parallel tests and to avoid conflicts<br/>    l, err := net.Listen("tcp", ":0")<br/>    if err != nil {<br/>        t.Fatal(err)<br/>    }<br/>    defer l.Close()<br/>    go s.Serve(l)</span><span id="5045" class="jc jd hu mc b fv mp mm l mn mo">    res, err := http.Get("http://" + l.Addr().String() + "/?sloths=arecool")<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    greeting, err := ioutil.ReadAll(res.Body)<br/>    res.Body.Close()<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    fmt.Println(string(greeting))<br/>}</span><span id="07ad" class="jc jd hu mc b fv mp mm l mn mo">func TestServeMemory(t *testing.T) {<br/>    // Less verbose and more flexible way<br/>    req := httptest.NewRequest("GET", "http://example.com/?sloths=arecool", nil)<br/>    w := httptest.NewRecorder()</span><span id="0e97" class="jc jd hu mc b fv mp mm l mn mo">    ServeHTTP(w, req)<br/>    greeting, err := ioutil.ReadAll(w.Body)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    fmt.Println(string(greeting))<br/>}</span></pre><p id="ebea" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">也许使用<code class="eh lz ma mb mc b">httptest</code>带给你的最大好处是能够将你的测试划分为你想要测试的功能。没有路由器，中间件或任何其他副作用来自建立服务器，服务，处理器工厂，处理器工厂工厂或任何你以前认为是好的想法扔给你。</p><p id="a723" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">要了解更多这种模式的应用，请看马克·伯格的文章。</p><h1 id="545b" class="ld jd hu bd je le lf lg ji lh li lj jm lk ll lm jq ln lo lp ju lq lr ls jy lt dt translated">使用单独的<code class="eh lz ma mb mc b">_test</code>包装</h1><p id="8251" class="pw-post-body-paragraph ke kf hu kh b ki lu kk kl km lv ko kp jn lw ks kt jr lx kw kx jv ly la lb lc hn dt translated">生态系统中的大多数测试都是在文件<code class="eh lz ma mb mc b">pkg_test.go</code>中创建的，但是仍然在同一个包<code class="eh lz ma mb mc b">package pkg</code>中。一个单独的测试包是您在一个新文件<code class="eh lz ma mb mc b">foo_test.go</code>中创建的包，在您想要测试的包<code class="eh lz ma mb mc b">foo/</code>的目录中，声明<code class="eh lz ma mb mc b">package foo_test</code>。从那里，您可以导入<code class="eh lz ma mb mc b">github.com/example/foo</code>和其他依赖项。这个特性支持很多事情。对于测试中的循环依赖，这是推荐的解决方法，它防止了脆弱的测试，并且它允许开发人员感受消费他们自己的包是什么感觉。如果你的包很难使用，那么用这种方法测试也很难。</p><p id="cebe" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">这种策略通过限制对私有变量的访问来防止脆弱的测试。特别是，如果您的测试中断了，并且您正在使用一个单独的测试包，那么几乎可以保证使用中断了测试的特性的客户端在被调用时也会中断。</p><p id="cf8a" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">最后，这有助于避免测试中的导入周期。除了那些被测试的包之外，大多数包很可能依赖于你编写的其他包，所以你最终会遇到一个情况，一个导入周期作为一个自然的结果发生。在包层次结构中，外部包位于两个包之上。以Go编程语言(Chp)为例。11秒2.4)，<code class="eh lz ma mb mc b">net/url</code>实现了一个URL解析器，<code class="eh lz ma mb mc b">net/http</code>导入它以供使用。然而，<code class="eh lz ma mb mc b">net/url</code>希望通过导入<code class="eh lz ma mb mc b">net/http</code>来使用真实用例进行测试。于是<code class="eh lz ma mb mc b">net/url_test</code>诞生了。</p><p id="3ed7" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">既然您正在使用一个单独的测试包，您可能需要访问包中未导出的实体，而这些实体以前是可以访问的。大多数人在测试基于时间的东西时首先点击这个(例如<code class="eh lz ma mb mc b">time.Now</code>通过一个函数被模仿)。在这种情况下，我们可以使用一个额外的文件在测试期间专门暴露它们，因为<code class="eh lz ma mb mc b">_test.go</code>文件被排除在常规构建之外。</p><h1 id="33ed" class="ld jd hu bd je le lf lg ji lh li lj jm lk ll lm jq ln lo lp ju lq lr ls jy lt dt translated">要记住的东西</h1><p id="a01b" class="pw-post-body-paragraph ke kf hu kh b ki lu kk kl km lv ko kp jn lw ks kt jr lx kw kx jv ly la lb lc hn dt translated">重要的是要记住，以上建议的方法都不是灵丹妙药。最佳解决方案是始终对情况进行批判性分析，并决定适合问题的最佳解决方案。</p><p id="35ab" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">想学习更多的围棋测试技巧吗？</p><p id="391d" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">看看这些帖子:</p><ul class=""><li id="323b" class="ng nh hu kh b ki kj km kn jn ni jr nj jv nk lc nl nm nn no dt translated">Dave Cheney编写Go中的表格驱动测试</li><li id="35d0" class="ng nh hu kh b ki np km nq jn nr jr ns jv nt lc nl nm nn no dt translated"><a class="ae ka" href="http://www.gopl.io/" rel="noopener ugc nofollow" target="_blank">关于测试的Go编程语言章节。</a></li></ul><p id="cbbe" class="pw-post-body-paragraph ke kf hu kh b ki kj kk kl km kn ko kp jn kr ks kt jr kv kw kx jv kz la lb lc hn dt translated">或者这些视频:</p><ul class=""><li id="f756" class="ng nh hu kh b ki kj km kn jn ni jr nj jv nk lc nl nm nn no dt translated"><a class="ae ka" href="https://www.youtube.com/watch?v=yszygk1cpEc" rel="noopener ugc nofollow" target="_blank">桥本的高级测试与Gophercon 2017的Go talk】</a></li><li id="5346" class="ng nh hu kh b ki np km nq jn nr jr ns jv nt lc nl nm nn no dt translated">【2014年Andrew Gerrand的测试技术讲座</li></ul></div><div class="ab cl nu nv hc nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="hn ho hp hq hr"><blockquote class="kb kc kd"><p id="12cf" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">这篇文章最初出现在<a class="ae ka" href="https://bit.ly/2J0mhcp" rel="noopener ugc nofollow" target="_blank">栏目博客</a>上。Hacker Noon的每周赞助商<a class="ae ka" href="https://segment.com/?utm_source=hacker%20noon%20blog%20post" rel="noopener ugc nofollow" target="_blank"> Segment </a>，目前提供90天免费试用——发送电子邮件至friends@segment，并提及Hacker Noon进行兑换。</p></blockquote></div></div>    
</body>
</html>