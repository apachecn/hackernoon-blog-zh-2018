<html>
<head>
<title>Deploying GitLab Review Apps with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform部署GitLab Review应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-terraform-for-gitlab-review-apps-acf05920a264?source=collection_archive---------9-----------------------#2018-05-31">https://medium.com/hackernoon/using-terraform-for-gitlab-review-apps-acf05920a264?source=collection_archive---------9-----------------------#2018-05-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9cdf78b44a761a3fbf9fe95c7320bba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FP2DrlfcZpqdn5kqwtHww.png"/></div></div></figure><div class=""/><p id="b189" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GitLab Review Apps 是一种管理动态环境的便捷方式，用于在合并到您的主分支之前审查变更。GitLab拥有强大的Kubernetes支持，可以轻松地部署到您的集群中，但是如果您的应用程序没有很好地容器化，或者您的团队没有准备好接受Kubernetes，您该怎么办？你这个地球人！</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="65a1" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">将（行星）地球化（以适合人类居住）</h1><p id="0625" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">Terraform 是一款优秀的云无关工具，用于将基础设施开发为代码。通过结合Terraform的几个特性，我们可以很容易地构建一个部署评论应用的系统。</p><h2 id="6ace" class="ll kj if bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">1.工作区</h2><p id="7986" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><a class="ae ka" href="https://www.terraform.io/docs/state/workspaces.html" rel="noopener ugc nofollow" target="_blank">工作区</a>提供了一种配置和管理多套相同基础设施的方法，无需复制Terraform配置文件。如果您熟悉Terraform及其<code class="eh lz ma mb mc b">.tfstate</code>文件，您可以将工作区视为创建和管理新的任意命名的<code class="eh lz ma mb mc b">.tfstate</code>文件。</p><p id="15cc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，<code class="eh lz ma mb mc b">terraform workspace new $BRANCH</code>创建了一个新的工作空间，用环境变量<code class="eh lz ma mb mc b">$BRANCH</code>的值来命名。这创建了一个新的空白<code class="eh lz ma mb mc b">.tfstate</code>，意味着<code class="eh lz ma mb mc b">terraform apply</code>将提供一组新的资源，这些资源独立于任何其他工作区管理的任何资源。</p><h2 id="4c64" class="ll kj if bd kk lm ln lo ko lp lq lr ks jn ls lt kw jr lu lv la jv lw lx le ly dt translated">2.远程状态</h2><p id="4461" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><a class="ae ka" href="https://www.terraform.io/docs/state/remote.html" rel="noopener ugc nofollow" target="_blank">远程状态</a>是一种跨多台机器持久化地形状态的方法，通过将<code class="eh lz ma mb mc b">.tfstate</code>文件存储在几个受支持的远程存储机制之一，如亚马逊S3。虽然这最常用于允许人们在基础设施上协作工作，但它可以很容易地在GitLab作业中使用，以提供和跟踪由Terraform管理的基础设施。</p><p id="ec85" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的关键是远程状态持久化工作区，允许GitLab CI/CD跨不同的作业引用为每个分支创建的工作区，这些作业将在不同的时间从不同的机器上运行。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="3282" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">GitLab CI/CD</h1><p id="3c0a" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">这个的<code class="eh lz ma mb mc b">.gitlab-ci.yml</code>配置非常简单，但是有几个关键点。</p><figure class="md me mf mg fq hw"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="df59" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有三个重要的配置，都在<code class="eh lz ma mb mc b">environment</code>模块中。</p><ol class=""><li id="f329" class="mj mk if je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh lz ma mb mc b">name</code>是环境本身的动态构建名称。在这种情况下，它基于<code class="eh lz ma mb mc b">CI_COMMIT_REF_SLUG</code>变量，该变量是分支名称的URL友好表示。</li><li id="4d19" class="mj mk if je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh lz ma mb mc b">url</code>是GitLab关联到环境的URL。请注意，GitLab不会为此创建DNS记录，而是由您自己来创建。</li><li id="980f" class="mj mk if je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh lz ma mb mc b">on_stop</code>告诉GitLab当分支被关闭或环境被手动停止时应该触发哪个作业，从而完成了使这成为一个<em class="mx">评审应用</em>而不仅仅是一个动态命名的环境。</li></ol></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="f3f9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">配置的<code class="eh lz ma mb mc b">script</code>部分是Terraform的用武之地。</p><p id="b9c3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要将Terraform配置存储在这个存储库之外，因为我们需要配置文件在分支关闭后可用。</p><p id="6b94" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在克隆这个存储库时引用一个特定的Git标记是必要的，这样可以确保用于提供这些应用程序的基础设施不会在您不知道的情况下发生变化。</p><p id="542e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如前所述，Terraform Workspaces是一个重要的功能，它使使用Terraform查看应用程序成为可能。我们可以定义运行应用程序所需的基础设施，然后使用<em class="mx">工作区</em>来管理该基础设施的独立副本。</p><pre class="md me mf mg fq my mc mz na aw nb dt"><span id="291f" class="ll kj if mc b fv nc nd l ne nf">terraform workspace select $CI_COMMIT_REF_SLUG || terraform workspace new $CI_COMMIT_REF_SLUG</span></pre><p id="0832" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们选择以值<code class="eh lz ma mb mc b">$CI_COMMIT_REF_SLUG</code>命名的工作区，如果它不存在，我们就创建它。这确保了我们可以从单个分支多次运行<code class="eh lz ma mb mc b">StartReview</code>作业，而不会出现问题。</p><p id="ef98" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">脚本的其余部分是一个标准的<code class="eh lz ma mb mc b">terraform apply</code>，后面是一些特定于CodeDeploy的内容。我不打算在本文中讨论部署细节，因为有许多工具可以用来做这件事，但是如果你对设置CodeDeploy <a class="ae ka" href="https://hackernoon.com/deploy-to-ec2-with-aws-codedeploy-from-bitbucket-pipelines-4f403e96d50c" rel="noopener ugc nofollow" target="_blank">感兴趣，我在过去曾经写过相关的文章</a>。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="5ffc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb mc b">StopReview</code>的工作与<code class="eh lz ma mb mc b">StartReview</code>非常相似。</p><figure class="md me mf mg fq hw"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="de22" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">设置为<code class="eh lz ma mb mc b">none</code>的<code class="eh lz ma mb mc b">GIT_STRATEGY</code>环境变量确保GitLab在运行该作业时不会试图克隆分支。这是必要的，因为此作业可能在分支关闭后运行，因此没有任何内容可克隆。</p><p id="a388" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb mc b">action: stop</code>和<code class="eh lz ma mb mc b">name</code>属性的组合告诉GitLab这个作业应该在哪个环境中停止。这里的<code class="eh lz ma mb mc b">name</code>需要与<code class="eh lz ma mb mc b">StartReview</code>中设置的<code class="eh lz ma mb mc b">name</code>相匹配。</p><p id="ef00" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到脚本，我们再次用前面使用的相同标签克隆Terraform存储库。</p><p id="b72c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们选择与该分支机构对应的Terraform工作区(如果我们正在运行该作业，则已经创建了该工作区),并运行<code class="eh lz ma mb mc b">terraform destroy -auto-approve</code>来取消为该分支机构的审核应用程序创建的基础架构。</p><p id="97c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了清理一切，我们然后切换<code class="eh lz ma mb mc b">default</code>工作区并删除我们为这个分支创建的工作区。Terraform不允许你删除当前选中的工作空间，这也是我们需要切换回<code class="eh lz ma mb mc b">default</code>的原因。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="5245" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，您应该拥有可以根据分支机构名称随意动态调配的基础架构，然后在分支机构关闭时随意销毁或自动销毁。在此基础上集成您选择的部署工具将为您提供具有自己的基础设施的全功能评审应用程序，即使您的应用程序尚未为Kubernetes做好准备。</p><p id="a8b7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">跟随<a class="ng nh gr" href="https://medium.com/u/bc152e4dcd63?source=post_page-----acf05920a264--------------------------------" rel="noopener" target="_blank"> Jared Ready </a>获得更多DevOps好处！</p><p id="4243" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">👏如果你喜欢这本书！</p></div></div>    
</body>
</html>