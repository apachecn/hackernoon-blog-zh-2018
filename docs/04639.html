<html>
<head>
<title>Build a ride sharing iOS app with push notifications.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个带有推送通知的乘车共享iOS应用程序。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-ride-sharing-ios-app-with-push-notifications-96a5e2324cc?source=collection_archive---------9-----------------------#2018-06-01">https://medium.com/hackernoon/build-a-ride-sharing-ios-app-with-push-notifications-96a5e2324cc?source=collection_archive---------9-----------------------#2018-06-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="f483" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">要学习本教程，您需要一台安装了Xcode的Mac、Xcode和Swift的知识、JavaScript(包括Node.js)的基础知识、一个Pusher帐户和安装在您机器上的Cocoapods。</p></blockquote><p id="dc22" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">像<a class="ae jw" href="https://uber.com" rel="noopener ugc nofollow" target="_blank">优步</a>和<a class="ae jw" href="https://lyft.com" rel="noopener ugc nofollow" target="_blank"> Lyft </a>这样的拼车应用可以让乘客向他们所在地区的司机请求搭车。当乘客请求搭车时，应用程序会尽快找到司机。如果乘客在等待时关闭了应用程序，他们需要一种方式来通知他们汽车正在路上，一旦汽车到达，他们就会再次收到通知。</p><p id="ca38" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在本文中，我们将创建一个简单的虚拟乘车共享应用程序，重点关注如何集成Pusher的Beams API来提供事务性推送通知。</p><p id="6ba0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将制作两个iOS应用程序来满足司机和骑手的需求，并制作一个Node.js应用程序来支持他们。然后，我们将添加推送通知，提醒司机有新的乘车请求，并提醒乘客他们有司机在路上，一旦他们到达。</p><h1 id="de8b" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">先决条件</h1><ul class=""><li id="dfe7" class="kv kw hu ix b iy kx jc ky jt kz ju la jv lb js lc ld le lf dt translated">安装了Xcode的Mac。<a class="ae jw" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank">在这里下载Xcode】。</a></li><li id="208c" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">Xcode使用知识。</li><li id="405c" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated"><a class="ae jw" href="https://developer.apple.com/swift/" rel="noopener ugc nofollow" target="_blank">迅捷</a>的知识。</li><li id="8233" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">推销账户。<a class="ae jw" href="http://pusher.com" rel="noopener ugc nofollow" target="_blank">在这里创建一个</a>。</li><li id="8e64" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">一个谷歌地图API密钥。<a class="ae jw" href="https://developers.google.com/maps/documentation/ios-sdk/get-api-key" rel="noopener ugc nofollow" target="_blank">在这里创建一个</a>。</li><li id="b2f0" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">JavaScript/Node.js基础知识(<a class="ae jw" href="https://www.w3schools.com/nodejs/default.asp" rel="noopener ugc nofollow" target="_blank">查看本教程</a>)。</li><li id="7d5a" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">安装在您的机器上的Cocoapods <a class="ae jw" href="https://guides.cocoapods.org/using/getting-started.html" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><p id="c35d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">一旦有了要求，就开始吧。</p><h1 id="67e1" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">关于我们的应用</h1><p id="007c" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">在本教程中，我们将制作三个应用程序:</p><ul class=""><li id="bb1c" class="kv kw hu ix b iy iz jc jd jt lo ju lp jv lq js lc ld le lf dt translated">后端应用程序(使用Node.js的Web)。这将是两个iOS应用程序的动力之家。它将包含应用程序正常运行所需的所有端点。它还将负责向各个设备发送推送通知。</li><li id="6c8d" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">骑手应用程序(使用Swift的iOS)。这将是骑手用来请求乘车的应用程序。</li><li id="725f" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">驱动程序应用程序(使用Swift的iOS)。这将是司机用来接受乘客请求的应用程序。驾驶员将能够根据情况更新游乐设备的状态。</li></ul><p id="f966" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这是我们完成后的屏幕录像:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff lr"><img src="../Images/548dc782328fc68406d9ecb5abda2b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bQtPGsJOOEnY2UhjqnR3zA.gif"/></div></div></figure><blockquote class="ir is it"><p id="5acf" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡我们不会过多关注拼车功能，但我们将主要关注如何将推送通知集成到应用程序中。</em></p></blockquote><h1 id="5016" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">构建后端应用程序(API)</h1><p id="a56b" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">我们首先要构建的是API。我们将添加支持我们的iOS应用程序所需的一切，然后在稍后添加推送通知。</p><p id="3bf3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，为API创建一个项目目录。在目录中，创建一个名为<code class="eh md me mf mg b">package.json</code>的新文件，并在文件中粘贴以下内容:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="6019" class="ml jy hu mg b fv mm mn l mo mp">{<br/>      "main": "index.js",<br/>      "scripts": {},<br/>      "dependencies": {<br/>        "body-parser": "^1.18.2",<br/>        "express": "^4.16.2",<br/>        "pusher": "^1.5.1",<br/>        "pusher-push-notifications-node": "^0.10.1"<br/>      }<br/>    }</span></pre><p id="5c87" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，在您的终端中运行以下命令:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="8e31" class="ml jy hu mg b fv mm mn l mo mp">$ npm install</span></pre><p id="0a8f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将安装所有列出的依赖项。接下来，在与<code class="eh md me mf mg b">package.json</code>文件相同的目录下创建一个<code class="eh md me mf mg b">index.js</code>文件，并粘贴以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="cbe3" class="ml jy hu mg b fv mm mn l mo mp">// --------------------------------------------------------<br/>    // Pull in the libraries<br/>    // --------------------------------------------------------</span><span id="fd26" class="ml jy hu mg b fv mq mn l mo mp">    const app = require('express')()<br/>    const bodyParser = require('body-parser')<br/>    const config = require('./config.js')<br/>    const Pusher = require('pusher')<br/>    const pusher = new Pusher({<br/>        appId: 'PUSHER_APP_ID',<br/>        key: 'PUSHER_APP_KEY',<br/>        secret: 'PUSHER_APP_SECRET',<br/>        cluster: 'PUSHER_APP_CLUSTER',<br/>        encrypted: true<br/>    })</span><span id="6419" class="ml jy hu mg b fv mq mn l mo mp">    // --------------------------------------------------------<br/>    // In-memory database<br/>    // --------------------------------------------------------</span><span id="0388" class="ml jy hu mg b fv mq mn l mo mp">    let rider = null<br/>    let driver = null<br/>    let user_id = null<br/>    let status = "Neutral"</span><span id="ea7c" class="ml jy hu mg b fv mq mn l mo mp">    // --------------------------------------------------------<br/>    // Express Middlewares<br/>    // --------------------------------------------------------</span><span id="2f80" class="ml jy hu mg b fv mq mn l mo mp">    app.use(bodyParser.json())<br/>    app.use(bodyParser.urlencoded({extended: false}))</span><span id="f6b0" class="ml jy hu mg b fv mq mn l mo mp">    // --------------------------------------------------------<br/>    // Helpers<br/>    // --------------------------------------------------------</span><span id="513c" class="ml jy hu mg b fv mq mn l mo mp">    function uuidv4() {<br/>        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {<br/>            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r &amp; 0x3 | 0x8);<br/>            return v.toString(16);<br/>        });<br/>    }</span><span id="1677" class="ml jy hu mg b fv mq mn l mo mp">    // --------------------------------------------------------<br/>    // Routes<br/>    // --------------------------------------------------------</span><span id="d8e7" class="ml jy hu mg b fv mq mn l mo mp">    // ----- Rider --------------------------------------------</span><span id="4221" class="ml jy hu mg b fv mq mn l mo mp">    app.get('/status', (req, res) =&gt; res.json({ status }))</span><span id="6566" class="ml jy hu mg b fv mq mn l mo mp">    app.get('/request', (req, res) =&gt; res.json(driver))</span><span id="751d" class="ml jy hu mg b fv mq mn l mo mp">    app.post('/request', (req, res) =&gt; {<br/>        user_id = req.body.user_id<br/>        status = "Searching"<br/>        rider = { name: "Jane Doe", longitude: -122.088426, latitude: 37.388064 }</span><span id="cf97" class="ml jy hu mg b fv mq mn l mo mp">        pusher.trigger('cabs', 'status-update', { status, rider })<br/>        res.json({ status: true })</span><span id="ffca" class="ml jy hu mg b fv mq mn l mo mp">    })<br/>    app.delete('/request', (req, res) =&gt; {<br/>        driver = null<br/>        status = "Neutral"<br/>        pusher.trigger('cabs', 'status-update', { status })<br/>        res.json({ status: true })<br/>    })</span><span id="4ba2" class="ml jy hu mg b fv mq mn l mo mp">    // ----- Driver ------------------------------------------</span><span id="5990" class="ml jy hu mg b fv mq mn l mo mp">    app.get('/pending-rider', (req, res) =&gt; res.json(rider))</span><span id="9de9" class="ml jy hu mg b fv mq mn l mo mp">    app.post('/status', (req, res) =&gt; {<br/>        status = req.body.status</span><span id="85dc" class="ml jy hu mg b fv mq mn l mo mp">        if (status == "EndedTrip" || status == "Neutral") {<br/>            rider = driver = null<br/>        } else {<br/>            driver = { name: "John Doe" }<br/>        }</span><span id="c5c5" class="ml jy hu mg b fv mq mn l mo mp">        pusher.trigger('cabs', 'status-update', { status, driver })<br/>        res.json({ status: true })<br/>    })</span><span id="4800" class="ml jy hu mg b fv mq mn l mo mp">    // ----- Misc ---------------------------------------------</span><span id="7c1a" class="ml jy hu mg b fv mq mn l mo mp">    app.get('/', (req, res) =&gt; res.json({ status: "success" }))</span><span id="89b6" class="ml jy hu mg b fv mq mn l mo mp">    // --------------------------------------------------------<br/>    // Serve application<br/>    // --------------------------------------------------------</span><span id="5d33" class="ml jy hu mg b fv mq mn l mo mp">    app.listen(4000, _ =&gt; console.log('App listening on port 4000!'))</span></pre><blockquote class="ir is it"><p id="1522" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡您需要将</em> <code class="eh md me mf mg b"><em class="hu">PUSHER_APP_*</em></code> <em class="hu">键替换为推杆仪表板上的真实键。</em></p></blockquote><p id="7510" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们首先获取应用程序运行所需的所有依赖项。接下来，我们设置一些变量来保存数据，作为内存中的数据存储。然后我们定义一个UUID生成器函数，我们将使用它来生成对象的ID。接下来，我们定义我们的应用程序路线:</p><ul class=""><li id="d70e" class="kv kw hu ix b iy iz jc jd jt lo ju lp jv lq js lc ld le lf dt translated"><code class="eh md me mf mg b">POST /request</code>保存对驱动程序的新请求。</li><li id="59da" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated"><code class="eh md me mf mg b">GET /request</code>获取处理请求的驱动程序。</li><li id="b228" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated">取消搭车请求。</li><li id="01df" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated"><code class="eh md me mf mg b">GET /pending-order</code>获取挂起的请求。</li><li id="fff4" class="kv kw hu ix b iy lg jc lh jt li ju lj jv lk js lc ld le lf dt translated"><code class="eh md me mf mg b">POST /status</code>改变游乐设备的状态。</li></ul><p id="ced4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这就是我们现在在API中所需要的，当我们需要发送推送通知时，我们将再次访问它。如果您想测试API是否正常工作，那么在您的终端上运行以下命令:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="cc1a" class="ml jy hu mg b fv mm mn l mo mp">$ node index.js</span></pre><p id="c109" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将启动一个监听端口<strong class="ix hv"> 4000 </strong>的新节点服务器。</p><h1 id="1207" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">构建骑士应用程序</h1><p id="57d9" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">我们需要做的下一件事是构建客户端应用程序。启动Xcode并创建一个新的“单一应用程序”项目。我们将把这个项目命名为<strong class="ix hv"> RiderClient。</strong></p><p id="f87d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">项目创建完成后，退出Xcode，在刚刚创建的Xcode项目的根目录下创建一个名为<code class="eh md me mf mg b">Podfile</code>的新文件。在文件中粘贴以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="4453" class="ml jy hu mg b fv mm mn l mo mp">platform :ios, '11.0'<br/><br/>    target 'RiderClient' do<br/>      use_frameworks!<br/>      pod 'GoogleMaps', '~&gt; 2.6.0'<br/>      pod 'PusherSwift', '~&gt; 5.1.1'<br/>      pod 'Alamofire', '~&gt; 4.6.0'<br/>    end</span></pre><p id="6fd7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的文件中，我们指定了项目需要运行的依赖项。<strong class="ix hv">记得把上面的</strong> <code class="eh md me mf mg b"><strong class="ix hv">target</strong></code> <strong class="ix hv">改成你项目的名字。</strong>现在，在您的终端中，运行以下命令来安装依赖项:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="b5cc" class="ml jy hu mg b fv mm mn l mo mp">$ pod install</span></pre><p id="9fc4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">安装完成后，打开由Cocoapods生成的Xcode工作空间文件。这将重新启动Xcode。</p><p id="7979" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当Xcode重新启动后，打开<code class="eh md me mf mg b">Main.storyboard</code>文件，在那里我们将为我们的客户端应用程序创建故事板。下面是我们如何设计故事板的截图:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mr"><img src="../Images/f5dc54d897c0fb850a68817c635bd572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3ZRMdwb_kSUaNXuDAkyvw.png"/></div></div></figure><p id="c882" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在主视图控制器中，我们定义了显示游乐设备状态、驾驶员详细信息和CTA按钮的视图。</p><blockquote class="ir is it"><p id="a164" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡CTA是</em> <strong class="ix hv"> <em class="hu">号召行动</em> </strong> <em class="hu">的缩写。</em></p></blockquote><p id="c59e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在Xcode中创建一个名为<code class="eh md me mf mg b">MainController.swift</code>的新文件，并将其作为上面主视图控制器的自定义类。接下来粘贴以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="0144" class="ml jy hu mg b fv mm mn l mo mp">import UIKit<br/>    import Alamofire<br/>    import GoogleMaps</span><span id="f08f" class="ml jy hu mg b fv mq mn l mo mp">    class MainViewController: UIViewController, GMSMapViewDelegate {<br/>        var latitude = 37.388064<br/>        var longitude = -122.088426<br/>        var locationMarker: GMSMarker!</span><span id="883d" class="ml jy hu mg b fv mq mn l mo mp">        @IBOutlet weak var mapView: GMSMapView!<br/>        @IBOutlet weak var loadingIndicator: UIActivityIndicatorView!<br/>        @IBOutlet weak var loadingOverlay: UIView!<br/>        @IBOutlet weak var orderButton: UIButton!<br/>        @IBOutlet weak var orderStatusView: UIView!<br/>        @IBOutlet weak var orderStatus: UILabel!<br/>        @IBOutlet weak var cancelButton: UIButton!<br/>        @IBOutlet weak var driverDetailsView: UIView!</span><span id="0334" class="ml jy hu mg b fv mq mn l mo mp">        override func viewDidLoad() {<br/>            super.viewDidLoad()<br/>            mapView.camera = GMSCameraPosition.camera(withLatitude:latitude, longitude:longitude, zoom:15.0)<br/>            mapView.delegate = self<br/>            locationMarker = GMSMarker(position: CLLocationCoordinate2D(latitude: latitude, longitude: longitude))<br/>            locationMarker.map = mapView<br/>            orderStatusView.layer.cornerRadius = 5<br/>            orderStatusView.layer.shadowOffset = CGSize(width: 0, height: 0)<br/>            orderStatusView.layer.shadowColor = UIColor.black.cgColor<br/>            orderStatusView.layer.shadowOpacity = 0.3</span><span id="df98" class="ml jy hu mg b fv mq mn l mo mp">            updateView(status: .Neutral, msg: nil)<br/>        }<br/>    }</span></pre><p id="a1e6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们有视图控制器类。在<code class="eh md me mf mg b">viewDidLoad</code>我们建立了谷歌地图，并调用了<code class="eh md me mf mg b">updateView</code>方法。<code class="eh md me mf mg b">updateView</code>方法是一个辅助函数，它只是根据<code class="eh md me mf mg b">RideStatus</code>改变显示的视图。将方法添加到类中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="b2a3" class="ml jy hu mg b fv mm mn l mo mp">private func updateView(status: RideStatus, msg: String?) {<br/>        switch status {<br/>        case .Neutral:<br/>            driverDetailsView.isHidden = true<br/>            loadingOverlay.isHidden = true<br/>            orderStatus.text = msg != nil ? msg! : "💡 Tap the button below to get a cab."<br/>            orderButton.setTitleColor(UIColor.white, for: .normal)<br/>            orderButton.isHidden = false<br/>            cancelButton.isHidden = true<br/>            loadingIndicator.stopAnimating()</span><span id="ee44" class="ml jy hu mg b fv mq mn l mo mp">        case .Searching:<br/>            loadingOverlay.isHidden = false<br/>            orderStatus.text = msg != nil ? msg! : "🚕 Looking for a cab close to you..."<br/>            orderButton.setTitleColor(UIColor.clear, for: .normal)<br/>            loadingIndicator.startAnimating()<br/>        case .FoundRide, .Arrival:<br/>            driverDetailsView.isHidden = false<br/>            loadingOverlay.isHidden = true</span><span id="dc8c" class="ml jy hu mg b fv mq mn l mo mp">            if status == .FoundRide {<br/>                orderStatus.text = msg != nil ? msg! : "😎 Found a ride, your ride is on it's way"<br/>            } else {<br/>                orderStatus.text = msg != nil ? msg! : "⏰ Your driver is waiting, please meet outside."<br/>            }</span><span id="dd4d" class="ml jy hu mg b fv mq mn l mo mp">            orderStatus.text = msg != nil ? msg! : "😎 Found a ride, your ride is on it's way"<br/>            orderButton.isHidden = true<br/>            cancelButton.isHidden = false<br/>            loadingIndicator.stopAnimating()<br/>        case .OnTrip:<br/>            orderStatus.text = msg != nil ? msg! : "🙂 Your ride is in progress. Enjoy."<br/>            cancelButton.isEnabled = false<br/>        case .EndedTrip:<br/>            orderStatus.text = msg != nil ? msg! : "🌟 Ride complete. Have a nice day!"<br/>            orderButton.setTitleColor(UIColor.white, for: .normal)<br/>            driverDetailsView.isHidden = true<br/>            cancelButton.isEnabled = true<br/>            orderButton.isHidden = false<br/>            cancelButton.isHidden = true<br/>        }<br/>    }</span></pre><p id="5327" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来是调用向API发送请求的<code class="eh md me mf mg b">sendRequest</code>方法的<code class="eh md me mf mg b">orderButtonPressed</code>方法。下一个方法是<code class="eh md me mf mg b">cancelButtonPressed</code>，它也调用<code class="eh md me mf mg b">sendRequest</code>方法。</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="88d2" class="ml jy hu mg b fv mm mn l mo mp">@IBAction func orderButtonPressed(_ sender: Any) {<br/>        updateView(status: .Searching, msg: nil)<br/><br/>        sendRequest(.post) { successful in<br/>            guard successful else {<br/>                return self.updateView(status: .Neutral, msg: "😔 No drivers available.")<br/>            }<br/>        }<br/>    }<br/><br/>    @IBAction func cancelButtonPressed(_ sender: Any) {<br/>        sendRequest(.delete) { successful in<br/>            guard successful == false else {<br/>                return self.updateView(status: .Neutral, msg: nil)<br/>            }<br/>        }<br/>    }<br/><br/>    private func sendRequest(_ method: HTTPMethod, handler: @escaping(Bool) -&gt; Void) {<br/>        let url = AppConstants.API_URL + "/request"<br/>        let params = ["user_id": AppConstants.USER_ID]<br/><br/>        Alamofire.request(url, method: method, parameters: params)<br/>            .validate()<br/>            .responseJSON { response in<br/>                guard response.result.isSuccess,<br/>                    let data = response.result.value as? [String:Bool],<br/>                    let status = data["status"] else { return handler(false) }<br/><br/>                handler(status)<br/>            }<br/>    }</span></pre><h1 id="cc0c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">使用Pusher集成实时更新</h1><p id="7857" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">接下来，让我们给视图控制器添加一些推送功能，这样它就可以实时获取对<code class="eh md me mf mg b">RideStatus</code>的更改。</p><p id="5499" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，您需要<code class="eh md me mf mg b">import</code>Pusher swift SDK:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="fa5a" class="ml jy hu mg b fv mm mn l mo mp">import PusherSwift</span></pre><p id="68f2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后在类的顶部定义<code class="eh md me mf mg b">pusher</code>变量:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="64bc" class="ml jy hu mg b fv mm mn l mo mp">let pusher = Pusher(<br/>        key: AppConstants.PUSHER_API_KEY,<br/>        options: PusherClientOptions(host: .cluster(AppConstants.PUSHER_API_CLUSTER))<br/>    )</span></pre><p id="a23b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，将以下方法添加到该类中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="0b1d" class="ml jy hu mg b fv mm mn l mo mp">private func listenForUpdates() {<br/>        let channel = pusher.subscribe("cabs")<br/><br/>        let _ = channel.bind(eventName: "status-update") { data in<br/>            if let data = data as? [String:AnyObject] {<br/>                if let status = data["status"] as? String, <br/>                let rideStatus = RideStatus(rawValue: status) {<br/>                    self.updateView(status: rideStatus, msg: nil)<br/>                }<br/>            }<br/>        }<br/><br/>        pusher.connect()<br/>    }</span></pre><p id="9b60" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面的方法只是订阅了一个Pusher通道，并绑定到通道上的<code class="eh md me mf mg b">status-update</code>事件。当事件被触发时，调用<code class="eh md me mf mg b">updateView</code>方法。</p><p id="e714" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后在<code class="eh md me mf mg b">viewDidLoad</code>方法的底部，添加一个对<code class="eh md me mf mg b">listenForUpdates</code>方法的调用:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="59dc" class="ml jy hu mg b fv mm mn l mo mp">listenForUpdates()</span></pre><p id="0c26" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，当后端应用程序触发一个状态更新事件时，我们的rider应用程序将获取它，并根据需要更改UI。</p><h1 id="9c99" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置谷歌地图</h1><p id="7d2c" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">接下来，打开您的<code class="eh md me mf mg b">AppDelegate</code>类并导入以下内容:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="7631" class="ml jy hu mg b fv mm mn l mo mp">import GoogleMaps</span></pre><p id="f627" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，您可以用以下代码替换<code class="eh md me mf mg b">application(didFinishLaunchingWithOptions:)</code>方法:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="72ad" class="ml jy hu mg b fv mm mn l mo mp">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {<br/>        GMSServices.provideAPIKey(AppConstants.GOOGLE_API_KEY)<br/>        return true<br/>    }</span></pre><h1 id="c8a6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">定义密钥和乘坐状态</h1><p id="9744" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">创建一个名为<code class="eh md me mf mg b">AppConstants.swift</code>的新文件，并粘贴以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="9b62" class="ml jy hu mg b fv mm mn l mo mp">import Foundation</span><span id="b412" class="ml jy hu mg b fv mq mn l mo mp">    class AppConstants {<br/>        static let GOOGLE_API_KEY = "GOOGLE_MAPS_API_KEY"<br/>        static let PUSHER_API_KEY = "PUSHER_APP_KEY"<br/>        static let PUSHER_API_CLUSTER = "PUSHER_APP_CLUSTER"<br/>        static let API_URL = "http://127.0.0.1:4000"<br/>        static let USER_ID = UUID().uuidString<br/>    }</span></pre><blockquote class="ir is it"><p id="3bd0" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">⚠️您需要用各自仪表板中的实际值替换上面的占位符。</p></blockquote><p id="31a5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，创建一个名为<code class="eh md me mf mg b">RideStatus.swift</code>的文件，我们将在这里定义所有可用的游乐设备状态:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="c3a9" class="ml jy hu mg b fv mm mn l mo mp">import Foundation<br/><br/>    enum RideStatus: String {<br/>        case Neutral = "Neutral"<br/>        case Searching = "Searching"<br/>        case FoundRide = "FoundRide"<br/>        case Arrived = "Arrived"<br/>        case OnTrip = "OnTrip"<br/>        case EndedTrip = "EndedTrip"<br/>    }</span></pre><p id="1e2c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这就是客户端应用程序的全部内容。让我们继续创建Rider应用程序。</p><p id="1a8d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们需要做的最后一件事是修改<code class="eh md me mf mg b">info.plist</code>文件。我们需要在<code class="eh md me mf mg b">plist</code>文件中添加一个条目，以允许连接到我们的本地服务器:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff ms"><img src="../Images/dd2b1f47a2b0f361ef0a0695bba2e24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9fjgt3fWphj1p2D0.png"/></div></div></figure><p id="2fea" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们转到rider应用程序。</p><h1 id="d557" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">构建驱动程序应用程序</h1><p id="30a4" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">启动Xcode并创建一个新的“单一应用程序”项目。我们将把我们的项目命名为<strong class="ix hv"> RiderDriver。</strong></p><p id="0fcc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">项目创建完成后，退出Xcode，在刚刚创建的Xcode项目的根目录下创建一个名为<code class="eh md me mf mg b">Podfile</code>的新文件。在文件中粘贴以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="7f6f" class="ml jy hu mg b fv mm mn l mo mp">platform :ios, '11.0'<br/><br/>    target 'RiderDriver' do<br/>      use_frameworks!<br/>      pod 'PusherSwift', '~&gt; 5.1.1'<br/>      pod 'Alamofire', '~&gt; 4.6.0'<br/>      pod 'GoogleMaps', '~&gt; 2.6.0'<br/>      pod 'PushNotifications'<br/>    end</span></pre><p id="acd4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的文件中，我们指定了项目需要运行的依赖项。<strong class="ix hv">记得把上面的</strong> <code class="eh md me mf mg b"><strong class="ix hv">target</strong></code> <strong class="ix hv">改成你项目的名字。</strong>现在在您的终端中，运行以下命令来安装依赖项:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="4549" class="ml jy hu mg b fv mm mn l mo mp">$ pod install</span></pre><p id="c769" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">安装完成后，打开由Cocoapods生成的Xcode工作空间文件。这将重新启动Xcode。</p><p id="f32a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当Xcode重新启动后，打开<code class="eh md me mf mg b">Main.storyboard</code>文件，在那里我们将为我们的客户端应用程序创建故事板。下面是我们如何设计故事板的截图:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mt"><img src="../Images/49facf88721cfb979520e7e86d0c498d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FuScyTCWuJAixtseiS6ycg.png"/></div></div></figure><p id="6a43" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在主视图控制器中，我们定义了显示骑手信息的视图，以及改变游乐设备状态所需的按钮。我们还有一个隐藏的视图，当没有未决请求时将会显示。</p><p id="5eb5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在Xcode中创建一个名为<code class="eh md me mf mg b">MainController.swift</code>的新文件，并将其作为上面主视图控制器的自定义类。接下来粘贴以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="b6b5" class="ml jy hu mg b fv mm mn l mo mp">import UIKit<br/>    import Alamofire<br/>    import GoogleMaps</span><span id="c127" class="ml jy hu mg b fv mq mn l mo mp">    class MainViewController: UIViewController, GMSMapViewDelegate {<br/>        var status: RideStatus!<br/>        var locationMarker: GMSMarker!</span><span id="6dbe" class="ml jy hu mg b fv mq mn l mo mp">        @IBOutlet weak var riderName: UILabel!    <br/>        @IBOutlet weak var mapView: GMSMapView!<br/>        @IBOutlet weak var requestView: UIView!<br/>        @IBOutlet weak var noRequestsView: UIView!<br/>        @IBOutlet weak var cancelButton: UIButton!<br/>        @IBOutlet weak var statusButton: UIButton!</span><span id="077f" class="ml jy hu mg b fv mq mn l mo mp">        override func viewDidLoad() {<br/>            super.viewDidLoad()<br/>            status = .Neutral<br/>            requestView.isHidden = true<br/>            cancelButton.isHidden = true<br/>            noRequestsView.isHidden = false<br/>            Timer.scheduledTimer(<br/>                timeInterval: 2,<br/>                target: self,<br/>                selector: #selector(findNewRequests),<br/>                userInfo: nil,<br/>                repeats: true<br/>            )<br/>        }<br/>    }</span></pre><p id="4a5d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><code class="eh md me mf mg b">viewDidLoad</code>设置用户界面的初始设置。然后我们注册一个每2秒触发一次<code class="eh md me mf mg b">findNewRequests</code>方法的定时器。让我们来定义这个方法。将下面的方法添加到类中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="25f2" class="ml jy hu mg b fv mm mn l mo mp">@objc private func findNewRequests() {<br/>        guard status == .Neutral else { return }</span><span id="92b7" class="ml jy hu mg b fv mq mn l mo mp">        Alamofire.request(AppConstants.API_URL + "/pending-rider")<br/>            .validate()<br/>            .responseJSON { response in<br/>                guard response.result.isSuccess,<br/>                    let data = response.result.value as? [String:AnyObject] else { return }</span><span id="743f" class="ml jy hu mg b fv mq mn l mo mp">                self.loadRequestForRider(Rider(data: data))<br/>            }<br/>    }</span></pre><p id="e4f0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">该方法将向后端发送一个请求，如果有挂起的请求，它会将其加载到UI。但是，除非游乐设备状态为<code class="eh md me mf mg b">Neutral</code>，否则不会触发请求。</p><p id="d1ff" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来让我们定义当有一个待定的乘坐请求时调用的<code class="eh md me mf mg b">loadRequestsForRider</code>方法:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="7ce9" class="ml jy hu mg b fv mm mn l mo mp">private func loadRequestForRider(_ rider: Rider) {<br/>        mapView.camera = GMSCameraPosition.camera(withLatitude:rider.latitude, longitude:rider.longitude, zoom:15.0)<br/>        mapView.delegate = self</span><span id="6e5e" class="ml jy hu mg b fv mq mn l mo mp">        locationMarker = GMSMarker(position: CLLocationCoordinate2D(latitude: rider.latitude, longitude: rider.longitude))<br/>        locationMarker.map = mapView</span><span id="3d8a" class="ml jy hu mg b fv mq mn l mo mp">        status = .Searching<br/>        cancelButton.isHidden = false<br/>        statusButton.setTitle("Accept Trip", for: .normal)</span><span id="8b53" class="ml jy hu mg b fv mq mn l mo mp">        riderName.text = rider.name<br/>        requestView.isHidden = false<br/>        noRequestsView.isHidden = true<br/>    }</span></pre><p id="20c2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">该方法只需使用发出请求的骑手的经度和纬度来加载谷歌地图。然后，它还准备UI来显示请求。</p><p id="0eb8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来要定义的方法是根据各种事件改变游乐设备状态和更新UI的方法:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="3091" class="ml jy hu mg b fv mm mn l mo mp">private func sendStatusChange(_ status: RideStatus, handler: @escaping(Bool) -&gt; Void) {<br/>        let url = AppConstants.API_URL+"/status"<br/>        let params = ["status": status.rawValue]</span><span id="95fd" class="ml jy hu mg b fv mq mn l mo mp">        Alamofire.request(url, method: .post, parameters: params).validate()<br/>            .responseJSON { response in<br/>                guard response.result.isSuccess,<br/>                    let data = response.result.value as? [String: Bool] else { return handler(false) }</span><span id="fa25" class="ml jy hu mg b fv mq mn l mo mp">                handler(data["status"]!)<br/>            }<br/>    }</span><span id="3b0e" class="ml jy hu mg b fv mq mn l mo mp">    private func getNextStatus(after status: RideStatus) -&gt; RideStatus {<br/>        switch self.status! {<br/>        case .Neutral,<br/>                .Searching: return .FoundRide<br/>        case .FoundRide: return .Arrived<br/>        case .Arrived: return .OnTrip<br/>        case .OnTrip: return .EndedTrip<br/>        case .EndedTrip: return .Neutral<br/>        }<br/>    }</span><span id="dff3" class="ml jy hu mg b fv mq mn l mo mp">    @IBAction func cancelButtonPressed(_ sender: Any) {<br/>        if status == .FoundRide || status == .Searching {<br/>            sendStatusChange(.Neutral) { successful in<br/>                if successful {<br/>                    self.status = .Neutral<br/>                    self.requestView.isHidden = true<br/>                    self.noRequestsView.isHidden = false<br/>                }<br/>            }<br/>        }<br/>    }</span><span id="22a5" class="ml jy hu mg b fv mq mn l mo mp">    @IBAction func statusButtonPressed(_ sender: Any) {<br/>        let nextStatus = getNextStatus(after: self.status)</span><span id="2416" class="ml jy hu mg b fv mq mn l mo mp">        sendStatusChange(nextStatus) { successful in<br/>            self.status = self.getNextStatus(after: nextStatus)</span><span id="3e21" class="ml jy hu mg b fv mq mn l mo mp">            switch self.status! {<br/>            case .Neutral, .Searching:<br/>                self.cancelButton.isHidden = true<br/>            case .FoundRide:<br/>                self.cancelButton.isHidden = false<br/>                self.statusButton.setTitle("Announce Arrival", for: .normal)<br/>            case .Arrived:<br/>                self.cancelButton.isHidden = false<br/>                self.statusButton.setTitle("Start Trip", for: .normal)<br/>            case .OnTrip:<br/>                self.cancelButton.isHidden = true<br/>                self.statusButton.setTitle("End Trip", for: .normal)<br/>            case .EndedTrip:<br/>                self.status = .Neutral<br/>                self.noRequestsView.isHidden = false<br/>                self.requestView.isHidden = true<br/>                self.statusButton.setTitle("Accept Trip", for: .normal)<br/>            }<br/>        }<br/>    }</span></pre><p id="4993" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><code class="eh md me mf mg b">sendStatusChange</code>是一个助手方法，它向API发送请求来改变游乐设备的状态。<code class="eh md me mf mg b">getNextStatus</code>是一个helper方法，它从传递给它的方法中返回下一个<code class="eh md me mf mg b">RideStatus</code>。</p><p id="01f8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当按下取消按钮并请求取消游乐设备时，触发<code class="eh md me mf mg b">cancelButtonPressed</code>。最后，<code class="eh md me mf mg b">statusButtonPressed</code>只是根据游乐设备的当前状态发送一个改变状态的请求。它还会更新UI以适应它被更改到的状态。</p><h1 id="87ba" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">使用Pusher集成实时更新</h1><p id="8274" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">接下来，让我们给视图控制器添加一些Pusher功能，这样它就可以实时获取对<code class="eh md me mf mg b">RideStatus</code>的更改。</p><p id="0c3c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，您需要<code class="eh md me mf mg b">import</code>Pusher swift SDK:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="bc46" class="ml jy hu mg b fv mm mn l mo mp">import PusherSwift</span></pre><p id="8c97" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后在类的顶部定义<code class="eh md me mf mg b">pusher</code>变量:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="c91b" class="ml jy hu mg b fv mm mn l mo mp">let pusher = Pusher(<br/>        key: AppConstants.PUSHER_API_KEY,<br/>        options: PusherClientOptions(host: .cluster(AppConstants.PUSHER_API_CLUSTER))<br/>    )</span></pre><p id="cb6e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，将以下方法添加到该类中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="72b0" class="ml jy hu mg b fv mm mn l mo mp">private func listenForStatusUpdates() {<br/>        let channel = pusher.subscribe(channelName: "cabs")</span><span id="3fd9" class="ml jy hu mg b fv mq mn l mo mp">        let _ = channel.bind(eventName: "status-update") { data in<br/>            if let data = data as? [String: AnyObject] {<br/>                if let status = data["status"] as? String, let rideStatus = RideStatus(rawValue: status) {<br/>                    if rideStatus == .Neutral {<br/>                        self.status = .Neutral<br/>                        self.cancelButtonPressed(UIButton())<br/>                    }<br/>                }<br/>            }<br/>        }</span><span id="b445" class="ml jy hu mg b fv mq mn l mo mp">        pusher.connect()<br/>    }</span></pre><p id="af10" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面的方法只是订阅了一个推送通道，并绑定到通道上的<code class="eh md me mf mg b">status-update</code>事件。当事件被触发时，取消按钮函数被调用。</p><p id="666b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后在<code class="eh md me mf mg b">viewDidLoad</code>方法的底部，添加一个对<code class="eh md me mf mg b">listenForStatusUpdates</code>方法的调用:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="6d40" class="ml jy hu mg b fv mm mn l mo mp">listenForStatusUpdates()</span></pre><p id="3d8c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，当后端应用程序触发一个状态更新事件时，我们的应用程序将获取它，并根据需要更改UI。</p><h1 id="0820" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置谷歌地图</h1><p id="4d5d" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">接下来，打开您的<code class="eh md me mf mg b">AppDelegate</code>类并导入以下内容:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="69a4" class="ml jy hu mg b fv mm mn l mo mp">import GoogleMaps</span></pre><p id="a592" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，您可以用以下代码替换<code class="eh md me mf mg b">application(didFinishLaunchingWithOptions:)</code>方法:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="2dd2" class="ml jy hu mg b fv mm mn l mo mp">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {<br/>        GMSServices.provideAPIKey(AppConstants.GOOGLE_API_KEY)<br/>        return true<br/>    }</span></pre><h1 id="00c9" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">定义密钥和乘坐状态</h1><p id="614b" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">创建一个名为<code class="eh md me mf mg b">AppConstants.swift</code>的新文件，并粘贴以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="d928" class="ml jy hu mg b fv mm mn l mo mp">class AppConstants {<br/>        static let GOOGLE_API_KEY = "GOOGLE_API_KEY"<br/>        static let PUSHER_KEY = "PUSHER_API_KEY"<br/>        static let PUSHER_CLUSTER = "PUSHER_API_CLUSTER"<br/>        static let API_URL = "http://127.0.0.1:4000"<br/>        static let PUSH_NOTIF_INSTANCE_ID = "PUSHER_NOTIFICATION_INSTANCE_ID"<br/>        static let USER_ID = UUID().uuidString<br/>    }</span></pre><blockquote class="ir is it"><p id="c771" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️您需要将上面的占位符替换为各自仪表板中的实际值。</em></p></blockquote><p id="c227" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，创建两个名为<code class="eh md me mf mg b">Rider.swift</code>和<code class="eh md me mf mg b">RideStatus.swift</code>的文件，然后将以下代码粘贴到文件中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="f4c4" class="ml jy hu mg b fv mm mn l mo mp">// Rider.swift<br/>    import Foundation</span><span id="7303" class="ml jy hu mg b fv mq mn l mo mp">    struct Rider {<br/>        let name: String<br/>        let longitude: Double<br/>        let latitude: Double</span><span id="d4f0" class="ml jy hu mg b fv mq mn l mo mp">        init(data: [String:AnyObject]) {<br/>            self.name = data["name"] as! String<br/>            self.longitude = data["longitude"] as! Double<br/>            self.latitude = data["latitude"] as! Double<br/>        }<br/>    }</span><span id="60c6" class="ml jy hu mg b fv mq mn l mo mp">// RideStatus.swift<br/>    import Foundation</span><span id="358b" class="ml jy hu mg b fv mq mn l mo mp">    enum RideStatus: String {<br/>        case Neutral = "Neutral"<br/>        case Searching = "Searching"<br/>        case FoundRide = "FoundRide"<br/>        case Arrived = "Arrived"<br/>        case OnTrip = "OnTrip"<br/>        case EndedTrip = "EndedTrip"<br/>    }</span></pre><p id="dfd1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">骑手应用程序到此为止。我们需要做的最后一件事是修改<code class="eh md me mf mg b">info.plist</code>文件，就像我们在客户端应用程序中做的那样。</p><p id="8250" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在我们已经创建了应用程序，您可以运行它们来查看它们的运行情况。但是，我们没有在应用程序中添加推送通知。我们需要这样做，这样当应用程序最小化时，用户可以知道服务上有一个事件。</p><p id="b5ab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们来设置推送通知。</p><h1 id="ec6b" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">向我们的iOS应用程序添加推送通知</h1><p id="6136" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">我们需要做的第一件事是让我们的服务器能够发送推送通知。</p><p id="5af4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">此时，应用程序开箱即可正常工作。我们现在需要向应用程序添加推送通知，以使其更具吸引力，即使用户当前没有使用该应用程序。</p><blockquote class="ir is it"><p id="9aa9" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️您需要</em> <a class="ae jw" href="https://developer.apple.com/programs/enroll/" rel="noopener ugc nofollow" target="_blank"> <em class="hu">注册苹果开发者计划</em> </a> <em class="hu">才能使用推送通知功能。此外，推送通知不能在模拟器上运行，因此您需要一个实际的iOS设备来测试。</em></p></blockquote><p id="7ef7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">Pusher的<a class="ae jw" href="https://pusher.com/push-notifications" rel="noopener ugc nofollow" target="_blank"> Beams API </a>对原生iOS应用有一流的支持。您的iOS应用程序实例订阅了<strong class="ix hv">兴趣</strong>；然后，您的服务器向这些兴趣发送推送通知。订阅该兴趣的每个应用实例都将收到通知，即使该应用当时未在设备上打开。</p><p id="d993" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">本节介绍如何设置iOS应用程序，以便通过Pusher接收关于您的食品交付订单的交易推送通知。</p><h1 id="99c0" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">配置APN</h1><p id="86c7" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">Pusher依靠苹果推送通知服务(APNs)代表你向iOS应用用户发送推送通知。当我们发送推送通知时，我们使用您的APNs密钥。本页将指导您完成获取APNs密钥的过程，以及如何将密钥提供给Pusher。</p><p id="6080" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">点击<a class="ae jw" href="https://developer.apple.com/account" rel="noopener ugc nofollow" target="_blank">这里</a>进入苹果开发者仪表板，然后创建一个新的密钥，如下所示:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/bf7f8bb42415d9b09ec0c962f4f7a76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*sLUJGDbwWL4ef5wQ."/></div></figure><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/2dc9a5c356607d8ed04164032a233e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*qIP__o6ST22oPkBs.gif"/></div></figure><p id="a609" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">创建密钥后，下载它。请妥善保管，因为我们将在下一节用到它。</p><blockquote class="ir is it"><p id="7889" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️你必须妥善保管生成的密钥，因为一旦丢失就无法找回。</em></p></blockquote><h1 id="f99a" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">创建您的Pusher应用程序</h1><p id="13a6" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">接下来你需要做的是从<a class="ae jw" href="https://dash.pusher.com" rel="noopener ugc nofollow" target="_blank"> Pusher仪表板</a>创建一个新的Pusher Push通知应用程序。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mv"><img src="../Images/111de1ef9702ada2bf7f35b885549ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MfRs3THsH3Tb6byg.png"/></div></div></figure><p id="d9b6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">创建应用程序后，您应该会看到一个快速启动向导，它将帮助您设置应用程序。</p><p id="092b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了配置推送通知，您需要从Apple获得一个APNs密钥。这与我们在上一节中下载的密钥相同。获得密钥后，将其上传到快速入门向导。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mv"><img src="../Images/a43e0475eaaac62779cc610b7a73fdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NP67Q60tjAK7Zhrd.png"/></div></div></figure><p id="a4f0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">输入您的Apple团队ID。你可以从<a class="ae jw" href="https://developer.apple.com/account/#/membership" rel="noopener ugc nofollow" target="_blank">这里</a>获取团队ID。点击继续进行下一步。</p><h1 id="4d8d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">更新您的骑手应用程序以支持推送通知</h1><p id="f566" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">在您的客户端应用程序中，如果您还没有，请打开<code class="eh md me mf mg b">Podfile</code>并将以下pod添加到依赖项列表中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="4b83" class="ml jy hu mg b fv mm mn l mo mp">pod 'PushNotifications'</span></pre><p id="a005" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在像前面一样运行<code class="eh md me mf mg b">pod install</code>命令来获取通知包。接下来打开<code class="eh md me mf mg b">AppDelegate</code>类并导入<code class="eh md me mf mg b">PushNotifications</code>包:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="b051" class="ml jy hu mg b fv mm mn l mo mp">import PushNotifications</span></pre><p id="6a58" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，作为<code class="eh md me mf mg b">AppDelegate</code>类的一部分，添加以下内容:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="335c" class="ml jy hu mg b fv mm mn l mo mp">let pushNotifications = PushNotifications.shared</span><span id="4c5d" class="ml jy hu mg b fv mq mn l mo mp">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {<br/>      // [...]</span><span id="0532" class="ml jy hu mg b fv mq mn l mo mp">      self.pushNotifications.start(instanceId: "PUSHER_NOTIF_INSTANCE_ID")<br/>      self.pushNotifications.registerForRemoteNotifications()</span><span id="3f97" class="ml jy hu mg b fv mq mn l mo mp">      // [...]</span><span id="c93d" class="ml jy hu mg b fv mq mn l mo mp">      return true<br/>    }</span><span id="92bd" class="ml jy hu mg b fv mq mn l mo mp">    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {<br/>      // [...]</span><span id="152a" class="ml jy hu mg b fv mq mn l mo mp">      self.pushNotifications.registerDeviceToken(deviceToken) {<br/>        try? self.pushNotifications.subscribe(interest: "rider_\(AppConstants.USER_ID)")<br/>      }</span><span id="5a9c" class="ml jy hu mg b fv mq mn l mo mp">      // [...]<br/>    }</span></pre><blockquote class="ir is it"><p id="c1a3" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡将</em> <code class="eh md me mf mg b"><em class="hu">PUSHER_PUSH_NOTIF_INSTANCE_ID</em></code> <em class="hu">替换为Pusher应用程序给你的密钥。</em></p></blockquote><p id="89fa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们在<code class="eh md me mf mg b">application(didFinishLaunchingWithOptions:)</code>方法中设置了推送通知，然后我们订阅了<code class="eh md me mf mg b">application(didRegisterForRemoteNotificationsWithDeviceToken:)</code>方法中的兴趣。</p><p id="ac56" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">动态兴趣演示了如何轻松地为特定设备或用户使用特定兴趣。只要服务器推送至正确的兴趣，您就可以放心，订阅该兴趣的设备将会收到推送通知。</p><p id="e016" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们需要为应用程序启用推送通知。在项目导航器中，选择您的项目，并点击<em class="iw">功能</em>选项卡。<a class="ae jw" href="http://help.apple.com/xcode/mac/current/#/devdfd3d04a1" rel="noopener ugc nofollow" target="_blank">打开开关，启用推送通知</a>。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mv"><img src="../Images/4456d38db19f54991c6fb16d147bcc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WaRPOSiBcHdqNdIW.png"/></div></div></figure><h1 id="6856" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">更新您的驱动程序应用程序以支持推送通知</h1><p id="991b" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">你的rider应用程序也需要能够接收推送通知。该过程类似于上面的设置。唯一的区别是我们将在<code class="eh md me mf mg b">AppDelegate</code>中认购的利息，这将是<strong class="ix hv"> ride_requests </strong>。</p><h1 id="1301" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">向iOS上的推送通知添加丰富的操作</h1><h1 id="f3e3" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">向iOS上的推送通知添加丰富的操作</h1><p id="f125" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">按照目前的情况，我们的应用程序将能够接收推送通知，但让我们更进一步，向应用程序添加丰富的操作。这将增加通知的参与度。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/7e64b058f37d57e056ae854a8c6d1b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*WnSS7TAG8UXPBnV4.gif"/></div></figure><p id="531e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，打开<code class="eh md me mf mg b">AppDelegate</code>类并导入以下类:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="356c" class="ml jy hu mg b fv mm mn l mo mp">import PushNotifications<br/>    import UserNotifications</span></pre><p id="fe38" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，您需要用类扩展<code class="eh md me mf mg b">AppDelegate</code>。然后添加以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="f6bf" class="ml jy hu mg b fv mm mn l mo mp">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {<br/>        // [...]    </span><span id="fc48" class="ml jy hu mg b fv mq mn l mo mp">        let center = UNUserNotificationCenter.current()<br/>        center.delegate = self</span><span id="d9e9" class="ml jy hu mg b fv mq mn l mo mp">        let cancelAction = UNNotificationAction(<br/>            identifier: "cancel", <br/>            title: "Reject", <br/>            options: [.foreground]<br/>        )</span><span id="1721" class="ml jy hu mg b fv mq mn l mo mp">        let acceptAction = UNNotificationAction(<br/>            identifier: "accept", <br/>            title: "Accept Request", <br/>            options: [.foreground]<br/>        )</span><span id="26b5" class="ml jy hu mg b fv mq mn l mo mp">        let category = UNNotificationCategory(<br/>            identifier: "DriverActions", <br/>            actions: [acceptAction, cancelAction], <br/>            intentIdentifiers: []<br/>        )</span><span id="c927" class="ml jy hu mg b fv mq mn l mo mp">        center.setNotificationCategories([category])</span><span id="16dc" class="ml jy hu mg b fv mq mn l mo mp">        // [...]</span><span id="fa2e" class="ml jy hu mg b fv mq mn l mo mp">        return true<br/>    }</span></pre><p id="04e5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们指定了希望推送通知显示的<a class="ae jw" href="https://developer.apple.com/documentation/usernotifications/unnotificationaction" rel="noopener ugc nofollow" target="_blank">动作</a>。</p><p id="c52e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在同一个<code class="eh md me mf mg b">AppDelegate</code>类中，添加以下方法，当在推送通知中选择动作时，该方法将处理这些动作:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="6241" class="ml jy hu mg b fv mm mn l mo mp">func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {<br/>        let name = Notification.Name("status")</span><span id="be3a" class="ml jy hu mg b fv mq mn l mo mp">        if response.actionIdentifier == "cancel" {<br/>            NotificationCenter.default.post(name: name, object: nil, userInfo: ["status": RideStatus.Neutral])<br/>        }</span><span id="73ac" class="ml jy hu mg b fv mq mn l mo mp">        if response.actionIdentifier == "accept" {<br/>            NotificationCenter.default.post(name: name, object: nil, userInfo: ["status": RideStatus.FoundRide])<br/>        }</span><span id="290e" class="ml jy hu mg b fv mq mn l mo mp">        completionHandler()<br/>    }</span></pre><p id="f48b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在代码中，我们只是在点击推送通知动作时发送一个本地通知。接下来，我们将在视图控制器中添加一个观察器，它将在收到通知时触发一些代码。</p><p id="a7b1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开<code class="eh md me mf mg b">MainViewController</code>类并在<code class="eh md me mf mg b">viewDidLoad</code>方法中添加以下代码:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="ce2b" class="ml jy hu mg b fv mm mn l mo mp">NotificationCenter.default.addObserver(<br/>        self,<br/>        selector: #selector(changeStatusFromPushNotification),<br/>        name: Notification.Name("status"),<br/>        object: nil<br/>    )</span></pre><p id="9510" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，将<code class="eh md me mf mg b">changeStatusFromPushNotification</code>方法添加到该类中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="783a" class="ml jy hu mg b fv mm mn l mo mp">@objc private func changeStatusFromPushNotification(notification: Notification) {<br/>        guard<br/>            let data = notification.userInfo as? [String: RideStatus],<br/>            let status = data["status"] else { return }</span><span id="0162" class="ml jy hu mg b fv mq mn l mo mp">        sendStatusChange(status) { successful in<br/>            guard successful else { return }</span><span id="ff5a" class="ml jy hu mg b fv mq mn l mo mp">            if status == .Neutral {<br/>                self.status = .FoundRide<br/>                self.cancelButtonPressed(UIButton())<br/>            }</span><span id="95f8" class="ml jy hu mg b fv mq mn l mo mp">            if status == .FoundRide {<br/>                self.status = .Searching<br/>                self.statusButtonPressed(UIButton())<br/>            }<br/>        }<br/>    }</span></pre><p id="aff0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这个回调只是触发了我们在前面的教程中已经定义的<code class="eh md me mf mg b">sendStatusChange</code>方法。</p><h1 id="d3b7" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">创建我们的通知服务扩展</h1><p id="82c5" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">接下来，我们需要创建通知服务扩展。</p><blockquote class="ir is it"><p id="890b" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡当在iOS应用程序中收到通知时，您可能希望能够下载内容以响应通知，或者在内容显示给用户之前对其进行编辑。在iOS 10中，苹果现在允许应用程序通过一个新的</em> <strong class="ix hv"> <em class="hu">通知服务扩展</em> </strong> <em class="hu">来做到这一点。— </em> <a class="ae jw" href="https://code.tutsplus.com/tutorials/ios-10-notification-service-extensions--cms-27550" rel="noopener ugc nofollow" target="_blank"> <em class="hu">代码</em> </a></p></blockquote><p id="a93b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在Xcode中，转到<strong class="ix hv">文件&gt;新建&gt;目标……</strong>，选择<strong class="ix hv">通知服务扩展</strong>，然后给目标命名，点击<strong class="ix hv">完成</strong>。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mv"><img src="../Images/2844765b765c8c406a9ac34d26c64b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oEHpO7fj6paC4_Tk.png"/></div></div></figure><p id="6073" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果您在Xcode的文件浏览器中查看，您应该看到添加了两个新文件的新目标:<code class="eh md me mf mg b">NotificationService.swift</code>和<code class="eh md me mf mg b">info.plist</code>。我们将修改这些文件，以确保它为我们的推送通知获取并提供正确的信息。</p><p id="23a7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开<code class="eh md me mf mg b">NotificationService</code>类并用以下内容替换<code class="eh md me mf mg b">didReceive</code>方法:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="775a" class="ml jy hu mg b fv mm mn l mo mp">override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {<br/>        self.contentHandler = contentHandler<br/>        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)</span><span id="3fe6" class="ml jy hu mg b fv mq mn l mo mp">        func failEarly() {<br/>            contentHandler(request.content)<br/>        }</span><span id="c32b" class="ml jy hu mg b fv mq mn l mo mp">        guard<br/>            let content = (request.content.mutableCopy() as? UNMutableNotificationContent),<br/>            let apnsData = content.userInfo["data"] as? [String: Any],<br/>            let mapURL = apnsData["attachment-url"] as? String,<br/>            let attachmentURL = URL(string: mapURL.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!),<br/>            let imageData = try? NSData(contentsOf: attachmentURL, options: NSData.ReadingOptions()),<br/>            let attachment = UNNotificationAttachment.create(imageFileIdentifier: "image.png", data: imageData, options: nil)<br/>        else {<br/>            return failEarly()<br/>        }</span><span id="9c86" class="ml jy hu mg b fv mq mn l mo mp">        content.attachments = [attachment]<br/>        contentHandler(content.copy() as! UNNotificationContent)<br/>    }</span></pre><p id="51dc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们试图获取推送通知的内容。因为我们希望在通知中显示地图，所以我们希望从推送通知的自定义数据中获得一个静态地图URL。我们使用它并将其作为一个<code class="eh md me mf mg b">attachment</code>来添加到推送的内容中。我们最终将<code class="eh md me mf mg b">content</code>传递给<code class="eh md me mf mg b">contentHandler</code>。</p><p id="2d9c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，将以下扩展名添加到同一个文件中:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="7289" class="ml jy hu mg b fv mm mn l mo mp">extension UNNotificationAttachment {</span><span id="3978" class="ml jy hu mg b fv mq mn l mo mp">        static func create(imageFileIdentifier: String, data: NSData, options: [NSObject : AnyObject]?) -&gt; UNNotificationAttachment? {<br/>            let fileManager = FileManager.default<br/>            let tmpSubFolderName = ProcessInfo.processInfo.globallyUniqueString<br/>            let tmpSubFolderURL = NSURL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(tmpSubFolderName, isDirectory: true)</span><span id="f275" class="ml jy hu mg b fv mq mn l mo mp">            do {<br/>                try fileManager.createDirectory(at: tmpSubFolderURL!, withIntermediateDirectories: true, attributes: nil)<br/>                let fileURL = tmpSubFolderURL?.appendingPathComponent(imageFileIdentifier)<br/>                try data.write(to: fileURL!, options: [])<br/>                let imageAttachment = try UNNotificationAttachment(identifier: imageFileIdentifier, url: fileURL!, options: options)<br/>                return imageAttachment<br/>            } catch let error {<br/>                print("error \(error)")<br/>            }</span><span id="ddce" class="ml jy hu mg b fv mq mn l mo mp">            return nil<br/>        }<br/>    }</span></pre><p id="ecb6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><code class="eh md me mf mg b">create</code>方法将静态地图保存到设备上的一个临时位置，这样就不必从URL加载了。</p><p id="3520" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们想要做的最后一个更改是在<code class="eh md me mf mg b">info.plist</code>文件中。在这里，我们想要注册推送通知的所有动作标识符。打开<code class="eh md me mf mg b">info.plist</code>文件，添加下图中高亮显示的内容；</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mv"><img src="../Images/a59cf7903c8676e11ced34d1ccf2a45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XNkiY139HJPGFDQi.png"/></div></div></figure><p id="af8f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这就是我们在应用程序端需要做的全部工作。现在我们需要确保API发送推送通知。</p><h1 id="0916" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">从Node.js API发送推送通知</h1><p id="a6b6" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">在Node.js项目中，打开我们的<code class="eh md me mf mg b">index.js</code>文件并导入推送通知包:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="b324" class="ml jy hu mg b fv mm mn l mo mp">const PushNotifications = require('pusher-push-notifications-node')<br/>    const pushNotifications = new PushNotifications({<br/>        instanceId: 'YOUR_INSTANCE_ID_HERE',<br/>        secretKey: 'YOUR_SECRET_KEY_HERE'<br/>    })</span></pre><blockquote class="ir is it"><p id="5f62" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡您应该用Pusher仪表板中的值替换占位符值。</em></p></blockquote><p id="896c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，添加以下助手函数:</p><pre class="ls lt lu lv fq mh mg mi mj aw mk dt"><span id="b937" class="ml jy hu mg b fv mm mn l mo mp">function sendRiderPushNotificationFor(status) {<br/>        switch (status) {<br/>            case "Neutral":<br/>                var alert = {<br/>                    "title": "Driver Cancelled :(",<br/>                    "body": "Sorry your driver had to cancel. Open app to request again.",<br/>                }<br/>                break;<br/>            case "FoundRide":<br/>                var alert = {<br/>                    "title": "🚕 Found a ride",<br/>                    "body": "The driver is on the way."<br/>                }<br/>                break;<br/>            case "Arrived":<br/>                var alert = {<br/>                    "title": "🚕 Driver is waiting",<br/>                    "body": "The driver outside, please meet him."                <br/>                }<br/>                break;<br/>            case "OnTrip":<br/>                var alert = {<br/>                    "title": "🚕 You are on your way",<br/>                    "body": "The driver has started the trip. Enjoy your ride."<br/>                }<br/>                break;<br/>            case "EndedTrip":<br/>                var alert = {<br/>                    "title": "🌟 Ride complete",<br/>                    "body": "Your ride cost $15. Open app to rate the driver."<br/>                }<br/>                break;<br/>        }<br/>        if (alert != undefined) {<br/>            pushNotifications.publish(['rider'], {apns: {aps: {alert, sound: "default"}}})<br/>                .then(resp =&gt; console.log('Just published:', resp.publishId))<br/>                .catch(err =&gt; console.log('Error:', err))<br/>        }<br/>    }</span><span id="cfab" class="ml jy hu mg b fv mq mn l mo mp">    function sendDriverPushNotification() {<br/>        pushNotifications.publish(['ride_requests'], {<br/>            "apns": {<br/>                "aps": {<br/>                    "alert": {<br/>                        "title": "🚗 New Ride Request",<br/>                        "body": `New pick up request from ${rider.name}.`,<br/>                    },<br/>                    "category": "DriverActions",<br/>                    "mutable-content": 1,<br/>                    "sound": 'default'<br/>                },<br/>                "data": {<br/>                    "attachment-url": "https://maps.google.com/maps/api/staticmap?markers=color:red|37.388064,-122.088426&amp;zoom=13&amp;size=500x300&amp;sensor=true"<br/>                }<br/>            }<br/>        })<br/>        .then(response =&gt; console.log('Just published:', response.publishId))<br/>        .catch(error =&gt; console.log('Error:', error));<br/>    }</span></pre><p id="bd48" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面我们有两个函数。第一个是<code class="eh md me mf mg b">sendRiderPushNotificationFor</code>，它根据旅行的状态向乘客发送通知。第二种方法是<code class="eh md me mf mg b">sendDriverPushNotification</code>,它只是向司机发送一个通知。</p><p id="fab7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh md me mf mg b">sendDriverPushNotification</code>中，我们可以看到推送通知的格式与第一个略有不同。这是因为我们支持丰富的动作，所以我们必须指定<code class="eh md me mf mg b">category</code>键和<code class="eh md me mf mg b">mutable-content</code>键。<code class="eh md me mf mg b">category</code>必须匹配我们在<code class="eh md me mf mg b">AppDelegate</code>中指定的名称。</p><p id="6c60" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，您需要在各自的路径中调用上面的函数。第一个函数应该添加到<code class="eh md me mf mg b">POST /status</code>路径中，在<code class="eh md me mf mg b">pusher.trigger</code>方法调用之上。第二个函数应该在<code class="eh md me mf mg b">pusher.trigger</code>方法调用上面的<code class="eh md me mf mg b">POST /request</code>路径中被调用。</p><p id="6602" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，当我们运行我们的应用程序时，我们应该在我们的设备上获得推送通知。</p><blockquote class="ir is it"><p id="7033" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️在iOS上使用推送通知时，服务器必须采用HTTPS。</em></p></blockquote><p id="0922" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这就是使用Pusher添加推送通知的全部内容。下面是我们应用程序运行的屏幕记录:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/3825dcdd0ae415b86bbc5000e6cc6171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*jOOYO9xM2c8QDyGT.gif"/></div></figure><h1 id="57c0" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="d94e" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt ll ji jj ju lm jm jn jv ln jq jr js hn dt translated">在本文中，我们创建了一个基本的乘车共享服务，并使用它来演示如何使用Pusher发送具有丰富操作的推送通知。希望你已经学会了如何使用Pusher来简化向用户发送推送通知的过程。</p><p id="bed5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">资源库的源代码可以在<a class="ae jw" href="https://github.com/neoighodaro/ride-sharing-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="6387" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">本帖最早发表在<a class="ae jw" href="https://pusher.com/tutorials/ride-sharing-app-push-notifications" rel="noopener ugc nofollow" target="_blank">推手</a>上。</p></div></div>    
</body>
</html>