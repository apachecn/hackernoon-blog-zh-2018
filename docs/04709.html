<html>
<head>
<title>Node.js framework comparison: Hapi.js and Sails.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js框架对比:Hapi.js和Sails.js</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/node-js-framework-comparison-hapi-js-and-sails-js-e31f05cc1da?source=collection_archive---------13-----------------------#2018-06-04">https://medium.com/hackernoon/node-js-framework-comparison-hapi-js-and-sails-js-e31f05cc1da?source=collection_archive---------13-----------------------#2018-06-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/76de1007f81076901134e13784a0b894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANieOLEbQ3Bx_C8HlCg3Zg.png"/></div></div></figure><h2 id="1919" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">在web开发的时代，node.js是使用最广泛的服务器端框架，Node.js是一个基于V8 JavaScript引擎的事件驱动I/O框架，它允许JavaScript在服务器端执行，并使用了Google为Chrome浏览器开发的快速V8引擎。</h2><p id="92b5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">node.js的基本理念是:-</p><ul class=""><li id="f721" class="kv kw hu kc b kd kx kh ky jn kz jr la jv lb ku lc ld le lf dt translated"><strong class="kc hv">非阻塞I/O </strong> —每个I/O调用都必须接受回调，无论是从磁盘、网络还是另一个进程检索信息，只要响应到达，回调就会立即执行</li><li id="498b" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated"><strong class="kc hv">内置支持最重要的协议</strong> — HTTP、DNS、TLS</li><li id="e843" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated"><strong class="kc hv">低级</strong> —不删除POSIX层的功能。例如，支持半封闭的TCP连接</li><li id="8ab5" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated"><strong class="kc hv">传输所有内容</strong> —从不强制缓冲数据</li></ul><p id="a995" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated"><a class="ae lo" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> Node.js </a>与客户端<a class="ae lo" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>的不同之处在于，它删除了某些东西，如DOM操作，并添加了对事件I/O、进程、流、HTTP、SSL、DNS、字符串和缓冲区处理以及C/C++插件的支持</p><p id="8cd7" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">让我们跳过无聊的通用术语bingo介绍，直接进入实质——两个流行的Node.js框架之间的比较？</p><p id="b0b6" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">判断框架是非常主观的。在构建企业级应用程序时，我们需要考虑以下几点:</p><ul class=""><li id="53ab" class="kv kw hu kc b kd kx kh ky jn kz jr la jv lb ku lc ld le lf dt translated">最佳实践和模式:框架是自己动手还是提供清晰的模式来使用。</li><li id="3223" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">配置:配置框架有多容易。</li><li id="74bb" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">惯例:如果这是首选路线，是否有惯例可循？</li><li id="e5c6" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">水平扩展:扩展用这个框架构建的应用程序有多容易。</li><li id="e7a8" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">测试:如何测试应用程序。</li><li id="5c41" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">脚手架:开发人员手动编码的工作量与使用内置代码生成器相比。</li><li id="70ca" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">监控:如何监控应用程序</li><li id="8187" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">跟踪记录:一个框架是如何被证明的，例如，谁支持它，它维护得如何。</li><li id="24f7" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">集成:插件/连接器的生态系统有多丰富。</li><li id="4db0" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">ORM/ODM:有对象关系/文档映射器吗？</li></ul><p id="c4b5" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">虽然性能很重要，但它会随着特定项目的需求和业务逻辑而变化。运行有意义的基准测试并不简单。</p><p id="4561" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">那么，使用极简的Node.js框架有什么好处呢？代价是时间的增加和更难的可维护性，因为当团队选择开源项目时，他们可以利用其他贡献者进行维护。当同一个团队选择了一个仅由该公司支持的闭源内部系统时，情况就不一样了。</p><p id="3b3e" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">最后，你需要自己思考，自己做决定。您的目标应用程序可能关注和/或需要不同的东西。这篇文章只能突出某些事实。即使是这样，也很可能是以一种主观的方式，就像一个人写的或说的几乎任何事情一样。😉</p><h1 id="b24f" class="lp jd hu bd je lq lr ls ji lt lu lv jm lw lx ly jq lz ma mb ju mc md me jy mf dt translated">哈皮网</h1><p id="6928" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">哈比神(用于<strong class="kc hv"> HTTP API服务器</strong>)由<strong class="kc hv">沃尔玛实验室</strong>支持，因此它显然有着在生产中服务大量流量的良好记录(#nodebf- Node黑色星期五)。</p><p id="cce4" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">哈比神内置了对输入验证、缓存、身份验证和其他功能的支持。它没有提供开箱即用的ORM/ODM，但是有一个第三方插件的广泛列表。</p><p id="dff5" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">哈比神的强大之处在于，您可以对请求处理进行很大程度的控制。这在企业应用程序中很方便，因为它们需要处理大量的逻辑。</p><p id="0604" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">其他优势包括:</p><ul class=""><li id="19fd" class="kv kw hu kc b kd kx kh ky jn kz jr la jv lb ku lc ld le lf dt translated">基于插件的架构:挑选模块来扩展你的应用</li><li id="3b3a" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">缓存:提高性能</li><li id="eb91" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">以配置为中心:使用配置文件</li><li id="eaa1" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">丰富的web服务器功能:加速您的开发</li><li id="58e3" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">详细的API文档:快速学习框架</li><li id="d226" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">可靠的跟踪记录和支持:从社区和贡献者那里获得支持</li><li id="b036" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">支持微服务:通过Seneca和chairo插件获得更好的业务逻辑分离和可伸缩性。</li></ul><p id="1833" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">哈比神的一些缺点包括:</p><ul class=""><li id="74c9" class="kv kw hu kc b kd kx kh ky jn kz jr la jv lb ku lc ld le lf dt translated">开发人员需要自己找出代码结构</li><li id="ad0e" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">“锁定”开发者使用特定于hapi的模块和插件，如catbox、joi、boom、tv、good、travelogue和yar并且与Express/Connect不兼容</li><li id="870d" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">端点是手工创建的</li><li id="f85a" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">重构是手动的</li><li id="c2ee" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">手动测试端点</li></ul><p id="445f" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">没有内置的ORM/ODM本身并不是一个缺点，因为并不是所有的企业应用程序都需要数据库。例如，从遗留SOAP服务中提取数据的编排层不需要带有模型和模式的MongoDB驱动程序，因为它从服务中获取数据，并可能将数据缓存在Redis中。</p><p id="6eb4" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">就代码而言，哈比神不同于本文中的其他框架，因为它不是构建在Express之上的。这个架构需要熟悉Express的开发人员额外学习(我们大多数人都是)，因为他们可以将自己的Express.js技能应用到哈比神。</p><p id="6aee" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">具有两条路由GET /和GET /name的简单哈比神服务器如下所示:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="44e3" class="jc jd hu ml b fv mp mq l mr ms">'use strict';</span><span id="c8cc" class="jc jd hu ml b fv mt mq l mr ms">const Hapi = require('hapi');</span><span id="74fc" class="jc jd hu ml b fv mt mq l mr ms">// Create a server with a host and port</span><span id="97e4" class="jc jd hu ml b fv mt mq l mr ms">const server = Hapi.server({ host:'localhost', port:8000 });</span><span id="e36a" class="jc jd hu ml b fv mt mq l mr ms">// Add the route</span><span id="b709" class="jc jd hu ml b fv mt mq l mr ms">server.route({ <br/>  method:'GET', <br/>  path:'/hello', <br/>  handler: (request,h) =&gt; { <br/>    return 'hello world'; <br/>  }});</span><span id="3ac2" class="jc jd hu ml b fv mt mq l mr ms">// Start the server</span><span id="08c8" class="jc jd hu ml b fv mt mq l mr ms">async function start() { <br/>  try { <br/>    await server.start(); <br/>  } catch (err) { <br/>   console.log(err); <br/>   process.exit(1); <br/>}</span><span id="be51" class="jc jd hu ml b fv mt mq l mr ms">console.log('Server running at:', server.info.uri);</span><span id="6554" class="jc jd hu ml b fv mt mq l mr ms">};</span><span id="bf5d" class="jc jd hu ml b fv mt mq l mr ms">start();</span></pre><p id="d8bf" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">要开始使用npm，只需像安装任何其他依赖项一样安装哈比神:</p><p id="d0ce" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated"><code class="eh mu mv mw ml b">npm install hapi --save</code></p><p id="e8b7" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">在撰写本文的最后一个月(2018年3月)，哈比神的社交证明有9207个GitHub明星和722014次npm下载。</p><p id="bc4b" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">网址:<a class="ae lo" href="http://hapijs.com/" rel="noopener ugc nofollow" target="_blank">http://hapijs.com</a></p><p id="63c4" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">GitHub:<a class="ae lo" href="http://github.com/hapijs/hapi" rel="noopener ugc nofollow" target="_blank">http://github.com/hapijs/hapi</a></p><p id="7d59" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">NPM:<a class="ae lo" href="https://www.npmjs.org/package/hapi" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.org/package/hapi</a></p><h1 id="caf8" class="lp jd hu bd je lq lr ls ji lt lu lv jm lw lx ly jq lz ma mb ju mc md me jy mf dt translated">帆. js</h1><p id="d7f1" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">Sails.js建立在Express.js之上；因此，对于已经熟悉Express.js的人来说，学习起来更容易。</p><p id="1040" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">Sails.js有丰富的脚手架。想想Ruby on Rails(因此得名“sails”)。这使得开发人员无需编写任何代码就可以创建RESTful API端点。自动生成的代码可以在以后进行定制，以满足特定的业务需求。<br/> Sails.js是MVC框架，自带数据库ORM/ODM Waterline，支持各种数据库。</p><p id="cff3" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">Sails.js还通过Socket.io和一个资产工具(Grunt)内置了对WebSockets的支持。然而，Sails.js让你决定前端层，这通常是用Angular.js、Backbone.js或任何其他前端框架实现的。</p><p id="3860" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">Sails.js的好见解:</p><ul class=""><li id="3d04" class="kv kw hu kc b kd kx kh ky jn kz jr la jv lb ku lc ld le lf dt translated">提供良好的代码组织和蓝图</li><li id="e059" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">对WebSockets的内置支持</li><li id="5b99" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">支持各种数据库</li><li id="85d5" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">数据有效性</li><li id="39aa" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">控制器、模型和路线的自动生成代码</li><li id="b585" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">许多现成的安全功能，例如CSRF和与张亿嘟嘟的兼容性</li><li id="d5e0" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">内置文件上传库</li><li id="1025" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">良好的文档</li><li id="17c6" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">带有挂钩和插件的灵活模块化架构</li></ul><p id="6f52" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">一些缺点，如:</p><ul class=""><li id="eba4" class="kv kw hu kc b kd kx kh ky jn kz jr la jv lb ku lc ld le lf dt translated">陡峭的学习曲线</li><li id="d9ea" class="kv kw hu kc b kd lg kh lh jn li jr lj jv lk ku lc ld le lf dt translated">固执己见的</li></ul><p id="1767" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">以下是在Sails.js项目的config/routes.js文件中定义路线的示例:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="42eb" class="jc jd hu ml b fv mp mq l mr ms">module.exports.routes = { <br/> 'get /signup': { view: 'conversion/signup' }, <br/> 'post /signup': 'AuthController.processSignup', <br/> 'get /login': { view: 'portal/login' }, <br/> 'post /login': 'AuthController.processLogin', <br/> '/logout': 'AuthController.logout', <br/> 'get /me': 'UserController.profile' <br/>}</span></pre><p id="8c69" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">如您所见，抽象——意味着路由的逻辑在其他地方——保持routes.js文件简洁明了。这在大型企业级应用程序中非常重要，因为它提供了控制和良好的代码组织。</p><p id="5d45" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">要开始使用Sails.js，请将其作为命令行工具安装到npm中，并运行生成器:</p><p id="0e25" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated"><code class="eh mu mv mw ml b">npm -g install sails</code> <br/> <code class="eh mu mv mw ml b">Sails.js new sails-test</code> <br/> <code class="eh mu mv mw ml b">cd sails-test</code> <br/></p><p id="89dc" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">生成的框架项目将包含以下文件夹:</p><p id="75b9" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated"><code class="eh mu mv mw ml b">/api</code>:控制器、模型、策略、响应(请求处理程序)、服务(可重用组件)等所有服务器端逻辑<br/> <code class="eh mu mv mw ml b">/assets</code>:静态资产，如图片、前端JavaScript、样式等。<br/> <code class="eh mu mv mw ml b">/config</code>:环境、地区、中间件<br/> <code class="eh mu mv mw ml b">/tasks</code>等配置设置:人工构建任务<br/> <code class="eh mu mv mw ml b">/views</code>:服务器端模板</p><p id="f840" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">在撰写本文的最后一个月(2018年3月)，Social proof，Sails.js在<strong class="kc hv">18553</strong>GitHub stars和<strong class="kc hv">79352</strong>NPM下载量。</p><p id="b1ea" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">网址:<a class="ae lo" href="http://sailsjs.org/" rel="noopener ugc nofollow" target="_blank">http://sailsjs.org</a></p><p id="2f32" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">GitHub:<a class="ae lo" href="https://github.com/balderdashy/sails/" rel="noopener ugc nofollow" target="_blank">https://github.com/balderdashy/sails/</a></p><p id="665b" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">https://www.npmjs.org/package/sails<a class="ae lo" href="https://www.npmjs.org/package/sails" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="4128" class="lp jd hu bd je lq lr ls ji lt lu lv jm lw lx ly jq lz ma mb ju mc md me jy mf dt translated">裁决</h1><p id="80ba" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">我有意省略了构建Node.js/Io.js应用程序的默认选择Express.js，因为它缺乏代码生成器、组织和内置数据库支持，这太容易被人发现了。然而，你不应该低估Express.js。对于快速原型或高度定制的项目，它可能是一个更好的选择。Express.js/Connect中间件模块的数量是巨大的。这就是你可能想要选择Sails.js的原因，它们与Express.js中间件兼容。</p><p id="c547" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">目前(2018年3月)在Node.js-framework领域绝对是重量级的。他们带来了内置的ORM/ODM和丰富的脚手架，这将节省开发人员的时间。</p><p id="cb15" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">Sails.js的弊端显而易见。与任何全面的框架一样，特别是那些使用约定而不是配置的框架，它们对开发人员来说很神奇，需要一定的学习。</p><p id="16b8" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">哈比神独树一帜，因为它的架构在设计上与Express.js不同。这允许对请求和响应生命周期进行更细粒度的控制。</p><p id="0547" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">尽管我将GitHub stars和上个月的npm下载量作为趋势的代表，但对社会证据还是要有所保留。这并不总是准确的，因为一个框架存在的时间越长，推广得越好，统计数据就越大。相反，一个高级库的统计数据可能会更低，只是因为这个模块更新。</p><p id="a897" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">我不打算支持任何特定的框架。在大多数情况下，它们明显优于编写和维护自己的库或使用基本的Express.js。我的建议是根据它们的优缺点来使用它们，因为它适合您的特定项目。</p><p id="a827" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated">如果您认为这是一篇值得一读的文章，请不要犹豫，继续关注medium(<a class="mx my gr" href="https://medium.com/u/19d365322daa?source=post_page-----e31f05cc1da--------------------------------" rel="noopener" target="_blank">Shailesh shek hawat</a>)获取更多的javascript文章！</p></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="c36a" class="pw-post-body-paragraph ka kb hu kc b kd kx kf kg kh ky kj kk jn ll km kn jr lm kp kq jv ln ks kt ku hn dt translated"><em class="ng">原载于</em><a class="ae lo" href="https://101node.io" rel="noopener ugc nofollow" target="_blank"><em class="ng">101 node . io</em></a><em class="ng">。</em></p><figure class="mg mh mi mj fq iv"><div class="bz el l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>