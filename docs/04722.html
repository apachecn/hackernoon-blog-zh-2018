<html>
<head>
<title>A Common Misunderstanding About Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python生成器的一个常见误解</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-common-misunderstanding-about-python-generators-dbc622914d33?source=collection_archive---------26-----------------------#2018-06-04">https://medium.com/hackernoon/a-common-misunderstanding-about-python-generators-dbc622914d33?source=collection_archive---------26-----------------------#2018-06-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9a09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几天前我收到了以下邮件:</p><blockquote class="jp jq jr"><p id="d68a" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><em class="hu">杰夫，</em></p><p id="bd92" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">看来你知道迭代器。也许你能解释一些奇怪的行为。如果你运行下面的代码，你会发现这个函数被区别对待，仅仅是因为它在某个地方有一个“yield ”,即使它完全不可及。</p></blockquote><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="47e2" class="kf kg hu kb b fv kh ki l kj kk">def func(): <br/>    print("&gt; Why doesn't this line print?") <br/>    exit() # Within this function, nothing should matter after this point. The program should exit <br/>    yield "&gt; The exit line above will exit ONLY if you comment out this line."</span><span id="e79c" class="kf kg hu kb b fv kl ki l kj kk">x = func()<br/>print(x)</span></pre><p id="f381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我运行代码时，我从<code class="eh km kn ko kb b">print()</code>调用中得到以下输出:<code class="eh km kn ko kb b">&lt;generator object func at 0x10e968a50&gt;</code>。</p><p id="3a6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是怎么回事？为什么<em class="js"/>不在<code class="eh km kn ko kb b">func()</code>印那行字？即使<code class="eh km kn ko kb b">yield</code>完全不可达，它<em class="js">似乎</em>会影响函数执行的方式。</p><h1 id="8bc8" class="kp kg hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated"><code class="eh km kn ko kb b">yield</code>如何影响一项功能</h1><p id="3ea7" class="pw-post-body-paragraph ir is hu it b iu lm iw ix iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">为了解释为什么会出现这种现象，让我们回顾一下<code class="eh km kn ko kb b">yield</code>。任何包含<code class="eh km kn ko kb b">yield</code>关键字的函数都会自动转换为<a class="ae lr" href="https://hackernoon.com/tagged/generator" rel="noopener ugc nofollow" target="_blank"> <em class="js">生成器</em> </a>。它返回的是一个<em class="js">生成器迭代器</em>。我们的打印输出实际上暗示了这一点:</p><p id="5bf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh km kn ko kb b">$ python yield.py</code> <code class="eh km kn ko kb b">&lt;generator object func at 0x10e968a50&gt;</code></p><p id="ae42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当<code class="eh km kn ko kb b">x = func()</code>被执行时，<em class="js">我们实际上并没有执行</em> <code class="eh km kn ko kb b"><em class="js">func()</em></code>内的任何代码。相反，因为<code class="eh km kn ko kb b">func()</code>是一个<em class="js">生成器</em>，所以返回一个<em class="js">生成器迭代器</em>。因此，虽然这看起来像一个函数调用，但它实际上给了我们<em class="js">生成器迭代器</em>，我们将使用它来生成由<em class="js">生成器</em>生成的值。</p><p id="49db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们实际上如何“调用”一个<em class="js">发生器</em>？<em class="js">通过在生成器迭代器</em>上调用 <code class="eh km kn ko kb b"><em class="js">next()</em></code> <em class="js">。在上面的代码中，这将执行对由<code class="eh km kn ko kb b">func()</code>返回并绑定到<code class="eh km kn ko kb b">x</code>的<em class="js">生成器迭代器</em>的“下一个”调用。</em></p><p id="01f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想看到这个神秘的信息被打印出来，只需将代码的最后一行改为<code class="eh km kn ko kb b">print(next(x))</code>。</p><p id="7e5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，在应该被视为迭代器的东西上反复调用<code class="eh km kn ko kb b">next()</code>有点麻烦。幸运的是，<code class="eh km kn ko kb b">for</code>循环支持对<em class="js">生成器迭代器</em>的迭代。想象一个玩具发电机，实现如下:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="8c7b" class="kf kg hu kb b fv kh ki l kj kk">def one_to_ten(): <br/>    """Return the integers between one and ten, inclusive.""" <br/>    value = 1<br/>    while value &lt;= 10:<br/>        yield value value += 1</span></pre><p id="d0f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过以下方式在for循环中调用它:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="93f3" class="kf kg hu kb b fv kh ki l kj kk">for element in one_to_ten(): <br/>    print(element)</span></pre><p id="ef95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，我们可以写得更冗长些:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="985e" class="kf kg hu kb b fv kh ki l kj kk">iterator = one_to_ten()<br/>for element in iterator:<br/>    print(element)</span></pre><p id="899f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这类似于原始代码所做的。它只是没有使用<code class="eh km kn ko kb b">x</code>来实际执行<em class="js">生成器</em>中的代码。</p><h1 id="510f" class="kp kg hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">摘要</h1><p id="847f" class="pw-post-body-paragraph ir is hu it b iu lm iw ix iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">我希望这能澄清一些关于<a class="ae lr" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>中<code class="eh km kn ko kb b">yield</code>和<code class="eh km kn ko kb b">generators</code>的常见问题。有关该主题的更深入的教程，请查看<a class="ae lr" href="https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/" rel="noopener ugc nofollow" target="_blank">改进您的Python:“yield”和解释的生成器</a>。</p><p id="621e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Jeff Knupp于2018年6月4日发布</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><p id="1fed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="js">原载于2018年6月4日</em><a class="ae lr" href="https://jeffknupp.com/blog/2018/06/04/a-common-misunderstanding-about-python-generators/" rel="noopener ugc nofollow" target="_blank"><em class="js">jeffknupp.com</em></a><em class="js">。</em></p><figure class="jw jx jy jz fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure></div></div>    
</body>
</html>