<html>
<head>
<title>State Management in React Apps — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用程序中的状态管理—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/state-management-in-react-apps-part-i-9f46ebed2f6c?source=collection_archive---------37-----------------------#2018-06-04">https://medium.com/hackernoon/state-management-in-react-apps-part-i-9f46ebed2f6c?source=collection_archive---------37-----------------------#2018-06-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="435b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你知道如何<a class="ae jp" href="https://kolosek.com/react-jsx-loops/" rel="noopener ugc nofollow" target="_blank">正确使用JSX </a>以及<a class="ae jp" href="https://kolosek.com/react-props-basic/" rel="noopener ugc nofollow" target="_blank">反应组件如何相互通信</a>你就是一个真正的英雄。但是，您应该问自己一个重要的问题:<em class="jq">在哪里存储您的应用程序关心的信息？</em></p><p id="4b49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来谈谈React中的应用程序状态管理。</p><p id="1512" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多方法可以处理应用程序状态，但是首先，让我们来看看最简单的一种——组件的状态。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/c588302483f4925325e54e3982d2b39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BFX_IBUqGlnQVCrC.png"/></div></div></figure><h1 id="35dc" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">对组件状态做出反应</h1><p id="8c50" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">你可能以前看过<code class="eh lg lh li lj b">this.state</code>。一个组件有它的本地状态，一个目的是保存对组件重要的信息的对象，比如你应该呈现的电影列表。这个本地状态首先在构造函数中初始化，如下所示:</p><pre class="js jt ju jv fq lk lj ll lm aw ln dt"><span id="0fc7" class="lo ke hu lj b fv lp lq l lr ls">constructor() {<br/>    super();<br/>    this.state = {<br/>        itemKey: defaultItemValue,<br/>        ...<br/>    };<br/>}</span></pre><p id="048e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，您应该为您将在组件中使用的每个状态属性定义一个默认值，即使初始值是<code class="eh lg lh li lj b">undefined</code>。</p><p id="d9a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">您应该在组件状态中存储什么？</em>关于什么时候使用组件的状态，以及什么时候转向更高级的方法，有一个争论:过去许多开发人员强迫你根本不应该使用<code class="eh lg lh li lj b">this.state</code>，但是你应该保持所有东西在全局可访问的状态(即redux状态——稍后会提到)，即使它只是一个用于<a class="ae jp" href="https://kolosek.com/react-jsx-conditions/" rel="noopener ugc nofollow" target="_blank">条件渲染</a>的简单开关。</p><p id="3b5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，如果一个值只在这一个组件中使用，那么在redux状态中保持该值是没有意义的；如果正在开发的应用程序非常简单，就没有必要引入另一个依赖项，比如一个单独的状态管理库。一开始，当学习React时，最好坚持使用<code class="eh lg lh li lj b">this.state</code>，因为它不需要深入另一个库。</p><p id="e59d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React组件的状态被异步更新。您将使用<code class="eh lg lh li lj b">this.setState</code>功能来更新您的状态。然而，有一件事要永远记住:当一个setState依赖于前一个setState时，你不应该连续使用<code class="eh lg lh li lj b">setState</code>两次，因为它的异步特性。</p><pre class="js jt ju jv fq lk lj ll lm aw ln dt"><span id="791d" class="lo ke hu lj b fv lp lq l lr ls">// assuming this.state.count === 0<br/>this.setState({<br/>    count: this.state.count + 1<br/>});<br/>this.setState({<br/>    count: this.state.count + 1<br/>});<br/>// it doesn't necessarily mean that this.state.count will be 2 now</span></pre><p id="705b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，你可以使用所谓的<em class="jq">功能设置状态</em>来设置依赖于先前状态或依赖于某些<a class="ae jp" href="https://kolosek.com/react-props-basic/" rel="noopener ugc nofollow" target="_blank">组件的属性</a>的状态:</p><pre class="js jt ju jv fq lk lj ll lm aw ln dt"><span id="f574" class="lo ke hu lj b fv lp lq l lr ls">this.setState((previousState, currentProps) =&gt; {<br/>    return {<br/>        count: previousState.count + 1,<br/>    };<br/>});</span></pre><p id="99fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用函数setState是使用setState的最佳方式。</p><p id="912b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想要更改保存在状态中的多个值，您不需要多次调用setState:</p><pre class="js jt ju jv fq lk lj ll lm aw ln dt"><span id="f8c6" class="lo ke hu lj b fv lp lq l lr ls">// "standard" way<br/>this.setState({<br/>    item1: value1,<br/>    item2: value2,<br/>});<br/>// "functional" way<br/>this.setState((previousState, currentProps) =&gt; {<br/>     return {<br/>         item1: value1,<br/>         item2: value2,<br/>     };<br/>});</span></pre><p id="fdc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">状态不应该变异。这既适用于简单组件的状态，也适用于一些更高级的组件，比如第三方redux状态。组件的状态只能通过使用<code class="eh lg lh li lj b">setState</code>功能来改变。虽然您可以只使用<code class="eh lg lh li lj b">this.state.disabled = true</code>，但它不会触发组件的重新呈现。没有防止状态下保存的变异物品，所以你要关心自己不要变异它们。</p><p id="dadf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止，我已经介绍了React组件的状态和它的三个基本概念:它是<strong class="it hv">不可变的</strong>、<strong class="it hv">异步的</strong>和<strong class="it hv">局部的</strong>。这是在简单的应用程序中处理存储信息的一种快捷方式，对于应该从组件实例中的多个位置访问的局部变量也是如此，甚至在非常大和复杂的应用程序中也是如此。</p><p id="5e0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，对于更复杂的应用程序，对于过于依赖彼此状态的<a class="ae jp" href="https://kolosek.com/react-props-communication/" rel="noopener ugc nofollow" target="_blank">组件</a>，以及为了更好地处理应用程序使用的数据，有第三方库，如Redux、Flux、CerebralJS和许多其他库，它们提供了更高级的方法来处理应用程序状态。下次我一定会写更多关于他们的东西。</p><p id="44ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">敬请关注更多React内容！</em></p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><p id="858c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">原载于2018年6月4日kolosek.com</em><em class="jq">T21</em><a class="ae jp" href="https://kolosek.com/react-state/?utm_source=me" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>