<html>
<head>
<title>The Magic of Array References in Perl</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Perl中数组引用的魔力</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-magic-of-array-references-in-perl-cb0bdd82a448?source=collection_archive---------3-----------------------#2018-06-05">https://medium.com/hackernoon/the-magic-of-array-references-in-perl-cb0bdd82a448?source=collection_archive---------3-----------------------#2018-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/3a8eb0025bc9f72b80b7db5ab5abf4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*fNWVVG2QFZjuxmpR9K1rBA.png"/></div></figure><div class=""/><p id="f5bc" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在编程的世界里，如果不遇到嵌套的数据结构，你不可能走得很远。例如，JavaScript对象可能如下所示:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="0cea" class="kf kg ib kb b fv kh ki l kj kk">var cats = {<br/>	"name":"Mr. Tickles",<br/>	"owners": {<br/>		   "owner1" : "Tom",<br/>		   "owner2" : "Janet"<br/>		},<br/>	"color":"orange<br/>};</span></pre><p id="42d7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这个例子中，我们在一个更大的cats对象中嵌套了多个owner对象。对于数组，我们也可以有类似的东西:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="571b" class="kf kg ib kb b fv kh ki l kj kk">var array1 = [["one", "two"], ["three", "seven", "five"]];</span></pre><p id="8162" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，我们有一个嵌套数组，或数组的数组。</p><p id="7e28" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在JavaScript中，可以使用点符号或括号符号来访问嵌套对象。对于数组，您可以调用<code class="eh kl km kn kb b">array1[0]</code>，这个调用的预期输出将是数组中的第一个数组，即<code class="eh kl km kn kb b">[“one”, “two”]</code>。</p><p id="3cf9" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我们在Perl中访问数据的主要区别。尽管两种语言的语法非常相似，但在Perl中访问嵌套数据可能会稍微困难一些。例如，如果我们有上面相同的嵌套数组，保存数组的变量是<code class="eh kl km kn kb b">@array1</code>，我们想访问$array1中的第一个数组，并使用调用，<code class="eh kl km kn kb b">@array1[0], </code>，我们实际得到的输出将是第一个元素，<code class="eh kl km kn kb b">“one”.</code></p><p id="6191" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是因为Perl展平了所有嵌套数据。如果您有一个包含多个数组的数组，Perl将其解释为单个数组，并将所有数组数据混合在一起。Perl也以非常相似的方式解释对象或散列。</p><h1 id="bf84" class="ko kg ib bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">输入数组引用</h1><p id="3797" class="pw-post-body-paragraph iy iz ib ja b jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv hn dt translated">如果您不打算在访问数据时将所有数据展平，那么最好的解决方案是在定义数组变量时使用数组引用。这是在创建数组时完成的，远在我们打算访问数组之前。如果数据不是作为引用存储的，我们就不能作为引用访问它。</p><p id="9f15" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的例子中，我们可以如下定义它来实现这一点:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="304a" class="kf kg ib kb b fv kh ki l kj kk">my @array1 = ();</span></pre><p id="f724" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里，我们只是创建一个空数组来存放嵌套数组。接下来，我们可以将新数组放入数组容器中。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="3ac9" class="kf kg ib kb b fv kh ki l kj kk">my @nestedArray = ("one", "two");<br/>my @nestedArray2 = ("five", "seven", "three");</span></pre><p id="6dcd" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此时，我们可能会尝试使用以下代码:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="34ec" class="kf kg ib kb b fv kh ki l kj kk">push @array1, @nestedArray;</span></pre><p id="af0d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就完成了我们之前所做的，一个扁平的数组。相反，在将数组推入容器数组之前，我们将创建数组的引用。</p><h1 id="10cf" class="ko kg ib bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">创建参考:</h1><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="7177" class="kf kg ib kb b fv kh ki l kj kk">my $nestedArray = \@nestedArray;</span></pre><p id="b32f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这将创建一个标量变量来保存嵌套数组引用。引用实际上是使用反斜杠符号创建的。</p><p id="f4be" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们可以复制上面的代码，将引用推入数组:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="7d3c" class="kf kg ib kb b fv kh ki l kj kk">push @array1, $nestedArray;</span></pre><h1 id="cf5e" class="ko kg ib bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">取消引用被引用的数组:</h1><p id="90f0" class="pw-post-body-paragraph iy iz ib ja b jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv hn dt translated">使用同样的格式，我们可以将尽可能多的嵌套数组放入数组容器中。稍后，我们可能需要访问这些引用。让我们首先想象一下我们的嵌套数据是这样的:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="e223" class="kf kg ib kb b fv kh ki l kj kk">@array1 = [[1, 2, 4], [3, 4, 5], [8, 8, 9], [6, 7, 6]];</span></pre><p id="94f5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里，我们在一个数组容器中嵌套了四个数组，每个嵌套的数组包含3个整数。让我们尝试访问最后一个嵌套数组中的第一个整数。</p><p id="b011" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">起初，访问引用数组的语法似乎有点复杂。首先，我将把代码放在这里，然后解释它是如何工作的:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="12af" class="kf kg ib kb b fv kh ki l kj kk">@{ $array1[3] }[0];</span></pre><p id="13d5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">花括号前面的@符号告诉Perl我们正在访问一个数组，数组变量前面的$(标量)符号让我们只能访问容器中的一个数组。[3]让我们访问数组中的第4个元素，它位于索引[3]。这得到了序列中的最后一个数组，然后在这个块的末尾，我们有了熟悉的[0]，它告诉Perl我们想要这个数组中的第一个元素。我们在这里的预期收益是6。</p><p id="3267" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，让我们来看一个更复杂的问题，我们将不得不在一个循环中使用许多引用。这是一个叫做最大路径和的问题。以下面的三角形数字为例:</p><p id="8792" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">3，<br/> 7，4 <br/> 2，4，6 <br/> 8，5，9，3</p><p id="198b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里的目标是从上到下，找到最大和路径，只向右或向左移动。例如，从第二行开始，如果我们选择7，我们就不能访问6。在本例中，最大和路径为3、7、4、9，和为23。</p><p id="e646" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">知道了解决方案之后，让我们使用Perl和数组引用来逆向解决这个问题。要记住的第一件事是，对于较大的三角形，使用蛮力(尝试每一种数字组合)是不可能解决这个问题的。解决这类问题的最好方法实际上是逆向工作。我们将从第3行或示例开始，根据当前数字下两个可能数字的总和来测试每个数字。第一个数字是2，我们可能的组合是8和5。这里最大的可能和是10 ( 8 + 2)。在我们对每个数字完成这个过程后，我们只需删除最后一行，并用最高的和替换第三行。我们的新三角形如下所示:</p><p id="57f8" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">3、<br/> 7、4 <br/> 10、13、15</p><p id="4969" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们将对第二行做同样的事情，这将得到:</p><p id="6f79" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">3、<br/> 20、19</p><p id="4726" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后一行是23。</p><p id="dcd4" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从编程的角度来考虑这个过程，我们的数据输入可能是一个数组，而不是一个三角形:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="6e4f" class="kf kg ib kb b fv kh ki l kj kk">my <a class="ae lq" href="http://twitter.com/triangle" rel="noopener ugc nofollow" target="_blank">@triangle</a> = (3,7,4,2,4,6,8,5,9,3);</span></pre><p id="e34c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们接下来的过程可能是把它分成几行。这就是嵌套引用数组发挥作用的地方。我们想要的最终结果是这样的:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="28a5" class="kf kg ib kb b fv kh ki l kj kk">my <a class="ae lq" href="http://twitter.com/triangle" rel="noopener ugc nofollow" target="_blank">@triangle</a> = ([3],[7,4],[2,4,6],[8,5,9,3]);</span></pre><p id="d8a0" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最简单的方法是循环遍历我们的数组，创建每个嵌套数组的引用，并将其推入一个新数组。</p><p id="8f5b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有一种方法可以做到这一点:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="c6b4" class="kf kg ib kb b fv kh ki l kj kk">my <a class="ae lq" href="http://twitter.com/choppedTriangle" rel="noopener ugc nofollow" target="_blank">@choppedTriangle</a> = []; <br/>my <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a> = ();  #Our new array container<br/>my $start = 0;<br/>my $stop = 0;<br/>my $length = 1;<br/>my $row = 1;<br/>my $triangle = <a class="ae lq" href="http://twitter.com/triangle" rel="noopener ugc nofollow" target="_blank">@triangle</a>;<br/>while (<a class="ae lq" href="http://twitter.com/choppedTriangle" rel="noopener ugc nofollow" target="_blank">@choppedTriangle</a> &lt; <a class="ae lq" href="http://twitter.com/triangle" rel="noopener ugc nofollow" target="_blank">@triangle</a>) {<br/>my <a class="ae lq" href="http://twitter.com/row" rel="noopener ugc nofollow" target="_blank">@row</a> = ();<br/>for (my $i=$start; $i &lt;= $stop; $i++) {<br/>push <a class="ae lq" href="http://twitter.com/choppedTriangle" rel="noopener ugc nofollow" target="_blank">@choppedTriangle</a>, $triangle[$i];<br/>push <a class="ae lq" href="http://twitter.com/row" rel="noopener ugc nofollow" target="_blank">@row</a>, $triangle[$i];<br/>};</span><span id="adc8" class="kf kg ib kb b fv lr ki l kj kk">my $row = \<a class="ae lq" href="http://twitter.com/row" rel="noopener ugc nofollow" target="_blank">@row</a>;<br/>push <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>, $row;<br/>$start = $stop + 1;<br/>$length = $length + 1;<br/>$stop = $stop + $length;<br/>};</span></pre><p id="505c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里，我们在while循环中使用了for循环。在循环中，在每次迭代中，我们将每个@row推入@choppedTriangle。这不是一个数组引用，这是故意的。在这种情况下，我们应该只有4个嵌套数组，并且我们不想推送任何超过4个嵌套数组的东西。@triangle也有4个嵌套数组，所以只要两个数组相等，我们的while循环条件语句就会停止。一旦我们将所有行推入@choppedtriangle，我们就要结束循环。</p><p id="b7e9" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这些工作都将在我们的for循环中完成。在for循环之外，但仍在while循环中，我们将为每一行创建一个数组引用，您可以在下面的行中看到这一点:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="cb09" class="kf kg ib kb b fv kh ki l kj kk">my $row = \@row;<br/>push <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>, $row;</span></pre><p id="89fc" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后我们将这个引用放入我们的@chopped数组。我只使用@choppedtriangle作为while循环的条件，一旦循环完成，我就不再需要使用它了。但是，我需要的所有嵌套数组都包含在@chopped中。</p><p id="9d36" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我还在循环中使用$start、$stop和$length变量，使用这些变量作为索引来确定每一行的开头和结尾。例如，两者都从0开始，这将是[$start]的索引。因为我们要提取的第一个元素在索引0处，所以这是完美的。在每次循环之后，我们将调整变量$start和$stop，让Perl知道新行的长度。新行将从第一行结束的地方开始，因此:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="2452" class="kf kg ib kb b fv kh ki l kj kk">$start = $stop + 1;</span></pre><p id="30f3" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">那么长度也将是<code class="eh kl km kn kb b">$length = $length + 1</code>，因为我们从第1行开始，随后的每一行都长了一个字符。然后，不管新的长度是多少，我们将使用该值来设置新的<code class="eh kl km kn kb b">$stop</code>变量，它将只是长度之后的一个字符，允许我们获取新的<code class="eh kl km kn kb b">$start </code>和<code class="eh kl km kn kb b">$stop</code>变量之间的所有内容。</p><p id="4356" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这样一来，我们现在应该有一个包含4个嵌套数组的数组了。接下来我们要做的是遍历数组，然后遍历每个嵌套的数组。我们想要做与前面提到的完全相同的事情，将当前行与其下一行进行比较，并用最大和替换这些值。我的想法是这样的。假设我们当前的行是这样的:</p><p id="164f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">[ 2，4]下面一行是[1，2，3]。</p><p id="ac4c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我将创建一个临时数组，并遍历第一行。这个循环将只包含2次迭代，因为数组的长度只有2。在每次迭代中，我将进行2次比较，2+1和2+2，然后是4+2和4+3。在每次迭代中，我将取最大的比较和，并将其放入临时数组。所以我的临时数组现在保存了值[4，7]。</p><p id="fac0" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我将用新的临时数组[4，7]替换前面的行[2，4]。</p><p id="9c1d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我将重置我正在处理的行，新行是三角形上的下一行，我将重置我正在比较的行，这将是我们刚刚设置的行，[4，7]。</p><p id="7f84" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我把我要用的代码放在这里，然后我会解释我是如何得到它的:</p><p id="28bc" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我将创建两个变量来控制我要迭代的行:</p><p id="e65e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kl km kn kb b">my $iter = 1;<br/>my $iter2 = 2;</code></p><p id="762b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我在这里的想法是，我将在每个循环结束时改变这些变量，这将允许我移动到下一行。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="fb16" class="kf kg ib kb b fv kh ki l kj kk">my <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a> = ();<br/>my $chopRows = <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-1;<br/>for (my $i=0; $i &lt; $chopRows; $i++) {<br/><a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a> = ();<br/>for (my $i=0; $i &lt; @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }; $i++) {</span><span id="5cf0" class="kf kg ib kb b fv lr ki l kj kk">if(@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i] &gt; @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i+1])<br/>{<br/>push <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>, @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i];<br/>}<br/>else<br/>{push <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>,@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i+1];<br/>};<br/>};<br/>@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] } = <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>;<br/>$iter = $iter + 1;<br/>$iter2 = $iter2 + 1;<br/>};</span></pre><p id="c68d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一部分可能看起来很奇怪:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="096b" class="kf kg ib kb b fv kh ki l kj kk">my <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a> = ();<br/>my $chopRows = <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-1;<br/>for (my $i=0; $i &lt; $chopRows; $i++) {<br/><a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a> = ();</span></pre><p id="37ec" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因为我创建了临时数组，然后在for循环中再次调用它。原因是，当for循环结束时，我应该有新的值在那里，代表总和。一旦我回到循环的开始，我需要清空临时数组。因为我在循环之外创建了数组，如果我没有在每次循环开始时清空它的内容，那么到第4次迭代(我们的三角形的第4行)，我们将拥有一个包含整个三角形的所有总和的数组…而我们想要的只是当前行。现在，在我的第二个循环中，我们有这个:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="845e" class="kf kg ib kb b fv kh ki l kj kk">for (my $i=0; $i &lt; @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }; $i++) {</span></pre><p id="3e08" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，这只是一个非常基本的for循环，中间有一个奇特的长度控制。<code class="eh kl km kn kb b">@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] };</code></p><p id="39e3" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">希望这看起来很熟悉，因为这正是我们先前用来解引用数组并访问其内容的方法:</p><p id="9d83" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kl km kn kb b">@{ $array1[3] }[0];</code></p><p id="49f7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kl km kn kb b">[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] </code>这里的<code class="eh kl km kn kb b">$iter2</code>变量，目前是“2”，指向倒数第二行，基本上是从<code class="eh kl km kn kb b">@chopped</code>数组的末尾开始工作，向后退两位。这意味着，我们将遍历倒数第二行中的数字，并将它们与最后一行进行比较。完成后，我们可以将<code class="eh kl km kn kb b">$iter2</code>改为3，或者简单地称为<code class="eh kl km kn kb b">$iter2 = $iter2 + 1</code>。这将允许我们访问倒数第三行，然后我们可以继续重复这个过程。</p><p id="0d5b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了简单起见，我们在for循环中只有一个条件语句。这将当前整数与其下两个可能的整数进行比较。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="314f" class="kf kg ib kb b fv kh ki l kj kk">if(@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i] &gt; @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i+1])</span></pre><p id="328e" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里，我们正在访问解引用数组<code class="eh kl km kn kb b">@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i]</code>的值。这代表上一行的当前迭代，我们正在观察它和<code class="eh kl km kn kb b">@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i]</code>的和是否大于<code class="eh kl km kn kb b">@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i+1])</code>。这里，我们使用了变量$iter2和$iter，给出了每一行的值，$iter是底部的行，$iter2是上面的行。</p><p id="c26f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果该条件返回true，我们将推送当前值:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="12c5" class="kf kg ib kb b fv kh ki l kj kk"><a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>, @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i];</span></pre><p id="c96b" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">否则我们就推行另一种价值观。这样我们就不需要比较值是否相等了。因为如果第一个值不太大，我们会忽略另一个值，因为它们是否相同并不重要。</p><p id="662f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，在循环结束时，我们重置当前行的值，用temparray替换它的值，同时重置$iter和$iter2变量的值:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="0e96" class="kf kg ib kb b fv kh ki l kj kk">@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] } = <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>;<br/>$iter = $iter + 1;<br/>$iter2 = $iter2 + 1;</span></pre><p id="f585" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这使我们回到循环的顶部，在那里我们重置@temparray值，并从下一行开始。我们现在可以打印@tempArray的值，它将保存最终值。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="0f5c" class="kf kg ib kb b fv kh ki l kj kk">foreach my $x (<a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>) {<br/>  print "$x \n";<br/>}</span></pre><p id="d5de" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要查看完整的代码块，下面是我得到的结果:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="08e5" class="kf kg ib kb b fv kh ki l kj kk">#!/usr/bin/perl<br/>use strict;<br/>use warnings;<br/># By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.<br/># 3,<br/># 7, 4<br/># 2, 4, 6<br/># 8, 5, 9, 3<br/># 23!<br/># starting triangle array<br/>my <a class="ae lq" href="http://twitter.com/triangle" rel="noopener ugc nofollow" target="_blank">@triangle</a> = (3,7,4,2,4,6,8,5,9,3);<br/># array to hold<br/>my <a class="ae lq" href="http://twitter.com/choppedTriangle" rel="noopener ugc nofollow" target="_blank">@choppedTriangle</a> = [];<br/>my <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a> = ();<br/>my $start = 0;<br/>my $stop = 0;<br/>my $length = 1;<br/>my $row = 1;<br/>my $triangle = <a class="ae lq" href="http://twitter.com/triangle" rel="noopener ugc nofollow" target="_blank">@triangle</a>;<br/>while (<a class="ae lq" href="http://twitter.com/choppedTriangle" rel="noopener ugc nofollow" target="_blank">@choppedTriangle</a> &lt; <a class="ae lq" href="http://twitter.com/triangle" rel="noopener ugc nofollow" target="_blank">@triangle</a>) {<br/>my <a class="ae lq" href="http://twitter.com/row" rel="noopener ugc nofollow" target="_blank">@row</a> = ();<br/>for (my $i=$start; $i &lt;= $stop; $i++) {<br/>push <a class="ae lq" href="http://twitter.com/choppedTriangle" rel="noopener ugc nofollow" target="_blank">@choppedTriangle</a>, $triangle[$i];<br/>push <a class="ae lq" href="http://twitter.com/row" rel="noopener ugc nofollow" target="_blank">@row</a>, $triangle[$i];<br/>};</span><span id="fd4a" class="kf kg ib kb b fv lr ki l kj kk">my $row = \<a class="ae lq" href="http://twitter.com/row" rel="noopener ugc nofollow" target="_blank">@row</a>;<br/>push <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>, $row;<br/>$start = $stop + 1;<br/>$length = $length + 1;<br/>$stop = $stop + $length;<br/>};<br/>my $iter = 1;<br/>my $iter2 = 2;</span><span id="f751" class="kf kg ib kb b fv lr ki l kj kk">my <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a> = ();<br/>my $chopRows = <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-1;<br/>for (my $i=0; $i &lt; $chopRows; $i++) {<br/><a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a> = ();<br/>for (my $i=0; $i &lt; @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }; $i++) {</span><span id="8fad" class="kf kg ib kb b fv lr ki l kj kk">if(@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i] &gt; @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i+1])<br/>{<br/>push <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>, @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i];<br/>}<br/>else<br/>{push <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>,@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] }[$i] + @{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter] }[$i+1];<br/>};<br/>};<br/>@{ $chopped[scalar <a class="ae lq" href="http://twitter.com/chopped" rel="noopener ugc nofollow" target="_blank">@chopped</a>-$iter2] } = <a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>;<br/>$iter = $iter + 1;<br/>$iter2 = $iter2 + 1;<br/>};</span><span id="b521" class="kf kg ib kb b fv lr ki l kj kk">foreach my $x (<a class="ae lq" href="http://twitter.com/tempArray" rel="noopener ugc nofollow" target="_blank">@tempArray</a>) {<br/>  print "$x \n";<br/>}</span></pre><p id="8d25" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这可能有点难以理解，但是我发现，当习惯于在Perl中引用和解引用嵌套数据时，这样一个复杂的场景有助于我理解正在发生的事情，以及它为什么如此有用。如果你有任何反馈，请告诉我！</p></div></div>    
</body>
</html>