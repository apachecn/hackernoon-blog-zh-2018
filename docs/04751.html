<html>
<head>
<title>DotNetify-React Released: Build Reactive MVVM Apps with React + SignalR .NET Core 2.1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DotNetify-React发布:用React + SignalR构建反应式MVVM应用。网络核心2.1</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/https-hackernoon-com-dotnetify-react-released-efc7de44a47e?source=collection_archive---------8-----------------------#2018-06-05">https://medium.com/hackernoon/https-hackernoon-com-dotnetify-react-released-efc7de44a47e?source=collection_archive---------8-----------------------#2018-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1423c567dca829e3a63362c99b362112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wj7-WhZE2ABmabXLHsB92g.png"/></div></div></figure><p id="c021" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经过一年多的测试，我很高兴地宣布<a class="ae ka" href="https://github.com/dsuryd/dotNetify" rel="noopener ugc nofollow" target="_blank"> dotNetify-React终于发布了(3.0) </a>并准备好在后端定位的web应用上使用。网芯2.1。</p><p id="60c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DotNetify是一种简单、轻量级但功能强大的构建实时web应用程序的方法。它利用SignalR <a class="ae ka" href="https://hackernoon.com/tagged/technology" rel="noopener ugc nofollow" target="_blank">技术</a>在后端 上使用反应式MVVM范式<strong class="je hv"> <em class="kb">来实现基于WebSocket的web开发。最初创建它是为了与KnockoutJS一起工作，现在它可以与React和本地React一起使用。</em></strong></p><p id="2ab3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我之前的文章已经触及了反应式<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>和后端MVVM的话题；为什么我认为它们是web应用程序开发的理想选择，尤其是涉及实时数据编排和可视化的复杂应用程序。</p><p id="d714" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看看自那以后还有什么新的东西。</p><h1 id="f731" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">改进的反应式编程</h1><p id="ef3b" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">DotNetify以反应式视图模型属性的形式添加了对“函数式反应式编程”的一流支持。它们是静态或运行时创建的，可以立即从<em class="kb">系统连接到Rx APIs。Reactive.Linq </em>命名空间。</p><p id="0c55" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">提供了两个额外的API来进一步简化它:<em class="kb"> SubscribeTo </em>和<em class="kb">subscribe by</em>。他们在dispose上为你处理退订，让你的代码更流畅。例如，下面的简单代码将服务器的时钟实时推送到客户端浏览器:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/43c4d134829f1676d0fc6591bc7e2ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*fRU-ctkUwXjUB6CdeIVh3Q.png"/></div></figure><p id="a69c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb"> Clock </em>属性订阅每秒发出一个值的Rx observable，并将其转换为当前时间。反过来，它被<em class="kb">更新</em>属性订阅，每次更新时，该属性将<em class="kb">时钟</em>值推送给客户端。</p><p id="6a93" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种编程风格极具表现力、简洁，并且还有其他好处:</p><ul class=""><li id="eeca" class="lk ll hu je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">数据发布者(可观察对象)和订阅者(观察者)之间保持分离，</li><li id="f5fb" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">不需要将视图模型状态公开为公共属性，</li><li id="4500" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">显式订阅清楚地显示了依赖性和副作用，使事情变得容易推理，并且</li><li id="a154" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">可以说它最大的好处是:观察者能够订阅多个异步数据流，并通过一组强大的Rx LINQ函数以声明方式操纵它们，这些函数可以转换、组合、过滤和创建衍生流。</li></ul><h1 id="ce5a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">SignalR客户管理</h1><p id="4ef7" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">而信号员。NET Core破坏了与旧版本的兼容性。NET Framework版本，DotNetify两者都支持，并提供了一个简单的方法在它们之间切换。默认情况下，它被配置为与. NET核心后端对话，但是可以用这两行代码进行更改:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/47dd42ba31f263f1ee1a52f24df22372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*JFt4JiqdsSyMGcruc54o7w.png"/></div></div></figure><p id="2193" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以配置更多内容，例如，连接丢失时重试的次数、重试间隔、连接状态更改回调和跨域支持。</p><h1 id="bb7b" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">中间件/过滤器管道</h1><p id="b196" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">DotNetify允许您编写定制的中间件和过滤器——在到达视图模型之前拦截和转换WebSocket请求有效负载的能力，以及传出的响应。</p><p id="3fec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">抛出的异常也可以被拦截，并且有一个默认行为向客户端发送异常消息，因此您可以在浏览器的控制台日志中看到它们。</p><h1 id="5eaf" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">基于令牌的认证</h1><p id="e400" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">对JWT认证有现成的支持。客户端具有在初始连接上传递令牌的机制:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/802d5d890a76d9852f2eeb3792ccd0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*yQTuVPEh_XiHibNM28FPrw.png"/></div></figure><p id="595e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过内置中间件配置后端以提取和验证令牌后，您可以使用视图模型属性来基于声明或角色限制访问:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/3cbf18521c1b298a7d7e6ad665819db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*Ll6lrdO7bLBm9LL8fa15Uw.png"/></div></figure><h1 id="0921" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">依赖注入</h1><p id="9734" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">DotNetify与ASP.NET核心DI服务集成，这意味着您可以使用内置容器或您最喜欢的IoC库来实例化视图模型及其依赖关系。默认的作用域生存期只在HTTP请求的上下文中有意义，因此dotNetify通过将生存期的作用域设为持久WebSocket连接来覆盖它。</p><h1 id="0dce" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">React SPA模板</h1><p id="b011" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">去年年底，我发布了一个dotnet模板来快速创建一个React SPA ASP.NET核心+ WebPack项目，<a class="ae ka" href="https://hackernoon.com/introducing-real-time-react-spa-template-for-net-core-2-0-f13e64c3b7e9" rel="noopener ugc nofollow" target="_blank">在这里写了它</a>。此模板以材料UI主题中的实时仪表板演示为特色，并已更新以反映此版本。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/db82a4aa42da8b72b726679c32bfa00c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T7ZdOrPqK2NwgoWf.gif"/></div></div></figure><h1 id="c782" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">Angular或者Vue呢？</h1><p id="c102" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">虽然目前的重点是让dotNetify与React配合工作，但让dotNetify也与Angular或Vue配合工作并不需要太多时间。以下是Angular的示例:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/a404e709724d91f45d3041604b9ae850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*WQQJXXd87EAryJy9RFDQeA.png"/></div></figure><p id="56a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Vue也有一些社区努力；<a class="ae ka" href="https://github.com/dsuryd/dotNetify/issues/49" rel="noopener ugc nofollow" target="_blank">你可以在这里的Github问题论坛查看</a>。</p><h1 id="72d7" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">接下来会发生什么</h1><p id="2323" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">更令人兴奋的东西正在准备中。再过几周，<a class="ae ka" href="https://github.com/dsuryd/dotNetify-Elements" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="kb">dotNetify-Elements</em></strong></a>将首次亮相，希望你会发现它非常有用！这是一套后端就绪、可定制的React组件，让您可以构建专业外观的web应用程序，即使您只有很少的前端经验。一切都是以声明的方式完成的，并且使用了最少的Javascript。所以，敬请期待！</p><blockquote class="md me mf"><p id="0b22" class="jc jd kb je b jf jg jh ji jj jk jl jm mg jo jp jq mh js jt ju mi jw jx jy jz hn dt translated"><strong class="je hv">更新:<br/> dotNetify-Elements出来了！</strong> <a class="ae ka" href="http://www.dotnetify.net/elements/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">在这里查看文档和现场演示</strong> </a> <strong class="je hv">。</strong></p></blockquote><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>