<html>
<head>
<title>GRPC BFF for Swift iOS App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift iOS应用的GRPC BFF</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/grpc-bff-for-swift-ios-app-efdd52df7ce2?source=collection_archive---------17-----------------------#2018-06-05">https://medium.com/hackernoon/grpc-bff-for-swift-ios-app-efdd52df7ce2?source=collection_archive---------17-----------------------#2018-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2d68" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用gRPC(带HTTP/2流)进行移动后端联网，以优化UX响应性/反应性，并简化移动应用程序开发，而无需触及您的后端REST Api。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/e70c7fc0c43d44c14f02ce2ca6ecf095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpu1C2hxzZbeFrMbU1vSSQ.png"/></div></div></figure><h1 id="6e38" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">gRPC移动BFF</h1><p id="0dd2" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">本教程的重点是<em class="lj">后端对前端(BFF)设计模式</em>如何代表<a class="ae lk" href="https://hackernoon.com/tagged/mobile" rel="noopener ugc nofollow" target="_blank">移动</a>应用开发者“永远的好朋友”,特别是不同的技术如何帮助实现最佳BFF，从而为移动应用带来最佳<em class="lj">反应和响应</em>。</p><p id="f41d" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">一般来说，BFF的目标是简化客户端应用程序开发时间，分离“服务API”调用，潜在地减少调用的数量，并最终在不同的客户端实现之间共享一些逻辑，优化一般网络和数据转换，同时添加数据连接、分页、缓存、同步、流等的共享功能。最后实施安全和其他策略。</p><p id="6031" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">互联网上已经有很多教程介绍这种现在很常见的设计模式。在这里，我们不讨论多通道、微服务、api网关、服务网格，也不使用任何其他现代“服务器”术语，我们只是说BFF是移动应用程序和移动应用程序需要在云上或内部调用的每个“服务API”之间的“中间件”。</p><p id="bff1" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">本教程更具体地关注BFF模式如何有助于简化对这些服务API接口的访问，以及特别是gRPC协议的采用如何有助于减少数据量、优化网络以及实现和加强大量共享基础设施功能。</p><p id="41e7" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">当然，和许多其他领域一样，这里没有灵丹妙药。GraphQL等其他接口可以在某些场景下提供其他优势，而URLSession等特定移动技术在ios上的后台下载任务可以在特定移动环境下提供非常强大的网络优化控制(即有限的多任务处理)</p><h1 id="94f7" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">样本问题:必须抓住他们！</h1><p id="b50a" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在本教程中，我们将创建一个移动应用程序和一个BFF服务器来实际演示这种设计模式的优势。</p><p id="82f7" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">我们将创建一个Pokédex移动应用程序，使用公开可用的<a class="ae lk" href="http://pokeapi.co/" rel="noopener ugc nofollow" target="_blank">http://pokeapi.co/</a>REST API将允许用户按名称或类型搜索口袋妖怪，它将为每个找到的口袋妖怪显示以下信息:</p><ul class=""><li id="3ae4" class="lq lr hu kp b kq ll kt lm kw ls la lt le lu li lv lw lx ly dt translated">名字</li><li id="d023" class="lq lr hu kp b kq lz kt ma kw mb la mc le md li lv lw lx ly dt translated">图像</li><li id="6813" class="lq lr hu kp b kq lz kt ma kw mb la mc le md li lv lw lx ly dt translated">所有类型</li><li id="d294" class="lq lr hu kp b kq lz kt ma kw mb la mc le md li lv lw lx ly dt translated">身高和体重</li><li id="b7a9" class="lq lr hu kp b kq lz kt ma kw mb la mc le md li lv lw lx ly dt translated">他住的地方</li><li id="e912" class="lq lr hu kp b kq lz kt ma kw mb la mc le md li lv lw lx ly dt translated">物种栖息地的完整文本描述(风味文本)</li></ul><p id="7230" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">为了获得所有这些数据，将使用以下后端REST APIs:</p><ul class=""><li id="3a04" class="lq lr hu kp b kq ll kt lm kw ls la lt le lu li lv lw lx ly dt translated"><strong class="kp hv">/口袋妖怪</strong>:获取特定口袋妖怪名称的基本口袋妖怪数据</li><li id="8731" class="lq lr hu kp b kq lz kt ma kw mb la mc le md li lv lw lx ly dt translated"><strong class="kp hv">/口袋妖怪-物种</strong>:获取特定口袋妖怪的栖息地信息</li><li id="8c3c" class="lq lr hu kp b kq lz kt ma kw mb la mc le md li lv lw lx ly dt translated"><strong class="kp hv"> /type </strong>:获取特定类型名称的所有口袋妖怪列表</li></ul><h1 id="309d" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">为什么我们需要一个好朋友？</h1><p id="c9f2" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">但是等一下？这些口袋妖怪API只是简单的REST APIs，我可以很容易地从移动应用程序本身直接调用它们。为什么我需要gRPC，更重要的是为什么要使用BFF？</p><p id="42c0" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">没错。这些API可以被手机应用程序直接使用，但是让我们看看下图中这些简单方法的缺点。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff me"><img src="../Images/4ae63cec7a60b0f1eab8f0dad9a7d92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssoDfUULZ1gsf5usTNQAmw.png"/></div></div></figure><p id="7de3" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">首先，我们可以看到，即使这个超级简单的应用程序也需要协调来自三个不同网络API调用的数据。</p><p id="47c2" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">基本上，为了搜索特定类型的所有口袋妖怪，我们需要首先调用/type Rest API来获得口袋妖怪名称或Id的列表，然后对于该列表中的任何单个口袋妖怪，我们需要调用/pokemon Rest API来获得基本信息，如名称、类型、高度和宽度，还需要调用/pokemon-species Rest API来获得栖息地信息。</p><p id="4d82" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">除了需要“编排”对不同Rest API的调用之外，另一个需要关注的非常重要的事情是，所有这些pokemon Rest APIs都返回了更多的数据，这些数据实际上是我们渲染应用程序用户界面所真正需要的。</p><p id="dacb" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">事实上，在这个示例iOS移动应用程序中，我们将使用一个非常经典的UICollectionView接口，我们将需要在集合单元格中只显示我们上面介绍的口袋妖怪信息(名称、图像、类型等。).这些pokemon Rest APIs将通过网络(可能在蜂窝网络上)传输我们在简单的应用程序中根本不需要的许多其他数据。</p><h1 id="2d7c" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Node.js中的经典BFF</h1><p id="32f4" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">现在，BFF服务器在简化不同后端API调用的编排，以及在网络上过滤和向移动应用传输应用严格需要的数据方面的作用是否更加清晰了？</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/26d516e381bfb2a56dd4766f1081a461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*soxCDIlp53LbqXMgq0yn_w.png"/></div></div></figure><p id="0102" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">现在有很多不同的技术可以用来实现这个BFF服务器。原生iOS移动应用开发者现在甚至可以在Linux和服务器框架(如Kitura或Vapor)上使用<a class="ae lk" href="https://hackernoon.com/tagged/swift" rel="noopener ugc nofollow" target="_blank"> Swift </a>来轻松实现这些BFF。在这些Swift服务器框架的即将到来的新版本中采用苹果开源Swift Nio库也将很快提供更多的效率和可扩展性(参见<a class="ae lk" rel="noopener" href="/@JMangia/apple-swiftnio-netty-vert-x-grpc-and-service-mesh-ab5840c1b71c">https://medium . com/@ JMangia/Apple-Swift Nio-netty-vert-x-grpc-and-service-mesh-ab 5840 C1 b 71 c</a>)。</p><p id="c3fb" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">Node.js也是实现这种BFF服务器最常用的平台之一，因为它提供了极大的简单性，并从采用事件循环架构及其单线程异步I/O支持中获得了许多好处。</p><p id="2b7e" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">用Node.js和Express.js之类的Javascript框架超级容易实现这种BFF服务器。在与本教程相关的Github存储库中，您可以在BFF/Rest文件夹下找到这个REST BFF服务器的Node.js简单实现。</p><p id="24bf" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">正如我们之前在本教程的介绍中所讨论的，BFF也是实现基础设施功能的地方，例如认证、授权、缓存和其他通用功能。在我们的BFF Node.js实现中，特别是使用Javascript Node-Cache包实现了本地内存缓存，以便在本地存储从后端PokeApi返回的数据，并减少向后端的网络流量。</p><h1 id="daac" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">简化的API</h1><p id="de3b" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">我们已经说过，BFF也可以为移动应用程序提供一个简化的API接口。在我们的具体情况下，我们的BFF公开了一个独特和通用的/Search API，移动应用程序使用它来搜索单个特定的口袋妖怪名称或搜索特定类型名称的所有口袋妖怪。</p><p id="419c" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">下图说明了这个单一客户端API的伪代码实现，特别是它如何编排对我们前面已经介绍过的不同PokeApi调用的调用。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mf"><img src="../Images/69c768866439dddde5a424a76dcefa87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Grrg7AlAqfPex1kCveN4VQ.png"/></div></div></figure><p id="dc1b" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">有了这样的通用/搜索API，我们的移动应用程序的用户界面可以简化很多，基本上提供了一个单一的用户体验，可以同时搜索每个口袋妖怪类型或每个口袋妖怪的名字，而不必要求用户点击屏幕上的任何其他按钮，而是让移动应用程序本身在BFF的帮助下，理解用户只是搜索名字的简单通用意图。</p><p id="59ef" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">无论如何，BFF引入的这个新的抽象层与这个优化和简化的/Search API一起产生了关于最终用户体验的以下非常关键的问题:移动应用现在需要等待BFF /Search API输出的执行和网络传输，然后才能获得重新加载和呈现UICollecionView所需的所有数据。</p><p id="a4ce" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">基本上，在开始向用户显示新数据之前，移动应用程序需要等待BFF从缓存或调用PokeApi后端Rest API收集满足搜索请求所需的所有数据。</p><h1 id="653f" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Node.js中的gRPC BFF</h1><p id="e119" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">最后，我们将看到采用gRPC协议在我们的移动应用程序的响应性和反应性方面带来的好处。</p><p id="cb0a" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">本教程的目的不是全面介绍gRPC网络协议和协议缓冲数据协议。互联网上已经有很多很棒的教程。</p><p id="b6aa" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">这里，我们将简单地集中于现代HTTP/2网络协议的“透明”采用可以为我们的BFF实现以及移动应用和BFF之间的通信提供的优势，只需简单地使用将支持优化的HTTP/2流联网的gRPC服务接口。</p><p id="f24d" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">下图基本上预测了BFF模式的这一新功能，它使用gRPC协议直接将<em class="lj">流</em>到客户端集合，查看从缓存或从对PokeApi后端的Rest API调用收集的数据，并立即持续地及时向用户提供反馈，而无需等待全部时间来执行整个搜索操作。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/096c3d794e0d34bd42aa8fb0d0fae623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmaIKEaeMeYWGO2cFBxHUg.png"/></div></div></figure><h1 id="3fd7" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Protobuf gRPC接口</h1><p id="9feb" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">这基本上是为我们的BFF搜索服务定义的ProtoBuf/GRPC接口。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="1edc" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">正如你所看到的，<em class="lj"> searchPokemon </em> gRPC API(在第24行)被定义为一个服务器到客户端的流gRPC接口，它将<em class="lj">流</em>在同一个protobuf文件中描述的<em class="lj"> Pokemon </em>类型的对象(第5–15行)。</p><h1 id="c6e8" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Swift gRPC客户代码</h1><p id="c31d" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">一旦我们有了描述原始数据结构的protobuf文件和BFF API的gRPC服务接口，我们就可以生成相应的Swift文件，并与整个Swift gRPC包堆栈一起纳入我们的iOS Swift移动应用程序项目。</p><p id="97d4" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">一旦安装了gRPC运行时、Swift ProtoBuf和GRPC插件(遵循Swift GRPC github网站的说明),您就可以轻松执行以下命令行来生成这些Swift输出文件，以包含在XCode项目中:</p><pre class="jk jl jm jn fq mi mj mk ml aw mm dt"><span id="85fb" class="mn jw hu mj b fv mo mp l mq mr">protoc &lt;your proto files&gt; \<br/>    --swift_out=. \<br/>    --swiftgrpc_out=.</span></pre><p id="3fec" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">以下Swift PokemonDataSource类简单地包装了对protocol/grpc自动生成的Swift文件的访问，以便简化从实现UICollectionView的视图控制器对gRPC接口的访问。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="3f6b" class="pw-post-body-paragraph kn ko hu kp b kq ll iv ks kt lm iy kv kw ln ky kz la lo lc ld le lp lg lh li hn dt translated">以这种方式，Swift视图控制器类将简单地调用data source . search new Pokemon gRPC包装方法，并且对于通过gRPC-HTTP/2网络接口从BFF服务器流出的任何pokemon数据，从视图控制器传递的<em class="lj">完成块</em>将被回调。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mg mh l"/></div></figure><h1 id="5c13" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Node.js gRPC BFF代码</h1><p id="320c" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">Swift gRPC堆栈目前也支持服务器端代码生成，但为了本示例教程的完整性，我选择再次使用Node和Javascript来编码以下gRPC BFF实施:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mg mh l"/></div></figure><h1 id="b8da" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">完整源代码</h1><p id="da97" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">本教程针对客户端和BFF项目的完整源代码在GitHub repo:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ms mh l"/></div></figure></div></div>    
</body>
</html>