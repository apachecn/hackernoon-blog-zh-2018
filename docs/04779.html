<html>
<head>
<title>Poor man’s zero downtime deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">穷人的零停机部署</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/poor-mans-zero-downtime-deployment-e457002ec539?source=collection_archive---------36-----------------------#2018-06-05">https://medium.com/hackernoon/poor-mans-zero-downtime-deployment-e457002ec539?source=collection_archive---------36-----------------------#2018-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9fc5fce9ad0ec689c2e1eb3777ce8450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFgOddfnIhfJusSRE1myUw.jpeg"/></div></div></figure><div class=""/><p id="ebda" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt ka translated">当你在做一个项目时，迟早你要向客户展示你的成果。不用说，您将更新数据库中的文件、服务或模式，这意味着只有一件事——部署时间！</p><p id="dc9e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于许多程序员来说，这个过程可能是有压力的。有时服务会中断，数据库会崩溃，或者迁移会出错。客户也不会让我们的生活更轻松。他们希望部署能够顺利运行，并尽可能缩短时间。理想情况下，它的运行应该不会被用户注意到。不幸的是，条件可能会有所不同，后续版本的部署可能需要相当长的时间。它还会导致用户暂时停机。</p><blockquote class="kj"><p id="5d3f" class="kk kl if bd km kn ko kp kq kr ks jz ek translated"><em class="kt">在这种情况下，我们可以随时向DevOps团队寻求帮助。但是，他们通常非常忙，无法保证在现场重建整个部署流程。</em></p></blockquote><p id="6201" class="pw-post-body-paragraph jc jd if je b jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv ky jx jy jz hn dt translated">但是，我们可以对项目进行一些更改，以缩短部署时间和应用程序停机时间。下面是一些概念和解决方案，每个开发人员都应该能够顺利地在他们的项目中采用。</p><h1 id="be64" class="kz la if bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">回到过去—过去和现在的部署</h1><p id="817c" class="pw-post-body-paragraph jc jd if je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">几乎可以肯定的是，绝大多数程序员都记得他们职业生涯的开始和他们的第一次部署。当我们自己做一个小项目时，我们完全在自己的机器上创建了一个应用程序。我们附加或构建了库，下载了各种类型的资源(图像、字体、样式)，并使用FTP客户端将准备好的应用程序发送到服务器。所以，大部分的准备工作都是在当地进行的。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mc"><img src="../Images/f935085ee2def0851dbfa6875bddbbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_84W6A3J14JaG17WMyPapw.png"/></div></div></figure><p id="2eae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着技术的发展和新标准的产生，项目的部署方式也发生了变化。现在，在大多数情况下，开发人员远程登录生产/测试服务器，从存储库中下载项目的当前版本，然后启动应用程序构建过程。结果是一个完整的应用程序和必要的依赖项。很明显，整个过程已经转移到一台远程机器上，这使我们能够自动化该过程，并促进更容易的管理。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mh"><img src="../Images/731a7cd4d7d5831044124278cae4d3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8dmPQsq3oAIiPqM6fOYJA.png"/></div></div></figure><h1 id="2623" class="kz la if bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">使用构建工具加快前端部署</h1><p id="c4c6" class="pw-post-body-paragraph jc jd if je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">构建前端应用程序通常如下所示:</p><ol class=""><li id="324e" class="mi mj if je b jf jg jj jk jn mk jr ml jv mm jz mn mo mp mq dt translated">用当前应用程序版本清理文件夹</li><li id="3a70" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">运行捆绑任务</li><li id="685c" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">移除未使用的代码</li><li id="1609" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">翻译应用程序，使其可以在各种浏览器上工作</li><li id="e1d8" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">加载环境变量</li><li id="04ca" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">压缩和缩小代码以获得尽可能小的文件</li><li id="a85a" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">复制附加资产</li><li id="957d" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">搞定了。</li></ol><p id="d25d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">构建一个完整的应用程序所需的时间是一个很大的问题。对于一个大项目，可以分分钟算。由于您使用当前版本清理文件夹(您希望删除旧的和不必要的文件)，用户将无法访问您的应用程序。为了避免这种情况，您可以将应用程序构建在不同于提供给客户端的文件夹中，并将文件移动到最后。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mw"><img src="../Images/305dd57133aa685ddb74db8f6753894e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ySAhGVbEVItoLVbwkfhg-g.png"/></div></div></figure><p id="cd43" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种解决方案减少了应用程序对客户端不可用的时间，但是它有两个严重的问题:</p><ol class=""><li id="f4ac" class="mi mj if je b jf jg jj jk jn mk jr ml jv mm jz mn mo mp mq dt translated">这些文件是重复的。</li><li id="aadd" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">当您想要返回到以前的版本时，您会丢失数据。</li></ol><p id="0159" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了复制文件，您还可以创建符号链接，并将下一个版本保存在带有标签或时间戳的单独文件夹中。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mx"><img src="../Images/aa2d567766093ecc8d35871b12bf9a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLLdqAzN1UOJKcx47XxxQQ.png"/></div></div></figure><h1 id="8104" class="kz la if bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">带链接的任务示例</h1><figure class="md me mf mg fq hw"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="80e3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如有必要，回滚到以前的版本只需要链接另一个文件夹中的文件。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff na"><img src="../Images/19ca7c6db4d8a0378af7cf1173179a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yl78gI6J5BhHAK9YP7Fabg.png"/></div></div></figure><p id="14a1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后要记住的是，符号链接必须是相对的，构建文件夹也应该在服务器上可用。</p><h1 id="1fb3" class="kz la if bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">路径示例</h1><figure class="md me mf mg fq hw"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="3e09" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了避免浏览器缓存的问题，给文件分配一个随机散列也是明智的。</p><h1 id="6ff0" class="kz la if bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">后端部署</h1><h2 id="bcab" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">HAProxy</h2><p id="3247" class="pw-post-body-paragraph jc jd if je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">长期以来，TSH中的所有应用都是基于Docker容器化的。它增加了项目的灵活性，允许我们轻松地更改应用程序的各种元素。然而，为了以用户不可见的方式替换某些元素，您需要用负载平衡器来扩展您的架构。在我们的例子中，平衡器将在旧的和更新的容器之间重定向流量。HAProxy(高可用性代理)将完美地满足我们的需求。设置非常简单，只需在docker编写文件中添加几行即可。</p><figure class="md me mf mg fq hw"><div class="bz el l di"><div class="my mz l"/></div></figure><h2 id="273e" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">API更新</h2><p id="f040" class="pw-post-body-paragraph jc jd if je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">在很大程度上，后端实现归结为为当前API版本构建一个新容器，并将所有流量从一个容器重定向到另一个容器。有了HAProxy，整个过程变得几乎无缝。尽管如此，还是让我们把这方面的知识系统化吧。</p><p id="98ae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在服务器上，您已经启动了连接到LB(负载平衡器—这里是:HAProxy)的API v1版本。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div class="fe ff np"><img src="../Images/e2b91331834af092455e33ed64af17ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*Xg992UuiO_mQ_P8QCyP7zQ.png"/></div></figure><p id="b409" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您构建一个API <em class="nq"> v2 </em>容器，并将其添加到已经启动的容器中。为此，您必须使用<em class="nq"> docker-compose scale api=2 </em>命令，HAProxy本身会将它添加到配置中，并将流量重定向到它(默认情况下，流量均匀分布在配置中的所有容器上)。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/f88a94a3725e251ba2883bbba2353aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*wl5Gb79EU1kJjzB35xRd2g.png"/></div></figure><p id="1472" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，剩下唯一要做的就是删除v1版本，并将所有流量重定向到v2。不幸的是，将API scaling改为1将会删除最后添加的容器——即您当前的API版本。因此，在您更换秤之前，您必须记得停止并移除旧容器。这个问题可以用一个简单的bash脚本来解决。</p><h2 id="03cd" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">deploy.sh</h2><figure class="md me mf mg fq hw"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="d1f6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在脚本被执行之后，只有api v2容器将保持活动状态，所有流量都被定向到它。</p><figure class="md me mf mg fq hw fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/193425b6cc694523ea977c530ca0f468.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*fKwrIDW7DxXvyseO2hxOng.png"/></div></figure><h1 id="2e1b" class="kz la if bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">数据库ˌ资料库</h1><p id="ade7" class="pw-post-body-paragraph jc jd if je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">这里要讨论的最后一个元素是数据库。取决于你想改变什么，它可能是系统中最简单或最具挑战性的元素之一。为了确保这个过程能够顺利运行，下面给出了一些简单的概念。此外，值得一提的是，您应该逐步修改API，与数据库交替进行。</p><h2 id="7a21" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">添加新列</h2><ol class=""><li id="9676" class="mi mj if je b jf lx jj ly jn ns jr nt jv nu jz mn mo mp mq dt translated">创建迁移以添加新列。</li><li id="aa3f" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">将代码与迁移一起部署。</li><li id="0496" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">上传使用新列的API版本。</li></ol><h2 id="d2ae" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">删除列</h2><ol class=""><li id="e2a8" class="mi mj if je b jf lx jj ly jn ns jr nt jv nu jz mn mo mp mq dt translated">修改代码以不使用选定的列。</li><li id="6aa6" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">为过时的列准备一个迁移，添加一个有意义的后缀，例如<em class="nq"> _deprecated: </em></li><li id="eb20" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">如果新功能有效，并且您确定不再需要该数据，则可以删除该列。</li><li id="d8e2" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">如果遇到问题，可以通过删除后缀轻松回滚数据库。</li></ol><h2 id="3780" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">更改列名</h2><ol class=""><li id="a9a2" class="mi mj if je b jf lx jj ly jn ns jr nt jv nu jz mn mo mp mq dt translated">准备使用新名称创建列的迁移。</li><li id="3eda" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">添加一个事件，确保更新的数据被复制到新创建的列中。</li><li id="61d6" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">将数据从旧列迁移到新列(最好将记录分成几部分)。</li><li id="966e" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">修改代码以仅使用新列。</li><li id="b058" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">删除旧列(参见上面的示例)。</li></ol><h2 id="6d6b" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">更改列类型</h2><ol class=""><li id="c155" class="mi mj if je b jf lx jj ly jn ns jr nt jv nu jz mn mo mp mq dt translated">创建包含不同类型的新列的迁移。在名称中添加一个带有列类型的后缀，以便更容易区分它们<em class="nq"> name_column_type </em>。</li><li id="f7a1" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">添加一个事件，确保更新的数据被复制到新创建的列中。</li><li id="2799" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">将数据从旧列迁移到新列。</li><li id="4141" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">在模型中，输入新列类型的名称。(兼容性在这里很重要，所以让我们的模型变得“智能”。如果没有找到列<em class="nq"> name_column_type </em>，就使用原来的列名。在原则上，可以使用模式管理器获得列)。</li><li id="22a4" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">创建一个迁移，将<em class="nq"> _deprecated </em>后缀添加到原始列中，并从新列中删除类型后缀。</li><li id="cc72" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">从模型中删除列名猜测逻辑。</li><li id="375a" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz mn mo mp mq dt translated">删除旧列(参见上面的示例)。</li></ol><p id="d492" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看一下上面的例子，您可以看到经过深思熟虑的迁移允许我们以一种用户几乎看不见的方式更新/修改数据库。</p><h1 id="8f77" class="kz la if bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">最后</h1><p id="32d2" class="pw-post-body-paragraph jc jd if je b jf lx jh ji jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">总之，相对少量的工作可以显著缩短您的部署时间。当然，这个过程需要一些准备，谨慎，以及在执行过程中的纪律。但是，最终，这意味着更少的压力和更满意的客户。</p></div><div class="ab cl nv nw hc nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="hn ho hp hq hr"><h2 id="7eda" class="nb la if bd lb nc nd ne lf nf ng nh lj jn ni nj ln jr nk nl lr jv nm nn lv no dt translated">也值得一读:</h2><ul class=""><li id="a69f" class="mi mj if je b jf lx jj ly jn ns jr nt jv nu jz oc mo mp mq dt translated">Bastien Libersa在他的博客上</li><li id="edff" class="mi mj if je b jf mr jj ms jn mt jr mu jv mv jz oc mo mp mq dt translated"><a class="ae od" rel="noopener" href="/@korolvs/zero-downtime-deployment-with-docker-d9ef54e48c4">培养基上的斯拉瓦·科洛列夫</a></li></ul></div><div class="ab cl nv nw hc nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="hn ho hp hq hr"><p id="a11d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章是pawerychlewski写的，最初发表在软件之家博客<a class="ae od" href="http://www.tsh.io/blog" rel="noopener ugc nofollow" target="_blank"><strong class="je ig"/></a><strong class="je ig">上。访问博客，获得更多关于最佳开发实践和软件外包技巧的文章。</strong></p></div></div>    
</body>
</html>