<html>
<head>
<title>Testing Types: An Introduction to dtslint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试类型:dtslint简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-types-an-introduction-to-dtslint-b178f9b18ac8?source=collection_archive---------9-----------------------#2018-06-07">https://medium.com/hackernoon/testing-types-an-introduction-to-dtslint-b178f9b18ac8?source=collection_archive---------9-----------------------#2018-06-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="34a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个单元测试有什么奇怪的地方吗？</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="d618" class="jy jz hu ju b fv ka kb l kc kd">it('should square 4', () =&gt; {<br/>  square(4);<br/>});</span></pre><p id="3f23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然可以。<em class="ke">它没有断言任何东西！</em>是否正确执行<code class="eh kf kg kh ju b">square</code>并不重要。只要函数没有抛出异常，这个测试就会通过。</p><p id="7721" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不太好。如果检查一下<code class="eh kf kg kh ju b">square(4)</code>的返回值，测试会好很多:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="77ba" class="jy jz hu ju b fv ka kb l kc kd">it('should square 4' () =&gt; {<br/>  expect(square(4)).to.equal(16);<br/>});</span></pre><p id="63d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管第一个例子很疯狂，但这正是传统上测试<a class="ae ki" href="https://github.com/DefinitelyTyped/DefinitelyTyped" rel="noopener ugc nofollow" target="_blank">中的类型声明的方式。只要类型检查器没有发现任何错误，类型是什么并不重要。特别是在有<code class="eh kf kg kh ju b"><a class="ae ki" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#any" rel="noopener ugc nofollow" target="_blank">any</a></code> </a><a class="ae ki" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#any" rel="noopener ugc nofollow" target="_blank">类型</a>的情况下，这导致了一些弱测试。弱测试导致不精确和不准确的类型化，并且它们使重构类型声明变得可怕。</p><p id="b9ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">微软最近推出了一个新工具，<a class="ae ki" href="https://github.com/Microsoft/dtslint" rel="noopener ugc nofollow" target="_blank"> dtslint </a>，它使得类型声明测试中的断言成为可能。这篇文章的其余部分解释了如何使用它来将测试的所有好处带给类型声明文件。</p><h1 id="fa1a" class="kj jz hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">没有dtslint的测试</h1><p id="5c5c" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">下面是来自<code class="eh kf kg kh ju b">_.pluck</code>的<a class="ae ki" href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/3289762cca59308bf092e4b49ea2242ef27fc23e/types/underscore/underscore-tests.ts#L173-L174" rel="noopener ugc nofollow" target="_blank">下划线测试</a>的几行，我在之前已经<a class="ae ki" rel="noopener" href="/@danvdk/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8">写过了:</a></p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="60c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，返回类型缺少断言。这实际上是检查是否有一个名为<code class="eh kf kg kh ju b">_.pluck</code>的函数，并且它接受一个列表和一个字符串作为参数。</p><p id="ae45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">返回类型应该是<code class="eh kf kg kh ju b">string[]</code>，但是是<code class="eh kf kg kh ju b">any[]</code>。太糟糕了！怎样才能让测试失败？</p><h1 id="9563" class="kj jz hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">一个测试</h1><p id="0a86" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated"><code class="eh kf kg kh ju b">dtslint</code>来救援了！为了检查对<code class="eh kf kg kh ju b">_.pluck</code>调用的返回类型，我们可以使用一个<code class="eh kf kg kh ju b">// $ExpectType</code>断言:</p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="9146" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们在这个测试上运行<code class="eh kf kg kh ju b">tsc</code>时，它通过了。但是当我们在它上面运行<code class="eh kf kg kh ju b">dtslint</code>时，我们得到如下结果:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="aea6" class="jy jz hu ju b fv ka kb l kc kd">ERROR: 2:1  expect  Expected type to be:<br/>  string[]<br/>got:<br/>  any[]</span></pre><p id="b40f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Tada！抓住了！</p><p id="9da3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以使用映射类型使声明更加精确<a class="ae ki" rel="noopener" href="/@danvdk/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8">:</a></p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="aaf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们从<code class="eh kf kg kh ju b">dtslint</code>得到以下输出:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="1c78" class="jy jz hu ju b fv ka kb l kc kd">Test with 2.8<br/>Test with 2.7<br/>Test with 2.6<br/>Test with 2.5<br/>Test with 2.4<br/>Test with 2.3<br/>Test with 2.2<br/>Test with 2.1<br/>Test with 2.0<br/>Error: /Users/danvk/github/dtslint-post/types/index.d.ts:1:33<br/>ERROR: 1:33  expect  Compile error in typescript@2.0 but not in typescript@2.1.<br/>Fix with a comment '// TypeScript Version: 2.1' just under the header.<br/>Cannot find name 'keyof'.</span></pre><p id="4c7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TypeScript 2.1+通过了测试，但TypeScript 2.0未通过测试。这是有意义的，因为<code class="eh kf kg kh ju b">keyof</code>是在TypeScript 2.1 中引入的<a class="ae ki" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html" rel="noopener ugc nofollow" target="_blank">。在TS 2.1之前，不可能如此精确地输入<code class="eh kf kg kh ju b">pluck</code>。所以我们唯一真正的选择是使用建议的注释要求更新的版本:</a></p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="bac0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是类型声明难以维护的另一个原因。类型声明中实际上有三个独立的版本:</p><ul class=""><li id="69f8" class="lo lp hu it b iu iv iy iz jc lq jg lr jk ls jo lt lu lv lw dt translated">库的版本</li><li id="e9e0" class="lo lp hu it b iu lx iy ly jc lz jg ma jk mb jo lt lu lv lw dt translated">打字的版本</li><li id="cfad" class="lo lp hu it b iu lx iy ly jc lz jg ma jk mb jo lt lu lv lw dt translated">TypeScript编译器的版本</li></ul><p id="8bdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">FlowTyped选择<a class="ae ki" href="https://github.com/flowtype/flow-typed/tree/614bf49aa8b00b72c41caab1120094bc10fb9476/definitions/npm/underscore_v1.x.x" rel="noopener ugc nofollow" target="_blank">显式地对这个</a>建模，而DefinitelyTyped没有。</p><h1 id="ad76" class="kj jz hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">测试重构</h1><p id="c3fc" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">假设我们正在处理<a class="ae ki" href="https://lodash.com/docs#map" rel="noopener ugc nofollow" target="_blank"> lodash的</a> <code class="eh kf kg kh ju b"><a class="ae ki" href="https://lodash.com/docs#map" rel="noopener ugc nofollow" target="_blank">map</a></code> <a class="ae ki" href="https://lodash.com/docs#map" rel="noopener ugc nofollow" target="_blank">函数</a>的类型声明:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="1324" class="jy jz hu ju b fv ka kb l kc kd">export function map&lt;U, V&gt;(array: U[], fn: (u: U) =&gt; V): V[];</span></pre><p id="4081" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你用这个很像<code class="eh kf kg kh ju b">Array.prototype.map</code>:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="adce" class="jy jz hu ju b fv ka kb l kc kd">_.map([1, 2, 3], x =&gt; x * x);  // returns [1, 4, 9].</span></pre><p id="ec4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Lodash没有<code class="eh kf kg kh ju b">_.pluck</code>功能。相反，它增加了一个<code class="eh kf kg kh ju b">_.map</code>的变体:</p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="7f2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应该在类型声明中对此建模，但是改变如此重要的函数的类型是很可怕的！这是编写测试的最好理由之一:它们让你自信地重构。<code class="eh kf kg kh ju b">dtslint</code>让你对类型声明做同样的事情。</p><p id="2a7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个针对<code class="eh kf kg kh ju b">_.map</code>的dtslint测试，它涵盖了新旧声明:</p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="9222" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以为<code class="eh kf kg kh ju b">map</code>的声明添加一个重载:</p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="b839" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当<code class="eh kf kg kh ju b">dtslint</code>过去时，我们可以确信我们已经添加了新的功能<em class="ke">并且</em>避免了改变现有的行为。</p><h1 id="8b8a" class="kj jz hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">测试回调参数</h1><p id="b06b" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">回调在<a class="ae ki" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中无处不在，类型声明准确地建模它们的参数非常重要。这里也有帮助:如果我们注意格式，我们可以断言回调参数的类型。</p><p id="5908" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kf kg kh ju b">_.map</code>实际上向其回调传递了三个参数。这个代码片段测试了它们是否都推断出了正确的类型:</p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="cbb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们改变这些<code class="eh kf kg kh ju b">$ExpectType</code>行中的任何一行，我们都会得到一个错误。(这通常是一个很好的检查！)</p><h1 id="5320" class="kj jz hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">测试“这”的类型</h1><p id="f5f4" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">众所周知，<a class="ae ki" href="https://twitter.com/bendhalpern/status/578925947245633536?lang=en" rel="noopener ugc nofollow" target="_blank">很难</a>知道<code class="eh kf kg kh ju b">this</code>在JavaScript中指的是什么。但是<a class="ae ki" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>可以帮忙！如果一个库在其回调中操纵<code class="eh kf kg kh ju b">this</code>，那么类型声明应该对其建模。</p><p id="e5af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你已经做到了这一步，你就不会惊讶地发现<code class="eh kf kg kh ju b">dtslint</code>也能帮上忙！只需为<code class="eh kf kg kh ju b">this</code>写一个类型断言:</p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="b7fc" class="kj jz hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结论</h1><p id="57c4" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">处理不准确或不精确的类型声明可能是使用TypeScript最令人沮丧的方面之一。它们会引入虚假的错误，或者通过在你意想不到的地方引入<code class="eh kf kg kh ju b">any</code>类型，给你一种不必要的自信。</p><p id="bc1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">测试是改进现有代码库的关键，而<code class="eh kf kg kh ju b">dtslint</code>为TypeScript的类型语言带来了许多好处。它让您可以确定现有的行为，以便您可以放心地重构类型声明。它甚至可以让你用类型声明文件进行<a class="ae ki" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>！</p><p id="0751" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kf kg kh ju b">dtslint</code>已经在今天的<a class="ae ki" href="https://github.com/DefinitelyTyped/DefinitelyTyped" rel="noopener ugc nofollow" target="_blank">明确类型的</a>回购中使用。所以如果你写类型声明，请写一些类型断言！如果你要改变现有的类型声明，请为现有的行为编写断言。</p><p id="ea6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望，从长远来看，<code class="eh kf kg kh ju b">dtslint</code>将为所有TypeScript用户带来质量显著提高的类型声明。这意味着更好的打字体验，即使你不知道<code class="eh kf kg kh ju b">dtslint</code>的存在！</p><p id="3728" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ke">查看</em> <a class="ae ki" href="https://github.com/danvk/dtslint-post/" rel="noopener ugc nofollow" target="_blank"> <em class="ke">这个回购</em> </a> <em class="ke">看看这篇文章中的所有代码示例。如果你想在DefinitelyTyped之外使用dtslint，可以看看Paul krbitz的伟大文章</em>  <em class="ke">。</em></p><p id="eea7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这篇文章，你可能也会喜欢我的书，<a class="ae ki" href="https://www.amazon.com/Effective-TypeScript-Specific-Ways-Improve/dp/1492053740" rel="noopener ugc nofollow" target="_blank"> <em class="ke">有效的打字稿:62种改善你打字稿的具体方法</em></a><a class="ae ki" href="https://www.amazon.com/Effective-TypeScript-Specific-Ways-Improve/dp/1492053740" rel="noopener ugc nofollow" target="_blank"/>(O ' Reilly 2019)。这篇文章是第52条的基础:注意测试类型的陷阱。</p><figure class="jp jq jr js fq ll"><div class="bz el l di"><div class="mc ln l"/></div></figure></div></div>    
</body>
</html>