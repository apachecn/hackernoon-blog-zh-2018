<html>
<head>
<title>Code simplicity: A language independent perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码简单性:独立于语言的视角</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/code-simplicity-a-language-independent-perspective-756cf031c913?source=collection_archive---------13-----------------------#2018-06-08">https://medium.com/hackernoon/code-simplicity-a-language-independent-perspective-756cf031c913?source=collection_archive---------13-----------------------#2018-06-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/0fc7766ddb8db0466f0fa683b207bdcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4H2BbPpqmHVAP5WaGxhjKw.jpeg"/></div></div></figure><div class=""/><p id="7db6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">简单就是美好</em>是编程中的金科玉律。虽然效率和性能是主要因素，但在许多使用案例中，简单性和维护成本比它们更重要。在选择一种编程语言、探索一种语言的特性，甚至决定一个组织内的标准编码实践时，这些都成为决定性的因素。经常有关于特定编程语言是否更容易写出更简单和可维护的代码的争论；随着代码库开始增长，从事代码库工作的人数开始增加等等，项目经常会从更高效、性能更好的语言转向其他语言。</p><p id="2e6a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">许多这样的决定对一些团队来说确实很有效，但是它们中的许多并没有改变现实。让我们探索一下，是什么让代码变得简单，以及在这方面我们能做些什么。</p><h1 id="1611" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">是什么让代码变得简单</strong></h1><p id="1f39" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">具有讽刺意味的是，编写简单的代码既不容易也不简单，有时，简化一个逻辑或一段代码实际上可能相当复杂。</p><p id="3538" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简单易行写作的几个标志:</p><h2 id="c315" class="le kc if bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated"><strong class="ak">易于阅读和理解</strong></h2><p id="88ee" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">通常情况下，代码只需编写一次，在一段时间内就会被读取数百次。因此，它应该易于阅读和理解，这一点很重要。</p><p id="8431" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一些简单的提示会有所帮助:</p><ol class=""><li id="dcf5" class="ls lt if je b jf jg jj jk jn lu jr lv jv lw jz lx ly lz ma dt translated"><strong class="je ig">避免双重否定</strong>:而不是说<em class="ka"> if(！not_present)使用if(present)。</em></li><li id="85fc" class="ls lt if je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je ig">避免令人误解的缩写</strong>:有一次我们在做一个与销售点有关的项目。因为它有点长，我们把它缩短为POS。为了检查一个特定的对象是否属于POS，我们添加了一个名为isPOS的方法，它接受一个对象并相应地返回true或false。这个物体也有正或负的概念(它也和数量有些关系)。一个新开发人员最近加入了这个团队，他必须添加一些特性，并且需要检查对象是否有正数，他使用了这个方法isPOS(假设它是isPositive的一个快捷方式),然后继续。因为大部分数量应该是负的，而且很少对象应该与POS相关，所以他的大部分测试都正确通过了。没有人在代码审查中发现这一点，并且在代码进入生产后的很晚阶段才被发现。</li><li id="b822" class="ls lt if je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je ig">遵循命名约定的自然流程</strong>:如果变量w用于ResponseWriter，r通常意味着ResponseReader，不要将其用于Request。</li><li id="7457" class="ls lt if je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je ig">避免if块中的多个复杂条件:</strong>当处理遗留代码时，只添加一个条件并完成特性的诱惑太大了。虽然大多数时候它工作得很好，但是这些额外的条件不断改变业务意图，并且在几次迭代之后，业务逻辑变得完全不可管理。因此，重要的是，无论何时添加新条件，都要确保它在旧的上下文中仍然相关，如果不相关，那么一点点重构可能是更好的选择。</li><li id="25e8" class="ls lt if je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je ig">避免神奇的逻辑</strong>:应该避免以牺牲可读性为代价的效率。例如，X &lt; &lt; 3(将数字X左移3)而不是X * 8(将X乘以8)可能更快，但是可能不具有相同的可读性。避免这种东西通常有助于可读性，除非目的是相同的。</li></ol><h2 id="3e35" class="le kc if bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated"><strong class="ak">易于理解的代码/实现上下文</strong></h2><p id="6b1e" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">人们经常搬家，新来的人不得不查看代码，他们可能没有相同级别的暴露和正在解决的问题的上下文。因此，从代码中获取上下文越容易，新人的生产力就越高。很少有事情能帮上忙:</p><ol class=""><li id="bd36" class="ls lt if je b jf jg jj jk jn lu jr lv jv lw jz lx ly lz ma dt translated"><strong class="je ig">更少的状态和方法间的依赖</strong>:状态依赖于其他方法或者需要按一定顺序调用的方法更难阅读和修改。我们不仅要阅读和理解当前的方法，还要理解调用的顺序。这通常会导致调用当前状态没有正确更新的方法，从而导致问题。<strong class="je ig">不要在类中使用成员变量来存储临时状态，以避免私有方法中的额外参数</strong>。</li><li id="adb9" class="ls lt if je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je ig">特定的输入和输出</strong>:很多时候传递一个更大的通用数据结构给一个方法更容易，如果方法需要更多的输入，这使得以后的修改更容易。但是，这通常也会导致方法的可重用性降低。这也使得通过读取调用者端的代码来猜测另一端可能会发生什么变得更加困难。这迫使我们阅读更多的代码来理解逻辑。类似地，返回一个更大的结构并只填充几个字段，迫使我们阅读更多的代码，以了解在响应后可以使用结构的哪一部分，这通常会导致访问未填充的数据并使代码变得脆弱。最好只传递所需的输入，并返回特定的输出。</li><li id="bc11" class="ls lt if je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je ig">更少的重定向</strong>:做太多的重定向会迫使我们读取更大的代码库。喜欢较小的重定向。例如在下面的代码中(有点夸张)，</li></ol><figure class="mg mh mi mj fq hw"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="d7a8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多东西很可能不会改变。这种不必要的抽象使得获取上下文变得更加困难。</p><p id="8087" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以用一个简单的方法来代替所有这些可能是值得的</p><figure class="mg mh mi mj fq hw"><div class="bz el l di"><div class="mk ml l"/></div></figure><h2 id="8c5c" class="le kc if bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated"><strong class="ak">容易获得意图和问题上下文</strong></h2><p id="8b15" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当需要修改现有代码时，问题的背景和意图比实现步骤更有帮助。所以有意义的抽象很重要。</p><ol class=""><li id="933e" class="ls lt if je b jf jg jj jk jn lu jr lv jv lw jz lx ly lz ma dt translated"><strong class="je ig">有意义的抽象</strong></li></ol><p id="48fa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以编写一个非常具体的代码，非常适合某个上下文，但可能会隐藏其意图。</p><p id="91e3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，我们正在建立一个电子商务网站，一旦结账完成，我们需要发送一封电子邮件来表明结账完成，如果有错误，我们可能需要发送一封不同的电子邮件。假设在结帐被认为完成之前有2个步骤，我们可以有这样的场景，在第一个步骤之后，系统出错。还假设我们将每一步的成功记录为DB中的一行(在内存或实际DB中)。</p><p id="344e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个示例实现。</p><figure class="mg mh mi mj fq hw"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="2f47" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这在给定的条件下可能非常好，但这并没有正确地告诉我们意图，而是更多地集中在当前的假设上。如果以后我们添加一个新的步骤，这个代码将会中断。为一个新人修改这个代码将会非常困难，因为具体步骤的意图丢失了。</p><p id="fef4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这些情况下，代码更多但意图正确的实现可能更好</p><figure class="mg mh mi mj fq hw"><div class="bz el l di"><div class="mk ml l"/></div></figure><h2 id="6c9f" class="le kc if bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated"><strong class="ak">简单就是美丽</strong></h2><p id="d51d" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">最后，重要的是传达正确的上下文和含义。一个易于阅读和浏览但不能揭示正确意图的代码可能不被视为简单。虽然语言和它的特性可能会发挥重要的作用，但是如果我们注意到这些基本的东西，不管我们使用什么语言、什么范例或者语言的什么特性，我们的代码仍然会很漂亮。</p></div></div>    
</body>
</html>