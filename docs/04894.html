<html>
<head>
<title>m</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">m</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/project-blockhead-an-ethereum-smart-contract-service-broker-for-kubernetes-and-cloud-foundry-88390a3ac63f?source=collection_archive---------12-----------------------#2018-06-09">https://medium.com/hackernoon/project-blockhead-an-ethereum-smart-contract-service-broker-for-kubernetes-and-cloud-foundry-88390a3ac63f?source=collection_archive---------12-----------------------#2018-06-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="3ba5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated"><strong class="ak"> Project BlockHead:一个面向Kubernetes和Cloud Foundry的以太坊智能合约服务代理</strong></h1><p id="ee6f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="kn">这篇博文由</em> <a class="ko kp gr" href="https://medium.com/u/46bb227e00e9?source=post_page-----88390a3ac63f--------------------------------" rel="noopener" target="_blank"> <em class="kn">斯韦塔雷帕库拉</em></a><em class="kn"/><a class="ko kp gr" href="https://medium.com/u/aa215fb644c5?source=post_page-----88390a3ac63f--------------------------------" rel="noopener" target="_blank"><em class="kn">摩根鲍尔</em></a><em class="kn"/><a class="ko kp gr" href="https://medium.com/u/3f0e921f0d1b?source=post_page-----88390a3ac63f--------------------------------" rel="noopener" target="_blank"><em class="kn">乔纳森伯克汉</em> </a>合著</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff kq"><img src="../Images/b962c4dd85de1631da0d78a9326583db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2sHVRqouSSZ9VKCMDL67g.png"/></div></div></figure><p id="f47e" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">随着人们对区块链T21技术越来越感兴趣，软件开发商正在考虑将智能合同集成到他们的应用程序中。使用区块链开发和集成的应用程序通常由两部分组成:</p><ul class=""><li id="294a" class="li lj hu jr b js lc jw ld ka lk ke ll ki lm km ln lo lp lq dt translated">部署到区块链<a class="ae lh" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>的智能合同</li><li id="e925" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">绑定到已部署的协定并使用它的Web应用程序。</li></ul><p id="ce3b" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">智能合同可以被认为是区块链网络中给定地址可用的代码片段，它能够接收和处理输入数据，检索或更新分类帐状态，并将结果返回给请求方。使用契约的web应用程序通常被称为Web3应用程序。</p><p id="b3b0" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">尽管使用区块链令人兴奋，但是部署智能合约并将其集成到Web应用程序中的端到端多步骤过程相当繁琐。应用程序开发人员需要:</p><ol class=""><li id="d1e5" class="li lj hu jr b js lc jw ld ka lk ke ll ki lm km lw lo lp lq dt translated">开发或重用智能合同</li><li id="d894" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">编译合同代码</li><li id="8e1b" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">检索可执行二进制文件和应用程序二进制文件接口(ABI)</li><li id="4ec1" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">调出一个区块链节点(例如以太坊)</li><li id="01b0" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">在节点中创建或导入一个帐户(即钱包)</li><li id="c079" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">使用该帐户将二进制代码部署到区块链网络中</li><li id="e39c" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">验证部署并检索合同地址</li><li id="575d" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">最后，在Web应用程序中使用帐户地址、合同地址和合同ABI的组合来绑定到合同并使用它</li></ol><p id="7342" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">人们一直在努力简化智能合同的开发过程。例如，<a class="ae lh" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank"> Truffle </a>提供了一个开发框架，可以建立一个本地<a class="ae lh" href="https://hackernoon.com/tagged/ethereum" rel="noopener ugc nofollow" target="_blank">以太坊</a>网络，并允许开发者试驾他们的智能合约应用程序的开发。</p><div class="lx ly fm fo lz ma"><a href="http://truffleframework.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hv fv z el mf eo ep mg er et ht dt translated">松露套装-你的以太坊瑞士军刀</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">块菌是用JavaScript以完全模块化的方式编写的，允许你选择和…</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">truffleframework.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo la ma"/></div></div></a></div><p id="ba6d" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">然而，当部署到主以太网(mainnet)或测试网络(testnet)时，开发人员仍然需要手动完成区块链节点的配置过程，以确保成功部署并将其合同与其应用程序集成。</p><p id="b8a8" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">作为开源平台工程师，我们努力为软件工程师简化应用程序开发过程。平台即服务(PaaS)存在的前提是让开发者更容易部署、扩展和管理他们的应用程序；像Kubernetes和Cloud Foundry这样的平台在简化应用程序生命周期管理方面已经取得了长足的进步。根据同样的前提，我们认为PaaS平台能够并且应该简化智能合约应用程序的开发，并使其成为部署到PaaS的智能合约应用程序的生命周期的一部分。这就是为什么木头人项目诞生了。</p><p id="e1ca" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">Project BlockHead利用开放服务代理API规范来构建位于Web应用程序和区块链网络之间的服务代理层。这样，代理通过自动创建和部署智能合约，然后向Web应用程序公开所需的信息集，来控制智能合约的管理。</p><h1 id="176e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">开放式服务代理API</h1><p id="3248" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae lh" href="https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md" rel="noopener ugc nofollow" target="_blank">开放服务代理API (OSB API)规范</a>提供了一个公共接口，用于创建服务市场并将其集成到云应用中，这样服务可以独立于应用进行维护和管理，而应用可以通过公开的API轻松绑定和使用服务。服务代理负责向市场发布服务产品和服务计划的目录，并根据市场的请求进行供应、绑定、解除绑定和取消供应。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff mp"><img src="../Images/17f5702648d06c7f9541a3ef3955429c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5LwkLK1CjDrFDnCA."/></div></div></figure><p id="ffc2" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">借用OSB API的规范，provisioning将服务上的资源保留为实例。在BlockHead代理的上下文中，服务实例表示连接到区块链网络的区块链节点。绑定所代表的内容也可能因服务而异。绑定的创建为服务实例提供了智能协定信息，以便对其进行编译和部署，并对使用该服务的应用程序可用。平台市场可以展示来自一个或多个服务代理的服务，并且单个服务代理可以使用不同的URL前缀和凭证来支持一个或多个平台市场。上图显示了与service broker API交互以提供服务的示例。"</p><p id="8761" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">关于如何与服务代理交互的更多细节可以在下面找到:</p><div class="lx ly fm fo lz ma"><a href="https://github.com/openservicebrokerapi/servicebroker" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hv fv z el mf eo ep mg er et ht dt translated">openservicebrokerapi/service broker</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">servicebroker -开放服务代理API规范</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">github.com</p></div></div><div class="mj l"><div class="mq l ml mm mn mj mo la ma"/></div></div></a></div><h1 id="1f85" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">笨蛋服务经纪人</h1><p id="b2ed" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">通过project BlockHead，我们旨在将每个OSB API调用转换为智能合约生命周期中的一系列步骤，从而向应用程序开发人员隐藏与区块链交互的复杂性。</p><p id="66b1" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">代理的第一个版本建立在云铸造社区项目<a class="ae lh" href="https://github.com/cloudfoundry-community/cf-containers-broker" rel="noopener ugc nofollow" target="_blank">容器服务代理</a>之上。通过利用容器服务代理，区块链节点可以在隔离的Docker容器中运行，并在部署和绑定智能合约时独立运行。</p><p id="fc51" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">我们利用代理按需部署有状态以太坊节点。然后修改供应和绑定或解除绑定和取消供应中的每个步骤，以在创建/删除智能合约或节点时交付。下图提供了Blockhead service broker如何调配以太坊节点并与Cloud Foundry应用程序集成的整体架构:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff mr"><img src="../Images/1e218e80b4452ec72c0f863e4b3e7e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AovE-c2jJyQ_czkQqUFqAQ.png"/></div></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">The overall interaction model between the BlockHead service broker and Cloud Foundry applications</figcaption></figure><h2 id="c4f1" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">1.部署代理</h2><p id="1124" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">笨蛋经纪人的<a class="ae lh" href="https://github.com/nimakaviani/container-broker" rel="noopener ugc nofollow" target="_blank">初始版本作为BOSH版本发布。BOSH版本是一个版本化的集合，包括配置属性、配置模板、启动脚本、源代码、二进制工件以及以可复制的方式构建和部署软件所需的任何东西。</a></p><div class="lx ly fm fo lz ma"><a href="https://github.com/nimakaviani/ethereum-container-broker" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hv fv z el mf eo ep mg er et ht dt translated">nimakaviani/以太坊-集装箱经纪人</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">在GitHub上创建一个帐户，为以太坊容器代理的开发做出贡献。</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">github.com</p></div></div></div></a></div><p id="c9db" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">在这篇博文中，我们将BlockHead service broker与Cloud Foundry一起部署。这使我们能够从Cloud Foundry的功能中受益，推动Web3应用程序并将其绑定到合同服务。有关如何部署Cloud Foundry的说明，请参考下面的文档。</p><div class="lx ly fm fo lz ma"><a href="https://github.com/cloudfoundry/cf-deployment" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hv fv z el mf eo ep mg er et ht dt translated">cloud foundry/cf-部署</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">cf-deployment——Cloud Foundry的规范开源部署清单</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">github.com</p></div></div><div class="mj l"><div class="nk l ml mm mn mj mo la ma"/></div></div></a></div><p id="54c2" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">一旦您拥有一个部署了Cloud Foundry的BOSH部署环境，部署BlockHead代理就像运行以下脚本一样简单:</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="nl nm l"/></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">deply.sh from https://github.com/nimakaviani/container-broker</figcaption></figure><p id="2699" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">由于Kubernetes与Open Service Broker API兼容代理集成，如果您有Kubernetes部署，您可以将部署的BlockHead代理连接到您的Kubernetes平台，并使用部署到Kubernetes的Web3应用程序绑定到部署的智能合同。你可以在这里找到如何与Kubernetes <a class="ae lh" href="https://github.com/nimakaviani/ethereum-container-broker/tree/master/docs/kube" rel="noopener ugc nofollow" target="_blank">进行整合。</a></p><h2 id="6f81" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">2.服务市场和合同市场</h2><p id="547e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了让代理出现在Cloud Foundry marketplace中，您需要首先使用以下命令注册它:</p><pre class="kr ks kt ku fq nn no np nq aw nr dt"><span id="89f2" class="mw is hu no b fv ns nt l nu nv">bosh run-errand -d docker-broker broker-registrar</span></pre><p id="8220" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">代理注册后，您可以查询市场，您将看到以太坊服务出现在市场中:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff nw"><img src="../Images/21fca70931516b97c043c80a2594a829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AV7IZ8MRqA1voRM8."/></div></div></figure><p id="2f58" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">除此之外，我们还开发了一个<a class="ae lh" href="https://github.com/MHBauer/contract-marketplace" rel="noopener ugc nofollow" target="_blank">简单的合同市场</a> e，它允许我们列出合同，然后在将应用程序绑定到以太坊节点时使用它们的URL引用它们。要部署合同市场，您可以将您的智能合同添加到市场，构建docker映像，将其推送到docker注册表，然后使用类似于以下内容的命令来下载和使用它:</p><pre class="kr ks kt ku fq nn no np nq aw nr dt"><span id="6cc2" class="mw is hu no b fv ns nt l nu nv">cf push contract-marketplace --docker-image nimak/contract-marketplace</span></pre><p id="3d77" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">您可以通过检查<code class="eh nx ny nz no b">cf apps</code>来验证应用程序是否启动并运行:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff oa"><img src="../Images/69842db2cf15111434b1e2e566f51e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YNcI3ZLuugp_28Ej."/></div></div></figure><p id="a7f5" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">在我们的示例中，市场位于以下地址，导航到该地址，我们可以找到网站:</p><pre class="kr ks kt ku fq nn no np nq aw nr dt"><span id="8e8c" class="mw is hu no b fv ns nt l nu nv"><a class="ae lh" href="http://contract-marketplace.bosh-lite.com/posts/solidity/" rel="noopener ugc nofollow" target="_blank">http://contract-marketplace.bosh-lite.com/posts/solidity/</a></span></pre><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff ob"><img src="../Images/1e773a47908349e3f3186e9f8a0a24df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*md5fHolAYHYvuLIu."/></div></div></figure><p id="b1d8" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">请注意，在每个合同定义的顶部，有一个指向该合同代码的超链接引用。这个契约URL是我们用来将服务绑定到应用程序和部署契约的。注意，部署契约市场是可选的，如果您有其他方法为以太坊服务提供智能契约URL，它也完全可以工作。</p><h2 id="c061" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">3.提供服务实例</h2><p id="3ddc" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当发出提供服务实例的请求时，代理启动一个以太坊节点。以太坊节点公开其用于交互的远程过程调用(RPC) api，并通过给定的地址和端口号使端点可用。</p><p id="f8db" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">为了创建节点，您需要首先部署一个打算使用智能合约的Web3应用程序。对于这篇博文，我们将使用我们的<a class="ae lh" href="https://github.com/nkaviani/eth-apps/tree/master/sample-node-app" rel="noopener ugc nofollow" target="_blank">简单节点应用程序</a>,它只向分类帐写入和从中读取一个值。请注意，由于应用程序还没有连接到它的契约，所以我们在推送应用程序时不会启动它，否则部署将会失败。</p><pre class="kr ks kt ku fq nn no np nq aw nr dt"><span id="839c" class="mw is hu no b fv ns nt l nu nv">$ git clone <a class="ae lh" href="https://github.com/nkaviani/eth-apps" rel="noopener ugc nofollow" target="_blank">https://github.com/nimakaviani/eth-apps</a><br/>$ cd eth-apps/sample-node-app<br/>$ cf push nora --no-start</span></pre><p id="5009" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">验证应用程序<code class="eh nx ny nz no b">nora</code>是否被推送到您的Cloud Foundry部署中:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff oc"><img src="../Images/a6a63c563e606358d10ebe42f2bfae65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vSeKQ24WDRxseCjh."/></div></div></figure><p id="7a15" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">接下来，我们为部署的应用程序创建以太坊服务:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff od"><img src="../Images/72e4d34b8146b49427ee12bf31fbbf2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NXlN2IMqqevIUwVVpCKJw.png"/></div></div></figure><p id="95ce" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">对于创建服务的请求，service broker创建一个docker容器，在其上运行一个Ethereum节点。</p><p id="509d" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">这可以用BOSH通过连接到代理部署中的docker VM并查看它正在运行的docker容器列表来验证(注意，每个docker容器运行一个对应于所创建服务的Ethereum节点的实例)。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff ob"><img src="../Images/c8a2e3a11ff7c4d5b2f983c9afb0510b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gYeVpT9OnQvyUluh."/></div></div></figure><p id="7c7c" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">您可以看到以太坊节点的服务器运行在端口<code class="eh nx ny nz no b">8545</code>上，该端口从外部映射到主机虚拟机上的端口<code class="eh nx ny nz no b">32771</code>。</p><h2 id="6d58" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">4.创建服务绑定</h2><p id="51a4" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当绑定到服务时，URL形式的智能合约的位置被传递给代理。代理下载合同，编译合同，提取ABI，并使用启动服务时创建的帐户将二进制文件推送到以太坊节点。</p><p id="c7d9" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">我们前面提到过，示例合同市场提供了给定合同的链接，因此我们可以简单地获取合同的URL位置，并将其绑定到应用程序。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff ob"><img src="../Images/474d41c2e513b66f8b0a967d3294e991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Ke52MHisSymV_9w."/></div></div></figure><p id="288d" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">注意，在绑定服务时，我们将<code class="eh nx ny nz no b">contract_url</code>以内嵌JSON配置的形式传递给<code class="eh nx ny nz no b">cf bind-service</code>。</p><p id="3263" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">随着服务绑定的成功完成，我们可以发出一个<code class="eh nx ny nz no b">cf env</code>命令来查看应用程序的环境变量的更新列表。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff ob"><img src="../Images/9351c05c20da12f6fb6c7a005c827e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JATj3SC9C1uHWtaH."/></div></div></figure><p id="bade" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">在<code class="eh nx ny nz no b">VCAP_SERVICES</code>下，<code class="eh nx ny nz no b">eth</code>的配置涉及<code class="eh nx ny nz no b">eth_node</code>的<code class="eh nx ny nz no b">credentials</code>数据，如<em class="kn">契约</em> <em class="kn"> abi </em>，<em class="kn">账户地址</em>，<em class="kn">契约地址</em>，<em class="kn">交易散列</em>用于部署的契约，以及<em class="kn">主机地址</em>和<em class="kn">端口</em>的映射，用于应用连接到以太坊节点。</p><p id="164e" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">回到前面提到的示例节点应用程序，您会看到应用程序中的代码使用这些环境变量来绑定到智能协定并使用它。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="nl nm l"/></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">Code snippet to bind Web3 application to the deployed smart contract in Cloud Foundry</figcaption></figure><p id="1c25" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">瞧啊。有了这些信息，您就可以使用智能合约为node.js应用程序定义获取和设置分类帐值的路径:</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="nl nm l"/></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">Set and Get values into the blockchain ledger using deployed contract and Web3 application</figcaption></figure><h2 id="7326" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">5.删除服务绑定</h2><p id="0885" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在解除服务绑定时，代理假定不再需要绑定阶段使用的契约，因此，在收到解除绑定请求时，代理将服务从应用程序中分离出来，并从<code class="eh nx ny nz no b">VCAP_SERVICES</code>中删除注入的契约信息，但保留节点以备其他契约部署。新部署的契约将使用在服务创建阶段创建的相同帐户的相同以太坊节点。</p><p id="ffd1" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">在我们正在运行的示例中，以下命令将解除契约的绑定:</p><pre class="kr ks kt ku fq nn no np nq aw nr dt"><span id="3f5c" class="mw is hu no b fv ns nt l nu nv">cf unbind-service nora simple</span></pre><h2 id="5654" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">6.取消供应服务实例</h2><p id="c13d" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当发出取消供应服务的请求时，service broker继续删除docker容器:</p><pre class="kr ks kt ku fq nn no np nq aw nr dt"><span id="01a0" class="mw is hu no b fv ns nt l nu nv">cf delete-service eth</span></pre><h1 id="6785" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">挑战和未来改进计划</h1><h2 id="989f" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">1.同步分类帐</h2><p id="b31e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">像许多其他区块链网络一样，以太坊中的节点需要完整的分类账才能使后续交易生效。这意味着由BlockHead service broker创建的docker容器要么需要在创建时包含完整的分类帐，要么需要在创建容器后同步分类帐。后者非常耗时。mainnet以太坊的分类帐大小约为600GB，并且还在增长。给定分类帐的大小，被配置的以太坊节点将花费相当多的时间来同步其分类帐并准备就绪，这使得集成不切实际。</p><p id="e950" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">另一种解决方案是让service broker维护一个温暖的docker映像，其中包含一个最新的分类帐副本，以便在创建服务时使用。这要求代理运行一个端节点，该端节点不断地将其分类帐与以太坊网络的分类帐同步，并定期创建和发布以太坊节点docker映像。</p><p id="d38e" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">目前，service broker在开发人员模式下启动以太坊节点，这意味着从一个新的分类帐开始。这有助于我们快速建立一个开发环境来测试Web3应用程序，同时避免长时间等待分类账同步。我们计划实现一些技术，允许以太坊节点快速启动mainnet或testnet，用于生产目的。</p><h2 id="556b" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">2.内存占用</h2><p id="fe32" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">同步分类帐包括从网络中的其他对等方读取交易块，验证它们，然后将它们添加到分类帐的本地副本中。由于写入磁盘是I/O密集型操作，以太坊节点会在内存中维护分类帐的一个子集，同时在将新数据块写入磁盘之前执行节点的验证和链接。这限制了部署以太坊节点的虚拟机的内存使用，并为代理可以运行和管理的容器数量设定了上限。</p><h2 id="05f9" class="mw is hu bd it mx my mz ix na nb nc jb ka nd ne jf ke nf ng jj ki nh ni jn nj dt translated">3.账户管理</h2><p id="6c94" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如前所述，以太坊节点在能够部署契约之前需要绑定到一个以太坊帐户。这意味着代理要么需要管理以太坊帐户，要么在内部创建并向应用程序开发人员公开这些帐户，要么允许开发人员导入他们自己的帐户供代理使用。</p><p id="6c36" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">目前，删除智能合约服务和相应的以太坊节点后，帐户将被丢弃。这将被修改为帐户可导出/下载。</p><h1 id="8cdf" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">摘要</h1><p id="7880" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在这篇博文中，我们讨论了BlockHead项目作为服务代理的实现，该项目将在Cloud Foundry和Kubernetes等PaaS平台中使用。项目BlockHead的目标是通过消除部署和管理区块链节点的复杂性，简化智能合约在Web3应用程序中的部署和使用。</p><p id="067e" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">虽然我们描述了部署和使用代理的端到端过程，但是应用程序开发人员只需要关心上述过程的步骤3到6。这包括创建一个智能合约服务并将其绑定到应用程序。部署service broker和契约市场的步骤1和2可能只需执行一次，通常由平台工程师和运营工程师管理，从而简化了整个流程。</p><p id="5a62" class="pw-post-body-paragraph jp jq hu jr b js lc ju jv jw ld jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">Project BlockHead是在2018年波士顿Cloud Foundry Summit期间作为黑客马拉松项目出现的，正如你可能已经注意到的那样，我们在这篇博文中分享的大多数存储库都是我们参与黑客马拉松的团队的个人github存储库。幸运的是，该项目已经收到了社区的大量兴趣，希望在不久的将来，它将作为孵化项目找到一个新的家，并得到适当的CI/CD-ed。因此，请回到这篇博文，进一步了解在哪里可以找到官方的项目资源库。这是一个开源项目，我们当然欢迎任何有助于改进它的贡献。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="oe nm l"/></div></figure></div></div>    
</body>
</html>