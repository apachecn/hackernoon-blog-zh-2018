<html>
<head>
<title>I am a College Student and I Built My Own Robo Advisor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是一名大学生，我建立了自己的机器人顾问</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/i-am-a-college-student-and-i-built-my-own-robo-advisor-3f31b39dab50?source=collection_archive---------3-----------------------#2018-06-10">https://medium.com/hackernoon/i-am-a-college-student-and-i-built-my-own-robo-advisor-3f31b39dab50?source=collection_archive---------3-----------------------#2018-06-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/08a094760af17750eecd402e212cb4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKTZDEKuQeg18B-FjVrqqw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“Yes, you an do it too!”</figcaption></figure><p id="f634" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我是<a class="ae ke" rel="noopener" href="/@raobvinnakota">饶</a>，我是<a class="ae ke" href="https://hackernoon.com/tagged/alpaca" rel="noopener ugc nofollow" target="_blank">羊驼</a>的实习生，致力于构建一个开源<a class="ae ke" href="https://hackernoon.com/tagged/robo-advisor" rel="noopener ugc nofollow" target="_blank">的robo advisor </a>。我在这个领域没有太多经验，我不得不寻找很多答案。虽然网上有丰富的材料，但很少是有组织的。这个帖子是我通过阅读寻找答案的各种帖子和论坛的组合。</p><h1 id="99b4" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">到底什么是机器人顾问？！</h1><p id="493a" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">Robo advisors是自动化的建议服务，几乎不需要用户交互。他们专门根据投资者选择的风险水平维护投资组合。顺便说一句，它们是在2008年金融危机开始时推出的。</p><p id="1993" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">机器人顾问的实际逻辑很简单。</p><ul class=""><li id="2bd0" class="li lj hu ji b jj jk jn jo jr lk jv ll jz lm kd ln lo lp lq dt translated">"<strong class="ji hv">分配</strong> " —给定一个风险水平，部分资本被分配到不同的位置。</li><li id="40a3" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">"<strong class="ji hv">距离</strong> " —在一段固定的时间间隔内，顾问会扫描投资组合余额是否有重大变化，以及</li><li id="7dcf" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">"<strong class="ji hv">重新平衡</strong> " —如有必要，重新平衡。</li></ul><h1 id="691c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">分配:</h1><p id="22c4" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">分配的过程是基于开发者的算法将不同的权重分配给资产类别。这些资产类别涵盖了市场的各个方面，并保持了多元化的投资组合。Wealthfront将这些资产类别视为:</p><ul class=""><li id="04c1" class="li lj hu ji b jj jk jn jo jr lk jv ll jz lm kd ln lo lp lq dt translated">美国股票</li><li id="bc0b" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">外国股票</li><li id="5eac" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">美国债券</li><li id="c416" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">外国债券</li><li id="da42" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">通货膨胀保护</li></ul><p id="2c64" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这些资产中的每一种都用ETF来代表，ETF捕捉到了该资产类别的大致情况。</p><h1 id="401d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">距离:</h1><p id="2e36" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">重新平衡投资组合会带来一定的管理费用和成本。为了避免这种情况，robo advisor会计算一个“距离”向量。要触发重新平衡，这个距离必须大于给定的阈值。大多数机器人顾问通常将这个阈值设置为5%。</p><p id="e7be" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这种情况下，距离是每个位置重量的个体变化。这是通过首先计算当前分配来完成的。这是相对于投资组合总价值的头寸价值。如果任何一个位置的权重大于5%(当前权重/目标权重&gt; 1.05)，那么robo advisor将触发重新平衡</p><h1 id="d8cb" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">重新平衡:</h1><p id="0e26" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">再平衡是指通过买卖让投资组合回到目标状态的行为。重要的是，所有销售都要先完成。一旦收集到所有可用的现金，就进行必要的购买。</p><p id="5d9e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要计算卖出多少，使用现金的目标分配(权重*投资组合价值)，并查看现金产生的股票数量。当前持有的股票数量与股票目标水平之间的差额就是买入/卖出的数量。</p><h1 id="aac8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">使用Vanguard Core系列实施Robo Advisor:</h1><p id="a1a1" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">既然我们已经建立了机器人顾问的各个组成部分，我们将开始执行构建一个机器人顾问的步骤。我们将使用Quantopian的IDE来构建我们的robo advisor。</p><p id="b6c7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在实现我们的advisor时，我发现分步实现最简单。Quantopian的IDE只能对完整的算法进行回溯测试。这意味着，没有“中途”发展。所以，每一步都是一个独立的算法。</p><p id="55d3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">注意:Vanguard核心系列的实现使用了在此处找到的<a class="ae ke" href="https://advisors.vanguard.com/iwe/pdf/FASINVMP.pdf" rel="noopener ugc nofollow" target="_blank">信息。该投资组合包括对货币市场基金的2%投资，但这在Quantopian上不可用，因此出于本教程的目的，我们将忽略它。</a></p><h1 id="9cb7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">基于风险的分配:</h1><p id="7cf1" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">第一步，是确定我们的宇宙，并使用风险等级分配权重。我们的宇宙将是先锋核心系列:</p><ul class=""><li id="d844" class="li lj hu ji b jj jk jn jo jr lk jv ll jz lm kd ln lo lp lq dt translated">VTI —国内股票</li><li id="89bf" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">VXUS —国际股票</li><li id="26d7" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">BND —国内固定收益(债券)</li><li id="b97d" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ln lo lp lq dt translated">BNDX —国际固定收益(债券)</li></ul><p id="dd62" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">风险水平实际上是固定收益与权益的比率，权益的波动性更大。因此，0级风险将所有资本分配到固定收益(BND，BNDX)，而5级风险将是50/50。所有11个可能的风险级别都被编入字典，关键字是风险级别，值是包含权重分配的元组:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="4568" class="mf kg hu mb b fv mg mh l mi mj">risk_level = 5<br/>risk_based_allocation = {0: (0,0,0.686,0.294),<br/>                         1: (0.059,0.039,0.617,0.265),<br/>                         2: (0.118,0.078,0.549,0.235),<br/>                         3: (0.176,0.118,0.480,0.206),<br/>                         4: (0.235,0.157,0.412,0.176),<br/>                         5: (0.294,0.196,0.343,0.147), <br/>                         6: (0.353,0.235,0.274,0.118),<br/>                         7: (0.412,0.274,0.206,0.088),<br/>                         8: (0.470,0.314,0.137,0.059),<br/>                         9: (0.529,0.353,0.069,0.029),<br/>                         10: (0.588,0.392,0,0)}</span></pre><p id="6838" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下一步将是在Quantopian中实现我们的分配。对于这一步，我们需要的唯一方法是initialize和handle_data。其余的都是多余的。</p><p id="7044" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">initialize方法是主要的。当回溯测试开始时，它会自动调用initialize。因此，initialize将是包含风险级别字典以及选择风险级别的函数。初始化后会自动调用handle_data方法。在这里，我们将实际购买initialize中列出的头寸。</p><p id="27f5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">initialize和handle_data都有变量context和data。上下文允许用户存储在方法间传递的全局变量。数据帮助算法获取不同种类的数据。(注意:这与Quantopian 1不同，在quanto pian 1中，数据是存储全局变量的对象)。</p><p id="0d3c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们开始吧。在初始化中，复制并粘贴以下代码:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="4bac" class="mf kg hu mb b fv mg mh l mi mj">context.stocks = symbols(‘VTI’, ‘VXUS’, ‘BND’, ‘BNDX’)<br/>context.bought = False</span><span id="4c32" class="mf kg hu mb b fv mk mh l mi mj">risk_level = 5<br/>risk_based_allocation = {0: (0,0,0.686,0.294),<br/>                         1: (0.059,0.039,0.617,0.265),<br/>                         2: (0.118,0.078,0.549,0.235),<br/>                         3: (0.176,0.118,0.480,0.206),<br/>                         4: (0.235,0.157,0.412,0.176),<br/>                         5: (0.294,0.196,0.343,0.147),<br/>                         6: (0.353,0.235,0.274,0.118),<br/>                         7: (0.412,0.274,0.206,0.088),<br/>                         8: (0.470,0.314,0.137,0.059),<br/>                         9: (0.529,0.353,0.069,0.029),<br/>                         10: (0.588,0.392,0,0)}<br/>    #Saves the weights to easily access during rebalance<br/>context.target_allocation = dict(zip(context.stocks,<br/>                            risk_based_allocation[risk_level]))</span><span id="6538" class="mf kg hu mb b fv mk mh l mi mj">    #To make initial purchase<br/>context.bought = False</span></pre><p id="5dff" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">变量context.stocks是股票对象的列表。symbols函数将字符串转换成对象。这些对象具有诸如当前价格、收盘价等属性。使用该列表以及用于分配的字典，我们将创建第二个字典context.target_allocation。关键是每个股票(VTI，VXUS等。)并且这些值是股票行情自动收录器的权重。这本字典对分配和再平衡都有用。</p><p id="662e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">复制并粘贴以下代码以创建handle_data:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="27e2" class="mf kg hu mb b fv mg mh l mi mj">if not context.bought:<br/>        for stock in context.stocks:<br/>            amount = (context.target_allocation[stock] *<br/>                      context.portfolio.cash) / data.current(stock,’price’)<br/>            if (amount != 0):<br/>                order(stock, int(amount))<br/>                #log purchase<br/>            log.info(“buying “ + str(int(amount)) + “ shares of “ +<br/>                     str(stock))</span><span id="ccb8" class="mf kg hu mb b fv mk mh l mi mj">         #now won’t purchase again and again<br/>         context.bought = True</span></pre><p id="8d59" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">变量context.bought指的是最初在initialize中设置为False的值。因为每次市场事件发生时都会调用handle_data。因此，使用context.bought可以确保股票只被购买一次。</p><p id="d75e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了购买每只股票的股份，遍历股票对象列表。对于每只股票，通过分配适当数量的资本(重量*资本)，然后将该资本除以当前价格，计算出股票总数。由于我们只能购买整股股票，剩余的资本被添加回手头的现金。</p><p id="107e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，为了获得更流畅的回溯测试体验，所有事务都被记录。日志在右下角。构建当前算法。将开始日期设置为2013年6月或更晚，因为ETF BNDX于2013年6月7日首次交易。</p><h1 id="2dd7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">计算距离:</h1><p id="3dbb" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">在重新平衡投资组合之前，最好先计算一下当前投资组合是否值得重新平衡。在更复杂的robo advisors中，这一步将有一个用算法计算的目标投资组合。对于这个例子，我们的目标投资组合将是由initialize中的风险水平定义的初始分配。</p><p id="63f5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">随着每个头寸价值的波动，他们的投资组合权重也可能发生变化。距离向量将是每个单独位置的权重变化。计算距离分三步进行:</p><ol class=""><li id="86ed" class="li lj hu ji b jj jk jn jo jr lk jv ll jz lm kd ml lo lp lq dt translated">计算每个位置的当前权重</li><li id="19ac" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ml lo lp lq dt translated">计算目标重量(已经完成)</li><li id="3b74" class="li lj hu ji b jj lr jn ls jr lt jv lu jz lv kd ml lo lp lq dt translated">比较两个重量</li></ol><p id="d57c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们希望每天检查余额，所以我们将在_trading_starts之前，在代码中添加以下函数:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="560d" class="mf kg hu mb b fv mg mh l mi mj">def before_trading_starts(context, data):<br/>    #total value<br/>    value = context.portfolio.portfolio_value +<br/>                                         context.portfolio.cash<br/>    #calculating current weights for each position<br/>    for stock in context.stocks:<br/>        if (context.target_allocation[stock] == 0):<br/>            continue<br/>        current_holdings = data.current(stock,’close’) *<br/>                      context.portfolio.positions[stock].amount<br/>        weight = current_holdings/value<br/>        growth = float(weight) /<br/>                        float(context.target_allocation[stock])<br/>        if (growth &gt;= 1.025 or growth &lt;= 0.975):<br/>            log.info(“Need to rebalance portfolio”)<br/>            break</span></pre><p id="d5c2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们首先计算总价值。因为这个值不变，所以它可能在循环之外。然后，计算每个头寸的单个权重，并与目标权重进行比较(我们使用除法，因为我们对头寸的相对增长感兴趣，而不是绝对增长)。如果增长超过阈值(目前为2.5%)或低于阈值(贬值)，则会触发再平衡。我们没有编写实际的重新平衡函数，所以现在，我们将简单地记录重新平衡是必要的。重要的是要注意添加的中断。一旦算法意识到是时候重新平衡了，就没有必要继续检查剩余的股票。它创造了一个更好的最佳情况。</p><p id="bca8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而，我们实际上还没有完成。我们必须在_trading_start之前调用，但是循环调用效率很低。这就是为什么我们将在initialize中使用schedule_function命令。将这行代码添加到功能块的末尾:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="f026" class="mf kg hu mb b fv mg mh l mi mj">    schedule_function(<br/>    func=before_trading_starts,<br/>    date_rule=date_rules.every_day(),<br/>    time_rule=time_rules.market_open(hours=1))</span></pre><p id="1556" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将在每天开市时安排一次距离计算。通过计算早晨的距离，我们有了执行再平衡行动所必需的时间和空间。</p><h1 id="eded" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">调整资金组合</h1><p id="9403" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">重新平衡投资组合的行为分两步进行。先把需要卖的资产都卖了，再把需要买的资产都买了。先卖确保我们不会现金耗尽。</p><p id="b617" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是重新平衡函数的代码:</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="9788" class="mf kg hu mb b fv mg mh l mi mj">def rebalance(context, data):<br/>    for stock in context.stocks:<br/>        current_weight = (data.current(stock, ‘close’) *<br/>                          context.portfolio.positions[stock].amount) /<br/>                          context.portfolio.portfolio_value<br/>        target_weight = context.target_allocation[stock]<br/>        distance = current_weight — target_weight<br/>        if (distance &gt; 0):<br/>            amount = -1 * (distance * context.portfolio.portfolio_value) /<br/>                     data.current(stock,’close’)<br/>            if (int(amount) == 0):<br/>                continue<br/>            log.info(“Selling “ + str(int(amount)) + “ shares of “ +<br/>                      str(stock))<br/>            order(stock, int(amount))<br/>    for stock in context.stocks:<br/>        current_weight = (data.current(stock, ‘close’) *<br/>                          context.portfolio.positions[stock].amount) /<br/>                          context.portfolio.portfolio_value<br/>        target_weight = context.target_allocation[stock]<br/>        distance = current_weight — target_weight<br/>        if (distance &lt; 0):<br/>            amount = -1 * (distance * context.portfolio.portfolio_value) /<br/>                     data.current(stock,’close’)<br/>            if (int(amount) == 0):<br/>                continue<br/>            log.info(“Buying “ + str(int(amount)) + “ shares of “ +<br/>                      str(stock))<br/>            order(stock, int(amount))</span></pre><p id="82e0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">销售和购买机制是相同的。唯一的区别是在出售股票时，调用order函数时使用了负值。在这两种情况下，我们取重量的绝对差值(目标值-当前值)，并使用该值来计算要买卖的股票数量。</p><h1 id="5116" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">多重宇宙</h1><p id="cf56" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">先锋提供了核心系列之外的几个宇宙。目前，我们能够控制风险水平，并观察结果。让我们添加能够选择一个宇宙的功能。</p><p id="5bd5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">第一种简单的方法是实现多个字典。这是类似的东西看起来的样子。我们的算法中加入了CRSP级数。用户现在可以选择领域和风险级别。</p><pre class="lw lx ly lz fq ma mb mc md aw me dt"><span id="0a95" class="mf kg hu mb b fv mg mh l mi mj">    core_series = symbols(‘VTI’, ‘VXUS’, ‘BND’, ‘BNDX’)<br/>    crsp_series = symbols(‘VUG’, ‘VTV’, ‘VB’, ‘VEA’, ‘VWO’, ‘BSV’, ‘BIV’, ‘BLV’, ‘VMBS’, ‘BNDX’)<br/>    #universe risk based allocation<br/>    core_series_weights = {0: (0,0,0.686,0.294),<br/>                           1: (0.059,0.039,0.617,0.265),<br/>                           2: (0.118,0.078,0.549,0.235),<br/>                           3: (0.176,0.118,0.480,0.206),<br/>                           4: (0.235,0.157,0.412,0.176),<br/>                           5: (0.294,0.196,0.343,0.147),<br/>                           6: (0.353,0.235,0.274,0.118),<br/>                           7: (0.412,0.274,0.206,0.088),<br/>                           8: (0.470,0.314,0.137,0.059),<br/>                           9: (0.529,0.353,0.069,0.029),<br/>                           10: (0.588,0.392,0,0)}<br/>    crsp_series_weights = {0: (0,0,0,0,0,0.273,0.14,0.123,0.15,0.294),<br/>1: (0.024,0.027,0.008,0.03,0.009,0.245,0.126,0.111,0.135,0.265),<br/>2: (0.048,0.054,0.016,0.061,0.017,0.218,0.112,0.099,0.12,0.235),<br/>3: (0.072,0.082,0.022,0.091,0.027,0.191,0.098,0.086,0.105,0.206),<br/>4: (0.096,0.109,0.03,0.122,0.035,0.164,0.084,0.074,0.09,0.176),<br/>5: (0.120,0.136,0.038,0.152,0.044,0.126,0.07,0.062,0.075,0.147),<br/>6: (0.143,0.163,0.047,0.182,0.053,0.109,0.056,0.049,0.06,0.118),<br/>7: (0.167,0.190,0.055,0.213,0.061,0.082,0.042,0.037,0.045,0.088),<br/>8: (0.191,0.217,0.062,0.243,0.071,0.055,0.028,0.024,0.030,0.059),<br/>9: (0.215,0.245,0.069,0.274,0.079,0.027,0.014,0.013,0.015,0.029),<br/>10: (0.239,0.272,0.077,0.304,0.088,0,0,0,0,0)}</span><span id="5614" class="mf kg hu mb b fv mk mh l mi mj">    #set universe and risk level<br/>    context.stocks = crsp_series<br/>    risk_based_allocation = crsp_series_weights<br/>    risk_level = 1</span></pre><p id="eb04" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">用户可以使用context.stocks、risk_based_allocation和risk_level这三个变量来设置范围和风险级别。</p><h1 id="9c0d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">下一步是什么</h1><p id="1052" class="pw-post-body-paragraph jg jh hu ji b jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd hn dt translated">用Quantopian开发是一种很棒的体验——他们提供了很多有用的工具。但是，它也有局限性，被迫只能在一个文件中工作，等等。为了进一步构建这个robo advisor，我计划将我目前的工作迁移到后端，并使用Quantopian的开源python库Zipline来运行回溯测试。下一期将涵盖所有这些内容以及更多内容！</p><p id="fa83" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">你可以在这里</strong>  <strong class="ji hv">找到算法</strong> <a class="ae ke" href="https://www.quantopian.com/posts/built-robo-advisor" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">。你自己试试！</strong></a></p><p id="7564" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="mm">由</em> <a class="ae ke" rel="noopener" href="/@raobvinnakota"> <em class="mm">饶</em> </a></p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><figure class="lw lx ly lz fq iv fe ff paragraph-image"><a href="https://medium.com/automation-generation"><div class="fe ff mw"><img src="../Images/4d7d212ef68dd071daeaae0916d72f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgwdHnaQXAnW0LtrVSpdMA.png"/></div></a></figure><h2 id="0a5c" class="mf kg hu bd kh mx my mz kl na nb nc kp jr nd ne kt jv nf ng kx jz nh ni lb nj dt translated">金融市场、算法交易、技术方面的新岗位请关注<a class="ae ke" rel="noopener" href="/@alpacahq">羊驼</a>和<a class="ae ke" href="https://medium.com/automation-generation" rel="noopener">自动化生成</a>。</h2><h2 id="175e" class="mf kg hu bd kh mx my mz kl na nb nc kp jr nd ne kt jv nf ng kx jz nh ni lb nj dt translated">你可以找到我们<a class="ae ke" href="https://twitter.com/AlpacaHQ" rel="noopener ugc nofollow" target="_blank">@羊驼HQ </a>，如果你用twitter的话。</h2><figure class="lw lx ly lz fq iv fe ff paragraph-image"><a href="https://medium.com/automation-generation"><div class="fe ff nk"><img src="../Images/cdfe4e1b3df7ff7b28e2474ff8dfef1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xnDRs1aVpqUjToFRmk5Zw.png"/></div></a></figure></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><p id="1259" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="mm">感谢阅读！请跟随</em> </strong> <a class="ae ke" rel="noopener" href="/@alpacahq"> <strong class="ji hv"> <em class="mm">羊驼</em> </strong> </a> <strong class="ji hv"> <em class="mm">和</em> </strong> <a class="ae ke" href="https://medium.com/automation-generation" rel="noopener"> <strong class="ji hv"> <em class="mm">自动化生成</em> </strong> </a> <strong class="ji hv"> <em class="mm">获取金融市场、算法交易、技术方面的新鲜帖子。你可以找到我们</em></strong><a class="ae ke" href="https://twitter.com/AlpacaHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv"><em class="mm">@羊驼HQ </em> </strong> </a> <strong class="ji hv"> <em class="mm">，如果你用twitter的话。</em>T53】</strong></p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><p id="0589" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你是一名黑客，并且能够创造出在金融市场上运行的很酷的东西，<strong class="ji hv">请查看我们的项目“</strong> <a class="ae ke" href="https://alpaca.markets/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=strategy_list&amp;utm_content=part1" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">免佣金股票交易API </strong> </a> <strong class="ji hv">”，在这里我们免费提供简单的REST交易API和实时市场数据。</strong></p><p id="0f3d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">经纪服务由FINRA/SIPC成员Alpaca Securities LLC(<a class="ae ke" href="https://alpaca.markets/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=strategy_list&amp;utm_content=part1" rel="noopener ugc nofollow" target="_blank">Alpaca . markets</a>)提供。羊驼证券有限责任公司是AlpacaDB，Inc .的全资子公司。</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nl mo l"/></div></figure></div></div>    
</body>
</html>