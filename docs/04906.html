<html>
<head>
<title>Seamlessly Cross-Compiling Rust for Raspberry Pi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Raspberry Pi的无缝交叉编译Rust</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/seamlessly-cross-compiling-rust-for-raspberry-pis-ede5e2bd3fe2?source=collection_archive---------5-----------------------#2018-06-10">https://medium.com/hackernoon/seamlessly-cross-compiling-rust-for-raspberry-pis-ede5e2bd3fe2?source=collection_archive---------5-----------------------#2018-06-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f77f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的几周里，我把大部分时间都集中在一个项目上，我们称之为<strong class="it hv"> <em class="jp"> spark </em> </strong>。本质上，它是一个建立在Raspberry Pi之上的数据网关，将机器和能源指标从现有基础设施连接到我们的数据管道。</p><p id="d5bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于我们的主要关注点是高达100Hz的高频读数，所以很快就发现python(通常是我的首选语言)并不合适。经过一番研究后，我很快就选定了Rust，因为它具有尖端的性能，并且有一句话叫“<em class="jp">如果我编译，它就是安全的”</em>。</p><p id="6c7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但和往常一样，一切都是有代价的:虽然Rust速度惊人，让我们能够满怀信心地开发和发布新功能和修复程序，但它需要针对特定的架构进行编译——在我们的例子中是armv7。在MacbookPro上工作时，我最初解决这个问题的方法是拉动整个回购并在Raspberry Pi本身上构建应用程序，这导致了长达30分钟的不耐烦。</p><p id="b341" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了寻找更简化的构建过程，我最终实现了一个构建在<a class="ae jq" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>之上的交叉编译管道，我想和你分享一下。</p><h2 id="2189" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">对你有什么好处？</h2><p id="f570" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">这篇文章旨在帮助您逐步构建自己的自动化交叉编译管道:</p><ol class=""><li id="2233" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz dt translated">首先，我们将建立一个小的Rust程序，稍后我们将为armv7交叉编译它。</li><li id="52a0" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">其次，我们将创建一个定制的Docker映像，它将处理大量的交叉编译系统依赖以及我们的应用程序。</li><li id="99f0" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz dt translated">最后，我们将编写一个shell脚本来执行交叉编译过程。</li></ol><p id="d20b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们已经设定了范围，让我们为起飞做好准备吧！</p><figure class="lf lg lh li fq lj"><div class="bz el l di"><div class="lk ll l"/></div></figure><h1 id="62b9" class="lm js hu bd jt ln lo lp jx lq lr ls kb lt lu lv ke lw lx ly kh lz ma mb kk mc dt translated">准备我们的防锈应用</h1><p id="2239" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">由于这篇文章主要关注Rust应用程序的自动交叉编译，我们将建立一个裸支架并添加一个系统依赖项，我发现这特别棘手:OpenSSL。</p><p id="afca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们首先创建一个名为<code class="eh md me mf mg b">hello-rpi</code>的新目录，并将<code class="eh md me mf mg b">cd</code>放入其中。然后，我们通过在我们选择的终端中运行<code class="eh md me mf mg b">cargo new --bin hello-rpi</code>来初始化一个新的cargo项目。现在，我们应该有一个名为<code class="eh md me mf mg b">hello-rpi</code>的项目目录，其文件夹结构如下:</p><pre class="lf lg lh li fq mh mg mi mj aw mk dt"><span id="6ff7" class="jr js hu mg b fv ml mm l mn mo">hello-rpi<br/>|<br/>|--- hello-rpi<br/>*    |--- Cargo.toml<br/>     |<br/>     |--- src<br/>     *     |--- main.rs<br/>           *</span></pre><p id="3baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">生成我们的最小应用程序后，在我们的<code class="eh md me mf mg b">Cargo.toml</code>文件中添加<code class="eh md me mf mg b">openssl = “0.10.5”</code>作为依赖项，并在<code class="eh md me mf mg b">main.rs</code>中将<code class="eh md me mf mg b">openssl</code>声明为外部机箱。经过我们的小调整，我们的<code class="eh md me mf mg b">Cargo.toml</code>和<code class="eh md me mf mg b">main.rs</code>应该是这样的:</p><p id="8c5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Cargo.toml </strong></p><pre class="lf lg lh li fq mh mg mi mj aw mk dt"><span id="848a" class="jr js hu mg b fv ml mm l mn mo">[package]<br/>name = "hello-rpi"<br/>version = "0.1.0"<br/>authors = ["your handle &lt;<a class="ae jq" href="mailto:deniz.saner@rwth-aachen.de" rel="noopener ugc nofollow" target="_blank">your@mail.c</a>om&gt;"]</span><span id="d5b1" class="jr js hu mg b fv mp mm l mn mo">[dependencies]<br/>openssl = "0.10.5"</span></pre><p id="e58e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> main.rs </strong></p><pre class="lf lg lh li fq mh mg mi mj aw mk dt"><span id="66a3" class="jr js hu mg b fv ml mm l mn mo">extern crate openssl;</span><span id="0b0b" class="jr js hu mg b fv mp mm l mn mo">fn main() {<br/>    println!("Hello, world!");<br/>}</span></pre><p id="7969" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，继续将以下几行添加到<code class="eh md me mf mg b">hello-rpi/hello-rpi/.cargo/config</code>中的板条箱货物配置文件中:</p><pre class="lf lg lh li fq mh mg mi mj aw mk dt"><span id="9688" class="jr js hu mg b fv ml mm l mn mo">[target.armv7-unknown-linux-gnueabihf]<br/>linker = "arm-linux-gnueabihf-gcc"</span></pre><p id="40cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将告诉cargo使用哪个链接器，当我们指定<code class="eh md me mf mg b">armv7-unkown-linux-gnueabih</code>作为我们的目标时，这是我们Pi的架构。有了这几行代码，我们就完成了Rust端的工作。</p><h1 id="17ab" class="lm js hu bd jt ln lo lp jx lq lr ls kb lt lu lv ke lw lx ly kh lz ma mb kk mc dt translated">创建我们的自定义Docker图像</h1><figure class="lf lg lh li fq lj fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mq"><img src="../Images/706751c179fc8ddfd0b692875037e6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovRuAuqPf4r2xpiWh71rUg.png"/></div></div></figure><p id="bcaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的最小应用程序集已经准备就绪，现在我们把重点放在自动化应用程序的交叉编译过程上。为此，我们将创建一个Docker映像，它将处理我们的应用程序以及我们的依赖项的交叉编译，即我们的OpenSSL。</p><p id="fd89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，我们不必从零开始——斯蒂芬·瑟沃尔的码头工人形象<code class="eh md me mf mg b">raspberry-pi-cross-compiler</code>，可以在这里找到<a class="ae jq" href="https://github.com/sdt/docker-raspberry-pi-cross-compiler" rel="noopener ugc nofollow" target="_blank"/>，提供了一个很棒的样板。当不带任何参数运行时，基于该映像的容器返回一个助手脚本，该脚本反过来让您与容器交互并开始实际的交叉编译。</p><p id="4c78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以让我们开始吧！在我们的项目中创建一个新文件夹(不是板条箱！)根命名为<code class="eh md me mf mg b">rpxc</code>，创建一个<code class="eh md me mf mg b">Dockerfile</code>并粘贴以下内容到其中:</p><figure class="lf lg lh li fq lj"><div class="bz el l di"><div class="mx ll l"/></div></figure><p id="8f37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇，这里发生了很多事情——让我们分解一下:首先，我们将我们的基础映像指向sdthirwall的<code class="eh md me mf mg b">raspberry-pi-cross-compiler</code>,并通过<code class="eh md me mf mg b">apt-get</code>安装一些包——没什么特别的。</p><p id="34a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们使用<code class="eh md me mf mg b">ENV</code>表达式来设置指向我们的<code class="eh md me mf mg b">Cargo</code>和<code class="eh md me mf mg b">Rustup</code>安装以及OpenSSL <code class="eh md me mf mg b">lib</code>和<code class="eh md me mf mg b">include</code>目录的环境变量。</p><p id="0099" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随后的<code class="eh md me mf mg b">RUN</code>块借用了<code class="eh md me mf mg b">rust:1.26.0</code>图像，用于安装Rust工具链并添加<code class="eh md me mf mg b">armv7-unknown-linux-gnueabihf</code>作为编译目标。顾名思义，这是我们的树莓架构的编译器。</p><p id="4368" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，第二个<code class="eh md me mf mg b">RUN</code>命令为我们的目标架构下载、解压缩和交叉编译OpenSSL。注意，我们指向OpenSSL的<code class="eh md me mf mg b">lib</code>和<code class="eh md me mf mg b">include</code>目录的环境变量与我们的安装路径相匹配。</p><p id="23ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没那么复杂，对吧？更重要的是，这种设置通过简单地扩展我们的<code class="eh md me mf mg b">Dockerfile</code>-没有比这更容易的了。</p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><h1 id="b4e8" class="lm js hu bd jt ln nf lp jx lq ng ls kb lt nh lv ke lw ni ly kh lz nj mb kk mc dt translated">自动化构建过程</h1><p id="bcf8" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">随着我们<code class="eh md me mf mg b">Dockerfile</code>的建立，我们离构建管道只差一步之遥。更准确地说，我们想</p><ul class=""><li id="f9e8" class="kr ks hu it b iu iv iy iz jc kt jg ku jk kv jo nk kx ky kz dt translated">构建我们刚刚定义的Docker映像</li><li id="5500" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo nk kx ky kz dt translated">启动一个容器来获得我上面提到的交叉编译脚本</li><li id="4e83" class="kr ks hu it b iu la iy lb jc lc jg ld jk le jo nk kx ky kz dt translated">使用该脚本启动交叉编译过程</li></ul><p id="80b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将这个过程转换成一个shell脚本并进行一些清理会产生六行代码，这些代码需要放在<code class="eh md me mf mg b">rpxc</code>目录中才能正常工作。</p><figure class="lf lg lh li fq lj"><div class="bz el l di"><div class="mx ll l"/></div></figure><p id="688b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！我们定义了自定义Docker映像，它在构建时处理交叉编译系统依赖关系，并编写了一个shell脚本来实际构建和交叉编译整个应用程序。现在，你可以简单地将<code class="eh md me mf mg b">cd</code>转换成<code class="eh md me mf mg b">rpxc</code>，运行上面的脚本，坐下来观看神奇的事情发生。</p><figure class="lf lg lh li fq lj"><div class="bz el l di"><div class="nl ll l"/></div></figure><h1 id="97ff" class="lm js hu bd jt ln lo lp jx lq lr ls kb lt lu lv ke lw lx ly kh lz ma mb kk mc dt translated">摘要</h1><p id="f3d3" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">在这篇文章中，我们构建了一个构建管道，让我们只需执行一个shell脚本就可以交叉编译armv7架构的任何Rust应用程序。为此，我们构建了一个定制的<code class="eh md me mf mg b">Dockerfile</code>，添加了特定于应用程序的系统依赖项，并编写了一个小的shell脚本，开始了交叉编译过程。</p><p id="cba5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种设置是有利的，原因有很多:首先，只要安装了Docker，就可以在任何机器和平台上构建应用程序。因此，您可以轻松地将整个构建过程集成为持续集成管道的最后一步。此外，您可以通过扩展<code class="eh md me mf mg b">Dockerfile</code>来添加任何额外的系统依赖性，这使得该解决方案可扩展到更复杂的应用程序，这些应用程序可能依赖于大量的系统依赖性。</p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="6cf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我这边就是这样！我希望你喜欢我的第一篇帖子，并且我能够让你开始为<a class="ae jq" href="https://hackernoon.com/tagged/raspberry" rel="noopener ugc nofollow" target="_blank"> Raspberry </a> Pis交叉编译Rust。如果你对我的帖子有任何问题或批评，请在下面的评论中告诉我！</p><p id="bf15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jp">全披露:</em> </strong>我是Enlyze的联合创始人之一。我们是一家位于德国亚琛的初创公司，它将功耗视为任何电器健康状况的通用指标。我们的六人团队由充满激情的人工智能研究人员和电子及软件工程师组成。如果你想联系，给我们发一封去hello@enlyze.com的邮件。</p><figure class="lf lg lh li fq lj"><div class="bz el l di"><div class="nm ll l"/></div></figure></div></div>    
</body>
</html>