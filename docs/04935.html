<html>
<head>
<title>Using Generators as syntax sugar for side effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用生成器作为副作用的语法糖</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-generators-as-monads-do-notation-8600c53648cf?source=collection_archive---------18-----------------------#2018-06-11">https://medium.com/hackernoon/using-generators-as-monads-do-notation-8600c53648cf?source=collection_archive---------18-----------------------#2018-06-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7d25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个故事展示了生成器作为一种显式的无缝语法，用于具有异步操作、共享可变状态和其他副作用的程序。这种转换是基于所谓的单子。</p><p id="dbe1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管名字很吓人，单子是一个非常简单的概念。当您更改一些变量值或输出任何内容或抛出/捕捉异常时，您已经在使用它们了。单子首先出现在计算机科学中，以支持命令式语言中关于副作用的数学推理，如<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>。</p><p id="d5c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他研究人员正在设计只有纯函数的实用语言。只使用纯函数会使程序更加冗长，更难阅读。单子被用作一种实用的<a class="ae jp" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>，用于将有效果的程序转换成纯粹的程序。这里引用了最好的单子教程之一——Philip Wadler(1995)的《函数式编程单子》:</p><blockquote class="jq jr js"><p id="1a77" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">在模块化方面，显式数据流既是福也是祸。一方面，它是模块化的极致。所有输入和输出的数据都是显式的和可访问的，提供了最大的灵活性。另一方面，它是模块化的最低点。算法的本质可能被埋没在将数据从创建点传送到使用点所需的管道中。</p></blockquote><p id="20bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">听起来是不是很耳熟？例如React组件的属性钻取和状态管理解决它的原因之一。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/0ed6a67c282f242a7e88d535397f2278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayIObIxS0WIBP-Gc-RAqKA.png"/></div></div></figure><p id="4eaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原始抽象do-notation是一个将看起来像命令式的程序转换成抽象API调用的宏。API的具体实现可以构造一个可迭代的对象，或者一个承诺或者许多其他东西。这样，相同的语法(和相同的程序)可以在不同的上下文中重用。</p><p id="d777" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JavaScript有类似于do符号的语法扩展。它们是异步和/或生成器函数。与原始的do符号不同，它们被JavaScript编译器或一些transpiler(如再生器)转换成具体的API调用(<code class="eh kj kk kl km b">Promise#then</code>和Iterable构造函数)。这些具体函数几乎是抽象monad API的实例。</p><p id="e1ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">异步和生成器函数基于协同程序单子。可以转化成很多其他单子，但不是全部。JavaScript社区中有一个众所周知的事实——生成器函数可以代替异步函数。与标准异步函数不同，使用生成器语法编写的异步函数可以被取消。唯一的开销是需要调用一个包装函数，该函数将Iterable转换为Promise。</p><p id="4552" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多使用异步代码生成器的例子，所以我将用另一个例子来说明这个想法。这可能不太实际，但是我们可以把一个可变状态的生成器函数变成一个纯函数。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="22c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里函数<code class="eh kj kk kl km b">incr</code>和<code class="eh kj kk kl km b">incrX2</code>都有副作用。它们改变和读取共享数据。但是由此产生的函数<code class="eh kj kk kl km b">state(incrX2)</code>是纯粹的。函数<code class="eh kj kk kl km b">state</code>完成Iterable到状态monad的实际转换。</p><p id="4652" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是内联框架函数的外观:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="f636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该示例跳过了抽象API层。有很多选项来选择它的基础，但最简单的是两个功能:<code class="eh kj kk kl km b">of</code>和<code class="eh kj kk kl km b">chain</code>。它们都返回一元(有效)值。它是一个抽象的东西，可以是任何东西，取决于具体的API实现。对于抽象接口，这种类型的值是完全不透明的。</p><ul class=""><li id="e8c3" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated"><code class="eh kj kk kl km b">of</code> —接受任何值并返回有效值，它对参数的具体操作由接口实现定义</li><li id="807c" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><code class="eh kj kk kl km b">chain</code> —取某个有效值和一个将任何内容映射到另一个有效值的函数，返回某个其他有效值</li></ul><p id="cfc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果符合所谓的一元定律，函数的具体实现可以做任何事情。事实上，我选择的<code class="eh kj kk kl km b">chain</code>名称对于JavaScript库来说是典型的，但是有点误导。它建议一些具体的实现，链接的东西。但是，同样，这是一些抽象的东西，唯一的要求是单子定律的一致性。</p><p id="447d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">法律是这样的:</p><ul class=""><li id="aa3d" class="kp kq hu it b iu iv iy iz jc kr jg ks jk kt jo ku kv kw kx dt translated"><code class="eh kj kk kl km b">(f, x) =&gt; chain(of(x), f)</code>应该等于<code class="eh kj kk kl km b">(f, x) =&gt; f(x)</code></li><li id="8e24" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><code class="eh kj kk kl km b">m =&gt; chain(m, of)</code>应该等于<code class="eh kj kk kl km b">m</code></li><li id="d2e8" class="kp kq hu it b iu ky iy kz jc la jg lb jk lc jo ku kv kw kx dt translated"><code class="eh kj kk kl km b">(m, f, g) =&gt; chain(chain(m, f), g)</code>应该等于<code class="eh kj kk kl km b">(m, f, g) =&gt; chain(m, x =&gt; chain(f(x), g))</code></li></ul><p id="3322" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果定律成立，我们可以在do-notation中使用API，或者在为任何单子工作的一些抽象函数中使用API。</p><p id="3f58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们将Iterable转换成这个抽象接口。除了函数被抽象的调用所取代之外，它几乎与状态一样。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="bf5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于状态，有效值是一个函数，它采用某个原始状态并返回一对结果值和一个新的状态值。下面是使用抽象中间层的状态单子定义:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="50ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并承诺:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="e475" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一单子定律对承诺不起作用，但对实际用途来说很好。</p><p id="cdf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑到生成器对于承诺和迭代器来说已经足够了，有人可能想知道为什么我们需要异步生成器。事实上，结合普通生成器的两种效果来转换monad是非常容易的。但是，不会有任何替代<code class="eh kj kk kl km b">for await-of</code>的说法。这是另一种遍历语法。</p><p id="ead5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">协程/Iterables不能定义转换为任何单子。例如，Observable是一个单子，但生成器不能用作它们的do符号。</p><p id="f4f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个有用的例子是非决定论。即返回几个值的计算。这可以用于将逻辑编程嵌入JavaScript。实现抽象接口很简单:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="6d76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">生成器语法不起作用，因为<code class="eh kj kk kl km b">fun</code>可能被调用多次。</p><p id="4d54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一些库用JavaScript定义了一些具体实现的抽象API，例如<a class="ae jp" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank">幻想世界</a>。也有一些do notation as generators实现试图通过重启和重放开始示例的迭代器来模拟多个简历- <a class="ae jp" href="https://github.com/pelotom/burrido" rel="noopener ugc nofollow" target="_blank"> burrido </a>。这种方法不安全，效率也不高。</p><p id="b64c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我现在正在开发一个基于babel插件的do-syntax实现，适用于任何Monad — <a class="ae jp" href="https://github.com/awto/effectfuljs" rel="noopener ugc nofollow" target="_blank"> EffectfulJS </a>。它提供了许多选项，如持久状态、具体实现内联、隐式并行化。这可能会大大简化JavaScript代码。我很快会写更多关于它的内容，敬请关注！</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ld ko l"/></div></figure></div></div>    
</body>
</html>