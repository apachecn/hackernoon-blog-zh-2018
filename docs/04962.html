<html>
<head>
<title>M.E.R.N stack application using Passport for authentication.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">米（meter的缩写））使用Passport进行身份验证的E.R.N堆栈应用程序。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/m-e-r-n-stack-application-using-passport-for-authentication-920b1140a134?source=collection_archive---------0-----------------------#2018-06-12">https://medium.com/hackernoon/m-e-r-n-stack-application-using-passport-for-authentication-920b1140a134?source=collection_archive---------0-----------------------#2018-06-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="65cc" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在本教程中，我们将使用Node.js服务器中的Passport身份验证机制，在React应用程序中集成用于注册或登录目的的Google sign-in。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/7ae8f2c5bc1cc869c6377a3ba3f0e024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XB8rYOUoHDLtQHz470IDQw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/photos/Yhc7YGZlz3g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steve Halama</a> on <a class="ae jz" href="https://unsplash.com/search/photos/authentication?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8f31" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在当今世界，用户更喜欢在他们访问的每个网站上使用他们的任何社交帐户进行单点登录，而不是将他们的凭据再次交给另一个人。</p><p id="5044" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因此，现在有必要集成单点登录以使事情变得更容易，并且只允许经过验证的用户使用您的应用程序，这对用户和应用程序所有者都有利。</p><p id="041d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们直接进入开发阶段。</p><h1 id="1f2e" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">使用Google登录按钮创建React应用程序</h1><h2 id="527d" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated"><strong class="ak">步骤1 </strong>:让我们使用<a class="ae jz" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建一个基本的react应用程序</h2><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="eded" class="lo kx hu md b fv mh mi l mj mk">$ npx create-react-app my-app<br/>$ cd my-app<br/>$ npm start</span></pre><h2 id="ba46" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated"><strong class="ak">第二步</strong>:在根目录下的App.js中，添加以下HTML代码，在render()函数中的P标签后创建一个按钮。</h2><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="b11c" class="lo kx hu md b fv mh mi l mj mk">&lt;a href="/auth/google" class="button"&gt;<br/>          &lt;div&gt;<br/>            &lt;span class="svgIcon t-popup-svg"&gt;<br/>              &lt;svg<br/>                class="svgIcon-use"<br/>                width="25"<br/>                height="37"<br/>                viewBox="0 0 25 25"<br/>              &gt;<br/>                &lt;g fill="none" fill-rule="evenodd"&gt;<br/>                  &lt;path<br/>                    d="M20.66 12.693c0-.603-.054-1.182-.155-1.738H12.5v3.287h4.575a3.91 3.91 0 0 1-1.697 2.566v2.133h2.747c1.608-1.48 2.535-3.65 2.535-6.24z"<br/>                    fill="#4285F4"<br/>                  /&gt;<br/>                  &lt;path<br/>                    d="M12.5 21c2.295 0 4.22-.76 5.625-2.06l-2.747-2.132c-.76.51-1.734.81-2.878.81-2.214 0-4.088-1.494-4.756-3.503h-2.84v2.202A8.498 8.498 0 0 0 12.5 21z"<br/>                    fill="#34A853"<br/>                  /&gt;<br/>                  &lt;path<br/>                    d="M7.744 14.115c-.17-.51-.267-1.055-.267-1.615s.097-1.105.267-1.615V8.683h-2.84A8.488 8.488 0 0 0 4 12.5c0 1.372.328 2.67.904 3.817l2.84-2.202z"<br/>                    fill="#FBBC05"<br/>                  /&gt;<br/>                  &lt;path<br/>                    d="M12.5 7.38c1.248 0 2.368.43 3.25 1.272l2.437-2.438C16.715 4.842 14.79 4 12.5 4a8.497 8.497 0 0 0-7.596 4.683l2.84 2.202c.668-2.01 2.542-3.504 4.756-3.504z"<br/>                    fill="#EA4335"<br/>                  /&gt;<br/>                &lt;/g&gt;<br/>              &lt;/svg&gt;<br/>       &lt;/span&gt;<br/>     &lt;span class="button-label"&gt;Sign in with Google&lt;/span&gt;<br/>   &lt;/div&gt;<br/>&lt;/a&gt;</span></pre><h2 id="063f" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated"><strong class="ak">第三步</strong>:在根目录下的index.css文件中添加以下CSS来装扮你的按钮。</h2><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="15f8" class="lo kx hu md b fv mh mi l mj mk">a {<br/> -webkit-tap-highlight-color: transparent;<br/> text-decoration: none;<br/>}</span><span id="7c2a" class="lo kx hu md b fv ml mi l mj mk">.button {<br/> display: inline-block;<br/> max-width: 300px;<br/> margin-top: 50px;<br/> border: 0;<br/> padding: 0 18px;<br/> text-align: left;<br/> width: 100%;<br/> height: 37px;<br/> border-radius: 4px;<br/> -webkit-font-smoothing: antialiased;<br/> -moz-osx-font-smoothing: grayscale;<br/> -moz-font-feature-settings: "liga" on;<br/> color: rgba(0, 0, 0, 0.84) !important;<br/> fill: rgba(0, 0, 0, 0.84) !important;<br/> box-shadow: 0 1px 7px rgba(0, 0, 0, 0.05);<br/> font: inherit;<br/> outline: none;<br/>}</span><span id="24c4" class="lo kx hu md b fv ml mi l mj mk">.button .svgIcon {<br/> vertical-align: middle;<br/> fill: rgba(0, 0, 0, 0.54);<br/> padding-right: 4px;<br/> height: 37px;<br/> display: inline-block;<br/>}</span></pre><p id="51c2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">就是这样。您已经创建了一个带有链接的按钮，单击该按钮可以导航到Google认证页面(检查<a>标签中的href属性)。</a></p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="2be8" class="lo kx hu md b fv mh mi l mj mk">/auth/google </span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mm"><img src="../Images/8699ab011bd899251baa6d295024d730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pP1jV5-3o6usjkHA9ndWxw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">React app with Google sign-in button.</figcaption></figure><p id="b9ae" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">注意:现在，我们的客户端运行在3000端口。</strong></p><p id="5a64" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们将在本教程的后面处理路线。所以我请求您在您的应用程序中安装以下模块。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="4768" class="lo kx hu md b fv mh mi l mj mk">$ npm i --save react-router-dom</span></pre><p id="b1e7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">并用下面的代码替换index.js文件中的代码。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="8ef4" class="lo kx hu md b fv mh mi l mj mk">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import "./index.css";<br/>import App from "./App";<br/>import registerServiceWorker from "./registerServiceWorker";<br/>import { Route, Switch } from "react-router-dom";<br/>import { BrowserRouter } from "react-router-dom";</span><span id="19ef" class="lo kx hu md b fv ml mi l mj mk">ReactDOM.render(<br/> &lt;BrowserRouter&gt;<br/>  &lt;Switch&gt;<br/>   &lt;Route path="/" component={App} /&gt;<br/>  &lt;/Switch&gt;<br/> &lt;/BrowserRouter&gt;,<br/> document.getElementById("root")<br/>);<br/>registerServiceWorker();</span></pre><p id="75e0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们只是从“react-router-dom”中导入路由、交换机和BrowserRouter，并替换渲染函数中的一些代码，以在我们的应用程序中支持路由。</p><p id="3e7b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们将从URL访问查询参数，并在本教程的后面替换它。只有当您将应用程序配置为支持路由器时，您才能访问路由器属性(react中的属性)。要了解有关路由器及其配置的更多信息，请浏览此<a class="ae jz" rel="noopener" href="/@pshrmn/a-simple-react-router-v4-tutorial-7f23ff27adf">链接</a>。</p><h1 id="c9c6" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">设置Node.js服务器并配置Passport</h1><p id="85c1" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">我希望现在你能看到下面的按钮屏幕。现在让我们创建一个Node.js服务器并实现服务器端逻辑。</p><p id="8d8b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我将创建一个单独的Node.js服务器，并在另一个端口运行，因为在不同的代码库中维护服务器和客户端将更容易维护，而且据我所知，它们彼此不依赖。</p><h2 id="b725" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated"><strong class="ak">第四步:创建Node.js服务器，安装Passport模块。</strong></h2><p id="459a" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">如果您不知道要创建Node.js服务器，那么您不必担心。我已经创建了一个教程，介绍如何从零开始创建一个Node.js服务器。请浏览下面的链接，按照主题<strong class="kc hv">创建一个示例Node.js服务器</strong>，如果您没有服务器，请在继续之前创建一个。</p><div class="ms mt fm fo mu mv"><a rel="noopener follow" target="_blank" href="/full-stack-web-development-from-scratch-to/deploy-your-node-js-app-in-production-and-use-bitbucket-to-automate-your-deployment-50b07b18914c"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">在生产中部署Node.js应用程序，并使用BitBucket来自动化部署。</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">在本教程中，我们将创建一个示例Node.js服务器，将其推送到BitBucket并使用PM2，我们将自动…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">medium.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jt mv"/></div></div></a></div><p id="898c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因此，我们现在有一个服务器，但我们的服务器中没有护照模块。导航到你的服务器，安装<a class="ae jz" href="https://www.npmjs.com/package/passport" rel="noopener ugc nofollow" target="_blank"> passport </a>和<a class="ae jz" href="https://www.npmjs.com/package/passport-google-oauth" rel="noopener ugc nofollow" target="_blank"> passport-google-oauth </a></p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="d25c" class="lo kx hu md b fv mh mi l mj mk">$ cd my-server/<br/>$ npm i passport --save<br/>$ npm i passport-google-oauth --save</span></pre><p id="ba53" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们已经安装了所需的模块。让我们通过在app.js文件中添加下面两行来利用它。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="8a17" class="lo kx hu md b fv mh mi l mj mk">var passport = require(“passport”); // at header</span><span id="bcbf" class="lo kx hu md b fv ml mi l mj mk">app.use(passport.initialize()); // after line no.20 (express.static)<br/>require("./config/passport");</span></pre><p id="731d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">将默认服务器端口从3000更改为4500，以避免服务器和客户端之间的冲突。转到bin/www文件，将3000更改为4500，并通过发出以下命令启动您的应用程序。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="90d2" class="lo kx hu md b fv mh mi l mj mk">$ npm start</span></pre><p id="ef7f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">注意:现在，我们的服务器运行在端口4500上。</strong></p><h2 id="c96a" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated">步骤5:让我们创建一个passport.js文件来处理我们的passport认证机制。</h2><p id="2eea" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">在根目录下创建一个名为<em class="nk"> config </em>的文件夹，并在其中创建一个名为<em class="nk"> passport.js </em>的文件，其中包含以下内容。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="e268" class="lo kx hu md b fv mh mi l mj mk">var passport = require("passport");<br/>var GoogleStrategy = require("passport-google-oauth").OAuth2Strategy;</span><span id="5665" class="lo kx hu md b fv ml mi l mj mk">passport.serializeUser(function(user, done) {<br/> done(null, user);<br/>});</span><span id="a0d5" class="lo kx hu md b fv ml mi l mj mk">passport.deserializeUser(function(user, done) {<br/> done(null, user);<br/>});</span><span id="9452" class="lo kx hu md b fv ml mi l mj mk">passport.use(<br/> new GoogleStrategy(<br/>  {<br/>   clientID: "GOOGLE_CLIENT_ID",<br/>   clientSecret: "GOOGLE_CLIENT_SECRET",<br/>   callbackURL: "http://localhost:4500/auth/google/callback"<br/>  },<br/>  function(accessToken, refreshToken, profile, done) {<br/>   var userData = {<br/>    email: profile.emails[0].value,<br/>    name: profile.displayName,<br/>    token: accessToken<br/>   };<br/>   done(null, userData);<br/>  }<br/> )<br/>);</span></pre><p id="a97c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如您所见，我们需要GOOGLE _ CLIENT _ ID &amp; GOOGLE _ CLIENT _ SECRET用于您的应用程序。你可以在https://console.developers.google.com/<a class="ae jz" href="https://console.developers.google.com/" rel="noopener ugc nofollow" target="_blank">买到</a></p><h2 id="208e" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated">步骤6:在谷歌开发者仪表板中配置你的应用</h2><p id="28ef" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">导航到<a class="ae jz" href="https://console.developers.google.com/" rel="noopener ugc nofollow" target="_blank"> Google开发者控制台</a>并创建您的应用程序。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nl"><img src="../Images/d5af84ff996756b8cae80c1f0e918d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wugZYVVlzeq2RSg5KJQ-Mw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Credentials page in Google Developers Console.</figcaption></figure><p id="b49c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在上图页面中，点击<em class="nk">创建凭证</em>，选择<em class="nk"> OAuth客户端ID。</em></p><p id="bad6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在下一个屏幕中，选择应用程序类型作为<em class="nk"> Web应用程序</em>，并命名您的应用程序。</p><p id="c525" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在限制部分，您需要提供您的应用程序URL和重定向URL，以防止其他人滥用您的应用程序。</p><p id="aba3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在<em class="nk">授权JavaScript源</em>中提供您的应用URL。您可以在此添加多个条目。</p><blockquote class="nm nn no"><p id="69fd" class="ka kb nk kc b kd ke iv kf kg kh iy ki np kk kl km nq ko kp kq nr ks kt ku kv hn dt translated">http://本地主机:4500</p></blockquote><p id="5f0b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因为我们的服务器运行在4500端口。(允许服务器验证)</p><p id="75a0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在<em class="nk">授权重定向URIs </em>中提供您的重定向URI。</p><blockquote class="nm nn no"><p id="5d3e" class="ka kb nk kc b kd ke iv kf kg kh iy ki np kk kl km nq ko kp kq nr ks kt ku kv hn dt translated">http://localhost:4500/auth/Google/callback</p></blockquote><p id="d6b2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因为我们需要在谷歌认证完成后重定向回我们的服务器。(在我们的<em class="nk"> passport.js </em>文件中也提到过这个网址，看看吧)</p><p id="d05d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">保存并获取您的GOOGLE _ CLIENT _ ID &amp; GOOGLE _ CLIENT _ SECRET密钥，然后将其粘贴到passport.js文件中。</p><p id="afb4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">最后，点击<em class="nk">凭证</em>上面的<em class="nk">库</em>，搜索Google+ API。选择并启用以获取用户的Google+个人资料。</p><h2 id="dfba" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated">步骤7:创建处理Google身份验证的路由</h2><p id="d1a7" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">让我们创建一个名为/auth/google的API调用，我们的客户端在单击<strong class="kc hv"> Sing up with Google </strong>按钮后调用它。</p><p id="ccf6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">转到<em class="nk"> routes </em>文件夹中的<em class="nk"> index.js </em>，在标题处添加下面一行。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="8c8d" class="lo kx hu md b fv mh mi l mj mk">var passport = require(“passport”);</span></pre><p id="a340" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">以及缺省get请求之后的行。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="46b3" class="lo kx hu md b fv mh mi l mj mk">/* GET Google Authentication API. */<br/>router.get(<br/>    "/auth/google",<br/>    passport.authenticate("google", { scope: ["profile", "email"] })<br/>);</span><span id="0f86" class="lo kx hu md b fv ml mi l mj mk">router.get(<br/>    "/auth/google/callback",<br/>    passport.authenticate("google", { failureRedirect: "/", session: false }),<br/>    function(req, res) {<br/>        var token = req.user.token;<br/>        res.redirect("<a class="ae jz" href="http://localhost:3000?token=" rel="noopener ugc nofollow" target="_blank">http://localhost:3000?token=</a>" + token);<br/>    }<br/>);</span></pre><p id="754d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">就是这样。您已经配置了服务器。</p><p id="e348" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我将解释在上面的行中发生了什么。</p><p id="b31f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">第一个路由<em class="nk"> /auth/google </em>从客户端获取请求，使用passport向google认证。我们在范围数组中提供“个人资料”&amp;“电子邮件”，以获取用户的个人资料和电子邮件地址。你可以在<a class="ae jz" href="https://developers.google.com/identity/protocols/googlescopes" rel="noopener ugc nofollow" target="_blank"> Google OAuth 2.0 Scopes </a>查看可用范围列表。</p><p id="cfc3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">第二个路由是/auth/google/callback，它在用户完成google身份验证后调用。当您检查passport.js文件时，我们正在创建一个带有必填字段的对象，并将它发送回回调函数。</p><p id="9099" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在routes/index.js文件中，在/auth/google/callback route的回调函数中，我们通过<em class="nk"> req.user </em>访问这个对象。</p><p id="6af4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">req.user如何保存该值？</p><p id="3f1c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因为我们在一个<em class="nk"> passport.js </em>文件中使用了<em class="nk"> serializeUser </em>和<em class="nk"> deserializeUser </em>函数，该文件保存了从Google收到的响应的<em class="nk"> user </em>值，所以我们可以通过相同的。</p><p id="33ee" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">最后，我们重定向回我们的客户端应用程序，它运行在端口3000上，查询参数中有一个令牌。</p><h2 id="9651" class="lo kx hu bd ky lp lq lr lc ls lt lu lg kj lv lw li kn lx ly lk kr lz ma lm mb dt translated">步骤8:接收令牌并验证用户</h2><p id="17f8" class="pw-post-body-paragraph ka kb hu kc b kd mn iv kf kg mo iy ki kj mp kl km kn mq kp kq kr mr kt ku kv hn dt translated">现在让我们接收这个令牌并对用户进行身份验证。</p><p id="1d8c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">回到我们的客户端应用程序。安装下面的<a class="ae jz" href="https://www.npmjs.com/package/query-string" rel="noopener ugc nofollow" target="_blank">模块</a>来解析我们的react应用程序中的查询字符串，从根目录使用下面的命令。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="aa15" class="lo kx hu md b fv mh mi l mj mk">npm i query-string --save</span></pre><p id="2b0b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在我们的App.js文件的头部导入这个模块。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="ad61" class="lo kx hu md b fv mh mi l mj mk">import queryString from "query-string";</span></pre><p id="8f08" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在，让我们创建一个名为<strong class="kc hv"> <em class="nk">的组件生命周期方法。</em> </strong></p><p id="0229" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当我们的应用程序启动时，这个方法将被调用。查看<a class="ae jz" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">反应生命周期组件</a>了解更多信息。</p><p id="2612" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在render方法之前，在App.js中插入以下代码。</p><pre class="jk jl jm jn fq mc md me mf aw mg dt"><span id="a8a3" class="lo kx hu md b fv mh mi l mj mk">componentWillMount() {<br/>    var query = queryString.parse(this.props.location.search);<br/>    if (query.token) {<br/>      window.localStorage.setItem("jwt", query.token);<br/>      this.props.history.push("/");<br/>   }<br/>}<br/>render(){<br/>   ...<br/>}</span></pre><p id="1c52" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">该方法将在初始化期间从URL获取查询参数标记，并将其设置在本地存储中。</p><p id="618a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">最后，替换URL中的标记。</p><p id="4e8f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在你有了一个令牌，代表访问者是一个经过验证的用户来使用你的应用程序。从现在开始，在对API服务器的每个请求中都使用这个令牌。</p><p id="89c7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">希望这将有助于在您的MERN堆栈应用程序中实现基本认证系统。</p><p id="2f72" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">客户端App:<a class="ae jz" href="https://github.com/BalasubramaniM/react-nodejs-passport-app" rel="noopener ugc nofollow" target="_blank">https://github.com/BalasubramaniM/react-nodejs-passport-app</a></p><p id="4949" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">服务器App:<a class="ae jz" href="https://github.com/BalasubramaniM/react-nodejs-passport-server" rel="noopener ugc nofollow" target="_blank">https://github . com/BalasubramaniM/react-nodejs-passport-server</a></p><p id="90d7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">谢谢你。</p></div></div>    
</body>
</html>