<html>
<head>
<title>A Selfish Mining Double Spending Attack Simulator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个自私的挖掘双重花费攻击模拟器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-selfish-mining-double-spending-attack-simulator-fda1af38794b?source=collection_archive---------22-----------------------#2018-06-12">https://medium.com/hackernoon/a-selfish-mining-double-spending-attack-simulator-fda1af38794b?source=collection_archive---------22-----------------------#2018-06-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="22a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从命名开始——坦白地说，我不喜欢自私采矿这个名字。所有的区块链矿业都是自私的，都是为了创收。对所谓“自私采矿”的正确和不言自明的解释应该是“<a class="ae jp" href="https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf" rel="noopener ugc nofollow" target="_blank">秘密采矿</a>”。</p><p id="5ebb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信<a class="ae jp" href="https://arxiv.org/pdf/1507.06183.pdf" rel="noopener ugc nofollow" target="_blank">阿维夫·佐哈尔</a>让人们注意到了这样一个事实:使用隐形采矿可以产生双倍的支出攻击。基本上你要做的就是在主链之外继续采矿。由于区块链的规则是最长的有效链被视为分类账，如果你的链恰好比常规共识链长，那么那里的交易将被接受，而不是全球链上的交易。假设你在网络中拥有25%的采矿能力，它可能在大约4096 10分钟的纪元内- &gt;大约280天你将拥有这样的机会，你将领先主链6个街区。在这种情况下，你可以安排转移大量比特币来换取美元。然后，按照惯例等待6个时期，交易将被视为已接受。然后，你从帽子里拉出兔子，提交你的隐形链并覆盖主链，废弃之前完成的比特币转移。你带着你的美元逃跑，在危地马拉度过余生，原因不明。</p><p id="4ba1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是你要多久才能完成这个快速致富的计划呢？</p><p id="e5d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我在Github上创建了一个计算器供您使用</p><div class="jq jr fm fo js jt"><a href="https://github.com/yotam-gafni/selfish_mining_calculator" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hv fv z el jy eo ep jz er et ht dt translated">yotam-GAF ni/自私_采矿_计算器</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">在GitHub上创建一个帐户，为自私_采矿_计算器开发做贡献。</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">github.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh ki jt"/></div></div></a></div><p id="26df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有趣的部分是解释这个计算背后的数学。这里你实际上有一种<a class="ae jp" href="https://en.wikipedia.org/wiki/Random_walk" rel="noopener ugc nofollow" target="_blank">随机漫步</a>。在概率p下，p是你在总开采量中的份额，你设法在世界上其他人之前到达一个区块。在概率为1-p的情况下，他们会比你先做。然后，如果你达到6，也就是说你比其他人多前进了6个街区，你就赢了。这类似于<a class="ae jp" href="https://en.wikipedia.org/wiki/Gambler%27s_ruin" rel="noopener ugc nofollow" target="_blank">赌徒的破产问题</a>——一个资源X有限的赌徒需要多久才能完成他对赌场的资源赌博。但是有一些不同。首先也是最重要的是，每当世界上的其他人在你身上获得优势时，你可以重置他们的链条。没有伤害，你会重新开始。所以随机漫步永远不会进入轴的负侧。鉴于此，你不能直接使用随机游走公式。</p><p id="b24a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，你建立了一个递归公式，在n次随机行走后，距离原点k步的概率。我们把自己限制在k &lt;=6. The formulas look like that:</p><p id="65f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">F(n,k) = pF(n-1,k-1) + (1-p)F(n-1,k+1)</p><p id="5376" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">F(n,0)= (1-p)F(n-1,0) + (1-p)F(n-1,1)</p><p id="819f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">There are other edge cases such as F(1,2) is obviously 0 — You can’t get to a distance of 2 from the origin with only one step.</p><p id="62f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Our ultimate goal would be to represent F(n,k) not as a recursive function depending on other values of F but as an explicit formula in terms of p.</p><p id="5388" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Sadly enough, this is hard math.</p><p id="4858" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">But there’s a more straight-forward solution using <a class="ae jp" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态编程</a>上。与其递归执行公式，导致指数复杂度计算，不如看看F创建的筛子，从(n，k)对的较低值向上。这就变成了多项式复杂度的运算。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="fe ff kj"><img src="../Images/f194dbade3b352da26f82bce83fa3c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0FIZ4bSweoMgcOVkfHppQ.jpeg"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">By ways of Dynamic programming, you can calculate sieve values from lower n,k pairs upwards</figcaption></figure><p id="1943" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在Python中实现了这种筛选计算，以评估不同的p值在比特币挖掘时代产生攻击所需的时间。基本上我所做的是我有一个Numpy数组，代表p的系数，对于每一个n，k的组合。我归纳计算了n值增长时的F。出于记忆和简化的原因，我将k值限制为6，因此近似值为F(n，6) = pF(n-1，5) + pF(n-1，6)，而不是扩展到更高的k值。这种近似值实际上降低了攻击成功的概率，因此您可能会期望更高的历元估计值。我让代码可以扩展到更高的k值，比如12。</p><p id="5819" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您实现它时，很快就会遇到一些问题:</p><ul class=""><li id="f9df" class="ky kz hu it b iu iv iy iz jc la jg lb jk lc jo ld le lf lg dt translated">一旦你有了筛子，你如何找到概率足够好的点呢？为此，我使用了这个不错的通用二分搜索法摘录，我发现<a class="ae jp" href="https://gist.github.com/Shnatsel/e23fcd2fe4fbbd869581" rel="noopener ugc nofollow" target="_blank">在这里</a>。</li><li id="df6a" class="ky kz hu it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg dt translated">内存大小。F的系数是线性增长的，所以对于F(10000，k ),你已经有了10K系数，每个最大的浮点大小是16字节。对于筛子中的每个点来说，这是160KB，因此，如果筛子在该大小下大约有60K个点，这可以估计为高达1GB的RAM …这是一个很大的数字。我解决这个问题的方法是在筛子上加一个滑动窗。我计算了前200个n值。我检查概率是否足够好。如果是，我在当前窗口做一个二分搜索法。如果没有，我生成200个n值的下一个窗口。递归公式的好处是n的计算只取决于n-1个值。所以，你实际上不需要一次把所有东西都存在内存里。</li><li id="79b1" class="ky kz hu it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg dt translated">浮点问题——你很快就明白了。我只是使用了numpy的longdouble，这应该是最准确的可用float，而没有实现我自己版本的float，这样会很麻烦。</li></ul><p id="1657" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">享受模拟器吧！</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><a href="https://twitter.com/Suflaky"><div class="fe ff lm"><img src="../Images/d1c1cf5307a9b25a182f4069172834ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*fIUhg_Xlpr73p_N4keHoOQ.png"/></div></a></figure></div></div>    
</body>
</html>