<html>
<head>
<title>Build a MapReduce flow in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir中构建MapReduce流</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-mapreduce-flow-in-elixir-f97c317e457e?source=collection_archive---------2-----------------------#2018-06-13">https://medium.com/hackernoon/build-a-mapreduce-flow-in-elixir-f97c317e457e?source=collection_archive---------2-----------------------#2018-06-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7f71" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">给大象一些药剂</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f3146725f7687ca599af5bb5883c50cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fMmP7xfYV2b1icEr4WM4Cg.png"/></div></div></figure><p id="476c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">MapReduce是一种常见的大数据模式，用于同时分析数据集。本教程将向您介绍Elixir和Hadoop背后的原理。我们将在MapReduce中建立一个字数统计程序的Hello World的等价物。Map和Reduce也是函数式编程世界中常见的高阶函数。Map是一个函数，它将一个列表和一个匿名函数或lambda作为参数，将该函数应用于列表中的每个元素，并返回一个新列表，其中包含每个元素的lambda输出。Reduce是一个类似的函数，它在Elixir(一个累加器)中使用相同的参数和一个额外的参数，但是返回一个累加值而不是一个列表。Elixir是学习并发性的好语言，MapReduce既是一个有用的例子，也展示了Elixir的许多特性。</p><h2 id="e19f" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">MapReduce流程</h2><p id="43d8" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">MapReduce是数据流动和处理的管道。它可以被分解成大约5个步骤，对应于我们将在Elixir中编写的5个模块。我们的第一步是输入阅读器。它接收数据，将其分割成我们的Map流程可以读取的形式，并同时启动Map流程。我们的Map进程读取提供给它的数据，对每条数据运行一个函数，并向分区/比较进程输出一个键值对。分区进程从所有映射进程中累积键值对，比较这些键值对，并为每个唯一键生成Reduce进程。每个Reduce进程对每个值运行一个函数，将给定键的所有值相加，并将这些值发送到输出编写器。最后，输出编写器以您选择的格式生成数据。</p><h2 id="a50a" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">步骤0:设置</h2><p id="08dc" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">首先，确保您已经为当前系统安装了Elixir。说明可以在<a class="ae lr" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">这里找到</a>。从主站点<a class="ae lr" href="https://elixir-lang.org/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">这里</a>可以获得对该语言的精彩介绍，hexdocs.pm在这里提供了Elixir模块文档<a class="ae lr" href="https://hexdocs.pm/elixir/Kernel.html" rel="noopener ugc nofollow" target="_blank">。</a><a class="ae lr" href="https://learnxinyminutes.com/docs/elixir/" rel="noopener ugc nofollow" target="_blank"> Learnxiny </a>还提供了优秀的Elixir语法入门。本教程假设很少或没有使用过Elixir，但熟悉基本的编程概念和操作系统的命令行。这个项目的所有代码都可以在<a class="ae lr" href="https://github.com/torchhound/mapreduce" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="4f86" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">安装好Elixir后，使用<code class="eh ls lt lu lv b">mix new</code>创建一个新项目。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="d989" class="kr ks hu lv b fv ma mb l mc md">mix new mapreduce --module MapReduce</span></pre><p id="3053" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来进入你的<code class="eh ls lt lu lv b">mapreduce</code>目录，用<code class="eh ls lt lu lv b">def project do []</code>中的这一行编辑<code class="eh ls lt lu lv b">mix.ex</code>。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="0b6b" class="kr ks hu lv b fv ma mb l mc md">escript: [main_module: MapReduce]</span></pre><h2 id="b3e0" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">第一步:父进程</h2><p id="a6b9" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">一旦你有了一个新项目，在你的项目目录中导航到<code class="eh ls lt lu lv b">lib/</code>，打开<code class="eh ls lt lu lv b">mapreduce.ex</code>，它应该是由<code class="eh ls lt lu lv b">mix</code>自动生成的。首先删除文件中除<code class="eh ls lt lu lv b">defmodule MapReduce do </code>和<code class="eh ls lt lu lv b">end</code>以外的所有内容。让我们为稍后将要编写的模块添加几个导入到模块的顶部。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="5249" class="kr ks hu lv b fv ma mb l mc md">defmodule MapReduce do<br/>  require InputReader<br/>  require Partition</span></pre><p id="c325" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，让我们创建一个主函数，并将它的参数传递给几个函数。<a class="ae lr" href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" rel="noopener ugc nofollow" target="_blank"> Pipe </a>，<code class="eh ls lt lu lv b">|&gt;</code>，是一个操作符，其行为与bash的Pipe非常相似。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="58a4" class="kr ks hu lv b fv ma mb l mc md">def main(args) do<br/>  args |&gt; parse_args |&gt; pipeline<br/>end</span></pre><p id="1b0e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">之后，让我们编写一个私有函数(用<code class="eh ls lt lu lv b">defp</code>代替<code class="eh ls lt lu lv b">def</code>来表示)来解析我们的命令行参数。这里我们创建了一个tuple类型的变量，它包含了<code class="eh ls lt lu lv b">OptionParser.parse</code>的结果。我们的命令行参数是<code class="eh ls lt lu lv b">--file=example.txt</code>，因此我们相应地在解析器函数的参数中设置开关。我们只需要解析器的第一个输出，我们将从<code class="eh ls lt lu lv b">parse_args</code>返回，其他输出用下划线表示，表示我们不需要它们。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="7124" class="kr ks hu lv b fv ma mb l mc md">defp parse_args(args) do<br/>    {options, _, _} = OptionParser.parse(args,<br/>      switches: [file: :string]<br/>    )<br/>    options<br/>  end<br/>end</span></pre><p id="1c0b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们父流程的最后一部分是管道。第一个<code class="eh ls lt lu lv b">pipeline </code>函数是一个模式匹配案例，它检查一个空文件参数。下一个<code class="eh ls lt lu lv b">pipeline</code>函数启动一个分区进程，但只将进程id存储在一个变量中。我们使用<code class="eh ls lt lu lv b">elem</code>来给出通过启动我们的进程返回的元组的第二个元素，因为我们不需要atom，<code class="eh ls lt lu lv b">:ok</code>，第一个元素。然后，分区进程id和文件名被传递给我们将在下一步中编写的输入读取器。最后，我们使用一个递归函数<code class="eh ls lt lu lv b">forever</code>，在MapReduce流程的其余部分执行时保持父流程的活动。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="1c0a" class="kr ks hu lv b fv ma mb l mc md">defp pipeline([]) do<br/>    IO.puts "No file given"<br/>end</span><span id="9c1f" class="kr ks hu lv b fv me mb l mc md">defp pipeline(options) do<br/>    partition = elem(Partition.start_link, 1)<br/>    InputReader.reader("#{options[:file]}", partition)<br/>    forever()<br/>end</span><span id="bca1" class="kr ks hu lv b fv me mb l mc md">defp forever do<br/>    forever()<br/>end</span></pre><h2 id="851c" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">步骤2:输入阅读器</h2><p id="15dd" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">这个模块相当简单，它包含一个函数，该函数接受文件名和进程id。该函数将尝试打开一个文件，如果失败，将向STDERR发送一条消息。如果我们的文件成功打开，我们将在文件的每一行执行一个函数。我们使用正则表达式来解析文件中的行，并将它们作为列表返回。<code class="eh ls lt lu lv b">Enum.each</code>与map相同，除了它在成功完成时返回一个原子而不是一个列表。对于列表中的每一行，我们将使用行和分区进程id作为参数来映射进程。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="cc78" class="kr ks hu lv b fv ma mb l mc md">defmodule InputReader do<br/>  require Mapper</span><span id="c285" class="kr ks hu lv b fv me mb l mc md">def reader(file, partition) do<br/>    case File.read(file) do<br/>      {:ok, body}      -&gt; Enum.each(Regex.split( ~r/\r|\n|\r\n/, String.trim(body)), fn line -&gt; spawn(fn -&gt; Mapper.map(line, partition) end) end)<br/>      {:error, reason} -&gt; IO.puts :stderr, "File Error: #{reason}"<br/>    end<br/>  end<br/>end</span></pre><h2 id="7d77" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">第三步:映射器</h2><p id="c172" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">映射器模块很短，首先我们将当前映射进程的进程id发送给分区进程。这将使我们能够稍后在分区中检查我们的映射进程是否仍在运行。之后，我们将再次使用<code class="eh ls lt lu lv b">Enum.each</code>将列表中的单词发送到分区进程，该列表是通过基于空格字符拆分每行而生成的。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="1051" class="kr ks hu lv b fv ma mb l mc md">defmodule Mapper do<br/>  def map(line, partition) do<br/>    send(partition, {:process_put, self()})<br/>    Enum.each(String.split(line, " "), fn key -&gt; send(partition, {:value_put, key}) end)<br/>  end<br/>end</span></pre><h2 id="ee2f" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">第四步:分区</h2><p id="71c5" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">分区模块是我们将要创建的最复杂的模块。这里我们将使用<code class="eh ls lt lu lv b">Task</code>模块，而不仅仅是<code class="eh ls lt lu lv b">spawn</code>。我们使用<code class="eh ls lt lu lv b">start_link</code>而不是<code class="eh ls lt lu lv b">start</code>,因为我们希望当这个进程被终止时父进程也被终止。我们链接的进程依次是MapReduce、Partition和OutputWriter。OutputWriter将在退出自己的进程之前检查所有Reduce进程是否都已完成。这将退出所有链接的进程，一直回到父进程。我们在<code class="eh ls lt lu lv b">start_link</code>中使用一个lambda来启动一个递归函数，该函数以2个列表作为参数。请注意，end是关闭所有lambdas所必需的。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="4849" class="kr ks hu lv b fv ma mb l mc md">defmodule Partition do<br/>  require Reducer<br/>  require OutputWriter</span><span id="aa90" class="kr ks hu lv b fv me mb l mc md">  def start_link do<br/>    Task.start_link(fn -&gt; loop([], []) end)<br/>  end<br/>end</span></pre><p id="a1fd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来我们将编写我们的递归<code class="eh ls lt lu lv b">loop</code>函数。这将首先检查由我们的Map进程发送的邮件的邮箱长度。如果它已经处理了所有的消息，它将启动一个检查，看看我们是否应该启动我们的Reduce进程。我们使用<code class="eh ls lt lu lv b">Keyword.delete</code>来删除混入键值对中的所有null或空白字符。注意使用了一个<a class="ae lr" href="https://elixir-lang.org/getting-started/sigils.html" rel="noopener ugc nofollow" target="_blank">符号</a>，<code class="eh ls lt lu lv b">~s(\s)</code>，来表示一个空白字符。接下来，我们有一些模式匹配代码，用于检查所有接收到的消息中的特定元组。如果我们收到atom <code class="eh ls lt lu lv b">:processor_put</code>，我们将把调用者映射进程的进程id附加到递归<code class="eh ls lt lu lv b">loop</code>调用中的进程列表中。如果我们收到的是atom <code class="eh ls lt lu lv b">:value_put</code>，我们将添加一个<a class="ae lr" href="https://hexdocs.pm/elixir/Keyword.html" rel="noopener ugc nofollow" target="_blank">关键字</a>，其中包含Map发送给我们的关键字和单词计数的值1。任何其他消息都会产生错误。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="bdde" class="kr ks hu lv b fv ma mb l mc md">defp loop(processes, values) do<br/>  mailbox_length = elem(Process.info(self(), :message_queue_len), 1)<br/>  if (mailbox_length == 0), do: (<br/>    mapper_check(processes, Keyword.delete(Keyword.delete(values, String.to_atom(~s(\s))), String.to_atom("")))<br/>  )<br/>  receive do<br/>    {:process_put, caller} -&gt;<br/>      loop([caller | processes], values)<br/>    {:value_put, key} -&gt;<br/>      loop(processes, [{String.to_atom(key), 1} | values])<br/>    error -&gt; IO.puts :stderr, "Partition Error: #{error}"<br/>  end<br/>end</span></pre><p id="cfe7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后一块隔板是<code class="eh ls lt lu lv b">mapper_check</code>。该函数检查是否所有的Map进程都是死的，如果是，则为每个唯一的单词启动Reduce进程。首先，我们使用<code class="eh ls lt lu lv b">Enum.filter</code>返回一个列表<code class="eh ls lt lu lv b">check</code>，其中包含所有仍在运行的进程。然后我们创建一个列表，包含每个唯一的关键字/单词。如果我们有一个非零数量的键，并且没有映射进程是活动的，那么我们<code class="eh ls lt lu lv b">start_link</code>输出Writer并将其进程id传递给我们产生的每个Reduce进程。之后，我们在unique上使用<code class="eh ls lt lu lv b">Enum.each</code>并使用<code class="eh ls lt lu lv b">Keyword.take</code>提取每个unique的每个实例，然后生成一个包含所有这些实例的Reduce进程。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="dcfb" class="kr ks hu lv b fv ma mb l mc md">defp mapper_check(processes, values) do<br/>    check = Enum.filter(processes, fn process -&gt; Process.alive?(process) == true end)<br/>    uniques = Enum.uniq(Keyword.keys(values))<br/>    if (length(check) == 0 &amp;&amp; length(uniques) != 0), do: (<br/>      output_writer = elem(OutputWriter.start_link, 1) <br/>      Enum.each(uniques, fn unique -&gt; spawn(fn -&gt; Reducer.reduce(Keyword.to_list(Keyword.take(values, [unique])), output_writer) end) end)<br/>    )<br/>  end<br/>end</span></pre><h2 id="5ce0" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">第五步:减肥药</h2><p id="2de5" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">倒数第二个模块是我们的Reduce过程。这需要一个元组列表(键值对)和输出编写器的进程id。与Map类似，我们向输出编写器发送Reduce的进程id来跟踪它的状态。然后，我们检查以确保<code class="eh ls lt lu lv b">tuples</code>不为空，并且案例模式匹配。如果<code class="eh ls lt lu lv b">tuples</code>不为空，我们将向输出编写器发送一个字符串。这个字符串可能看起来有点奇怪，但那是因为我们使用了Elixir的字符串插值语法<code class="eh ls lt lu lv b">"#{}"</code>，来放置两个由空格分隔的表达式。让我们分解发送给输出编写器的字符串中的两个表达式。首先，我们使用之前见过的<code class="eh ls lt lu lv b">elem</code>，使用<code class="eh ls lt lu lv b">hd</code>或head从列表中的第一个元组获取密钥。列表中的所有键应该是相同的，所以我们使用哪一个并不重要。其次，我们使用<code class="eh ls lt lu lv b">Enum.reduce</code>将来自键值元组的所有值相加，使用累加器作为<code class="eh ls lt lu lv b">reduce</code>中的第二个参数和<code class="eh ls lt lu lv b">reduce</code>中的lambda。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="8251" class="kr ks hu lv b fv ma mb l mc md">defmodule Reducer do<br/>  def reduce(tuples, output_writer) do<br/>    send(output_writer, {:process_put, self()})<br/>    case tuples do<br/>      [] -&gt;  IO.puts :stderr, "Empty List"<br/>      tuples -&gt;<br/>        send(output_writer, {:value_put, "#{elem(hd(tuples), 0)} #{Enum.reduce(tuples, 0, fn ({_, v}, total) -&gt; v + total end)}"})<br/>    end<br/>  end<br/>end</span></pre><h2 id="473a" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">步骤6:输出编写器</h2><p id="c2ed" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">这个模块应该看起来非常熟悉，因为它是Partition的一个稍微修改的版本。唯一的区别是在<code class="eh ls lt lu lv b">reducer_check</code>中，我们打开一个文件，将每个单词及其计数写入STDOUT和我们刚刚打开的文件，然后关闭文件和整个进程链，一直返回到我们的父进程。一个重要的细节是使用<code class="eh ls lt lu lv b">Path.join</code>为我们提供跨不同操作系统的一致文件路径。另一个是使用<code class="eh ls lt lu lv b">&lt;&gt;</code>，它是Elixir的字符串连接操作符。</p><pre class="jk jl jm jn fq lw lv lx ly aw lz dt"><span id="30be" class="kr ks hu lv b fv ma mb l mc md">defmodule OutputWriter do<br/>  def start_link do<br/>    Task.start_link(fn -&gt; loop([], []) end)<br/>  end</span><span id="244f" class="kr ks hu lv b fv me mb l mc md">defp loop(processes, values) do<br/>    mailbox_length = elem(Process.info(self(), :message_queue_len), 1)<br/>    if (mailbox_length == 0), do: (<br/>      reducer_check(processes, values)<br/>    )<br/>    receive do<br/>      {:process_put, caller} -&gt;<br/>        loop([caller | processes], values)<br/>      {:value_put, value} -&gt;<br/>        loop(processes, [value | values])<br/>    end<br/>  end</span><span id="97d4" class="kr ks hu lv b fv me mb l mc md">defp reducer_check(processes, values) do<br/>    check = Enum.filter(processes, fn process -&gt; Process.alive?(process) == true end)<br/>    if (length(check) == 0 &amp;&amp; length(processes) != 0), do: (<br/>      {:ok, file} = File.open(Path.join("test", "output.txt"), [:write])<br/>      for value &lt;- values do<br/>        IO.puts value<br/>        IO.write(file, value &lt;&gt; ~s(\n))<br/>      end    <br/>      File.close(file)<br/>      Process.exit(self(), :kill)<br/>    )<br/>  end<br/>end</span></pre><h2 id="cadb" class="kr ks hu bd kt ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll dt translated">测试和总结</h2><p id="589c" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">恭喜你！您已经成功地编写了一个小而不平凡的灵药程序，它能做一些有用的事情。让我们做一些测试，然后我们就完成了。首先创建一个名为test的目录和一个包含随机文本的文件。我用<a class="ae lr" href="http://www.randomtextgenerator.com/" rel="noopener ugc nofollow" target="_blank">randomtextgenerator.com</a>给我的文件。接下来用<code class="eh ls lt lu lv b">mix escript.build</code>编译您的项目。最后使用<code class="eh ls lt lu lv b">./mapreduce --file=test/input.txt</code>运行您的代码。您应该会在命令行上看到数百行文本，如下所示。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/6bd46b794b0b2e98d971dc5d30010594.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4dya8NkCMKWeDEb2wF5iqQ.png"/></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek">Notice the exit message at the bottom.</figcaption></figure><p id="e53f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后打开您的<code class="eh ls lt lu lv b">test</code>目录，应该会有一个新的文件名<code class="eh ls lt lu lv b">output.txt</code>，其输出与您的命令行相同，只是退出消息不会在最后。</p><p id="380d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">感谢阅读，如果这篇教程对你有帮助，请留下一个或几个掌声！</p><p id="e7e6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="mk"> Joe Cieslik是Whiteboard Dynamics的CEO，这是一个专门从事函数式编程和Android的全栈开发团队。您可以在</em></strong><a class="ae lr" href="https://whiteboarddynamics.co/" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv"><em class="mk">【whiteboarddynamics.co】</em></strong></a><strong class="jx hv"><em class="mk">了解更多关于我们的信息、我们如何帮助您以及我们过去的项目。</em>T13】</strong></p></div></div>    
</body>
</html>