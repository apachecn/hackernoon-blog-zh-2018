<html>
<head>
<title>Railway oriented development with Erlang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Erlang进行面向铁路的开发</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/railway-oriented-development-with-erlang-46ea6db4a795?source=collection_archive---------10-----------------------#2018-06-13">https://medium.com/hackernoon/railway-oriented-development-with-erlang-46ea6db4a795?source=collection_archive---------10-----------------------#2018-06-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c09a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作者奥列格·塔拉森科</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/33c56aa99a2be8ad85a875ebcde03f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ffx6aDfZ1Tj6MlGgNa7Dmg.png"/></div></div></figure><p id="ec6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇博客提出了另一种构建程序的方法，这种方法受到了Elixir pipe宏' | &gt; '的启发，但是不需要使用我最近编写的小小的<a class="ae kb" href="https://github.com/oltarasenko/epipe" rel="noopener ugc nofollow" target="_blank"> epipe </a>库来进行可怕的解析转换。Epipe本身的灵感来自Scott Wlaschin发表的这篇<a class="ae kb" href="https://fsharpforfunandprofit.com/rop/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h1 id="476f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">入门指南</h1><p id="f81e" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">让我们执行一个小的实际任务来演示函数式编程的这种铁路方法。</p><p id="2a0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑我们使用Erlang构建POP3电子邮件客户端的情况。我们的目标是实现与POP服务器建立连接的控制流。</p><p id="a5d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下图说明了完成此操作所需的步骤:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/0b933f658121af267bcbb19f49e8ceed.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/0*Xj6CSh5g6A9SmBOw.png"/></div></figure><p id="92b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们构建一个实现连接功能的函数:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="6b5d" class="ll kd hu lh b fv lm ln l lo lp">connect(Addr, Port, ConnOptions, User, Password) -&gt;<br/>    {ok, Socket} = ssl:connect(Addr, Port, ConnOptions),<br/>    ok = receive_greetings(Socket),<br/>    ok = send_user(Socket, User),<br/>    ok = send_password(Socket, Password).</span></pre><p id="373f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码非常漂亮，只有四行代码，我们就完成了！但是等等…上面的实现是最好的情况。显然我们需要添加一些错误处理来处理边缘情况。我是说，“还能出什么差错”？</p><h1 id="6427" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">添加错误处理</h1><p id="e84c" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">让我们在下图中总结所有可能的边缘情况:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/0a2f483e66b5526c57f33c113668772d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*RFEzsnswPIZaGXTe.png"/></div></figure><p id="c288" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们添加错误处理代码，看看现在是什么样子！</p><p id="1341" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">剧透:下面的例子很简单，可以通过将操作分解成独立的函数来美化，但是嵌套的case语句是不可避免的。</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="e3b3" class="ll kd hu lh b fv lm ln l lo lp">connect(Addr, Port, ConnOptions, User, Password) -&gt;<br/>    case ssl:connect(Addr, Port, ConnOptions) of<br/>        {ok, Socket} -&gt;<br/>            case receive_greetings(Socket) of<br/>                ok -&gt;<br/>                    case send_user(Socket, User) of<br/>                        ok -&gt;<br/>                            case send_password(Socket, Password) of<br/>                                ok -&gt; ok;<br/>                                _Err -&gt; error_logger:error_msg("Auth error")<br/>                            end;<br/>                        _Err -&gt;<br/>                            error_logger:error_msg("Unknown user")<br/>                    end;<br/>                Err -&gt; error_logger:error_msg("Could not receive_greetings")<br/>            end;<br/>        _Error -&gt; error_logger:error_msg("Could not connect")<br/>    end.</span></pre><p id="0424" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇哦。现在我们已经添加了所有的错误代码。哇，代码的大小增加了400%…可读性却相应降低了。哎哟！</p><p id="7aab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也许有更干净的方法来实现这一点？</p><h1 id="ff07" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">用“铁路”方法设计更好的错误处理(理论)</h1><p id="fbad" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated"><a class="ae kb" href="https://fsharpforfunandprofit.com/rop/" rel="noopener ugc nofollow" target="_blank">铁路</a>方法背后的想法是分解“步进”功能块，使用铁路道岔作为模拟:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lr"><img src="../Images/f557e4bddca3fe3280009a17eebd90b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0_f5vZcH4RdJs06g.jpg"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">* Image source: Scott Wlaschin</figcaption></figure><p id="cb2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以翻译成下面的Erlang代码:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="69f9" class="ll kd hu lh b fv lm ln l lo lp">switch_component(Input) -&gt;<br/>    case some_action() of<br/>        {ok, Response} -&gt; {ok, Response}; % Green track<br/>        Error          -&gt; {error, Error}  % Red track<br/>    end.</span></pre><p id="8714" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦您为所有要求的操作创建了两种方式(ok/error)开关，您就可以像在铁路上一样优雅地组合它们:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lr"><img src="../Images/c98f5dbad487c3df4ac489bd8f47e66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mJaZEjJOiA8JL8Js.jpg"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">* Image source: Scott Wlaschin</figcaption></figure><p id="8733" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，概括一下，到底发生了什么:</p><p id="627a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在成功场景的情况下，所有功能(“铁路道岔”)被顺序执行，我们沿着“成功轨道”行进。否则，我们的列车会切换到“错误轨道”,绕过所有其他步骤，沿着这条路线行驶:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lr"><img src="../Images/3e78306bbeb22cdf92d43233d708a7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rz6nwOeYWtNNlCoS.jpg"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">* Image source: Scott Wlaschin</figcaption></figure><h1 id="461f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">用“铁路”方法设计更好的错误处理</h1><p id="cadf" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">我们发布了一个小小的<a class="ae kb" href="https://github.com/oltarasenko/epipe" rel="noopener ugc nofollow" target="_blank"> erlang库</a>，它简化了erlang的railway分解。因此，给定上面的例子，让我们看看如何使用Epipe实现我们的用例:</p><pre class="jq jr js jt fq lg lh li lj aw lk dt"><span id="4f22" class="ll kd hu lh b fv lm ln l lo lp">-record(connection, {<br/>    socket,<br/>    user,           <br/>    addr,<br/>    port,<br/>    passwd<br/>}).<br/><br/>connect(Addr, Port, User, Password) -&gt;<br/>    Connection = #connection{<br/>        user = User,<br/>        passwd = Password,<br/>        add = Addr,<br/>        port = Port<br/>    },<br/>    % Defining list of railway switches to follow<br/>    ConnectionSteps = [<br/>        {get_socket, fun get_socket/1},<br/>        {recv_greetings, fun recv_greetings/1},<br/>        {send_user, fun send_user/1},<br/>        {send_passwd, fun send_passwd/1}<br/>    ],<br/>    % Running through switches<br/>    case epipe:run(ConnectionSteps, Connection) of<br/>        {error, Step, Reason, _State} -&gt;<br/>            error_logger:error_msg("Failed to establish connection. Reason: ~p", [Step]),<br/>            {error, Reason};<br/>        {ok, _Conn} = Success -&gt; Success<br/>    end.<br/><br/><br/>% Building blocks. Note that every function can return either {ok, Connection} or {error, Reason}<br/><br/>get_socket(Connection) -&gt;<br/>    case ssl:connect(Addr, Port, ExtraOptions) of<br/>        {ok, Socket} -&gt; {ok, Connection#connection{socket = Socket}};<br/>        Error        -&gt; {error, Error}<br/>    end.<br/><br/>recv_greetings(Connection) -&gt;<br/>    case recv(Connection) of<br/>        {ok, &lt;&lt;"+OK", _Rest/binary&gt;&gt;}   -&gt; {ok, Connection};<br/>        {ok, &lt;&lt;"-ERR ", Error/binary&gt;&gt;} -&gt; {error, Error};<br/>        Err                             -&gt; {error, Err}<br/>    end.<br/><br/>send_user(Connection = #connection{user = User}) -&gt;<br/>    Msg = list_to_binary(User),<br/>    send(Connection, &lt;&lt;"USER ", Msg/binary&gt;&gt;),<br/><br/>    case recv(Connection) of<br/>        {ok, &lt;&lt;"+OK", _Rest/binary&gt;&gt;}   -&gt; {ok, Connection};<br/>        {ok, &lt;&lt;"-ERR ", Error/binary&gt;&gt;} -&gt; {error, Error};<br/>        Err                             -&gt; {error, Err}<br/>    end.<br/><br/>send_passwd(Connection = #connection{passwd = Passwd}) -&gt;<br/>    Msg = list_to_binary(Passwd),<br/>    send(Connection, &lt;&lt;"PASS ", Msg/binary&gt;&gt;),<br/><br/>    case recv(Connection) of<br/>        {ok, &lt;&lt;"+OK", _Rest/binary&gt;&gt;}   -&gt; {ok, Connection};<br/>        {ok, &lt;&lt;"-ERR ", Error/binary&gt;&gt;} -&gt; {error, Error};<br/>        Err                             -&gt; {error, Err}<br/>    end.</span></pre><p id="e1a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与嵌套的case语句实现相比，生成的代码在代码行数方面并没有减少，但是可读性更好，更易于调试和支持。</p><p id="29b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想看看真实世界的实现，请看看这个使用railway方法执行的<a class="ae kb" href="https://github.com/oltarasenko/erlpop/blob/master/src/epop_client.erl#L38-L115" rel="noopener ugc nofollow" target="_blank">重构示例。</a></p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="2d8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="md">原载于2018年6月13日</em><a class="ae kb" href="http://www2.erlang-solutions.com/l/23452/2018-06-13/5kmnlh" rel="noopener ugc nofollow" target="_blank"><em class="md">【www.erlang-solutions.com</em></a><em class="md">。</em></p></div></div>    
</body>
</html>