<html>
<head>
<title>Build a typing indicator in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中建立一个打字指示器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-typing-indicator-in-swift-8a1854a3d7f4?source=collection_archive---------24-----------------------#2018-06-15">https://medium.com/hackernoon/build-a-typing-indicator-in-swift-8a1854a3d7f4?source=collection_archive---------24-----------------------#2018-06-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="2ae6" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">遵循本教程需要对Swift和Node.js有基本的了解。</p></blockquote><p id="8677" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在之前的教程中，我们介绍了<a class="ae jw" href="https://blog.pusher.com/create-anonymous-public-ios-chat-app/" rel="noopener ugc nofollow" target="_blank">如何创建一个公开的匿名iOS聊天应用</a>。我们能够使用Swift和Pusher创建应用程序，因此应用程序不会保存状态。</p><p id="dd35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在本文中，我们将扩展该应用程序，并向该应用程序添加一个输入指示器。如果您还没有阅读前一篇文章，我建议您阅读，但是如果您不想阅读，那么您可以在这里获取文章的<a class="ae jw" href="https://github.com/neoighodaro/anonymous-ios-app-pusher/tree/v1.0" rel="noopener ugc nofollow" target="_blank">源代码并跟随阅读。</a></p><h1 id="6ec0" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">我们将会建造什么</h1><p id="66cb" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">如前所述，我们将在应用程序中添加一个输入指示器。这个功能表明有人正在另一端键入消息——就像WhatsApp、微信或即时通讯客户端一样。</p><figure class="lb lc ld le fq lf fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff la"><img src="../Images/5da354e6603dccf42c50835a878ee455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*INxfenFEUcT6C3E5.gif"/></div></div></figure><h1 id="a1c3" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置应用程序</h1><p id="546e" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">打开上面你下载的源代码的根目录，然后打开目录中包含的<code class="eh lm ln lo lp b">.xcworkspace</code>文件；这应该会启动XCode。现在我们已经有了一个故事板。在故事板中，我们有一个进入控制器，它有一个匿名登录的按钮。点击按钮，导航控制器加载<code class="eh lm ln lo lp b">ChatViewController</code>。</p><figure class="lb lc ld le fq lf fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lq"><img src="../Images/9185e40a491e76db09cc7c1db9817e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BKD-oDrnXr_ao5u3.png"/></div></div></figure><blockquote class="ir is it"><p id="ef4c" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><strong class="ix hv"> <em class="hu">注意</em> </strong> <em class="hu">:为了测试应用程序，您可能需要在web app目录下的</em> <code class="eh lm ln lo lp b"><em class="hu">ChatViewController</em></code> <em class="hu">和</em> <code class="eh lm ln lo lp b"><em class="hu">index.js</em></code> <em class="hu">文件中定制Pusher应用程序凭证。您还需要在webapp目录下运行</em> <code class="eh lm ln lo lp b"><em class="hu">node index.js</em></code> <em class="hu">来启动一个本地web服务器。</em></p></blockquote><h1 id="a959" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">我们需要做的是</h1><p id="13a6" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">为了让这个应用程序做我们需要它做的事情，我们需要做一些新的事情。首先，我们将向web服务器应用程序添加一个新的端点，一旦有人开始输入，它将触发Pusher。我们将在应用程序中添加一个新的监听器，在有人打字时监听，最后，当有人在“新消息”字段中输入文本时，我们将触发新的端点。</p><h1 id="3d7f" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">在web服务器上添加端点</h1><p id="942a" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">现在，我们想在web服务器上添加一个端点，每当有人输入时，它就会触发Pusher事件。在您选择的编辑器上打开<code class="eh lm ln lo lp b">webapp</code>目录中的<code class="eh lm ln lo lp b">index.js</code>。现在可以将<code class="eh lm ln lo lp b">/typing</code>端点添加到代码中，如下所示:</p><pre class="lb lc ld le fq lr lp ls lt aw lu dt"><span id="65fe" class="lv jy hu lp b fv lw lx l ly lz">app.post('/typing', function (req, res) {<br/>  var message = {<br/>    sender: req.body.sender,<br/>    text: req.body.sender + " is typing..."<br/>  };<br/>  pusher.trigger('chatroom', 'user_typing', message);<br/>  res.json({success: 200})<br/>})</span></pre><p id="abab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">所以现在，每当我们点击<code class="eh lm ln lo lp b">/typing</code>端点时，它应该用消息<code class="eh lm ln lo lp b">senderId is typing…</code>触发Pusher。太好了。</p><h1 id="776c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">打字时从应用程序触发推送器</h1><p id="1a43" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">接下来要做的事情是每当当前用户在应用程序上输入时触发Pusher。这基本上会触及我们刚刚创建的以<code class="eh lm ln lo lp b">username</code>作为<code class="eh lm ln lo lp b">sender</code>参数的<code class="eh lm ln lo lp b">/typing</code>端点。</p><p id="c3c4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了确保我们的代码保持干燥，我们对代码进行了一点重构。我们已经将到达终点的部分抽象成一个叫做<code class="eh lm ln lo lp b">hitEndpoint</code>的方法，现在只要我们想到达终点就使用它。</p><pre class="lb lc ld le fq lr lp ls lt aw lu dt"><span id="7991" class="lv jy hu lp b fv lw lx l ly lz">var isBusySendingEvent : Bool = false</span><span id="bd3e" class="lv jy hu lp b fv ma lx l ly lz">private func postMessage(name: String, message: String) {<br/>    let params: Parameters = ["sender": name, "text": message]<br/>    hitEndpoint(url: ChatViewController.API_ENDPOINT + "/messages", parameters: params)<br/>}</span><span id="b506" class="lv jy hu lp b fv ma lx l ly lz">private func sendIsTypingEvent(forUser: String) {<br/>    if isBusySendingEvent == false {<br/>        isBusySendingEvent = true<br/>        let params: Parameters = ["sender": forUser]<br/>        hitEndpoint(url: ChatViewController.API_ENDPOINT + "/typing", parameters: params)<br/>    } else {<br/>        print("Still sending something")<br/>    }<br/>}</span><span id="f7e4" class="lv jy hu lp b fv ma lx l ly lz">private func hitEndpoint(url: String, parameters: Parameters) {<br/>    Alamofire.request(url, method: .post, parameters: parameters).validate().responseJSON { response in<br/>        switch response.result {<br/>        case .success:<br/>            self.isBusySendingEvent = false<br/>            // Succeeded, do something<br/>            print("Succeeded")<br/>        case .failure(let error):<br/>            self.isBusySendingEvent = false<br/>            // Failed, do something<br/>            print(error)<br/>        }<br/>    }<br/>}</span><span id="1dda" class="lv jy hu lp b fv ma lx l ly lz">override func textViewDidChange(_ textView: UITextView) {<br/>    super.textViewDidChange(textView)<br/>    sendIsTypingEvent(forUser: senderId)<br/>}</span></pre><p id="bf21" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh lm ln lo lp b">sendIsTypingEvent</code>中，我们有一个快速标志，用于阻止应用程序发送过多的请求，尤其是在最后一个请求没有完成的情况下。因为每当有人在文本字段上更改某些内容时我们都会触发这个方法，所以这个检查是必要的。</p><h1 id="c3af" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">添加一个监听器，以便在其他人打字时接听</h1><p id="a6cc" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">这个难题的最后一部分是添加一个监听器，它在其他人打字时拾取并将视图控制器的标题栏更改为<code class="eh lm ln lo lp b">someone is typing…</code>。为此，我们将在<code class="eh lm ln lo lp b">PusherChannel</code>对象上使用<code class="eh lm ln lo lp b">subscribe</code>方法。</p><pre class="lb lc ld le fq lr lp ls lt aw lu dt"><span id="2c74" class="lv jy hu lp b fv lw lx l ly lz">override func viewDidLoad() {<br/>    super.viewDidLoad()</span><span id="ab61" class="lv jy hu lp b fv ma lx l ly lz">    let n = Int(arc4random_uniform(1000))</span><span id="36fe" class="lv jy hu lp b fv ma lx l ly lz">    senderId = "anonymous" + String(n)<br/>    senderDisplayName = senderId</span><span id="2a94" class="lv jy hu lp b fv ma lx l ly lz">    inputToolbar.contentView.leftBarButtonItem = nil</span><span id="6c27" class="lv jy hu lp b fv ma lx l ly lz">    incomingBubble = JSQMessagesBubbleImageFactory().incomingMessagesBubbleImage(with: UIColor.jsq_messageBubbleBlue())<br/>    outgoingBubble = JSQMessagesBubbleImageFactory().outgoingMessagesBubbleImage(with: UIColor.jsq_messageBubbleGreen())</span><span id="3d9f" class="lv jy hu lp b fv ma lx l ly lz">    collectionView!.collectionViewLayout.incomingAvatarViewSize = CGSize.zero<br/>    collectionView!.collectionViewLayout.outgoingAvatarViewSize = CGSize.zero</span><span id="6027" class="lv jy hu lp b fv ma lx l ly lz">    automaticallyScrollsToMostRecentMessage = true</span><span id="ac5e" class="lv jy hu lp b fv ma lx l ly lz">    collectionView?.reloadData()<br/>    collectionView?.layoutIfNeeded()</span><span id="6f5c" class="lv jy hu lp b fv ma lx l ly lz">    listenForNewMessages()</span><span id="b313" class="lv jy hu lp b fv ma lx l ly lz">    isTypingEventLifetime = Timer.scheduledTimer(timeInterval: 2.0,<br/>                                                 target: self,<br/>                                                 selector: #selector(isTypingEventExpireAction),<br/>                                                 userInfo: nil,<br/>                                                 repeats: true)</span><span id="866a" class="lv jy hu lp b fv ma lx l ly lz">}</span><span id="d545" class="lv jy hu lp b fv ma lx l ly lz">private func listenForNewMessages() {<br/>    let options = PusherClientOptions(<br/>        host: .cluster("PUSHER_CLUSTER")<br/>    )</span><span id="9f39" class="lv jy hu lp b fv ma lx l ly lz">    pusher = Pusher(key: "PUSHER_ID", options: options)</span><span id="7064" class="lv jy hu lp b fv ma lx l ly lz">    let channel = pusher.subscribe("chatroom")</span><span id="5f09" class="lv jy hu lp b fv ma lx l ly lz">    channel.bind(eventName: "new_message", callback: { (data: Any?) -&gt; Void in<br/>        if let data = data as? [String: AnyObject] {<br/>            let author = data["sender"] as! String</span><span id="b14e" class="lv jy hu lp b fv ma lx l ly lz">            if author != self.senderId {<br/>                let text = data["text"] as! String<br/>                self.addMessage(senderId: author, name: author, text: text)<br/>                self.finishReceivingMessage(animated: true)<br/>            }<br/>        }<br/>    })</span><span id="10dc" class="lv jy hu lp b fv ma lx l ly lz">    channel.bind(eventName: "user_typing", callback: { (data: Any?) -&gt; Void in<br/>        if let data = data as? [String: AnyObject] {<br/>            let author = data["sender"] as! String<br/>            if author != self.senderId {<br/>                let text = data["text"] as! String<br/>                self.navigationItem.title = text<br/>            }<br/>        }<br/>    })</span><span id="0c07" class="lv jy hu lp b fv ma lx l ly lz">    pusher.connect()<br/>}</span><span id="c782" class="lv jy hu lp b fv ma lx l ly lz">public func isTypingEventExpireAction() {<br/>    navigationItem.title = "AnonChat"<br/>}</span></pre><p id="08f5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面我们做了一些改变。在<code class="eh lm ln lo lp b">listenForNewMessages</code>中，我们向<code class="eh lm ln lo lp b">user_typing</code>事件添加了一个新的订阅，在<code class="eh lm ln lo lp b">viewDidLoad</code>方法中，我们添加了一个定时器，它只是按时间间隔运行，并重置应用程序的标题。基本上，订阅者从Pusher获取事件中的变化，更新导航标题，然后计时器每x秒重置一次标题。</p><p id="0fc3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">至此，我们已经完成了我们的任务，我们应该有打字指示器功能的工作。</p><h1 id="9fdb" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="b02f" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">很明显，您可以添加许多改进来使体验更加无缝，但这演示了如何将该功能轻松实现到您的iOS应用程序中。</p><p id="9cad" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这个帖子最初是发布给<a class="ae jw" href="https://pusher.com/tutorials/typing-indicator-swift/" rel="noopener ugc nofollow" target="_blank">推手</a>的。</p></div></div>    
</body>
</html>