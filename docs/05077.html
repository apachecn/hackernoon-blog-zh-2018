<html>
<head>
<title>Avoiding infinite loops inside JavaScript callbacks - a TDD approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免JavaScript回调中的无限循环——一种TDD方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/avoiding-infinite-loops-inside-javascript-callbacks-a-tdd-approach-b41b32ca4406?source=collection_archive---------6-----------------------#2018-06-16">https://medium.com/hackernoon/avoiding-infinite-loops-inside-javascript-callbacks-a-tdd-approach-b41b32ca4406?source=collection_archive---------6-----------------------#2018-06-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/06ac469a01e05fc65403426ac3b226c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZLW4zkMlZpiwRsEgo7brQ.jpeg"/></div></div></figure><h1 id="ab8c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">停顿问题</h1><p id="7734" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">所有计算机科学中最著名的问题之一是 <a class="ae ky" href="https://en.wikipedia.org/wiki/Halting_problem" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">停机问题</strong> </a>。基本上这就是<a class="ae ky" href="https://hackernoon.com/tagged/determining" rel="noopener ugc nofollow" target="_blank">决定</a>的问题，从一个计算机程序的描述和一个输入来看，程序是结束运行还是永远继续运行。早在1936年，著名的Alan Turing <a class="ae ky" href="https://en.wikipedia.org/wiki/Halting_problem" rel="noopener ugc nofollow" target="_blank">就证明了</a>不可能提供一个通用算法来解决所有可能的程序输入对的停机问题。换句话说，你不能写代码总是能够决定你的程序是否会结束，或者是否会陷入无限循环。显然我不会证明艾伦·图灵是错的，但我最近想出了一些代码，可以确保许多<a class="ae ky" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>应用程序中非常常见的特定代码不会进入无限循环。</p><h1 id="23c3" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak"> JavaScript回调</strong></h1><p id="bbf1" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">JavaScript语言严重依赖回调来执行异步处理。在为浏览器或NodeJS等环境编写JavaScript代码时，这是一种非常常见的模式。JavaScript回调通常作为函数实现，作为参数传递给其他函数，引发一些异步操作。当操作完成时，回调函数被调用，通常指示成功或失败。这是可能的，因为在JavaScript中，函数是<a class="ae ky" href="https://en.wikipedia.org/wiki/First-class_function" rel="noopener ugc nofollow" target="_blank">一级公民</a>，可以像其他值一样作为参数传递给函数。</p></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="2c9e" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">回调机制可以通过允许多个回调订阅单个事件来一般化。回调订阅函数可以接受两个值:事件的名称，以及事件发生时要调用的实际回调函数。从而允许多个外部模块将其期望的功能与当前流程挂钩，同时能够分离不同模块之间的关注点。这通常被称为经典的<strong class="kc hv">事件发射器模式</strong>或<strong class="kc hv">发布-订阅</strong>。</p><p id="b50c" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">基本上，这种方法的经典实现是持有一个事件名+回调对的私有映射，并添加一个公共方法来订阅(如果愿意，还可以取消订阅)这些对。我们还想为订阅的回调添加一个执行方法(emit函数),以便实际运行它们。如果我们希望从外部触发，这个方法可以是完全内部的，也可以是外部的。</p><p id="cf9d" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">显然，调用subscribe方法的人必须知道所支持的键或事件名称/类型，否则它们永远不会被执行。</p><p id="aeff" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">这通常看起来像这样:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><h1 id="14c5" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">所以让我们回到无限循环！</h1><p id="2589" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我正在开发一个类似的机制，在这样做的时候，我想到了一个理论上的例子，它还没有发生，但如果发生了，可能很难跟踪；其中执行回调的emit函数可以不断地自称为<em class="lr"/>。</p><p id="530e" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">假设有人订阅了我的机制的回调，在他们的回调中，他们将触发另一个已知事件(来自我的已知事件名称集)，不知不觉地，那个事件也在执行事件的回调，所以回调将被再次调用<em class="lr"/>…<em class="lr">和再次…再次</em> …</p><p id="1ca6" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">在回调中从外部调用另一个事件的人，不一定知道事件执行触发了一组额外的回调执行，代码将进入一个无限循环，坦率地说，这是一个很难理解的循环。</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><h1 id="d20c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">来点TDD的乐趣吧:)</strong></h1><p id="112c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">所以我决定用<a class="ae ky" href="http://agiledata.org/essays/tdd.html" rel="noopener ugc nofollow" target="_blank"> TDD </a>风格来攻题！因为我对于这个所谓的bug没有实际的用例，而且这纯粹是理论上的，所以我认为TDD方法真的可以帮助我以最简单和最纯粹的方式定义这个问题。此外，我知道如果我为这种情况添加一个真正可维护且稳定的测试，它将永远不会在生产中发生。</p><p id="d285" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">因此，首先，我想编写尽可能简单和最短的测试(即使没有人会在真实的代码示例中编写这种测试)，首先模拟问题，然后找出解决问题的方法。</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="5bd1" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">我查过了。结果是<a class="ae ky" href="https://stackoverflow.com/questions/6095530/maximum-call-stack-size-exceeded-error" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">最大调用栈超过了</strong> </a>，完全如我所愿。所以我手上的危险场景测试失败了，很明显它失败了。我想到了路过的场景，以及我想在那里发生什么。我意识到我根本不需要任何断言，我所关心的是测试即将结束。</p><p id="86af" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">对于所谓的bug的解决方案本身非常简单，我决定存储一个状态变量，该变量在回调执行时进行标记，并在回调执行结束时重置为默认值。</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="6c10" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">因此，如果我得到一个回调，它将再次触发额外的回调，它们将被忽略和报告。</p><p id="fba3" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">我添加了我的代码，再次运行测试，它通过了。最甜蜜简单干净的TDD，没有断言。只是普通的绿色测试:)</p><p id="ea5a" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">之后，我可以重构我的代码，让它变得更漂亮、更好。我需要做的就是重新运行我的测试，并确保它仍然是绿色的！</p><p id="95b5" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated">嗯，实际上它最好的部分是它对未来是防弹的。如果其他人修改了我的问题解决方案或删除了它，测试将再次超出最大调用堆栈，显然会失败:)</p></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><h1 id="160c" class="jc jd hu bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz dt translated"><strong class="ak">运动侧记</strong></h1><p id="e05d" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">请注意，我的解决方案只有在额外的事件发射以<strong class="kc hv">同步</strong>方式完成时才有效。如果订阅的回调以一种<strong class="kc hv">异步</strong>的方式触发了其他回调的执行，你会怎么做？我会把它作为对我的读者的一个挑战，很乐意听听你们想出的任何东西:)</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="bdb9" class="pw-post-body-paragraph ka kb hu kc b kd lg kf kg kh lh kj kk kl li kn ko kp lj kr ks kt lk kv kw kx hn dt translated"><a class="ae ky" href="https://upscri.be/hackernoon/" rel="noopener ugc nofollow" target="_blank">https://upscri.be/hackernoon/</a></p></div></div>    
</body>
</html>