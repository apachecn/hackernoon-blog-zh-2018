<html>
<head>
<title>Four Semesters of Computer Science in Five Hours…Phew!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五个小时四个学期的计算机科学…唷！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/four-semesters-of-computer-science-in-five-hours-phew-53dd8779b79f?source=collection_archive---------9-----------------------#2018-06-16">https://medium.com/hackernoon/four-semesters-of-computer-science-in-five-hours-phew-53dd8779b79f?source=collection_archive---------9-----------------------#2018-06-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bb8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的博客记录了我作为一名技术人员进入硅谷的经历。我是一个有色人种的怪人，性别不合群，移民，曾被收养的年轻人。我来自一个非传统的编码背景。我在大学里学了几门CS课程，最后在成为老师之前主修了人文学科。向青少年教授web开发让我对编码产生了兴趣。在一所编码学校毕业后，我开始在旧金山的初创企业工作。我的博客一半是关于技术主题，另一半是关于平等和技术访问(我的旅程)。</p><p id="2029" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本周选择了布莱恩·霍尔特的另一个教程。我喜欢向布莱恩学习的一点是，他理解自学，因为他承认从大学辍学，自学成才。他用简单的英语解释一切，谦逊地承认他使用的工具或他如何着手解决问题是一种“观点”,并强调有其他方法可以达到同样的结果。他说，“第一次学习递归很难。但一旦你得到了，你就开始意识到这很难但很简单。”他还补充了一个警告，即这门课程并不能代替修完4个学期<a class="ae jp" href="https://hackernoon.com/tagged/semesters" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae jp" href="https://hackernoon.com/tagged/comp-sci" rel="noopener ugc nofollow" target="_blank">比较科学</a>课程。我知道从大学辍学并“自学成才”是科技行业的一个笑话，如果《硅谷》这部剧可以说明这一点的话:</p><p id="ec96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大外卖:</p><ul class=""><li id="4a2d" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">大O</li><li id="9f54" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">递归</li><li id="9f0c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">排序算法</li><li id="d581" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">数据结构</li></ul><p id="24fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">大O批注</strong></p><p id="077f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单来说，大O就是用n个输入执行x次运算所需时间的度量。例如，如果你有一个等式，3x + x + 1。大O考虑了运算x，它给出了等式中最大的数。这个方程的大O将是O(n)，因为如果我们将O(n ) + O(1) + O(1) = O(2n)的运算相加，我们会去掉系数，因为随着数字变大，它变得无关紧要。让我们尝试使用另一个函数来计算大O。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="7321" class="kn ko hu kj b fv kp kq l kr ks">var crossAdd = function(input) {<br/>var answer = [];<br/>for (var i = 0; i &lt; input.length; i++){<br/>  var goingUp = input[i];<br/>  var goingDown = input[input.length-1-i];<br/>  answer.push(goingUp + goingDown);<br/>}<br/>return answer;<br/>}</span></pre><p id="32ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们计算一下大O，crossAdd是一个赋值所以那是O(1)，答案也是。所以我们有，O(1) + O(1)。我们的for循环O(1) + O(n) + O(n)。另一个赋值，O(1) + O(n) + O(n) + O(1)。总的来说，我们有O(5) + O(4n)。因为O(1)是一个常数，我们可以去掉O(5)。随着数字变大，n前面的系数将变得越来越不重要，所以我们剩下O(n)。试试另一个:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="6c49" class="kn ko hu kj b fv kp kq l kr ks">function makeTuples(input) {<br/>var answer = [];<br/>for (var i = 0; i &lt; input.length; i++) {<br/>  for (var j = 0; j &lt; input.length; j++) {<br/>    answer.push([input[i], input[j]]);<br/>  }<br/>}<br/>return answer;<br/>}</span></pre><p id="ad2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">跟踪对程序影响最大的操作，2 for循环意味着我们必须遍历输入O(n) * O(n)次，等于O(n)。</p><p id="0889" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">递归</strong></p><ul class=""><li id="3b15" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">一个函数在它的代码块内部调用它自己</li><li id="8e89" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">必须有一个基本用例(将函数从递归调用中分离出来)</li><li id="51c6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">如果您的基本情况失败，您会得到堆栈溢出—调用函数，直到堆栈中没有剩余的内存(高成本，使用for或while循环—迭代而不是递归)</li></ul><p id="d095" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们什么时候使用递归？多次调用一个函数会增加开销，因为必须创建函数的堆栈框架。这包括最低级别的内存操作和CPU寄存器更新。迭代/循环不需要这些额外的工作。如果我们有一个程序，要求用户多次调用递归函数，这是没有效率的，迭代会工作得更好。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="721a" class="kn ko hu kj b fv kp kq l kr ks">function countdown(current) {<br/>  if(current &lt;= 0) return;<br/>  wr(current);<br/>  countdown(current-1)<br/>}</span></pre><p id="18d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">著名的递归函数——斐波那契</strong></p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="f65a" class="kn ko hu kj b fv kp kq l kr ks">function fibonacci(num) {<br/>  if(num &lt;= 2) {<br/>    return 1<br/>  } else {<br/>    return fibonacci(num — 1) + fibonacci(num — 2)<br/>  }<br/>}</span></pre><p id="eb8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">同样著名的递归函数——阶乘</strong></p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="bfde" class="kn ko hu kj b fv kp kq l kr ks">function factorial(num) {<br/>  if(num &lt; 2) {<br/>    return 1<br/>  } else {<br/>     return num * factorial(num — 1)<br/>  }<br/>}</span></pre><p id="821d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">排序算法</strong></p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="dd0b" class="kn ko hu kj b fv kp kq l kr ks">//create a function that will swap numbers</span><span id="5f9b" class="kn ko hu kj b fv kt kq l kr ks">//write a function that will take a list, index1, and index2<br/>function swap(list, index1, index2) {<br/>  let swapped = list[index1]<br/>  list[index1] = list[index2]<br/>  list[index2] = swapped<br/>}</span></pre><ol class=""><li id="6e41" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ku jw jx jy dt translated">冒泡排序——效率非常低，因为有一个外部循环和一个内部循环，加上其他常数运算，算法的大O等于O(n)。</li></ol><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="60d7" class="kn ko hu kj b fv kp kq l kr ks">//loop across the list to keep track if you are at <br/>the beginning of the end<br/>//loop across the list to swap letters<br/>//return the new list</span><span id="df66" class="kn ko hu kj b fv kt kq l kr ks">function bubbleSort(items){<br/>  let len = items.length<br/>  for (let i=0; i &lt; len; i++){<br/>    for (j=0, stop=len-i; j &lt; stop; j++){<br/>      if (items[j] &gt; items[j+1]){<br/>       swap(items, j, j+1);<br/>    }<br/>  }<br/>}<br/> return items;<br/>}</span></pre><p id="8832" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<a class="ae jp" href="http://codingmiles.com/sorting-algorithms-insertion-sort-using-javascript/" rel="noopener ugc nofollow" target="_blank">插入排序</a> —更复杂，偶尔有用。参见伪代码进行解释</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="2344" class="kn ko hu kj b fv kp kq l kr ks">//ex: [5, 3, 1] =&gt; inserts 3 into the 5 position, now 2 are sorted to [3, 5, 1] =&gt; makes a copy of 1 compares it to 5, moves 5 into its spot =&gt; look</span><span id="67fe" class="kn ko hu kj b fv kt kq l kr ks">function insertionSort(array) {<br/>  for(var i = 0; i &lt; array.length; i++) {<br/>    var temp = array[i];<br/>    var j = i — 1;<br/>    while (j &gt;= 0 &amp;&amp; array[j] &gt; temp) {<br/>      array[j + 1] = array[j];<br/>      j — ;<br/>    }<br/>   array[j + 1] = temp;<br/>  }<br/>return array;<br/>}</span></pre><p id="7718" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<a class="ae jp" href="https://www.tutorialspoint.com/data_structures_algorithms/merge_sort_algorithm.htm" rel="noopener ugc nofollow" target="_blank">合并排序</a> —分而治之，将数组分成左排序和右排序，然后我们将它们放回一起</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="a3a6" class="kn ko hu kj b fv kp kq l kr ks">function stitch(left, right) {<br/>  const results = []<br/>  while(left.length &amp;&amp; right.length) {<br/>    if(left[0] &lt;= right[0]) {<br/>      results.push(left.shift())<br/>    } else {<br/>     results.push(right.shift())<br/>    }<br/>  }<br/>  while(left.length){<br/>    results.push(left.shift())<br/>  }<br/>  while(right.length) {<br/>    results.push(right.shift())<br/>  }<br/>}</span></pre><p id="f559" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">合并排序</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="43eb" class="kn ko hu kj b fv kp kq l kr ks">function mergeSort(nums) {<br/>  if(nums.length &lt; 2) {<br/>    return nums<br/>  }<br/>  const length = nums.length<br/>  const middle = Math.floor(length / 2)<br/>  const left = nums.slice(0, middle)<br/>  const right = nums.slice(middle, length)<br/>  const sortedLEft = mergeSort(left)<br/>  const sortedRight = mergeSort(right)<br/>  return stitch(mergeSort(left), mergeSort(right))<br/>}</span></pre><p id="eedf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.<a class="ae jp" href="http://blog.benoitvallon.com/sorting-algorithms-in-javascript/the-quicksort-algorithm/" rel="noopener ugc nofollow" target="_blank">快速排序</a> —另一种分治算法，最强大的排序算法，递归。基本要点是，你把列表中的最后一个元素作为枢纽。小于中枢的所有东西都放在“左”列表中，大于中枢的所有东西都放在“右”列表中。然后递归调用左右列表的快速排序，连接排序后的左列表、透视，然后是右列表(按此顺序。)基本情况是当长度为1或0时，返回列表。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="ef26" class="kn ko hu kj b fv kp kq l kr ks">function quicksortBasic(array) {<br/>  if(array.length &lt; 2) {<br/>    return array;<br/>  }<br/>  var pivot = array[0];<br/>  var lesser = [];<br/>  var greater = [];<br/>  for(var i = 1; i &lt; array.length; i++) {<br/>    if(array[i] &lt; pivot) {<br/>      lesser.push(array[i]);<br/>    } else {<br/>     greater.push(array[i]);<br/>    }<br/>  }<br/>return quicksortBasic(lesser).concat(pivot,quicksortBasic(greater));<br/>}</span></pre><p id="ba6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">数据结构</strong></p><p id="7fd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数组列表与链表</p><p id="e4e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数组列表—需要与分配的内存块进行交互。在Java中，你必须声明数组的大小。典型的方法有:push、pop、find和delete(在本教程中_collapseTo是delete的辅助函数)。</p><p id="9749" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">链接列表—有头、尾、下一个和上一个(如果是双重链接)。链表有助于避免哈希表中的重复键造成的数据冲突。它们在删除和插入中也很有用。</p><p id="73d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">二叉查找树(BST)-快速搜索，BST可以有0，1，2个孩子。左小于父节点。权大于父。查找次数为O(log n)。BST不用于生产。自平衡采油树用于生产。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="583b" class="kn ko hu kj b fv kp kq l kr ks">class Node {<br/>  constructor(data, left=null, right=null) {<br/>    this.data = data<br/>    this.left = left<br/>    this.right = right<br/>  }<br/>}</span><span id="f8b4" class="kn ko hu kj b fv kt kq l kr ks">class Tree {<br/>  constructor() {<br/>    this.root = null;<br/>  }</span><span id="a883" class="kn ko hu kj b fv kt kq l kr ks">  add(value) {<br/>    if (this.root === null) {<br/>      this.root = new Node(value);<br/>    } else {<br/>       let current = this.root;<br/>    while(true) {<br/>      if (current.value &gt; value) {<br/>      // go left<br/>        if (current.left) {<br/>          current = current.left;<br/>        } else {<br/>           current.left = new Node(value);<br/>           break;<br/>        }<br/>      } else {<br/>        // go right<br/>        if (current.right) {<br/>          current = current.right;<br/>        } else {<br/>            current.right = new Node(value);<br/>            break;<br/>        }<br/>      }<br/>    }<br/>  }<br/> return this;<br/>}</span><span id="a0c3" class="kn ko hu kj b fv kt kq l kr ks">  toJSON() {<br/>    return JSON.stringify(this.root.serialize(), null, 4);<br/>  }</span><span id="7993" class="kn ko hu kj b fv kt kq l kr ks">  toObject() {<br/>    return this.root.serialize();<br/>  }<br/>}</span></pre><p id="edce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个教程中肯定有很多信息，我肯定是在试图吸收所有的信息。我一定会再看一遍。</p><figure class="ke kf kg kh fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure></div></div>    
</body>
</html>