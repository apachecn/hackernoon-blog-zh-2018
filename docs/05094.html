<html>
<head>
<title>Divide and Conquer (Merge Sort)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分而治之(合并排序)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/divide-and-conquer-merge-sort-11c673470427?source=collection_archive---------4-----------------------#2018-06-17">https://medium.com/hackernoon/divide-and-conquer-merge-sort-11c673470427?source=collection_archive---------4-----------------------#2018-06-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/a711cec9c5a1b2923d3ac524652057ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0fUKBPH_qyPQX6F3wuDPQ.png"/></div></figure><p id="3cf6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">分而治之是一种算法策略，通过将一个问题分解成两个或更多相同或相关类型的子问题，解决它们并添加子问题。让我们弄清楚。在分而治之技术中，我们需要将一个问题分成子问题，递归地解决它们，并组合子问题。所以我们可以假设，为了遵循这个策略，我们需要<strong class="ja hv">将</strong> a分成一些部分，然后<strong class="ja hv">征服</strong>或者解决这些部分，最后将它们组合起来。因此，我们可以很容易地解决问题。</p><p id="b632" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有许多算法遵循分治技术。如递归二分搜索法、归并排序、快速排序、选择排序、斯特拉森矩阵乘法等。</p><p id="a435" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我想做一个系列，在其中我将讨论一些遵循分而治之策略的算法。</p><p id="b2f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">今天我讨论的是归并排序。合并排序是一种排序算法。我们采取分而治之的策略。在归并排序中，我们将把一个数组分成两部分，然后分别排序，最后合并。</p><p id="71a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先我们需要输入一个数组。然后，我们将应用以下步骤:</p><p id="eb8b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">第一步:</strong>如果数组不超过一个元素，那么数组已经排序过了。</p><p id="9349" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第二步:然后我们将数组中的一半元素保存在一个名为left的新数组中，并合并排序后的数组。</p><p id="35e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">第三步:</strong>然后数组的另一半元素应该保留在右边的数组中，合并排序后的数组。</p><p id="316a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">第四步:</strong>最后合并两个合并排序后的数组。</p><p id="9de4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">假设一个数组有八个元素，分别是8，3，2，9，7，1，5，4。现在我们将它们分成两部分。那我们就按照之前的步骤来。通过看这些图片，你可以得到一个清晰的解释。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff jw"><img src="../Images/a7173a802fa815fcc7163fad339b561c.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*zsMWBmP_fY4Dl40fHSnDaw.png"/></div></figure><p id="d026" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要在程序中应用这些步骤，首先我们需要一个合并排序程序，然后我们需要一个合并程序。所以我们来写程序吧。</p><p id="d9d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">合并排序功能:</strong></p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="2d36" class="kg kh hu kc b fv ki kj l kk kl">//ara is needed to merge sorted<br/>//left is the index of first element<br/>//right is the index of last element</span><span id="5e19" class="kg kh hu kc b fv km kj l kk kl">void merge_sort (int ara[], int left, int right)</span><span id="3a32" class="kg kh hu kc b fv km kj l kk kl">{</span><span id="9e51" class="kg kh hu kc b fv km kj l kk kl">if(left &gt;=right)<br/>    {</span><span id="a143" class="kg kh hu kc b fv km kj l kk kl">return;</span><span id="477c" class="kg kh hu kc b fv km kj l kk kl">}<br/>    <br/>    //ara is divided into two parts<br/>    // one is from left to mid<br/>    // other is from mid+1 to right</span><span id="80cf" class="kg kh hu kc b fv km kj l kk kl">int mid = left+(right-left)/2;<br/>    //applying merge sort from ara[left] to ara[mid]<br/>    merge_sort(ara,left,mid);<br/>    //applying merge sort from ara[mid+1] to ara[right]<br/>    merge_sort(ara,mid+1,right);<br/>    //finally merging them<br/>    merge(ara,left,mid,right);</span><span id="bd0a" class="kg kh hu kc b fv km kj l kk kl">}</span></pre><p id="55de" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后我们需要做一个<strong class="ja hv">合并函数</strong>。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="5eb1" class="kg kh hu kc b fv ki kj l kk kl">void merge(int ara[],int left,int mid,int right)<br/>{</span><span id="8790" class="kg kh hu kc b fv km kj l kk kl">int i;<br/>    int index_a, index_l, index_r;<br/>    int size_left, size_right;<br/>    size_left = mid - left + 1;<br/>    size_right = right - mid;<br/>    int L [size_left], R[size_right];<br/>    <br/>    //copying from ara[left] to ara[mid]<br/>    for(i=0;i&lt;size_left;i++)<br/>    {</span><span id="1b8c" class="kg kh hu kc b fv km kj l kk kl">L[i]=ara[left+i];</span><span id="ae7b" class="kg kh hu kc b fv km kj l kk kl">}<br/>    <br/>    ////copying from ara[mid+1] to ara[right]<br/>    for(i=0;i&lt;size_right;i++)<br/>    {</span><span id="1818" class="kg kh hu kc b fv km kj l kk kl">R[i]=ara[mid+1+i];</span><span id="5613" class="kg kh hu kc b fv km kj l kk kl">}<br/>    index_l = 0;<br/>    index_r = 0;<br/>    for(index_a = left;<br/>    index_l &lt; size_left &amp;&amp; index_r &lt; size_right;<br/>    index_a++)<br/>    {</span><span id="acc0" class="kg kh hu kc b fv km kj l kk kl">if(L[index_l]&lt;R[index_r])<br/>        {</span><span id="829f" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = L[index_l];<br/>            index_l += 1;</span><span id="b491" class="kg kh hu kc b fv km kj l kk kl">}<br/>        else<br/>        {</span><span id="109a" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = R [index_r];<br/>            index_r += 1;</span><span id="eb26" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="c766" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="55b6" class="kg kh hu kc b fv km kj l kk kl">while (index_l &lt; size_left)<br/>    {</span><span id="9747" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = L [index_l];<br/>        index_l += 1;<br/>        index_a += 1;</span><span id="ca45" class="kg kh hu kc b fv km kj l kk kl">}<br/>     while (index_r &lt; size_right)<br/>    {</span><span id="4522" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = R [index_r];<br/>        index_r += 1;<br/>        index_a += 1;</span><span id="8cc6" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="ebe8" class="kg kh hu kc b fv km kj l kk kl">}</span></pre><p id="36d2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，该计划将是:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="b577" class="kg kh hu kc b fv ki kj l kk kl">#include &lt;iostream&gt;</span><span id="a018" class="kg kh hu kc b fv km kj l kk kl">using namespace std;</span><span id="af53" class="kg kh hu kc b fv km kj l kk kl">void merge(int ara[],int left,int mid,int right);</span><span id="9bf1" class="kg kh hu kc b fv km kj l kk kl">//ara is needed to merge sorted<br/>//left is the index of first element<br/>//right is the index of last element</span><span id="e4c0" class="kg kh hu kc b fv km kj l kk kl">void merge_sort (int ara[], int left, int right)</span><span id="8ae2" class="kg kh hu kc b fv km kj l kk kl">{</span><span id="0097" class="kg kh hu kc b fv km kj l kk kl">if(left &gt;=right)<br/>    {</span><span id="71eb" class="kg kh hu kc b fv km kj l kk kl">return;</span><span id="a6a8" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="ef61" class="kg kh hu kc b fv km kj l kk kl">//ara is divided into two parts<br/>    // one is from left to mid<br/>    // other is from mid+1 to right</span><span id="f7a8" class="kg kh hu kc b fv km kj l kk kl">int mid = left+(right-left)/2;<br/>    //applying merge sort from ara[left] to ara[mid]<br/>    merge_sort(ara,left,mid);<br/>    //applying merge sort from ara[mid+1] to ara[right]<br/>    merge_sort(ara,mid+1,right);<br/>    //finally merging them<br/>    merge(ara,left,mid,right);</span><span id="5db7" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="e2df" class="kg kh hu kc b fv km kj l kk kl">void merge(int ara[],int left,int mid,int right)<br/>{</span><span id="3c57" class="kg kh hu kc b fv km kj l kk kl">int i;<br/>    int index_a, index_l, index_r;<br/>    int size_left, size_right;<br/>    size_left = mid - left + 1;<br/>    size_right = right - mid;<br/>    int L [size_left], R[size_right];</span><span id="347d" class="kg kh hu kc b fv km kj l kk kl">//copying from ara[left] to ara[mid]<br/>    for(i=0;i&lt;size_left;i++)<br/>    {</span><span id="6d02" class="kg kh hu kc b fv km kj l kk kl">L[i]=ara[left+i];</span><span id="6cb4" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="38d1" class="kg kh hu kc b fv km kj l kk kl">////copying from ara[mid+1] to ara[right]<br/>    for(i=0;i&lt;size_right;i++)<br/>    {</span><span id="1914" class="kg kh hu kc b fv km kj l kk kl">R[i]=ara[mid+1+i];</span><span id="cd9b" class="kg kh hu kc b fv km kj l kk kl">}<br/>    index_l = 0;<br/>    index_r = 0;<br/>    for(index_a = left;<br/>    index_l &lt; size_left &amp;&amp; index_r &lt; size_right;<br/>    index_a++)<br/>    {</span><span id="11dd" class="kg kh hu kc b fv km kj l kk kl">if(L[index_l]&lt;R[index_r])<br/>        {</span><span id="6d50" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = L[index_l];<br/>            index_l += 1;</span><span id="1a51" class="kg kh hu kc b fv km kj l kk kl">}<br/>        else<br/>        {</span><span id="f75c" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = R [index_r];<br/>            index_r += 1;</span><span id="3694" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="c0e6" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="5303" class="kg kh hu kc b fv km kj l kk kl">while (index_l &lt; size_left)<br/>    {</span><span id="3674" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = L [index_l];<br/>        index_l += 1;<br/>        index_a += 1;</span><span id="62e4" class="kg kh hu kc b fv km kj l kk kl">}<br/>     while (index_r &lt; size_right)<br/>    {</span><span id="b596" class="kg kh hu kc b fv km kj l kk kl">ara[index_a] = R [index_r];<br/>        index_r += 1;<br/>        index_a += 1;</span><span id="ec36" class="kg kh hu kc b fv km kj l kk kl">}</span><span id="8fbd" class="kg kh hu kc b fv km kj l kk kl">}<br/>int main()<br/>{</span><span id="9613" class="kg kh hu kc b fv km kj l kk kl">int i, n = 7;<br/>    int ara[] = {8,3,2,9,7,1,5,4};<br/>    cout&lt;&lt;"After merge sorting:"&lt;&lt;endl;<br/>    merge_sort(ara,0,n);<br/>    for(i=0; i&lt;=n; i++)<br/>    {</span><span id="0d0e" class="kg kh hu kc b fv km kj l kk kl">cout&lt;&lt;ara[i]&lt;&lt;endl;</span><span id="76d2" class="kg kh hu kc b fv km kj l kk kl">}<br/>    return 0;</span><span id="c254" class="kg kh hu kc b fv km kj l kk kl">}</span></pre><p id="8d53" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将得到如下输出:</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/ffeba2812939ba3375e0f5708405450d.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*1XkvF-qR1eGstxuwp_12fw.png"/></div></figure><p id="83a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">合并排序的复杂度:</strong></p><p id="fab4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里，我们将数组分为两部分。所以它的复杂性在于</p><p id="bcd1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">o(日志<em class="ko"> n </em>)。但是我们也合并了他们。对于merge()函数，复杂度是O( <em class="ko"> n </em>)。</p><p id="7344" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以归并排序的复杂度是O((log <em class="ko"> n </em> ) x <em class="ko"> n </em>)或者O( <em class="ko"> n </em> log <em class="ko"> n)。</em></p><p id="3d4c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">编码快乐！</p><p id="0d51" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">参考:</strong></p><p id="43d0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae kp" href="http://dimik.pub/book/245/computer-programming-3-data-structure-algorithm-by-tamim-shahriar" rel="noopener ugc nofollow" target="_blank">电脑编程</a>由<a class="kq kr gr" href="https://medium.com/u/efa50d3355e6?source=post_page-----11c673470427--------------------------------" rel="noopener" target="_blank">塔米姆·沙里亚尔·苏宾</a></p><p id="b79a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">迪米克的孟加拉语编程书籍改变了我的生活。</p><p id="e79c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">感谢<a class="kq kr gr" href="https://medium.com/u/efa50d3355e6?source=post_page-----11c673470427--------------------------------" rel="noopener" target="_blank">塔米姆·沙里亚·苏宾</a>瓦伊亚:)</p></div></div>    
</body>
</html>