<html>
<head>
<title>Build a chat app using ASP.NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ASP建立一个聊天应用程序。网</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-chat-app-using-asp-net-b6804d0bf794?source=collection_archive---------5-----------------------#2018-06-18">https://medium.com/hackernoon/build-a-chat-app-using-asp-net-b6804d0bf794?source=collection_archive---------5-----------------------#2018-06-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="3b58" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">要阅读本教程，需要对C#和jQuery有基本的了解。</p></blockquote><p id="01d6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们当今时代的交流主要是数字化的，而最流行的数字化交流形式是即时通讯。</p><p id="af54" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">一些应用程序包括某种形式的聊天工具，如Slack或脸书。在本教程中，我们将考虑如何使用C# .NET构建一个聊天应用程序。</p><p id="4670" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">要完成本教程，您需要:</p><ul class=""><li id="56ce" class="jw jx hu ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke dt translated">Visual Studio，一个广泛用于构建的IDE。NET项目。点击查看安装详情<a class="ae kf" href="https://www.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="a0a2" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">C#基础知识。</li><li id="b88b" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">的基本知识。净MVC。</li><li id="c66e" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">JavaScript (jQuery)基础知识。</li></ul><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff kl"><img src="../Images/75640600f1a9d1a88b1e41b1bc4dbdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jSFxKlmzi0fgPLgk.gif"/></div></div></figure><h1 id="95f9" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">设置我们的聊天项目</h1><p id="7960" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">使用我们的Visual Studio IDE，我们将按照<strong class="ix hv">新建项目</strong>向导创建我们的聊天项目。</p><p id="f58f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将:</p><ul class=""><li id="6bf1" class="jw jx hu ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke dt translated">将C#设为我们要使用的语言。</li><li id="98b8" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">选择。NET MVC项目作为模板。</li><li id="67c0" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">填写项目名称，例如HeyChat。</li><li id="1ff2" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">填写解决方案名称，即应用程序名称。</li></ul><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff ma"><img src="../Images/eec1ced5bdbd0bf26a2b015a15a2a69f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jBcNmHtqo6xeSJvd.gif"/></div></div></figure><h1 id="8efb" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">创建我们的聊天应用</h1><h1 id="672d" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">定义页面和路线</h1><p id="5cfa" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">出于本教程的目的，我们的聊天应用程序将由2个页面组成:</p><ul class=""><li id="8bab" class="jw jx hu ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke dt translated">首页——用户注册的地方。</li><li id="3f83" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">聊天视图—用户在这里选择一个联系人并交换消息。</li></ul><p id="8d3c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了实现这些观点，我们将需要以下途径:</p><ul class=""><li id="03d0" class="jw jx hu ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke dt translated">呈现首页的路线。</li><li id="84f5" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">实现登录的路径。</li><li id="e497" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">呈现聊天页面的路径。</li></ul><blockquote class="ir is it"><p id="a43d" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡这些路由仅呈现视图并实现用户登录。我们会继续增加更多的路线。</em></p></blockquote><p id="e908" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">将这些路线添加到我们的<code class="eh mb mc md me b">RouteConfig.cs</code>文件中，我们将得到:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="ab24" class="mj ky hu me b fv mk ml l mm mn">routes.MapRoute(<br/>        name: "Home",<br/>        url: "",<br/>        defaults: new { controller = "Home", action = "Index" }<br/>    );</span><span id="d7ea" class="mj ky hu me b fv mo ml l mm mn">    routes.MapRoute(<br/>        name: "Login",<br/>        url: "login",<br/>        defaults: new { controller = "Auth", action = "Login" }<br/>    );</span><span id="0af5" class="mj ky hu me b fv mo ml l mm mn">    routes.MapRoute(<br/>        name: "ChatRoom",<br/>        url: "chat",<br/>        defaults: new { controller = "Chat", action="Index"}<br/>    );</span></pre><p id="61d3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这些路线定义规定了路线模式和处理它的<strong class="ix hv">控制器</strong>和<strong class="ix hv">动作</strong>。</p><blockquote class="ir is it"><p id="58b6" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡用Visual Studio创建我们的项目会自动创建带有</em> <code class="eh mb mc md me b"><em class="hu">Index</em></code> <em class="hu">动作的</em> <code class="eh mb mc md me b"><em class="hu">HomeContoller.cs</em></code> <em class="hu">文件。我们将用它作为回家的路线。</em></p></blockquote><p id="bfa0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在我们的<code class="eh mb mc md me b">HomeController.cs</code>中，我们将呈现首页，用户可以用它登录:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="2141" class="mj ky hu me b fv mk ml l mm mn">//HomeController.cs</span><span id="2b8d" class="mj ky hu me b fv mo ml l mm mn">    // ...<br/>    Using System.Web.Mvc;<br/>    // ...<br/>    public class HomeController : Controller<br/>    {<br/>        public ActionResult Index()<br/>        {<br/>            if ( Session["user"] != null ) {<br/>                return Redirect("/chat");<br/>            }</span><span id="2633" class="mj ky hu me b fv mo ml l mm mn">            return View();<br/>        }<br/>    }</span></pre><blockquote class="ir is it"><p id="0c95" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡函数</em> <code class="eh mb mc md me b"><em class="hu">View</em></code> <em class="hu">创建一个我们返回的视图响应。当它被调用时，C#寻找调用控制器类的默认视图。该默认视图是在视图目录中找到的</em> <code class="eh mb mc md me b"><em class="hu">index.cshtml</em></code> <em class="hu">文件，该目录与控制器同名，即HomeController类的默认视图将是</em> <code class="eh mb mc md me b"><em class="hu">Views/Home/index.cshtml</em></code> <em class="hu">文件。</em></p></blockquote><h1 id="3d49" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">建立我们的数据库</h1><p id="13bb" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">为了实现我们的登录功能，我们需要一个数据库来存储用户。有几个数据库驱动程序可供选择，但是在本教程中，我们将使用MySQL数据库驱动程序和一个名为实体框架的. NET ORM。</p><p id="74d8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将从通过NuGet安装<code class="eh mb mc md me b">MySql.Data.Entities</code>包开始。NET的包管理器)。然后，我们将通过NuGet安装<strong class="ix hv">实体框架</strong>包，为我们提供ORM功能。</p><blockquote class="ir is it"><p id="d383" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡要使用NuGet安装软件包，请在我们的项目解决方案中右键单击packages文件夹。选择</em> <code class="eh mb mc md me b"><em class="hu">Add Package</em></code> <em class="hu">选项；并搜索和选择您想要的包。</em></p></blockquote><p id="3134" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">一旦我们的包被安装，我们将开始设置我们的数据库连接和通信。</p><p id="2b46" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，我们将把数据库连接凭证添加到解决方案文件夹中的<code class="eh mb mc md me b">Web.config</code>文件中。在<code class="eh mb mc md me b">Web.config</code>中，我们将添加:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="1550" class="mj ky hu me b fv mk ml l mm mn">&lt;connectionStrings&gt;<br/>        &lt;add name="YourConnectionName" connectionString="Server=localhost;Database=database_name;Uid=root;Pwd=YourPassword;" providerName="MySql.Data.MySqlClient" /&gt;<br/>    &lt;/connectionStrings&gt;</span></pre><blockquote class="ir is it"><p id="d82d" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️您需要用实际值数据库值替换上面代码片段中的占位符值。</em></p></blockquote><p id="d0db" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><code class="eh mb mc md me b">Web.config</code>文件是一个<strong class="ix hv"> XML </strong>文件，上面的<code class="eh mb mc md me b">connectionStrings</code>元素将被添加到文件的<code class="eh mb mc md me b">configuration</code>元素体中。</p><p id="00e1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们将在我们的解决方案文件夹中创建一个<code class="eh mb mc md me b">Models</code>文件夹(与<code class="eh mb mc md me b">Controllers</code>在同一文件夹级别)。在这个文件夹中，我们将创建我们的模型类——这个类代表了我们的表。对于登录特性，我们将创建<code class="eh mb mc md me b">User.cs</code>文件。在这个类文件中，我们将添加模型的属性:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="2efa" class="mj ky hu me b fv mk ml l mm mn">// File: User.cs file</span><span id="d459" class="mj ky hu me b fv mo ml l mm mn">    using System;<br/>    using System.Collections.Generic;<br/>    namespace HeyChat.Models<br/>    {<br/>        public class User<br/>        {<br/>            public User()<br/>            {<br/>            }</span><span id="a7c5" class="mj ky hu me b fv mo ml l mm mn">            public int id { get; set; }<br/>            public string name { get; set; }<br/>            public DateTime created_at { get; set; }<br/>        }<br/>    }</span></pre><blockquote class="ir is it"><p id="0898" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡要创建一个模型类，右击模型文件夹，选择</em> <code class="eh mb mc md me b"><em class="hu">Add</em></code> <em class="hu">和</em> <code class="eh mb mc md me b"><em class="hu">New File</em></code> <em class="hu">选项，然后在</em> <code class="eh mb mc md me b"><em class="hu">Empty Class</em></code> <em class="hu">选项中填入类名。</em></p></blockquote><p id="ea26" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们的<code class="eh mb mc md me b">User</code>模型为我们的users表定义了唯一标识ID、用户名和用户的创建日期。</p><p id="83db" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，我们将添加数据库上下文类。这个类读入我们在<code class="eh mb mc md me b">Web.config</code>文件中定义的数据库连接配置，并获取它应该应用配置的模型类(数据集)。</p><p id="a593" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将在我们的<code class="eh mb mc md me b">Models</code>文件夹中创建我们的上下文类，遵循创建一个新的空类的相同步骤，我们将它命名为<code class="eh mb mc md me b">ChatContext.cs</code>。在其中，我们将添加以下内容:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="aa6b" class="mj ky hu me b fv mk ml l mm mn">// File: ChatContext.cs</span><span id="e29b" class="mj ky hu me b fv mo ml l mm mn">    using System;<br/>    using System.Data.Entity;<br/>    namespace HeyChat.Models<br/>    {<br/>        public class ChatContext: DbContext<br/>        {<br/>            public ChatContext() : base("YourConnectionName")<br/>            {<br/>            }</span><span id="bf7a" class="mj ky hu me b fv mo ml l mm mn">            public static ChatContext Create()<br/>            {<br/>                return new ChatContext();<br/>            }</span><span id="1192" class="mj ky hu me b fv mo ml l mm mn">            public DbSet&lt;User&gt; Users { get; set; }<br/>        }<br/>    }</span></pre><blockquote class="ir is it"><p id="02d7" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡我们正在使用代码优先的方法实现实体框架ORM。这种方法包括编写定义模型(表)的代码，而不需要任何现有的数据库或表。使用这种方法，当我们的应用程序代码被执行时，数据库和表将被创建。</em></p></blockquote><h1 id="8086" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">登录我们的用户</h1><p id="4885" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">由于我们的数据库连接和模型(尽管随着我们的深入，可能会引入更多的模型)已经创建，我们可以继续我们的登录功能。</p><p id="2d9e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">从<code class="eh mb mc md me b">HomeController</code>呈现的首页将包含一个接受用户名的表单。此表单将提交给<code class="eh mb mc md me b">/`</code>登录<code class="eh mb mc md me b">route which we defined earlier. Following our route definition, this request will be handled by the</code> AuthController <code class="eh mb mc md me b">and its</code>登录`操作方法。</p><p id="d08e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将创建<code class="eh mb mc md me b">AuthController</code>类，并添加用于存储或检索用户详细信息的代码。存储或检索的选项将基于用户名是否已经存在于我们的<code class="eh mb mc md me b">Users</code>表中。<code class="eh mb mc md me b">AuthController</code>的代码如下:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="4eff" class="mj ky hu me b fv mk ml l mm mn">// File: AuthController</span><span id="6e98" class="mj ky hu me b fv mo ml l mm mn">    // ...<br/>    using HeyChat.Models;<br/>    public class AuthController : Controller<br/>    {<br/>        [HttpPost]<br/>        public ActionResult Login()<br/>        {<br/>            string user_name = Request.Form["username"];</span><span id="9377" class="mj ky hu me b fv mo ml l mm mn">            if (user_name.Trim() == "") {<br/>                return Redirect("/");<br/>            }</span><span id="5dde" class="mj ky hu me b fv mo ml l mm mn">            using (var db = new Models.ChatContext()) {</span><span id="e5c8" class="mj ky hu me b fv mo ml l mm mn">                User user = db.Users.FirstOrDefault(u =&gt; u.name == user_name);</span><span id="b99f" class="mj ky hu me b fv mo ml l mm mn">                if (user == null) {<br/>                    user = new User { name = user_name };</span><span id="5125" class="mj ky hu me b fv mo ml l mm mn">                    db.Users.Add(user);<br/>                    db.SaveChanges();<br/>                }</span><span id="3488" class="mj ky hu me b fv mo ml l mm mn">                Session["user"] = user;<br/>            }</span><span id="67fb" class="mj ky hu me b fv mo ml l mm mn">            return Redirect("/chat");<br/>        }<br/>    }</span></pre><p id="d257" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们使用这个名称检查用户是否存在。如果存在，我们检索用户的详细信息，如果不存在，我们首先创建一个新记录。然后，我们将用户的详细信息分配到一个<code class="eh mb mc md me b">session</code>对象中，供整个应用程序使用。最后，我们将用户重定向到聊天页面。</p><h1 id="7639" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">呈现聊天页面</h1><p id="ff92" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">大多数聊天应用程序的一个特点是能够选择和谁聊天。出于本教程的目的，我们将假设所有注册用户可以互相聊天，因此我们的聊天页面将提供与存储在我们数据库中的任何用户聊天的可能性。</p><p id="aa0c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">前面，我们定义了我们的聊天路线，并将其分配给了<code class="eh mb mc md me b">ChatController</code>类及其<code class="eh mb mc md me b">Index</code>动作方法。</p><p id="4228" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们创建<code class="eh mb mc md me b">ChatController</code>并实现包含可用联系人的聊天页面的呈现。将下面的代码粘贴到<code class="eh mb mc md me b">ChatController</code>中:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="6aae" class="mj ky hu me b fv mk ml l mm mn">// File: ChatController</span><span id="859f" class="mj ky hu me b fv mo ml l mm mn">    // ...<br/>    using HeyChat.Models;</span><span id="13bf" class="mj ky hu me b fv mo ml l mm mn">    namespace HeyChat.Controllers<br/>    {<br/>        public class ChatController : Controller<br/>        {<br/>            public ActionResult Index()<br/>            {<br/>                if (Session["user"] == null) {<br/>                    return Redirect("/");<br/>                }</span><span id="7300" class="mj ky hu me b fv mo ml l mm mn">                var currentUser = (Models.User) Session["user"];</span><span id="8a8b" class="mj ky hu me b fv mo ml l mm mn">                using ( var db = new Models.ChatContext() ) {</span><span id="509f" class="mj ky hu me b fv mo ml l mm mn">                    ViewBag.allUsers = db.Users.Where(u =&gt; u.name != currentUser.name )<br/>                                     .ToList();<br/>                }<br/></span><span id="3a63" class="mj ky hu me b fv mo ml l mm mn">                ViewBag.currentUser = currentUser;<br/></span><span id="2771" class="mj ky hu me b fv mo ml l mm mn">                return View ();<br/>            }<br/>        }<br/>    }</span></pre><p id="9e6e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了获得可用的联系人，我们读取数据库中除当前用户之外的所有用户。使用<code class="eh mb mc md me b">ViewBag</code>将这些用户传递到我们的客户端。我们还使用<code class="eh mb mc md me b">ViewBag</code>传递当前用户。</p><p id="bab1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，我们已经将所有可用的联系人检索到了<code class="eh mb mc md me b">ViewBag</code>对象中，我们将创建用于向用户显示这些联系人和聊天页面其余部分的标记。为了创建我们聊天页面的视图文件，我们在<code class="eh mb mc md me b">Views</code>文件夹中创建了一个<code class="eh mb mc md me b">Chat</code>文件夹。</p><p id="ec76" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来右击<code class="eh mb mc md me b">Chat</code>文件夹，选择选项<code class="eh mb mc md me b">Add</code> → <code class="eh mb mc md me b">Views</code>，选择Razor模板引擎，命名文件<code class="eh mb mc md me b">index.cshtml</code>。将下面的代码粘贴到文件中:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="096b" class="mj ky hu me b fv mk ml l mm mn">&lt;!DOCTYPE html&gt;<br/>    &lt;html&gt;<br/>      &lt;head&gt;<br/>        &lt;title&gt;pChat &amp;mdash; Private Chatroom&lt;/title&gt;<br/>        &lt;link rel="stylesheet" href="@Url.Content("~/Content/app.css")"&gt;<br/>      &lt;/head&gt;<br/>      &lt;body&gt;<br/>        &lt;!-- Navigation Bar --&gt;<br/>        &lt;nav class="navbar navbar-inverse"&gt;<br/>          &lt;div class="container-fluid"&gt;<br/>            &lt;div class="navbar-header"&gt;<br/>              &lt;a class="navbar-brand" href="#"&gt;pChat - @ViewBag.currentUser.name &lt;/a&gt;<br/>            &lt;/div&gt;<br/>            &lt;ul class="nav navbar-nav navbar-right"&gt;<br/>              &lt;li&gt;&lt;a href="#"&gt;Log Out&lt;/a&gt;&lt;/li&gt;<br/>            &lt;/ul&gt;<br/>          &lt;/div&gt;<br/>        &lt;/nav&gt;<br/>        &lt;!-- / Navigation Bar --&gt;<br/>        &lt;div class="container"&gt;<br/>          &lt;div class="row"&gt;<br/>            &lt;div class="col-xs-12 col-md-3"&gt;<br/>              &lt;aside class="main visible-md visible-lg"&gt;<br/>                &lt;div class="row"&gt;<br/>                  &lt;div class="col-xs-12"&gt;<br/>                    &lt;div class="panel panel-default users__bar"&gt;<br/>                      &lt;div class="panel-heading users__heading"&gt;<br/>                        Contacts (@ViewBag.allUsers.Count)<br/>                      &lt;/div&gt;<br/>                      &lt;div class="__no__chat__"&gt;<br/>                          &lt;p&gt;Select a contact to chat with&lt;/p&gt;<br/>                      &lt;/div&gt;<br/>                      &lt;div class="panel-body users__body"&gt;<br/>                        &lt;ul id="contacts" class="list-group"&gt;</span><span id="ecf8" class="mj ky hu me b fv mo ml l mm mn">                        @foreach( var user in @ViewBag.allUsers ) {<br/>                            &lt;a class="user__item contact-@user.id" href="#" data-contact-id="@user.id" data-contact-name="@user.name"&gt;<br/>                                &lt;li&gt;<br/>                                  &lt;div class="avatar"&gt;<br/>                                     &lt;img src="@Url.Content("~/Content/no_avatar.png")"&gt;<br/>                                  &lt;/div&gt;<br/>                                  &lt;span&gt;@user.name&lt;/span&gt;<br/>                                  &lt;div class="status-bar"&gt;&lt;/div&gt;<br/>                                &lt;/li&gt;<br/>                            &lt;/a&gt;<br/>                        }<br/>                        &lt;/ul&gt;<br/>                      &lt;/div&gt;<br/>                    &lt;/div&gt;<br/>                  &lt;/div&gt;<br/>                &lt;/div&gt;<br/>              &lt;/aside&gt;<br/></span><span id="c4ff" class="mj ky hu me b fv mo ml l mm mn">            &lt;/div&gt;<br/>            &lt;div class="col-xs-12 col-md-9 chat__body"&gt;<br/>              &lt;div class="row"&gt;<br/>                &lt;div class="col-xs-12"&gt;<br/>                  &lt;ul class="list-group chat__main"&gt;</span><span id="7bc7" class="mj ky hu me b fv mo ml l mm mn">                  &lt;/ul&gt;<br/>                &lt;/div&gt;<br/>                &lt;div class="chat__type__body"&gt;<br/>                  &lt;div class="chat__type"&gt;<br/>                    &lt;textarea id="msg_box" placeholder="Type your message"&gt;&lt;/textarea&gt;<br/>                    &lt;button class="btn btn-primary" id="sendMessage"&gt;Send&lt;/button&gt;<br/>                  &lt;/div&gt;<br/>                &lt;/div&gt;<br/>                &lt;div class="chat__typing"&gt;<br/>                  &lt;span id="typerDisplay"&gt;&lt;/span&gt;<br/>                &lt;/div&gt;<br/>              &lt;/div&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;script src="@Url.Content("~/Content/app.js")"&gt;&lt;/script&gt;<br/>      &lt;/body&gt;<br/>    &lt;/html&gt;</span></pre><blockquote class="ir is it"><p id="9e14" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡</em><a class="ae kf" href="mailto:`@Url.Content" rel="noopener ugc nofollow" target="_blank"><em class="hu">` @网址。内容</em></a><em class="hu">(" ~/Content/app . CSS ")</em><code class="eh mb mc md me b"><em class="hu">and</em></code><em class="hu">@ Url。Content(" ~/Content/app . js ")</em><code class="eh mb mc md me b"><em class="hu">load some previously bundled JavaScript and CSS dependencies such as jQuery and Bootstrap from our</em></code><em class="hu">Content `文件夹。</em></p></blockquote><p id="910a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在我们的视图文件中，我们创建了一个侧边栏，并遍历传递给<code class="eh mb mc md me b">ViewBag</code>的用户，使用Razor的<code class="eh mb mc md me b">@foreach</code>指令来指示可用的联系人。我们还添加了一个文本区域来输入和发送消息给这些联系人。</p><h1 id="58a6" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">选择联系人和发送信息</h1><p id="515f" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">当我们的用户选择一个联系人进行聊天时，我们希望检索用户和所选联系人之间以前的消息。为了实现这一点，我们需要一个用于存储用户间消息的表和这个表的模型。</p><p id="4e93" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们在<code class="eh mb mc md me b">Models</code>文件夹中创建一个名为<code class="eh mb mc md me b">Conversations</code>的模型。它将由唯一的<code class="eh mb mc md me b">id</code>、<code class="eh mb mc md me b">sender_id</code>、<code class="eh mb mc md me b">receiver_id</code>、<code class="eh mb mc md me b">message</code>、<code class="eh mb mc md me b">status</code>和<code class="eh mb mc md me b">created_at</code>日期组成。该模型的代码如下:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="7a55" class="mj ky hu me b fv mk ml l mm mn">// File: Conversation.cs</span><span id="230a" class="mj ky hu me b fv mo ml l mm mn">    using System;<br/>    namespace HeyChat.Models<br/>    {<br/>        public class Conversation<br/>        {<br/>            public Conversation()<br/>            {<br/>                status = messageStatus.Sent;<br/>            }</span><span id="7b2f" class="mj ky hu me b fv mo ml l mm mn">            public enum messageStatus<br/>            {<br/>                Sent, <br/>                Delivered<br/>            }</span><span id="dfc7" class="mj ky hu me b fv mo ml l mm mn">            public int id { get; set; }<br/>            public int sender_id { get; set; }<br/>            public int receiver_id { get; set; }<br/>            public string message { get; set; }<br/>            public messageStatus status { get; set; }<br/>            public DateTime created_at { get; set; }<br/>        }<br/>    }</span></pre><p id="319b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">创建完<code class="eh mb mc md me b">Conversation</code>模型后，我们将把它添加到<code class="eh mb mc md me b">ChatContext</code>文件中，如下所示:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="8717" class="mj ky hu me b fv mk ml l mm mn">// File: ChatContext.cs<br/>    using System;<br/>    using System.Data.Entity;</span><span id="0c50" class="mj ky hu me b fv mo ml l mm mn">    namespace HeyChat.Models<br/>    {<br/>        public class ChatContext: DbContext<br/>        {<br/>            public ChatContext() : base("MySqlConnection")<br/>            {<br/>            }</span><span id="d511" class="mj ky hu me b fv mo ml l mm mn">            public static ChatContext Create()<br/>            {<br/>                return new ChatContext();<br/>            }</span><span id="0f65" class="mj ky hu me b fv mo ml l mm mn">            public DbSet&lt;User&gt; Users { get; set; }<br/>            public DbSet&lt;Conversation&gt; Conversations { get; set; }<br/>        }<br/>    }</span></pre><p id="44cd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了检索这些消息，我们将为<code class="eh mb mc md me b">/contact`</code> /conversations/{contact} `创建一条路由。该路由将接受联系人ID，检索当前用户和联系人之间的消息，然后在JSON响应中返回消息。</p><p id="4ea8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">由<code class="eh mb mc md me b">ConversationWithContact</code>动作方法中的<code class="eh mb mc md me b">ChatController</code>处理，如下图所示:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="2840" class="mj ky hu me b fv mk ml l mm mn">//ChatController.cs</span><span id="82de" class="mj ky hu me b fv mo ml l mm mn">    ...<br/>    public JsonResult ConversationWithContact(int contact)<br/>    {<br/>        if (Session["user"] == null)<br/>        {<br/>            return Json(new { status = "error", message = "User is not logged in" });<br/>        }</span><span id="8382" class="mj ky hu me b fv mo ml l mm mn">        var currentUser = (Models.User)Session["user"];</span><span id="e8ab" class="mj ky hu me b fv mo ml l mm mn">        var conversations = new List&lt;Models.Conversation&gt;();</span><span id="1109" class="mj ky hu me b fv mo ml l mm mn">        using (var db = new Models.ChatContext())<br/>        {<br/>            conversations = db.Conversations.<br/>                              Where(c =&gt; (c.receiver_id == currentUser.id <br/>                                  &amp;&amp; c.sender_id == contact) || <br/>                                  (c.receiver_id == contact <br/>                                  &amp;&amp; c.sender_id == currentUser.id))<br/>                              .OrderBy(c =&gt; c.created_at)<br/>                              .ToList();<br/>        }</span><span id="acc0" class="mj ky hu me b fv mo ml l mm mn">        return Json(<br/>            new { status = "success", data = conversations }, <br/>            JsonRequestBehavior.AllowGet<br/>        );<br/>    }</span></pre><p id="c868" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在我们有了检索旧消息的路径，我们将使用一些jQuery来选择用户、获取消息并在页面上显示它们。在我们的视图文件中，我们将创建一个<code class="eh mb mc md me b">script</code>标签来保存JavaScript和jQuery函数。在其中，我们将添加:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="bfb1" class="mj ky hu me b fv mk ml l mm mn">...<br/>    &lt;script&gt;<br/>    let currentContact = null; // Holds current contact<br/>    let newMessageTpl = <br/>    `&lt;div&gt;<br/>        &lt;div id="msg-{{id}}" class="row __chat__par__"&gt;<br/>          &lt;div class="__chat__"&gt;<br/>            &lt;p&gt;{{body}}&lt;/p&gt;<br/>            &lt;p class="delivery-status"&gt;Delivered&lt;/p&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>     &lt;/div&gt;`;<br/>    ...<br/>    // select contact to chat with<br/>    $('.user__item').click( function(e) {<br/>        e.preventDefault();</span><span id="ad21" class="mj ky hu me b fv mo ml l mm mn">        currentContact = {<br/>            id: $(this).data('contact-id'),<br/>            name: $(this).data('contact-name'),<br/>        };</span><span id="c78b" class="mj ky hu me b fv mo ml l mm mn">        $('#contacts').find('li').removeClass('active');</span><span id="2336" class="mj ky hu me b fv mo ml l mm mn">        $('#contacts .contact-' + currentContact.id).find('li').addClass('active');<br/>        getChat(currentContact.id);<br/>    });</span><span id="69c5" class="mj ky hu me b fv mo ml l mm mn">    // get chat data        <br/>    function getChat( contact_id ) {<br/>        $.get("/contact/conversations/" + contact_id )<br/>         .done( function(resp) {         <br/>            var chat_data = resp.data || [];<br/>            loadChat( chat_data );         <br/>         });<br/>    }</span><span id="1806" class="mj ky hu me b fv mo ml l mm mn">    //load chat data into view<br/>    function loadChat( chat_data ) {</span><span id="5b41" class="mj ky hu me b fv mo ml l mm mn">        chat_data.forEach( function(data) {<br/>            displayMessage(data);<br/>        });</span><span id="f412" class="mj ky hu me b fv mo ml l mm mn">        $('.chat__body').show();<br/>        $('.__no__chat__').hide();<br/>    }</span><span id="50f3" class="mj ky hu me b fv mo ml l mm mn">    function displayMessage( message_obj ) {<br/>        const msg_id = message_obj.id;<br/>        const msg_body = message_obj.message;</span><span id="9b03" class="mj ky hu me b fv mo ml l mm mn">        let template = $(newMessageTpl).html();</span><span id="55ce" class="mj ky hu me b fv mo ml l mm mn">        template = template.replace("{{id}}", msg_id);<br/>        template = template.replace("{{body}}", msg_body);</span><span id="419c" class="mj ky hu me b fv mo ml l mm mn">        template = $(template);</span><span id="f7ee" class="mj ky hu me b fv mo ml l mm mn">        if ( message_obj.sender_id == @ViewBag.currentUser.id ) {<br/>            template.find('.__chat__').addClass('from__chat');<br/>        } else {<br/>            template.find('.__chat__').addClass('receive__chat');<br/>        }</span><span id="ad97" class="mj ky hu me b fv mo ml l mm mn">        if ( message_obj.status == 1 ) {<br/>            template.find('.delivery-status').show();<br/>        }</span><span id="5695" class="mj ky hu me b fv mo ml l mm mn">        $('.chat__main').append(template);<br/>    }</span></pre><p id="548c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">既然选择一个联系人可以检索以前的消息，我们需要用户能够发送新消息。为了实现这一点，我们将创建一个路由，该路由接受正在发送的消息并将其保存到数据库中，然后使用一些jQuery从<code class="eh mb mc md me b">textarea</code>字段中读取消息文本并发送到该路由。</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="08be" class="mj ky hu me b fv mk ml l mm mn">//RouteConfig.cs</span><span id="c513" class="mj ky hu me b fv mo ml l mm mn">    ...<br/>    routes.MapRoute(<br/>        name: "SendMessage",<br/>        url: "send_message",<br/>        defaults: new { controller = "Chat", action = "SendMessage" }<br/>    );</span></pre><p id="d678" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">根据<code class="eh mb mc md me b">RouteConfig</code>文件规定，该路线将由<code class="eh mb mc md me b">ChatController</code>的<code class="eh mb mc md me b">SendMessage</code>动作方式处理。</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="ffb8" class="mj ky hu me b fv mk ml l mm mn">//ChatController.cs</span><span id="cdf3" class="mj ky hu me b fv mo ml l mm mn">    ...<br/>    [HttpPost]<br/>    public JsonResult SendMessage() <br/>    {<br/>        if (Session["user"] == null)<br/>        {<br/>            return Json(new { status = "error", message = "User is not logged in" });<br/>        }</span><span id="aeda" class="mj ky hu me b fv mo ml l mm mn">        var currentUser = (User)Session["user"];</span><span id="c18b" class="mj ky hu me b fv mo ml l mm mn">        string socket_id = Request.Form["socket_id"];</span><span id="73e0" class="mj ky hu me b fv mo ml l mm mn">        Conversation convo = new Conversation<br/>        {<br/>            sender_id = currentUser.id,<br/>            message = Request.Form["message"],<br/>            receiver_id = Convert.ToInt32(Request.Form["contact"])<br/>        };</span><span id="3a47" class="mj ky hu me b fv mo ml l mm mn">        using ( var db = new Models.ChatContext() ) {<br/>            db.Conversations.Add(convo);<br/>            db.SaveChanges();<br/>        }</span><span id="244a" class="mj ky hu me b fv mo ml l mm mn">        return Json(convo);<br/>    }</span></pre><h1 id="c870" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">添加实时功能</h1><p id="da1f" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">聊天应用程序有几个需要实时功能的特性，其中包括:</p><ul class=""><li id="67bf" class="jw jx hu ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke dt translated">接收实时发送的消息。</li><li id="e9fc" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">收到即将响应的通知——“用户正在输入”功能。</li><li id="beba" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">正在获取邮件传递状态。</li><li id="e5ac" class="jw jx hu ix b iy kg jc kh jt ki ju kj jv kk js kb kc kd ke dt translated">联系人离线或在线时的即时通知。</li></ul><p id="5958" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了实现这些功能，我们将使用<a class="ae kf" href="http://pusher.com" rel="noopener ugc nofollow" target="_blank">推杆</a>。要继续，让我们前往推动器<a class="ae kf" href="https://dashboard.pusher.com/" rel="noopener ugc nofollow" target="_blank">仪表板</a>并创建一个应用程序。如果你没有帐号，你可以免费注册。用要求的信息填写创建应用程序表单。接下来，我们将使用NuGet在C#代码中安装<strong class="ix hv"> Pusher Server </strong>包。</p><p id="b5a7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了实现我们所说的一些实时特性，我们需要能够在客户端触发事件。为了在这个应用程序中触发客户端事件，我们将使用私有通道。</p><p id="6286" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当联系人被选中时，我们将创建我们的私人频道。该通道将用于在登录用户和他正在发送消息的联系人之间传输消息。</p><p id="dc3c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">私有通道需要来自服务器端代码的认证端点可用，因为当通道被实例化时，推送器将尝试认证客户端对通道的有效访问。</p><p id="0fff" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">Pusher认证请求的默认路由是<code class="eh mb mc md me b">/pusher/auth</code>，因此我们将创建该路由并实施认证。</p><p id="2be6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，在我们的<code class="eh mb mc md me b">RouteConfig.cs</code>文件中，我们将添加路线定义:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="3767" class="mj ky hu me b fv mk ml l mm mn">routes.MapRoute(<br/>        name: "PusherAuth",<br/>        url:  "pusher/auth",<br/>        defaults: new { controller = "Auth", action = "AuthForChannel"}<br/>    );</span></pre><p id="8a3f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后，正如我们上面所定义的，在<code class="eh mb mc md me b">AuthController</code>类文件中，我们将创建<code class="eh mb mc md me b">AuthForChannel</code>动作方法并添加:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="45de" class="mj ky hu me b fv mk ml l mm mn">public JsonResult AuthForChannel(string channel_name, string socket_id)<br/>    {<br/>        if (Session["user"] == null)<br/>        {<br/>            return Json(new { status = "error", message = "User is not logged in" });<br/>        }<br/>        var currentUser = (Models.User)Session["user"];</span><span id="6907" class="mj ky hu me b fv mo ml l mm mn">        var options = new PusherOptions();<br/>        options.Cluster = "PUSHER_APP_CLUSTER";</span><span id="8441" class="mj ky hu me b fv mo ml l mm mn">        var pusher = new Pusher(<br/>        "PUSHER_APP_ID",<br/>        "PUSHER_APP_KEY",<br/>        "PUSHER_APP_SECRET", options);</span><span id="ca5f" class="mj ky hu me b fv mo ml l mm mn">        if (channel_name.IndexOf(currentUser.id.ToString()) == -1)<br/>        {<br/>            return Json(<br/>              new { status = "error", message = "User cannot join channel" }<br/>            );<br/>        }</span><span id="bfad" class="mj ky hu me b fv mo ml l mm mn">        var auth = pusher.Authenticate(channel_name, socket_id);</span><span id="ca52" class="mj ky hu me b fv mo ml l mm mn">        return Json(auth);<br/>    }</span></pre><p id="d355" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们的身份验证端点，如上所述，接受客户机的通道名和套接字ID，它们是由Pusher在连接尝试时发送的。</p><blockquote class="ir is it"><p id="172e" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡我们将使用对话参与者(即发送者和接收者)的id来命名我们的私有通道。我们将用它来限制消息向不在特定对话中的Messenger应用程序的其他用户传播。</em></p></blockquote><p id="4817" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">使用。NET库，我们通过传递通道名和套接字ID来验证用户。然后，我们通过JSON返回身份验证的结果对象。</p><p id="8f18" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">有关客户活动和私人渠道的更多信息，请查看推手<a class="ae kf" href="https://pusher.com/docs/client_api_guide/client_presence_channels" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><blockquote class="ir is it"><p id="ab15" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡客户端事件只能由私有通道或存在通道触发。</em></p></blockquote><p id="d1da" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在视图的脚本部分，我们将实例化私有通道的变量。我们还将调整我们的联系人选择片段，以创建发送消息、输入和发送通知的渠道:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="d7fa" class="mj ky hu me b fv mk ml l mm mn">...<br/>    &lt;script&gt;<br/>    ...</span><span id="2395" class="mj ky hu me b fv mo ml l mm mn">    let currentContact = null; // Holds contact currently being chatted with<br/>    let socketId = null;<br/>    let currentconversationChannel = null;<br/>    let conversationChannelName = null;</span><span id="d81a" class="mj ky hu me b fv mo ml l mm mn">    //Pusher client side setup<br/>    const pusher = new Pusher('PUSHER_APP_ID', {<br/>        cluster:'PUSHER_APP_CLUSTER'<br/>    });</span><span id="a699" class="mj ky hu me b fv mo ml l mm mn">    pusher.connection.bind('connected', function() {<br/>      socketId = pusher.connection.socket_id;<br/>    });</span><span id="9995" class="mj ky hu me b fv mo ml l mm mn">    // select contact to chat with<br/>    $('.user__item').click( function(e) {<br/>        e.preventDefault();</span><span id="d46d" class="mj ky hu me b fv mo ml l mm mn">        currentContact = {<br/>            id: $(this).data('contact-id'),<br/>            name: $(this).data('contact-name'),<br/>        };</span><span id="b3e4" class="mj ky hu me b fv mo ml l mm mn">        if ( conversationChannelName ) {<br/>            pusher.unsubscribe( conversationChannelName );<br/>        }</span><span id="1b50" class="mj ky hu me b fv mo ml l mm mn">        conversationChannelName = getConvoChannel( <br/>                                      (@ViewBag.currentUser.id * 1) ,  <br/>                                      (currentContact.id * 1) <br/>                                  );</span><span id="adf8" class="mj ky hu me b fv mo ml l mm mn">        currentconversationChannel = pusher.subscribe(conversationChannelName);</span><span id="b966" class="mj ky hu me b fv mo ml l mm mn">        bind_client_events();</span><span id="e0f3" class="mj ky hu me b fv mo ml l mm mn">        $('#contacts').find('li').removeClass('active');</span><span id="fad2" class="mj ky hu me b fv mo ml l mm mn">        $('#contacts .contact-' + currentContact.id).find('li').addClass('active');<br/>        getChat(currentContact.id);<br/>    });</span><span id="102a" class="mj ky hu me b fv mo ml l mm mn">    function getConvoChannel(user_id, contact_id) {<br/>        if ( user_id &gt; contact_id ) {<br/>            return 'private-chat-' + contact_id + '-' + user_id;<br/>        }</span><span id="b26b" class="mj ky hu me b fv mo ml l mm mn">        return 'private-chat-' + user_id + '-' + contact_id;<br/>    }</span><span id="b22c" class="mj ky hu me b fv mo ml l mm mn">    function bind_client_events(){<br/>      //bind private channel events here  </span><span id="c790" class="mj ky hu me b fv mo ml l mm mn">      currentconversationChannel.bind("new_message", function(msg) {<br/>          //add code here<br/>      });</span><span id="e5a3" class="mj ky hu me b fv mo ml l mm mn">      currentconversationChannel.bind("message_delivered", function(msg) {<br/>          $('#msg-' + msg.id).find('.delivery-status').show();<br/>      });<br/>    }</span></pre><p id="c4d1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们还将用于连接通道的<code class="eh mb mc md me b">socket_id</code>保存在一个变量中。这个以后会派上用场的。</p><h2 id="c8ac" class="mj ky hu bd kz mp mq mr ld ms mt mu lh jt mv mw ll ju mx my lp jv mz na lt nb dt translated">接收实时发送的消息</h2><p id="4591" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">之前，我们添加了一个路由来保存作为用户和联系人之间的对话发送的消息。</p><p id="b899" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">但是，在保存这些消息后，我们希望将这些消息添加到用户和联系人的屏幕上。</p><p id="f385" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了实现这一点，在我们的C#代码中，在存储消息后，我们将通过Pusher私有通道触发一个事件。然后，我们的客户将监听这些事件，并通过将它们携带的消息添加到屏幕上来响应它们。</p><p id="245f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在我们的<code class="eh mb mc md me b">ChatController</code>类文件中，保存对话后我们将添加以下内容:</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="93db" class="mj ky hu me b fv mk ml l mm mn">private Pusher pusher;</span><span id="700d" class="mj ky hu me b fv mo ml l mm mn">    //class constructor<br/>    public ChatController() <br/>    {<br/>        var options = new PusherOptions();<br/>        options.Cluster = "PUSHER_APP_CLUSTER";</span><span id="0125" class="mj ky hu me b fv mo ml l mm mn">        pusher = new Pusher(<br/>           "PUSHER_APP_ID",<br/>           "PUSHER_APP_KEY",<br/>           "PUSHER_APP_SECRET",<br/>           options<br/>       );<br/>    }</span><span id="4ed2" class="mj ky hu me b fv mo ml l mm mn">    [HttpPost]<br/>    public JsonResult SendMessage() <br/>    {<br/>        if (Session["user"] == null)<br/>        {<br/>            return Json(new { status = "error", message = "User is not logged in" });<br/>        }</span><span id="9ff0" class="mj ky hu me b fv mo ml l mm mn">        var currentUser = (User)Session["user"];</span><span id="66fb" class="mj ky hu me b fv mo ml l mm mn">        string socket_id = Request.Form["socket_id"];</span><span id="fd25" class="mj ky hu me b fv mo ml l mm mn">        Conversation convo = new Conversation<br/>        {<br/>            sender_id = currentUser.id,<br/>            message = Request.Form["message"],<br/>            receiver_id = Convert.ToInt32(Request.Form["contact"])<br/>        };</span><span id="f478" class="mj ky hu me b fv mo ml l mm mn">        using ( var db = new Models.ChatContext() ) {<br/>            db.Conversations.Add(convo);<br/>            db.SaveChanges();<br/>        }</span><span id="1141" class="mj ky hu me b fv mo ml l mm mn">        var conversationChannel = getConvoChannel( currentUser.id, contact);</span><span id="d416" class="mj ky hu me b fv mo ml l mm mn">        pusher.TriggerAsync(<br/>          conversationChannel,<br/>          "new_message",<br/>          convo,<br/>          new TriggerOptions() { SocketId = socket_id });</span><span id="0d3a" class="mj ky hu me b fv mo ml l mm mn">        return Json(convo);<br/>    }</span><span id="4a70" class="mj ky hu me b fv mo ml l mm mn">    private String getConvoChannel(int user_id, int contact_id)<br/>    {<br/>        if (user_id &gt; contact_id)<br/>        {<br/>            return "private-chat-" + contact_id + "-" + user_id;<br/>        }</span><span id="2cc6" class="mj ky hu me b fv mo ml l mm mn">        return "private-chat-" + user_id + "-" + contact_id;<br/>    }</span></pre><p id="9746" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">为了利用Pusher服务器端功能，我们将把<code class="eh mb mc md me b">using PusherServer;</code>添加到控制器文件的顶部。</p><blockquote class="ir is it"><p id="f7ac" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡我们在发送消息时接受了用户的</em> <code class="eh mb mc md me b"><em class="hu">socket_id</em></code> <em class="hu">。这样，我们可以指定发送者可以免于收听他们广播的事件。</em></p></blockquote><p id="e9d9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在我们看来，我们将监听<code class="eh mb mc md me b">new_message</code>事件，并使用它向我们的视图添加新消息。</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="9f3e" class="mj ky hu me b fv mk ml l mm mn">//index.cshtml</span><span id="4a77" class="mj ky hu me b fv mo ml l mm mn">    ...<br/>    &lt;script&gt;<br/>    ...<br/>    //Send button's click event<br/>    $('#sendMessage').click( function() {<br/>        $.post("/send_message", {<br/>            message: $('#msg_box').val(),<br/>            contact: currentContact.id,<br/>            socket_id: socketId,<br/>        }).done( function (data) {<br/>            //display the message immediately on the view of the sender<br/>            displayMessage(data); <br/>            $('#msg_box').val('');<br/>        });<br/>    });</span><span id="7e0b" class="mj ky hu me b fv mo ml l mm mn">    function bind_client_events(){<br/>        //listening to the message_sent event by the message's recipient<br/>        currentconversationChannel.bind("new_message", function(msg) {<br/>                if ( msg.receiver_id == @ViewBag.currentUser.id ) {<br/>                    displayMessage(msg);<br/>                }<br/>        });<br/>    }</span></pre><h2 id="124b" class="mj ky hu bd kz mp mq mr ld ms mt mu lh jt mv mw ll ju mx my lp jv mz na lt nb dt translated">实现打字指示器功能</h2><p id="40c4" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">此功能使用户意识到对话是活动的，并且正在键入响应。为了实现这一点，我们将监听消息文本区域的<code class="eh mb mc md me b">keyup</code>事件，当这个<code class="eh mb mc md me b">keyup</code>事件发生时，我们将触发一个名为<code class="eh mb mc md me b">client-is-typing</code>的客户端事件。</p><pre class="km kn ko kp fq mf me mg mh aw mi dt"><span id="02ba" class="mj ky hu me b fv mk ml l mm mn">// index.cshtml</span><span id="af22" class="mj ky hu me b fv mo ml l mm mn">    function bind_client_events(){<br/>        currentconversationChannel.bind("client-is-typing", function(data) {<br/>            if ( data.user_id == currentContact.id &amp;&amp; <br/>                 data.contact_id == @ViewBag.currentUser.id  ) {</span><span id="1724" class="mj ky hu me b fv mo ml l mm mn">                $('#typerDisplay').text( currentContact.name + ' is typing...');</span><span id="5612" class="mj ky hu me b fv mo ml l mm mn">                $('.chat__typing').fadeIn(100, function() {<br/>                    $('.chat__type__body').addClass('typing_display__open');<br/>                }).delay(1000).fadeOut(300, function(){<br/>                    $('.chat__type__body').removeClass('typing_display__open');<br/>                });<br/>            }<br/>        });</span><span id="f1ef" class="mj ky hu me b fv mo ml l mm mn">        ...<br/>    }</span><span id="9c15" class="mj ky hu me b fv mo ml l mm mn">    //User is typing<br/>    var isTypingCallback = function() {<br/>        chatChannel.trigger("client-is-typing", {<br/>            user_id: @ViewBag.currentUser.id,<br/>            contact_id: currentContact.id,<br/>        });<br/>    };</span><span id="dec0" class="mj ky hu me b fv mo ml l mm mn">    $('#msg_box').on('keyup',isTypingCallback);<br/>    ...</span></pre><h1 id="928a" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">结论</h1><p id="3b66" class="pw-post-body-paragraph iu iv hu ix b iy lv ja jb jc lw je jf jt lx ji jj ju ly jm jn jv lz jq jr js hn dt translated">在jQuery的帮助下，我们用C#构建了一个聊天应用程序，并使用Pusher实现了一些聊天应用程序中常见的实时特性。</p><p id="e468" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这个帖子最早发布给<a class="ae kf" href="https://pusher.com/tutorials/chat-aspnet/" rel="noopener ugc nofollow" target="_blank">推手</a>。</p></div></div>    
</body>
</html>