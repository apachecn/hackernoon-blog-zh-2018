<html>
<head>
<title>Treat Your Tests Like Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像对待代码一样对待你的测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/treat-your-tests-like-your-code-64a6e3841268?source=collection_archive---------30-----------------------#2018-06-18">https://medium.com/hackernoon/treat-your-tests-like-your-code-64a6e3841268?source=collection_archive---------30-----------------------#2018-06-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4f7767e896c8c72c026491faf5eb0277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KA2adVc1nlSDu4oF-gVRLQ.jpeg"/></div></div></figure><p id="4fc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一名多年的<a class="ae ka" href="https://hackernoon.com/tagged/developer" rel="noopener ugc nofollow" target="_blank">开发者</a>，我注意到了一个模式。这种模式与单元测试有关。尤其是那些写单元测试的人。我注意到的是，很多开发人员并不像对待他们的(生产)代码那样对待他们的单元测试。也就是说，他们低估了单元测试的工程化程度，最终得到了无法调试的不可读的测试，并且没有人理解什么是测试<a class="ae ka" href="https://hackernoon.com/tagged/testing" rel="noopener ugc nofollow" target="_blank">测试</a>。</p><h1 id="6984" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用构造函数</h1><p id="7564" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您在生产代码中使用DI(依赖注入),您的测试代码通常需要大量的设置。我们都看到了这种混乱。new x()；new y()；new z()；最终，您得到的设置只需要半个页面。但是，幸运的是，有一些模式可以解决这个问题。我喜欢在尽可能少的地方使用构造函数的规则。这意味着，你应该钻研你的模式书，从使用构建器模式开始。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3829" class="ln kc hu lj b fv lo lp l lq lr">public class RepositoryBuilder<br/>{<br/>    public RepositoryBuilder()<br/>    {<br/>        DbConnection = new MockDbConnection();<br/>    }</span><span id="6773" class="ln kc hu lj b fv ls lp l lq lr">public IDbConnection DbConnection { get; set; }</span><span id="84e5" class="ln kc hu lj b fv ls lp l lq lr">public Repository Build()<br/>    {<br/>        return new Repository(DbConnection);<br/>    }<br/>}</span></pre><p id="d3a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你不必遵循上面所说的，但基本上，这将抽象出构造函数并为你设置一些默认值。如果需要测试DbConnection和存储库之间的特定行为，可以自己设置DbConnection。现在您的测试将如下所示，您甚至可以更进一步。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="430a" class="ln kc hu lj b fv lo lp l lq lr">[TestFixture]<br/>public class RepositoryTests<br/>{<br/>    [Test]<br/>    public void CanGetDataFromRepository()<br/>    {<br/>        var repository = new RepositoryBuilder().Build();<br/>        var expectedData = CreateExpectedData();</span><span id="7b5c" class="ln kc hu lj b fv ls lp l lq lr">var data = repository.GetData();</span><span id="a787" class="ln kc hu lj b fv ls lp l lq lr">data.ShouldBe(expectedData);<br/>    }<br/>}</span></pre><p id="8a79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以看到代码是可读的。不再有构造函数的复制+粘贴，这意味着当你重构的时候——会很容易，因为你只需要改变一个地方。现在，我并不是说这个规则是100%正确的，但是当你可以将你的测试从实现中分离出来一点点的时候，它会让你的生活变得更加容易。</p><h1 id="9d1f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">保持简单愚蠢</h1><p id="c0f1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">不要试图在一个单元测试中测试多个东西。如果你的方法不止做一件事，那么也许是时候考虑重构这个方法了。但是不用担心！救援马上就到。您可以编写多个单元测试，在您的方法中测试不同的东西。也许你有一个装饰器，你想测试你添加的东西是否有效，你是否还在调用你正在装饰的类。没关系！分两次单元测试就行了。</p><h1 id="dec3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">嘲弄的</h1><p id="44d6" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我喜欢嘲笑班级的行为。比起创建存根类，我更喜欢它。外面有成吨的嘲讽框架。对于你选择的语言，可能会有一个嘲讽的框架。对于C#，我喜欢使用Moq——但是如果有人能推荐一个更好的模拟框架——我会支持它。对于JS——你可以从我之前的帖子中看到我喜欢Jest。它能做我们需要的一切。</p><h1 id="6445" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">流畅的语法/方法链接</h1><p id="9fe4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我喜欢断言和构建器的流畅语法。它有助于创建一个故事，任何阅读测试的人都可以跟随和理解，而不必查看代码。但是你可能会走得太远——有时候就是这样。我见过人们为“给定/何时/然后”现象而疯狂。一个例子:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d140" class="ln kc hu lj b fv lo lp l lq lr">[Test]<br/>public void DocusignTest()<br/>{<br/>    Given.ADocuSignService<br/>        .ThatReturnsInvalidTempResult().GetDocuSignURL(Given.AHotelId)<br/>        .ShouldNotBeNullOrEmpty();<br/>}</span></pre><p id="ea69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的:它是可读的</p><ul class=""><li id="1c7e" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">是的:可以理解。</li><li id="d429" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">是的:很短。</li></ul><p id="3b8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，缺点是:</p><ul class=""><li id="99b9" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">没有:它在测试什么？</li><li id="0039" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">否:我在哪里调试？</li><li id="0a91" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">否:我无法浏览这个测试并了解其内部工作原理。我必须仔细检查每一种方法，找出每一种方法的作用。</li></ul><p id="9482" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我更喜欢“安排、行动、断言”的语法。你做你设置(安排)。您调用有问题的方法(act)。你决定真相(断言)。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="cdd3" class="ln kc hu lj b fv lo lp l lq lr">[Test]<br/>public void DocusignTest()<br/>{<br/>    // arrange<br/>    var service = Given.ADocuSignService.ThatReturnsInvalidTempResult();</span><span id="6a69" class="ln kc hu lj b fv ls lp l lq lr">// act  <br/>    var result = service.GetDocuSignURL(Given.AHotelId);</span><span id="6b4d" class="ln kc hu lj b fv ls lp l lq lr">// assert<br/>    result.ShouldNotBeNullOrEmpty();<br/>}</span></pre><p id="36c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我觉得这比第一个例子更容易理解。也许你不知道？让我知道你如何组织你的测试。</p><p id="f6db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望你能从这篇简短的介绍中学到一点东西来改进你的测试。总而言之，使用构建器(或类似的东西)将你的测试从你测试的对象的变化中分离出来。这会让你的重构变得更加容易。保持你的测试简单。一次测试一件事。试试嘲讽！这将节省您创建存根。最后，尝试流畅的语法——只是不要太过火。</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><p id="4f99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mo">原载于2018年6月18日</em><a class="ae ka" href="https://www.alexaitken.nz/blog/treat-your-tests-like-your-code/" rel="noopener ugc nofollow" target="_blank"><em class="mo">www . alexaitken . NZ</em></a><em class="mo">。</em></p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure></div></div>    
</body>
</html>