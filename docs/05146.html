<html>
<head>
<title>Debugging with Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Git调试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/debugging-with-git-b18600bbaa96?source=collection_archive---------33-----------------------#2018-06-18">https://medium.com/hackernoon/debugging-with-git-b18600bbaa96?source=collection_archive---------33-----------------------#2018-06-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="45f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您从事一个大型项目时，您可能会发现代码中的错误，这些错误会阻止您继续开发。如何修复它们？</p><p id="0af1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以从手动查看提交历史开始，但是这将是一个非常乏味的过程。令人欣慰的是，Git有多个工具<strong class="it hv">可以帮助你在出错时寻找bug或罪魁祸首。</strong></p><h1 id="eed5" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">责备</h1><p id="70aa" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><code class="eh ks kt ku kv b">$ git blame &lt;file_path/file_name&gt;</code><br/><code class="eh ks kt ku kv b"><strong class="it hv">git blame</strong></code><a class="ae kw" href="https://kolosek.com/git-commands-tutorial-part2/" rel="noopener ugc nofollow" target="_blank">命令</a>帮助您在项目的<strong class="it hv">特定文件</strong>中找到创建导致bug的特定代码行的提交。它还确定了提交的作者，使得询问关于代码的更多信息变得更加容易。</p><p id="bc5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用-L选项来限制行输出范围。</p><pre class="kx ky kz la fq lb kv lc ld aw le dt"><span id="40a6" class="lf jq hu kv b fv lg lh l li lj">$ git blame -L 11,21 new_file<br/>^95d69a196b5c7 (Jhon Smith 2018-05-18 13:04:22 +0200 11) def new ^95d69a196b5c7 (Jhon Smith 2018-05-18 13:04:22 +0200 12) @article =<br/>Article.new<br/>^95d69a196b5c7 (Jhon Smith 2018-05-18 13:04:22 +0200 13) end 3171aa2dbbce7 (David Smith 2018-05-16 18:21:30 +0200 14) def edit 3171aa2dbbce7 (David Smith 2018-05-16 18:21:30 +0200 15) @article = Article.find(params[:id])<br/>3171aa2dbbce7 (David Smith 2018-05-16 18:21:30 +0200 16) end ^95d69a196b5c7 (Jhon Smith 2018-05-18 13:04:22 +0200 17) def create 3171aa2dbbce7 (David Smith 2018-05-16 18:21:30 +0200 18) @article = Article.new(article_params)<br/>^95d69a196b5c7 (Jhon Smith 2018-05-18 13:04:22 +0200 19) if @article.save<br/>^95d69a196b5c7 (Jhon Smith 2018-05-18 13:04:22 +0200 20) redirect_to @article<br/>^95d69a196b5c7 (Jhon Smith 2018-05-18 13:04:22 +0200 21) else</span></pre><p id="2dd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过跟踪提交的<strong class="it hv">部分SHA-1 </strong>,您可以很容易地看到谁、何时以及如何修改了特定的代码行。注意，<code class="eh ks kt ku kv b">^</code>前缀显示了在初始提交中创建的行，并且从那以后一直保持不变。</p><blockquote class="lk ll lm"><p id="cb9e" class="ir is ln it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated"><em class="hu">使用</em> <code class="eh ks kt ku kv b"><a class="ae kw" href="https://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git#_file_annotation" rel="noopener ugc nofollow" target="_blank"><em class="hu">-C</em></a></code> <a class="ae kw" href="https://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git#_file_annotation" rel="noopener ugc nofollow" target="_blank"> <em class="hu">选项</em> </a> <em class="hu">找出代码片段最初来自哪里，如果它们是从别处复制的。它告诉您原始作者并提交，而不管后来做了什么重构。</em></p><p id="7d40" class="ir is ln it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated"><code class="eh ks kt ku kv b"><em class="hu">$ git blame -L -C 11,21 &lt;file_path/file_name&gt;</em></code></p></blockquote><p id="a971" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ks kt ku kv b">git blame</code>当你能假设问题的原因时会有帮助。如果您不知道如何回到工作状态，该怎么办？这就是<code class="eh ks kt ku kv b">git bisect</code>发挥作用的地方。</p><h1 id="b8d4" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">Git平分</h1><p id="e487" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">一个<code class="eh ks kt ku kv b"><strong class="it hv">git bisect</strong></code>是一个<a class="ae kw" href="https://kolosek.com/rails-debugging/" rel="noopener ugc nofollow" target="_blank">调试工具</a>，用于通过做一个<a class="ae kw" href="https://labs.consol.de/development/git/2018/01/12/automated-debugging-with-git.html" rel="noopener ugc nofollow" target="_blank">自动二分搜索法</a>来找出哪个具体的提交在项目中引入了一个bug或者问题。您不知道项目中的哪个文件包含bug。</p><p id="c746" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您不知道什么正在中断，并且自从您知道代码工作的最后一个状态以来已经有一堆提交，您可能会求助于<code class="eh ks kt ku kv b">git bisect</code>。</p><figure class="kx ky kz la fq ls fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/d1ff5106649aae0259f6c9d9743484e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*-Xp-uTVBvP3vyNri.png"/></div></figure><p id="fce7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ks kt ku kv b">git bisect</code>所做的是，它将<a class="ae kw" href="https://kolosek.com/git-branches/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> git提交树</strong> </a>分成“好的”、无错误提交和“坏的”提交，通过用<strong class="it hv">二分搜索法</strong>测试它们。基于测试的结果，Git浏览最近的提交，识别它们，直到找到问题的根源。这就是所谓的二分搜索法算法。</p><blockquote class="lk ll lm"><p id="afcb" class="ir is ln it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated"><em class="hu">如果你有多个bug，你需要对每个bug进行二分搜索法。</em></p></blockquote><h1 id="1415" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">这是如何工作的？</h1><ol class=""><li id="69d9" class="lv lw hu it b iu kn iy ko jc lx jg ly jk lz jo ma mb mc md dt translated">首先，让我们从二分搜索法模式开始寻找一个bug: <code class="eh ks kt ku kv b">$ git bisect start</code>。</li><li id="7641" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">接下来，您需要寻找一个一切都还在工作的提交。为此，让我们检查一下<strong class="it hv">提交历史</strong>以找到您需要的:<code class="eh ks kt ku kv b">$ git log --oneline</code>。</li></ol><p id="4a47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">oneline选项仅显示git提交的名称。</p><pre class="kx ky kz la fq lb kv lc ld aw le dt"><span id="f2f0" class="lf jq hu kv b fv lg lh l li lj">$ git log --oneline<br/>f11c599 Removed unnecessary lines<br/>95d69a1 Added article tests<br/>3171aa2 Enabled editing articles<br/>95d69a1 Added articles</span></pre><ol class=""><li id="0e89" class="lv lw hu it b iu iv iy iz jc mj jg mk jk ml jo ma mb mc md dt translated"><strong class="it hv">标签</strong>最老的“好”犯SHA-1: <code class="eh ks kt ku kv b">$ git bisect good 95d69a1</code>。</li><li id="7d3a" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">在分配了“好”标签之后，您需要找到一个<strong class="it hv">“坏”提交</strong>来划分提交树，Git可以在其中应用二分搜索法算法。既然您知道最近的提交有错误，那么您将把它指定为“坏的”提交:<code class="eh ks kt ku kv b">$ git bisect bad f11c599</code>。</li><li id="0bcd" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">一旦您为您的搜索指定了初始和最终指针，Git将带您浏览<a class="ae kw" href="https://kolosek.com/git-branches/" rel="noopener ugc nofollow" target="_blank">提交历史</a>，并标记“好的”和“坏的”提交。</li><li id="c731" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo ma mb mc md dt translated">这个过程一直持续到您成功地找到第一个“坏的”提交，即您的问题的原因。现在您可以通过执行:<code class="eh ks kt ku kv b">$ git bisect reset</code>来退出git二分搜索法模式。</li></ol><h1 id="eecd" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">Git Grep</h1><p id="ef3a" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><code class="eh ks kt ku kv b">$ git grep &lt;keyword&gt;</code>它避免了搜索<code class="eh ks kt ku kv b">.gitignore</code>文件。</p><blockquote class="lk ll lm"><p id="d0a7" class="ir is ln it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated"><em class="hu"> GREP代表</em><strong class="it hv"><em class="hu">G</em></strong><em class="hu">lobal</em><strong class="it hv"><em class="hu">R</em></strong><em class="hu">egular</em><strong class="it hv"><em class="hu">E</em></strong><em class="hu">xpression</em><strong class="it hv"><em class="hu">P</em></strong><em class="hu">rint。</em></p></blockquote><p id="f9f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">附加选项:</strong></p><ul class=""><li id="4679" class="lv lw hu it b iu iv iy iz jc mj jg mk jk ml jo mm mb mc md dt translated"><code class="eh ks kt ku kv b">-n</code>或<code class="eh ks kt ku kv b">--line-number</code>:打印出Git找到匹配的行号。</li><li id="4445" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo mm mb mc md dt translated"><code class="eh ks kt ku kv b">-i</code>或<code class="eh ks kt ku kv b">--ignore-case</code>:忽略被搜索关键字和文件之间的大小写差异。</li><li id="f9c7" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo mm mb mc md dt translated"><code class="eh ks kt ku kv b">-c</code>或<code class="eh ks kt ku kv b">--count</code>:显示在文件中找到的与输入关键字匹配的次数。</li><li id="bea6" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo mm mb mc md dt translated"><code class="eh ks kt ku kv b">-p</code>或<code class="eh ks kt ku kv b">--show-function</code>:显示被搜索关键字的上下文。</li><li id="75f0" class="lv lw hu it b iu me iy mf jc mg jg mh jk mi jo mm mb mc md dt translated"><code class="eh ks kt ku kv b">--and</code>:确保同一行文本中有多个匹配项。</li></ul><p id="33c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你知道错误代码在哪里，那么<code class="eh ks kt ku kv b">git blame</code>是一个很好的工具。另一方面，如果您的存储库相当大，有大量的提交历史，很难发现错误，那么可以使用<code class="eh ks kt ku kv b">git bisect</code>。或者您可以使用<code class="eh ks kt ku kv b">git grep</code>在项目中搜索字符串或正则表达式。</p><p id="7cd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">三个调试工具，有三种不同的方法，以各自独特的方式解决您的问题。目前为止你遇到的是哪一个？分享一下你的经验！</p><p id="5869" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢您的阅读！</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="c106" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ln">原载于2018年6月18日kolosek.com</em><a class="ae kw" href="https://kolosek.com/debugging-with-git/?utm_source=me" rel="noopener ugc nofollow" target="_blank"><em class="ln"/></a><em class="ln">。</em></p></div></div>    
</body>
</html>