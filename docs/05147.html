<html>
<head>
<title>Contributing to GHC 2: Basic Hacking and Organization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贡献给GHC 2:基本黑客和组织</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/contributing-to-ghc-2-basic-hacking-and-organization-8959c1df1d76?source=collection_archive---------34-----------------------#2018-06-18">https://medium.com/hackernoon/contributing-to-ghc-2-basic-hacking-and-organization-8959c1df1d76?source=collection_archive---------34-----------------------#2018-06-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0d69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周，我们向GHC迈出了第一步，Glasgow Haskell编译器。我们总结了构建它所需要安装的包和工具。我们甚至在windows笔记本电脑相当恶劣的环境中也做到了这一点。但是，在一天结束时，我们现在可以用<code class="eh jq jr js jt b">make</code>构建项目，并创建我们本地版本的GHC。</p><p id="9d6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本周，我们将通过查看我们可以对编译器进行的一个非常简单的更改来建立我们的开发周期。我们还将讨论存储库的架构，以便下周我们可以做一些更酷的更改。</p><p id="3dda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GHC是开源软件的一些令人敬畏的好处的真实见证。没有它，Haskell就不是同一种语言了。但是要理解GHC，您首先必须对Haskell本身有一个相当好的理解！如果你以前从未写过一行Haskell，看看我们的<a class="ae jp" href="https://www.mmhaskell.com/liftoff" rel="noopener ugc nofollow" target="_blank">启动系列</a>中关于如何开始的一些提示。你也可以下载我们的<a class="ae jp" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>。</p><p id="af17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能也听说过，虽然Haskell是一种简洁的语言，但从行业角度来看，它毫无用处。但是如果你看一下我们的<a class="ae jp" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>，你会发现有很多工具可以编写更有趣的Haskell程序！</p><h1 id="aa7a" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">入门指南</h1><p id="0c3e" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">让我们从用<code class="eh jq jr js jt b">Main.hs</code>编写一个非常简单的程序开始。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="460b" class="lf jv hu jt b fv lg lh l li lj">module Main where</span><span id="bccb" class="lf jv hu jt b fv lk lh l li lj">main :: IO ()<br/>main = do<br/>  putStrLn "Using GHC!"</span></pre><p id="c1ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以使用<code class="eh jq jr js jt b">ghc</code>命令将这个程序编译成可执行文件。我们从跑步开始:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="806c" class="lf jv hu jt b fv lg lh l li lj">ghc -o prog Main.hs</span></pre><p id="7c78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就创建了我们的可执行文件<code class="eh jq jr js jt b">prog.exe</code>(或者如果你没有使用Windows，就只创建<code class="eh jq jr js jt b">prog</code>)。然后我们可以像运行任何程序一样运行它:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="4bc3" class="lf jv hu jt b fv lg lh l li lj">./prog.exe<br/>Using GHC!</span></pre><p id="b547" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这是使用系统级GHC，我们必须安装，而建立它在本地！</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="3920" class="lf jv hu jt b fv lg lh l li lj">which ghc<br/>/mingw/bin/ghc</span></pre><p id="4798" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们构建GHC时，它为编译过程的每个阶段创建可执行文件。它在一个名为<code class="eh jq jr js jt b">ghc/inplace/bin</code>的目录中生成这些文件。所以我们可以创建一个别名来简化我们的工作。我们将把<code class="eh jq jr js jt b">lghc</code>写成一个“本地GHC”命令:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="84da" class="lf jv hu jt b fv lg lh l li lj">alias lghc="~/ghc/inplace/bin/ghc-stage2.exe -o prog"</span></pre><p id="6579" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将使我们能够用<code class="eh jq jr js jt b">lghc Main.hs</code>编译我们的单模块程序。</p><h1 id="e1c5" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">黑客等级0</h1><p id="9969" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">最终，我们希望能够验证我们的更改。因此，我们应该能够修改编译器，重新构建它，在我们的程序中使用它，然后看到我们的更改反映在代码中。测试编译器行为的一个简单方法是改变错误消息。例如，我们可以尝试导入一个不存在的模块:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="cb3e" class="lf jv hu jt b fv lg lh l li lj">module Main where</span><span id="eb34" class="lf jv hu jt b fv lk lh l li lj">import OtherModule (otherModuleString)</span><span id="eb8a" class="lf jv hu jt b fv lk lh l li lj">main :: IO ()<br/>main = do<br/>  putStrLn otherModuleString</span></pre><p id="d514" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，我们会得到一条错误消息:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="aa90" class="lf jv hu jt b fv lg lh l li lj">[1 of 1] Compiling Main (Main.hs, Main.o)</span><span id="f10d" class="lf jv hu jt b fv lk lh l li lj">Main.hs:3:1: error:<br/>    Could not find module 'OtherModule'<br/>    Use -v to see a list of the files search for.<br/>   |<br/>3  |import OtherModule (otherModuleString)<br/>   |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></pre><p id="d793" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们尝试更改此错误消息的文本。我们可以在代码库的<code class="eh jq jr js jt b">compiler</code>部分快速搜索这条消息，并找到它的定义位置:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="452b" class="lf jv hu jt b fv lg lh l li lj">cd ~/ghc/compiler<br/>grep -r "Could not find module" .<br/>./main/Finder.hs:cannotFindModule = cantFindErr (sLit "Could not find module")</span></pre><p id="27e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们继续将该字符串更新为稍有不同的内容:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="92aa" class="lf jv hu jt b fv lg lh l li lj">cannotFindModule :: DynFlags -&gt; ModuleName -&gt; FindResult -&gt; SDoc<br/>cannotFindModule = cantFindErr<br/>  (sLit "We were unable to locate the module")<br/>  (sLit "Ambiguous module name")</span></pre><p id="1c02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们继续重建，除了让我们使用上周的一些技术来使这个过程进行得更快一点。首先，我们将把<code class="eh jq jr js jt b">mk/build.mk.sample</code>复制到<code class="eh jq jr js jt b">mk/build.mk</code>。根据安装指南的建议，我们将取消对下面一行的注释:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="30e5" class="lf jv hu jt b fv lg lh l li lj">BuildFlavour=devel2</span></pre><p id="ce4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还将取消对<code class="eh jq jr js jt b">stage=2</code>行的注释。这将限制编译器只能构建编译器的最后阶段。它将跳过我们已经建立的阶段0和阶段1。</p><p id="636e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还将从<code class="eh jq jr js jt b">compiler</code>目录开始构建，而不是从根目录<code class="eh jq jr js jt b">ghc</code>开始。请注意，由于我们已经更改了构建文件，我们必须再次引导和配置。但是在我们重新编译之后，我们会发现我们有了新的错误信息！</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="1837" class="lf jv hu jt b fv lg lh l li lj">[1 of 1] Compiling Main (Main.hs, Main.o)</span><span id="dcc9" class="lf jv hu jt b fv lk lh l li lj">Main.hs:3:1: error:<br/>    We were unable to locate the module 'OtherModule'<br/>    Use -v to see a list of the files search for.<br/>   |<br/>3  |import OtherModule (otherModuleString)<br/>   |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></pre><h1 id="3a8e" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">一般建筑</h1><p id="43b7" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">下周，我们将对编译器进行更复杂的修改。但至少现在我们已经证实了我们可以正常发展。我们可以做一个改变，在很短的时间内编译，然后确定这个改变有所不同。但是现在让我们考虑一下GHC存储库的组织。这将帮助我们更多地思考我们将做出的改变的类型。我将借鉴西蒙·佩顿·琼斯和西蒙·马洛的描述。</p><p id="5acc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GHC代码库有三个主要部分。首先是编译器本身。编译器的工作是获取我们的Haskell源代码，并将其转换成机器可执行代码。下面是一个非常不完整的编译器任务列表</p><ol class=""><li id="4b9c" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">确定引用模块的位置</li><li id="9f1b" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">读取单个源文件</li><li id="ccad" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">将源代码分解成最简单的语法表示</li></ol><p id="2e0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后是开机部分。本节讨论编译器本身所依赖的库。它们包括像<code class="eh jq jr js jt b">Int</code>或<code class="eh jq jr js jt b">Data.Map</code>这样的低级类型。这一节稍微稳定一些，就不多看了。</p><p id="a471" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一个主要部分是运行时系统(RTS)。这将获取上面的编译器生成的代码，并确定如何运行它。这部分发生了很多神奇的事情，使得Haskell在并发性和并行性等任务上特别强大。它也是我们处理像垃圾收集这样的机制的地方。</p><p id="3dfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们会尽量把大部分时间花在<code class="eh jq jr js jt b">compiler</code>部分。编译管道有许多阶段，像类型检查和去糖。这将让我们专注于一个特定的阶段，并做出一个小小的改变。此外，运行时系统大部分是C代码，而大部分编译器是在Haskell本身！</p><h1 id="6531" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="e386" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">下周我们将会看到更多修改编译器的方法。在那之后，我们将开始研究GHC的实际问题，看看我们能做些什么来尝试解决它们！我们最终将在Github和Phabricator的提交过程中达到顶峰。</p><p id="8064" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想开始你的Haskell之旅，你应该阅读我们的<a class="ae jp" href="https://www.mmhaskell.com/liftoff" rel="noopener ugc nofollow" target="_blank">发射系列</a>！它将帮助你学习这种令人敬畏的语言的基础。更多更新，你也可以<a class="ae jp" href="https://www.mmhaskell.com/subscribe" rel="noopener ugc nofollow" target="_blank">订阅</a>我们的每月简讯！</p></div></div>    
</body>
</html>