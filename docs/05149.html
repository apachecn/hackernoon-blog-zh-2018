<html>
<head>
<title>RNN or Recurrent Neural Network for Noobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RNN或用于Noobs的递归神经网络</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rnn-or-recurrent-neural-network-for-noobs-a9afbb00e860?source=collection_archive---------0-----------------------#2018-06-19">https://medium.com/hackernoon/rnn-or-recurrent-neural-network-for-noobs-a9afbb00e860?source=collection_archive---------0-----------------------#2018-06-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7386" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">什么是递归神经网络或RNN，它如何工作，它可以用在哪里？本文试图回答以上问题。它还展示了一个用于特定目的的RNN的演示实现，但是您可以根据自己的需要对其进行概括。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/eb8382f2b0f8e4b7285657973fb1cbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*6xj691fPWf3S-mWUCbxSJg.jpeg"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">Recurrent Neural Network Architecture</figcaption></figure><p id="4ff1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">诀窍。Python，CNN知识是必须的。CNN被要求比较RNN为什么比CNN表现好，在哪里表现好？不需要理解数学。如果你想检查然后回到我以前的文章检查什么是CNN。</p><p id="aac7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将从“循环”这个词的用法开始。为什么叫反复发作？在英语中，单词recurrent的意思是:</p><blockquote class="kb kc kd"><p id="7a56" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">经常或重复发生的</p></blockquote><p id="5131" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种类型的神经网络的情况下，它被称为递归，因为它在连续输入集上反复进行相同的操作。我们将在本文后面讨论<em class="ke">操作</em>的含义。</p><h1 id="a312" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">我们为什么需要RNN？</h1><p id="2b0a" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">你现在可能在想，我们有性能非常好的普通网络，比如卷积网络。为什么我们需要另一种类型的网络？有一个非常特殊的用例需要rnn。为了解释RNNs，你需要首先理解一个叫做序列的东西。先说一下<strong class="it hv">序列</strong>。</p><p id="3fbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">序列是相互依赖的数据流(有限或无限)。例如时间序列数据、字符串的信息片段、对话等。在对话中，一个句子意味着一些东西，但整个对话流程大多意味着完全不同的东西。同样，在像股票市场数据这样的时间序列数据中，单个分笔成交点数据意味着当前价格，但一整天的数据将显示运动，并允许我们决定是买还是卖。</p><p id="bdaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当输入数据在序列模式中相互依赖时，CNN通常表现不佳。CNN在前一个输入和下一个输入之间没有任何关联。所以所有的输出都是独立的。CNN基于训练好的模型接收输入和输出。如果你运行100个不同的输入，没有一个会被之前的输出所影响。但是想象一下句子生成或文本翻译这样的场景。所有生成的单词都依赖于前面生成的单词(在某些情况下，它也依赖于后面的单词，但我们将在后面讨论)。所以你需要有一些基于你之前输出的偏差。这就是RNNs大放异彩的地方。rnn对数据序列中之前发生的事情有一定的记忆。这有助于系统获得上下文。理论上，rnn有无限的记忆，这意味着它们有能力无限地回顾过去。我所说的回顾是指所有以前的输入。但实际上他们只能回顾最后几步。<em class="ke">(我们稍后会讨论这个)</em></p><blockquote class="kb kc kd"><p id="ea26" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">只是为了与人类做一个总体上的关联，我们也不会就地做出决定。我们也将我们的决定建立在先前对这个主题的了解上。(*过于简化，很难说我能理解人类大脑的0.1% * *)</p></blockquote><h1 id="37a9" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">在哪里使用RNN？</h1><p id="ec61" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">RNNs可以用在很多不同的地方。下面是几个使用大量rnn的例子。</p><h2 id="e067" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jc ls lt kw jg lu lv la jk lw lx le ly dt translated">1.语言建模和生成文本</h2><p id="e121" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">给定一个单词序列，这里我们试图预测下一个单词的可能性。这对于翻译很有用，因为最有可能的句子是正确的。</p><h2 id="41a8" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jc ls lt kw jg lu lv la jk lw lx le ly dt translated">2.机器翻译</h2><p id="85d7" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">将文本从一种语言翻译成另一种语言使用一种或另一种形式的RNN。所有实用的日制系统都使用某种高级版本的RNN。</p><h2 id="0895" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jc ls lt kw jg lu lv la jk lw lx le ly dt translated">3.语音识别</h2><p id="5083" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">基于输入声波预测语音片段，从而形成单词。</p><h2 id="0fb4" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jc ls lt kw jg lu lv la jk lw lx le ly dt translated">4.生成图像描述</h2><p id="f9dc" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">一个非常大的用例是理解图像内部发生了什么，因此我们有一个很好的描述。这是CNN和RNN的合作项目。CNN做了分段，然后RNN用分段的数据重建描述。这是最基本的，但可能性是无限的。</p><h2 id="98d4" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jc ls lt kw jg lu lv la jk lw lx le ly dt translated">5.视频标记</h2><p id="3f10" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">这可以用于视频搜索，我们逐帧对视频进行图像描述。</p><h1 id="ad53" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">让我们深入挖掘！</h1><p id="ac94" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">我们将按照下面提到的主题顺序来完成文档。每一部分都建立在另一部分的基础上，所以不要将此作为参考。</p><ol class=""><li id="8036" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated">前馈网络</li><li id="3bef" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">循环网络</li><li id="da3a" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">回归神经元</li><li id="3466" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">穿越时间的反向传播(BPTT)</li><li id="0c9d" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">RNN实施</li></ol><h1 id="5a20" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">前馈网络入门</h1><p id="1237" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">前馈网络通过发生在网络每个节点的一系列操作来传递信息。前馈网络将信息直接通过每一层传递一次。这与其他循环网络不同。我们将在后面的章节中讨论它们。一般来说，前馈网络接受一个输入并从中产生一个输出。这也主要是一个监督学习步骤，其结果很可能是一个分类。它的行为类似于CNN的行为。输出可以预期是像猫或狗作为标签的类。</p><p id="ee3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据一组预先标记的数据训练前馈网络。训练阶段的目标是在前馈网络试图猜测类别时减少误差。训练完成后，权重用于对新批次的数据进行分类。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mn"><img src="../Images/69127c92648fb278270b5cdcea21a64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SL8FESMwzSy6QTrcIzcRYw.png"/></div></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">A typical feed-forward network architecture</figcaption></figure><p id="5731" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里需要注意一件重要的事情。在前馈网络中，无论在测试阶段向分类器显示什么图像，它都不会改变权重，因此第二个决定不受影响。这是前馈网络和递归网络之间的一个非常重要的区别。</p><blockquote class="kb kc kd"><p id="0036" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">与递归网络不同，前馈网络在测试时不会记住历史输入数据。</p></blockquote><p id="40a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这总是时间点的决定。他们只记得在训练阶段展示给他们的东西。</p><h1 id="2eaa" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">循环网络</h1><p id="5ace" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">另一方面，循环网络不仅将他们看到的当前输入实例作为输入，还将他们之前感知到的内容作为输入。</p><p id="a4bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们试着建立一个<a class="ae ms" href="https://en.wikipedia.org/wiki/Multilayer_perceptron" rel="noopener ugc nofollow" target="_blank">多层感知器</a>来开始解释。简单来说，有一个输入层，一个隐藏层，有一定的激活，最后我们得到一个输出。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/a75ee1ed976568ad10d616776843b43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*UXDlYTeJFlbq2an7MH1HbA.jpeg"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">A sample multi layer perceptron architecture</figcaption></figure><p id="191b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们在上面的例子中增加层数，输入层接受输入。然后，第一个隐藏层进行激活，传递到下一个隐藏层，依此类推。最后它到达输出层，输出层给出输出。每个隐藏层都有自己的权重和偏好。现在的问题是我们能否输入到隐藏层。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mu"><img src="../Images/d0ac489f54f91f98309283ef161ba769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8m2AxT3aH7bHfnnaMj8Ptw.jpeg"/></div></div></figure><p id="6cf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每一层都有自己的权重(W)、偏差(B)、激活函数(F)。这些层的行为不同，从技术上来说，将它们合并在一起具有挑战性。为了能够合并它们，让我们用相同的权重和偏差替换所有的层。它看起来会像这样。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mu"><img src="../Images/7d7e35f43052c6d007bcb39adc04343a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sL5dNMry95B_u4NLbuBNKg.jpeg"/></div></div></figure><p id="85aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以将所有的层合并在一起。所有隐藏层可以合并成一个单独的递归层。所以它们看起来有点像这样:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/bd9749b228493e782840e4602a3146f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*EHd7wwjnogvNvH9vHLp3Uw.jpeg"/></div></figure><p id="89c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在每一步为隐藏层提供输入。现在，递归神经元存储所有先前的阶跃输入，并将该信息与当前的阶跃输入合并。因此，它还捕获一些关于当前数据步骤和先前步骤之间的相关性的信息。在时间步长<code class="eh mw mx my mz b">t-1</code>的决定影响在时间<code class="eh mw mx my mz b">t</code>采取的决定。这很像我们人类在生活中做决定的方式。我们将当前的数据与最近的历史结合起来，以解决手头的特定问题。这个例子非常简单，但是原则上它符合我们的决策能力。<em class="ke">这真的激起了我的兴趣，我们人类是聪明的还是我们有非常先进的神经网络模型。我们的决定只是我们一生中收集的训练数据。因此，一旦我们有了一个相当先进的模型和系统，能够在合理的时间内存储和计算它们，我们就可以数字化我们的大脑。那么，当我们拥有比我们的大脑根据数百万人的数据训练更好更快的模型时，会发生什么呢？</em></p><blockquote class="kb kc kd"><p id="4192" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">另一篇<a class="ae ms" href="https://deeplearning4j.org/lstm.html" rel="noopener ugc nofollow" target="_blank">文章</a> : <strong class="it hv">一个人被自己的行为所困扰</strong></p></blockquote><p id="f6d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们回到手头的问题，用一个例子来重新表述上面的解释，来预测一系列字母之后的下一个字母是什么。想象中的单词<strong class="it hv"> namaskar </strong>。这个单词有8个字母。</p><blockquote class="kb kc kd"><p id="bb75" class="ir is ke it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">namaskar:一种传统的印度问候或尊敬的手势，将手掌放在脸或胸前并鞠躬。</p></blockquote><p id="4477" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们试图在7个字母输入网络后找出第8个字母，会发生什么。隐藏层将经历8次迭代。如果我们要展开这个网络，它将是一个8层的网络，每个字母一层。所以你可以想象一个正常的神经网络是重复多次的。你展开的次数与它能记住多远的过去直接相关。但稍后会详细介绍。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff na"><img src="../Images/bd9750f23aaa077516e219805f6daf12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_mM83sFLjzKt8cRB439Y3Q.gif"/></div></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">how recurrent neural networks work #deeplearning4j #dl4j</figcaption></figure><h1 id="3d5c" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">回归神经元</h1><p id="ea1c" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">在这里，我们将更深入地研究负责决策的实际神经元。我们将使用上面描述的<strong class="it hv"> namaskar </strong>例子。我们将尝试找出前7个字母中的第8个字母。输入数据的总词汇是{n，a，m，s，k，r}。在现实世界中，你会遇到更复杂的单词或句子。为了简单起见，我们将使用这个简单的词汇。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/bd9749b228493e782840e4602a3146f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*EHd7wwjnogvNvH9vHLp3Uw.jpeg"/></div></figure><p id="0a0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上图中，隐藏层或RNN块将一个公式应用于当前输入和先前状态。在这种情况下，namaste的字母<code class="eh mw mx my mz b">n</code>前面没有任何内容，所以我们将继续下一个字母<code class="eh mw mx my mz b">a</code>。在字母<code class="eh mw mx my mz b">a</code>和字母<code class="eh mw mx my mz b">n</code>的前一状态期间，隐藏层应用该公式。我们一会儿会讨论这个公式。输入通过网络时的每个状态都是一个时间步长或一个步长。所以如果在时间t，输入是<code class="eh mw mx my mz b">a</code>，那么在时间t-1，输入是<code class="eh mw mx my mz b">n</code>。将公式应用于<code class="eh mw mx my mz b">n</code>和<code class="eh mw mx my mz b">a</code>之后，我们得到一个新的状态。</p><p id="bb3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当前状态的公式可以写成这样:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/4bf44754f1d1990f9bac6db241eaabe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*cL2HAU5Q9qcwD-LKjgPdWw.png"/></div></figure><p id="e7c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mw mx my mz b">ht</code>是新状态，<code class="eh mw mx my mz b">ht-1</code>是先前状态。<code class="eh mw mx my mz b">xt</code>是时间<code class="eh mw mx my mz b">t</code>的输入。我们现在对之前的输入有了一种感觉，在它经历了之前时间步骤的相同公式之后。我们将对网络进行7次这样的输入，网络在每一步都经过相同的权重和相同的函数。</p><p id="79fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们尝试以简单的方式定义<code class="eh mw mx my mz b">f()</code>。我们将<code class="eh mw mx my mz b">tanh</code>作为激活函数。权重由矩阵<code class="eh mw mx my mz b">Whh</code>定义，输入由矩阵<code class="eh mw mx my mz b">Wxh</code>定义。所以这个公式看起来像:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/2caf13b726c52f484f540348c559cccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*rZCv_pub_2Kdzb7sqsXEsg.png"/></div></figure><p id="8996" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的例子只把最后一步作为记忆，从而与最后一步的数据合并。为了增加网络的存储容量，并在内存中保存更长的序列，我们必须向等式中添加更多的状态，如<code class="eh mw mx my mz b">ht-2</code>、<code class="eh mw mx my mz b">ht-3</code>等。最后，可以计算测试期间的输出:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/9e4777ecf7f4be479c6bebc5516aab34.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*kBJUiDmobt-ZbzoXwUSAgw.png"/></div></figure><p id="5674" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中<code class="eh mw mx my mz b">yt</code>是产量。将输出与实际输出进行比较，然后计算误差值。网络通过经由网络反向传播误差来学习，以更新权重。我们将在下一节讨论反向传播。</p><h1 id="addd" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">穿越时间的反向传播(BPTT)</h1><p id="af17" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">本节认为你知道反向传播是一个概念。如果您需要了解反向传播，请访问此<a class="ae ms" href="http://cs231n.github.io/optimization-2/" rel="noopener ugc nofollow" target="_blank">链接</a>阅读更多内容。</p><p id="7435" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们明白了RNN实际上是如何工作的，但是训练实际上是如何工作的呢？我们如何决定每个连接的权重？我们如何初始化这些隐藏单元的权重。递归网络的目的是准确地对顺序输入进行分类。我们依靠误差的反向传播和梯度下降来做到这一点。但是在前馈网络中使用的标准反向传播不能在这里使用。</p><p id="2fc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rnn的问题在于它们是循环图，不像前馈网络那样是非循环有向图。在前馈网络中，我们可以从上一层计算误差导数。在RNN，我们没有这样的层次。</p><p id="56df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答案就在我们上面讨论的内容中。我们需要展开网络。我们将展开它，使它看起来像一个前馈网络。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff ne"><img src="../Images/01fc02e26396ce9e4fe4121259baa066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1_uXU6oW4Bt5UFoaqvAiw.jpeg"/></div></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">Unrolling a RNN</figcaption></figure><p id="b0a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们采用RNN的隐藏单元，并在每个时间步复制它。每个时间步的复制就像一个前馈网络中的一层。每个时间步长<code class="eh mw mx my mz b">t</code>层连接到时间步长<code class="eh mw mx my mz b">t+1</code>中所有可能的层。因此，我们随机初始化权重，展开网络，然后使用反向传播来优化隐藏层中的权重。初始化是通过向最低层传递参数来完成的。作为反向传播的一部分，这些参数也被优化。</p><p id="ded4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">展开的结果是每个层现在开始保持不同的权重，因此最终得到不同的优化。根据重量计算的误差不能保证相等。因此在单次运行结束时，每层可以具有不同的权重。我们绝对不希望这种情况发生。简单的解决方案是以某种方式汇总所有层的误差。我们可以计算出误差的平均值，甚至把它们加起来。这样，我们可以在所有时间步长中使用一个层来保持相同的权重。</p><h1 id="f81a" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">RNN实施</h1><p id="9fc1" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">下面是一个示例代码，我们尝试使用Keras模型实现了一个RNN。这里是到<a class="ae ms" href="https://gist.github.com/09aefc5231972618d2c13ccedb0e22cc.git" rel="noopener ugc nofollow" target="_blank">要点</a>的直接链接。我们试图预测给定一组文本的下一个序列。</p><p id="d636" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个模型是由<a class="ae ms" href="https://github.com/yashk2810/Predicting-Next-Character-using-RNN" rel="noopener ugc nofollow" target="_blank"> Yash Katariya </a>建造的。我稍微更新了代码，以适应本文的要求。代码是注释的，这是不言自明的。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff nf"><img src="../Images/8584535ffa17b3366c36bb69838802d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwRiD82qcfUfMJiGiEcBeA.png"/></div></div></figure><h1 id="c53c" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结论</h1><p id="d228" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">好了，我们已经到了这篇文章的结尾。到目前为止，我们所讨论的只是RNN的一个基本实现。为了对这个话题有一个全面的了解，我们需要涵盖很多东西。我将在一周内写第二篇文章。我将尝试涵盖以下主题。</p><ol class=""><li id="faa6" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated">消失和爆炸渐变</li><li id="b18b" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">长期依赖的问题</li><li id="5d31" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">长短期记忆网络(LSTM)</li><li id="4570" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">LSTM门</li><li id="bfc5" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">双向RNNs</li><li id="a001" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">深度(双向)RNNs</li><li id="f024" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">GRU细胞</li></ol><p id="3658" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想让我报道除此之外的事情，请在评论区留言。rnn是非常强大的东西，它非常接近人类大脑的工作方式。我将期待在这一领域有更多的发展，我个人也在这方面努力。任何改进，我一定会在这里分享。因此，请在<a class="ae ms" rel="noopener" href="/@debarko">媒体</a>或<a class="ae ms" href="https://twitter.com/debarko" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，了解最新消息。</p><h2 id="2edc" class="ll kj hu bd kk lm ln lo ko lp lq lr ks jc ls lt kw jg lu lv la jk lw lx le ly dt translated"><strong class="ak"> <em class="ng">如果你喜欢这篇文章，请点击👏按钮来支持它。这将有助于其他媒体用户找到它。</em> </strong> <a class="ae ms" href="http://twitter.com/intent/tweet?text=%40debarko%20just%20released%20an%20article%20on%20%23RNN.%20It%20talks%20about%20how%20you%20can%20build%20a%20%23RecurrentNeuralNetwork%20%F0%9F%9A%80and%20its%20workings.%20%23AI%20%23ML%20%23NeuralNetworks%20%23MachineLearning%20https%3A%2F%2Fgoo.gl%2FFPPwYN" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> <em class="ng">在Twitter上分享这篇文章</em> </strong> </a> <strong class="ak"> <em class="ng">帮助尽可能多的读者。</em> </strong></h2></div></div>    
</body>
</html>