<html>
<head>
<title>Clean Architecture Example in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的清洁建筑范例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/clean-architecture-example-in-kotlin-9f23169219be?source=collection_archive---------4-----------------------#2018-06-19">https://medium.com/hackernoon/clean-architecture-example-in-kotlin-9f23169219be?source=collection_archive---------4-----------------------#2018-06-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/520d33bdcc71e44285507e571e8e9442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQ44uetgQxDqvySnryFzKw.jpeg"/></div></div></figure><p id="ef87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在过去的几年里，已经有许多博客文章和文章介绍了<em class="ka">干净的架构</em>，正如<em class="ka">罗伯特·c·马丁(鲍勃叔叔)</em>在他的<a class="ae kb" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">博客文章</a>和(更详细的)他的奇妙的书<a class="ae kb" href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" rel="noopener ugc nofollow" target="_blank"> <em class="ka">“干净的架构:软件结构和设计的工匠指南”中所介绍的那样</em> </a></p><p id="fce3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我们展示了一个REST服务的例子，它使用了干净的架构，并且是用<em class="ka"> Kotlin </em>编写的。</p><p id="31b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">源代码可以在以下报告中找到:</p><div class="kc kd fm fo ke kf"><a href="https://github.com/thecodegang/clean-architecture-example" rel="noopener  ugc nofollow" target="_blank"><div class="kg ab ej"><div class="kh ab ki cl cj kj"><h2 class="bd hv fv z el kk eo ep kl er et ht dt translated">烟囱/清洁建筑-示例</h2><div class="km l"><h3 class="bd b fv z el kk eo ep kl er et ek translated">一个在科特林和Spring Boot 2.0中的简单的干净架构的例子</h3></div><div class="kn l"><p class="bd b gc z el kk eo ep kl er et ek translated">github.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt ja kf"/></div></div></a></div><h1 id="b584" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">干净架构示例模块的简短描述</h1><p id="d35d" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">该项目由四个模块<code class="eh lx ly lz ma b">core</code>、<code class="eh lx ly lz ma b">usecases</code>、<code class="eh lx ly lz ma b">dataproviders</code>和<code class="eh lx ly lz ma b">delivery</code>组成。</p><h1 id="8aee" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated"><code class="eh lx ly lz ma b">core</code>模块</h1><p id="4f1f" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">该模块包含域实体。不依赖于框架和/或库。</p><h1 id="0a44" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated"><code class="eh lx ly lz ma b">usecases</code>模块</h1><p id="a665" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">该模块包含我们的应用程序所必需的业务规则。这个模块唯一的依赖是对<code class="eh lx ly lz ma b">core</code>的依赖。在本模块中，将定义存储库的网关。每个用例定义了遵循<a class="ae kb" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank"> ISP </a>所需的网关接口。这些网关在<code class="eh lx ly lz ma b">core</code>中定义的域实体上运行。</p><p id="1847" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在该模块中，还定义了<code class="eh lx ly lz ma b"><a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/usecases/src/main/kotlin/com/github/aantoniadis/delivery/usecases/core/UseCase.kt" rel="noopener ugc nofollow" target="_blank">UseCase</a></code>和<code class="eh lx ly lz ma b"><a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/usecases/src/main/kotlin/com/github/aantoniadis/delivery/usecases/core/UseCase.kt" rel="noopener ugc nofollow" target="_blank">UseCaseExecutor</a></code>。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="5292" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">UseCase</code>是一个类似于<code class="eh lx ly lz ma b">java.util.Function</code>的接口。它只是得到一个请求，并将其转换成一个响应。</p><p id="f7d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">UseCaseExecutor</code>处理<code class="eh lx ly lz ma b">UseCase</code>的执行。为此，它有一个接受以下参数的<code class="eh lx ly lz ma b">invoke</code>方法:</p><ol class=""><li id="ef39" class="mh mi hu je b jf jg jj jk jn mj jr mk jv ml jz mm mn mo mp dt translated">将要执行的<code class="eh lx ly lz ma b">UseCase</code></li><li id="f679" class="mh mi hu je b jf mq jj mr jn ms jr mt jv mu jz mm mn mo mp dt translated">一个<code class="eh lx ly lz ma b">RequestDto</code></li><li id="e71b" class="mh mi hu je b jf mq jj mr jn ms jr mt jv mu jz mm mn mo mp dt translated">一个<em class="ka">映射函数</em>，它将<code class="eh lx ly lz ma b">RequestDto</code>转换成一个<code class="eh lx ly lz ma b">Request</code>对象(用例的输入)</li><li id="9942" class="mh mi hu je b jf mq jj mr jn ms jr mt jv mu jz mm mn mo mp dt translated">一个<em class="ka">映射函数</em>，它将<code class="eh lx ly lz ma b">UseCase</code>执行的<code class="eh lx ly lz ma b">Response</code>对象(用例的输出)转换为<code class="eh lx ly lz ma b">ResponseDto</code></li></ol><p id="32be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有三个重载版本的<code class="eh lx ly lz ma b">invoke</code>方法，它们省略了<code class="eh lx ly lz ma b">UseCaseExecutor</code>的输入和/或输出。</p><p id="0369" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前，<code class="eh lx ly lz ma b">UseCaseExecutor</code>实现(<code class="eh lx ly lz ma b"><a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/usecases/src/main/kotlin/com/github/aantoniadis/delivery/usecases/core/UseCase.kt" rel="noopener ugc nofollow" target="_blank">UseCaseExecutorImp</a></code>)正在使用<code class="eh lx ly lz ma b">java.util.concurrent.CompletableFuture</code>和<code class="eh lx ly lz ma b">java.util.concurrent.CompletionStage</code>进行执行抽象。这些抽象很方便，因为它们可以执行异步执行，并且与大多数框架都有现成的兼容性。</p><h1 id="a3cd" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated"><code class="eh lx ly lz ma b">dataproviders</code>模块</h1><p id="3334" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">该模块包含<code class="eh lx ly lz ma b">usecases</code>模块中定义的网关的实现。该模块依赖于便于数据访问的框架。在我们的例子中，我们使用JPA和Spring数据。<code class="eh lx ly lz ma b">Jpa*Repository</code>类是在<code class="eh lx ly lz ma b">usecases</code>模块中定义的网关的实际实现。</p><p id="9faf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些存储库利用了Spring数据<code class="eh lx ly lz ma b">JpaRepository</code>。这里有一个<code class="eh lx ly lz ma b"><a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/dataproviders/src/main/kotlin/com/github/aantoniadis/dataproviders/db/jpa/repositories/JpaProductRepository.kt" rel="noopener ugc nofollow" target="_blank">JpaProductRepository.kt</a></code>的例子:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="eac6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lx ly lz ma b">DBProductRepository</code>是a Spring数据<code class="eh lx ly lz ma b">JpaRepository</code>的子类。</p><p id="779f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个模块中的实体是JPA实体，所以需要映射器函数在这些实体和域实体之间进行转换。在前面的代码片段中，我们演示了如何在<code class="eh lx ly lz ma b">JpaProductRepository</code>中使用这些映射器函数。一个实体的例子是<code class="eh lx ly lz ma b"><a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/dataproviders/src/main/kotlin/com/github/aantoniadis/dataproviders/db/jpa/entities/ProductEntity.kt" rel="noopener ugc nofollow" target="_blank">ProductEntity.kt</a></code>:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><h1 id="dbe0" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated"><code class="eh lx ly lz ma b">delivery</code>模块</h1><p id="6d64" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">该模块包含我们使用的交付机制的所有细节，以及应用程序的连接和配置。在我们的例子中，我们使用Spring Boot构建的rest服务。类似地，对于<code class="eh lx ly lz ma b">dataproviders</code>模块的JPA实体，d to有映射器来转换域实体。</p><p id="dd12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">rest控制器获取<code class="eh lx ly lz ma b">RequestDto</code>，并通过<code class="eh lx ly lz ma b">UseCaseExecutor</code>将其转发给相关用例。用例的响应(是一个<code class="eh lx ly lz ma b">ResponseDto</code>)是实现端点的控制器方法的响应。这种用法的一个例子是<code class="eh lx ly lz ma b"><a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/delivery/src/main/kotlin/com/github/aantoniadis/delivery/rest/imp/ProductResourceImp.kt" rel="noopener ugc nofollow" target="_blank">ProductResourceImp.kt</a></code>。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="47a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">异常由<a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/delivery/src/main/kotlin/com/github/aantoniadis/delivery/rest/imp/GlobalExceptionHandler.kt" rel="noopener ugc nofollow" target="_blank">global exception handler . kt</a>处理，并转换为<code class="eh lx ly lz ma b"><a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/blob/master/delivery/src/main/kotlin/com/github/aantoniadis/delivery/rest/api/ErrorDto.kt" rel="noopener ugc nofollow" target="_blank">ErrorDto</a></code>。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><h1 id="396c" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">干净的架构将低层细节与高层策略分开</h1><p id="9206" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在这个<a class="ae kb" href="https://github.com/thecodegang/clean-architecture-example/pull/1" rel="noopener ugc nofollow" target="_blank">拉取请求</a>中，我们展示了在不触及业务逻辑(<code class="eh lx ly lz ma b">core</code>和<code class="eh lx ly lz ma b">usecases</code>模块)的情况下更改数据层是多么容易。每层之间清晰的边界提供了灵活性。此外，由于外层依赖于内层的依赖规则，<code class="eh lx ly lz ma b">core</code>和<code class="eh lx ly lz ma b">usecases</code>模块不知道我们在外层模块中所做的任何改变。因此，我们甚至不需要重新编译这些模块来部署带有新数据层的应用程序。</p><p id="58e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，由于<code class="eh lx ly lz ma b">core</code>和<code class="eh lx ly lz ma b">usecases</code>模块只包含业务对象和它们交互的方式，对于参与项目的人来说，理解应用程序的领域要简单得多。有人可能会说，对于一个新的团队成员来说，在没有充分熟悉所使用的框架和/或库的情况下就开始编写新的功能是可能的(当然也有一些例外)。我们应用程序的核心不包含任何可能使学习曲线变得更陡的<em class="ka">魔法</em>框架。</p><h1 id="9819" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">干净的架构是可测试的</h1><p id="af7a" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">由于上一节讨论的分离，测试应用程序的业务逻辑很简单，不需要设置任何框架或库。我们可以编写简单的单元测试来测试应用程序中复杂的业务逻辑，而不必处理框架。同样，当我们在一个框架中改变一些东西时，我们不必改变这些测试。当然，我们应该有集成测试来确保一切都正确连接，但是这些昂贵的测试将只是少数，并且不会随着我们业务逻辑复杂性的增加而增加。</p><h1 id="0911" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">干净的架构不是银弹</h1><p id="e226" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">很容易注意到，我们为应用程序提供的简单功能写了太多东西，即使是用像Kotlin这样简洁的语言。如果我们构建的应用程序相对简单，干净的架构需要一些可能被认为是过度工程化的抽象。开始时间接调用数据和交付层可能感觉不自然，但是当我们向系统添加新功能时，我们的速度会增加，因为我们将纯领域代码与框架和配置分开。</p><p id="1da1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">干净的架构，像所有的软件架构一样，都是有成本的，所以由开发人员/架构师来决定他们是否能从中受益。</p><h1 id="29f6" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">进一步阅读</h1><ol class=""><li id="127e" class="mh mi hu je b jf ls jj lt jn mv jr mw jv mx jz mm mn mo mp dt translated"><a class="ae kb" href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" rel="noopener ugc nofollow" target="_blank">“干净的架构:软件结构和设计的工匠指南(罗伯特·马丁系列)</a>作者<em class="ka">罗伯特·马丁(鲍勃叔叔)</em></li><li id="a2dc" class="mh mi hu je b jf mq jj mr jn ms jr mt jv mu jz mm mn mo mp dt translated"><a class="ae kb" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">洁净的建筑</a></li><li id="84bc" class="mh mi hu je b jf mq jj mr jn ms jr mt jv mu jz mm mn mo mp dt translated"><a class="ae kb" rel="noopener" href="/@eminetto/clean-architecture-using-golang-b63587aa5e3f">使用Golang清洁建筑</a></li></ol></div></div>    
</body>
</html>