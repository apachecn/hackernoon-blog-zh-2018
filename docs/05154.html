<html>
<head>
<title>My Experience with FFmpeg on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在Android上使用FFmpeg的体验</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/android-ndk-my-experience-with-ffmpeg-93dd7e4b9269?source=collection_archive---------5-----------------------#2018-06-19">https://medium.com/hackernoon/android-ndk-my-experience-with-ffmpeg-93dd7e4b9269?source=collection_archive---------5-----------------------#2018-06-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="796c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Android SDK为开发人员每天使用的大多数常见工作提供了API，如<code class="eh jp jq jr js b">direct share</code>、<code class="eh jp jq jr js b">app linking</code>、<code class="eh jp jq jr js b">fingerprint authentication</code>等等。有时，我们可能需要处理低级功能，这些功能大多以<a class="ae jt" href="https://ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> C/C++库</a>的形式提供。有了<a class="ae jt" href="https://hackernoon.com/tagged/android" rel="noopener ugc nofollow" target="_blank"> Android </a> NDK，我们可以通过创建一个C/C++包装器来使用这些预建的库，并使用JNI从Kotlin/Java调用本地代码。</p><p id="6362" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这篇文章，我将解释</p><ul class=""><li id="c9f5" class="ju jv hu it b iu iv iy iz jc jw jg jx jk jy jo jz ka kb kc dt translated">如何将预构建的库与Android应用程序(如FFmpeg)集成</li><li id="c7b5" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated">围绕预构建的库创建一个包装器，用于您的android应用程序。</li></ul><p id="4e6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于NDK基础知识和本地代码回调的信息，你可以看看我以前的文章:</p><ol class=""><li id="3195" class="ju jv hu it b iu iv iy iz jc jw jg jx jk jy jo ki ka kb kc dt translated"><a class="ae jt" rel="noopener" href="/fueled-android/using-android-ndk-with-kotlin-episode-1-the-concepts-bbffd69d2ea6"> <em class="kj">安卓NDK:使用科特林第1集——概念</em> </a></li><li id="0a62" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo ki ka kb kc dt translated"><a class="ae jt" rel="noopener" href="/fueled-engineering/understanding-android-ndk-with-kotlin-episode-2-callbacks-kotlin-to-cpp-e67a87d6d8c9"> <em class="kj">安卓NDK:使用科特林第二集——回调(科特林到cpp) </em> </a></li><li id="c34f" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo ki ka kb kc dt translated"><a class="ae jt" rel="noopener" href="/@iamnitishbhatt/understanding-android-ndk-with-kotlin-episode-3-callbacks-continued-bbeacf884848"> <em class="kj">安卓NDK:使用科特林第三集——回调继续。</em> </a></li></ol><h1 id="a8fd" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">将FFmpeg与Android应用集成</h1><p id="0111" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">其中一个项目要求使用FFmpeg进行视频处理。作为使用FFmpeg的新手，我遇到了处理视频所需的重新复用、代码转换、速率转换和大小转换过程。</p><h1 id="c72d" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">热木兴</h1><p id="3679" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">重新muxing是一个无损过程，用于更改给定文件的容器格式(例如，从mp4到avi，反之亦然)。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ln"><img src="../Images/05e6991ef9601c052117222814e730f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8P3oZ7ZRgfvQThkYI3fBSw.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Remuxing</figcaption></figure><h1 id="2f67" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">转码</h1><p id="5dae" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated"><a class="ae jt" href="https://hackernoon.com/tagged/transcoding" rel="noopener ugc nofollow" target="_blank">转码</a>是将文件从一种编码格式转换为另一种编码格式的过程，以便可以在不同的播放设备上观看内容。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff md"><img src="../Images/27bbbe23a35fae4e0a372f15e1b3549e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyr8RnfQeGNotVzaodzI-Q.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Transcoding</figcaption></figure><h1 id="e77f" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated"><strong class="ak">翻译</strong></h1><p id="35b0" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">速率转换是将视频文件和音频文件转换为降低的比特率，同时仍保持原始媒体格式的过程。</p><h1 id="355d" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated"><strong class="ak">转运</strong></h1><p id="a500" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">改变大小指的是改变视频的图片大小，如果输出分辨率不同于媒体的分辨率，这是很有用的。</p><blockquote class="me mf mg"><p id="dcbf" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">根据要求，可以选择重新复用或代码转换。</p><p id="a637" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">例如:</p><p id="4d69" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">将一种格式转换成另一种格式— <strong class="it hv">重新复用</strong></p><p id="ea1a" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">要裁剪视频或播放实时流— <strong class="it hv">转码</strong></p><p id="6854" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">降低比特率— <strong class="it hv">速率转换</strong></p><p id="c84a" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">要更改分辨率— <strong class="it hv">改变尺寸</strong></p><p id="5fd8" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">通常这些方法结合使用以获得期望的结果</p></blockquote><h1 id="01b7" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">为Android编译FFmpeg</h1><p id="cda6" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">接下来是重要的部分，即编译FFmpeg源代码，为android生成库(<a class="ae jt" href="https://en.wikipedia.org/wiki/Cross_compiler" rel="noopener ugc nofollow" target="_blank">交叉编译</a>)。从事过一些硬件相关的项目对我帮助很大，因为这些术语对我来说不再陌生了😛。下面是我用来生成库的一些教程。</p><ul class=""><li id="1556" class="ju jv hu it b iu iv iy iz jc jw jg jx jk jy jo jz ka kb kc dt translated"><a class="ae jt" href="https://yesimroy.gitbooks.io/android-note/content/compile_ffmpeg_for_android.html" rel="noopener ugc nofollow" target="_blank">为android编译FFmpeg。</a></li><li id="91fa" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><a class="ae jt" href="https://yesimroy.gitbooks.io/android-note/content/compile_x264_for_android.html" rel="noopener ugc nofollow" target="_blank">为android编译X264。</a></li></ul><p id="ee79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些教程将帮助你跨越交叉编译的障碍。</p><p id="3d5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编译后，您将拥有如下所示的<a class="ae jt" href="https://developer.android.com/ndk/guides/abis.html" rel="noopener ugc nofollow" target="_blank"> ABIs </a>:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mk"><img src="../Images/e0bc6e4f9d606d9751e4a327d7811b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ta0-ex0O69oycCYmbLndQ.png"/></div></div></figure><h1 id="a439" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">FFmpeg库</h1><p id="45d7" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">C/C++中有两种<a class="ae jt" href="https://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries" rel="noopener ugc nofollow" target="_blank">库</a></p><ul class=""><li id="02ef" class="ju jv hu it b iu iv iy iz jc jw jg jx jk jy jo jz ka kb kc dt translated">共享:共享库是<code class="eh jp jq jr js b">.so</code>文件。与该库相关的所有代码都在这个文件中，并且在运行时被使用它的程序引用。</li></ul><blockquote class="me mf mg"><p id="b588" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">使用共享库的程序只引用它在共享库中使用的代码。</p></blockquote><ul class=""><li id="73d5" class="ju jv hu it b iu iv iy iz jc jw jg jx jk jy jo jz ka kb kc dt translated">静态:静态库是。a文件。所有与库相关的代码都在这个文件中，它在编译时直接链接到程序中。</li></ul><blockquote class="me mf mg"><p id="ce22" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">使用静态库的程序从静态库中复制它所使用的代码，并使其成为程序的一部分。</p></blockquote><p id="44ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">FFmpeg包含一组可用于不同操作的共享库:</p><ul class=""><li id="5e78" class="ju jv hu it b iu iv iy iz jc jw jg jx jk jy jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/libavcodec.html" rel="noopener ugc nofollow" target="_blank">libavcodec</a></code>:提供通用编码/解码框架，包含多个用于音频、视频和字幕流的解码器和编码器，以及几个比特流过滤器。</li><li id="7e15" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/libavutil.html" rel="noopener ugc nofollow" target="_blank">libavutil</a></code>:是一个帮助便携式多媒体编程的实用程序库。</li><li id="601b" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/libavformat.html" rel="noopener ugc nofollow" target="_blank">libavformat</a></code>:为音频、视频和字幕流的复用和解复用(复用和解复用)提供通用框架。</li><li id="6b3b" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/libavdevice.html" rel="noopener ugc nofollow" target="_blank">libavdevice</a></code>:提供一个通用框架，用于从许多常见的多媒体输入/输出设备中抓取和渲染，并支持多种输入和输出设备，包括Video4Linux2、VfW、DShow和ALSA。</li><li id="134c" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/libavfilter.html" rel="noopener ugc nofollow" target="_blank">libavfilter</a></code>:提供一个通用的音频/视频过滤框架，包含几个过滤器、源和接收器。</li><li id="c48d" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/doxygen/2.5/group__lavr.html" rel="noopener ugc nofollow" target="_blank">libavresample</a></code>:是一个处理音频重采样、样本格式转换和混音的库。</li><li id="34b0" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/libswscale.html" rel="noopener ugc nofollow" target="_blank">libswscale</a></code>:该库执行高度优化的图像缩放、色彩空间和像素格式转换操作。</li><li id="e329" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b"><a class="ae jt" href="https://www.ffmpeg.org/libswresample.html" rel="noopener ugc nofollow" target="_blank">libswresample</a></code>:这个库执行高度优化的音频重采样、重混音和样本格式转换操作。</li><li id="6949" class="ju jv hu it b iu kd iy ke jc kf jg kg jk kh jo jz ka kb kc dt translated"><code class="eh jp jq jr js b">libpostproc</code>:是用于转码的后处理库。</li></ul><blockquote class="me mf mg"><p id="ba31" class="ir is kj it b iu iv iw ix iy iz ja jb mh jd je jf mi jh ji jj mj jl jm jn jo hn dt translated">根据项目需求，用户可以选择需要集成到项目中的库。</p></blockquote><h1 id="27c7" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">将编译后的库添加到项目中</h1><p id="f887" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">根据需要，您可以将库包含在JNI文件夹下，如下所示:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/a18d23aaf823f6d3d861fc45d27fdeef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*fyNszRnhYDykuii7JMcqEA.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Adding Shared Libs and header files to project</figcaption></figure><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mm mn l"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Adding the path of shared libs and abifilters in the Gradle file</figcaption></figure><p id="a691" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将此添加到CMakeLists.txt文件中</p><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mm mn l"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Importing required libraries</figcaption></figure><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mm mn l"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Linking pre-built libraries</figcaption></figure><h1 id="73cf" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">创建使用库的包装器</h1><p id="acae" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">由于我们已经将FFmpeg库添加到项目中，并使用<code class="eh jp jq jr js b">target_link_libraries</code>将<code class="eh jp jq jr js b">JNIFunctions.cpp</code>链接到FFmpeg库，我们现在可以通过在* <code class="eh jp jq jr js b">.h</code>中包含头文件来使用库中可用的函数。</p><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mm mn l"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Include the header files required in the project</figcaption></figure><p id="1273" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是从RTSP馈送中获取SPS(序列参数集)帧的函数之一:</p><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mm mn l"/></div></figure><h1 id="6b0f" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">结论</h1><p id="d5a7" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">FFmpeg是一个非常棒的用于A/V处理的库。我们可以执行解复用、显示矩阵旋转、视频裁剪、合并音频和视频流等。有很多<a class="ae jt" href="https://trac.ffmpeg.org/wiki/Projects" rel="noopener ugc nofollow" target="_blank">开源</a>项目使用FFmpeg库。请务必阅读它们以获取更多信息。</p><h1 id="3c92" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">如果你喜欢这篇文章，点击👏。特别感谢我的朋友兼同事<a class="mo mp gr" href="https://medium.com/u/40499e50fc3b?source=post_page-----93dd7e4b9269--------------------------------" rel="noopener" target="_blank"> Arun Sasidharan </a>催我写这篇文章。</h1><p id="73e5" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">抓我这里:<br/> <em class="kj">推特:</em><a class="ae jt" href="https://twitter.com/initishbhatt" rel="noopener ugc nofollow" target="_blank"><em class="kj">@ iamnitishbhatt</em></a><em class="kj"><br/>领英:</em><a class="ae jt" href="https://www.linkedin.com/in/iamnitishbhatt/" rel="noopener ugc nofollow" target="_blank"><em class="kj"/>https://www.linkedin.com/in/iamnitishbhatt/</a><br/><em class="kj">Github:</em><a class="ae jt" href="https://github.com/initishbhatt" rel="noopener ugc nofollow" target="_blank">https://github.com/initishbhatt</a></p><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mq mn l"/></div></figure></div></div>    
</body>
</html>