<html>
<head>
<title>Linear Search Vs Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性搜索Vs二分搜索法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/linear-search-vs-binary-search-ce7c56f8feb1?source=collection_archive---------10-----------------------#2018-06-19">https://medium.com/hackernoon/linear-search-vs-binary-search-ce7c56f8feb1?source=collection_archive---------10-----------------------#2018-06-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/8151992999243420c6d3247ca8f06a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*xz1gwaJr-7URg8nRXs1Fng.png"/></div></figure><p id="9794" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所有程序员都熟悉线性搜索和二分搜索法。通常，我们使用它们来搜索任何元素及其位置。今天的讨论是关于这两种搜索算法的比较。</p><p id="2fb1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> 1。连续:</strong></p><p id="ed04" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">线性搜索遵循顺序，二分搜索法不遵循。线性搜索从起点到终点开始搜索。二进制搜索从中间点开始。</p><p id="8a3b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> 2。已排序:</strong></p><p id="9e00" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于二分搜索法，我们需要排序的元素。线性搜索不需要排序元素。</p><p id="ae03" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它搜索所有位置的所有元素，直到它得到想要的元素。</p><p id="7fff" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> 3。对比:</strong></p><p id="55dc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">二分搜索法的比较次数少于线性搜索，因为二分搜索法从中间开始，总比较次数为log <em class="jw"> 2 </em> N</p><p id="1073" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> 4。时间复杂度:</strong></p><p id="309b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从下图，我们可以了解一个算法的时间复杂度。</p><figure class="jy jz ka kb fq iv fe ff paragraph-image"><div class="fe ff jx"><img src="../Images/354662c57d4995e67508b33a6a011e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*lpjpuuNJkj73zEOO_atpkA.png"/></div></figure><p id="de9f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">线性搜索的时间复杂度为:</p><p id="c4d3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个<em class="jw">。</em>最佳<em class="jw"> </em>案例<strong class="ja hv"> <em class="jw"> </em> </strong> = O(1)</p><p id="be12" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">b <em class="jw">。</em>平均事例= n(n+1)/2n = O(n)</p><p id="16d1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">c <em class="jw">。</em>最坏情况= O(n)</p><p id="5e05" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">线性搜索的时间复杂度为:</p><p id="0d59" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个<em class="jw">。</em>最佳情况<strong class="ja hv"> <em class="jw"> </em> </strong> = O(1)</p><p id="78a1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">b <em class="jw">。</em>平均事例= logn(logn+1)/2logn = O(logn)</p><p id="1876" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">c <em class="jw">。</em>最坏情况= O(logn)</p><p id="ca4d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以我们可以假设二分搜索法的时间复杂度小于线性搜索。</p><p id="5f53" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> 5。空间复杂度:</strong></p><p id="8b58" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">线性搜索的空间复杂度为O(1)，二分搜索法为O(1)。</p><p id="6341" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以我们可以假设，当我们需要更好的复杂度时，我们应该使用二分搜索法算法。我们不能在未排序的列表中搜索元素时应用二分搜索法。编码快乐！</p></div></div>    
</body>
</html>