<html>
<head>
<title>Fast and Simple Rendering in Rust using Proc Macros</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Proc宏在Rust中快速简单地渲染</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fast-and-simple-rendering-in-rust-using-proc-macros-f0d919eb6475?source=collection_archive---------12-----------------------#2018-06-19">https://medium.com/hackernoon/fast-and-simple-rendering-in-rust-using-proc-macros-f0d919eb6475?source=collection_archive---------12-----------------------#2018-06-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8214688c882719fc75c124ac5283dfdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DoQZVn7xZHgZMHdk1KXRFg.jpeg"/></div></div></figure><div class=""/><p id="8471" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近一直在做一个名为<a class="ae ka" href="https://github.com/trezm/thruster" rel="noopener ugc nofollow" target="_blank">推进器</a>的项目，需要一种开发者可以合理使用模板的方式。推进器是一个基于中间件的网络服务器，用Rust编写(懂了吗，th-rust-er？我正在为业余爱好者的阿波罗之夜而努力，)因此，我需要一种方法来加载HTML模板并以一种高性能的方式将变量插入其中。而不是在众多现有的库中翻来翻去，选择一个我不认识的人做的——更奇怪的危险！—我决定自己做。这篇文章是关于那次旅程，在Rust写我的第一篇<code class="eh kb kc kd ke b">proc_macro_derive</code>的令人难以置信的惊险冒险。<a class="ae ka" href="https://open.spotify.com/track/60ZYLVPmSNY9r0Uquaivvs?si=b5BbeA1tSLeIG2VNzjQhXw" rel="noopener ugc nofollow" target="_blank">提示印第安纳琼斯音乐</a>。</p><p id="7c60" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你需要知道的第一件事是，我不是我所说的系统专家。我选择rust是因为我想要一种更新的基于性能的语言，但我更像是一个web开发人员。我已经可以通过互联网管道听到你的盐了；“我为什么要接受一个网络开发者的建议呢？他可能只是想谈谈arrow函数，以及他这一代人是如何发现函数式<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的。”你是对的。我只是想谈谈这个，但我也正在做鳄梨吐司，我的生活教练说我应该专注于我的气，而不是谈论榆树郎。</p><p id="7789" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我提到我是一名web开发人员的原因是，在web框架中，我首先要考虑的事情之一是在框架中开发有多复杂，以及框架组合和移动各个部分有多容易。有时候，我喜欢能够复制/粘贴我已经在不同项目中编写的代码，而不必重新计算将人送上月球的轨道。</p><p id="c60f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该知道的第二件事是，Rust是伟大的，尽管我的同事想用鞋子砸我的头，如果我看起来像是要谈论它的内存安全或速度，我对它的爱仍然比一千个太阳还要强烈。</p><p id="8c6d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了，既然忏悔室已经不碍事了，我们可以开始研究项目的实质了；<code class="eh kb kc kd ke b">proc_macro_derive</code>。过程宏(以及一般的宏)是迷人的生物。许多来自其他语言的开发人员会翻着白眼，记起每次他们不得不调试一个神秘的宏，但是Rust有点不同。从文档中:</p><blockquote class="kg kh ki"><p id="0672" class="jc jd kf je b jf jg jh ji jj jk jl jm kj jo jp jq kk js jt ju kl jw jx jy jz hn dt translated">…Rust有一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Hygienic_macro" rel="noopener ugc nofollow" target="_blank">卫生宏系统</a>。每个宏展开都发生在不同的“语法上下文”中，每个变量都用引入它的语法上下文来标记。</p></blockquote><p id="aea5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是我想在宏中实现的目标:</p><ul class=""><li id="6789" class="km kn if je b jf jg jj jk jn ko jr kp jv kq jz kr ks kt ku dt translated">它应该在编译期间而不是运行时从文件中提取模板。</li><li id="d91b" class="km kn if je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">它是类型安全的，也就是说，我不会以恐慌结束！或者在运行时在我的渲染模板中出现一些奇怪的<code class="eh kb kc kd ke b">undefined</code>类型的文本。</li><li id="c483" class="km kn if je b jf kv jj kw jn kx jr ky jv kz jz kr ks kt ku dt translated">它很快。</li></ul><p id="90b5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，第一点只考虑了常规的旧宏，所以我不得不开始研究过程宏。宏本质上具有额外的逻辑，可以在编译过程中引入，并实际改变代码的AST。</p><p id="8a30" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">过程宏是特殊的动物，所以首先，我需要声明我的代码是<code class="eh kb kc kd ke b">Cargo.toml</code>文件中的一片特殊的雪花:</p><pre class="la lb lc ld fq le ke lf lg aw lh dt"><span id="7ecd" class="li lj if ke b fv lk ll l lm ln">[lib]<br/>proc-macro = true</span></pre><p id="39b6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我还包括了一些方便的从人类代码(oxymoron？)到一个锈AST又回来，<code class="eh kb kc kd ke b">syn</code>和<code class="eh kb kc kd ke b">quote</code>:</p><pre class="la lb lc ld fq le ke lf lg aw lh dt"><span id="bbb5" class="li lj if ke b fv lk ll l lm ln">syn = "0.13.1"<br/>quote = "0.5.1"</span></pre><p id="0a0c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我开始编写实际宏的代码。这里要做的一个重要区别是不同类型的程序宏之间的区别。我就把这个留在这里，因为有人已经在铁锈黑魔法书中替我做了工作:<a class="ae ka" href="https://doc.rust-lang.org/unstable-book/language-features/proc-macro.html" rel="noopener ugc nofollow" target="_blank">不稳定之书</a>。</p><p id="a0bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">长话短说——我决定定制一个派生的程序宏！这意味着我的代码看起来像这样开始:</p><figure class="la lb lc ld fq hw"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="1cc7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，我有了一种向结构中添加自定义实现的方法，这正是您希望使用derive的目的。这很好，但是我仍然希望能够从文件中加载模板。问题是，究竟如何获得要加载的模板的名称？</p><p id="0286" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对我们来说幸运的是，我们处于编译器领域(比糖果领域糟糕得多)，所以我们也可以添加额外的属性。下面是添加了用于抓取模板的<code class="eh kb kc kd ke b">TemplateName</code>属性的代码</p><figure class="la lb lc ld fq hw"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="1274" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的，我知道上面有点乱。就像我的车库和我工作时的桌子一样，当我有空的时候，我会开始清理它。我在这里做的是遍历传入的struct上的属性，以便找到<code class="eh kb kc kd ke b">TemplateName</code>属性。然后，我将基于该字符串加载一个文件的内容，并将其传递给由<code class="eh kb kc kd ke b">quote!</code>生成的令牌流。</p><p id="a53d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一步是做实际的插值，这有点乱，但相对简单。需要记住的重要一点是，除了从<code class="eh kb kc kd ke b">quote!</code>传回的内容之外的所有内容都将在编译时完成，反之亦然。请注意，上面的例子实际上并不包括插值，相反，<a class="ae ka" href="https://github.com/trezm/fuel-line/blob/master/fuel_line_derive/src/lib.rs#L49-L106" rel="noopener ugc nofollow" target="_blank">这里有一个GitHub </a>上发布的包的源代码的链接。</p></div><div class="ab cl lq lr hc ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hn ho hp hq hr"><p id="f17b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你已经做到了。你已经跟随我的分散的逻辑和强迫的修辞到了纳粹的脸融化的最后场景(你不会认为我已经忘记了第一段中的印第安纳琼斯参考，是吗？)程序性宏很锈；它们是安全和卫生的，但它们不是灵丹妙药。为了开发人员的安全，以及维护您代码的人的理智，他们的权力是有限的。然而，如果有一个问题是可以在编译时决定的，那么它们就是一个非常好的工具。</p><p id="3fdb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在这里找到代码:<a class="ae ka" href="https://github.com/trezm/fuel-line" rel="noopener ugc nofollow" target="_blank">https://github.com/trezm/fuel-line</a>和合适的货物包装:这里:<a class="ae ka" href="https://crates.io/crates/fuel_line" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/fuel_line</a>和这里:<a class="ae ka" href="https://crates.io/crates/fuel_line_derive" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/fuel_line_derive</a>。</p><figure class="la lb lc ld fq hw"><div class="bz el l di"><div class="lx lp l"/></div></figure></div></div>    
</body>
</html>