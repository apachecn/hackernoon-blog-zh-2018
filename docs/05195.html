<html>
<head>
<title>KVO &amp; KVC In swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift中的KVO和KVC</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kvo-kvc-in-swift-12f77300c387?source=collection_archive---------1-----------------------#2018-06-20">https://medium.com/hackernoon/kvo-kvc-in-swift-12f77300c387?source=collection_archive---------1-----------------------#2018-06-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="ab fr cl iv"><img src="../Images/f852925746abbe9ee5f06ef5519e28d5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OgeU8HPo8TFF1cZQ-4XjJw.jpeg"/></div></figure><ul class=""><li id="9216" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated"><strong class="ja hv">简介:</strong></li></ul><p id="6116" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">程序的流程取决于我们在代码中使用的各种变量的值。根据程序中变量的值，我们可以根据需要导航执行流程。</p><p id="ab7d" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">例如，如果我们使用任何集合类型，当集合被修改或更改时，很难执行逻辑。即当添加、删除或修改新项目时。我们仍然可以用很多方法处理这种情况。</p><p id="438a" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">其中之一是使用通知中心，通知我们，每当发生变化的财产价值。但是，如果想要检查我们代码中的许多属性，这种(使用通知中心)方式会导致我们使用大量代码来调用我们需要检查的所有属性。在这种情况下，另一种更好的方法是(也是苹果在其库中大量使用的)被称为<strong class="ja hv"/>(键值观察)，这也与另一种称为<strong class="ja hv">【KVC】</strong>(键值编码)的强大机制直接相关。</p><p id="a9fd" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv"> <em class="kf">注意:任何我们想要观察变化的属性必须是KeyValueCoding (KVC)投诉。</em>T9】</strong></p><p id="026d" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><em class="kf">这两个KVO &amp; KVC，提供了一种高效的方式来编写我们的代码。现在让我们从KVC开始，然后是KVO。</em></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><ul class=""><li id="19eb" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated"><strong class="ja hv"> KVC: </strong></li></ul><p id="153b" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv"> KVC </strong>是一种编码形式，允许你间接访问一个对象的属性，使用字符串代替属性的访问器或者直接访问变量来访问它们。要启用这种机制，您的类必须遵守NSKeyValueCoding非正式协议。(或者)</p><p id="1946" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><em class="kf">键值编码是一种间接访问对象属性的机制，使用字符串来标识属性，而不是通过调用访问器方法或通过实例变量直接访问它们。</em></p><blockquote class="kn ko kp"><p id="c955" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">例如:<strong class="ja hv">类配置文件:NSObject { </strong></p><p id="f831" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated"><strong class="ja hv"> var firstName: String </strong></p><p id="b67e" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated"><strong class="ja hv"> var lastName: String </strong></p><p id="c02e" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated"><strong class="ja hv"><em class="hu">var custom Profile:Profile</em></strong></p><p id="ff1a" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated"><strong class="ja hv"> } </strong></p></blockquote><p id="fc80" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如果我们想在类init()或类文件中的某个地方为上面声明的变量赋值，通常我们会这样做:</p><blockquote class="kn ko kp"><p id="1b33" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">self.firstName = "Robert "</p><p id="56b9" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">self.lastName = "Stark "</p><p id="f9bf" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">与KVC；我们确实喜欢以下内容:</p><p id="91f5" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated"><em class="hu">self . setvalue:</em><strong class="ja hv"><em class="hu">Robert</em></strong><em class="hu">for key:</em><strong class="ja hv"><em class="hu">first name</em></strong><em class="hu"/><strong class="ja hv"><em class="hu"/>//self . setvalue:</strong><em class="hu">Any</em><strong class="ja hv">for key:</strong><em class="hu">key/key path</em></p><p id="d9a7" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated"><em class="hu">self . setvalue:“</em><strong class="ja hv"><em class="hu">Stark</em></strong><em class="hu">”for key:“</em><strong class="ja hv"><em class="hu">last name</em></strong><em class="hu">”</em></p><p id="07d6" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">要检索KVC属性的值，我们使用如下方式:</p><p id="7d32" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">let Robert last name = self . value(forKey:<em class="hu">"</em><strong class="ja hv"><em class="hu">last name</em></strong><em class="hu">"</em></p></blockquote><p id="f99e" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">上述KVC的工作方式类似于在swift中使用字典。对吗？</p><p id="7ec5" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">在这里，在KVC；我们不是直接<em class="kf">将值分配给属性</em>，或者使用对象的(#如果可用)<em class="kf"> setter方法，而是简单地<strong class="ja hv">将</strong>值分配给<strong class="ja hv"> <em class="kf">键/键路径。</em> </strong> <em class="kf">所以我们用</em> <strong class="ja hv"> <em class="kf">键和值</em> </strong> <em class="kf">，这种技术叫做</em> <strong class="ja hv"> <em class="kf">键值编码(KVC)。</em> </strong></em></p><p id="c3c2" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv">注:</strong> <em class="kf">有一种协议被称为</em> <strong class="ja hv"> <em class="kf"> NSKeyValueCoding非正式协议</em> </strong> <em class="kf">，它与</em><strong class="ja hv"><em class="kf">【KVC】</em></strong><em class="kf">一起强制工作。</em> <strong class="ja hv"> <em class="kf">我们的跟班必须确认这个协议，以便使用KVC&amp;</em></strong><em class="kf">。</em><strong class="ja hv"><em class="kf">n对象</em> </strong> <em class="kf">确认本协议。所以</em>在<strong class="ja hv">基础</strong>框架中定义的并且继承自<strong class="ja hv"> <em class="kf"> NSObject </em> </strong>的每个类都符合<strong class="ja hv"><em class="kf">NSKeyValueCoding</em></strong>协议。</p><ul class=""><li id="e33a" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated"><strong class="ja hv">什么是key &amp; KeyPath？</strong></li></ul><p id="f0cb" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv">键:</strong> <em class="kf">简单地说就是</em> <strong class="ja hv"> <em class="kf">键</em> </strong> <em class="kf">"指定一个单独的属性，我们要从</em> <strong class="ja hv"> <em class="kf">中设置一个值或者从</em> </strong> <em class="kf">中获取一个值。所以其</em> <strong class="ja hv"> <em class="kf">名称</em> </strong> <em class="kf">应该与</em> <strong class="ja hv"> <em class="kf">属性的名称相同。</em>T109】</strong></p><blockquote class="kn ko kp"><p id="4172" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">ex:<em class="hu">self . setvalue:</em><strong class="ja hv"><em class="hu">Stark</em></strong><em class="hu">for key:</em><strong class="ja hv"><em class="hu">last name</em></strong><em class="hu"/></p></blockquote><p id="d1a2" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv">KeyPath:</strong><em class="kf">A</em><strong class="ja hv">T5】KeyPath</strong><em class="kf">由点语法跟随子串构成，所以不是单个单词/串。</em><strong class="ja hv"><em class="kf">Key-path</em></strong><em class="kf">代表</em> <strong class="ja hv"> <em class="kf">一个对象的所有属性</em> </strong> <em class="kf">，</em> <strong class="ja hv"> <em class="kf">直到达到所需的值/属性</em> </strong> <em class="kf">。</em></p><p id="eba9" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">例如:</p><blockquote class="kn ko kp"><p id="94d0" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">var myProfile: <strong class="ja hv">个人资料</strong></p><p id="5fa5" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated"><em class="hu">self . setvalue:"</em><strong class="ja hv"><em class="hu">拜拉席恩</em></strong><em class="hu">" for key:"</em><strong class="ja hv">my profile。<em class="hu">custom profile . last name</em>T41<em class="hu"/></strong></p></blockquote><p id="d958" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">KVC : </p><ul class=""><li id="a2cd" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated">这里，我们将创建一个单一视图应用程序，与KVC和KVO一起工作。这个项目有两个示例项目，但是我们在这里探索的那个与任何UI都没有关系。另一个是当文本改变时更新ViewController视图上的UILable。项目链接会在底部分享，你可以自己轻松探索。</li><li id="6d7e" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl jm jn jo jp dt translated">首先，在swift中创建单一视图应用程序</li><li id="081e" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl jm jn jo jp dt translated">要使用KVC，我们的类需要符合<em class="kf"> NSKeyValueCoding协议。所以通过向NSObject确认，我们可以实现这一步。UIViewController已经确认了这个NSObject，所以我们可以从这个协议调用方法，而不需要任何设置。</em></li><li id="d766" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl jm jn jo jp dt translated">在Xcode中，在您的项目中创建一个新的swift文件，名称为Children with NSObject作为基类(Children从NSObject继承)。然后在该类文件中，通过将'<strong class="ja hv"> <em class="kf"> @objc dynamic </em> </strong>'关键字放在声明<em class="kf">的前面，声明名为'<em class="kf"> name' </em>和'<em class="kf"> age' </em>的两个属性。那么我们为什么需要这样做呢？？？</em></li></ul><p id="955f" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">→在swift中，有许多关键字/属性有助于编译、运行时规范、访问控制等。例如:@逃避、@可用等。同样，它还定义了一系列声明修饰符，以修改属性/类成员的声明。例如，通过用'<strong class="ja hv"> <em class="kf"> final' </em> </strong>关键字标记类声明，我们通知编译器该类不能被子类化。这允许编译器进行一些优化来提高性能。<strong class="ja hv"><em class="kf">‘动态’</em></strong>也是我们在swift中使用的声明修饰符。</p><p id="0c36" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv">动态分派</strong>，是Objective-C中的一个很酷的特性。它简单地意味着Objective-C运行时在运行时决定它需要调用特定方法或函数的哪个实现。例如，如果一个子类覆盖了它的超类的一个方法，动态调度会计算出该方法的哪个实现需要被调用，是子类的还是父类的。这是一个非常强大的概念。</p><p id="fd66" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">Swift尽可能使用Swift运行时。结果是它可以进行许多优化。虽然Objective-C完全依赖于动态调度，但Swift只有在别无选择的情况下才会选择动态调度。如果编译器能够在编译时指出它需要选择方法的哪一个实现，它就可以通过退出动态调度来赢得几纳秒的时间。</p><p id="5d61" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">Swift运行时尽可能选择其他选项，如<strong class="ja hv">静态</strong>和<strong class="ja hv">虚拟调度</strong>，而不是<strong class="ja hv">动态调度</strong>。这样做是为了提高性能。静态和虚拟调度比动态调度快得多。尽管我们谈论的是纳秒，但最终结果可能是戏剧性的。我们已经习惯的许多特性都是因为动态Objective-C运行时才成为可能的，包括核心数据和键值观察。</p><h1 id="2330" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">动态调度</h1><p id="87eb" class="pw-post-body-paragraph jq jr hu ja b jb lw js jt jd lx ju jv jf ly jx jy jh lz ka kb jj ma kd ke jl hn dt translated">通过将'<strong class="ja hv"><em class="kf">【dynamic '</em></strong>声明修饰符应用于一个类的成员，你告诉编译器应该使用动态分派来访问那个成员。</p><p id="4827" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">通过用'<strong class="ja hv"> <em class="kf"> dynamic' </em> </strong>关键字作为声明的前缀，该声明被隐式地标记有<strong class="ja hv"> <em class="kf"> objc </em> </strong>属性。<strong class="ja hv"> <em class="kf"> objc </em> </strong>属性使声明在Objective-C中可用，这是Objective-C运行时调度它的一个要求。</p><p id="0ca9" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv"> <em class="kf">动态'</em> </strong>声明修饰符只能用于一个类的成员。结构和枚举不支持继承，这意味着运行时不必弄清楚它需要使用哪个实现。</p><p id="bae0" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">因此，要在swift中使用KVC和KVO，对于我们希望在KVO观察的属性，我们需要用@objc动态关键字来声明它们。</p><ul class=""><li id="9370" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated">现在，我们的<strong class="ja hv">子类</strong>中有两个属性，在初始化方法中初始化/定义它们。</li></ul><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mb"><img src="../Images/8dc7177b795fa14d56ab8077f379f713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TCkhco-TRujX3-Fy_RqJg.png"/></div></div></figure><ul class=""><li id="8260" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated">现在，在ViewController类文件中，声明如下所示的三个子实例:</li></ul><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mk"><img src="../Images/fcddf0d14feae1d021b5aeb48103dabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0R9tXt_CX6glel4rLzMrXQ.png"/></div></div></figure><p id="4e9c" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">首先我们使用'<em class="kf"> child1' </em>的宾语。在viewDidLoad()方法中，我们初始化child1对象，然后为其属性赋值。</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff ml"><img src="../Images/b0b0b52490a6523998e7912394f3a5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oajiRKdQ0FUfEpgvdIeVA.png"/></div></div></figure><p id="b324" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如果您打印'<em class="kf"> child1' </em> objects属性，如姓名和年龄，您将在结果中获得指定的值。</p><p id="64a7" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">现在，我们将使用KVC方法来做同样的事情。</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mm"><img src="../Images/45af41f7dd53564b57a5990f76b814d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVJzOqjwZnZbNDW0sYNBFQ.png"/></div></div></figure><p id="e15c" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">在上面的代码片段中，在前几行中，我们使用<em class="kf"> setValue:forKey: </em>方法为这两个属性设置了所需的值。注意关键字字符串与属性的名称相同。</p><p id="07c1" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">接下来，我们执行完全相反的任务。我们使用<em class="kf"> valueForKey: </em>方法从属性中提取值，并将它们分配给两个局部变量。然后我们在控制台中打印这些值。结果和上一个一样。</p><p id="75b4" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">注意:如果我们给属性名不同的键，应用程序将崩溃。当编写符合KVC标准的代码时，非常重要的一点是要小心，确保关键字符串与属性名匹配，否则应用程序就会崩溃。这不是直接处理属性的情况，因为没有机会在它们的名字上犯任何错误；在这种情况下，编译器会抛出一个错误，促使我们修复它。</p><p id="f182" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">综上所述，我们已经了解了如何编写KVC风格的代码，以及如何使用键来设置和获取值。在下一部分，我们将完成这个项目。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="a76f" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv">使用关键路径:</strong></p><p id="ae9d" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">现在转到Children类，添加以下属性。</p><blockquote class="kn ko kp"><p id="cd45" class="jq jr kf ja b jb jc js jt jd je ju jv kq jw jx jy kr jz ka kb ks kc kd ke jl hn dt translated">@objc动态var child:孩子？</p></blockquote><p id="7f9f" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">在<em class="kf"> viewDidLoad </em>方法中。现在，添加初始化相关对象并赋予其初始值的下一行:</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mn"><img src="../Images/947ee8aef8d3e90a487a7a3c3c8e2ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHI4Ga57Gx3FXaATdDbIBg.png"/></div></div></figure><p id="921a" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">在上面的代码片段中，在前几行中，我们刚刚初始化了'<em class="kf"> child2 ' </em>对象及其'<em class="kf"> child' </em>属性。接下来，我们为<strong class="ja hv"> child2 </strong>的属性<strong class="ja hv"> name </strong>和<strong class="ja hv"> age </strong>设置值。对于<strong class="ja hv"> child2 </strong>的<strong class="ja hv"> child </strong>属性，我们使用key-path来设置值。仔细观察。我们可以检索这些值来检查赋值是否成功:取消对打印语句的注释。</p><p id="d40b" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated"><strong class="ja hv">现在我们来看看如果孩子的孩子也有孩子会怎么样… </strong></p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mo"><img src="../Images/47474b0a04d277454adcfe1cd0cc4656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TT5kN-CXDyhuHX4ME7YJzw.png"/></div></div></figure><p id="9373" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如果您想要检查值/结果，请使用上面代码片段的打印语句。</p><p id="9630" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">到目前为止，我们学习了如何使用键和键路径编写KVC投诉代码。接下来，我们将学习观察资产的价值变化:</p><p id="1af4" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">KVO : </p><p id="a721" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">在这里，我们将看到应该采取什么行动，以便能够跟踪属性的变化。首先，让我以列表的形式向你介绍实施KVO所需的步骤:</p><p id="8658" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">1.要观察其属性的类必须符合KVO标准。这意味着:</p><ul class=""><li id="4354" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated">根据我们在简介和上一节中看到的内容，该类必须符合KVC标准。</li><li id="76df" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl jm jn jo jp dt translated">该类必须能够自动或手动发送通知(我们将在后面看到更多)。</li></ul><p id="6c6e" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">2.将用于观察另一个类的属性的类应该设置为<em class="kf">观察者</em>。</p><p id="c378" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">3.一个名为<strong class="ja hv"> <em class="kf">的特殊方法observe value(forkey path key path:String？对象:任何？，更改:[NSKeyValueChangeKey : Any]？，context:unsafmutablerawpointer？)</em> </strong>应该落实到观察类。</p><p id="9797" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">让我们一个一个来看。当我们想要观察一个属性的变化时，最重要的事情是让<em class="kf">让</em>我们的类观察这些变化。这或多或少是通过临时通知(<em class="kf"> NSNotifications </em>)来完成的，但是使用了另一种方法。这个方法就是<strong class="ja hv"><em class="kf">add observer(&lt;# T # # observer:ns object # # ns object #&gt;，forkey path:&lt;# T # # String #&gt;，options:&lt;# T # # NSKeyValueObservingOptions #&gt;，context:&lt;# T # # unsafmutablerawpointer？# &gt; ) </em> </strong></p><p id="01c8" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">这里我们观察到一个<strong class="ja hv"> child1 </strong>对象的<strong class="ja hv"> name </strong>和<strong class="ja hv"> age </strong>属性的值变化。所以在viewWillAppear()方法中，为child1对象添加观察者。</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mn"><img src="../Images/619cf09744df9143e6a8ebca0909abbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QE81PIRwsPcCq4bNU5G0Dw.png"/></div></div></figure><p id="b467" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">上述方法接受的参数是:</p><ul class=""><li id="a1ef" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp dt translated"><em class="kf"> addObserver </em>:这是观察类，通常是<em class="kf">自身</em>对象。</li><li id="2adc" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl jm jn jo jp dt translated">我猜你能明白这是干什么用的。它是您用作键或键路径的字符串，并且与您想要观察的属性相匹配。请注意，您可以在这里指定一个键或一个键路径。</li><li id="03e0" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl jm jn jo jp dt translated"><em class="kf">选项</em>:一组<em class="kf">NSKeyValueObservingOptions</em>值。</li><li id="de1d" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl jm jn jo jp dt translated"><em class="kf">上下文</em>:这是一个指针，可以作为我们观察的属性变化的唯一标识符。通常这被设置为<em class="kf">零</em>或<em class="kf">零</em>。稍后我们会看到更多相关内容。</li></ul><p id="1c81" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">既然我们已经使我们的类能够观察上述两个属性的任何变化，我们必须实现<em class="kf">observevaluforkeypath:of object:change:context:</em>方法。它的实现是强制性的，并且有一个很大的缺点。这是每个KVO变化都需要的事实，如果你观察许多属性，那么你必须写很多的<em class="kf"> if </em>语句，以便对每个属性采取适当的行动。然而，这很容易被忽略，因为KVO的好处大于这一限制。</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mp"><img src="../Images/c98e9d243bf398eac6d7e6abd0558ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FLPsLIreGuYh0fMhu1VTQ.png"/></div></div></figure><p id="8f2b" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">每当添加到观察者的属性值发生变化时，就会调用上述方法。这里通过key-path参数，我们打印了name和age属性的新值和旧值。</p><p id="2d82" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">要测试此功能，请将UIButton的操作连接到viewController，并在该操作方法中添加以下代码行:</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mq"><img src="../Images/9ca2dbbe9a1e31531f0512dc30592f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crDvvttvS9fzV7Rv7H4LKg.png"/></div></div></figure><p id="b74f" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">超级！在我们为<em class="kf"> child1 </em>对象的<em class="kf"> name </em>和<em class="kf"> age </em>属性设置了新值之后，我们收到了通知，我们请求显示的消息显示在调试器上。如您所见，以前的值和新值都包含在字典中。</p><p id="efd4" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">从<em class="kf"> change </em>字典中，你可以提取任何你想要的值(如果需要的话)，但是最重要的是它非常容易被通知属性的变化。</p><p id="2854" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">在按钮操作方法中添加以下代码行，并运行程序。</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mr"><img src="../Images/79d06ab428be76653ff72f940d2b13bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtBEB-t-lkeXGDxS0g3dKQ.png"/></div></div></figure><p id="79cf" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如果您观察结果，我们会收到两个关于对<em class="kf"> age </em>属性进行更改的通知。但这似乎令人困惑，因为即使我们知道每个通知所属的对象，我们也无法通过编程来确定发送通知的对象。那么，我们如何面对这一点，我们如何通过编程来100%确定被更改的属性所属的对象呢？</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff ms"><img src="../Images/4b9e23b7e4b0f666b3587d4173d60577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnWEc3CqxDNDA6kAweut4w.png"/></div></div></figure><p id="1d30" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">以上问题的答案是一:我们将利用<strong class="ja hv"> <em class="kf"> addObserver的<strong class="ja hv"> <em class="kf"> context </em> </strong>参数(&lt;# T # # observer:ns object # # ns object #&gt;，forkey path:&lt;# T # # String #&gt;，options:&lt;# T # # NSKeyValueObservingOptions #&gt;，context:&lt;# T # # unsafmutable erawpoint# &gt; ) </em> </strong>法。我之前已经提到过，上下文的目的是唯一地识别一个属性上的变更，所以它是我们所拥有的最好的工具。</p><p id="da7b" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">这里，我为每个child1和child2定义了两个上下文:</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mt"><img src="../Images/c1d6d880ae8096705f43e742d95d412c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dW69R3ietHZ0mX09NEvHQ.png"/></div></div></figure><p id="7deb" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">注意，每个被观察属性的上下文值必须是一个全局变量，因为它必须可以从<em class="kf"> addObserver… </em>和<em class="kf">observeValueForKeyPath…</em>方法中访问。</p><p id="1c22" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">现在修改child1和child2中的代码，通过传递上下文参数来添加观察者方法。然后我们需要修改observe方法，如下所示:这样我们可以在传递的上下文参数的帮助下识别更改的属性。所以我们设法以编程方式指定每个更改的属性。</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mu"><img src="../Images/073e34b3e2472aa2357a0001199bb322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIzkEnO1V68NE6RS2JYBrA.png"/></div></div></figure><p id="72b9" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">最后，在我们到达本章末尾之前，在某些时候删除您添加的观察者也是非常重要的。没有食谱告诉你应该在哪里做那件事。例如，在许多情况下，在处理了接收到的通知之后，在<em class="kf">observeValueForKeyPath:of object:change:context:</em>中这样做是很有用的。在其他情况下，您应该在解除视图控制器时这样做。一般来说，这取决于你的应用程序的结构。在本例中，我们将在<em class="kf">viewwillddissapear:</em>方法中完成。就是这里:对于<strong class="ja hv"> <em class="kf"> child2，</em> </strong> <em class="kf">我在上面的片段中去掉了观察者。</em></p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mv"><img src="../Images/cf6780a604b86847ceed800eddfe8f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-efsSJcrFAIAPbphbRxoLQ.png"/></div></div></figure><h1 id="a745" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">自动和手动通知</h1><p id="d2b7" class="pw-post-body-paragraph jq jr hu ja b jb lw js jt jd lx ju jv jf ly jx jy jh lz ka kb jj ma kd ke jl hn dt translated">默认情况下，当您使用KVO进行观察时，系统会在每次属性发生更改时发送通知。这在大多数情况下是合适的，但是有时候我们不希望在一个变化发生后得到通知，而是在多个属性发生一系列变化之后或者在稍后的时间。幸运的是，iOS SDK为我们提供了一些非常方便的方法，让我们可以控制通知，所以我们可以在实际需要的时候手动发送它们。在我们进入更多的细节之前，让我说一下，使用你接下来将要看到的方法并不是强制性的。相反，如果真的有必要，你可以实现它。</p><p id="b78d" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">现在进入正题，为了控制属性更改时发送的通知，您必须实现<em class="kf">automatically notifiesobserverforkey:</em>类方法。它接受的参数是您需要控制通知的属性的键的字符串表示，并且它返回一个布尔值。如果您不希望在被观察属性的值被更改后发送通知，那么该方法必须返回false。在任何其他情况下，您应该让iOS决定通知。</p><p id="2176" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">实际上，让我们假设当<em class="kf">子类</em>的<em class="kf">名称</em>属性改变时，我们不希望发布通知。记住这一点，下面是该方法在<em class="kf">子类</em>中的实现</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mw"><img src="../Images/dbe60afc43c2fc8f260f94036175b1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAyjvDOVNMfrkuZDbGNBTw.png"/></div></div></figure><p id="c440" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">在<em class="kf"> else </em>子句中，我们使用<em class="kf"> super </em>类调用相同的方法，以便让iOS处理我们在这里没有显式添加的所有键，并且我们返回的值是我们在最后返回的值。</p><p id="f6dd" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如果您此时运行应用程序，您会发现调试器上没有出现关于名称更改的消息。当然，这是我们所渴望的，所以我们已经设法实现了我们的目标。但是，我们真的做到了吗？</p><p id="2cf9" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">嗯，正如您所理解的，通过在上述方法中为特定的键返回false，我们仅仅成功地阻止了相关通知的发送。当然，这并不意味着手动通知，这意味着根本没有通知！为了在我们决定这样做时发送通知，我们必须使用另外两种方法。它们是<em class="kf"> willChangeValueForKey: </em>和<em class="kf"> didChangeValueForKey: </em>。使用它们时，必须先调用<em class="kf"> willChangeValueForKey: </em>，然后将新值赋给属性，最后调用<em class="kf"> didChangeValueForKey: </em>。要测试手动操作，请在viewcontroller的action方法中添加这些行。</p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mx"><img src="../Images/05f3c9892c392e779c2534f0763010d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGdiNZwtObvlxMNNYDo-Cw.png"/></div></div></figure><p id="767d" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如果您现在运行应用程序，关于名称更改的消息会出现在调试器上，这意味着我们已经成功地手动发送了通知！</p><p id="7b9a" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">实际上，通知是在调用了<em class="kf"> didChangeValueForKey: </em>方法之后发送的，因此将该方法放在您认为适合接收通知的任何地方。</p><p id="02cb" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">这正是我们一直期待的应用程序！正如您所看到的，我们已经成功地控制了通知发送点，而且只需一点点努力！请注意，在<em class="kf"> willChangeValueForKey: </em>和<em class="kf"> didChangeValueForKey: </em>方法之间，可以分配多个属性值。</p><p id="e438" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如上所示，<em class="kf"> willChangeValueForKey: </em>和<em class="kf"> didChangeValueForKey: </em>方法不是必须使用的。它们也可以在<em class="kf">子类</em>中实现(或者在你自己的类中)。</p><p id="df77" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">请点击<a class="ae my" href="https://github.com/penumutchuprasad/KVOKVCExmple" rel="noopener ugc nofollow" target="_blank">此处</a>查看上述教程描述的项目。</p><p id="2fe3" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">参考资料:</p><ol class=""><li id="9e66" class="iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl mz jn jo jp dt translated"><a class="ae my" href="http://michael-brown.net/2017/swift-and-kvo-context-variables/" rel="noopener ugc nofollow" target="_blank">http://Michael-brown . net/2017/swift-and-kvo-context-variables/</a></li><li id="1e3d" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl mz jn jo jp dt translated"><a class="ae my" href="https://www.appcoda.com/understanding-key-value-observing-coding/" rel="noopener ugc nofollow" target="_blank">https://www . app coda . com/understanding-key-value-observing-coding/</a></li><li id="074a" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl mz jn jo jp dt translated"><a class="ae my" href="https://cocoacasts.com/key-value-observing-kvo-and-swift-3" rel="noopener ugc nofollow" target="_blank">https://cocoacasts.com/key-value-observing-kvo-and-swift-3</a></li><li id="168f" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl mz jn jo jp dt translated"><a class="ae my" href="https://www.ralfebert.de/ios-examples/swift/property-key-value-observer/" rel="noopener ugc nofollow" target="_blank">https://www . ralfebert . de/IOs-examples/swift/property-key-value-observer/</a></li><li id="02fa" class="iy iz hu ja b jb kt jd ku jf kv jh kw jj kx jl mz jn jo jp dt translated"><a class="ae my" href="https://blog.scottlogic.com/2015/02/11/swift-kvo-alternatives.html" rel="noopener ugc nofollow" target="_blank">https://blog . Scott logic . com/2015/02/11/swift-kvo-alternatives . html</a></li></ol></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="15dd" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">如果你喜欢我的教程，请在<strong class="ja hv">媒体</strong>上关注我。可以通过<a class="ae my" href="https://twitter.com/Leelakrishn4" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv">我的-twitter </strong> </a>或者<a class="ae my" href="https://www.linkedin.com/in/leela-prasad-penumutchu-b44023157/" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> linkedIn </strong> </a>账号联系我。</p><p id="5200" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">感谢阅读。通过更多的教程会很快变得更好。</p><p id="245c" class="pw-post-body-paragraph jq jr hu ja b jb jc js jt jd je ju jv jf jw jx jy jh jz ka kb jj kc kd ke jl hn dt translated">再见！！！</p></div></div>    
</body>
</html>