<html>
<head>
<title>Git from zero to hero - starting with foundations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到英雄——从基础开始</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/git-from-zero-to-hero-starting-with-foundations-e42e49b524c5?source=collection_archive---------6-----------------------#2018-06-20">https://medium.com/hackernoon/git-from-zero-to-hero-starting-with-foundations-e42e49b524c5?source=collection_archive---------6-----------------------#2018-06-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/4bb6bde296e9d26e3bebeb1a31e37bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*gTEbDtag5NW8NUYbef_Qmg.gif"/></div></figure><p id="5393" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如git页面中所述:</p><p id="359c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">“Git是一个自由开放源码的分布式版本控制系统，旨在快速高效地处理从小型到超大型的所有项目。”— <a class="ae jw" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git-scm </a></p><p id="5b31" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们首先分析一下这意味着什么。</p><p id="6624" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">作为一个<strong class="ja hv">版本控制系统，</strong>意味着它允许你一路上创建你的项目的不同版本。</p><p id="4f95" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">分布式意味着它可以沿着网络复制。这非常合理，因为整个团队都在使用它。</strong></p><p id="17f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先要知道的是git是如何管理事情来执行这个<strong class="ja hv">版本控制</strong>。本文将重点讨论git foundations，以便在接下来的文章中我们能够处理更高级的概念。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><h1 id="6b8c" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">如何进行版本控制</h1><p id="3f89" class="pw-post-body-paragraph iy iz hu ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">要使用git，必须做的第一件事是在文件夹中初始化一个git存储库。当然，您也可以克隆现有的项目，但是让我们从头开始。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="3cec" class="lq kf hu lm b fv lr ls l lt lu">&gt; mkdir git-project<br/>&gt; cd git-project<br/>&gt; git init</span><span id="278d" class="lq kf hu lm b fv lv ls l lt lu">Initialized empty Git repository in /Users/stupidgopher/git-project/.git/</span></pre><p id="f4b0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如您所看到的，一个空的git存储库被初始化在我们目录中的. git文件夹中。</p><p id="1f51" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了保存你的代码版本，你必须执行一个动作，进行一次交互。所以第一个结论是你和git之间有一个互动点。</p><p id="9329" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个交互点被称为提交。提交可以被描述为git的项目变更事务。</p><p id="938d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了提交一些更改，我们必须将文件或文件夹添加到临时区域。阶段可以被描述为一个桶，您可以在其中放置下一个要提交的更改。</p><p id="9ad5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们通过向stage添加我们的第一个文件和文件夹来看看这个操作:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="f79e" class="lq kf hu lm b fv lr ls l lt lu">&gt; mkdir folder<br/>&gt; echo "a file" &gt; folder/A<br/>&gt; echo "a file" &gt; B<br/>&gt; git add folder B<br/>&gt; git status</span><span id="a784" class="lq kf hu lm b fv lv ls l lt lu">On branch master</span><span id="a079" class="lq kf hu lm b fv lv ls l lt lu">No commits yet</span><span id="d6fd" class="lq kf hu lm b fv lv ls l lt lu">Changes to be committed:<br/>  (use "git rm --cached &lt;file&gt;..." to unstage)</span><span id="6b0f" class="lq kf hu lm b fv lv ls l lt lu">new file:   B<br/>new file:   folder/A</span></pre><p id="659a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一条反馈线表示我们在主分支上。分支机构将在下一篇文章中介绍。现在认为大师是我们的背景。</p><p id="8884" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们添加了文件夹和文件B，现在它们都是要提交的更改。</p><p id="4ec2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们提交更改，使用选项<strong class="ja hv"> -m </strong>关联一条消息。关联消息是必须的，所以如果您没有提供<strong class="ja hv"> -m </strong>的关联消息，默认的系统编辑器会提示您一条消息。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0a8e" class="lq kf hu lm b fv lr ls l lt lu">&gt; git commit -m "Adding the first files"</span><span id="fd0b" class="lq kf hu lm b fv lv ls l lt lu">[master (root-commit) 967d0ac] Adding the first files<br/> 2 files changed, 2 insertions(+)<br/> create mode 100644 B<br/> create mode 100644 folder/A</span></pre><p id="9e81" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，我们进行了第一次修改，创建了项目的第一个版本。让我们进行第二次提交，这样您就可以开始了解全局:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="f61a" class="lq kf hu lm b fv lr ls l lt lu">&gt; echo "one more line" &gt;&gt; B # &gt;&gt; appends a new line to the file<br/>&gt; git add B<br/>&gt; git commit -m "Add changes to file B"</span></pre><p id="db84" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们现在有两个提交，第一个用第一行将文件添加到您的git存储库中。第二次提交建立在第一次提交的基础上。</p><p id="8faa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Git就像一个图形数据库，每个提交都建立在前一个的基础上，除了第一个没有任何祖先的提交。因此，从这里您已经可以掌握一个模型，就像我将在下一张图片中展示的模型一样:</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/3da51551d563c831855232f10649e1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*I7iyeEX9w8sklWGJ9PeUIQ.jpeg"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Graph showing a sequence of commits</figcaption></figure><p id="45f4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">每个提交都隐藏在对应于一个版本的快照后面。这是git的一个重要特性，与保存更改的其他版本控制系统相反。为什么这很重要？</p><p id="b75b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们存储了项目的几个版本，那么将来我们可能会想回到以前的提交。通过保存快照而不是更改，我们可以从点D到达点A，而无需重新访问中间点。</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/615a78ab8f57507a7568dc261da44f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*hI6LzGyJxvBcYAWyIGPiVA.jpeg"/></div></figure><h1 id="5d3c" class="ke kf hu bd kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb dt translated">提交id和引用/指针</h1><p id="caeb" class="pw-post-body-paragraph iy iz hu ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">像在任何数据库中一样，记录需要有一个ID。Git也不例外，每次创建提交时，都会有一个新的惟一ID与该提交相关联。在这种情况下，会生成一个<strong class="ja hv"> sha1散列</strong>,以便我们稍后可以识别该提交。</p><p id="20ec" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">提交的另一个重要特征是一旦创建就不能更改。它是不可变的，所以如果我们需要改变包括消息在内的任何东西，必须生成一个新的提交。</p><p id="06e8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们使用几个选项来执行git log命令，这会使输出更漂亮:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1220" class="lq kf hu lm b fv lr ls l lt lu">&gt; git log --pretty --graph --oneline</span><span id="bc57" class="lq kf hu lm b fv lv ls l lt lu">* d316650 (HEAD -&gt; master) Add changes to file B<br/>* 967d0ac Adding the first files</span></pre><p id="9036" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如你在这种情况下看到的，我们的第一次提交有一个以<strong class="ja hv"> 967d0ac </strong>开始的散列，第二次提交有<strong class="ja hv"> d316650 </strong>。如果你跟随并复制我的步骤，你的散列将会不同。</p><p id="30f3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可能注意到，在最后一次提交中，我们有(HEAD -&gt; master)。这表示<strong class="ja hv">头</strong>指向<strong class="ja hv">主分支</strong>并且<strong class="ja hv">主分支</strong>指向最后一次提交。</p><p id="ce19" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> HEAD </strong>是指向项目当前状态的引用。</p><p id="4515" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如你可能已经猜到的，a分支也是一个指针，但是具有不同于HEAD的特征。这将在下一篇文章中解释。</p><h1 id="7716" class="ke kf hu bd kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb dt translated">下钻版本存储</h1><p id="2487" class="pw-post-body-paragraph iy iz hu ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">在这篇文章的结尾，我们将深入研究快照存储，使用提交作为起点。我将要使用的命令对于日常使用并不重要。但是在我看来，重要的是要知道事情是如何在引擎盖下工作的，以便更自信地使用git。</p><p id="62bf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">到目前为止，提交是由一个<strong class="ja hv"> SHA1 ID </strong>和一个提交<strong class="ja hv">消息</strong>定义的。如果我们执行不带选项的git log，我们将看到更多信息:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="a51f" class="lq kf hu lm b fv lr ls l lt lu">&gt; git log<br/>commit d316650f83e2cc2ec2f44485c521b3f42872d403 (HEAD -&gt; master)<br/>Author: *** &lt;<a class="ae jw" href="mailto:henrmota@gmail.com" rel="noopener ugc nofollow" target="_blank">***@gmail.com</a>&gt;<br/>Date:   Sun Jun 17 01:52:53 2018 +0100</span><span id="df02" class="lq kf hu lm b fv lv ls l lt lu">Add changes to file B</span><span id="2a22" class="lq kf hu lm b fv lv ls l lt lu">commit 967d0acee11b5156c48b833c24cc6696e6804bd3<br/>Author: *** &lt;<a class="ae jw" href="mailto:henrmota@gmail.com" rel="noopener ugc nofollow" target="_blank">***@gmail.com</a>&gt;<br/>Date:   Sun Jun 17 01:38:03 2018 +0100</span><span id="291c" class="lq kf hu lm b fv lv ls l lt lu">Adding the first files</span></pre><p id="b17d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">到目前为止，我们得到的是:</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/f6390def55838bf36757bb10440cc6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*1xIM8BvCz6nTd9wyMhQSpQ.jpeg"/></div></figure><p id="26b5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们知道一个提交为<strong class="ja hv">的消息</strong>，<strong class="ja hv">作者</strong>和<strong class="ja hv">日期</strong>。我们没有看到提交是如何引用祖先和那个版本的树的快照的。</p><p id="3a7a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将使用一个新命令<strong class="ja hv"> git cat-file </strong>。Git cat-file为存储库对象提供内容或类型和大小信息，如<a class="ae jw" href="https://git-scm.com/docs/git-cat-file" rel="noopener ugc nofollow" target="_blank"> git手册</a>中所述。</p><p id="b6ac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以git使用对象来存储信息。我们将通过互动的方式来发现这些物品，让我们开始吧:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c7ce" class="lq kf hu lm b fv lr ls l lt lu">&gt; git log --pretty --graph --oneline</span><span id="9ff2" class="lq kf hu lm b fv lv ls l lt lu">* d316650 (HEAD -&gt; master) Add changes to file B<br/>* 967d0ac Adding the first files</span></pre><p id="4c5d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先让我们分析第一次提交:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="78a2" class="lq kf hu lm b fv lr ls l lt lu">&gt; git cat-file -t 967d0ac<br/>commit # the type of this object is commit</span><span id="8562" class="lq kf hu lm b fv lv ls l lt lu">&gt; git cat-file -p 967d0ac<br/>tree 1b8369392f39b30c2da28ae285476572394e145e<br/>author *** &lt;<a class="ae jw" href="mailto:henrmota@gmail.com" rel="noopener ugc nofollow" target="_blank">***@gmail.com</a>&gt; 1529195883 +0100<br/>committer *** &lt;***<a class="ae jw" href="mailto:henrmota@gmail.com" rel="noopener ugc nofollow" target="_blank">@gmail.com</a>&gt; 1529195883 +0100</span><span id="4f5e" class="lq kf hu lm b fv lv ls l lt lu">Adding the first files</span></pre><p id="bf70" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以我们首先用-t执行cat-file来查看提交对象的类型。正如所料，类型是<strong class="ja hv">提交</strong>。其次，我们用-p选项“pretty print”执行了cat-file，我们在对象中有作者和消息。但是新信息是树引用。什么是树对象？</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8e87" class="lq kf hu lm b fv lr ls l lt lu">&gt; git cat-file -t 1b8369392f39b30c2da28ae285476572394e145e<br/>tree</span><span id="7bd6" class="lq kf hu lm b fv lv ls l lt lu">&gt; git cat-file -p 1b8369392f39b30c2da28ae285476572394e145e<br/>100644 blob 02f6335fc4f28cc4ea2d0846aacff267a149effb B<br/>040000 tree da97193026f17ed933494b723517904586648324 folder</span></pre><p id="340b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">树对象，因为他的类型说，这是一个文件树。在这种情况下，树对象作为两个引用。第一个是一个<strong class="ja hv"> blob </strong>，注意在这个引用的前面我们有文件名，在这个例子中是b。第二个是另一个<strong class="ja hv">树</strong>，正如所料，因为正如你所知道的，我们向我们的项目添加了一个文件和一个文件夹。</p><p id="7567" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们分析一下这个斑点:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="5d00" class="lq kf hu lm b fv lr ls l lt lu">&gt; git cat-file -t 02f6335fc4f28cc4ea2d0846aacff267a149effb<br/>blob<br/>&gt; git cat-file -p 02f6335fc4f28cc4ea2d0846aacff267a149effb<br/>a file</span></pre><p id="4f27" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">blob是一个存储文件内容的对象。为了一致起见，让我们在这个blob的同一层上看树。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0584" class="lq kf hu lm b fv lr ls l lt lu">&gt; git cat-file -t da97193026f17ed933494b723517904586648324<br/>tree<br/>&gt; git cat-file -p da97193026f17ed933494b723517904586648324<br/>100644 blob 02f6335fc4f28cc4ea2d0846aacff267a149effb A</span></pre><p id="5431" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">哇，这棵树引用了一个名为<strong class="ja hv"> A </strong>的文件，它和我们之前看到的blob是一样的。这是因为<strong class="ja hv">文件夹</strong>中文件<strong class="ja hv"> A </strong>的内容与文件<strong class="ja hv"> B </strong>的内容相同。Git很聪明，它只存储他需要存储的东西，仅此而已。</p><p id="f01d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以我们分析了第一个提交，这是一个特例，因为它没有任何祖先。让我们看看第二次提交:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c379" class="lq kf hu lm b fv lr ls l lt lu">&gt; git cat-file -t HEAD # HEAD &gt; MASTER &gt; current commit<br/><br/>&gt; git cat-file -p HEAD<br/>tree 3c7e122c50226fdb638ad38f44beffe717d4922e<br/><strong class="lm hv">parent 967d0acee11b5156c48b833c24cc6696e6804bd3</strong><br/>author *** &lt;<a class="ae jw" href="mailto:henrmota@gmail.com" rel="noopener ugc nofollow" target="_blank">***@gmail.com</a>&gt; 1529196773 +0100<br/>committer *** &lt;<a class="ae jw" href="mailto:henrmota@gmail.com" rel="noopener ugc nofollow" target="_blank">***@gmail.com</a>&gt; 1529196773 +0100</span><span id="b529" class="lq kf hu lm b fv lv ls l lt lu">Add changes to file B</span></pre><p id="8919" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意，这个提交中的引用是祖先。</p><p id="5a23" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后让我们看看树。重要的是要记住，第二次提交只在文件b中引入了更改。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="4adf" class="lq kf hu lm b fv lr ls l lt lu">&gt; git cat-file -p 3c7e122c50226fdb638ad38f44beffe717d4922e<br/>100644 blob 84a9ec3809e10f40ac7e1b248e036c0ce1237ee6 B<br/><strong class="lm hv">040000 tree da97193026f17ed933494b723517904586648324 folder</strong></span></pre><p id="c7aa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">文件夹中树的散列保持不变，git只为变化构建新的blobs和树。一切未被触及的都保持原样。</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/52c5e92e36d033e0eee345a441869391.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*cIuOc-HIo73L8FPo3GHHYg.jpeg"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">how git keeps track of versions</figcaption></figure></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><p id="d590" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">希望你喜欢这第一篇文章，如果它太长了，我很抱歉。在下一篇文章中，我们将关注分支。</p><p id="e265" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">和平，</p><p id="127b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">愚蠢的地鼠</p></div></div>    
</body>
</html>