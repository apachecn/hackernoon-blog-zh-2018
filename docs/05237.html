<html>
<head>
<title>The pioneer’s guide to GX — decentralized dependency management on IPFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GX先锋指南——IPFS的分散依赖管理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-pioneers-guide-to-gx-decentralized-dependency-management-on-ipfs-90064858f4c2?source=collection_archive---------9-----------------------#2018-06-21">https://medium.com/hackernoon/the-pioneers-guide-to-gx-decentralized-dependency-management-on-ipfs-90064858f4c2?source=collection_archive---------9-----------------------#2018-06-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0cd6267ff52d9f9104c29cdf549b3e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*482et5cA1DX8CQb69lolVA.jpeg"/></div></div></figure><p id="f6f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于今天的开发人员来说，分散式包管理是一个令人兴奋的工具开发领域。分散的包管理器有可能从现代软件库的互联网络中消除集中的故障点。它们为开发团队提供了一种直接的方法来确保他们的内部代码网络始终可用，同时确保整个互联网上的冗余。分散的包管理器可以使我们的代码——现代社会最有价值的产出之一——更能抵抗篡改、审查和操纵。</p><p id="d59e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也就是说，分散的包管理仍然是不完整的。当将我们的代码发布到围绕数字信息的不变性而构建的网络中时，有许多问题需要解决，在这些网络中，信息的无限拷贝可能随时存在。如果没有中央机构，他们需要新的解决方案来发现、删除信息(例如，内容不归发布者所有)、解决争议和防范潜在的不良行为者。这些问题不仅仅是分散的包管理器所共有的，也是分散的网络所共有的，因此已经提出了一些解决方案，许多其他方案正在积极开发中。也就是说，在使用任何分散的包管理器之前，理解您的风险和责任是很重要的。</p><p id="1493" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在文章中更完整地讨论了我们在分散源代码和网络依赖性时所面临的前景(和一些陷阱)。如果您不熟悉这个主题，我强烈建议您在阅读本教程之前阅读它。在这里，你可以发现<a class="ae ka" rel="noopener" href="/textileio/decentralized-code-distribution-for-the-future-of-open-source-2dc58f1153b2">去中心化的代码分发对于开源的未来。</a></p><p id="b0b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至此，这里简单介绍一下如何使用分散式包管理器<a class="ae ka" href="https://github.com/whyrusleeping/gx" rel="noopener ugc nofollow" target="_blank"> GX </a>(特别是<a class="ae ka" href="https://hackernoon.com/tagged/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a>实现，<a class="ae ka" href="https://github.com/whyrusleeping/gx-go" rel="noopener ugc nofollow" target="_blank"> gx-go </a>)来分发你的代码并管理你在IPFS上的代码依赖。在我们开始之前的最后一件事，这里是GX开发者在他们自己的自述中所说的话，</p><blockquote class="kb kc kd"><p id="7d81" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated">gx是<strong class="je hv">阿尔法质量</strong>。它还不完美，但是已经被证明足够可靠来管理go-ipfs中的依赖关系，并且已经为先锋开发者和早期用户做好了尝试和探索的准备。</p></blockquote><h1 id="bd9e" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">GX和gx-go简介</h1><p id="8834" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">gx-go和<a class="ae ka" href="https://github.com/sterpe/gx-js" rel="noopener ugc nofollow" target="_blank"> gx-js </a>包管理器使用的GX库核心功能。它们共有的基本原则是，</p><ol class=""><li id="23c6" class="ll lm hu je b jf jg jj jk jn ln jr lo jv lp jz lq lr ls lt dt translated">您发布的代码版本由包含的代码的不可变哈希引用。</li><li id="ed57" class="ll lm hu je b jf lu jj lv jn lw jr lx jv ly jz lq lr ls lt dt translated">您链接到代码中的依赖项链接到那些不可变的散列，以便查找和检索代码，并确保您使用的是您期望的版本。</li><li id="6ab1" class="ll lm hu je b jf lu jj lv jn lw jr lx jv ly jz lq lr ls lt dt translated">不可变散列是发布的代码应该在<a class="ae ka" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"> IPFS </a>上可用的地址。</li></ol><p id="40e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一切意味着什么？首先，它使用代码本身的指纹(散列),而不是依赖语义版本化之类的东西作为对特定代码版本的全局引用。GX还支持散列到语义版本的二次映射，这主要是为了改善人类与代码的交互(例如可读性)。这些散列成为IPFS使用的内容寻址系统的<a class="ae ka" rel="noopener" href="/textileio/enabling-the-distributed-web-abf7ab33b638">的一部分。</a></p><p id="d5c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不熟悉IPFS，这里有一些很好的概述来解释什么是<a class="ae ka" rel="noopener" href="/@ConsenSys/an-introduction-to-ipfs-9bba4860abd0">系统</a>、<a class="ae ka" rel="noopener" href="/@jasonrigden/a-very-brief-introduction-to-ipfs-b2356e023b98">它如何工作</a>，以及<a class="ae ka" href="https://ipfs.io/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">在GX之外</a>使用它。需要理解的是，它是一组技术和协议，使任何用户都能够通过分散的计算机网络分发媒体或数据。在GX用户的情况下，他们的代码。只要有人在分发您正在寻找的媒体，您就可以使用IPFS通过网络检索这些数据。</p><p id="eeb1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对GX来说，这种分布模型意味着如果你想在系统上发布你的代码，你需要从让它在IPFS网络上可用开始。虽然您可能是第一个托管这些数据的人，但是一旦其他人开始使用这些数据，其他节点很快就会提供这些数据。纺织品和其他GX用户经常镜像他们使用的代码，增加了网络的冗余和速度。例如，在<a class="ae ka" href="https://github.com/textileio/textile-go/" rel="noopener ugc nofollow" target="_blank">纺织品照片Go库</a>中，我们有一个团队IPFS节点，在那里我们锁定了我们从GX依赖的所有依赖项。</p><p id="ea91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好了，这是基本原理。让我们试着使用它。</p><h1 id="37f3" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">安装GX和gx-go</h1><p id="66fb" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">接下来的两个部分(分发和依赖项管理)都需要这个简单的步骤。让GX和gx-go在您的系统上运行，只需运行以下两个命令。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="d16a" class="mi kj hu me b fv mj mk l ml mm">go get -u github.com/whyrusleeping/gx<br/>go get -u github.com/whyrusleeping/gx-go</span></pre><p id="e39f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只要你把你的根目录和<code class="eh mn mo mp me b">/bin</code>正确地添加到你的<code class="eh mn mo mp me b">path</code>中，上面应该可以使用GX命令行工具。如果上一行对你来说没有意义，在这里继续之前，这里有一些关于开始使用Go的教程。</p><h1 id="cd16" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">分享GX的代码</h1><p id="3a8d" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">我们或多或少偶然发现了GX，因为它是IPFS相关项目中使用的包管理器。但是使用它让我们真正思考了我们上面提到的所有好处。GX最初是为了支持<a class="ae ka" href="https://github.com/whyrusleeping/gx-go" rel="noopener ugc nofollow" target="_blank"> gx-go </a>而编写的，但也有<a class="ae ka" href="https://github.com/sterpe/gx-js" rel="noopener ugc nofollow" target="_blank"> gx-js </a>的，而且最初的<a class="ae ka" href="https://github.com/whyrusleeping/gx" rel="noopener ugc nofollow" target="_blank"> GX </a>代码已经准备好了，可以为任何语言的包管理器分叉。它具有足够的可扩展性，这让我们开始思考IPFS的移动应用商店的未来会是什么样子……不过我们还是留到以后再说吧。在接下来的博客文章中，让我们浏览一下在您自己的项目中使用gx-go的基础知识。</p><h2 id="aedb" class="mi kj hu bd kk mq mr ms ko mt mu mv ks jn mw mx kw jr my mz la jv na nb le nc dt translated">在您的Go项目中设置GX</h2><p id="cfda" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">从Go项目的文件夹中，您只需在终端中运行以下命令，</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="7a0d" class="mi kj hu me b fv mj mk l ml mm">gx init --lang=go</span></pre><p id="3993" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行上面的代码将会在你的文件夹中添加一个<code class="eh mn mo mp me b">package.json</code>文件，其中包含一些与GX一起工作所必需的信息。如果你的项目因为其他原因已经有了一个<code class="eh mn mo mp me b">package.json</code>文件:重要的部分将被添加。以下是GX在你的<code class="eh mn mo mp me b">package.json</code>文件中储存了什么信息的概述。</p><p id="1e7d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的<code class="eh mn mo mp me b">package.json</code>将列出您在该项目中使用的GX版本:</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="c08c" class="mi kj hu me b fv mj mk l ml mm">"gxVersion": "0.12.1",</span></pre><p id="3b1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样从<code class="eh mn mo mp me b">package.json</code>开始，GX添加了导入重写路径。这将指定如何在用户代码中重写import语句(而不是一直向他们显示非人类可读的散列)。这里是我的样子，从我的围棋路径自动检测。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="e86a" class="mi kj hu me b fv mj mk l ml mm">"gx": {<br/>  "dvcsimport": "github.com/textileio/gx-demo"<br/>}</span></pre><p id="7374" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，<code class="eh mn mo mp me b">package.json</code>包含helper命令，稍后它将告诉GX如何为您处理新的发布。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="6160" class="mi kj hu me b fv mj mk l ml mm">"releaseCmd": "git commit -a -m \"gx publish $VERSION\""</span></pre><p id="4999" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。现在，您的代码可以开始在GX上发布了。让我们试着在GX上发布你的代码版本。为此，我们可以使用GX提交我们的代码，它将运行上面的<code class="eh mn mo mp me b">releaseCmd</code>脚本。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="bea8" class="mi kj hu me b fv mj mk l ml mm">gx release 0.0.1-dev</span><span id="2503" class="mi kj hu me b fv nd mk l ml mm">Error: ipfs daemon isn't running</span></pre><p id="faa4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在…你可能已经抓住了第一个问题。正如我在引言中所说，GX使用IPFS来分发你的代码，这意味着你需要在你的系统上运行一个IPFS守护进程。我不打算在这里介绍<a class="ae ka" href="https://ipfs.io/docs/install/" rel="noopener ugc nofollow" target="_blank">安装步骤</a>或<a class="ae ka" href="https://ipfs.io/docs/getting-started/#going-online" rel="noopener ugc nofollow" target="_blank">一行程序，您需要</a>来启动和运行守护程序。但是一旦你这样做了，你应该能够再次运行<code class="eh mn mo mp me b">gx release 0.0.1-dev</code>,并得到一个输出，</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="a060" class="mi kj hu me b fv mj mk l ml mm">gx release 0.0.1-dev </span><span id="4fff" class="mi kj hu me b fv nd mk l ml mm">package gx-demo published with hash: QmZFb51F1rJcHy9UUWWgPvwJAMorMgdzw2a52y2xgjVZJu</span></pre><p id="9a6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，任何人都应该能够通过GX或者直接通过IPFS(甚至是一个网关)访问您的代码。</p><p id="003d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能已经注意到，当您运行<code class="eh mn mo mp me b">gx release</code>时，会创建一个新文件<code class="eh mn mo mp me b">.gx/lastpubver</code>。该文件包含语义版本号到IPFS散列的映射。您应该将这个文件夹包含在您的git历史中，因为它可以在将来的任何时候将代码链接到发行版。与哈希不同，语义版本不能保证是不可变的。即使在GX，你也可以用一套全新的代码重新发布相同的语义版本，因此也有一个新的散列。</p><h2 id="0afc" class="mi kj hu bd kk mq mr ms ko mt mu mv ks jn mw mx kw jr my mz la jv na nb le nc dt translated">出版关于GX的新版本</h2><p id="b696" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">好了，你已经检查并修改了你的代码，现在你准备发布一个新的版本。你现在有几个选择。GX没有太多的规则，所以技术上你可以通过运行<code class="eh mn mo mp me b">gx release 0.0.1-dev</code>再次发布相同的版本号。但是更有可能的是，你想要发布下一个版本，所以只要运行，</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="3589" class="mi kj hu me b fv mj mk l ml mm">gx release 0.0.1</span><span id="59dc" class="mi kj hu me b fv nd mk l ml mm">package gx-demo published with hash: QmcUaXVES69qZEhV8tdUbhYtVBkbGU7b9h7bpvAo6xnvC9<br/>[master 6f1a98f] gx publish 0.0.1<br/> 2 files changed, 2 insertions(+), 2 deletions(-)</span></pre><p id="c943" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你会注意到你的<code class="eh mn mo mp me b">.gx/lastpubver</code>已经更新了，现在你可以在网上分享你的新散列了。</p><h1 id="9853" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">从GX安装依赖项</h1><p id="a809" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如果你想编写源代码，防止集中式服务离线、改变路线图或被阻塞，那么你可能想使用GX来管理你的依赖关系。你不一定要在GX上发布你的项目才能以这种方式使用GX，也不是每个图书馆都能在IPFS上找到，但希望在未来的几个月里会有越来越多的图书馆能找到。</p><p id="fa2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">那么我们来看看。</strong></p><p id="530e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以做的第一件事是导入一个新的依赖项。你需要有一个目标哈希，GX才能做任何事情。好的，这是一个我们可以使用<a class="ae ka" href="https://github.com/mr-tron/base58" rel="noopener ugc nofollow" target="_blank">https://github.com/mr-tron/base58</a>的<a class="ae ka" href="https://hackernoon.com/tagged/open-source" rel="noopener ugc nofollow" target="_blank">开源</a>项目。它是一个简单的库，可以在Go中把<code class="eh mn mo mp me b">strings</code>转换成<code class="eh mn mo mp me b">base58</code>的形式。因此，如果你知道你在找什么，你会注意到回购不包含任何<code class="eh mn mo mp me b">.gx/pubver</code>文件。所以我们有几个选择:</p><ul class=""><li id="c2f1" class="ll lm hu je b jf jg jj jk jn ln jr lo jv lp jz ne lr ls lt dt translated">我们可以使用上一节中的步骤将GX添加到项目中，并以这种方式获得散列。之后，我们可以使用和共享这种依赖性，并通过将源代码锁定在我们的IPFS节点上来帮助解决网络问题。</li><li id="a7c6" class="ll lm hu je b jf lu jj lv jn lw jr lx jv ly jz ne lr ls lt dt translated">我们可以说服业主自己做。</li></ul><p id="3ca7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对我们来说很容易，有人已经采取了这个项目的第一条路线。分叉原来的base58项目，在这里发布分叉GX版本，<a class="ae ka" href="https://github.com/gxed/base58" rel="noopener ugc nofollow" target="_blank">https://github.com/gxed/base58</a>。所以现在，我们可以使用发布的散列来尝试和安装导入。</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="362b" class="mi kj hu me b fv mj mk l ml mm">gx import QmWFAMPqsEyUX7gDUsRVmMWz59FxSpJ1b2v6bJ1yYzo7jY</span><span id="044f" class="mi kj hu me b fv nd mk l ml mm">update imports of github.com/mr-tron/base58 to the newly imported package? [y/N]</span></pre><p id="4313" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">通过对提示</strong>回答 <code class="eh mn mo mp me b"><strong class="je hv">yes</strong></code> <strong class="je hv">，您将提示GX重写库的导入以使用GX提供的库。所以在这种情况下<code class="eh mn mo mp me b">import github.com/mr-tron/base58</code>看起来更像<code class="eh mn mo mp me b">import gx/ipfs/QmWFAMPqsEyUX7gDUsRVmMWz59FxSpJ1b2v6bJ1yYzo7jY/go-base58-fast/base58</code>。建议你<strong class="je hv">而不是</strong> <strong class="je hv">将你的项目发布</strong>到GX，并重写它们的导入。相反，让下游的GX来处理这个问题。</strong></p><p id="508e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GX将使用您的<code class="eh mn mo mp me b">package.json</code>文件来跟踪这些依赖关系，并处理未来的重写/取消重写。您可以在<code class="eh mn mo mp me b">gxDependencies</code>部分找到GX托管依赖项的列表，看起来像这样，</p><pre class="lz ma mb mc fq md me mf mg aw mh dt"><span id="fa71" class="mi kj hu me b fv mj mk l ml mm">"gxDependencies": [<br/>    {<br/>      "author": "mr-tron",<br/>      "hash": "QmWFAMPqsEyUX7gDUsRVmMWz59FxSpJ1b2v6bJ1yYzo7jY",<br/>      "name": "go-base58-fast",<br/>      "version": "0.1.1"<br/>    }<br/>  ]</span></pre><h1 id="3507" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">今天就开始使用GX！</h1><p id="bdb0" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">就这样，只需几个命令，你就可以开始运行了…但是…哦，等等。你可能会遇到一些关于项目可用性的障碍。在<a class="ae ka" href="https://textile.photos/" rel="noopener ugc nofollow" target="_blank"> Textile </a>，我们在代码上合作，每个人都可以更新依赖关系。这意味着，如果我添加了一个依赖项，并且是第一个固定源代码的IPFS同事，当我的任何合作者试图安装它并且代码不可用时，他们可能会遇到困难。GX尽了最大努力，但有时仍有问题。为了在我们的团队中解决这个问题，我们已经将所有的GX依赖项都绑定到了我们共享的IPFS服务器上。</p><p id="6451" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过锁定我们工作所依赖的代码，我们还可以提高网络的冗余性和可用性。你应该加入进来:)</p><p id="ff91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您对我们更多的开发工作感兴趣，请查看我们在GitHub上的<a class="ae ka" href="https://github.com/textileio/textile-go/" rel="noopener ugc nofollow" target="_blank"> textile-go </a>库或<a class="ae ka" href="https://github.com/textileio/textile-mobile/" rel="noopener ugc nofollow" target="_blank"> textile-mobile </a>库。如果您对IPFS网络的其他想法感兴趣，请查看我们的<a class="ae ka" rel="noopener" href="/textileio/adding-the-next-million-peers-to-ipfs-76d356352d14">计划，将下一批1，000，000名同行加入该网络</a>。当然，如果你只是想让IPFS在你的手机上运行，存储和保存你的照片，或者实现点对点共享，<a class="ae ka" href="https://textile.photos/join" rel="noopener ugc nofollow" target="_blank">请加入我们的手机应用程序</a>试用列表。</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>