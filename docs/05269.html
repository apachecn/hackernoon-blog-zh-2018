<html>
<head>
<title>Traffic routing between functions using Fn Project and Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fn Project和Istio的功能间流量路由</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/traffic-routing-between-fn-functions-using-fn-project-and-istio-fd56607913b8?source=collection_archive---------9-----------------------#2018-06-22">https://medium.com/hackernoon/traffic-routing-between-fn-functions-using-fn-project-and-istio-fd56607913b8?source=collection_archive---------9-----------------------#2018-06-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9543c989b9606f157876b15c38d39613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bjDqgcirv9x1L0nt"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@danfreemanphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Freeman</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7bed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di">在本文中，我将解释如何使用<a class="ae jg" href="http://istio.io" rel="noopener ugc nofollow" target="_blank"> Istio </a>服务网格在<a class="ae jg" href="https://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn功能</a>之间实现基于版本的流量路由。</span></p><p id="801a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将首先解释<a class="ae jg" href="http://istio.io" rel="noopener ugc nofollow" target="_blank"> Istio </a>路由的基础知识以及Fn在Kubernetes上部署和运行的方式。最后，我将解释我如何能够利用Istio服务网格及其路由规则在两个不同的Fn功能之间路由流量。</p><p id="ca14" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，下面的解释非常基本和简单——我的意图不是解释Istio或Fn的深入工作，相反，我想解释足够多，这样您就可以理解如何让路由自己工作。</p><h1 id="8ec5" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">Istio路由101</h1><p id="3d05" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated">让我们花点时间来解释一下Istio路由是如何工作的。Istio使用一个sidecar容器(<code class="eh lr ls lt lu b">istio-proxy</code>)，您可以将它注入到部署中。然后，注入的代理劫持进出该pod的所有网络流量。您的部署中所有这些代理的集合与Istio系统的其他部分进行通信，以确定如何以及在何处<a class="ae jg" href="https://istio.io/docs/tasks/traffic-management/request-routing/" rel="noopener ugc nofollow" target="_blank">路由流量</a>(以及其他一些很酷的东西，如<a class="ae jg" href="https://istio.io/docs/tasks/traffic-management/mirroring/" rel="noopener ugc nofollow" target="_blank">流量镜像</a>、<a class="ae jg" href="https://istio.io/docs/tasks/traffic-management/fault-injection/" rel="noopener ugc nofollow" target="_blank">故障注入</a>和<a class="ae jg" href="https://istio.io/docs/tasks/traffic-management/circuit-breaking/" rel="noopener ugc nofollow" target="_blank">电路中断</a>)。</p><p id="4702" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了解释这是如何工作的，我们将从一个Kubernetes服务(<code class="eh lr ls lt lu b">myapp</code>)和两个版本特定的应用部署(<code class="eh lr ls lt lu b">v1</code>和<code class="eh lr ls lt lu b">v2</code>)开始。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lv"><img src="../Images/557570194eea2727efbdabaa5f1d9035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6w-SFpYJl5EBYMZItTQ2g.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Service routing to all app versions</figcaption></figure><p id="9de2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上图中，我们有一个选择器设置为<code class="eh lr ls lt lu b">app=myapp</code>的<code class="eh lr ls lt lu b">myapp</code> Kubernetes服务，这意味着它将查找所有设置了<code class="eh lr ls lt lu b">app=myapp</code>标签的pod，并将流量路由给它们。基本上，如果你做了一个<code class="eh lr ls lt lu b">curl myapp-service</code>操作，你会得到一个响应，要么来自运行v1版本的应用程序，要么来自运行v2版本的应用程序。</p><p id="c99f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在那里还有两个Kubernetes部署——这些部署运行着<code class="eh lr ls lt lu b">myapp</code> v1和v2代码。除了<code class="eh lr ls lt lu b">app=myapp</code>标签，每个pod还具有设置为<code class="eh lr ls lt lu b">v1</code>或<code class="eh lr ls lt lu b">v2</code>的<code class="eh lr ls lt lu b">version</code>标签。</p><p id="ea04" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上图中的一切都是Kubernetes开箱即用的结果。</p><p id="6329" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">输入Istio。为了能够进行更加智能和基于权重的路由，我们需要安装<a class="ae jg" href="http://istio.io" rel="noopener ugc nofollow" target="_blank"> Istio </a>，然后将代理注入我们的每个pod，如下图所示。下图中的每个窗格都有一个包含Istio代理(由蓝色图标表示)的容器和运行应用程序的容器。在上图中，我们在每个pod中只运行了一个容器app容器。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lv"><img src="../Images/1f9a1af3871ff8f11bab65818e55e2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJZqOqNAryl34XxdlW2vTw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Pods with Istio proxy sidecars</figcaption></figure><blockquote class="ma mb mc"><p id="6954" class="jh ji md jj b jk jl jm jn jo jp jq jr me jt ju jv mf jx jy jz mg kb kc kd ke hn dt translated">请注意，还有比图中所示更多的东西。我没有展示同样部署在Kubernetes集群上的其他Istio pods和服务——注入的Istio代理与这些pods和服务通信，以便知道如何正确地路由流量。有关Istio不同部分的深入解释，请参见此处的文档<a class="ae jg" href="https://istio.io/docs/concepts/traffic-management/overview/" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><p id="cd0a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们可以在这一点上卷曲<code class="eh lr ls lt lu b">myapp</code>服务，我们仍然会得到与第一张图中的设置完全相同的结果——来自<code class="eh lr ls lt lu b">v1</code>和<code class="eh lr ls lt lu b">v2</code>pod的随机响应。唯一的区别是网络流量从服务流向pod的方式。在第二种情况下，对服务的任何调用都在Istio代理中结束，然后代理决定(基于任何定义的路由规则)将流量路由到哪里。</p><p id="1e4e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就像当今几乎所有的东西一样，Istio路由规则是使用YAML定义的，它们看起来像这样:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/e22c15721ca5e6d76427d6b341a1fef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGqVjIDow2pEldMfxmki8Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Route all traffic coming to myapp-service to pods, labeled “v1”</figcaption></figure><p id="bc38" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的路由规则接收到达<code class="eh lr ls lt lu b">myapp-service</code>的请求，并将它们重新路由到标记为<code class="eh lr ls lt lu b">version=v1</code>的pod。以下是具有上述路由规则的图表的外观:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lv"><img src="../Images/6472f8c8de493b17f6934a122a8b4d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4DSAqKQ3_VChe0RJVmWPw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Routing to v1 pods</figcaption></figure><p id="6340" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">底部的大Istio图标代表Istio部署/服务，除了其他事情之外，路由规则是从这里读取的。然后，这些规则用于重新配置在每个pod内运行的Istio代理边车。</p><p id="9676" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这个规则，如果我们卷曲服务，我们只能从标有<code class="eh lr ls lt lu b">version=v1</code>的容器中得到响应(在图中用蓝色连接器表示)。</p><p id="c8ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既然我们已经知道了路由是如何工作的，我们可以研究一下<a class="ae jg" href="http://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn </a>，部署它，看看它是如何工作的，以及我们是否可以使用Istio来建立路由。</p><h1 id="3315" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">Kubernetes上的Fn函数</h1><p id="ebb9" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di">我们</span>将从Kubernetes上<a class="ae jg" href="http://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn </a>的一些片段的基本图开始。您可以使用<a class="ae jg" href="http://github.com/fnproject/fn-helm" rel="noopener ugc nofollow" target="_blank">掌舵图</a>在您的Kubernetes集群上部署Fn。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/3505ff055ebf1e0eb14d299b2fc9a6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*eXGvk4PNnd8Pj0lM6z_j-Q.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A simple representation of Fn on Kubernetes</figcaption></figure><p id="905a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">图表顶部的Fn API服务是Fn的入口点，用于管理您的功能(创建、部署、运行等)。)—这是在Fn项目中被称为<code class="eh lr ls lt lu b">FN_API_URL</code>的URL。</p><p id="d5f2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该服务进而将调用路由到Fn负载平衡器(即任何标有<code class="eh lr ls lt lu b">role=fn-lb</code>的pods)。然后负载均衡器施展魔法，将调用路由到<code class="eh lr ls lt lu b">fn-service</code> pod的一个实例。这些是作为Kubernetes守护进程集的一部分部署的，通常每个Kubernetes节点都有一个pod实例。</p><p id="4c22" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这些简单的基础知识，让我们创建和部署一些功能，并考虑如何进行流量路由。</p><h1 id="f8a9" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">创建和部署功能</h1><p id="1a53" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di">如果</span>您想跟进，请确保您已经将<a class="ae jg" href="https://hackernoon.com/part-ii-fn-load-balancer-585babd90456" rel="noopener ugc nofollow" target="_blank"> Fn部署到您的Kubernetes集群</a>(我使用的是Mac版Docker)并安装了<a class="ae jg" href="https://github.com/fnproject/cli" rel="noopener ugc nofollow" target="_blank"> Fn CLI </a>，然后运行以下程序来创建应用程序和一些功能:</p><pre class="lw lx ly lz fq mj lu mk ml aw mm dt"><span id="32ef" class="mn kp hu lu b fv mo mp l mq mr"># Create the app folder<br/>mkdir hello-app &amp;&amp; cd hello-app<br/>echo "name: hello-app" &gt; app.yaml</span><span id="6d5a" class="mn kp hu lu b fv ms mp l mq mr"># Create a V1 function<br/>mkdir v1<br/>cd v1<br/>fn init --name v1 --runtime go<br/>cd ..</span><span id="047c" class="mn kp hu lu b fv ms mp l mq mr"># Create a V2 function<br/>mkdir v2<br/>cd v2<br/>fn init --name v2 --runtime go<br/>cd ..</span></pre><p id="c8a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用上面的命令，您已经为应用程序创建了一个名为<code class="eh lr ls lt lu b">hello-app</code>的根文件夹。在这个文件夹中，我们创建了两个文件夹，每个都有一个功能— <strong class="jj hv"> v1 </strong>和<strong class="jj hv"> v2。</strong>样板Go函数是使用<code class="eh lr ls lt lu b">fn init</code>创建的，Go被指定为运行时——这是文件夹结构的样子:</p><pre class="lw lx ly lz fq mj lu mk ml aw mm dt"><span id="7733" class="mn kp hu lu b fv mo mp l mq mr">.<br/>├── app.yaml<br/>├── v1<br/>│   ├── Gopkg.toml<br/>│   ├── func.go<br/>│   ├── func.yaml<br/>│   └── test.json<br/>└── v2<br/>    ├── Gopkg.toml<br/>    ├── func.go<br/>    ├── func.yaml<br/>    └── test.json</span></pre><p id="fd3d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">打开两个文件夹中的<code class="eh lr ls lt lu b">func.go</code>,更新返回的消息，使其包含版本号——我们这样做的唯一原因是为了快速区分哪个函数被调用。v1 <code class="eh lr ls lt lu b">func.go</code>应该是这样的(<code class="eh lr ls lt lu b">Hello V1</code>):</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/1e00bddab8ded3927bdfeff074a517f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tz7dz7HPsQabsOZSjnn1tw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Hello V1</figcaption></figure><p id="0da6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完成这些更改后，您可以将这些功能部署到Kubernetes上运行的Fn服务中。为此，您必须设置<code class="eh lr ls lt lu b">FN_REGISTRY</code>环境变量来指向您的Docker注册用户名。</p><blockquote class="ma mb mc"><p id="e2ac" class="jh ji md jj b jk jl jm jn jo jp jq jr me jt ju jv mf jx jy jz mg kb kc kd ke hn dt translated">因为我们在Kubernetes集群上运行Fn，所以我们不能使用本地构建的映像——它们需要被推送到可由Kubernetes集群访问的Docker注册表。</p></blockquote><p id="6d84" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以使用<a class="ae jg" href="https://github.com/fnproject/cli" rel="noopener ugc nofollow" target="_blank"> Fn CLI </a>来部署这些功能:</p><pre class="lw lx ly lz fq mj lu mk ml aw mm dt"><span id="6e8b" class="mn kp hu lu b fv mo mp l mq mr">FN_API_URL=http://localhost:80 fn deploy --all</span></pre><blockquote class="ma mb mc"><p id="7d1e" class="jh ji md jj b jk jl jm jn jo jp jq jr me jt ju jv mf jx jy jz mg kb kc kd ke hn dt translated">上述命令假设Fn API服务在localhost:80上公开(如果您在Docker for Mac中使用Kubernetes支持，这是默认的)。如果使用不同的群集，可以用fn-api服务的外部IP地址替换FN_API_URL。</p></blockquote><p id="74b9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Docker构建和推送完成后，我们的功能被部署到Fn服务中，我们可以尝试调用它们。</p><p id="4fd5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">部署到Fn服务的任何功能都有一个唯一的URL，其中包含应用程序名称和路由名称。通过我们的应用名称和路线，我们可以在<code class="eh lr ls lt lu b">http://$(FN_API_URL)/r/hello-app/v1</code>访问部署的功能。所以，如果我们想称之为<code class="eh lr ls lt lu b">v1</code>路线，我们可以这样做:</p><pre class="lw lx ly lz fq mj lu mk ml aw mm dt"><span id="6ee7" class="mn kp hu lu b fv mo mp l mq mr">$ curl <a class="ae jg" href="http://localhost/r/hello-app/v1" rel="noopener ugc nofollow" target="_blank">http://localhost/r/hello-app/v1</a><br/>{"message":"Hello V1"}</span></pre><p id="e250" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">类似地，调用<code class="eh lr ls lt lu b">v2</code>路由返回Hello V2消息。</p><h2 id="f41f" class="mn kp hu bd kq mu mv mw ku mx my mz ky js na nb lc jw nc nd lg ka ne nf lk ng dt translated">但是函数在哪里运行呢？</h2><p id="ca95" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">如果您在调用函数时查看正在创建/删除的窗格，您会注意到实际上没有什么变化，即没有创建或删除窗格。原因是Fn不能创建像Kubernetes pods那样的功能，因为那样太慢了。相反，所有Fn功能部署和调用都发生在fn-service pods内部。然后，Fn负载平衡器负责放置和路由到这些pod，以最佳方式部署/执行功能。</p><p id="c632" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们没有得到Kubernetes pods/services for functions，但是Istio要求我们有可以路由到的服务和pods…在这种情况下，我们该做什么以及如何使用Istio？</p><h1 id="f7aa" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">这个想法</h1><p id="2b9b" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di"> L </span>让我们暂时抛开这些功能，思考一下Istio路由工作需要什么:</p><ul class=""><li id="e748" class="nh ni hu jj b jk jl jo jp js nj jw nk ka nl ke nm nn no np dt translated">Kubernetes服务——我们hello-app的入口</li><li id="ef75" class="nh ni hu jj b jk nq jo nr js ns jw nt ka nu ke nm nn no np dt translated">针对v1 hello-app的Kubernetes部署</li><li id="6586" class="nh ni hu jj b jk nq jo nr js ns jw nt ka nu ke nm nn no np dt translated">针对v2 hello-app的Kubernetes部署</li></ul><p id="50f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如在Istio Routing 101的文章开头所解释的，我们还必须为我们的两个部署添加一个代表版本的标签和<code class="eh lr ls lt lu b">app=hello-app</code>标签。服务上的选择器将只有<code class="eh lr ls lt lu b">app=hello-app</code>标签——特定于版本的标签将由Istio路由规则添加。</p><p id="b4d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为此，每个版本特定的部署都需要在正确的路径(例如<code class="eh lr ls lt lu b">/r/hello-app/v1</code>)上调用Fn负载均衡器。由于一切都在Kubernetes中运行，并且我们知道Fn负载平衡器服务的名称，我们可以实现这一点。</p><p id="840e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们的部署中需要一个容器，当被调用时，它会将调用转发到特定路径上的Fn负载平衡器。</p><p id="fecb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是用图表表示的上述想法:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/07a17f00444de23c7fba4a076402e07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*nrP0L_uSR7aCXBGByeZtcg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Version specific deployments calling the Fn API service at exact path</figcaption></figure><p id="2a66" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们有一个代表我们的应用程序的服务和两个特定于版本的部署，并直接路由到Fn服务中运行的功能。</p><h2 id="9bed" class="mn kp hu bd kq mu mv mw ku mx my mz ky js na nb lc jw nc nd lg ka ne nf lk ng dt translated">简单代理</h2><p id="383a" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di">要实现这一点，我们需要某种代理来接收任何传入的呼叫，并将它们转发给Fn服务。下面是一个简单的Nginx配置，它可以做到这一点:</span></p><pre class="lw lx ly lz fq mj lu mk ml aw mm dt"><span id="b747" class="mn kp hu lu b fv mo mp l mq mr">events {<br/>    worker_connections  4096;<br/>}</span><span id="b0aa" class="mn kp hu lu b fv ms mp l mq mr">http {<br/>    upstream fn-server {<br/>        server <strong class="lu hv">my-fn-api.default</strong>;<br/>    }</span><span id="7bc6" class="mn kp hu lu b fv ms mp l mq mr">server {<br/>        listen 80;</span><span id="3712" class="mn kp hu lu b fv ms mp l mq mr">location / {<br/>            proxy_pass <a class="ae jg" href="http://fn-server/r/hello-app/v1" rel="noopener ugc nofollow" target="_blank">http://fn-server/<strong class="lu hv">r/hello-app/v1</strong></a>;<br/>            proxy_set_header X-Real-IP  $remote_addr;<br/>            proxy_set_header X-Forwarded-For $remote_addr;<br/>            proxy_set_header Host $host;<br/>        }<br/>    }<br/>}</span></pre><p id="fa5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了解释配置:我们说每当有东西进入/，就把那个调用传递给<code class="eh lr ls lt lu b"> <a class="ae jg" href="http://fn-server/r/hello-app/v1," rel="noopener ugc nofollow" target="_blank">http://fn-server/r/hello-app/v1</a></code> <a class="ae jg" href="http://fn-server/r/hello-app/v1," rel="noopener ugc nofollow" target="_blank">，</a>，其中<code class="eh lr ls lt lu b">fn-server</code>(定义为上游)被解析为<code class="eh lr ls lt lu b">my-fn-api.default</code>——这是运行在<code class="eh lr ls lt lu b">default</code>名称空间中的fn-api的Kubernetes服务名。</p><p id="ed5f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了对<code class="eh lr ls lt lu b">v2</code>做同样的事情，粗体部分是我们唯一需要改变的。</p><p id="d7b0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我用一个脚本创建了一个Docker映像，该脚本根据您传入的上游和路由值生成Nginx配置。图片可以在<a class="ae jg" href="https://hub.docker.com/r/pj3677/simple-proxy/" rel="noopener ugc nofollow" target="_blank"> Docker hub </a>上获得，你可以在这里查看图片来源<a class="ae jg" href="https://github.com/peterj/fn-simple-proxy" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="db68" class="mn kp hu bd kq mu mv mw ku mx my mz ky js na nb lc jw nc nd lg ka ne nf lk ng dt translated">部署到Kubernetes</h2><p id="18b0" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated">现在，我们可以为服务、部署和用于访问功能的入口创建Kubernetes YAML文件。</p><p id="c71c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是部署文件的摘录，展示了我们如何为<code class="eh lr ls lt lu b">UPSTREAM</code>和<code class="eh lr ls lt lu b">ROUTE</code>以及标签设置环境变量。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/2efd7dbb75f27bc4eb613687628667c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41VRsFr66EWiPEnMsvPOaw.png"/></div></div></figure><p id="e039" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">简单代理容器读取<code class="eh lr ls lt lu b">UPSTREAM</code>和<code class="eh lr ls lt lu b">ROUTE</code>环境变量，并根据这些值生成Nginx配置。</p><p id="e70f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">服务YAML文件也没什么特别的——我们只是将选择器设置为<code class="eh lr ls lt lu b">app: hello-app</code>:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/02eb45df574fd43a1d47cc81cd14f6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLsp-8E4A7LUCvKgZRweBg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Service definition</figcaption></figure><p id="a4be" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后一部分是Istio入口，我们在这里设置规则，将所有传入流量路由到后端服务:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/6951cf9522b5dc8b6b9079952c44a230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZS3wp0Q8GUWjmEuLcEz-vQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Ingress</figcaption></figure><p id="b66a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要部署这些，您可以使用<code class="eh lr ls lt lu b">kubectl</code>来部署入口和服务，使用<code class="eh lr ls lt lu b">istioctl kube-inject</code>来部署以注入Istio代理。</p><p id="b1fb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">部署好所有东西后，您最终应该会得到以下Kubernetes资源:</p><ul class=""><li id="0663" class="nh ni hu jj b jk jl jo jp js nj jw nk ka nl ke nm nn no np dt translated">hello-app-deployment-v1(使用指向v1路由的简单代理映像的部署)</li><li id="f8d1" class="nh ni hu jj b jk nq jo nr js ns jw nt ka nu ke nm nn no np dt translated">hello-app-deployment-v2(使用指向v2路由的简单代理映像的部署)</li><li id="71f1" class="nh ni hu jj b jk nq jo nr js ns jw nt ka nu ke nm nn no np dt translated">hello-app-service(针对hello-app部署中的v1和v2 pods的服务)</li><li id="4d56" class="nh ni hu jj b jk nq jo nr js ns jw nt ka nu ke nm nn no np dt translated">指向hello-app-service的入口，使用“istio”入口类注释进行注释</li></ul><p id="cc2b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果我们调用hello-app-service或者调用ingress，我们应该会从v1和v2函数得到随机响应。下面是对入口的调用输出示例:</p><pre class="lw lx ly lz fq mj lu mk ml aw mm dt"><span id="b2a7" class="mn kp hu lu b fv mo mp l mq mr">$ while true; do sleep 1; curl <a class="ae jg" href="http://localhost:8082;done" rel="noopener ugc nofollow" target="_blank">http://localhost:8082;done</a><br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V2"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V2"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V2"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V1"}<br/>{“message”:”Hello V2"}</span></pre><p id="1a64" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你会注意到我们随机从V1和V2得到回复——这正是我们此时想要的！</p><h1 id="7026" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">Istio规则！</h1><p id="f795" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di">随着我们的服务和部署的启动和运行(以及工作),我们可以为Fn功能创建Istio路由规则。让我们从一个简单的v1规则开始，它将把所有(<code class="eh lr ls lt lu b">weight: 100</code>)到<code class="eh lr ls lt lu b">hello-app-service</code>的呼叫路由到标记为<code class="eh lr ls lt lu b">v1</code>的pod:</span></p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/deed6a5f3a4072dcfc2369c48d14c595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QTpQ3mt0_msCoF8AkJQig.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Route all calls to v1 label</figcaption></figure><p id="387b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以通过运行<code class="eh lr ls lt lu b">kubectl apply -f v1-rule.yaml</code>来应用这个规则。查看路由运行情况的最佳方式是运行一个不断调用端点的循环——这样您可以看到响应从mixed (v1/v2)到all v1。</p><p id="21ff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如我们对权重为100的<code class="eh lr ls lt lu b">v1</code>规则所做的那样，我们可以类似地定义一个将所有内容路由到<code class="eh lr ls lt lu b">v2</code>的规则，或者一个将50%的流量路由到<code class="eh lr ls lt lu b">v1</code>和50%的流量路由到<code class="eh lr ls lt lu b">v2</code>的规则，如下面的演示所示。</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nx ny l"/></div></figure><p id="7441" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我证明这可以用简单的curl命令工作，我就停止了:)</p><p id="1d0b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">幸运的是，<a class="ae jg" rel="noopener" href="/@carimura/the-importance-of-devops-to-serverless-f671070efb9"> Chad Arimura </a>在他关于DevOps对无服务器的重要性的文章中更进一步(剧透:DevOps不会消失)。他使用Spinnaker对运行在实际Kubernetes集群上的Fn函数进行了加权蓝绿色部署。请看下面他的演示视频:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nx ny l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Spinnaker — Fn Project — Istio — Kubernetes in action</figcaption></figure><h1 id="1c69" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">结论</h1><p id="9559" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt kf translated">每个人都会同意，服务网格在函数世界中是重要的，并且将会是重要的。如果使用服务网格，可以获得很多好处——比如路由、流量镜像、故障注入和一堆其他东西。</p><p id="ad3b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我认为最大的挑战是缺乏以开发人员为中心的工具，这些工具可以让开发人员利用所有这些又好又酷的功能。设置这个项目并演示运行几次并不太复杂。</p><p id="9592" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是这两个函数几乎只返回一个字符串，不做任何其他事情。这是一个简单的演示。只要想想运行数百或数千个函数，并在它们之间设置不同的路由规则。然后考虑管理所有这些。或者推出新版本并监控故障。</p><p id="c3d8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我认为，在使功能管理、服务网格管理、路由、[插入其他很酷的功能]以一种对所有相关人员都很直观的方式工作方面，存在巨大的机遇(和挑战)。</p><h1 id="5584" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">感谢阅读！</h1><p id="2b63" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">欢迎对本文的任何反馈！你也可以在<a class="ae jg" href="http://twitter.com/pjausovec" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae jg" href="http://github.com/peterj" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。如果你喜欢这个并且想在我写更多东西的时候得到通知，你应该订阅<a class="ae jg" href="https://tinyletter.com/pjausovec" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>