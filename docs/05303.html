<html>
<head>
<title>Implementing hidesNavigationBarWhenPushed on UIViewController</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在UIViewController上实现hidesNavigationBarWhenPushed</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/implementing-hidesnavigationbarwhenpushed-on-uiviewcontroller-10d8a68bca86?source=collection_archive---------6-----------------------#2018-06-24">https://medium.com/hackernoon/implementing-hidesnavigationbarwhenpushed-on-uiviewcontroller-10d8a68bca86?source=collection_archive---------6-----------------------#2018-06-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c330" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">距离我上次发帖已经有一段时间了。</p><p id="b03b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我回来了，希望花更多的时间来写教程和开源有趣的东西。</p><h2 id="e454" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">这篇文章是关于什么的？</h2><p id="bc23" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在这篇文章中，我想浏览一下最近发布的<a class="ae kp" href="https://github.com/gontovnik/HidesNavigationBarWhenPushed/" rel="noopener ugc nofollow" target="_blank">HidesNavigationBarWhenPushed</a>库，并解释其背后的动机和实现。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/c7a0f208d103ec79d5a184f9149513b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*mNyuMf-LPMhz38AePUaNcA.gif"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">hidesNavigationBarWhenPushed in action (With interactive pop gesture recognizer)</figcaption></figure><h2 id="2dfb" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">动机</h2><p id="68db" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">当<a class="ae kp" href="https://hackernoon.com/tagged/hacking" rel="noopener ugc nofollow" target="_blank">在各种项目上破解</a>时，我不时地得到这样的设计，视图控制器A有<a class="ae kp" href="https://hackernoon.com/tagged/navigation-bar" rel="noopener ugc nofollow" target="_blank">导航条</a>可见，而视图控制器B隐藏了导航条。让它运转起来总是很痛苦。</p><p id="53bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最简单的解决方案是:</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="1441" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它是这样工作的:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/fa15bc83c5154098d7e5b62e1a4a89da.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*xQqdDVwfl7y6KhUHVWTCzg.gif"/></div></figure><p id="96b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这并不十分奏效，因为关键要求是<strong class="it hv">保持</strong>导航条标题和按钮转换相同，就好像导航条是可见的一样。</p><p id="f148" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我想…</p><blockquote class="le"><p id="378d" class="lf lg hu bd lh li lj lk ll lm ln jo ek translated"><em class="lo">如果在推送或弹出时，我可以隐藏现有的导航栏，而显示假的导航栏，会怎么样？</em></p></blockquote><h2 id="6f91" class="jp jq hu bd jr js lp ju jv jw lq jy jz jc lr kb kc jg ls ke kf jk lt kh ki kj dt translated">调查</h2><p id="87f0" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在直接跳到编码之前，我决定更好地理解<a class="ae kp" href="https://developer.apple.com/documentation/uikit/uinavigationbar" rel="noopener ugc nofollow" target="_blank"> UINavigationBar </a>在幕后是如何工作的。该过程包括两个步骤:</p><ol class=""><li id="6aa3" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">通读<a class="ae kp" href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UINavigationBar.h" rel="noopener ugc nofollow" target="_blank"> UINavigationBar运行时标题</a></li><li id="c2ea" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">通过<strong class="it hv">调试视图层次</strong>检查导航栏内的内容</li></ol><p id="5d52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这让我明白了两件事:</p><ol class=""><li id="b8bf" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">导航条本身总是以与状态栏高度相等的<strong class="it hv"> origin.y </strong>定位，但是它的子项以负的<strong class="it hv"> origin.y </strong>布局，以模拟好像导航条的<strong class="it hv"> origin.y </strong>等于0。</li><li id="d37e" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">导航栏包含一个类<strong class="it hv"> _UIBarBackground </strong>的子类，负责绘制实际背景。在运行时头中，我发现有一个getter <strong class="it hv"> _backgroundView </strong>。</li></ol><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mi"><img src="../Images/961ddfa9b1db82bf2ef39f84acaf32af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmjPt7eUVWAr-7ngbK0TQw.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">The position of navigation bar is offset vertically by the height of the status bar.</figcaption></figure><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mn"><img src="../Images/8b2e1b6adb0e31fa51233714c4fcfb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNoCjPTRl0DcUXd3B7o_iA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">The vertical position of the background view is negative, to simulate that navigation bar is position with origin.y equal to 0.</figcaption></figure><h2 id="9792" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">履行</h2><p id="3982" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">调查之后，我有了足够的信息，可以开始入侵了。</p><p id="49f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我制定了一个关于它应该如何工作的小型计划。有两种情况我不得不担心:</p><ol class=""><li id="5cd8" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">从显示导航栏的视图控制器转换到隐藏导航栏的视图控制器，然后再转换回来</li><li id="fc7f" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">从隐藏导航栏的视图控制器转换到显示导航栏的视图控制器，然后再转换回来</li></ol><p id="2124" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们更详细地看一下这些案例。</p><p id="5116" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">从可见到隐藏再返回</strong></p><ol class=""><li id="ee4e" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">当我从导航栏可见的当前视图控制器推到导航栏隐藏的目标视图控制器时，我复制了导航栏并将其添加到当前视图控制器的视图中，并且我隐藏了原始导航栏上的背景视图，它是导航控制器视图的子视图。在这种情况下，我可以保证导航栏背景只保留在当前视图控制器中，而不在目标视图控制器中。<a class="ae kp" href="https://github.com/gontovnik/HidesNavigationBarWhenPushed/blob/master/HidesNavigationBarWhenPushed/NavigationController.swift#L76-L78" rel="noopener ugc nofollow" target="_blank">见实施。</a></li><li id="67bf" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">当我从隐藏了导航条的当前视图控制器跳到导航条可见的目标视图控制器时，我等待导航转换完成。在过渡结束时，我从目标视图控制器的视图中移除了伪导航栏，并在原始导航栏上取消隐藏背景视图。<a class="ae kp" href="https://github.com/gontovnik/HidesNavigationBarWhenPushed/blob/master/HidesNavigationBarWhenPushed/NavigationController.swift#L119-L123" rel="noopener ugc nofollow" target="_blank">见实施。</a></li></ol><p id="0a7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">从隐藏到可见再返回</strong></p><ol class=""><li id="dd03" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">当我从隐藏了导航条的当前视图控制器推到导航条可见的目标视图控制器时，我复制了导航条，但是我只在调用<strong class="it hv"> viewWillAppear </strong>时才将其添加到目标视图控制器。在这个推送过渡的最后，我必须从目标视图控制器中移除伪导航条，并在原始导航条上取消隐藏背景视图。<a class="ae kp" href="https://github.com/gontovnik/HidesNavigationBarWhenPushed/blob/master/HidesNavigationBarWhenPushed/NavigationController.swift#L80-L91" rel="noopener ugc nofollow" target="_blank">参见实现。</a></li><li id="b59d" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">当我从导航栏可见的当前视图控制器跳到导航栏隐藏的目标视图控制器时，我复制了导航栏并将其添加到当前视图控制器，并隐藏了原始导航栏上的背景视图。如果过渡失败，我们返回到当前视图控制器，我会添加逻辑来移除假的导航栏，并在当前视图控制器的<strong class="it hv"> viewWillAppear </strong>上取消隐藏原始导航栏上的背景视图。<a class="ae kp" href="https://github.com/gontovnik/HidesNavigationBarWhenPushed/blob/master/HidesNavigationBarWhenPushed/NavigationController.swift#L125-L130" rel="noopener ugc nofollow" target="_blank">见实施。</a></li></ol><h2 id="f566" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">错误和错误修复</h2><p id="2322" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">令人惊讶的是，我只遇到了一个bug，并且不得不与之斗争。</p><p id="50fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于<strong class="it hv"> _backgroundView </strong>是私有API，由苹果公司管理，因此存在该视图被苹果公司隐藏或取消隐藏的情况。为了防止这种情况，并使其与我的状态保持同步，我添加了逻辑来观察背景视图上隐藏的<strong class="it hv">标志，并在它发生意外变化时用我的值覆盖它。<a class="ae kp" href="https://github.com/gontovnik/HidesNavigationBarWhenPushed/blob/master/HidesNavigationBarWhenPushed/NavigationBar.swift#L51-L67" rel="noopener ugc nofollow" target="_blank">见实施。</a></strong></p><h2 id="70f9" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">结论</h2><p id="5d9a" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">老实说，像这样将<em class="mo"> hack </em>包含到生产应用程序中是有风险的，因为它使用的是苹果的内部API，这个API可以随时改变。另一方面，我在生产中有这个逻辑一年多了，没有遇到任何bug。</p><p id="19ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有任何问题，请给我写信！</p><h2 id="eb33" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">感谢您的阅读！如果你喜欢这篇文章，请点击“鼓掌”(掌声)👏按钮)，这样其他人也可以看！😉</h2><p id="1632" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">如果你想聊天，请在Twitter上点击我。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="mp ld l"/></div></figure></div></div>    
</body>
</html>