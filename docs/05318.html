<html>
<head>
<title>Supercharging Kafka — Enable Realtime Web Streaming by Adding Pushpin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强Kafka——通过添加图钉实现实时网络流</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/supercharging-kafka-enable-realtime-web-streaming-by-adding-pushpin-fd62a9809d94?source=collection_archive---------0-----------------------#2018-06-25">https://medium.com/hackernoon/supercharging-kafka-enable-realtime-web-streaming-by-adding-pushpin-fd62a9809d94?source=collection_archive---------0-----------------------#2018-06-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="3a6b" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">通过公共HTTP流API公开Kafka消息</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/778df1fbfca4c7f3d0c1d403aefb512c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*kdryoGalqaiHcsqK.gif"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek"><a class="ae jv" href="http://butlerm.tumblr.com/post/131710073935/connecting-networks" rel="noopener ugc nofollow" target="_blank">Matt Butler</a></figcaption></figure><p id="5664" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">Apache Kafka 是为系统添加实时消息功能的新热点。其核心是一个开源的分布式消息传递系统，使用发布-订阅系统来构建实时数据管道。但是，更广泛地说，它是一个分布式的、水平可伸缩的提交日志。</p><p id="f35f" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在Kafka集群中，您将拥有主题、生产者、消费者和经纪人:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff ks"><img src="../Images/2dfb21ec61d26012c0cfacba89d72115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KrzDqVVNgdnwI8J1xullA.png"/></div></div></figure><ul class=""><li id="7314" class="kx ky hu jy b jz ka kc kd kf kz kj la kn lb kr lc ld le lf dt translated">主题—一组邮件的分类</li><li id="a764" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr lc ld le lf dt translated">生产者——将信息推入卡夫卡的主题</li><li id="9a48" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr lc ld le lf dt translated">消费者——从卡夫卡的主题中提取信息</li><li id="9f4c" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr lc ld le lf dt translated">卡夫卡经纪人——一个卡夫卡节点</li><li id="dfac" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr lc ld le lf dt translated">卡夫卡集群——卡夫卡经纪人的集合</li></ul><p id="b38f" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><em class="ll">这里深入探究卡夫卡</em><a class="ae jv" href="https://sookocheff.com/post/kafka/kafka-in-a-nutshell/" rel="noopener ugc nofollow" target="_blank">T5</a><em class="ll">。</em></p><p id="426a" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">总的来说，Kafka通过发布-订阅模型提供了快速、高度可伸缩和冗余的消息传递。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff ks"><img src="../Images/1e54caabbfcdf4014f105d6051a7fa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXUW_4BnKZzR4Ho9spGuNA.png"/></div></div></figure><p id="6837" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">发布-订阅模型是一种消息传递模式，其中发布者将发布的消息分类到主题中，而不知道哪些订阅者会收到这些消息(如果有的话)。同样，订阅者表达对一个或多个主题的兴趣，并且只接收感兴趣的消息，而不了解发布者的任何信息(<a class="ae jv" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">源</a>)。</p><h1 id="caa9" class="lm ln hu bd lo lp lq lr ls lt lu lv lw ja lx jb ly jd lz je ma jg mb jh mc md dt translated">卡夫卡的长处</h1><p id="c900" class="pw-post-body-paragraph jw jx hu jy b jz me iv kb kc mf iy ke kf mg kh ki kj mh kl km kn mi kp kq kr hn dt translated">作为一个信息系统，卡夫卡有一些变革的力量，这些力量催化了它越来越受欢迎</p><ol class=""><li id="4f12" class="kx ky hu jy b jz ka kc kd kf kz kj la kn lb kr mj ld le lf dt translated"><strong class="jy hv">实时数据管道</strong> —可以处理高流量的实时消息吞吐量</li><li id="e166" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr mj ld le lf dt translated"><strong class="jy hv">高吞吐量</strong> —支持高速大容量数据(每秒1000个)的能力</li><li id="9291" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr mj ld le lf dt translated"><strong class="jy hv">容错</strong> —由于其分布式特性，它对集群中的节点故障具有较强的抵抗力</li><li id="7e0a" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr mj ld le lf dt translated"><strong class="jy hv">低延迟</strong> —毫秒处理数千条消息</li><li id="9424" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr mj ld le lf dt translated"><strong class="jy hv">可扩展性</strong> — Kafka的分布式特性允许您在不停机的情况下添加额外的节点，从而方便了分区和复制</li></ol><h1 id="6e9c" class="lm ln hu bd lo lp lq lr ls lt lu lv lw ja lx jb ly jd lz je ma jg mb jh mc md dt translated">卡夫卡的极限</h1><p id="a5ff" class="pw-post-body-paragraph jw jx hu jy b jz me iv kb kc mf iy ke kf mg kh ki kj mh kl km kn mi kp kq kr hn dt translated">由于其固有的架构，Kafka没有优化为API消费者提供对实时数据的友好访问。因此，许多组织都不愿意公开他们的Kafka端点。</p><p id="4c7a" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">换句话说，如果您想使用传统协议(如websockets或HTTP)，很难跨公共API边界公开Kafka。</p><p id="725c" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">为了克服这个限制，我们可以将Pushpin集成到我们的Kafka生态系统中，以处理更传统的协议，并以更容易访问和标准化的方式公开我们的公共API。</p><h1 id="615e" class="lm ln hu bd lo lp lq lr ls lt lu lv lw ja lx jb ly jd lz je ma jg mb jh mc md dt translated">图钉+卡夫卡</h1><p id="86c4" class="pw-post-body-paragraph jw jx hu jy b jz me iv kb kc mf iy ke kf mg kh ki kj mh kl km kn mi kp kq kr hn dt translated">服务器发送事件(SSE)是一种浏览器通过HTTP连接(在HTML5标准中标准化)从服务器接收自动更新的技术。Kafka本身并不支持这个协议，所以我们需要添加一个额外的服务来实现这一点。</p><p id="acba" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><a class="ae jv" href="http://pushpin.org/" rel="noopener ugc nofollow" target="_blank"> Pushpin的</a>主要价值主张是它是一个<strong class="jy hv">开源</strong>解决方案，支持实时推送——这是事件API(<a class="ae jv" href="https://github.com/fanout/pushpin" rel="noopener ugc nofollow" target="_blank">GitHub Repo</a>)的必备条件。它的核心是一个反向代理服务器，使得实现WebSocket、HTTP流和HTTP长轮询服务变得容易。从结构上来说，图钉使用常规的、短期的HTTP请求与后端web应用程序进行通信。</p><p id="469b" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">集成图钉和卡夫卡为你提供了一些显著的<strong class="jy hv">好处</strong>:</p><ul class=""><li id="68d7" class="kx ky hu jy b jz ka kc kd kf kz kj la kn lb kr lc ld le lf dt translated"><strong class="jy hv">面向资源的API </strong> —为消费者提供更符合逻辑的面向资源的API <strong class="jy hv"> </strong>，它与现有的REST API相适应。换句话说，您可以通过标准化的、更安全的协议公开数据。</li><li id="e7f4" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr lc ld le lf dt translated"><strong class="jy hv">认证</strong> —重用现有的认证令牌和数据格式。</li><li id="db01" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr lc ld le lf dt translated"><strong class="jy hv"> API管理</strong> —利用您现有的API管理系统或负载平衡器。</li><li id="f9c4" class="kx ky hu jy b jz lg kc lh kf li kj lj kn lk kr lc ld le lf dt translated"><strong class="jy hv"> web层可扩展性</strong> —如果您的Web用户数量大幅增长，那么扩展您的Web层可能比Kafka集群更经济、更高效。</li></ul><p id="ba8b" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在下一个例子中，<strong class="jy hv">我们将通过HTTP流API公开Kafka消息。</strong></p><h1 id="4669" class="lm ln hu bd lo lp lq lr ls lt lu lv lw ja lx jb ly jd lz je ma jg mb jh mc md dt translated">构建Kafka服务器发送的事件</h1><p id="42fe" class="pw-post-body-paragraph jw jx hu jy b jz me iv kb kc mf iy ke kf mg kh ki kj mh kl km kn mi kp kq kr hn dt translated">这个<a class="ae jv" href="https://github.com/fanout/kafka-sse-example" rel="noopener ugc nofollow" target="_blank">示例项目</a>从Kafka服务读取消息，并使用HTTP上的服务器发送事件(SSE)协议通过流API公开数据。它是使用Python &amp; Django编写的，并且依赖于Pushpin来管理流连接。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff ks"><img src="../Images/34eb92af6baa55dcaf02b69a9b58b485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdWrdrcEugG3POHxqTacVw.png"/></div></div></figure><h2 id="0c3e" class="mk ln hu bd lo ml mm mn ls mo mp mq lw kf mr ms ly kj mt mu ma kn mv mw mc mx dt translated">它是如何工作的</h2><p id="5bfe" class="pw-post-body-paragraph jw jx hu jy b jz me iv kb kc mf iy ke kf mg kh ki kj mh kl km kn mi kp kq kr hn dt translated">在这个演示中，我们在Kafka broker上放置了一个图钉实例。Pushpin充当Kafka消费者，订阅所有主题，并将收到的消息重新发布给连接的客户端。客户端通过图钉收听事件。</p><p id="f978" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">更具体地说，我们使用<a class="ae jv" href="https://github.com/fanout/kafka-sse-example/blob/master/kafka_events/views.py" rel="noopener ugc nofollow" target="_blank"> views.py </a>来建立一个SSE端点，而<a class="ae jv" href="https://github.com/fanout/kafka-sse-example/blob/master/kafka_events/management/commands/relay.py" rel="noopener ugc nofollow" target="_blank"> relay.py </a>处理消息输入和输出。</p><ol class=""><li id="6838" class="kx ky hu jy b jz ka kc kd kf kz kj la kn lb kr mj ld le lf dt translated"><strong class="jy hv">首先，我们需要设置virtualenv并安装依赖项:</strong></li></ol><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="5335" class="mk ln hu mz b fv nd ne l nf ng">virtualenv --python=python3 venv<br/>. venv/bin/activate<br/>pip install -r requirements.txt</span></pre><p id="3eb8" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><strong class="jy hv"> 2。用卡夫卡和图钉设置创建一个合适的</strong><code class="eh nh ni nj mz b"><strong class="jy hv">.env</strong></code><strong class="jy hv">:</strong></p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="d98d" class="mk ln hu mz b fv nd ne l nf ng">KAFKA_CONSUMER_CONFIG={"bootstrap.servers":"localhost:9092","group.id":"mygroup"}<br/>GRIP_URL=http://localhost:5561</span></pre><p id="f3ec" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><strong class="jy hv"> 3。运行Django服务器:</strong></p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="847d" class="mk ln hu mz b fv nd ne l nf ng">python manage.py runserver</span></pre><p id="afe3" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><strong class="jy hv"> 4。运行图钉:</strong></p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="b951" class="mk ln hu mz b fv nd ne l nf ng">pushpin --route="* localhost:8000"</span></pre><p id="0650" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><strong class="jy hv"> 5。运行</strong> <code class="eh nh ni nj mz b"><strong class="jy hv">relay</strong></code> <strong class="jy hv">命令:</strong></p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="33a0" class="mk ln hu mz b fv nd ne l nf ng">python manage.py relay</span></pre><p id="63b7" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><code class="eh nh ni nj mz b">relay</code>命令根据<code class="eh nh ni nj mz b">KAFKA_CONSUMER_CONFIG</code>设置一个Kafka消费者，订阅所有话题，将收到的消息重新发布到Pushpin，包装成SSE格式。</p><p id="2105" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">客户可以通过向<code class="eh nh ni nj mz b">/events/{topic}/</code>发出请求(通过图钉)来收听事件:</p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="32fd" class="mk ln hu mz b fv nd ne l nf ng">curl -i <a class="ae jv" href="http://localhost:7999/events/test/" rel="noopener ugc nofollow" target="_blank">http://localhost:7999/events/test/</a></span></pre><p id="74a9" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">输出流可能如下所示:</p><pre class="jk jl jm jn fq my mz na nb aw nc dt"><span id="ea74" class="mk ln hu mz b fv nd ne l nf ng">HTTP/1.1 200 OK<br/>Content-Type: text/event-stream<br/>Transfer-Encoding: chunked<br/>Connection: Transfer-Encoding</span><span id="75cd" class="mk ln hu mz b fv nk ne l nf ng">event: message<br/>data: hello</span><span id="2749" class="mk ln hu mz b fv nk ne l nf ng">event: message<br/>data: world</span></pre><p id="45a1" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><a class="ae jv" href="https://github.com/fanout/kafka-sse-example" rel="noopener ugc nofollow" target="_blank"><strong class="jy hv">GitHub上的回购</strong> </a></p></div></div>    
</body>
</html>