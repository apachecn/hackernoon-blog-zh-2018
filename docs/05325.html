<html>
<head>
<title>Serverless Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器步骤</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-steps-8a43eac354e1?source=collection_archive---------7-----------------------#2018-06-25">https://medium.com/hackernoon/serverless-steps-8a43eac354e1?source=collection_archive---------7-----------------------#2018-06-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="6edb" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">有没有更好的方式来讲述无服务器传奇？</h2></div><h1 id="35aa" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">搭建舞台</h1><p id="2084" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我之前的帖子是关于<a class="ae kx" href="https://hackernoon.com/consistent-modelling-of-serverless-long-running-background-tasks-2f686c872f8c" rel="noopener ugc nofollow" target="_blank">无服务器长期运行后台任务</a>的一致建模。在那里，展示了一个社交<a class="ae kx" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>爬虫的如下流程模型图:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="ab fr cl ld"><img src="../Images/ed4b81894051cb8a2165cd5a9ead1695.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8bHInG-tgxrIhaW_31J3sw.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">MakirOto Crawler: Process Model</figcaption></figure><p id="2658" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在这样的体系结构中，收集关于特定MakirOto系统用户的数据的整个过程是由AWS Step函数来编排的。这种类型的功能有许多名称，例如分布式事务、工作流、Saga或流程管理器等等。</p><p id="81ef" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated"><a class="lp lq gr" href="https://medium.com/u/d00f1e6b06a2?source=post_page-----8a43eac354e1--------------------------------" rel="noopener" target="_blank">崔琰</a>发表了一篇非常好的<a class="ae kx" href="https://read.acloud.guru/how-the-saga-pattern-manages-failures-with-aws-lambda-and-step-functions-bc8f7129f900" rel="noopener ugc nofollow" target="_blank">文章</a>关于使用AWS Step函数和AWS Lambda实现Saga模式。强烈推荐阅读，以便理解这三个概念是如何结合在一起的。</p><p id="93ac" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">然而，我的追求是寻找一种<a class="ae kx" href="https://hackernoon.com/documenting-serverless-architectures-69bf63fc67b0" rel="noopener ugc nofollow" target="_blank">无服务器架构语言</a>，在这篇文章中，我将探索一致建模<a class="ae kx" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>传奇的可能方式。</p><h2 id="332c" class="lr jk hu bd jl ls lt lu jp lv lw lx jt kk ly lz jv ko ma mb jx ks mc md jz me dt translated">缩小焦点</h2><p id="e7aa" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">以下是MakirOto数据收集器组件的流程模型:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mf"><img src="../Images/0f81e50b4bcc33de50974f22ab692eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qy_q8BMVpm5cOn6UNMT0Pg.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">MakirOto Data Collector: Process Model</figcaption></figure><p id="f7d6" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这个图表很好地说明了这样一个事实，即任何一致的图形符号的表达能力都是非常有限的:我们想说的越清楚，我们能够/应该说的就越少。</p><p id="4466" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">和前面所有的例子一样，这个图非常精确地描述了计算进程和资源之间的引用指针和访问权限。然而，它没有解释这里到底发生了什么，特别是哪些计算是并行的，哪些是顺序的。因为后者是流程模型的主要目标，所以我们有一个问题。</p><p id="3611" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">让我们试着理解问题从何而来，我们能做些什么。</p><h1 id="b3da" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">有什么问题？</h1><p id="431f" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">主要问题源于人类解释图形表示的方式。例如，通过查看下图，几乎所有人都会自动假设所有Lambda函数都是并行运行的:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/395d678ef75897e4bd85c0698a6f530c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*rM9wdzpQKAz0JzoF2EA0yg.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Lambda Function — level Concurrency</figcaption></figure><p id="f057" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">因此，除了访问指针和权限之外，我们还可以直观地了解系统并发性——每个API端点请求都将被并行处理。</p><p id="9c78" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这反过来意味着所有的Lambda函数都需要某种形式的同步，大概是由Neptune图DB提供的。</p><p id="7b36" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这个图没有提到单个Lambda函数的内部并发性。因为我们知道Lambda函数遵循“每个请求一个实例”的策略，所以我们可以假设内部线程根本不存在。</p><p id="8808" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">甚至，如果一些Lambda函数调用另一个Lambda函数，我们将很好地理解顺序处理在哪里。到目前为止，一切顺利。</p><p id="bb14" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">再次强调这一点很重要:这种直观的解释深深植根于人类大脑处理视觉的方式，无法轻易避免。</p><p id="796d" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">现在，如果我们再看一看，由一个阶跃函数编排的多个Lambda函数，我们有一个问题:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/13ac19db17741dcc98c4ac1e9c8d184a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*RwhcM1bRqiIo160fvI9yyA.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">What runs in parallel and what sequentially?</figcaption></figure><p id="abda" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在这里，我们不能自动说出什么并行运行，什么顺序运行。</p><p id="31c2" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">事实上，所有的Lambda函数都是并行运行的，但是在某种意义上与我们直觉上的假设不同。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/4d47b902b950b3799c15fed1a612726d.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*k4vBv9dgL55YZFHdbDfv4Q.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Service vs Resource Class vs Resource Instance</figcaption></figure><p id="1d9d" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在当前的符号中，我们在服务(例如<a class="ae kx" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a> Step Functions服务)和由该服务管理的单个资源(例如特定的Step Function)之间有一个清晰的分离。然而，我们仍然不区分资源类和单个资源实例。UML类图和对象图之间也存在类似的模糊性。</p><p id="323a" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">我们可以断言，只要关注同一个阶跃函数的所有实例，由这些阶跃函数实例调用的所有Lambda函数都将并行运行。通过查看上面的流程模型图，我们无法确定在阶跃函数的单个实例中会发生什么。换句话说，我们对系统中真正的并发性的理解是不完整的。</p><p id="2dba" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">人们可以理直气壮地说，单个阶跃函数的内部并发性直接反映在它的图中。例如:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/2507ffa6a4836c8162834dd5c0e9cd84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*zqo7M5YZ5gn7zccn29tsBQ.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">AWS Step Functions Parallelism</figcaption></figure><p id="6af0" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这并不完全错误，但是诉诸AWS步骤功能图打开了一个新的蠕虫罐，充满了语义一致性问题。</p><h2 id="be75" class="lr jk hu bd jl ls lt lu jp lv lw lx jt kk ly lz jv ko ma mb jx ks mc md jz me dt translated">术语混乱</h2><p id="3ccb" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">先说一个简单的——术语。AWS Step Functions服务所称的“状态机”根本不是状态机，它是一个活动流，通常由UML活动图建模。</p><p id="fabb" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">雪上加霜的是，AWS Step Functions服务将活动步骤称为“states ”,而它拥有的唯一真实状态被称为，猜猜看……对了—“activity”。</p><p id="d258" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">为什么AWS Step Functions架构师懒得看一下UML规范，而是决定引入他们自己的术语，从而搞乱了整个业务，这超出了我的理解范围。</p><h2 id="4938" class="lr jk hu bd jl ls lt lu jp lv lw lx jt kk ly lz jv ko ma mb jx ks mc md jz me dt translated">有了合适的建模工具，它变得更加清晰</h2><p id="19bd" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">因此，为了理解Step函数的内部并发性，我们需要用UML活动图对它进行建模。给你:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mo"><img src="../Images/73cc0760c8d00464f7c004b112e5ff46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sccc91aQd7Ws33WaJWpSDA.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">MakirOto Data Collection Workflow</figcaption></figure><p id="7e62" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在这种情况下，所有分支都遵循相同的模式:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mp"><img src="../Images/f31d8a896fdf210a5aa01a2ad27eaf3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H48iemyM-mMjQPyx9BoPgw.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">MakirOto Data Collection Workflow Branch Structure</figcaption></figure><p id="cb26" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">现在，我们可以有把握地断言，脸书个人资料、脸书照片和LinkedIn个人资料是并行处理的，而在每个分支机构内部，其步骤是按顺序进行的。</p><p id="caa5" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">抛开这是否是最佳解决方案以及什么是替代方案的问题，让我们注意到UML活动图属于逻辑模型而不是过程模型。</p><p id="2914" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">因此，为了真正理解系统并发性，我们需要查看两个模型，并在头脑中协调它们。经过一点训练，这并不难做到。主要问题是从业人员缺乏认识。</p><h2 id="2917" class="lr jk hu bd jl ls lt lu jp lv lw lx jt kk ly lz jv ko ma mb jx ks mc md jz me dt translated">阶跃函数对传奇好吗？</h2><p id="4955" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">回到用AWS步骤函数实现分布式事务。正如我最近在2018年Pycon IL上的演讲中所说</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="0962" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在作为Lambda函数实现的单独计算和作为Step函数实现的处理并发性和错误处理的编排层之间的明确分离有一定的优势。</p><p id="171b" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">作为我研究的一部分，我采用了一种相当极端的方法来否认所有单个Lambda函数的复合行为:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff ms"><img src="../Images/b699306a058626fa464c05d29fc744a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AL0xBwxkLnPnmG8z29pDtw.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Extreme approach to separation between computation and orchestration</figcaption></figure><p id="086f" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">有一种观点认为，选择特定形式的并发应该由基础设施而不是开发人员来完成。也许有一天，我们会到达这个无线天堂。</p><p id="9a92" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">我想在这篇文章的最后探讨的问题是，AWS步骤函数和UML活动图是否是建模分布式事务(Sagas)的合适工具？</p><p id="f7f5" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">答案是“可惜，没有大规模”。主要问题是，虽然AWS Step函数可能并行运行多个分支，但各个Lambda函数是同步调用的，除非有人想搞乱“活动”。另一方面，真正的传奇是异步实现的，并用UML状态图建模。为什么？因为可伸缩性。</p><p id="b895" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在一定范围内，AWS Lambda服务是可伸缩的。一般来说，对于托管服务来说，这是不正确的。</p><p id="f1d9" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">例如，AWS Dynamo DB对读写活动设置了限制。当超过这一限制时，就要支付罚金，要么拒绝请求，要么增加成本。完全无限的计算与其说是现实，不如说是梦想。</p><p id="1d29" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">DynamoDB I/O容量(非原因)可以正确测量、调整和保留。然而，这一切把我们带回到旧的IT世界，只不过是换了一件花哨的现代服装。特别是，这种方法不能很好地处理时间峰值。</p><p id="7083" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">另一方面，如果Lambda函数被异步调用，这些峰值可以被Lambda函数收件箱内部队列拉平。这反过来将允许降低预留容量水平。但是，为了继续进行，Saga需要在特定操作完成时获取一个事件。换句话说，它必须表现得像一个真正的状态机。</p><p id="15eb" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">例如，著名的旅行预订传奇可以建模如下:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/67ae9477d0cb09cd67ae392c02ed676d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*UatGQqDrR1Nv-7p6iuCIbg.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Travel Booking State Machine (for illustration purposes only)</figcaption></figure><p id="5c11" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这是一个过于简单化的犯罪模型，只是为了说明这一点。真实的状态转换模型要复杂得多。但是，即使在这种过于简化的水平上，我们也可以发现一些重要的差异:</p><ul class=""><li id="2784" class="mu mv hu kd b ke lk kh ll kk mw ko mx ks my kw mz na nb nc dt translated">在本地执行的本地操作和异步发送给外部服务的消息之间有明确的区分</li><li id="bd67" class="mu mv hu kd b ke nd kh ne kk nf ko ng ks nh kw mz na nb nc dt translated">由事件触发的状态和转换，作为基本构件</li></ul><h1 id="a0fc" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">评估备选方案</h1><p id="2a71" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">具有讽刺意味的是，虽然<a class="ae kx" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>架构宣称自己是事件驱动的，但目前还没有好的基础设施支持事件驱动的面向状态的编程。以下是一些可用的选项:</p><ol class=""><li id="53f0" class="mu mv hu kd b ke lk kh ll kk mw ko mx ks my kw ni na nb nc dt translated">仍然使用AWS阶跃函数并用“活动”对每个状态建模。</li><li id="bf5a" class="mu mv hu kd b ke nd kh ne kk nf ko ng ks nh kw ni na nb nc dt translated">Lambda函数之间的异步通信，模拟actor计算风格。</li><li id="89f3" class="mu mv hu kd b ke nd kh ne kk nf ko ng ks nh kw ni na nb nc dt translated">Lambda函数之间的异步通信以及处理来自受影响资源的事件。</li><li id="55c4" class="mu mv hu kd b ke nd kh ne kk nf ko ng ks nh kw ni na nb nc dt translated">使用一个功能完整的事件存储库，正如事件源支持者所提倡的，并据此设计整个系统。</li></ol><p id="7b26" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">让我们简单分析一下最后三个选项。</p><h2 id="c050" class="lr jk hu bd jl ls lt lu jp lv lw lx jt kk ly lz jv ko ma mb jx ks mc md jz me dt translated">具有演员式计算的异步Saga实现</h2><p id="90e2" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">该选项可以按如下方式实现:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/6d6de3227a55860629be9850193dfa93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*3j4B163zLiz5t8T3hut-9Q.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Actor-like Serverless Computing</figcaption></figure><p id="dbd2" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这里，负责实现某个特定Saga的流程管理器Lambda函数将流程状态保存在持久性存储中，比如说Dynamo DB表，并调用相关服务，异步传递其ARN和流程标识作为参数。</p><p id="3928" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">另一组Lambda函数负责实现特定的服务，比如酒店预订、机票预订等。通常，但不总是，这会导致封装一些托管服务资源，比如另一个DynamoDB表。当服务Lambda函数完成处理服务请求时，它使用函数ARN和作为参数获得的进程ID将成功/失败消息发送回进程管理器。这在概念上非常类似于典型的演员计算系统，如Erlang或Akka的工作方式。</p><p id="d9ec" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这种做法还不错。即使引入了一些影响性能的开销，它也能很好地扩展。后者不是一个大问题——传奇很少被要求以接近实时的速度执行。还有两个更严重的问题。</p><p id="767c" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">首先，管理访问权限并不简单。根据定义，服务Lambda函数不知道调用Sagas，因此无法提前建立相应的策略。使用命名约定和通配符会打开另一个安全漏洞。当一个新的传奇被部署时，它可以自动完成，但是有点棘手。</p><p id="4ca8" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">第二个问题是，当服务Lambda函数认为数据更新完成时，而不是当它真正发生时，它将发送一个成功/失败消息。在DynamoDB调用中增加一致性要求会损害吞吐量。这留下了资源更新仍未完成的小概率，而流程管理器会有不同的想法。</p><h2 id="25b4" class="lr jk hu bd jl ls lt lu jp lv lw lx jt kk ly lz jv ko ma mb jx ks mc md jz me dt translated">具有资源事件处理的异步Saga</h2><p id="2678" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">第二个选项如下所示:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/1baeaf7a6c0a17eeb485ccd80ce9cbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*OGiepmDE50isnH19W7Bg-Q.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Asynchronous Saga with Resource Event Handling</figcaption></figure><p id="584a" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在这种情况下，流程管理器仍然异步发送服务请求，但是Service Lambda函数不发回任何东西。它只是处理请求，这导致相应的资源更新(例如，在DynamoDB表中放置一条新记录)。</p><p id="b0e8" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">此外，进程管理器Lambda函数监听资源更新流，并相应地在其自身的状态中反映这一点。这种方法的最大优点是，当资源更新真正发生时，它会更新Saga状态。然而，它也有自己的局限性。</p><p id="f53d" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">首先，现在将特定资源中的更新与流程相关联已经不是小事了。事实上，我怎么知道哪个Saga正在等待DynamodDB记录被创建或更新呢？虽然有些惯例可以适用，但它总是临时拼凑的。</p><p id="33d6" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">第二个问题是，流程经理现在需要了解服务的内部结构。它突然需要知道一个DynamoDB表正在运行，以及它拥有哪个模式。</p><p id="323e" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">第三个问题是，对于纯粹的计算服务，第一种机制仍然是必需的。</p><h2 id="eb71" class="lr jk hu bd jl ls lt lu jp lv lw lx jt kk ly lz jv ko ma mb jx ks mc md jz me dt translated">带有事件存储的异步Saga</h2><p id="2d5a" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">目前，AWS云上没有托管事件存储服务。然而，有许多开源服务和框架，原则上可以这样打包。在不涉及选择哪一个的细节的情况下，让我们假设我们已经有了它，然后看看异步Saga实现会是什么样子:</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/38dfbd61083c962546a6f156c1a312b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*gFAx5RKEWpy8Iqq9B1gFiQ.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Asynchronous Saga with Event Store</figcaption></figure><p id="e60b" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">这种设计展示了许多微妙而本质的区别。</p><p id="8d2f" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">首先，服务Lambda不再更新状态资源，而是将事件发布到特定的事件流中。</p><p id="2628" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">第二，这个事件流具有定义良好且稳定的接口。流程经理知道这一点没有问题。</p><p id="b4cc" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">第三，流程管理器可以预先订阅这个事件流。这可能是最干净的解决方案。</p><p id="3a11" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">一些问题仍然存在。AWS上还没有无服务器的本地事件存储解决方案。所有可用的框架都会招致一定的妥协。</p><p id="a266" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">此外，事件源和命令-查询-请求分离(CQRS)是固执己见的设计模式。不是每个人都接受这些模式。最后，只有少数人真正理解这些模式，并能够正确地应用它们。</p><p id="8ff6" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">在任何情况下，拥有一个100%事件源系统传统上被认为是一个过度工程。但是，也许，真正可歌可泣的传奇故事不能以其他方式实现。</p><p id="210f" class="pw-post-body-paragraph kb kc hu kd b ke lk iv kg kh ll iy kj kk lm km kn ko ln kq kr ks lo ku kv kw hn dt translated">总之，我们现在可以肯定的是，无服务器本地架构仍在出现，在这一领域需要一些实验和探索。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="nm mr l"/></div></figure></div></div>    
</body>
</html>