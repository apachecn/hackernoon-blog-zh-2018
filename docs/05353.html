<html>
<head>
<title>Contributing to GHC 3: Hacking Syntax and Parsing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为GHC 3做贡献:破解语法和解析</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/contributing-to-ghc-3-hacking-syntax-and-parsing-4c8dea6658d8?source=collection_archive---------35-----------------------#2018-06-25">https://medium.com/hackernoon/contributing-to-ghc-3-hacking-syntax-and-parsing-4c8dea6658d8?source=collection_archive---------35-----------------------#2018-06-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5417" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上周的文章中，我们对GHC有了更多的了解。我们完成了基本的开发周期，并探索了代码库的一般结构。我们还通过更新一条错误消息进行了最简单的更改。本周，我们将对编译器进行一些更复杂的修改，展示你可以调整语言的方法。你不太可能做出这样的改变来解决现存的问题。但它会帮助我们更好地理解正在发生的事情。</p><p id="5255" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和往常一样，您可以通过查看我们的其他资源来了解更多关于Haskell的基础知识。看看我们的<a class="ae jp" href="https://www.mmhaskell.com/liftoff" rel="noopener ugc nofollow" target="_blank">升空系列</a>或者下载我们的<a class="ae jp" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>！</p><h1 id="8e8b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">注释和更改词法分析器</h1><p id="7403" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">让我们用一个简单的改变来热身。我们将添加一些新的语法来允许不同种类的注释。首先，我们必须稍微熟悉一下在<code class="eh kt ku kv kw b">parser/Lexer.x</code>中定义的Lexer。让我们试着定义它，这样我们就可以用四个撇号来表示一个注释。下面是我们的代码中可能出现的情况，以及如果我们现在尝试这样做，将会得到的错误消息。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="8d03" class="lf jr hu kw b fv lg lh l li lj">module Main where</span><span id="d641" class="lf jr hu kw b fv lk lh l li lj">'''' This is our main function<br/>main :: IO ()<br/>main = putStrLn "Hello World!"</span><span id="b54b" class="lf jr hu kw b fv lk lh l li lj">…</span><span id="041e" class="lf jr hu kw b fv lk lh l li lj">Parser error on `''`<br/>Character literals may not be empty<br/>  |<br/>5 | '''' This is our main function<br/>  | ^^</span></pre><p id="2ddd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，很容易添加新的一行来描述如何使用这个令牌。我们可以遵循Lexer文件中的示例。GHC在这里定义了一个普通的单行注释:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2284" class="lf jr hu kw b fv lg lh l li lj">"-- " ~$docsym .* { lineCommentToken }<br/>"--" [^$symbol \ ] . * { lineCommentToken }</span></pre><p id="d1e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它需要两种情况，因为黑线鳕评论。但是我们不需要担心这个。我们可以在一行中指定我们的符号，如下所示:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="8653" class="lf jr hu kw b fv lg lh l li lj">"''''" .* { lineCommentToken }</span></pre><p id="18b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以将上面的注释添加到我们的代码中，它可以编译了！</p><h1 id="d042" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">添加新关键字</h1><p id="697d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们看看如何给语言添加一个新的关键字。我们将从一个简单的替换开始。假设我们想像使用<code class="eh kt ku kv kw b">if</code>一样使用<code class="eh kt ku kv kw b">iffy</code>这个词。下面是代码片段的样子，以及我们最初得到的编译器错误:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="f290" class="lf jr hu kw b fv lg lh l li lj">main :: IO ()<br/>main = do<br/>  i &lt;- read &lt;$&gt; getLine<br/>  iffy i `mod` 2 == 0<br/>    then putStrLn "Hello"<br/>    else putStrLn "World"</span><span id="cbe2" class="lf jr hu kw b fv lk lh l li lj">…</span><span id="899c" class="lf jr hu kw b fv lk lh l li lj">Main.hs:11:5: error: parse error on input 'then'<br/>   |<br/>11 |     then putStrLn "Hello"<br/>   |     ^^^^</span></pre><p id="7d13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们快速搜索一下关键字“if”在解析器部分中已经存在的位置。我们会找到两个地方。第一个是语言中所有保留字的列表。我们可以通过在列表中添加新的关键字来更新它。我们就找<code class="eh kt ku kv kw b">basicTypes/Lexeme.hs</code>里的<code class="eh kt ku kv kw b">reservedIds</code>集，可以添加一下:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3707" class="lf jr hu kw b fv lg lh l li lj">reservedIds :: Set.Set String<br/>reservedIds = Set.fromList [ …<br/>  , "_", "iffy" ]</span></pre><p id="6916" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们还必须解析它，以便它映射到一个特定的令牌。我们可以在<code class="eh kt ku kv kw b">Lexer.x</code>中看到发生这种情况的一行:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3fb4" class="lf jr hu kw b fv lg lh l li lj">( "if", ITif, 0)</span></pre><p id="8e4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在它的正下方添加另一行，将它匹配到同一个<code class="eh kt ku kv kw b">ITif</code>令牌:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5ef9" class="lf jr hu kw b fv lg lh l li lj">( "iffy", ITif, 0)</span></pre><p id="2a3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，一旦我们开始将语言放在一起，lexer就会将它与相同的标记进行匹配。现在我们的代码编译并产生预期的结果！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="210c" class="lf jr hu kw b fv lg lh l li lj">lghc Main.hs<br/>./prog.exe<br/>5<br/>World</span></pre><h1 id="41d6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">反转If</h1><p id="10c0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们给这个过程增加一点曲折。我们将添加另一个“if”关键字，并将其命名为<code class="eh kt ku kv kw b">reverseif</code>。这将改变if语句的顺序。因此，当布尔值为假时，我们的代码将执行第一个分支，而不是第二个分支。我们需要往上游走一点。我们希望尽可能多地重复使用现有的机器，并在适当的时候颠倒我们的两种表达方式。让我们使用与上面相同的代码，除了reverse关键字。那么如果我们输入<code class="eh kt ku kv kw b">5</code>，我们应该得到<code class="eh kt ku kv kw b">Hello</code>而不是<code class="eh kt ku kv kw b">World</code>。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4f59" class="lf jr hu kw b fv lg lh l li lj">main :: IO ()<br/>main = do<br/>  i &lt;- read &lt;$&gt; getLine<br/>  reverseif i `mod` 2 == 0<br/>    then putStrLn "Hello"<br/>    else putStrLn "World"</span></pre><p id="5f3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们必须从在lexer中当前的<code class="eh kt ku kv kw b">if</code>标记下给我们的<code class="eh kt ku kv kw b">Token</code>类型添加一个新的构造函数开始。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6698" class="lf jr hu kw b fv lg lh l li lj">data Token =<br/>  …<br/>  | ITif<br/>  | ITreverseif<br/>  ...</span></pre><p id="d602" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们必须添加一行代码来将我们的关键字转换成这种令牌。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="cd76" class="lf jr hu kw b fv lg lh l li lj">...<br/>("if", ITif, 0),<br/>("reverseif", ITreverseif, 0),<br/>...</span></pre><p id="2a8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和以前一样，我们也将它添加到我们的关键字列表中:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="50a2" class="lf jr hu kw b fv lg lh l li lj">reservedIds :: Set.Set String<br/>reservedIds = Set.fromList [ …<br/>  , "_", "iffy", "reverseif" ]</span></pre><p id="055d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们看看使用<code class="eh kt ku kv kw b">ITif</code>构造函数的不同地方。然后我们也可以将它们应用到<code class="eh kt ku kv kw b">ITreverseif</code>中。我们可以在<code class="eh kt ku kv kw b">Lexer.x</code>中找到另外两个例子。首先，有一个函数<code class="eh kt ku kv kw b">maybe_layout</code>，它决定了一个语法结构是否需要一个左括号。然后是<code class="eh kt ku kv kw b">isALRopen</code>函数，它告诉我们是否可以开始某种其他的缩进。在这两种情况下，我们都将以<code class="eh kt ku kv kw b">ITif</code>为例:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="9aa1" class="lf jr hu kw b fv lg lh l li lj">maybe_layout :: Token -&gt; P ()<br/>…<br/>  where<br/>    f ITif = pushLexState layout_if<br/>    f ITreverseif = pushLexState layout_if</span><span id="9ec9" class="lf jr hu kw b fv lk lh l li lj">...<br/>isALRopen ITif = True<br/>isALRopen ITreverseif = True<br/>...</span></pre><p id="d1f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh kt ku kv kw b">Parser.y</code>中还有一点我们需要解析我们的新令牌:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1d72" class="lf jr hu kw b fv lg lh l li lj">%token<br/> …<br/> 'if' { L _ ITif }<br/> 'reverseif' { L _ ITreverseif }</span></pre><p id="d911" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要弄清楚这些标记是如何创建语法结构的。这似乎也发生在<code class="eh kt ku kv kw b">Parser.y</code>中。例如，我们可以看看构造基本if语句的部分:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="468f" class="lf jr hu kw b fv lg lh l li lj">| 'if' exp optSemi 'then' exp optSemi 'else' exp<br/>    {% checkDoAndIfThenElse $2 (snd $3) $5 (snd $6) $8 &gt;&gt;<br/>      Ams (sLL $1 $&gt; $ mkHsIf $2 $5 $8)<br/>        (mj AnnIf $1:mj AnnThen $4<br/>          :mj AnnElse $7<br/>          :(map (\l -&gt; mj AnnSemi l) (fst $3))<br/>         ++(map (\l -&gt; mj AnnSemi l) (fst $6))) }</span></pre><p id="43be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里发生了很多事情，我们现在不打算去理解它！但是我们只需要改变两件事来为<code class="eh kt ku kv kw b">reverseif</code>制定新的规则。首先，我们显然需要在第一行使用这个标记而不是<code class="eh kt ku kv kw b">if</code>。</p><p id="dccd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二，看到第三行的那个<code class="eh kt ku kv kw b">mkHsIf</code>语句了吗？这是我们在语法树中创建实际Haskell“If”表达式的地方。<code class="eh kt ku kv kw b">$5</code>指的是令牌列表中<code class="eh kt ku kv kw b">exp</code>的第二个实例，<code class="eh kt ku kv kw b">$8</code>指的是第三个也是最后一个表达式。这些分别是我们的“If”语句的<code class="eh kt ku kv kw b">True</code>和<code class="eh kt ku kv kw b">False</code>分支表达式。因此，为了颠倒我们的“如果”，我们需要做的就是将这个论点翻转到第三行！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="681b" class="lf jr hu kw b fv lg lh l li lj">| 'reverseif' exp optSemi 'then' exp optSemi 'else' exp<br/>    {% checkDoAndIfThenElse $2 (snd $3) $5 (snd $6) $8 &gt;&gt;<br/>      Ams (sLL $1 $&gt; $ mkHsIf $2 $8 $5)<br/>        (mj AnnIf $1:mj AnnThen $4<br/>          :mj AnnElse $7<br/>          :(map (\l -&gt; mj AnnSemi l) (fst $3))<br/>         ++(map (\l -&gt; mj AnnSemi l) (fst $6))) }</span></pre><p id="aad5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们还需要做一个改变。添加这一行将在我们的语法中引入一些新的转换/减少冲突。已经有233个了，所以我们现在不用太担心。我们需要做的只是改变断言中冲突数量的计数:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7e72" class="lf jr hu kw b fv lg lh l li lj">%expect 235 -- shift/reduce conflicts</span></pre><p id="6477" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们编译并运行我们的简单程序时，我们确实会看到它像预期的那样工作！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="c636" class="lf jr hu kw b fv lg lh l li lj">lghc Main.hs<br/>./prog.exe<br/>5<br/>Hello</span></pre><h1 id="1afd" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="bad7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">因此，本周我们看到GHC发生了一些更复杂的变化，这些变化产生了切实的影响。下周，我们将通过查看捐献过程来结束对GHC的讨论。我们先来看看Github的“简单”方式。然后，我们还将使用Arc和Phabricator等工具完成更复杂的过程。</p><p id="5060" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要了解关于Haskell的更多信息，您应该查阅我们的一些基本资料！如果你是这门语言的初学者，请阅读我们的<a class="ae jp" href="https://www.mmhaskell.com/liftoff" rel="noopener ugc nofollow" target="_blank">发射系列</a>。它会教你如何从头开始使用Haskell。也可以看看我们的<a class="ae jp" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>看看更高级实用的技巧！</p></div></div>    
</body>
</html>