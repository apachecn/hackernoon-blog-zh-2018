<html>
<head>
<title>A Step By Step Guide To Testing and Deploying Ethereum Smart Contracts in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中测试和部署以太坊智能合约的分步指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-step-by-step-guide-to-testing-and-deploying-ethereum-smart-contracts-in-go-9fc34b178d78?source=collection_archive---------3-----------------------#2018-06-26">https://medium.com/hackernoon/a-step-by-step-guide-to-testing-and-deploying-ethereum-smart-contracts-in-go-9fc34b178d78?source=collection_archive---------3-----------------------#2018-06-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b0e38c4c69b9754ef369eb69d96e3515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T4koPPupgxdoEw92"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“A toddler standing at the bottom of a tall staircase” by <a class="ae jg" href="https://unsplash.com/@tateisimikito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mikito Tateisi</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="225d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我们将一步一步地看看如何使用Go编程语言测试、部署一个简单的以太坊智能合约并与之交互。</p><p id="07bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">网上有很多教程详细介绍了如何部署以太坊智能合约并与之交互。然而，这些教程要么完全由Javascript完成，要么是Javascript和Go的某种组合。</p><p id="f671" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为一个初露头角的Gopher和以太坊爱好者，我想使用Go在以太坊上构建、测试、部署智能合约并与之交互。然而，我无法找到一个简单的逐步指南来帮助我开始。我不得不从不同的来源收集信息，并通过挖掘Go Ethereum源代码来理解和整合所有需要的拼图。在这篇文章中，我将尝试使用我所学到的知识来编写一个简单的循序渐进的指南，希望能帮助其他人快速掌握围棋和以太坊。</p><p id="38b2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在以下情况下，这篇文章对你最有用:</p><ul class=""><li id="4b06" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">您熟悉Go编程语言，并且已经设置了Go工作区。</li><li id="d9c5" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">你对以太坊区块链和相关的智能合约有了大致的了解。</li><li id="8b5e" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">您已经接触了一些用于编写智能合同的Solidity编程语言。</li></ul><p id="34cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你是区块链和以太坊领域的新手，我建议你从以下方面开始:</p><ul class=""><li id="7dfd" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">观看这个精彩的<a class="ae jg" href="https://anders.com/blockchain/" rel="noopener ugc nofollow" target="_blank">视频</a>，从高层次了解区块链是什么。</li><li id="24cd" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">浏览(打开你最喜欢的文本编辑器，用你最喜欢的编程语言跟随)这篇关于构建区块链的优秀的<a class="ae jg" href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46" rel="noopener ugc nofollow" target="_blank">博客</a>文章。</li><li id="dfa2" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">阅读以太坊<a class="ae jg" href="https://github.com/ethereum/wiki/wiki/White-Paper" rel="noopener ugc nofollow" target="_blank">白皮书</a>。</li></ul></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><h2 id="4c73" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">安装Go-Ethereum和相关的开发工具</h2><p id="49b7" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">首先，我们需要为以太坊协议安装Go绑定。假设您已经安装了Go并适当地设置了<em class="ma"> GOPATH </em>环境变量，您可以通过以下方式获得绑定:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="4d5a" class="la lb hu mg b fv mk ml l mm mn">$ go get -d github.com/ethereum/go-ethereum</span></pre><p id="4470" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们签出了源代码，我们就可以继续构建<em class="ma"> geth </em> (Geth是运行以太坊节点的完整go实现的主要命令行工具)<em class="ma"> </em>以及所有开发人员工具:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="83e3" class="la lb hu mg b fv mk ml l mm mn">$ cd $GOPATH/src/<!-- -->github.com/ethereum<br/>$ go install ./...</span></pre><h2 id="2b06" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">设置项目结构</h2><p id="72c0" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们将编写并部署一个简单的收件箱合约。为此，让我们从设置以下目录和文件结构开始:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="b0f2" class="la lb hu mg b fv mk ml l mm mn"># Navigate to your Go src directory. Mine looks like: <br/># $GOPATH/src/<!-- -->github.com/sabbas</span><span id="17ad" class="la lb hu mg b fv mo ml l mm mn">$ cd $GOPATH/src/<!-- -->github.com/sabbas<br/>$ mkdir -p inbox/contracts<br/>$ touch contracts/inbox_test.go fetch.go update.go deploy.go</span><span id="ace1" class="la lb hu mg b fv mo ml l mm mn">$ <!-- -->tree inbox/<br/>inbox/<br/>├── contracts<br/>│   └── inbox_test.go<br/>├── deploy.go<br/>├── fetch.go<br/>└── update.go</span></pre><p id="a7a3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们创建一个名为<em class="ma">收件箱</em>的新项目文件夹。在这个文件夹中，我们创建一个名为<em class="ma">合同的包文件夹。</em>该文件夹将包含我们收件箱合同的可靠性代码及其相关的Go绑定(我们将很快生成)。在<em class="ma">合同</em>包文件夹中，我们还有一个<em class="ma"> inbox_test.go </em>文件。这个文件将包含我们所有的测试。还有三个名为<em class="ma"> deploy.go、fetch.go和update.go的附加文件</em>我们将使用这些附加文件来编写代码，以便在公共网络上部署以太坊合约并与之交互。这些文件暂时可以是空的。</p><h2 id="1c26" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">创建一个简单的以太坊契约</h2><p id="427d" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们现在准备为我们的收件箱合约编写一些可靠性代码。导航到<code class="eh mp mq mr mg b">inbox/contracts</code>文件夹，创建一个名为<em class="ma"> Inbox.sol </em>的文件。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="a052" class="la lb hu mg b fv mk ml l mm mn">$ tree inbox/<br/>inbox/<br/>└── contracts<br/>    └── Inbox.sol</span></pre><p id="c8dc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">编辑<em class="ma"> inbox.sol </em>文件，并为我们的收件箱合同添加以下几行可靠性代码:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="5f83" class="la lb hu mg b fv mk ml l mm mn">pragma solidity ^0.4.17;<br/><br/>contract Inbox {<br/><br/>    string public message;<br/><br/>    function Inbox(string initialMessage) public {<br/>        message = initialMessage;<br/>    }<br/><br/>    function setMessage(string newMessage) public {<br/>        message = newMessage;<br/>    }<br/>}</span></pre><p id="1c34" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">收件箱合同非常简单。它有一个名为<em class="ma"> message </em>的公共数据变量，用于保存最新消息字符串的内容。该契约还定义了一个公共的<em class="ma"> setMessage </em>方法，该方法更新<em class="ma">消息</em>数据变量的内容。</p><h2 id="c7a6" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">使用Go中的以太坊合同</h2><p id="5e0b" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">既然我们在Solidity中定义了收件箱合约，我们希望能够在Go应用程序中使用这个合约。更具体地说，我们希望能够将这个契约部署到以太网上，并在我们的Go应用程序中方便地与之交互。go-Ethereum提供了一个代码生成器工具，可以将一个Solidity契约文件转换成一个类型安全的Go包，我们可以直接从Go应用程序中导入和使用这个包。这个工具叫做<em class="ma"> abigen </em>，它是在我们上面的go-ethereum设置中构建和安装的。要使用<em class="ma"> abigen，</em>导航到<code class="eh mp mq mr mg b">inbox/contracts</code>文件夹并执行:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="3899" class="la lb hu mg b fv mk ml l mm mn">$ abigen -sol inbox.sol -pkg contracts -out inbox.go</span><span id="3029" class="la lb hu mg b fv mo ml l mm mn">$ tree inbox<br/>inbox<br/>└── contracts<br/>    ├── Inbox.sol<br/>    └── inbox.go</span></pre><p id="6bdf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将我们想要生成Go包的Solidity契约文件的名称传递给<em class="ma"> sol </em>命令行参数。我们还为<em class="ma"> pkg </em>和<em class="ma"> out </em>命令行参数指定Go包名称和输出文件名。运行<em class="ma"> abigen </em>会生成<em class="ma"> inbox.go </em>包文件，其中包含收件箱可靠性契约的go绑定。一旦我们有了这些绑定，我们就可以开始测试收件箱合约了。</p><h2 id="86d3" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">在部署到公共网络之前测试以太坊合同</h2><p id="af3c" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">在我们将我们的合同部署到一个公共以太网之前，我们希望确保它按预期工作。在收件箱契约的情况下，我们想要测试我们是否可以部署带有初始消息的契约，检索这个初始消息并在以后更新它的值。Go-Ethereum为区块链模拟器提供了一个很好的工具，对自动化单元测试非常有帮助。在下面的代码片段中，我们将看到如何使用区块链模拟器工具来测试收件箱合同。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="a15d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="ma"> TestDeployInbox </em>方法通过调用<code class="eh mp mq mr mg b">crypto.GenerateKey</code>来生成私钥。该键用于创建交易签名者功能，该功能用于在模拟区块链中授权交易。通过调用<code class="eh mp mq mr mg b">bind.NewKeyedTransactor.</code>生成交易签名函数和一个我们可以用来进行交易的地址。这个地址然后被用来创建一个包含有一些初始余额的单一账户的起源块(通过调用<code class="eh mp mq mr mg b">make(core.GenesisAlloc</code>和<code class="eh mp mq mr mg b">core.GenesisAccount</code>)。这个创世纪块然后被用来播种模拟区块链。最后，我们<em class="ma">“挖掘”</em>下一个块，方法是显式提交所有未决事务，并检查收件箱合约是否部署在有效地址。</p><p id="c76f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以导航到<code class="eh mp mq mr mg b">inbox\contracts</code>并执行<code class="eh mp mq mr mg b">go test</code>来确保我们的部署测试通过</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="b357" class="la lb hu mg b fv mk ml l mm mn">$ go test -v<br/>=== RUN   TestDeployInbox<br/>--- PASS: TestDeployInbox (0.01s)<br/>PASS<br/>ok   github.com/sabbas/inbox/contracts 0.042s</span></pre><p id="fc5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，我们想要测试当我们部署Inbox契约时，它与正确的初始消息一起被部署。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="53e5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">类似于<em class="ma"> TestDeployInbox </em>函数，<em class="ma"> TestGetMessage </em>函数通过设置我们的模拟区块链开始(模拟区块链函数可以重构为一个单独的可重用函数。我在这里避免了这一点，只是为了有助于可读性)。然后它调用<em class="ma"> DeployInbox </em>函数，该函数是为我们的Inbox Solidity契约自动生成的Go绑定的一部分。注意，<em class="ma"> DeployInbox </em>函数返回一个指向已部署的收件箱契约实例的指针，作为第三个返回值。我们可以使用这个指针与我们部署的收件箱合同进行交互(超级酷！).这正是测试查询和检查存储在我们刚刚部署的inbox契约实例中的初始消息的目的。</p><p id="a1fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以导航到<code class="eh mp mq mr mg b">inbox\contracts</code>并执行<code class="eh mp mq mr mg b">go test</code>来确保我们的测试通过</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="be15" class="la lb hu mg b fv mk ml l mm mn">$ go test -v<br/>=== RUN   TestDeployInbox<br/>--- PASS: TestDeployInbox (0.01s)<br/>=== RUN   TestGetMessage<br/>--- PASS: TestGetMessage (0.00s)<br/>PASS<br/>ok   github.com/sabbas/inbox/contracts 0.045s</span></pre><p id="606d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们希望测试我们是否可以将已部署的收件箱契约中的消息数据属性更新为一个新值。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="792f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="ma"> TestSetMessage </em>函数从我们之前看到的相同boiler plate代码开始，以设置模拟区块链并部署收件箱合同。正如我们之前看到的，成功调用<em class="ma"> DeployInbox </em>函数调用会返回一个指向已部署收件箱契约实例的指针，作为第三个返回值。在<em class="ma"> TestSetMessage </em>函数中，我们使用这个契约指针通过调用<code class="eh mp mq mr mg b">SetMessage</code>函数来更新收件箱契约的消息数据属性。由于<code class="eh mp mq mr mg b">SetMessage</code>函数<em class="ma">修改了</em>收件箱合同，它实际上生成了一个新的<em class="ma">事务。</em>结果，我们传入一个指向填充了交易授权数据的<code class="eh mp mq mr mg b">TrasactOpts</code>结构的指针。由于我们不需要随<code class="eh mp mq mr mg b">SetMessage</code>调用发送任何资金，我们将<code class="eh mp mq mr mg b">TransactOpts</code>结构的<code class="eh mp mq mr mg b">Value</code>属性设置为<code class="eh mp mq mr mg b">nil.</code></p><p id="1e53" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以导航到<code class="eh mp mq mr mg b">inbox\contracts</code>并再次运行<code class="eh mp mq mr mg b">go test</code>以确保一切正常。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="b566" class="la lb hu mg b fv mk ml l mm mn">$ go test -v<br/>=== RUN   TestDeployInbox<br/>--- PASS: TestDeployInbox (0.01s)<br/>=== RUN   TestGetMessage<br/>--- PASS: TestGetMessage (0.00s)<br/>=== RUN   TestSetMessage<br/>--- PASS: TestSetMessage (0.01s)<br/>PASS<br/>ok   github.com/sabbas/inbox/contracts 0.051s</span></pre><p id="be1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们的本地测试通过，我们的收件箱合同就准备好了。在下一节中，我们将了解如何将收件箱合同部署到公共以太网上。</p></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><p id="03a4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将在<em class="ma"> Rinkeby测试</em>以太坊公共网络上部署收件箱合同。在<em class="ma">主</em>以太坊网络上部署以太坊合约并与之互动需要实际的金钱，当我们只是在学习或玩耍时，这是不必要的。</p><p id="0bc0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要在像<em class="ma"> Rinkeby </em>这样的公共网络上部署以太坊契约并与之交互，需要做几件事情:</p><ul class=""><li id="1844" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">我们需要在网络上有一个有一些资金的账户</li><li id="2fdc" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">我们需要能够连接到以太坊节点并与之交互。</li></ul><p id="7382" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在接下来的几节中，我们将依次研究每一个问题。</p><h2 id="27fa" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">使用元掩码创建帐户</h2><p id="0d2a" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们可以直接从我们之前构建的命令行界面创建和管理账户。然而，当开始时，我发现使用浏览器中的meta mask Chrome扩展要简单得多。安装Metamask并创建一个帐户非常简单。我将把这作为一个练习留给读者。</p><p id="90df" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们启动并运行元掩码并创建了一个帐户，我们希望确保将元掩码指向<em class="ma"> Rinkeby </em>测试网络</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/020a0d7325619a322240f0ae82903276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3MQKEMu5hv6rp9zO4V-Nw.png"/></div></div></figure><h2 id="d1e4" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">为账户提供资金</h2><p id="3387" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">Rinkeby网络有一个测试龙头(【https://faucet.rinkeby.io/】)正在运行，我们可以用它来请求乙醚。然而，要从这个测试龙头请求以太，我们首先需要发布一个包含我们以太坊帐户地址的帖子(这是我们想要转移资金的帐户。我们可以通过在社交网站上点击Metamask扩展上的帐户名称右边的省略号来复制这个地址，并提供到水龙头的帖子的链接。这很简单。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/2c0ee81cd863b267575944623616a9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvV2cerXQiwfwe6QyLeETw.png"/></div></div></figure><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/c7d1a9780a2a71571029c8a985810e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMlBZilbzahPeaHrBx0kAA.png"/></div></div></figure><p id="97ea" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将需要几秒钟，我们应该会看到资金显示在我们的帐户中的Metamask扩展。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/c9a37876ed724f1fc6cd877dc8fa5c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nu8-Ss2rVS11kdrS-m6V9g.png"/></div></div></figure><h2 id="0e6d" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">连接到以太坊节点</h2><p id="c612" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们可以使用<em class="ma"> geth </em>在Rinkeby测试网络上启动和管理我们自己的以太坊节点。这是一个既耗费资源又耗费时间的过程，并不总是一帆风顺。一个更好的替代方法是连接到第三方提供商托管的运行中的以太坊节点。一个这样的提供者是<a class="ae jg" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"> Infura </a>。我们可以在Infura注册一个免费账户。一旦我们注册，Infura将发送URL给我们，以连接到运行在不同以太网上的节点。Rinkeby测试网络的URL应该类似于<a class="ae jg" href="https://rinkeby.infura.io/fYe8qCnWiMxQZAXOVoff" rel="noopener ugc nofollow" target="_blank">https://rinkeby.infura.io/fYE8qC0WiMx4ZAX4Voff</a>。</p><h2 id="1953" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">为我们的帐户生成加密的JSON密钥</h2><p id="f8c7" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">为了通过Go-Ethereum在Rinkeby等公共以太网上部署和交互合同，我们需要为通过上面的Metamask创建的帐户提供一个加密的json密钥。这是我们希望为部署收件箱合同并与之交互而收取费用的帐户。</p><p id="938b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以通过将metamask中帐户的私钥导出到一个文件中(单击Metamask中帐户名称旁边的省略号，进入导出私钥选项),然后通过<em class="ma"> geth导入它，从而生成这个JSON密钥。确保在完成导入后删除私钥文件。</em></p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="87ec" class="la lb hu mg b fv mk ml l mm mn">geth account import path/to/private/key/file</span></pre><p id="e2b7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上述命令将在Mac上的<em class="ma">~/Library/ether eum/keystore</em>和<em class="ma"> ~/.ethereum中生成一个加密的JSON密钥文件。</em>注意这个文件。当我们在Rinkeby测试网络上部署Inbox契约并与之交互时，我们将在下一节中使用它的内容。</p><h2 id="5842" class="la lb hu bd lc ld le lf lg lh li lj lk js ll lm ln jw lo lp lq ka lr ls lt lu dt translated">最后的边疆</h2><p id="7346" class="pw-post-body-paragraph jh ji hu jj b jk lv jm jn jo lw jq jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">我们终于可以将收件箱合同部署到Rinkeby网络了。让我们首先来看看我们之前创建的<em class="ma"> deploy.go </em>文件中的代码，然后我们将详细介绍它。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="6d2b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用前面生成的带有Infura url的<code class="eh mp mq mr mg b">ethclient.Dial</code>方法连接到Rinkeby测试网络上的以太坊节点。然后，我们使用<code class="eh mp mq mr mg b">bind.NewTransactor</code>实用程序方法从密钥文件的内容(您可以使用<code class="eh mp mq mr mg b">geth account list</code>命令来检索您的JSON密钥文件在您的系统上的位置)和我们上面通过<code class="eh mp mq mr mg b">geth account import</code>生成的相关密码创建一个授权的交易者。从那以后，部署契约的代码与我们在使用模拟区块链部署收件箱契约时看到的代码完全相同。最后，如果一切顺利，我们打印收件箱合同在网络上部署的地址。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="695e" class="la lb hu mg b fv mk ml l mm mn">$ go run deploy.go<br/>Contract pending deploy: 0x491c7fd67ac1f0afeceae79447cd98d2a0e6a9ff</span></pre><p id="8d25" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将需要几分钟的时间来开采合同，并成为区块链的一部分。我们可以通过导航到https://rinke by . etherscan . io/address/[合同地址]来通过ethers can检查状态。在我的情况下，这将是<a class="ae jg" href="https://rinkeby.etherscan.io/address/" rel="noopener ugc nofollow" target="_blank">https://rinkeby . ethers can . io/address/0x 491 C7 FD 67 AC 1 f 0 afeceae 79447 CD 98 D2 A0 e 6 a9 ff</a></p><p id="d353" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦被挖掘并包含在区块链中，我们就可以使用已部署的收件箱合约的地址开始与之交互。例如，我们可以将下面的代码放在我们上面创建的<em class="ma"> fetch.go </em>中，以检索初始消息。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="1413" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如前所述，我们使用前面生成的带有Infura url的<code class="eh mp mq mr mg b">ethclient.Dial</code>方法连接到Rinkeby测试网络上的以太坊节点。然后，我们使用作为Solidity契约的Go绑定的一部分而生成的<code class="eh mp mq mr mg b">NewInbox</code>方法，将收件箱契约的一个实例附加到部署在特定地址的收件箱契约。最后，我们访问契约上的<code class="eh mp mq mr mg b">Message</code>属性，它应该打印<em class="ma"> Hello World。</em></p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="b5f6" class="la lb hu mg b fv mk ml l mm mn">$ go run interact.go<br/>Hello World &lt;nil&gt;</span></pre><p id="f9c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还可以更新已部署的收件箱契约上的<code class="eh mp mq mr mg b">Message</code>属性。为此，将下面的代码放入之前创建的<em class="ma"> update.go </em>文件中。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="4e27" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回想一下，<code class="eh mp mq mr mg b">SetMessage</code>函数<em class="ma">修改了</em>收件箱合同，并实际生成了一个新的<em class="ma">事务。</em>结果，我们传入一个指向填充了交易授权数据的<code class="eh mp mq mr mg b">TrasactOpts</code>结构的指针。同样，需要几分钟时间来挖掘该事务，使其成为区块链的一部分。一旦它被挖掘出来并包含在区块链中，我们就可以按照前面的例子从已部署的契约中检索<code class="eh mp mq mr mg b">Message</code>属性来查看更新后的值。</p><p id="bec1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以用Go Ethereum做很多事情，但是刚刚开始可能有点太累了。希望这篇文章给了你一个可以进一步探索的起点。</p></div></div>    
</body>
</html>