<html>
<head>
<title>Event-driven Microservices with Quebic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用Quebic的事件驱动微服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/event-driven-microservices-with-quebic-f65f99a5b25a?source=collection_archive---------14-----------------------#2018-06-27">https://medium.com/hackernoon/event-driven-microservices-with-quebic-f65f99a5b25a?source=collection_archive---------14-----------------------#2018-06-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/db3a28059b34006ec8ce18919053cbae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADrNnp8n1bMS0IaMQ3bFyQ.png"/></div></div></figure><p id="19e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗨，今天我将讨论如何使用Quebic <a class="ae ka" href="https://hackernoon.com/tagged/framework" rel="noopener ugc nofollow" target="_blank">框架</a>开发事件驱动的<a class="ae ka" href="https://hackernoon.com/tagged/microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>。如果你是微服务的新手，你可以参考我以前的<a class="ae ka" rel="noopener" href="/@tharanganilupul/microservices-implementation-netflix-stack-ba4f4a57a79f">文章</a>，它涵盖了微服务的主要概念。如果你是Quebic的新手，请仔细阅读这份<a class="ae ka" href="https://github.com/quebic-source/quebic" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><h2 id="8395" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">主要话题</h2><ol class=""><li id="9118" class="kw kx hu je b jf ky jj kz jn la jr lb jv lc jz ld le lf lg dt translated">为什么我们需要事件驱动的微服务</li><li id="033b" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">活动采购</li><li id="571c" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">事件驱动的</li><li id="2a42" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">CQRS</li><li id="0a8a" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">示例应用程序-事件驱动的咖啡店</li><li id="b47f" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">事件流</li><li id="cc60" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">Quebic入门</li><li id="afce" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">Quebic - EventBox</li><li id="b2cb" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">履行</li><li id="b56d" class="kw kx hu je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg dt translated">如何运行示例应用程序</li></ol><h1 id="6f7f" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated"><strong class="ak"> 1。为什么我们需要事件驱动的微服务</strong></h1><h2 id="015e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated"><em class="md">服务之间没有外键约束</em></h2><p id="c7f2" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">假设您有两个服务。一个服务是用户服务，另一个是搜索服务，该服务为搜索而优化。当用户服务存储新的用户数据时，它也调用搜索服务来存储相关数据。如果有人从用户服务中删除用户数据，搜索服务并不知道这一删除。</p><h2 id="1a33" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">分布式事务是困难的</h2><p id="6144" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">当一些事务通过多个服务发生时，如果在执行过程中出现问题，由于事务涉及多个位置，很难确定谁负责再现/回滚。</p><h2 id="4e06" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">服务之间的高度耦合</h2><p id="3e5b" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">当我们想要在服务之间交换信息时，我们需要了解彼此。然后需要知道如何到达另一个服务以及如何响应它。</p><h2 id="5d66" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">难以扩展</h2><p id="def9" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">在传统的微服务架构中，所有服务间的通信都是以请求-响应的方式进行的。如果一个服务变慢了，那么这个服务的所有调用堆栈也会变慢。这使得系统难以扩展。</p><p id="6c88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看如何使用事件源和事件驱动架构概念来最小化这些挑战。</p><h1 id="3b9d" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">2.活动采购</h1><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/9bea437805bf5bbee7fbdce8c50aba4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r21JWu9GuK4RwyCT3HqjYg.png"/></div></div></figure><p id="9de6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事件源将每个状态事务作为一个事件存储在日志中。</p><p id="9e4a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为特定域存储所有事件。领域事件是事件源架构背后的主要关键概念。</p><p id="fb09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">领域事件是一种表示过去发生的某件事情的数据结构。领域事件是不可变的和不朽的。这意味着永远不要改变或从事件存储中删除它。</p><p id="128e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了事件源架构，我们就有了一个审计线索来告诉我们过去的事情是如何发生的。现在我们知道如何再现/回滚系统的状态。这确实有助于识别分布式系统中出现的问题。</p><h1 id="7152" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">3.事件驱动的</h1><p id="cc2f" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">事件驱动架构有助于消除服务之间的高度耦合。每个服务都可以独立运行，不需要知道如何联系其他服务。每个人都在收听他们自己的事件。</p><p id="cc3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了事件驱动的微服务，所有的操作都以最终一致的方式发生。用户不再等待并得到响应，而是使用跟踪器来跟踪他的请求。但最终他能得到正确的回应。</p><p id="2aa9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看如何使用这些概念实现事件驱动的微服务。</p><h1 id="c9b0" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">4.CQRS</h1><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/47ce387d16759529f1c5856ae601c536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ya_uYMBfu4f9q3SZdCV0Sg.png"/></div></div></figure><p id="b0ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">CQRS代表命令查询责任分离。该模式用于从事件流创建物化视图。CQRS模式是基于事件源和事件驱动的架构概念构建的。</p><p id="8b75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据CQRS模式，您可以将应用程序的读写部分划分到单独的模块中。读取部分称为查询模型，写入部分称为命令模型。</p><p id="1d3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是不要求将命令和查询模型保存在单独的项目中。如果你愿意，你可以把两个模块放在同一个项目中，然后这些模块在同一个进程中运行。但是这些模块是完全独立，任何时候你都可以把它们分开。</p><p id="7c08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">CQRS把读和写分开。那么它有助于独立缩放这两个部分。每一面都得到优化。</p><p id="f488" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想，我们已经讨论了大部分理论。让我们开始实施吧。</p><h1 id="ca8b" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">5.示例应用程序-事件驱动的咖啡店</h1><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/9410bd2698760330baef89022dd83801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h62R9itp2gpoxdq_tCajAw.png"/></div></div></figure><p id="278c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您可以看到我们有三个微服务。订单服务、豆子服务和咖啡师服务。来源<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/tree/master/event-driven-microservice-coffee-shop" rel="noopener ugc nofollow" target="_blank">位置</a>。</p><p id="d49a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">订单服务</strong>负责管理来自用户的订单。</p><p id="670f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">bean-service</strong>负责在处理订单之前存储和验证bean。</p><p id="c585" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">咖啡师服务负责根据订单制作咖啡。</p><h1 id="a29f" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">6.事件流</h1><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/8d1e0cf51637deb28f991314dfc27847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63qVb3hkdeeWol6_MPrFgQ.png"/></div></div></figure><p id="87cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不会解释整个事件流程，但我会解释一些要点。这里的第一步是<em class="mp">订单-服务</em>正在监听<em class="mp">请求。已下单的</em>事件。</p><p id="5c13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该事件由API-Gateway触发。在<em class="mp"> orders-service </em>收到事件后，它创建<em class="mp"> reference-id </em>并将该<em class="mp"> reference-id </em>返回给API-Gateway。然后，用户最终可以使用<em class="mp">引用id </em>来跟踪他的订单。</p><p id="429d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后<em class="mp">订单服务</em>调用<em class="mp"> placeOrder() </em>方法。该方法负责创建<em class="mp">订单。已订购的</em>域-事件。<em class="mp"> reference-id </em>(在之前的步骤中创建)被用作域事件的<em class="mp"> aggregate-id </em>。</p><h1 id="0ec6" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">7.<strong class="ak">que BIC入门</strong></h1><p id="11a8" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">Quebic是一个用于编写在Kubernetes上运行的无服务器函数的框架。你可以用任何语言编写你的函数。目前Quebic只支持Java和NodeJS。Github <a class="ae ka" href="https://github.com/quebic-source/quebic" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><h1 id="093a" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">8.<strong class="ak"> Quebic - EventBox </strong></h1><p id="9c25" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">EventBox支持Quebic的事件源功能。使用Eventbox，您可以维护域的事件存储，EventBox提供了检查特定域下的域事件的方法。这有助于在应用程序中利用事件源的优势。您可以通过使用它的REST界面或仪表板UI来访问EventBox。</p><h2 id="a405" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">创建域</h2><ul class=""><li id="912d" class="kw kx hu je b jf ky jj kz jn la jr lb jv lc jz mq le lf lg dt translated"><strong class="je hv">仪表盘UI </strong></li></ul><p id="0158" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转到事件存储部分，然后单击创建按钮。然后它会打开域名创建界面。有三个必填字段。</p><p id="2b32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">名称:</strong>域名。为您的域提供唯一的名称以便识别</p><p id="ef80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">事件组:</strong>这将是事件类型的前缀值。让我们来看一些事件类型。</p><p id="7694" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mp">下命令。下单</em>，<em class="mp">订单。订单确认</em></p><p id="0d12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里所有的事件类型都以“订单”前缀开始。那就是那个事件的事件组。通过提到事件组，这个域将只监听<em class="mp">命令。* </em>事件类型。</p><p id="8497" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">聚合ID字段:</strong>域事件的聚合字段名称。您可以设置域对象的身份字段名称。</p><ul class=""><li id="1493" class="kw kx hu je b jf jg jj jk jn mr jr ms jv mt jz mq le lf lg dt translated"><strong class="je hv">休息界面</strong></li></ul><pre class="mi mj mk ml fq mu mv mw mx aw my dt"><span id="61c4" class="kb kc hu mv b fv mz na l nb nc">curl -X POST http://&lt;eventbox-host:port&gt;/api/domains<br/>-H 'content-type: application/json' <br/>-d '{<br/>     "name":"orders",<br/>     "eventGroup":"orders",<br/>     "aggregateIdField":"id"<br/> }'</span></pre><h2 id="0633" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">获取域事件</h2><ul class=""><li id="1f78" class="kw kx hu je b jf ky jj kz jn la jr lb jv lc jz mq le lf lg dt translated"><strong class="je hv">仪表盘UI </strong></li></ul><p id="0b4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转到事件存储部分，它将显示创建的域。从其中一个域中打开右键菜单。选择菜单中的域-事件链接。然后它将被重定向到域事件页面。</p><ul class=""><li id="a474" class="kw kx hu je b jf jg jj jk jn mr jr ms jv mt jz mq le lf lg dt translated"><strong class="je hv">休息界面</strong></li></ul><pre class="mi mj mk ml fq mu mv mw mx aw my dt"><span id="8916" class="kb kc hu mv b fv mz na l nb nc">curl http://&lt;eventbox-host:port&gt;/api/domains/&lt;domain-name&gt;/domain-events</span></pre><h1 id="d471" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">9.<strong class="ak">实施</strong></h1><figure class="mi mj mk ml fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/23cf39e4b582c1ed771ff522fbdd606c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCHe0m4x_oERzB36pfqCSQ.png"/></div></div></figure><p id="96b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据我们的示例项目，我们有三个微服务<em class="mp">订单——服务</em>、<em class="mp">豆子——服务</em>和<em class="mp">咖啡师——服务</em>。根据CQRS模式，我们可以将<em class="mp">订单-服务</em>分为两个模块<em class="mp">订单-普通-服务</em>和<em class="mp">订单-查询-服务</em>。我们将使用Quebic函数实现每个模块。</p><p id="b805" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我将解释一些重要的观点。您可以在此处的的<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/tree/master/event-driven-microservice-coffee-shop" rel="noopener ugc nofollow" target="_blank">中找到该示例应用程序的完整实现。</a></p><h2 id="d379" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">订单-命令-服务</h2><p id="a7f0" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">在orders-commond-service中，只允许用户进行写操作。这是它的<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/blob/master/event-driven-microservice-coffee-shop/orders-command-service/function_spec.yml" rel="noopener ugc nofollow" target="_blank">功能规格文件</a>的一部分。</p><pre class="mi mj mk ml fq mu mv mw mx aw my dt"><span id="f038" class="kb kc hu mv b fv mz na l nb nc">...<br/>replicas: 1<br/>events:<br/>  - request.OrderPlaced<br/>  - orders.OrderBeanValidated<br/>  - orders.OrderBeanCancelled<br/>  - orders.CoffeeBrewStarted<br/>  - orders.CoffeeBrewFinished</span></pre><p id="75bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据events部分，这个函数将只监听<em class="mp">的请求。下单</em>，<em class="mp">订单。订单确认</em>等..事件。</p><p id="5602" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们检查它的<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/blob/master/event-driven-microservice-coffee-shop/orders-command-service/main.js" rel="noopener ugc nofollow" target="_blank">处理程序实现</a>。它使用<em class="mp"> context.eventID </em>将请求映射到特定的方法。</p><h2 id="e12b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">订单-查询-服务</h2><p id="b0e0" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">在订单-查询-服务中，只允许用户进行读取操作。</p><p id="3aca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当接收到一个从‘订单’开始的事件时(例如:<em class="mp">订单。OrderPlaced </em>)前缀，则事件的有效负载存储在查询数据存储中。对于这个例子，我只是使用JavaScript数据结构作为查询数据存储。但是如果你愿意，你可以使用一些外部数据库来查询数据存储。</p><p id="3a16" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们检查它的<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/blob/master/event-driven-microservice-coffee-shop/orders-query-service/main.js" rel="noopener ugc nofollow" target="_blank">处理程序实现</a>。你可以看到，它在加载函数-容器时调用<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/blob/master/event-driven-microservice-coffee-shop/orders-query-service/main.js#L4" rel="noopener ugc nofollow" target="_blank"> fetchLatestPayloads() </a>方法。在其中，它调用EventBox来获取特定域的最新事件负载。</p><pre class="mi mj mk ml fq mu mv mw mx aw my dt"><span id="351e" class="kb kc hu mv b fv mz na l nb nc">http://&lt;eventbox-host:port&gt;/api/domains/&lt;domain-name&gt;/domain-events/latest-payloads</span></pre><p id="53c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">EventBox存储所有域事件，这个端点代表系统在特定域下的当前状态。</p><p id="2c23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当<em class="mp">订单-查询-服务</em>启动/重新启动时，它调用<em class="mp"> fetchLatestPayloads() </em>方法。这将有助于用域-事件-存储更新查询数据存储，并确保<em class="mp">订单-查询-服务</em>的所有实例保持相同的查询数据存储。</p><p id="819c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<em class="mp"> EVENTBOX_URI </em>环境变量获得EventBox的连接URI。</p><h2 id="0369" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated"><strong class="ak">路由规则</strong></h2><p id="639f" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">让我们来看看<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/blob/master/event-driven-microservice-coffee-shop/routes/order-place-route.yml" rel="noopener ugc nofollow" target="_blank">下单路由规则</a>。这是一个下新订单的http请求示例。这将返回订单id为的已创建订单。</p><pre class="mi mj mk ml fq mu mv mw mx aw my dt"><span id="e06f" class="kb kc hu mv b fv mz na l nb nc">&lt;api-gateway-host:port&gt;/orders POST</span><span id="c83f" class="kb kc hu mv b fv ne na l nb nc">Content-Type: "application/json"<br/>{<br/>     "beanType":"bean_type_1"<br/>}</span></pre><p id="4466" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看看<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/blob/master/event-driven-microservice-coffee-shop/routes/order-fetch-route.yml" rel="noopener ugc nofollow" target="_blank">订单提取路由规则。</a>这是获取订单详细信息的http请求示例。</p><pre class="mi mj mk ml fq mu mv mw mx aw my dt"><span id="c979" class="kb kc hu mv b fv mz na l nb nc">&lt;api-gateway-host:port&gt;/orders/{order-id} GET</span></pre><p id="c263" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当用户向API网关发送http请求后，它就会触发<em class="mp">请求。订单获取</em>事件。收到<em class="mp">订单-查询-服务</em>事件，然后从查询数据存储中获取相关的订单细节。</p><p id="e700" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个<em class="mp">订单id </em>是下单时创建的<em class="mp">参考id </em>。而这个<em class="mp"> order-id </em>就是域事件的<em class="mp"> aggregate-id </em>。</p><h1 id="6814" class="lm kc hu bd kd ln lo lp kh lq lr ls kl lt lu lv ko lw lx ly kr lz ma mb ku mc dt translated">10.如何运行示例应用程序</h1><p id="330a" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn me jp jq jr mf jt ju jv mg jx jy jz hn dt translated">此<a class="ae ka" href="https://github.com/quebic-source/quebic-sample-project/blob/master/event-driven-microservice-coffee-shop/README.md" rel="noopener ugc nofollow" target="_blank">文档</a>包含运行示例应用程序的所有说明。</p><p id="7d48" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想你对事件驱动的微服务以及如何用Quebic实现它有了相当的了解。如果有任何问题，请与我联系。我真的期待你的宝贵反馈。感谢阅读。祝你好运。</p><h2 id="c874" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">参考</h2><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="nh ng l"/></div></figure></div></div>    
</body>
</html>