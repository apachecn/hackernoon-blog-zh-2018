<html>
<head>
<title>Scaling Microservices via Fork-ing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过分叉扩展微服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scaling-microservices-via-fork-ing-37f8f9b3266c?source=collection_archive---------39-----------------------#2018-06-27">https://medium.com/hackernoon/scaling-microservices-via-fork-ing-37f8f9b3266c?source=collection_archive---------39-----------------------#2018-06-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9c4a" class="pw-subtitle-paragraph is ht hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ek translated">构建本地可扩展的微服务</h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/b3c87ccf2199dba5d934105dab016964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CN9N2ngabaEA9CZ1V46dFg.jpeg"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Image from LONGLONGLIFE.org</figcaption></figure><h1 id="a471" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jb kl jc km je kn jf ko jh kp ji kq kr dt translated">介绍</h1><p id="04b2" class="pw-post-body-paragraph ks kt hu ku b kv kw iw kx ky kz iz la lb lc ld le lf lg lh li lj lk ll lm ln hn dt translated">几乎所有熟悉<a class="ae lo" href="https://hackernoon.com/tagged/microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>架构的人都听说过<em class="lp">扩展</em>。伸缩是通过运行一个服务(容器)的多个实例来实现负载平衡的过程。</p><p id="8fe8" class="pw-post-body-paragraph ks kt hu ku b kv lq iw kx ky lr iz la lb ls ld le lf lt lh li lj lu ll lm ln hn dt translated">在任何现有的编排平台中，可以自动或手动进行扩展。但是，这两种方法都需要某种管理来决定微服务何时需要扩展。本文介绍了一种由操作系统调用驱动的自主扩展方法，无需外部干预。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="ab03" class="ka kb hu bd kc kd mc kf kg kh md kj kk jb me jc km je mf jf ko jh mg ji kq kr dt translated">动机</h1><p id="96f1" class="pw-post-body-paragraph ks kt hu ku b kv kw iw kx ky kz iz la lb lc ld le lf lg lh li lj lk ll lm ln hn dt translated">自治是微服务架构的主要原则之一，对于构建敏捷生态系统至关重要。在敏捷生态系统中，除了开发中的敏捷性，微服务还需要对操作条件做出即时反应的权限——高工作负载就是其中之一。当一个微服务承受高负载时，通过自我复制来降低其工作负载会更加方便快捷。</p><p id="66b9" class="pw-post-body-paragraph ks kt hu ku b kv lq iw kx ky lr iz la lb ls ld le lf lt lh li lj lu ll lm ln hn dt translated">这有点类似于身体细胞的行为。当一个细胞生长时，在某个时候，它可能会经历一个分裂期，分裂成两个更小的细胞。</p><p id="676c" class="pw-post-body-paragraph ks kt hu ku b kv lq iw kx ky lr iz la lb ls ld le lf lt lh li lj lu ll lm ln hn dt translated">微服务通常被允许使用一小部分系统资源。将<em class="lp">增长</em>定义为与总可用资源相关的资源消耗量，当增长达到某个极限时，就是微服务进行复制的时候了。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mh"><img src="../Images/5fea5e2d4d8f66c4d655814dcd3d3d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyRhz-Zg6pOSVT7hFvPA5g.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Replication via Fork-ing</figcaption></figure><p id="b27d" class="pw-post-body-paragraph ks kt hu ku b kv lq iw kx ky lr iz la lb ls ld le lf lt lh li lj lu ll lm ln hn dt translated">此外，通过这种方法，为了实现高可用性，不需要在出现故障时重新创建微服务，因为它的位置将被新一代自动取代。但是，需要最小数量的副本来防止早期故障导致的突然死亡。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="396a" class="ka kb hu bd kc kd mc kf kg kh md kj kk jb me jc km je mf jf ko jh mg ji kq kr dt translated">履行</h1><p id="b05b" class="pw-post-body-paragraph ks kt hu ku b kv kw iw kx ky kz iz la lb lc ld le lf lg lh li lj lk ll lm ln hn dt translated">微服务通常作为单个操作系统进程来实现。操作系统中进程的复制被称为<em class="lp">fork</em>ing。系统调用创建一个子进程作为调用进程的精确副本。下面是使用<code class="eh mi mj mk ml b">fork</code>函数在C语言中实现复制的一个例子:</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="b879" class="pw-post-body-paragraph ks kt hu ku b kv lq iw kx ky lr iz la lb ls ld le lf lt lh li lj lu ll lm ln hn dt translated">在上面的代码中，<code class="eh mi mj mk ml b">fork</code>创建了一个新的子进程，并根据函数的结果返回父进程及其子进程。随后，在子流程中，需要调用<code class="eh mi mj mk ml b">execv</code>函数来将子流程从其父流程中分离和隐藏。否则，当子进程死亡时，它将变成一个僵尸进程，直到父进程<em class="lp">等待</em>或死亡时才会被清理。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="6d69" class="ka kb hu bd kc kd mc kf kg kh md kj kk jb me jc km je mf jf ko jh mg ji kq kr dt translated">缺点</h1><p id="bdc9" class="pw-post-body-paragraph ks kt hu ku b kv kw iw kx ky kz iz la lb lc ld le lf lg lh li lj lk ll lm ln hn dt translated">请注意，本文中介绍的复制方法并没有消除对编排的需求。编排平台仍然需要播种微服务，即第一次实例化，并通过对允许的副本计数施加限制来控制系统资源利用。</p><p id="70c5" class="pw-post-body-paragraph ks kt hu ku b kv lq iw kx ky lr iz la lb ls ld le lf lt lh li lj lu ll lm ln hn dt translated">另一方面，并不是所有的<a class="ae lo" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言都可以与OS系统调用交互，一些其他的语言出于安全考虑可能会阻止它们。但是，有一些方法可以解决这个问题，例如，通过直接执行程序或使用帮助服务来创建新的进程。</p><p id="eae3" class="pw-post-body-paragraph ks kt hu ku b kv lq iw kx ky lr iz la lb ls ld le lf lt lh li lj lu ll lm ln hn dt translated">同样显而易见的是，fork-ing只能在容器中使用，不能实例化新的容器。这与当前编排平台扩展微服务的方式形成了对比。但是，通过在新的集群节点上播种微服务，仍然可以支持集群。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="dc70" class="ka kb hu bd kc kd mc kf kg kh md kj kk jb me jc km je mf jf ko jh mg ji kq kr dt translated">阅读更多</h1><p id="74f0" class="pw-post-body-paragraph ks kt hu ku b kv kw iw kx ky kz iz la lb lc ld le lf lg lh li lj lk ll lm ln hn dt translated">这是实现创新的微服务架构所采用的思想，称为有机服务架构。你可以在这里阅读更多关于这个想法和建筑<a class="ae lo" rel="noopener" href="/@aslrousta/organic-service-architecture-concepts-47f1331d38f8">的起源。</a></p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mo mn l"/></div></figure></div></div>    
</body>
</html>