<html>
<head>
<title>React/Redux development on steroids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应/减少类固醇的发展</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-redux-development-on-steroids-95dfed7e7a85?source=collection_archive---------11-----------------------#2018-06-29">https://medium.com/hackernoon/react-redux-development-on-steroids-95dfed7e7a85?source=collection_archive---------11-----------------------#2018-06-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="99a3" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在本文中，我将展示使用<a class="ae jj" href="https://github.com/evheniy/redux-lazy" rel="noopener ugc nofollow" target="_blank"><strong class="ak"/></a>开发React / Redux应用程序有多快。</h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/b2e36ce324002c5b6cb46edbe918b9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OZbLsFd7FzIMkKJbnF7zg.jpeg"/></div></div></figure></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><p id="1c4f" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">让我分享一下我之前关于<strong class="kf hv">的文章链接:</strong></p><div class="kz la fm fo lb lc"><a href="https://hackernoon.com/react-redux-for-lazy-developers-b551f16a456f" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab ej"><div class="le ab lf cl cj lg"><h2 class="bd hv fv z el lh eo ep li er et ht dt translated">React —为懒惰的开发人员提供redux</h2><div class="lj l"><h3 class="bd b fv z el lh eo ep li er et ek translated">每次在react应用程序中使用redux时，我们都要花费大量时间来创建动作类型、动作创建者、减少者…大多数…</h3></div><div class="lk l"><p class="bd b gc z el lh eo ep li er et ek translated">hackernoon.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ju lc"/></div></div></a></div><div class="kz la fm fo lb lc"><a href="https://hackernoon.com/react-redux-for-lazy-developers-part-2-d0c60123592f" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab ej"><div class="le ab lf cl cj lg"><h2 class="bd hv fv z el lh eo ep li er et ht dt translated">React —为懒惰的开发人员提供redux。第二部分</h2><div class="lj l"><h3 class="bd b fv z el lh eo ep li er et ek translated">在本文中，我将继续讨论使用redux-lazy创建react redux应用程序。</h3></div><div class="lk l"><p class="bd b gc z el lh eo ep li er et ek translated">hackernoon.com</p></div></div><div class="ll l"><div class="lr l ln lo lp ll lq ju lc"/></div></div></a></div><div class="kz la fm fo lb lc"><a href="https://hackernoon.com/react-redux-for-lazy-developers-part-3-319b639a22c3" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab ej"><div class="le ab lf cl cj lg"><h2 class="bd hv fv z el lh eo ep li er et ht dt translated">React —为懒惰的开发人员提供redux。第三部分</h2><div class="lj l"><h3 class="bd b fv z el lh eo ep li er et ek translated">这是关于创建react redux应用程序系列的最后一部分。</h3></div><div class="lk l"><p class="bd b gc z el lh eo ep li er et ek translated">hackernoon.com</p></div></div><div class="ll l"><div class="ls l ln lo lp ll lq ju lc"/></div></div></a></div></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><p id="e9d4" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><a class="ae jj" href="https://github.com/evheniy/redux-lazy" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hv"> Redux Lazy </strong> </a>是redux stuff(动作类型、动作创建者、还原者、容器……)的包装器。就像为redux重新作曲一样。</p><p id="3390" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">如果你正在使用<a class="ae jj" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hv">重组</strong> </a>你就知道这是一个有用的高阶组件包(HOC)。但是在使用其他开发人员创建的HOC之前，您应该知道如何创建一个简单的React组件，如何将其与其他组件组合，以及如何创建自己的HOC。</p><p id="757d" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">Redux Lazy也一样。这不是一个新的商店图书馆。这只是一个包装器，用一点点魔法(是的，我知道在代码中使用魔法不是一个好的做法)你可以在创建React / Redux应用程序上节省高达50%的时间。</p></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><p id="b73c" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">在开始描述Redux Lazy之前，我想展示使用Redux的主要部分。</p><p id="6fbd" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">Redux是一家商店。您可以阅读大量手册和文章，其中包含文档或良好实践。但是商店永远是商店。这是一个你可以保存数据的地方。</p><p id="4cac" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">为了让redux获得数据，你应该为react-redux创建选择器(比如SQL SELECT ),连接特设和动作类型、动作创建器和还原器，以使用存储调度来设置数据。</p><p id="627b" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">因此，我将在这里展示使用redux的每个要点:</p><h2 id="e1d2" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">动作类型:</h2><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="0b21" class="lt lu hu mp b fv mt mu l mv mw"><strong class="mp hv">export const</strong> NAME_SPACE_TEXT = '@@nameSpace/TEXT';</span></pre><p id="94dc" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">这里我只创建了一个动作类型。它应该有助于存储文本字段。我使用名称空间将一个大的应用程序分割成具有自己的组件、存储(使用combineReducers)和逻辑(我使用<a class="ae jj" href="https://redux-observable.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kf hv">redux-observable</strong></a>)的小模块。</p><h2 id="da2c" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">动作创建者:</h2><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="d1f9" class="lt lu hu mp b fv mt mu l mv mw"><strong class="mp hv">import</strong> { NAME_SPACE_TEXT } <strong class="mp hv">from</strong> './types';</span><span id="07b8" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">export const</strong> textAction = text =&gt; ({<br/>  type: NAME_SPACE_TEXT, <br/>  text,<br/>});</span></pre><h2 id="e964" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">减速器:</h2><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="3ded" class="lt lu hu mp b fv mt mu l mv mw"><strong class="mp hv">import </strong>{ NAME_SPACE_TEXT } <strong class="mp hv">from </strong>'./types';<br/><br/><strong class="mp hv">const </strong>defaultState = {<br/>  text: '',<br/>};<br/><br/><strong class="mp hv">export default </strong>(state = defaultState, action) =&gt; {<br/>  <strong class="mp hv">switch </strong>(action.type) {<br/>    <strong class="mp hv">case </strong>NAME_SPACE_TEXT:<br/>      <strong class="mp hv">return </strong>{ ...state, ...action<strong class="mp hv"> </strong>};<br/>    <strong class="mp hv">default</strong>:<br/>      <strong class="mp hv">return </strong>state;<br/>  }<br/>};</span></pre><p id="4c43" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">这是一个简单的减速器。主要思想是检查动作类型，如果它是我们的文本动作，用以前的动作状态创建一个新的状态。</p><h2 id="f23a" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">容器:</h2><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="e266" class="lt lu hu mp b fv mt mu l mv mw"><strong class="mp hv">import </strong>{ connect } <strong class="mp hv">from </strong>'react-redux';<br/><strong class="mp hv">import *</strong> as actions <strong class="mp hv">from </strong>'./actions';<br/><br/><strong class="mp hv">const </strong>mapStateToProps = state =&gt; state[NAME_SPACE];<br/><strong class="mp hv">const </strong>mapDispatchToProps = { ...actions };<br/><br/><strong class="mp hv">export default </strong>connect(mapStateToProps, mapDispatchToProps);</span></pre><p id="b8d7" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">在这里，我使用相同的名称空间在我的模块中获取store的一部分。<strong class="kf hv"> mapDispatchToProps </strong>帮我用商店调度功能包装我的动作创建者。</p><p id="2d7f" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">我需要添加减压器来存储:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="8dda" class="lt lu hu mp b fv mt mu l mv mw"><strong class="mp hv">import</strong> { combineReducers } <strong class="mp hv">from</strong> 'redux';<br/><strong class="mp hv">import </strong>nameSpace <strong class="mp hv">from</strong> './reducer';</span><span id="ae3b" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">const</strong> rootReducer = combineReducers({<br/>  ...<br/>  <strong class="mp hv">nameSpace</strong>,<br/>});</span></pre><p id="0e02" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">以及由容器包裹的部件:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="5508" class="lt lu hu mp b fv mt mu l mv mw">import Container from './container';<br/>import Component from './component';</span><span id="f221" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">export default </strong>Container(Component);</span></pre><p id="23c2" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">仅此而已。每次创建新特性时，你都应该创建类型、创建者、减少者、容器……而不是考虑你的应用程序逻辑。</p></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><p id="adb1" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">为了节省时间，我创建了Redux Lazy。它能为你制造所有这些东西。你需要描述你需要哪些动作并得到它。</p><p id="eb72" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">所以我来介绍一下Redux Lazy。要使用它，你应该做一些小步骤。</p><p id="682e" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">第一步是安装redux-lazy:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="5ca2" class="lt lu hu mp b fv mt mu l mv mw">npm i -S redux-lazy</span></pre><p id="8469" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">或者用纱线:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="4764" class="lt lu hu mp b fv mt mu l mv mw">yarn add redux-lazy</span></pre><p id="3781" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">第二步是创建Redux懒惰模型:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="0b47" class="lt lu hu mp b fv mt mu l mv mw"><strong class="mp hv">import </strong>RL <strong class="mp hv">from </strong>'redux-lazy';<br/><br/><strong class="mp hv">const </strong>rl = <strong class="mp hv">new </strong>RL('modelName');</span><span id="9d74" class="lt lu hu mp b fv mx mu l mv mw">const {<br/>  nameSpace,<br/>  types,<br/>  actions,<br/>  defaultState,<br/>  reducer,<br/>  mapStateToProps,<br/>  mapDispatchToProps,<br/>  Container,<br/>} = rl.<strong class="mp hv">flush</strong>();</span></pre><p id="a505" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">这里我们应该为我们的模型设置一个命名空间。例如，我使用<strong class="kf hv">模型名称</strong>命名空间。</p><p id="8380" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated"><strong class="kf hv">它为你创建名称空间、类型、动作、缩减器、容器……</strong></p><p id="056f" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">接下来，你应该考虑你需要商店中的哪些领域。假设您正在使用SQL表。你需要为它命名(这就是为什么我使用<strong class="kf hv">模型名称</strong>命名空间)和字段。</p><p id="a2aa" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">例如，在前面的例子中，我们只需要一个字段— <strong class="kf hv">文本</strong>。所以你的工作是为这个领域做getter和setter。</p><h2 id="30e7" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">addEventAction(名称)</h2><p id="bb5d" class="pw-post-body-paragraph kd ke hu kf b kg my iv ki kj mz iy kl km na ko kp kq nb ks kt ku nc kw kx ky hn dt translated">如果您需要将事件发送到redux-observable，您需要创建一个只有一个字段的动作类型:<strong class="kf hv"> type </strong>。史诗可以为你运行一些任务。</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="1249" class="lt lu hu mp b fv mt mu l mv mw"><strong class="mp hv">import </strong>RL <strong class="mp hv">from </strong>'redux-lazy';<br/><br/><strong class="mp hv">const </strong>rl = <strong class="mp hv">new </strong>RL('modelName');</span><span id="d37a" class="lt lu hu mp b fv mx mu l mv mw">rl.addEventAction('event');</span><span id="4119" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">const</strong> { types, actions } = rl.<strong class="mp hv">flush</strong>();</span><span id="77c0" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">const</strong> { MODEL_NAME_EVENT } = types;<br/><strong class="mp hv">const</strong> { eventAction } = actions;</span><span id="f1f7" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">export</strong> { MODEL_NAME_EVENT, eventAction };</span><span id="e6f2" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">export default </strong>rl;</span><span id="4223" class="lt lu hu mp b fv mx mu l mv mw">eventAction() // =&gt; { <strong class="mp hv">type</strong>: MODEL_NAME_EVENT }</span><span id="8870" class="lt lu hu mp b fv mx mu l mv mw">eventAction(anyData) // =&gt; { <strong class="mp hv">type</strong>: MODEL_NAME_EVENT }</span></pre><h2 id="f37e" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">addFormAction(名称)；</h2><p id="bb64" class="pw-post-body-paragraph kd ke hu kf b kg my iv ki kj mz iy kl km na ko kp kq nb ks kt ku nc kw kx ky hn dt translated">如果您需要提交带有redux动作的表单，您需要处理事件并将函数放入表单组件中。在组件中使用链接代替对象或函数是一个很好的实践。因为它总是创建一个新的实例，React应该再次渲染组件，即使数据是相同的。</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="1477" class="lt lu hu mp b fv mt mu l mv mw">&lt;form onSubmit={(event) =&gt; {<br/>    event.preventDefault();<br/>    props.submitAction();<br/>}}&gt;</span></pre><p id="15c3" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">使用Redux Lazy，您可以避免无用的渲染:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="1eee" class="lt lu hu mp b fv mt mu l mv mw">rl.addFormAction('submit');</span><span id="8e72" class="lt lu hu mp b fv mx mu l mv mw">&lt;form onSubmit={<strong class="mp hv">props.submitAction</strong>}&gt;</span></pre><h2 id="301b" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">addFormElementAction(名称，默认值)</h2><p id="6073" class="pw-post-body-paragraph kd ke hu kf b kg my iv ki kj mz iy kl km na ko kp kq nb ks kt ku nc kw kx ky hn dt translated">表单元素也是如此。每次都应该从事件(event.target.value)中获取值:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="3f4a" class="lt lu hu mp b fv mt mu l mv mw">&lt;input<br/>  type="text"<br/>  onChange={<strong class="mp hv">event =&gt; props.titleAction(event.target.value)</strong>}<br/>  value={props.title}<br/>/&gt;</span></pre><p id="a1ec" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">有了Redux Lazy，你可以让事情变得更简单:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="b1ba" class="lt lu hu mp b fv mt mu l mv mw">rl.addFormElementAction('title', '');</span><span id="11ea" class="lt lu hu mp b fv mx mu l mv mw">&lt;input<br/>  type="text"<br/>  onChange={<strong class="mp hv">props.titleAction</strong>}<br/>  value={props.title}<br/>/&gt;</span></pre><h2 id="b3b6" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">addParamAction(名称，默认值)</h2><p id="e45a" class="pw-post-body-paragraph kd ke hu kf b kg my iv ki kj mz iy kl km na ko kp kq nb ks kt ku nc kw kx ky hn dt translated">它和addFormElementAction一样，只是用简单的数据代替了事件对象。</p><p id="bc89" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">和任何redux动作创建器完全一样:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="8663" class="lt lu hu mp b fv mt mu l mv mw">rl.addParamAction('title', 'defaultValue');</span><span id="99a7" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">const</strong> { actions } = rl.<strong class="mp hv">flush</strong>();<br/><strong class="mp hv">const</strong> { titleAction } = actions;</span><span id="b7c1" class="lt lu hu mp b fv mx mu l mv mw">titleAction('data')// =&gt; {type: '@@modelName/TITLE', title: 'data'}</span><span id="3269" class="lt lu hu mp b fv mx mu l mv mw">titleAction()// =&gt; {type: '@@modelName/TITLE', title:'defaultValue'}</span></pre><h2 id="1575" class="lt lu hu bd lv lw lx ly lz ma mb mc md km me mf mg kq mh mi mj ku mk ml mm mn dt translated">addParamsAction(名称，有效负载)</h2><p id="e58b" class="pw-post-body-paragraph kd ke hu kf b kg my iv ki kj mz iy kl km na ko kp kq nb ks kt ku nc kw kx ky hn dt translated">如果需要设置多个字段，可以使用addParam <strong class="kf hv"> s </strong>动作:</p><pre class="jl jm jn jo fq mo mp mq mr aw ms dt"><span id="1910" class="lt lu hu mp b fv mt mu l mv mw">rl.addParamsAction('clear', { title: '', body: '' });</span><span id="4b9f" class="lt lu hu mp b fv mx mu l mv mw"><strong class="mp hv">const</strong> { actions } = rl.<strong class="mp hv">flush</strong>();<br/><strong class="mp hv">const</strong> { clearAction } = actions;</span><span id="ea40" class="lt lu hu mp b fv mx mu l mv mw">clearAction('1', '2') // =&gt; { title: '1', body: '2' }</span><span id="244d" class="lt lu hu mp b fv mx mu l mv mw">clearAction('1') // =&gt; { title: '1', body: ''}</span><span id="a2e2" class="lt lu hu mp b fv mx mu l mv mw">clearAction() // =&gt; { title: '', body: '' }</span></pre></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><p id="627c" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">Redux Lazy确实帮助我加快了我的React / Redux开发。但是有时很难得到所有的动作、类型…</p><p id="b523" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">我知道它是如何工作的，也知道我能从<strong class="kf hv"> rl.flush() </strong>中得到什么。但是第一次也许你可以运行<strong class="kf hv"> console.log(rl) </strong>看看里面有什么类型、动作、名称空间……</p><p id="a4e6" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">我认为这对于开发速度来说并不是一个很好的回报。</p><p id="03f1" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">可以看更多<a class="ae jj" href="https://github.com/evheniy/redux-app" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hv">例子</strong> </a>。</p><p id="38c3" class="pw-post-body-paragraph kd ke hu kf b kg kh iv ki kj kk iy kl km kn ko kp kq kr ks kt ku kv kw kx ky hn dt translated">请在评论中提出你的问题，别忘了在<a class="ae jj" href="https://github.com/evheniy/redux-lazy" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hv"> github </strong> </a>上发表。</p></div></div>    
</body>
</html>