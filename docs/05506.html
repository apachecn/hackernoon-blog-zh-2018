<html>
<head>
<title>Timsort — the fastest sorting algorithm you’ve never heard of</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">timsort——你从未听说过的最快的排序算法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/timsort-the-fastest-sorting-algorithm-youve-never-heard-of-36b28417f399?source=collection_archive---------0-----------------------#2018-06-30">https://medium.com/hackernoon/timsort-the-fastest-sorting-algorithm-youve-never-heard-of-36b28417f399?source=collection_archive---------0-----------------------#2018-06-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0602272aacfc5a1915bef55312ea0bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SPyNqR8y-m24soKLAX45g.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/-Vqn2WrfxTQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Marc Sendra martorell</a> on <a class="ae jg" href="https://unsplash.com/search/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5121" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Timsort:一种非常快速、O(n log n)、稳定的排序算法，专为现实世界构建，而不是在学术界构建。</p><p id="2401" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">点击此处查看更新文章:</strong></p><div class="kf kg fm fo kh ki"><a href="https://skerritt.blog/timsort-the-fastest-sorting-algorithm-youve-never-heard-of/" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">timsort——你从未听说过的最快的排序算法</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">Timsort:一个非常快速、O(n log n)、稳定的排序算法，为现实世界而构建——不是在学术界构建的…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">skerritt.blog</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw ja ki"/></div></div></a></div></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff le"><img src="../Images/d1efca5333699827aef6dc77788902a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*kZKyCrzT9YvXBtT9.jpg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image of Tim Peter from <a class="ae jg" href="https://www.youtube.com/watch?v=1wAOy88WxmY" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="3457" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Timsort是一种排序算法，对于真实世界的数据非常有效，而不是在学术实验室中创建的。Tim Peters在2001年为Python编程语言创建了Timsort。Timsort首先分析它试图排序的列表，然后根据对列表的分析选择一种方法。</p><p id="0f5b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">自从该算法被发明以来，它已经被用作Python、<a class="ae jg" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6804124" rel="noopener ugc nofollow" target="_blank"> Java </a>、<a class="ae jg" href="http://www.kiwidoc.com/java/l/x/android/android/5/p/java.util/c/TimSort" rel="noopener ugc nofollow" target="_blank"> Android </a>平台和GNU Octave中的默认排序算法。</p><p id="e442" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Timsort的大O记法是O(n log n)。要了解大O符号，请阅读<a class="ae jg" href="https://hackernoon.com/you-need-to-understand-big-o-notation-now-4ada3d2ec93a" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/a6c36dba7205a4d0c8625fc4fa448c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CkG3c4mZGswDShAV9eHbQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">From <a class="ae jg" href="http://bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="178e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Timsort的排序时间和Mergesort一样，比你可能知道的大多数其他排序都要快。Timsort实际上利用了插入排序和合并排序，您很快就会看到这一点。</p><p id="ff8a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Peters设计Timsort是为了使用大多数真实数据集中已经存在的有序元素。它称这些已经有序的元素为“自然运行”。它遍历数据，将元素收集到运行中，同时将这些运行合并成一个运行。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="c394" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated"><strong class="ak">数组中的元素少于64个</strong></h1><p id="6bd2" class="pw-post-body-paragraph jh ji hu jj b jk mi jm jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated">如果我们试图排序的数组中的元素少于64个，Timsort将执行插入排序。</p><p id="d40a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">插入排序是一种简单的排序，对小列表最有效。对于较大的列表来说很慢，但是对于较小的列表来说非常快。插入排序的思想如下:</p><ul class=""><li id="d7d2" class="mn mo hu jj b jk jl jo jp js mp jw mq ka mr ke ms mt mu mv dt translated">一个一个看元素</li><li id="3862" class="mn mo hu jj b jk mw jo mx js my jw mz ka na ke ms mt mu mv dt translated">通过在正确的位置插入元素来构建排序列表</li></ul><p id="5f44" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是一个跟踪表，显示了插入排序将如何对列表[34，10，64，51，32，21]进行排序</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/72b6fd76cd1fc7424d439b819665a40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bMtqGONwfRvPMvVf8zfJQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image taken by me, from my website <a class="ae jg" href="https://skerritt.tech" rel="noopener ugc nofollow" target="_blank">skerritt.tech</a></figcaption></figure><p id="89a2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个例子中，我们将新排序的元素插入到一个新的子数组中，这个子数组从数组的开头开始。</p><p id="084b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个显示插入排序的gif:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/365fe1531238f701ca75e32cbd7abc76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*I8VlK7-Zh-2btQP4.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Taken from <a class="ae jg" href="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="612d" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated"><strong class="ak">关于运行的更多信息</strong></h1><p id="690e" class="pw-post-body-paragraph jh ji hu jj b jk mi jm jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated">如果列表大于64个元素，则算法将首先遍历列表，寻找严格增加或减少的部分。如果该部分正在减少，它将反转该部分。</p><p id="160a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，如果游程在减少，它将看起来像这样(其中游程以粗体显示):</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/54d7d90c895b59d3a4bdba2fcbea6025.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*LWJSZ8DHZ2DNF8aeVyGpig.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image from my website, <a class="ae jg" href="https://skerritt.tech/" rel="noopener ugc nofollow" target="_blank">skerritt.tech</a></figcaption></figure><p id="715a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果不减少，它会像这样:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/2bd4ae3d1965985aef75cf161143720b.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*r96puBtKKiF6-Rj3DKjOUA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image from my website, <a class="ae jg" href="https://skerritt.tech/" rel="noopener ugc nofollow" target="_blank">skerritt.tech</a></figcaption></figure><p id="1b1a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最小游程的大小是根据数组的大小确定的。该算法选择它，使得随机数组中的大多数游程在长度上等于或变成最小游程。当运行次数等于或略小于2的幂时，合并2个数组更有效。Timsort选择minrun来确保这种效率，方法是确保minrun等于或小于2的幂。</p><p id="ff1f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该算法从32到64(包括32和64)的范围内选择minrun。它选择minrun，使得原始数组的长度除以minrun，等于或略小于2的幂。</p><p id="414f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果游程的长度小于minrun，则计算该游程远离minrun的长度。使用这个新的数字，您可以在运行之前获取这么多的项目，并执行插入排序来创建一个新的运行。</p><p id="f51a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，如果最小游程是63，游程长度是33，则63–33 = 30。然后，从运行结束前获取30个元素，因此这是运行[33]中的30个项目，然后执行插入排序以创建新的运行。</p><p id="5d95" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这部分完成后，我们现在应该在一个列表中有一堆排序的运行。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="3b8d" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated"><strong class="ak">合并</strong></h1><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Gif from <a class="ae jg" href="https://gph.is/18RPLoO" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="3416" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Timsort现在执行mergesort将运行合并在一起。然而，Timsort确保在合并排序时保持稳定性和合并平衡。</p><p id="a9f4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了保持稳定，我们不应该交换两个等值的数字。这不仅保持了它们在列表中的原始位置，而且使得算法更快。我们将很快讨论合并平衡。</p><p id="7df1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当Timsort找到游程时，它将它们添加到堆栈中。一个简单的堆栈如下所示:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/96f1467821419a5e476cfae50dfefbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*sJ4GSPsTvUdIYQIR2pbKig.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image from my website, <a class="ae jg" href="https://skerritt.tech/" rel="noopener ugc nofollow" target="_blank">skerritt.tech</a></figcaption></figure><p id="8b8d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想象一堆盘子。你不能从底部拿盘子，所以你必须从顶部拿。堆栈也是如此。</p><p id="5744" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当mergesort运行时，Timsort试图平衡两个相互竞争的需求。一方面，我们希望尽可能延迟合并，以便利用以后可能出现的模式。但是我们更希望尽快进行合并，以利用运行刚刚发现的仍然在内存层次结构中处于高位的运行。我们也不能将合并延迟“太久”，因为它会消耗内存来记住仍未合并的游程，并且堆栈有固定的大小。</p><p id="3313" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了确保这种折衷，Timsort跟踪堆栈中最近的三个项目，并创建了两个必须适用于这些项目的定律:</p><p id="0ec4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">1.A &gt; B + C</p><p id="fccd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.B &gt; C</p><p id="b5e8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中A、B和C是堆栈上最近的三个项目。</p><p id="0df4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用蒂姆·彼得斯自己的话说:</p><blockquote class="ni"><p id="3cc3" class="nj nk hu bd nl nm nn no np nq nr ke ek translated"><em class="ns">一个好的折衷方案是在堆栈条目上保持两个不变量，其中A、B和C是最前面三个还没有合并的片的长度</em></p></blockquote><p id="e741" class="pw-post-body-paragraph jh ji hu jj b jk nt jm jn jo nu jq jr js nv ju jv jw nw jy jz ka nx kc kd ke hn dt translated">通常，合并不同长度的相邻线路是很困难的。更困难的是，我们必须保持稳定。为了解决这个问题，Timsort留出了临时内存。它将两次运行中较小的一次(同时调用运行A和B)放入临时内存。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="5950" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated"><strong class="ak">飞奔</strong></h1><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ny ng l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Gif from <a class="ae jg" href="https://giphy.com/search/galloping" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="9bdd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当Timsort正在合并A和B时，它注意到一个run已经连续“赢”了很多次。如果结果是运行A包含的数字完全小于运行B，那么运行A将会回到原来的位置。合并这两个项目需要做大量的工作，但却一无所获。</p><p id="6468" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常情况下，数据会有一些预先存在的内部结构。Timsort假设，如果很多run A的值低于run B的值，那么很可能A将继续具有比B小的值。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nz"><img src="../Images/34fe6d38b6e5b9e4f79a8f8ba75b46b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*giTGeRv08yzrchIlkHu48A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image from my website, <a class="ae jg" href="https://skerritt.tech/" rel="noopener ugc nofollow" target="_blank">skerritt.tech</a>. Image of 2 example runs, A and B. Runs have to be strictly increasing or decreasing, hence why these numbers were picked.</figcaption></figure><p id="ce9b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Timsort随后将进入飞奔模式。Timsort对a[0]中b[0]的适当位置执行二分搜索法，而不是对A[0]和B[0]进行核对。这样，Timsort可以将A的整个部分移动到位。然后，Timsort在B中搜索A[0]的适当位置。然后，Timsort将一次移动B罐的整个部分，并放置到位。</p><p id="c902" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们来看看实际情况。Timsort检查B[0](即5)，并使用二分搜索法在a中查找正确的位置</p><p id="1bd4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗯，B[0]属于A列表的后面。现在Timsort在B的正确位置检查A[0](也就是1)。所以我们要看看数字1去了哪里。这个数在B的开头，我们现在知道B属于A的结尾，A属于B的开头。</p><p id="fa07" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">事实证明，如果B[0]的合适位置非常靠近A的开头(反之亦然)，那么这个操作是不值得的。因此，如果没有回报，疾驰模式很快就会退出。此外，Timsort注意到了这一点，并通过增加连续A-only或B-only获胜的次数来增加以后进入疾驰模式的难度。如果gallop模式有回报，Timsort会让重新进入变得更容易。</p><p id="51ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">简而言之，Timsort做了两件非常好的事情:</p><ul class=""><li id="b13a" class="mn mo hu jj b jk jl jo jp js mp jw mq ka mr ke ms mt mu mv dt translated">在具有预先存在的内部结构的阵列上实现出色的性能</li><li id="de7a" class="mn mo hu jj b jk mw jo mx js my jw mz ka na ke ms mt mu mv dt translated">能够保持稳定的排序</li></ul><p id="f236" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以前，为了实现稳定的排序，您必须用整数压缩列表中的项目，并将其作为元组数组进行排序。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h1 id="8325" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated"><strong class="ak">代码</strong></h1><p id="f87b" class="pw-post-body-paragraph jh ji hu jj b jk mi jm jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated">如果您对代码不感兴趣，可以跳过这一部分。这一部分下面还有更多信息。</p><p id="851a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面的源代码是基于我和Nanda Javarma的工作。源代码并不完整，也不像Python官方的sorted()源代码。这只是一个简化的Timsort，我实现它是为了对Timsort有一个总体的感觉。如果你想看到Timsort的原始源代码，请点击这里查看<a class="ae jg" href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="noopener ugc nofollow" target="_blank">。Timsort是用C实现的，而不是Python。</a></p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="oa ng l"/></div></figure><p id="7ff1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Timsort实际上内置在Python中，所以这段代码只是作为一个解释器。要使用Timsort，只需编写:</p><pre class="lf lg lh li fq ob oc od oe aw of dt"><span id="3cba" class="og ll hu oc b fv oh oi l oj ok">list.sort()</span></pre><p id="994e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者</p><pre class="lf lg lh li fq ob oc od oe aw of dt"><span id="06ed" class="og ll hu oc b fv oh oi l oj ok">sorted(list)</span></pre><p id="ca28" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想掌握Timsort的工作原理并有所体会，我强烈建议你尝试自己实现它！</p><p id="ba55" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本文基于Tim Peters对Timsort的原始介绍，在这里找到<a class="ae jg" href="https://bugs.python.org/file4451/timsort.txt" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><h2 id="617c" class="og ll hu bd lm ol om on lq oo op oq lu js or os ly jw ot ou mc ka ov ow mg ox dt translated">你喜欢这篇文章吗？在社交媒体上与我联系，讨论所有与计算机科学相关的事情😁</h2><p id="84d2" class="pw-post-body-paragraph jh ji hu jj b jk mi jm jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated"><a class="ae jg" href="https://twitter.com/brandon_skerrit" rel="noopener ugc nofollow" target="_blank">推特</a>|<a class="ae jg" href="http://instagram.com/brandon.codes" rel="noopener ugc nofollow" target="_blank">insta gram</a>|<a class="ae jg" href="https://www.linkedin.com/in/brandonls/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></p><p id="a646" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">别忘了点击那个👏拍手声👏按钮，以示感谢！</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="oy ng l"/></div></figure><p id="11ba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我写这篇文章没有得到报酬。如果你想支持我，请在下面给我买杯咖啡什么的😁</p><div class="kf kg fm fo kh ki"><a href="https://paypal.me/BrandonSkerritt" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">用贝宝支付布兰登·斯凯里特。我</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">去paypal.me/BrandonSkerritt输入金额。既然是PayPal，那就简单又安全。没有PayPal…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">paypal.me</p></div></div><div class="kr l"><div class="oz l kt ku kv kr kw ja ki"/></div></div></a></div><div class="kf kg fm fo kh ki"><a href="https://monzo.me/brandonskerritt" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">通过Monzo.me即时支付Brandon</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">点击链接向布兰登付款。你不需要创建一个账户，而且完全免费。</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">monzo.me</p></div></div><div class="kr l"><div class="pa l kt ku kv kr kw ja ki"/></div></div></a></div><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="oy ng l"/></div></figure></div></div>    
</body>
</html>