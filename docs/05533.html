<html>
<head>
<title>Solving invisible scaling issues with Serverless and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Serverless和MongoDB解决不可见的伸缩问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/solving-invisible-scaling-issues-with-serverless-and-mongodb-1a065b5a6465?source=collection_archive---------5-----------------------#2018-07-01">https://medium.com/hackernoon/solving-invisible-scaling-issues-with-serverless-and-mongodb-1a065b5a6465?source=collection_archive---------5-----------------------#2018-07-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/dfef6933422424e7e1fb2aa4adf94b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cA8USjsEnH6vdg2mkzMr3Q.jpeg"/></div></div></figure><div class=""/><p id="97f6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自从软件工程成为一种职业以来，我们一直努力为全球的用户服务。随之而来的是缩放问题以及如何解决它。很多时候，这些将我们的软件扩展到不可想象的程度的想法是不成熟和不必要的。</p><p id="8aa8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着无服务器架构和后端即服务提供商的兴起，这已经完全变成了另一回事。现在，我们面临的不是如何纵向扩展和横向扩展的问题，而是如何在不产生沉重负载的情况下扩展我们的数据库连接。</p><p id="4789" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着我们对底层基础设施了解的减少，除了编写<a class="ae ka" href="https://hackernoon.com/fantastic-serverless-security-risks-and-where-to-find-them-737d2206545a" rel="noopener ugc nofollow" target="_blank">健壮、高效的代码</a>和使用<a class="ae ka" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank">合适的工具</a>来缓解这个问题，我们没有太多可以做的。</p><p id="7e74" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者是？🤔</p><h1 id="576f" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">数据库如何与无服务器协同工作？</h1><p id="5bf0" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">使用传统服务器，您的应用程序将在启动时连接到数据库。很符合逻辑，对吧？它做的第一件事是通过一个连接字符串连接到数据库，直到完成，应用程序的其余部分将初始化。</p><p id="b4d1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://www.martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank">无服务器</a>对此的处理略有不同。只有当你触发一个函数时，代码才会真正运行。这意味着您必须在同一个函数调用期间初始化数据库连接并与数据库交互。</p><p id="c9b0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每次运行一个函数时，都要经历这个过程，这将是非常低效和耗时的。这就是为什么无服务器开发人员利用一种称为连接池的技术，只在第一次函数调用时创建数据库连接，并在每次后续调用中重用它。现在你在想这怎么可能？</p><p id="e358" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简而言之，lambda函数本质上是一个微小的容器。它被创建并在很长一段时间内保持<em class="le">温暖</em>，即使它不是一直在运行。只有当它处于非活动状态超过15分钟后，才会被终止。</p><p id="777a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这为我们提供了15到20分钟的时间框架，在此期间，我们的数据库连接处于活动状态，可以随时使用，而不会遭受任何性能损失。</p><h1 id="4d02" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用Lambda和MongoDB Atlas</h1><p id="f16f" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这里有一个简单的代码片段供您查看。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="63c4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你更好地看了上面的代码，你会发现它是有意义的。在顶部，我们需要<code class="eh ll lm ln lo b">mongoose</code>并初始化一个名为<code class="eh ll lm ln lo b">connection</code>的对象。没什么更多的了。我们将使用connection对象作为缓存来存储数据库连接是否存在。</p><p id="2938" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一次需要并调用<code class="eh ll lm ln lo b">db.js</code>文件时，它会将mongoose连接到数据库连接字符串。每个连续的呼叫都将重新使用现有的连接。</p><p id="0e1d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是它在代表我们的lambda函数的<code class="eh ll lm ln lo b">handler</code>中的样子。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="c2e4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个简单的模式将使您的lambda函数缓存数据库连接，并显著提高它们的速度。很酷吧？😊</p><p id="c6cc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这一切都很神奇，但是如果我们达到了数据库所能处理的连接数上限，该怎么办呢？嗯，好问题！这里有一个可行的答案。</p><h1 id="2fe1" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">连接限制呢？</h1><p id="f916" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你担心连接限制，那么你可以考虑使用后端即服务来解决这个问题。理想情况下，它会创建一个您的函数可以使用的连接池，而不必担心达到上限。实现这一点意味着提供者会给你一个REST API来处理实际的数据库交互，而你只使用这些API。</p><p id="d4bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你们这些铁杆读者会考虑自己创建一个API来容纳连接池或者使用GraphQL之类的东西。这两种解决方案都非常适合最适合您的用例。但是，我将着重于使用现成的工具来快速启动和运行。</p><h1 id="279b" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用Lambda和MongoDB缝合</h1><p id="1593" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你像我一样喜欢MongoDB，你可能想看看他们的后端即服务解决方案，名为<a class="ae ka" href="https://www.mongodb.com/cloud/stitch" rel="noopener ugc nofollow" target="_blank"> Stitch </a>。它为您提供了一个简单的API来与MongoDB驱动程序交互。你只需要创建一个Stitch应用程序，将它连接到你已经运行的Atlas集群和你的set。在Stitch应用程序中，确保启用匿名登录并创建您的数据库名称和集合。</p><p id="77ed" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装stitch npm模块，并在代码中引用您的stitch应用程序id，然后开始调用API。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="5adc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如你所见，模式非常相似。我们创建一个缝合客户端连接，并为每个后续请求重用它。</p><p id="f3be" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">lambda函数本身看起来几乎和上面的例子一样。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="fe17" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">似乎很相似。我会习惯的。然而，Stitch有一些现成的很酷的特性，比如为您的客户端连接提供身份验证和授权。这使得保护您的路线变得非常容易。</p><h1 id="a69e" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">怎么知道有效？</h1><p id="b58b" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了确保我知道在每个给定时间哪个连接正在被使用，我使用<a class="ae ka" href="https://dashbird.io/features/aws-lambda-serverless-monitoring/" rel="noopener ugc nofollow" target="_blank"> Dashbird的调用视图</a>来检查我的<a class="ae ka" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda </a>日志。</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lp"><img src="../Images/f75fd6f1de5c4c705eef498e126626a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ox8V7NhrXeSD5dnM.png"/></div></div></figure><p id="7f67" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您可以看到它在第一次调用时创建了一个新的连接，同时在后续调用中重用它。</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lp"><img src="../Images/c42168467931fc41e9873f82b8e0337f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hwv2ENWI7aucJi20.png"/></div></div></figure><p id="f30b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这项服务有一个免费层,可以试用14天来获得无限的功能，所以如果你想要的话，你可以<a class="ae ka" href="https://dashbird.io/register/" rel="noopener ugc nofollow" target="_blank">去看看。</a><a class="ae ka" href="mailto:adnan@dashbird.io" rel="noopener ugc nofollow" target="_blank">如果你想要延长试用期，请告诉我</a>，或者只是<a class="ae ka" href="https://upscri.be/b6f3d5/" rel="noopener ugc nofollow" target="_blank">加入我的简讯</a>。😊</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/4061b0cc9c5d333e2c7581b91aa09660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*DlbOA5wnSdSVajb6.gif"/></div></figure><h1 id="2e01" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">包扎</h1><p id="41ad" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在理想的无服务器世界中，我们不需要担心数据库连接的上限。然而，要达到这个规模问题，访问您的API所需的用户数量是巨大的。上面的例子展示了如何通过使用后端即服务提供商来缓解这个问题。即使<a class="ae ka" href="https://www.mongodb.com/cloud/stitch" rel="noopener ugc nofollow" target="_blank"> Stitch </a>还没有成熟，但它是由<a class="ae ka" href="https://www.mongodb.com/cloud" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>制作的，这是一个令人惊叹的数据库。和<a class="ae ka" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>配合使用，速度快得惊人。</p><p id="9e28" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要查看使用上述两种连接模式的几个项目，请跳到这里:</p><ul class=""><li id="eb35" class="lr ls if je b jf jg jj jk jn lt jr lu jv lv jz lw lx ly lz dt translated"><a class="ae ka" href="https://github.com/adnanrahic/building-a-serverless-rest-api-with-nodejs" rel="noopener ugc nofollow" target="_blank">用MongoDB构建无服务器REST API</a></li><li id="a5c5" class="lr ls if je b jf ma jj mb jn mc jr md jv me jz lw lx ly lz dt translated"><a class="ae ka" href="https://github.com/adnanrahic/building-a-serverless-rest-api-with-nodejs-and-mongodb-stitch" rel="noopener ugc nofollow" target="_blank">用Stitch构建无服务器REST API</a></li></ul><p id="f308" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想阅读我以前的一些无服务器思考，请前往<a class="ae ka" href="https://dev.to/adnanrahic" rel="noopener ugc nofollow" target="_blank">我的简介</a>或<a class="ae ka" href="https://upscri.be/b6f3d5/" rel="noopener ugc nofollow" target="_blank">加入我的时事通讯！</a></p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="mf lk l"/></div></figure><p id="8604" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，看看我写的其他几篇关于无服务器的文章:</p><ul class=""><li id="acc9" class="lr ls if je b jf jg jj jk jn lt jr lu jv lv jz lw lx ly lz dt translated"><a class="ae ka" href="https://dev.to/adnanrahic/how-to-deploy-a-nodejs-application-to-aws-lambda-using-serverless-2nc7" rel="noopener ugc nofollow" target="_blank">如何使用无服务器将Node.js应用程序部署到AWS Lambda</a></li><li id="e993" class="lr ls if je b jf ma jj mb jn mc jr md jv me jz lw lx ly lz dt translated"><a class="ae ka" href="https://hackernoon.com/getting-started-with-aws-lambda-and-node-js-4ce3259c6dfd" rel="noopener ugc nofollow" target="_blank">AWS Lambda和Node.js入门</a></li><li id="01e2" class="lr ls if je b jf ma jj mb jn mc jr md jv me jz lw lx ly lz dt translated"><a class="ae ka" href="https://medium.freecodecamp.org/a-crash-course-on-securing-serverless-apis-with-json-web-tokens-ff657ab2f5a5" rel="noopener ugc nofollow" target="_blank">用JSON web令牌保护无服务器API的速成班</a></li><li id="c885" class="lr ls if je b jf ma jj mb jn mc jr md jv me jz lw lx ly lz dt translated"><a class="ae ka" href="https://hackernoon.com/migrating-your-node-js-rest-api-to-serverless-d2a170e0856c" rel="noopener ugc nofollow" target="_blank">将Node.js REST API迁移到无服务器</a></li><li id="faa6" class="lr ls if je b jf ma jj mb jn mc jr md jv me jz lw lx ly lz dt translated"><a class="ae ka" href="https://hackernoon.com/building-a-serverless-rest-api-with-node-js-and-mongodb-2e0ed0638f47" rel="noopener ugc nofollow" target="_blank">用Node.js和MongoDB构建无服务器REST API</a></li><li id="2fa4" class="lr ls if je b jf ma jj mb jn mc jr md jv me jz lw lx ly lz dt translated"><a class="ae ka" href="https://hackernoon.com/a-crash-course-on-serverless-with-node-js-632b37d58b44" rel="noopener ugc nofollow" target="_blank">node . js无服务器速成班</a></li></ul><p id="330d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你们喜欢读这篇文章，就像我喜欢写这篇文章一样。击中微小的心脏，让其他人在媒体上看到。下次见，保持好奇，玩得开心。</p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="6e16" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="le">最初发布于</em><a class="ae ka" href="https://dev.to/adnanrahic/solving-invisible-scaling-issues-with-serverless-and-mongodb-4m55" rel="noopener ugc nofollow" target="_blank"><em class="le">dev . to</em></a><em class="le">。</em></p></div></div>    
</body>
</html>