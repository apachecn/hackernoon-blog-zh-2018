<html>
<head>
<title>How to use MVVM, Coordinators, and RxSwift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用MVVM、协调员和RxSwift</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-use-mvvm-coordinators-and-rxswift-7364370b7b95?source=collection_archive---------1-----------------------#2018-07-02">https://medium.com/hackernoon/how-to-use-mvvm-coordinators-and-rxswift-7364370b7b95?source=collection_archive---------1-----------------------#2018-07-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1a266aab0db8bdd26e9bf949bfb0e853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eLG1rrap-PDMaKUznuAjg.jpeg"/></div></div></figure><p id="9021" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的团队在生产应用中使用协调器和MVVM已经超过2年了。起初，这看起来很可怕，但从那时起，我们已经完成了基于这些架构模式的<strong class="je hv"> </strong> 6 <strong class="je hv"> </strong>应用程序。在这篇文章中，我将分享我们的经验，并将引导你到MVVM地，协调员&amp;反应式编程。</p><p id="1a34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将从一个简单的MVC示例应用程序开始，而不是预先给出一个定义。我们将一步一步地慢慢进行重构，以展示每个组件如何影响代码库以及结果是什么。每一步都会以一个简短的理论介绍开始。</p><h1 id="8a7f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">例子</h1><p id="7ffe" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在本文中，我们将使用一个简单的示例应用程序，它按语言显示GitHub上最受欢迎的存储库列表。它有两个屏幕:一个按语言过滤的存储库列表和一个按语言过滤存储库的列表。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ld"><img src="../Images/ec3ed3f905e1df21d4c02136f9bb4b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-JLJkOn1nV4N9igbRf99Q.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Screens of the example app</figcaption></figure><p id="2af6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用户可以点击导航栏中的按钮来显示第二个屏幕。在语言屏幕上，他可以选择一种语言或通过点击取消按钮关闭屏幕。如果用户选择一种语言，屏幕将关闭，存储库列表将根据所选语言进行更新。</p><p id="bb36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以在这里找到源代码:</p><div class="lm ln fm fo lo lp"><a href="https://github.com/uptechteam/Coordinator-MVVM-Rx-Example" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab ej"><div class="lr ab ls cl cj lt"><h2 class="bd hv fv z el lu eo ep lv er et ht dt translated">uptechteam/协调员-MVVM-Rx-示例</h2><div class="lw l"><h3 class="bd b fv z el lu eo ep lv er et ek translated">协调员-MVVM-Rx-示例-使用RxSwift实施的MVVM-C架构示例</h3></div><div class="lx l"><p class="bd b gc z el lu eo ep lv er et ek translated">github.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md ja lp"/></div></div></a></div><p id="7999" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该库包含4个文件夹:MVC，MVC-Rx，MVVM-Rx，协调员-MVVM-Rx，对应于重构的每一步。让我们打开<a class="ae me" href="https://github.com/uptechteam/Coordinator-MVVM-Rx-Example/tree/master/MVC" rel="noopener ugc nofollow" target="_blank"> MVC文件夹</a>中的项目，看看重构前的代码。</p><p id="5287" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大部分代码在两个视图控制器中:<code class="eh mf mg mh mi b">RepositoryListViewController</code>和<code class="eh mf mg mh mi b">LanguageListViewController</code>。第一个获取最流行的存储库列表，并通过表格视图显示给用户，第二个显示语言列表。<code class="eh mf mg mh mi b">RepositoryListViewController</code>是<code class="eh mf mg mh mi b">LanguageListViewController</code>的代表，符合以下协议:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="ef32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">RepositoryListViewController</code>也是表视图的代表和数据源。它处理导航、格式化要显示的模型数据并执行网络请求。哇，一个视图控制器要承担很多责任！</p><p id="cfa8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，您可能会注意到全局作用域中的两个变量定义了<code class="eh mf mg mh mi b">RepositoryListViewController</code> : <code class="eh mf mg mh mi b">currentLanguage</code>和<code class="eh mf mg mh mi b">repositories</code>的状态。这样的有状态变量给类带来了复杂性，并且当我们的应用程序的一部分可能以我们不期望的状态结束时，这是一个常见的错误来源。总而言之，当前的代码库有几个问题:</p><ul class=""><li id="bef0" class="ml mm hu je b jf jg jj jk jn mn jr mo jv mp jz mq mr ms mt dt translated">视图控制器的责任太多；</li><li id="5471" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">我们需要被动地处理状态变化；</li><li id="36c8" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">代码根本不可测试。</li></ul><p id="200a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该见见我们的第一位客人了。</p><h1 id="b40b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">RxSwift</h1><p id="47e8" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">该组件将允许我们对变化做出反应，并编写声明性代码。</p><p id="2194" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rx是什么？其中一个定义是:</p><blockquote class="mz na nb"><p id="fb94" class="jc jd nc je b jf jg jh ji jj jk jl jm nd jo jp jq ne js jt ju nf jw jx jy jz hn dt translated">ReactiveX是一个库，用于通过使用可观察序列来编写异步和基于事件的程序。</p></blockquote><p id="75d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不熟悉函数式编程，或者这个定义听起来像一门火箭科学(对我来说仍然是),你可以把Rx想象成一种服用了类固醇的观察者模式。欲了解更多信息，您可以参考<a class="ae me" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" rel="noopener ugc nofollow" target="_blank">入门指南</a>或<a class="ae me" href="https://store.raywenderlich.com/products/rxswift" rel="noopener ugc nofollow" target="_blank"> RxSwift书籍</a>。</p><p id="d84d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们打开资源库中的<a class="ae me" href="https://github.com/uptechteam/Coordinator-MVVM-Rx-Example/tree/master/MVC-Rx" rel="noopener ugc nofollow" target="_blank"> MVC-Rx项目，看看Rx是如何修改代码的。我们将从与Rx相关的最显而易见的事情开始——我们用两个可观察到的事物来代替<code class="eh mf mg mh mi b">LanguageListViewControllerDelegate</code>:<code class="eh mf mg mh mi b">didCancel</code>和<code class="eh mf mg mh mi b">didSelectLanguage</code>。</a></p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Delegate pattern done right</figcaption></figure><p id="6355" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">LanguageListViewControllerDelegate</code>变成了<code class="eh mf mg mh mi b">didSelectLanguage</code>和<code class="eh mf mg mh mi b">didCancel</code>可观测量。我们在<code class="eh mf mg mh mi b">prepareLanguageListViewController(_: )</code>方法中使用它们来反应性地观察<code class="eh mf mg mh mi b">RepositoryListViewController</code>事件。</p><p id="5630" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将重构<code class="eh mf mg mh mi b">GithubService</code>来返回observables，而不是使用回调。之后，我们将使用RxCocoa框架的能力来重写我们的视图控制器。<code class="eh mf mg mh mi b">RepositoryListViewController</code>的大部分代码将转移到<code class="eh mf mg mh mi b">setupBindings</code>函数，在这里我们声明性地描述了视图控制器的逻辑:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">A declarative description of the view controller logic</figcaption></figure><p id="815f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们去掉了视图控制器中的表视图委托和数据源方法，并将我们的状态转移到一个可变主题:</p><pre class="le lf lg lh fq ng mi nh ni aw nj dt"><span id="ccda" class="nk kb hu mi b fv nl nm l nn no">fileprivate let currentLanguage = BehaviorSubject(value: “Swift”)</span></pre><h2 id="0de2" class="nk kb hu bd kc np nq nr kg ns nt nu kk jn nv nw ko jr nx ny ks jv nz oa kw ob dt translated">结果</h2><p id="6654" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我们已经使用RxSwift和RxCocoa框架重构了示例应用程序。那么它到底给了我们什么？</p><ul class=""><li id="803b" class="ml mm hu je b jf jg jj jk jn mn jr mo jv mp jz mq mr ms mt dt translated">所有的逻辑都以声明的方式写在一个地方；</li><li id="4085" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">我们把状态简化为当前语言的一个主题，我们观察变化并对变化作出反应；</li><li id="c612" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">我们使用了RxCocoa的一些语法糖来设置表视图数据源，并且简单明了地进行委托。</li></ul><p id="2ff9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的代码仍然是不可测试的，视图控制器仍然负责很多事情。让我们转向架构的下一个组件。</p><h1 id="1e26" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">MVVM</h1><p id="04a8" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">MVVM是一个来自模型-视图-X家族的UI架构模式。MVVM类似于标准的MVC，除了它定义了一个新的组件——ViewModel，它允许更好地将UI从模型中分离出来。本质上，ViewModel是一个独立于视图UIKit的对象。</p><p id="e9ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nc">该示例项目在</em> <a class="ae me" href="https://github.com/uptechteam/Coordinator-MVVM-Rx-Example/tree/master/MVVM-Rx" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> MVVM-Rx文件夹下</em> </a> <em class="nc">。</em></p><p id="a857" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们创建一个视图模型，它将为视图中的显示准备模型数据:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="2132" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将把所有的数据突变和格式化代码从<code class="eh mf mg mh mi b">RepositoryListViewController</code>移到<code class="eh mf mg mh mi b">RepositoryListViewModel</code>:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="ef87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们的视图控制器将所有UI交互(如按钮点击或行选择)委托给视图模型，并观察视图模型输出的数据或事件(如<code class="eh mf mg mh mi b">showLanguageList</code>)。</p><p id="aaad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将为<code class="eh mf mg mh mi b">LanguageListViewController</code>做同样的事情，看起来我们准备好了。但是我们的测试文件夹仍然是空的！视图模型的引入允许我们测试大部分代码。因为视图模型纯粹使用注入依赖关系将输入转换成输出，所以视图模型和单元测试是我们应用程序中最好的朋友。</p><p id="c26e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用RxSwift附带的RxTest框架测试该应用程序。最重要的部分是一个<code class="eh mf mg mh mi b">TestScheduler</code>类，它允许你通过定义它们应该在什么时候发出值来创建假的可观测量。这就是我们测试视图模型的方式:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">View Model tests</figcaption></figure><h2 id="b3e7" class="nk kb hu bd kc np nq nr kg ns nt nu kk jn nv nw ko jr nx ny ks jv nz oa kw ob dt translated">结果</h2><p id="1b52" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">好了，我们已经从MVC移到了MVVM。但是有什么区别呢？</p><ul class=""><li id="0705" class="ml mm hu je b jf jg jj jk jn mn jr mo jv mp jz mq mr ms mt dt translated">视图控制器现在更薄了；</li><li id="10c2" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">数据格式化逻辑与视图控制器分离；</li><li id="3859" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">MVVM让我们的代码可测试。</li></ul><p id="f142" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，我们的视图控制器还有一个问题— <code class="eh mf mg mh mi b">RepositoryListViewController</code>知道<code class="eh mf mg mh mi b">LanguageListViewController</code>的存在并管理导航流。让我们与协调员一起解决它。</p><h1 id="9260" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">协调者</h1><p id="5742" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">如果你还没有听说过协调员，我强烈推荐你阅读Soroush Khanlou的这篇很棒的博客文章。</p><p id="7af4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简而言之，协调器是控制应用程序导航流的对象。它们有助于:</p><ul class=""><li id="9372" class="ml mm hu je b jf jg jj jk jn mn jr mo jv mp jz mq mr ms mt dt translated">隔离并重用ViewControllers</li><li id="3177" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">沿导航层次结构向下传递依赖关系；</li><li id="afcc" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">定义应用程序的用例；</li><li id="ae76" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">实现深度链接。</li></ul><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oc"><img src="../Images/bef2ad1e2c488bc5b28c5e389e8835b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNFMhDEwq-o4GbzVsjAXUA.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Coordinators Flow</figcaption></figure><p id="bf8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该图显示了应用程序中典型的协调器流程。App Coordinator检查是否有存储的有效访问令牌，并决定接下来显示哪个Coordinator—登录或选项卡栏。选项卡栏协调器显示了三个子协调器，它们对应于选项卡栏项目。</p><p id="342b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的重构过程终于要结束了。已完成的项目位于<a class="ae me" href="https://github.com/uptechteam/Coordinator-MVVM-Rx-Example/tree/master/Coordinators-MVVM-Rx" rel="noopener ugc nofollow" target="_blank">协调员-MVVM-Rx </a>目录中。有什么变化？</p><p id="39f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们来看看什么是<code class="eh mf mg mh mi b">BaseCoordinator</code>:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Base Coordinator</figcaption></figure><p id="9fb3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个通用对象为具体的协调者提供了三个特性:</p><ul class=""><li id="2f17" class="ml mm hu je b jf jg jj jk jn mn jr mo jv mp jz mq mr ms mt dt translated">启动协调器作业的抽象方法<code class="eh mf mg mh mi b">start()</code>(即呈现视图控制器)；</li><li id="74e9" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">通用方法<code class="eh mf mg mh mi b">coordinate(to: )</code>，它调用传递的子协调器上的<code class="eh mf mg mh mi b">start()</code>，并将其保存在内存中；</li><li id="e6a1" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated"><code class="eh mf mg mh mi b">disposeBag</code>为子类所用。</li></ul><p id="707c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nc">为什么</em> <code class="eh mf mg mh mi b"><em class="nc">start</em></code> <em class="nc">方法返回一个</em> <code class="eh mf mg mh mi b"><em class="nc">Observable</em></code> <em class="nc">，什么是</em> <code class="eh mf mg mh mi b"><em class="nc">ResultType</em></code> <em class="nc">？</em></p><p id="e655" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">ResultType</code>是代表协调者工作结果的类型。更常见的是<code class="eh mf mg mh mi b">ResultType</code>将是<code class="eh mf mg mh mi b">Void</code>，但是对于某些情况，它将是可能结果情况的枚举。<code class="eh mf mg mh mi b">start</code>将发出一个结果项并完成。</p><p id="2803" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在应用程序中有三个协调员:</p><ul class=""><li id="5751" class="ml mm hu je b jf jg jj jk jn mn jr mo jv mp jz mq mr ms mt dt translated"><code class="eh mf mg mh mi b">AppCoordinator</code>这是协调员层级的一个根；</li><li id="3067" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated"><code class="eh mf mg mh mi b">RepositoryListCoordinator</code>；</li><li id="993b" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated"><code class="eh mf mg mh mi b">LanguageListCoordinator.</code></li></ul><p id="d0be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看最后一个是如何与ViewController和ViewModel通信并处理导航流的:</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="a97d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果用户点击“取消”按钮，则LanguageListCoordinator工作的结果可以是选定的语言或什么都不是。两种情况都在<code class="eh mf mg mh mi b">LanguageListCoordinationResult</code>枚举中定义。</p><p id="724c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh mf mg mh mi b">RepositoryListCoordinator</code>中，我们通过<code class="eh mf mg mh mi b">LanguageListCoordinator</code>的呈现来平铺<code class="eh mf mg mh mi b">showLanguageList</code>的输出。在<code class="eh mf mg mh mi b">LanguageListCoordinator</code>的<code class="eh mf mg mh mi b">start()</code>方法完成后，我们过滤结果，如果选择了一种语言，我们将它发送到视图模型的<code class="eh mf mg mh mi b">setCurrentLanguage</code>输入。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="492c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nc">注意，我们返回</em> <code class="eh mf mg mh mi b"><em class="nc">Observable.never()</em></code> <em class="nc">，因为存储库列表屏幕总是在视图层次中。</em></p><h2 id="e4a8" class="nk kb hu bd kc np nq nr kg ns nt nu kk jn nv nw ko jr nx ny ks jv nz oa kw ob dt translated">结果</h2><p id="3de7" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我们完成了重构的最后一个阶段</p><ul class=""><li id="e828" class="ml mm hu je b jf jg jj jk jn mn jr mo jv mp jz mq mr ms mt dt translated">将导航逻辑移出视图控制器并隔离它们；</li><li id="f7c9" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">设置视图模型到视图控制器的注入；</li><li id="f04c" class="ml mm hu je b jf mu jj mv jn mw jr mx jv my jz mq mr ms mt dt translated">简化了故事板。</li></ul></div><div class="ab cl od oe hc of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="hn ho hp hq hr"><p id="6e60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从鸟瞰图来看，我们的系统是这样的:</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ok"><img src="../Images/da6cc3580c0982765699a2fe34566718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVJv23ChJixjayLKzL9HRg.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">MVVM-C architecture</figcaption></figure><p id="6361" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序协调器启动第一个协调器，该协调器初始化视图模型，注入视图控制器并呈现它。视图控制器向视图模型发送用户事件，如按钮点击或单元格区域。视图模型向视图控制器提供格式化的数据，并要求协调器导航到另一个屏幕。协调器也可以向视图模型输出发送事件。</p><h1 id="bcd9" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="0596" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我们已经讨论了很多:我们讨论了描述UI架构的MVVM，用协调器解决了导航/路由问题，并用RxSwift声明了我们的代码。我们已经对应用程序进行了一步一步的重构，并展示了每个组件是如何影响代码库的。</p><p id="5083" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在构建iOS应用程序架构时，没有灵丹妙药。每个解决方案都有自己的缺点，可能适合也可能不适合您的项目。坚持架构是在您的特定情况下权衡取舍的问题。</p><p id="fbc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，关于Rx、协调员和MVVM的内容比我在这篇文章中所能涵盖的要多得多，所以如果你想让我再写一篇关于边缘案例、问题和解决方案的文章，请告诉我。</p><p id="7228" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读！</p></div><div class="ab cl od oe hc of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="hn ho hp hq hr"><p id="5c27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nc">亚瑟·迈伦科，</em> <a class="ae me" href="https://uptech.team/" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> UPTech团队</em> </a> <em class="nc">与❤️ </em></p><p id="abeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nc">本帖原载于</em> <a class="ae me" href="http://blog.uptech.team" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> UPTech团队博客</em> </a> <em class="nc">。关注我们，获取更多关于如何构建优秀产品的文章💪</em></p></div></div>    
</body>
</html>