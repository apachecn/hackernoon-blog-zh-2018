<html>
<head>
<title>Easy peasy GraphQL authentication and authorization using Schema Directives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模式指令进行简单的身份验证和授权</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/easy-peasy-graphql-authentication-and-authorization-using-schema-directives-f28f1845da20?source=collection_archive---------4-----------------------#2018-07-02">https://medium.com/hackernoon/easy-peasy-graphql-authentication-and-authorization-using-schema-directives-f28f1845da20?source=collection_archive---------4-----------------------#2018-07-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/6dadb0f91e36e0a2635b1b18d295a393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzJLTUfsY_VdVtMs64BIBg.png"/></div></div></figure><p id="78ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在这里找到本教程的回购；<br/>T5】https://github . com/mhaagens/graphl _ authentic ation _ authorization</p><h1 id="435d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">入门指南</h1><p id="0c8e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们将使用Apollo惊人的GraphQL工具来设置我们的GraphQL服务器并创建我们的模式。首先我们需要为我们的项目安装一些依赖项；</p><p id="25f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们创建我们的package.json</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ed21" class="ln kc hu lj b fv lo lp l lq lr">npm init -y</span></pre><p id="89bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后让我们安装我们的依赖项；</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f7b5" class="ln kc hu lj b fv lo lp l lq lr">npm install apollo-server graphql lodash</span></pre><p id="ff61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将安装nodemon，这样我们就可以在发生变化时自动重新加载我们的服务器。如果你想学习如何使用Webpack和ES6模块热重装你的服务器——不重启服务器——你可以在这里查看我的另一个教程；<a class="ae ka" href="https://hackernoon.com/hot-reload-all-the-things-ec0fed8ab0" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://hackernoon.com/hot-reload-all-the-things-ec0fed8ab0</em></a></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="69bf" class="ln kc hu lj b fv lo lp l lq lr">npm install nodemon --save-dev</span></pre><p id="76d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，让我们将我们的启动脚本添加到package.json中；</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="822b" class="ln kc hu lj b fv lo lp l lq lr">'scripts': {<br/>  'start': 'nodemon ./src/app.js'<br/>},</span></pre><h1 id="86e3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">设置应用程序结构</h1><p id="3e55" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在设置package.json和node_modules的文件夹中重新创建这个树结构；</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="2863" class="ln kc hu lj b fv lo lp l lq lr">src/ <br/>  directives/ <br/>    - requireAuthDirective.js<br/>  models/ <br/>    - post.js<br/>  - app.js<br/>  - schema.js <br/>node_modules/<br/>package.json</span></pre><p id="b093" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经有了我们的结构，让我们粘贴一些样板代码让我们开始；</p><h2 id="703e" class="ln kc hu bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">src/app.js</h2><p id="350a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这段代码使用令人惊叹的Apollo Server 2.0来设置我们的GraphQL服务器🔥。<br/>我们导入我们的类型定义、解析器和模式指令，最后我们根据服务器上下文对象的请求属性对用户进行硬编码— <br/>在生产中，您需要使用密码哈希、JWT或会话cookie中间件等来设置数据库。—但是为了只关注GraphQL部分，我们跳过了所有这些，现在只对用户进行硬编码。我们还将我们的<code class="eh mg mh mi lj b">requireAuthDirective</code>(我们稍后将创建它)添加到我们的<code class="eh mg mh mi lj b">schemaDirectives</code>中。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><h2 id="6c8d" class="ln kc hu bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">src/schema.js</h2><p id="adcc" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在这里，我们定义我们的模式，用我们的Post类型定义扩展我们的根类型定义，然后将Post解析器与根解析器合并。我们将在下一步创建Post类型定义和解析器。我们还为模式指令创建了角色枚举。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><h2 id="cf13" class="ln kc hu bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">src/models/post.js</h2><p id="a86e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在我们有了模式，让我们创建我们的Post类型定义和解析器。我们只是硬编码一些要返回的帖子，然后我们用<code class="eh mg mh mi lj b">posts</code>的查询解析器扩展根查询，它将返回我们所有的帖子——假设您已经过身份验证和授权。</p><p id="426c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意posts查询定义后面的<code class="eh mg mh mi lj b">@requireAuth</code>指令。这就是我们如何告诉我们的模式使用字段定义的指令。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><h2 id="f984" class="ln kc hu bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">src/directives/requireautdirective . js</h2><p id="7174" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这是我们为模式指令定义规则的地方。<br/>我们创建了一个从apollo-server扩展“SchemaDirectiveVisitor”的指令。我们检查一个用户是否存在于我们的<code class="eh mg mh mi lj b">context.req</code>对象上，如果指定了一个角色，那么这个角色与用户的角色相匹配。如果是，我们解析该字段，如果不是，我们抛出一个AuthenticationError。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><h1 id="977c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">我们来试试吧！</h1><p id="4d9a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">运行<code class="eh mg mh mi lj b">npm start</code>进入<a class="ae ka" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>。<br/>现在您应该看到GraphQL平台，在这里您可以针对您的模式运行查询。</p><p id="f043" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对帖子运行一个查询，它<em class="ls">应该</em>返回帖子<br/>，因为我们是用硬编码的用户“登录”的；</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/1e0d6d4f525225ee29da9eb4bfaca397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcLv-ambm19Sa8w7Lh_UuA.png"/></div></div></figure><p id="7687" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果我们想要求一个角色来访问这些帖子呢？<br/>我们的用户被硬编码为用户角色，因此我们需要管理员角色来访问帖子。</p><p id="c220" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开<code class="eh mg mh mi lj b">src/models/post.js</code>，将<code class="eh mg mh mi lj b">@requireAuth</code>指令改为<code class="eh mg mh mi lj b">@requireAuth(role: ADMIN)</code>。在操场上再次运行查询，现在应该会得到一个AuthenticationError。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/3c37f5c56d509714e38a60b8b52b87c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJPtMGlQ9iL-sGrNylBktw.png"/></div></div></figure><p id="2aa8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，让我们将用户从我们的服务器上下文中完全删除，以检查您是否需要登录才能访问帖子。</p><p id="5c24" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开<code class="eh mg mh mi lj b">src/app.js</code>，从服务器中移除<code class="eh mg mh mi lj b">context</code>对象，像这样；</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="01c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您现在应该得到另一个AuthenticationError，告诉您需要登录才能查看资源；</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/5553324757e2e07653c5eaabc53c1daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjY7FyHW3h8PR093p1phbg.png"/></div></div></figure><h1 id="2a83" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">包裹</h1><p id="8013" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">原来如此。这是对使用模式指令进行身份验证和授权的简单介绍。现在，请不要在生产中使用这段代码——可能还有很多检查要做，当然，您需要安全地实现会话cookies或JWTs来使其正常工作——但是我希望您在阅读完这篇文章后，在GraphQL web应用程序中实现正确的auth方面有所进步！</p><p id="acb7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更多关于web开发、GraphQL和Javascript的文章，请在Twitter上关注我；<br/><a class="ae ka" href="https://twitter.com/mhaagens" rel="noopener ugc nofollow" target="_blank">https://twitter.com/mhaagens</a></p><p id="a1ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">延伸阅读；<br/><a class="ae ka" href="https://www.apollographql.com/docs/graphql-tools/schema-directives.html" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/graph QL-tools/schema-directives . html</a></p><h2 id="5034" class="ln kc hu bd kd lt lu lv kh lw lx ly kl jn lz ma kp jr mb mc kt jv md me kx mf dt translated">谢谢</h2><p id="a7a9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">感谢<a class="ae ka" href="https://twitter.com/jbaxleyiii" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> @ </strong> jbaxleyiii </a>帮助我弄清楚如何实现模式指令，感谢Apollo团队令人惊叹的工作！</p></div></div>    
</body>
</html>