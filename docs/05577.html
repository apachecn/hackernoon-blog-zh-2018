<html>
<head>
<title>Contributing to GHC 4: Real Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为GHC 4献计献策:现实问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/contributing-to-ghc-4-real-issues-8238fba87775?source=collection_archive---------32-----------------------#2018-07-02">https://medium.com/hackernoon/contributing-to-ghc-4-real-issues-8238fba87775?source=collection_archive---------32-----------------------#2018-07-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="db22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的几周里，我们好好看看GHC。<a class="ae jp" href="https://mmhaskell.com/blog/2018/6/11/contributing-to-ghc-1-preparation" rel="noopener ugc nofollow" target="_blank">我们从</a>开始，看看为GHC开发准备本地机器所需的步骤。这在Windows上是一个特别困难的过程，所以我们把重点放在那里。之后，我们看了一下<a class="ae jp" href="https://mmhaskell.com/blog/2018/6/18/contributing-to-ghc-2-basic-hacking-and-organization" rel="noopener ugc nofollow" target="_blank">为我们自己创建一个开发周期</a>的基本方法。我们通过改变一个错误消息并观察它在编译器中的表现来验证这一点。上周我们做了一些更复杂的改动。这一周，我们将通过看一些做贡献的基本方法来结束这个系列。</p><h1 id="a476" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">证明文件</h1><p id="7174" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在任何软件项目中，文档都是一件棘手的事情。在任何给定的时刻，大部分的努力都是为了确保程序正常运行。当你已经理解了代码，你就不需要看文档了。所以诱惑是不要改变任何评论。这意味着文档总是有可能过时。哈斯克尔更容易犯这种错误。我们通过修改、编译和查看哪里出了问题来寻找问题。文档永远不会中断！</p><p id="c307" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有经验的开发人员会记得多修改文档。尽管如此，还是不可避免地会有一些东西从缝隙中溜走。但是对于GHC代码库的新手来说，有一个好消息！我们处于寻找文档漏洞的最佳位置，因为我们是最需要阅读它的人！这就是我如何发现我能做出的第一个贡献。</p><p id="d8e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在探索lexing类型时，我发现了一个不太有意义的评论。在<code class="eh kt ku kv kw b">compiler/basicTypes/BasicTypes.hs</code>的顶部，写着:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="14ef" class="lf jr hu kw b fv lg lh l li lj">-- There is considerable overlap between the logic here and the logic<br/>-- in Lexer.x, but sadly there seems to be way to merge them.</span></pre><p id="833f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这读起来不太对。从上下文来看，似乎很清楚作者打算写“似乎没有<strong class="it hv">或</strong>方法来合并它们”。太好了，让我们为此提交一个拉取请求！我们将派生存储库并打开一个拉取请求。因此，我们将创建<a class="ae jp" href="https://github.com/jhb563/ghc" rel="noopener ugc nofollow" target="_blank">fork</a>，克隆repo，打开一个新分支，并针对master打开一个pull请求。</p><p id="4311" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在有一个有点恼人的问题，那就是CI构建现在似乎还没有通过。但是希望<a class="ae jp" href="https://github.com/ghc/ghc/pull/153" rel="noopener ugc nofollow" target="_blank">这个公关</a>会在某个时候被合并进去。</p><h1 id="da7c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用Trac跟踪问题</h1><p id="5547" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当然，GHC还有更复杂的问题。这是我们想要添加到代码库中的真正特性，以及我们想要修复的错误！要了解那里发生了什么，您需要查看<a class="ae jp" href="https://ghc.haskell.org/trac/ghc" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>。GHC为此使用Trac，你可以观察列表上的所有问题。它们有标签，这些标签基于它们的版本以及它们的重要性。</p><p id="63ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能是一个很长的列表。我翻阅了许多不同的门票，不知道我能帮上什么忙。那么，你如何能找到一些东西开始呢？首先，你可以订阅GHC发展邮件列表。那里的对话会帮助你发现人们在做什么。其次，您可以登录到<a class="ae jp" href="https://freenode.net/" rel="noopener ugc nofollow" target="_blank"> Freenode </a>并进入<code class="eh kt ku kv kw b">#ghc</code>通道。你可以问任何人发生了什么事，你可以在哪里帮忙。幸运的是，在问题列表上还有一个“新来者”的标签。这些是GHC开发者强调的问题，对于代码新手来说应该很容易。让我们来看看其中的一个问题。</p><h1 id="5a8f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">看看真正的问题:中缀模式</h1><p id="f2c5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">从这次狩猎中，我发现<a class="ae jp" href="https://ghc.haskell.org/trac/ghc/ticket/15235" rel="noopener ugc nofollow" target="_blank">这张票</a>，和<code class="eh kt ku kv kw b">(-&gt;)</code>的中缀值有关。票声称声明的箭头操作符的中缀级别0实际上是不正确的。让我们来看看它们是什么意思。</p><p id="cbc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提醒一下，中缀级别表示操作员在确定操作顺序时的优先级。例如，乘法运算符<code class="eh kt ku kv kw b">(*)</code>比加法运算符<code class="eh kt ku kv kw b">(+)</code>具有更高的中缀级别。我们可以在每台机器上使用<code class="eh kt ku kv kw b">:info</code>命令，通过快速的ghci会话来确认这些信息。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="898f" class="lf jr hu kw b fv lg lh l li lj">&gt;&gt; :i (+)<br/>…<br/>infixl 6 +<br/>&gt;&gt; :i (*)<br/>…<br/>infixl 7 *<br/>&gt;&gt; 5 + 2 * 3<br/>11 -- Would be 21 if addition were higher precedence</span></pre><p id="65fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当两个算子有相同的中缀水平时，那么我们参考中缀水平的方向。作为一个例子，我们可以比较减法和加法。我们会发现也是<code class="eh kt ku kv kw b">infixl 6</code>。由于是<code class="eh kt ku kv kw b">infixl</code>(相对于<code class="eh kt ku kv kw b">infixr</code>)，我们给左侧操作优先权。这里有一个例子。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="527e" class="lf jr hu kw b fv lg lh l li lj">&gt;&gt; :i (-)<br/>…<br/>infixl 6 -<br/>&gt;&gt; 5 - 2 + 18<br/>21 -- Not (-15)</span></pre><p id="a9bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以让我们看看我们的箭头操作符，我们在定义类型签名时使用它:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="50a2" class="lf jr hu kw b fv lg lh l li lj">&gt;&gt; :i (-&gt;)<br/>data (-&gt;) (a :: TYPE q) (b :: TYPE r) -- Defined . `GHC.Prim`<br/>infixr 0 `(-&gt;)`<br/>...</span></pre><p id="0fa1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这表明这个操作符的中缀级别为0，我们应该优先考虑右边的内容。然而，提交bug的人建议使用以下代码:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b704" class="lf jr hu kw b fv lg lh l li lj">{-# LANGUAGE TypeOperators #-}</span><span id="8d4e" class="lf jr hu kw b fv lk lh l li lj">module Bug where</span><span id="9c8d" class="lf jr hu kw b fv lk lh l li lj">import Data.Type.Equality</span><span id="af0c" class="lf jr hu kw b fv lk lh l li lj">type (~&gt;) = (-&gt;)<br/>infixr 0 ~&gt;</span><span id="ef9a" class="lf jr hu kw b fv lk lh l li lj">f :: (a ~&gt; b -&gt; c) :~: (a ~&gt; (b -&gt; c))<br/>f = Refl</span></pre><p id="d699" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有很多更高层次的概念，所以让我们把它们都分解一下。第一，<code class="eh kt ku kv kw b">(-&gt;)</code>是一个类型运算符，意思是它本身其实就是一个类型。因此，我们可以为它创建一个名为<code class="eh kt ku kv kw b">(~&gt;)</code>的类型同义词。然后我们可以给这个新的操作符指定任何我们喜欢的中缀层次。在这种情况下，我们将选择与原始操作符<code class="eh kt ku kv kw b">infixr 0</code>相同的中缀级别。</p><p id="8f18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一部分创建一个表达式<code class="eh kt ku kv kw b">f</code>。它的类型签名使用<code class="eh kt ku kv kw b">(:~:)</code>操作符来表示类型之间的关系相等。这个类型有一个<code class="eh kt ku kv kw b">Refl</code>构造函数。你唯一需要理解的是我们的每个箭头模式(<code class="eh kt ku kv kw b">(a ~&gt; b -&gt; c)</code>和<code class="eh kt ku kv kw b">(a ~&gt; (b -&gt; c))</code>)都是一个类型。并且这些代码应该<strong class="it hv">只编译</strong>如果那些类型是相同的。</p><p id="70be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从表面上看，这些类型<em class="ll">应该是相同的。毕竟，这两个操作符都声称是<code class="eh kt ku kv kw b">infixr 0</code>，这意味着我们在<code class="eh kt ku kv kw b">(:~:)</code>右边加括号的方式应该与它自然排序的方式相匹配。但是代码<strong class="it hv">不编译！</strong></em></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b60b" class="lf jr hu kw b fv lg lh l li lj">&gt;&gt; ghci<br/>&gt;&gt; :l Bug.hs<br/>Bug.hs:11:5: error:<br/>    * Couldn’t match type `a` with `a ~&gt; b`<br/>      `a` is a rigid type variable bound by<br/>        f :: forall a b c. ((a ~&gt; b) -&gt; c) :~: (a ~&gt; ( b -&gt; c))<br/>        At Bug.hs:10:1-38<br/>      Expected type: ((a ~&gt; b) -&gt; c) :~: (a ~&gt; (b -&gt; c))<br/>        Actual type: ((a ~&gt; b) -&gt; c) :~: ((a ~&gt; b) -&gt; c)<br/>    * In the expression: Refl<br/>      In an equation for `f’: f = Refl<br/>    * Relevant bindings include<br/>      f :: ((a ~&gt; b) -&gt; c) :~: (a ~&gt; (b -&gt; c))<br/>        (bound at Bug.hs:11:1)<br/>   |<br/>11 | f = Refl<br/>   |</span></pre><p id="de98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在“实际类型”一行看到编译器是如何解释<code class="eh kt ku kv kw b">(a ~&gt; b -&gt; c)</code>的。它优先考虑左派，而不是右派。事实上，如果我们更改类型签名以反映给予<code class="eh kt ku kv kw b">(~&gt;)</code>的优先级，我们的代码将编译为:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="ac82" class="lf jr hu kw b fv lg lh l li lj">f :: (a ~&gt; b -&gt; c) :~: ((a ~&gt; b) -&gt; c)<br/>f = Refl<br/>…<br/>&gt;&gt; ghci<br/>&gt;&gt; :l Bug.hs<br/>Ok, one module loaded.</span></pre><h1 id="381f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">修复</h1><p id="a828" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对我们来说幸运的是，票里已经提出了解决方案。编译器使用<code class="eh kt ku kv kw b">Fixity</code>类型表示我们的操作符的中缀级别。我们可以看到我们为一些内置运算符定义了级别的特定位置:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="f5f7" class="lf jr hu kw b fv lg lh l li lj">negateFixity, funTyFixity :: Fixity<br/>negateFixity = Fixity NoSourceText 6 InfixL -- Fixity of unary negate<br/>funTyFixity = Fixity NoSourceText 0 InfixR -- Fixity of `-&gt;`</span></pre><p id="8562" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们想改变函数类型操作符的固定性。我们应该让它看起来像是<code class="eh kt ku kv kw b">-1</code>，而不是看起来像是0，显示这个操作符的较低优先级。注意这个代码指的是我们的we report。它最终具有较低优先级的实际原因更加复杂。但是让我们做出改变:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3fac" class="lf jr hu kw b fv lg lh l li lj">funTyFixity = Fixity NoSourceText (-1) InfixR</span></pre><h1 id="e057" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">测试我们的变化</h1><p id="0f09" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这似乎应该是一个简单的测试变化。首先，我们将再次<code class="eh kt ku kv kw b">make</code>我们的代码。然后我们将启动GHCI并询问关于<code class="eh kt ku kv kw b">(-&gt;)</code>的信息。但是当我们尝试时，这似乎不起作用！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1ef6" class="lf jr hu kw b fv lg lh l li lj">&gt; make<br/>&gt; ghci<br/>...<br/>&gt;&gt; :i (-&gt;)<br/>data (-&gt;) (a :: TYPE q) (b :: TYPE r) -- Defined . `GHC.Prim`<br/>infixr 0 `(-&gt;)`<br/>...</span></pre><p id="049f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的问题是，重新制作不会导致GHCI使用我们新的本地构建版本的GHC。即使在从<code class="eh kt ku kv kw b">ghc/inplace/bin</code>目录中使用<code class="eh kt ku kv kw b">ghci.exe</code>时，它仍然不能解释这种变化。解决这个问题的方法是，不使用<code class="eh kt ku kv kw b">ghci</code>，我们可以将<code class="eh kt ku kv kw b">--interactive</code>标志传递给对<code class="eh kt ku kv kw b">ghc</code>的普通调用。所以我们需要这样的东西:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d443" class="lf jr hu kw b fv lg lh l li lj">~/ghc/inplace/bin/ghc-stage2.exe -o prog --interactive Main.hs</span></pre><p id="7bcd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将打开GHCI提示符，加载我们的主模块。现在，当我们继续前进并获得信息时，我们将看到它的工作！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d7aa" class="lf jr hu kw b fv lg lh l li lj">&gt; ~/ghc/inplace/bin/ghc-stage2.exe -o prog --interactive Main.hs<br/>...<br/>&gt;&gt; :i (-&gt;)<br/>data (-&gt;) (a :: TYPE q) (b :: TYPE r) -- Defined . `GHC.Prim`<br/>infixr -1 `(-&gt;)`<br/>...</span></pre><p id="3237" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我现在将发出一个简单的pull请求来解决这个问题。你可以在这里跟踪进度<a class="ae jp" href="https://github.com/ghc/ghc/pull/158" rel="noopener ugc nofollow" target="_blank">。随着进展的深入，我会更新这篇文章。</a></p><h1 id="b9c6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="5b75" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们为GHC做贡献的系列报道到此结束！外面有很多bug，所以不要害怕看一看任何标有<code class="eh kt ku kv kw b">newcomer</code>的东西。只要确保看一看已经在票上发生的讨论就行了！</p><p id="21d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要了解更多关于Haskell的内容，你可以阅读我们的<a class="ae jp" href="https://www.mmhaskell.com/liftoff" rel="noopener ugc nofollow" target="_blank"> Liftoff系列</a>(针对初学者)或者我们的<a class="ae jp" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>，如果你已经熟悉这种语言的话。你也可以下载我们的<a class="ae jp" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank"> Haskell初学者清单</a>来开始！或者你可以看看我们的<a class="ae jp" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>如果你想要一些更先进的项目的想法。</p></div></div>    
</body>
</html>