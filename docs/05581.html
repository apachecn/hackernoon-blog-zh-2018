<html>
<head>
<title>Virtual reality with React 360</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 360虚拟现实</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/virtual-reality-with-react-360-ce24b611f0f5?source=collection_archive---------2-----------------------#2018-07-03">https://medium.com/hackernoon/virtual-reality-with-react-360-ce24b611f0f5?source=collection_archive---------2-----------------------#2018-07-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/bb407f7b73714d2725bd4af3bd2f15e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*4zq4HrS85EmlGj_H"/></div></figure><p id="5760" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">作为一名软件开发人员，我花时间构建网站和网络应用，但长期以来，我还对虚拟现实感兴趣。我将我的Oculus Go命名为“Betty ”,并开始兴奋地谈论如何体验威尼斯的贡多拉之旅、惊险的过山车以及在人体血管中旅行。因为我使用React，主要是，我很兴奋地得知我可以用一个我已经知道并喜欢的库来开发虚拟现实体验。</p><p id="17ef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">T <a class="ae jw" href="https://lilydbarrett.com/2018/04/23/recompose-with-react-vr/" rel="noopener ugc nofollow" target="_blank">为了尝试React VR </a>，我最近创建了一个名为<a class="ae jw" href="https://github.com/lilybarrett/find-your-zen-react-360" rel="noopener ugc nofollow" target="_blank"> Find Your Zen </a>的虚拟现实应用程序，它允许用户选择一个沉浸式冥想环境，每个环境都有自己的咒语，灵感来自非常优秀的节目<a class="ae jw" href="https://www.nbc.com/the-good-place?nbc=1" rel="noopener ugc nofollow" target="_blank">“好地方”。</a>2018年5月，在我建立我的应用程序后不久，脸书发布了一个经过修改和更名的React VR版本，名为<a class="ae jw" href="https://facebook.github.io/react-360/" rel="noopener ugc nofollow" target="_blank"> React 360 </a>，有多处变化和重大改进。</p><p id="882b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我将我的应用程序移植到React 360时，我注意到了React VR和React 360之间的一些重要差异。我为拥有React应用知识的开发人员写了下面这篇文章。如果你不熟悉这个库，我推荐你先从这里的开始。</p><p id="b26d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你想要React VR的介绍(以及<a class="ae jw" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank">重组</a>，它的效用函数帮助管理我的应用程序的状态)，你可以在这里找到<a class="ae jw" href="https://lilydbarrett.com/2018/04/23/recompose-with-react-vr/" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到<a class="ae jw" href="https://lilydbarrett.com/2018/05/05/recompose-with-react-vr-pt-2/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b9f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">查看完成的演示代码</strong></p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="b7c8" class="kg kh hu kc b fv ki kj l kk kl">$ git clone <a class="ae jw" href="https://github.com/lilybarrett/find-your-zen.git" rel="noopener ugc nofollow" target="_blank">https://github.com/lilybarrett/find-your-zen.git</a><br/>$ cd find-your-zen<br/>$ npm i<br/>$ npm start</span></pre><p id="13aa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">文件结构</strong></p><p id="f9f9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">React VR的基本文件结构如下:</p><ul class=""><li id="4057" class="km kn hu ja b jb jc jf jg jj ko jn kp jr kq jv kr ks kt ku dt translated"><code class="eh kv kw kx kc b">index.vr.js</code> =我的应用程序的入口</li><li id="7a2b" class="km kn hu ja b jb ky jf kz jj la jn lb jr lc jv kr ks kt ku dt translated"><code class="eh kv kw kx kc b">vr</code>文件夹=存储启动我的应用程序的代码，包括<code class="eh kv kw kx kc b">index.html</code>和<code class="eh kv kw kx kc b">client.js</code>文件</li><li id="3d9f" class="km kn hu ja b jb ky jf kz jj la jn lb jr lc jv kr ks kt ku dt translated"><code class="eh kv kw kx kc b">static_assets</code> =存储图像、音频文件和其他外部资源</li></ul><p id="8243" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是React 360的新文件结构:</p><ul class=""><li id="e616" class="km kn hu ja b jb jc jf jg jj ko jn kp jr kq jv kr ks kt ku dt translated"><code class="eh kv kw kx kc b">index.js</code> =我的应用入口</li><li id="4797" class="km kn hu ja b jb ky jf kz jj la jn lb jr lc jv kr ks kt ku dt translated">设置“运行时”，将我的React组件转换成我们的VR场景中的3D元素</li><li id="760f" class="km kn hu ja b jb ky jf kz jj la jn lb jr lc jv kr ks kt ku dt translated"><code class="eh kv kw kx kc b">index.html</code> =在典型的React应用程序中，为我安装React代码提供了一个位置</li><li id="8fe5" class="km kn hu ja b jb ky jf kz jj la jn lb jr lc jv kr ks kt ku dt translated"><code class="eh kv kw kx kc b">static_assets</code> =存储图像、音频文件和其他外部资源</li></ul><p id="e8ac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我将文件夹结构的其余部分设置如下:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="6292" class="kg kh hu kc b fv ki kj l kk kl">- components // shared components <br/>  - base-button<br/>  - content<br/>- consts<br/>- providers // Recompose providers live here<br/>- scenes<br/>  - home-environment <br/>    - components<br/>      - menu<br/>      - title<br/>      - zen-button<br/>      - zens <br/>    - zen-environment<br/>      - components<br/>        - home-button<br/>        - mantra <br/>- static-assets<br/>  - images<br/>  - sounds </span></pre><p id="b567" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">共享组件位于顶层<code class="eh kv kw kx kc b">components</code>文件夹中。存储在<code class="eh kv kw kx kc b">scenes,</code>我的<code class="eh kv kw kx kc b">HomeEnvironment</code>中——第一个加载的环境，在那里我的用户访问冥想环境菜单进行探索——并且<code class="eh kv kw kx kc b">ZenEnvironment</code>场景每个都有自己的相关组件集。我的状态管理由<a class="ae jw" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank">重组</a> <code class="eh kv kw kx kc b">providers</code>处理，并在功能上组合成每个需要访问状态的组件。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/bc44e80276ffc84fbe7b72c787a6a0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*msH7fiEZIBNSv67c"/></div></figure><p id="b5ff" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">安装应用</strong></p><p id="2298" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在React VR中，我的<code class="eh kv kw kx kc b">client.js</code>相当简单，没有给我太多的配置选项:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="7875" class="kg kh hu kc b fv ki kj l kk kl">// React VR application -- vr/client.js<br/>// Auto-generated content.<br/>// This file contains the boilerplate to set up your React app.<br/>// If you want to modify your application, start in "index.vr.js"</span><span id="5ca0" class="kg kh hu kc b fv ld kj l kk kl">import<!-- --> <!-- -->{ VRInstance } from "react-vr-web";<br/>function<!-- --> <!-- -->init(bundle, parent, options) {<br/>   const vr = new<!-- --> <!-- -->VRInstance(bundle, "MeditationApp", parent, {<br/>      cursorVisibility: "auto",<br/>      // Add custom options here<br/>      ...options,<br/>   });</span><span id="24b0" class="kg kh hu kc b fv ld kj l kk kl">vr.render = function() {<br/>      // Any custom behavior you want to perform on each frame goes  <br/>      here<br/>   };<br/>   // Begin the animation loop<br/>   vr.start();<br/>   return<!-- --> <!-- -->vr;<br/>}<br/>window.ReactVR = {init};</span></pre><p id="a536" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在React 360中，我可以将应用程序的内容安装到某个表面或位置。Surfaces，<a class="ae jw" href="https://facebook.github.io/react-360/docs/surfaces.html" rel="noopener ugc nofollow" target="_blank">正如文件所说</a>，“允许你在3D空间中添加2D界面，让你以像素而不是物理尺寸工作。”在我的例子中，我将应用程序的可视内容包装在一个<code class="eh kv kw kx kc b">AppContent</code>组件中，我将这个组件挂载到React 360的默认柱面上。这个表面将内容投射到一个半径为4米的圆柱体内部——位于用户前方的中心。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/accc9f1d609dcc66f340c0e9846e06f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*V5AN-bm9TglCoOAn"/></div></figure><p id="32f0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我可以在React 360中创建自己的自定义曲面，增加或减少半径或使曲面平坦而不是圆柱形。</p><p id="0059" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我还将整个应用程序本身挂载到React 360的默认位置，这允许我的应用程序利用React 360的运行时。</p><p id="bd93" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">新的运行时是React 360相对于React VR的显著优势之一。为什么？将应用程序的渲染或“运行时”方面从应用程序代码中分离出来，可以改善<strong class="ja hv">延迟</strong>:用户操作与视图中像素更新以响应该操作之间的时间。如果数据传输太慢，会给用户带来断断续续、令人迷惑的画面——类似于Youtube视频中的缓冲或电视屏幕上的静态画面。</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/76ce3da9d2990582b04cf99e43ed704c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*5hNAdJKVzmP1p3Bx"/></div></figure><p id="abe3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae jw" href="https://facebook.github.io/react-360/docs/runtime.html" rel="noopener ugc nofollow" target="_blank">React 360文档进一步解释了</a>，网络浏览器是单线程的，这意味着作为应用程序后台更新的一部分，该进程可能会阻止或阻碍数据传输。“这对于在VR头戴设备上观看360°体验的用户来说尤其成问题，在那里，显著的渲染延迟会破坏沉浸感，”文件告诉我们，“通过在单独的上下文中运行应用程序代码，我们允许渲染循环以高帧速率持续更新。”</p><blockquote class="le lf lg"><p id="d5ca" class="iy iz lh ja b jb jc jd je jf jg jh ji li jk jl jm lj jo jp jq lk js jt ju jv hn dt translated"><strong class="ja hv"> <em class="hu">如果数据传输太慢，会给用户带来断断续续、令人迷惑的画面——类似于Youtube视频上的缓冲或电视屏幕上的静态画面。</em> </strong></p></blockquote><p id="3c27" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我的<code class="eh kv kw kx kc b">index.js</code>中，我<em class="lh">注册</em>我的<code class="eh kv kw kx kc b">MeditationApp</code>(见下面的第二个代码块)以挂载到默认位置——让我的整个应用程序访问运行时——同时我将我想要显示的内容(同样，存储在<code class="eh kv kw kx kc b">AppContent</code>中)注册到默认的柱面。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="be5f" class="kg kh hu kc b fv ki kj l kk kl">// components/content.js</span><span id="6f6a" class="kg kh hu kc b fv ld kj l kk kl">import<!-- --> <!-- -->React from "react";<br/>import<!-- --> <!-- -->{ View } from "react-360";<br/>import<!-- --> <!-- -->{ HomeEnvironment, ZenEnvironment } from "../../scenes";<br/>import<!-- --> <!-- -->{ withAppContext } from "../../providers";</span><span id="af20" class="kg kh hu kc b fv ld kj l kk kl">const AppContent = withAppContext(() =&gt; (<br/>   &lt;View&gt;<br/>      &lt;HomeEnvironment /&gt;<br/>      &lt;ZenEnvironment /&gt;<br/>   &lt;/View&gt;<br/>));</span><span id="e945" class="kg kh hu kc b fv ld kj l kk kl">export<!-- --> <!-- -->default<!-- --> <!-- -->AppContent;</span><span id="4a52" class="kg kh hu kc b fv ld kj l kk kl">// index.js</span><span id="d885" class="kg kh hu kc b fv ld kj l kk kl">import<!-- --> <!-- -->React from "react";<br/>import<!-- --> <!-- -->{<br/>   AppRegistry,<br/>   View,<br/>} from "react-360";<br/>import<!-- --> <!-- -->{ AppContent } from "./components";<br/>import<!-- --> <!-- -->{ withAppContext } from "./providers";</span><span id="d031" class="kg kh hu kc b fv ld kj l kk kl">const MeditationApp = withAppContext(() =&gt; (<br/>   &lt;View style={{<br/>      transform: [{ translate: [0, 0, -2] }]<br/>   }}&gt;<br/>      &lt;AppContent /&gt;<br/>   &lt;/View&gt;<br/>));</span><span id="a680" class="kg kh hu kc b fv ld kj l kk kl">AppRegistry.registerComponent("AppContent", () =&gt; AppContent);<br/>AppRegistry.registerComponent("MeditationApp", () =&gt; MeditationApp);</span></pre><p id="5c99" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我的<code class="eh kv kw kx kc b">client.js </code>负责将组件安装到位置和表面:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="7098" class="kg kh hu kc b fv ki kj l kk kl">// client.js<strong class="kc hv"><br/></strong>import<!-- --> <!-- -->{ ReactInstance, Surface } from "react-360-web";</span><span id="780d" class="kg kh hu kc b fv ld kj l kk kl">function<!-- --> <!-- -->init(bundle, parent, options = {}) {<br/>   const r360 = new<!-- --> <!-- -->ReactInstance(bundle, parent, {<br/>      fullScreen: true,<br/>      // Add custom options here<br/>      ...options,<br/>   });</span><span id="7e66" class="kg kh hu kc b fv ld kj l kk kl">   r360.renderToSurface(<br/>      r360.createRoot("AppContent", { /* initial props */<!-- --> <!-- -->}),<br/>      r360.getDefaultSurface()<br/>   );</span><span id="73fa" class="kg kh hu kc b fv ld kj l kk kl">   r360.renderToLocation(<br/>      r360.createRoot("MeditationApp", { /* initial props */<!-- --> <!-- -->}),<br/>      r360.getDefaultLocation(),<br/>   );</span><span id="b650" class="kg kh hu kc b fv ld kj l kk kl">   r360.compositor.setBackground(<br/>      r360.getAssetURL("images/homebase.png")<br/>   );<br/>}</span><span id="cab8" class="kg kh hu kc b fv ld kj l kk kl">window.React360 = {init};</span></pre><p id="32db" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">播放音频</strong></p><p id="eb24" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我的<code class="eh kv kw kx kc b">consts</code>文件夹中，我创建了一个<code class="eh kv kw kx kc b">zens.js</code>文件来快速存储我的数据——包括每个环境的正确音频文件和图像:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="11e5" class="kg kh hu kc b fv ki kj l kk kl">const zens = [<br/>   { id: 1,<br/>     mantra: "Find your inner motherforking peace",<br/>     image: "images/hawaii_beach.jpg",<br/>     audio: "sounds/waves.mp3",<br/>     text: "I'm feeling beachy keen",<br/>   },<br/>   { id: 2,<br/>     mantra: "Breathe in peace, breathe out bullshirt",<br/>     image: "images/horseshoe_bend.jpg",<br/>     audio: "sounds/birds.mp3",<br/>     text: "Ain't no mountain high enough",<br/>   },<br/>   { id: 3,<br/>     mantra: "Benches will be benches",<br/>     image: "images/sunrise_paris_2.jpg",<br/>     audio: "sounds/chimes.mp3",<br/>     text: "I want a baguette",<br/>   },<br/>   { id: 4,<br/>     image: "images/homebase.png",<br/>     text: "Home"<br/>   }<br/>]</span><span id="866d" class="kg kh hu kc b fv ld kj l kk kl">export default zens;</span></pre><p id="baf6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了在我的React VR场景中播放音频，我使用了一个<code class="eh kv kw kx kc b">Sound</code>组件，它接受一个在<code class="eh kv kw kx kc b">static_assets</code>文件夹中的声音文件的URL作为<code class="eh kv kw kx kc b">source</code>道具。为了防止音频在不属于它的环境中播放——比如家庭环境——我通过重新组合实现了逻辑，根据我们是否处于没有音频文件与之关联的环境中来“隐藏”和“显示”<code class="eh kv kw kx kc b">Sound</code>组件。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="cd65" class="kg kh hu kc b fv ki kj l kk kl">// React VR -- components/audio.js</span><span id="e233" class="kg kh hu kc b fv ld kj l kk kl">import<!-- --> <!-- -->React from "react";<br/>import<!-- --> <!-- -->{ Sound } from "react-vr";<br/>import<!-- --> <!-- -->zens from "../consts/zens.js";<br/>import<!-- --> <!-- -->{ compose } from "recompose";<br/>import<!-- --> <!-- -->{ asset } from "react-vr";<br/>import<!-- --> <!-- -->{ hideIf, usingAppContext } from "../providers/index.js";</span><span id="50e6" class="kg kh hu kc b fv ld kj l kk kl">const hideIfNoAudioUrl = hideIf(({ selectedZen }) =&gt; {<br/>   const zenAudio = zens[selectedZen - 1].audio;<br/>   return<!-- --> <!-- -->zenAudio === null<!-- --> <!-- -->|| zenAudio === undefined || zenAudio.length === 0;<br/>});</span><span id="f529" class="kg kh hu kc b fv ld kj l kk kl">export<!-- --> <!-- -->default<!-- --> <!-- -->compose(<br/>   usingAppContext,<br/>   hideIfNoAudioUrl,<br/>)(({ selectedZen }) =&gt; {<br/>   const zenAudio = zens[selectedZen - 1].audio;<br/>   return<!-- --> <!-- -->(<br/>      &lt;Sound source={asset(zenAudio)} /&gt;<br/>   )<br/>});</span></pre><p id="5540" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">React 360在此基础上有了很大改进。对于播放音频，我使用的是<code class="eh kv kw kx kc b">AudioModule</code>原生模块。它的<code class="eh kv kw kx kc b">playEnvironmental</code>方法允许我提供一个路径(到我们的assets文件夹中的音频)和一个音量来循环播放所述音频。一旦音频文件停止播放，它将重新开始。</p><p id="b6f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这个过程中，我意识到我需要告诉我的应用程序在切换场景时何时停止播放特定的音频文件。(否则，在沉浸于寻找你的禅时，你可能会在导航回到家庭环境后，听到来自你以前环境的音频——例如，巴黎城市广场上的教堂钟声)。我用<code class="eh kv kw kx kc b">AudioModule</code>的<code class="eh kv kw kx kc b">stopEnvironmental</code>方法完成这个任务。</p><p id="1a76" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请继续阅读以了解这一点…</p><p id="168b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">使用图像</strong></p><p id="7f9c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在React VR中，我使用了一个<code class="eh kv kw kx kc b">Pano</code>组件来显示一张360度的照片。为了显示特定的图像，<code class="eh kv kw kx kc b">Pano</code>和<code class="eh kv kw kx kc b">Audio</code>一样，接受一个资产URL作为<code class="eh kv kw kx kc b">source</code>道具。根据用户选择的环境，应用程序的状态会更新以显示该环境的图像。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="1c2e" class="kg kh hu kc b fv ki kj l kk kl">// React VR -- components/wrapped-pano.js</span><span id="8dd3" class="kg kh hu kc b fv ld kj l kk kl">import<!-- --> <!-- -->React from "react";<br/>import<!-- --> <!-- -->{ Pano } from "react-vr";<br/>import<!-- --> <!-- -->{ usingAppContext } from "../providers/index.js";<br/>import<!-- --> <!-- -->{ Audio } from "../components/index.js";<br/>import<!-- --> <!-- -->zens from "../consts/zens.js";<br/>import<!-- --> <!-- -->{ asset } from "react-vr";</span><span id="1205" class="kg kh hu kc b fv ld kj l kk kl">export<!-- --> <!-- -->default<!-- --> <!-- -->usingAppContext(({ selectedZen }) =&gt; {<br/>   return<!-- --> <!-- -->(<br/>      &lt;Pano source={asset(zens[selectedZen - 1].image)} &gt;<br/>         &lt;Audio /&gt;<br/>      &lt;/Pano&gt;<br/>   )<br/>});</span></pre><p id="e3a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可能注意到了，也可能没有注意到，在我的React 360应用程序的<code class="eh kv kw kx kc b">client.js</code>中，我在渲染了我的应用程序的组件后写了下面一行:</p><p id="add9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kv kw kx kc b">r360.compositor.setBackground(r360.getAssetURL("images/homebase.png"));</code></p><p id="1cbf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这一行代码在应用首次安装时立即设置背景图像，使用React 360的<code class="eh kv kw kx kc b">asset</code>实用程序自动在我的<code class="eh kv kw kx kc b">static_assets</code>文件夹中查找正确的图像。</p><p id="f9e7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这很好，但是我仍然希望根据用户选择的环境来改变图像。幸运的是，我可以通过使用React 360的<code class="eh kv kw kx kc b">Environment</code>模块来处理React事件中的动态图像。下面是一些用法示例:</p><p id="5632" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh kv kw kx kc b">Environment.setBackgroundImage(asset(someImage));</code></p><p id="a9ce" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了将所有这些放在一起，下面是我如何使用Recompose的<code class="eh kv kw kx kc b">withState</code>和<code class="eh kv kw kx kc b">withHandlers</code>函数，根据用户选择的环境动态设置我的背景图像和音频:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="e2bc" class="kg kh hu kc b fv ki kj l kk kl">// providers/withStateAndHandlers.js</span><span id="8f0e" class="kg kh hu kc b fv ld kj l kk kl">import<!-- --> <!-- -->React from "react";<br/>import<!-- --> <!-- -->{ withState, withHandlers, compose } from "recompose";<br/>import<!-- --> <!-- -->{ Environment, asset, NativeModules } from "react-360";<br/>const { AudioModule } = NativeModules;<br/>import<!-- --> <!-- -->{ zens } from "../consts";</span><span id="a318" class="kg kh hu kc b fv ld kj l kk kl">const withStateAndHandlers = compose(<br/>   withState("selectedZen", "zenClicked", 4),<br/>   withHandlers({<br/>      zenClicked: (props) =&gt; (id, evt) =&gt; {<br/>         Environment.setBackgroundImage(asset(zens[id - 1].image));<br/>         if<!-- --> <!-- -->(zens[id - 1].audio !== null<!-- --> <!-- -->&amp;&amp; zens[id - 1].audio !== undefined) {<br/>            AudioModule.playEnvironmental({<br/>               source: asset(zens[id - 1].audio),<br/>               volume: 0.3,<br/>            });<br/>           } else<!-- --> <!-- -->{<br/>               AudioModule.stopEnvironmental();<br/>           }<br/>         props.zenClicked(selectedZen =&gt; id);<br/>      }<br/>   }),<br/>)</span><span id="def9" class="kg kh hu kc b fv ld kj l kk kl">export<!-- --> <!-- -->default<!-- --> <!-- -->withStateAndHandlers;</span></pre><p id="098d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">设计应用程序</strong></p><p id="f5b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">与React VR一样，React 360使用<a class="ae jw" href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" rel="noopener ugc nofollow" target="_blank"> Flexbox </a>来轻松调整应用程序的布局以适应任何显示器，无论是笔记本电脑的网络浏览器还是手机屏幕或VR耳机。然而，对于安装在某个位置的应用程序部分——比如我的例子中的<code class="eh kv kw kx kc b">MeditationApp</code>——React 360从Flexbox布局切换到基于米的三维坐标系统。这就是为什么你会在我的<code class="eh kv kw kx kc b">index.js</code>中看到这段代码:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="dd3c" class="kg kh hu kc b fv ki kj l kk kl">// index.js</span><span id="f3e5" class="kg kh hu kc b fv ld kj l kk kl">// other code goes here<br/>const MeditationApp = withAppContext(() =&gt; (<br/>   &lt;View style={{<br/>      transform: [{ translate: [0, 0, -2] }]<br/>   }}&gt;<br/>      &lt;AppContent /&gt;<br/>   &lt;/View&gt;<br/>));</span><span id="5685" class="kg kh hu kc b fv ld kj l kk kl">// other code goes here</span></pre><p id="f790" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">传入<code class="eh kv kw kx kc b">transform</code>的值依次为<code class="eh kv kw kx kc b">x</code>、<code class="eh kv kw kx kc b">y</code>和<code class="eh kv kw kx kc b">z</code>。<code class="eh kv kw kx kc b">x</code>代表用户右边的对象的方位；<code class="eh kv kw kx kc b">y</code>表示向上或向下的方向，<code class="eh kv kw kx kc b">z</code>表示感知到的与用户的距离。</p><p id="fcc3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的例子中，<code class="eh kv kw kx kc b">View</code>应该在中心，在用户前方2米处。</p><p id="97be" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">变换都是相对于它们的父对象定位的。</p><p id="27a6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">对我有效的实践</strong></p><p id="9a05" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">样式表</strong></p><p id="053d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">来自<code class="eh kv kw kx kc b">react-native</code>的<code class="eh kv kw kx kc b">StyleSheet </code>允许我使用JavaScript来设计我的React组件。请参见下面的我的代码:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="e3b5" class="kg kh hu kc b fv ki kj l kk kl">// scenes/home-environment/components/zen-button/style.js<br/>import<!-- --> <!-- -->{ StyleSheet } from "react-360";</span><span id="aad5" class="kg kh hu kc b fv ld kj l kk kl">export<!-- --> <!-- -->default<!-- --> <!-- -->StyleSheet.create({<br/>   text: {<br/>      backgroundColor: "#29ECCE",<br/>      textAlign: "center",<br/>      color: "white",<br/>      marginTop: 30<br/>   }<br/>})</span></pre><p id="8d2b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这里，我创建并导出了一个<code class="eh kv kw kx kc b">StyleSheet</code>对象，它允许我在组件本身中以简洁的方式引用样式。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="c148" class="kg kh hu kc b fv ki kj l kk kl">// scenes/home-environment/components/zen-button/index.js<br/>import<!-- --> <!-- -->React from "react";<br/>import<!-- --> <!-- -->{ BaseButton } from "../../../../components";<br/>import<!-- --> <!-- -->style from "./style";</span><span id="8130" class="kg kh hu kc b fv ld kj l kk kl">const ZenButton = ({ text, buttonClick, selectedZen }) =&gt; {<br/>   return<!-- --> <!-- -->(<br/>      &lt;BaseButton<br/>         text={text}<br/>         selectedZen={selectedZen}<br/>         buttonClick={buttonClick}<br/>         textStyle={style.text}<br/>      /&gt;<br/>   )<br/>}</span><span id="b842" class="kg kh hu kc b fv ld kj l kk kl">export<!-- --> <!-- -->default<!-- --> <!-- -->ZenButton;</span></pre><p id="e1c0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">状态管理</strong></p><p id="252d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因为，归根结底，这仍然只是React，您可以用与典型React应用程序相同的方式处理状态:<a class="ae jw" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>、<a class="ae jw" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank"> Recompose </a>、<a class="ae jw" href="https://github.com/mobxjs/mobx" rel="noopener ugc nofollow" target="_blank"> Mobx </a>等等。我选择使用重组，因为我喜欢它允许我构建功能组件的方式。如前所述，我在React VR的上下文中写过一些关于重新组合的帖子，你可以在这里找到<a class="ae jw" href="https://lilydbarrett.com/2018/04/23/recompose-with-react-vr/" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到<a class="ae jw" href="https://lilydbarrett.com/2018/05/05/recompose-with-react-vr-pt-2/" rel="noopener ugc nofollow" target="_blank">。将我的应用从React VR移植到React 360时，我不需要对我的状态管理方法做任何改变。</a></p><p id="c0fa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">调试React 360 </strong></p><p id="f2e5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当你打开应用程序时，你会看到React 360把所有的文件打包成一个巨大的blob，这个blob不太容易被破解。好在因为React 360支持<a class="ae jw" href="https://trackjs.com/blog/debugging-with-sourcemaps/" rel="noopener ugc nofollow" target="_blank"> sourcemaps </a>，所以我们还是可以访问原始文件，使用<code class="eh kv kw kx kc b">debugger</code>等。</p></div></div>    
</body>
</html>