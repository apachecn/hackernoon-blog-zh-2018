<html>
<head>
<title>Android Clean Architecture with Kotlin, RxJava and Dagger 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Clean架构，采用Kotlin、RxJava和Dagger 2</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/android-clean-architecture-with-kotlin-rxjava-and-dagger-2-6006be2d0c02?source=collection_archive---------4-----------------------#2018-07-03">https://medium.com/hackernoon/android-clean-architecture-with-kotlin-rxjava-and-dagger-2-6006be2d0c02?source=collection_archive---------4-----------------------#2018-07-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/27ec5eadb6c459caa075ccbd7541ce97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IoDD_9cLFSMSZh2c"/></div></div></figure><p id="ba05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管我们生活在一个敏捷的世界里，有很多时间和精力管理技术可以在你的生活中轻松实现，但是在软件开发中仍然有一些事情可以提高你的生产力和代码的总体质量。</p><p id="9cb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我想描述的是以<a class="ae ka" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净架构</a>方式的应用架构。通过在您的项目中实现Clean，您将拥有用于数据存储、处理和呈现的解耦的、可测试的部分。干净的应用程序非常容易维护，因为可互换的实现，你可以很容易地改变应用程序的每个方面:从UI和简单的数据处理到DB和API框架。</p><p id="0a3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">乍一看，你可能会认为干净的架构是一堆抽象的想法，没有“真正的代码”的力量，但是在这篇文章中，我将尝试向你展示这些如何在Android端实现。</p><p id="afd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们快速介绍一下项目结构:我将使用视图和演示者来显示应用程序的UI部分，并使用Kotlin+RXJava2+Dagger2在network \ db \ cache \等工作中实现干净的架构原则。</p><h1 id="4dd7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">科特林</h1><p id="3594" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Kotlin的特性极大地简化了android开发，不仅允许你使用更小的语言结构，还能在你的应用中保持语义正确的功能。这将让你少考虑实现细节，多考虑整个应用程序的结构。Kotlin的功能部分将减少代码的副作用，使代码更容易测试和理解。看看<a class="ae ka" href="https://blog.uptech.team/how-kotlin-became-our-primary-language-for-android-3af7fd6a994c" rel="noopener ugc nofollow" target="_blank">的文章</a>，它解释了为什么值得使用Kotlin。</p><h1 id="4a7a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">RXJava</h1><p id="497b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">RXJava为处理数据流和线程提供了易于使用的东西。但在我看来，RxJava的主要目的是为应用程序中的数据流提供通用结构。<br/>说真的，如果你还不熟悉RxJava，你应该<a class="ae ka" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank">去看看</a>。</p><h1 id="3bf1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">达格人2</h1><p id="da61" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">【Android和Java的快速依赖注入器。Dagger2是一个很棒的库，它允许你把你需要的所有东西注入到你需要的地方，并处理创建的对象的生命周期。Dagger2用于避免将架构元素相互连接的细节复杂的样板代码。</p><h1 id="b4ef" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">让我们来看看建筑</h1><p id="f6b2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们将遵循这个众所周知的图片上的依赖规则来创建一个具有可互换部件的应用程序。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/03a878433ff3c7c069c79967df071972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*dtL10Oo6gUKZU6GEt85Few.png"/></div></figure><p id="3e20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">仅仅几个原则(<a class="ae ka" href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)" rel="noopener ugc nofollow" target="_blank"> S O L I D </a>)将允许我们分离应用程序的数据获取和处理过程，构建可互换的视图，并保持它们的接口干净简单，同时保持框架和数据层实现的可靠抽象级别。</p><p id="c0f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我之前提到的，应用架构的UI部分将建立在视图和呈现者之上，你可以在这里<a class="ae ka" rel="noopener" href="/@cervonefrancesco/model-view-presenter-android-guidelines-94970b430ddf">和</a><a class="ae ka" href="http://hannesdorfmann.com/mosby/mvp/" rel="noopener ugc nofollow" target="_blank">这里</a>找到很好的指南。<br/>数据获取和处理层将作为用例和存储库呈现。</p><h1 id="50da" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">样品</h1><p id="4ed4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">从现在开始，我们将检查更改用户电子邮件的功能以及在每一层上执行的操作。<br/>如果你不熟悉清洁架构方法，你应该看看费尔南多切哈斯的<a class="ae ka" href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h2 id="ecca" class="lk kc hu bd kd ll lm ln kh lo lp lq kl jn lr ls kp jr lt lu kt jv lv lw kx lx dt translated">数据层</h2><p id="334c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">数据层由存储库接口表示。每个存储库与应用程序的一个单独的、定义良好的方面(用户、消息、事件收件箱等)一起工作</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ly lz l"/></div></figure><blockquote class="ma mb mc"><p id="91b6" class="jc jd le je b jf jg jh ji jj jk jl jm md jo jp jq me js jt ju mf jw jx jy jz hn dt translated">此存储库的主要目的是处理用户工作流:API调用创建\获取\修补用户实体。</p></blockquote><p id="0b3f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">匕首模块代码:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ly lz l"/></div></figure><blockquote class="ma mb mc"><p id="88ff" class="jc jd le je b jf jg jh ji jj jk jl jm md jo jp jq me js jt ju mf jw jx jy jz hn dt translated">请注意，<a class="ae ka" href="http://twitter.com/Provides" rel="noopener ugc nofollow" target="_blank">@的返回值提供的</a>注释函数是一个接口，而不是实现。这种方法将允许我们对实现进行巨大的改变，而不改变“客户端”代码。</p></blockquote><h2 id="f2cc" class="lk kc hu bd kd ll lm ln kh lo lp lq kl jn lr ls kp jr lt lu kt jv lv lw kx lx dt translated">畴层</h2><p id="00a0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">领域层的元素是用例。UseCase的作用是组合数据层元素，执行数据操作的组合。</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ly lz l"/></div></figure><blockquote class="ma mb mc"><p id="48a9" class="jc jd le je b jf jg jh ji jj jk jl jm md jo jp jq me js jt ju mf jw jx jy jz hn dt translated">另一件重要的事情是应用程序的每一层都有不同的实体。当依赖性反转原理以另一种方式工作时，额外的场减少。<br/>每层不同实体的目的是减少内层可能依赖的信息量。例如，在应用程序的域和表示层中，您的实体不需要api版本，您只需要数据层中的这个属性。</p></blockquote><h2 id="6c72" class="lk kc hu bd kd ll lm ln kh lo lp lq kl jn lr ls kp jr lt lu kt jv lv lw kx lx dt translated">表示层</h2><p id="2bc9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">表示层由两个元素组成:一个被动视图和一个具有表示逻辑的表示器。视图是完全被动的，所以当执行任何UI动作时，它只调用presenter函数，Presenter决定在一个或另一个UI事件上必须执行什么动作。</p><p id="39c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="d55d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">演示者:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="580c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">调用堆栈</h1><p id="92ea" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这是一次快速的分层。现在让我们来看一下当用户按下confirm按钮时调用堆栈。</p><p id="77be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，调用视图中的按钮点击监听器。</p><pre class="lg lh li lj fq mg mh mi mj aw mk dt"><span id="eaf8" class="lk kc hu mh b fv ml mm l mn mo"><em class="le">confirmButton</em>.<em class="le">onClick </em><strong class="mh hv">{ <br/>  </strong>presenter.onConfirmButtonClicked()<br/><strong class="mh hv">}</strong></span></pre><p id="edd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后view调用演示者的方法。在presenter中，我们使用<em class="le">validation utils . is valid email(view . getemailinput())</em>验证用户输入，如果输入无效，则显示用户验证错误消息。我们设置observable使用observeOn()操作符在指定的线程上执行它的发射和通知。如果我们不需要在某个线程上执行操作，我们就让用例或知识库来设置observable将要工作的线程。</p><pre class="lg lh li lj fq mg mh mi mj aw mk dt"><span id="6ded" class="lk kc hu mh b fv ml mm l mn mo">changeUserEmailUseCase.changeUserEmail(view.getEmailInput()) .observeOn(AndroidSchedulers.mainThread())</span></pre><p id="df8f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们订阅项目排放，指定“快乐”和“错误”情况。</p><pre class="lg lh li lj fq mg mh mi mj aw mk dt"><span id="b235" class="lk kc hu mh b fv ml mm l mn mo">...</span><span id="4874" class="lk kc hu mh b fv mp mm l mn mo">.subscribe(<br/> { //Email is successfully changed },<br/> { //Error while changing email }<br/>)</span></pre><p id="1211" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用例本身将使用存储库的实现来执行电子邮件更改操作。</p><pre class="lg lh li lj fq mg mh mi mj aw mk dt"><span id="616f" class="lk kc hu mh b fv ml mm l mn mo">appUserRepository.changeUserEmail(email)<br/>    .map { DomainMapper.fromDataUserToDomain(it) }</span></pre><p id="74f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它还通过减少外层依赖性或添加显示内容可能需要的字段，将元素映射到可理解的UI层类型。</p><p id="ec33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">存储库将使用DB、Firebase或API执行电子邮件更改操作，在本地内存中缓存结果，并通过RxJava主题向订户分发新信息。</p><h1 id="5bec" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="361a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">你仍然可以花时间将特性部分从你的代码中分离出来，以在你的项目中创建某种代码可重用性，或者你可以使用这种在Android中组织事物的方式，这允许你为你的客户和顾客创建一个可测试和可维护的解决方案。构建易于更改的应用程序，因为它的各个部分都是基于功能的，有保证的，你不会因为微小的更改而重写一半的应用程序，顺便说一句，这会让你的客户讨厌。</p><h1 id="81c9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">链接</h1><p id="8469" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin语言文档&amp;教程</a><br/>T5】rx Java和<a class="ae ka" href="https://github.com/ReactiveX/RxAndroid" rel="noopener ugc nofollow" target="_blank">rx Android</a><br/><a class="ae ka" href="https://google.github.io/dagger/" rel="noopener ugc nofollow" target="_blank">dagger 2集成示例，教程&amp;文档</a> <br/> <a class="ae ka" href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" rel="noopener ugc nofollow" target="_blank">干净的架构— Android之道</a>作者费尔南多·切哈斯<br/> <a class="ae ka" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">鲍勃大叔的架构</a> <br/> <a class="ae ka" href="https://github.com/uptechteam/CleanArchExample" rel="noopener ugc nofollow" target="_blank"> Git回购一个工作示例</a></p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="5293" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="le">如果您觉得这很有帮助，请点击</em>👏下面这样其他人也可以欣赏。本文原载于 <a class="ae ka" href="http://blog.uptech.team" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> <em class="le"> UPTech团队博客。</em> </strong> </a> <em class="le">关注我们，获取更多关于如何打造优秀产品的文章</em></p></div></div>    
</body>
</html>