<html>
<head>
<title>Build a location feed app for Android with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin为Android构建一个位置反馈应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-location-feed-app-for-android-with-kotlin-742096e8f80e?source=collection_archive---------15-----------------------#2018-07-03">https://medium.com/hackernoon/build-a-location-feed-app-for-android-with-kotlin-742096e8f80e?source=collection_archive---------15-----------------------#2018-07-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="5fa7" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">推手</strong> </a>，我们的每周赞助商，开发通信和协作API，为世界各地的应用提供支持，由易于集成的SDK支持，用于web、移动设备以及最受欢迎的后端堆栈。<a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">入门。</strong> </a></p></blockquote><p id="ff4a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">很多时候，我们喜欢在一个中心位置跟踪和可视化我们的应用程序。饲料是伟大的！在本教程中，我们将构建一个带有活动提要的Android应用程序，允许用户广播他们的位置，并与所有其他连接的用户实时共享。</p><p id="a9ca" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们将构建Android应用程序来监控一个<a class="ae jt" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> REST API的活动。每次点击API的端点时，Pusher会向一个通道发布一个带有一些信息(用户共享的位置)的事件。该事件将在所有连接的Android设备上实时接收。</p><p id="c534" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这是正在运行的应用程序:</p><h1 id="d1a2" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">先决条件</h1><p id="c1df" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">本教程使用了以下技术</p><ul class=""><li id="895a" class="la lb hu ix b iy iz jc jd ju lc jv ld jw le js lf lg lh li dt translated"><a class="ae jt" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank">推杆</a></li><li id="0f1e" class="la lb hu ix b iy lj jc lk ju ll jv lm jw ln js lf lg lh li dt translated"><a class="ae jt" href="https://developer.android.com/studio/index.html" rel="noopener ugc nofollow" target="_blank">安卓工作室</a></li><li id="c2f7" class="la lb hu ix b iy lj jc lk ju ll jv lm jw ln js lf lg lh li dt translated"><a class="ae jt" href="https://nodejs.org/en/download" rel="noopener ugc nofollow" target="_blank">节点</a></li></ul><p id="025e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">要跟进，您需要<a class="ae jt" href="https://pusher.com/signup." rel="noopener ugc nofollow" target="_blank">注册Pusher </a>并访问您的仪表板以创建Pusher项目。您还需要安装Android Studio v3+来构建这个应用程序的客户端部分。要构建我们的服务器端脚本，您需要下载并安装节点，如果您还没有安装的话。</p><h1 id="4995" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">客户端</h1><p id="607c" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">既然你已经解决了这个问题，让我们开始构建我们的Android应用程序。启动Android Studio并创建一个新项目。一定要包括Kotlin支持。输入一个应用程序名称，在我们的例子中是推料器-位置-进料</p><p id="0e57" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">选择应用程序的目标SDK:</p><p id="33e9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">选择基本活动模板:</p><p id="a617" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">当项目构建完成时，打开您的应用程序级<code class="eh lo lp lq lr b">build.gradle</code>文件并更新依赖项，如下所示:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="e568" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，通过点击<strong class="ix hv"> Sync Now </strong>与gradle文件同步项目以安装添加的依赖项。</p><h1 id="c97d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">应用活动</h1><h1 id="e338" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">登录活动</h1><p id="f567" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">默认情况下，创建Android项目也会为您创建一个<code class="eh lo lp lq lr b">MainActivity</code>类和一个关联的<code class="eh lo lp lq lr b">activity_main.xml</code>文件。现在我们需要一个登录活动来收集用户的用户名。所以创建一个新活动，右键点击<strong class="ix hv">main Activity&gt;T30】New&gt;&gt;Activity&gt;&gt;Empty Activity</strong>，然后将其命名为<code class="eh lo lp lq lr b">LoginActivity</code>。一旦这个活动被创建，它将在<code class="eh lo lp lq lr b">res</code>下的<code class="eh lo lp lq lr b">layout</code>文件夹中创建一个默认的布局文件<code class="eh lo lp lq lr b">activity_login.xml</code>。布局将是一个相当简单的，它将有一个文本输入来收集用户的<code class="eh lo lp lq lr b">username</code>和一个按钮来分享他们的位置。下面是<code class="eh lo lp lq lr b">activity_login.xml</code>文件的一个片段:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="f8c8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里我们有一个简单的带有两个视图对象的<code class="eh lo lp lq lr b">LinearLayout</code>，一个用于收集用户的<code class="eh lo lp lq lr b">username</code>的<code class="eh lo lp lq lr b">EditText</code>输入和一个用于将位置发送到服务器的共享按钮。</p><p id="4c5a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">Android的默认风格并不总是吸引人，所以让我们添加一些自定义风格到我们的布局中，只是为了美观。在<code class="eh lo lp lq lr b">res</code>文件夹下，打开<code class="eh lo lp lq lr b">values</code>文件夹，导航到<code class="eh lo lp lq lr b">colors.xml</code>文件，用以下代码更新:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="0af1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">其次，为了实现按钮和输入样式，我们创建了两个<code class="eh lo lp lq lr b">drawable</code>文件。在<code class="eh lo lp lq lr b">res</code>下右键点击<strong class="ix hv">可绘制&gt; &gt;新建&gt; &gt;可绘制资源文件</strong>，将其命名为<code class="eh lo lp lq lr b">input_bg</code>并用以下代码更新:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c3e7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这只是将圆边添加到EditText对象中。对于按钮样式，遵循与上面相同的步骤，创建一个新的可绘制文件，命名为<code class="eh lo lp lq lr b">button</code>并如下设置:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="62cd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最后更新<code class="eh lo lp lq lr b">layout</code>目录下<code class="eh lo lp lq lr b">values</code>文件夹中的<code class="eh lo lp lq lr b">styles.xml</code>文件:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="d1ee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">此时，xml可视化工具中的输出应该如下所示:</p><p id="e015" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来让我们创建一个名为<code class="eh lo lp lq lr b">custom_view.xml</code>的新布局文件。我们将使用该文件在recyclerview对象上呈现用户的每个地图。在<code class="eh lo lp lq lr b">res</code>下的<code class="eh lo lp lq lr b">layout</code>文件夹中，创建新的布局资源文件，设置如下:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="adfd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">好了，我们完成了登录和UI，让我们用它的Java文件来处理逻辑。打开<code class="eh lo lp lq lr b">LoginActivity.kt</code>文件，设置如下:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="ce7a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里我们只是简单地获取我们在布局文件中定义的输入值，并有目的地将其传递给<code class="eh lo lp lq lr b">MainActivity</code>类。一旦用户在<code class="eh lo lp lq lr b">Edittext</code>对象中输入了一个值(用户名),我们就在按钮上设置一个监听器，以便在单击时调用intent动作。只有当输入值不为空时，才会执行此操作。</p><h1 id="580d" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">主要活动</h1><p id="f224" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">接下来，我们定义一个布局，当每个用户共享他们的位置时，我们将呈现他们的地图位置。我们将获得他们的纬度和经度坐标以及他们在<code class="eh lo lp lq lr b">LoginActivity</code>中提供的用户名，并将其发送到我们的服务器，然后服务器会返回一张地图，在地图标记上显示用户名，并在屏幕上显示给所有用户。</p><p id="c943" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在进入MainActivity之前，让我们首先用RecyclerView对象定义一个新的布局文件，以便在用户共享这些位置小部件时保存它们。在<code class="eh lo lp lq lr b">res</code>下，右键点击<strong class="ix hv">布局&gt; &gt;新建&gt; &gt;布局资源文件</strong>，并将其命名为<code class="eh lo lp lq lr b">content_main</code>(如果您在设置项目时选择了基本活动模板，那么默认情况下应该有这个文件)。打开这个文件，并像这样设置它:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="93bc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">正如所看到的，我们只是有一个RecyclerView对象，在其中我们将呈现每个用户的位置，这样他们就可以全部出现在一个列表中。最后，打开<code class="eh lo lp lq lr b">activity_main.xml</code>并更新它:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><h1 id="584c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">应用逻辑</h1><p id="c9d5" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">因为我们在布局文件中使用了RecyclerView，所以我们需要一个适配器类。<code class="eh lo lp lq lr b">RecyclerView</code>使用一个<a class="ae jt" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" rel="noopener ugc nofollow" target="_blank">适配器</a>来管理其数据源的项目，使用一个<a class="ae jt" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html" rel="noopener ugc nofollow" target="_blank">视图保持器</a>来保存表示单个列表项目的视图。在我们创建<code class="eh lo lp lq lr b">Adapter</code>类之前，让我们首先创建一个<code class="eh lo lp lq lr b">Model</code>类，它将在我们的远程数据和适配器之间接口。它将包含我们将数据传递给recyclerview的值。现在右击<strong class="ix hv">main activity&gt;&gt;New&gt;&gt;</strong><strong class="ix hv">kot Lin文件/类</strong>，将其命名为<strong class="ix hv"> Model，<strong class="ix hv">种类</strong>下拉框下的</strong>，选择<strong class="ix hv">类</strong>，设置如下:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="9385" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我们有了这个，让我们创建<code class="eh lo lp lq lr b">Adapter</code>类。右键单击<strong class="ix hv">main activity&gt;&gt;New&gt;&gt;kot Lin文件/类</strong>，将其命名为<code class="eh lo lp lq lr b">Adapter</code>，在<strong class="ix hv">种类</strong>下拉菜单下，再次选择类，并用代码设置:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="7161" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里我们从模型类中定义了一个<code class="eh lo lp lq lr b">arrayList</code>，适配器将使用它来填充<code class="eh lo lp lq lr b">R``ecycler``V``iew</code>。在<code class="eh lo lp lq lr b">onBindViewHolder()</code>方法中，我们将来自服务器的位置(经度和纬度)绑定到我们为其定义的视图容器。我们还将用户的用户名传递给地图标记。</p><p id="c476" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然后在<code class="eh lo lp lq lr b">onCreateViewHolder()</code>方法中，我们为列表中的单个项目定义布局设计。最后，<code class="eh lo lp lq lr b">addItem()</code>方法将我们的模型类的一个新实例添加到<code class="eh lo lp lq lr b">arrayList</code>中，并在每次添加新实例时刷新列表。</p><p id="3883" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，让我们使用我们在开始时安装的改进库来建立到节点服务器的连接。首先，我们创建一个新的Kotlin接口来定义我们将为此项目调用的API端点。右键点击<strong class="ix hv">main activity&gt;&gt;New&gt;&gt;</strong><strong class="ix hv">kot Lin文件/类</strong>，在<strong class="ix hv">种类</strong>下拉菜单下，选择接口名称it <strong class="ix hv"> Service </strong>，设置如下:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="5e7c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们还需要一个类，它将为我们提供进行网络调用的改进实例。它也将是我们定义服务器URL和网络参数的类。所以按照前面的步骤，创建一个名为<code class="eh lo lp lq lr b">Client.kt</code>的类，并像这样设置它:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><blockquote class="ir is it"><p id="8cc1" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">用节点服务器的本地主机地址替换基本URL。我们将</em></p></blockquote><p id="7efa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们在这里使用的<code class="eh lo lp lq lr b">baseUrl</code>指向我们在你的机器上运行的本地节点服务器，如上所示，但是我们将在后面的教程中讨论它。现在让我们回到<code class="eh lo lp lq lr b">MainActivity.kt</code>，初始化必要的对象并用我们上面创建的类更新它。</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="64db" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里我们已经初始化了我们需要的对象，我们的适配器类、Pusher、位置请求和<code class="eh lo lp lq lr b">fusedLocationClient</code>。</p><p id="72b3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在<code class="eh lo lp lq lr b">onCreate()</code>方法中，我们将使用适配器设置我们的RecyclerView。我们还将调用带有浮动动作按钮的<code class="eh lo lp lq lr b">setupPusher()</code>方法和<code class="eh lo lp lq lr b">sendLocation()</code>动作:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><blockquote class="ir is it"><p id="53e9" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">在将这段代码添加到您的</em> <code class="eh lo lp lq lr b"><em class="hu">onCreate()</em></code> <em class="hu">方法中时，注意不要错过花括号</em></p></blockquote><p id="f061" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">所以我们调用了我们还没有定义的方法，这没问题，我们将在后面的教程中定义<code class="eh lo lp lq lr b">setupPusher()</code>方法，但是首先，让我们这次定义并设置<code class="eh lo lp lq lr b">sendLocation()</code>方法，在<code class="eh lo lp lq lr b">onCreate()</code>之外:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="e07d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">通过我们之前初始化的<code class="eh lo lp lq lr b">fusedLocationClient</code>对象，我们获得了用户的位置。如果我们成功地获得了位置，我们将把经度和纬度以及用户的<code class="eh lo lp lq lr b">username</code>传递给我们的<code class="eh lo lp lq lr b">body</code>对象。然后，我们使用它来构建HTTP请求，并将<code class="eh lo lp lq lr b">jsonObjects</code>作为请求参数。</p><p id="3fa1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们也在<code class="eh lo lp lq lr b">onCreate()</code>方法中调用了<code class="eh lo lp lq lr b">checkLocationPermission()</code>方法，但是我们还没有定义它。现在让我们创建这个方法，并像这样设置它:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="31c4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">当然，我们不能在没有得到用户许可的情况下就获取他们的位置，所以下面是我们如何设置请求访问他们位置许可的方法。就在<code class="eh lo lp lq lr b">sendLocation()</code>方法之后，添加:x</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="28cc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在让我们定义我们之前在<code class="eh lo lp lq lr b">onCreate()</code>方法中调用的<code class="eh lo lp lq lr b">setUpPusher()</code>方法:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="9ea8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里，我们简单地将Pusher配置传递给Pusher对象，并订阅<code class="eh lo lp lq lr b">feed</code>通道来监听<code class="eh lo lp lq lr b">location</code>事件。然后，我们将从服务器返回的数据放入我们定义的变量中，并将它们传递给我们的模型类来更新适配器。</p><p id="6df3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，我们在应用程序中分别实现<code class="eh lo lp lq lr b">onStart()</code>和<code class="eh lo lp lq lr b">onStop()</code>方法来连接和断开推动器:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="7f5e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最后，在客户端，我们创建一个Kotlin数据类，它将定义我们将从服务器请求的有效负载。按照前面的步骤，创建一个名为<strong class="ix hv"> RequestPayload </strong>的类，并像这样设置它:</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="lx ly l"/></div></figure><h1 id="fb05" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">服务器端</h1><h1 id="0a72" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置推动器</h1><p id="4cc1" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">现在我们已经有了所有的客户端功能，让我们继续构建我们的服务器。但是首先，如果你还没有，现在是时候在这里创建一个免费账户了。首次登录时，系统会要求您输入一些配置选项:</p><p id="64af" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">输入名字，选择<em class="iw"> Android </em>作为你的前端<a class="ae jt" href="https://hackernoon.com/tagged/tech" rel="noopener ugc nofollow" target="_blank"> tech </a>，选择<em class="iw"> Node.js </em>作为你的后端tech。这将为您提供一些示例代码，帮助您了解项目api密钥:</p><p id="cf17" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然后转到<strong class="ix hv"> App Keys </strong>选项卡，复制您的app_id、密钥和秘密凭证，我们稍后会用到它们。</p><h1 id="de9e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置节点服务器</h1><p id="60d7" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">为此，我们将使用节点。因此，通过在命令提示符下运行以下命令，检查您的机器上是否安装了<code class="eh lo lp lq lr b">node</code>和<code class="eh lo lp lq lr b">npm</code>:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="9deb" class="md jy hu lr b fv me mf l mg mh">node --version<br/>//should display version numbers<br/>    <br/>npm --version<br/>//should display version numbers</span></pre><p id="5c73" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果不是这样，<a class="ae jt" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">下载并安装节点</a>。</p><p id="9461" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来让我们开始构建我们的服务器端脚本。仍然在命令提示符下，运行:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="73a3" class="md jy hu lr b fv me mf l mg mh">mkdir pusherLocationFeeds<br/>//this creates a project directory to host your project files<br/>    <br/>cd pusherLocationFeeds<br/>// this navigates into the just created directory<br/>    <br/>npm init -y<br/>//this creates a default package.json file to host our project dependencies</span></pre><p id="e26e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">让我们安装这个项目需要的节点模块。基本上我们需要Express、Pusher和body-parser。在项目目录中，运行:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="4ea7" class="md jy hu lr b fv me mf l mg mh">install express, body-parser, pusher</span></pre><p id="a640" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">您总是可以通过打开“package.json”文件来验证这些安装，此时依赖块应该如下所示:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="12de" class="md jy hu lr b fv me mf l mg mh">"dependencies": {<br/>        "body-parser": "^1.18.2",<br/>        "express": "^4.16.3",<br/>        "pusher": "^1.5.1"<br/>      }</span></pre><p id="a9b0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来在项目目录中创建一个server.js文件。首先，我们需要安装的节点模块:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="04c0" class="md jy hu lr b fv me mf l mg mh">var express = require("express")<br/>var pusher = require("pusher")<br/>var bodyParser = require("body-parser")</span></pre><p id="25f5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，我们配置Express:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="1d4c" class="md jy hu lr b fv me mf l mg mh">var app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: false }));</span></pre><p id="5404" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在让我们通过传递配置对象来创建Pusher对象，该配置对象带有在<a class="ae jt" href="https://dashboard.pusher.com/" rel="noopener ugc nofollow" target="_blank"> Pusher仪表板</a>中创建的应用程序的id、密钥和密码:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="d67b" class="md jy hu lr b fv me mf l mg mh">var pusher = new Pusher({    <br/>        appId: "pusher_app_id",<br/>        key: "pusher_app_key",<br/>        secret: "pusher_app_secret",<br/>        cluster: "pusher_app_cluster"<br/>      });</span></pre><p id="04f4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如前所述，我们将使用Pusher发布应用程序中发生的事件。这些事件有一个<strong class="ix hv"> eventChannel </strong>，允许它们与一个特定的主题相关联，一个<strong class="ix hv"> eventName </strong>，用于标识事件的类型，还有一个<strong class="ix hv"> payload </strong>，您可以将任何附加信息附加到这个payload上并发送回客户端。</p><p id="ff2d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在我们的例子中，当API的端点被调用时，我们将发布一个事件到推送通道(“feed”)。然后将信息作为附件发送，这样我们就可以在客户端的活动提要中显示它。</p><p id="4156" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">下面是我们如何定义API的REST端点:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="777f" class="md jy hu lr b fv me mf l mg mh">app.post('/location', (req, res,next)=&gt;{<br/>        <br/>        var longitude = req.body.longitude;<br/>        var latitude = req.body.latitude;<br/>        var username = req.body.username;<br/>      ...</span></pre><p id="489f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在这里，当我们接收请求参数时，我们将从请求中提取发送者的经度、纬度和用户名，并像这样作为响应发送回客户端:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="a1c1" class="md jy hu lr b fv me mf l mg mh">...  <br/>        pusher.trigger('feed', 'location', {longitude, latitude,username});<br/>        res.json({success: 200});<br/>      });</span></pre><p id="4aea" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，当用户键入用户名并点击“共享位置”按钮时，服务器会返回如下数据:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="f56e" class="md jy hu lr b fv me mf l mg mh">{<br/>      "longitude" : "longitude_value"<br/>      "latitude" : "latitude_value"<br/>      "username" : "username_value"<br/> }</span></pre><p id="16e6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">从这里，我们使用<strong class="ix hv">适配器</strong>将它传递到<strong class="ix hv">取景框</strong>并在屏幕上显示出来。完成后，您的server.js文件应该如下所示:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="dd6c" class="md jy hu lr b fv me mf l mg mh">var pusher = require("pusher")<br/>    var express = require("express")<br/>    var Pusher = require("pusher")<br/>    var bodyParser = require("body-parser")<br/>    var pusher = new Pusher({<br/>        appId: "app_id",<br/>        key: "app_key",<br/>        secret: "app_secrete",<br/>        cluster: "app_cluster"<br/>      });<br/>    var app = express();<br/>    app.use(bodyParser.json());<br/>    app.use(bodyParser.urlencoded({ extended: false }));<br/>    <br/>    app.post('/location', (req, res,next)=&gt;{<br/>        <br/>        var longitude = req.body.longitude;<br/>        var latitude = req.body.latitude;<br/>        var username = req.body.username;<br/>      <br/>        pusher.trigger('feed', 'location', {longitude, latitude,username});<br/>        res.json({success: 200});<br/>    });<br/>    app.listen(4040, function () {<br/>        console.log('Listening on 4040')<br/>      })</span></pre><p id="4f6d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在导航到终端，cd进入<code class="eh lo lp lq lr b">server.js</code>文件。然后使用以下命令运行服务器:</p><pre class="ls lt lu lv fq lz lr ma mb aw mc dt"><span id="e226" class="md jy hu lr b fv me mf l mg mh">node server.js</span></pre><h1 id="f801" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">运行应用程序</h1><p id="f9f5" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">一旦服务器启动，继续运行Android应用程序。若要运行该应用程序，请保持您的系统连接到互联网。回到Android Studio，单击菜单栏上的绿色play图标运行应用程序，或者从菜单中选择<strong class="ix hv">运行</strong>，并从下拉菜单中单击<strong class="ix hv">运行“应用程序”</strong>。此操作将启动您的设备模式，让您看到所有连接的设备和模拟器。如果您使用的是物理设备，只需从显示的可用设备列表中选择您的设备，然后点击<strong class="ix hv">确定</strong>。</p><p id="bf1b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果您在模拟器上运行，请从设备列表中选择您的首选模拟器(如果您有一个设置),或者按照以下说明设置新的模拟器:</p><p id="4f47" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在设备模式上，选择<strong class="ix hv">创建新的虚拟设备。</strong>这将启动一个硬件选择模式，您可以选择任何设备，例如Nexus 5，然后单击<strong class="ix hv">下一步。</strong>这将启动另一个模式，您可以在其中选择想要在设备上运行的API级别。您可以选择任何可用的选项，或者坚持使用默认选项，选择API level 25。再次点击<strong class="ix hv">下一步</strong>给你的仿真器一个自定义名称，然后点击<strong class="ix hv">完成</strong>完成设置。现在，当您再次运行该应用程序时，您将看到您的仿真器列在可用设备模式中。在系统仍连接到互联网的情况下，选择您的首选设备并单击<strong class="ix hv">确定</strong>运行。</p><h1 id="feb8" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="a70d" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">希望这篇教程以一种简单的方式向你展示了如何用Pusher为Android应用程序构建一个活动提要。随着你继续构建，也许你会发现实时更新是非常重要的。当你这样做时，Pusher拥有你需要的一切。项目可在Github上获得，服务器端代码也可在gist上获得。</p></div><div class="ab cl mi mj hc mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hn ho hp hq hr"><p id="a463" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><em class="iw">原载于</em> <a class="ae jt" href="https://pusher.com/tutorials/location-feed-android-kotlin" rel="noopener ugc nofollow" target="_blank"> <em class="iw">推手的博客</em> </a> <em class="iw">。</em></p><blockquote class="ir is it"><p id="ee96" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">我们的每周赞助商<a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv"> Pusher </strong> </a>开发通信和协作API，为世界各地的应用提供支持，并由易于集成的web、移动和最受欢迎的后端堆栈SDK提供支持。<a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">入门。</strong> </a></p></blockquote><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="mp ly l"/></div></figure></div></div>    
</body>
</html>