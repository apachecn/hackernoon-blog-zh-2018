<html>
<head>
<title>Build a chat app in the terminal using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python在终端中构建一个聊天应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-chat-app-in-the-terminal-using-python-9f306e57db8f?source=collection_archive---------16-----------------------#2018-07-03">https://medium.com/hackernoon/build-a-chat-app-in-the-terminal-using-python-9f306e57db8f?source=collection_archive---------16-----------------------#2018-07-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="0e93" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">推手</strong> </a>，我们的每周赞助商，开发通信和协作API，为世界各地的应用提供支持，由易于集成的SDK支持，用于web、移动设备以及最受欢迎的后端堆栈。<a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">入门。</strong> </a></p></blockquote><p id="5927" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">实时聊天实际上是提供从发送者到接收者的文本消息的实时或现场传输的任何在线通信。本教程将向您展示如何使用<a class="ae jt" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>和Pusher通道构建一个<a class="ae jt" href="https://hackernoon.com/tagged/realtime" rel="noopener ugc nofollow" target="_blank">实时</a>终端聊天。</p><p id="694f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">使用终端聊天是轻量级的，因为不需要打开浏览器，加载JS库或任何前端代码。此外，它允许我们快速测试我们的想法，而不用担心用户界面会是什么样子。</p><blockquote class="ir is it"><p id="6603" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">本教程中的Python指的是Python 3.x </em></p></blockquote><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff jx"><img src="../Images/c7eae75216cb9a60525ab70a757f20be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*nX0_idjq0t0CiRs7Vfe-Rg.gif"/></div></figure><h1 id="d869" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">先决条件</h1><p id="cce5" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">阅读本教程需要对Python有一个基本的了解。您还需要在您的机器上安装和配置Python 3和pip。</p><h1 id="01b4" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">在Pusher上设置一个应用程序</h1><p id="e979" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated"><a class="ae jt" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank"> Pusher </a>是一种托管服务，可以非常容易地将实时数据和功能添加到web和移动应用程序中。</p><p id="7c47" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">Pusher充当服务器和客户端之间的实时层。Pusher保持与客户端的持久连接——如果可能的话，通过Web-socket连接，并退回到基于HTTP的连接——这样，一旦您的服务器有了新数据，它们就可以通过Pusher将数据推送到客户端。</p><p id="5185" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果你还没有，去Pusher创建一个免费账户。我们将在仪表板上注册一个新的应用程序。唯一必须的选项是应用程序名称和集群。一个集群代表Pusher服务器的物理位置，它将处理您的应用程序的请求。此外，从应用程序密钥部分复制出你的应用程序ID、密钥和密码，因为我们稍后会用到它们。</p><h1 id="f262" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">创建我们的应用程序</h1><h1 id="ffc3" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">初始步骤</h1><p id="337b" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">首先，我们需要安装一个名为<code class="eh li lj lk ll b">virtualenv</code>的包。Virtualenv帮助管理Python中的环境。这样我们就不会因为项目间的安装操作而导致库冲突。要安装Virtualenv，我们运行:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="539a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">对于Windows用户，以管理员身份打开Powershell，并运行:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="ebde" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">安装完成后，我们可以通过运行以下命令进行验证:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="5751" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，让我们用Virtualenv创建一个新环境:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="483f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">环境创建完成后，我们进入创建的新目录，并激活环境:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="1328" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">对于Windows用户，您可以通过运行以下命令来激活:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="127f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们需要安装库，我们将在这个项目中使用。要安装它们，请运行:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="f04e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们安装的这些包是什么？他们做什么？我会解释的。</p><ul class=""><li id="f942" class="lo lp hu ix b iy iz jc jd ju lq jv lr jw ls js lt lu lv lw dt translated"><code class="eh li lj lk ll b">termcolor</code>:终端输出的ANSII颜色格式。这个包将格式化输出到终端的颜色。请注意，这些颜色不会显示在Powershell或Windows命令提示符中。</li><li id="3b41" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">pusher</code>:官方Python库，用于与Pusher HTTP API交互。</li><li id="3169" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">pysher</code>:用于处理pusher WebSockets的Python模块。这将使用Pusher处理事件订阅</li><li id="eaf5" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">python-dotenv</code> : Python模块，从<code class="eh li lj lk ll b">.env</code>文件中读取键、值对，并将它们添加到环境变量中。</li></ul><h1 id="b3c3" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">创建入口点</h1><p id="829b" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">让我们创建一个新的<code class="eh li lj lk ll b">.env</code>文件，它将保存我们的环境变量，这些变量将用于连接到Pusher。创建一个名为<code class="eh li lj lk ll b">.env</code>的新文件，并分别添加您的pusher应用id、密钥、机密和集群:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="11f1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，创建一个名为<code class="eh li lj lk ll b">terminalChat.py</code>的文件并添加:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="6d72" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">上面的代码是怎么回事？</p><p id="22e3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们导入了colored模块，它将为我们的控制台输出提供颜色，还导入了<code class="eh li lj lk ll b">load_env</code>模块，以便从我们的<code class="eh li lj lk ll b">.env</code>文件中加载环境变量。然后我们调用了<code class="eh li lj lk ll b">load_env</code>函数。</p><p id="cc18" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然后定义了<code class="eh li lj lk ll b">terminalChat</code>类，具有一些属性:</p><ul class=""><li id="519a" class="lo lp hu ix b iy iz jc jd ju lq jv lr jw ls js lt lu lv lw dt translated"><code class="eh li lj lk ll b">pusher</code>:一旦Pusher服务器实例可用，该属性将保存它。</li><li id="d5a1" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">channel</code>:该属性将保存订阅的通道的Pusher实例。</li><li id="acc6" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">chatroom</code>:该属性将保存用户想要聊天的频道名称。</li><li id="8703" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">clientPusher</code>:一旦Pusher客户端实例可用，该属性将保存它。</li><li id="5661" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">user</code>:该属性将保存当前登录用户的详细信息。</li><li id="3851" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated"><code class="eh li lj lk ll b">users</code>:这个属性保存了可以登录的用户的静态列表，以他们的值作为密码。在现实世界的应用程序中，这通常是从一些数据库中获得的</li><li id="f125" class="lo lp hu ix b iy lx jc ly ju lz jv ma jw mb js lt lu lv lw dt translated">这个属性保存了一个人可以加入的所有可用聊天室的列表。</li></ul><h1 id="341f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">理解定义的函数</h1><p id="4a1a" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">我们定义了四个函数，我将分别解释它们是如何工作的:</p><p id="1d58" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这是我们应用程序的入口点。这里，我们调用函数来登录，调用函数来选择一个聊天室。在这之后，我们有一个while循环来调用<code class="eh li lj lk ll b">getInput</code>函数。这个while循环意味着<code class="eh li lj lk ll b">getInput</code>函数将一直运行。这是为了使我们总是有一个输入，以键入新的消息到终端。</p><p id="4899" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><code class="eh li lj lk ll b">login</code>:登录功能顾名思义简单。它用于管理应用程序的登录。在函数中，我们要求输入用户的用户名和密码。接下来，我们检查用户名是否存在于我们用户的字典中。此外，我们检查密码是否与用户的密码相关。如果一切正常，我们将用户变量赋给用户输入的值。</p><blockquote class="ir is it"><p id="8331" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">注意:为了这个教程，我们有一个预定义的用户字典。在您的应用程序中，您可能需要验证数据库中是否存在该用户。</em></p></blockquote><p id="ce3f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><code class="eh li lj lk ll b">selectChatroom</code>:顾名思义，这个功能可以让用户选择一个聊天室。首先，它通知用户可用的聊天室，然后让我们选择一个聊天室。一旦选择了一个有效的聊天室，我们就将聊天室变量分配给所选的聊天室，并调用一个名为<code class="eh li lj lk ll b">initPusher</code>的方法(我们将很快创建它)，该方法初始化并设置Pusher来发送和接收消息。</p><p id="5d75" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><code class="eh li lj lk ll b">getInput</code>:这个功能很简单。它显示一个输入，前面是登录的用户名，等待用户输入消息并发送。目前，它对消息没有任何作用，一旦Pusher设置正确，我们将重新访问该功能。</p><h1 id="5c90" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">将推送服务器和客户端连接到我们的应用程序</h1><p id="f9de" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">如果我们还记得，在前面的部分中，我们讨论了初始化和设置Pusher来发送和接收消息的<code class="eh li lj lk ll b">initPusher</code>方法。这里是我们实现该功能的地方。首先，我们需要将以下导入添加到文件的顶部:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="f584" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，让我们继续在terminalChat类中定义<code class="eh li lj lk ll b">initPusher</code>和其他一些函数:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="de60" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在init函数中，我们将新的Pusher实例初始化为变量<code class="eh li lj lk ll b">pusher</code>，分别传入我们的<code class="eh li lj lk ll b">APP_ID</code>、<code class="eh li lj lk ll b">APP_KEY</code>、<code class="eh li lj lk ll b">APP_SECRET</code>和<code class="eh li lj lk ll b">APP_CLUSTER</code>。接下来，我们为Pusher初始化一个新的<code class="eh li lj lk ll b">Pysher</code>客户端，传入我们的<code class="eh li lj lk ll b">APP_KEY</code>。然后我们绑定到连接，即<code class="eh li lj lk ll b">pusher:connection_established</code>事件，并在回调时传递<code class="eh li lj lk ll b">connectHandler</code>函数。我们这样做的原因是为了确保在我们尝试订阅频道之前客户端已经连接。这样做之后，我们在<code class="eh li lj lk ll b">clientPusher</code>上调用<code class="eh li lj lk ll b">connect</code>。</p><blockquote class="ir is it"><p id="73d5" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">你可能想知道为什么我们在这里使用</em><a class="ae jt" href="https://github.com/nlsdfnbch/Pysher" rel="noopener ugc nofollow" target="_blank"><em class="hu">py sher</em></a><em class="hu">作为Pusher的客户端库。这是因为默认的Pusher库只允许触发事件，而不允许订阅事件。Pysher </em>  <em class="hu">是一个社区库，允许我们在服务器上使用Python订阅事件。</em></p></blockquote><p id="3139" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在<code class="eh li lj lk ll b">connectHandler</code>函数中，我们收到一个名为<code class="eh li lj lk ll b">data</code>的参数。这包括来自推动器网络插座之间建立的连接的连接数据。我们订阅用Pusher选择的通道，然后绑定到一个名为<code class="eh li lj lk ll b">newmessage</code>的事件，在回调时传入<code class="eh li lj lk ll b">pusherCallback</code>函数。</p><p id="bf7c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在<code class="eh li lj lk ll b">pusherCallback</code>方法中，我们接收一个名为<code class="eh li lj lk ll b">message</code>的参数，它返回从Pusher接收的新消息的对象。在这里，我们将消息转换成Python可读的JSON格式，然后在将消息打印到屏幕上发送者姓名旁边之前，检查消息是否不是给当前登录用户的。我们还将登录用户的名字打印到屏幕上，前面有一个冒号，这样用户就知道他仍然可以输入。</p><h1 id="b72d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">更新getInput函数</h1><p id="df97" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">让我们更新我们的<code class="eh li lj lk ll b">getInput</code>函数，这样一旦收到消息，我们就可以触发消息给Pusher:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="6da2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里，收到消息后，我们触发一个<code class="eh li lj lk ll b">newmesage</code>事件到当前聊天室，传递当前用户和发送的消息。</p><h1 id="ed72" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">将所有这些整合为一个整体</h1><p id="f2a3" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">这是我们的<code class="eh li lj lk ll b">terminalChat.py</code>的样子:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="6dc3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">以下是我们运行<code class="eh li lj lk ll b">python terminalChat.py</code>后的聊天内容:</p><h1 id="1743" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="bca5" class="pw-post-body-paragraph iu iv hu ix b iy ld ja jb jc le je jf ju lf ji jj jv lg jm jn jw lh jq jr js hn dt translated">我们已经看到，由于推送通道，在我们的终端上添加实时聊天是多么简单。我们的演示应用程序是一个简单的例子。相同的功能可以用在许多真实的场景中。您可以在<a class="ae jt" href="https://github.com/samuelayo/terminal-chat" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看完整应用程序的源代码，并在这里深入了解Pusher服务<a class="ae jt" href="https://pusher.com/docs" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="ir is it"><p id="5249" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">我们的每周赞助商<a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv"> Pusher </strong> </a>开发通信和协作API，为世界各地的应用提供支持，并由易于集成的SDK提供支持，用于web、移动设备以及最受欢迎的后端堆栈。<a class="ae jt" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">入门。</strong>T13】</a></p></blockquote><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="mc ln l"/></div></figure></div></div>    
</body>
</html>