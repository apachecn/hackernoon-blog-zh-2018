<html>
<head>
<title>Winds 2.1: Building Touch Bar Support for macOS in Electron with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Winds 2.1:用React为macOS构建Touch Bar支持</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/winds-2-1-building-touch-bar-support-for-macos-in-electron-with-react-e10adb811c91?source=collection_archive---------23-----------------------#2018-07-03">https://medium.com/hackernoon/winds-2-1-building-touch-bar-support-for-macos-in-electron-with-react-e10adb811c91?source=collection_archive---------23-----------------------#2018-07-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a77d064930e3c5370b060e2ab34c3fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7V44m6yHVr5We1O0RYZVg.png"/></div></div></figure><p id="bc3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近，科技/硬件领域最新、最酷的创新之一是苹果去年在MacBook Pro上发布的touch bar。随着这些机器变得越来越受欢迎，越来越多的应用程序正在利用touch bar以一种新的方式与用户进行交互。随着我们观察这一趋势的发展，我们认为这似乎是一个有趣的挑战，因为我们过去几个月的宠物项目<a class="ae ka" href="https://getstream.io/winds" rel="noopener ugc nofollow" target="_blank"> Winds 2.0 </a>在本月早些时候首次亮相。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/905514d25b1208a0bb7adf07ecdaa960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NiweWKwbBW42qVO6g7e5Qw.gif"/></div></div></figure><p id="6feb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着我们继续根据社区反馈对Winds进行迭代，现在似乎是在<a class="ae ka" href="https://codeburst.io/announcing-winds-2-1-more-features-stability-and-pure-awesomeness-c109484fa1bf?source=user_profile---------2-------------------" rel="noopener" target="_blank"> Winds 2.1 </a>中推出对macOS上触摸条控制支持的最佳时机。走进去，似乎是小菜一碟。然而，我们大错特错了。macOS和<a class="ae ka" href="https://electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>之间的API通信远未完成。希望在不久的将来，我们能看到macOS和electronic之间更好的支持。</p><p id="79c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前，我们已经想出了一个不错的解决方案，允许我们在Electron和macOS touch bar之间进行双向通信。为此，我们非常依赖三个主要的电子元件:</p><ol class=""><li id="7539" class="kg kh hu je b jf jg jj jk jn ki jr kj jv kk jz kl km kn ko dt translated">电子提供的【有限】<a class="ae ka" href="https://github.com/electron/electron/blob/master/docs/api/touch-bar.md" rel="noopener ugc nofollow" target="_blank">触摸条</a> <strong class="je hv"> </strong> API <strong class="je hv"> </strong></li><li id="d73b" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><a class="ae ka" href="https://electronjs.org/docs/api/ipc-main" rel="noopener ugc nofollow" target="_blank"> ipcMain </a>模块，处理从渲染器进程(网页)发送的异步和同步消息</li><li id="5d37" class="kg kh hu je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko dt translated"><a class="ae ka" href="https://electronjs.org/docs/api/ipc-renderer" rel="noopener ugc nofollow" target="_blank"> ipcRenderer </a>模块，它提供了一些方法，允许您从呈现器进程(网页)向主进程(ipcMain)发送同步和异步消息。</li></ol><p id="6243" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本帖中，我们将深入探究我们是如何完成这项任务的。让我们开始吧。</p><h1 id="54cc" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">ipcMain模块</h1><p id="bcb0" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">ipcMain模块是<a class="ae ka" href="https://nodejs.org/api/events.html#events_class_eventemitter" rel="noopener ugc nofollow" target="_blank"> EventEmitter </a>类的一个实例。当在主进程中使用时，它处理从呈现器进程(网页)发送的异步和同步消息。从渲染器发送的消息被发送到该模块，由事件处理程序拾取，然后传递给函数进行进一步处理。</p><h2 id="664a" class="lx kv hu bd kw ly lz ma la mb mc md le jn me mf li jr mg mh lm jv mi mj lq mk dt translated">从电子设备发送和接收</h2><p id="edf2" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在<a class="ae ka" href="https://github.com/GetStream/Winds/blob/master/app/public/electron.js" rel="noopener ugc nofollow" target="_blank"> /app/public/electron.js </a>中，一旦窗口准备好显示，我们就初始化以下代码:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="ce04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事件属性指定发生了什么，而参数可以是单个值或键值对的对象。对于Winds，我们选择使用一个对象，这样我们就可以传递额外的元数据(来自前端)，比如当前的剧集标题和播客名称。</p><h1 id="f42f" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">ipcRenderer模块</h1><p id="881f" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">ipcRenderer模块是EventEmitter类的一个实例。它提供了一些方法，允许您从呈现器进程(web页面)向主进程(electronic)发送同步和异步消息。</p><p id="b13c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理解通信如何工作是我们获得媒体控制支持的第一步。为了更好地理解它的工作原理，我们来看几个简短的代码示例:</p><h2 id="e3a1" class="lx kv hu bd kw ly lz ma la mb mc md le jn me mf li jr mg mh lm jv mi mj lq mk dt translated">从React发送和接收</h2><p id="e083" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">在<a class="ae ka" href="https://github.com/GetStream/Winds/blob/master/app/src/components/Player.js" rel="noopener ugc nofollow" target="_blank">/app/src/components/player . js</a>中，我们使用了<strong class="je hv"><em class="mn">window . ipcRenderer</em></strong>，由于IPC renderer不是直接可用的，因此需要我们将其从窗口对象中拖出:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="8e0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">和</strong></p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="280e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，说了这么多，做了这么多，我们可以使用播放器上下文来区分正在播放的剧集和暂停的剧集。它看起来像这样:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="e315" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">对生命周期事件做出反应</strong></p><p id="56f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je hv"><em class="mn">componentidmount()</em></strong>上，我们使用以下处理程序来确保我们的传入事件被拾取。</p><p id="0c98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="mn">注意</em> </strong> <em class="mn">:我们通过</em><a class="ae ka" href="https://www.npmjs.com/package/is-electron" rel="noopener ugc nofollow" target="_blank"><em class="mn">is-electronic</em></a><em class="mn">节点模块将我们的代码包装在一个电子检查中，以确保我们只在电子环境中执行它——这很重要，因为我们有</em><a class="ae ka" href="https://winds.getstream.io" rel="noopener ugc nofollow" target="_blank"><em class="mn">web</em></a><em class="mn">和</em> <a class="ae ka" href="https://getstream.io/winds" rel="noopener ugc nofollow" target="_blank"> <em class="mn">本地版本</em> </a> <em class="mn">。</em></p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="9214" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je hv"><em class="mn">componentWillUnmount()</em></strong>上，我们使用下面的处理程序来确保<em class="mn">的所有</em>监听器都被销毁:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="d9e8" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">电子触摸条API</h1><p id="5927" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">正如本文前面部分所指出的，我们在我们的electron.js文件中初始化ipcMain。但是等等，还有更多…我们<em class="mn">还有</em>有一部分代码专门用于处理传入(和传出)消息，除了切换触摸栏图像，以及处理触摸栏事件:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="fa32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个函数应该放在main.js文件中，或者在我们的例子中，放在<a class="ae ka" href="https://github.com/GetStream/Winds/blob/master/app/public/electron.js" rel="noopener ugc nofollow" target="_blank"> electron.js </a>文件中。</p><h1 id="9f78" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">最终产品</h1><p id="34af" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">所有这些都为Winds 2.1提供了一个非常棒的触摸栏功能，允许我们的用户在Winds中暂停和播放播客剧集，查看当前正在播放的播客，并向前和向后搜索。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/966d8247bdb654738a2ecf20dfe9dac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neL9wnOmGCC85kJfIDUijQ.jpeg"/></div></div></figure><p id="2876" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着我们继续开发这款应用程序，并且<a class="ae ka" href="https://github.com/GetStream/Winds/issues" rel="noopener ugc nofollow" target="_blank">收到来自我们令人敬畏的社区的反馈</a>，我们希望继续增加用户与touch bar互动的新方式，让人们对他们与Winds的每一次互动都感到惊喜。</p><h1 id="2eed" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">结束语</h1><p id="978e" class="pw-post-body-paragraph jc jd hu je b jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz hn dt translated">我希望这篇小教程能帮助我们理解主进程(电子)和渲染器(反应)之间的通信。如前所述，API还没有完全实现，所以在这个过程中你可能会遇到一些小问题——欢迎在评论中发表；我很乐意帮忙！</p><p id="1312" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你认为我错过了什么，请在下面的评论中留言或者在Twitter上找到我— <a class="ae ka" href="https://twitter.com/@nickparsons" rel="noopener ugc nofollow" target="_blank"> @NickParsons </a>。</p></div></div>    
</body>
</html>