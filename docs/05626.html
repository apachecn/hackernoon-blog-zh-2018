<html>
<head>
<title>Building API with Express.js and Hadron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express.js和Hadron构建API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-api-with-express-js-and-hadron-be7f6dfc792a?source=collection_archive---------14-----------------------#2018-07-04">https://medium.com/hackernoon/building-api-with-express-js-and-hadron-be7f6dfc792a?source=collection_archive---------14-----------------------#2018-07-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/5e1a0cfc8192fa610479c592eb2a87e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ee6J2APyYn9Uh2UTPjj3jA.png"/></div></figure><div class=""/><h1 id="c507" class="iy iz ib bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">背景</h1><p id="43b1" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">与Brainhub的人们一起，我们开发了一个工具，利用依赖注入提供的一些魔力，使CRUD API的实现变得更加愉快和容易。</p><p id="814c" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated"><a class="ae ku" href="https://hadron.pro/" rel="noopener ugc nofollow" target="_blank"> Hadron </a>是一个轻量级的开源框架，可以与Express.js(目前，Express是唯一支持的web框架)和TypeORM等数据库管理工具一起使用。强子甚至由类似<code class="eh la lb lc ld b">hadron-serialization</code>的包组成，这使得简单地构造API输出的数据成为可能，即使选择的字段仅对一些“组”可见。</p><p id="b5e9" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">强子不会以任何负面方式影响后端性能，它的目标是在构建和维护API并提供高效率的同时改善体验。</p><h1 id="f59c" class="iy iz ib bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">强子+用例概述</h1><p id="2432" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">用Hadron设置后端只需要几行代码。首先，我将向你展示如何使用<em class="le">强子</em>和<em class="le"> Express.js </em>建立一个基本的hello world路线。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">A hello-world example built with <strong class="ak">Hadron</strong></figcaption></figure><p id="c843" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">这里最重要的是<strong class="jy ic">配置</strong>对象。我们在那里指定了Hadron包的配置(<em class="le">路由<code class="eh la lb lc ld b">hadron-express</code>的</em>)。构造函数方法返回一个带有<strong class="jy ic">容器</strong>对象的承诺，用于依赖注入。我们将在本文的后面对此进行更深入的探讨。</p><p id="e7a0" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">正如你可能已经注意到的，当使用更多的强子包时，开发一个更大的应用程序可能是一场噩梦。config对象将是巨大的——想象一下那里的所有路由。当然，我们可以简单地将路径划分到多个文件并导入它们。</p><p id="8479" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">这就是<code class="eh la lb lc ld b"><a class="ae ku" href="https://github.com/brainhubeu/hadron/tree/master/packages/hadron-json-provider" rel="noopener ugc nofollow" target="_blank">hadron-json-provider</a></code>计划的用武之地。这个独立的软件包允许您为自动导入的文件指定路径和扩展名。</p><p id="5ce2" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">这是非常有用的分裂成不同的文件我们的路线。默认情况下，<code class="eh la lb lc ld b">hadron-express</code>包接受Hadron配置中的键<em class="le"> routePaths </em>，它接受一组路径和扩展名，然后使用<code class="eh la lb lc ld b">hadron-json-provider</code>包从这些文件中加载路由。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><h1 id="c78f" class="iy iz ib bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">强子vs平原快递. js</h1><p id="1037" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">请记住，强子<strong class="jy ic">不会影响后端应用</strong>的性能——使用<a class="ae ku" href="https://github.com/matteofigus/api-benchmark" rel="noopener ugc nofollow" target="_blank"> api基准</a>和<code class="eh la lb lc ld b">10000 runs sampled with concurrency: 10000</code>进行测试。</p><p id="3102" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">Hadron为您提供了空间和工具来提高您项目的生产率和可维护性，并在像T1这样的框架上创建了一个抽象层。</p><p id="40a3" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">使用Hadron的主要优势在于，您可以快速而<strong class="jy ic">轻松地选择各种工具</strong>来管理数据库，<strong class="jy ic">提供安全性</strong>，并根据用户类型调整您的输出。一切都简单地为您完成，并由您轻松配置。</p><p id="6730" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">使用Hadron创建API是如此简单，以至于你可以将你的路径分成不同的文件，而不用关心依赖关系、实例等。这是因为依赖注入，它用在路由的回调函数中。</p><p id="a1e0" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">当您注册任何包时，它会使用提供的配置进行初始化，并放入容器中的特定键下，您可以稍后在路由的回调函数中使用这些键。</p><h1 id="2e7f" class="iy iz ib bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">强子依赖注入</h1><p id="e96b" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">Hadron提供了在我们称之为<strong class="jy ic">容器</strong>的东西中存储数据或对象实例的选项。它还保存由Hadron包初始化的数据，例如，<code class="eh la lb lc ld b">hadron-typeorm</code>包中的数据库存储库。</p><p id="4885" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">在容器中注册项目时，您可以选择一个生存期选项，即:</p><ul class=""><li id="8bb0" class="lp lq ib jy b jz kv kd kw kh lr kl ls kp lt kt lu lv lw lx dt translated"><code class="eh la lb lc ld b">value</code> —这是默认行为。当从容器中获取数据时，您获得的是注册的相同内容。</li><li id="de03" class="lp lq ib jy b jz ly kd lz kh ma kl mb kp mc kt lu lv lw lx dt translated"><code class="eh la lb lc ld b">singleton</code> —总是返回注册类/构造函数的同一个实例。</li><li id="d9dd" class="lp lq ib jy b jz ly kd lz kh ma kl mb kp mc kt lu lv lw lx dt translated"><code class="eh la lb lc ld b">transient</code> —总是返回注册类/构造函数的新实例。</li></ul><p id="38dd" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">依赖注入在路由的回调中使用，这允许您轻松地访问任何容器值。假设我们将把一个字符串<code class="eh la lb lc ld b">Hello World</code>存储在容器中的键<code class="eh la lb lc ld b">message</code>下，并且我们想在我们的路径上访问它。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="6c92" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">向<a class="ae ku" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080/ </a>发送请求后，您将收到:</p><pre class="lf lg lh li fq md ld me mf aw mg dt"><span id="21d3" class="mh iz ib ld b fv mi mj l mk ml">"Message stored in container: Hello World"</span></pre><p id="6ea7" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">这就是您访问容器项目的方式。大多数包都在那里存储项目，因此您可以轻松地执行一些操作或检索所需的数据。</p><p id="2e91" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">您现在可能会考虑访问我们的路线中经常使用的<em class="le">请求</em>变量，如<strong class="jy ic">标题</strong>、<strong class="jy ic">参数</strong>、<strong class="jy ic">正文</strong>、<strong class="jy ic">查询</strong>等..这些数据作为回调函数的第一个参数提供。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="9bf9" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">在这种情况下，路由的响应将返回请求的header对象。</p><h1 id="ef37" class="iy iz ib bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">Hadron软件包快速概述</h1><p id="a6f9" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">到目前为止我们只发现了几个包，尤其是<code class="eh la lb lc ld b">hadron-express</code>。我们来讨论一些官方的强子包。</p><p id="ee9d" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">本文中的所有例子都可以在GitHub的<a class="ae ku" href="https://github.com/damian66/hadron-examples" rel="noopener ugc nofollow" target="_blank">这里</a>找到。随意和他们玩。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h2 id="4821" class="mh iz ib bd ja mt mu mv je mw mx my ji kh mz na jm kl nb nc jq kp nd ne ju nf dt translated"><a class="ae ku" href="https://github.com/brainhubeu/hadron/tree/master/packages/hadron-typeorm" rel="noopener ugc nofollow" target="_blank">强子型态</a></h2><p id="0c3d" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">这个包将<a class="ae ku" href="https://github.com/typeorm/typeorm" rel="noopener ugc nofollow" target="_blank">类型的ORM </a>包与Hadron进行了封装和集成。它让我们能够以简单的方式注册和访问<a class="ae ku" href="http://typeorm.io/#/working-with-repository" rel="noopener ugc nofollow" target="_blank">库</a>或<a class="ae ku" href="http://typeorm.io/#/migrations" rel="noopener ugc nofollow" target="_blank">迁移</a>。</p><p id="9017" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">要连接您的数据库，您只需导入<code class="eh la lb lc ld b">hadron-typeorm</code>包，并向Hadron的配置提供连接对象。</p><p id="3197" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">假设我们有一个用户表。为了检索一个带有ID的记录，我们将使用一个端点，如<code class="eh la lb lc ld b">/user/1</code>。我们的回调可能看起来像这样:</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="ed48" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">看起来很简单，对吧？但是和我们数据库的连接呢？正如我之前提到的，在初始化强子时，我们需要为我们的配置提供一个连接对象。在下面的例子中，我们将使用MySQL数据库。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="68ab" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">要在TypeORM中创建存储库，我们需要提供一个<a class="ae ku" href="http://typeorm.io/#/entities" rel="noopener ugc nofollow" target="_blank">实体</a>。然后，Hadron将从其中注册一个存储库，并在包含实体名称和<em class="le">存储库</em>后缀的关键字下注册—实体<em class="le">用户</em>将在<em class="le">用户存储库</em>关键字下的容器中注册。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h2 id="6034" class="mh iz ib bd ja mt mu mv je mw mx my ji kh mz na jm kl nb nc jq kp nd ne ju nf dt translated"><a class="ae ku" href="https://github.com/brainhubeu/hadron/tree/master/packages/hadron-serialization" rel="noopener ugc nofollow" target="_blank">强子-序列化</a></h2><p id="4c0b" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">序列化程序允许您指定JSON输出的形状。</p><p id="82ee" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">假设一个用户用一个auth令牌向API发送请求。使用一个<code class="eh la lb lc ld b">hadron-serialization</code>包，我们可以很容易地根据用户的权限来处理他将看到的字段。</p><p id="7472" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">在下面的例子中，只有一个端点<br/> — <code class="eh la lb lc ld b"><strong class="jy ic">/:group?</strong></code>(我们将关注两个组，mod和admin)。</p><p id="68b0" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">在我们的例子中，将会有一个用户列表作为对该端点的响应返回。每个用户都应该看到用户的名字和姓氏，组<strong class="jy ic"> mod </strong>中的用户也应该看到一封电子邮件，而<strong class="jy ic"> admin </strong>将看到他们所有人的附加ID字段。</p><p id="e73e" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">这是我们将使用的数据:</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="7a83" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">所以为了让<code class="eh la lb lc ld b">hadron-serialization</code>包工作，我们需要初始化它。但是在此之前，我们应该为我们的数据定义一个模式。我们可以在另一个文件中定义它，或者简单地在Hadron的配置中提供一个对象文本。我们将把它保存为外部JSON文件。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="5609" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">因此，明确地说，模式是一个对象，应该包含:</p><ul class=""><li id="f119" class="lp lq ib jy b jz kv kd kw kh lr kl ls kp lt kt lu lv lw lx dt translated"><strong class="jy ic">名称</strong> —简单的模式名称。在序列化数据时，我们将需要它来识别模式。</li><li id="d6c9" class="lp lq ib jy b jz ly kd lz kh ma kl mb kp mc kt lu lv lw lx dt translated"><strong class="jy ic">属性</strong> —这些字段包含一个对象数组。每个对象保存将被序列化的键的名称、它的类型和它应该可见的组(如果组是空的，那么它们对每个人都是可见的)。</li></ul><pre class="lf lg lh li fq md ld me mf aw mg dt"><span id="535d" class="mh iz ib ld b fv mi mj l mk ml">Notice that if you don’t specify some key in a schema, it <strong class="ld ic">won’t be visible</strong>!</span></pre><p id="468a" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">好了，现在我们已经定义了序列化包中所需的数据和模式，接下来让我们定义Hadron实例。我们的<strong class="jy ic"> index.js </strong>文件应该是这样的:</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="e58b" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">上面的例子基本上是一个使用强子制作的整个app的例子。所以设置<code class="eh la lb lc ld b">hadron-serialization</code>包很简单——我们所需要做的就是声明模式对象，它将被用来形成我们的数据并在配置中提供它们。</p><p id="2726" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">接下来，当我们想要序列化数据时，只需从容器中取出<strong class="jy ic"> serializer </strong>对象并执行serialize方法。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h2 id="cd30" class="mh iz ib bd ja mt mu mv je mw mx my ji kh mz na jm kl nb nc jq kp nd ne ju nf dt translated"><a class="ae ku" href="https://github.com/brainhubeu/hadron/tree/master/packages/hadron-events" rel="noopener ugc nofollow" target="_blank">强子事件</a></h2><p id="adf4" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated"><code class="eh la lb lc ld b">Hadron-events</code>包允许您使用内置事件，甚至声明您自己的定制事件，将监听器绑定到它们，并在应用程序生命周期的任何时候简单地发出它们。</p><p id="5cef" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">目前，在强子中，包文档中列出的内置事件很少，你可以在这里找到<a class="ae ku" href="https://github.com/brainhubeu/hadron/tree/master/packages/hadron-events" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1a1d" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">为了初始化我们的简单事件处理程序，我们需要提供事件监听器。在下面的例子中，我们将在<code class="eh la lb lc ld b">hadron-core</code>的引导函数中提供<code class="eh la lb lc ld b">hadron-events</code>包的配置。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="0de2" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">所以我们将我们的侦听器包含在一个外部文件中。在我们的例子中，我们将尝试<strong class="jy ic">handleRequestCallbackEvent</strong>，它将在每个请求发生之前发出事件。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="ca0d" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">在<code class="eh la lb lc ld b">hadron-events</code>包中，我们还可以在应用程序生命周期的任何部分发出我们自己的事件。我们将监听两个具有简单名称的事件，如<strong class="jy ic">成功事件</strong>和<strong class="jy ic">失败事件</strong>。如果<em class="le">键</em>值为<strong class="jy ic"> foo </strong>，那么当用户向<code class="eh la lb lc ld b"><em class="le">/:key</em></code>发送请求时，我们将发出该事件。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="80c2" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">我们例子的最后一步是实现监听器。如前所述，我们将创建两个侦听器，一个用于successEvent，一个用于failEvent。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="3ecb" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">这将允许我们从应用程序中的任何地方发出这些自定义事件。为了简单起见，在我们的例子中，这个地方就是请求的回调。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h1 id="3305" class="iy iz ib bd ja jb ng jd je jf nh jh ji jj ni jl jm jn nj jp jq jr nk jt ju jv dt translated">链接</h1><ul class=""><li id="4ea3" class="lp lq ib jy b jz ka kd ke kh nl kl nm kp nn kt lu lv lw lx dt translated"><a class="ae ku" href="https://github.com/brainhubeu" rel="noopener ugc nofollow" target="_blank"> Brainhub的Github </a> —如果你正在寻找更多的开源项目。</li><li id="223d" class="lp lq ib jy b jz ly kd lz kh ma kl mb kp mc kt lu lv lw lx dt translated"><a class="ae ku" href="https://brainhub.eu/" rel="noopener ugc nofollow" target="_blank">Brainhub</a>——如果你正在寻找专业人士来帮助你构建你的JavaScript应用程序。</li></ul><h1 id="8c87" class="iy iz ib bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">关于</h1><p id="00bc" class="pw-post-body-paragraph jw jx ib jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated"><a class="ae ku" href="https://hadron.pro/" rel="noopener ugc nofollow" target="_blank">强子</a>及其官方软件包由Brainhub开发团队维护。它由Brainhub资助，Brainhub的名称和徽标是Brainhub Sp的商标。z o.o..你可以查看一下我们队友支持/开发的其他<a class="ae ku" href="https://github.com/brainhubeu" rel="noopener ugc nofollow" target="_blank">开源项目</a>。</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div class="fe ff no"><img src="../Images/de252fdb9335d3e2c80837e8f25da0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*JRSNbdvB9lpHptmp7xRA9A.png"/></div></figure><p id="c632" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated">我们热爱开源JavaScript软件！查看我们的其他项目或雇佣我们来构建您的下一个web，<a class="ae ku" href="https://brainhub.eu/services" rel="noopener ugc nofollow" target="_blank">桌面和移动JavaScript应用</a>。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="1c69" class="pw-post-body-paragraph jw jx ib jy b jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp kz kr ks kt hn dt translated"><em class="le">帖子由</em> <a class="ae ku" rel="noopener" href="/@damian23"> <em class="le">达米安</em> </a> <em class="le">，</em> o <em class="le">原创发布于</em><a class="ae ku" href="https://brainhub.eu/blog/building-api-expressjs-and-hadron/" rel="noopener ugc nofollow" target="_blank"><em class="le">brainhub . eu</em></a></p></div></div>    
</body>
</html>