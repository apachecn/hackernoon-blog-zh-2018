<html>
<head>
<title>Testing Node.js in 2018</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2018年测试Node.js</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-node-js-in-2018-10a04dd77391?source=collection_archive---------0-----------------------#2018-07-05">https://medium.com/hackernoon/testing-node-js-in-2018-10a04dd77391?source=collection_archive---------0-----------------------#2018-07-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/7f3f5c68a87e1e66a918d461521ca616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3lGUOAGK-XdZMXwiHcI6w.png"/></div></div></figure><div class=""/><p id="b0e8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://getstream.io" rel="noopener ugc nofollow" target="_blank"> Stream </a>为3亿多终端用户提供信息。由于所有这些用户都依赖于我们的基础设施，我们非常擅长测试投入生产的所有东西。我们的主要代码库是用Go编写的，还有一些Python的剩余代码。</p><p id="8c22" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们最近的展示应用程序<a class="ae ka" href="https://getstream.io/winds" rel="noopener ugc nofollow" target="_blank"> Winds 2.0 </a>是用Node.js构建的，我们很快发现我们在Go和Python中常用的测试方法不太合适。此外，创建适当的测试套件需要在Node.js中做一些前期工作，因为我们使用的框架不提供任何类型的内置测试功能。</p><p id="bc42" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不管使用什么语言，建立一个好的测试框架都是很棘手的。在这篇文章中，我们将揭示Node.js测试的难点，这是我们决定在Winds 2.0中使用的各种工具，并为您指出编写下一组测试的正确方向。</p><h1 id="5dc0" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为什么测试如此重要</h1><p id="4541" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们都曾将错误的承诺推向生产，并承担后果。发生这种事可不好玩。编写一个可靠的测试套件不仅是一个很好的健全性检查，而且它允许您完全重构代码，并对您的代码库仍然有效充满信心。如果您刚刚启动，这一点尤为重要。</p><p id="e2bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你和一个团队一起工作，拥有测试覆盖率是非常重要的。没有它，团队中的其他开发人员几乎不可能知道他们的贡献是否会导致突破性的变化(哎哟)。</p><p id="51fd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编写测试也鼓励你和你的队友将代码分成更小的部分。这使得理解你的代码变得更加容易，并且在这个过程中修正错误。生产率的提高甚至更大，因为你在早期就发现了错误。</p><p id="9866" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，如果没有测试，你的代码库也可能是一个纸牌屋。你的代码绝对不可能是稳定的。</p><h1 id="e57f" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">困难的部分</h1><p id="06b3" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在我看来，我们在Winds上遇到的大多数测试问题都是针对Node.js的。比如你在macOS上运行“brew upgrade”(安装了homebrew)，你看到Node.js新版本的几率相当高。随着Node.js的快速发展，库也紧随其后，很难保持与最新库的同步。</p><p id="25f2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">下面是我立即想到的几个痛点:</strong></p><ol class=""><li id="8b13" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">Node.js中的测试非常固执己见，同时又不固执己见。许多人对测试基础设施应该如何构建和衡量是否成功有不同的看法。可悲的是，对于如何进行测试，还没有黄金标准。</li><li id="6cb7" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">在您的应用程序中有大量的框架可供使用。然而，它们通常是最小的，没有良好定义的配置或引导过程。这导致了非常普遍的副作用，但是很难诊断；因此，您很可能会从头开始编写自己的测试运行程序。</li><li id="be7d" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">几乎可以肯定的是，你会被<em class="ls">要求</em>编写你自己的测试运行程序(我们马上就要谈到这一点)。</li></ol><p id="199a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面列出的情况并不理想，Node.js社区需要尽快解决这个问题。如果其他语言已经发现了这一点，我认为Node.js这种被广泛采用的语言也应该发现这一点了。</p><h1 id="3a88" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">编写您自己的测试运行程序</h1><p id="709f" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">所以…你可能想知道什么是测试赛跑者<em class="ls"/>。说实话，没那么复杂。测试运行程序是测试套件中最高的组件。它允许您指定全局配置和环境，以及导入设备。有人会认为这很简单，也很容易做到…对吗？没那么快…</p><p id="9948" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们了解到，尽管有大量的测试框架，但没有一个Node.js提供统一的方法来构建您的测试运行器。可悲的是，这取决于开发人员。下面是对测试跑步者要求的快速分解:</p><ul class=""><li id="eaed" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lt lk ll lm dt translated">能够加载不同的配置(例如，本地、测试、开发)并确保您<strong class="je ig"> <em class="ls">永远不会</em> </strong>加载生产配置——您可以猜到发生这种情况时会出现什么问题。</li><li id="9a3a" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lt lk ll lm dt translated">用虚拟数据提升和播种数据库以进行测试。这必须适用于各种数据库，无论是MySQL、PostgreSQL、MongoDB还是任何其他数据库。</li><li id="35ca" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lt lk ll lm dt translated">能够加载fixtures(带有种子数据的文件，用于在开发环境中进行测试)。</li></ul><p id="091b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于Winds，我们选择使用摩卡作为我们的测试跑步者。Mocha提供了一种简单的编程方式，通过命令行工具(与Babel集成)在ES6代码库上运行测试。</p><p id="5882" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了开始测试，我们自己注册了Babel模块加载器。这为我们在Babel覆盖Node.js模块加载过程之前对导入哪些模块提供了更好的控制，使我们有机会在运行任何测试之前模拟模块。</p><p id="7557" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，我们还使用Mocha的test runner特性为特定的请求预先分配HTTP处理程序。我们这样做是因为在测试期间不运行正常的初始化代码(Chai HTTP插件模拟服务器交互),并且运行一些安全检查以确保我们没有连接到生产数据库。</p><p id="dd6b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这不是测试运行程序的一部分，但是拥有一个fixture loader是我们测试套件的一个重要部分。我们研究了现有的解决方案；然而，我们决定编写我们自己的助手，以便它能满足我们的需求。使用我们的解决方案，我们可以在手工生成或编写fixture时，通过遵循一个简单的特别约定来加载具有复杂数据依赖性的fixture。</p><h1 id="5630" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">风力工具</h1><p id="4fa5" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">尽管这个过程很麻烦，但我们能够找到工具和框架的正确平衡，使适当的测试成为我们后端API的现实。以下是我们的选择:</p><h1 id="989c" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">摩卡☕</h1><p id="b18e" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">被描述为“在Node.js上运行的功能丰富的JavaScript测试框架”的Mocha ，是我们立即选择的工作工具。有超过15，000名明星、许多支持者、赞助者和贡献者，我们知道这是适合这项工作的框架。</p><h1 id="e6ba" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">柴🥃</h1><p id="2a58" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">接下来是我们的断言库。我们选择了传统的方法，这是最适合摩卡——<a class="ae ka" href="http://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>的方法。Chai是Node.js的BDD和TDD断言库。通过一个简单的API，Chai很容易集成到我们的应用程序中，并允许我们轻松断言我们应该从Winds API返回的<strong class="je ig"><em class="ls"/></strong><em class="ls"/><strong class="je ig"><em class="ls"/></strong>。最重要的是，使用Chai编写测试感觉很自然。这里有一个简短的例子:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="9939" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">兴农🧙‍</h1><p id="88a1" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">由于能够使用任何单元测试框架，<a class="ae ka" href="http://sinonjs.org/" rel="noopener ugc nofollow" target="_blank"> Sinon </a>是我们模仿库的第一选择。同样，一个具有最小设置的超级干净的集成，Sinon将模仿请求变成一个简单和容易的过程。他们的网站有一个非常友好的用户体验，并提供了简单的步骤来集成Sinon与您的测试套件。</p><h1 id="682f" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">作凹痕于🔮</h1><p id="5496" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对于所有外部HTTP请求，我们使用<a class="ae ka" href="https://github.com/node-nock/nock" rel="noopener ugc nofollow" target="_blank"> nock </a>，这是一个健壮的HTTP模仿库，当您必须与第三方API(如<a class="ae ka" href="https://getstream.io/docs_rest/" rel="noopener ugc nofollow" target="_blank"> Stream的REST API </a>)通信时，它真的很方便。除了它的功能令人敬畏这一事实之外，这个小小的库没什么可说的，这也是我们喜欢它的原因。这里有一个简单的例子，我们称我们的<a class="ae ka" href="https://getstream.io/personalization" rel="noopener ugc nofollow" target="_blank">个性化</a>引擎为Stream:</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="2afb" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">模拟要求🎩</h1><p id="8a92" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">库<a class="ae ka" href="https://github.com/boblauer/mock-require" rel="noopener ugc nofollow" target="_blank"> mock-require </a>允许依赖外部代码。在一行代码中，您可以替换一个模块，当一些代码试图导入该模块时，mock-require会介入。这是一个小而简约的图书馆，但是很强大，我们是它的忠实粉丝。</p><h1 id="bce6" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">伊斯坦布尔🔭</h1><p id="4f60" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/gotwarlost/istanbul" rel="noopener ugc nofollow" target="_blank">伊斯坦布尔</a>是一个JavaScript代码覆盖工具，用模块加载器挂钩计算语句、行、函数和分支覆盖，在运行测试时透明地添加覆盖。尽管我们与CodeCov有类似的功能(见下一节)，但在本地运行测试时，这是一个很好的工具。</p><h1 id="cc71" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">最终结果——工作测试</h1><p id="ff42" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><em class="ls">有了所有的库，包括上面提到的测试运行程序，让我们看看一个完整的测试是什么样子的(你可以在这里</em>  <em class="ls">看一下我们的整个测试套件</em><a class="ae ka" href="https://github.com/GetStream/Winds/tree/master/api/test" rel="noopener ugc nofollow" target="_blank">】:</a></p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="868c" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">连续累计</h1><p id="e174" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有很多持续集成服务可用，但我们喜欢使用Travis CI，因为他们和我们一样热爱开源环境。鉴于Winds是开源的，它非常适合。</p><p id="6790" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的集成相当简单——我们有一个<a class="ae ka" href="https://github.com/GetStream/Winds/blob/master/.travis.yml" rel="noopener ugc nofollow" target="_blank"> .travis.yml </a>文件，它通过一个简单的<a class="ae ka" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>命令设置环境并启动我们的测试。覆盖率报告给GitHub，在那里我们可以清楚地看到我们最新的代码库或PR是否通过了我们的测试。GitHub集成很棒，因为它是可见的，我们不必去Travis CI查看结果。下面是GitHub查看PR时的截图(测试后):</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ma"><img src="../Images/7d9cee03a88a5aa7c4258986c6ace53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWfI0No5wZn7BBoWtJsLoA.png"/></div></div></figure><p id="59f9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了Travis CI，我们还使用了一个叫做<a class="ae ka" href="https://codecov.io/#features" rel="noopener ugc nofollow" target="_blank"> CodeCov </a>的工具。CodeCov类似于伊斯坦布尔的<a class="ae ka" href="https://github.com/gotwarlost/istanbul" rel="noopener ugc nofollow" target="_blank"/>，然而，它是一个可视化工具，允许我们轻松地看到代码覆盖、文件更改、代码行修改以及其他各种好处。虽然没有CodeCov也可以可视化这些数据，但是把所有东西都放在一个地方还是不错的。</p><h1 id="3cf8" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">我们学到了什么</h1><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mb"><img src="../Images/6344a12d589b39ff887bef03335df837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9uadS4Rk4oQHxf9Gl6Q3g.png"/></div></div></figure><p id="3e4a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在开发测试套件的过程中，我们学到了很多东西。由于没有“正确的”做事方式，我们决定着手创建我们自己的测试流程，通过对可用的库进行排序来找到那些有希望添加到我们的工具箱中的库。</p><p id="3e96" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们最终了解到，在Node.js中进行测试并不像听起来那么简单。希望随着Node.js的不断发展，社区会团结起来，建立一个坚固的库，以“正确”的方式处理所有与测试相关的事情。</p><p id="8c12" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在那之前，我们将继续使用我们的测试套件，它在<a class="ae ka" href="https://github.com/GetStream/Winds/tree/master/api/test" rel="noopener ugc nofollow" target="_blank"> Winds GitHub库</a>上是开源的。</p><h1 id="bbc7" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">限制</h1><h2 id="4f64" class="mc kc if bd kd md me mf kh mg mh mi kl jn mj mk kp jr ml mm kt jv mn mo kx mp dt translated">没有创建装置的简单方法</h2><p id="c89c" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">框架和语言，比如Python的Django，有简单的方法来创建fixtures。例如，使用Django，您可以使用以下命令通过将数据转储到文件中来自动创建装置:</p><p id="cdb1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">下面的命令会将整个数据库转储到一个db.json文件中:</strong> <br/>。/manage.py dumpdata &gt; db.json</p><p id="d08d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">下面的命令将只转储django admin.logentry表</strong> : <br/>中的内容。/manage . py dump data admin . log entry&gt;log entry . JSON</p><p id="cc7b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">下面的命令将转储django auth.user表中的内容:<br/> </strong>。/manage . py dump data auth . user&gt;user . JSON</p><p id="35c6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Node.js中创建fixture没有简单的方法，我们最后做的是使用MongoDB Compass并从那里导出JSON。这产生了一个很好的夹具，如下所示(然而，这是一个繁琐的过程，容易出错):</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mq"><img src="../Images/e5fbb6960dafc5d6ca2f2e0bdb99c0d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvXXS57rAIfBTOQ9h1HCew.png"/></div></div></figure><h2 id="b26f" class="mc kc if bd kd md me mf kh mg mh mi kl jn mj mk kp jr ml mm kt jv mn mo kx mp dt translated">使用Babel、模拟模块和Mocha测试运行程序时的非直观模块加载</h2><p id="dab3" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了支持更广泛的节点版本并获得Javascript标准的最新补充，我们使用Babel将我们的ES6代码库移植到ES5。Node.js模块系统基于CommonJS标准，而ES6模块系统具有不同的语义。</p><p id="d249" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Babel在Node.js模块系统上模拟ES6模块语义，但是因为我们使用mock-require来干扰模块加载，所以我们开始了一段奇怪的模块加载的旅程，这看起来不直观，并且可能导致在整个代码库中导入、初始化和使用多个独立版本的模块。这使得测试期间的模仿和全局状态管理变得复杂。</p><h2 id="6e1e" class="mc kc if bd kd md me mf kh mg mh mi kl jn mj mk kp jr ml mm kt jv mn mo kx mp dt translated">当使用ES6模块时，不能模仿在声明它们的模块中使用的函数</h2><p id="775e" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当一个模块导出多个函数，其中一个调用另一个时，不可能模仿模块内部使用的函数。原因是，当您需要一个ES6模块时，您会看到一组独立于模块内部使用的引用。任何重新绑定引用以指向新值的尝试都不会真正影响模块内部的代码，它将继续使用原来的函数。</p><h1 id="d5f9" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">最后的想法</h1><p id="da5d" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">测试Node.js应用程序是一个复杂的过程，因为生态系统总是在不断发展。掌握最新最棒的工具非常重要，这样你才不会落后。</p><p id="2535" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如今，JavaScript相关新闻的渠道如此之多，以至于很难与所有这些新闻保持同步。关注电子邮件时事通讯，如<a class="ae ka" href="https://javascriptweekly.com/" rel="noopener ugc nofollow" target="_blank"> JavaScript周刊</a>和<a class="ae ka" href="https://nodeweekly.com/" rel="noopener ugc nofollow" target="_blank"> Node周刊</a>是一个好的开始。除此之外，加入一个像<a class="ae ka" href="https://www.reddit.com/r/node/" rel="noopener ugc nofollow" target="_blank"> /r/node </a>这样的子节点是一个好主意。如果你喜欢站在最新趋势的顶端，JS的<a class="ae ka" href="https://stateofjs.com/2017/testing/results/" rel="noopener ugc nofollow" target="_blank">State</a>在帮助开发人员可视化测试世界的趋势方面做得很好。</p><p id="18e6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，这里有几个我最喜欢的博客，经常会有文章出现:</p><ul class=""><li id="92fc" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lt lk ll lm dt translated"><a class="ae ka" href="https://hackernoon.com/" rel="noopener ugc nofollow" target="_blank">黑客正午</a></li><li id="427a" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lt lk ll lm dt translated"><a class="ae ka" href="https://medium.freecodecamp.org/" rel="noopener ugc nofollow" target="_blank">免费代码营</a></li><li id="361f" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lt lk ll lm dt translated"><a class="ae ka" href="https://blog.bitsrc.io/" rel="noopener ugc nofollow" target="_blank">零零碎碎</a></li></ul><p id="89a5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">觉得我错过了什么重要的东西？让我在评论中知道，或者在Twitter上知道-<a class="ae ka" href="https://twitter.com/@nickparsons" rel="noopener ugc nofollow" target="_blank">@ nick Parsons</a>。</p><p id="c9ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，如果你想看看流，我们有一个伟大的5分钟教程在我们的网站上。在这里试一下<a class="ae ka" href="https://getstream.io/try-the-api" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="lu lv lw lx fq hw"><div class="bz el l di"><div class="mr lz l"/></div></figure></div></div>    
</body>
</html>