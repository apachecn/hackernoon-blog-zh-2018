<html>
<head>
<title>Upgrade your React UI with state machines 💡</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用状态机升级您的React UI💡</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/upgrade-your-react-ui-with-state-machines-30d1298e90be?source=collection_archive---------2-----------------------#2018-07-05">https://medium.com/hackernoon/upgrade-your-react-ui-with-state-machines-30d1298e90be?source=collection_archive---------2-----------------------#2018-07-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5225" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章是关于React-Machinery，一个用于在React中创建和使用状态机来控制UI的库。 <a class="ae jq" href="https://github.com/francisrstokes/React-Machinery" rel="noopener ugc nofollow" target="_blank"> <em class="jp">在github上找到完整源码</em> </a></p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/f31ba4767b020f489aace7d60c48e774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lo_79VKZQepmY5h55BF_tA.png"/></div></div></figure></div><div class="ab cl kd ke hc kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hn ho hp hq hr"><p id="d1e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">状态无处不在，它是web开发社区中特别热门的话题。我们有像<strong class="it hv"> redux </strong>这样的库来帮助管理全局状态，但是在组件级别上，我们可以更进一步，利用一些优秀的老式计算机科学。</p><p id="cf65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几乎所有的UI组件都有一组特定的状态。像下拉菜单这样的简单组件有<em class="jp">未选中</em>，<em class="jp">处于选中</em>状态，<em class="jp">处于选中</em>状态。像youtube视频组件这样的复杂视图有许多状态，如<em class="jp">播放</em>、<em class="jp">暂停</em>、<em class="jp">加载</em>——以及许多子状态，如音量控制是否<em class="jp">展开</em>，或者是否启用了隐藏字幕。这也不限于UI——任何种类的应用程序、对象或函数都可以是有状态的。</p><p id="c509" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为开发人员，我们经常使用<strong class="it hv">布尔变量</strong>和<strong class="it hv"> if语句来建模这些状态。虽然这本身并不坏，但这种方法存在一些问题:</strong></p><ul class=""><li id="41f6" class="kk kl hu it b iu iv iy iz jc km jg kn jk ko jo kp kq kr ks dt translated">布尔表达式的组合很难理解和交流</li><li id="a8f1" class="kk kl hu it b iu kt iy ku jc kv jg kw jk kx jo kp kq kr ks dt translated">随着需求的变化，这些分支if语句可能会产生不必要的副作用</li></ul><p id="4903" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有没有遇到过这样的错误，由于某种原因，状态的两个完全不同的部分以一种意想不到的方式结合在一起，产生一种奇怪的效果？我几乎在我参与的每一个项目中都有这样的经历，从游戏到水疗到休息后端。</p><p id="a0e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，计算机科学为这类问题提供了一个非常好的解决方案，恰当地命名为<strong class="it hv">有限状态机</strong>。</p><h2 id="865f" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">有限状态机&gt;组合逻辑</h2><p id="0144" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">首先，粗略地说，有限状态机是:</p><blockquote class="ly lz ma"><p id="859a" class="ir is jp it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">一个<strong class="it hv">有限状态机</strong> ( <strong class="it hv"> FSM </strong>)或<strong class="it hv">有限状态自动机</strong> ( <strong class="it hv"> FSA </strong>，复数:<em class="hu">自动机</em>)，<strong class="it hv">有限自动机</strong>，或简称为<strong class="it hv">状态机</strong>，是计算的数学<a class="ae jq" href="https://en.wikipedia.org/wiki/Model_of_computation" rel="noopener ugc nofollow" target="_blank">模型。它是一个</a><a class="ae jq" href="https://en.wikipedia.org/wiki/Abstract_machine" rel="noopener ugc nofollow" target="_blank">抽象机器</a>，在任何给定的时间，它可以处于有限个<a class="ae jq" href="https://en.wikipedia.org/wiki/State_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="hu">状态</em> </a>中的一个状态。FSM可以响应一些外部<a class="ae jq" href="https://en.wikipedia.org/wiki/Input_(computer_science)" rel="noopener ugc nofollow" target="_blank">输入</a>从一种状态变为另一种状态；从一种状态到另一种状态的变化称为<em class="hu">转换</em>。FSM由它的状态列表、它的初始状态和每个转换的条件来定义。</p><p id="80f9" class="ir is jp it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">摘自<a class="ae jq" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Finite-state_machine</a></p></blockquote><p id="321d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这个定义能和我上面谈到的UI状态联系起来。如果没有，不要担心——一个实际的例子来了！</p><p id="47a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个小注意，有趣的是注意到了描述中的那个词<strong class="it hv"> <em class="jp">自动机</em> </strong>。在数学和计算机科学中，自动机是处理可计算性的“抽象机器”。这些<strong class="it hv"> <em class="jp">自动机</em> </strong>形成一个层级:</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff me"><img src="../Images/eb01a72a20825212d50db3cd86ae4480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*q7spAETJyIHKLthwRqEOWg.png"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">From: <a class="ae jq" href="https://en.wikipedia.org/wiki/Automata_theory" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Automata_theory</a></figcaption></figure><p id="19e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从图中可以看出，有限状态机比单纯的组合逻辑(布尔和if语句)占据了自动机的更高层次。简单地说，它们为你提供了一种语言，以一种比你单独使用组合逻辑更精确的方式来描述一些东西。</p><p id="8e66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以将这一理论付诸实践，并与反应⚛️一起使用</p><h2 id="1cdb" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated"><hardchoicebutton>组件</hardchoicebutton></h2><p id="c78c" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">不久前，韦斯·博斯在夏威夷导弹恐慌后发布了这条推特:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="0f28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将使用这个组件作为灵感，并使用<strong class="it hv"><em class="jp">react-machinery</em></strong>构建类似的东西。</p><p id="a646" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果将是一个名为<strong class="it hv"> HardChoiceButton，</strong>的组件，它将显示一条消息，倒计时的秒数，以及一个作为道具运行的动作函数。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ml mk l"/></div></figure><p id="432d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你愿意，你可以在阅读之前快速浏览一下完成的例子。T3】</p><p id="3351" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">按钮开始处于<em class="jp">等待输入</em>状态，当用户按下按钮时，进入<em class="jp">等待</em>状态。</p><p id="8bca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<em class="jp">未决</em>状态期间，计时器从5(或我们传递的任何值)开始倒计时。在倒计时过程中的任何时候，用户都可以再次按下按钮中止操作，进入<em class="jp">中止</em>状态。</p><p id="a44b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果在<em class="jp">等待</em>期间没有按下按钮，并且倒计时一直到0，那么动作被执行，按钮进入<em class="jp">完成</em>状态。</p><p id="9a9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以用下面的<strong class="it hv"> <em class="jp">状态图来表示上述逻辑:</em> </strong></p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/3596504e72cb06c5b18228598203101b.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*qpORCDe1kBavflJ69VQSmA.png"/></div></figure><h2 id="a4c6" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">引进反应机械</h2><p id="3c05" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">让我们开始定义<strong class="it hv">硬选择按钮</strong>类:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ml mk l"/></div></figure><p id="30fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您所看到的，由<strong class="it hv">react-machine</strong>公开的StateMachine组件有4个属性:states数组、获取/设置当前状态的函数和一些数据属性，我马上就要谈到这些属性。您可以将任何想要的数据源连接到<strong class="it hv"><em class="jp">getCurrentState()</em></strong>和<strong class="it hv"><em class="jp">setNewState()</em></strong>函数——从redux存储或mobx状态树中获取数据——但是这个示例只使用常规的组件状态。</p><p id="2852" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">states数组包含有名称的对象，在本例中是一个名为render的函数。此处的<strong class="it hv"> <em class="jp">渲染</em> </strong>功能表示处于<em class="jp">等待输入</em>状态时要渲染的组件。该函数接收<strong class="it hv"> <em class="jp">数据</em> </strong>对象作为道具，允许我们显示‘发射导弹’消息。</p><p id="6a6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管<strong class="it hv">硬选择按钮</strong>只有一个州，但它并没有多大用处！让我们继续填写其余的州。</p><p id="dcbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在此之前有一个小注意:与每个状态相关联的组件可以用两种方式给出。第一种是通过一个<strong class="it hv"> <em class="jp">渲染</em> </strong>功能如上图。这种方式遵循<a class="ae jq" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具模式</a>。第二种方法是改为指定一个<strong class="it hv"> <em class="jp">组件的</em> </strong>属性。这不是一个函数，而是一个普通的组件。如果您有一个带有自己内部状态的react类组件，这种风格会更适用一些。</p><h2 id="18c1" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">完整状态定义</h2><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ml mk l"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">State definitions + two class components</figcaption></figure><p id="eefc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们在<em class="jp">等待输入</em>状态下点击按钮时，我们称<strong class="it hv"> <em class="jp">转换为(‘待定’)</em></strong>。这是<strong class="it hv"> <em class="jp">状态机</em> </strong>组件传递给<strong class="it hv"> <em class="jp">渲染</em> </strong>以及<strong class="it hv"> <em class="jp">数据</em> </strong>对象的一个特殊函数。</p><p id="6d18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">里面还有另外一个键叫做<strong class="it hv"> <em class="jp"> validTransitions。</em> </strong>用于登记允许与<strong class="it hv"> <em class="jp">过渡到</em> </strong>的状态。尝试转换到未注册的状态将导致错误。</p><p id="11f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一个<strong class="it hv"> <em class="jp"> beforeRender </em> </strong>函数，允许你执行一些副作用的东西——在这种情况下，确保每当我们进入<em class="jp">等待输入</em>状态时，定时器都被重置。这样我们可以确保计时器总是从5点开始计时。</p><p id="6ca8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当挂起状态变为活动状态时，它会呈现<strong class="it hv"> <em class="jp">挂起</em> </strong>组件，这是一个相当简单的类组件，可以创建和销毁interval，并呈现新按钮。间隔每秒调用<strong class="it hv"> <em class="jp">状态机的<strong class="it hv"> <em class="jp">道具</em> </strong>中定义的<strong class="it hv"><em class="jp">decrease time left()</em></strong>函数。</em>T47】</strong></p><p id="1ab5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管对于<em class="jp">未决</em>来说，将状态转换到<em class="jp">完成</em>状态的机制略有不同。我们可以描述一个自动转换，而不是将<strong class="it hv"> <em class="jp">转换为</em> </strong>，它使用一个函数来决定是否改变状态。这些类型的转换可以通过<strong class="it hv"> <em class="jp">自动转换</em> </strong>键在状态中定义。</p><p id="c58e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其余的状态只是使用这些不同类型的转换逻辑的组合。</p><h2 id="2530" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">利益</h2><p id="7726" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">那么，用这种方式建模组件会有什么好处呢？首先，你肯定<strong class="it hv">知道</strong>你不可能到达一个你没有明确定义的状态。考虑一下，因为这是一个很大的想法。拥有这样的状态机实质上消除了您必须测试的一整类错误。</p><p id="554f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在此基础上，因为您显式地定义了这个数据结构，所以您可以使用它来生成关于组件的信息。取下面的函数:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ml mk l"/></div></figure><p id="227a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这会产生以下对象(显示为JSON):</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ml mk l"/></div></figure><p id="2ffa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以使用这些信息来为您的组件生成状态图。这是不言自明的。</p><p id="5f37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在假设您在生产站点上启用了日志记录。您可以轻松地编写一个状态机来记录每个状态变化，为您提供追溯到任何错误来源的线索。</p><p id="fcf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，对业务逻辑中需求的更改通常可以干净地添加进来。假设我们需要添加一个新的行为，当用户在时钟还剩1秒的时候点击按钮。我们不需要简单地进入<em class="jp">中止</em>状态，而是需要进入<em class="jp">接近</em>状态。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ml mk l"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Doesn’t take much to account for new requirements</figcaption></figure><h2 id="1e6b" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">结论</h2><p id="6ba1" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">如果你发现自己因为<strong class="it hv"> if语句</strong>的奇怪组合而开发bug，考虑使用<strong class="it hv">有限状态机</strong>来实现组件。你现在就可以在React中用<strong class="it hv"> react-machinery </strong>(只有2kb gzipped！).状态机将帮助您更有效地对组件的工作进行建模、推理和交流。</p></div><div class="ab cl kd ke hc kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hn ho hp hq hr"><p id="b886" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">如果您对此感兴趣，请留下👏或者两个。在github </em>  <em class="jp">上查看</em> <a class="ae jq" href="https://github.com/francisrstokes/React-Machinery" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> React-Machinery的代码，并在那里或Twitter</em></a><a class="ae jq" href="http://twitter.com/fstokesman" rel="noopener ugc nofollow" target="_blank"><em class="jp">@ fstokesman</em></a><em class="jp">上给我反馈。</em></p></div></div>    
</body>
</html>