<html>
<head>
<title>Why we choose Kotlin for creating Android apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们选择Kotlin来创建Android应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-we-choose-kotlin-for-creating-android-apps-46030b10d19c?source=collection_archive---------9-----------------------#2018-07-05">https://medium.com/hackernoon/why-we-choose-kotlin-for-creating-android-apps-46030b10d19c?source=collection_archive---------9-----------------------#2018-07-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e2d84511126dcf1856e2309595794db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emxs5NVF2atEmfy922YlBQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Me, trying to convince Android team to use Kotlin</figcaption></figure><p id="2a86" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">大约两年前，我们的团队决定尝试一些新东西:完全用JetBrains的一种T2编程语言Kotlin T1开发一个商业应用程序。当时，我们有过Kotlin的经验，但规模要小得多:将应用程序的某些部分转换成一种新语言，或者在自己喜欢的项目上尝试。然而，用新的编程语言开发商业应用程序会带来一些困难:</p><ul class=""><li id="dd57" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated">我们深深扎根于基于Java的Android开发。切换到Kotlin相当困难，尤其是对于没有函数式编程经验的开发人员来说</li><li id="f0ae" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated">有些东西就是不行。匕首在盒子外面并不好用</li></ul><p id="aba3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所有这些都可能导致错过交付日期和应用程序的稳定性问题。</p><p id="35ca" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一个人应该有强烈的动机去完成转变。我们的动机是相信<strong class="ji hv">科特林将成为Android平台开发的游戏改变者。这很有趣。</strong></p></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><p id="21d4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">保持Kotlin参考开放，我们开始开发<a class="ae ke" href="https://uptech.team/#portfolio" rel="noopener ugc nofollow" target="_blank">选民应用程序。Kotlin是一种具有100% Java互操作性的JVM语言，如果你熟悉Java，学习Kotlin很容易。然而，如果你想充分利用这种语言，理解函数式编程的概念是必不可少的。</a></p><blockquote class="la lb lc"><p id="3959" class="jg jh ld ji b jj jk jl jm jn jo jp jq le js jt ju lf jw jx jy lg ka kb kc kd hn dt translated">学习函数式编程需要一段时间。所以要有耐心。</p></blockquote><p id="3a3f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">而函数式编程并不容易。至少在开始的时候。直到它变得有趣。我强烈建议参加Martin Ordersky的<a class="ae ke" href="https://www.coursera.org/specializations/scala" rel="noopener ugc nofollow" target="_blank">系列课程“Scala中的函数式编程”。Scala有时让人不知所措，但它很好地概述了新的函数式编程思维。你可以把Kotlin看作是Scala的一个更简单的版本。</a></p><h1 id="1b28" class="lh li hu bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me dt translated">是什么让我们转向科特林一边</h1><h2 id="05ae" class="mf li hu bd lj mg mh mi ln mj mk ml lr jr mm mn lv jv mo mp lz jz mq mr md ms dt translated">功能性编程风格</h2><p id="25ba" class="pw-post-body-paragraph jg jh hu ji b jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz nf kb kc kd hn dt translated">Kotlin与Java 100%互操作。此外，Kotlin是一种函数式语言。后者允许编写更优雅、更有表现力的代码。</p><ol class=""><li id="44e2" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd ng kl km kn dt translated"><strong class="ji hv">功能纯度</strong></li></ol><p id="1f08" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">纯函数的概念<strong class="ji hv"> </strong>(一个没有副作用的函数)是最重要的函数概念，它允许我们极大地降低代码的复杂性并摆脱大多数可变状态。</p><blockquote class="la lb lc"><p id="460d" class="jg jh ld ji b jj jk jl jm jn jo jp jq le js jt ju lf jw jx jy lg ka kb kc kd hn dt translated">在Javascript、Java、C#等命令式编程语言中，副作用无处不在。这使得调试非常困难，因为变量可以在程序中的任何地方更改。那么当你因为一个变量在错误的时间被改成了错误的值而出现bug的时候，你去哪里找呢？到处都是？这可不好。</p></blockquote><p id="1fd4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意我们是如何在不改变数据内容的情况下操作数据的。</p><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="9f29" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 2。高阶函数</strong></p><blockquote class="la lb lc"><p id="b81f" class="jg jh ld ji b jj jk jl jm jn jo jp jq le js jt ju lf jw jx jy lg ka kb kc kd hn dt translated">高阶函数要么将函数作为参数，要么作为返回函数，要么两者都是。</p></blockquote><p id="e230" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">高阶函数无处不在。您只需将函数传递给集合，使代码易于阅读。读起来像简单的英语。是不是很奇妙？</p><p id="c8ed" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们设想一种情况，我们想要统计不同类型的未读消息的数量。典型的方法是:</p><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="1131" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如您所见，随着新需求的引入，代码变得不可读和不可管理。让我们看看如何用高阶函数解决这个问题:</p><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="d396" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以想象这样的用例，我们想要参数化<code class="eh nn no np nq b">fold</code>函数参数，比方说，用于计算未读消息的乘积。</p><p id="75a2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用高阶函数的另一个例子是用简单的高阶函数替换大量的监听器:</p><pre class="nh ni nj nk fq nr nq ns nt aw nu dt"><span id="f0bb" class="mf li hu nq b fv nv nw l nx ny">BillingView : LinearLayout {</span><span id="f93c" class="mf li hu nq b fv nz nw l nx ny">var billingChangeListener: (() -&gt; Unit)? = null<br/>...</span><span id="8441" class="mf li hu nq b fv nz nw l nx ny">}</span><span id="3216" class="mf li hu nq b fv nz nw l nx ny">... // in an activity far, far away<br/>billingView.billingChangeListener { updateUI() }</span></pre><p id="208f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 3。不变性<br/> </strong>不变性使代码更容易编写、使用和推理(类不变量建立一次，然后不变)。你的应用组件的内部状态会更加一致。Kotlin通过引入<code class="eh nn no np nq b">val</code>关键字和Kotlin集合来增强不变性，缺省情况下kot Lin集合是不可变的。一旦<code class="eh nn no np nq b">val</code>或集合被初始化，你就可以确定它的有效性。(关于<code class="eh nn no np nq b">val</code>关键词的更准确定义，见UPD)。</p><pre class="nh ni nj nk fq nr nq ns nt aw nu dt"><span id="7fd0" class="mf li hu nq b fv nv nw l nx ny">data class Address(val line1: String, val city: String)</span><span id="ed54" class="mf li hu nq b fv nz nw l nx ny"><strong class="nq hv">val</strong> items = listOf(Address("242 5th St", "Los Angeles"),   Address("Dovzhenka St. 5", "Kiev"))</span></pre><h2 id="52e8" class="mf li hu bd lj mg mh mi ln mj mk ml lr jr mm mn lv jv mo mp lz jz mq mr md ms dt translated">零安全</h2><p id="6b78" class="pw-post-body-paragraph jg jh hu ji b jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz nf kb kc kd hn dt translated">这个语言特性让我们仔细考虑模型类中字段的可空性。以前，您不能确定DTO中的字段是否已初始化，@Nullable和@NotNull注释会有所帮助，但作用不大。现在，有了Kotlin，您可以精确地知道什么字段可以为空，什么字段稍后被初始化(例如由Dagger注入的字段)，并且您可以对这些字段进行严格的控制。结果？几乎没有<code class="eh nn no np nq b">NullPointerExceptions</code>。(我们内部称<code class="eh nn no np nq b">?.</code>为<a class="ae ke" href="https://pixabay.com/static/uploads/photo/2014/05/26/11/23/swan-354448_960_720.jpg" rel="noopener ugc nofollow" target="_blank">鹅</a>运算符，因为它看起来像鹅的脖子)</p><pre class="nh ni nj nk fq nr nq ns nt aw nu dt"><span id="7a88" class="mf li hu nq b fv nv nw l nx ny">brand?.let { badge.enabled = brand.isNewBadge }<br/>// Can also be written as <br/>badge.enabled = brand?.isNewBadge?:false</span></pre><h2 id="888d" class="mf li hu bd lj mg mh mi ln mj mk ml lr jr mm mn lv jv mo mp lz jz mq mr md ms dt translated">安科</h2><p id="3fd2" class="pw-post-body-paragraph jg jh hu ji b jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz nf kb kc kd hn dt translated">Anko DSL是一个很棒的库，它极大地简化了视图、线程和android生命周期的工作。Github的描述称Anko是“令人愉快的Android应用程序开发”,事实也确实如此。</p><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="d130" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">注意，当在Activity内部调用<code class="eh nn no np nq b">uiThread</code>时，如果<code class="eh nn no np nq b">isFinishing</code>是<code class="eh nn no np nq b">true</code>，那么这个块将不会执行。我们实际上并不使用这个特性，因为RxJava处理我们应用程序中的所有线程，但这是一个很好的特性。</p><p id="0e35" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">用Anko代替XML </strong>。虽然Anko还没有准备好取代标准的Android UI构建，但有时它非常方便。</p><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="8c49" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如你所见，Anko DSL允许你在Android内置视图旁边使用自定义视图。这就是它比标准XML更有优势的地方。</p><h2 id="8e81" class="mf li hu bd lj mg mh mi ln mj mk ml lr jr mm mn lv jv mo mp lz jz mq mr md ms dt translated">Kotlin Android扩展:移除ButterKnife依赖</h2><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="720b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">无聊了没？我打赌你没看就滚动了。在科特林，你不需要这些。您可以通过@id XML参数引用视图属性，这些属性的名称将与XML文件中声明的名称相同。更多信息可在<a class="ae ke" href="https://kotlinlang.org/docs/tutorials/android-plugin.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>中找到。</strong></p><h2 id="33f6" class="mf li hu bd lj mg mh mi ln mj mk ml lr jr mm mn lv jv mo mp lz jz mq mr md ms dt translated">其他简洁的功能</h2><ol class=""><li id="2ffc" class="kf kg hu ji b jj nb jn nc jr oa jv ob jz oc kd ng kl km kn dt translated"><strong class="ji hv">扩展功能&amp;构建器</strong></li></ol><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure><p id="b29c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh nn no np nq b">apply</code>、<code class="eh nn no np nq b">let</code>和扩展函数可以很容易地用来创建优雅的构建器。</p><p id="9bae" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 2。在最初的几天里，你经常会遇到一个问题:你不知道如何用Kotlin编写一个相当简单的Java表达式。<br/>一个简单的窍门是用Java写一段代码，然后粘贴到Kotlin文件中。多亏了JetBrains里的人，它被自动转换成Kotlin。Hacky，但工作像一个魅力！</strong></p><p id="c016" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 3。摆脱不必要的依赖<br/> </strong> Kotlin替代了很多第三方库，比如ButterKnife、Google Autovalue、Retrolambda、Lombok和一些RxJava代码。</p><h1 id="5e2c" class="lh li hu bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me dt translated">摘要</h1><p id="6d18" class="pw-post-body-paragraph jg jh hu ji b jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz nf kb kc kd hn dt translated">作为一个软件开发团队，我们面临的主要挑战是交付优秀的产品和有效地完成工作。虽然要开始在Kotlin中有效地开发，您需要一些函数式编程的先决知识，但是投入时间学习它确实会有回报。我相信Kotlin是对传统Android开发的一个重大改进，它允许我们按时交付优秀的应用程序，并且错误少得多。</p><p id="5bfa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请随意提问，我们将乐意帮助其他人完成过渡。在下面分享你的想法/评论吧！</p><blockquote class="la lb lc"><p id="e31a" class="jg jh ld ji b jj jk jl jm jn jo jp jq le js jt ju lf jw jx jy lg ka kb kc kd hn dt translated">穿着衣服编程是你能得到的最大乐趣。</p><p id="354b" class="jg jh ld ji b jj jk jl jm jn jo jp jq le js jt ju lf jw jx jy lg ka kb kc kd hn dt translated">约翰·古塔格</p></blockquote><p id="15e2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ld"> UPD: </em> <code class="eh nn no np nq b"><em class="ld">val</em></code> <em class="ld">实际上并不是指‘不可变’，而是指‘只读’。详见</em> <a class="ae ke" href="https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/" rel="noopener ugc nofollow" target="_blank"> <em class="ld">本文</em> </a> <em class="ld">。</em></p><blockquote class="od"><p id="e80c" class="oe of hu bd og oh oi oj ok ol om kd ek translated">这篇文章最初发表在<a class="ae ke" href="http://blog.uptech.team" rel="noopener ugc nofollow" target="_blank"> UPTech团队博客</a>上。关注我们，获取更多关于如何构建优秀产品的文章💪</p></blockquote><p id="08f9" class="pw-post-body-paragraph jg jh hu ji b jj on jl jm jn oo jp jq jr op jt ju jv oq jx jy jz or kb kc kd hn dt translated"><strong class="ji hv">参考文献</strong></p><ol class=""><li id="47b3" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd ng kl km kn dt translated"><a class="ae ke" href="https://kotlinlang.org/docs/reference/" rel="noopener ugc nofollow" target="_blank">科特林参考</a></li><li id="61b1" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd ng kl km kn dt translated"><a class="ae ke" rel="noopener" href="/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536#.8cmkitum2">所以你想成为一名函数式程序员</a></li><li id="5d26" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd ng kl km kn dt translated"><a class="ae ke" href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf" rel="noopener ugc nofollow" target="_blank">为什么函数式编程很重要</a></li><li id="53a7" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd ng kl km kn dt translated"><a class="ae ke" href="https://www.linkedin.com/pulse/20140528113353-16837833-6-benefits-of-programming-with-immutable-objects-in-java" rel="noopener ugc nofollow" target="_blank">用Java不可变对象编程的6个好处</a></li><li id="d7f7" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd ng kl km kn dt translated"><a class="ae ke" href="http://maximomussini.com/posts/anko-vs-android-xml/" rel="noopener ugc nofollow" target="_blank">Anko DSL vs Android XML-First</a></li><li id="a12e" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd ng kl km kn dt translated"><a class="ae ke" rel="noopener" href="/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6#.jkxs39qko">将应用程序转换成100% Kotlin的经验教训</a></li><li id="fbb6" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd ng kl km kn dt translated"><a class="ae ke" href="https://play.google.com/store/apps/details?id=app.voter.xyz&amp;hl=en" rel="noopener ugc nofollow" target="_blank">结果:选民申请</a>。99.8%无崩溃用户。</li><li id="4095" class="kf kg hu ji b jj ko jn kp jr kq jv kr jz ks kd ng kl km kn dt translated">Kotlin: val并不意味着不可变，它只是意味着只读</li></ol><figure class="nh ni nj nk fq iv"><div class="bz el l di"><div class="os nm l"/></div></figure></div></div>    
</body>
</html>