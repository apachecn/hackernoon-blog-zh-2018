<html>
<head>
<title>Using MongoDB as a realtime database with change streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB作为包含变更流的实时数据库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-mongodb-as-a-realtime-database-with-change-streams-213cba1dfc2a?source=collection_archive---------1-----------------------#2018-07-06">https://medium.com/hackernoon/using-mongodb-as-a-realtime-database-with-change-streams-213cba1dfc2a?source=collection_archive---------1-----------------------#2018-07-06</a></blockquote><div><div class="eg hj hk hl hm hn"/><div class="ho hp hq hr hs"><div class=""/><blockquote class="is it iu"><p id="4d93" class="iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ho dt translated">本文原载于<a class="ae ju" href="https://pusher.com/tutorials/mongodb-change-streams" rel="noopener ugc nofollow" target="_blank"> Pusher的博客</a>。</p><p id="2e87" class="iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ho dt translated">我们的每周赞助商<a class="ae ju" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hw"> Pusher </strong> </a>，在易于集成的web、移动和最受欢迎的后端堆栈SDK的支持下，开发通信和协作API，为世界各地的应用提供支持。<a class="ae ju" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hw">入门。</strong>T9】</a></p></blockquote><p id="b9f7" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">从数据库中实时获取数据变化并不像您想象的那么简单。</p><p id="6089" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated"><a class="ae ju" href="https://pusher.com/tutorials/realtime-mysql-java" rel="noopener ugc nofollow" target="_blank">在之前的教程</a>中，我提到有三种主要方法可以做到这一点:</p><ul class=""><li id="a0b2" class="jy jz hv iy b iz ja jd je jv ka jw kb jx kc jt kd ke kf kg dt translated">每隔X秒轮询一次数据库，并使用时间戳、版本号或状态字段确定是否发生了变化。</li><li id="e728" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">当发生变化时，使用数据库或应用程序级触发器来执行一段代码。</li><li id="1fb9" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">使用数据库事务/复制日志，它记录数据库的每次更改。</li></ul><p id="488a" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">然而，在MongoDB中，<a class="ae ju" href="https://docs.mongodb.com/manual/changeStreams/" rel="noopener ugc nofollow" target="_blank"> change streams </a>允许您在没有任何复杂性的情况下监听集合中的变化。</p><p id="394b" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">更改流从MongoDB 3.6开始可用，它们通过读取<a class="ae ju" href="https://docs.mongodb.com/manual/reference/glossary/#term-oplog" rel="noopener ugc nofollow" target="_blank">操作日志</a>来工作，这是一个有上限的集合，其中写入了对数据的所有更改，并充当数据库复制日志。</p><p id="c267" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">在本教程中，您将学习如何使用Node.js服务器将MongoDB数据库中的集合更改实时传输到React应用程序。</p><p id="d41b" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">您将要构建的应用程序允许您添加和删除任务。看起来是这样的:</p><figure class="kn ko kp kq fr kr ff fg paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="ff fg km"><img src="../Images/2e184a998aef1d07cc5aaa36de9c5043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8EeaeGh0jPmYbWxR.gif"/></div></div></figure><p id="5fed" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">在幕后，它与Node.js中实现的API进行通信，将更改保存到数据库中。Node.js脚本也使用更改流接收这些更改，解析它们并将其发布到Pusher通道，以便React应用程序可以使用它们。</p><p id="0876" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">下图描述了上述过程:</p><figure class="kn ko kp kq fr kr ff fg paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="ff fg ky"><img src="../Images/aa1978c4d74d10d56af5df7eee10b65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bp1hwCkpvsqJaj-g.png"/></div></div></figure><p id="3e83" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">当然，多个应用程序写入同一个数据库的场景可能更现实，但是出于学习的目的，我将使用一个简单的应用程序。</p><p id="d9d4" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">此外，您将看到像这样的解决方案如何成为Firebase实时数据库功能的良好替代方案。</p><h1 id="2380" class="kz la hv bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">先决条件</h1><p id="3a8e" class="pw-post-body-paragraph iv iw hv iy b iz lx jb jc jd ly jf jg jv lz jj jk jw ma jn jo jx mb jr js jt ho dt translated">按照本教程，您需要安装以下内容:</p><ul class=""><li id="435c" class="jy jz hv iy b iz ja jd je jv ka jw kb jx kc jt kd ke kf kg dt translated">MongoDB(3.6版或更高版本)</li><li id="c164" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> (6或以上)</li><li id="f396" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">可选地，JavaScript编辑器。</li></ul><p id="636d" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">你需要了解:</p><ul class=""><li id="092d" class="jy jz hv iy b iz ja jd je jv ka jw kb jx kc jt kd ke kf kg dt translated">JavaScript(中级)，特别是Node.js和React。</li><li id="5130" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">基本MongoDB管理任务</li></ul><p id="52eb" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">作为参考，<a class="ae ju" href="https://github.com/eh3rrera/realtime-mongodb-pusher" rel="noopener ugc nofollow" target="_blank">这里有一个GitHub库</a>，包含本教程中显示的所有代码和运行它的指令。</p><p id="be85" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">现在让我们从创建一个Pusher应用程序开始。</p><h1 id="ec47" class="kz la hv bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">创建推送应用程序</h1><p id="6d83" class="pw-post-body-paragraph iv iw hv iy b iz lx jb jc jd ly jf jg jv lz jj jk jw ma jn jo jx mb jr js jt ho dt translated">如果你还没有，在<a class="ae ju" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank">按钮</a>创建一个免费账户。</p><p id="eba4" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">然后，转到您的<a class="ae ju" href="https://dashboard.pusher.com/" rel="noopener ugc nofollow" target="_blank">仪表板</a>并创建一个Channels应用程序，选择一个名称、离您位置最近的集群，并且可选地，React作为前端技术，Node.js作为后端技术:</p><figure class="kn ko kp kq fr kr ff fg paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="ff fg mc"><img src="../Images/fdf104a31cda0eaa739db621ea2de404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KbFviFTHoFWukc06.png"/></div></div></figure><p id="4f97" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">这将为您提供一些开始使用的示例代码:</p><figure class="kn ko kp kq fr kr ff fg paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="ff fg md"><img src="../Images/6dcd55c72d86f52e99e94c77f63b76a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*anWvx6z1ED1hCCJL.png"/></div></div></figure><p id="4ca1" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">保存你的应用id、密钥、密码和聚类值。我们以后会需要它们。</p><h1 id="bf07" class="kz la hv bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">配置MongoDB</h1><p id="6e60" class="pw-post-body-paragraph iv iw hv iy b iz lx jb jc jd ly jf jg jv lz jj jk jw ma jn jo jx mb jr js jt ho dt translated">因为变更流使用MongoDB的操作日志，并且操作日志用于支持该数据库的复制特性，所以您只能使用带有<a class="ae ju" href="https://docs.mongodb.com/manual/replication/" rel="noopener ugc nofollow" target="_blank">副本集</a>或<a class="ae ju" href="https://docs.mongodb.com/manual/sharding/" rel="noopener ugc nofollow" target="_blank">分片集群</a>的变更流。</p><p id="6273" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">使用副本集更容易，所以我们走那条路。</p><p id="2480" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">副本集是一组维护相同数据集的<code class="ei me mf mg mh b">mongod</code>进程。但是，您可以只使用一台服务器创建副本集，只需执行以下命令:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="9fbc" class="mm la hv mh b fw mn mo l mp mq">mongod --replSet "rs"</span></pre><p id="1ce4" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">请记住，如果您不使用默认数据目录(<code class="ei me mf mg mh b">/data/db</code>或<code class="ei me mf mg mh b">c:\data\db</code>)，请使用<code class="ei me mf mg mh b">--dbpath</code>选项指定数据目录的路径:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="866a" class="mm la hv mh b fw mn mo l mp mq">mongod --dbpath &lt;DATA_PATH&gt; --replSet "rs"</span></pre><p id="0169" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">接下来，在一个单独的终端窗口中，运行MongoDB客户端<code class="ei me mf mg mh b">mongo</code>。</p><p id="6747" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">如果这是您第一次创建副本集，执行<code class="ei me mf mg mh b">rs.initiate()</code>:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="ba83" class="mm la hv mh b fw mn mo l mp mq">eh@eh:~/Documents/mongodb-linux-x86_64-3.6.4$ bin/mongo<br/>MongoDB shell version v3.6.4<br/>connecting to: mongodb://127.0.0.1:27017<br/>MongoDB server version: 3.6.4<br/>...<br/>&gt; rs.initiate()<br/>{<br/>    "info2" : "no configuration specified. Using a default configuration for the set",<br/>    "me" : "localhost:27017",<br/>    "ok" : 1,<br/>    "operationTime" : Timestamp(1527258648, 1),<br/>    "$clusterTime" : {<br/>        "clusterTime" : Timestamp(1527258648, 1),<br/>        "signature" : {<br/>            "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),<br/>            "keyId" : NumberLong(0)<br/>        }<br/>    }<br/>}<br/>rs:OTHER&gt;</span></pre><p id="8724" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">应用程序将在名为<code class="ei me mf mg mh b">tasksDb</code>的数据库中观察集合<code class="ei me mf mg mh b">tasks</code>。</p><p id="3ef5" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">通常，数据库和集合是由MongoDB驱动程序在应用程序对它们执行第一个操作时创建的，但是对于变更流，它们必须在打开流之前存在。</p><p id="95de" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">因此，当您在<code class="ei me mf mg mh b">mongo</code>时，使用命令<code class="ei me mf mg mh b">use</code>和<code class="ei me mf mg mh b">db.createCollection</code>创建数据库和集合，如下所示:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="455e" class="mm la hv mh b fw mn mo l mp mq">rs:OTHER&gt; use tasksDb<br/>switched to db tasksDb<br/>rs:OTHER&gt; db.createCollection('tasks')<br/>{<br/>    "ok" : 1,<br/>    "operationTime" : Timestamp(1527266976, 1),<br/>    "$clusterTime" : {<br/>        "clusterTime" : Timestamp(1527266976, 1),<br/>        "signature" : {<br/>          "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),<br/>          "keyId" : NumberLong(0)<br/>        }<br/>    }<br/>}<br/>rs:OTHER&gt;</span></pre><p id="8264" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">现在您已经准备好开始构建应用程序了。</p><p id="8927" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">让我们从Node.js服务器开始。</p><h1 id="df39" class="kz la hv bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">构建Node.js服务器</h1><p id="0f7e" class="pw-post-body-paragraph iv iw hv iy b iz lx jb jc jd ly jf jg jv lz jj jk jw ma jn jo jx mb jr js jt ho dt translated">创建一个新目录，并在终端窗口中，在该目录中使用以下命令初始化Node.js项目:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="5aac" class="mm la hv mh b fw mn mo l mp mq">npm init -y</span></pre><p id="27b6" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">接下来，安装应用程序将要使用的依赖项:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="7eae" class="mm la hv mh b fw mn mo l mp mq">npm install --save body-parser express mongoose pusher</span></pre><ul class=""><li id="0657" class="jy jz hv iy b iz ja jd je jv ka jw kb jx kc jt kd ke kf kg dt translated"><a class="ae ju" href="https://github.com/expressjs/body-parser" rel="noopener ugc nofollow" target="_blank"> body-parser </a>是一个中间件，用于解析请求的主体。</li><li id="c6d9" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> express </a>为React应用将要使用的REST API创建web服务器。</li><li id="3103" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" href="http://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>是一个基于模式的库，用于使用MongoDB。</li><li id="4ace" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank">推送器</a>实时发布数据库变化。</li></ul><p id="8116" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">现在，我们要做的第一件事是为任务集合创建一个模式。创建文件<code class="ei me mf mg mh b">models/task.js</code>并复制以下代码:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="6003" class="mm la hv mh b fw mn mo l mp mq">const mongoose = require('mongoose');  <br/>const Schema   = mongoose.Schema;<br/><br/>const taskSchema = new Schema({ <br/>  task: { type: String },<br/>});<br/><br/>module.exports = mongoose.model('Task', taskSchema);</span></pre><p id="10fa" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">如您所见，该集合只将任务存储为文本。</p><p id="33cb" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">接下来，创建文件<code class="ei me mf mg mh b">routes/api.js</code>并需要任务模式和Express来创建路由器:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="cb69" class="mm la hv mh b fw mn mo l mp mq">const Task  = require('../models/task');<br/>const express = require('express');<br/>const router = express.Router();</span></pre><p id="7f71" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">使用<code class="ei me mf mg mh b">/new</code>路径创建一个<code class="ei me mf mg mh b">POST</code>端点来保存任务:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="79aa" class="mm la hv mh b fw mn mo l mp mq">router.post('/new', (req, res) =&gt; {<br/>    Task.create({<br/>        task: req.body.task,<br/>    }, (err, task) =&gt; {<br/>        if (err) {<br/>          console.log('CREATE Error: ' + err);<br/>          res.status(500).send('Error');<br/>        } else {<br/>          res.status(200).json(task);<br/>        }<br/>    });<br/>});</span></pre><p id="2deb" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">另一个用来删除任务，使用一个<code class="ei me mf mg mh b">DELETE</code>方法传递任务的ID:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="0740" class="mm la hv mh b fw mn mo l mp mq">router.route('/:id')<br/>    <em class="ix">/* DELETE */</em><br/>    .delete((req, res) =&gt; {<br/>        Task.findById(req.params.id, (err, task) =&gt; {<br/>          if (err) { <br/>            console.log('DELETE Error: ' + err);<br/>            res.status(500).send('Error');<br/>          } else if (task) {<br/>            task.remove( () =&gt; {<br/>              res.status(200).json(task);<br/>            });<br/>          } else {<br/>            res.status(404).send('Not found');<br/>          }<br/>        });<br/>    });<br/><br/>module.exports = router;</span></pre><p id="ee46" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">现在，在根目录中，创建文件<code class="ei me mf mg mh b">server.js</code>并需要以下模块:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="07c4" class="mm la hv mh b fw mn mo l mp mq">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const mongoose = require('mongoose');<br/>const api = require('./routes/api');<br/>const Pusher = require('pusher');</span></pre><p id="a235" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">输入您的应用程序信息，配置推送器对象:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="ede1" class="mm la hv mh b fw mn mo l mp mq">const pusher = new Pusher({<br/>  appId      : '&lt;INSERT_APP_ID&gt;',<br/>  key        : '&lt;INSERT_APP_KEY&gt;',<br/>  secret     : '&lt;INSERT_APP_SECRET&gt;',<br/>  cluster    : '&lt;INSERT_APP_CLUSTER&gt;',<br/>  encrypted  : true,<br/>});<br/>const channel = 'tasks';</span></pre><p id="129d" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">用CORS头(因为React应用程序将在不同的端口发布)、JSON请求和作为路径的<code class="ei me mf mg mh b">/api</code>配置一个Express服务器:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="4d60" class="mm la hv mh b fw mn mo l mp mq">const app = express();<br/><br/>app.use((req, res, next) =&gt; {<br/>  res.header("Access-Control-Allow-Origin", "*");<br/>  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");<br/>  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");<br/>  next();<br/>});<br/><br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>app.use('/api', api);</span></pre><p id="4dc7" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">这样，您就可以通过之前配置的副本集的名称连接到数据库:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="2bea" class="mm la hv mh b fw mn mo l mp mq">mongoose.connect('mongodb://localhost/tasksDb?replicaSet=rs');</span></pre><p id="2c55" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">并设置两个回调，一个用于连接错误，另一个用于连接成功时:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="522a" class="mm la hv mh b fw mn mo l mp mq">const db = mongoose.connection;<br/><br/>db.on('error', console.error.bind(console, 'Connection Error:'));<br/><br/>db.once('open', () =&gt; {<br/><br/>});</span></pre><p id="e6b6" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">如果连接成功，让我们开始监听端口9000上的连接，并观察<code class="ei me mf mg mh b">tasks</code>集合上的变化:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="09a4" class="mm la hv mh b fw mn mo l mp mq">db.once('open', () =&gt; {<br/>  app.listen(9000, () =&gt; {<br/>    console.log('Node server running on port 9000');<br/>  });<br/><br/>  const taskCollection = db.collection('tasks');<br/>  const changeStream = taskCollection.watch();<br/><br/>  changeStream.on('change', (change) =&gt; {<br/><br/>  });<br/>});</span></pre><p id="76ee" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">有趣的部分来了。</p><p id="0d02" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">当集合中有更改时，会收到一个更改事件。特别是，支持以下更改:</p><ul class=""><li id="d223" class="jy jz hv iy b iz ja jd je jv ka jw kb jx kc jt kd ke kf kg dt translated">插入</li><li id="d07c" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">更新</li><li id="3b20" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">替换</li><li id="0907" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">删除</li><li id="a1de" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">使无效</li></ul><p id="8d05" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">下面是一个插入事件的示例:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="6d5b" class="mm la hv mh b fw mn mo l mp mq">{<br/>  _id: <br/>  {<br/>    _data: Binary {<br/>      _bsontype: 'Binary',<br/>      sub_type: 0,<br/>      position: 49,<br/>      buffer: &lt;Buffer 82 5b 08 8a 2a 00 00 00 01 46 64 5f 69 64 00 64 5b 08 8a 2a 99 a1 c5 0d 65 f4 c4 4f 00 5a 10 04 13 79 9a 22 35 5b 45 76 ba 45 6a f0 69 81 60 af 04&gt; <br/>    }<br/>  },<br/>  operationType: 'insert',<br/>  fullDocument: { <br/>    _id: 5b088a2a99a1c50d65f4c44f, <br/>    task: 'my task', <br/>    __v: 0<br/>  },<br/>  ns: { db: 'tasksDb', coll: 'tasks' },<br/>  documentKey: { _id: 5b088a2a99a1c50d65f4c44f } <br/>}</span></pre><p id="5c0f" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">您可以使用<code class="ei me mf mg mh b">_id</code>属性来<a class="ae ju" href="https://docs.mongodb.com/manual/changeStreams/#resume-a-change-stream" rel="noopener ugc nofollow" target="_blank">恢复一个变更流</a>，换句话说，开始从该属性所表示的操作中接收事件。</p><p id="1abc" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">下面是一个删除事件的示例:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="30dd" class="mm la hv mh b fw mn mo l mp mq">{ <br/>  _id: <br/>  { <br/>    _data: Binary {<br/>      _bsontype: 'Binary',<br/>      sub_type: 0,<br/>      position: 49,<br/>      buffer: &lt;Buffer 82 5b 08 8b f6 00 00 00 01 46 64 5f 69 64 00 64 5b 08 8a 2a 99 a1 c5 0d 65 f4 c4 4f 00 5a 10 04 13 79 9a 22 35 5b 45 76 ba 45 6a f0 69 81 60 af 04&gt; <br/>    }<br/>  },<br/>  operationType: 'delete',<br/>  ns: { db: 'tasksDb', coll: 'tasks' },<br/>  documentKey: { _id: 5b088a2a99a1c50d65f4c44f }<br/>}</span></pre><p id="49d1" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">注意，在这种情况下，被删除的对象没有被返回，只有它在<code class="ei me mf mg mh b">documentKey</code>属性中的ID。</p><p id="0a63" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">你可以在这里了解更多关于这些<a class="ae ju" href="https://docs.mongodb.com/manual/reference/change-events/" rel="noopener ugc nofollow" target="_blank">变化事件的信息。</a></p><p id="6f40" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">有了这些信息，回到<code class="ei me mf mg mh b">server.js</code>，您可以从对象中提取相关数据，并通过以下方式将其发布给Pusher:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="5b75" class="mm la hv mh b fw mn mo l mp mq">changeStream.on('change', (change) =&gt; {<br/>    console.log(change);</span><span id="48e9" class="mm la hv mh b fw mr mo l mp mq">    if(change.operationType === 'insert') {<br/>      const task = change.fullDocument;<br/>      pusher.trigger(<br/>        channel,<br/>        'inserted', <br/>        {<br/>          id: task._id,<br/>          task: task.task,<br/>        }<br/>      ); <br/>    } else if(change.operationType === 'delete') {<br/>      pusher.trigger(<br/>        channel,<br/>        'deleted', <br/>        change.documentKey._id<br/>      );<br/>    }<br/>});</span></pre><p id="ba0f" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">这是服务器的代码。现在让我们构建React应用程序。</p><h1 id="6cf5" class="kz la hv bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">构建React应用程序</h1><p id="4b76" class="pw-post-body-paragraph iv iw hv iy b iz lx jb jc jd ly jf jg jv lz jj jk jw ma jn jo jx mb jr js jt ho dt translated">让我们使用<a class="ae ju" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>来引导一个react应用。</p><p id="bf8c" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">在另一个目录中，在终端窗口中执行以下命令来创建新的应用程序:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="e8d6" class="mm la hv mh b fw mn mo l mp mq">npx create-react-app my-app</span></pre><p id="a574" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">现在进入app目录，用<code class="ei me mf mg mh b">npm</code>安装所有Pusher依赖项:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="15e8" class="mm la hv mh b fw mn mo l mp mq">cd my-app<br/>npm install --save pusher-js</span></pre><p id="670e" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">打开文件<code class="ei me mf mg mh b">src/App.css</code>，用下面的CSS样式替换它的内容:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="4813" class="mm la hv mh b fw mn mo l mp mq">*{<br/>  box-sizing: border-box;<br/>}</span><span id="6c4a" class="mm la hv mh b fw mr mo l mp mq">body {<br/>  font-size: 15px;<br/>  font-family: 'Open Sans', sans-serif;<br/>  color: #444;<br/>  background-color: #300d4f;<br/>  padding: 50px 20px;<br/>  margin: 0;<br/>  min-height: 100vh;<br/>  position: relative;<br/>}</span><span id="ca26" class="mm la hv mh b fw mr mo l mp mq">.todo-wrapper {<br/>  width: 400px;<br/>  max-width: 100%;<br/>  min-height: 500px;<br/>  margin: 20px auto 40px;<br/>  border: 1px solid #eee;<br/>  border-radius: 4px;<br/>  padding: 40px 20px;<br/>  -webkit-box-shadow: 0 0 15px 0 rgba(0,0,0,0.05);<br/>  box-shadow: 0 0 15px 0 rgba(0,0,0,0.05);<br/>  background-color: #e9edf6;<br/>  overflow: hidden;<br/>  position: relative;<br/>}</span><span id="cb07" class="mm la hv mh b fw mr mo l mp mq">form {<br/>  overflow: overlay;<br/>}</span><span id="f6c5" class="mm la hv mh b fw mr mo l mp mq">.btn, input {<br/>  line-height: 2em;<br/>  border-radius: 3px;<br/>  border: 0;<br/>  display: inline-block;<br/>  margin: 15px 0;<br/>  padding: 0.2em 1em;<br/>  font-size: 1em;<br/>}</span><span id="b9df" class="mm la hv mh b fw mr mo l mp mq">input[type='text'] {<br/>  border: 1px solid #ddd; <br/>  min-width: 80%;<br/>}</span><span id="3851" class="mm la hv mh b fw mr mo l mp mq">input:focus {<br/>  outline: none;<br/>  border: 1px solid #a3b1ff;<br/>}</span><span id="cccd" class="mm la hv mh b fw mr mo l mp mq">.btn {<br/>  text-align: center;<br/>  font-weight: bold; <br/>  cursor: pointer;<br/>  border-width: 1px;<br/>  border-style: solid;<br/>}</span><span id="ab4d" class="mm la hv mh b fw mr mo l mp mq">.btn-add {<br/>  background: #00de72;<br/>  color: #fefefe;<br/>  min-width: 17%;<br/>  font-size: 2.2em;<br/>  line-height: 0.5em;<br/>  padding: 0.3em 0.3em;<br/>  float: right;<br/>}</span><span id="b05c" class="mm la hv mh b fw mr mo l mp mq">ul {<br/>  list-style: none;<br/>  padding: 0;<br/>}</span><span id="a8ca" class="mm la hv mh b fw mr mo l mp mq">li {<br/>    display: flex;<br/>    justify-content: space-between;<br/>    align-items: center;<br/>    margin-bottom: 5px;<br/>    background-color: #dee2eb;<br/>}</span><span id="d7a3" class="mm la hv mh b fw mr mo l mp mq">.text {<br/>  padding: 0.7em;<br/>}</span><span id="c22e" class="mm la hv mh b fw mr mo l mp mq">.delete {<br/>  padding: 0.3em 0.7em;<br/>  min-width: 17%;<br/>  background: #f56468;<br/>  color: white;<br/>  font-weight: bold;<br/>  cursor: pointer;<br/>  font-size: 2.2em;<br/>  line-height: 0.5em;<br/>}</span></pre><p id="319f" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">接下来，打开文件<code class="ei me mf mg mh b">src/App.js</code>，在顶部，导入推动器库:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="f2f7" class="mm la hv mh b fw mn mo l mp mq">import Pusher from 'pusher-js';</span></pre><p id="d699" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">为API URL定义一个常数:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="c0c7" class="mm la hv mh b fw mn mo l mp mq">const API_URL = 'http://localhost:9000/api/';</span></pre><p id="74b9" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">在类的构造函数中，将任务的数组和任务文本的属性定义为状态，并绑定方法以更新文本以及添加和删除任务:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="2048" class="mm la hv mh b fw mn mo l mp mq">class App extends Component {<br/>    constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      tasks: [],<br/>      task: ''<br/>    };<br/>    this.updateText = this.updateText.bind(this);<br/>    this.postTask = this.postTask.bind(this);<br/>    this.deleteTask = this.deleteTask.bind(this);<br/>    this.addTask = this.addTask.bind(this);<br/>    this.removeTask = this.removeTask.bind(this);<br/>  }<br/>  ...<br/>}</span></pre><p id="f7bd" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">让我们回顾一下每种方法。将它们添加在构造函数之后，在<code class="ei me mf mg mh b">render()</code>方法之前。</p><p id="0371" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated"><code class="ei me mf mg mh b">updateText</code>方法将在每次任务的输入文本改变时更新状态:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="031c" class="mm la hv mh b fw mn mo l mp mq">updateText(e) {<br/>    this.setState({ task: e.target.value });<br/>}</span></pre><p id="cd52" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated"><code class="ei me mf mg mh b">postTask</code>方法将用户输入的任务发布到API:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="1e80" class="mm la hv mh b fw mn mo l mp mq">postTask(e) {<br/>    e.preventDefault();<br/>    if (!this.state.task.length) {<br/>      return;<br/>    }<br/>    const newTask = {<br/>      task: this.state.task<br/>    };<br/>    fetch(API_URL + 'new', {<br/>      method: 'post',<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      },<br/>      body: JSON.stringify(newTask)<br/>    }).then(console.log);<br/>}</span></pre><p id="e3f4" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">方法<code class="ei me mf mg mh b">deleteTask</code>将调用API来删除使用其ID的任务:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="df90" class="mm la hv mh b fw mn mo l mp mq">deleteTask(id) {<br/>    fetch(API_URL + id, {<br/>      method: 'delete'<br/>    }).then(console.log);<br/>}</span></pre><p id="9fd0" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">另一方面，您还需要从状态中添加和删除任务的方法，以便更改可以反映在UI中。这就是方法<code class="ei me mf mg mh b">addTask</code>和<code class="ei me mf mg mh b">removeTask</code>的工作:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="284b" class="mm la hv mh b fw mn mo l mp mq">addTask(newTask) {<br/>    this.setState(prevState =&gt; ({<br/>      tasks: prevState.tasks.concat(newTask),<br/>      task: ''<br/>    }));<br/>}</span><span id="9cc7" class="mm la hv mh b fw mr mo l mp mq">removeTask(id) {<br/>    this.setState(prevState =&gt; ({<br/>      tasks: prevState.tasks.filter(el =&gt; el.id !== id)<br/>    }));<br/>}</span></pre><p id="45d9" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">当收到来自Pusher的相应事件时，app将调用这些方法。</p><p id="53ec" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">您可以设置Pusher并将这些方法绑定到方法<code class="ei me mf mg mh b">componentDidMount</code>中的<code class="ei me mf mg mh b">inserted</code>和<code class="ei me mf mg mh b">deleted</code>事件，输入您的Pusher app密钥和集群:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="75c4" class="mm la hv mh b fw mn mo l mp mq">componentDidMount() {<br/> this.pusher = new Pusher('&lt;INSERT_APP_KEY&gt;', {<br/>     cluster: '&lt;INSERT_APP_CLUSTER&gt;',<br/>     encrypted: true,<br/> });<br/> this.channel = this.pusher.subscribe('tasks');</span><span id="ffee" class="mm la hv mh b fw mr mo l mp mq"> this.channel.bind('inserted', this.addTask);<br/> this.channel.bind('deleted', this.removeTask);<br/>}</span></pre><p id="7181" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">通过这种方式，<code class="ei me mf mg mh b">render</code>方法只是使用一个<code class="ei me mf mg mh b">Task</code>组件和一个输入新任务的表单来呈现状态中的任务。</p><p id="1947" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">用以下方法替换<code class="ei me mf mg mh b">render()</code>方法:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="7cf0" class="mm la hv mh b fw mn mo l mp mq">render() {<br/>    let tasks = this.state.tasks.map(item =&gt;<br/>        &lt;Task key={item.id} task={item} onTaskClick={this.deleteTask} /&gt;<br/>    );<!-- --> </span><span id="48ce" class="mm la hv mh b fw mr mo l mp mq">    return (<br/>        &lt;div className="todo-wrapper"&gt;<br/>            &lt;form&gt;<br/>              &lt;input type="text" className="input-todo" placeholder="New task" onChange={this.updateText} value={this.state.task} /&gt;<br/>              &lt;div className="btn btn-add" onClick={this.postTask}&gt;+&lt;/div&gt;<br/>            &lt;/form&gt;</span><span id="c860" class="mm la hv mh b fw mr mo l mp mq">            &lt;ul&gt;<br/>              {tasks}<br/>            &lt;/ul&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="d44e" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">和<code class="ei me mf mg mh b">Task</code>组件的代码(可以放在<code class="ei me mf mg mh b">App</code>类之后):</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="63b4" class="mm la hv mh b fw mn mo l mp mq">class Task extends Component {<br/>    constructor(props) {<br/>      super(props);<br/>      this._onClick = this._onClick.bind(this);<br/>    }<br/>    _onClick() {<br/>      this.props.onTaskClick(this.props.task.id);<br/>    }<br/>    render() {<br/>      return (<br/>        &lt;li key={this.props.task.id}&gt;<br/>          &lt;div className="text"&gt;{this.props.task.task}&lt;/div&gt;<br/>          &lt;div className="delete" onClick={this._onClick}&gt;-&lt;/div&gt;<br/>        &lt;/li&gt;<br/>      );<br/>    }<br/>}</span></pre><p id="a9e2" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">仅此而已。让我们测试完整的应用程序。</p><h1 id="9629" class="kz la hv bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">测试应用程序</h1><p id="ef0f" class="pw-post-body-paragraph iv iw hv iy b iz lx jb jc jd ly jf jg jv lz jj jk jw ma jn jo jx mb jr js jt ho dt translated">确保MongoDB数据库在服务器上配置了副本集的情况下运行:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="1939" class="mm la hv mh b fw mn mo l mp mq">mongod --dbpath &lt;DATA_PATH&gt; --replSet "rs"</span></pre><p id="e76f" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">在终端窗口中，转到Node.js服务器所在的目录并执行:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="0bd6" class="mm la hv mh b fw mn mo l mp mq">node server.js</span></pre><p id="211c" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">对于React应用程序，在应用程序目录中，执行:</p><pre class="kn ko kp kq fr mi mh mj mk aw ml dt"><span id="8614" class="mm la hv mh b fw mn mo l mp mq">npm start</span></pre><p id="628c" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">将会打开一个浏览器窗口<a class="ae ju" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>，从这里，您可以开始输入和删除任务:</p><figure class="kn ko kp kq fr kr ff fg paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="ff fg km"><img src="../Images/bf2251a8cd7e9bcf5c1d222948bca1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1ycSMPHUc0FyKR47.gif"/></div></div></figure><p id="7d68" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">您还可以在Node.js服务器的输出中看到如何从MongoDB接收变更事件:</p><figure class="kn ko kp kq fr kr ff fg paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="ff fg ms"><img src="../Images/40f16ad23c3b2217c146a5dba36de0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p5YLN8oCiC8XAygT.gif"/></div></div></figure><p id="3b22" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">或者在<a class="ae ju" href="https://dashboard.pusher.com/" rel="noopener ugc nofollow" target="_blank">推进器的仪表板</a>上，选择你的应用，在调试部分，你会看到消息是如何被接收的:</p><figure class="kn ko kp kq fr kr ff fg paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="ff fg km"><img src="../Images/efd016db86c45c721d88c2e98e387553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X9rOAc-IN-ZNimLb.gif"/></div></div></figure><h1 id="f281" class="kz la hv bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">结论</h1><p id="22bf" class="pw-post-body-paragraph iv iw hv iy b iz lx jb jc jd ly jf jg jv lz jj jk jw ma jn jo jx mb jr js jt ho dt translated">在本教程中，您已经学习了如何在MongoDB中持久化数据，并使用变更流和推送通道实时传播变更</p><p id="958e" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">这相当于Firebase及其实时数据库提供的功能。这样做的好处是，像本教程中介绍的这种解决方案更加灵活，并且给您更多的控制。</p><p id="7c01" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">从这里开始，应用程序可以以多种方式进行扩展，例如:</p><ul class=""><li id="701c" class="jy jz hv iy b iz ja jd je jv ka jw kb jx kc jt kd ke kf kg dt translated">支持更多集合</li><li id="2b45" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">为任务实现更新功能(例如，状态)并复制此事件。</li><li id="abd8" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated">在连接失败后，使用resume令牌接收来自最后一个注册的事件。</li></ul><p id="685e" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">请记住，在<a class="ae ju" href="https://github.com/eh3rrera/realtime-mongodb-pusher" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中，您可以找到Node.js服务器和React应用程序的代码。</p><p id="4816" class="pw-post-body-paragraph iv iw hv iy b iz ja jb jc jd je jf jg jv ji jj jk jw jm jn jo jx jq jr js jt ho dt translated">有关变更流的更多信息，这里有一些好的资源:</p><ul class=""><li id="c6dc" class="jy jz hv iy b iz ja jd je jv ka jw kb jx kc jt kd ke kf kg dt translated"><a class="ae ju" href="https://www.mongodb.com/presentations/using-change-streams-to-keep-up-with-your-data" rel="noopener ugc nofollow" target="_blank">使用更改流来跟上您的数据</a></li><li id="7995" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" href="https://www.mongodb.com/blog/post/an-introduction-to-change-streams" rel="noopener ugc nofollow" target="_blank">更改流简介</a></li><li id="d47d" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" rel="noopener" href="/@thakkaryash94/mongodb-3-6-change-streams-example-with-node-js-2b9a85652c50"> MongoDB 3.6使用Node.js更改流示例</a></li><li id="3943" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" rel="noopener" href="/riow/mongodb-data-collection-change-85b63d96ff76"> MongoDB数据变更</a></li><li id="0bd3" class="jy jz hv iy b iz kh jd ki jv kj jw kk jx kl jt kd ke kf kg dt translated"><a class="ae ju" href="https://docs.mongodb.com/manual/changeStreams/" rel="noopener ugc nofollow" target="_blank"> MongoDB手册:更改流</a></li></ul><blockquote class="is it iu"><p id="7072" class="iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ho dt translated">我们的每周赞助商<a class="ae ju" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hw"> Pusher </strong> </a>开发通信和协作API，为世界各地的应用提供支持，并由易于集成的web、移动和最受欢迎的后端堆栈SDK提供支持。<a class="ae ju" href="http://bit.ly/2lCXscm" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hw">入门。</strong> </a></p></blockquote></div></div>    
</body>
</html>