<html>
<head>
<title>4 Future Challenges for TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript的未来挑战</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/4-future-challenges-for-typescript-e3ae90563d7e?source=collection_archive---------4-----------------------#2018-07-06">https://medium.com/hackernoon/4-future-challenges-for-typescript-e3ae90563d7e?source=collection_archive---------4-----------------------#2018-07-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f9a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类型化的<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>给web开发带来了一个新的层次。更好的自动完成，更自信的重构，<a class="ae jp" href="http://earlbarr.com/publications/typestudy.pdf" rel="noopener ugc nofollow" target="_blank">更少的错误</a>——有一个类型检查器很棒。有几种类型化的语言风格可以移植到javascript。有TypeScript，Flow，Elm，ClojureScript，Reason，Kotlin等。其中最<a class="ae jp" href="https://stateofjs.com/2017/flavors/results/" rel="noopener ugc nofollow" target="_blank">流行的</a>，是打字稿。</p><p id="143b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然我认为TypeScript很棒，但它并不全是阳光和彩虹。以下是我认为TypeScript未来面临的四大挑战。</p><h1 id="2cf0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">配置TypeScript可能会让人不知所措</h1><p id="a4e7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这是JavaScript世界中的一个普遍问题。对于新人来说，构建系统并不容易理解。Webpack无法配置是一个笑话，还有babel——现在还有TypeScript，它有自己的设置困难。</p><p id="d669" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为这种复杂的迷宫是像angular cli，Create React App和ParcelJS这样没有配置的固执己见的构建工具正在获得动力的原因之一。</p><p id="8903" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然TypeScript有一些合理的默认设置，但在设置项目时创建的<code class="eh ku kv kw kx b">tsconfig.json</code>文件中仍然有(count 'em) <strong class="it hv"> 54 </strong>个编译器标志。现在，它们中的大多数都有合理的默认设置，而且它们中的许多都是为了防止破坏性的改变而添加的——但是在帮助调试了我那份有问题的<code class="eh ku kv kw kx b">tsconfig</code>文件之后，我可以告诉你们这些人<em class="kt">肯定</em>弄错了。</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/9bcfb4d1db17a1e0ff1f11f345d50118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*f1XyOIDGLUROS0R3.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek"><em class="lk">All 54 of them!</em></figcaption></figure><p id="50d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，<code class="eh ku kv kw kx b">tsconfig.json</code>是用每个标志作为一个注释生成的，这无疑是有帮助的，因此可以看到要调整什么旋钮，但是要确定使用什么JavaScript目标、使用什么模块系统、要包含什么库等等仍然是一件很困难的事情。</p><h2 id="fa68" class="ll jr hu bd js lm ln lo jw lp lq lr ka jc ls lt ke jg lu lv ki jk lw lx km ly dt translated">让TypeScript融入JS生态系统</h2><p id="2976" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在，虽然TypeScript附带了一些配置选项，但是当您希望将它与其他构建工具结合使用时，复杂性才真正开始激增。</p><p id="0e33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们想在webpack构建管道中使用TypeScript。我们使用装载机来完成这项工作，但是我们应该使用<a class="ae jp" href="https://github.com/s-panferov/awesome-typescript-loader" rel="noopener ugc nofollow" target="_blank"> ats </a>还是<a class="ae jp" href="https://github.com/TypeStrong/ts-loader" rel="noopener ugc nofollow" target="_blank"> ts-loader </a>？或者我们应该只是运行<code class="eh ku kv kw kx b">"tsc --watch"</code>然后使用编译后的输出并将其输入webpack？</p><p id="38d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个webpack加载器都有自己的一组选项。<code class="eh ku kv kw kx b">ats</code>有18种设置，<code class="eh ku kv kw kx b">ts-loader</code>有19种不同的选项。</p><p id="954d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是也许我们根本不应该使用类型脚本加载器？Babel 7支持TypeScript它仍处于测试阶段，但许多大型项目已经在使用它，而且它看起来很稳定。然而，babel TypeScript支持在一些你很少使用的东西上是有限的(常量和名称空间是最大的两个)——所以这是你愿意为了额外的简单性而做出的一个折衷吗？</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/1a7571987107ffbbab026bbaa581343d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*6BneElWcG6DVfz-f.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek"><a class="ae jp" href="https://twitter.com/iamdevloper" rel="noopener ugc nofollow" target="_blank">@iamdevloper</a> knows how it feels</figcaption></figure><p id="fb03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后你当然也需要让它和你的测试框架一起工作——<a class="ae jp" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">Jest</a>有<a class="ae jp" href="https://github.com/kulshekhar/ts-jest" rel="noopener ugc nofollow" target="_blank"> ts-jest </a>作为TypeScript的预处理器，但是它也有一些限制和10多个配置选项。您最好确保它的配置方式与上面的typescript-loader相同，否则您会遇到难以调试的不一致。</p><p id="843e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有这些都是完全可行的，现在我建立打字稿项目并不需要很长时间，但是我已经花了<em class="kt">许多</em>小时，并且我已经被<em class="kt">许多</em>次弄清楚发生了什么。入门肯定会很难。</p><h1 id="214a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">类型系统错误消息是含糊的</h1><p id="eb6d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">虽然TypeScript的目标是按原样键入JavaScript，但考虑到JavaScript极其动态，这可能很难做到。像这样的任务需要一个复杂的类型系统，因为它必须输入的真实生活场景非常复杂。</p><p id="ff55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的方面是，TypeScript类型系统功能非常全面，你可以用它做一些令人惊奇的事情。</p><p id="bc0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">坏的一面是，当它不起作用时——完全不可能弄清楚到底发生了什么。想想我前段时间在twitter上的这段对话:</p><p id="9d69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://twitter.com/michlbrmly" rel="noopener ugc nofollow" target="_blank"> @michlbrmly </a>对条件类型做了一些很酷的工作:</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff ma"><img src="../Images/534177ddb30ee08d86c21765dd3046fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Ch8o2XCac29LQ-E.png"/></div></div></figure><p id="f049" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">具体细节并不十分重要，但是使用一些聪明的类型系统魔术，它定义了一个包含可翻译和不可翻译的本地化键的对象。</p><p id="7004" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里要注意的第一件事是，虽然这些类型非常聪明——它们也足够聪明，即使有评论描述它们，我也很难弄清楚发生了什么。</p><p id="f12b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，第二个问题是——如果一个库使用了这些类型，而你指定了一个错误的类型。这是您将得到的错误消息:</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mf"><img src="../Images/aa2ffdb40bc9ace0a417cbc20919b4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aNOVA_lxi6GL-hir.png"/></div></div></figure><p id="13d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此..这里到底出了什么问题？从错误信息上肯定是看不出来的。这并不是一个孤立的案例，我以前在使用react-redux等工具时也尝试过类似的错误消息。</p><p id="877c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对我来说，这是一个真正的恐惧，随着类型系统变得越来越复杂，在某一点上它会变得如此复杂以至于无用。如果你不知道这些类型告诉你什么，它们就没有多大帮助，因为它们只是一把无法理解的错误信息的加特林机枪。TypeScript 3.0在<a class="ae jp" href="https://github.com/Microsoft/TypeScript/wiki/Roadmap" rel="noopener ugc nofollow" target="_blank">路线图</a>上有<a class="ae jp" href="https://github.com/Microsoft/TypeScript/issues/25310" rel="noopener ugc nofollow" target="_blank">更好的错误消息</a>，所以希望这是团队关注的事情。</p><h1 id="d5eb" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">生态系统破碎化</h1><p id="14f9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">React Native 0.56在<a class="ae jp" href="https://github.com/react-native-community/react-native-releases/blob/master/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank">的变更日志</a>中包含了这个片段</p><p id="7722" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">“我们正在从PropTypes和运行时检查中迁移出来，转而依赖于Flow。您会注意到在这个版本中有许多与流程相关的改进。”</em></p><p id="2905" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于上述trans file-to-js语言的几种变体，我认为存在生态系统分裂的真正风险。</p><p id="7191" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">“本库只有TypeScript类型。嗯？这个只能在你使用Flow的时候使用。但是我在用ReasonML，怎么办？”</em></p><p id="c4b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为目前在不同的JavaScript方言之间为互操作输入相同的库有很多重复的工作。这个问题没有简单的解决方案，例如，Kotlin中的类型系统不能开箱即用地使用TypeScript中的类型，因为Kotlin中的类型系统不够动态，无法理解映射类型之类的东西。</p><p id="772a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为为了生态系统的利益，考虑我们是否需要某种标准的类型格式是有意义的，就像我们对源地图一样。它可能不会像TypeScript的打字那么复杂，但这也很好——大多数图书馆都没有那么复杂的打字，</p><p id="b7cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为如果我们最终在不同的围墙、不同类型的花园里，那将是一个悲剧。</p><h1 id="e5d5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">边界类型检查</h1><p id="9186" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">打字稿的目标<em class="kt">非目标</em>之一是<a class="ae jp" href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" rel="noopener ugc nofollow" target="_blank">这个</a>:</p><p id="bef1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kt">在程序中添加或依赖运行时类型信息，或根据类型系统的结果发出不同的代码。相反，鼓励不需要运行时元数据的</em> <a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank"> <em class="kt">编程</em> </a> <em class="kt">模式。”</em></p><p id="b8c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我觉得这个有利有弊。在很大程度上，这很好。在你的应用程序中，有一些地方你会想要使用类型信息，依赖注入可能是最大的。然而，这是通过使用实验性的<code class="eh ku kv kw kx b">emitDecoratorMetaData</code>标志在诸如Angular和<a class="ae jp" href="https://github.com/inversify/InversifyJS" rel="noopener ugc nofollow" target="_blank"> InversifyJS </a>中解决的。</p><p id="6322" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这将真正有所帮助的一个重要方面是在应用程序的边界进行类型检查。在大多数类型化语言中，你可以用一个X形状的对象来表达你正在接受一个请求。</p><p id="9109" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在TypeScript中，您当然可以做同样的事情——但是由于类型信息在运行时不做任何事情，因此无法确保您所说的类型就是您实际得到的类型。</p><p id="12d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您关心对象的结构，您将需要在运行时使用类似于<a class="ae jp" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a>或<a class="ae jp" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>的东西来指定它，但是这要求您以某种方式指定类型，在我看来，这比TypeScript接口要差得多。</p><p id="6067" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，TypeScript实际上正在对新的顶级类型<a class="ae jp" href="https://github.com/Microsoft/TypeScript/pull/24439" rel="noopener ugc nofollow" target="_blank"> unknown </a>进行边界检查，这基本上是一种我们一无所知的类型。您可以接受一个类型为<code class="eh ku kv kw kx b">unknown</code>的边界对象，然后您被迫在运行时检查它实际上是什么类型。</p><p id="d992" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我仍然认为类似运行时检查的东西，ala <a class="ae jp" href="https://github.com/codemix/flow-runtime" rel="noopener ugc nofollow" target="_blank"> flow-runtime </a>对于TypeScript来说是有意义的。像一个<code class="eh ku kv kw kx b">"validate"</code>关键字或者一个<code class="eh ku kv kw kx b">“validateType()”</code>函数编译成一个函数，确保对象实际上是指定的类型。</p><p id="d498" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管这明显违背了设计目标，但我可能不会对此抱太大希望——我们现在只能用<code class="eh ku kv kw kx b">unknown</code>了。</p><p id="336e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您认为typescript还面临其他问题吗，或者您不同意其中的一些问题？伸手在<a class="ae jp" href="https://twitter.com/GeeWengel" rel="noopener ugc nofollow" target="_blank"><em class="kt">@ GeeWengel</em></a></p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="mg mh l"/></div></figure></div></div>    
</body>
</html>