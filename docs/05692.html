<html>
<head>
<title>7 features proposed so far in Python 3.8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">到目前为止，Python 3.8中提出了7个特性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/7-features-proposed-so-far-in-python-3-8-acb0d97c83c8?source=collection_archive---------0-----------------------#2018-07-07">https://medium.com/hackernoon/7-features-proposed-so-far-in-python-3-8-acb0d97c83c8?source=collection_archive---------0-----------------------#2018-07-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3538" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python 3.7出来了。如果你想了解更多，请观看我的Pluralsight.com课程。</p><p id="f5d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python 3.7受益于新的功能和优化。从我们目前对3.8的了解来看，这将是一个类似的故事。这一次，大多数新功能都是针对C扩展和模块开发的。</p><p id="82db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于现有的Python增强提议，或已经提交的3.8版本的“pep”，我们很好地掌握了哪些特性可能会被包括在内。<a class="ae jp" href="https://tonybaloney.github.io/pep-explorer/#3.8_Any" rel="noopener ugc nofollow" target="_blank">我在这里为3.8做了一个PEP-Explorer用户界面。</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/64a8e1f2988633775bbad94531bd1390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PW0V40Rle4gMKop9oD09Q.png"/></div></div></figure><p id="40b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">许多提交的pep处于草案状态</strong>，这意味着实施细节<strong class="it hv">尚未最终确定</strong>。此外，pep在获得批准之前，必须得到大师或BDFL的批准。</p><p id="21a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.python.org/dev/peps/pep-0569/" rel="noopener ugc nofollow" target="_blank">我们将在2019年初看到第一个测试版</a>，它将在2019年6月左右“功能冻结”。</p><h1 id="2475" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">解释器的启动时间将会得到改善</h1><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff la"><img src="../Images/2d8b13a0d38f4666a47cab06a20c9f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KRGUToNBwTIBlvYRHMAbA.png"/></div></div></figure><p id="2800" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python的启动时间总是很“慢”，这在解释型语言中很常见。即使对于预编译(即Python文件与现有的。pyc cache)脚本，如果您正在启动多个进程，Python解释器启动所花费的时间可能是个问题。</p><p id="a0be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如此图所示(越低越快)，Python 3的启动速度比2.7慢，PyPy甚至更慢，因为JIT初始化过程。</p><p id="3d10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们已经尝试过优化启动，但是没有什么“剧烈的”改变。据传3.8是这种改进的目标版本，<a class="ae jp" href="https://www.python.org/dev/peps/pep-0432/#implementation-strategy" rel="noopener ugc nofollow" target="_blank"> PEP 432解释了将启动过程分成几个阶段的清晰策略。这个想法是，当从命令行或通过WSGI进程运行<code class="eh lb lc ld le b">python</code>时，它将运行相同的初始化序列，不管你是想运行单元测试、探索REPL、运行1函数还是执行预编译脚本。</a></p><p id="85e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">研究表明，由于Python导入路径的复杂性和典型安装中库的数量，Python的大部分启动时间都由I/O决定。</p><p id="1a78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PEP432本身不会提高启动性能，但是随着另一个(<em class="lf">尚未编写，我只是猜测它会</em>)，PEP提出预编译的脚本如何可以缓存或配置它们的导入序列和状态，将会产生巨大的差异。</p><h2 id="54a2" class="lg kd hu bd ke lh li lj ki lk ll lm km jc ln lo kq jg lp lq ku jk lr ls ky lt dt translated">有多个口译员</h2><p id="cf60" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">通过与启动时间的联系，<a class="ae jp" href="https://www.python.org/dev/peps/pep-0554/#api-summary-for-interpreters-module" rel="noopener ugc nofollow" target="_blank"> PEP 554提出了</a>一个新的标准库模块，<code class="eh lb lc ld le b">interpreters</code>它将公开已经存在的C-API，以便在单个进程中拥有多个Python解释器。这允许在比整个Python进程更少的开销内隔离代码。</p><p id="8196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PEP 554还建议扩展现有的API，以允许数据解释器之间更好的共享。</p><p id="6388" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可能是这样的:</p><pre class="jr js jt ju fq lz le ma mb aw mc dt"><span id="d78f" class="lg kd hu le b fv md me l mf mg">import interpreters<br/>interp = interpreters.create()<br/>print('before')<br/>interp.run('print("during")')<br/>print('after')</span></pre><h1 id="5adc" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">“无意识”操作符</h1><p id="336d" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">任何C#、Perl、PHP或Swift开发人员都可能熟悉空操作符，它们可以用于许多目的。我最喜欢的C#之一是空感知三元运算符。在这个例子中，水果的值被赋给<code class="eh lb lc ld le b">val</code>的值，除非它为空，在这种情况下，赋给它<code class="eh lb lc ld le b">"watermelon"</code>的值。</p><pre class="jr js jt ju fq lz le ma mb aw mc dt"><span id="4c34" class="lg kd hu le b fv md me l mf mg">var fruit = val ?? "watermelon";</span></pre><p id="8432" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.python.org/dev/peps/pep-0505/" rel="noopener ugc nofollow" target="_blank"> PEP505为<code class="eh lb lc ld le b">None</code>值提出了</a> 3个Python等价物，它们与这个C#示例类似，但具有Python风格。</p><pre class="jr js jt ju fq lz le ma mb aw mc dt"><span id="adf5" class="lg kd hu le b fv md me l mf mg">if val is None:<br/> fruit = "watermelon"<br/>else: <br/> fruit = val</span><span id="f4ef" class="lg kd hu le b fv mh me l mf mg"># now becomes in PEP505..<br/>fruit = val ?? "watermelon"</span></pre><p id="918a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无感知属性访问</p><pre class="jr js jt ju fq lz le ma mb aw mc dt"><span id="10bc" class="lg kd hu le b fv md me l mf mg">if val.fruit is not None:<br/>  fruit = val.fruit.name()<br/>else:<br/>  </span><span id="91e2" class="lg kd hu le b fv mh me l mf mg"># now becomes in PEP505<br/>fruit = val.fruit?.name()</span></pre><p id="9934" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，在不确定是否设置了的情况下，对值进行切片或索引。</p><pre class="jr js jt ju fq lz le ma mb aw mc dt"><span id="99b7" class="lg kd hu le b fv md me l mf mg">list_of_things = get_values()  # could be ``list`` or None<br/>first = list_of_things?[0]</span></pre><p id="c863" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个关注类似行为的PEP是<a class="ae jp" href="https://www.python.org/dev/peps/pep-0532/" rel="noopener ugc nofollow" target="_blank"> PEP 532 </a>。</p><h1 id="12cf" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">生成器敏感的上下文变量</h1><p id="4fd5" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">Python 3.7中包含的PEP 567引入了上下文变量，它是上下文本地状态，类似于线程本地存储。它们可以很好地处理类似线程的环境，比如asyncio任务。</p><p id="e5c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Nathaniel Smith(Trio fame)开发的PEP 568 基于PEP567，但增加了生成器上下文敏感性。这对那些使用asyncio并希望使用生成器的人来说是个好消息。我现在不怎么用asyncio，所以这个对我来说有点难。</p><h1 id="a52a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">为C扩展方法扩展API</h1><p id="0a13" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">Python有<code class="eh lb lc ld le b">@staticmethod</code>和<code class="eh lb lc ld le b">@classmethod</code>，类方法通常用纯Python定义，但也可以用C编写</p><ul class=""><li id="c1ee" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">PyType_GetModule</li><li id="95f4" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">PyType _ DefiningTypeFromSlotFunc</li><li id="7926" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">PyType_GetModuleState</li><li id="abd8" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">PyErr _ PrepareImmutableException</li></ul><h1 id="653a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">赋值表达式</h1><p id="88ce" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">这是3.8版本中最有争议的提议，并且它的一种形式已经被批准。</p><p id="498e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PEP 572建议对Python语法进行修改，以启用“赋值表达式”。理解这种变化需要理解Python中的<strong class="it hv">语句</strong>和<strong class="it hv">表达式</strong>之间的区别。</p><p id="5957" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python有许多类型的<strong class="it hv">简单的</strong>语句，每一个都以换行符结束(除非你使用分号，比如<code class="eh lb lc ld le b">import pdb; pdb.set_trace()</code>)。</p><ul class=""><li id="7027" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">导入声明- <code class="eh lb lc ld le b">import foo</code></li><li id="a987" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">流和传递语句，例如<code class="eh lb lc ld le b">break</code></li><li id="c290" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">表情语句，如<code class="eh lb lc ld le b">x = y</code>、<code class="eh lb lc ld le b">x += y</code></li></ul><p id="7e60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python也有表达式，在中找到了<strong class="it hv">的某些类型的语句</strong></p><ul class=""><li id="1501" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">If语句的语法为<code class="eh lb lc ld le b">if TEST: SUITE</code>，其中<code class="eh lb lc ld le b">SUITE</code>是一组嵌套空格的语句，<code class="eh lb lc ld le b">TEST</code>是一个比较表达式或一系列，使用<code class="eh lb lc ld le b">and</code>、<code class="eh lb lc ld le b">or</code>和<code class="eh lb lc ld le b">not</code>关键字。</li><li id="c4d5" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">For语句的语法为<code class="eh lb lc ld le b">for EXPRESSION LIST in TESTS: SUITE</code></li><li id="2f8b" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">删除报表，<code class="eh lb lc ld le b">del EXPRESSSION</code></li><li id="3f95" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">用as语句<code class="eh lb lc ld le b">with TEST as EXPRESSION: SUITE</code></li><li id="58ee" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">列表和字典理解</li></ul><p id="d35f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不能做的是把语句放到表达式里，因为语句不返回任何东西。所以<code class="eh lb lc ld le b">if x = y:</code>不起作用</p><pre class="jr js jt ju fq lz le ma mb aw mc dt"><span id="433a" class="lg kd hu le b fv md me l mf mg">&gt;&gt;&gt; x = 1<br/>&gt;&gt;&gt; y = 2<br/>&gt;&gt;&gt; if x=y:<br/>File "&lt;stdin&gt;", line 1<br/>if x=y:<br/>^<br/>SyntaxError: invalid syntax</span></pre><p id="378e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PEP 572建议用一个新的<code class="eh lb lc ld le b">:=</code>操作符和一种新的赋值表达式语法来改变这种情况。</p><p id="73b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以这个例子为例，你有一个产品列表，你想计算总运费。目前在Python中，如果你在一个列表理解中使用一个<code class="eh lb lc ld le b">if</code>语句，你不能用一个语句来赋值。</p><p id="3f8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这种新语法，您可以。本例中的重要部分是在list comprehension中创建一个新名称<code class="eh lb lc ld le b">cost</code>，它是<code class="eh lb lc ld le b">to_usd</code>函数调用的产物。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mw mx l"/></div></figure><h2 id="d7f2" class="lg kd hu bd ke lh li lj ki lk ll lm km jc ln lo kq jg lp lq ku jk lr ls ky lt dt translated">想试试这个新语法吗？</h2><p id="4dd8" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">我用赋值表达式语法和无值合并操作符语法构建了一个分支:<a class="ae jp" href="https://github.com/tonybaloney/cpython/tree/python38_wonderland" rel="noopener ugc nofollow" target="_blank">https://github . com/tonybaloney/cpython/tree/python 38 _ wonderland</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff my"><img src="../Images/343fad1cdfb8be2fc24b490a8df2eafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*hwIkElkigZ2zoAx_TxZBvQ.png"/></div></div></figure><h1 id="e507" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">对内置函数类的更改</h1><p id="174e" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">PEP576建议扩展内置函数和方法的类，使其更像Python函数。具体来说，内置函数和方法将获得对声明它们的模块的访问权，内置方法将获得对它们所属的类的访问权。</p><p id="45ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么需要这样做？如果你正在开发一个Python模块，比如Cython，并且想用C开发函数，你有两个选择:</p><ul class=""><li id="be38" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">使用内置的CPython函数，如<code class="eh lb lc ld le b">len</code>、<code class="eh lb lc ld le b">print</code>等。这是首选方法，但是对于可以在模块中访问的数据有缺点(如果用Python实现，就没有这种缺点)，或者</li><li id="3f5f" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">构建您自己的len、print等版本。这通常是个坏主意。</li></ul><p id="c626" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个提议给C API增加了两个变化:</p><ol class=""><li id="810a" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mz mo mp mq dt translated">添加了一个新函数<code class="eh lb lc ld le b">PyBuiltinFunction_New(PyMethodDef *ml, PyObject *module)</code>来创建内置函数。</li><li id="cd1e" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated"><code class="eh lb lc ld le b">PyCFunction_NewEx()</code>和<code class="eh lb lc ld le b">PyCFunction_New()</code>被弃用，如果可以将返回一个<code class="eh lb lc ld le b">PyBuiltinFunction</code>，否则返回一个<code class="eh lb lc ld le b">builtin_function_or_method</code>。</li></ol><p id="2531" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PEP还提出了一个新的内置类<code class="eh lb lc ld le b">builtin_function</code></p><p id="3e25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.python.org/dev/peps/pep-0573/#background" rel="noopener ugc nofollow" target="_blank">一个相关的PEP，573期待</a>扩展用C编写的扩展方法可以访问的API，使它们能够看到模块的状态，而不必调用昂贵的<code class="eh lb lc ld le b">PyState_FindModule</code>操作。同样，该实现对Cython非常有用，但实际效果可能会有所不同。</p><p id="9742" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.python.org/dev/peps/pep-0580/" rel="noopener ugc nofollow" target="_blank">另一个相关的PEP，580 </a>，与<code class="eh lb lc ld le b">builtin_function_or_method</code>、<code class="eh lb lc ld le b">method_descriptor</code>、<code class="eh lb lc ld le b">method</code>和<code class="eh lb lc ld le b">function y</code>内置实例的扩展类型开发有关</p><p id="67e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些类都不是子类。因此，任何基于方法、内置等假设的优化。无法制造。</p><p id="929a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">573建议用新的“C调用”协议来代替对<code class="eh lb lc ld le b">builtin_function_or_method</code>和<code class="eh lb lc ld le b">method_descriptor</code>的检查。</p><p id="b878" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这种新协议意味着用户开发的扩展类型将获得与内置相同的优化优势，例如Python 3.7中添加的新的快20%的LOAD_METHOD操作码。</p><h1 id="1d07" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">Python运行时审计挂钩</h1><p id="3326" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated"><a class="ae jp" href="https://www.python.org/dev/peps/pep-0578/" rel="noopener ugc nofollow" target="_blank"> PEP 578提议在CPython运行时</a>中添加挂钩，这些挂钩将使开发者能够:</p><ul class=""><li id="1c46" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">安全软件</li><li id="2b2d" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">调试软件</li><li id="060e" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">剖析软件，可能还有一些我想不出来的例子</li></ul><p id="5461" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“挂钩”到核心运行时事件并执行扩展代码。该API将被添加到<code class="eh lb lc ld le b">sys</code>模块中，既可以任意调用钩子，也可以配置自己的钩子。一旦添加，挂钩就不能移除或更换。</p><pre class="jr js jt ju fq lz le ma mb aw mc dt"><span id="21a8" class="lg kd hu le b fv md me l mf mg"># Add an auditing hook<br/>sys.addaudithook(hook: Callable[[str, tuple]])<br/><br/># Raise an event with all auditing hooks<br/>sys.audit(str, *args)</span></pre><p id="48fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例和建议的事件包括exec、import、compile和object。__setattr__。PEP对基本的低级挂钩(如代码对象的执行)以及高级挂钩(如网络套接字的打开和URL的调用)提出了一些建议。</p><p id="29a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">听到最后一句话，我可以听到各地的安全爱好者都皱起了眉头。<strong class="it hv">我是这个PEP </strong>的超级粉丝，因为它可以为CPython带来一些优秀的第三方插件来锁定执行环境。类似于SELinux对Linux内核的处理。</p><p id="b184" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">钩子将实现对事件的响应，典型的响应是记录事件，异常中止操作，或者通过操作系统退出调用立即终止进程。</p><p id="b7b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是我能想到的一些使用示例</p><ul class=""><li id="d614" class="mi mj hu it b iu iv iy iz jc mk jg ml jk mm jo mn mo mp mq dt translated">检测核心对象和函数的猴子补丁</li><li id="c853" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">默认情况下，对所有非根用户禁用/记录网络套接字的打开</li><li id="f29e" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">远程URL连接的陷阱/代理打开</li><li id="c129" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">检测导入操作以捕获运行时及其测试的导入树。</li></ul></div></div>    
</body>
</html>