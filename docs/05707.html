<html>
<head>
<title>Advanced JavaScript with Kyle Simpson</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">凯尔·辛普森的高级JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/advanced-javascript-with-kyle-simpson-50e9276e5426?source=collection_archive---------6-----------------------#2018-07-08">https://medium.com/hackernoon/advanced-javascript-with-kyle-simpson-50e9276e5426?source=collection_archive---------6-----------------------#2018-07-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f985" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的博客记录了我作为一名技术人员进入硅谷的经历。我是一个有色人种的怪人，性别不合群，移民，曾被收养的年轻人。我来自一个<a class="ae jp" href="https://hackernoon.com/tagged/non-traditional" rel="noopener ugc nofollow" target="_blank">非传统</a>的编码背景。我在大学里学了几门CS课程，最后在成为老师之前主修了人文学科。向青少年教授web开发让我对编码产生了兴趣。在一所编码学校毕业后，我开始在旧金山的初创企业工作。我的博客一半是关于技术主题，另一半是关于平等和技术访问(我的旅程)。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/bc83b8370a2a7281827cb7edb1a98a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*YYFs6vFwKgrbzys_-I60gg.jpeg"/></div></figure><p id="4090" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在博客上发布我在<a class="ae jp" href="https://frontendmasters.com/" rel="noopener ugc nofollow" target="_blank">前端大师</a>上完成的教程。这是凯尔·辛普森的高级<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>工作坊。Kyle是当今最流行的编程语言之一的作者和教师，这是一个流行的Javascript系列书籍，名为<a class="ae jp" href="https://github.com/getify/You-Dont-Know-JS" rel="noopener ugc nofollow" target="_blank">“你不知道JavaScript。”</a></p><p id="56ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">诚然，这不是一个“性感”的前端大师的课程，但是，如果你想成为一名优秀的Javascript开发人员，你必须有坚实的基础知识，这就足够了，凯尔辛普森在本教程中教你。</p><p id="049c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了是JS方面的专家，凯尔也是一个好老师。作为一名教师和学生，我经历过好的、坏的和丑陋的事情。他说话清晰，直接与观众互动(在研讨会视频中)，反复强调这个概念，直到我们理解为止。</p><p id="678c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大外卖:</p><ul class=""><li id="41d3" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">范围</li><li id="c692" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">关闭</li><li id="9821" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">“这个”和“新的”</li><li id="c035" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">面向对象编程(OOP)</li><li id="b62a" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">异步模式</li><li id="3516" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">该做的和不该做的</li></ul><h1 id="b084" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated"><strong class="ak">范围</strong></h1><h2 id="d952" class="lk kn hu bd ko ll lm ln ks lo lp lq kw jc lr ls la jg lt lu le jk lv lw li lx dt translated"><a class="ae jp" href="https://spin.atomicobject.com/2014/10/20/javascript-scope-closures/" rel="noopener ugc nofollow" target="_blank">词法范围</a></h2><p id="2495" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">凯尔为<a class="ae jp" href="http://javascriptissexy.com/tag/variable-scope/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">词汇范围</strong> </a>、建筑物内部的地址给了我们一个巧妙的类比。如果你找不到某一层的地址，那么进入下一层，你的搜索就会像同心圆一样迅速展开。<a class="ae jp" href="https://www.sitepoint.com/demystifying-javascript-variable-scope-hoisting/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">范围</strong> </a>在JavaScript编程中无处不在。所以，学习JavaScript需要对词法范围有扎实的理解:如何<a class="ae jp" href="https://stackoverflow.com/questions/18465211/javascript-loop-variable-scope" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">遍历</strong> </a>它，通过使变量<a class="ae jp" href="https://crockford.com/javascript/private.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">私有</strong> </a>来隐藏变量。</p><p id="1661" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想欺骗词法作用域，并创建私有变量你可以立即使用<a class="ae jp" rel="noopener" href="/@vvkchandra/essential-javascript-mastering-immediately-invoked-function-expressions-67791338ddc6"><strong class="it hv">【IIFEs】</strong></a>调用函数表达式。开/闭括号会立即调用JavaScript函数。在下面的例子中，变量foo在全局命名空间中受到保护。</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="2d10" class="lk kn hu me b fv mi mj l mk ml">var foo = “foo”;<br/>(function(){<br/>   var foo = “foo2”;<br/>   console.log(foo);<br/>})();</span><span id="049d" class="lk kn hu me b fv mm mj l mk ml">console.log(foo);</span></pre><h2 id="bcd1" class="lk kn hu bd ko ll lm ln ks lo lp lq kw jc lr ls la jg lt lu le jk lv lw li lx dt translated"><strong class="ak">封锁范围</strong></h2><p id="6ceb" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated"><a class="ae jp" href="https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var-to-declare-a-variable-in-jav" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">让</strong> </a>关键字附加到<a class="ae jp" href="https://edgecoders.com/function-scopes-and-block-scopes-in-javascript-25bbd7f293d7" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">块范围</strong> </a>。在一个<code class="eh mn mo mp me b">for loop</code>中，关键字<code class="eh mn mo mp me b">let</code>附加到“I”和“for循环”的代码块中。权衡是，let关键字允许变量重用，但它不提升那个变量。</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="8d85" class="lk kn hu me b fv mi mj l mk ml">// i accessible to let<br/>for(let i = 0; i &lt; list.length; i++){<br/>//i accessible here too<br/>  return i <br/>}</span></pre><h2 id="2206" class="lk kn hu bd ko ll lm ln ks lo lp lq kw jc lr ls la jg lt lu le jk lv lw li lx dt translated"><a class="ae jp" href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/apA.md" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">动态范围</strong> </a></h2><p id="6b8e" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">在下面的代码中,“function foo”可以访问“var bar ”,因为它查看的是<a class="ae jp" rel="noopener" href="/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec"> <strong class="it hv">调用堆栈</strong> </a>而不是其词法范围。</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="acd7" class="lk kn hu me b fv mi mj l mk ml">function foo() {<br/>  console.log(bar); //dynamic!<br/>}</span><span id="f262" class="lk kn hu me b fv mm mj l mk ml">function baz() {<br/> var bar = “bar”;<br/>  foo();<br/>}</span><span id="3c92" class="lk kn hu me b fv mm mj l mk ml">baz();</span></pre><h1 id="111d" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated"><strong class="ak">合拢&amp;吊装</strong></h1><h2 id="5739" class="lk kn hu bd ko ll lm ln ks lo lp lq kw jc lr ls la jg lt lu le jk lv lw li lx dt translated"><a class="ae jp" href="http://javascriptissexy.com/tag/variable-hoisting/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">吊装</strong> </a></h2><p id="4585" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">当变量声明和函数声明在编译阶段被移到顶部时。</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="82c1" class="lk kn hu me b fv mi mj l mk ml">function showName () {<br/>console.log ("First Name: " + name);<br/>var name = "Ford";<br/>console.log ("Last Name: " + name);<br/>}<br/><br/>showName (); <br/>// First Name: undefined<br/>// Last Name: Ford<br/><br/>// Undefined prints because the local variable name is hoisted to the top of the function<br/>// Local variable gets called the first time</span><span id="cd74" class="lk kn hu me b fv mm mj l mk ml">// This is how the code is actually processed by the JavaScript engine:<br/><br/>function showName () {<br/>  // name is hoisted (note that is undefined at this point, <br/>     since the assignment happens below)<br/>  var name; <br/>  // First Name: undefined<br/>  console.log ("First Name: " + name); <br/>  // name is assigned a value<br/>  name = "Ford"; <br/><br/>// now name is Ford<br/>console.log ("Last Name: " + name); <br/>// Last Name: Ford<br/>}</span></pre><p id="015b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在提升中，首先调用函数，接着是变量声明，执行，然后是函数表达式。</p><h2 id="a53d" class="lk kn hu bd ko ll lm ln ks lo lp lq kw jc lr ls la jg lt lu le jk lv lw li lx dt translated"><a class="ae jp" href="http://javascriptissexy.com/understand-javascript-closures-with-ease/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">封</strong> </a></h2><p id="310b" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">是函数访问并记住其词法范围的能力，即使该函数在其词法范围之外执行。Javascript中的一个必要机制，允许一级函数的可用性</p><p id="59a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关闭示例#1</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="2f4b" class="lk kn hu me b fv mi mj l mk ml">function foo(){<br/>  var bar = “bar”;<br/>  function baz() {<br/>    console.log(bar);<br/>  }<br/>  bam(baz);<br/>}</span><span id="9bf9" class="lk kn hu me b fv mm mj l mk ml">function bam(baz) {<br/>  //can still access the variable bar — that is closure<br/>  baz(); <br/>}</span><span id="3669" class="lk kn hu me b fv mm mj l mk ml">foo();</span></pre><p id="fbab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关闭示例#2</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="022c" class="lk kn hu me b fv mi mj l mk ml">function foo(){<br/>  var bar = “bar”;<br/>  return function() {<br/>    console.log(bar);<br/>  }<br/>}</span><span id="e5b8" class="lk kn hu me b fv mm mj l mk ml">function bam() {<br/>  //can still access the variable bar — that is closure<br/>  foo()(); <br/>}</span><span id="6ad1" class="lk kn hu me b fv mm mj l mk ml">bam();</span></pre><h2 id="3c01" class="lk kn hu bd ko ll lm ln ks lo lp lq kw jc lr ls la jg lt lu le jk lv lw li lx dt translated"><strong class="ak">‘这个’</strong></h2><p id="1a74" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">每个正在执行的函数都有一个对其当前执行上下文的引用(包括不止<a class="ae jp" href="http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/" rel="noopener ugc nofollow" target="_blank">'<strong class="it hv">'</strong>'</a>、局部变量、调用堆栈)。<a class="ae jp" href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">执行上下文</strong> </a>表示函数被调用时是如何被调用的。</p><p id="7e98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">规则——取决于“调用位置”——放在代码中执行函数的位置。</p><ul class=""><li id="9e61" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">硬绑定—可预测地使用“this”</li></ul><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="3f20" class="lk kn hu me b fv mi mj l mk ml">function foo(){<br/>  console.log(this.bar);<br/>}<br/>var obj = { bar: “bar” };<br/>var obj2 = { bar: “bar2” };<br/>var orig = foo;</span><span id="7f5c" class="lk kn hu me b fv mm mj l mk ml">foo = function(){ orig.call(obj); };<br/>foo();<br/>foo.call(obj2)</span></pre><p id="4ea7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有没有一个效用函数可以做到这一点？是的，有—绑定:</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="8905" class="lk kn hu me b fv mi mj l mk ml">function bind(fn, o){<br/>  return function() {<br/>    fn.call(o);<br/>  };<br/>}</span><span id="6b7a" class="lk kn hu me b fv mm mj l mk ml">function foo() {<br/>  console.log(this.bar);<br/>}</span><span id="9f49" class="lk kn hu me b fv mm mj l mk ml">var obj = { bar: “bar” };</span><span id="229c" class="lk kn hu me b fv mm mj l mk ml">var obj2 = { bar: “bar2” };</span><span id="1581" class="lk kn hu me b fv mm mj l mk ml">foo = bind(foo, obj);</span><span id="cbce" class="lk kn hu me b fv mm mj l mk ml">foo();</span><span id="af4c" class="lk kn hu me b fv mm mj l mk ml">foo.call(obj2);</span></pre><p id="050e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.显式绑定规则—在调用位置，如果存在显式指定“this”的调用或应用</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="7a24" class="lk kn hu me b fv mi mj l mk ml">function foo(){<br/>  console.log(this.bar);<br/>}</span><span id="ef87" class="lk kn hu me b fv mm mj l mk ml">var bar = “bar1”;</span><span id="d7fb" class="lk kn hu me b fv mm mj l mk ml">var obj = { bar: “bar2” };</span><span id="c765" class="lk kn hu me b fv mm mj l mk ml">foo(); //default binding</span><span id="f9aa" class="lk kn hu me b fv mm mj l mk ml">foo.call(obj); //explicit binding</span></pre><p id="eec3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.隐式绑定规则—参见下文“this”如何绑定到对象属性引用</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="7df7" class="lk kn hu me b fv mi mj l mk ml">var implicitBinding = { bar: “bar2”, foo: foo };<br/>implicitBinding.foo(); //’this’ binds to object property reference</span></pre><p id="eac1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.默认绑定规则—如果您处于“严格模式”，则将“this”关键字默认为未定义的值。否则，将“this”关键字默认为全局对象</p><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="21a3" class="lk kn hu me b fv mi mj l mk ml">function foo() {<br/>  console.log(this.bar) //this is bound to an object with property<br/>}<br/>foo(); //call site looks like this and default binding applies</span></pre><p id="f3a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于“this”关键字的4个问题:</p><ul class=""><li id="d50a" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">该函数是用“new”关键字调用的吗？</li><li id="0bea" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">是否使用“call”或“apply”调用了函数，使其成为显式绑定？</li><li id="fde3" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">该函数是通过包含/拥有对象(上下文)调用的吗？(隐式绑定)</li><li id="413a" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">默认值:全局对象(严格模式除外)</li></ul><h1 id="fd4e" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated"><a class="ae jp" href="https://stackoverflow.com/questions/1646698/what-is-the-new-keyword-in-javascript" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">新</strong> </a></h1><p id="196c" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">当“new”关键字放在函数调用前面时，会发生4种情况:</p><ul class=""><li id="f44f" class="jy jz hu it b iu iv iy iz jc ka jg kb jk kc jo kd ke kf kg dt translated">创建了一个新对象。</li><li id="bac2" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">新对象链接到不同的对象。</li><li id="3aae" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">新对象被绑定到“this”关键字</li><li id="f0b2" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">如果该函数不返回任何内容，它将隐式插入一个返回this</li></ul><pre class="jr js jt ju fq md me mf mg aw mh dt"><span id="7f8f" class="lk kn hu me b fv mi mj l mk ml">function foo() {<br/>  this.baz = “baz”;<br/>  console.log(this.bar + “ “ + baz);<br/>}</span><span id="8144" class="lk kn hu me b fv mm mj l mk ml">var bar = “bar”;<br/>var baz = new foo();</span></pre><h2 id="c380" class="lk kn hu bd ko ll lm ln ks lo lp lq kw jc lr ls la jg lt lu le jk lv lw li lx dt translated"><strong class="ak">该做和不该做的事情</strong></h2><ul class=""><li id="cf57" class="jy jz hu it b iu ly iy lz jc mq jg mr jk ms jo kd ke kf kg dt translated">不要使用未命名的匿名函数。这是一种不好的做法，(喘息脸表情符号)——因为你不能递归调用这个函数。</li><li id="a030" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">不要使用“with”或“eval”—eval修改现有的词法范围以在运行时添加新的声明，这会使您的代码变慢</li><li id="da2f" class="jy jz hu it b iu kh iy ki jc kj jg kk jk kl jo kd ke kf kg dt translated">使用<a class="ae jp" href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" rel="noopener ugc nofollow" target="_blank">文件</a>使变量私有</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mt mu l"/></div></figure></div></div>    
</body>
</html>