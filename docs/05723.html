<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-jest-and-enzyme-for-testing-react-apps-4d3e1543bf0d?source=collection_archive---------0-----------------------#2018-07-09">https://medium.com/hackernoon/using-jest-and-enzyme-for-testing-react-apps-4d3e1543bf0d?source=collection_archive---------0-----------------------#2018-07-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/55c3b66cc27f089cf48691060521709f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SruahLTSYt6Oo8MKhTMI6w.png"/></div></div></figure><p id="4804" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated"><em class="jc">供参考:如果你想直接从我的个人博客阅读这篇文章，你可以点击</em> <a class="ae jd" href="https://timgivois.me/using-jest-and-enzyme" rel="noopener ugc nofollow" target="_blank"> <em class="jc">这里</em> </a> <em class="jc">。</em></p><h1 id="1b89" class="je jf if bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dt translated">使用Jest和Enzyme测试React应用程序</h1><p id="e5b7" class="pw-post-body-paragraph id ie if ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb hn dt translated">测试代码可能是软件工程中最重要的事情之一。测试确保了我们所构建的质量。测试代码有很多方法，从端到端测试(手工测试)到单元测试(React中的组件测试)。在本文中，我们将介绍一些使用Jest、Enzyme和其他优秀的<a class="ae jd" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>来测试<a class="ae jd" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>代码的最常见和最有效的方法。</p><h2 id="5ff0" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">测试金字塔</h2><p id="cd56" class="pw-post-body-paragraph id ie if ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb hn dt translated">在敏捷框架中，自动化测试可以被分组到一个测试金字塔中。测试金字塔说明了什么时候我们应该使用一种测试方法而不是另一种。金字塔显示了许多单元快照测试可以用来验证一个集成测试，许多集成测试可以用来验证一个手动测试。在金字塔的顶端，我们有一个端到端的测试:对整个应用程序的手工测试。选择应该使用什么类型的测试的想法是很重要的，因为我们可能在金字塔的两个或三个不同的层次上测试相同的东西。</p><figure class="kw kx ky kz fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kv"><img src="../Images/e5377008fd9bb2592df57878b5827f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*837yp4KYQIX_c0mrYq9QNw.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Image 1. Test pyramid.</figcaption></figure><p id="911c" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">手动测试既慢又不可持续。这种类型的测试适用于我们的前端应用程序，因为它模拟了用户将如何与我们的应用程序交互。这种测试的问题是维护成本很高(任何微小的UI更改都可能破坏测试，因为这些测试通常是用Selenium(一种web浏览器模拟器)完成的)，并且开发这种测试的时间可能很长。需要注意的是，由于成本较高，我们通常不会在前端应用中使用这种测试。</p><p id="f43f" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">集成测试可能有助于测试组件之间的连接，并在这些连接中找到错误。例如，让我们假设我们想要测试每当用户点击按钮时，父组件是否将特定的道具传递给子组件。维护和进行这些测试的成本并不是很高，并且会测试我们没有用单元测试来测试的部分。</p><p id="854b" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">单元/快照测试可能是测试组件最简单的方法。我们只关注一个孤立的项目及其逻辑。如果我们遵循表示层-功能组件的划分，测试这一点甚至会更容易。对于表示组件，我们为组件提供道具，并期待一个特定的呈现(对于快照来说可能是一个很好的用例)。在功能测试中，测试可能更加棘手。我们需要模拟一个redux store来创建用户动作，并且我们希望在模拟事件时redux动作被模拟的store调用。</p><p id="2207" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">作为前端开发的经验法则，从单元/快照测试开始。仅在必要时进行集成测试。尽量避免手动/UI测试。我们可以使用Jest作为金字塔前两步的主要测试工具。</p></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><h2 id="f729" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">为什么开玩笑？</h2><blockquote class="ll lm ln"><p id="d523" class="id ie jc ig b ih ii ij ik il im in io lo iq ir is lp iu iv iw lq iy iz ja jb hn dt translated">用笑话让测试再次变得伟大。</p></blockquote><p id="9910" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">Jest是由脸书创建的一个测试框架。脸书用它来测试JavaScript和React代码。是在性能、特色、适应性的前提下创造出来的。Jest提供了集成的“零配置”体验。这是与其他流行的测试框架如Mocha的区别。一些致命的特征是:</p><ul class=""><li id="3ea4" class="lr ls if ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz dt translated"><strong class="ig ma">即时反馈:</strong>沉浸式观看模式只运行与更改文件相关的测试文件。</li><li id="7d34" class="lr ls if ig b ih mb il mc ip md it me ix mf jb lw lx ly lz dt translated"><strong class="ig ma">快速且沙箱化:</strong>它跨工作人员运行并行测试，缓冲控制台消息并一起打印。</li><li id="b6ee" class="lr ls if ig b ih mb il mc ip md it me ix mf jb lw lx ly lz dt translated"><strong class="ig ma">快照测试:</strong>捕获React树或其他可序列化值的快照，以简化测试并分析状态如何随时间变化。</li><li id="4e3e" class="lr ls if ig b ih mb il mc ip md it me ix mf jb lw lx ly lz dt translated"><strong class="ig ma">内置代码覆盖报告:</strong>支持<code class="eh mg mh mi mj b">—-coverage </code>带来现成的覆盖报告。</li><li id="21a5" class="lr ls if ig b ih mb il mc ip md it me ix mf jb lw lx ly lz dt translated"><strong class="ig ma">零配置</strong></li></ul><h2 id="a6e0" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">笑话匹配器</h2><p id="3d8b" class="pw-post-body-paragraph id ie if ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb hn dt translated">匹配器是Jest中最基本的测试单元。它们用于断言一个预期的对象等于、接近、大于或小于，或者包含到另一个输出对象的任何其他逻辑连接。我们可以用这些逻辑联系创造不同的结构。更多参考，请查看Jest <a class="ae jd" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="683b" class="kh jf if mj b fv mo mp l mq mr">test(‘object assignment’, () =&gt; {<br/> const data = {one: 1};<br/> data[‘two’] = 2;<br/> expect(data).toEqual({one: 1, two: 2});<br/>});</span><span id="58d5" class="kh jf if mj b fv ms mp l mq mr">test(‘increasing a positive number is not zero’, () =&gt; {<br/> let a = 1;<br/> expect(a + 1).not.toBe(0);<br/>});</span><span id="a528" class="kh jf if mj b fv ms mp l mq mr">test('zero', () =&gt; {<br/>  const z = 0;<br/>  expect(z).not.toBeNull();<br/>  expect(z).toBeDefined();<br/>  expect(z).not.toBeUndefined();<br/>  expect(z).not.toBeTruthy();<br/>  expect(z).toBeFalsy();<br/>});</span><span id="a65f" class="kh jf if mj b fv ms mp l mq mr">test('adding floating point numbers', () =&gt; {<br/>  const value = 0.1 + 0.2;<br/>  // It fails because in JavaScript 0.2 + 0.1 = 0.30000000000000004 jejeje.<br/>  // expect(value).toBe(0.3);<br/>  // This works with a precision of 5.<br/>  expect(value).toBeCloseTo(0.3, 5);<br/>});</span></pre><p id="3021" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">我们甚至可以测试一个预期的函数抛出一个错误:</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="c142" class="kh jf if mj b fv mo mp l mq mr">function compileAndroidCode() {<br/> throw new ConfigError(‘you are using the wrong JDK’);<br/>}</span><span id="1cd3" class="kh jf if mj b fv ms mp l mq mr">test(‘compiling android goes as expected’, () =&gt; {<br/> expect(compileAndroidCode).toThrow();<br/> expect(compileAndroidCode).toThrow(ConfigError);</span><span id="16d7" class="kh jf if mj b fv ms mp l mq mr">// You can also use the exact error message or a regexp<br/> expect(compileAndroidCode).toThrow(‘you are using the wrong JDK’);<br/> expect(compileAndroidCode).toThrow(/JDK/);<br/>});</span></pre><h2 id="80ec" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">玩笑嘲弄</h2><p id="b35d" class="pw-post-body-paragraph id ie if ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb hn dt translated">模仿是隔离组件和功能的有效方法。为此，我们定义函数/依赖项的输出。一个好的模拟是模仿所有的极限情况。Jest的另一个优秀特性是创建模仿函数/依赖项的便利性。</p><blockquote class="ll lm ln"><p id="1719" class="id ie jc ig b ih ii ij ik il im in io lo iq ir is lp iu iv iw lq iy iz ja jb hn dt translated">如果你没有嘲笑，你就不是单元测试。</p></blockquote><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="37c5" class="kh jf if mj b fv mo mp l mq mr">test('computeList calls callback in array', () =&gt; {<br/>    function computeList(items, callback) {<br/>      for (let index = 0; index &lt; items.length; index++) {<br/>        callback(items[index])<br/>      }<br/>    }</span><span id="b19b" class="kh jf if mj b fv ms mp l mq mr">    const mockCallback = jest.fn()<br/>                          .mockReturnValue(32)</span><span id="b6e5" class="kh jf if mj b fv ms mp l mq mr">    computeList([0, 1], mockCallback)</span><span id="d9c8" class="kh jf if mj b fv ms mp l mq mr">    // The mock function is called twice<br/>    expect(mockCallback.mock.calls.length).toBe(2)</span><span id="0e45" class="kh jf if mj b fv ms mp l mq mr">    // The first argument of the first call to the function was 0<br/>    expect(mockCallback.mock.calls[0][0]).toBe(0)<br/>  })</span></pre><h2 id="889d" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">安装和拆卸</h2><p id="2443" class="pw-post-body-paragraph id ie if ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb hn dt translated">Jest中一个很好的实践是按块组织数据。为此，我们可以使用接收两个参数的<code class="eh mg mh mi mj b">describe</code>函数:第一个是块名，然后是一个函数，这个函数或者有更多组织好的块，或者测试函数。为了使它更加模块化，Jest提供了一组函数，在我们运行测试之前和之后控制代码的执行。</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="7219" class="kh jf if mj b fv mo mp l mq mr">describe('City Database', () =&gt; {<br/>    beforeAll(() =&gt; {<br/>        initEnvironment()<br/>    })<br/>    <br/>    beforeEach(() =&gt; {<br/>        initCityDB()<br/>    })<br/>    <br/>    afterEach(() =&gt; {<br/>        clearCityDB()<br/>    })<br/>    <br/>    test('has Vienna', () =&gt; {<br/>        expect(isCity('Vienna').toBeTruthy())<br/>    })<br/>    <br/>    test('has San Juan', () =&gt; {<br/>        expect(isCity('San Juan').toBeTruthy())<br/>    })<br/>})</span></pre></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><h2 id="f2cd" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">快照测试</h2><blockquote class="ll lm ln"><p id="121a" class="id ie jc ig b ih ii ij ik il im in io lo iq ir is lp iu iv iw lq iy iz ja jb hn dt translated">随着项目的发展和变化，代码和测试也需要发展。</p></blockquote><p id="30c0" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">为长期项目编写单元测试最复杂的部分是维护。随着项目的发展，代码也在发展，自然地，测试也在发展。某些功能或组件可能会故意改变输出，测试可能需要修改它们的断言。如图所示，这种适应通常有重复的任务。2.快照测试是一种自动化该过程并创建单元测试的方法，随着时间的推移，单元测试可以很容易地被覆盖和管理。快照测试的主要好处是，我们可以快速地为<em class="jc">黑盒</em>创建测试，而不需要太多的配置，并且很容易地使它们适应变化。</p><figure class="kw kx ky kz fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mt"><img src="../Images/20d8a96ccf5d9717ee4ec1196cf86c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vrJJBv21xb7--dAw"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Image 2. Unit Tests without Snapshots</figcaption></figure><p id="1a8d" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">想象一个函数，当给定一个关键字时，它过滤一个对象列表。其中一个测试可以写成如下形式:</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="ac5b" class="kh jf if mj b fv mo mp l mq mr">test('function filters users', () =&gt; {<br/>    expect(filterUsers('b').toEqual([<br/>        { name: 'Becky' },<br/>        { name: 'Bob' },<br/>        { name: 'Bryan' },<br/>        { name: 'Bryce' }<br/>    ]))    <br/>})</span></pre><p id="9e8f" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">但是，如果我们添加用户或更改模式，会发生什么呢？我们必须改变测试，复制并粘贴断言以使测试通过。逻辑没变，只有预期输出。这在一个项目中可能会发生多次。快照是使这一重复过程自动化和自动生成的解决方案。</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="09f5" class="kh jf if mj b fv mo mp l mq mr">test('filters items', () =&gt; {<br/>    expect(filterUsers('b')).toMatchSnapshot()<br/>})</span></pre><p id="d703" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">Jest有一个管理快照创建和更新的内置模块。它会将快照保存在名为<em class="jc"> __snapshots__的目录中。</em>无论何时我们运行Jest(如果该目录存在)，它都会将输出与保存的输出进行比较。如果不同，我们可以很容易地覆盖保存的快照或检查代码中可能的错误。以下是自动生成的快照:</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="004d" class="kh jf if mj b fv mo mp l mq mr">// Jest Snapshot v1, <a class="ae jd" href="https://goo.gl/fbAQLP" rel="noopener ugc nofollow" target="_blank">https://goo.gl/fbAQLP</a></span><span id="a6ad" class="kh jf if mj b fv ms mp l mq mr">exports[`Snapshots filters users 1`] = `<br/>Array [<br/>  Object {<br/>    "name": "Becky",<br/>  },<br/>  Object {<br/>    "name": "Bob",<br/>  },<br/>]<br/>`;</span></pre></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><h2 id="42b8" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">测试React应用？</h2><p id="ff2e" class="pw-post-body-paragraph id ie if ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb hn dt translated">到目前为止，我们讨论的所有内容都与React没有直接联系。所有以前的工具都可以用来测试我们前端应用程序的逻辑。在前端应用程序中，并不是一切都是逻辑；我们有一个演示文稿需要测试。但是，我们如何测试呢？经验法则是我们应该测试所有非静态的东西。换句话说，我们应该测试两件事:</p><ol class=""><li id="0b35" class="lr ls if ig b ih ii il im ip lt it lu ix lv jb mu lx ly lz dt translated">给定一组输入(state &amp; props)，断言组件应该输出什么(render)。</li><li id="3515" class="lr ls if ig b ih mb il mc ip md it me ix mf jb mu lx ly lz dt translated">给定一个用户动作，断言组件的行为方式。该组件可以进行状态更新或调用从父代传下来的属性函数。</li></ol><figure class="kw kx ky kz fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mv"><img src="../Images/f87d0b01790a52ea068661df8144915e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3M-n5hVpXuqw82U6"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">image 3. Tests for a simple form app.</figcaption></figure><p id="f2a7" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">这很好，但是如果你仔细想想，我们将要测试或拍摄的表示组件的输出会是什么？它将是生成的反应树。Enzyme是一个工具，我们将使用它轻松地渲染甚至可以隔离的React树(例如，不渲染子组件)。</p><h2 id="d848" class="kh jf if bd jg ki kj kk jk kl km kn jo ip ko kp js it kq kr jw ix ks kt ka ku dt translated">酶</h2><p id="cca9" class="pw-post-body-paragraph id ie if ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb hn dt translated">Enzyme是由Airbnb开发和管理的测试工具。Enzyme使用React提供的几个工具来构建它的API。API减少了样板代码。</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="c55b" class="kh jf if mj b fv mo mp l mq mr">import App from '../App'</span><span id="cb40" class="kh jf if mj b fv ms mp l mq mr">describe('App component', () =&gt; {<br/>  test('should shallow correctly', () =&gt; {<br/>      expect(shallow(<br/>        &lt;App /&gt;<br/>      )).toMatchSnapshot() <br/>  })<br/>  test('should mount correctly', () =&gt; {<br/>      expect(mount(<br/>        &lt;App /&gt;<br/>      )).toMatchSnapshot() <br/>  })<br/>  test('should render correctly', () =&gt; {<br/>      expect(render(<br/>        &lt;App /&gt;<br/>      )).toMatchSnapshot() <br/>  })<br/>})</span></pre><p id="b982" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">酶有三种呈现反应成分的方法。这些方法给出不同的结果，我们在不同的情况下使用它们。我们建议总是从浅层开始。只有当您需要测试与生命周期相关的东西时，才使用mount。当我们要测试孩子时，应该使用Render。</p><ol class=""><li id="1446" class="lr ls if ig b ih ii il im ip lt it lu ix lv jb mu lx ly lz dt translated">浅层渲染有助于将组件作为一个单元进行测试，并确保测试不会间接断言子组件的行为。</li><li id="00b9" class="lr ls if ig b ih mb il mc ip md it me ix mf jb mu lx ly lz dt translated"><strong class="ig ma">挂载:</strong>全渲染，不需要“浏览器”这样的环境。当您希望用比mount更少的开销测试子节点时，这很有用。</li><li id="a82b" class="lr ls if ig b ih mb il mc ip md it me ix mf jb mu lx ly lz dt translated"><strong class="ig ma">呈现:</strong>全DOM呈现非常适合那些组件可能与DOM APIs交互的用例。完全呈现实际上是在DOM中挂载组件。这是测试<em class="jc">componentid mount</em>和<em class="jc">componentid update</em>的唯一方法。</li></ol><p id="4ac8" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">我们有三种方法的API方法，可以帮助我们进行断言。其中最重要的两个是“模拟”和“查找”。第一个可以模拟用户事件，如点击，悬停等。第二种方法可以用选择器找到一个子节点。</p><pre class="kw kx ky kz fq mk mj ml mm aw mn dt"><span id="2eec" class="kh jf if mj b fv mo mp l mq mr">describe('the user populates the input', () =&gt; {<br/>    const testem = 'Vancouver'</span><span id="8af6" class="kh jf if mj b fv ms mp l mq mr">    beforeEach(() =&gt; {<br/>        const input = wrapper.find('input').first()<br/>        input.simulate('change', {<br/>          target: { value: testem }<br/>        })<br/>      })</span><span id="3556" class="kh jf if mj b fv ms mp l mq mr">  test('should update the state property `testem`', () =&gt; {<br/>        expect(<br/>          wrapper.state().testem<br/>        ).toEqual(testem)<br/>  })<br/>})</span></pre><p id="b12c" class="pw-post-body-paragraph id ie if ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb hn dt translated">我们现在准备测试我们的React应用程序。更具体例子的代码可以在<a class="ae jd" href="https://github.com/timgivois/jest-talk" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kw kx ky kz fq hw"><div class="bz el l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>