<html>
<head>
<title>BST Sequences in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的BST序列</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/bst-sequences-in-python-c072c0e9b19f?source=collection_archive---------7-----------------------#2018-07-09">https://medium.com/hackernoon/bst-sequences-in-python-c072c0e9b19f?source=collection_archive---------7-----------------------#2018-07-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5361" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">#开始背景</p><p id="023b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几年前，我踏上了在<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>领域认真提高技能的旅程，我开始在Codecademy上做教程，并在Udemy上注册课程。由于我的工作涉及到相当多的旅行，我把教程离线下载到我的ipad上，然后在飞机上学习。我一开始打算学习编程来构建有用的东西，尽管旅程的每一步都很艰难，但我意识到，直到我沉浸在数据结构和算法中，我才知道“困难”这个词的真正含义。</p><p id="5fe8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我是航空航天工程专业的学生，以一等荣誉毕业于新加坡。之后，我作为新产品工程师加入了Schlumberger，从事油田泵的工作，并在北海安装设备。工作时间很长(每天16个小时很常见，周末也经常加班)，工资很低，但这种体验很棒，我不会用它来交换任何东西。直到今天，进行翻船训练、走下挪威逃生滑道以及乘坐直升机到钻井平台的生存训练都是美好的回忆，除非是油田工程师，否则人们不会经历这些。</p><p id="8d3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在那之后，我加入了P&amp;G，成为一名研究护发品牌的研究员，在两次晋升之后，我开始意识到，虽然项目管理、利益相关者管理(确保和你一起工作的每个人都开心)和建立信誉可能很重要，而且实际上在任何地方都是最重要的，但我并没有在工作中获得做我非常热爱的事情所需的技能，即构思、制造有用的东西来解决问题和建立品牌。不过，我所处的环境超级棒，有支持我的同事和管理层。在这样的企业环境中工作让我意识到，关于一家公司如何运作，有多少东西需要学习；管理层如何在分配人员和资源以及整合不同部门的努力以建立和振兴品牌方面做出决策(无论是基于数据还是直觉，这就是为什么商业是一门如此美丽的科学，也是一门艺术)。神奇的东西。</p><p id="a644" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望通过提供快速而准确的事实，帮助公司各级管理层和产品经理做出更明智的决策，这促使我开始编程，为大众创建一个抓取和数据挖掘工具，该工具一直为致力于十亿美元品牌(如Pantene、Vicks、Tide、Head and Shoulders、SKII、Oral b等)的团队提供有价值的消费者洞察。这个工具叫做www.wheregottext.com<a class="ae jp" href="http://www.wheregottext.com" rel="noopener ugc nofollow" target="_blank"/>(首字母缩略词WGT)(我已经设置了认证，所以只有宝洁公司的员工可以创建账户)。</p><p id="8fb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了WGT，我还开发了一个求职应用程序和一个识别超市产品的应用程序，并显示其他消费者的相关在线评分和评论，以便消费者在购买前做出更明智的决定，而不仅仅是与商店的销售代表交谈等。我还参与了Android和iOS应用程序开发，我将在另一个时间描述这一点。</p><p id="c752" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何，咆哮到此为止，我会在另一篇文章中介绍更多的内容。到目前为止，我遇到的一个比较困难的问题是:给定一个BST，找出一个可以创建BST的列表。</p><p id="537f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">#结束背景</p><p id="5050" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将使用Gayle Laakmann McDowell的《破解编码采访》中的例子来提供我的观点和解释，希望遇到这个问题的人不会像我一样在网上寻找有用的解释，但没有成功。我会用<a class="ae jp" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>提供代码。书中的代码是用Java写的。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/2de50f2e6a839b224817520d17c838f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Qi9TNnAqQO9hooG-21mCUA.png"/></div></figure><p id="6a30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想想左边的二叉查找树。我们可以尝试手动列出一些可能的数组，这些数组包含可以插入以形成二叉查找树的元素。</p><p id="4b73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">[20,10,5,15,25]</p><p id="6afe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">[20,10,25,5,15]</p><p id="92ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">[20, 25,10,15,5]</p><p id="6df6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">…</p><p id="e230" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，对于每个子树(由三个节点组成),必须总是首先插入根，然后是任何顺序的子树，因为子树在同一层。</p><p id="cfa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我解决这个问题的最初想法是首先对所有节点进行一次前序遍历，并将节点存储到一个列表中。然后，我将生成一个所有元素排列的列表，然后过滤掉以值20开始的列表，以及10在5和15之前的条件(因为10必须首先相加才能形成BST)。这种想法有很多缺陷。这是一种非常手动的方法，如果BST较大，或者如果我们无法在上面的图表中显示BST，那么确定节点的层次结构将会变得不必要的复杂。我们可以做一个BFS，算出10必须在5和15之前，但是我宁愿遵循教科书的方法，而不是实现它。</p><p id="3600" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们知道，我们总是将问题分解成更小的问题，然后对于BST，我们可以使用回收将解决方案扩展到更大的问题。在书中，使用了两个递归函数。一个叫做weaveLists，另一个叫做allSequences。</p><p id="b5e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们来定义一个树类。我们需要能够进行插入，也能够得到根。</p><pre class="jr js jt ju fq jy jz ka kb aw kc dt"><span id="1447" class="kd ke hu jz b fv kf kg l kh ki">class Node:<br/>    def __init__(self, val):<br/>        self.l = None<br/>        self.r = None<br/>        self.v = val</span><span id="d45b" class="kd ke hu jz b fv kj kg l kh ki">class Tree:<br/>    def __init__(self):<br/>        self.root = None</span><span id="5f81" class="kd ke hu jz b fv kj kg l kh ki">def getRoot(self):<br/>        return self.root</span><span id="be13" class="kd ke hu jz b fv kj kg l kh ki">def insert(self, val):<br/>        if(self.root == None):<br/>            self.root = Node(val)<br/>        else:<br/>            self._insert(val, self.root)</span><span id="c64f" class="kd ke hu jz b fv kj kg l kh ki">def _insert(self, val, node):<br/>        if(val &lt; node.v):<br/>            if(node.l != None):<br/>                self._insert(val, node.l)<br/>            else:<br/>                node.l = Node(val)<br/>        else:<br/>            if(node.r != None):<br/>                self._insert(val, node.r)<br/>            else:<br/>                node.r = Node(val)</span></pre><p id="f53f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此后，我们希望能够编织子树的元素。weaveList函数如下(我在代码中直接添加了注释来解释发生了什么) :</p><p id="8a4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">#注意，在递归中，我们总是对第一、第二和前缀列表使用相同的引用，因此修改这些列表的操作必须就地完成。任何拷贝都必须使用deepcopy函数来完成。</p><p id="932c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">###编辑到下面的代码:不要使用result = prefix.copy()，而是使用:</p><pre class="jr js jt ju fq jy jz ka kb aw kc dt"><span id="dda1" class="kd ke hu jz b fv kf kg l kh ki">import copy<br/>result = copy.deepcopy(prefix)</span></pre><p id="5690" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自从。copy()是一个浅层副本。</p><p id="8a83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢智勇指出这一点。</p><pre class="jr js jt ju fq jy jz ka kb aw kc dt"><span id="c081" class="kd ke hu jz b fv kf kg l kh ki"># 'first' list shall be referred to as first[]<br/># 'second' list shall be referred to as second[]<br/># 'prefix' list shall be referred to as prefix[]</span><span id="9cb8" class="kd ke hu jz b fv kj kg l kh ki">def weaveLists(first, second, results, prefix):<br/>    # if first or second is an empty list<br/>    if not first or not second:<br/>        # ensuring that result is a CLONE and not a reference to prefix<br/>        result = prefix.copy() ### EDIT HERE TO DEEPCOPY<br/>        # add result to first or/ and second lists<br/>        if first:<br/>            result += first<br/>        if second:<br/>            result += second<br/>        # append the weaved list which is result, to results<br/>        results.append(result)<br/>        return</span><span id="7b6a" class="kd ke hu jz b fv kj kg l kh ki">        # add result to first or/ and second lists<br/>        if first:<br/>            result += first<br/>        if second:<br/>            result += second<br/>        # append the weaved list which is result, to results<br/>        results.append(result)<br/>        return</span><span id="dbd1" class="kd ke hu jz b fv kj kg l kh ki">    # this would be the method as described in the textbook<br/>    # first, remove and store first element of first[]<br/>    headFirst = first.pop(0)<br/>    # append to prefix<br/>    prefix.append(headFirst)<br/>    ### add recursive call to operate on first[]<br/>    weaveLists(first, second, results, prefix) <br/>    # exit when first[] is empty</span><span id="2323" class="kd ke hu jz b fv kj kg l kh ki">    # reset prefix for second recursive call below by removing last element<br/>    # IMPT to modify in-place<br/>    del prefix[-1] <br/>    # reset first[] for second recursive call below by adding back first element<br/>    # IMPT to modify in-place<br/>    first.insert(0,headFirst)</span><span id="0739" class="kd ke hu jz b fv kj kg l kh ki">    # do the same thing on the second[]<br/>    headSecond = second.pop(0)<br/>    prefix.append(headSecond)<br/>    ### add recursive call to operate on first[] and second[]<br/>    weaveLists(first, second, results, prefix)<br/>    del prefix[-1]<br/>    second.insert(0,headSecond)</span></pre><p id="8159" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们希望weaveList函数能够对子树进行操作，并构建整个树。</p><p id="f71f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，通常我们希望weaveList处理蓝色的子树1，然后是绿色的整棵树。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff kk"><img src="../Images/f803cec3a8c6b9f1ec9186f23e623abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bjdb-VujcLcLon6Ygcr4aQ.png"/></div></div></figure><p id="6c13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，所有序列的代码是(带有解释注释):</p><pre class="jr js jt ju fq jy jz ka kb aw kc dt"><span id="8b22" class="kd ke hu jz b fv kf kg l kh ki">def allSequences(node):<br/>    # this is the final list of lists we want to output<br/>    results = []<br/>    # termination, append [] so that results will not be empty\<br/>    # and the nested for loop will still execute since<br/>    # leftSeq == [[]] and rightSeq == [[]] in termination<br/>    if not node:<br/>        results.append([])<br/>        return results</span><span id="7319" class="kd ke hu jz b fv kj kg l kh ki">    # prefix will always be root of subtree<br/>    prefix = []<br/>    prefix.append(node.v)<br/>    # then represent the left and right subtrees<br/>    leftSeq = allSequences(node.l)<br/>    rightSeq = allSequences(node.r)</span><span id="f3b7" class="kd ke hu jz b fv kj kg l kh ki">    # nested for loop and call weaveLists on each list in<br/>    # leftSeq and rightSeq, which are list of lists<br/>    # and each represents results of each subtree<br/>    for left in leftSeq:<br/>        for right in rightSeq:<br/>            # make weaved an empty list, <br/>            # which is results in weaveList<br/>            weaved = []<br/>            weaveLists(left, right, weaved, prefix)<br/>            # weaved is list of lists generated by left[] and right[]<br/>            # add weaved list of lists to final <br/>            # results list of lists<br/>            results += weaved</span><span id="2420" class="kd ke hu jz b fv kj kg l kh ki">return results</span></pre><p id="de5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">驱动程序的主要功能是:</p><pre class="jr js jt ju fq jy jz ka kb aw kc dt"><span id="c8fc" class="kd ke hu jz b fv kf kg l kh ki">if __name__ == "__main__":</span><span id="54db" class="kd ke hu jz b fv kj kg l kh ki">    tree = Tree()<br/>    <br/>    tree.insert(20)<br/>    tree.insert(10)<br/>    tree.insert(25)<br/>    tree.insert(5)<br/>    tree.insert(15)</span><span id="24c7" class="kd ke hu jz b fv kj kg l kh ki">    allSeq = allSequences(tree.getRoot())</span><span id="3678" class="kd ke hu jz b fv kj kg l kh ki">    for each in allSeq:<br/>        print (each)<br/>    print (len(allSeq))</span></pre><p id="5344" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将所有代码复制到一个脚本中，然后运行它来查看结果。代码在Python3中。</p><p id="7bb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如有任何意见、建议或问题，请随时联系我们。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="kp kq l"/></div></figure></div></div>    
</body>
</html>