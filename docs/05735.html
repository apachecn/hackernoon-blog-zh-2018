<html>
<head>
<title>How to control asynchronous invocations of your AWS Lambda functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何控制AWS Lambda函数的异步调用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-control-asynchronous-invocations-of-your-aws-lambda-functions-ad2def033222?source=collection_archive---------12-----------------------#2018-07-09">https://medium.com/hackernoon/how-to-control-asynchronous-invocations-of-your-aws-lambda-functions-ad2def033222?source=collection_archive---------12-----------------------#2018-07-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/75f002e2d4bd7f441e978da8349a0692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roedigbmFjRYkZobdZWuKg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/8OyKWQgBsKQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jg" href="https://unsplash.com/search/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f6e7" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">问题是</h1><p id="711d" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我有一个连续运行的无服务器进程——一个Lambda运行，在它结束之前，它调用另一个Lambda。由于速率限制和其他错误，我需要知道调用是否成功，但我不想等到新的Lambda结束。这很有挑战性。</p><p id="e580" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">另一件恼人的事情是，运行Lambda的数量正在不受控制地增加，尽管我应该一次有一个Lambda处于活动状态(可能有两个，因为我启动了一个新的Lambda，然后才关闭当前的Lambda——有几毫秒的重叠)。</p><h1 id="74a8" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">解决方案</h1><p id="be59" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">lambda调用有两种类型:Sync(“request response”)和Async(“Event”)。</p><p id="e2ff" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">最初，我从<a class="ae jg" href="https://hackernoon.com/tagged/async" rel="noopener ugc nofollow" target="_blank">异步</a>选项开始，因为我不想等待新的Lambda结束。结果是<a class="ae jg" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>将这个调用请求添加到一个队列中，您不知道它是否被成功调用。此外，如果调用失败，那么AWS可以再次重新运行它..</p><p id="63a2" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我的下一个尝试是同步调用。为了知道Lambda调用是否成功，我需要等待新的Lambda结束。所以我用了一个小技巧:</p><ol class=""><li id="3939" class="li lj hu kh b ki ld km le kq lk ku ll ky lm lc ln lo lp lq dt translated">调用同步Lambda</li><li id="a765" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">等一下</li><li id="6154" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">一秒钟后，发生了三件事:</li><li id="0995" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">我在一秒钟内从AWS获得了一次成功的调用(这意味着新的lambda运行了不到一秒钟——这不太可能发生)</li><li id="2767" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">我从AWS得到一个错误</li><li id="d35f" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">发生了超时，所以我假设调用是成功的。新的Lambda正在运行，但我不再等待它。</li></ol><h1 id="3b31" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">根据我的经验，重要的是:</h1><ol class=""><li id="10ad" class="li lj hu kh b ki kj km kn kq lw ku lx ky ly lc ln lo lp lq dt translated">如果发生超时，我假设调用成功并继续执行我的代码<strong class="kh hv">，但是</strong>在某个时间点，新函数将结束并返回一个真正的成功或失败响应。您必须准备代码来处理它。你可能会得到两股水流，而不是一股——小心！</li><li id="e174" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">与前一个场景相同，但是这一次，在被调用的Lambda用一个答案回复之前，第一个Lambda已经结束——AWS将认为调用失败，并重新运行Lambda！</li><li id="0582" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">Lambda套接字超时:如果Lambda以同步方式调用一个新的Lambda B(<strong class="kh hv">“request response”</strong>)，它会根据Lambda套接字超时<strong class="kh hv"> (lambda。config . http options = { time out:1500 }；)</strong> —即使你的代码结束了，回复了200或者500个响应！</li><li id="26c2" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq dt translated">您可以使用:<strong class="kh hv"> "context </strong>强制Lambda结束，而不等待套接字超时。<strong class="kh hv">callbackWaitsForEmptyEventLoop</strong>=<strong class="kh hv">false</strong>；"—请注意，当调用的lambda结束时，您会得到一条错误消息(B ),在这种情况下，它也会重新调用。</li></ol><h1 id="cd50" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">结论</h1><ul class=""><li id="aa86" class="li lj hu kh b ki kj km kn kq lw ku lx ky ly lc lz lo lp lq dt translated">我想知道Lambda调用是否成功，但我找不到直接的解决方案。您需要使用同步调用来“入侵”系统。</li><li id="134a" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc lz lo lp lq dt translated">当AWS仅仅因为你没有等待它的响应就认为你的Lambda失败时，要注意额外的调用。</li><li id="84dc" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc lz lo lp lq dt translated">你的Lambda函数会被多次调用——你的代码应该是幂等的——代码逻辑应该知道如何处理同一个输入(事件)的多次调用。</li></ul><p id="3e2e" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">本文未讨论的其他解决方案:</strong></p><ul class=""><li id="665e" class="li lj hu kh b ki ld km le kq lk ku ll ky lm lc lz lo lp lq dt translated">Lambda死信队列——当失败的lambda被插入到需要管理的队列中时，在这种情况下仍会发生错误重试调用。</li><li id="fa0b" class="li lj hu kh b ki lr km ls kq lt ku lu ky lv lc lz lo lp lq dt translated">使用外部数据库来管理您的调用。例如，当Lambda开始时增加发电机计数器，当它结束时减少它。</li></ul></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><p id="f0fa" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><a class="ae jg" href="https://www.linkedin.com/in/amos-shahar-483b182/" rel="noopener ugc nofollow" target="_blank"> <em class="mh">阿莫斯【沙哈尔】</em></a> <em class="mh">是DevOps &amp;的总监IT at</em><a class="ae jg" href="https://chrome.google.com/webstore/detail/superquery-bigquery-optim/lfckfngaeoheoppemkocjjebloiamfdc/reviews?hl=en" rel="noopener ugc nofollow" target="_blank"><strong class="kh hv"><em class="mh">superQuery</em></strong></a><em class="mh">。通过我们用于Google BigQuery的SQL IDE，superQuery使用人工智能和智能缓存来使数据团队能够在Google BigQuery上运行最高效和最具成本效益的查询。</em></p><figure class="mi mj mk ml fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>