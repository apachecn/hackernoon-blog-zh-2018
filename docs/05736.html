<html>
<head>
<title>Distributed graphs processing with Spark GraphX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark GraphX的分布式图形处理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/distributed-graphs-processing-with-spark-graphx-f0ceea695220?source=collection_archive---------13-----------------------#2018-07-09">https://medium.com/hackernoon/distributed-graphs-processing-with-spark-graphx-f0ceea695220?source=collection_archive---------13-----------------------#2018-07-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/409b1d8097e7e0e1cac49618618eb9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D871z_-H3knIuLvMCPuzNg.png"/></div></div></figure><blockquote class="jc jd je"><p id="1f56" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">简单是可靠的先决条件</p></blockquote></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="45c6" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated"><strong class="ji hv">开场白</strong></p><p id="49c0" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">图是一种明显且易于理解的数据结构。自从伦纳德·欧拉的时代以来，图论迫使人类思考不同的任务，例如一个人如何能够走过柯尼希斯堡的所有七座桥而不经过其中任何一座两次，或者旅行推销员应该如何找到最有利可图的路线。</p><figure class="kp kq kr ks fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ko"><img src="../Images/d2ce863f1b56611c4043dd12b914f5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I95DGa7mn8n6hEiCK_9F7Q.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Seven Bridges of Königsberg — is a notable problem in the graph theory</figcaption></figure><p id="5b05" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">从欧拉的时代开始，出现了很多东西:晶体管，编程语言，分布式计算都出现了。这个列表的最后一项极大地简化了图形的存储和处理。这就是本文将要讨论的内容。</p><p id="4632" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">如果您不熟悉Apache Spark的基本概念，如RDD、驱动程序、工作节点等。在继续阅读本文之前，我建议您阅读来自Databricks的文档<a class="ae kx" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7f1a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">对我来说，对付任何技术的最好方法就是试着用它写点东西。在本文中，我们将利用图论的基本概念来分析<em class="jh">【社交网络】</em>的相似性。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="da77" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated"><strong class="ji hv">练习</strong></p><p id="29a1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">存储我们的“社交网络”的方式我选择了一种简单直观的方式:磁盘上的tsv文件。当然，它可以是任何其他格式的文件，如Parquet、Avro。在这一步，文件的存储位置并不重要，它可以是HDFS或S3，即使我们需要更改某些内容，Spark SQL也会无缝地进行迁移。网络结构看起来像这样:第一个文件是用户的Id及其名称，第二个文件是用户的Id及其对等方的列表。Apache Spark支持以下编程语言Java、Scala和Python作为API。我选择了第二种。</p><p id="dd16" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">我只想回答一个流行的问题，即当您有许多插入/更新操作时，是否使用Spark GraphX来存储图形—答案是否定的，RDD force上的所有更改操作都是为了更改集群中的整个RDD，这不是最佳解决方案，对于这种情况，NoSQL的解决方案如Neo4J、Titanium甚至Cassandra、HBase都可以提供帮助。没有什么可以阻止你使用Spark GraphX，还有前面提到的NoSQL解决方案，用于处理图形、从数据库下载数据/通过调度程序检索，以及通过Spak以事件驱动的方式进一步处理，这些都是很好的用例。</p><p id="f10f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">好了，让我们开始写代码吧。首先，我们需要将图形加载到内存中，获取源文件并提取必要的顶点和边:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="38cd" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated"><strong class="ji hv">预凝胶</strong></p><p id="d533" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">GraphX中图形迭代的主要机制是Pregel算法。该算法由Google开发，Pregel模型使用<a class="ae kx" href="https://stanford.edu/~rezab/classes/cme323/S15/notes/lec8.pdf" rel="noopener ugc nofollow" target="_blank">图中顶点之间的消息传递</a>。通过称为超步的迭代序列传输消息，这是该算法的基本思想。还有，主要思想可以描述为:“像顶点一样思考”换句话说，当前顶点的一个状态只取决于它的邻居的一个状态。</p><p id="200a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">如果用通常的MapReduce解决问题变成一个复杂的过程，Pregel就变得非常必要。有趣的是，Pregel这个名字来源于这条河的名字，这条河横扫了柯尼斯堡的七座桥。</p><p id="9631" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">遍历图的主要原语是三元组——它由以下部分组成:当前顶点、我们要经过的顶点以及它们之间的边。同样，您必须指定顶点之间的默认距离；通常，它是PositiveInfinity，每个顶点的UDF(用户定义的函数)函数处理传入的消息并计算下一个顶点，UDF合并两个传入的消息，这个函数必须是可交换的和关联的。由于Scala是一种函数式语言，最后两个函数将表示为，两个lambda表达式。</p><p id="b09c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">我们实现的第一个算法是Dijkstra算法，用于查找从任意顶点到所有其他顶点的最短路径。</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="6007" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">一切都很清楚:从一个给定的顶点开始，使用最小值函数来确定每一步的最小距离。Pregel中使用的第一个函数保持传入消息和当前顶点之间的最短距离。第二个功能是在保持距离的同时向邻居传播消息。最后一个功能类似于Reduce阶段，它在有多个传入消息的情况下选择最小值。此外，我们用字符串形成了一个方便的图形表示。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="59bd" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated"><strong class="ji hv">分离度</strong></p><p id="33b4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">我相信这篇文章的许多读者都听说过<a class="ae kx" href="https://en.wikipedia.org/wiki/Six_degrees_of_separation" rel="noopener ugc nofollow" target="_blank">六度分离</a>理论，这是一个未经证实的理论，即地球上的任何人都可以通过不超过五个中间人的熟人链与地球上的任何其他人联系起来。关于图论，这听起来像这样:对于地球上的任何两个人，图的直径不超过6。</p><p id="86be" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated"><em class="jh">特朗普先生和我的分离程度:</em></p><p id="876a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">我很好奇我和唐纳德·特朗普(Donald Trump)或马克·扎克伯格(Mark Zuckerberg)等一些名人之间的分离程度。想了想，我记起了下一个:我的同事在脸书工作，并且认识马克，因此我和马克的分离度是两个:我——我的伙伴，我的伙伴——马克。当然，马克和川普先生是认识的，结果，+1:川普先生和我的分离度是三。如果你个人认识我，就意味着你对这些人的分离度相应地至少是3和4。很好奇，不是吗？</p><figure class="kp kq kr ks fq iv fe ff paragraph-image"><div class="fe ff la"><img src="../Images/900c0396c9128d070ec3f2ebdd78f426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*0eF3C2x5PkZSDoAYhq4ypg.jpeg"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">An example of the degree of separation graph</figcaption></figure><p id="b27a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">让我们开始编写该任务的代码，我们需要在<a class="ae kx" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度</a>中遍历一个图，以便找到指定顶点的联系人，为此我们需要修改Dijkstra算法的代码:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="1c4e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">一切都与上面的Dijkstra算法非常相似，但是我们必须指定迭代次数——对于我根据经验得到的图表，值为10，对于您的图表，这可能是一个不同的数字。接下来，我们使用用户名执行join，并获取任意用户的前100个值:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="5da3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">找到两个任意顶点的分离度也是可行的:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="0cb9" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">Spark GraphX从框中可以得到关于图的许多信息，例如，得到图的连通分量:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="197a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">以图形中三角形的数量(三角形计数)来获取此指标:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="5810" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated"><strong class="ji hv"> PageRank </strong></p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="2977" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">PageRank为图的每个顶点分配重要性。例如，如果一个Twitter用户有来自其他用户的大量订阅，那么他就有很高的评级，因此，这个用户可以很容易地在搜索引擎中找到。</p><figure class="kp kq kr ks fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lb"><img src="../Images/4f41b30e553c0768e12642e97e3e2475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0BMml5HS0lVLkuxJCAvRw.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">PageRank representation</figcaption></figure><p id="1105" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">GraphX有PageRank实现的静态和动态版本。静态版本具有固定的迭代次数，而动态版本运行直到秩收敛到指定值。</p><p id="c936" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">我们的图表看起来是这样的:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ky kz l"/></div></figure></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="1a0d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated"><strong class="ji hv">结论</strong></p><p id="ac21" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kl js jt ju km jw jx jy kn ka kb kc kd hn dt translated">细心的读者注意到，本文的主题是图的分布式处理，但是在编写代码时，我们没有做任何事情来使处理真正分布式。让我们想起埃德格·迪克斯特拉在开头的话。Spark通过承担分布式计算的负担，极大地简化了我们的生活。编写将在分布式集群上启动的代码并不像一开始看起来那样困难。Spark的集群资源管理甚至有几个选项:Hadoop YARN、Apache Mesos(我个人最喜欢的选项),最近还有对Kubernetes的支持。本文中考虑的所有源代码都可以在这个GitHub <a class="ae kx" href="https://github.com/arukavytsia/spark-graphx" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到。</p></div></div>    
</body>
</html>