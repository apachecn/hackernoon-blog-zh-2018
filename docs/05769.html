<html>
<head>
<title>Mocking static method in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的模拟静态方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mocking-static-method-in-kotlin-614df89482ae?source=collection_archive---------2-----------------------#2018-07-10">https://medium.com/hackernoon/mocking-static-method-in-kotlin-614df89482ae?source=collection_archive---------2-----------------------#2018-07-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/018bae2cb4c89245238826dafb0f8bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78lDdKSPwr50lccR64qEiQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/ym3QFTHYUE4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Susan Yin</a> on <a class="ae jg" href="https://unsplash.com/search/photos/mock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fb44" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">静态方法不好，或者至少，当它不是<strong class="jj hv">纯</strong>的时候。</p><p id="197e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，纯粹意味着:</p><ul class=""><li id="6dbb" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">它不会产生副作用，不会在方法范围之外产生任何变化。</li><li id="6dc2" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">它是引用透明的，意味着任何引用都必须作为参数传递，否则引用值的变化将导致不确定的结果。</li></ul><p id="b877" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这有什么不好？</p><p id="d75e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为谁消费了那个不纯的静态方法，谁就不容易测试。如果静态方法是纯的，它可能是好的，因为你可以预测它的行为，你不需要嘲笑他们(少嘲笑是伟大的！)，只需要断言返回值就够了。但是不纯洁的，那就不一样了。</p><p id="b0ce" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果代码在你的控制之下，你可以也应该避免不纯的静态方法。但是如果你不得不使用一个库或者框架中静态方法，而且你不能避免它们，你能做什么呢？</p><p id="b6ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，我们想使用<a class="ae jg" href="https://www.twilio.com/" rel="noopener ugc nofollow" target="_blank"> Twillo </a>发送短信通知。</p><p id="d894" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Twillo SDK提供了静态方法<code class="eh kt ku kv kw b">Message.creator</code>，这是一个构造<code class="eh kt ku kv kw b">MessageCreator</code>的工厂方法。实际向Twillo请求发送短信的方法是<code class="eh kt ku kv kw b">messageCreator.create(restClient)</code>。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="189c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然<code class="eh kt ku kv kw b">Message.creator</code>是纯粹的，但是<code class="eh kt ku kv kw b">messageCreator.create(restClient)</code>也就是<code class="eh kt ku kv kw b">Message.creator</code>的结果却不是。所以我们需要通过首先清除<code class="eh kt ku kv kw b">Message.creator</code>的返回值来模拟<code class="eh kt ku kv kw b">create</code>方法。但是由于<code class="eh kt ku kv kw b">Message.creator</code>是静态的，我们没有办法进去。</p><p id="27f1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有人可能会说:我们可以围绕这个静态方法创建一个包装器类，这样我们就可以模仿这个包装器。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="58d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是测试的目的是增加你对代码的信心。仅仅为了测试而增加另一层间接性并不会增加被测系统的可信度，反而会增加代码库的复杂性。</p><p id="8f2f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，如果添加包装器有助于您改善团队使用API的编码体验，并且它被大量使用，那么它可能值得投资，而不仅仅是为了测试。</p><p id="bb5e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，有没有更精益的方法呢？</p><h2 id="adfa" class="ld le hu bd lf lg lh li lj lk ll lm ln js lo lp lq jw lr ls lt ka lu lv lw lx dt translated">高阶函数FTW</h2><p id="3147" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">我们想以某种方式创建一条路径，用别的东西来代替<code class="eh kt ku kv kw b">Message.creator</code>。在科特林和其他许多语言中，函数被视为一等公民。最小的可重用组件不再是类，而是函数。所以你可以像其他物体一样传递函数。</p><p id="acb5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在严格的函数和数学意义上，函数必须是纯函数。但是在科特林的上下文中，函数似乎是允许不纯的。</p><p id="da40" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Kotlin中方法和函数的区别在于，方法与对象相关联，而函数不需要。你可以看到,<code class="eh kt ku kv kw b">fun</code>关键字到处引用函数，不管是方法声明还是顶级函数声明，这意味着函数是方法的超集，至少在这个上下文中是这样。</p><p id="0c61" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是什么是高阶函数呢？</p><p id="d36f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">高阶函数基本上是指以函数为参数或返回函数的函数。</p><p id="e3b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使没有函数作为参数且不返回函数的函数被称为一阶函数，这里使用的术语高阶函数而不是二阶或三阶，因为理论上，我们可以将“具有函数作为参数或返回函数的函数”嵌套无限多个级别。所以它高于二阶或三阶。</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><p id="0671" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们回到我们的主题。所以我们想把<code class="eh kt ku kv kw b">Message.creator</code>注入到<code class="eh kt ku kv kw b">notify</code>中，我们可以通过让<code class="eh kt ku kv kw b">notify</code>成为一个高阶函数来实现，这样我们就可以把<code class="eh kt ku kv kw b">Message.creator</code>作为一个参数传入。</p><p id="90b0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了做到这一点，第一步，我们需要得到正确的类型。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="2fa1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们弄清楚这个特殊函数的类型。下面是最初的<code class="eh kt ku kv kw b">creator</code>在SDK中的实现:</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="2014" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以它有一个类型</p><pre class="kx ky kz la fq mk kw ml mm aw mn dt"><span id="04ab" class="ld le hu kw b fv mo mp l mq mr">(PhoneNumber, String, String) -&gt; MessageCreator</span></pre><p id="da78" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这意味着参数类型在箭头“<code class="eh kt ku kv kw b">-&gt;</code>”的左边，返回类型在右边。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="66a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们定义我们的<code class="eh kt ku kv kw b">typealias</code>来引用这个函数类型，并为了可读性而命名它。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="68f7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是现在，我们只是改变了我们的接口，这不是很好，因为通常我们不需要传递<code class="eh kt ku kv kw b">creator</code>到<code class="eh kt ku kv kw b">notify</code>，除非是在测试中。</p><p id="53c3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Kotlin中，我们可以通过提供默认参数来避免这种情况。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="da15" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以现在，我们现有的界面保持不变，我们有自己的方式！</p><h2 id="62d5" class="ld le hu bd lf lg lh li lj lk ll lm ln js lo lp lq jw lr ls lt ka lu lv lw lx dt translated">来嘲讽一下吧！</h2><p id="f553" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">我在这里使用了<a class="ae jg" href="https://spekframework.org/" rel="noopener ugc nofollow" target="_blank"> Spek </a>和<a class="ae jg" href="https://github.com/nhaarman/mockito-kotlin" rel="noopener ugc nofollow" target="_blank"> mockito-kotlin </a>。</p><p id="0d57" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们定义了一个返回模拟的<code class="eh kt ku kv kw b">MessageCreator</code>的<code class="eh kt ku kv kw b">creator</code>，这个stub <code class="eh kt ku kv kw b">create</code>方法返回我们想要的<code class="eh kt ku kv kw b">Message</code>。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="0157" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能会问，在第22行:</p><ul class=""><li id="0aca" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">为什么不直接用<code class="eh kt ku kv kw b">Message</code>构造函数呢？= &gt;是私人的。</li><li id="48a4" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">为什么我们不嘲笑getters？= &gt;就这么定了。</li></ul><p id="3a04" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们最终使用<code class="eh kt ku kv kw b">fromJson</code>来代替。</p><p id="97da" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> <em class="ms">编辑2018年7月14日:</em> </strong> <a class="mt mu gr" href="https://medium.com/u/417d954d6bf5?source=post_page-----614df89482ae--------------------------------" rel="noopener" target="_blank"> <em class="ms">大卫基什内尔</em> </a> <em class="ms">指出mockito 2已经可以嘲讽</em> <code class="eh kt ku kv kw b"><em class="ms">final</em></code> <em class="ms">类和方法了。</em>见全反应<a class="ae jg" rel="noopener" href="/@dpkirchner/mockito-now-supports-mocking-final-classes-natively-although-you-have-to-opt-in-and-be-aware-of-37fa0545d20e">见<em class="ms">此处</em>见</a></p><p id="81a2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">而我用<code class="eh kt ku kv kw b">::creator</code>引用<code class="eh kt ku kv kw b">creator</code>函数，它会当作一个值。另一种方法，我们可以使用lambda并将其分配给<code class="eh kt ku kv kw b">val</code>而不是<code class="eh kt ku kv kw b">fun</code>。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="cc1b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过使用lambda，我们可以忽略使用<code class="eh kt ku kv kw b">_</code>的参数，因为我们不在这个上下文中使用它。如果我们用<code class="eh kt ku kv kw b">fun</code>来定义它，这是不可能的。</p><p id="2da5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关于这些函数和lambdas如何工作的更多信息，你可以在Kotlin文档中找到。</p><p id="db3d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可能想要验证是否用正确的参数调用了<code class="eh kt ku kv kw b">creator</code>。问题是mockito的<code class="eh kt ku kv kw b">verify</code>只支持方法调用验证。我们如何验证<code class="eh kt ku kv kw b">creator</code>没有关联到任何对象？</p><p id="93f7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但结果是，function实际上只是一个带有<code class="eh kt ku kv kw b">invoke</code>方法的类，所以我们可以模仿function类型，而不是自己创建function。这样，mockito可以验证该函数的<code class="eh kt ku kv kw b">invoke</code>方法是否被正确的参数调用。这是函数在标准库中的定义方式。</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="b3a4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们知道，我们可以模拟我们的函数来验证调用，我们也可以存根返回值。让我们双管齐下！</p><figure class="kx ky kz la fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="567e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如您所看到的，我们可以验证我们的函数调用，并在不破坏语言的情况下清除静态方法的返回值。</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h2 id="2aac" class="ld le hu bd lf lg lh li lj lk ll lm ln js lo lp lq jw lr ls lt ka lu lv lw lx dt translated">摘要</h2><p id="bf26" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">我们正在利用语言的高阶函数和默认参数特性，允许我们将静态方法注入到我们想要测试的函数中，这样我们就可以模仿/存根它，同时保留旧的接口。任何具有这两种特性的语言也可以使用相同的技巧。</p><p id="0309" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我希望你已经明白了。</p><p id="4045" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢阅读！享受测试:D</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><p id="5a04" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在twitter上关注我<a class="ae jg" href="https://twitter.com/ibossptk" rel="noopener ugc nofollow" target="_blank"> @ibossptk </a></p></div></div>    
</body>
</html>