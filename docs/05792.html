<html>
<head>
<title>Switch from Meteor to GraphQL: Secrets of Hassle-Free Migration Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Meteor到GraphQL的转换:无障碍迁移过程的秘密</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/switch-from-meteor-to-graphql-secrets-of-hassle-free-migration-process-3bbfda4e4c40?source=collection_archive---------25-----------------------#2018-07-10">https://medium.com/hackernoon/switch-from-meteor-to-graphql-secrets-of-hassle-free-migration-process-3bbfda4e4c40?source=collection_archive---------25-----------------------#2018-07-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/30b670c89c2934ff8748b4a09826a954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tx8_spzGQ4rTWG4V9bihtw.jpeg"/></div></div></figure><div class=""/><p id="e200" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我决定写这篇文章的原因是，目前我们的团队正在将一个复杂的应用程序从Meteor迁移到GraphQL。在描述我们为什么要这样做之前，我想简单地讲一下这个项目的概念。</p><p id="625b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们正在进行的项目是一个<a class="ae ka" href="https://apiko.com/blog/how-we-built-a-work-order-management-system-case-study/" rel="noopener ugc nofollow" target="_blank">工作订单管理应用</a>——一个连接按需服务提供商(提供垃圾箱租赁、污水处理、景观和设备管理等服务)的复杂系统。)和不同规模的公司。</p><p id="ed54" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该平台帮助公司管理工作订单，跟踪所有文件，自动化发票处理和消除文书工作。该应用程序由3个产品组成，可以根据公司需求进行定制</p><ul class=""><li id="fb20" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">公司的工作订单网站，在这里他们可以创建和跟踪工作请求，分配供应商，创建报告，管理发票等。</li><li id="33ab" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">面向技术人员的工作订单移动应用程序，允许留下已完成工作的报告，跟踪他们的工作时间，设置工作可用性等。</li><li id="4511" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">聊天机器人系统，自动处理来自公司的请求，并创建工作订单。</li></ul><p id="cf56" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您所看到的，这个项目由处理大量用户、请求和数据的不同应用程序组成。该产品更重要的一个方面是，它必须实时处理所有数据。这就是为什么我们选择了流星来建造MVP。</p><h1 id="b2c6" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">MVP的流星。为什么我们为这个项目选择了流星</h1><p id="4955" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated"><a class="ae ka" href="https://www.meteor.com/" rel="noopener ugc nofollow" target="_blank"> Meteor </a>是一个全栈JavaScript框架，涵盖了编写web或移动应用的所有方面。它提供了简化开发过程的现成工具。Meteor的另一个关键特性是默认的反应式数据流。所有数据都实时存在于客户端，因此数据库中的更改会立即填充到所有连接的客户端。</p><p id="5cd2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当涉及到MVP开发时，Meteor是非常有用的——你可以在几分钟内开始，并推迟做出关于应用程序架构的超级复杂的决定，直到你真正需要它们。正如Donald Knuth所说:“过早优化是万恶之源”，所以你知道我的意思。</p><p id="ba98" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">流星还与最流行的前端库(React、Angular、Vue)有很大的集成，托管即服务，与<a class="ae ka" href="https://oauth.net/" rel="noopener ugc nofollow" target="_blank"> OAuth </a>的集成(这里说的是社交网络登录)并建立了零配置构建系统(说说web pack配置，我说的对吗？).</p><p id="3b8a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你还可以使用Meteor(使用Cordova)轻松构建和发布Android和iOS应用，这些应用不如原生应用好，但非常适合MVP，甚至是简单产品的生产就绪应用。</p><p id="3e0d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你想构建一个MVP时，Meteor就派上了用场——你只需要专注于外观、感觉和功能。此外，Meteor允许构建实时web应用程序(如聊天、游戏、协作工具等)。)轻松。这对任何应用程序来说都很方便，用户很快就会依赖他们应用程序中的实时数据，而您可以立即向他们提供这些数据。</p><h1 id="b628" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">我们什么时候决定从Meteor迁移到GraphQL的？</h1><p id="dd4c" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">随着我们的应用程序变得越来越大，各种客户端的更多需求(很少的web和移动应用程序、微服务和第三方应用程序)出现在地平线上，我们已经意识到我们需要更通用和可扩展的后端解决方案。</p><p id="3f08" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显而易见的选择是使用任何语言构建REST服务器。但既然生活在2018年，就有更好的。女士们先生们，我向你们介绍GraphQL(其实不是我，但主要是脸书。您可以在<a class="ae ka" href="https://apiko.com/blog/tag/graphql/" rel="noopener ugc nofollow" target="_blank">我们的文章</a>中深入了解GraphQL的特性。</p><p id="76b5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简而言之，GraphQL是一种查询语言，它允许你以一种非常明确和简洁的方式处理应用程序的数据层。它关注的是实体之间的联系(即“图”)。它用大多数流行的语言实现，并有各种客户端框架。我们选择了Apollo GraphQL系列库(不是框架或库，Carl！)</p><figure class="lt lu lv lw fq hw fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/8f6d1b338248ffcead97c748fc0b38e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/0*Zp5NXCpMb70zSu0Z.jpeg"/></div></figure><p id="cd2a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是GraphQL(尤其是Apollo)的主要优势。</p><h1 id="e7ad" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">GraphQL的主要优势</h1><ul class=""><li id="ca2a" class="kb kc if je b jf ln jj lo jn lx jr ly jv lz jz kg kh ki kj dt translated"><strong class="je ig">需要为多个app提供API端点</strong></li></ul><p id="536e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL非常适合作为多个客户端的中介，因为它为大多数平台提供了库。即使不可能或不想使用客户机库，你也可以发布一些JSON，它就能工作了！</p><ul class=""><li id="3993" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig"> GraphQL鼓励增量采用</strong></li></ul><p id="8c0b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以保持之前的所有投资不变，并使用GraphQL server添加新功能。这对我们的案子来说太完美了！</p><ul class=""><li id="05f6" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig"> GraphQL几乎是技术不可知的</strong></li></ul><p id="f4b6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为大多数语言中都有GraphQL实现，所以您可以很容易地切换到另一个技术栈。数据源也是如此。您可以使用任何数据库或外部资源来管理数据。这也促进了与第三方服务的集成，这是我们心中的需求。</p><ul class=""><li id="e171" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig"> GraphQL易于扩展和拆分为微服务</strong></li></ul><p id="da34" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于每个解析器都是独立的，所以您可以轻松地将一些应用程序托管为无服务器功能，甚至是具有不同堆栈和硬件资源的独立服务。</p><ul class=""><li id="df20" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig">像Apollo这样的库涵盖了许多关于构建API的复杂决策</strong></li></ul><p id="c412" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当从头开始编写REST server时，你很容易弄乱它的架构，并在将来让它飞起来时遇到麻烦。这尤其与您的应用程序的控制器级别相关。</p><ul class=""><li id="a388" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig"> GraphQL负责数据中实体之间的连接</strong></li></ul><p id="5310" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您最终可以将数据库规范化，因为所有的连接都将被覆盖。这给了我们一些额外的好处，我们将在后面介绍。但总的来说，这是GraphQL背后的主要思想之一，它真的很重要！想要更高级的描述？看看这篇<a class="ae ka" href="https://blog.apollographql.com/graphql-explained-5844742f195e" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><ul class=""><li id="212e" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig">它有一个很棒的客户端基础设施</strong></li></ul><p id="98a0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以真正享受在客户端使用GraphQL。客户端应用程序可以以人类可读的方式轻松定义它需要的数据。没有多余的信息传输，这意味着更少的流量使用和更快的加载时间。此外，使用查询散列，您基本上只能通过网络发送数据。只要看看CDN 上的<a class="ae ka" href="https://www.apollographql.com/docs/guides/performance.html#CDN-Integration" rel="noopener ugc nofollow" target="_blank">托管查询和响应——太棒了！</a></p><p id="cc24" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着应用程序的增长，自动测试对于促进变更和改进代码库是必不可少的。缺乏测试覆盖将很可能导致更长的开发时间，更高的易错性和整体挫败感。因为GraphQL架构的核心是纯函数形式的解析器，所以测试它们是一件非常愉快的事情！Meteor也提供了一个复杂的测试框架，但是由于大量的技术细节，它过于复杂并且混淆了测试。</p><ul class=""><li id="fd6c" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig">面向开发者的强大功能</strong></li></ul><p id="0bbe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它们包括客户端开发工具、对乐观渲染和订阅的支持、GraphiQL的自动文档、对FP范式和类型的强大支持、性能监控和优化工具。</p><h1 id="d674" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">切换到GraphQL的过程</h1><p id="8e1b" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">由于GraphQL支持增量采用，我们开始用GraphQL端点替换旧功能并构建新功能。除了少数例外，这是一个相当平稳的过渡。让我们来看一个从Meteor到GraphQL的某个特定实体集合的<strong class="je ig">简短描述:</strong></p><ul class=""><li id="9bd6" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">为GraphQL服务器中的查询和变化创建模式和解析器。</li><li id="e9e7" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">用测试来覆盖它。可选(不，不是)。我们更喜欢TDD，但这取决于你。</li><li id="de8b" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">用Apollo客户端代替通过Meteor获取数据。</li><li id="20e6" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">用突变代替流星方法。</li><li id="bed4" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">如果需要，创建和添加订阅，使您的数据具有流星般的反应能力。</li><li id="2434" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">替换对查询GraphQL端点时保留的已移除的сcollection的引用。</li><li id="b681" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">从Meteor中删除与实体相关的代码。</li></ul><p id="a2bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这种方式，您可以用更灵活的GraphQL替换现有的Meteor堆栈。</p><h1 id="792c" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">从Meteor迁移到GraphQL的主要挑战和困难以及如何解决它们</h1><p id="6c4c" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">现在我们来谈谈正经事。你知道那种感觉吗，当你读一些到处都是小马和彩虹的文章，然后你开始写一些类似的东西，它变成了吸血鬼和墓地。我想避免这样的经历。</p><p id="4ab9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">众所周知，我们在转型过程中遇到了一些相当严重的问题，我们花了一些时间才找到最佳解决方案。让我们在这里深入了解更多细节。</p><p id="3202" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">问题一。流星般的取乐</strong>。正如我之前提到的，用户倾向于期望数据随时实时更新。对于Meteor来说或多或少有些琐碎的事情，对于Apollo GraphQL来说需要一个非常健壮的设置。更糟糕的是，用于订阅的API还没有完全开发和稳定。</p><p id="cef2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">您可以选择以下解决方案之一</strong>:</p><ul class=""><li id="3ab7" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">让您的订阅通知客户端数据已更改，并使其重新获取所有当前视图</li><li id="3b56" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">通知客户端对特定数据的更改，并使其重新获取一些特定的查询</li><li id="3033" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">实现全面订阅，通过订阅传递所有必要的数据并更新视图。</li></ul><p id="b096" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前两个选项可能比轮询好，但仍然很难看。让我们用下面的例子简要描述第三种解决方案:</p><ul class=""><li id="dbde" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">假设你有一个简单的TODO应用程序，它有TODO本身和一个与这个TODO相关的任务。</li><li id="3e90" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">使用文档中描述的方法在您的服务器上创建TODOs订阅。</li><li id="b80c" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">在您的TODO项目更改时添加简单的发布。你可以在你的变异解析器中放一些处理器，使用一些钩子或者尝试新的Mongo <a class="ae ka" href="https://docs.mongodb.com/manual/changeStreams/" rel="noopener ugc nofollow" target="_blank">改变流</a>，如果你使用的是MongoDB的话。</li><li id="0f38" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">这里需要注意几点:有时你需要在其他实体发生变更时发布对相关实体的变更。例如，假设您可以独立于任务的待办事项来更新任务。在这种情况下，您需要发布此TODO，以获得相关的订阅更新视图，而不管TODO本身是否发生变化。</li></ul><p id="7a38" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最棘手的部分是客户端实现。</p><p id="f46d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为此，您需要:</p><ol class=""><li id="d9c7" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz ma kh ki kj dt translated">使用普通查询来查询数据</li><li id="0da0" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz ma kh ki kj dt translated">使用完全相同的字段集订阅此数据更改</li><li id="df66" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz ma kh ki kj dt translated">如果订阅的参数已更改(例如，您有一个带过滤器的表),请关闭旧的订阅并启动新的订阅。当筛选器更改时，关闭当前订阅并启动新的订阅。)</li><li id="fd01" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz ma kh ki kj dt translated">如果一切顺利，Apollo将自动更新存储的数据和视图。</li><li id="99ef" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz ma kh ki kj dt translated">您可以围绕默认的Apollo helper创建一个非常简单的包装器来执行上面提到的操作。</li></ol><p id="d167" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，与Meteor相比，Apollo的订阅相当复杂。但是GraphQL还在不断发展中，它们可能很快就会变得容易得多。特别是，有一个“实时查询”的概念，这将使上述一切更加方便。(查看这篇<a class="ae ka" href="https://blog.apollographql.com/the-next-step-for-realtime-data-in-graphql-b564b72eb07b" rel="noopener ugc nofollow" target="_blank">文章</a>了解更多信息)</p><p id="eace" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">问题二。不想要也是朋友</strong>。计算机科学中有一个常见的已知问题，称为“n + 1”。当您试图加载带有指向其他项目的链接的某些项目的列表时，会出现这种情况。</p><p id="8e14" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，您查询包含导演的电影列表。在GraphQL中，每部电影的导演将被单独加载，从而增加数据库的负载。幸运的是，脸书有一个很棒的工具叫做<a class="ae ka" href="https://github.com/facebook/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>。</p><p id="211f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然它看起来很神奇，但它非常简单，我强烈建议您深入了解它的实现(大约250行代码)。我就不赘述了，因为网上有很多文章<a class="ae ka" rel="noopener" href="/slite/avoiding-n-1-requests-in-GraphQL-including-within-subscriptions-f9d7867a257d">或者文档</a>里有很多文章或者<a class="ae ka" href="https://www.apollographql.com/docs/" rel="noopener ugc nofollow" target="_blank">。我很高兴现在你被告知并且安全了。</a></p><p id="3802" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">问题三。帮我找到这个。</strong>您可能对这个常见场景很熟悉:用户应该能够对他们在表中看到的每个字段使用全文搜索。现在设想一个表，其中有来自多个实体的数据，例如:收视率、票房、原产国。</p><figure class="lt lu lv lw fq hw fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/1b53f18481ae222e82081071b5ab7036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/0*IAhd_apHen83NtL_.png"/></div></figure><p id="e235" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至于这是一个“电影”表，它由4个不同实体的数据组成——电影、演员、分级、国家。如果用户想使用单个字段在所有数据库中搜索这些实体中的任何一个，那就麻烦了。事情是这样的，当你搜索一个演员的电影时，你需要找到这个演员，然后找到这个演员的电影，并返回包含所有相关数据的电影。</p><p id="43b2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，你应该为每一个可能的场景都这样做，而且要快。如果您在一些更传统的环境中，您可以使用“like”搜索进行一些连接并返回结果。这时，专门的第三方服务机构就会出手相救。我们选择了<a class="ae ka" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank">弹性搜索</a>。</p><p id="c97e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您需要做的就是配置Elastic，将您的数据加载到服务中，并使用Elastic API解析您的GraphQL搜索查询。不要忘记更新你的数据。我希望你不需要实时数据，是吗？是的，没那么简单。我们将在接下来的文章中更详细地介绍这一点。</p><p id="2c7d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样做的好处是，使用GraphQL，您仍然可以拥有实体间关系的强大功能。当你有了你的弹性电影搜索结果，GraphQL会自动把它和演员，收视率，国家联系在一起！</p><p id="ebc7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您开始从Meteor到GraphQL的迁移时，我想提几个需要记住的更重要的事情:</p><ul class=""><li id="eb3c" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je ig">认证和授权</strong>——你需要弄清楚流星认证。机制，并用几行代码和原始节点库代替它。您还需要在GraphQL和Meteor服务器上登录一个用户。</li><li id="4702" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je ig">深究GraphQL的思维方式，然后再做出重大举措</strong>。以最佳方式做事可能需要时间，因为在软件开发中用图表思考并不常见。您通常会尝试为特定请求获取所有可能的数据，并根据用户需求进行拼接。但是使用GraphQL，你需要专注于只获得用户要求的根，让奇迹发生。</li><li id="4a98" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">尝试根据现有的关系为你的模式建模。不要创建类似<code class="eh mc md me mf b">movies (actor) {}</code>的查询。用<code class="eh mc md me mf b">Actor { movies }</code>就行了。</li><li id="cf89" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je ig">阅读文档时不要跳过接口和联合</strong>。这些都是非常强大的工具，可以在很多场合派上用场。</li><li id="bfd6" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je ig">请记住，GraphQL实现发展非常迅速</strong>，您昨天使用的API可能明天就会过时。每周都有更好的做事方式和令人敬畏的有用工具出现。所以你必须忍受它。</li><li id="3633" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je ig">Apollo stack某些部分的文档可能不完整</strong>、过时或混乱。您需要找到一些文章，甚至钻研源代码，写出您自己的文章。或者几篇文章。</li></ul><h1 id="edc0" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">迁移还是不迁移？</h1><p id="123d" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">总而言之——graph QL和Meteor是web应用程序开发的绝佳工具。Meteor让您轻松启动，非常适合中小型实时应用程序。但是，如果您需要很大的灵活性，需要支持多个客户端并拥有复杂的分布式数据层，GraphQL 是一个不错的选择。</p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="43a1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mn">原载于2018年7月10日</em><a class="ae ka" href="https://apiko.com/blog/switch-from-meteor-to-graphql/" rel="noopener ugc nofollow" target="_blank"><em class="mn">apiko.com</em></a><em class="mn">。</em></p></div></div>    
</body>
</html>