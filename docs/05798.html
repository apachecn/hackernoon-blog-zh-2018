<html>
<head>
<title>Scaling Microservices with Message Queues, Spring Boot and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过消息队列、Spring Boot和Kubernetes扩展微服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scaling-microservices-with-message-queues-spring-boot-and-kubernetes-9ba4b0e48bdf?source=collection_archive---------2-----------------------#2018-07-11">https://medium.com/hackernoon/scaling-microservices-with-message-queues-spring-boot-and-kubernetes-9ba4b0e48bdf?source=collection_archive---------2-----------------------#2018-07-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/28e89a43054d355f1c968eca06320bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EYkQh1w1msyxqcl6.png"/></div></div></figure><p id="8973" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您大规模设计和构建应用程序时，您需要应对两个重大挑战:<strong class="je hv">可伸缩性和健壮性</strong>。</p><p id="1394" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该设计您的服务，以便即使它受到间歇性重负载的影响，也能继续可靠地运行。</p><p id="ae3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">以苹果专卖店为例。</em></p><p id="d265" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每年都有数以百万计的苹果用户预先注册购买新的iPhone。</p><p id="f8bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那是数百万人同时购买一件商品。</p><p id="b853" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您将苹果商店的流量描绘为一段时间内每秒的请求数，图表可能是这样的:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/78699f48fb6ff5d67b960101a358da25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZn69gOs0bNR-sBbreoXbA.png"/></div></div></figure><p id="9459" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，假设您面临构建此类应用程序的挑战。</p><p id="30bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">你正在建立一个商店，用户可以在那里购买他们喜欢的商品。</strong></p><p id="2c2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您构建一个微服务来呈现网页和服务静态资产。</p><p id="be4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您还构建了一个后端REST API来处理传入的请求。</p><p id="37e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您希望将这两个组件分开，因为使用相同的REST API，您可以为网站和移动应用程序提供服务。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/f91638717967fdea7b8f007e59d91b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*J32K3B5vresK9z1l70wQ2Q.gif"/></div></div></figure><p id="4756" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今天是个大日子，你的店开始营业了。</p><p id="b67a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您决定将应用程序的前端扩展到四个实例，后端扩展到四个实例，因为您预计网站会比平时更加繁忙。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/98c0c0e9eb224a692299d7c516d591d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PwTIFhIbrEqoQD3SxGZFDQ.gif"/></div></div></figure><p id="b81b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你开始收到越来越多的流量。</p><p id="ac1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前端服务正在处理流量罚款。</p><p id="cdf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您注意到连接到数据库的后端正在努力跟上事务的数量。</p><p id="f683" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不用担心，您可以将后端的副本数量扩展到8个。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/ed304fd7d90bfd1ef5f0be8b1c05566a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w4A1g8im1BhkF83Y6eCE-w.gif"/></div></div></figure><p id="ebd4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你收到的流量越来越多，后端处理不了。</p><p id="c7c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一些服务开始断开连接。</p><p id="bc63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">愤怒的顾客联系你的客服。</p><p id="765b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你淹没在车流中。</p><p id="0e64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你的后端处理不了它，它会丢失大量的连接。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/6608ba546e7876be9ca8294f23f7ff8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0HW4QXm7SDQTyMpqYrGeZw.gif"/></div></div></figure><p id="7aa0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你刚刚损失了一大笔钱，你的顾客很不高兴。</p><p id="086d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的应用程序没有被设计为健壮和高度可用:</p><ul class=""><li id="0074" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">前端和后端是紧密耦合的— <em class="ka">事实上，没有后端it就无法处理应用程序</em></li><li id="f59d" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">前端和后端必须协调扩展— <em class="ka">如果没有足够的后端，您可能会淹没在流量中</em></li><li id="d24c" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">如果后端不可用，您将无法处理传入的事务。</li></ul><p id="f2f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">交易的损失就是收入的损失。</p><p id="ccbc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以重新设计您的体系结构，用队列来分离前端和后端。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/ff0e9bb46869222933930dbb682b47ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w0v6zBC0n6jWs5xg790Ncg.gif"/></div></div></figure><p id="f586" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前端将消息发布到队列中，而后端一次处理一个挂起的消息。</p><p id="a6dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新架构有一些明显的优势:</p><ul class=""><li id="86a8" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">如果后端不可用，队列就充当缓冲区</li><li id="073d" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">如果前端生成的消息超过了后端可以处理的数量，那么这些消息将被缓存在队列中</li><li id="2d2b" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">您可以独立于前端扩展后端，也就是说，您可以拥有数百个前端服务和一个后端实例</li></ul><p id="aa98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很好，但是你如何构建这样的应用程序呢？</p><p id="b5e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如何设计一个可以处理成千上万个请求的服务？</p><p id="4d19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">您如何部署可动态扩展的应用程序？</em></p><p id="a96b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在深入部署和扩展的细节之前，让我们先来关注一下应用程序。</p><h1 id="8556" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">编写Spring应用程序</h1><p id="b72e" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">该服务有三个组件:前端、后端和消息代理。</p><p id="9d41" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前端是一个简单的<a class="ae ly" href="https://hackernoon.com/tagged/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>网络应用程序与百里香叶模板引擎。</p><p id="6c8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">后端是一个使用队列中的消息的工作进程。</p><p id="5d76" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于Spring Boot与JSM有很好的集成，你可以用它来发送和接收异步消息。</p><p id="157f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以在<a class="ae ly" href="https://github.com/learnk8s/spring-boot-k8s-hpa" rel="noopener ugc nofollow" target="_blank">learn k8s/spring-boot-k8s-HPA</a>找到一个包含连接到JSM的前端和后端应用程序的示例项目。</p><blockquote class="lz ma mb"><p id="0c85" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated"><em class="hu">请注意，应用程序是用</em><a class="ae ly" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"><em class="hu">Java</em></a><em class="hu">10来杠杆化</em> <a class="ae ly" href="https://blog.docker.com/2018/04/improved-docker-container-integration-with-java-10/" rel="noopener ugc nofollow" target="_blank"> <em class="hu">改进的Docker容器集成</em> </a> <em class="hu">。</em></p></blockquote><p id="8deb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一个单一的代码库，你可以配置项目作为前端或后端运行。</p><p id="4cea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该知道该应用程序具有:</p><ul class=""><li id="199f" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">你可以购买物品的主页</li><li id="17e6" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">一个管理面板，您可以在其中检查队列中的邮件数量</li><li id="f461" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">一个<code class="eh mf mg mh mi b">/health</code>端点，当应用程序准备好接收流量时发出信号</li><li id="db78" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">接收表单提交并在队列中创建消息的<code class="eh mf mg mh mi b">/submit</code>端点</li><li id="68cb" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">一个<code class="eh mf mg mh mi b">/metrics</code>端点，用于公开队列中待处理消息的数量(稍后将详细介绍)</li></ul><p id="453d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该应用程序可以两种模式运行:</p><p id="7f66" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">作为前端</strong>，应用程序呈现人们可以购买物品的网页。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/01662fd08882513ee163797f4b00a7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qPDgvcK9fMtjwbsF.png"/></div></div></figure><p id="152e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">作为一个工作者</strong>，应用程序在队列中等待消息并处理它们。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/301473d6e55874ed1797db933aebd3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*75ja5bugOE5Z5hQr.png"/></div></div></figure><blockquote class="lz ma mb"><p id="e444" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated"><em class="hu">请注意，在示例项目中，通过使用</em> <code class="eh mf mg mh mi b"><em class="hu">Thread.sleep(5000)</em></code> <em class="hu">等待五秒钟来模拟加工。</em></p></blockquote><p id="e9fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过改变<code class="eh mf mg mh mi b">application.yaml</code>中的值，您可以在任一模式下配置应用程序。</p><h1 id="4a01" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">试运行应用程序</h1><p id="a184" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">默认情况下，应用程序作为前端和工作程序启动。</p><p id="ab96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以运行应用程序，只要您有一个本地运行的ActiveMQ实例，您就应该能够购买商品并让系统处理这些商品。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/6855870c7aa16812d96025a8d655c155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s4fyYQEqvYlrNS8v.gif"/></div></div></figure><p id="ff99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您检查日志，您应该看到工作人员正在处理项目。</p><p id="0de7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">成功了！</p><p id="5424" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编写Spring Boot应用程序很容易。</p><p id="36c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个更有趣的主题是学习如何将Spring Boot连接到消息代理。</p><h1 id="e72f" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">使用JMS发送和接收消息</h1><p id="8f11" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">Spring JMS (Java消息服务)是一种使用标准协议发送和接收消息的强大机制。</p><p id="9042" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您过去使用过JDBC API，您应该会发现JMS API很熟悉，因为它的工作方式类似。</p><p id="42be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以使用JMS的最流行的消息代理是<a class="ae ly" href="http://activemq.apache.org/" rel="noopener ugc nofollow" target="_blank">ActiveMQ</a>——一个开源消息服务器。</p><p id="d61b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这两个组件，您可以使用熟悉的接口(JMS)将消息发布到队列(ActiveMQ ),并使用相同的接口接收消息。</p><p id="1a30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更好的是，Spring Boot与JMS有很好的集成，所以你可以很快上手。</p><p id="9b9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，下面的短类封装了用于与队列交互的逻辑:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="0ebf" class="mo kw hu mi b fv mp mq l mr ms"><strong class="mi hv">@Component</strong></span><span id="6a82" class="mo kw hu mi b fv mt mq l mr ms"><strong class="mi hv">public</strong> <strong class="mi hv">class</strong> QueueService <strong class="mi hv">implements</strong> MessageListener {</span><span id="1938" class="mo kw hu mi b fv mt mq l mr ms"><strong class="mi hv">  private</strong> <strong class="mi hv">static</strong> <strong class="mi hv">final</strong> <strong class="mi hv">Logger</strong> LOGGER = LoggerFactory.getLogger(QueueService.class);</span><span id="135b" class="mo kw hu mi b fv mt mq l mr ms"><strong class="mi hv">  @Autowired<br/>  private</strong> <strong class="mi hv">JmsTemplate</strong> jmsTemplate;<br/>  <strong class="mi hv">public</strong> <strong class="mi hv">void</strong> send(<strong class="mi hv">String</strong> destination, <strong class="mi hv">String</strong> message) {<br/>    LOGGER.info("sending message='{}' to destination='{}'", message, destination);<br/>    jmsTemplate.convertAndSend(destination, message);<br/>  }</span><span id="01de" class="mo kw hu mi b fv mt mq l mr ms"><strong class="mi hv">  @Override<br/>  public</strong> <strong class="mi hv">void</strong> onMessage(<strong class="mi hv">Message</strong> message) {<br/>    if (message instanceof ActiveMQTextMessage) {<br/>      <strong class="mi hv">ActiveMQTextMessage</strong> textMessage = (ActiveMQTextMessage) message;<br/>      try {<br/>        LOGGER.info("Processing task " + textMessage.getText());<br/>        Thread.sleep(5000);<br/>        LOGGER.info("Completed task " + textMessage.getText());<br/>      } catch (<strong class="mi hv">InterruptedException</strong> e) {<br/>        e.printStackTrace();<br/>      } catch (<strong class="mi hv">JMSException</strong> e) {<br/>        e.printStackTrace();<br/>      }<br/>    } else {<br/>      LOGGER.error("Message is not a text message " + message.toString());<br/>    }<br/>  }<br/>}</span></pre><p id="8126" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<code class="eh mf mg mh mi b">send</code>方法将消息发布到命名队列。</p><p id="9470" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，Spring Boot将对每个传入的消息执行<code class="eh mf mg mh mi b">onMessage</code>方法。</p><p id="d3aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">拼图的最后一块是指导Spring Boot使用这个类。</p><p id="d0b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以通过<a class="ae ly" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jms-annotated-programmatic-registration" rel="noopener ugc nofollow" target="_blank">在Spring Boot应用程序</a>中注册监听器来在后台处理消息，如下所示:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="9e3e" class="mo kw hu mi b fv mp mq l mr ms"><strong class="mi hv">@SpringBootApplication<br/>@EnableJms<br/>public</strong> <strong class="mi hv">class</strong> SpringBootApplication <strong class="mi hv">implements</strong> JmsListenerConfigurer {<br/>  <strong class="mi hv">@Autowired<br/>  private</strong> <strong class="mi hv">QueueService</strong> queueService;</span><span id="2cda" class="mo kw hu mi b fv mt mq l mr ms"><strong class="mi hv">  public</strong> <strong class="mi hv">static</strong> <strong class="mi hv">void</strong> main(<strong class="mi hv">String</strong>[] args) {<br/>    SpringApplication.run(SpringBootApplication.class, args);<br/>  }</span><span id="05ad" class="mo kw hu mi b fv mt mq l mr ms"><strong class="mi hv">  @Override<br/>  public</strong> <strong class="mi hv">void</strong> configureJmsListeners(<strong class="mi hv">JmsListenerEndpointRegistrar</strong> registrar) {<br/>    <strong class="mi hv">SimpleJmsListenerEndpoint</strong> endpoint = new SimpleJmsListenerEndpoint();<br/>    endpoint.setId("myId");<br/>    endpoint.setDestination("queueName");<br/>    endpoint.setMessageListener(queueService);<br/>    registrar.registerEndpoint(endpoint);<br/>  }<br/>}</span></pre><p id="eebc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其中<em class="ka"> id </em>是消费者的唯一标识符，而<em class="ka">目的地</em>是队列的名称。</p><p id="bf42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以从Github上的项目中阅读Spring queue服务的完整源代码。</p><p id="98b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，您如何能够用不到40行代码编写一个可靠的队列。</p><p id="29ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你会爱上Spring Boot的。</p><h1 id="a1cc" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">您在部署中节省的所有时间都可以集中在编码上</h1><p id="381b" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">您已经验证了应用程序可以工作，现在终于到了部署它的时候了。</p><p id="de65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，您可以启动VPS，安装Tomcat，花一些时间编写定制脚本来测试、构建、打包和部署应用程序。</p><p id="d648" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，您可以编写一个描述，描述您希望拥有什么:一个消息代理和两个部署了负载平衡器的应用程序。</p><p id="5bae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像Kubernetes这样的编排者可以读取您的意愿列表，并提供合适的基础设施。</p><p id="1df4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为花在基础设施上的时间越少，意味着编码的时间越多，所以这次您将把应用程序部署到Kubernetes。</p><p id="8ed0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在开始之前，您需要一个Kubernetes集群。</p><p id="6332" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以注册一个谷歌云平台或Azure，并使用云提供商Kubernetes的产品。</p><p id="5a57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，在将应用程序迁移到云之前，您可以在本地尝试Kubernetes。</p><p id="e567" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">minikube</code>是打包成虚拟机的本地Kubernetes集群。</p><p id="235e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你使用的是Windows、Linux和Mac，它非常棒，因为创建一个集群只需要五分钟。</p><p id="1c17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您还应该安装<code class="eh mf mg mh mi b">kubectl</code>，客户端连接到您的集群。</p><p id="5361" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以从<a class="ae ly" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到如何安装<code class="eh mf mg mh mi b">minikube</code>和<code class="eh mf mg mh mi b">kubectl</code>的说明。</p><blockquote class="lz ma mb"><p id="69d1" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated"><em class="hu">如果你在Windows上运行，你应该看看我们的</em> <a class="ae ly" href="https://learnk8s.io/blog/installing-docker-and-kubernetes-on-windows" rel="noopener ugc nofollow" target="_blank"> <em class="hu">关于如何安装Kubernetes和Docker </em> </a> <em class="hu">的详细指南。</em></p></blockquote><p id="c444" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该使用8GB内存和一些额外的配置来启动集群:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="968b" class="mo kw hu mi b fv mp mq l mr ms">minikube start \<br/>  --memory 8096 \<br/>  --extra-config=controller-manager.horizontal-pod-autoscaler-upscale-delay=1m \<br/>  --extra-config=controller-manager.horizontal-pod-autoscaler-downscale-delay=2m \<br/>  --extra-config=controller-manager.horizontal-pod-autoscaler-sync-period=10s</span></pre><blockquote class="lz ma mb"><p id="65d9" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated"><em class="hu">请注意，如果您正在使用一个预先存在的</em> <code class="eh mf mg mh mi b"><em class="hu">minikube</em></code> <em class="hu">实例，您可以通过销毁它并重新创建它来调整虚拟机的大小。仅仅添加</em> <code class="eh mf mg mh mi b"><em class="hu">--memory 8096</em></code> <em class="hu">不会有任何效果。</em></p></blockquote><p id="b37d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该使用以下命令验证安装是否成功:</p><p id="f65c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该会看到一些资源以表格的形式列出。</p><p id="c23b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">集群已经准备好了，<em class="ka">也许你现在应该开始部署了？</em></p><p id="ce1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还没有。</p><p id="38e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你得先收拾好你的东西。</p><h1 id="3088" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">有什么比超级罐子更好？容器</h1><p id="f6ab" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">部署到Kubernetes的应用程序必须打包成容器。</p><p id="4598" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">毕竟，Kubernetes是一个容器编排器，所以它不能本地运行您的jar。</p><p id="3a23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">容器类似于fat jars:它们包含运行应用程序所需的所有依赖项。</p><p id="b20b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">甚至JVM也是容器的一部分。</p><p id="30b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以从技术上来说，他们是一个更胖的胖子。</p><p id="4174" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将应用程序打包成容器的一种流行技术是Docker。</p><blockquote class="lz ma mb"><p id="91c5" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated">虽然Docker是最流行的，但它并不是唯一能够运行容器的技术。其他热门选项还有<code class="eh mf mg mh mi b"><em class="hu">rkt</em></code><em class="hu"/><code class="eh mf mg mh mi b"><em class="hu">lxd</em></code><em class="hu">。</em></p></blockquote><p id="4519" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果没有安装Docker，可以按照Docker官方网站上的<a class="ae ly" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">说明进行操作。</a></p><p id="c888" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常，您构建您的容器并将它们推送到注册中心。</p><p id="5999" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这类似于将jar发布到Artifactory或Nexus。</p><p id="98f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在这个特殊的例子中，您将在本地工作并跳过注册表部分。</p><p id="7a02" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，您将直接在<code class="eh mf mg mh mi b">minikube</code>中创建容器映像。</p><p id="9f0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，按照这个命令输出的指令将Docker客户机连接到<code class="eh mf mg mh mi b">minikube</code>:</p><blockquote class="lz ma mb"><p id="3fc2" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated"><em class="hu">请注意，如果切换终端，需要重新连接到</em> <code class="eh mf mg mh mi b"><em class="hu">minikube</em></code> <em class="hu">里面的Docker守护进程。每次使用不同的终端时，您都应该遵循相同的说明。</em></p></blockquote><p id="de2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从项目的根目录开始，使用以下内容构建容器映像:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="b18f" class="mo kw hu mi b fv mp mq l mr ms">docker build -t spring-k8s-hpa .</span></pre><p id="780f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下命令验证映像是否已构建并准备好运行:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="777b" class="mo kw hu mi b fv mp mq l mr ms">docker images | grep spring</span></pre><p id="299f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了！</p><p id="12a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">集群已经准备好，您已经打包了您的应用程序，<em class="ka">也许您现在已经准备好部署了？</em></p><p id="4256" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的，您最终可以要求Kubernetes部署应用程序。</p><h1 id="55b3" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">将应用程序部署到Kubernetes</h1><p id="02ea" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">您的应用程序有三个组件:</p><ul class=""><li id="4a77" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">呈现前端的Spring Boot应用程序</li><li id="224b" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">作为消息代理的ActiveMQ</li><li id="9d61" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">处理事务的Spring Boot后端</li></ul><p id="3144" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该分别部署这三个组件。</p><p id="ce96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于其中的每一项，您都应该创建:</p><ul class=""><li id="6abb" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">一个<em class="ka">部署</em>对象，描述部署了什么容器及其配置</li><li id="d8ff" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">一个<em class="ka">服务</em>对象，作为由<em class="ka">部署</em>创建的应用程序的所有实例的负载平衡器</li></ul><p id="2856" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">部署中应用程序的每个实例被称为一个<em class="ka"> Pod </em>。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/db49122058840880f4d6f4eca4948a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5FQMzr8Wus8gQFAU1NPgcQ.gif"/></div></div></figure><h1 id="5c0f" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">部署ActiveMQ</h1><p id="ea96" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">先说ActiveMQ。</p><p id="97a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该创建一个包含以下内容的<code class="eh mf mg mh mi b">activemq-deployment.yaml</code>文件:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="2ee5" class="mo kw hu mi b fv mp mq l mr ms">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: queue<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: queue<br/>    spec:<br/>      containers:<br/>      - name: web<br/>        image: webcenter/activemq:5.14.3<br/>        imagePullPolicy: IfNotPresent<br/>        ports:<br/>          - containerPort: 61616<br/>        resources:<br/>          limits:<br/>            memory: 512Mi</span></pre><p id="2d83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该模板冗长，但易于阅读:</p><ul class=""><li id="4f43" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">你从官方注册中心要求一个名为<a class="ae ly" href="https://hub.docker.com/r/webcenter/activemq/" rel="noopener ugc nofollow" target="_blank"> webcenter/activemq </a>的activemq容器</li><li id="7846" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">容器在端口61616上公开消息代理</li><li id="e9a2" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">有512MB的内存分配给容器</li><li id="bddc" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">您要求单个副本—您的应用程序的单个实例</li></ul><p id="1ccc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用以下内容创建一个<code class="eh mf mg mh mi b">activemq-service.yaml</code>文件:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="20ee" class="mo kw hu mi b fv mp mq l mr ms">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: queue<br/>spec:<br/>  ports:<br/>  - port: 61616 <br/>    targetPort: 61616<br/>  selector:<br/>    app: queue</span></pre><p id="46ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是这个模板甚至更短！</p><p id="ee4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">yaml写道:</p><ul class=""><li id="0af6" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">您创建了一个公开端口61616的负载平衡器</li><li id="3a67" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">传入流量被分发到所有标签类型为<code class="eh mf mg mh mi b">app: queue</code>的pod(见上面的部署)</li><li id="555e" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated"><code class="eh mf mg mh mi b">targetPort</code>是吊舱暴露的端口</li></ul><p id="54c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以通过以下方式创建资源:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="d160" class="mo kw hu mi b fv mp mq l mr ms">kubectl create -f activemq-deployment.yaml<br/>kubectl create -f activemq-service.yaml</span></pre><p id="89bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下命令验证数据库的一个实例是否正在运行:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="3911" class="mo kw hu mi b fv mp mq l mr ms">kubectl get pods -l=app=queue</span></pre><h1 id="124f" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">部署前端</h1><p id="979a" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">用以下内容创建一个<code class="eh mf mg mh mi b">fe-deployment.yaml</code>文件:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="08a3" class="mo kw hu mi b fv mp mq l mr ms">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: frontend<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: frontend<br/>    spec:<br/>      containers:<br/>      - name: frontend<br/>        image: spring-boot-hpa<br/>        imagePullPolicy: IfNotPresent<br/>        env:<br/>        - name: ACTIVEMQ_BROKER_URL<br/>          value: "tcp://queue:61616"<br/>        - name: STORE_ENABLED<br/>          value: "true"<br/>        - name: WORKER_ENABLED<br/>          value: "false"<br/>        ports:<br/>        - containerPort: 8080<br/>        livenessProbe:<br/>          initialDelaySeconds: 5<br/>          periodSeconds: 5<br/>          httpGet:<br/>            path: /health<br/>            port: 8080<br/>        resources:<br/>          limits:<br/>            memory: 512Mi</span></pre><p id="019c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">部署</em>看起来和之前的很像。</p><p id="122f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过，也有一些新领域:</p><ul class=""><li id="66c2" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">有一部分你可以注入环境变量</li><li id="1d62" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">有一个活跃度探测器，它会告诉您应用程序何时准备好接受流量</li></ul><p id="ae6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用以下内容创建一个<code class="eh mf mg mh mi b">fe-service.yaml</code>文件:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="4510" class="mo kw hu mi b fv mp mq l mr ms">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: frontend<br/>spec:<br/>  ports:<br/>  - nodePort: 32000<br/>    port: 80<br/>    targetPort: 8080<br/>  selector:<br/>    app: frontend<br/>  type: NodePort</span></pre><p id="81d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以通过以下方式创建资源:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="5543" class="mo kw hu mi b fv mp mq l mr ms">kubectl create -f fe-deployment.yaml<br/>kubectl create -f fe-service.yaml</span></pre><p id="3634" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下命令验证前端应用程序的一个实例是否正在运行:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="a395" class="mo kw hu mi b fv mp mq l mr ms">kubectl get pods -l=app=fe</span></pre><h1 id="fc75" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">部署后端</h1><p id="c8bf" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">用以下内容创建一个<code class="eh mf mg mh mi b">backend-deployment.yaml</code>文件:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="4580" class="mo kw hu mi b fv mp mq l mr ms">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: backend<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: backend<br/>      annotations:<br/>        prometheus.io/scrape: 'true'<br/>    spec:<br/>      containers:<br/>      - name: backend<br/>        image: spring-boot-hpa<br/>        imagePullPolicy: IfNotPresent<br/>        env:<br/>        - name: ACTIVEMQ_BROKER_URL<br/>          value: "tcp://queue:61616"<br/>        - name: STORE_ENABLED<br/>          value: "false"<br/>        - name: WORKER_ENABLED<br/>          value: "true"<br/>        ports:<br/>        - containerPort: 8080<br/>        livenessProbe:<br/>          initialDelaySeconds: 5<br/>          periodSeconds: 5<br/>          httpGet:<br/>            path: /health<br/>            port: 8080<br/>        resources:<br/>          limits:<br/>            memory: 512Mi</span></pre><p id="2c74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用以下内容创建一个<code class="eh mf mg mh mi b">backend-service.yaml</code>文件:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="58a1" class="mo kw hu mi b fv mp mq l mr ms">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: backend<br/>  spec:<br/>    ports:<br/>    - nodePort: 31000<br/>      port: 80<br/>      targetPort: 8080<br/>    selector:<br/>      app: backend<br/>    type: NodePort</span></pre><p id="55f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以通过以下方式创建资源:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="d3ca" class="mo kw hu mi b fv mp mq l mr ms">kubectl create -f backend-deployment.yaml<br/>kubectl create -f backend-service.yaml</span></pre><p id="2dc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下命令验证后端的一个实例是否正在运行:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="31f6" class="mo kw hu mi b fv mp mq l mr ms">kubectl get pods -l=app=backend</span></pre><p id="22aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">部署完成。</p><p id="7d29" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">然而，这真的有用吗？</em></p><p id="9a80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下命令在浏览器中访问该应用程序:</p><p id="f882" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="7720" class="mo kw hu mi b fv mp mq l mr ms">minikube service frontend</span></pre><p id="a8cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果有效，你应该尝试购买一些物品！</p><p id="5579" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">工作人员正在处理事务吗？</p><p id="4e1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的，如果有足够的时间，worker将处理所有未决的消息。</p><p id="0931" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">恭喜你！</p><p id="d6a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您刚刚将应用程序部署到了Kubernetes！</p><h1 id="c113" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">手动扩展以满足不断增长的需求</h1><p id="3c53" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">单个工作人员可能无法处理大量邮件。</p><p id="31d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，它当时只能处理一条消息。</p><p id="d454" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你决定购买成千上万的商品，需要几个小时才能排清队伍。</p><p id="ea39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，您有两个选择:</p><ul class=""><li id="240d" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">您可以手动放大和缩小</li><li id="0109" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">您可以创建自动缩放规则来自动放大或缩小</li></ul><p id="c062" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们先从基础开始。</p><p id="dc0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以通过以下方式将后端扩展到三个实例:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="aedb" class="mo kw hu mi b fv mp mq l mr ms">kubectl scale --replicas=5 deployment/backend</span></pre><p id="4004" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下命令验证Kubernetes创建了另外五个实例:</p><p id="f81b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序可以处理五倍多的消息。</p><p id="3514" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦工作人员清空了队列，您可以使用以下方法缩小规模:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="0733" class="mo kw hu mi b fv mp mq l mr ms">kubectl scale --replicas=1 deployment/backend</span></pre><p id="2a6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你知道什么时候你的服务流量最大，那么手动缩放是很好的。</p><p id="1486" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果没有，设置一个自动缩放器允许应用程序自动缩放，而无需手动干预。</p><p id="20bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您只需要定义一些规则。</p><h1 id="afc7" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">公开应用程序指标</h1><p id="acc7" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">【Kubernetes如何知道何时扩展您的应用？</p><p id="bed0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简单，你要讲出来。</p><p id="e1a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自动缩放器通过监控指标来工作。</p><p id="6fe3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只有这样，它才能增加或减少应用程序的实例。</p><p id="5008" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，您可以将队列的长度公开为一个度量，并要求自动缩放器监视该值。</p><p id="dd45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">队列中等待处理的消息越多，Kubernetes创建的应用程序实例就越多。</p><p id="d573" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">那么，如何公开这些指标呢？</em></p><p id="b97e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序有一个<code class="eh mf mg mh mi b">/metrics</code>端点来公开队列中的消息数量。</p><p id="912c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您尝试访问该页面，您会注意到以下内容:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="e574" class="mo kw hu mi b fv mp mq l mr ms"># HELP messages Number of messages in the queue<br/># TYPE messages gauge<br/>messages 0</span></pre><p id="93bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序没有将指标公开为JSON格式。</p><p id="6de0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">格式为纯文本，是公开<a class="ae ly" href="https://prometheus.io/docs/concepts/metric_types/" rel="noopener ugc nofollow" target="_blank">普罗米修斯指标</a>的标准。</p><p id="82d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要担心记忆格式。</p><p id="5491" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数情况下，您将使用其中一个<a class="ae ly" href="https://prometheus.io/docs/instrumenting/clientlibs/" rel="noopener ugc nofollow" target="_blank"> Prometheus客户端库</a>。</p><h1 id="069d" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">在Kubernetes中使用应用程序指标</h1><p id="6ccf" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">您几乎可以自动缩放了；您应该首先安装度量服务器。</p><p id="623f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，默认情况下，Kubernetes不会从您的应用程序中获取指标。</p><p id="a244" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您愿意，您应该启用<a class="ae ly" href="https://github.com/kubernetes-incubator/custom-metrics-apiserver" rel="noopener ugc nofollow" target="_blank">自定义指标API </a>。</p><p id="b9d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要安装定制度量API，您还需要<a class="ae ly" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a> —一个时间序列数据库。</p><p id="e6ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装自定义指标API所需的所有文件都方便地打包在<a class="ae ly" href="https://github.com/learnk8s/spring-boot-k8s-hpa" rel="noopener ugc nofollow" target="_blank">learn k8s/spring-boot-k8s-HPA</a>中。</p><p id="d83c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该下载该存储库的内容，并将当前目录更改为该项目的<code class="eh mf mg mh mi b">monitoring</code>文件夹。</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="e8c9" class="mo kw hu mi b fv mp mq l mr ms">cd spring-boot-k8s-hpa/monitoring</span></pre><p id="f5f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您可以使用以下内容创建自定义指标API:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="be74" class="mo kw hu mi b fv mp mq l mr ms">kubectl create -f ./metrics-server<br/>kubectl create -f ./namespaces.yaml<br/>kubectl create -f ./prometheus<br/>kubectl create -f ./custom-metrics-api</span></pre><p id="161f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该等待，直到以下命令返回自定义指标列表:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="7920" class="mo kw hu mi b fv mp mq l mr ms">kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1" | jq .</span></pre><p id="430e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">任务完成！</p><p id="12fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">您已经准备好使用指标了。</em></p><p id="1496" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，您应该已经找到了队列中消息数量的自定义指标:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="be71" class="mo kw hu mi b fv mp mq l mr ms">kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/messages" | jq .</span></pre><p id="4e11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">恭喜，您有了一个公开指标的应用程序和一个使用它们的指标服务器。</p><p id="e55b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您终于可以启用自动缩放器了！</p><h1 id="9ab9" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">Kubernetes中的自动缩放部署</h1><p id="8ec9" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">Kubernetes有一个名为<a class="ae ly" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">Horizontal Pod auto scaler</a>的对象，用于监控部署和缩放Pod的数量。</p><p id="cd4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您将需要其中的一个来自动缩放您的实例。</p><p id="7158" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该创建一个包含以下内容的<code class="eh mf mg mh mi b">hpa.yaml</code>文件:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="39c3" class="mo kw hu mi b fv mp mq l mr ms">apiVersion: autoscaling/v2beta1<br/>kind: HorizontalPodAutoscaler<br/>metadata:<br/>  name: spring-boot-hpa<br/>spec:<br/>  scaleTargetRef:<br/>    apiVersion: extensions/v1beta1<br/>    kind: Deployment<br/>    name: backend <br/>  minReplicas: 1<br/>  maxReplicas: 10<br/>  metrics:<br/>  - type: Pods<br/>    pods:<br/>      metricName: messages<br/>      targetAverageValue: 10</span></pre><p id="da0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个文件很神秘，让我给你翻译一下:</p><ul class=""><li id="971d" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">Kubernetes监视着<code class="eh mf mg mh mi b">scaleTargetRef</code>中指定的部署。在这种情况下，是工人。</li><li id="22b0" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">您正在使用<code class="eh mf mg mh mi b">messages</code>指标来缩放您的<em class="ka">窗格</em>。当队列中有超过十条消息时，Kubernetes将触发自动缩放。</li><li id="f489" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">部署至少应该有两个<em class="ka">吊舱</em>。十个<em class="ka">吊舱</em>是上限。</li></ul><p id="d5f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以通过以下方式创建资源:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="1aad" class="mo kw hu mi b fv mp mq l mr ms">kubectl create -f hpa.yaml</span></pre><p id="56a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">提交自动缩放器后，您应该注意到后端的副本数量为两个:</p><p id="aed7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是有意义的，因为您要求自动缩放器总是运行至少两个副本。</p><p id="9274" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用以下命令检查触发自动缩放器的条件以及由此产生的事件:</p><p id="bbec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自动缩放器表明它能够将吊舱缩放到2个，并准备好监控部署。</p><p id="5d91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">令人兴奋的东西，但它有用吗？</p><h1 id="d3fe" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">负载测试</h1><p id="a090" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">只有一种方法可以知道它是否有效:在队列中创建大量消息。</p><p id="5304" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转到前端应用程序，开始添加大量消息。</p><p id="3588" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">添加消息时，使用以下工具监控水平窗格自动缩放器的状态:</p><p id="59a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">豆荚的数量从2个增加到4个，然后8个，最后10个。</p><p id="7688" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">应用程序随着消息的数量而扩展！</em></p><p id="0324" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">万岁！</em></p><p id="37d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您刚刚部署了一个完全可伸缩的应用程序，它可以根据队列中挂起消息的数量进行伸缩。</p><p id="a741" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另外，缩放的算法如下:</p><pre class="kc kd ke kf fq mk mi ml mm aw mn dt"><span id="b563" class="mo kw hu mi b fv mp mq l mr ms">MAX(CURRENT_REPLICAS_LENGTH * 2, 4)</span></pre><blockquote class="lz ma mb"><p id="84ca" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated"><em class="hu">文档在解释算法时帮助不大。你可以</em> <a class="ae ly" href="https://github.com/kubernetes/kubernetes/blob/bac31d698c1eed2b54374bdabfd120f7319dd5c8/pkg/controller/podautoscaler/horizontal.go#L588" rel="noopener ugc nofollow" target="_blank"> <em class="hu">在</em> </a> <em class="hu">代码中找到详情。</em></p></blockquote><p id="67fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，每分钟都会重新评估一次放大，而每两分钟就会缩小一次。</p><p id="a4b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以上都是可以调的设置。</p><p id="d865" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过，你还没完成。</p><h1 id="11b6" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">什么比自动缩放实例更好？自动缩放聚类</h1><p id="d4e6" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">跨节点扩展pod效果惊人。</p><p id="260f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">但是，如果集群中没有足够的容量来扩展您的单元，该怎么办？</em></p><p id="a001" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果达到最大容量，Kubernetes将让pod处于待定状态，等待更多资源可用。</p><p id="0446" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">如果您能使用类似于水平Pod自动缩放器的自动缩放器，那就太好了，但要针对节点。</em></p><p id="2e19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好消息！</p><p id="2eec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以拥有一个集群自动缩放器，当您需要更多资源时，它会向您的Kubernetes集群添加更多节点。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/70d913524a5993de5e1ef9241f3991ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5Rhpc_NQaxa8jqxXpUkcSg.gif"/></div></div></figure><p id="7e20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">集群自动缩放器有不同的形状和大小。</p><p id="8bc4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它也是特定于云提供商的。</p><blockquote class="lz ma mb"><p id="b485" class="jc jd ka je b jf jg jh ji jj jk jl jm mc jo jp jq md js jt ju me jw jx jy jz hn dt translated"><em class="hu">请注意，您将无法使用</em> <code class="eh mf mg mh mi b"><em class="hu">minikube</em></code> <em class="hu">测试自动缩放器，因为根据定义它是单节点。</em></p></blockquote><p id="c20c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在Github上找到<a class="ae ly" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#cluster-autoscaler" rel="noopener ugc nofollow" target="_blank">更多关于集群自动缩放器</a>和<a class="ae ly" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#deployment" rel="noopener ugc nofollow" target="_blank">云提供商实现</a>的信息。</p><h1 id="39d8" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">概述</h1><p id="90bf" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">大规模设计应用程序需要仔细的规划和测试。</p><p id="48bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于队列的架构是一种优秀的设计模式，可以分离您的微服务，并确保它们可以独立扩展和部署。</p><p id="b042" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然您可以推出部署脚本，但利用Kubernetes等容器编排器来自动部署和扩展您的应用程序更容易。</p><p id="a7c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，你应该在https://twitter.com/@danielepolencic的推特上关注我</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="3aee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">原载于2018年7月11日</em><a class="ae ly" href="https://learnk8s.io/blog/scaling-spring-boot-microservices" rel="noopener ugc nofollow" target="_blank"><em class="ka">learn k8s . io</em></a><em class="ka">。</em></p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure></div></div>    
</body>
</html>