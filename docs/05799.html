<html>
<head>
<title>Javascript ES6 — You don’t really need to learn Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript ES6——你真的不需要学习生成器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-es6-you-dont-really-need-to-learn-generators-96aa2e9114fa?source=collection_archive---------3-----------------------#2018-07-11">https://medium.com/hackernoon/javascript-es6-you-dont-really-need-to-learn-generators-96aa2e9114fa?source=collection_archive---------3-----------------------#2018-07-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="624e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">但无论如何你都应该读读这个…</h2></div></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="2444" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt km translated">随着async/await语法越来越受欢迎，人们对其内部工作方式的好奇也越来越多。通过<a class="ae kv" href="https://www.google.com/search?ei=ZE1FW87YKsnzzgLG-anIBw&amp;q=how+does+async+await+work&amp;oq=how+does+async+await+work&amp;gs_l=psy-ab.3..35i39k1j0i67k1j0i20i263k1j0j0i30k1j0i8i30k1.4146.6328.0.6467.2.2.0.0.0.0.78.145.2.2.0....0...1.1.64.psy-ab..0.2.145...0i13k1j0i22i30k1.0.86ChreR7zqA" rel="noopener ugc nofollow" target="_blank">谷歌搜索</a>很容易拼凑出async/await的基础是承诺(好吧，我当然知道承诺)和生成器(嗯？).</p><p id="cbb5" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">本条的目的如下:</p><ul class=""><li id="4533" class="kw kx hu js b jt ju jw jx jz ky kd kz kh la kl lb lc ld le dt translated">探索生成器的基本功能</li><li id="4a21" class="kw kx hu js b jt lf jw lg jz lh kd li kh lj kl lb lc ld le dt translated">谈论生成器+承诺=异步/等待</li><li id="23de" class="kw kx hu js b jt lf jw lg jz lh kd li kh lj kl lb lc ld le dt translated">证明你不需要担心学习生成器</li><li id="33ab" class="kw kx hu js b jt lf jw lg jz lh kd li kh lj kl lb lc ld le dt translated">本文假设<em class="lk">一些</em>承诺的基本知识</li></ul><h2 id="96ab" class="ll lm hu bd ln lo lp lq lr ls lt lu lv jz lw lx ly kd lz ma mb kh mc md me mf dt translated">迭代器和生成器——但主要是生成器</h2><p id="021d" class="pw-post-body-paragraph jq jr hu js b jt mg iv jv jw mh iy jy jz mi kb kc kd mj kf kg kh mk kj kk kl hn dt translated">从ES6开始，该语言增加了几个新功能，旨在使处理异步数据流和对象集合变得更容易。迭代器和生成器就属于这一类。</p><p id="a912" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">迭代器非常强大，因为它们提供了一种每次访问集合中一个条目的方法，同时跟踪当前索引。</p><figure class="mm mn mo mp fq mq fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff ml"><img src="../Images/751c62de74bfddc26e5799cb0b8162a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yn2YYgxp1MbWUd52uj_uZw.png"/></div></div><figcaption class="mx my fg fe ff mz na bd b be z ek"><a class="ae kv" href="https://gist.github.com/btg5679/91048cc658db67594b6fe2bca4c70ef1" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/btg5679/91048cc658db67594b6fe2bca4c70ef1</a></figcaption></figure><p id="854c" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">上面我们传入了一个包含2个值的简单数组，并通过调用它. next()来迭代这些值。请注意完整的评论回复。</p><p id="7012" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在对于<strong class="js hv">发电机。</strong>生成器是充当<strong class="js hv">迭代器</strong>工厂的函数。让我们看一个基本的例子，然后我们将讨论生成器的两个基本部分，生成器函数<strong class="js hv">和生成器迭代器</strong>。</p><figure class="mm mn mo mp fq mq fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff nb"><img src="../Images/a6b03cc3c8d36f38f7da5e1373177a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNY-WphoE1C9apgIau7TOQ.png"/></div></div><figcaption class="mx my fg fe ff mz na bd b be z ek"><a class="ae kv" href="https://gist.github.com/btg5679/d830f0067e5ae1610459131d38ce636e" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/btg5679/d830f0067e5ae1610459131d38ce636e</a></figcaption></figure><p id="3b74" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">注意语法，<em class="lk">星号</em>表示该函数是一个生成器，<em class="lk">产生</em>关键字，该关键字暂停函数执行(😮)并返回(产生)一个值。</p><p id="f835" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">前面我提到了发电机的两个部分:</p><ul class=""><li id="6058" class="kw kx hu js b jt ju jw jx jz ky kd kz kh la kl lb lc ld le dt translated"><strong class="js hv">发生器函数</strong> —定义在或附近带有星号<a class="ae kv" href="http://2ality.com/2014/08/formatting-generator-asterisk.html" rel="noopener ugc nofollow" target="_blank">或<em class="lk">的函数名或关键字</em></a></li><li id="61d0" class="kw kx hu js b jt lf jw lg jz lh kd li kh lj kl lb lc ld le dt translated"><strong class="js hv">生成器迭代器</strong>——在调用生成器函数时创建</li></ul><p id="270f" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">这里我们看到了工作中的生成器工厂，生成迭代器。</p><p id="b4cf" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">此时，事情开始变得更有趣了。与生成器的通信可以双向进行，生成器可以通过<em class="lk">向迭代器输出</em>值，但是迭代器也可以通过<code class="eh nc nd ne nf b">iterator.next('someValue')</code>方法向生成器发送值。</p><figure class="mm mn mo mp fq mq fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff ng"><img src="../Images/70313b74e1f2ebca46a9afe1c6349264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wG_gcBuaa5f7jHmKrRHXzg.png"/></div></div><figcaption class="mx my fg fe ff mz na bd b be z ek"><a class="ae kv" href="https://gist.github.com/btg5679/ffe53b3522abeb49ac11ea9844890899" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/btg5679/ffe53b3522abeb49ac11ea9844890899</a></figcaption></figure><h2 id="72f0" class="ll lm hu bd ln lo lp lq lr ls lt lu lv jz lw lx ly kd lz ma mb kh mc md me mf dt translated">发电机+承诺</h2><p id="fbdd" class="pw-post-body-paragraph jq jr hu js b jt mg iv jv jw mh iy jy jz mi kb kc kd mj kf kg kh mk kj kk kl hn dt translated">现在我们可以讨论一下生成器和承诺是如何构成异步/等待表达式的基础的。想象一下，生成器没有产生值，而是产生了承诺函数。然后，您可以将生成器包装在一个函数中，该函数可以等待承诺解析并将承诺值返回给。我们刚才演示的next()方法。有一个叫做<a class="ae kv" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank">协程</a>的流行库就是这么做的。很简单，就像这样:</p><figure class="mm mn mo mp fq mq fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff nh"><img src="../Images/c6e0abb5a15964aee7e20568d33254ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5IRfuW189N8Ebrl-2xhsw.png"/></div></div></figure><h2 id="c895" class="ll lm hu bd ln lo lp lq lr ls lt lu lv jz lw lx ly kd lz ma mb kh mc md me mf dt translated">我需要它吗？</h2><p id="edf9" class="pw-post-body-paragraph jq jr hu js b jt mg iv jv jw mh iy jy jz mi kb kc kd mj kf kg kh mk kj kk kl hn dt translated">我对生成器的看法是，为了让async/await工作，您需要它们，但是您不需要学习将它们直接合并到您的代码中。生成器为JS引入了暂停函数执行并在我们认为合适的时候返回的能力。到目前为止，我们期望函数在执行时运行到完成。这是一个启示，但async/await为我们巧妙地包装了这个启示。</p><p id="fc03" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">一些反驳的论点是，捆绑代码将async/await转移到生成器中，因此，熟悉生成器可能会在调试过程中对您有所帮助。我对此有不同的看法，尽管试图找到将生成器直接集成到代码中的方法。</p></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="9c8c" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">这一轮就到此为止。我们讨论了迭代器和生成器的基础知识，Generators + Promises如何让我们异步/等待，以及为什么不应该尝试将生成器强行加入JS指令清单。</p><p id="e9b9" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">你对发电机有什么想法？有我没有想到的用例吗？让我知道你的想法和问题，并在<a class="ae kv" href="http://twitter.com/_bengarrison" rel="noopener ugc nofollow" target="_blank"> twitter </a>上关注我。坚持下去。</p><h2 id="2bed" class="ll lm hu bd ln lo lp lq lr ls lt lu lv jz lw lx ly kd lz ma mb kh mc md me mf dt translated">我发现有帮助的进一步阅读:</h2><p id="02c8" class="pw-post-body-paragraph jq jr hu js b jt mg iv jv jw mh iy jy jz mi kb kc kd mj kf kg kh mk kj kk kl hn dt translated"><a class="ae kv" href="https://blog.benestudio.co/async-await-vs-coroutines-vs-promises-eaedee4e0829" rel="noopener ugc nofollow" target="_blank">https://blog . benestudio . co/async-await-vs-coroutines-vs-promises-eaede E4 e 0829</a></p><div class="ni nj fm fo nk nl"><a href="https://code.tutsplus.com/tutorials/using-iterators-and-generators-in-javascript-to-optimize-code--cms-30395" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd hv fv z el nq eo ep nr er et ht dt translated">在JavaScript中使用迭代器和生成器来优化代码</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">引言你是否曾经需要循环遍历一个列表，但是这个操作花费了大量的时间…</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">code.tutsplus.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz mv nl"/></div></div></a></div><div class="ni nj fm fo nk nl"><a rel="noopener follow" target="_blank" href="/javascript-scene/the-hidden-power-of-es6-generators-observable-async-flow-control-cfa4c7f31435"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd hv fv z el nq eo ep nr er et ht dt translated">ES6发电机的隐藏能量:可观测的异步流量控制</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">在我用JavaScript编写斐波那契生成器时学到的7件令人惊讶的事情中，我介绍了ES6的一个明显的用例…</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">medium.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz mv nl"/></div></div></a></div><p id="7155" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><a class="ae kv" href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/async-await-generators-promises-51 f1 a6 CEE de 2</a></p></div></div>    
</body>
</html>