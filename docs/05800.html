<html>
<head>
<title>Javascript Framework Comparison with Examples (React, Vue &amp; Hyperapp)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript框架与示例的比较(React、Vue和Hyperapp)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-framework-comparison-with-examples-react-vue-hyperapp-97f064fb468d?source=collection_archive---------4-----------------------#2018-07-11">https://medium.com/hackernoon/javascript-framework-comparison-with-examples-react-vue-hyperapp-97f064fb468d?source=collection_archive---------4-----------------------#2018-07-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="46c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的上一篇文章中，我试图解释为什么我认为Hyperapp是React或T21的一个可行的替代方案，以及为什么我觉得它更容易上手。许多人批评那篇文章，因为它固执己见，没有给其他框架一个适当的展示机会。因此，在本文中，我将尽可能客观地比较这三个框架，提供一些最小的例子来展示它们的能力。</p><h2 id="6354" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">臭名昭著的反例</h2><p id="423b" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">计数器可能是反应式编程中最常用的例子之一，非常容易理解:</p><ul class=""><li id="c78d" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">您需要有一个变量来跟踪计数器的<code class="eh kz la lb lc b">count</code>。</li><li id="9adf" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">您需要两种方法来递增和递减<code class="eh kz la lb lc b">count</code>变量。</li><li id="3822" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">你需要一种方法来呈现所说的<code class="eh kz la lb lc b">count</code>变量并呈现给用户。</li><li id="29ff" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">您需要两个按钮连接到您的两个方法，以便在用户与它们交互时改变<code class="eh kz la lb lc b">count</code>变量。</li></ul><p id="bed0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是以上三个框架中的实现:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/ceb026c2a695aa38c12fd0ebf7f474d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqyC-DRj22wZRBiI-NOiwA.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Counter example in React, Vue and Hyperapp</figcaption></figure><p id="877e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里可能有很多东西需要理解，尤其是如果您对其中一个或多个不熟悉，那么让我们一步一步地解构代码:</p><ul class=""><li id="a6a3" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">所有三个框架的顶部都有一些<code class="eh kz la lb lc b">import</code>语句。</li><li id="cd1b" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">React更喜欢面向对象的范例，它为<code class="eh kz la lb lc b">Counter</code>组件创建了一个<code class="eh kz la lb lc b">class</code>。Vue遵循类似的模式，创建一个新的<code class="eh kz la lb lc b">Vue</code>类实例并向其传递信息。最后，Hyperapp坚持功能范式，同时完全将<code class="eh kz la lb lc b">view</code>、<code class="eh kz la lb lc b">state</code>和<code class="eh kz la lb lc b">actions</code>彼此分开。</li><li id="495a" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">就<code class="eh kz la lb lc b">count</code>变量而言，React在组件的构造函数中实例化它，而Vue和Hyperapp只是分别在它们的<code class="eh kz la lb lc b">data</code>和<code class="eh kz la lb lc b">state</code>中设置一个属性。</li><li id="3147" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">向前看，我们注意到React和Vue有非常相似的方法来与<code class="eh kz la lb lc b">count</code>变量交互。React使用从<code class="eh kz la lb lc b">React.Component</code>继承的<code class="eh kz la lb lc b">setState</code>方法来改变它的状态，而Vue直接改变<code class="eh kz la lb lc b">this.count</code>。Hyperapp的方法是使用ES6胖箭头语法编写的，据我所知，它是唯一一个偏好这种语法的框架，因为React和Vue需要在它们的方法中使用<code class="eh kz la lb lc b">this</code>。另一方面，Hyperapp的方法需要状态作为参数，这意味着在不同的上下文中重用它们是可能的。</li><li id="8d7f" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">所有三个框架的呈现部分实际上是相同的。唯一的细微差别是Vue需要一个函数<code class="eh kz la lb lc b">h</code>传递给渲染器，Hyperapp使用<code class="eh kz la lb lc b">onclick</code>而不是<code class="eh kz la lb lc b">onClick</code>的事实，以及引用<code class="eh kz la lb lc b">count</code>变量的方式基于每个框架中实现状态的方式。</li><li id="bc43" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">最后，所有三个框架都被安装到<code class="eh kz la lb lc b">#app</code>元素上。每个框架都有稍微不同的语法，Vue是最简单的，它通过使用元素选择器而不是元素来提供最大的通用性。</li></ul><h2 id="f24c" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">反例裁决</h2><p id="ea07" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">并排比较所有三个框架，Hyperapp需要最少的代码行来实现一个计数器，并且它是唯一一个采用函数式方法的框架。然而，Vue的代码在绝对长度上似乎略短，而元素选择器安装是一个很好的补充。React的代码似乎是最冗长的，但这并不意味着代码不容易理解。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="c023" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">使用异步代码</h2><p id="74dd" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">很有可能你将不得不处理异步代码。最常见的异步操作之一是向API发送请求。出于这个例子的目的，我将使用一个带有一些虚拟数据的<a class="ae jp" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">占位符API </a>，并呈现一个帖子列表。必须完成的概要如下:</p><ul class=""><li id="4a02" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">存储一个数组<code class="eh kz la lb lc b">posts</code>的状态。</li><li id="21a6" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">使用一个方法用正确的URL调用<code class="eh kz la lb lc b">fetch()</code>，等待数据，转换成JSON，最后用接收到的数据更新<code class="eh kz la lb lc b">posts</code>变量。</li><li id="0c17" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">呈现一个按钮，该按钮将调用获取帖子的方法。</li><li id="9774" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">渲染<code class="eh kz la lb lc b">posts</code>的键控列表。</li></ul><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mf"><img src="../Images/cb7d01e1ba828586a4357620210c4240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aubSG-bpe4g20EOJ_99CFA.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Fetching data from a RESTful API</figcaption></figure><p id="059e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们分解上面的代码，比较三个框架:</p><ul class=""><li id="fda3" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">与上面的反例相似，所有三个框架之间的状态存储、视图呈现和挂载都非常相似。不同之处与上面讨论的相同。</li><li id="be2d" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">用<code class="eh kz la lb lc b">fetch()</code>获取数据非常简单，并且在所有三个框架中都能正常工作。然而，这里的关键区别是Hyperapp处理异步动作的方式与其他两个稍有不同。当数据被接收并转换为JSON时，动作将调用不同的同步动作，而不是直接在异步动作中修改状态。这使得核心功能更强大，更容易分解成更小的、潜在可重用的单元，同时避免了一些可能出现的回调嵌套问题。</li><li id="217d" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">就代码长度而言，Hyperapp仍然需要最少的代码行来达到相同的结果，但Vue的代码似乎不那么冗长，并且具有最短的字符绝对长度。</li></ul><h2 id="a742" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">异步代码判决</h2><p id="ca53" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">无论您选择哪种框架，异步操作都非常容易。当处理异步动作时，Hyperapp可能会迫使您编写功能性和更模块化的代码，但是其他两个框架肯定也可以做到这一点，并且在这方面为您提供了更多的选择。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="3e6a" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">待办事项列表项组件</h2><p id="bb52" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">可能是反应式编程中最著名的例子，待办事项列表已经用几乎所有现存的框架实现了。我不打算在这里实现所有的东西，只是一个无状态的组件来展示这三个框架如何帮助为您的web应用程序创建更小的可重用构建块。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mg"><img src="../Images/544fe3156253255d2919e3e20612aba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-v6XHigZe_5VfPvcR6nyQ.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Sample TodoItem implementations</figcaption></figure><p id="753d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上图展示了每个框架的一种技术和React的另一种技术。以下是我们在阅读这四本书时注意到的:</p><ul class=""><li id="d2b9" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">就编码模式而言，React是最灵活的。它支持功能组件和类组件。它还支持右下方的Hyperapp组件，开箱即用，无需任何更改。</li><li id="d94f" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">Hyperapp还支持功能性的React组件实现，这意味着两者之间有很大的实验空间。</li><li id="1068" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">Vue排在最后，它有一个相当奇怪的语法，即使是对其他两个有经验的人也不能立即理解。</li><li id="9bb8" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">就长度而言，所有示例的长度都非常相似，React在某些方法中稍微长一些。</li></ul><h2 id="c688" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">待办事项列表项目判断</h2><p id="a098" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">Vue需要一点时间来适应，因为它的模板与其他两个框架有点不同。React非常灵活，支持几种不同的创建组件的方法，而Hyperapp保持一切简单，并提供与React的兼容性，如果您想在某个时候进行切换的话。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="e9ad" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">生命周期方法比较</h2><p id="7386" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">另一个关键的考虑是每个框架允许您根据需要订阅和处理哪些组件生命周期事件。下面是我根据每一个的API参考创建的表格:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mh"><img src="../Images/f4e033787e9b7ac03000dfc66334373e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yj4H9pYnagZ7b1pyRE-wmQ.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Lifecycle method comparison</figcaption></figure><ul class=""><li id="b777" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">Vue拥有最多的生命周期挂钩，提供了处理生命周期事件触发之前或之后发生的任何事情的机会。这对于管理更复杂的组件很方便。</li><li id="39ae" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">React和Hyperapp的生命周期挂钩非常相似，React将<code class="eh kz la lb lc b">unmount</code>和<code class="eh kz la lb lc b">destroy</code>事件捆绑在一起，而Hyperapp将<code class="eh kz la lb lc b">create</code>和<code class="eh kz la lb lc b">mount</code>事件捆绑为一个事件。两者都在处理生命周期事件方面提供了相当多的控制。</li><li id="bf45" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">Vue根本不处理<code class="eh kz la lb lc b">unmount</code>(据我所知)，而是依赖<code class="eh kz la lb lc b">destroy</code>事件在组件生命周期的后期触发。React不处理<code class="eh kz la lb lc b">destroy</code>事件，而是选择只处理<code class="eh kz la lb lc b">unmount</code>事件。最后，Hyperapp不处理<code class="eh kz la lb lc b">create</code>事件，而是完全依赖于<code class="eh kz la lb lc b">mount</code>事件。根据您的需求和经验，在围绕组件的生命周期事件进行设计时，记住这些差异可能很重要。</li></ul><h2 id="e90f" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">生命周期方法比较结论</h2><p id="9d3c" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">总的来说，每个框架中都提供了生命周期挂钩，它们帮助你处理组件生命周期中的许多事情。所有这三个框架都为它们所有的生命周期事件提供了挂钩，它们之间的细微差别可能源于实现和方法的根本差异。Vue提供了更细粒度的事件处理，允许您在生命周期事件被触发之前或之后处理它们，这无疑是领先一步。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="2532" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">性能比较</h2><p id="a25d" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">除了易用性和编码技术，性能也是大多数开发人员的主要考虑因素之一，尤其是在处理更复杂的应用程序时。<a class="ae jp" href="https://github.com/krausest/js-framework-benchmark" rel="noopener ugc nofollow" target="_blank"> js-framework-benchmark </a>是比较框架的一个很好的资源，所以让我们看看每组基准测试的数字说明了什么:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mi"><img src="../Images/0ab96218c05a7e6a919125ca25ff5f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojtkwrkY4NETUmPsfQYDYA.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Table operations benchmark</figcaption></figure><ul class=""><li id="fa97" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">在所有三个框架中，非键控操作比键控操作快得多。</li><li id="c21d" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">非键控React是所有六种变体中性能最好的，它在所有基准测试中都取得了令人印象深刻的性能。</li><li id="e361" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">键控Vue仅比键控React稍有优势，而非键控Vue的性能明显不如非键控React。</li><li id="f578" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">Vue和Hyperapp似乎在部分更新基准测试中遇到了一些问题，而React似乎在比较中针对该特定操作进行了很好的优化。</li></ul><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mj"><img src="../Images/1cf953799be3aff19640ab5719c56f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFIM2Rd93jDnEZmqw_k3cw.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Startup metrics benchmark</figcaption></figure><ul class=""><li id="ee2b" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">Hyperapp是三个框架中最轻量级的，而React和Vue的大小差别非常小。</li><li id="4465" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">Hyperapp有一个更快的启动时间，这肯定是由于其微小的尺寸和极简的API。</li><li id="6fae" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">就启动时间而言，Vue比React略胜一筹。</li></ul><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mk"><img src="../Images/d45335ca13bd9e880a91ec3f95dc5220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVtufoJUvyjkaeEl2hz2sQ.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Memory allocation benchmark</figcaption></figure><ul class=""><li id="7c78" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">Hyperapp是三者中资源最少的，与其他两者相比，任何操作都需要较少的内存。</li><li id="5743" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">资源消耗不是很高，所有三个框架在现代硬件上的表现应该是相似的。</li></ul><h2 id="b900" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">性能比较结论</h2><p id="5be6" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">如果性能是一个问题，你应该考虑你在做什么样的应用，你的需求是什么。Vue和React似乎最适合更复杂的应用程序，而Hyperapp更适合较小的应用程序，需要处理的数据较少，以及需要非常快速启动或需要在低端硬件上工作的应用程序。</p><p id="f1f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，请记住，这些基准远远不能代表平均用例，因此您可能会在现实生活中看到相当不同的结果。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="634c" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">附加注释</h2><p id="e14e" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">比较React、Vue和Hyperapp在很多方面可能感觉像是在比较苹果和橙子。关于这些框架，还有一些额外的考虑因素，可以很好地帮助您决定选择哪一个:</p><ul class=""><li id="c31e" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">React通过引入<a class="ae jp" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段</a>绕过了相邻的JSX元素必须包装在父元素中的问题，这些元素允许您分组子元素列表，而无需向DOM添加额外的节点。</li><li id="bf9b" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">React还为您提供了<a class="ae jp" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，而Vue为您提供了<a class="ae jp" href="https://vuejs.org/v2/guide/mixins.html" rel="noopener ugc nofollow" target="_blank">混合组件</a>，用于重用组件功能。</li><li id="d4df" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">Vue通过利用<a class="ae jp" href="https://vuejs.org/v2/guide/syntax.html" rel="noopener ugc nofollow" target="_blank">模板</a>来分离结构和功能，从而更好地分离关注点。</li><li id="b53c" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">与其他两个相比，Hyperapp感觉像是一个低级别的API，它的代码要短得多，如果你想调整它并了解它是如何工作的，它允许更多的通用性。</li></ul></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><h2 id="113c" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">结论</h2><p id="33d4" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">我想如果你已经读到这里，你已经知道哪种工具更适合你的需要。毕竟，这不是讨论哪一个是最好的，而是讨论哪一个更适合每种情况。总而言之:</p><ul class=""><li id="c6f1" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">React是一个非常强大的工具，它有一个庞大的开发者社区，可能会帮助你找到工作。不是特别难进，但是肯定要花很多时间去掌握。然而，它是非常棒的，值得你花时间去做。</li><li id="fc78" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">如果您过去使用过另一个Javascript框架，Vue可能看起来有点奇怪，但它也是一个非常有趣的工具。如果React不合你的胃口，它是React的一个可行的替代方案，可能值得学习。它内置了一些很酷的功能，而且它的社区正在增长，甚至可能比React还要快。</li><li id="cd07" class="kq kr hu it b iu ld iy le jc lf jg lg jk lh jo kv kw kx ky dt translated">最后，Hyperapp是一个用于小型项目的很酷的小框架，也是初学者开始的好地方。与React或Vue相比，它提供的工具较少，但它可以帮助您快速构建原型并理解许多基础知识。您为它编写的许多代码都与其他两个框架兼容，要么是现成的，要么稍加修改，因此一旦您对其中一个框架有信心，就可以切换框架。</li></ul></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="1e56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这篇文章以及你为此付出的努力，记得给它一两下掌声，并在社交媒体上与你所有的朋友分享！</p></div></div>    
</body>
</html>