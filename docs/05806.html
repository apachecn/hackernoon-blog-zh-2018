<html>
<head>
<title>Learn how React Reconciler package works by building your own lightweight React DOM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建自己的轻量级React DOM，了解React Reconciler包的工作原理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/learn-you-some-custom-react-renderers-aed7164a4199?source=collection_archive---------10-----------------------#2018-07-11">https://medium.com/hackernoon/learn-you-some-custom-react-renderers-aed7164a4199?source=collection_archive---------10-----------------------#2018-07-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/45d8776f9ecb3b135673f816b9586135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPkuwdsPcFK2HrkdqZPhGA.png"/></div></div></figure><p id="5625" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自从<a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>被引入前端社区已经五年了。自从它发布以来，它已经为表达UI代码开辟了新的途径。通过React及其相关的生态系统，社区一直致力于解决客户端脚本的缺点，其中一项工作是React Fiber，它使我们的应用程序开发人员能够简单地声明我们的代码看起来像什么，以及它应该如何应对数据的变化，同时它会在幕后计算对UI的必要更改。在这个过程中，它实际上会在很短的时间片内计算它们，而不是在JS线程中一次完成。</p><p id="b1a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然，很少有人知道(【https://twitter.com/dan_abramov/status/1009246589473390592】)将计算与更新调度本身分开的包——让我们编写自己的定制呈现器。事实上，react-reconciler，这个有问题的包，已经打开了全新的可能性。已经尝试确保React代码可以在基于<a class="ae ka" href="https://github.com/iamdustan/react-hardware" rel="noopener ugc nofollow" target="_blank"> firmata的硬件</a>、<a class="ae ka" href="https://www.npmjs.com/package/@react-pdf/core" rel="noopener ugc nofollow" target="_blank">pdf、</a>、<a class="ae ka" href="https://www.npmjs.com/package/react-qml-renderer" rel="noopener ugc nofollow" target="_blank"> QML、</a>、<a class="ae ka" href="https://www.npmjs.com/package/react-regl" rel="noopener ugc nofollow" target="_blank"> Regl、</a>、<a class="ae ka" href="https://www.npmjs.com/package/react-framer" rel="noopener ugc nofollow" target="_blank">成帧器动画</a>中运行。</p><p id="e1b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今天，让我们以DOM本身为目标，编写我们自己的微型react-dom呈现器。如果你足够认真地对待它，也许你可以在你的应用中用它代替react-dom，并看到包大小和性能的提高。让我们开始吧。</p><p id="0b32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们使用<a class="ae ka" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>引导React项目</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f000" class="kk kl hu kg b fv km kn l ko kp">npx create-react-app my-react-dom-project</span><span id="1cc8" class="kk kl hu kg b fv kq kn l ko kp"># Or if you use yarn<br/>yarn create react-app my-react-dom-project</span></pre><p id="16d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们将根应用程序组件修改得更简单一些，原因将很快变得显而易见。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="9073" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行的磨坊反应代码对吗？如果你对这里的任何东西都不熟悉，建议<a class="ae ka" href="https://reactjs.org/docs/hello-world.html" rel="noopener ugc nofollow" target="_blank">让我们的React基础更强</a>。此外，为了清晰起见，请暂时忽略perf问题。</p><p id="0b1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，为我们的自定义dom渲染器创建一个空文件，并将其命名为renderer.js。(请忽略gist文件的名称)</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="d29f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并导入它而不是index.js中的react-dom</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="aed9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">错误，对吗？</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kt"><img src="../Images/4601dd7fdbcf20c693ae92c67a063625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Rt0YF9IJF7imYYpocW2tw.png"/></div></div></figure><p id="14df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，我们从渲染器——一个渲染方法——那里确切地知道我们需要什么呢？一个接受我们的React元素、容器DOM节点和回调的方法，对吗？我们手动反应我们的元素，容器节点，一个回调函数，然后React变魔术般地运行回调函数来表示它已经完成了它的工作。有了<code class="eh ku kv kw kg b">react-reconciler</code>，我们可以控制一些魔法。</p><p id="1cec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好消息是官方ReactDOM本身使用react-reconciler包。我们可以从那里得到暗示。</p><p id="1d2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们找到了ReactReconciler(由包导出函数)</p><ol class=""><li id="597f" class="kx ky hu je b jf jg jj jk jn kz jr la jv lb jz lc ld le lf dt translated">需要一个配置。</li><li id="8b63" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated">需要一个内部容器数据<a class="ae ka" href="https://hackernoon.com/tagged/structure" rel="noopener ugc nofollow" target="_blank">结构</a>来呈现</li><li id="6f3a" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated">使用我们的元素、容器的内部形式和渲染后要运行的回调函数运行<code class="eh ku kv kw kg b">updateContainer</code>。</li></ol><p id="d806" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以让我们试一试。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="92ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们有以下错误。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ll"><img src="../Images/925eece8ad7ff8f77e33346f2698da8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAHZkYUIMRTZFcMhJULvOA.png"/></div></div></figure><p id="b4d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">毕竟我们的“hostConfig”是一个空对象！</p><p id="040c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，在代码和散文中，所有对“主机”的引用都是指React代码将运行的环境。React运行在移动端(Android/iOS)已经不是什么秘密了——React只需要一个可以渲染UI更新的JS环境。在我们的项目中，宿主是DOM本身。</p><p id="0672" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，什么是<code class="eh ku kv kw kg b">now</code>？Internally React需要一种方法来跟踪时间，例如计算是否已经“过期”或超出了分配的时间。请查看<a class="ae ka" href="https://www.youtube.com/watch?v=ZCuYPiUIONs" rel="noopener ugc nofollow" target="_blank">林·克拉克关于React光纤的演讲</a>以深入了解该主题。但是，有人会问“不能用类似<code class="eh ku kv kw kg b">Date.now</code>的东西来反应吗？”可以的！但是主机环境可以提供更好的跟踪时间的方法。比如<code class="eh ku kv kw kg b">Performance.now</code>？在这方面，所有的宿主环境可能不尽相同。无论如何，让我们现在使用<code class="eh ku kv kw kg b">Date.now</code>并继续前进。</p><p id="12e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">弄清楚<code class="eh ku kv kw kg b">hostConfig</code>中发生了什么的一个好方法是查看<a class="ae ka" href="https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMHostConfig.js#L87-L389" rel="noopener ugc nofollow" target="_blank"> ReactDOMHostConfig.js </a>(在编写时)。我们会发现我们需要以下内容。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="af98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只需在其中添加一个日志语句，然后再次运行应用程序，就会得到以下结果。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lm"><img src="../Images/f61e3c615af11bb33acc677c27f45d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KYFKZtKxFGiX6QNQwUyXA.png"/></div></div></figure><p id="7fdd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b"><strong class="je hv">getRootHostContext</strong></code> <strong class="je hv">和</strong> <code class="eh ku kv kw kg b"><strong class="je hv">getChildHostContext</strong></code></p><p id="7089" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这需要一点阅读和探索。比较官方repo上的渲染器，我们可以安全地得出这样的结论:React Reconciler提供了<code class="eh ku kv kw kg b">getRootHostContext</code>和<code class="eh ku kv kw kg b">getChildHostContext</code>作为在其他配置函数之间共享一些上下文的方式。希望在后续的帖子中能有更多的相关内容。现在，让我们返回空对象。</p><p id="3605" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b"><strong class="je hv">shouldSetTextContent</strong></code></p><p id="63c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有些宿主允许您在宿主元素上设置文本内容，而其他宿主可能要求创建新元素。现在我们简单地返回false。</p><p id="294f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b"><strong class="je hv">createTextInstance</strong></code></p><p id="c9f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们记录函数中接收到的所有参数。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lm"><img src="../Images/0d346dcdb660f653829c209a5562f31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kk3dfs9OTWB90voZbNmuRQ.png"/></div></div></figure><p id="2cab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是他们的情况，</p><p id="d2ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b">0</code>=&gt;<code class="eh ku kv kw kg b">this.state.count</code>的初始值</p><p id="b1e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b">&lt;div id="root"&gt;&lt;/div&gt;</code>=&gt;DOM容器</p><p id="ed06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">{tag: 6，key: null，type: null，stateNode: null，return: FiberNode，…}` = &gt;关联的纤程。我们不必担心这个。大多数时候，我们只需要将它传递给reconciler。它被认为是不透明的。在我们简单的渲染器中，我们甚至不需要这样做。React调用<code class="eh ku kv kw kg b">createTextInstance</code>在主机环境中创建文本节点。所以干脆返回<code class="eh ku kv kw kg b">document.createTextNode(text)</code></p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="2c17" class="kk kl hu kg b fv km kn l ko kp">createTextInstance(<br/>    text,<br/>    rootContainerInstance,<br/>    hostContext,<br/>    internalInstanceHandle<br/>) {<br/><br/>    return document.createTextNode(text);<br/>}</span></pre><p id="fb8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b"><strong class="je hv">createInstance</strong></code></p><p id="75ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再次记录我们看到的所有论点</p><ol class=""><li id="649c" class="kx ky hu je b jf jg jj jk jn kz jr la jv lb jz lc ld le lf dt translated"><code class="eh ku kv kw kg b">type</code>=&gt;DOM节点的类型。如div、span、p等。</li><li id="15f3" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated">道具= &gt;道具通过。由于我们从未向应用程序中的div传递任何东西，所以只传递子元素。</li><li id="9835" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><code class="eh ku kv kw kg b">&lt;div id="root"&gt;&lt;/div&gt;</code> = &gt;根容器</li><li id="0ecb" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated">{…} = &gt;纤维节点</li></ol><p id="2461" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类似于<code class="eh ku kv kw kg b">createTextNode</code>，我们只返回一个div节点，即= &gt; <code class="eh ku kv kw kg b">document.createElement(type)</code></p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f9de" class="kk kl hu kg b fv km kn l ko kp">createInstance(<br/>    type,<br/>    props,<br/>    rootContainerInstance,<br/>    hostContext,<br/>    internalInstanceHandle<br/>) {<br/>    return document.createElement(type);<br/>},</span></pre><p id="74d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b"><strong class="je hv">appendInitialChild</strong></code></p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/355ebf0a2380e3edd95e3b809ea0f117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*jDxubQPJY4WmxEaf9padRQ.png"/></div></figure><p id="d1cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们看到了没有设置属性的父DOM节点及其相应的子节点。在我们的例子中<code class="eh ku kv kw kg b">.appendChild()</code>，使用我们主机的api将子元素附加到父元素是有意义的</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="dff2" class="kk kl hu kg b fv km kn l ko kp">appendInitialChild(parentInstance, child) {<br/>    parentInstance.appendChild(child)<br/>}</span></pre><p id="581f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b"><strong class="je hv">finalizeInitialChildren</strong></code></p><p id="72e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是争论</p><ol class=""><li id="5e0a" class="kx ky hu je b jf jg jj jk jn kz jr la jv lb jz lc ld le lf dt translated"><code class="eh ku kv kw kg b">domElement</code> : <code class="eh ku kv kw kg b">&lt;div&gt;&lt;/div&gt;</code>来自我们App.js中的<code class="eh ku kv kw kg b">&lt;div&gt;{this.state.count}&lt;/div&gt;</code></li><li id="7a0c" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><code class="eh ku kv kw kg b">type</code> : div</li><li id="63af" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><code class="eh ku kv kw kg b">props</code>从<code class="eh ku kv kw kg b">{this.state.count}</code>到<code class="eh ku kv kw kg b">{ children: 0 }</code>它的初始值为0</li><li id="c061" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><code class="eh ku kv kw kg b">rootContainerInstance</code></li><li id="a288" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><code class="eh ku kv kw kg b">hostContext</code></li></ol><p id="d485" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们仔细查看日志，我们会发现<code class="eh ku kv kw kg b">shouldSetTextContent</code>=&gt;<code class="eh ku kv kw kg b">createTextInstance</code>=&gt;<code class="eh ku kv kw kg b">createInstance</code>=&gt;<code class="eh ku kv kw kg b">finalizeInitialChildren </code>发生在App.js中声明的每个元素上—</p><ol class=""><li id="4303" class="kx ky hu je b jf jg jj jk jn kz jr la jv lb jz lc ld le lf dt translated"><div> {this.state.count} </div></li><li id="d96c" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><button onclick="{onClickHandler}">增量</button></li><li id="fa04" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated">父div: <div> … </div></li></ol><p id="4024" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">协调器试图在宿主环境中创建节点，在我们的例子中是DOM！</p><p id="b826" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b"><strong class="je hv">finalizeInitializeChildren</strong></code></p><p id="c4ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它接收宿主中的DOM节点、类型、props和根容器。如果我们从这个函数的名字中得到提示(当然也咨询了其他的协调器:P)，我们就可以在React将它推送到DOM之前创建它的子树。举个例子，</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/7573a3f3faa12698f6f6da662b6a9762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*mUBGWwt03yMV4xR5S5efzA.png"/></div></figure><p id="55d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这代表<code class="eh ku kv kw kg b">&lt;div&gt;{this.state.count}&lt;/div&gt;</code></p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/8eabd60eb5fecf0b3efe4204bf529e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIejPJtbU1aCvfOz2kunkg.png"/></div></div></figure><p id="88b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有这个，<code class="eh ku kv kw kg b">&lt;button onClick={onClickHandler}&gt;Increment&lt;/button</code></p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lq"><img src="../Images/0e03370a2c6b49b02e50e45b8f9cd172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PMiDD6zvjcQdQV14z1I9AA.png"/></div></div></figure><p id="ffad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意元素上没有类。<code class="eh ku kv kw kg b">finalizeInitialChildren</code>可用于应用类、事件处理程序和其他属性和特性。因为在我们简单的应用程序中，我们真正需要的是类(html类)和事件处理程序，所以让我们应用它们。如果您想处理其他属性和特性，这将是一个好地方。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="34c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b">prepareForCommit</code>和<code class="eh ku kv kw kg b">resetAfterCommit</code></p><p id="61db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们暂时把这些放在一边。但是，如果您认为在协调器进入提交阶段之前，您需要完成任何事情，请在prepareForCommit中完成。同样，此后的清洁可以在<code class="eh ku kv kw kg b">resetAfterCommit</code>中进行</p><p id="1af7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ku kv kw kg b">appendChildToContainer</code></p><p id="11a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顾名思义，只需添加我们准备好的DOM树。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c24c" class="kk kl hu kg b fv km kn l ko kp"><br/>appendChildToContainer(container, child) {         container.appendChild(child)<br/>},</span></pre><p id="9405" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">瞧啊。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lr"><img src="../Images/8169e3ab1c27e9e2ed73ef51d6b15b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiNXBXELGMNIDchXo-Wv8w.png"/></div></div></figure><p id="db54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们第一次使用<code class="eh ku kv kw kg b">react-reconciler</code> API渲染！</p><p id="4941" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">点击增量几次。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/1d25a993dfbdd373fa14e996b837decf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZniJ67sr47iGJvyADg9gEA.png"/></div></div></figure><p id="6d38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">UI不更新。调用了协调器配置中的一些方法。</p><p id="9a83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经看到了resetAfterCommit。我们追求的是<code class="eh ku kv kw kg b">prepareUpdate</code>和<code class="eh ku kv kw kg b">commitTextUpdate</code>。尽管我们没有看到<code class="eh ku kv kw kg b">commitUpdate</code>，但我们最好现在就看它，因为它与<code class="eh ku kv kw kg b">prepareUpdate</code>非常接近，就像<code class="eh ku kv kw kg b">commitTextUpdate.</code></p><p id="f129" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还记得React最初是如何用这个叫做“区分算法”的东西风靡全球的吗？嗯，我们现在可以自己写了！</p><p id="35e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在此之前，让我们记住——React，核心库，现在只是一个UI更新调度器。作为自定义渲染器的作者，是我们决定了差异实际上意味着什么。对于DOM，我们寻找元素属性和特性。对于不同的宿主，它可能是任何东西。让我们玩一会儿。</p><p id="bbbd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们定义了协调(差异)，我们还可以选择什么数据结构来保存不同的更改，并且正是这个数据结构被传递——由我们从prepareUpdate返回，传递给<code class="eh ku kv kw kg b">commitUpdate</code>。<code class="eh ku kv kw kg b">commitTextUpdate</code>非常简单——不需要传递任何数据结构。我们真正需要的是旧文本和更新的新文本，看看需要如何处理差异。在大多数简单的情况下，您可以简单地将新文本分配给DOM元素。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c7f1" class="kk kl hu kg b fv km kn l ko kp">commitTextUpdate(textInstance, oldText, newText) {        textInstance.nodeValue = newText;<br/>},</span></pre><p id="449f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们的应用程序暂时发挥作用(尤其是对我们这些寻求成就感的人来说)，稍后再来看看<code class="eh ku kv kw kg b">commitUpdate</code>和<code class="eh ku kv kw kg b">prepareUpdate</code>。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="2b71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们回到<code class="eh ku kv kw kg b">prepareUpdate</code>和<code class="eh ku kv kw kg b">commitUpdate</code>。</p><p id="c4c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要修改一下我们的应用程序——目前触发<code class="eh ku kv kw kg b">prepareUpdate</code>和<code class="eh ku kv kw kg b">commitUpdate.</code>太简单了</p><p id="c760" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们想在计数器超过阈值(比如10)时用红色显示它。我们的App.js必须用下面一行更新</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="cfd6" class="kk kl hu kg b fv km kn l ko kp">&lt;div className={ this.state.count &gt; 5 ? "counter red": "counter" }&gt;{this.state.count}&lt;/div&gt;</span></pre><p id="63ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设css文件(App.css)有一些改变文本颜色的样式。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="0031" class="kk kl hu kg b fv km kn l ko kp">.red {<br/>  color: red;<br/>}</span></pre><p id="d24a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">保存、重新加载并开始递增计数器。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lm"><img src="../Images/57d0cdcd6f39bea552e28cafe1bc2648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdgZviVaFSvPt8UN3tCmXw.png"/></div></div></figure><p id="dabf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意<code class="eh ku kv kw kg b">prepareUpdate</code>和<code class="eh ku kv kw kg b">commitUpdate</code>是如何分别被调用三次的。<code class="eh ku kv kw kg b">div.root</code>、内<code class="eh ku kv kw kg b">div</code>和按钮各一个。您可以通过临时添加类似<code class="eh ku kv kw kg b">&lt;p&gt;&lt;span&gt;some text&lt;/span&gt;&lt;/p&gt;</code>的随机标记来快速验证这一点</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="420d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们试着改变我们的世界！让我们研究它的所有论点。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e4e1" class="kk kl hu kg b fv km kn l ko kp">prepareUpdate(<br/>    domElement,<br/>    type,<br/>    oldProps,<br/>    newProps,<br/>    rootContainerInstance,<br/>    hostContext<br/>) {<br/>    console.log('prepareUpdate', oldProps, newProps, rootContainerInstance);<br/>    return [ null ];<br/>},</span></pre><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lm"><img src="../Images/b348873f2dbe1b94c7477687692af570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awKzDVqxuq2snyTlpe2j7A.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">prepareUpdate being run for each react element on incrementing</figcaption></figure><p id="bfa4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当增量被点击时，子节点从0更新到1。点击增量超过5次，我们会看到，</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lm"><img src="../Images/92e15a07d19a9ee00ac55183044b14c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivMG9hjdvlXXJeE5J8nuxg.png"/></div></div></figure><p id="0cc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在第6次点击时，className从“counter”变成了“counter red”。又一个道具变了。</p><p id="aaa4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在理想的情况下，如果JS land中的DOM数据结构可以简单地直接映射到C++数据结构，我们可以盲目地对这些属性中的每一个进行更新操作。但是我们在约束下工作！DOM必然会来回封送结构。<a class="ae ka" href="https://youtu.be/Zemce4Y1Y-A?t=438" rel="noopener ugc nofollow" target="_blank">差异是必要的，而不是编写功能性声明式UI组件的特性</a>。因此，让我们计算一下需要对DOM进行的最少的必要更新。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="6e75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并在<code class="eh ku kv kw kg b">commitUpdate</code>中应用这些更新</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="4ce8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们正在以不同的方式处理事件侦听器(也作为道具传递)。为了简单起见，我们确保任何时候都只有一个事件监听器。</p><p id="3d74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们走吧！</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/2b944be022dad29118c60a65f9a21b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/1*MbFqVLFqU0zesW3fX4Q8gg.gif"/></div></figure><p id="addb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完整的renderer.js</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="5a5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你喜欢这篇文章，并将继续修改react-reconciler！</p><p id="dfe6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Github回购:<a class="ae ka" href="https://github.com/prometheansacrifice/my-react-dom" rel="noopener ugc nofollow" target="_blank">https://github.com/prometheansacrifice/my-react-dom</a></p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="ly ks l"/></div></figure></div></div>    
</body>
</html>