<html>
<head>
<title>GitState — Git-style Isomorphic State Management with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git State——使用GraphQL进行Git风格的同构状态管理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/gitstate-git-style-isomorphic-state-management-with-graphql-3b0c9475412d?source=collection_archive---------14-----------------------#2018-07-11">https://medium.com/hackernoon/gitstate-git-style-isomorphic-state-management-with-graphql-3b0c9475412d?source=collection_archive---------14-----------------------#2018-07-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3cc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没有一天不出现关于国家管理图书馆的新想法。我想谈谈另一个例子。但是要注意，<strong class="it hv">这不是真正的</strong>图书馆。这是我的一个想法，并希望与社区分享。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/48003f58cb94f559dfda5bc8c8343139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaAbXW-v8LdFkZyll7SPYw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">This is supposed to be a mashup of Git and GraphQL logos</figcaption></figure><p id="6811" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将把这个假想的库称为GitState。</p><p id="7f11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GitState可以帮助你在本地管理你的状态，并使它的一部分与你的远程数据库保持同步。所有这些事务都用git风格的api来处理。它应该与任何GraphQL后端工作，可能有一些配置。它负责以下工作:</p><ul class=""><li id="ca14" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo kk kl km kn dt translated"><strong class="it hv">保持/管理本地状态</strong> —对于本地和被跟踪的远程数据，它就像一个可预测的、不可变的状态容器。</li><li id="066a" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated"><strong class="it hv">处理数据流</strong> —您可以<em class="kt">跟踪远程数据存储的</em>片，并扩展/更改这些片(用于加载更多、过滤等。).加载和错误状态由GitState处理。</li><li id="0f0a" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated"><strong class="it hv">处理请求流</strong> —请求被完全抽象出来。你可以添加或修改音轨，在你执行<em class="kt"> G.pull </em>之前，不会有任何东西到达后端。一旦你这样做了，GitState就会根据音轨和缓存生成一个最优的查询，所以它尽可能少地访问后端，请求最少的负载。</li><li id="f4d4" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated"><strong class="it hv">缓存</strong> — GitState通过与状态分离的<code class="eh ku kv kw kx b">__typename</code>和<code class="eh ku kv kw kx b">id</code>来跟踪获取的资源，这些资源被规范化并且独立于它们被拉入的层次结构。它允许为每种类型或每种类型的每个字段单独定义全局缓存策略。优化查询时会考虑这些因素。</li></ul><p id="3a1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是对该API的一个简要介绍。请注意，所有功能都是按照配置第一数据最后数据的顺序自动执行的。</p><h2 id="5d09" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">G</h2><p id="3e61" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">库的句柄，像这样导入:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="75e2" class="ky kz hu kx b fv mc md l me mf">import G from 'gitstate'</span></pre><h2 id="6d0d" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">g .初始化</h2><p id="0a0a" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">用于配置GitState客户端。</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="6fa7" class="ky kz hu kx b fv mc md l me mf">G.init({ origin: "&lt;server ip&gt;" })</span></pre><h2 id="2573" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">g .跟踪</h2><p id="6012" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">与<code class="eh ku kv kw kx b">git track …</code>类似，该方法跟踪远程数据存储的一部分。接受一个<strong class="it hv">轨迹键</strong>和一个<strong class="it hv"> GQL查询</strong>。它可以有选择地带<strong class="it hv">查询参数</strong>和选项。它或者创建一个新的轨迹，或者覆盖已经存在的轨迹。</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="528b" class="ky kz hu kx b fv mc md l me mf">G.track(key)(query)(params)(options)</span></pre><p id="3fa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以很容易地修改现有轨道的范围，以支持诸如<strong class="it hv">分页</strong>、<strong class="it hv">查询</strong>和<strong class="it hv">过滤</strong>之类的事情。这可以通过覆盖查询参数轻松实现。为此，只需省略查询并提供新值。</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="0a71" class="ky kz hu kx b fv mc md l me mf">G.track(key)(params)(options)</span></pre><p id="2a95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="f091" class="ky kz hu kx b fv mc md l me mf">const q = `<br/>  query Posts($limit: Int, $offset: Int){<br/>    posts(limit: $limit, offset: $offset) {<br/>      id<br/>      title<br/>      contents<br/>    }<br/>  }<br/>`;</span><span id="b9e4" class="ky kz hu kx b fv mg md l me mf">// Create a new track &amp; start pulling<br/>G.track('posts')(q)({ limit: 10, offset: 0 })()<br/>G.pull('posts')()</span><span id="471a" class="ky kz hu kx b fv mg md l me mf">// ...Later<br/><br/>// Modify the scope of the tracked posts<br/>G.track('posts')({ offset: 10 })({ append: true })<br/>G.pull('posts')()</span></pre><h2 id="7a16" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">g .拉</h2><p id="8ccd" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">接受两个可选参数，<strong class="it hv">轨迹关键点</strong>和<strong class="it hv">选项</strong>。省略任何一个都是可行的。当提供track key时，它只尝试获取给定的轨迹，否则它将所有现有轨迹作为目标。</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="b5f0" class="ky kz hu kx b fv mc md l me mf">G.pull(key)(options)</span></pre><p id="dbe8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调用时，GitState只获取需要获取的数据。如果一个音轨的查询参数发生了变化，它就会被获取。如果不是，则根据缓存解析策略或<code class="eh ku kv kw kx b">force</code>选项做出决定。</p><p id="4d9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="7428" class="ky kz hu kx b fv mc md l me mf">G.pull()()<br/>G.pull('posts')()<br/>G.pull()({ force: true })<br/>G.pull('posts')({ force: true })</span></pre><h2 id="e005" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">g .现状</h2><p id="ba90" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">Status是GitState保存<strong class="it hv">请求信息</strong>和<strong class="it hv">跟踪元数据</strong>的对象。它由轨迹键组织。该对象可用于处理加载/错误状态，并访问跟踪参数。</p><p id="9fa4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="be5e" class="ky kz hu kx b fv mc md l me mf">// G.status<br/>// {<br/>//  userDetails: {<br/>//   fetched: &lt;boolean&gt;, // has it been fetched<br/>//   fetching: &lt;boolean&gt;, // is it fetching now<br/>//   loading: &lt;boolean&gt;, // see G.exec<br/>//   hasChange: &lt;boolean&gt;, // did the request params change<br/>//   error: &lt;err object&gt;, // error object for the last request<br/>//   params: {...}, // current query parameters<br/>//   options: {...}, // current query options<br/>//  }<br/>// }</span></pre><h2 id="3ff0" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">g .表格</h2><p id="7691" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated"><a class="ae mh" href="https://en.wikipedia.org/wiki/Theory_of_forms" rel="noopener ugc nofollow" target="_blank"> Forms </a>是一个内部使用的对象，通过它们的<code class="eh ku kv kw kx b">__typename</code>和<code class="eh ku kv kw kx b">id</code>保存所有获取的资源的标准化和扁平化索引。每次拉取后，GitState都将这个对象与后端保持同步。它保存资源数据和上次获取时间(对于每个单独的字段)。Forms对象是最近获取的资源版本的唯一来源，应用程序状态是该对象的派生。</p><h2 id="4284" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">g .国家</h2><p id="739a" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">应用程序的本地状态。由轨迹键组织。getter函数从forms对象中获取当前状态，因此它总是包含每个资源的最新获取版本。此外，它在根级别保存未跟踪的局部变量。要获得状态，只需调用getter函数。</p><p id="0628" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="6b0c" class="ky kz hu kx b fv mc md l me mf">G.track('userDetails')(`...`)<br/>G.track('favoritePosts')(`...`)<br/>G.pull()</span><span id="6fbe" class="ky kz hu kx b fv mg md l me mf">// G.state()<br/>// {<br/>//  userDetails: {...},<br/>//  favoritePosts: {...},<br/>//  nonTrackedLocalVariable: 'blah'<br/>// }</span></pre><h2 id="d047" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">G.add</h2><p id="fa4f" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">创建或更新本地状态树中的节点。它接受一个<strong class="it hv">对象路径</strong>和一个<strong class="it hv">节点的新值</strong>。它是自动激活的，这意味着如果它不存在，它会创建一个新节点及其所有路径。</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="b72e" class="ky kz hu kx b fv mc md l me mf">G.add(path)(val)</span></pre><p id="5f9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果更新的节点被跟踪，这意味着它实际上只是forms对象上的一个资源的派生。在这种情况下，GitState会更新相关的资源表单，因此从该资源派生的所有状态变量也会得到更新。</p><p id="7f30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="0103" class="ky kz hu kx b fv mc md l me mf">G.add('nonTrackedLocalVariable')('blah')<br/>G.add('counter')(G.state().counter + 1)<br/>G.commit()</span><span id="9017" class="ky kz hu kx b fv mg md l me mf">// Below, it actually updates the associated `User` resource on G.forms, so this change gets reflected on all references on the local state object that points to that resource<br/><br/>G.add('userDetails.email')('new@email.com')<br/>G.commit()</span></pre><p id="9c88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这种变化只是局部的。修改数据的GraphQL方法是调用突变。如果更改没有发生在后端，对跟踪数据的本地状态的更新将在下一次拉取时被覆盖。参见<em class="kt"> G.exec </em>。</p><h2 id="bd82" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">提交</h2><p id="c07b" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">添加操作只是排队，直到提交后才生效。这确保了开发人员可以准确地决定何时更新状态，并且在此之前，使用该状态的所有内容都将收到相同的版本。</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="34d4" class="ky kz hu kx b fv mc md l me mf">G.commit(options)</span></pre><h2 id="a365" class="ky kz hu bd la lb lc ld le lf lg lh li jc lj lk ll jg lm ln lo jk lp lq lr ls dt translated">g .执行</h2><p id="b90d" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">该命令用于执行突变。它接受一个<strong class="it hv">执行键</strong>和一个<strong class="it hv"> GQL变异</strong>。它可以额外带<strong class="it hv">参数</strong>和一些选项。</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="e0f2" class="ky kz hu kx b fv mc md l me mf">G.exec(key)(mutation)(params)(options)</span></pre><p id="aa79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">突变调用的加载/错误状态在<code class="eh ku kv kw kx b">G.status</code>上处理，就像轨道一样。它是在执行键下组织的:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="4e54" class="ky kz hu kx b fv mc md l me mf">G.exec('modifyUserDetails')(`...`)({...})({...})</span><span id="5409" class="ky kz hu kx b fv mg md l me mf">// G.status<br/>// {<br/>//  modifyUserDetails: {<br/>//   loading: &lt;boolean&gt;,<br/>//   error: &lt;err object&gt;,<br/>//  }<br/>// }</span></pre><p id="12ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">突变是在GQL中执行写操作的唯一方式，更新必须与本地状态保持同步。有几个选项可以做到这一点。下面是一个变异示例，展示了这些选项是如何工作的:</p><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="18d3" class="ky kz hu kx b fv mc md l me mf">const m = `<br/>  mutation ModifyUserEmail($id: String!){<br/>    modifyUserEmail(id: $id){<br/>      id<br/>      email<br/>    }<br/>  }<br/>`;</span><span id="f1d6" class="ky kz hu kx b fv mg md l me mf">// Note that since functions are curried, `exec` below is assigned to a function that takes in the options to trigger the G.exec call.</span><span id="3663" class="ky kz hu kx b fv mg md l me mf">const exec = G.exec('modifyUserEmail')(m)({ id: '123' });</span></pre><ul class=""><li id="2ea6" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo kk kl km kn dt translated"><strong class="it hv"> Merge </strong> —如果您知道变异用修改后的资源或者只是修改后的位来响应，那么您可以使用<code class="eh ku kv kw kx b">merge</code>选项。这将遍历响应，通过给定的<code class="eh ku kv kw kx b">__typename</code>和<code class="eh ku kv kw kx b">id</code>将资源与表单匹配，并更新表单对象。因此，在您的本地状态中，您将拥有修改后的资源的最新版本。</li></ul><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="a8db" class="ky kz hu kx b fv mc md l me mf">exec({ merge: true })</span></pre><ul class=""><li id="a9cf" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo kk kl km kn dt translated"><strong class="it hv">手动</strong> —如果您不咨询服务器响应就知道哪个字段发生了变化，或者如果您希望手动更新状态，您可以使用您首选的异步方法，并更新本地状态，如下所示:</li></ul><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="dd3e" class="ky kz hu kx b fv mc md l me mf">// Manually update the local state<br/>const updateEmail = res =&gt; {<br/>  G.add('userDetails.email')(res.email);<br/>  G.commit()<br/>}</span><span id="935d" class="ky kz hu kx b fv mg md l me mf">// Callback<br/>exec({ callback: updateEmail })</span><span id="666e" class="ky kz hu kx b fv mg md l me mf">// Promise<br/>exec({ promise: true }).then(updateEmail)</span><span id="824d" class="ky kz hu kx b fv mg md l me mf">// Async / await<br/>const res = await exec({ async: true })<br/>updateEmail(res);</span></pre><ul class=""><li id="b160" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo kk kl km kn dt translated"><strong class="it hv">触发</strong> —有时候你可能不知道资源是如何改变的，后端可能不会返回修改后的版本。或者出于某种原因，您可能需要重新提取一个轨道。在这些情况下，您可以使用触发器选项。它接受一个或多个轨迹关键点，并将变异与给定轨迹相关联。它将<em class="kt"> G.status </em>上所有关联轨迹的<code class="eh ku kv kw kx b">loading</code>标志设置为真，一旦解决，它将触发对它们的强制<em class="kt"> G.pull </em>。</li></ul><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="f01c" class="ky kz hu kx b fv mc md l me mf">exec({ trigger: 'userDetails' })</span><span id="bb39" class="ky kz hu kx b fv mg md l me mf">// G.status<br/>// {<br/>//  userDetails: {..., loading: true },<br/>//  modifyUserEmail: {..., loading: true},<br/>// }</span></pre><ul class=""><li id="f4fc" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo kk kl km kn dt translated"><strong class="it hv">混血儿</strong>——你可以把以上所有的结合起来:</li></ul><pre class="jq jr js jt fq ly kx lz ma aw mb dt"><span id="389e" class="ky kz hu kx b fv mc md l me mf">exec({<br/>  merge: true,<br/>  trigger: 'userDetails',<br/>  callback: res =&gt; /* do something */<br/>})</span></pre><h1 id="73b3" class="mi kz hu bd la mj mk ml le mm mn mo li mp mq mr ll ms mt mu lo mv mw mx lr my dt translated">最后的话</h1><p id="9430" class="pw-post-body-paragraph ir is hu it b iu lt iw ix iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo hn dt translated">正如我提到的，这不是一个真正的图书馆。它是不完整的，并且可能有更多的事情要考虑，以使这成为现实。如果你喜欢这个想法，你可能想看看阿波罗客户端。它没有git风格的api，但是处理事情的方式非常相似。</p><p id="be58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望GitState能启发一些人，我也很想听听你们的想法！</p></div></div>    
</body>
</html>