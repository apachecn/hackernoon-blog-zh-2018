<html>
<head>
<title>Why is Python so slow?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python为什么这么慢？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-is-python-so-slow-e5074b6fe55b?source=collection_archive---------0-----------------------#2018-07-16">https://medium.com/hackernoon/why-is-python-so-slow-e5074b6fe55b?source=collection_archive---------0-----------------------#2018-07-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9c30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python越来越受欢迎。它用于DevOps、数据科学、Web开发和安全。</p><p id="0270" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，它没有赢得任何速度奖牌。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/e50a22c6931e62cd96208cfc24d102aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*M2qZQsVnDS-4i5zc.jpg"/></div></figure><blockquote class="jx"><p id="5378" class="jy jz hu bd ka kb kc kd ke kf kg jo ek translated">就速度而言，Java与C或C++或C#或Python相比如何？答案很大程度上取决于您运行的应用程序的类型。没有完美的基准测试，但是计算机语言基准测试游戏是一个很好的起点。</p></blockquote><p id="5c86" class="pw-post-body-paragraph ir is hu it b iu ki iw ix iy kj ja jb jc kk je jf jg kl ji jj jk km jm jn jo hn dt translated">十多年来，我一直在参考计算机语言基准游戏；与其他语言如Java、C#、Go、JavaScript、C++相比，Python是<a class="ae kh" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/python.html" rel="noopener ugc nofollow" target="_blank">最慢的</a>之一。这包括<a class="ae kh" href="https://en.wikipedia.org/wiki/Just-in-time_compilation" rel="noopener ugc nofollow" target="_blank"> JIT </a> (C#，Java)和<a class="ae kh" href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation" rel="noopener ugc nofollow" target="_blank"> AOT </a> (C，C++)编译器，以及JavaScript这样的解释型语言。</p><p id="3a5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kn">注意:当我说“Python”的时候，我说的是语言的引用实现，CPython。我将在本文中引用其他运行时。</em></p><blockquote class="jx"><p id="4933" class="jy jz hu bd ka kb ko kp kq kr ks jo ek translated">我想回答这个问题:<strong class="ak">当Python完成一个可比的应用程序比另一种语言慢2-10倍的时候，<em class="kt">为什么会慢</em>而我们<em class="kt">不能让它更快</em> </strong>？</p></blockquote><p id="0f98" class="pw-post-body-paragraph ir is hu it b iu ki iw ix iy kj ja jb jc kk je jf jg kl ji jj jk km jm jn jo hn dt translated">以下是最热门的理论:</p><ul class=""><li id="851f" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">"<em class="kn">是GIL(全局解释器锁)</em>"</li><li id="2fb6" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated"><em class="kn">因为它是解释的而不是编译的</em></li><li id="ded2" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">"这是因为它是一种动态类型语言"</li></ul><p id="26c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些原因中哪一个对性能影响最大？</p><h1 id="6086" class="li lj hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">“这是GIL”</h1><p id="225e" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">现代计算机的CPU有多个内核，有时有多个处理器。为了利用所有这些额外的处理能力，操作系统定义了一个称为线程的低级结构，其中一个进程(例如Chrome浏览器)可以产生多个线程，并在内部为系统提供指令。通过这种方式，如果一个进程特别占用CPU资源，该负载可以在内核间共享，从而有效地使大多数应用程序更快地完成任务。</p><p id="f1ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我写这篇文章的时候，我的Chrome浏览器打开了44个线程。请记住，基于POSIX(例如Mac OS和Linux)和Windows OS的线程的结构和API是不同的。操作系统还处理线程的调度。</p><p id="79df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前没有做过多线程编程，你需要快速熟悉锁这个概念。与单线程进程不同，您需要确保在更改内存中的变量时，多个线程不会试图同时访问/更改同一个内存地址。</p><p id="ede4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当CPython创建变量时，它分配内存，然后计算存在多少个对该变量的引用，这是一个称为引用计数的概念。如果引用的数量是0，那么它从系统中释放那块内存。这就是为什么在for循环的范围内创建一个“临时”变量，不会增加应用程序的内存消耗。</p><p id="482e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当变量在多个线程中共享时，挑战就变成了CPython如何锁定引用计数。有一个“全局解释器锁”仔细控制线程的执行。解释器一次只能执行一个操作，不管它有多少个线程。</p><h2 id="0ae3" class="ml lj hu bd lk mm mn mo lo mp mq mr ls jc ms mt lw jg mu mv ma jk mw mx me my dt translated">这对Python应用的性能意味着什么？</h2><p id="e819" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">如果你有一个单线程、单解释器的应用程序。<strong class="it hv">对速度</strong>没有影响。移除GIL不会影响代码的性能。</p><p id="0ac8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您希望通过使用线程在单个解释器(Python进程)中实现并发，并且您的线程是IO密集型的(例如网络IO或磁盘IO)，您将会看到GIL争用的后果。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff mz"><img src="../Images/f5ececadc8cfbc845c187d75987b120d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S_iSksY5oM5H1Qf_.png"/></div></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">From David Beazley’s GIL visualised post <a class="ae kh" href="http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html" rel="noopener ugc nofollow" target="_blank">http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html</a></figcaption></figure><p id="f245" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有一个web应用程序(例如Django ),并且你正在使用WSGI，那么对你的web应用程序的每个请求都是一个<strong class="it hv">单独的</strong> Python解释器，所以每个请求只有一个锁<em class="kn">。因为Python解释器启动缓慢，所以一些WSGI实现有一个“守护模式”<a class="ae kh" href="https://www.slideshare.net/GrahamDumpleton/secrets-of-a-wsgi-master" rel="noopener ugc nofollow" target="_blank">,它可以让Python进程一直运行。</a></em></p><h2 id="47ec" class="ml lj hu bd lk mm mn mo lo mp mq mr ls jc ms mt lw jg mu mv ma jk mw mx me my dt translated">其他Python运行时呢？</h2><p id="d9bd" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">PyPy有一个GIL，通常比CPython快3倍。</p><p id="82cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kh" href="http://www.jython.org/jythonbook/en/1.0/Concurrency.html#no-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank"> Jython没有GIL </a>，因为Jython中的Python线程由Java线程表示，并受益于JVM内存管理系统。</p><h2 id="834b" class="ml lj hu bd lk mm mn mo lo mp mq mr ls jc ms mt lw jg mu mv ma jk mw mx me my dt translated">JavaScript是如何做到这一点的？</h2><p id="d2be" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">首先，所有的Javascript引擎<a class="ae kh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">都使用标记-清除垃圾收集</a>。如上所述，GIL的主要需求是CPython的内存管理算法。</p><p id="b6cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JavaScript没有GIL，但是它也是单线程的，所以不需要。JavaScript的事件循环和承诺/回调模式是异步编程代替并发性的实现方式。Python对asyncio事件循环也有类似的处理。</p><h1 id="f396" class="li lj hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">“因为它是一种解释性语言”</h1><p id="09c2" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">我经常听到这种说法，我发现这是对CPython实际工作方式的粗略简化。如果你在一个终端上写了<code class="eh ni nj nk nl b">python myscript.py</code>，那么CPython将开始一长串的读取、词法分析、解析、编译、解释和执行代码。</p><p id="878c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你对这个过程感兴趣，我以前写过:</p><div class="nm nn fm fo no np"><a href="https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab ej"><div class="nr ab ns cl cj nt"><h2 class="bd hv fv z el nu eo ep nv er et ht dt translated">在6分钟内修改Python语言</h2><div class="nw l"><h3 class="bd b fv z el nu eo ep nv er et ek translated">本周，我向CPython核心项目提出了我的第一个pull-request，但是被拒绝了</h3></div><div class="nx l"><p class="bd b gc z el nu eo ep nv er et ek translated">hackernoon.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jv np"/></div></div></a></div><p id="5be6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个过程中很重要的一点是创建一个<code class="eh ni nj nk nl b">.pyc</code>文件，在编译阶段，字节码序列被写入Python 3上的<code class="eh ni nj nk nl b">__pycache__/</code>中的一个文件，或者Python 2中的同一个目录中。这不仅适用于你的脚本，也适用于你导入的所有代码，包括第三方模块。</p><p id="308b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以大多数时候(除非你写的代码只运行一次？)，Python是解释字节码，本地执行。与Java和C#相比。网络:</p><blockquote class="oe of og"><p id="59c2" class="ir is kn it b iu iv iw ix iy iz ja jb oh jd je jf oi jh ji jj oj jl jm jn jo hn dt translated">Java编译成一种“中间语言”，Java虚拟机读取字节码，<strong class="it hv">实时</strong>将其编译成机器代码。的。NET CIL是一样的。NET公共语言运行时(CLR)使用实时编译来编译机器代码。</p></blockquote><p id="1ab7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，如果它们都使用虚拟机和某种字节码，为什么Python在基准测试中比Java和C#慢这么多呢？首先，。NET和Java都是JIT编译的。</p><p id="8951" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JIT或即时编译需要一种中间语言来将代码分成块(或帧)。提前(AOT)编译器被设计成在任何交互发生之前确保CPU能够理解代码中的每一行。</p><p id="eb7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JIT本身并没有使执行更快，因为它仍然在执行相同的字节码序列。然而，JIT支持在运行时进行优化。一个好的JIT优化器会看到应用程序的哪些部分被频繁执行，称之为“热点”。然后，它会对这些代码进行优化，用更高效的版本替换它们。</p><p id="c958" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着当您的应用程序一次又一次地做同样的事情时，速度会明显加快。另外，记住Java和C#是强类型语言，所以优化者可以对代码做更多的假设。</p><p id="d18a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PyPy有一个JIT ,如前一节所述，比CPython快得多。这篇性能指标评测文章更详细地介绍了—</p><div class="nm nn fm fo no np"><a href="https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab ej"><div class="nr ab ns cl cj nt"><h2 class="bd hv fv z el nu eo ep nv er et ht dt translated">Python最快的版本是哪个？</h2><div class="nw l"><h3 class="bd b fv z el nu eo ep nv er et ek translated">当然，“视情况而定”，但它取决于什么，以及如何评估哪一个版本的Python速度最快…</h3></div><div class="nx l"><p class="bd b gc z el nu eo ep nv er et ek translated">hackernoon.com</p></div></div><div class="ny l"><div class="ok l oa ob oc ny od jv np"/></div></div></a></div><h2 id="5f7e" class="ml lj hu bd lk mm mn mo lo mp mq mr ls jc ms mt lw jg mu mv ma jk mw mx me my dt translated">那么CPython为什么不使用JIT呢？</h2><p id="2090" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">JIT也有缺点:其中之一是启动时间。CPython的启动时间已经比较慢了，PyPy的启动速度比CPython慢2-3倍。众所周知，Java虚拟机启动缓慢。的。NET CLR通过在系统启动时启动来解决这个问题，但是CLR的开发人员也开发运行CLR的操作系统。</p><p id="8ad0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您有一个运行了很长时间的Python进程，其中的代码因为包含“热点”而可以优化，那么JIT就很有意义。</p><p id="c6eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，CPython是一个<strong class="it hv">通用</strong>实现。因此，如果您正在使用Python开发命令行应用程序，那么每次调用CLI时都必须等待JIT启动将会非常慢。</p><p id="2c14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CPython必须尝试服务尽可能多的用例。有可能<a class="ae kh" href="https://www.slideshare.net/AnthonyShaw5/pyjion-a-jit-extension-system-for-cpython" rel="noopener ugc nofollow" target="_blank">在CPython </a>中插入一个JIT，但是这个项目在很大程度上被搁置了。</p><blockquote class="jx"><p id="a571" class="jy jz hu bd ka kb ko kp kq kr ks jo ek translated">如果您想要JIT的好处，并且您有适合它的工作负载，那么使用PyPy。</p></blockquote><h1 id="e7da" class="li lj hu bd lk ll lm ln lo lp lq lr ls lt ol lv lw lx om lz ma mb on md me mf dt translated">"<em class="kt">因为它是一种动态类型语言</em>"</h1><p id="d761" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">在“静态类型”语言中，你必须在声明变量时指定变量的类型。这些语言包括C，C++，Java，C#，Go。</p><p id="9e4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在动态类型语言中，仍然有类型的概念，但是变量的类型是动态的。</p><pre class="jq jr js jt fq oo nl op oq aw or dt"><span id="dcae" class="ml lj hu nl b fv os ot l ou ov">a = 1<br/>a = "foo"</span></pre><p id="cef3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个玩具示例中，Python创建了第二个具有相同名称和类型<code class="eh ni nj nk nl b">str</code>的变量，并释放了为第一个<code class="eh ni nj nk nl b">a</code>实例创建的内存</p><p id="85ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">静态类型语言并不是为了让你的生活变得困难而设计的，它们是因为CPU的工作方式而设计的。如果一切最终都需要等同于一个简单的二进制操作，那么您必须将对象和类型向下转换到一个低级数据结构。</p><p id="5f7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python为你做到了这一点，你只是从来没有看到过，也不需要在意。</p><p id="93e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不必声明类型并不是Python速度慢的原因，Python语言的设计让你几乎可以做任何动态的事情。您可以在运行时替换对象上的方法，您可以将低级系统调用修改为运行时声明的值。几乎一切皆有可能。</p><p id="7130" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正是这种设计使得优化Python变得极其困难。</p><p id="f999" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了说明我的观点，我将使用一个在Mac OS中工作的名为Dtrace的系统调用跟踪工具。CPython发行版没有内置DTrace，所以您必须重新编译CPython。我的演示使用的是3.6.6</p><pre class="jq jr js jt fq oo nl op oq aw or dt"><span id="fa68" class="ml lj hu nl b fv os ot l ou ov">wget <a class="ae kh" href="https://github.com/python/cpython/archive/v3.6.6.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/python/cpython/archive/v3.6.6.zip</a><br/>unzip v3.6.6.zip<br/>cd v3.6.6<br/>./configure --with-dtrace<br/>make</span></pre><p id="13a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在<code class="eh ni nj nk nl b">python.exe</code>将在整个代码中使用Dtrace跟踪程序。<a class="ae kh" href="https://github.com/paulross/dtrace-py#the-lightning-talk" rel="noopener ugc nofollow" target="_blank">保罗·罗斯在Dtrace </a>上写了一篇精彩的闪电演讲。你可以<a class="ae kh" href="https://github.com/paulross/dtrace-py/tree/master/toolkit" rel="noopener ugc nofollow" target="_blank">为Python下载DTrace starter文件</a>来测量函数调用、执行时间、CPU时间、系统调用，各种乐趣。例如</p><p id="eddd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ni nj nk nl b">sudo dtrace -s toolkit/&lt;tracer&gt;.d -c ‘../cpython/python.exe script.py’</code></p><p id="e1e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ni nj nk nl b">py_callflow</code>跟踪器显示了应用程序中所有的函数调用</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff ow"><img src="../Images/68d1ae9479945d64b444929de919b73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Lz4UdUi4EwknJ0IcpSJ52g.gif"/></div></div></figure><p id="8f30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，Python的动态类型化是不是让它变慢了？</p><ul class=""><li id="34be" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">比较和转换类型的成本很高，每次读取、写入或引用变量时，都要检查类型</li><li id="c58e" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">很难优化如此动态的语言。Python的许多替代品如此之快是因为它们以性能的名义对灵活性做出了妥协</li><li id="92b8" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">看看<a class="ae kh" href="http://cython.org/" rel="noopener ugc nofollow" target="_blank"> Cython </a>，它结合了C-Static类型和Python来优化已知类型的代码<a class="ae kh" href="http://notes-on-cython.readthedocs.io/en/latest/std_dev.html" rel="noopener ugc nofollow" target="_blank">可以为</a>提供84倍的性能提升<strong class="it hv">。</strong></li></ul><h1 id="bb43" class="li lj hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">结论</h1><blockquote class="jx"><p id="77b8" class="jy jz hu bd ka kb ko kp kq kr ks jo ek translated">Python速度慢主要是因为它的动态性和多功能性。它可以用作解决各种问题的工具，在这种情况下，可能会有更优化、更快速的替代方案。</p></blockquote><p id="c934" class="pw-post-body-paragraph ir is hu it b iu ki iw ix iy kj ja jb jc kk je jf jg kl ji jj jk km jm jn jo hn dt translated">然而，有一些方法可以优化您的Python应用程序，比如利用async，理解分析工具，以及考虑使用多重解释器。</p><p id="4705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于启动时间不重要并且代码对JIT有益的应用程序，可以考虑PyPy。</p><p id="0a42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于性能至关重要且有更多静态类型变量的代码部分，考虑使用<a class="ae kh" href="http://cython.org/" rel="noopener ugc nofollow" target="_blank"> Cython </a>。</p><h2 id="26d1" class="ml lj hu bd lk mm mn mo lo mp mq mr ls jc ms mt lw jg mu mv ma jk mw mx me my dt translated">进一步阅读</h2><p id="a2fc" class="pw-post-body-paragraph ir is hu it b iu mg iw ix iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">杰克·VDP的优秀文章(虽然略显过时)<a class="ae kh" href="https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/" rel="noopener ugc nofollow" target="_blank">https://jakevdp . github . io/blog/2014/05/09/why-python-is-slow/</a></p><p id="115c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">戴夫·比兹利在http://www.dabeaz.com/python/GIL.pdf GIL的演讲</p><p id="d043" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于JIT编译器的一切<a class="ae kh" href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/" rel="noopener ugc nofollow" target="_blank">https://hacks . Mozilla . org/2017/02/a-crash-course-in-just-in-time-JIT编译器/ </a></p></div></div>    
</body>
</html>