<html>
<head>
<title>How I added awesome multi-threaded features to Express JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何添加令人敬畏的多线程特性来表达JS的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-added-awesome-multi-threaded-features-to-express-js-753452a1c10e?source=collection_archive---------5-----------------------#2018-07-16">https://medium.com/hackernoon/how-i-added-awesome-multi-threaded-features-to-express-js-753452a1c10e?source=collection_archive---------5-----------------------#2018-07-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3a8cce1f525cb51c8d6c349547141959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLnfr-m1ZR1gL2Hl5Q8KUw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Thread, yarn, and npm (not to scale): Photo by <a class="ae jg" href="https://unsplash.com/photos/8A7qKkvm_ew?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae jg" href="https://unsplash.com/search/photos/thread?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ba27" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="ca2a" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我写了<code class="eh ld le lf lg b"><a class="ae jg" href="https://www.npmjs.com/package/express-http-context" rel="noopener ugc nofollow" target="_blank">express-http-context</a></code>,这是一个非常简单的npm包，它提供了对请求范围的上下文的访问，可以在代码库中的任何地方使用。它有助于使令人敬畏的事情变得简单，比如将关联id添加到日志中。</p><h1 id="b1a6" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">事件循环的快速复习</h1><p id="cfd5" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">请允许我简单回顾一下Node的事件循环和“真正的”多线程语言之间的区别。</p><p id="8d67" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">事件循环是Node及其底层V8引擎最酷的特性之一(我猜你可以说它<em class="lm">是</em>节点……但我跑题了)。它允许Node在单线程上下文中运行应用程序，还可以处理多个并发的异步操作，而不会阻塞应用程序流。漂亮。</p><p id="0826" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">当异步操作开始时(例如调用API或写入数据库)，Node保持回调，然后继续运行当前的调用堆栈。当栈被清空时，当前的“帧”完成，节点或者开始另一个帧，或者如果没有其他事情要做就退出。(我很快就会回到这个话题。)</p><p id="5d10" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">当异步操作完成时，节点将结果放在内部消息队列中。当帧结束时，节点检查队列以查看是否有任何已完成的操作。如果有，则使用下一个消息开始新的帧；回调中的代码成为下一个调用堆栈，执行继续。</p><p id="4366" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">通过这种方式，Node可以轻松地完成所有的同步工作，直到完成为止。然后，它检查在它忙碌的时候是否有新的工作进来。如果什么都没有，应用程序就退出。</p><p id="4821" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">在真正的多线程环境中，每个线程都有自己的调用堆栈，并且在异步调用期间线程会被挂起。当异步调用完成时，线程从它自己的调用堆栈中停止的地方继续。当每个线程到达各自调用堆栈的末尾时，应用程序退出。</p><p id="442e" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">单线程事件循环和真正的并发多线程环境的区别之一是线程本地存储的概念。这种存储方式使CPU能够在异步事件发生时跟踪与线程相关的数据。还是那句话，超高级和手波浪，但大体概念在这里对我们有用。</p><h1 id="de77" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">线程和API</h1><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ln"><img src="../Images/b8e1a140f276501f5f671ca6be80ee11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sPqdsBB7Fw0dbtUBOmAig.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Building a multi-threaded application: Photo by <a class="ae jg" href="https://unsplash.com/photos/VO-7ZroQtJA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">sarathy selvamani</a> on <a class="ae jg" href="https://unsplash.com/search/photos/thread?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="633f" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">如果你要用。Net并在微软Windows上的IIS中运行它(并活下来讲故事😃)，对服务器的每个请求将由不同的线程处理。对于进行异步调用(例如对数据库或其他API)的API，每个线程将能够维护自己的上下文，并在这些异步调用完成后从它停止的地方继续。</p><p id="3773" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">。Net使用<code class="eh ld le lf lg b">HttpContext</code>类来公开当前线程，而当前线程代表请求的状态。你可以读和写cookies和headers，查看已经发生的错误，以及仅仅通过查看这个上下文的许多其他事情。这意味着无论您在代码中的什么位置，您都可以访问当前请求范围内的数据。</p><p id="6ae9" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">ExpressJS(我目前选择的Javascript API框架)在处理多个并发请求方面做得非常好，但是在提供对请求和响应范围的数据的访问方面做得不好。这是因为单线程事件驱动的执行模型不能很好地维护来自队列的每个消息的上下文。因此，如果您想要访问与请求相关的数据，比如auth header或correlation ID，您必须在整个代码库中传递请求或至少来自请求的数据。</p><p id="3354" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">对于较小的API，这不是问题。很多时候，所有的代码都存在于少数几个文件中。但是随着代码规模的增长和健康的代码分离变得至关重要，Express中缺少请求范围的存储变得显而易见。</p><h1 id="fe7e" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">如何在Express中实现这一点</h1><p id="8c62" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Express-http-context通过使用相对模糊的<code class="eh ld le lf lg b"><a class="ae jg" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank">async_hooks</a></code>模块添加了非常基本的<code class="eh ld le lf lg b">HttpContext</code>风格的功能来表达。根据文档，“<code class="eh ld le lf lg b">async_hooks</code>模块提供了一个API来注册回调，跟踪Node.js应用程序中创建的异步资源的生命周期。”</p><p id="60bb" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">像大多数开发人员一样，我不想为我构建的每个web API“注册跟踪异步资源生命周期的回调”,所以我将所有这些作为一个快速中间件放在了一起<code class="eh ld le lf lg b">express-http-context</code>。</p><p id="1cd0" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">以下是展示如何使用http上下文设置项目的最基本的示例:</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="6d42" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">第6行运行一个中间件，为每个请求创建一个新的上下文。在请求过程中添加到该上下文中的任何值对于同一个请求来说只能被<em class="lm">访问</em>。让我们添加另一个中间件，它为每个请求生成一个惟一的请求ID，然后将其添加到上下文中:</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="eff7" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">正如您所看到的，这个中间件创建了一个新的ID，然后它被添加到上下文中，并作为响应的头。现在我们可以在项目的任何地方获得当前的请求ID，即使我们不能简单地通过运行<code class="eh ld le lf lg b">const reqId = httpContext.get('requestId');</code>来访问原始的<code class="eh ld le lf lg b">res</code>。</p><h1 id="74b4" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">给我看些酷的东西！</h1><p id="0293" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我实际上是专门为了管理<a class="ae jg" href="https://blog.rapid7.com/2016/12/23/the-value-of-correlation-ids/" rel="noopener ugc nofollow" target="_blank">相关id</a>来记录日志而写的这个包。回顾一下，关联ID是一个在分布式系统的许多部分中传递的值，以便可以关联不连贯的调用。</p><p id="83a3" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">以下是我通常用于此目的的中间件:</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="5e6c" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">如您所见，我们实际上创建了两个id。首先，我们通过查看请求头来检查是否已经向我们传递了一个现有的相关ID。如果我们找不到，我们就创造一个，然后继续前进。接下来，我们创建一个请求ID。这两个id都被添加到上下文中，然后作为消息头添加到响应中。</p><p id="7979" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">我喜欢创建不同的关联和请求ID，以确保我们可以始终维护一个有保证的唯一请求ID。有些情况下，消费者会用同一个关联ID多次调用您的API。这通常发生在更基础的服务中。如果消费者需要在一次操作中多次调用您的API，他们可能会使用相同的关联ID。因此，相关ID表示分布在多个应用程序上的单个唯一操作，而请求ID表示对单个应用程序的单个唯一调用。</p><p id="6b1c" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">通过在日志中包含相关性和请求id，它极大地减少了跟踪整个生态系统中的任何错误或性能问题所需的工作量。</p><p id="8feb" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">最后，还要确保将关联ID传递给您可能使用的任何API。我通常为<code class="eh ld le lf lg b">request</code>包创建一个助手来自动添加<code class="eh ld le lf lg b">X-Correlation-ID</code>头。也许有更好的方法，但这是我的解决方案:</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="25e4" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">注意，这个助手模块可以完全从快速请求处理程序中分离出来，但是它仍然可以访问当前上下文，从而访问相关id。</p><p id="635f" class="pw-post-body-paragraph kf kg hu kh b ki lh kk kl km li ko kp kq lj ks kt ku lk kw kx ky ll la lb lc hn dt translated">总之，<code class="eh ld le lf lg b">express-http-context</code>增加了请求范围的上下文特性来表达API，类似于你在更重的多线程平台中发现的。</p><h1 id="d077" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">喜欢你看到的吗？</h1><p id="264f" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">希望你觉得这个项目有趣！如果是这样，以下是你可以提供帮助的方式:</p><ol class=""><li id="5a1c" class="lu lv hu kh b ki lh km li kq lw ku lx ky ly lc lz ma mb mc dt translated">怪异的行为？令人困惑的自述？Github问题超级有帮助！😃</li><li id="f978" class="lu lv hu kh b ki md km me kq mf ku mg ky mh lc lz ma mb mc dt translated">给它一颗星:<a class="ae jg" href="https://github.com/skonves/express-http-context" rel="noopener ugc nofollow" target="_blank">https://github.com/skonves/express-http-context</a>⭐</li><li id="1087" class="lu lv hu kh b ki md km me kq mf ku mg ky mh lc lz ma mb mc dt translated">给这个帖子几个👏</li></ol></div></div>    
</body>
</html>