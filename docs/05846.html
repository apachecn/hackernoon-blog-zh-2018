<html>
<head>
<title>Handling and documenting GraphQL errors using Apollo-Prophecy + Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用阿波罗-预言+阿波罗处理和记录GraphQL错误</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/handling-and-documenting-graphql-errors-using-apollo-prophecy-apollo-7a32de3547a1?source=collection_archive---------10-----------------------#2018-07-16">https://medium.com/hackernoon/handling-and-documenting-graphql-errors-using-apollo-prophecy-apollo-7a32de3547a1?source=collection_archive---------10-----------------------#2018-07-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0d105ddafc6f353bf126197c08437ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-rI1KV22Ghve32IjoClOw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">You shall fail… successfully</figcaption></figure><p id="efb7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt ke translated">所有计算机程序都有错误；它们可能很难维护，但是正确处理它们无疑是构建应用程序最关键的部分。</p><p id="3285" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在客户端/服务器架构的环境中，我们需要服务器输出<strong class="ji hv">格式良好的</strong>和<strong class="ji hv">易于识别的错误</strong>，客户端可以<strong class="ji hv">无缝读取、处理</strong>和<strong class="ji hv">处理</strong>，以便<strong class="ji hv">成功失败</strong>。</p><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/a21fd669ed50fe4896914cfeceafb124.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*H4fjHIsJZblHY6YgiHMoTg.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><strong class="bd ks">E.g. a successful failure</strong></figcaption></figure><p id="306b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">GraphQL驱动的API没有例外😏)到这个规律。以下是GraphQL规范的最新草案<em class="kt">(孙，2018 . 6 . 10)</em>关于错误输出应该如何格式化的内容。</p><blockquote class="ku kv kw"><p id="bc78" class="jg jh kt ji b jj jk jl jm jn jo jp jq kx js jt ju ky jw jx jy kz ka kb kc kd hn dt translated">如果操作遇到任何错误，响应映射必须包含一个带有关键字<code class="eh la lb lc ld b"><em class="hu">errors</em></code>的条目。</p><p id="1875" class="jg jh kt ji b jj jk jl jm jn jo jp jq kx js jt ju ky jw jx jy kz ka kb kc kd hn dt translated">每个错误都必须包含一个带有关键字<code class="eh la lb lc ld b"><em class="hu">message</em></code>的条目，该条目带有错误的字符串描述，旨在为开发人员理解和纠正错误提供指导。</p><p id="ff58" class="jg jh kt ji b jj jk jl jm jn jo jp jq kx js jt ju ky jw jx jy kz ka kb kc kd hn dt translated">GraphQL服务可能会通过关键字<code class="eh la lb lc ld b"><em class="hu">extensions</em></code>提供额外的错误条目。如果设置了这个条目，它的值必须是map。这个条目是为实现者保留的，他们可以以他们认为合适的方式向错误添加附加信息，并且对其内容没有附加限制。</p></blockquote><p id="15d2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">考虑到这一点，典型的错误对象应该如下所示:</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="46d5" class="li lj hu ld b fv lk ll l lm ln">...<br/>"errors": [<br/>    {<br/>      "message": "Only Prophets can do this",<br/>      "locations": [ ... ],<br/>      "path": [ ... ],<br/>      "extensions": {<br/>        "code": "NOT_A_PROPHET",<br/>        "timestamp": "Thu Jun 21 17:03:00 UTC 2018"<br/>      }<br/>    }<br/>  ]<br/>...</span></pre><p id="6ff8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请记住，我们希望错误输出是“<strong class="ji hv">格式良好的</strong>和<strong class="ji hv">易于识别的</strong>”，这意味着它应该至少包含一个可以被计算机无缝处理的字段。</p><p id="120e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要考虑的第一个候选项是<code class="eh la lb lc ld b">message</code>，一个<em class="kt">“针对开发人员的错误的字符串描述[…]”。</em>由于它被格式化为人类可读的格式，它可能是一个包含不需要的字符(<em class="kt"> %，à，$，€，@，空格，</em>等)的有表现力的长字符串，因此并不理想。</p><p id="632e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">根据规范，<code class="eh la lb lc ld b">extensions</code>应为<code class="eh la lb lc ld b">errors</code> <em class="kt">的任何附加条目的专用空间。</em>在这里，它赋予我们附加一个<code class="eh la lb lc ld b">code</code>键的能力，提供一个<strong class="ji hv">机器可读的</strong>数据，可以被<em class="kt"/><strong class="ji hv"><em class="kt">无缝读取，处理</em></strong><em class="kt"/><strong class="ji hv"><em class="kt">处理</em> </strong> <em class="kt">。</em></p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="4d2c" class="li lj hu ld b fv lk ll l lm ln">if (error.extensions.code === "NOT_A_PROPHET") {<br/>  // Do Something<br/>}</span></pre><h1 id="58ba" class="lo lj hu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk dt translated">走向🏇</h1><p id="fe77" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">我们刚刚看到了关于如何在GraphQL API的上下文中输出错误的指南。有了它，我们应该能够:</p><ul class=""><li id="b66a" class="mq mr hu ji b jj jk jn jo jr ms jv mt jz mu kd mv mw mx my dt translated">在我们的解析器中抛出并输出符合<strong class="ji hv">规范的</strong>和<strong class="ji hv">可识别的</strong>错误——多亏了<code class="eh la lb lc ld b"><em class="kt">extensions</em></code>。</li><li id="ac21" class="mq mr hu ji b jj mz jn na jr nb jv nc jz nd kd mv mw mx my dt translated">识别和处理错误客户端到<strong class="ji hv">失败成功</strong>。</li></ul><p id="2cad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而，该规范并没有为API错误文档、重试或故障处理等问题指定指导原则，这意味着有无数种方法可以为此目的适当地安排我们的代码库。</p><p id="c208" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">没有明确的约定导致我构建了<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">阿波罗-预言</strong> </a>。</p><h1 id="9db5" class="lo lj hu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk dt translated">异教徒的方式</h1><p id="ea33" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">首先，让我们举例说明没有<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">阿波罗预言</strong> </a>维护错误会是什么样子。<strong class="ji hv"> </strong>为此，我们将使用<strong class="ji hv"> Apollo Server </strong>，这是一个优秀的、符合规范的、功能齐全的、维护良好的nodeJS graph QL服务器实现。</p><p id="0526" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为我们使用的是<a class="ae ne" href="https://github.com/apollographql/apollo-server" rel="noopener ugc nofollow" target="_blank"> Apollo服务器</a>，所以我们可以使用构造函数<code class="eh la lb lc ld b">ApolloError(message, code)</code>:使用这个构造函数抛出的错误会产生一个符合规范的JSON输出，如上图所示。</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="0e2a" class="li lj hu ld b fv lk ll l lm ln">throw new ApolloError("Only Prophets can do this", "NOT_A_PROPHET");</span></pre><p id="6688" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了让我们更容易存储错误，我们可以按照以下方式组织我们的服务器端代码:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">server</figcaption></figure><p id="51bf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">并正确处理这样的错误:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">client</figcaption></figure><p id="a5bc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">完成了，对吗？</p><p id="3e15" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">不，我们可以做得更好。有了这个配置，我们最终做了同样的工作两次:因为<strong class="ji hv">对于服务器上每个现有的错误条目</strong>，我们必须在客户端编写一个<strong class="ji hv">对应的键</strong>。</p><p id="a91b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我不知道你怎么想，但我更喜欢说干。</p></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><h1 id="b678" class="lo lj hu bd lp lq no ls lt lu np lw lx ly nq ma mb mc nr me mf mg ns mi mj mk dt translated">利用API文档📑</h1><p id="bc5c" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">GraphQL最有趣的命题之一是<strong class="ji hv"> <em class="kt"> API应该是自文档化的。</em> </strong>虽然这通常是通过一种称为“自省查询”的机制来完成的，这种机制为我们提供了模式中字段和类型的详细信息，但这并不意味着我们不能向模式本身添加文档资料:</p><blockquote class="nt"><p id="7abc" class="nu nv hu bd nw nx ny nz oa ob oc kd ek translated">如果错误是模式的一部分呢？</p></blockquote><p id="5307" class="pw-post-body-paragraph jg jh hu ji b jj od jl jm jn oe jp jq jr of jt ju jv og jx jy jz oh kb kc kd hn dt translated">下面是我们如何利用这一点:</p><p id="0eb8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 1。</strong>我们将<strong class="ji hv"> </strong>错误<strong class="ji hv"> </strong>包含在<strong class="ji hv"> </strong>模式中:</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="a156" class="li lj hu ld b fv lk ll l lm ln">type ErrorExtensions {<br/>  code: String!<br/>}</span><span id="d70c" class="li lj hu ld b fv oi ll l lm ln">type Error {<br/>  name: String!<br/>  message: String<br/>  extensions: ErrorExtensions<br/>}</span><span id="8cd6" class="li lj hu ld b fv oi ll l lm ln">type Query {<br/>  ...<br/>  errors: [Error!]!<br/>  ...<br/>}</span></pre><p id="55b9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 2。</strong>我们<strong class="ji hv"> </strong>在查询字段上创建相应的解析器:</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="39d6" class="li lj hu ld b fv lk ll l lm ln">...<br/>const resolvers = {<br/>  Query: {<br/>    ...<br/>    errors: { ... }<br/>  }<br/>}<br/>...</span></pre><h2 id="1dd0" class="li lj hu bd lp oj ok ol lt om on oo lx jr op oq mb jv or os mf jz ot ou mj ov dt translated">那很酷，但是客户怎么办？🤷</h2><p id="938b" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">假设关于错误的信息可以通过我们的API访问，我们需要找到一种从客户端访问它们的方法，记住我们希望避免两次做同样的工作。</p><p id="cceb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从这里我们可以讨论两种不同的实现:</p><ol class=""><li id="c10a" class="mq mr hu ji b jj jk jn jo jr ms jv mt jz mu kd ow mw mx my dt translated">每次我们的应用程序启动时，客户端可以<strong class="ji hv">执行一个查询来获取所有的错误代码，并将它们存储在本地</strong>。<strong class="ji hv">😒</strong> <em class="kt">咩… </em></li><li id="20a4" class="mq mr hu ji b jj mz jn na jr nb jv nc jz nd kd ow mw mx my dt translated">作为构建过程的一部分，通过获取<strong class="ji hv"> </strong>和<strong class="ji hv">在代码库</strong>中静态存储错误，在开发端处理它。<strong class="ji hv">💁</strong> <em class="kt">有何不可？</em></li></ol><p id="eb8d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">由于正确的错误处理对应用程序的良好运行至关重要，使用<strong class="ji hv">选项1 </strong>会使获取所有错误的定义成为应用程序启动过程的一个强制步骤——因此增加了加载时间。</p><p id="3815" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是为什么为了清洁度和整体性能，我更喜欢<strong class="ji hv">第二选项</strong>。</p></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><h1 id="9c3f" class="lo lj hu bd lp lq no ls lt lu np lw lx ly nq ma mb mc nr me mf mg ns mi mj mk dt translated">先知之道？🧙🏼‍</h1><p id="6096" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">我已经开始从事<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy" rel="noopener ugc nofollow" target="_blank">阿波罗预言</a>的工作:一个代码生成命令行界面，做我们需要的事情(还有一点点！).它将:</p><ul class=""><li id="3f47" class="mq mr hu ji b jj jk jn jo jr ms jv mt jz mu kd mv mw mx my dt translated">生成我们可以在解析器中抛出的错误，并通过模式作为文档公开— <code class="eh la lb lc ld b">apollo-prophecy generate</code></li><li id="2034" class="mq mr hu ji b jj mz jn na jr nb jv nc jz nd kd mv mw mx my dt translated">查询服务器模式并生成带有方法和帮助器的文件，以优雅地处理错误— <code class="eh la lb lc ld b">apollo-prophecy ask</code></li></ul><p id="70b5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">目标是让你的服务器和客户端错误库保持同步。</p><p id="a04c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，通过你喜欢的软件包管理器安装它。</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="9e7f" class="li lj hu ld b fv lk ll l lm ln">[npm | yarn] install -g apollo-prophecy</span></pre><h2 id="48af" class="li lj hu bd lp oj ok ol lt om on oo lx jr op oq mb jv or os mf jz ot ou mj ov dt translated">像希腊神一样制造错误🔮</h2><p id="e2cc" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated"><code class="eh la lb lc ld b">generate</code>命令将创建一个包含可抛出错误类的文件。它接受如下格式的JSON文件作为输入:</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Map of objects whose keys are error names, each of those object has a key “<code class="eh la lb lc ld b">message"</code> (optional) and "<code class="eh la lb lc ld b">code"</code></figcaption></figure><p id="3150" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它可以像下面这样运行(如果没有指定，它将在运行文件夹中查找一个<strong class="ji hv"> errors.json </strong>文件):</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="9ef0" class="li lj hu ld b fv lk ll l lm ln">apollo-prophecy generate errorsDef.json</span></pre><p id="a853" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用上面的<strong class="ji hv"> errosDef.json </strong>，CLI将生成以下文件。</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="cfbe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是生成的文件关键组件:</p><ul class=""><li id="d893" class="mq mr hu ji b jj jk jn jo jr ms jv mt jz mu kd mv mw mx my dt translated"><code class="eh la lb lc ld b">errorsList</code> —用于文档输出的普通JSON数组。它包含所有错误表示及其静态数据:<code class="eh la lb lc ld b">name</code>、<code class="eh la lb lc ld b">message</code>、<code class="eh la lb lc ld b">extensions -&gt; code</code>。<em class="kt">如果没有要生成的错误，总是生成但为空。</em></li><li id="7c72" class="mq mr hu ji b jj mz jn na jr nb jv nc jz nd kd mv mw mx my dt translated"><code class="eh la lb lc ld b">errorType</code> —可以包含在<strong class="ji hv">模式定义</strong>中的GraphQL对象类型。对于<em class="kt"> </em>文档，应与<code class="eh la lb lc ld b">errorsList</code> <em class="kt"> </em>一起使用。<em class="kt">总是按原样生成</em>。</li><li id="65dc" class="mq mr hu ji b jj mz jn na jr nb jv nc jz nd kd mv mw mx my dt translated"><code class="eh la lb lc ld b">PropheticError</code> —类扩展ApolloError本应由该文件中的其他错误<strong class="ji hv">继承</strong>。<em class="kt">总是按原样生成</em>。</li><li id="5e8a" class="mq mr hu ji b jj mz jn na jr nb jv nc jz nd kd mv mw mx my dt translated"><code class="eh la lb lc ld b">NotAProphetError ProphetNotFoundWithId</code> —这是用JSON文件输入的信息生成的两个自定义错误类。</li></ul><p id="5ff7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以在我们的服务器中使用所有这些元素。假设我们需要错误成为我们模式的一部分，我们可以做以下事情:</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="d3be" class="li lj hu ld b fv lk ll l lm ln">import { errorsList, NotAProphetError } from './gen/GeneratedErrors'</span><span id="23ed" class="li lj hu ld b fv oi ll l lm ln">Query: {<br/>  errors: () =&gt; errorsList<br/>  getAllUsers: () =&gt; {...throw new NotAProphetError()},<br/>}</span></pre><h2 id="a80c" class="li lj hu bd lp oj ok ol lt om on oo lx jr op oq mb jv or os mf jz ot ou mj ov dt translated">嗯，好吧…那我们现在是先知了吗？🤔</h2><p id="7a18" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">还没有；先知需要和神交流才能预见未来，不是吗？使用<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy" rel="noopener ugc nofollow" target="_blank">阿波罗预言</a>，我们可以用命令<code class="eh la lb lc ld b">ask</code>做类似的事情:</p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="bf9e" class="li lj hu ld b fv lk ll l lm ln">apollo-prophecy ask <a class="ae ne" href="http://localhost:3000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/graphql</a> [--field]</span></pre><p id="63fd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将向指定的端点发送一个请求，并尝试对<code class="eh la lb lc ld b">--field</code>选项执行GraphQL查询，以尝试获取错误信息(如果未指定任何内容，默认情况下将查询一个<em class="kt">“错误”字段</em>)。</p><p id="dff4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是生成文件的一个极其简化的版本。如果你想知道它到底是什么样子，那就自己去试试吧！</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure><ul class=""><li id="a4a6" class="mq mr hu ji b jj jk jn jo jr ms jv mt jz mu kd mv mw mx my dt translated"><code class="eh la lb lc ld b">PropheticErrorCode</code>—一个枚举，包含模式中暴露的所有错误的代码。</li><li id="0f44" class="mq mr hu ji b jj mz jn na jr nb jv nc jz nd kd mv mw mx my dt translated"><code class="eh la lb lc ld b">errorHere</code>和<code class="eh la lb lc ld b">isThis</code>是真正的两个助手方法，它们使我们能够以干净和可重用的方式处理客户端错误。</li></ul><h2 id="b6d1" class="li lj hu bd lp oj ok ol lt om on oo lx jr op oq mb jv or os mf jz ot ou mj ov dt translated"><code class="eh la lb lc ld b">- errorHere(error)</code></h2><p id="76aa" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">当被调用时，它返回一个对象，该对象有一个以在服务器上发现的每个错误命名的<strong class="ji hv">属性。根据所提供的参数，被调用的属性返回<strong class="ji hv">真或假</strong>:</strong></p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="63c2" class="li lj hu ld b fv lk ll l lm ln">import { errorHere } from `./_generated/Errors.ts`;</span><span id="ba43" class="li lj hu ld b fv oi ll l lm ln">...(error) =&gt; {<br/>  if(errorHere(error).isNotAProphetError){<br/>    // Do something<br/>  } else if(errorHere(error).isProphetNotFoundWithId){<br/>    // Do something else<br/>  }<br/>}</span></pre><h2 id="4425" class="li lj hu bd lp oj ok ol lt om on oo lx jr op oq mb jv or os mf jz ot ou mj ov dt translated"><code class="eh la lb lc ld b">- isThis(error)</code></h2><p id="9f15" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">当被调用时，它返回一个对象，该对象有一个以在服务器<strong class="ji hv">上发现的每个错误</strong>命名的<strong class="ji hv">处理函数。</strong></p><pre class="ko kp kq kr fq le ld lf lg aw lh dt"><span id="b243" class="li lj hu ld b fv lk ll l lm ln">import { isThis } from `./_generated/Errors.ts`;</span><span id="c406" class="li lj hu ld b fv oi ll l lm ln">...(error) =&gt; {<br/>  isThis(error)<br/>  .UserNotFoundError(() =&gt; ...)<br/>  .NotAProphetError(() =&gt; ...)<br/>  .handle()<br/>}</span></pre><p id="93ca" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">处理程序返回与<code class="eh la lb lc ld b">isThis</code>相同的实例对象，这样每个函数调用都可以被链接起来。一旦调用了<code class="eh la lb lc ld b">handle</code>方法，它就开始检查，如果匹配就调用相应的处理程序。</p><p id="93e8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后…瞧！多亏了<code class="eh la lb lc ld b">ask</code>命令，我们可以通过模式保持客户端错误存储库与API同步。通过使用<code class="eh la lb lc ld b">errorHere</code>和<code class="eh la lb lc ld b">isThis</code>,我们现在有了一个干净的、富有表现力的处理错误的方法——看，代码也很漂亮！</p><h1 id="8db1" class="lo lj hu bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk dt translated">结论</h1><p id="d431" class="pw-post-body-paragraph jg jh hu ji b jj ml jl jm jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd hn dt translated">就像任何年轻的技术一样，<a class="ae ne" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>仍然有空白需要填补。<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy" rel="noopener ugc nofollow" target="_blank">Apollo-prophet</a>就是为了填补其中一个空白而构建的:<em class="kt">我们如何实现错误处理和文档</em>。但这并不是谈话的结束；阿波罗预言是开源的，我相信我们可以一起想出更好的方法来改进它。</p><p id="b9f0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">关于阿波罗预言<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv"/></a>已经有很多工作和修正要做；贡献和建议都是受欢迎和需要的。请访问<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy/issues/new" rel="noopener ugc nofollow" target="_blank"> Github </a>并查看现有的<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy/issues" rel="noopener ugc nofollow" target="_blank">问题</a>或者甚至<a class="ae ne" href="https://github.com/theGlenn/apollo-prophecy/issues/new" rel="noopener ugc nofollow" target="_blank">创建新的</a>问题。</p><p id="d1d2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你已经走了这么远，感谢你阅读❤️。我真的希望你喜欢这篇文章，我很乐意听到你的想法和反馈🙂。</p><div class="ox oy fm fo oz pa"><a href="https://github.com/theGlenn/apollo-prophecy" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab ej"><div class="pc ab pd cl cj pe"><h2 class="bd hv fv z el pf eo ep pg er et ht dt translated">葛兰/阿波罗预言</h2><div class="ph l"><h3 class="bd b fv z el pf eo ep pg er et ek translated">阿波罗-预言-🔮GraphQL错误管理变得简单，为Apollo生成自定义的机器可读错误…</h3></div><div class="pi l"><p class="bd b gc z el pf eo ep pg er et ek translated">github.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po ja pa"/></div></div></a></div></div></div>    
</body>
</html>