<html>
<head>
<title>Improve Smart Contract Security by Formal Proofs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过形式化证明提高智能合同的安全性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/improve-smart-contract-security-by-formal-proofs-c0b377288e2e?source=collection_archive---------23-----------------------#2018-07-16">https://medium.com/hackernoon/improve-smart-contract-security-by-formal-proofs-c0b377288e2e?source=collection_archive---------23-----------------------#2018-07-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ad1f120e49e2513fae15ed2098a215a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2gUD6BhNjkF7ac4UEwg5Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/5mZ_M06Fc9g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Roman Mager</a> on <a class="ae jg" href="https://unsplash.com/search/photos/math?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="df08" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">智能合同中的漏洞长期威胁着区块链的项目、开发商和投资者。越来越多的<a class="ae jg" href="https://hackernoon.com/tagged/security" rel="noopener ugc nofollow" target="_blank">安全</a>团队正在这一领域努力，用各种方法来获得合同。SECBIT实验室建议将正式证明与传统测试和安全审计结合起来。在本文中，我们以GitHub仓库<a class="ae jg" href="https://github.com/sec-bit/tokenlibs-with-proofs" rel="noopener ugc nofollow" target="_blank">token libs-with proof</a>中的ERC20形式证明为例，展示形式证明在智能合约中的使用。我们希望正式的证明可以帮助消除错误的合同，并保护智能合同的所有方面，包括设计逻辑、实现、经济系统、<em class="kf">等</em>。</p><h1 id="9597" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">什么是正式证明</h1><p id="6a71" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">形式证明是形式验证下的一个概念，在<a class="ae jg" href="https://en.wikipedia.org/wiki/Formal_verification" rel="noopener ugc nofollow" target="_blank"> Wikipedia </a>上定义为</p><blockquote class="lj lk ll"><p id="c6cb" class="jh ji kf jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated"><em class="hu">在硬件和</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Software_system" rel="noopener ugc nofollow" target="_blank"> <em class="hu">软件系统</em></a><em class="hu"/><strong class="jj hv"><em class="hu">的背景下，形式化验证</em> </strong> <em class="hu">是对</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Mathematical_proof" rel="noopener ugc nofollow" target="_blank"> <em class="hu">证明</em> </a> <em class="hu">或反证</em><a class="ae jg" href="https://en.wikipedia.org/wiki/Correctness_(computer_science)" rel="noopener ugc nofollow" target="_blank"/><em class="hu">正确性的行为</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Algorithms" rel="noopener ugc nofollow" target="_blank"> <em class="hu">算法</em> </a> <a class="ae jg" href="https://github.com/sec-bit/tokenlibs-with-proofs" rel="noopener ugc nofollow" target="_blank"/></p><p id="392d" class="jh ji kf jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated"><em class="hu">这些系统的验证是通过在系统的抽象</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Mathematical_model" rel="noopener ugc nofollow" target="_blank"> <em class="hu">数学模型</em> </a> <em class="hu">上提供一个</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Formal_proof" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> <em class="hu">形式证明</em> </strong> </a> <em class="hu">来完成的，数学模型和系统的性质之间的对应关系通过构造是已知的。经常用于建模系统的数学对象的例子有:</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Finite_state_machine" rel="noopener ugc nofollow" target="_blank"> <em class="hu">有限状态机</em> </a> <em class="hu">，</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Labelled_transition_system" rel="noopener ugc nofollow" target="_blank"> <em class="hu">带标签的变迁系统</em> </a> <em class="hu">，</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Petri_net" rel="noopener ugc nofollow" target="_blank"> <em class="hu"> Petri网</em> </a> <em class="hu">，</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Vector_addition_system" rel="noopener ugc nofollow" target="_blank"> <em class="hu">向量加法系统</em> </a> <em class="hu">，</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Timed_automaton" rel="noopener ugc nofollow" target="_blank"> <em class="hu">时间自动机</em> </a> <em class="hu"> 编程语言的形式语义如</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Operational_semantics" rel="noopener ugc nofollow" target="_blank"> <em class="hu">操作语义</em> </a> <em class="hu">，</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Denotational_semantics" rel="noopener ugc nofollow" target="_blank"> <em class="hu">指称语义</em> </a> <em class="hu">，</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Axiomatic_semantics" rel="noopener ugc nofollow" target="_blank"> <em class="hu">公理语义</em> </a> <em class="hu">和</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Hoare_logic" rel="noopener ugc nofollow" target="_blank"> <em class="hu">霍尔逻辑</em> </a> <em class="hu">。 </em></p></blockquote><p id="4688" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本质上，形式验证是为了证明数学模型的性质。在智能合约的正式证明中，模型是智能合约及其运行方式，属性是智能合约的那些期望的<em class="kf">良好的</em>行为，例如永远不会发生整数溢出和下溢。</p><p id="2034" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">具体来说，我们通过<em class="kf">程序逻辑</em>对智能契约进行形式化建模，证明它们符合给定的<em class="kf">契约规范</em>，并证明该规范能够进一步保证某些<em class="kf">高级属性</em>。所有证明都作为显式<em class="kf">证明对象</em>提供，其正确性可以独立于证明过程进行检查。</p><p id="798b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在讨论任何形式证明时，我们必须牢记以下先决条件:</p><ol class=""><li id="dee9" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated"><strong class="jj hv">所有的证明都是在一定的假设下；</strong></li><li id="8c36" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated"><strong class="jj hv">证明的正确性依赖于形式逻辑理论；</strong></li><li id="3a7f" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated"><strong class="jj hv">最终证明结果和定理确实定义了智能合约的正确性和安全性。</strong></li></ol><p id="4ea3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在ERC20契约的形式证明中，第一点要求基本定义的正确性；第二个要求一个有效的证明，可以由一个流行的证明助手Coq来构造和检查；最后一个依赖于我们正确地陈述常见的ERC20属性。</p><p id="a035" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:以上三点是先决条件，也是我们关于智能合约的形式证明的<em class="kf">可信计算基础</em> (TCB)。每个安全系统都依赖于特定的TCB。TCB越小越强，系统越安全。</p><h1 id="2f25" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">为什么要为智能合同提供正式证明</h1><p id="8643" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">以太坊通过引入一种图灵完备的智能契约语言改进和增强了智能契约，这种语言带来了与传统编程语言一样的灵活性和表达能力。不可避免地，错误和安全问题也被引入，导致巨大的经济损失。</p><p id="a205" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">SECBIT Labs对以太坊上所有部署的令牌合约进行了多轮扫描和分析，共记录了4172个存在漏洞和安全风险的合约。其中101个也是由CoinMarketCap记录的，完整的列表可以在SECBIT的repo<a class="ae jg" href="https://github.com/sec-bit/awesome-buggy-erc20-tokens" rel="noopener ugc nofollow" target="_blank">awesome-buggy-ERC 20-tokens</a>中找到。</p><p id="13f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在审核了大量智能合同后，SECBIT Labs意识到智能合同中的安全问题比传统软件更加复杂和关键:</p><ol class=""><li id="eb1b" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">智能合约的信任来自于其不变性，<em class="kf">即</em>，一旦部署，没有人能轻易修改代码。然而，这也意味着，如果没有提前做好准备，很难轻松快速地修复错误，尤其是在受到攻击的时候。这种脆弱性肯定会损害代币经济和区块链项目的信任和价值。</li><li id="9095" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated">许多部署的智能合约的实现都是开源的。虽然它可以提高契约的透明度和信任度，但也降低了攻击者发现漏洞的成本。</li><li id="fecb" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated">智能合同语言的设计仍然有许多限制和缺陷，更容易引入错误和安全风险。缺乏有经验的开发人员进一步加剧了这一问题。</li></ol><p id="d22f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">目前，解决智能合约安全问题的方法主要有两种:测试和审计。尽管它们是避免常见漏洞所必需的，但它们的能力仍然有限。</p><ul class=""><li id="6b94" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated">试验</li></ul><p id="1a74" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">安全团队可以手动或通过自动测试工具生成测试用例，并使用它们来检查输入组合和尽可能多的契约执行路径。然而，很难保证100%的覆盖率，所以测试中没有发现问题并不意味着没有bug。</p><ul class=""><li id="7525" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated">审计</li></ul><p id="83fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">专业的安全审计员检查合同的执行和逻辑，寻找漏洞和风险。审计主要依赖于审计人员的主观经验，因此审计的范围和有效性难以衡量和评价。</p><p id="25f8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">形式化证明通过数学模型描述程序，并通过数学证明证明其正确性和安全性。它基于严格的数学和逻辑，因此能够覆盖所有程序行为，并严格保证精确定义的正确性和安全性。形式化证明已成功应用于航天、高速铁路、核能和航空等关键领域。</p><p id="2921" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于智能合约的脆弱性及其管理的大量资产，智能合约要求极高的安全性。此外，经济学和博弈论的一些高层次和复杂的性质不容易通过测试和审计来验证。因此，正式证明无疑是确保这些小而复杂的智能合同的有效方式。</p><h1 id="b3c9" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">如何正式证明智能合同</h1><h2 id="c9cb" class="me kh hu bd ki mf mg mh km mi mj mk kq js ml mm ku jw mn mo ky ka mp mq lc mr dt translated">证明结构</h2><p id="1b12" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">智能合约的正式证明包括四个部分:源代码、规范、属性和证明。</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/4f1a2993cc968625b273c491c25055dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNOTZ-QcSFZyKQAS7UqRAw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Structure of Formal Proof</figcaption></figure><ul class=""><li id="8fa7" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated">源代码:是证明对象。</li><li id="60a7" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">规范:定义每个契约函数的预期行为。</li><li id="4550" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">Properties:定义当契约作为一个整体工作时期望的或者<em class="kf">好的</em>属性，比如令牌总量的不变性。</li><li id="2e51" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">证据:合同确实实现了规范并保证了特性的原因。</li></ul><h2 id="095e" class="me kh hu bd ki mf mg mh km mi mj mk kq js ml mm ku jw mn mo ky ka mp mq lc mr dt translated">证明的特性</h2><p id="235c" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我们对ERC20合同的证明主要证明了合同的以下性质:</p><ul class=""><li id="3dc2" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><em class="kf">NAT _ no overflow _ DSL _ no overflow</em>:transfer()和transferFrom()中没有有害的溢出</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="b0cc" class="me kh hu my b fv nc nd l ne nf">Lemma nat_nooverflow_dsl_nooverflow:<br/>   forall (m: state -&gt; a2v) st env msg,<br/>    (_from = _to \/ (_from &lt;&gt; _to /\ (m st _to &lt;= MAX_UINT256 - _value)))%nat -&gt;<br/>    ((from == to) ||<br/>     ((fun st env msg =&gt; m st (to st env msg)) &lt;= max_uint256 - value))%dsl st env msg = otrue.</span></pre><ul class=""><li id="f35d" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><em class="kf">Property _ total supply _ equal _ to _ sum _ balances</em>:total supply等于执行合同中任何步骤后所有余额的总和</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="b4be" class="me kh hu my b fv nc nd l ne nf"><em class="kf">(* Prop #1: total supply is equal to sum of balances *)</em><br/> Theorem Property_totalSupply_equal_to_sum_balances :<br/>  forall env0 env msg ml C E C' E',<br/>   create env0 msg C E<br/>   -&gt; env_step env0 env<br/>   -&gt; run env C ml C' E'<br/>   -&gt; Sum (st_balances (w_st C')) (st_totalSupply (w_st C')).</span></pre><ul class=""><li id="d8d5" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><em class="kf">Property _ total supply _ fixed _ transfer</em>:执行转账()后，代币金额保持不变</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="c9b2" class="me kh hu my b fv nc nd l ne nf"><em class="kf">(* Prop #2: total supply is fixed with transfer *)</em><br/> Theorem Property_totalSupply_fixed_transfer:<br/>  forall env C C' E' msg to v spec preP evP postP,<br/>   spec = funcspec_transfer to v (w_a C) env msg<br/>   -&gt; preP = spec_require spec<br/>   -&gt; evP = spec_events spec<br/>   -&gt; postP = spec_trans spec<br/>   -&gt; preP (w_st C) /\ evP (w_st C) E' /\ postP (w_st C) (w_st C')<br/>   -&gt; (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')).</span></pre><ul class=""><li id="0252" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><em class="kf">Property _ total supply _ fixed _ after _ initial ization</em>:初始化后令牌总数不变</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="922f" class="me kh hu my b fv nc nd l ne nf"><em class="kf">(* Prop #3: total supply is fixed after initialization *)</em><br/> Theorem Property_totalSupply_fixed_after_initialization:<br/>  forall env0 env msg C E C' E',<br/>   create env0 msg C E<br/>   -&gt; step env C msg C' E'<br/>   -&gt; (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')).</span></pre><ul class=""><li id="8012" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><em class="kf">Property _ total supply _ fixed _ delegate _ transfer</em>:执行transferFrom()后，令牌总数保持不变</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="767f" class="me kh hu my b fv nc nd l ne nf"><em class="kf">(* Prop #4: total supply is fixed with delegate transfer *)</em><br/> Theorem Property_totalSupply_fixed_delegate_transfer1:<br/>   forall env C C' E' from msg to v spec,<br/>   spec = funcspec_transferFrom_1 from to v (w_a C) env msg<br/>   -&gt; (spec_require spec) (w_st C) /\ (spec_events spec) (w_st C) E' /\ (spec_trans spec) (w_st C) (w_st C')<br/>   -&gt; (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')).</span><span id="b22d" class="me kh hu my b fv ng nd l ne nf"> Theorem Property_totalSupply_fixed_delegate_transfer2:<br/>   forall env C C' E' from msg to v spec,<br/>   spec = funcspec_transferFrom_2 from to v (w_a C) env msg<br/>   -&gt; (spec_require spec) (w_st C) /\ (spec_events spec) (w_st C) E' /\ (spec_trans spec) (w_st C) (w_st C')<br/>   -&gt; (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')).</span></pre><ul class=""><li id="a6dd" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><em class="kf">Property _ from _ to _ balances _ change</em>:转账只影响所涉及账户的余额，其他账户不变</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="82fd" class="me kh hu my b fv nc nd l ne nf"><em class="kf">(* Prop #5: only balances of from and to changed by transfer*)</em><br/> Theorem Property_from_to_balances_change_only:<br/>  forall env C C' E' to addr msg v spec,<br/>   spec = funcspec_transfer to v (w_a C) env msg<br/>   -&gt; (spec_require spec) (w_st C) /\<br/>     (spec_events spec) (w_st C) E' /\<br/>     (spec_trans spec) (w_st C) (w_st C')<br/>   -&gt; m_sender msg &lt;&gt; to<br/>   -&gt; m_sender msg &lt;&gt; addr<br/>   -&gt; to &lt;&gt; addr<br/>   -&gt; (st_balances (w_st C') to = (st_balances (w_st C) to) + v)<br/>     /\ (st_balances (w_st C') (m_sender msg) = (st_balances (w_st C) (m_sender msg)) - v)<br/>     /\ st_balances (w_st C') addr = st_balances (w_st C) addr.</span></pre><h2 id="bdc6" class="me kh hu bd ki mf mg mh km mi mj mk kq js ml mm ku jw mn mo ky ka mp mq lc mr dt translated">证明过程</h2><p id="664f" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">被证明的合同是一个标准的ERC20合同，包括六个公共函数:<code class="eh nh ni nj my b">constructor</code>、<code class="eh nh ni nj my b">transfer()</code>、<code class="eh nh ni nj my b">transferFrom()</code>、<code class="eh nh ni nj my b">balanceOf()</code>、<code class="eh nh ni nj my b">approve()</code>和<code class="eh nh ni nj my b">allowance()</code>。简单的证明过程如下所示。</p><p id="7673" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> 1。定义规格</strong></p><blockquote class="lj lk ll"><p id="e4b8" class="jh ji kf jj b jk jl jm jn jo jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd ke hn dt translated"><em class="hu">一种</em> <strong class="jj hv"> <em class="hu">规格语言</em> </strong> <em class="hu">一种</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Formal_language" rel="noopener ugc nofollow" target="_blank"> <em class="hu">形式语言</em></a><a class="ae jg" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank"><em class="hu">计算机科学</em> </a> <em class="hu">系统分析</em><a class="ae jg" href="https://en.wikipedia.org/wiki/Systems_analysis" rel="noopener ugc nofollow" target="_blank"><em class="hu"><em class="hu"/><a class="ae jg" href="https://en.wikipedia.org/wiki/Requirements_analysis" rel="noopener ugc nofollow" target="_blank"><em class="hu">需求分析</em> </a> <em class="hu">和<a class="ae jg" href="https://en.wikipedia.org/wiki/Systems_design" rel="noopener ugc nofollow" target="_blank"/></em></em></a></p></blockquote><p id="2ec6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf"> Spec.v </em>定义了合同中六个公共功能的规范。</p><p id="c549" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个函数的执行可能涉及多种情况，并且在每种情况下表现不同。我们为一种情况定义一个规格说明规则，因此规格说明通常由一个或多个规则组成。以<code class="eh nh ni nj my b">transferFrom()</code>的规格为例:它由两个规则- <code class="eh nh ni nj my b">funspec_transferFrom_1</code>和<code class="eh nh ni nj my b">funcspec_transferFrom_2</code>组成，对应的是审批额度小于<code class="eh nh ni nj my b">2**256-1</code>或等于<code class="eh nh ni nj my b">2**256-1</code>的两种情况。</p><p id="8cec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以<code class="eh nh ni nj my b">funcspec_transferFrom_1</code>为例，每个规范规则都由以下部分组成。</p><ul class=""><li id="d484" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><code class="eh nh ni nj my b">spec_require</code>指定在第一种情况下执行<code class="eh nh ni nj my b">transferFrom</code>之前必须满足的先决条件。</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="5d3e" class="me kh hu my b fv nc nd l ne nf">Definition funcspec_transferFrom_1<br/>        (from: address)<br/>        (to: address)<br/>        (value: value) :=<br/>    fun (this: address) (env: env) (msg: message) =&gt;<br/>     (mk_spec<br/>      (fun S : state =&gt;<br/>      <em class="kf">(* require(balances[_from] &gt;= _value); *)</em><br/>        st_balances S from &gt;= value /\<br/>      <em class="kf">(* require(_from == _to || balances[_to] &lt;= MAX_UINT256 - _value); *)</em><br/>        ((from = to) \/ (from &lt;&gt; to /\ st_balances S to &lt;= MAX_UINT256 - value)) /\<br/>      <em class="kf">(* require(allowance &gt;= _value); *)</em><br/>        st_allowed S (from, m_sender msg) &gt;= value /\<br/>      <em class="kf">(* allowance &lt; MAX_UINT256 *)</em><br/>        st_allowed S (from, m_sender msg) &lt; MAX_UINT256<br/>      )<br/>     ...</span></pre><ul class=""><li id="5220" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><code class="eh nh ni nj my b">spec_events</code>指定成功执行功能后必须发生的事件:</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="5960" class="me kh hu my b fv nc nd l ne nf">Definition funcspec_transferFrom_1<br/>        (from: address)<br/>        (to: address)<br/>        (value: value) :=<br/>    fun (this: address) (env: env) (msg: message) =&gt;<br/>     (mk_spec<br/>      <em class="kf">(* require omitted *)</em></span><span id="0e9a" class="me kh hu my b fv ng nd l ne nf">      <em class="kf">(* emit Transfer(_from, _to, _value); *)</em><br/>      <em class="kf">(* return True; *)</em><br/>      (fun S E =&gt; E = (ev_Transfer (m_sender msg) from to value) :: (ev_return _ True) :: nil)</span></pre><p id="d864" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在哪里，</p><ul class=""><li id="7fc0" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated"><code class="eh nh ni nj my b">ev_Transfer</code>代表事件<code class="eh nh ni nj my b">Transfer</code>；</li><li id="5842" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated"><code class="eh nh ni nj my b">ev_return</code>是规范中的一个伪事件，用来表示函数返回和返回值。</li><li id="174d" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated"><code class="eh nh ni nj my b">spec_trans</code>指定成功执行功能时的状态转换，例如存储变量的变化:</li></ul><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="534b" class="me kh hu my b fv nc nd l ne nf">Definition funcspec_transferFrom_1<br/>        (from: address)<br/>        (to: address)<br/>        (value: value) :=<br/>    fun (this: address) (env: env) (msg: message) =&gt;<br/>     (mk_spec<br/>      <em class="kf">(* require omitted *)</em><br/>      <em class="kf">(* events omitted *)</em></span><span id="b5c1" class="me kh hu my b fv ng nd l ne nf">      <em class="kf">(* State transition: *)</em><br/>      (fun S S' : state =&gt;<br/>      <em class="kf">(* Unchanged. *)</em><br/>        st_totalSupply S' = st_totalSupply S /\<br/>        st_name S' = st_name S /\<br/>        st_decimals S' = st_decimals S /\<br/>        st_symbol S' = st_symbol S /\<br/>      <em class="kf">(* balances[_from] -= _value; *)</em><br/>        st_balances S' = (st_balances S) $+{ from &lt;- -= value }<br/>      <em class="kf">(* balances[_to] += _value; *)</em><br/>                        $+{ to &lt;- += value } /\<br/>      <em class="kf">(* allowed[_from][msg.sender] -= _value; *)</em><br/>        st_allowed S' = (st_allowed S) $+{ from, m_sender msg &lt;- -= value }<br/>      )</span></pre><p id="bada" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中规定，必须按预期改变<code class="eh nh ni nj my b">balances</code>和<code class="eh nh ni nj my b">allowed</code>中的相应条目，而其他存储变量不变。</p><p id="6c5d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所有规范规则的完整定义请参考<em class="kf">规范五</em>。</p><p id="aa93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> 2。对照规格进行验证</strong></p><p id="5e11" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在证明上面定义的规范的高级属性之前，我们需要确保Solidity源代码确实实现了规范。首先，我们在Coq中表示可靠性合同代码。Coq中为此定义了领域规范语言(DSL)。例如，ERC20函数<code class="eh nh ni nj my b">transfer()</code>可以在<em class="kf"> DSL.v </em>中表示如下:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="ad45" class="me kh hu my b fv nc nd l ne nf">(* DSL representation of transfer(), generated from solidity *)<br/>   Definition transfer_dsl : Stmt :=<br/>    (@require(balances[msg.sender] &gt;= value) ;<br/>    @require((msg.sender == to) || (balances[to] &lt;= max_uint256 - value)) ;<br/>    @balances[msg.sender] -= value ;<br/>    @balances[to] += value ;<br/>    (@emit Transfer(msg.sender, to, value)) ;<br/>    (@return true)<br/>    ).</span></pre><p id="ec62" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我们证明DSL中的每一个函数都符合规范，例如我们通过<em class="kf"> DSL.v </em>中的以下引理证明<code class="eh nh ni nj my b">transfer()</code>符合<code class="eh nh ni nj my b">funcspec_transfer</code>:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="1530" class="me kh hu my b fv nc nd l ne nf">Lemma transfer_dsl_sat_spec:<br/>  forall st env msg this,<br/>    spec_require (funcspec_transfer _to _value this env msg) st -&gt;<br/>    forall st0 result,<br/>      dsl_exec transfer_dsl st0 st env msg this nil = result -&gt;<br/>        spec_trans (funcspec_transfer _to _value this env msg) st (ret_st result) /\<br/>        spec_events (funcspec_transfer _to _value this env msg) (ret_st result) (ret_evts result).</span></pre><p id="0047" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请参考<em class="kf"> DSL.v </em>获取完整的DSL定义、DSL表示和规范证明。</p><p id="3d9f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> 3。定义并证明高级属性</strong></p><p id="8dd7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的规范定义了一个函数每次执行的预期行为，而高级属性定义了当接收到任意消息调用时，契约作为一个整体所呈现的预期行为。例如，在<em class="kf"> DSL.v </em>中定义的以下属性声明了一个属性，即无论契约处理哪个消息调用，令牌都不会丢失:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="f026" class="me kh hu my b fv nc nd l ne nf"><em class="kf">(* Prop #1: total supply is equal to sum of balances *)</em><br/>  Theorem Property_totalSupply_equal_to_sum_balances :<br/>   forall env0 env msg ml C E C' E',<br/>    create env0 msg C E<br/>    -&gt; env_step env0 env<br/>    -&gt; run env C ml C' E'<br/>    -&gt; Sum (st_balances (w_st C')) (st_totalSupply (w_st C')).</span></pre><p id="19f1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所有高级属性的完整定义和证明请参见<em class="kf">规范五</em>。</p><h1 id="36f9" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">未来计划</h1><p id="5959" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我们创建了项目<a class="ae jg" href="https://github.com/sec-bit/tokenlibs-with-proofs" rel="noopener ugc nofollow" target="_blank">token libs-with proof</a>来收集和发布我们对各种令牌契约的正式证明。</p><ul class=""><li id="bd8d" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke md lv lw lx dt translated">我们将证明更多的公共属性，以帮助社区避免漏洞和风险。</li><li id="f886" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">我们将证明更多的具有更多特征的象征性契约，例如冻结、升级、权限操纵、添加所有权。</li><li id="6059" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">我们正在研究证明博弈论的高级属性，例如公平性、乐观策略、纳什均衡。</li></ul><p id="0464" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们希望这个项目可以成为一个有用的资源和参考，展示如何在智能合同中使用形式证明。我们也希望更多的智能合约开发者和安全专家能够通过形式化的证明加入到提高智能合约安全性的研究和应用中来。如果您有任何问题、建议和想法，欢迎在我们的<a class="ae jg" href="https://gitter.im/sec-bit/Lobby" rel="noopener ugc nofollow" target="_blank"> Gitter频道</a>讨论。</p><p id="8f1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">特别感谢来自康赛思中国的</em> <a class="nk nl gr" href="https://medium.com/u/cb00151fd96b?source=post_page-----c0b377288e2e--------------------------------" rel="noopener" target="_blank"> <em class="kf">【汤怡】</em> </a> <em class="kf">与我们讨论了这个话题并提供了反馈和意见。</em></p><h1 id="024f" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">相关著作</h1><ul class=""><li id="7951" class="lp lq hu jj b jk le jo lf js nm jw nn ka no ke md lv lw lx dt translated">SECBIT实验室:真棒-错误-er C20-令牌。<a class="ae jg" href="https://github.com/sec-bit/awesome-buggy-erc20-tokens" rel="noopener ugc nofollow" target="_blank">https://github.com/sec-bit/awesome-buggy-erc20-tokens</a></li><li id="a460" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">康斯塞斯:代币。<a class="ae jg" href="https://github.com/ConsenSys/Tokens" rel="noopener ugc nofollow" target="_blank">https://github.com/ConsenSys/Tokens</a></li><li id="b00e" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">ConsenSys:智能合同安全最佳实践。<a class="ae jg" href="https://github.com/ConsenSys/smart-contract-best-practices" rel="noopener ugc nofollow" target="_blank">https://github.com/ConsenSys/smart-contract-best-practices</a></li><li id="e1b7" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">迈克尔·伯格:以太坊合约的DSL。<a class="ae jg" href="https://www.michaelburge.us/2018/05/15/ethereum-chess-engine.html" rel="noopener ugc nofollow" target="_blank">https://www . michaelburge . us/2018/05/15/ether eum-chess-engine . html</a></li><li id="f261" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">C.艾尔·霍尔。计算机编程的公理基础。美国计算机学会通讯，26(1):53-56，1983年1月。</li><li id="069b" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">长度兰波特。证明多进程程序的正确性。IEEE软件工程汇刊 SE-3，2(1977年3月)，125–143页。</li><li id="24c8" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">G.内库拉。带证明的代码。在第24届ACM  <em class="kf">程序设计语言原理研讨会(POPL'97) </em>上。第106–119页，纽约，1997年1月。</li><li id="58e8" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">inria:Coq校对助手。<a class="ae jg" href="https://coq.inria.fr/" rel="noopener ugc nofollow" target="_blank">https://coq.inria.fr/</a></li><li id="b7f6" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">《程序分析的原理》。施普林格(2015年)</li><li id="02a8" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke md lv lw lx dt translated">北京大学自然科学学报:基于逻辑的形式验证方法:进展与应用<a class="ae jg" href="http://xbna.pku.edu.cn/html/2016-2-363.htm" rel="noopener ugc nofollow" target="_blank">http://xbna.pku.edu.cn/html/2016-2-363.htm</a></li></ul></div><div class="ab cl np nq hc nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hn ho hp hq hr"><p id="efab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://secbit.io" rel="noopener ugc nofollow" target="_blank"><strong class="jj hv"><em class="kf">sec bit</em></strong></a><em class="kf">由一群加密货币爱好者创立。我们正在研究智能合同安全、智能合同形式验证、加密协议、编译、合同分析、博弈论和加密经济学。</em></p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="nw nx l"/></div></figure></div></div>    
</body>
</html>