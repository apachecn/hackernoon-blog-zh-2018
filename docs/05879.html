<html>
<head>
<title>Web Activities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络活动</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/web-activities-a04e1bae54a6?source=collection_archive---------43-----------------------#2018-07-16">https://medium.com/hackernoon/web-activities-a04e1bae54a6?source=collection_archive---------43-----------------------#2018-07-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="3e11" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="4ece" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是一个有点返璞归真的话题。对于一个web页面来说，打开另一个页面(弹出窗口)执行一些操作并将其结果返回给调用者页面是一项常见的任务。这可能是同源或跨源弹出窗口。典型的用例包括位置选择器、联系人选择器、支付表单、社交登录/单点登录等等。</p><p id="4de5" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">Android SDK为此提供了一个简单而干净的API—<a class="ae ks" href="https://developer.android.com/training/basics/intents/result.html" rel="noopener ugc nofollow" target="_blank">startActivityForResult</a>。例如，参见<a class="ae ks" href="https://developers.google.com/places/android-api/placepicker" rel="noopener ugc nofollow" target="_blank">位置拾取器</a>。然而，Web没有这样清晰的API。早在IE时代，就有一个非标准的<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showModalDialog" rel="noopener ugc nofollow" target="_blank"> showModalDialog </a> API，它的设计和实现都很糟糕，并且已经在大多数浏览器中被弃用。因此，如果您今天试图在web上支持这样一个用例，您必须涵盖以下问题:</p><ol class=""><li id="f4c0" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">可以使用<code class="eh lc ld le lf b">window.open(url, target)</code> API打开一个弹出窗口。</li><li id="80c3" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">一旦弹出窗口被打开，你可以通过<code class="eh lc ld le lf b">window.opener</code>使用自定义窗口消息(<code class="eh lc ld le lf b">postMessage</code>)与它通信。弹出窗口必须正确打开，以确保<code class="eh lc ld le lf b">window.opener</code>可用(无<code class="eh lc ld le lf b">rel=noopener</code>)。</li><li id="3eed" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">你还必须通过<code class="eh lc ld le lf b">window.opener</code>来应对一系列可能的<a class="ae ks" href="https://gitlab.com/gitlab-org/gitlab-ce/issues/15331" rel="noopener ugc nofollow" target="_blank"> XSS攻击</a>。显然，您会信任您打开的页面本身，但是弹出网站也有可能受到威胁，这也将使调用者网站受到攻击。</li><li id="aa26" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">手机浏览器在后台卸载页面。因此，调用方页面可能会被卸载，无法从弹出窗口接收消息。</li><li id="8d2e" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">并非所有环境都支持多窗口和弹出窗口。例如，一些web视图或主屏幕Web应用程序，不是打开一个带有指定目标的弹出窗口，而是像<code class="eh lc ld le lf b">target=_top</code>一样重定向呼叫者页面。在这种情况下，<code class="eh lc ld le lf b">window.opener</code>将不可用，也没有办法向它发送消息。通常，这是通过使用重定向来解决的，同样，使用自定义协议通过重定向URL传递数据。</li><li id="088e" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">有些浏览器允许打开弹出窗口，但不支持<code class="eh lc ld le lf b">window.opener</code>。</li><li id="d22d" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">打开几个页面和几个弹出窗口，它会很快变得非常强大UX:哪个弹出窗口属于哪个页面？一个好的实现应该是给调用者页面加阴影，当被点击时，会试图将焦点带回弹出窗口。对于一些非常基本和期望的东西来说，这是一个很大的工作量。</li><li id="0ccd" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">如果用户关闭了调用者窗口会怎样？</li><li id="20f9" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">通过窗口消息传递的数据通过起点控制是安全的。重定向一点也不安全。显然，SSL覆盖了许多数据泄漏媒介，但最终，用户仍可能复制/粘贴URL并通过电子邮件发送。某些环境(如Web视图)也可以观察到重定向URL。</li><li id="8701" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">在重定向的情况下，也不可能返回到“以前”的历史状态。这排除了<code class="eh lc ld le lf b">history.state</code>和相关API的一些用途。</li></ol><p id="d049" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这些只是Web开发人员必须应对的一些重要问题。不同的浏览器会带来额外的问题。这是很难做到的，解决方案往往是脆弱的，最终的UX是穷人。</p><p id="9d1b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">当然，网络平台可以做得更好。</p><h1 id="f00e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">弹出窗口与iframes</h1><p id="cc47" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这篇文章中会提到很多弹出窗口，所以我想立刻回答这个问题:为什么不用iframes代替弹出窗口呢？有了iframe，父页面对弹出窗口的位置和大小有了更多的控制，iframe避免了上面描述的大多数问题——最明显的是没有重定向回退或卸载，这可能是最难解决的问题。事实上，iframes已经在web上的类似用例中使用了。弹出窗口的使用已经减少了很多:部分是因为上面列出的问题，部分是因为iframes提供了更好的UX和更简单的实现。</p><p id="23ea" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">然而，对于许多用例，尤其是安全敏感的用例(如SSO和支付)，iframes的使用受到限制，原因如下:</p><ol class=""><li id="3fd1" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">点击/输入-顶起。一种非常常见的攻击手段，攻击者试图将内容放在iframe的顶部，以误导用户激活敏感操作或在他们意想不到的地方输入敏感数据。例如，一个攻击者可以在iframe“购买”按钮上放置“立即免费获取”UI，这样用户就可以购买他们没有想到的东西。另一种攻击可以在iframe的信用卡输入上放置输入控件，从而窃取iframe的信用卡。</li><li id="4a1b" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">使用cookies和本地存储时的Iframe限制。弹出窗口作为顶层浏览上下文，获取未分区的cookies和存储。因此，社交登录表单不需要不断地再次提示用户输入密码。然而，在后ITP时代，Iframes在这个领域受到越来越多的限制。</li></ol><p id="d5d3" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">过去的一些提议考虑为iframes创建一个全屏模式的特殊子类，以提供防止点击/输入劫持的保证。然而，考虑到iframe cookie分区，这是不够的。最重要的是，保证iframe的不可点击jackable模式需要客户机和服务器的参与，这以<code class="eh lc ld le lf b">X-Frame-Options</code>和CSP的形式定义了限制。服务器堆栈需要客户端提供一些严格的保证来解除iframing限制——这将是一个主要的向后兼容性问题。</p><p id="d784" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">鉴于这些限制，我们将主要关注弹出窗口作为解决方案空间。</p><h1 id="e322" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">弹出窗口的其他替代方法</h1><p id="4cca" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Web平台可以继续使用<a class="ae ks" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>来支持需要弹出窗口的关键用例。正如使用<a class="ae ks" href="https://developers.google.com/web/fundamentals/payments/deep-dive-into-payment-request" rel="noopener ugc nofollow" target="_blank">支付请求UI </a>一样，网络平台可以为社交登录、日历共享等定义API。对于这样的用例来说，这将是一个很大的改进。</p><p id="1c52" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">然而，这种API的设计和实现需要时间。迁移需要聚合填充。最终Web平台无法支持所有这样的用例。因此，我欢迎新的Web APIs，但不管怎样，仍然非常需要“获得结果”弹出窗口的通用解决方案。</p><h1 id="15b1" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">Android活动API</h1><p id="935f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在我们开始研究处理“得到结果”弹出窗口的不同方法之前，让我们看看Android APIs是如何安排这些用例的。</p><p id="9636" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">Android提供了<a class="ae ks" href="https://developer.android.com/training/basics/intents/result.html" rel="noopener ugc nofollow" target="_blank">startActivityForResult</a>API。它由三部分组成:<code class="eh lc ld le lf b">startActivityForResult</code>、<code class="eh lc ld le lf b">onActivityResult</code>和<code class="eh lc ld le lf b">setResult</code>。例如，<a class="ae ks" href="https://developers.google.com/places/android-api/placepicker" rel="noopener ugc nofollow" target="_blank">位置选取器</a> API可以这样使用:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="81f5" class="lt is hu lf b fv lu lv l lw lx"><a class="ae ks" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>protected void onActivityResult(int requestCode, int resultCode,<br/>    Intent data) {<br/>  if (resultCode != RESULT_OK) {<br/>    return;<br/>  }<br/>  if (requestCode == PICK_PLACE_REQUEST) {<br/>    // Process result.<br/>  }<br/>}</span><span id="a86c" class="lt is hu lf b fv ly lv l lw lx">private void pickPlace() {<br/>  startActivityForResult(<br/>      new PlacePicker.IntentBuilder().build(this),<br/>      PICK_PLACE_REQUEST);<br/>}</span></pre><p id="1e6b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">位置选取器活动本身必须调用<code class="eh lc ld le lf b">setResult</code>方法:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="7b4f" class="lt is hu lf b fv lu lv l lw lx">private void clickHandler() {<br/>  Intent intent = new Intent();  <br/>  intent.putExtra("place", selectedPlaceData);  <br/>  setResult(RESULT_OK, intent);<br/>}</span></pre><p id="4a92" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这个API明确存在的事实是一个很好的迹象，表明Android认真对待这些用例。但是有一些重要的属性需要考虑:</p><ol class=""><li id="7084" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">API编纂了返回和接收活动结果的标准方法。不需要涉及一些定制的消息传递协议——如果我们只需要将一包数据从被调用的活动转发给调用者，那就太过分了。</li><li id="cd53" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">即使Android决定卸载调用者活动，这个API自然仍然可以工作。当调用方活动重新启动时，将调用<code class="eh lc ld le lf b">onActivityResult</code>处理程序。</li><li id="747b" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">打开的活动窗口的呈现与数据交换的机制是分开的。Android通常会全屏显示新的活动，完全掩盖了呼叫者。然而，它也可能部分地模糊了呼叫者，等等。</li></ol><h1 id="04b5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">网上支持活动</h1><p id="912e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Web平台可以考虑几种方法来使这种“得到一个结果”弹出窗口的编码变得更容易和不那么脆弱。这里有两个相互支持的主要方向:上下文弹出窗口和用于结果交换的API。</p><h2 id="fa4c" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">上下文弹出窗口(窗口弹出窗口)</h2><p id="de92" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是上下文弹出窗口的<code class="eh lc ld le lf b">window.open</code> API的专门版本(例如<code class="eh lc ld le lf b">window.openInContext</code>，或者可能使用新的<code class="eh lc ld le lf b">window.open</code>选项)——也就是说，弹出窗口的“画中画”模式。这种弹出窗口将在呼叫者页面的上下文中打开。构建这个API是为了避免引言部分列出的大多数缺陷。特别是，不需要重定向回退，调用者(上下文)页面永远不会被卸载。它仍然依赖自定义窗口消息将结果传递给调用者。</p><p id="64c8" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">为了说明这个选项，考虑Web上弹出窗口的当前状态。桌面和移动浏览器的UX总是很差:打开一个单独的标签或窗口。如果用户切换到另一个标签，很难找到弹出窗口。</p><p id="1ea2" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这方面的一个模型可以是<a class="ae ks" href="https://developers.google.com/web/fundamentals/payments/deep-dive-into-payment-request" rel="noopener ugc nofollow" target="_blank">支付请求UI </a>。在<a class="ae ks" href="https://developers.google.com/web/fundamentals/payments/deep-dive-into-payment-request" rel="noopener ugc nofollow" target="_blank">桌面</a>和<a class="ae ks" href="https://developers.google.com/web/updates/2016/07/payment-request" rel="noopener ugc nofollow" target="_blank">移动</a>上，该UX确保:</p><ol class=""><li id="1aee" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">很明显，支付UI显示在调用者页面的上下文中。</li><li id="af46" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">仍然有明确的起源归属。</li><li id="f94d" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">弹出窗口的内容不能被页面本身或另一个弹出窗口遮挡，它是模态的。因此有一个固有的点击/输入劫持保护。</li><li id="d686" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">在<a class="ae ks" href="https://developers.google.com/web/fundamentals/payments/deep-dive-into-payment-request" rel="noopener ugc nofollow" target="_blank">桌面</a>用户可以切换选项卡。弹出窗口将停留在选项卡中，当用户返回时，它还会在那里。用户不需要跟踪两个窗口。</li></ol><p id="a7af" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果弹出窗口可以作为顶级浏览上下文打开，但仍然在结构上和视觉上呈现在调用者页面的上下文中，那就太好了。</p><p id="09e1" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">一个重要的细微差别是:这样的弹出窗口不能打开嵌套的弹出窗口——没有好的方法使这成为一个好的UX。但这也会通过减缓标签的扩散给浏览器带来更好的性能参数。</p><p id="0f36" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">额外的大承诺:上下文弹出窗口可以完全消除重定向回退，这反过来也可以简化许多API。正如您将在本文的其他地方看到的，重定向回退(由于单窗口浏览器或页面卸载)是“获得结果”模式的主要复杂性。</p><p id="0f8b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">关于这个话题的最后一句话:网络浏览量。今天的网页浏览量占了移动流量的很大一部分(有人估计接近50%)，这使得这种模式变得非常复杂。默认情况下，Web视图是单窗口浏览器。支持多窗口模式是一项非常复杂的任务，需要权衡内存。理想情况下，上下文弹出窗口将在开箱即用的现代Web视图中实现。默认情况下不必启用它们，但是实现本身对于减少浏览器和Web视图之间的解决方案空间碎片非常重要。</p><h2 id="e677" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">用于结果交换的API</h2><p id="20b7" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当弹出窗口实际打开时，可以使用窗口消息返回结果。为此，调用者和弹出窗口必须同意一个定制的消息传递协议。对于像返回单个结果这样简单的事情来说，这有点矫枉过正，而且充满了安全隐患。但这很有效。</p><p id="2d02" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">然而，消息传递并不总是可用的。消息传递不可用的一些情况:</p><ol class=""><li id="4cdb" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">在重定向模式下，调用者的上下文被弹出式菜单代替。<code class="eh lc ld le lf b">window.opener</code>字段不可用，无法发送信息。请注意，重定向模式有时是UX的选择，但有时是环境所迫:单窗口浏览器、弹出窗口拦截器等。</li><li id="1c05" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">调用者窗口可以在移动设备上卸载，使得消息传递不可能。</li></ol><p id="8579" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在重定向模式中，将数据返回给调用者的唯一方式是将URL中的结果重定向回调用者，例如URL片段中的结果。当结果敏感时，必须对其进行加密，以避免不必要的泄露。正确支持重定向模式是一项艰巨的任务，任何解决方案都非常脆弱。</p><p id="5046" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这里要考虑两种方法:提供一种在重定向模式下返回数据的安全方法，或者采用一种支持弹出窗口和重定向的新API，类似于Android Activity API。</p><p id="de28" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">我们想把重点放在Web的Activity API上，但是首先，说几句重定向模式。</p><h2 id="8c94" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">在重定向模式下返回数据的附加API</h2><p id="0243" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们可以提供一个专门针对重定向模式的特殊API来安全可靠地返回数据。例如，我们可以扩展Web历史API。在重定向回调用者之前，弹出窗口会将数据推入历史堆栈:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="5d31" class="lt is hu lf b fv lu lv l lw lx">history.pushResult(resultData, "<a class="ae ks" href="https://caller.com" rel="noopener ugc nofollow" target="_blank">https://caller.com</a>");<br/>window.location.replace("<a class="ae ks" href="https://caller.com/continue" rel="noopener ugc nofollow" target="_blank">https://caller.com/continue</a>");</span></pre><p id="a1b7" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">调用者将能够在启动时从历史堆栈中读取数据:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="ff5b" class="lt is hu lf b fv lu lv l lw lx">var result = history.popResult("<a class="ae ks" href="https://popup.com" rel="noopener ugc nofollow" target="_blank">https://popup.com</a>");<br/>if (result) {<br/>  // Result is already available.<br/>  ...<br/>}</span></pre><p id="32f0" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">请注意，push和pop都被限制在调用者和弹出窗口的特定来源，以确保安全地交换数据。</p><h1 id="efd9" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">提议——用于Web的类似Android的活动API</h1><p id="8be8" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在Web上采用类似Android的Activities API是一个更激进的解决方案。但是它可以很自然地解决重定向和弹出模式。它也可以很好地发挥上下文弹出窗口的想法，以改善UX。</p><h2 id="fb13" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">应用程序接口</h2><p id="7212" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">遵循Android API，我们可以在Web上引入类似的API，包括:<code class="eh lc ld le lf b">window.openForResult()</code>、<code class="eh lc ld le lf b">window.onResult()</code>和<code class="eh lc ld le lf b">window.setResult()</code>。上面的位置选取器调用者在Web上看起来像这样:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="f95a" class="lt is hu lf b fv lu lv l lw lx">// Anticipate that the result might arrive at some point, even<br/>// if openForResult has not been called in the instance of this<br/>// page.<br/>window.onResult(<br/>    'pickPlace',<br/>    '<a class="ae ks" href="https://maps.google.com'" rel="noopener ugc nofollow" target="_blank">https://maps.google.com'</a>,<br/>    (response) =&gt; {<br/>      if (response.ok) {<br/>        // Process result.<br/>      }<br/>    });</span><span id="d2cb" class="lt is hu lf b fv ly lv l lw lx">// Call openForResult.<br/>button.onclick = () =&gt; {<br/>  window.openForResult(<br/>      'pickPlace',<br/>      '<a class="ae ks" href="https://maps.google.com/pickplace'" rel="noopener ugc nofollow" target="_blank">https://maps.google.com/pickplace'</a>,<br/>      target);<br/>};</span></pre><p id="dfeb" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">弹出页面将返回如下结果:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="b245" class="lt is hu lf b fv lu lv l lw lx">window.setResult(ok, payload);</span></pre><p id="952f" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">让我们更详细地看看这个API。</p><h2 id="155e" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">window.openForResult</h2><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="7075" class="lt is hu lf b fv lu lv l lw lx">window.openForResult(<br/>    requestId: string,<br/>    url: string,<br/>    target: string,<br/>    opt_options: string<br/>): void</span></pre><p id="a55c" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这种方法类似于<code class="eh lc ld le lf b">window.open</code>，但是也有一些关键的区别。这些论点是:</p><ul class=""><li id="2fc8" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km mm kz la lb dt translated"><code class="eh lc ld le lf b">requestId</code> —稍后将在<code class="eh lc ld le lf b">window.onResult</code>回调中可用的字符串ID。</li><li id="ec95" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><code class="eh lc ld le lf b">url</code> —弹出的网址。</li><li id="8067" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><code class="eh lc ld le lf b">target</code> —窗口目标:这使它成为弹出窗口或重定向窗口。</li><li id="928a" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><code class="eh lc ld le lf b">opt_options</code> —附加选项，类似于<code class="eh lc ld le lf b">window.open</code></li></ul><p id="7bd9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">与<code class="eh lc ld le lf b">window.open</code>不同，<code class="eh lc ld le lf b">window.openForResult</code> API中既不需要弹出窗口引用，也不需要<code class="eh lc ld le lf b">window.opener</code>。虽然这些仍然可以提供，删除它们将减少XSS漏洞的表面。</p><h2 id="f80a" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">windows . on结果</h2><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="ca59" class="lt is hu lf b fv lu lv l lw lx">window.onResult(<br/>    requestId: string,<br/>    resultOrigin: string,<br/>    callback: function(Response)<br/>): void</span></pre><p id="57d0" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">该方法用于注册requestId的回调，该回调将在<code class="eh lc ld le lf b">window.openForResult</code>中进一步指定。</p><p id="08fc" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">抛弃这种方法，简单地让<code class="eh lc ld le lf b">window.openForResult</code>回复一个承诺，这很有诱惑力。然而，由于重定向和页面卸载，这并不那么简单。如果调用者页面已经被重定向或卸载，结果将由浏览器保存在某个临时存储中(如历史堆栈),一旦使用<code class="eh lc ld le lf b">window.onResult</code>注册了回调，它将立即被调用并得到结果。此功能对于下面某一部分中的重定向聚合填充也很有用。另一方面，如果上下文弹出窗口成为现实，它可以帮助简化这个API。</p><p id="d103" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">另一个细微差别是，<code class="eh lc ld le lf b">resultOrigin</code>参数通常是不必要的，因为原点在<code class="eh lc ld le lf b">window.openForResult</code>调用中的<code class="eh lc ld le lf b">url</code>中是清楚的。然而，这是一个很好的额外保护，也将有助于多填充物。</p><h2 id="4fbf" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">window.setResult</h2><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="ac19" class="lt is hu lf b fv lu lv l lw lx">window.setResult(<br/>    ok: boolean,<br/>    payload: Object<br/>): void</span></pre><p id="e04e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">一旦结果可用，弹出窗口将调用此方法，并关闭弹出窗口返回给调用者。</p><p id="b48c" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这些论点是:</p><ul class=""><li id="717e" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km mm kz la lb dt translated"><code class="eh lc ld le lf b">ok</code> —完成信号:<code class="eh lc ld le lf b">true</code>表示成功，<code class="eh lc ld le lf b">false</code>表示取消或失败。</li><li id="b7db" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><code class="eh lc ld le lf b">payload</code> —在弹出窗口中采取的操作的数据有效负载。出错时—失败的原因。</li></ul><h1 id="60e2" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">聚合填料</h1><p id="75f1" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">聚合填充这个API是有挑战性的，但也是可能的。</p><h2 id="a600" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">window.openForResult聚合填充</h2><p id="de90" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">API调用是:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="a5c1" class="lt is hu lf b fv lu lv l lw lx">window.openForResult(requestId, url, target, opt_options)</span></pre><p id="5e23" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">聚合填充将执行以下步骤:</p><ol class=""><li id="50d2" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">设置窗口消息监听器。</li><li id="2b14" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">叫<code class="eh lc ld le lf b">popup = window.open(url, target, opt_options)</code>。主动将<code class="eh lc ld le lf b">#ACTIVITY={requestId, returnUrl}</code>片段添加到<code class="eh lc ld le lf b">url</code>中，以防浏览器环境会像<code class="eh lc ld le lf b">_top</code>一样静默打开窗口(见步骤7)。</li><li id="cad3" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">如果<code class="eh lc ld le lf b">window.open</code>失败或返回无效的弹出对象，转到步骤7。</li><li id="7846" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">开始保活轮询以检查<code class="eh lc ld le lf b">popup.closed</code>。我们需要它，以防弹出窗口被用户关闭，产生“取消”信号。</li><li id="a681" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">当“结果”消息到达时，将<code class="eh lc ld le lf b">requestId</code>和<code class="eh lc ld le lf b">response{ok, payload}</code>传递给结果处理代码。</li><li id="df94" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">将“结果-确认”消息发送回弹出窗口。结束了。</li><li id="867c" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">如果<code class="eh lc ld le lf b">window.open</code>调用失败，使用添加的片段<code class="eh lc ld le lf b">#ACTIVITY={requestId, returnUrl}</code>将当前页面重定向到<code class="eh lc ld le lf b">url</code>。调用方页面的执行被中止，但是我们希望在弹出页面通过重定向完成后返回。结束了。</li></ol><p id="0875" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果<code class="eh lc ld le lf b">window.open</code>polyfill返回重定向失败(步骤7)，弹出页面重定向回调用者时:</p><ol class=""><li id="36af" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">解码将包含结构<code class="eh lc ld le lf b">{requestId, ok, payload}</code>的<code class="eh lc ld le lf b">#ACTIVITY={…}</code>片段参数。</li><li id="e2e3" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">检查<code class="eh lc ld le lf b">document.referer</code>和<code class="eh lc ld le lf b">url</code>是否来自同一原点。如果不是同一原点，则失败。</li><li id="1866" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">将<code class="eh lc ld le lf b">requestId</code>和<code class="eh lc ld le lf b">response{resultOrigin, ok, payload}</code>传给结果处理代码。结束了。</li></ol><p id="f342" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在所有这些操作之后，<code class="eh lc ld le lf b">#ACTIVITY</code>被从片段中删除。</p><h2 id="8c47" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">window . on结果聚合填充</h2><p id="f4db" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">API调用是:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="847a" class="lt is hu lf b fv lu lv l lw lx">window.onResult(requestId, resultOrigin, function(response) {})</span></pre><p id="f866" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">多填充的执行取决于响应是在调用<code class="eh lc ld le lf b">window.onResult()</code>之前还是之后到达。</p><p id="9234" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果响应在调用<code class="eh lc ld le lf b">window.onResult</code>之前到达，polyfill会简单地将响应存储在<code class="eh lc ld le lf b">requestId</code>的内存或历史堆栈中。一旦<code class="eh lc ld le lf b">window.onResult</code>被调用并且相应的响应可用，执行以下步骤:</p><ol class=""><li id="b015" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">检查<code class="eh lc ld le lf b">resultOrigin</code>参数是否与<code class="eh lc ld le lf b">response.resultOrigin</code>相同。</li><li id="01b9" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">调用<code class="eh lc ld le lf b">callback(response{ok, payload})</code>。</li><li id="e361" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">从内存中删除响应。</li></ol><h2 id="d400" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">window.setResult多填充</h2><p id="2cf0" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">API调用是:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="a70e" class="lt is hu lf b fv lu lv l lw lx">window.setResult(ok, payload);</span></pre><p id="4d27" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">弹出页面中的聚合填充考虑了两种模式:弹出或重定向。如果<code class="eh lc ld le lf b">window.opener</code>可用，采取弹出模式并执行以下步骤:</p><ol class=""><li id="b8a7" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">设置消息监听器并等待“结果确认”消息。</li><li id="4c0f" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">通过<code class="eh lc ld le lf b">window.opener.postMessage</code>发送带有<code class="eh lc ld le lf b">{ok, payload}</code>的“结果”消息。</li><li id="b200" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">一旦“结果-确认”信息到达，关闭自己。结束了。</li><li id="dd1e" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">如果“result-acknowledge”未在超时内到达，则假定呼叫者寻呼机已卸载，并尝试使用重定向模式进行恢复。继续重定向步骤。</li></ol><p id="4878" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果<code class="eh lc ld le lf b">window.opener</code>不可用或消息传递失败，则采用重定向模式并执行以下步骤:</p><ol class=""><li id="4c8e" class="kt ku hu jr b js kn jw ko ka kv ke kw ki kx km ky kz la lb dt translated">解析<code class="eh lc ld le lf b">#ACTIVITY={requestId, returnUrl}</code>。</li><li id="b0c3" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">检查<code class="eh lc ld le lf b">returnUrl</code>和<code class="eh lc ld le lf b">document.referrer</code>是否具有相同的原点。如果没有，就失败。</li><li id="7e73" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">如果<code class="eh lc ld le lf b">window.opener</code>不可用，重定向到添加了片段<code class="eh lc ld le lf b">#ACTIVITY={requestId, ok, payload}</code>的<code class="eh lc ld le lf b">returnUrl</code>。结束了。</li><li id="e595" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km ky kz la lb dt translated">如果<code class="eh lc ld le lf b">window.opener</code>可用(即消息传递失败)，打开与目标<code class="eh lc ld le lf b">_blank</code>相同的URL，即<code class="eh lc ld le lf b">window.open(‘returnUrl#ACTIVITY={…}’, ‘_blank’)</code>。结束了。</li></ol><h2 id="f00f" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">聚合填充、重定向和数据敏感性</h2><p id="23d0" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">重定向确实使数据交换机制变得复杂了。在某些用例中，将敏感数据作为重定向URL中的<code class="eh lc ld le lf b">payload</code>传递可能会有问题。如果这被认为是一个问题，弹出窗口和调用者页面必须同意不以纯文本形式发送数据，而是使用某种形式的加密。例如:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="3494" class="lt is hu lf b fv lu lv l lw lx">window.onResult(<br/>    'sensitive-request',<br/>    '<a class="ae ks" href="https://popup-domain'" rel="noopener ugc nofollow" target="_blank">https://popup-domain'</a>,<br/>    (response) =&gt; {<br/>      if (response.ok) {<br/>        fetch('<a class="ae ks" href="https://popup-domain/get-payload.json?nonce=${response.payload.nonce}'" rel="noopener ugc nofollow" target="_blank">https://popup.com/decrypt</a>', {<br/>          method: 'POST',<br/>          body: response.payload.encrypted,<br/>        })<br/>        .then(response =&gt; {<br/>           // Process the payload as the actual popup response.<br/>        });<br/>     }<br/>   });</span></pre><p id="cce9" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这样，敏感数据永远不会在重定向URL中传递，服务获取可以控制CORS源。<code class="eh lc ld le lf b">https://popup.com/decrypt.json</code>将解密并返回有效载荷，并依靠CORS <code class="eh lc ld le lf b">Origin</code>报头来确保端到端的安全性。关键的是，该请求还必须依赖一些内部会话标识符来防止会话固定攻击(SFA):</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="39b6" class="lt is hu lf b fv lu lv l lw lx">app.post('/decrypt.json', (req, res) =&gt; {<br/>  // "decrypted" is a structure:<br/>  // {forOrigin: string, sessionId: string, data: Object}<br/>  var decrypted = decrypt(req.body['encryped']);</span><span id="91fe" class="lt is hu lf b fv ly lv l lw lx">  // The CORS origin must match the indented origin:<br/>  if (decrypted.forOrigin != req.headers.origin) {<br/>    res.sendError(403);<br/>    return;<br/>  }</span><span id="72c7" class="lt is hu lf b fv ly lv l lw lx">  // The CORS cookie should correspond to the intended sessionId:<br/>  if (decrypted.sessionId != getSessionId(req.cookies)) {<br/>    res.sendError(403);<br/>    return;<br/>  }</span><span id="edf2" class="lt is hu lf b fv ly lv l lw lx">  // All good: send back the data.<br/>  res.send(decrypted.data);<br/>});</span></pre><h1 id="baa0" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">网络活动实施</h1><p id="54f1" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">虽然不是完全相同的API，但GitHub中的<a class="ae ks" href="https://github.com/google/web-activities" rel="noopener ugc nofollow" target="_blank"> web-activities </a>项目实现了一个形状非常相似的API。</p><h1 id="96fe" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">其他考虑</h1><h2 id="dc6d" class="lt is hu bd it lz ma mb ix mc md me jb ka mf mg jf ke mh mi jj ki mj mk jn ml dt translated">本地集成和定制协议</h2><p id="ff8c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">目前，<code class="eh lc ld le lf b">window.open</code>在理论上可以被转发给Android上的一个匹配的本地活动。但是，没有办法将结果返回给调用者页面。让我们想象一下这是如何成为可能的。</p><p id="ce8e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果浏览器实现了提议的API，那么使用相同的API将它扩展到本地活动将会很简单。然而，<code class="eh lc ld le lf b">openForResult</code> API如何允许本地调用呢？Android已经允许意图过滤器拦截URL，但是另外，我们可以扩展<code class="eh lc ld le lf b">openForResult</code>来支持<a class="ae ks" href="https://developer.chrome.com/multidevice/android/intents" rel="noopener ugc nofollow" target="_blank">意图URL</a>和<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/registerProtocolHandler" rel="noopener ugc nofollow" target="_blank">自定义协议</a>的替代URL。例如:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="a075" class="lt is hu lf b fv lu lv l lw lx">window.openForResult(<br/>    requestId,<br/>    [<br/>      // First try an intent URL.<br/>      'intent://get-place/#Intent;scheme=a;package=com.a;end',<br/>      // Then, try a custom protocol.<br/>      'web+location://get-place',<br/>      // Finally, fallback to web URL.<br/>      '<a class="ae ks" href="https://maps.google.com/placepicker'" rel="noopener ugc nofollow" target="_blank">https://maps.google.com/placepicker'</a><br/>    ]);</span></pre><p id="c900" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">请注意，在这种情况下,<code class="eh lc ld le lf b">window.onResult</code>也将接受一个用于<code class="eh lc ld le lf b">resultOrigin</code>参数的原点数组。</p><p id="4503" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果来源对于敏感通信很重要，呼叫者页面可能需要“严格来源模式”，在这种情况下，浏览器/Android平台可能需要类似于Android的<a class="ae ks" href="https://developers.google.com/digital-asset-links/v1/getting-started" rel="noopener ugc nofollow" target="_blank">数字资产链接</a>协议的来源验证。例如:</p><pre class="ll lm ln lo fq lp lf lq lr aw ls dt"><span id="7284" class="lt is hu lf b fv lu lv l lw lx">window.openForResult(requestId, url, {origin: 'strict'});</span></pre><p id="f781" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">本机支持目前不可聚合填充。如果指定了多个URL，polyfill将只使用数组中的最后一个(后备)URL。</p><h1 id="7e54" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">摘要</h1><p id="8a4f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">今天在Web上实现高质量的弹出结果模式太复杂了。此外，许多此类案例都有重要的安全和隐私需求，这一事实更是雪上加霜。Web平台可以以上下文弹出窗口的形式，和/或通过遵循Android SDK现有的<code class="eh lc ld le lf b">startActivityForResult</code>协议来实现对这种模式的改进。其中任何一个或两个都可以显著改善开发体验、稳定性、安全性、跨浏览器支持和UX。</p><h1 id="7903" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">参考</h1><ul class=""><li id="848b" class="kt ku hu jr b js jt jw jx ka mn ke mo ki mp km mm kz la lb dt translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/open" rel="noopener ugc nofollow" target="_blank"> Window.open API </a></li><li id="e12a" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showModalDialog" rel="noopener ugc nofollow" target="_blank">window . showmodaldialog API</a></li><li id="f62d" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><a class="ae ks" href="https://developer.android.com/training/basics/intents/result.html" rel="noopener ugc nofollow" target="_blank">安卓的startActivityForResult API </a></li><li id="f6ab" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><a class="ae ks" href="https://developers.google.com/web/fundamentals/payments/deep-dive-into-payment-request" rel="noopener ugc nofollow" target="_blank">付款申请界面</a></li><li id="8407" class="kt ku hu jr b js lg jw lh ka li ke lj ki lk km mm kz la lb dt translated"><a class="ae ks" href="https://github.com/google/web-activities" rel="noopener ugc nofollow" target="_blank">GitHub中的网络活动项目</a></li></ul><figure class="ll lm ln lo fq mq"><div class="bz el l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>