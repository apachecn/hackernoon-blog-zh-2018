<html>
<head>
<title>Reacting to React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Reacting to React.js</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reacting-to-react-js-10ff1d50a36c?source=collection_archive---------3-----------------------#2018-07-17">https://medium.com/hackernoon/reacting-to-react-js-10ff1d50a36c?source=collection_archive---------3-----------------------#2018-07-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6e5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">差不多一个月前，Vue.js社区还很兴奋，Vue.js获得的明星比T2还多。github上的js。好莱坞明星那样的明星？真的，没有lol，但可能是比喻…或哲学？</p><p id="a7a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Github stars是开发人员有效地将该页面加入书签的一种方式，以便他们可以在以后引用它。这是什么意思？Vue的受欢迎程度已经超过了React，这是一种象征性的前端接力棒移交，如果你愿意的话。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/39737f3484500cddf5185e9c785f0bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*dpMrT3c6kmFmaov9hS8E-g.png"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">As of 16th July!</figcaption></figure><p id="73a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以大家都在用Vue.js，它比React更受欢迎？嗯，不，星级并不意味着使用，但我们可以看看npm下载，这是用来安装这些，并看到Vue仍然远远落后；</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff kc"><img src="../Images/ae5c0c033b582f79b4a61ae8b4876a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfLsGC7YjYe4ZJMmJjoapg.png"/></div></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">stats via <a class="ae jp" href="http://www.npmtrends.com/react-vs-vue" rel="noopener ugc nofollow" target="_blank">http://www.npmtrends.com/react-vs-vue</a></figcaption></figure><p id="b40b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着技术不断被使用，企业必须决定是否值得花费时间和金钱来升级到更新的技术。趋势可能是所有的炒作，但需要有一个相当大的理由需要切换到一个更好的<a class="ae jp" href="https://hackernoon.com/tagged/technology" rel="noopener ugc nofollow" target="_blank">技术</a>，而不是继续使用他们目前的技术。</p><p id="3189" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着所有使用React的企业可能会看到使用Vue的优势，但它不值得改变，继续使用他们已经拥有的就足够了。</p><p id="54e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为通过更详细地检查React来扩展我的技能集是个好主意，看看它有什么不同。这是我发现的…用非常简单的术语解释。</p><h1 id="d768" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">设置-创建React应用程序</h1><p id="ae23" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">刚开始学习React时，最令人沮丧的事情之一是使用过时的教程。开发人员最大的技能之一是能够通过在线寻找解决方案来解决问题。但是了解这些解决方案的年龄也很重要。有相当多的教程，但是它们已经过时了，会让你在意识到之前掉进兔子洞。</p><p id="41de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">脸书的回购是最好的开始方式。它的最小配置、完全模板化的入门套件可让您立即上手。我完全赞成简单和省事，所以这很棒。</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="8712" class="ls ki hu ln b fv lt lu l lv lw">npx create-react-app [project name]<br/>cd [project name]<br/>npm install<br/>npm start</span></pre><p id="82d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">四个简单的终端命令让你开始！</p><p id="97ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦npm启动，本地主机服务器就会启动，您会在浏览器上看到React的示例页面…</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff lx"><img src="../Images/848ce5a04f497c6eb3689237d4bfceba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsVq9B9raq--VyCKI0iPvA.png"/></div></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">You’ll see a spinning radioactive React logo in your localhost browser…</figcaption></figure><h1 id="e8fb" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">经典结构</h1><p id="9c68" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">说双关语。ES6在React中很普遍，所以在开始之前请确保您已经记下了这些内容，否则会非常混乱！</p><p id="91e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像Vue一样，我们使用组件。组件是我们热爱React和Vue的全部原因。我们正在把我们的网站分成可重复使用的组件。我们正在重构我们的<a class="ae jp" href="https://hackernoon.com/front-end-refactored-components-with-vue-907a08a3630?source=user_profile---------2-------------------&amp;gi=7b7459545941" rel="noopener ugc nofollow" target="_blank">前端</a>(不要脸的塞到我的另一篇帖子)！</p><p id="c46e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我决定做一个简单的书签管理器，用户可以将这些链接保存到页面上。还记得我们不得不那样做的那些日子吗？没有吗？糟糕，我觉得自己老了… O_o ' '</p><p id="298c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，让我们制定一个计划。就像纸和笔…你也记得那些东西吗？</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/65385574857caa95f1ed9858e925871b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*U_jaMDjWId_BmYkrMbWg9w.jpeg"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Don’t ask me why I write in ALL CAPS</figcaption></figure><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="fc82" class="ls ki hu ln b fv lt lu l lv lw">import React, { Component } from 'react';<br/>import './App.css';<br/>import BookmarkForm from './components/BookmarkForm';</span><span id="ec67" class="ls ki hu ln b fv lz lu l lv lw">class App extends Component {<br/>    render() {<br/>        return (<br/>            &lt;div className="App"&gt;<br/>                &lt;h1&gt;Bookmarks&lt;/h1&gt;<br/>                &lt;BookmarkForm /&gt;<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}</span><span id="19c9" class="ls ki hu ln b fv lz lu l lv lw">export default App;</span></pre><p id="4528" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有组件大致遵循这种结构。顶部是导入，一个包含所有内容的组件类，然后是导出。</p><p id="e06f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在组件类中，你几乎总是会有一个渲染函数，它是被解析到页面的东西。渲染函数总是返回JSX代码，其中将包含你想渲染的一切。</p><p id="46c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个渲染函数中，我们有divs，一个h1标签，和另一个组件'<BookmarkForm/>'。</p><p id="8fae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以使用其他内置函数，它们与render函数处于同一级别，但仍在component类中。您也可以拥有自己想要使用的自定义函数。</p><p id="c10a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最棒的是，这些函数被限制在这个类组件的范围内，这意味着它们只能在这个组件内被访问，除非你不希望它这样做。</p><p id="4162" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">学习React最常见的问题可能是……JSX到底是什么？？</p><h1 id="1a51" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">JSX——一切都是Javascript</h1><p id="8dca" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">由于需求，ES6有争议地将类引入了Javascript。但实际上，它只不过是语法上的糖。这意味着它看起来和行为就像其他语言中的类，但它实际上并没有做任何不同。</p><p id="40f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSX也是如此。它的行为和外观都像HTML，但实际上是Javascript被翻译成HTML的样子。</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="e98c" class="ls ki hu ln b fv lt lu l lv lw">let newDiv = document.createElement('div');</span><span id="486d" class="ls ki hu ln b fv lz lu l lv lw">newDiv.className = "hello";</span></pre><p id="0a9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与相同</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="45b2" class="ls ki hu ln b fv lt lu l lv lw">&lt;div class="hello"&gt;&lt;/div&gt;</span></pre><p id="b6b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用最简单的术语来说，JSX将应用Javascript，但看起来仍然像HTML。</p><p id="c58f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在JSX，class是一个保留的关键字，所以我们在React中使用' className ',以免与实际的HTML混淆，所以对于JSX，我们应该这样写；</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="2031" class="ls ki hu ln b fv lt lu l lv lw">&lt;div className="hello"&gt;&lt;/div&gt;</span></pre><p id="e3b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于JSX是Javascript，我们希望它有时使用Javascript，所以我们需要一些语法来帮助它识别我们想要这样做。</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="ef83" class="ls ki hu ln b fv lt lu l lv lw">&lt;div className="hello" onClick={this.clicked}&gt;&lt;/div&gt;</span></pre><p id="9ce1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，onClick属性运行单击div时在该组件中创建的函数clicked。正如你所看到的，Javascript对此是显而易见的。</p><h1 id="5610" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">传递信息</h1><p id="7b9e" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">在这个令人敬畏的组件世界中，我们想要做的事情之一是能够传递信息，以便我们的组件可以灵活。</p><p id="ff3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以让我们创建一些状态(数据)来保存我们的网站列表。在类中，我们添加构造函数来初始化我们的状态。超级()我稍后会解释…</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="dcad" class="ls ki hu ln b fv lt lu l lv lw">class App extends Component { <br/>    constructor(props) {  <br/>        super(props);  <br/>            this.state = {   websites: []  }; <br/>    } <br/>    render() {</span><span id="fd5a" class="ls ki hu ln b fv lz lu l lv lw"><em class="ma">    //JSX rendering stuff...</em></span></pre><p id="9e53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将状态存储在一个散列中。现在调用this.state.websites将输出空数组。Props允许在传递给其他组件时访问这些信息。</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="5942" class="ls ki hu ln b fv lt lu l lv lw">render() {<br/>    let websites = this.state.websites;<br/>    websites = websites.map((website) =&gt; {<br/>        return (<br/>            &lt;WebsiteChoice<br/>                website={website}<br/>            &gt;<br/>                {website}<br/>            &lt;/WebsiteChoice&gt;<br/>        );<br/>    });</span><span id="c31d" class="ls ki hu ln b fv lz lu l lv lw"><em class="ma">//... more JSX stuff</em></span></pre><p id="5d3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在render函数中，我们将变量“websites”分配给状态中的数组。然后我们用map遍历数组，对于数组中的每个元素(一个网站),我们返回组件WebsiteChoice，并将网站的名称作为属性传入，作为WebsiteChoice接收的自定义属性。</p><p id="8d6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这听起来有点疯狂！简单地说，这意味着我们将网站的名称传递给WebsiteChoice组件，以便我们可以对它做一些事情，并让WebsiteChoice组件而不是父组件来处理它。</p><p id="8b64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以在WebsiteChoice组件中；</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="ec91" class="ls ki hu ln b fv lt lu l lv lw">class WebsiteChoice extends React.Component {<br/>    render() {<br/>        return (<br/>            &lt;li&gt;<br/>                &lt;div className="website-choice-container"&gt;<br/>                    &lt;span className="website-choice"&gt;<br/>                        &lt;a href={`<a class="ae jp" href="http://${this.props.website}`" rel="noopener ugc nofollow" target="_blank">http://${this.props.website}`</a>}&gt;<br/>                            {this.props.website}<br/>                        &lt;/a&gt;<br/>                    &lt;/span&gt;<br/>                &lt;/div&gt;<br/>            &lt;/li&gt;<br/>        );<br/>    }<br/>}</span></pre><p id="2456" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们通过调用“this.props.website”来传递网站的名称，并将其设置为href，然后将其呈现到页面，从而允许该组件负责与每个单独的网站相关的任何事情。</p><h1 id="f804" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">省去你这点头痛</h1><p id="5b15" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">Javascript有趣的部分之一是使用关键字<code class="eh lk ll lm ln b">this</code>。这是指某个物体内部的事物。这个<a class="ae jp" href="http://davidshariff.com/blog/javascript-this-keyword/" rel="noopener ugc nofollow" target="_blank">博客</a>解释的超级好。</p><p id="d729" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，当我们通过props传递这些信息时，我们也可以传递函数，这些函数可以位于父组件中，但在子组件中被调用。</p><p id="423b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，由于我们正在传递对象，关键字this可能指向错误的对象。所以知道这里的ES6箭头函数非常有用，因为它们允许this关键字不引用所创建的函数对象。</p><p id="4943" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以不要</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="3a62" class="ls ki hu ln b fv lt lu l lv lw">function doSomething() {<br/>    // some code<br/>}</span></pre><p id="f0c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="cb13" class="ls ki hu ln b fv lt lu l lv lw">doSomething = () =&gt; {<br/>    // some code<br/>}</span></pre><p id="6b49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以避免范围问题。这允许子组件能够从它自己的组件中调用传递下来的<code class="eh lk ll lm ln b">this.props.doSomething</code>。</p><p id="252e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你记得上面我们有那个奇怪的“超级”关键字，里面有道具。</p><pre class="jr js jt ju fq lo ln lp lq aw lr dt"><span id="9600" class="ls ki hu ln b fv lt lu l lv lw">class App extends Component { <br/>    constructor(props) {  <br/>        super(props);  <br/>            this.state = {   websites: []  }; <br/>    } <br/>    render() {</span><span id="ca25" class="ls ki hu ln b fv lz lu l lv lw"><em class="ma">//JSX rendering stuff...</em></span></pre><p id="4cb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在反应过来，用道具召唤<code class="eh lk ll lm ln b">super</code>的时候。React将通过<code class="eh lk ll lm ln b">this.props</code>使<code class="eh lk ll lm ln b">props</code>跨组件可用。这允许我们在数据在父组件上时调用<code class="eh lk ll lm ln b">this.props.websites</code>。</p><h1 id="3aae" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">部署到Heroku</h1><p id="647d" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">代码还有很多，但是这篇文章开始有点太长了。当我高兴的时候，我想看看把我的代码上传到Heroku并让它工作是多么容易。我很想知道需要多少配置，尤其是在使用<code class="eh lk ll lm ln b">create-react-app</code>设置我的模板之后。</p><p id="d6f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我上传到Heroku，就像我建立一个新的github库一样，并遵循他们的<a class="ae jp" href="https://devcenter.heroku.com/articles/git" rel="noopener ugc nofollow" target="_blank">指令</a>。</p><p id="66f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上传后，我很快意识到您需要添加一个节点构建包，它可以有效地进行在线npm安装来安装所有的依赖项。这是在heroku网站上你的应用程序/设置下。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mb"><img src="../Images/f2c86c02b7615d88234ed5707fa07fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkgq8f5gEcPCKaESd5cGwg.png"/></div></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">npm install on Heroku!</figcaption></figure><p id="ce04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦完成，瞧！它起来了！超级简单，我真的认为<code class="eh lk ll lm ln b">create-react-app</code>是一个很棒的模板，可以帮助开发者开箱即用。请随意查看<a class="ae jp" href="https://react-bookmark-manager.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">这里</a>和github回购是<a class="ae jp" href="https://github.com/puyanwei/React-Bookmark-Manager" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/f5fa5a8be94b3c830e7e3bce3e065a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*pYymfiptGcNpSvEeoburzg.png"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Ugly, but functional working prototype!</figcaption></figure><h1 id="c911" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">最后的想法</h1><p id="12af" class="pw-post-body-paragraph ir is hu it b iu lf iw ix iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo hn dt translated">我认为React.js是一个很好的框架，一旦你了解了JSX语法，它的潜力是巨大的。</p><p id="fca5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，我确实认为乍一看很难进入，它的可读性比不上Vue.js，而且它也有一些例外情况规则，你基本上只需要记住，比如使用<code class="eh lk ll lm ln b">className</code>而不是<code class="eh lk ll lm ln b">class</code>，这似乎是他们刚刚保留的设计中的远见。</p><p id="822d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">文档是可以的，但是有很多旧的答案，并且总是实现旧的做事方式是有危险的。也就是说，这个社区非常庞大，而且有脸书的“支持”，在可预见的未来，它肯定会继续存在。</p><p id="5d10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为能够使用ES6对于react来说几乎是必须的，考虑到使用传统的非箭头函数会带来的作用域问题，处理到处放置绑定来控制你的this！</p><p id="add7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对我来说，如果Vue不存在，我可能会是一个满意的React开发人员，但对我来说，很难用一种更简单的方式来编写代码…</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="md me l"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">From the youtube channel DevTips!</figcaption></figure><p id="1ba1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想以一个非常酷的系列视频来结束我的演讲，它讲述了从开始到结束，从概念到工作原型，开发一个项目的过程。我真的很喜欢他们计划的方式，包括他们在整个过程中遇到的所有障碍。这可以很好地洞察开发人员在创建产品时经历了什么。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mf me l"/></div></figure></div></div>    
</body>
</html>