<html>
<head>
<title>How to Stop Using Callbacks and Start Living</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何停止使用回调，开始生活</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-stop-using-callbacks-and-start-living-1e5ed92e68e8?source=collection_archive---------8-----------------------#2018-07-18">https://medium.com/hackernoon/how-to-stop-using-callbacks-and-start-living-1e5ed92e68e8?source=collection_archive---------8-----------------------#2018-07-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/53aa916c1ec10e53d703403f5bf88314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdZ4EZ91EoEnDyn_yUKStw.png"/></div></div></figure><p id="e9b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Javascript有两种处理异步任务的主要方式——回调和承诺。一般来说，承诺被认为比回电更容易使用和维护。但事实上，仅仅是承诺并不能让你快乐。异步代码可能仍然很难阅读和理解。因此，第三方库<a class="ae ka" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank">，例如co </a>，提供了编写类似同步的异步代码的方法。</p><p id="6699" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我个人更喜欢世界上的一切都像<a class="ae ka" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> redux-saga </strong> </a>一样清晰美好。但是并不是每个人都能幸运地使用React和Redux来使用传奇。在本文中，我将展示在现代Javascript中，不使用任何第三方库来编写结构良好且易于理解的异步代码并不困难。</p><h1 id="815a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">回调地狱</h1><p id="955c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">先说个例子。比方说，我们有一个可以从流中读取一些数据的对象，这个对象使用一个事件发射器来通知每个对事件感兴趣的人。这些事件是“开始”、“数据”、“停止”，更复杂的是，“暂停”。</p><p id="6d9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们希望捕获“开始”事件，我们希望在这个事件上开始获取和存储数据，同时侦听“数据”事件。对于“停止”事件，我们需要执行一些数据处理。在“暂停”事件时，我们停止等待下一个“数据”事件，而是等待“开始”来继续获取和存储数据。</p><p id="83c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代码如下:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d63a" class="ln kc hu lj b fv lo lp l lq lr">let data = '';<br/> <br/>const handleStart = () =&gt; {<br/>   streamReader.removeAllListeners('pause', handlePause);<br/> <br/>   streamReader.on('data', (chunk, err) =&gt; {<br/>       if (err) {<br/>           console.error(err);<br/>           streamReader.removeAllListeners('data');<br/>           streamReader.removeAllListeners('pause');<br/>           return;<br/>       }<br/> <br/>       data += chunk;<br/>   })<br/>}<br/> <br/>const handleStop = () =&gt; {<br/>   streamReader.removeAllListeners('data');<br/>   streamReader.removeAllListeners('pause');<br/>   streamReader.removeAllListeners('stop');<br/> <br/>   processData(data, (err, result) =&gt; {<br/>       if (err) {<br/>           console.error(err);<br/>           return;<br/>       }<br/> <br/>       storeResult(result, () =&gt; {<br/>           console.log('Stored')<br/>       })<br/>   });<br/>}<br/> <br/>const handlePause = () =&gt; {<br/>   streamReader.removeAllListeners('data');<br/>   streamReader.on('start', handleStart);<br/>}<br/> <br/>streamReader.once('start', handleStart);<br/>streamReader.on('stop', handleStop)<br/>streamReader.on('pause', handlePause);</span></pre><p id="afbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们有一堆事件监听器和事件处理器来实现上面描述的流程。还有一些名为<strong class="je hv"> processData </strong>和<strong class="je hv"> storeData </strong>的函数，它们执行一些异步操作，并在完成时调用一个回调函数。</p><p id="4071" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码有什么问题？嗯…我想，这完全是一场噩梦。首先，有一个全局变量<strong class="je hv">数据</strong>不可能去掉。我上面也提到了一个流程，但是代码中没有流程。很难理解动作的顺序，因此很难调试。人们不会无缘无故地称之为‘回调地狱’。</p><h1 id="577a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">出口</h1><p id="7e9c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Javascript中异步回调的好处是，如果您不想使用它们，就不必使用它们。任何回调都可能变成承诺。最简单的例子是这样的:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="934e" class="ln kc hu lj b fv lo lp l lq lr">const processDataPromise = new Promise((resolve, reject) =&gt; {<br/>   processData(data, (err, result) =&gt; {<br/>       if (err) reject(err);<br/>       resolve(result);<br/>   });<br/>})</span></pre><p id="c146" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者更一般的解决方案:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ce7e" class="ln kc hu lj b fv lo lp l lq lr">function promisify(f, context, isEvent) {<br/>   const ctx = context || this;<br/>   return function () {<br/>       return new Promise((resolve, reject) =&gt; {<br/>           f.call(ctx, ...arguments, (...args) =&gt; {<br/>               const err = arguments ? args.find((a) =&gt; a instanceof Error) : null;<br/>               if (err) {<br/>                   reject(err);<br/>               } else {<br/>                   if (isEvent) {<br/>                       resolve({<br/>                           type: arguments[0],<br/>                           cbArgs: [...args],<br/>                       });<br/>                   } else {<br/>                       resolve([...args]);<br/>                   }<br/>               }<br/>           })<br/>       });<br/>   }<br/>}</span></pre><p id="ce1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一般的解决方案并不能立即明确，所以让我来解释一下。</p><p id="c665" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">函数<strong class="je hv"> promisify </strong>将一个异步函数作为第一个参数，并返回一个函数，该函数除了回调之外，采用与原始函数相同的所有参数。当这个返回的函数被调用时，它返回一个承诺。原始函数在Promise内部被调用，当原始函数调用回调时，Promise被解析。如果原始函数有一个上下文(<strong class="je hv"> promisify </strong>的<strong class="je hv">上下文</strong>参数),那么当在Promise内部调用时，它就被绑定到这个上下文。如果原始函数只是一个普通的异步函数，我们用回调的参数来解析承诺。如果它是一个事件监听器(<strong class="je hv"> isEvent = true </strong>)，我们返回事件类型和回调参数。如果回调被错误调用，承诺将被拒绝。</p><p id="e2d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> promisify </strong>的应用看起来是这样的:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1b82" class="ln kc hu lj b fv lo lp l lq lr">const processDataPromise = promisify(processData);<br/>const storeResultPromise = promisify(storeResult);<br/>const onEventPromise = promisify(emitter.once, emitter, true);</span></pre><p id="1086" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个承诺可以这样使用:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="dfa9" class="ln kc hu lj b fv lo lp l lq lr">processDataPromise(data).then(([err, processedData]) =&gt; {<br/>/* do something with the data*/<br/>})</span></pre><p id="c765" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是有更好的方法。</p><h1 id="f2e3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">传奇般的天堂</h1><p id="6019" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们确实需要一个更好的方法，因为要把上面描述的这种流程压缩成一个承诺链几乎是不可能的。</p><p id="6cc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更好的方法是Javascript <strong class="je hv"> async </strong>函数，这里是同一流程的另一个实现:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9c3b" class="ln kc hu lj b fv lo lp l lq lr">async function readStream(streamReader, initialData) {<br/> const processDataPromise = promisify(processData);<br/>const storeResultPromise = promisify(storeResult);<br/>const onEventPromise = promisify(streamReader.once, streamReader, true);<br/> <br/>   await onEventPromise('start');<br/>   let data = initialData || '';<br/> <br/>   while (true) {<br/>       try {<br/>           const event = await Promise.race([<br/>               onEventPromise('data'),<br/>               onEventPromise('stop'),<br/>               onEventPromise('pause'),<br/>           ]);<br/> <br/>           const {type} = event;<br/> <br/>           if (type === 'data') {<br/>               const [chunk] = event.cbArgs;<br/>               data += chunk;<br/>           }<br/> <br/>           if (type === 'pause') {<br/>               readStream(streamReader, data);<br/>               break;<br/>           }<br/> <br/>           if (type === 'stop') {<br/>               const [err, processedData] = await processDataPromise(data);<br/>               await storeResultPromise(processedData);<br/>               return processedData;<br/>           }<br/>       } catch (err) {<br/>           handleError(err);<br/>           return;<br/>       }<br/>   }<br/>}</span></pre><p id="e3ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，这个实现有什么好处呢？首先，它看起来更漂亮。其次，也是更重要的一点，这段代码中有一个流程。这几乎就像流程图，你可以一步一步地追踪整个序列的每个循环和每个分支。它确实看起来像我在开始提到的一个传奇，但没有必要了解任何关于<strong class="je hv"> redux-saga </strong>的知识来编写这样的代码。更重要的是，这是一个你可以忍受的准则。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><div class="le lf lg lh fq lz"><a href="https://hackernoon.com/missing-part-of-redux-saga-experience-1d2d169ba765" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd hv fv z el me eo ep mf er et ht dt translated">Redux Saga体验中缺失的部分</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">Redux saga是应用程序和redux store之间的中间件，由redux actions处理。这意味着，它可以…</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">hackernoon.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ja lz"/></div></div></a></div><div class="mo mp fm fo mq lz"><a href="https://hackernoon.com/using-normalizr-to-organize-data-in-stores-practical-guide-82fa061b60fb" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd hv fv z el me eo ep mf er et ht dt translated">使用Normalizr组织商店中的数据——实用指南</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">在对Normalizr的工作结果应用一些简单的操作之后，我们得到了可以存储的数据</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">hackernoon.com</p></div></div><div class="mi l"><div class="mr l mk ml mm mi mn ja lz"/></div></div></a></div><div class="mo mp fm fo mq lz"><a href="https://hackernoon.com/usage-of-reselect-in-a-react-redux-application-fcdca05cc00d" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd hv fv z el me eo ep mf er et ht dt translated">在React-Redux应用程序中使用重选</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">为什么重选这么好</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">hackernoon.com</p></div></div><div class="mi l"><div class="ms l mk ml mm mi mn ja lz"/></div></div></a></div><div class="mo mp fm fo mq lz"><a href="https://hackernoon.com/using-normalizr-to-organize-data-in-store-part-2-d9646133b7df" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd hv fv z el me eo ep mf er et ht dt translated">使用Normalizr组织存储中的数据。第二部分</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">文章的第二部分讲述了如何使用Normalizr来组织商店中的数据。</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">hackernoon.com</p></div></div><div class="mi l"><div class="mt l mk ml mm mi mn ja lz"/></div></div></a></div><p id="138b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由Ilya Bohaslauchyk撰写</p></div></div>    
</body>
</html>