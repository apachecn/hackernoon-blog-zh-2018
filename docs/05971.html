<html>
<head>
<title>Simple Steps to Optimize Your App Performance with MongoDB, Redis, and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB、Redis和Node.js优化应用性能的简单步骤</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simple-steps-to-optimize-your-app-performance-5700d8b58f58?source=collection_archive---------2-----------------------#2018-07-19">https://medium.com/hackernoon/simple-steps-to-optimize-your-app-performance-5700d8b58f58?source=collection_archive---------2-----------------------#2018-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/af21ccdae323fba0ccc3778b5480292e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vumuGXWXCrQ39uzHYoCrVg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://getstream.io/try-the-api/" rel="noopener ugc nofollow" target="_blank">https://getstream.io/try-the-api/</a></figcaption></figure><h1 id="653f" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">重要的事情先来</h1><p id="d17d" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">在<a class="ae jg" href="https://getstream.io" rel="noopener ugc nofollow" target="_blank"> Stream </a>这里，我们为3亿多终端用户提供活动订阅源，并且喜欢尝试在各种用例中使用我们的产品。最近，我们构建了Winds，<a class="ae jg" href="https://getstream.io/winds/" rel="noopener ugc nofollow" target="_blank">，一个开源的RSS和播客</a>应用，重点放在UI和UX上。</p><p id="a0d4" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">在我们于2018年5月下旬推出第二代Winds后不久，我们开始看到用户注册量大幅上升。当然，大多数示例应用程序不会有这么大的流量。然而，风在<a class="ae jg" href="https://news.ycombinator.com/item?id=17129086" rel="noopener ugc nofollow" target="_blank">黑客新闻</a>和<a class="ae jg" href="https://www.producthunt.com/posts/winds-2-0" rel="noopener ugc nofollow" target="_blank">产品搜索</a>上疯传。到目前为止，示例应用程序代码并没有得到很好的优化。这篇博文涵盖了一些快速入门技巧，可以帮助你提高应用程序的性能。</p><p id="74c1" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">在这篇文章中，我们将讨论如何通过优化数据库模式和添加缓存来减少API调用延迟，以及我们实现的其他工具和改进。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/f318812437cb3b6ce03a2d42bda2ac68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3Nw6SUnASpe0qBD_Bf50g.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">https://getstream.io/winds</figcaption></figure><h1 id="5106" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">可视化和优化API调用</h1><p id="eea6" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">对问题进行分类的第一步是理解潜在的问题。如果您没有使用正确的工具来帮助您可视化代码库中正在发生的事情，这可能是一项艰巨的任务。对于Winds，我们利用各种工具的组合来更好地了解我们的生产环境中发生了什么，从而帮助我们查明延迟问题和缺陷。下面是我们使用的工具以及我们为什么喜欢它们的简要概述。</p><h1 id="87d6" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">新遗迹</h1><p id="1c50" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><a class="ae jg" href="https://newrelic.com/" rel="noopener ugc nofollow" target="_blank"> New Relic </a>提供了我们的请求和响应基础设施的全面视图，使我们的团队能够更好地理解和定位慢速路线。Node.js(我们选择的语言)和其他语言的实现非常简单——只需导入包并放入您的密钥；新圣物从那里接手。</p><p id="39f0" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">这是New Relic在野外的截图(你会注意到我们还没有优化我们的<strong class="kh hv"> POST /rss </strong>端点<em class="ln">和</em>——New Relic如何让我们看到哪些端点需要优化的完美例子)。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/ce7468a9c323910773b63a97da1327af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2-StP69RuhOOLAwFUrHMw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://newrelic.com" rel="noopener ugc nofollow" target="_blank">https://newrelic.com</a></figcaption></figure><p id="209b" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">在上面截图中的“交易”下，您会看到一个路线列表。这些是API路由，以及从应用程序到API、数据库并返回所需的时间(以毫秒为单位)。了解往返需要多长时间对于隔离缓慢的响应时间非常重要。</p><h1 id="79cc" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">维克托罗普斯</h1><p id="cb8d" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">这个工具<em class="ln">很神奇</em>。<a class="ae jg" href="https://victorops.com/" rel="noopener ugc nofollow" target="_blank"> VictorOps </a>允许我们的团队指派其他团队成员“随叫随到”，如果/当出现问题(如API关闭)时，VictorOps将ping用户Slack并发送短信以引起他们的注意。这个过程加快了解决问题的速度，并让团队中的每个人都知道应用程序是否有问题。下面是我们的帐户仪表板的屏幕截图:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/19204e37b1dc4a8a5a172ff87106bd69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xc_irf5povIGwX8M-e0Bug.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://victorops.com" rel="noopener ugc nofollow" target="_blank">https://victorops.com</a></figcaption></figure><h1 id="b55b" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">StatsD</h1><p id="0714" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">最初由<a class="ae jg" href="https://codeascraft.com/2011/02/15/measure-anything-measure-everything/" rel="noopener ugc nofollow" target="_blank"> Etsy </a>，<a class="ae jg" href="https://github.com/etsy/statsd" rel="noopener ugc nofollow" target="_blank"> StatsD </a>编写，是一套工具，可用于从您的应用程序发送、收集和聚合自定义指标。该名称既指原始守护程序中使用的协议，也指实现该协议的软件和服务的集合。</p><p id="30df" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">StatsD系统需要三个组件:客户机、服务器和后端。客户端是一个库，在我们的Winds应用程序代码中调用它来发送指标。这些指标由StatsD服务器收集。</p><p id="d7c7" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">服务器汇总这些指标，然后定期将汇总的数据发送到后端。后端然后使用我们的数据执行各种任务——例如，<a class="ae jg" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>(显示在Grafana部分)用于查看风力<a class="ae jg" href="https://github.com/GetStream/Winds/tree/master/api/src/workers" rel="noopener ugc nofollow" target="_blank">工人</a>的实时图表(RSS、播客、打开图表等)。)和其他重要的基础设施指标。</p><p id="2046" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">为了收集数据，我们使用一个名为node-statsd的节点库。使用这个库，我们创建了一个帮助文件来保持代码的整洁:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2c66" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我们可以像这样调用util(在任何有statsd注释的地方):</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="18d8" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">值得注意的是，您可以将以下<a class="ae jg" href="https://github.com/etsy/statsd/blob/master/docs/metric_types.md" rel="noopener ugc nofollow" target="_blank">指标类型</a>用于StatsD:</p><ul class=""><li id="8709" class="lq lr hu kh b ki ld km le kq ls ku lt ky lu lc lv lw lx ly dt translated"><strong class="kh hv">计数器</strong> —它们代表一段时间内的数值或某一事件的发生次数(您可以设置或增加/减少)。StatsD将计算平均值、百分位数等。)</li><li id="fb3f" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated"><strong class="kh hv">仪表</strong> —类似于计数器，但它代表一个值(可用的最新数据点)，而不是一段时间内的值</li><li id="4691" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated"><strong class="kh hv">计时器</strong>——类似于计数器，但用于测量操作花费的时间，而不是操作发生的次数</li></ul><h1 id="81f9" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">石墨</h1><p id="c470" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Graphite 由三个软件组件组成:Carbon、Whisper和Graphite Web。Carbon是一个高性能的服务，它监听StatsD发出的时间序列数据。Whisper是一个简单的数据库库，用于存储时间序列数据，graphite-web是graphite的用户界面和API，用于呈现图形和仪表板(尽管我们在项目中不使用Graphite Web，因为我们使用Grafana)。</p><p id="e44f" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">更清楚地说，来自StatsD的指标通过Carbon服务输入堆栈，Carbon服务将数据写出到Whisper数据库进行长期存储。然后，我们使用Graphite Web提供的API在Grafana中可视化数据。</p><p id="a7da" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">石墨的详细实施和其他信息可以在<a class="ae jg" href="https://graphiteapp.org/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/3923079204c838fa6e0ae2e7d22fcb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-xqmtBY-IrylAW18fCW1g.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://graphiteapp.org/" rel="noopener ugc nofollow" target="_blank">https://graphiteapp.org/</a></figcaption></figure><h1 id="acdb" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">格拉夫纳</h1><p id="5538" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><a class="ae jg" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>是领先的时间序列分析开源软件，这就是为什么我们选择用它来分析风和河流。Grafana允许我们的团队查询、可视化、警告和理解从Graphite检索的风的度量。它充满了令人敬畏的可视化工具(如下面的截图所示)，允许我们的团队挑选和选择我们想要如何显示我们的数据。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mf"><img src="../Images/84c53dd194dbe0c4163882c0f81ef163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_H24noX_IRmRwNZL8-Wxg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">https://grafana.com/</a></figcaption></figure><h1 id="a876" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">优化我们的MongoDB数据库</h1><p id="1ea8" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">对于我们的主数据存储，我们使用<a class="ae jg" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank">MongoDB Atlas</a>——由 MongoDB提供的MongoDB <em class="ln">的托管版本。这允许Winds拥有一个完整的副本集(3台服务器),而无需管理它们。服务器会自动升级并自动安装补丁，这非常方便。MongoDB Atlas还执行定期备份，并提供副本集的时间点备份。不幸的是，这种奢侈是有代价的；然而，这是我们愿意承受的，这样我们就可以专注于改善Winds的用户体验。</em></p><p id="c474" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">虽然MongoDB Atlas负责数据库管理的繁重工作。这并不意味着它解决了所有问题。文档需要正确地组织和索引，我们需要确保将读写保持在最低水平，这样我们就不会使用所有分配的每秒输入/输出操作(IOPS)和连接。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/070af8dbe84e236f949ae3c34988fc51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DfwoJFvG2OWs3PpW5euFg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://cloud.mongodb.com" rel="noopener ugc nofollow" target="_blank">https://cloud.mongodb.com</a></figcaption></figure><h1 id="1e1c" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">索引使用</h1><p id="0e3d" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">不正确的索引或根本没有索引通常是应用程序延迟增加的首要原因。如果没有索引，MongoDB必须执行集合扫描，即扫描集合中的每个文档，以选择那些匹配查询语句的文档。</p><p id="20ae" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">正如MongoDB所描述的，索引是一种特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。索引存储特定字段或字段集的值，按字段值排序。索引条目的排序支持高效的等式匹配和基于范围的查询操作。此外，MongoDB可以通过使用索引中的排序返回排序的结果。</p><p id="0f32" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">下图说明了一个使用索引对匹配文档进行选择和排序的查询:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/db0a79048eb2798e21f201dcd69f66f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPm24jaKf8lpXueosSsDRg.png"/></div></div></figure><h1 id="0843" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">散列索引</h1><p id="d617" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">在Winds中，我们几乎拥有所有合适的索引，但是，我们没有认识到MongoDB中的一个主要需求/约束。索引条目的总大小必须小于1024字节。这并不难保证…对吗？事情是这样的，我们对URL进行索引以加快查找过程，一些进入Winds API的URL超过1024字节。这导致了各种意想不到的错误。</p><p id="2dfd" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">经过大量研究，我们找到了一个解决方案— <a class="ae jg" href="https://docs.mongodb.com/manual/core/index-hashed/" rel="noopener ugc nofollow" target="_blank">散列索引</a>。散列索引维护索引字段值的散列条目。这意味着我们可以像以前一样在同一个URL上进行查找，而不用担心它的长度，并且仍然保持完整性。</p><blockquote class="mi mj mk"><p id="c4e6" class="kf kg ln kh b ki ld kk kl km le ko kp ml lf ks kt mm lg kw kx mn lh la lb lc hn dt translated">注意:当使用散列索引解析查询时，MongoDB会自动计算散列。应用程序不需要计算散列。</p></blockquote><h1 id="a3b4" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">单一索引</h1><p id="0a3e" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">除了default _id索引之外，MongoDB还支持在文档的单个字段上创建用户定义的升序/降序索引。这将是你最常用的索引类型。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/9eae95365412893aa3e5baa363c5ba1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZSop2J9dXWj4n4N_9_-fg.png"/></div></div></figure><p id="57d2" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">对于单字段索引和排序操作，索引键的排序顺序(即升序或降序)并不重要，因为MongoDB可以在任一方向上遍历索引。</p><h1 id="d5c0" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">复合指数</h1><p id="7aad" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">与其他数据库类似，MongoDB支持复合索引，其中单个索引结构保存对多个字段的引用。</p><blockquote class="mi mj mk"><p id="26c6" class="kf kg ln kh b ki ld kk kl km le ko kp ml lf ks kt mm lg kw kx mn lh la lb lc hn dt translated">注意:不能创建具有散列索引类型的复合索引。如果试图创建包含哈希索引字段的复合索引，将会收到错误消息。</p></blockquote><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/9cac388725916dc2e3256f67fed03657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCLQF4C3rH6FWbveViZKug.png"/></div></div></figure><p id="11ee" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">要创建复合索引，请使用类似如下的操作:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="7572" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">或者，如果您使用Mongoose，您将需要在模式级别定义索引。这里有一个例子:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><blockquote class="mi mj mk"><p id="25cb" class="kf kg ln kh b ki ld kk kl km le ko kp ml lf ks kt mm lg kw kx mn lh la lb lc hn dt translated">注意:上面展示了一个添加复合指数的例子，类似于添加单一指数。唯一的区别是，对于单个索引，只有一个值为1或-1的键。</p></blockquote><p id="c272" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">索引中字段的值描述了该字段的索引种类。例如，值1指定按升序排列项目的索引。值-1指定按降序对项目排序的索引。</p><blockquote class="mi mj mk"><p id="4859" class="kf kg ln kh b ki ld kk kl km le ko kp ml lf ks kt mm lg kw kx mn lh la lb lc hn dt translated">注意:如果您对深入阅读MongoDB中的索引感兴趣，<a class="ae jg" href="https://docs.mongodb.com/manual/indexes/" rel="noopener ugc nofollow" target="_blank">这里有一个很好的资源</a>。还有一个关于性能索引的精彩的<a class="ae jg" href="https://www.slideshare.net/mongodb/fast-querying-indexing-for-performance-4" rel="noopener ugc nofollow" target="_blank">幻灯片</a>。</p></blockquote><h1 id="6048" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">确保索引</h1><p id="7b33" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">MongoDB提供的一个特性是<strong class="kh hv"> createIndex() </strong>操作。这样做的目的是遍历数据库中的每个文档，并“确保”它有正确的索引。许多人没有意识到这是一个非常繁重的数据库任务，占用了宝贵的CPU和内存，降低了数据库的速度。</p><p id="d9cb" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">如果对索引进行更新，您需要运行<strong class="kh hv"> createIndex() </strong>操作；但是，我们建议在非高峰时间这样做，此时您的数据库不会受到每秒大量请求的冲击。</p><p id="a60e" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">要在Mongoose中启用这个特性，请看一下这里的文档<a class="ae jg" href="http://mongoosejs.com/docs/api.html#model_Model.ensureIndexes" rel="noopener ugc nofollow" target="_blank"/>。</p><blockquote class="mi mj mk"><p id="e6b3" class="kf kg ln kh b ki ld kk kl km le ko kp ml lf ks kt mm lg kw kx mn lh la lb lc hn dt translated">注意:如果您想阅读关于<strong class="kh hv"> createIndex() </strong>操作的内容，MongoDB有关于这个主题的<a class="ae jg" href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#db.collection.createIndex" rel="noopener ugc nofollow" target="_blank">大量文档</a>。</p></blockquote><h1 id="a0ac" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">巧妙处理查询</h1><p id="5674" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">减少对数据库的查询是您可以实现的最大性能增强。使用New Relic，我们发现用户注册路径非常慢。一个注册API调用变成了对Stream API的大约60个请求，还有几个对数据库的调用来获取兴趣。在研究了这个问题之后，我们意识到我们可以做两件事来减少请求的总数:</p><ol class=""><li id="d08e" class="lq lr hu kh b ki ld km le kq ls ku lt ky lu lc mq lw lx ly dt translated">在Redis中缓存兴趣(接下来将介绍)，而不是为每个用户注册对数据库进行N次API调用</li><li id="8c2e" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc mq lw lx ly dt translated">批量API调用第三方服务，如Stream</li></ol><p id="741c" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">另一个常见的错误是多次执行一个简单的查询，而不是读取所有必需记录的单个查询。当从流中读取提要时，我们简单地使用MongoDB <strong class="kh hv"> $in </strong>操作符来检索流中存储的所有带有id值的文章。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="8e78" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">精简查询</h1><p id="7c12" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">对于我们的ODM，我们使用了Mongoose，它是MongoDB驱动程序之上的一个功能打包且易于使用的Node.js层。这允许我们实施对象模型验证、转换和业务逻辑，这在我们的API代码库中提供了一致性。唯一的缺点是每个查询都返回一个沉重的mongose对象，带有getter/setter方法和其他我们有时不需要的mongose魔法。</p><p id="7a60" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">为了避免查询响应中有时出现的额外开销，我们在一些查询中使用了<a class="ae jg" href="http://mongoosejs.com/docs/api.html#query_Query-lean" rel="noopener ugc nofollow" target="_blank"><strong class="kh hv">【lean()</strong></a><strong class="kh hv"/>选项。这产生了一个普通的JavaScript对象，然后可以将其转换为JSON作为响应负载。就像做类似下面的事情一样简单:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="137b" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">解释查询</h1><p id="c8c7" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><a class="ae jg" href="https://docs.mongodb.com/manual/reference/method/cursor.explain/#cursor.explain" rel="noopener ugc nofollow" target="_blank"> $explain操作符</a>非常方便。顾名思义，它返回一个描述用于返回查询的过程和索引的文档。这在尝试优化查询时提供了有用的见解(例如，添加什么索引来加速查询)。</p><p id="011c" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">关于$explain操作符的文档指定了如何实现查询。</p><h1 id="5350" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">雷迪斯</h1><p id="4cfa" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated"><a class="ae jg" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>是内存中的数据结构存储。它可以用作数据库、缓存和消息代理。在我看来，Redis是最容易被忽视的数据存储库之一——前提是它在存储内容方面非常灵活。对于Winds，我们将其广泛用作缓存，以避免不必要的数据库查找。</p><p id="b8a7" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">例如，在Winds的注册阶段，我们会问你的兴趣是什么，这样我们就可以利用机器学习围绕你喜欢的东西打造用户体验。这个步骤过去需要调用数据库来获取数据库ID，这样就可以存储它。现在，我们简单地将利息存储为JSON，并对Redis进行查询。因为Redis将所有内容都存储在内存中，所以这是一个非常轻量级的任务，几乎没有额外的延迟。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/ddb6629f7b735f4491696d83fce50c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTNEQSWXlxBAe2a2F3HYTA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://winds.getstream.io" rel="noopener ugc nofollow" target="_blank">https://winds.getstream.io</a></figcaption></figure><p id="6e71" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">这里有一个我们如何将兴趣储存在风中的例子:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="5491" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">针对您的应用的一些关键要点:</p><p id="1012" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">使用Redis表示</strong>:</p><ul class=""><li id="2bb3" class="lq lr hu kh b ki ld km le kq ls ku lt ky lu lc lv lw lx ly dt translated">存储流行的和频繁查询的数据，以减少数据库查询(查询内存比让数据库对磁盘进行查找要有效得多)。</li><li id="89a7" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">在数据有效的时间内缓存数据(例如，在我们的例子中，Winds为60分钟)，并使用自动过期(这是默认设置)。</li><li id="1e33" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">将您的缓存键与您的应用程序版本号相关联(例如<strong class="kh hv">兴趣:v2.0.0 </strong>)。这将在您向应用程序部署更新时强制重新缓存，从而避免潜在的错误和缓存不匹配。</li><li id="0b62" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">字符串化你的数据，以确保它可以存储在Redis中(它只是键值，两者都必须是字符串。</li></ul><h1 id="c11f" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">公牛队列</h1><p id="c76c" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Bull是一个奇妙的排队系统，位于Redis之上。我们在Winds中将Bull用于我们的工人基础架构，并且有几个队列用于处理(抓取)数据:</p><ul class=""><li id="94b3" class="lq lr hu kh b ki ld km le kq ls ku lt ky lu lc lv lw lx ly dt translated">简易资讯聚合</li><li id="ad62" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">播客</li><li id="22e5" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">打开图表</li></ul><p id="d1fb" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">最重要的是，我们选择公牛的原因如下</strong>:</p><ul class=""><li id="4a82" class="lq lr hu kh b ki ld km le kq ls ku lt ky lu lc lv lw lx ly dt translated">由于采用了免轮询设计，CPU使用率极低</li><li id="bd8b" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">基于Redis的稳健设计</li><li id="affb" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">延迟的工作</li><li id="ae4f" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">作业的限速器</li><li id="dc79" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">重试次数</li><li id="c81d" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">优先</li><li id="e90c" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">并发</li><li id="9244" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">每个队列有多种作业类型</li><li id="95bd" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">线程(沙盒)处理功能</li><li id="1b08" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">从流程崩溃中自动恢复</li></ul><p id="b04b" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">我们对提要和开放图抓取使用了一种排队机制，因为它将进程分开，这样它们就不会在没有API性能的情况下发生冲突。这通常是最佳实践，因为当您经常解析10，000或更多的提要时，您不希望您的API挂起。</p><p id="4d68" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">在构建API或应用服务器时，重要的是退后一步，问一问任务是否会妨碍您的响应时间。响应时间应该最多250毫秒，即使这个数字也很慢。当有疑问时，将它放入一个队列，并在一个单独的线程上处理它。</p><blockquote class="mi mj mk"><p id="5be3" class="kf kg ln kh b ki ld kk kl km le ko kp ml lf ks kt mm lg kw kx mn lh la lb lc hn dt translated">注意:这里是我们队列的一个快速截图。这将显示队列中活跃的RSS、Podcast和打开的Graph作业的数量及其状态。Bull通过API提供所有这些数据，使我们能够更好地了解幕后发生的事情。你也可以使用其他第三方用户界面进行监控，比如<a class="ae jg" href="https://taskforce.sh/" rel="noopener ugc nofollow" target="_blank">任务组</a>和<a class="ae jg" href="https://github.com/mixmaxhq/arena" rel="noopener ugc nofollow" target="_blank">竞技场</a>。</p></blockquote><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/aa716aae2a5d73c99afee7c346912217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1aca56aEntJIqAoOMm0blQ.png"/></div></div></figure><h1 id="376d" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">使用专用解决方案</h1><p id="7e4a" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">类似于Bull卸载处理负担的方式，使用专用解决方案来加速应用程序是非常有价值的。例如，我们使用自己的服务<a class="ae jg" href="https://getstream.io/try-the-api" rel="noopener ugc nofollow" target="_blank"> Stream </a>，以确保用户在被放入系统时，能够跟踪必要的提要并接收更新。从零开始建造这个可能需要几个月，甚至几年；然而，通过使用服务，我们能够在几个小时内实现。</p><p id="3a81" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">另一个我们喜欢的第三方服务是Algolia。Algolia在Winds中增强了我们的搜索功能，使查找速度快如闪电(查找时间少于50毫秒)。虽然我们<em class="ln">可以</em>用一个专用的端点和一个奇特的MongoDB查询自己构建搜索，但我们无法扩展搜索功能并保持Algolia提供的相同速度，而且当用户执行搜索时，它会耗尽宝贵的API资源。</p><p id="a35a" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">这两种解决方案都远远优于您使用通用数据库在内部构建的解决方案。</p><h1 id="35d7" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">最后的想法</h1><p id="8c87" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我们希望您喜欢这份提高Node应用程序性能的基本技巧列表。大多数现实世界的性能问题都是由简单的事情引起的。这篇文章列举了一些常见的解决方案:</p><ul class=""><li id="f019" class="lq lr hu kh b ki ld km le kq ls ku lt ky lu lc lv lw lx ly dt translated">APM工具，如New Relic、StatsD和Grafana</li><li id="8fe5" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">索引使用和查询优化</li><li id="6e3c" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">Redis和缓存</li><li id="c24a" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">异步任务</li><li id="c84b" class="lq lr hu kh b ki lz km ma kq mb ku mc ky md lc lv lw lx ly dt translated">为搜索和提要使用专门的数据存储</li></ul><p id="af9f" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">如果你正在寻找更高级的主题，请查看关于<a class="ae jg" href="https://stackshare.io/stream/stream-and-go-news-feeds-for-over-300-million-end-users" rel="noopener ugc nofollow" target="_blank"> Stream如何使用RocksDB，Go和Raft为超过3亿用户提供提要的帖子</a>。</p><p id="5c56" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated">如果您正在构建一个需要新闻提要或活动提要的应用程序，请查看Stream。我们有一个5分钟的教程，将带您浏览我们涵盖的各种使用案例。API教程可以在<a class="ae jg" href="https://getstream.io/try-the-api" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="8496" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><em class="ln">如果你有任何问题，请在下面的评论中提出。如果你有兴趣在推特上关注我，我的账号是</em><a class="ae jg" href="https://twitter.com/@nickparsons" rel="noopener ugc nofollow" target="_blank"><strong class="kh hv"><em class="ln">@ nick Parsons</em></strong></a><em class="ln">。</em></p><p id="00cf" class="pw-post-body-paragraph kf kg hu kh b ki ld kk kl km le ko kp kq lf ks kt ku lg kw kx ky lh la lb lc hn dt translated"><strong class="kh hv">快乐编码！</strong></p></div></div>    
</body>
</html>