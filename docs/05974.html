<html>
<head>
<title>Build a Realtime Serverless GraphQL API with Websockets on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS上用Websockets构建一个实时无服务器的GraphQL API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-realtime-serverless-graphql-api-with-websockets-on-aws-d9e553a997?source=collection_archive---------5-----------------------#2018-07-19">https://medium.com/hackernoon/build-a-realtime-serverless-graphql-api-with-websockets-on-aws-d9e553a997?source=collection_archive---------5-----------------------#2018-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/90bf65fce335fc8eb833ffde568a7bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJuRf9OEWQk9aSb4_62yxw.png"/></div></div></figure><p id="50be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着AWS AppSync的发布，我们终于有能力在AWS上创建实时无服务器应用。以前，为了创建websocket连接，您不得不启动EC2实例，因为AWS Lambda不支持它们。</p><p id="540b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本教程中，您将学习如何使用AWS AppSync构建一个简单的<a class="ae ka" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> API。然后，您将使用普通的<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> javascript </a>(没有框架)编写一个客户端应用程序，通过websockets接收实时更新。我们开始吧！</p><h1 id="0c59" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">1.设置</h1><p id="c7e2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">继续安装无服务器框架cli，我们将使用它来部署AppSync GraphQL API并为我们的项目创建一个新目录。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="7427" class="ln kc hu lj b fv lo lp l lq lr">$ npm install -g serverless $ mkdir realtime-chat<br/>$ cd realtime-chat</span></pre><h1 id="0a12" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">2.创建GraphQL模式</h1><p id="0ce2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们将为我们的聊天应用程序定义一个基本的GraphQL模式。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3d7f" class="ln kc hu lj b fv lo lp l lq lr">schema {<br/>    query: Query<br/>    mutation: Mutation<br/>    subscription: Subscription<br/>}</span><span id="eeb6" class="ln kc hu lj b fv ls lp l lq lr">type Subscription {<br/>    inbox(to: String): Page<br/>    <a class="ae ka" href="http://twitter.com/aws_subscribe" rel="noopener ugc nofollow" target="_blank">@aws_subscribe</a>(mutations: ["message"])<br/>}</span><span id="8960" class="ln kc hu lj b fv ls lp l lq lr">type Mutation {<br/>    message(body: String!, to: String!): Page!<br/>}</span><span id="1fb6" class="ln kc hu lj b fv ls lp l lq lr">type Message {<br/>    from: String!<br/>    to: String!<br/>    body: String!<br/>    sentAt: String!<br/>}</span><span id="6ab1" class="ln kc hu lj b fv ls lp l lq lr">type Query {<br/>    me: String<br/>}</span></pre><p id="3c17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除实时订阅之外的标准GraphQL模式，它使用特殊的语法向AWS AppSync指示订阅哪个变异(<code class="eh lt lu lv lj b">@aws_subscribe(mutations: ["message"])</code>)，在本例中是<code class="eh lt lu lv lj b">message</code>变异。</p><h1 id="f4d4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">3.创建映射模板</h1><p id="7f9b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在我们已经定义了模式，我们需要为它添加解析器。如果你期望需要写一个lambda函数，那你就错了！AppSync引入了<a class="ae ka" href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-overview.html" rel="noopener ugc nofollow" target="_blank">映射模板</a>的概念，它将客户端请求翻译成后台存储(DynamoDB、elasticsearch等)理解的请求，然后将响应再次翻译回客户端。</p><p id="81b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简单起见，我们正在创建一个没有数据库的API。AppSync提供了一种特殊类型的解析器，称为<a class="ae ka" href="https://docs.aws.amazon.com/appsync/latest/devguide/tutorial-local-resolvers.html" rel="noopener ugc nofollow" target="_blank">本地解析器</a>，它不保存请求数据，而是将请求数据转发给当时存在的任何订阅者。</p><p id="b297" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们创建一个目录来存放我们的映射模板。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="395c" class="ln kc hu lj b fv lo lp l lq lr">$ mkdir mapping-templates</span></pre><p id="fd0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，让我们在一个名为<code class="eh lt lu lv lj b">mapping-templates/Message.request.vtl</code>的文件中为我们的<code class="eh lt lu lv lj b">message</code>变异创建请求模板，它将从变异请求中提取字段。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f9b4" class="ln kc hu lj b fv lo lp l lq lr">{<br/>  "version": "2017-02-28",<br/>  "payload": {<br/>    "body": "${context.arguments.body}",<br/>    "from": "${context.identity.username}",<br/>    "to":  "${context.arguments.to}",<br/>    "sentAt": "$util.time.nowISO8601()"<br/>  }<br/>}</span></pre><p id="8b2a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于响应，我们只使用标准转发模板。用以下内容创建一个名为<code class="eh lt lu lv lj b">mapping-templates/ForwardResult.response.vtl</code>的文件。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0e4e" class="ln kc hu lj b fv lo lp l lq lr">$util.toJson($context.result)</span></pre><p id="866d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的文件夹结构现在应该如下所示:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="05ca" class="ln kc hu lj b fv lo lp l lq lr">$ tree mapping-templates mapping-templates ├── ForwardResult.response.vtl └── Message.request.vtl</span></pre><h1 id="49e9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">4.使用无服务器框架部署AppSync GraphQL API</h1><p id="4526" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在我们需要为无服务器框架创建一个配置文件来提供我们的API。为此，我们将使用<a class="ae ka" href="https://github.com/sid88in/serverless-appsync-plugin" rel="noopener ugc nofollow" target="_blank">无服务器AppSync插件</a>。</p><p id="8fc6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用<code class="eh lt lu lv lj b">npm</code>安装。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="da93" class="ln kc hu lj b fv lo lp l lq lr">$ npm install --dev serverless-appsync-plugin</span></pre><p id="af5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后用以下内容创建一个<code class="eh lt lu lv lj b">serverless.yml</code>文件。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="452f" class="ln kc hu lj b fv lo lp l lq lr">---<br/>service: realtime-chat</span><span id="3baa" class="ln kc hu lj b fv ls lp l lq lr">frameworkVersion: "&gt;=1.21.0 &lt;2.0.0"</span><span id="aced" class="ln kc hu lj b fv ls lp l lq lr">plugins:<br/>  - serverless-appsync-plugin</span><span id="7248" class="ln kc hu lj b fv ls lp l lq lr">provider:<br/>  name: aws<br/>  region: eu-west-1</span><span id="c4f8" class="ln kc hu lj b fv ls lp l lq lr">custom:<br/>  awsAccountId: ${env:AWS_ACCOUNT_ID}<br/>  appSync:<br/>    name: realtimeChat<br/>    apiKey: ${env:APPSYNC_API_KEY}<br/>    apiId: ${env:APPSYNC_API_ID}<br/>    authenticationType: API_KEY<br/>    schema: schema/schema.graphql<br/>    serviceRole: "AppSyncServiceRole" # AppSyncServiceRole is a role defined by amazon and available in all accounts<br/>    mappingTemplatesLocation: mapping-templates<br/>    mappingTemplates:<br/>      - dataSource: Chat<br/>        type: Mutation<br/>        field: message<br/>        request: Message.request.vtl<br/>        response: ForwardResult.response.vtl<br/>      - dataSource: Chat<br/>        type: Subscription<br/>        field: inbox<br/>        request: Message.request.vtl<br/>        response: ForwardResult.response.vtl<br/>    dataSources:<br/>      - type: NONE  # use an AppSync local resolver<br/>        name: Chat<br/>        description: 'Chat relay'</span></pre><p id="ba97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，我们将数据源类型设置为<code class="eh lt lu lv lj b">NONE</code>，以便使用<a class="ae ka" href="https://docs.aws.amazon.com/appsync/latest/devguide/tutorial-local-resolvers.html" rel="noopener ugc nofollow" target="_blank">本地解析器</a>，因为我们不想将聊天消息保存在数据库中，而是将它们转发给其他监听更新的客户端。</p><p id="2b5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的<code class="eh lt lu lv lj b">serverless.yml</code>配置包含一些我们必须提供的环境变量。让我们创建一个包含AWS帐户ID的<code class="eh lt lu lv lj b">.env</code>文件，并动态填充其他变量。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="e9ae" class="ln kc hu lj b fv lo lp l lq lr"># .env</span><span id="f7bf" class="ln kc hu lj b fv ls lp l lq lr">export AWS_ACCOUNT_ID=123456789</span><span id="d493" class="ln kc hu lj b fv ls lp l lq lr">export APPSYNC_API_ID=$(aws appsync list-graphql-apis \<br/>  --query 'graphqlApis[?name==`realtimeChat`].apiId' \<br/>   --output text &gt;/dev/null 2&gt;&amp;1)</span><span id="2c30" class="ln kc hu lj b fv ls lp l lq lr">export APPSYNC_API_KEY=$(aws appsync list-api-keys \<br/>  --api-id "$APPSYNC_API_ID" \<br/>  --query 'apiKeys[0].id' \<br/>   --output text &gt;/dev/null 2&gt;&amp;1)</span></pre><p id="5304" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经准备好用一个命令来部署我们的API了:</p><p id="6090" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">恭喜你！您刚刚部署了一个具有实时支持的GraphQL API。</p><h1 id="b038" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">5.为客户端应用程序创建GraphQL查询</h1><p id="6caa" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们需要做的下一件事是创建GraphQL查询，我们将从我们的客户端使用它来查询我们的API。</p><p id="c246" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们创建一个目录来存放我们的客户机代码。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1088" class="ln kc hu lj b fv lo lp l lq lr">$ mkdir src</span></pre><p id="8e8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后让我们为我们的查询创建一个目录。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d17f" class="ln kc hu lj b fv lo lp l lq lr">$ mkdir src/graphql</span></pre><p id="f831" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh lt lu lv lj b">src/graphql/inboxSubscription.js</code>为我们的订阅查询创建一个文件，包含以下内容:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="a5f8" class="ln kc hu lj b fv lo lp l lq lr">import gql from 'graphql-tag';</span><span id="7ecf" class="ln kc hu lj b fv ls lp l lq lr">export default gql`<br/>subscription Inbox($to: String) {<br/>    inbox(to: $to) {<br/>      from<br/>      body<br/>    }<br/>}`;</span></pre><p id="6efd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这只是一个简单的订阅查询，将返回<code class="eh lt lu lv lj b">from</code>和<code class="eh lt lu lv lj b">body</code>消息字段。</p><h1 id="99d1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">6.从AWS控制台下载API配置</h1><p id="efce" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们需要下载应用程序的配置设置，以便它可以连接到我们的GraphQL API。</p><p id="523d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">导航到AWS控制台中的AppSync部分。选择您的API并下载web配置设置。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lw"><img src="../Images/a3c470db0a0f005f090c5d7469cf7501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T1gwb2_MN8egts_X.png"/></div></div></figure><p id="023d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的下载区中会有一个名为<code class="eh lt lu lv lj b">AppSync.js</code>的文件。将这个目录移动到您的<code class="eh lt lu lv lj b">src</code>目录，并将其重命名为<code class="eh lt lu lv lj b">config.js</code>。</p><p id="fdf8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您将保护API的默认选项保留为<code class="eh lt lu lv lj b">API_KEY</code>，那么您下载的配置文件应该如下所示。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f2bc" class="ln kc hu lj b fv lo lp l lq lr">export default {<br/>  "graphqlEndpoint": "<a class="ae ka" href="https://xxxx.appsync-api.eu-west-1.amazonaws.com/graphql" rel="noopener ugc nofollow" target="_blank">https://xxxx.appsync-api.eu-west-1.amazonaws.com/graphql</a>",<br/>  "region": "eu-west-1",<br/>  "authenticationType": "API_KEY",<br/>  "apiKey": "xxxxxxxxxxxxxxxxxxxxxxxxx"<br/>}</span></pre><h1 id="beff" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">7.用于订阅实时API更新的同构普通JavaScript客户端代码</h1><p id="0319" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们将创建一个同构的客户端——既可以在浏览器中运行，也可以通过node.js在终端中运行。</p><p id="b38a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先让我们安装我们需要的依赖项。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="eccb" class="ln kc hu lj b fv lo lp l lq lr">$ npm install -s apollo-cache-inmemory apollo-client apollo-link aws-appsync aws-sdk es6-promise graphql graphql-cli graphql-tag isomorphic-fetch ws</span></pre><p id="92be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后让我们为应用程序创建一个入口点。</p><p id="32e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的应用程序源代码目录现在应该包含以下内容。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1044" class="ln kc hu lj b fv lo lp l lq lr">$ tree src<br/>src<br/>├── config.js<br/>├── graphql<br/>│   └── inboxSubscription.js<br/>└── index.js</span></pre><p id="b411" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将以下代码粘贴到您的<code class="eh lt lu lv lj b">index.js</code>文件中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3f2f" class="ln kc hu lj b fv lo lp l lq lr">const RECIPIENT = 'Bobby';</span><span id="7fbb" class="ln kc hu lj b fv ls lp l lq lr">if (!global.WebSocket) {<br/>  global.WebSocket = require('ws');<br/>}<br/>if (!global.window) {<br/>  global.window = {<br/>    setTimeout: setTimeout,<br/>    clearTimeout: clearTimeout,<br/>    WebSocket: global.WebSocket,<br/>    ArrayBuffer: global.ArrayBuffer,<br/>    addEventListener: function () { },<br/>    navigator: { onLine: true }<br/>  };<br/>}<br/>if (!global.localStorage) {<br/>  global.localStorage = {<br/>    store: {},<br/>    getItem: function (key) {<br/>      return this.store[key];<br/>    },<br/>    setItem: function (key, value) {<br/>      this.store[key] = value;<br/>    },<br/>    removeItem: function (key) {<br/>      delete this.store[key];<br/>    }<br/>  };<br/>}<br/>require('es6-promise').polyfill();<br/>require('isomorphic-fetch');</span><span id="90c7" class="ln kc hu lj b fv ls lp l lq lr">// Require config file downloaded from AWS console with endpoint and auth info<br/>const AppSyncConfig = require('./config').default;<br/>const AWSAppSyncClient = require('aws-appsync').default;<br/>import InboxSubscription from './graphql/inboxSubscription';</span><span id="8600" class="ln kc hu lj b fv ls lp l lq lr">// Set up Apollo client<br/>const client = new AWSAppSyncClient({<br/>  url: AppSyncConfig.graphqlEndpoint,<br/>  region: AppSyncConfig.region,<br/>  auth: {<br/>    type: AppSyncConfig.authenticationType,<br/>    apiKey: AppSyncConfig.apiKey,<br/>  }<br/>});</span><span id="e4fd" class="ln kc hu lj b fv ls lp l lq lr">client.hydrated().then(function (client) {</span><span id="2f84" class="ln kc hu lj b fv ls lp l lq lr">const observable = client.subscribe({ query: InboxSubscription, variables: { to: RECIPIENT } });</span><span id="ceab" class="ln kc hu lj b fv ls lp l lq lr">const realtimeResults = function realtimeResults(data) {<br/>    console.log('realtime data: ', data);<br/>  };</span><span id="fc2f" class="ln kc hu lj b fv ls lp l lq lr">observable.subscribe({<br/>    next: realtimeResults,<br/>    complete: console.log,<br/>    error: console.log,<br/>  });<br/>});</span></pre><p id="d309" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这个简单的演示，我们已经将收件人硬编码为<code class="eh lt lu lv lj b">Bobby</code>，但是很明显，您希望在实际应用程序中实现这种动态。</p><h1 id="2918" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">8.Node.js客户端应用程序构建流程</h1><p id="7fc9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">此时，我们已经为websockets客户端编写了所有的源代码，我们只需要实现构建过程。因为源代码使用es6特性，我们需要使用babel来转换它。</p><p id="7dea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装我们需要的开发依赖项。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ea8a" class="ln kc hu lj b fv lo lp l lq lr">$ npm install --save-dev babel-cli babel-preset-es2015 rimraf webpack webpack-cli webpack-dev-server</span></pre><p id="05d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们构建我们的应用程序。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1ca8" class="ln kc hu lj b fv lo lp l lq lr">$ rimraf build/ &amp;&amp; babel ./src --out-dir build/ --ignore ./node_modules,./.babelrc,./package.json,./npm-debug.log --copy-file</span></pre><h1 id="0cfb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">9.Node.js客户端应用程序</h1><p id="2d63" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在让我们运行node.js中的应用程序。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9329" class="ln kc hu lj b fv lo lp l lq lr">$ node build/index.js</span></pre><p id="e7a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在AWS控制台中导航到AppSync API中的<code class="eh lt lu lv lj b">queries</code>页面，并运行以下graphQL变体来触发一些更新。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="17fe" class="ln kc hu lj b fv lo lp l lq lr">mutation Message {<br/>    message(to: "Bobby", body: "Yo node!") {<br/>        body<br/>        to<br/>        from<br/>        sentAt<br/>    }<br/>}</span></pre><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lx"><img src="../Images/92bf804a283808ea6ea101d1c920a109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jmUdHzFCuI03AJnb.png"/></div></div></figure><p id="8833" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该会看到消息立即出现在您的终端中。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/a31e1e3e4672ee628ffcd2ddcbca6510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7L4MPIM9bMzfBtq6.png"/></div></div></figure><h1 id="a7b3" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">10.浏览器客户端应用程序构建流程</h1><p id="ee44" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">记住我们写的代码是同构的。这意味着它可以在浏览器中运行。</p><p id="69e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先安装我们需要的开发依赖项。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="c0cb" class="ln kc hu lj b fv lo lp l lq lr">$ npm install --save-dev webpack webpack-cli webpack-dev-server</span></pre><p id="57e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用<a class="ae ka" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>来运行我们的构建过程，因此我们需要为它创建一个配置文件。在项目路径下创建一个名为<code class="eh lt lu lv lj b">webpack.config.js</code>的文件，内容如下。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="62c3" class="ln kc hu lj b fv lo lp l lq lr">const path = require('path');</span><span id="df52" class="ln kc hu lj b fv ls lp l lq lr">module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'bundle.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  }<br/>};</span></pre><p id="1d7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于web服务器将提供来自<code class="eh lt lu lv lj b">dist</code>目录的资产，我们需要添加一个包含webpack将生成的<code class="eh lt lu lv lj b">bundle.js</code>文件的<code class="eh lt lu lv lj b">index.html</code>文件。在<code class="eh lt lu lv lj b">dist/index.html</code>创建一个文件，内容如下。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="70a7" class="ln kc hu lj b fv lo lp l lq lr">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;AWS Serverless Websockets Demo&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;</span><span id="b935" class="ln kc hu lj b fv ls lp l lq lr">&lt;/body&gt;<br/>&lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt;<br/>&lt;/html&gt;</span></pre><h1 id="e0b0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">10.浏览器客户端应用程序</h1><p id="8dcf" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">运行以下命令，这将从<code class="eh lt lu lv lj b">dist</code>目录中启动<code class="eh lt lu lv lj b"><a class="ae ka" href="https://github.com/webpack/webpack-dev-server" rel="noopener ugc nofollow" target="_blank">webpack-dev-server</a></code>服务资产。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6283" class="ln kc hu lj b fv lo lp l lq lr">$ webpack-dev-server --mode development --content-base dist/</span></pre><p id="90ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后在您的浏览器中导航到<code class="eh lt lu lv lj b">http://localhost:8080</code>并打开开发工具，因为我们将把数据记录到控制台。</p><p id="7188" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在AWS控制台中导航到AppSync API中的<code class="eh lt lu lv lj b">queries</code>页面，并运行另一个graphQL变体来触发更新。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="41d0" class="ln kc hu lj b fv lo lp l lq lr">mutation Message {<br/>    message(to: "Bobby", body: "hello browser!") {<br/>        body<br/>        to<br/>        from<br/>        sentAt<br/>    }<br/>}</span></pre><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lz"><img src="../Images/a89908e643d81932eea00f138f4f6395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GgSt0mYUDsoqtRhh.png"/></div></div></figure><p id="bde7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该会看到更新被记录到浏览器的控制台中。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/07185a2fa543c5acbe8918f598de45fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*6G_xAEfVybZvgpMa.png"/></div></div></figure><h1 id="4427" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">12.结论</h1><p id="700c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们已经用node.js和浏览器客户端建立了一个无服务器的GraphQL API，通过websockets使用实时更新。不到30分钟的工作还不错！</p><p id="78b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然AppSync被宣传为托管GraphQL API服务，但对我来说，它最好的特性是提供实时更新的能力。以前，您必须全天候运行服务器才能做到这一点。现在，您可以获得无服务器的所有成本节约，并且没有管理服务器的任何麻烦。</p><p id="453b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">github上有这个<a class="ae ka" href="https://github.com/techjacker/appsync-realtime-vanillajs" rel="noopener ugc nofollow" target="_blank">无服务器websockets示例</a>的完整源代码。</p><p id="9b3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你有兴趣了解更多关于构建实时无服务器应用的知识，那么请查看我即将推出的培训课程<a class="ae ka" href="https://andrewgriffithsonline.com/training/full-stack-serverless-graphql-appsync" rel="noopener ugc nofollow" target="_blank">AWS app sync上的全栈无服务器GraphQL应用</a>。</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><p id="1a03" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">【andrewgriffithsonline.com】最初发表于<a class="ae ka" href="https://andrewgriffithsonline.com/blog/serverless-websockets-on-aws" rel="noopener ugc nofollow" target="_blank"><em class="mi"/></a><em class="mi">。</em></p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>