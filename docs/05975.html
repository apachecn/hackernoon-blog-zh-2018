<html>
<head>
<title>Collect or not Collect your Java Stream?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">收集还是不收集你的Java流？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/collect-or-not-collect-your-java-stream-733821507ce?source=collection_archive---------6-----------------------#2018-07-19">https://medium.com/hackernoon/collect-or-not-collect-your-java-stream-733821507ce?source=collection_archive---------6-----------------------#2018-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="30ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们一直在探索一些Java APIs，它们如何改变了我们使用这种流行语言的方式，以及如何使用这些新工具编写更好、更高性能的代码。请阅读Java中的<a class="ae jp" href="https://hackernoon.com/finally-functional-programming-in-java-ad4d388fb92e" rel="noopener ugc nofollow" target="_blank"><em class="jq">Finally Functional Programming</em></a><em class="jq"/>和<em class="jq"> </em> <a class="ae jp" href="https://hackernoon.com/a-sad-story-about-concurrency-346990a9a3fe" rel="noopener ugc nofollow" target="_blank"> <em class="jq">关于并发的片段</em> </a> <em class="jq"> </em>了解更多信息。</p><p id="0783" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，有一个特定的API，作为一个组织，我们广泛使用，有时与我们之前讨论过的语言的其他部分结合使用。我们将利用这篇文章来扩展我们之前的<a class="ae jp" href="https://hackernoon.com/a-sad-story-about-concurrency-346990a9a3fe" rel="noopener ugc nofollow" target="_blank"> <em class="jq">文章</em> </a>，同时讨论Stream API的用法以及使用时应该注意的一些问题。</p><p id="30aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从一些代码示例开始，这些示例将使我们对正在讨论的问题有所了解。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="5dd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望我们都能看到这里的问题。每次我们收集流并将其具体化为列表，然后，为了执行下一个操作，我们再次将列表转换为流，只是为了将结果具体化为列表。</p><p id="c7e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于流的主要观点是它们懒惰的本性，这使得它们在处理大到足以溢出内存的连续数据或数据集时非常好。</p><p id="13b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一个问题。这一条也隐含了懒惰的本性。当处理流时，如果不将其具体化，就没有实际的方法知道流的大小，这同时意味着我们实际上永远无法找到它的大小。这听起来可能令人困惑，但是让我们看一个例子。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="ba92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们试图得到它的<code class="eh jy jz ka kb b">.size</code>，你的程序将永远挂起，因为这是一个无界的流。</p><p id="046a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们试图使用一个<code class="eh jy jz ka kb b">Collectors</code>来实现它，也会发生同样的情况，比如:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="2032" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个节目永远不会结束，因为<code class="eh jy jz ka kb b">numbers</code>之流不会结束。</p><p id="3f43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，假设我们可以将流<code class="eh jy jz ka kb b">numbers</code>转换成有界流。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="b7c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们所看到的，即使我们知道流的具体化是可能的，收集它只是为了将它转换回流可能是非常昂贵的。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="e55a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些操作需要在每个<code class="eh jy jz ka kb b">.stream</code>和<code class="eh jy jz ka kb b">.collect</code>反复检查整个流。</p><p id="ff26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至此，我们已经讨论了两个问题，一个是性能问题，这意味着物化和转换回流。应用程序的性能可能会受到影响，并且可能会处理无界的流，这可能会带来陷入永无止境的处理点的风险。</p><p id="3bee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个经验法则，我们不应该在处理链的最后物化流，并且物化应该只发生在我们确定我们的流在这一点上是有界的时候。</p><p id="d3d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在一些代码审查中，我们发现了类似下面的代码片段。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="71f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意我们要检查多少次整个系列。基本上，每个计算阶段至少两次。根据用户数量的大小，这些简单的例子可能会对应用程序的性能产生影响。</p><p id="392c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看如何能做得更好。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jw jx l"/></div></figure><p id="6824" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，现在我们所有的函数都接收并返回流。基本上，每个计算阶段都会将新的流传递到计算的下一步。如果我们仔细想想，直到最后什么都没有实现。因为最后一个迭代是先前流的组合，所以在流上只有最后一个迭代。不过有一个例外。为了分组，流必须被物化，没有别的办法。除此之外，其他所有操作都被延迟执行，直到最后一步，我们才触发这个数据集的物化过程。</p><p id="322f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于性能，还有一些我们应该考虑的因素。因为我们使用流，所以我们可以处理大量的用户，而不用太担心内存消耗，因为我们可能永远不会一次处理整个数据集。当然，我们的最后一个函数<code class="eh jy jz ka kb b">veryInterstingUser</code>并没有利用这一点，但是在现实世界的应用中，我们也可能在这里返回一个流，然后使用这个流而不是<code class="eh jy jz ka kb b">List&lt;&gt;</code>。</p><h2 id="8a03" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">结论</h2><p id="1022" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">Java并发API和流API是非常有趣和强大的工具，我们所有使用Java的人都应该学习如何以负责任的方式使用它们，这样我们才能交付更好、更高性能的应用程序。可能需要一些时间来适应这些新概念，尤其是在开始使用它们的时候，但这只是一个实践和良好工程技术的问题，直到我们成为这些领域的专家。</p><p id="a4eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">享受你的Java:)</p></div></div>    
</body>
</html>