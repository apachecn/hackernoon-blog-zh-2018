<html>
<head>
<title>[Utility Post] STDOUT, STDERR, &amp; Redirection for the Perplexed &amp; Curious</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Utility Post]面向困惑和好奇者的STDOUT、STDERR和重定向</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/utility-post-stdout-stderr-redirection-for-the-perplexed-curious-463dfbe377ee?source=collection_archive---------18-----------------------#2018-07-19">https://medium.com/hackernoon/utility-post-stdout-stderr-redirection-for-the-perplexed-curious-463dfbe377ee?source=collection_archive---------18-----------------------#2018-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6e59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(Psst——如果你很忙，想要一份备忘单，请看这里:<a class="ae jp" href="https://github.com/valgaze/redirection-fun/blob/master/cheatsheet.md" rel="noopener ugc nofollow" target="_blank">https://github . com/valgaze/redirection-fun/blob/master/cheat sheet . MD</a></p><p id="e196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，“重定向”是一种将输出和错误保存到文件(或完全隐藏它们)的方法，而不是它们在屏幕上显示的默认行为。这可能是有用的，因为有时可能希望存储输出/错误日志以供以后分析，而不是让它们在终端上匆匆而过。当使用长时间运行或嘈杂的<a class="ae jp" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>时，重定向也很有用。</p><p id="452d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，如果您想要运行npm install，并将输出保存到一个文件中，将任何错误保存到另一个文件中，只需执行以下操作:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="7f35" class="jz ka hu jv b fv kb kc l kd ke">npm install &gt;npm-log.txt 2&gt;npm-errors.txt</span></pre><p id="bc68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[如果你对重定向和npm感兴趣，请查看配套回购的<strong class="it hv">/示例</strong>目录:<a class="ae jp" href="https://github.com/valgaze/redirection-fun" rel="noopener ugc nofollow" target="_blank">https://github.com/valgaze/redirection-fun</a></p><p id="3908" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者想象有一个叫做“myapp”的工具。如果您对“myapp”一无所知，不知道它的用途、功能或输出，那么对于下面的命令，您有什么可以确定的吗？</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="4e63" class="jz ka hu jv b fv kb kc l kd ke">$ /dev/bin/myapp &gt;logfile.log 2&gt;&amp;1</span></pre><p id="4411" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可能不多，但是如果myapp的行为像大多数其他命令行程序一样(并且您熟悉重定向！)，你至少可以这样说:</p><ul class=""><li id="50c6" class="kf kg hu it b iu iv iy iz jc kh jg ki jk kj jo kk kl km kn dt translated">它的标准输出(如果有)将被写入logfile.log</li><li id="b99f" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated">它的标准错误(如果有的话)也将被写入logfile.log(与标准输出混合在一起)</li></ul><p id="1321" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本说明将解释这意味着什么，为什么会这样，并详细说明如何在终端中执行“重定向”的一些其他示例。</p><p id="60ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想按照示例进行操作，请在命令提示符下键入以下内容:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="61c2" class="jz ka hu jv b fv kb kc l kd ke">git clone <a class="ae jp" href="https://github.com/valgaze/redirect-fun" rel="noopener ugc nofollow" target="_blank">https://github.com/valgaze/redirection-fun</a> redirection-fun &amp;&amp; cd $_</span></pre><h1 id="9c03" class="kt ka hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">流和重定向</h1><p id="282b" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">无论何时在终端中运行一个命令，都可以访问三个“流”:标准输入(stdin)、标准输出(stdout)和标准错误(stderr)</p><p id="8863" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，无论何时您看到运行命令的“好消息”可能来自其stdout(标准输出)流，无论何时您看到任何“坏消息”(错误或警告)，它很可能来自stderr(标准错误。)</p><p id="af91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">默认情况下，一旦命令运行，这些所谓的“标准流”将始终显示在终端中。但是由于这些流是标准化的和明文的(即人类可读的),事实上你可以使用一个非常简单但是强大的语法将它们“重定向”到其他地方。</p><p id="edc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，当您使用<a class="ae jp" href="http://man7.org/linux/man-pages/man1/ls.1.html" rel="noopener ugc nofollow" target="_blank"> "ls "命令</a>时，您将会看到它的输出(即列出个文件的<em class="lv">列表)如预期的那样显示在您的终端中:</em></p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="a733" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun ls</span><span id="b55a" class="jz ka hu jv b fv lw kc l kd ke">1.json  3.json  5.json  README.md<br/>2.json  4.json  6.json  example</span></pre><p id="03e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是因为<strong class="it hv"> STDOUT </strong>流(标准输出)是一个文件列表，STDOUT流默认选择终端作为其目的地。</p><p id="5339" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，如果我们使用重定向，而不是在终端显示，输出可以改为<strong class="it hv"> <em class="lv">重定向</em> </strong> <em class="lv"> </em>到文件<em class="lv"> : </em></p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="fa26" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls 1&gt;output.txt</span></pre><p id="02e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果检查output.txt，您会发现它现在包含我们前面看到的ls命令的标准输出:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="3ff4" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun cat output.txt<br/>1.json<br/>2.json<br/>3.json<br/>4.json<br/>5.json<br/>6.json<br/>README.md<br/>example<br/>output.txt</span></pre><p id="2b91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，stdout不是显示在终端中，而是被“重定向”到output.txt</p><p id="641c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于错误，过程是相同的。如果您键入ls命令并要求它列出一个不存在的目录中的文件(这里是一个不存在的名为“bongo”的目录)，您将得到一个错误:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8952" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun ls bongo/<br/>ls: bongo/: No such file or directory</span></pre><p id="b4a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的错误来自STDERR，和STDOUT一样，默认情况下它的目的地是终端。我们可以使用重定向将其保存到名为“errors.txt”的文件中:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="1b2f" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls bongo/ 2&gt;errors.txt</span></pre><p id="0a51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你检查errors.txt，猜猜你会发现什么？</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ff54" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun cat errors.txt<br/>ls: bongo/: No such file or directory</span></pre><p id="f6a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是重定向的意义所在——将数据从其默认目的地(终端)重定向到其他地方。正如您将在下面看到的，您可以将来自stdout和stderr的数据发送到单个文件、单独的文件，或者完全丢弃它。</p><h1 id="74c2" class="kt ka hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">标准输出</h1><p id="d8f8" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">如果您正在家中进行跟踪(<a class="ae jp" href="https://github.com/valgaze/redirect-fun" rel="noopener ugc nofollow" target="_blank">https://github.com/valgaze/redirection-fun</a>)<strong class="it hv"><em class="lv">，</em> </strong>)，请尝试项目主目录中的以下内容:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ee90" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun ls 1&gt;output.txt</span></pre><p id="5db4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该在屏幕上看不到任何输出，如果您检查output.txt，它将被ls命令的stdout填充(即您的终端中显示的内容)。)</p><p id="434d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">重要提示:</strong>特殊数字1被称为<em class="lv">文件描述符</em>，这里它代表标准输出，在引用stdout时可以安全地删除。以下所有命令与<code class="eh lx ly lz jv b">ls 1&gt;output.txt</code>相同:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="74d4" class="jz ka hu jv b fv kb kc l kd ke">ls 1&gt;output.txt<br/>ls 1&gt; output.txt<br/>ls &gt; output.txt<br/>ls &gt;output.txt</span></pre><p id="ce45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于本说明的其余部分，我们将遵循上面列表中最后一项的语法(没有文件描述符，没有用于stdout的空间。)如果文件output.txt不存在，上面的命令将创建它，如果它存在，将覆盖它。请注意，如果您将文件重定向到特定子目录(例如<code class="eh lx ly lz jv b">ls &gt; /usr/abcd/output.txt</code>)，该子目录必须已经存在，否则该命令将失败。</p><p id="962e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想将<strong class="it hv"> <em class="lv">追加</em> </strong>到一个已存在的文件(不是覆盖)stdout，你可以做如下操作(两个箭头):</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="4c8f" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls &gt;&gt;output.txt</span></pre><p id="d9e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您检查output.txt，您会看到，由于我们运行了该命令两次，标准输出增加了一倍:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ae28" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun cat output.txt<br/>1.json<br/>2.json<br/>3.json<br/>4.json<br/>5.json<br/>6.json<br/>README.md<br/>example<br/>output.txt<br/>1.json<br/>2.json<br/>3.json<br/>4.json<br/>5.json<br/>6.json<br/>README.md<br/>example<br/>output.txt</span></pre><p id="f3f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们知道如何将stdout写入一个文件，并将其附加到一个现有的文件中，但是如果我们想完全摆脱stdout，该怎么办呢？如何运行一个完全没有任何(标准)输出的命令？</p><p id="893e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要丢弃所有的标准输出数据，您应该将命令重定向到位于路径<strong class="it hv"> /dev/null </strong>上的<a class="ae jp" href="https://www.networkworld.com/article/3025497/linux/sending-data-into-the-void-with-dev-null.html" rel="noopener ugc nofollow" target="_blank">“null”设备流</a></p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="60b1" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls &gt;/dev/null</span></pre><p id="8a0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于像ls这样的"<a class="ae jp" href="https://hackernoon.com/tagged/informational" rel="noopener ugc nofollow" target="_blank">信息性的</a>"命令，重定向到/dev/null没有太大意义，但是对于其他命令(尤其是那些长时间运行和/或有噪声输出的命令)，重定向到/dev/null是丢弃流数据的最佳方式。</p><p id="2da9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">概括地说，要重定向stdout，您只需知道:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="0103" class="jz ka hu jv b fv kb kc l kd ke">ls &gt;/dev/tty # redirects to terminal, default behavior</span><span id="d4a1" class="jz ka hu jv b fv lw kc l kd ke">ls &gt;output.txt # redirects stdout to a file, here output.txt</span><span id="79ce" class="jz ka hu jv b fv lw kc l kd ke">ls &gt;&gt;output.txt # appends stdout to a file, here output.txt</span><span id="7250" class="jz ka hu jv b fv lw kc l kd ke">ls &gt;/dev/null # discards stdout entirely by redirecting it to /dev/null</span></pre><h1 id="35d2" class="kt ka hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">标准误差</h1><p id="fd2a" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">标准错误(stderr)类似于stdout，但是如果stdout是大多数“好消息”，那么stderr就是所有的“坏消息”大多数语法是相同的，但是，唯一的变化是stderr的文件描述符(数字2)不能被删除。</p><p id="4f5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要将错误重定向到名为errors.txt的文件，只需运行:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="b448" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls bongo 2&gt;errors.txt</span></pre><p id="7d58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您检查errors.txt，您将得到您的错误:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="599d" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun cat errors.txt<br/>ls: bongo: No such file or directory</span></pre><p id="8866" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这与向现有文件追加内容是一样的:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="abcd" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls bongo 2&gt;&gt;errors.txt</span></pre><p id="a0bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您在追加后检查errors.txt，您将会看到预期的多个条目:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="9f10" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun cat errors.txt<br/>ls: bongo: No such file or directory<br/>ls: bongo: No such file or directory</span></pre><p id="f1ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像使用stdout一样，如果您想完全丢弃stderr(既不在屏幕上显示也不写入文件)，只需将stderr重定向到空设备:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="b4b7" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun ls bongo 2&gt;/dev/null</span></pre><p id="897f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了强制文件描述符(即数字2)之外，重定向标准错误看起来与重定向标准输出非常相似:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="45be" class="jz ka hu jv b fv kb kc l kd ke">ls 2&gt;stderr.txt # Write stderr to file</span><span id="752c" class="jz ka hu jv b fv lw kc l kd ke">ls 2&gt;&gt;stderr.txt # Append errors to file</span><span id="84c4" class="jz ka hu jv b fv lw kc l kd ke">ls 2&gt;/dev/null # Discard stderr entirely</span></pre><h1 id="ebb9" class="kt ka hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">组合标准输出和标准误差</h1><p id="605b" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">通常，您会希望同时捕获stdout和stderr。</p><h2 id="1185" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">简单情况:分离文件(覆盖)</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="2ec6" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun ls &gt;output.txt 2&gt;errors.txt</span></pre><p id="334c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，stdout被重定向到output.txt，stderr被重定向到errors.txt</p><h2 id="46c2" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">简单的情况:单独的文件(追加，不要覆盖)</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="f2e3" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun ls &gt;&gt;output.txt 2&gt;&gt;errors.txt</span></pre><p id="00ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像上面一样，stdout和stderr被<em class="lv">附加到它们新的目标文件的末尾</em>。</p><h2 id="9ef7" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">更棘手的情况:相同的文件(覆盖)</h2><p id="1e16" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">如果您希望stdout和stderr共享同一个文件，有多种方法。一种方法是使用“&amp;num”语法“复制”流。首先重定向stdout，然后通过使用&amp;符号和数字指示stderr去stdout要去的地方，将stderr重定向到相同的目的地，例如:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="4cc1" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls &gt;shared-output.txt 2&gt;&amp;1</span></pre><p id="0733" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，stdout (1)被重定向到<em class="lv"> output.txt </em>，stderr (2)被重定向到stdout要去的任何地方(在本例中是output.txt)</p><p id="c4d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，下面的结果与上面的结果相同:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="1f70" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls 2&gt;shared-output.txt &gt;&amp;2</span></pre><p id="40ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，stderr (2)首先被重定向到<strong class="it hv"> shared-output.txt </strong>，然后stdout (1)被重定向到stderr的目的地，因此它也转到<strong class="it hv"> shared-output.txt </strong></p><p id="cd61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想使用此语法将<strong class="it hv">追加</strong> stdout和stderr到同一个文件，您可以执行以下任一操作:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e045" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls &gt;&gt;shared-output.txt 2&gt;&amp;1</span><span id="1d4f" class="jz ka hu jv b fv lw kc l kd ke">😎  ~/redirection-fun ls 2&gt;&gt;shared-output.txt &gt;&amp;2</span></pre><p id="9940" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第一个命令中，stdout (1)在追加模式(两个箭头)下被重定向到<strong class="it hv"> shared-output.txt </strong>，stderr (2)跟在stdout后面，因此它也被重定向到<strong class="it hv"> shared-output.txt </strong>。在第二个命令中，逻辑完全相同，但是，stdout (1)跟随stderr)的前导。</p><p id="a005" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一种将stdout和sterr重定向到空设备的“可移植”方法(即将它们放入垃圾桶)，您可以编写如下代码:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="353e" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls &gt;/dev/null 2&gt;&amp;1</span></pre><h2 id="eb92" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">危险:秩序很重要！</h2><p id="ce35" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">将stdout和stderr组合到同一个目标顺序时，顺序很重要。例如，如果我们打算让stdout和stderr共享一个名为<strong class="it hv"> shared-output-2.txt </strong>的文件，下面的命令将会失败:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="9533" class="jz ka hu jv b fv kb kc l kd ke">😎 ~/redirection-fun ls &gt;&amp;2 2&gt;shared-output-2.txt</span><span id="623a" class="jz ka hu jv b fv lw kc l kd ke"># This first command would fail and in fact displays stdout on the screen when run. The reason is that since order matters, stdout (1) copies stderr’s <strong class="jv hv">initial default destination </strong>(the terminal or /dev/tty) and then stderr (2) is redirected to <strong class="jv hv">shared-output-2.txt</strong>. Stdout was copying stderr's first destination (the terminal, it's default) and not it's final redirected destination (the file shared-output2.txt)</span><span id="765d" class="jz ka hu jv b fv lw kc l kd ke">😎 ~/redirection-fun ls 2&gt;&amp;1 &gt;shared-output-2.txt</span><span id="ba16" class="jz ka hu jv b fv lw kc l kd ke"># This command would <strong class="jv hv">not</strong> redirect stderr to <strong class="jv hv">shared-output-2.txt</strong>. Going in order, stderr (2) is redirected to stdout's initial destination (/dev/tty or terminal) and only later is stdout (1) redirected to shared-output-2.txt</span></pre><p id="f5e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">概括地说，重定向stdout和stderr流…</p><h2 id="62ff" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">不同的目的地:</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="bff5" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls &gt;output.txt 2&gt;errors.txt<br/>😎  ~/redirection-fun ls &gt;&gt;output.txt 2&gt;&gt;errors.txt # (no overwrite)</span></pre><h2 id="2a50" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">相同目的地:</h2><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="37ce" class="jz ka hu jv b fv kb kc l kd ke">😎  ~/redirection-fun ls &gt;shared-output.txt 2&gt;&amp;1<br/>😎  ~/redirection-fun ls 2&gt;shared-output.txt 1&gt;&amp;2<br/>😎  ~/redirection-fun ls &gt;&gt;shared-output.txt 2&gt;&amp;1 # (no overwrite)<br/>😎  ~/redirection-fun ls &gt;/dev/null 2&gt;&amp;1</span></pre><h1 id="f606" class="kt ka hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">标准输入(stdin)和管道</h1><h2 id="84af" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">标准输入(标准输入)</h2><p id="3f59" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">像stdout和stderr一样，标准输入(stdin)也是一种抽象，数据是如何生成的或来自哪里的细节并不重要。例如，程序的标准输入通常来自键盘等来源，但是重定向标准输入可以使命令的输入来自文件:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e120" class="jz ka hu jv b fv kb kc l kd ke">command &lt; file</span></pre><p id="768d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，如果您想列出名称中包含“json”的文件，您可以运行以下两个命令:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="5c64" class="jz ka hu jv b fv kb kc l kd ke">ls &gt;files.txt # stdout to files.txt<br/>grep json &lt; files.txt # stdin to grep is from files.txt</span></pre><p id="2e7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里<code class="eh lx ly lz jv b">ls</code>列出了当前的文件/文件夹，而不是终端上显示的stdout，stdout被重定向到files.txt。在下一个命令中，我们运行<code class="eh lx ly lz jv b">grep json</code>并将stdin重定向到grep。我们没有重定向<code class="eh lx ly lz jv b">grep</code>的stdout，所以当它运行时，会在终端中显示文件名中带有json的文件列表(如果有的话)。</p><h2 id="66cd" class="jz ka hu bd ku ma mb mc ky md me mf lc jc mg mh lg jg mi mj lk jk mk ml lo mm dt translated">平静的</h2><p id="0408" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">管道非常类似于重定向到stdout，但是管道不是写入文件，而是将stdout作为stdin重定向到另一个程序。</p><p id="8b5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们不是用两个命令编写上面的代码，而是通过管道完成同样的事情:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="2b4b" class="jz ka hu jv b fv kb kc l kd ke">ls | grep json</span><span id="11dc" class="jz ka hu jv b fv lw kc l kd ke">😎  ~/redirection-fun ls grep | json<br/>1.json<br/>2.json<br/>3.json<br/>4.json<br/>5.json<br/>6.json</span></pre><p id="1195" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lx ly lz jv b">ls</code>命令列出了文件，然后它的stdout作为stdin <code class="eh lx ly lz jv b">grep json</code>被“传输”过来，后者的stdout没有被重定向，所以它显示在终端中。</p><h1 id="d5f7" class="kt ka hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">有趣的例子:tweet上的可启动Live-CD</h1><p id="ea73" class="pw-post-body-paragraph ir is hu it b iu lq iw ix iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo hn dt translated">安全工程师Alok Menghrajan编写了一个小到可以压缩到280个字符的命令，为一个复古的计算机游戏生成一个可引导的live-cd:</p><figure class="jq jr js jt fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="07ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个命令本身有点混乱，但是如果你想当然地认为<a class="ae jp" href="https://www.quaxio.com/bootable_cd_retro_game_tweet/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Alok出色的Perl技巧</strong> </a>，它只是管道化和重定向:Perl命令输出被管道化为一个base64编码的命令，然后base64操作的STDOUT被重定向到cd.iso文件——非常漂亮:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ef21" class="jz ka hu jv b fv kb kc l kd ke">$ perl -E "ALOKS_PERL_TRICK" | base 64 -D &gt;cd.iso</span></pre><p id="a4fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">应该可以了，快乐重定向！</p><h1 id="8b88" class="kt ka hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">进一步阅读</h1><ul class=""><li id="f530" class="kf kg hu it b iu lq iy lr jc mq jg mr jk ms jo kk kl km kn dt translated"><a class="ae jp" href="http://www.linfo.org/standard_output.html" rel="noopener ugc nofollow" target="_blank">http://www.linfo.org/standard_output.html</a></li><li id="7045" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated">http://www.linfo.org/output_redirection_operator.html<a class="ae jp" href="http://www.linfo.org/output_redirection_operator.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="af7d" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated">【http://wiki.bash-hackers.org/howto/redirection_tutorial T4】</li><li id="105d" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated"><a class="ae jp" href="https://ryanstutorials.net/linuxtutorial/piping.php" rel="noopener ugc nofollow" target="_blank">https://ryanstutorials.net/linuxtutorial/piping.php</a></li><li id="7492" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated"><a class="ae jp" href="https://www.networkworld.com/article/3025497/linux/sending-data-into-the-void-with-dev-null.html" rel="noopener ugc nofollow" target="_blank">https://www . network world . com/article/3025497/Linux/sending-data-into-the-void-with-dev-null . html</a></li><li id="2874" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated"><a class="ae jp" href="http://www.informit.com/articles/article.aspx?p=2854374&amp;seqNum=5" rel="noopener ugc nofollow" target="_blank">http://www.informit.com/articles/article.aspx?p=2854374&amp;序列号=5 </a></li><li id="3808" class="kf kg hu it b iu ko iy kp jc kq jg kr jk ks jo kk kl km kn dt translated"><a class="ae jp" href="https://www.quaxio.com/bootable_cd_retro_game_tweet/" rel="noopener ugc nofollow" target="_blank">https://www.quaxio.com/bootable_cd_retro_game_tweet/</a></li></ul><figure class="jq jr js jt fq mn"><div class="bz el l di"><div class="mt mp l"/></div></figure></div></div>    
</body>
</html>