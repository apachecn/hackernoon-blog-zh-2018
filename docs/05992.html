<html>
<head>
<title>Testing chained promises with jest in react-native using mock-data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模拟数据在react-native中用jest测试连锁承诺</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-chained-promises-with-jest-in-react-native-using-mock-data-a6bd868fee1e?source=collection_archive---------23-----------------------#2018-07-19">https://medium.com/hackernoon/testing-chained-promises-with-jest-in-react-native-using-mock-data-a6bd868fee1e?source=collection_archive---------23-----------------------#2018-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a384" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我正在为我的react本地应用程序开发登录屏幕，并把google-sign-in作为选项。该逻辑包含嵌套承诺，并且是使用链式承诺构建的。</p><p id="0e76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开发代码很容易，但是当我开始为这个逻辑编写单元测试用例时，我真的大吃一惊。我找不到任何好的文档来处理这种情况，尽管在这个过程中很少有<a class="ae jp" href="https://stackoverflow.com/questions/36400623/test-promise-chain-with-jest" rel="noopener ugc nofollow" target="_blank">例子</a>有所帮助</p><p id="b70c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">jest团队为异步代码提供的<a class="ae jp" href="https://jestjs.io/docs/en/tutorial-async" rel="noopener ugc nofollow" target="_blank">文档</a>适用于单个承诺。代码结构见<a class="ae jp" href="https://github.com/facebook/jest/tree/master/examples/async" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/jest/tree/master/examples/async</a>。</p><p id="8850" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在阅读了文档之后，我认为缺少了一些东西</p><ol class=""><li id="bc27" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">它说<code class="eh jz ka kb kc b"> __mocks__</code>文件夹应该和要测试的文件在同一个文件夹中。</li><li id="05e4" class="jq jr hu it b iu kd iy ke jc kf jg kg jk kh jo jv jw jx jy dt translated">它要求将待测试的函数相对导入到测试文件夹中。</li></ol><p id="3372" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这对于相对导入来说很好，但是我的代码是通过修改。<code class="eh jz ka kb kc b">babelrc</code>文件。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="dd45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是我的文件夹结构:-</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="3442" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我喜欢将测试分开，所以我创建了一个单独的<code class="eh jz ka kb kc b">__tests__ </code>文件夹。</p><p id="4b81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果我按照上面提到的jest的要求，我必须在一个特定的屏幕中创建一个名为<code class="eh jz ka kb kc b">__mocks__</code>的文件夹。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="8579" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了使这个工作，现在我必须从<code class="eh jz ka kb kc b">__mocks__</code>相对导入到<code class="eh jz ka kb kc b">__tests__/tests/screens/Auth</code>。我试过了，效果很好。但是由于我的整个项目都使用绝对导入，所以我不想专门为此添加相对导入。</p><p id="493f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我做了一些小的调整，以使这个工作使用绝对进口。</p><p id="d29d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以让我们开始吧。</p><p id="f698" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们先看看<code class="eh jz ka kb kc b">Auth.container.js</code>代码，看看业务逻辑是如何实现的。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="d73f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在按钮onPress上，我调用该组件中的函数<code class="eh jz ka kb kc b">onPress</code>，该函数执行以下操作:-</p><ol class=""><li id="d16e" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">使用<a class="ae jp" href="https://github.com/joonhocho/react-native-google-sign-in" rel="noopener ugc nofollow" target="_blank">react-native-google-sign-in</a>向Google认证并返回<code class="eh jz ka kb kc b">email</code>、<code class="eh jz ka kb kc b">idToken</code>和<code class="eh jz ka kb kc b">status</code>。</li></ol><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="4b03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你愿意，我已经在这个文件中添加了<code class="eh jz ka kb kc b">TEST_authorizeGoogle</code>,我会在测试代码中谈到它。对于现在刚刚结账的<code class="eh jz ka kb kc b">authorizeUser</code>功能。</p><p id="43c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.用生成的<code class="eh jz ka kb kc b">email</code>和<code class="eh jz ka kb kc b">idToken</code>调用我的后端，为用户生成一个新的<code class="eh jz ka kb kc b">accessToken</code>，并让他(或她)登录。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="3db5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在再次忽略<code class="eh jz ka kb kc b">TEST_setLoginGoogle</code>。</p><p id="990c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们看看实际的测试案例。</p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="ae1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我从本地创建的<code class="eh jz ka kb kc b">mocks</code>文件夹中导入了模拟。</p><p id="d252" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我使用<code class="eh jz ka kb kc b">TEST_setAuthorizeGoogle</code>覆盖函数<code class="eh jz ka kb kc b">authorizeGoogle</code>，使用<code class="eh jz ka kb kc b">TEST_setLoginGoogle</code>登录Google。这样做是因为在ES6中，命名导出总是常量。查看<a class="ae jp" href="https://stackoverflow.com/a/48173881/2485624" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</p><p id="e7bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我在上面代码的第54行测试第二个承诺的调用是否带有第一个承诺的结果。</p><p id="2262" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，我在第55行测试最终数据是否与服务器返回的模拟数据相同。</p><p id="be86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这种方式，我能够分离测试文件夹，并使用绝对导入来测试我的组件的连锁承诺。</p><p id="9593" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">欢迎反馈！！干杯！！</p></div></div>    
</body>
</html>