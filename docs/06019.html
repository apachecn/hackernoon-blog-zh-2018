<html>
<head>
<title>So I still can’t run my Node.js 10 code on AWS Lambda, or can I?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所以我还是不能在AWS Lambda上运行我的Node.js 10代码，是吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/so-i-still-cant-run-my-node-js-10-code-on-aws-lambda-or-can-i-d2a9e8b1eeec?source=collection_archive---------4-----------------------#2018-07-21">https://medium.com/hackernoon/so-i-still-cant-run-my-node-js-10-code-on-aws-lambda-or-can-i-d2a9e8b1eeec?source=collection_archive---------4-----------------------#2018-07-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6b00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个非常普通的工作日，在办公室里，我听到我的同事默默地抱怨，他希望他能在他的AWS Lambda代码中使用async/await JS语言特性。不好的是那个时候(2018年3月)你只能在Lambda上运行Node.js 4和6代码。好消息是Node.js 8支持很快被引入Lambda(那是2018年4月的2^nd ),看起来这个问题已经消失了。但随后Node.js 10几乎立即推出(2018年4月，24^th ),推出了另一组有吸引力的语言和运行时功能，如ECMAScript模块或工作线程。这次Lambda支持Node.js 10还要等多久？等等——看起来已经有办法在Lambda中使用Node.js 10了。让我带你去那里。</p><h1 id="3f3a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">巴别塔不就是答案吗？</h1><p id="d3d8" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Babel是一个伟大的项目，它支持最新的JS语言技巧，比如前面提到的ECMAScript模块。要使用它，你要为Node.js 10写一些代码，然后让Babel把它转换成当前Lambda能理解的东西。突然你意识到这并不容易。</p><p id="4dea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一段使用async/await的代码:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="eee2" class="lb jq hu kx b fv lc ld l le lf">const { map } = require('async');</span><span id="4151" class="lb jq hu kx b fv lg ld l le lf">const someFunction = async (users) =&gt; {<br/>  const start = new Date();<br/>  const results = await promisify(map)(users, (async user =&gt; {<br/>    const promisedUser = await Promise.resolve(user);<br/>    ...<br/>    return something;<br/>  }));<br/>  return new Date() - start;<br/>}</span></pre><p id="8f3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">传输后，<code class="eh lh li lj kx b">start</code>变量被放入<code class="eh lh li lj kx b">async call</code>函数范围，并且对于<code class="eh lh li lj kx b">new Date() — start</code>表达式不可达。transpiled代码还有更多类似的问题——非常类似于上面讨论的问题，有些只与async/await有关。我同意通过牺牲一些语法上的好处来克服所有这些问题是可能的。就我个人而言，每次我被迫这样做时，我都感觉很糟糕。</p><h1 id="aceb" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">救援的第三方模块</h1><p id="a356" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我现在应该谈论在Lambda上启动Node.js 10，然而，为了完成有人想要这样做的可能原因的列表，我必须简要地提到第三方模块。我的意思是，HTTP/2是Node.js 10的顶级特性之一，然而，第三方HTTP/2模块已经存在5年了。还有第三方模块可以覆盖工作线程或保证你的回调函数。另一方面，从长远来看，现在选择其中一个模块可能不是一个好的决定。最后，只有最新的Node.js版本才可能需要使用最新的V8或libuv版本。</p><h1 id="986a" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">而不是那个幼稚的Node.js子进程</h1><p id="aa1f" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">因此，让我们最后来看一下我之前尝试在Lambda中生成子进程的要点。例如，我可以在Lambda的子进程中启动Headless Chromium。当然，这种方法的问题是Chromium二进制文件的大小超过50 MB(不适合Lambda部署包)，所以一旦Lambda函数启动，它就必须从S3下载二进制文件，这意味着整个过程变得很慢。更不用说铬工艺要消耗几百MB内存。好的一面是Node.js不是Chromium，它看起来可能与Chromium不同，足以在子进程中高效运行。</p><p id="5795" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Node.js很小。它的压缩大小小于10 MB。在Lambda术语中，有超过40 MB的空间留给你的代码(Lambda包的限制是50 MB)。</p><p id="2a4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Node.js起步快。我找不到任何好的资料来支持这种说法，但从少量的<a class="ae lk" href="https://nodejs.org/dist/latest-v8.x/docs/api/" rel="noopener ugc nofollow" target="_blank">核心模块</a>和广泛使用的第三方模块如<code class="eh lh li lj kx b"><a class="ae lk" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank">nodemon</a></code>来看，这应该是显而易见的。用Lambda术语来说:新进程一启动，我的JS代码就被执行。</p><p id="b06c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Node.js只消耗运行应用程序所需的内存。如果应用程序很小—内存消耗很小。我在我的Linux机器上运行了<code class="eh lh li lj kx b">node</code>命令(打开Node.js shell ),它消耗了7.5 MB。用Lambda术语来说:7.5 MB与你的函数可以分配的最小内存量(128 MB)相比并不算多。</p><p id="d6ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们把和平结合在一起:</p><ol class=""><li id="f963" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">Node.js 10与您的js代码捆绑在一起，成为一个Lambda部署包。</li><li id="7d5e" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">在最初执行Lambda函数时，会产生一个子进程来启动捆绑的Node.js 10运行时。</li><li id="dd3e" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">Node.js 10子进程执行你的js代码。</li></ol><p id="85ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我敢肯定，相当多的Lambda粉丝已经想到了这个想法，但是，我在网上找不到任何形式的这个想法(确切地说是NPM)。因此，我很自豪地向您介绍一个名为<code class="eh lh li lj kx b">lambda-node-runtime</code>的开源NPM模块。</p><div class="lz ma fm fo mb mc"><a href="https://www.npmjs.com/package/lambda-node-runtime" rel="noopener  ugc nofollow" target="_blank"><div class="md ab ej"><div class="me ab mf cl cj mg"><h2 class="bd hv fv z el mh eo ep mi er et ht dt translated">λ-节点-运行时</h2><div class="mj l"><h3 class="bd b fv z el mh eo ep mi er et ek translated">在AWS Lambda上运行任何节点版本</h3></div><div class="mk l"><p class="bd b gc z el mh eo ep mi er et ek translated">www.npmjs.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq mr mc"/></div></div></a></div><p id="4337" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的模式总结了<code class="eh lh li lj kx b">lambda-node-runtime</code>的架构。它充当代理，使用IPC和通过stdin、stdout和stderr通道的所有I/O流量(Lambda在Linux环境中运行您的代码)，将处理程序函数调用传递到您的Node.js 10代码。由于代理的透明性，你的代码感觉像是由Lambda直接运行的。</p><figure class="ks kt ku kv fq mt fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/1041c1ff3d9110273f88125720996bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*E2oiSRqL1bikYXbyrFjVRg.png"/></div><figcaption class="mv mw fg fe ff mx my bd b be z ek">lambda-node-runtime spawns a Node.js 10 child process and proxies handler function invocation (via IPC) and all I/O transparently</figcaption></figure><p id="9d6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请随意在<a class="ae lk" href="https://www.npmjs.com/package/lambda-node-runtime" rel="noopener ugc nofollow" target="_blank"> README.md </a>或源代码(真的没有那么多)中找到所有具体细节，以了解Lambda函数的适用性。有一些事情你需要知道，所以<a class="ae lk" href="https://www.npmjs.com/package/lambda-node-runtime#benchmarks" rel="noopener ugc nofollow" target="_blank">基准</a>部分讨论了在你的Lambda函数中使用模块的一些含义。</p><h1 id="c8ba" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">它有前途吗？</h1><p id="3ae5" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">Node.js 10最终会来到Lambda，所以请所有等待的人(最新的LTS Node.js版本的介绍是在连续两年的4月进行的，所以很有可能在明年4月在Lambda中看到Node.js 10)。矛盾的是，JS语言发展很快，因此Node.js不断发布新版本。看来Lambda的粉丝将不得不一次又一次地在Lambda“门口”排队等待最新的Node.js版本。直到事情稳定下来。在等待的同时，让我们看看Lambda用户是否会发现<code class="eh lh li lj kx b">lambda-node-runtime</code>模块有用。</p></div></div>    
</body>
</html>