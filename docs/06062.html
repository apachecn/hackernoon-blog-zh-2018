<html>
<head>
<title>Serverless and Lambdaless Scalable CRUD Data API with AWS API Gateway and DynamoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有AWS API网关和DynamoDB的无服务器和无内存的可扩展CRUD数据API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-and-lambdaless-scalable-crud-data-api-with-aws-api-gateway-and-dynamodb-626161008bb2?source=collection_archive---------3-----------------------#2018-07-23">https://medium.com/hackernoon/serverless-and-lambdaless-scalable-crud-data-api-with-aws-api-gateway-and-dynamodb-626161008bb2?source=collection_archive---------3-----------------------#2018-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ceea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在现代微服务架构中，当与其他系统(如可视化、用户界面，甚至与其他第三方集成)共享数据时，通常会创建RESTful数据服务应用编程接口(API)。在创建、维护和监控此类系统时，需要考虑许多架构、基础设施和开发复杂性。此外，您需要考虑成本以及API和数据存储的可伸缩性。</p><p id="9a95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们正在从难以扩展到微服务架构的大型复杂整体架构中脱离出来。例如，您可以拥有一个松散耦合的微服务群，每个微服务都有一个针对每个数据源的API，并与集群化的NoSQL数据库(如Cassandra)集成。采用微服务架构通常意味着您需要一个DevOps团队，例如，设置、监控和维护持续集成/持续部署(CI/CD)管道、<a class="ae jp" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>容器编排平台和监控系统。随着AWS宣布<a class="ae jp" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank">亚马逊弹性容器服务用于Kubernetes (EKS) </a>和<a class="ae jp" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> AWS Fargate </a>帮助Kubernetes，事情看起来越来越好，但仍有许多集成需要开发者和容器配置来考虑。</p><p id="991e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">早在2014年，AWS就推出了Lambda函数，它充当服务之间的集成粘合剂，您只需编写业务逻辑代码来响应入站事件。这些事件可能是来自API Gateway的GET请求、添加到Kinesis流的新记录或放入S3的对象。使用Lambda非常流行，因为它们是无状态的，有内置的事件源集成，你只需为每100毫秒的执行时间付费。因此，你可以构建一个高度可扩展的无服务器堆栈，集成API Gateway、Lambda和DynamoDB，而不是使用运行在容器上的一群微服务。有很多关于这方面的教程，包括我的第一个视频课程。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/6531d642c1f44e34ba173e9faa29a061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owiAJxxzOe__oy99BmoUzQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Serverless &amp; Lambdaless RESTful Data API</figcaption></figure><p id="051e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇博文中，我将向您展示如何完全放开Lambda，让API Gateway直接调用DynamoDB，以创建一整套创建、读取、更新和删除(CRUD)操作。我读过的其他帖子只涉及如何在AWS控制台中手动完成部分工作，而不是用代码使用<a class="ae jp" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank">斯瓦格</a>和<a class="ae jp" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank">萨姆</a>，这就是我将在这里向你展示的。使用Swagger和SAM部署基础设施和API实际上是您绝对想做的事情，以便将其发布到生产环境中，从而最大限度地减少人为错误、可重复性和可伸缩性。</p><h1 id="7cca" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">概观</h1><p id="5140" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我假设你已经有了一个<a class="ae jp" href="https://aws.amazon.com/free/" rel="noopener ugc nofollow" target="_blank"> AWS帐户设置</a>并且已经安装了<a class="ae jp" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html" rel="noopener ugc nofollow" target="_blank">AWS CLI</a>。我使用Ubuntu bash和一些shell脚本，对于<a class="ae jp" href="https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/" rel="noopener ugc nofollow" target="_blank"> Windows 10用户安装Linux Bash Shell </a>注意在Linux 中运行脚本时需要删除的<a class="ae jp" href="https://www.qualitestgroup.com/resources/knowledge-center/how-to-guide/remove-windows-carriage-returns-text-files-linux/" rel="noopener ugc nofollow" target="_blank"> Windows回车。</a></p><p id="909b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我首先使用AWS CLI创建环境变量和带有策略的IAM角色。我这样做是为了即使我删除了CloudFormation堆栈，它们也能保留在原来的位置，并且可以被其他API重用。然后，我构建一个SAM模板来创建一个DynamoDB表和POST、PUT、GET和DELETE API方法，我通过CloudFormation部署这些方法。最后，我测试API方法，以确保它们按预期工作。</p><h1 id="6894" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">创建变量</h1><p id="dcab" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">首先，让我们创建一个包含您的环境特定细节的<code class="eh lj lk ll lm b">common-variables.sh</code>。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="b789" class="lr kh hu lm b fv ls lt l lu lv">#!/bin/sh<br/>export profile="demo"<br/>export region="eu-west-1"<br/>export aws_account_id="000000000000"<br/>export template="apigateway-dynamo"</span></pre><p id="d0ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些将用于我稍后运行的AWS CLI命令。</p><h1 id="884b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">安全性创建IAM角色和策略</h1><p id="7ac6" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">为了让API Gateway将日志推送到CloudWatch并访问DynamoDB，您需要创建一个具有两个策略的角色。您可以在AWS控制台或AWS CLI中完成此操作。我已经使用AWS CLI在代码中完成了它，这是我推荐的可重复性和避免错误的方法。此外，您永远不知道是否有人错误地删除了策略，然后您需要追溯您的JSON策略步骤，如果您有100多个策略，并且在实时系统的压力下，这不是您想要做的事情！</p><p id="03b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们调用API网关角色<code class="eh lj lk ll lm b">api-gateway-dynamo-full-user-vists</code>，使用信任关系创建角色，然后为cloudWatch附加服务角色，然后创建DynamoDB角色并附加它。</p><p id="d203" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经创建了一个shell脚本，你可以调用<code class="eh lj lk ll lm b">./create-role.sh</code>，确保你运行<code class="eh lj lk ll lm b">chmod + x</code>使其可执行。以下是脚本的内容</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="b921" class="lr kh hu lm b fv ls lt l lu lv">#!/bin/sh<br/>. ./common-variables.sh<br/><br/>#Setup API Gateway Role<br/>role_name=api-gateway-dynamo-full-user-comments<br/>aws iam create-role --role-name ${role_name} \<br/>    --assume-role-policy-document file://../../IAM/assume-role-api-gateway.json --profile $profile<br/><br/>#Add Policy for API Gateway to write to logs<br/>role_policy_arn="arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"<br/>aws iam attach-role-policy \<br/>    --role-name "${role_name}" \<br/>    --policy-arn "${role_policy_arn}"  --profile ${profile}<br/><br/>#Create DynamoDB Policy<br/>policy_name="dynamo-full-user-visits-api"<br/>aws iam create-policy --policy-name ${policy_name} --policy-document file://../../IAM/dynamo-full-user-comments.json --profile ${profile}<br/><br/>#Attach Policy for API Gateway to access DynamoDB<br/>role_policy_arn="arn:aws:iam::${aws_account_id}:policy/${policy_name}"<br/>aws iam attach-role-policy \<br/>    --role-name "${role_name}" \<br/>    --policy-arn "${role_policy_arn}"  --profile ${profile}</span></pre><p id="0a6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lj lk ll lm b">assume-role-api-gateway.json</code>信任关系。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="40fa" class="lr kh hu lm b fv ls lt l lu lv">{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Sid": "",<br/>      "Effect": "Allow",<br/>      "Principal": {<br/>        "Service": "apigateway.amazonaws.com"<br/>      },<br/>      "Action": "sts:AssumeRole"<br/>    }<br/>  ]<br/>}</span></pre><p id="998c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lj lk ll lm b">dynamo-full-user-comments.json</code>允许API网关完全CRUD访问DynamoDB表</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="e1a3" class="lr kh hu lm b fv ls lt l lu lv">{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Sid": "Stmt1422032676021",<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "dynamodb:DeleteItem",<br/>                "dynamodb:DescribeTable",<br/>                "dynamodb:GetItem",<br/>                "dynamodb:PutItem",<br/>                "dynamodb:Query",<br/>                "dynamodb:Scan",<br/>                "dynamodb:UpdateItem"<br/>            ],<br/>            "Resource": [               "arn:aws:dynamodb:eu-west-1:000000000000:table/user-comments-api-sam"]<br/>        },<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": "dynamodb:ListTables",<br/>            "Resource": "*",<br/>            "Condition": {}<br/>        }<br/>    ]<br/>}</span></pre><p id="37e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我有一个shell脚本，您可以用<code class="eh lj lk ll lm b">./create-role.sh</code>调用它，它运行所有这些脚本来设置IAM角色和策略。</p><h1 id="1a3d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">创建参数和DynamoDB表</h1><p id="649c" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">创建一个名为<code class="eh lj lk ll lm b">apigateway-dynamo.yaml</code>的YAML模板文件，我们将添加参数、DynamoDB配置和稍后的API方法。下面是一组参数:。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="0350" class="lr kh hu lm b fv ls lt l lu lv">Parameters:<br/>  Table: {Default: user-comments-api-sam, Type: String}  <br/>  AccountId: {Default: 000000000000, Type: String}<br/>  RoleName: {Default: api-gateway-dynamo-full-user-comments, Type: String}</span></pre><p id="64b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后让我们使用SAM创建一个DynamoDB表，并将其命名为<code class="eh lj lk ll lm b">user-comments-api-sam</code>,我将在脚本中将其作为参数重用。然后，我使用服务器端加密和名为<code class="eh lj lk ll lm b">PageId</code>的散列或主键创建表，并将读写吞吐量设置为1。我这样做是为了将它保留在<a class="ae jp" href="https://aws.amazon.com/free/#software" rel="noopener ugc nofollow" target="_blank">空闲层</a>中，但是您可以根据需要轻松地进行更改。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="e09d" class="lr kh hu lm b fv ls lt l lu lv">Resources:<br/>  DynamoDBTable:<br/>    Type: AWS::DynamoDB::Table<br/>    Properties: <br/>      TableName: !Ref Table<br/>      SSESpecification: <br/>        SSEEnabled: True<br/>      AttributeDefinitions: <br/>        - AttributeName: PageId<br/>          AttributeType: S<br/>      KeySchema: <br/>        - AttributeName: PageId<br/>          KeyType: HASH<br/>      ProvisionedThroughput: <br/>        ReadCapacityUnits: 1<br/>        WriteCapacityUnits: 1</span></pre><h1 id="e02f" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">PUT方法</h1><p id="c65e" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">让我们从使用API的PUT方法向DynamoDB添加一些JSON数据开始。我正在使用<code class="eh lj lk ll lm b">Type: AWS::Serverless::Api</code>来定义一组Amazon API网关资源和方法，它们可以通过HTTPS端点来调用。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="516e" class="lr kh hu lm b fv ls lt l lu lv">MyApi:<br/>    Type: AWS::Serverless::Api<br/>    Properties:<br/>        StageName: Prod<br/>        DefinitionBody:<br/>            swagger: 2.0<br/>            info:<br/>              title:<br/>                Ref: AWS::StackName<br/>            paths:<br/>              "/visits":<br/>                put:<br/>                  consumes:<br/>                    - "application/json"<br/>                  produces:<br/>                    - "application/json"<br/>                  responses:<br/>                    "200":<br/>                      description: "200 response"<br/>                      schema:<br/>                        $ref: "#/definitions/Empty"<br/>                  x-amazon-apigateway-integration:<br/>                    httpMethod: POST<br/>                    type: AWS<br/>                    uri: { "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:dynamodb:action/PutItem" }<br/>                    credentials: { "Fn::Sub": "arn:aws:iam::${AccountId}:role/${RoleName}" }<br/>                    requestTemplates:<br/>                      application/json: { 'Fn::Sub': "{ \n\<br/>                      \t\"TableName\": \"${Table}\",\n\<br/>                      \t\"Item\": {\n\<br/>                      \t\t\"PageId\": {\n\<br/>                      \t\t\t\"S\": \"$input.path('$.PageId')\"\n\<br/>                      \t\t},\n\<br/>                      \t\t\"EventCount\": {\n\<br/>                      \t\t\t\"N\": \"$input.path('$.EventCount')\"\n\<br/>                      \t\t},\n\<br/>                      \t\t\"Message\": {\n\<br/>                      \t\t\t\"S\": \"$input.path('$.Message')\"\n\<br/>                      \t\t}\n<br/>                      \t}\n}" }<br/>                    responses:<br/>                      default:<br/>                        statusCode: "200"</span></pre><p id="6222" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我为区域使用了像<code class="eh lj lk ll lm b">${AWS::Region}</code>这样的内置变量，但是也使用了之前在脚本顶部指定的参数。</p><p id="a81c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我遵循PUT约定，使它幂等，这意味着如果你多次调用它，它将导致相同的操作。这里我们将简单地用传递的JSON主体覆盖现有的行。我使用<code class="eh lj lk ll lm b">PutItem</code>动作来做这件事，你可以在<code class="eh lj lk ll lm b">requestTemplates</code>中看到我解析JSON并将它们映射到DynamoDB键和值。然后将键和值放入DynamoDB表<code class="eh lj lk ll lm b">${Table}</code>，使用脚本<code class="eh lj lk ll lm b">Table: {Default: user-comments-api-sam, Type: String}</code>顶部的参数用<code class="eh lj lk ll lm b">user-comments-api-sam</code>替换。你还会注意到<code class="eh lj lk ll lm b">\t</code>和<code class="eh lj lk ll lm b">\n</code>已经被重新格式化，以便更容易理解。</p><h1 id="3ac2" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">获取方法</h1><p id="21c8" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在我有了一些数据，我想从DynamoDB中检索它。我使用一个GET方法，允许您从DynamoDB中获取指定的数据。与PUT方法不同，我使用resourceId而不是JSON主体来完成这项工作。这里我将<code class="eh lj lk ll lm b">{PageId}</code>作为URL参数传递给API Gateway。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="51be" class="lr kh hu lm b fv ls lt l lu lv">            paths:<br/>              "/visits/{PageId}":<br/>                get:<br/>                  consumes:<br/>                    - "application/json"<br/>                  produces:<br/>                    - "application/json"<br/>                  responses:<br/>                    "200":<br/>                      description: "200 response"<br/>                      schema:<br/>                        $ref: "#/definitions/Empty"<br/>                  x-amazon-apigateway-integration:<br/>                    httpMethod: POST<br/>                    type: AWS<br/>                    uri: { "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:dynamodb:action/Query" }<br/>                    credentials: { "Fn::Sub": "arn:aws:iam::${AccountId}:role/${RoleName}" }<br/>                    requestTemplates:<br/>                      application/json: { 'Fn::Sub': "{ \n\<br/>                      \t\"TableName\": \"${Table}\",\n\<br/>                      \t\"KeyConditionExpression\": \"PageId = :v1\",\n\<br/>                      \t\"ExpressionAttributeValues\": {\n\<br/>                      \t\t\":v1\": { \n\<br/>                      \t\t\t\"S\": \"$input.params('PageId')\"\n\<br/>                      \t\t}\n\<br/>                      \t}\n}"}<br/>                    responses:<br/>                      default:<br/>                        statusCode: "200"   <br/>                        responseTemplates:<br/>                          application/json: "#set($inputRoot = $input.path('$'))\n\<br/>                          {\n\<br/>                          \t\"comments\": [\n\<br/>                          \t\t#foreach($elem in $inputRoot.Items) {\n\<br/>                          \t\t\t\"PageId\": \"$elem.PageId.S\",\n\<br/>                          \t\t\t\"Message\": \"$elem.Message.S\",\n\<br/>                          \t\t\t\"EventCount\": \"$elem.EventCount.N\"\n\<br/>                          \t\t}#if($foreach.hasNext),#end\n\<br/>                          \t#end\n\<br/>                          \t]\n}"</span></pre><p id="60ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您将看到<code class="eh lj lk ll lm b">requestTemplates</code>使用<code class="eh lj lk ll lm b">PageId</code>创建一个<a class="ae jp" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html" rel="noopener ugc nofollow" target="_blank"> DynamoDB查询</a>。如果数据与查询匹配，则返回数据并通过<code class="eh lj lk ll lm b">responseTemplates</code>传递，T10将数据从原生DynamoDB格式转换为更标准的JSON格式。</p><h1 id="12c7" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">过帐方法</h1><p id="c7ef" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我已经展示了如何执行幂等PUT，现在让我们来看一个更复杂的更新，它在每次被调用时将计数器递增指定的值。这对于保持排行榜分数、指标或交易非常有用。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="f06a" class="lr kh hu lm b fv ls lt l lu lv">                post:<br/>                  consumes:<br/>                    - "application/json"<br/>                  produces:<br/>                    - "application/json"<br/>                  responses:<br/>                    "200":<br/>                      description: "200 response"<br/>                      schema:<br/>                        $ref: "#/definitions/Empty"<br/>                  x-amazon-apigateway-integration:<br/>                    httpMethod: POST<br/>                    type: AWS<br/>                    uri: { "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:dynamodb:action/UpdateItem" }<br/>                    credentials: { "Fn::Sub": "arn:aws:iam::${AccountId}:role/${RoleName}" }<br/>                    requestTemplates:<br/>                      application/json: { 'Fn::Sub': "{\n\t\"TableName\": \"${Table}\",\n\<br/>                      \t\"Key\":{\n<br/>                      \t\t\"PageId\": {\n<br/>                      \t\t\t\"S\": \"$input.path('$.PageId')\"\n\<br/>                      \t\t}\n\<br/>                      \t},\n\<br/>                      \t\"ExpressionAttributeValues\": {\n\<br/>                      \t\t\":event_count\": {\n\<br/>                      \t\t\t\"N\": \"$input.path('$.EventCount')\"},\n\<br/>                      \t\t\":message\": {\n\<br/>                      \t\t\t\"S\": \"$input.path('$.Message')\"}\n\<br/>                      \t},\n\<br/>                      \t\"UpdateExpression\": \"ADD EventCount :event_count SET Message = :message\",\n\ \t\"ReturnValues\": \"ALL_NEW\"\n}"}<br/>                    responses:<br/>                      default:<br/>                        statusCode: "200"</span></pre><p id="31d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我再次使用<code class="eh lj lk ll lm b">requestTemplates</code>来形成一个查询，使用<code class="eh lj lk ll lm b">$input.path()</code>从JSON主体中提取不同的值。我认为DynamoDB最好的特性之一是丰富的用于更新的表达式语言。这里我使用了<code class="eh lj lk ll lm b">"UpdateExpression\": \"ADD EventCount :event_count</code>，它对DynamoDB中已经存在的<code class="eh lj lk ll lm b">EventCount</code>值执行非锁定更新。美妙之处在于，读取和更新是使用UpdateExpression作为一个原子操作来完成的，不需要在客户端浪费时间和重试！我还想显示调用的结果，所以我使用<code class="eh lj lk ll lm b">"ReturnValues\": \"ALL_NEW\"</code>返回它。</p><h1 id="fe75" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">删除方法</h1><p id="4f05" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">最后，我希望能够在DynamoDB中删除特定的<code class="eh lj lk ll lm b">PageId</code>记录，所以我使用了<code class="eh lj lk ll lm b">DeleteItem</code>动作，其中我将<code class="eh lj lk ll lm b">PageId</code>作为URL参数传递。</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="986d" class="lr kh hu lm b fv ls lt l lu lv">                delete:<br/>                  consumes:<br/>                  - "application/json"<br/>                  produces:<br/>                  - "application/json"<br/>                  parameters:<br/>                  - name: "PageId"<br/>                    in: "path"<br/>                    required: true<br/>                    type: "string"<br/>                  responses:<br/>                    "200":<br/>                      description: "200 response"<br/>                      schema:<br/>                        $ref: "#/definitions/Empty"<br/>                  x-amazon-apigateway-integration:<br/>                    credentials: { "Fn::Sub": "arn:aws:iam::${AccountId}:role/${RoleName}" }<br/>                    uri: { "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:dynamodb:action/DeleteItem" }<br/>                    requestTemplates:<br/>                      application/json:  { 'Fn::Sub': "{ \n\<br/>                      \t\"TableName\": \"${Table}\",\n\<br/>                      \t\"Key\": {\n\<br/>                      \t\t\"PageId\": {\n<br/>                      \t\t\t\"S\": \"$input.params('PageId')\"\n\<br/>                      \t\t}\n\<br/>                      \t},\n\<br/>                      \t\"ConditionExpression\": \"attribute_not_exists(Replies)\",\n\<br/>                      \t\"ReturnValues\": \"ALL_OLD\"\n}" }<br/>                    responses:<br/>                      default:<br/>                        statusCode: "200"<br/>                    passthroughBehavior: "when_no_match"<br/>                    httpMethod: "POST"<br/>                    type: "aws"<br/>                  <br/>            definitions:<br/>              Empty:<br/>                type: "object"<br/>                title: "Empty Schema"</span></pre><p id="52d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我想看看删除了什么，所以我加入了<code class="eh lj lk ll lm b">"ReturnValues\": \"ALL_OLD\"</code>。在脚本的末尾，我们有一个通过YAML文件引用的空模式。</p><h1 id="f2bb" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">部署API</h1><p id="2483" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">生活变得更加简单快捷，现在我甚至不需要任何Lambda代码，也不需要将Lambda和依赖项打包成Zip文件。我所需要做的就是使用<code class="eh lj lk ll lm b">apigateway-dynamo.yaml</code>中的代码和配置来部署堆栈，就这样！</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lw"><img src="../Images/53de6f68c3d4e3e35b5bb71e1bbffcd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFppf7z-AGtiWSDieAhcTg.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Serverless &amp; Lambdaless RESTful Data API Deployment</figcaption></figure><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="d1e0" class="lr kh hu lm b fv ls lt l lu lv">$ aws cloudformation deploy --template-file $template.yaml --stack-name $template --capabilities CAPABILITY_IAM --region $region --profile $profile</span></pre><p id="4a7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也很容易添加到任何CI/CD管道步骤中。</p><h1 id="ebad" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">测试API</h1><p id="7da4" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在您已经了解了如何构建API，让我们手动测试它是否如预期的那样工作。登录AWS控制台&gt; API网关，或者您也可以使用浏览器插件，如postman。</p><h2 id="f9d7" class="lr kh hu bd ki lx ly lz km ma mb mc kq jc md me ku jg mf mg ky jk mh mi lc mj dt translated">测试PUT方法或Create</h2><p id="a5df" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">因为DynamoDB中还没有数据，所以让我们从添加一些数据开始。</p><ol class=""><li id="d8b0" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">打开<a class="ae jp" href="https://console.aws.amazon.com/apigateway/" rel="noopener ugc nofollow" target="_blank"> API网关</a></li><li id="8d11" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在导航窗格中，选择apigateway-dynamo和资源</li><li id="00c3" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在资源中，单击上传</li><li id="21c1" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在/访问-放置-方法执行下单击测试</li><li id="b702" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在“请求正文”中，输入以下JSON</li></ol><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="c609" class="lr kh hu lm b fv ls lt l lu lv">{"PageId": "444",<br/>"EventCount": 1,<br/>"Message": "happy"}</span></pre><ol class=""><li id="6efd" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">向下滚动并单击测试按钮。</li></ol><p id="15c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您将在右侧(或移动设备下方)看到状态:200，这意味着呼叫成功，并看到响应正文。您还将看到完整的API日志，这对测试和调试非常有用。这些也存储在CloudWatch日志中，如果您开始收到4XX或5XX错误，这是您需要查看的第一个地方。</p><h2 id="be14" class="lr kh hu bd ki lx ly lz km ma mb mc kq jc md me ku jg mf mg ky jk mh mi lc mj dt translated">测试GET方法</h2><p id="84c5" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在您在DynamoDB中有了一条记录，让我们使用PageId = 444查询来检索它。</p><ol class=""><li id="70f4" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">在资源中，单击上传</li><li id="ddb4" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在/visits/{PageId} — GET —方法执行下，单击测试</li><li id="fdcd" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在{PageId}的路径中输入444，或者在{PageId}的查询字符串中输入PageId=444</li><li id="7aeb" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">点击测试按钮。</li></ol><p id="b8c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该得到一个状态:200，还可以看到下面的响应体，这正是我们所期望的</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="2c0d" class="lr kh hu lm b fv ls lt l lu lv">{<br/>  "comments": [<br/>    {<br/>      "PageId": "444",<br/>      "Message": "happy",<br/>      "EventCount": "1"<br/>    }<br/>  ]<br/>}</span></pre><h2 id="72d1" class="lr kh hu bd ki lx ly lz km ma mb mc kq jc md me ku jg mf mg ky jk mh mi lc mj dt translated">测试POST方法</h2><p id="05b3" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">使用PUT方法，您会看到无论调用多少次,<code class="eh lj lk ll lm b">EventCount</code>值都保持不变。现在让我们测试POST方法，它在每次被调用时将计数器递增指定的值。</p><ol class=""><li id="d1bb" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">在资源中，单击帖子</li><li id="dd36" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在/访问-后-方法执行下，单击测试</li><li id="8160" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在“请求正文”中，输入以下JSON</li></ol><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="18d0" class="lr kh hu lm b fv ls lt l lu lv">{"PageId": "444",<br/>"EventCount": 1,<br/>"Message": "happy"}</span></pre><p id="988b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该得到一个状态:200，还可以看到下面的响应体</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="89e1" class="lr kh hu lm b fv ls lt l lu lv">"comments": [<br/>    {<br/>      "PageId": "444",<br/>      "Message": "happy",<br/>      "EventCount": "2"<br/>    }<br/>  ]<br/>}</span></pre><p id="220e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行它几次，您将看到EventCount递增，如果您修改请求JSON主体EventCount值，您还可以将它递增1以上。为什么这个POST方法返回当前值？这取决于配置，因为我想让你不用去DynamoDB控制台就能看到POST的效果！</p><h2 id="6197" class="lr kh hu bd ki lx ly lz km ma mb mc kq jc md me ku jg mf mg ky jk mh mi lc mj dt translated">测试删除方法</h2><p id="e13e" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在你有了很多数据，也许你需要删除一些记录。</p><ol class=""><li id="cbb1" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">在资源中点击删除</li><li id="9a02" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在/visits/{PageId} —删除—方法执行下，单击测试</li><li id="6d1d" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在{PageId}的路径中输入444，或者在{PageId}的查询字符串中输入PageId=444</li><li id="25f9" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">点击测试按钮。</li></ol><p id="6970" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该得到一个status: 200，还可以看到被删除记录的响应主体，我使用了<code class="eh lj lk ll lm b">"ReturnValues\": \"ALL_OLD\"</code>。</p><p id="0db7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了仔细检查，您可以在AWS控制台中查看DynamoDB</p><ol class=""><li id="c5f8" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">打开<a class="ae jp" href="https://console.aws.amazon.com/dynamodb" rel="noopener ugc nofollow" target="_blank"> DynamoDB控制台</a></li><li id="abe0" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在导航下，单击表格</li><li id="cf03" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在名字下点击<code class="eh lj lk ll lm b">user-comments-api-sam</code></li><li id="5fb8" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">在选项卡上，单击项目</li></ol><p id="d6a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该看到记录不再存在，您还可以使用查询下拉菜单进行检查。</p><h1 id="68ad" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">打扫</h1><p id="ad10" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">要删除堆栈，只需运行<code class="eh lj lk ll lm b">./delete-stack.sh</code>以下是shell脚本的内容:</p><pre class="jr js jt ju fq ln lm lo lp aw lq dt"><span id="7e63" class="lr kh hu lm b fv ls lt l lu lv">$ aws cloudformation delete-stack --stack-name $template --region $region --profile $profile</span></pre><h1 id="1240" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">分析和结论</h1><p id="3d99" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">很好地完成了创建无服务器数据API的步骤！完整的源代码将很快在我的<a class="ae jp" href="https://github.com/astarwolf/" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上提供</p><h1 id="5c73" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">后续步骤:</h1><ul class=""><li id="1b30" class="mk ml hu it b iu le iy lf jc my jg mz jk na jo nb mq mr ms dt translated">作为一个好的起点，在AWS控制台中创建API，然后导出YAML</li><li id="7a96" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">尽可能使用环境变量和参数</li><li id="2bbd" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">从SAM模板中分离IAM角色和策略</li></ul><p id="96f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的无羔皮方法的缺点是:</p><ul class=""><li id="cc38" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo nb mq mr ms dt translated">如果云的形成是不可行的，那么使用AWS CLI会更复杂</li><li id="e12f" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">CloudFormation符号对我来说冗长而奇怪，例如<code class="eh lj lk ll lm b">{ 'Fn::Sub': [...] }</code>和<code class="eh lj lk ll lm b">if($foreach.hasNext),#end</code>感觉不友好或不直观！</li><li id="c5c2" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">复杂的分页和异常处理由于CloudFormation符号而变得更加复杂，比如Node.js或Python</li><li id="4339" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">如何在yaml中对API集成请求和响应进行单元测试？</li></ul><p id="427d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的无Lambdaless方法的优点:</p><ul class=""><li id="a316" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo nb mq mr ms dt translated">没有Lambda冷启动，比中间有Lambda更快</li><li id="7932" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">更简单、代码更少——不需要Python或Node.js Zip包，所有配置都在一个YAML文件中！</li><li id="6458" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">Swagger和SAM —非常快速且易于部署，易于在CI/CD中使用</li><li id="3a4b" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">在CloudWatch中进行API网关日志记录和监控</li></ul><p id="bf08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，不是所有的事情都可以用这种无服务器方法来完成，但是无服务器计算可以用在大多数情况下。如果你想了解更多关于无服务器微服务和更复杂的用例，请看看我的视频课程，并支持我写更多的博客帖子。</p><ul class=""><li id="65c8" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo nb mq mr ms dt translated">对于初学者和中间用户，<a class="ae jp" href="https://www.packtpub.com/application-development/building-scalable-serverless-microservice-rest-data-api-video" rel="noopener ugc nofollow" target="_blank">完整的无服务器数据API代码</a>，配置和详细的演练</li><li id="6d46" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo nb mq mr ms dt translated">对于中级或高级用户，我涵盖了<a class="ae jp" href="https://www.packtpub.com/application-development/implementing-serverless-microservices-architecture-patterns-video" rel="noopener ugc nofollow" target="_blank"> 15+无服务器微服务模式</a>的实施，超过7小时的原始内容，代码，配置和详细的演练，使其成为最完整的无服务器微服务视频课程之一！</li></ul><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://www.packtpub.com/application-development/implementing-serverless-microservices-architecture-patterns-video"><div class="fe ff nc"><img src="../Images/be4fb5feaba8c334dc85a22ccf6f4aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*XBbcZmMS3kOyhzB9ftvsMA.png"/></div></a></figure><p id="c38d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请随时在<a class="ae jp" href="https://www.linkedin.com/in/drfreeman/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，或者给我发消息征求意见。</p></div></div>    
</body>
</html>