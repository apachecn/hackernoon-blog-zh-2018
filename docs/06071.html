<html>
<head>
<title>How to prepare your iOS app for UI testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何准备您的iOS应用程序进行UI测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-developer-and-tester-friendly-guide-to-ui-testing-on-ios-71fbd20f22a8?source=collection_archive---------12-----------------------#2018-07-23">https://medium.com/hackernoon/a-developer-and-tester-friendly-guide-to-ui-testing-on-ios-71fbd20f22a8?source=collection_archive---------12-----------------------#2018-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a4f5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">为你的iOS应用编写稳定一致的UI测试</h2></div><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="jo jp l"/></div></figure><p id="a2a8" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">去年，我与我们的测试人员密切合作，将第一个UI测试目标添加到我们的iOS项目中。我们有一些简单的目标来衡量我们的成功:</p><ul class=""><li id="c46b" class="km kn hu js b jt ju jw jx jz ko kd kp kh kq kl kr ks kt ku dt translated">编写易于维护的测试。</li><li id="2f03" class="km kn hu js b jt kv jw kw jz kx kd ky kh kz kl kr ks kt ku dt translated">从测试中抽象出app内部接线和架构。</li><li id="670d" class="km kn hu js b jt kv jw kw jz kx kd ky kh kz kl kr ks kt ku dt translated">一个简单的机制来<a class="ae la" href="https://github.com/AliSoftware/OHHTTPStubs" rel="noopener ugc nofollow" target="_blank">存根</a>相关的API调用(使用<a class="ae la" href="https://www.charlesproxy.com/" rel="noopener ugc nofollow" target="_blank">查尔斯</a>或<a class="ae la" href="https://itunes.apple.com/app/charles-proxy/id1134218562?mt=8" rel="noopener ugc nofollow" target="_blank">查尔斯代理</a>找到相关的调用)。</li></ul></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h2 id="7467" class="li lj hu bd lk ll lm ln lo lp lq lr ls jz lt lu lv kd lw lx ly kh lz ma mb mc dt translated">您实际测试的是什么</h2><p id="7061" class="pw-post-body-paragraph jq jr hu js b jt md iv jv jw me iy jy jz mf kb kc kd mg kf kg kh mh kj kk kl hn dt translated">例如，为了确保你测试的是你的应用程序，而不是你的后端，把你所有的API调用都截掉是个好主意。这也保证了一致性、稳定性和不那么脆弱的UI测试。</p><p id="c841" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">你的目标不应该是测试你的后端或它和前端之间的集成，而是孤立地测试应用程序，并确认它在一些预先确定的条件下一致地工作。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h1 id="df62" class="mi lj hu bd lk mj mk ml lo mm mn mo ls ja mp jb lv jd mq je ly jg mr jh mb ms dt translated">设置事物</h1><p id="ac18" class="pw-post-body-paragraph jq jr hu js b jt md iv jv jw me iy jy jz mf kb kc kd mg kf kg kh mh kj kk kl hn dt translated">如果您的应用程序还没有UI测试目标，您将不得不转到<code class="eh mt mu mv mw b"><strong class="js hv">File</strong> &gt; <strong class="js hv">New</strong> &gt; <strong class="js hv">Target</strong> &gt; <strong class="js hv">iOS UI Testing Bundle</strong></code>添加一个。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="fe ff mx"><img src="../Images/9845c4a5d64622e25453f23d74c79645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugTelnO1Rljmpqxug8ApmQ.png"/></div></div></figure><h2 id="864e" class="li lj hu bd lk ll lm ln lo lp lq lr ls jz lt lu lv kd lw lx ly kh lz ma mb mc dt translated">XCTest框架如何工作</h2><p id="a3f8" class="pw-post-body-paragraph jq jr hu js b jt md iv jv jw me iy jy jz mf kb kc kd mg kf kg kh mh kj kk kl hn dt translated">让大多数人感到困惑的第一件事是，你不能在你的<code class="eh mt mu mv mw b"><strong class="js hv">XCTestCase</strong></code>中存根你的API调用，因为它只是打开你的应用程序，所以你在那里做的任何存根都将丢失。</p><p id="0cd3" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">你必须使用<a class="ae la" href="https://developer.apple.com/documentation/xctest/xcuiapplication/1500477-launcharguments" rel="noopener ugc nofollow" target="_blank"> launch arguments </a>来代替，让你的应用程序知道它处于UI测试模式，什么API调用需要存根。</p><h2 id="ef55" class="li lj hu bd lk ll lm ln lo lp lq lr ls jz lt lu lv kd lw lx ly kh lz ma mb mc dt translated">如何存根你的API调用</h2><p id="5dc8" class="pw-post-body-paragraph jq jr hu js b jt md iv jv jw me iy jy jz mf kb kc kd mg kf kg kh mh kj kk kl hn dt translated">当涉及到向你的应用返回虚假数据(预先决定的响应)时，你有很多选择，比如模仿存储库(管理者，等等..基于您的应用程序架构)协议。换句话说，就是在呼叫实际到达网络层之前避开它。</p><p id="541b" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">另一个选择是阻止你的应用程序在测试中可能发出的所有web调用。使用<a class="ae la" href="https://github.com/AliSoftware/OHHTTPStubs" rel="noopener ugc nofollow" target="_blank">ohhttpsubs</a>时，您的应用程序实际上执行了存储库中的所有代码，当您访问网络层时<a class="ae la" href="https://github.com/AliSoftware/OHHTTPStubs" rel="noopener ugc nofollow" target="_blank">ohhttpsubs</a>会返回预先响应或错误。与第一个选项不同，这实际上会暴露存储库中隐藏的错误。</p><h2 id="28e1" class="li lj hu bd lk ll lm ln lo lp lq lr ls jz lt lu lv kd lw lx ly kh lz ma mb mc dt translated">一个简单的结构来存根现有的和未来的API调用</h2><p id="28a8" class="pw-post-body-paragraph jq jr hu js b jt md iv jv jw me iy jy jz mf kb kc kd mg kf kg kh mh kj kk kl hn dt translated">在我以前编写可维护的UI测试的尝试中，主要是在Android上，模仿存储库方法总是很棘手，特别是从测试人员的角度来看，因为它们不会每天都在代码库上工作。另一方面，您可以轻松运行应用程序，找出应用程序发出的所有请求及其响应，并轻松处理它们，而不必担心代码中会发生什么。</p><p id="bfd4" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我仍然想让代码清晰，并且可以很容易地映射到我们的API结构/文档中。任何REST后端都有不同的API，每个API都有一堆端点，所以这就是代码看起来的样子。我甚至可能会考虑将来自动生成所有这些代码。</p><pre class="jj jk jl jm fq ne mw nf ng aw nh dt"><span id="d6f9" class="li lj hu mw b fv ni nj l nk nl"><strong class="mw hv">protocol </strong>StubApi {   <br/>}</span><span id="4e03" class="li lj hu mw b fv nm nj l nk nl"><strong class="mw hv">protocol </strong>StubEndpoint {<br/>    <br/>    <strong class="mw hv">var </strong>path: String { <strong class="mw hv">get </strong>}<br/>    <strong class="mw hv">var </strong>name: String { <strong class="mw hv">get </strong>}<br/>    <strong class="mw hv">var </strong>type: String { <strong class="mw hv">get </strong>}<br/>    <strong class="mw hv">var </strong>method: HttpMethod { <strong class="mw hv">get </strong>}<br/>    <strong class="mw hv">var </strong>params: [String: String]? { <strong class="mw hv">get </strong>}<br/>    <br/>}</span><span id="a8a9" class="li lj hu mw b fv nm nj l nk nl"><strong class="mw hv">extension </strong>StubEndpoint {<br/>    <br/>    // Helper serialization function.<br/>    <strong class="mw hv">func </strong>toDictionary() -&gt; [String: String] {<br/>        <strong class="mw hv">var </strong>dictionary = [String: String]()<br/>        dictionary["path"] = path<br/>        dictionary["name"] = name<br/>        dictionary["type"] = type<br/>        dictionary["method"] = method.rawValue<br/>        <br/>        <strong class="mw hv">if let </strong>params = params {<br/>            <strong class="mw hv">let </strong>json = <strong class="mw hv">try</strong>! JSONSerialization.data(withJSONObject: params, options: JSONSerialization.WritingOptions())<br/>            dictionary["params"] = String(data: json, encoding: String.Encoding(rawValue: String.Encoding.utf8.rawValue))<br/>        }<br/>        <br/>        <strong class="mw hv">return </strong>dictionary<br/>    }<br/>    <br/>}</span></pre><p id="adae" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我还包括了<code class="eh mt mu mv mw b"><strong class="js hv">StubbingManager</strong></code>将支持的HTTP方法和资源类型。</p><pre class="jj jk jl jm fq ne mw nf ng aw nh dt"><span id="6cc5" class="li lj hu mw b fv ni nj l nk nl"><strong class="mw hv">enum </strong>HttpMethod: String {<br/>    <strong class="mw hv">case </strong><em class="nn">GET</em>, <em class="nn">POST</em>, <em class="nn">DELETE</em>, <em class="nn">PUT<br/>    <br/>    </em><strong class="mw hv">static func </strong>fromString(rawValue: String?) -&gt; HttpMethod {<br/>        <strong class="mw hv">guard let </strong>rawValue = rawValue <strong class="mw hv">else </strong>{ fatalError() }<br/>        <br/>        <strong class="mw hv">switch </strong>rawValue {<br/>        <strong class="mw hv">case </strong>HttpMethod.<em class="nn">GET</em>.rawValue:<br/>            <strong class="mw hv">return </strong>.<em class="nn">GET<br/>        </em><strong class="mw hv">case </strong>HttpMethod.<em class="nn">POST</em>.rawValue:<br/>            <strong class="mw hv">return </strong>.<em class="nn">POST<br/>        </em><strong class="mw hv">case </strong>HttpMethod.<em class="nn">DELETE</em>.rawValue:<br/>            <strong class="mw hv">return </strong>.<em class="nn">DELETE<br/>        </em><strong class="mw hv">case </strong>HttpMethod.<em class="nn">PUT</em>.rawValue:<br/>            <strong class="mw hv">return </strong>.<em class="nn">PUT<br/>        </em><strong class="mw hv">default</strong>:<br/>            fatalError()<br/>        }<br/>    }<br/>}</span><span id="f5be" class="li lj hu mw b fv nm nj l nk nl"><strong class="mw hv">enum </strong>ResourceType: String {<br/>    <strong class="mw hv">case </strong>J<em class="nn">SON<br/></em>}</span></pre><p id="baee" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">一个示例API存根看起来像这样</p><pre class="jj jk jl jm fq ne mw nf ng aw nh dt"><span id="7873" class="li lj hu mw b fv ni nj l nk nl">// <a class="ae la" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/</a><br/><strong class="mw hv">class </strong>PostsStubApi: StubApi {<br/>    <br/>    <strong class="mw hv">class </strong>RetrieveOnePostItem: StubEndpoint {<br/>        <strong class="mw hv">let </strong>path = "/posts/1"<br/>        // This file name, it can exist anywhere but it needs to be accessible by the app target as well as the UI test target.<br/>        <strong class="mw hv">let </strong>name = "stub_discarded_jobs"<br/>        <strong class="mw hv">let </strong>type = ResourceType.<em class="nn">json</em>.rawValue<br/>        <strong class="mw hv">let </strong>method = HttpMethod.<em class="nn">GET<br/>        </em><strong class="mw hv">let </strong>params: [String : String]? = <strong class="mw hv">nil<br/>    </strong>}<br/>}</span></pre></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><h2 id="5c22" class="li lj hu bd lk ll lm ln lo lp lq lr ls jz lt lu lv kd lw lx ly kh lz ma mb mc dt translated">如何在UI测试模式下启动您的应用程序</h2><p id="c924" class="pw-post-body-paragraph jq jr hu js b jt md iv jv jw me iy jy jz mf kb kc kd mg kf kg kh mh kj kk kl hn dt translated">因为您不能在测试中存根API调用，所以当从UI测试启动应用程序时，您必须将一些数据传递给应用程序。为此，我们可以在<code class="eh mt mu mv mw b"><strong class="js hv">XCUIApplication</strong></code>上使用<code class="eh mt mu mv mw b"><strong class="js hv">launchEnvironment</strong></code>。</p><pre class="jj jk jl jm fq ne mw nf ng aw nh dt"><span id="141b" class="li lj hu mw b fv ni nj l nk nl"><strong class="mw hv">class </strong>BaseTestCase: QuickSpec { // Or XCTestCase<br/>    <br/>    <strong class="mw hv">private var </strong>stubManager: StubManager = StubManager()<br/>    <br/>    // Easily add a new stub before your test run.<br/>    <strong class="mw hv">func </strong>stub(endpoint: StubEndpoint) {<br/>        stubManager.add(stub: endpoint)<br/>    }</span><span id="6d85" class="li lj hu mw b fv nm nj l nk nl">    // Remove all tests after a test has ran.<br/>    <strong class="mw hv">func </strong>removeAllStubs() {<br/>        stubManager.removeAllStubs();<br/>    }</span><span id="023c" class="li lj hu mw b fv nm nj l nk nl">    <strong class="mw hv">// Here is where the magic happens.</strong><br/>    <strong class="mw hv">func </strong>launch(app: XCUIApplication) {<br/>        app.launchEnvironment["stubs"] = stubManager.toJSON()<br/>        app.launch()<br/>    }<br/>    <br/>}</span></pre><p id="8f23" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">并且<code class="eh mt mu mv mw b"><strong class="js hv">StubManager</strong></code>可以存在于应用程序或者UI测试目标中，它只需要在两个目标之间共享。</p><pre class="jj jk jl jm fq ne mw nf ng aw nh dt"><span id="c93a" class="li lj hu mw b fv ni nj l nk nl"><strong class="mw hv">import </strong>OHHTTPStubs<br/><br/><strong class="mw hv">final class </strong>StubManager {<br/>    <br/>    <strong class="mw hv">let </strong>jsonHeaders = ["content-type": "application/json"]<br/>    <br/>    <strong class="mw hv">private var </strong>stubs: [StubEndpoint] = []<br/>    <br/>    <strong class="mw hv">deinit </strong>{<br/>        killStubs()<br/>    }<br/>    <br/>    <strong class="mw hv">func </strong>add(stub: StubEndpoint) {<br/>        stubs.append(stub)<br/>    }<br/>    <br/>    <strong class="mw hv">func </strong>loadStubs() {<br/>        // Just stub any image request to avoid any web calls.<br/>        stub(condition: isExtension("png") || isExtension("jpg") || isExtension("gif")) { _ <strong class="mw hv">in<br/>            let </strong>stubPath = OHPathForFile("stub.jpg", type(of: <strong class="mw hv">self</strong>))<br/>            <strong class="mw hv">return </strong>fixture(filePath: stubPath!, headers: ["Content-Type" <strong class="mw hv">as </strong>NSObject:"image/jpeg" <strong class="mw hv">as </strong>AnyObject])<br/>        }</span><span id="7a5c" class="li lj hu mw b fv nm nj l nk nl">        <strong class="mw hv">// Now let us go through the stubs array and apply them.</strong><br/>        <strong class="mw hv">for </strong>stub <strong class="mw hv">in </strong>stubs {<br/>            // Base url for your endpoints.<br/>            <strong class="mw hv">var </strong>condition = isHost("<a class="ae la" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com</a>")<br/>            condition = condition &amp;&amp; isPath(stub.path)<br/>            <br/>            <strong class="mw hv">switch</strong>(stub.method) {<br/>            <strong class="mw hv">case </strong>.<em class="nn">GET</em>: condition = condition &amp;&amp; isMethodGET()<br/>            <strong class="mw hv">case </strong>.<em class="nn">POST</em>: condition = condition &amp;&amp; isMethodPOST()<br/>            <strong class="mw hv">case </strong>.<em class="nn">DELETE</em>: condition = condition &amp;&amp; isMethodDELETE()<br/>            <strong class="mw hv">case </strong>.<em class="nn">PUT</em>: condition = condition &amp;&amp; isMethodPUT()<br/>            }<br/>            <br/>            <strong class="mw hv">if let </strong>params = stub.params {<br/>                condition = condition &amp;&amp; containsQueryParams(params)<br/>            }<br/>            <br/>            stub(condition: condition) { _ <strong class="mw hv">in<br/>                let </strong>bundle = Bundle(for: type(of: <strong class="mw hv">self</strong>))<br/>                <strong class="mw hv">let </strong>path = bundle.path(forResource: stub.name, ofType: stub.type)<br/>                <strong class="mw hv">return </strong>OHHTTPStubsResponse(fileAtPath: path!, statusCode: 200, headers: <strong class="mw hv">self</strong>.jsonHeaders)<br/>            }<br/>        }<br/>    }<br/>    <br/>    <strong class="mw hv">func </strong>removeAllStubs() {<br/>        stubs = []<br/>    }<br/>    <br/>    <strong class="mw hv">func </strong>killStubs() {<br/>        OHHTTPStubs.removeAllStubs()<br/>    }</span><span id="1e5f" class="li lj hu mw b fv nm nj l nk nl"><strong class="mw hv">    // To serialize stubs and send them to the app.</strong><br/>    <strong class="mw hv">func </strong>toJSON() -&gt; String? {<br/>        <strong class="mw hv">var </strong>arrayOfStubs = [[String: String]]()<br/>        <br/>        <strong class="mw hv">for </strong>sutb <strong class="mw hv">in </strong>stubs {<br/>            arrayOfStubs.append(stub.toDictionary())<br/>        }<br/>        <br/>        <strong class="mw hv">let </strong>json = <strong class="mw hv">try</strong>! JSONSerialization.data(withJSONObject: arrayOfStubs, options: JSONSerialization.WritingOptions())<br/>        <br/>        <strong class="mw hv">return </strong>String(data: json, encoding: String.Encoding(rawValue: String.Encoding.utf8.rawValue))<br/>    }</span><span id="da98" class="li lj hu mw b fv nm nj l nk nl"><strong class="mw hv">    // To deserialize stubs in the app and apply them.</strong><br/>    <strong class="mw hv">func </strong>fromJSON(json: String) {<br/>        stubs.removeAll()<br/>        <br/>        <strong class="mw hv">let </strong>data = <strong class="mw hv">try</strong>! JSONSerialization.jsonObject(with: json.data(using: String.Encoding.utf8)!, options: JSONSerialization.ReadingOptions())<br/>        <br/>        <strong class="mw hv">if let </strong>stubData = data <strong class="mw hv">as</strong>? [[String: String]] {<br/>            <strong class="mw hv">for </strong>stub <strong class="mw hv">in </strong>stubData {<br/>                stubs.append(AnyStubEndpoint(dictionary: stub))<br/>            }<br/>        }<br/>    }<br/>    <br/>    <strong class="mw hv">struct </strong>AnyStubEndpoint: StubEndpoint {<br/>        <br/>        <strong class="mw hv">var </strong>path: String<br/>        <strong class="mw hv">var </strong>name: String<br/>        <strong class="mw hv">var </strong>type: String<br/>        <strong class="mw hv">var </strong>method: HttpMethod<br/>        <strong class="mw hv">var </strong>params: [String: String]?<br/>        <br/>        <strong class="mw hv">init</strong>(dictionary: [String: String]) {<br/>            uri = dictionary["path"] ?? ""<br/>            name = dictionary["name"] ?? ""<br/>            type = dictionary["type"] ?? ""<br/>            method = HttpMethod.fromString(rawValue: dictionary["method"])<br/>                <br/>            <strong class="mw hv">if let </strong>params = dictionary["params"] {<br/>                <strong class="mw hv">self</strong>.params = <strong class="mw hv">try</strong>! JSONSerialization.jsonObject(with: params.data(using: String.Encoding.utf8)!, options: JSONSerialization.ReadingOptions()) <strong class="mw hv">as</strong>? [String: String]<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="e1f9" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">剩下的就是检查<code class="eh mt mu mv mw b"><strong class="js hv">AppDelegate</strong></code>是否设置了<code class="eh mt mu mv mw b"><strong class="js hv">launchEnvironment</strong></code>。</p><pre class="jj jk jl jm fq ne mw nf ng aw nh dt"><span id="ee06" class="li lj hu mw b fv ni nj l nk nl"><strong class="mw hv">extension </strong>AppDelegate {<br/>    <br/>    <strong class="mw hv">func </strong>isStubbing() -&gt; Bool {<br/>        <strong class="mw hv">return </strong>ProcessInfo.processInfo.environment["stubs"] != <strong class="mw hv">nil<br/>    </strong>}<br/>    <br/>    <strong class="mw hv">func </strong>configureStubsIfNeeded() -&gt; Bool {<br/>        <strong class="mw hv">if </strong>isStubbing() {<br/>            stubManager = StubManager()<br/>            <strong class="mw hv">if let </strong>json = ProcessInfo.processInfo.environment["stubs"] {<br/>                stubManager.fromJSON(json: json)<br/>                stubManager.loadStubs()<br/>            }<br/>            <br/>            <strong class="mw hv">return true<br/>        </strong>}<br/>        <strong class="mw hv">else </strong>{<br/>            <strong class="mw hv">guard </strong>stubManager != <strong class="mw hv">nil else </strong>{ <strong class="mw hv">return false </strong>}<br/>            stubManager.killStubs()<br/>            <br/>            <strong class="mw hv">return false<br/>        </strong>}<br/>    }<br/>    <br/>}</span></pre><h2 id="5bd9" class="li lj hu bd lk ll lm ln lo lp lq lr ls jz lt lu lv kd lw lx ly kh lz ma mb mc dt translated">使用Quick and Nimble编写您的第一个UI测试</h2><p id="0879" class="pw-post-body-paragraph jq jr hu js b jt md iv jv jw me iy jy jz mf kb kc kd mg kf kg kh mh kj kk kl hn dt translated">编写UI测试不需要太多的应用架构知识，测试人员或开发人员只需要找到哪些端点需要存根，就可以轻松地开始添加更多测试。</p><pre class="jj jk jl jm fq ne mw nf ng aw nh dt"><span id="e83d" class="li lj hu mw b fv ni nj l nk nl"><strong class="mw hv">import </strong>Quick<br/><strong class="mw hv">import </strong>Nimble<br/><br/><strong class="mw hv">class </strong>DiscardJobsSpec: TMTestCase {<br/>    <br/>    <strong class="mw hv">override func </strong>spec() {<br/>        <strong class="mw hv">let </strong>app = XCUIApplication()<br/>        <br/>        describe("retrieve discarded jobs") {<br/><br/>            beforeEach {<br/>                stub(endpoint: PostsStubApi.RetrieveOnePostItem())<br/>            }<br/><br/>            afterEach {<br/>                removeAllStubs()<br/>            }<br/><br/>            it("should do something") {<br/>                // You will have one item on the screen at this point 🎉<br/>            }<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="b27a" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我希望你喜欢读这篇文章，如果你喜欢就分享它，如果你喜欢就在Twitter上关注我<a class="ae la" href="https://goo.gl/pnkheb" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>