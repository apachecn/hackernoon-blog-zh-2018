<html>
<head>
<title>Smart Contract Attacks [Part 2] - Ponzi Games Gone Wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同攻击[第2部分] -庞氏游戏出错</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/smart-contract-attacks-part-2-ponzi-games-gone-wrong-d5a8b1a98dd8?source=collection_archive---------17-----------------------#2018-07-23">https://medium.com/hackernoon/smart-contract-attacks-part-2-ponzi-games-gone-wrong-d5a8b1a98dd8?source=collection_archive---------17-----------------------#2018-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/185333fce7e28ea72ddf586f149f6ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpVN5nEddcXOtDIZMmVsPw.png"/></div></div></figure><p id="97ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">庞氏游戏。如果你在2016年关注以太坊区块链，你会知道早期的智能合约开发有过多的庞氏游戏。像传统的庞氏骗局一样，这些游戏的设计使得它们的继续取决于边缘玩家加入合同以保持“乐趣”继续。虽然这些合同注定会戛然而止，但有些人会发现结束的原因不同…</p><p id="0386" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="ka">智能合约攻击</em> ( <a class="ae kb" href="https://hackernoon.com/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0a" rel="noopener ugc nofollow" target="_blank">第一部分这里</a>)的第二部分，我将带你浏览三个成为智能合约漏洞受害者的庞氏游戏，以及如何避免犯同样的错误。您还将对智能合同开发、合同最佳实践以及以太坊最著名的庞氏游戏有更全面的了解。</p><h1 id="1ff4" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">攻击#1:异常紊乱</h1><p id="0569" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">当攻击者利用合同未能返回异常错误时，就会发生异常紊乱攻击。当合同调用<code class="eh lf lg lh li b">address.send()</code>或<code class="eh lf lg lh li b">address.call.value()</code>等函数不成功时，触发异常错误。错误本身不会被标记，除非合同被指示这样做；异常错误不会自动生成。</p><p id="0d5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">攻击<br/></strong>2016年2月6日<a class="ae kb" href="https://www.kingoftheether.com/thrones/kingoftheether/index.html" rel="noopener ugc nofollow" target="_blank">以太王座(KotET) </a>智能契约部署完毕。KotET是一种游戏，玩家将向合同发送一定数量的乙醚，以获得“王位”。一登上王位，这位球员就被加入了“帝王之殿”，并在区块链上永垂不朽。更重要的是，新国王有权获得由后来篡夺他们的国王支付的以太。随着继承王位的国王越来越多，成为国王的成本也越来越高。如果14天过去了还没有新的继任者，王位就被重置，游戏重新开始。这个想法是，一个新的国王付钱要求继承王位，意图是一个继任者出现并支付更高的价格——“更大的傻瓜理论”或庞氏骗局，如果你愿意…</p><p id="ab78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">下面的代码<br/> </strong>是最初KotET契约的简化版。注意回退功能，当玩家发送<code class="eh lf lg lh li b">msg.value</code>到契约时触发。回退功能将首先检查是否有足够的乙醚被送到国王手中，以便继承王位。如果没有，请求被抛出，代码被恢复。如果足够的以太被发送来要求王位，现有的国王收到上述补偿(索赔价格减去佣金)，发送者被加冕为新国王。总结一下，计算一个新的索赔价格。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="6dfa" class="lr kd hu li b fv ls lt l lu lv"><strong class="li hv">contract KotET {</strong></span><span id="d200" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    address public king;<br/>    uint public claimPrice = 100;<br/>    address owner;</strong></span><span id="d3bc" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">  </strong>  //constructor, assigning ownership</span><span id="3306" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    constructor() {<br/>        owner = msg.sender;<br/>        king = msg.sender;<br/>    }</strong></span><span id="dc1a" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    </strong>//for contract creator to withdraw commission fees<strong class="li hv"><br/>    function sweepCommission(uint amount) {<br/>        owner.send(amount);<br/>    }</strong></span><span id="4dcc" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">   </strong> //fallback function<strong class="li hv"><br/>    function() {<br/>        if (msg.value &lt; claimPrice) revert;<br/>        uint compensation = calculateCompensation();</strong></span><span id="9226" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">        <br/>        king.send(compensation);<br/>        king = msg.sender;<br/>        claimPrice = calculateNewPrice();<br/>    }</strong></span><span id="fde8" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">}</strong></span></pre><p id="3600" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">KotET契约的致命缺陷是使用了<code class="eh lf lg lh li b">address.send()</code>,并且在调用失败时没有检查异常错误。正如我在<a class="ae kb" href="https://hackernoon.com/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0a" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">智能契约攻击【第一部分】</strong></a><code class="eh lf lg lh li b">address.send()</code>和<code class="eh lf lg lh li b">address.transfer()</code>中讨论的，都被限制在2300的津贴。虽然这对于防止重入攻击来说很棒，但是如果国王的合同有花费&gt; 2300汽油的后备功能，汽油限制将导致无法向国王的地址发送资金。KotET就是这种情况，支付给被废黜国王的款项被发送到一个<strong class="je hv">以太迷雾“基于合同的钱包</strong>”而不是一个<strong class="je hv">“合同账户”，</strong>需要更多的汽油才能成功地将款项发送给即将被篡夺的国王。最终结果是一次不成功的付款转账，ether退回到KotET合同。因为付款永远不会寄给国王，所以新国王永远不会加冕，合同也永远无法解除。</p><p id="f655" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">解决方案<br/> </strong>我们可以通过用<code class="eh lf lg lh li b">king.call.value(Compensation)</code>替换契约的回退功能<code class="eh lf lg lh li b">king.send(Compensation)</code>来使契约更加安全。问题是，这将要求所有者分配一个足够大的天然气量，以方便大多数接收钱包合同，但也要足够低，以满足当前合同的大多数呼叫者——这几乎是一个不可能的任务。即使没有规定天然气的数量，合同仍然容易受到DoS攻击。攻击者可以创建一个带有回退函数的契约，该函数抛出一个异常<code class="eh lf lg lh li b">revert()</code>。这也会导致合同永久失效。</p><p id="d499" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">KotET可以用两种方法解决:</p><ol class=""><li id="493a" class="lx ly hu je b jf jg jj jk jn lz jr ma jv mb jz mc md me mf dt translated">抛出一个异常，调用被恢复——我们可以通过简单地将<code class="eh lf lg lh li b">revert</code>添加到函数中来实现。这将阻止合同被搁置，但需要额外的步骤来促进支付转移。想到的两个想法包括所有者自己发送批量支付(过于集中)，或者实现批量支付，确保支付一直发送到“头奖”中没有剩余资金。</li><li id="70ea" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated">与直接的<code class="eh lf lg lh li b">send</code>叫牌相反，实现一个撤销模式，契约可以被构造为玩家只能导致他或她自己的撤销失败，而不是契约的其余部分。撤销模式的唯一缺点是它的自主性差得多，需要更多的用户交互。让我们看看如何更新合同来实现这些更改。</li></ol><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="6263" class="lr kd hu li b fv ls lt l lu lv"><strong class="li hv">contract KotET {</strong></span><span id="6d66" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    address public king;<br/>    uint public claimPrice = 100;<br/>    uint public resolutionFunds<br/>    address owner;<br/>    mapping (address =&gt; uint) creditedFunds;<br/> <br/>    </strong>//constructor, assigning ownership<strong class="li hv"><br/>    constructor() {<br/>        owner = msg.sender;<br/>        king = msg.sender;<br/>    }<br/> <br/>    </strong>//for contract creator to withdraw commission fees<strong class="li hv"><br/>    function sweepCommission(uint amount) {<br/>        owner.send(amount);<br/>    }<br/> <br/>    </strong>//for assigning new king and crediting balance<strong class="li hv"><br/>    function becomeKing() public payable returns (bool) {<br/>        if (msg.value &gt; claimPrice) {<br/>            creditedFunds[richest] += msg.value;<br/>            king = msg.sender;<br/>            return true;<br/>        } else {<br/>            return false;<br/>        }<br/>    }<br/>    <br/>    function withdraw() public {<br/>        uint amount = creditedFunds[msg.sender];<br/>        </strong>//zeroing the balance BEFORE sending creditedFunds<br/>        //to prevent re-entrancy attacks<strong class="li hv"><br/>        pendingWithdrawals[msg.sender] = 0;<br/>        msg.sender.transfer(amount);<br/>    }</strong></span><span id="396b" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">}</strong></span></pre><p id="102e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嘣！现在，合同不再依赖后备功能来执行新国王的加冕<em class="ka">和</em>直接发送资金给被篡夺的国王。契约现在是安全的，不会受到任何可能危及契约的回退/重入攻击。</p><h1 id="c427" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">攻击#2:调用堆栈攻击</h1><p id="9ed4" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在<a class="ae kb" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md" rel="noopener ugc nofollow" target="_blank"> EIP 150 </a>实现之前，EVM的可达调用栈深度为1024帧。这意味着某人可以调用合约1023次，直到第1024次调用自动失败。攻击者会故意拨打第1023次电话，导致随后的电话失败，从而窃取资金/获得合同控制权。</p><p id="1227" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与KotET类似，GovernMental是一个庞氏游戏，参与者向契约中发送一定数量的乙醚以加入。每一轮的赢家取决于赢得“头奖”的那一轮。游戏规则如下:</p><ul class=""><li id="978e" class="lx ly hu je b jf jg jj jk jn lz jr ma jv mb jz ml md me mf dt translated">你必须至少借1 ETH给合同，你有权得到+ 10%的利息</li><li id="1025" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz ml md me mf dt translated">如果“政府”(合同)在12小时内没有收到新的资金，最新的债权人将获得头奖，所有其他人都将失去他们的债权</li><li id="56e0" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz ml md me mf dt translated">发给合同的乙醚是这样分配的:5%给累积奖金，5%给管理政府的腐败精英(合同所有者)，90%用于按照债权人的信用日期支付他们</li><li id="35e7" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz ml md me mf dt translated">当头奖满时(10K联邦理工学院)，95%支付给债权人</li><li id="a8b5" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz ml md me mf dt translated">额外好处:债权人可以为想要加入的朋友使用附属链接。如果一个朋友为合同做了贡献，那么5%归债权人，5%归腐败精英(合同所有者)，5%归累积奖金，85%用于支出。</li></ul><p id="c247" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">合同是这样写的，参与者和他们的资金记录在两个数组中，<code class="eh lf lg lh li b">address[] public credAddr</code>和<code class="eh lf lg lh li b">uint[] public credAmt</code>。这两个数组都将在每场游戏结束时被重置。政府取得了足够的成功，阵列变得如此之大，以至于清除它们所需的气体超过了单次交易所允许的最大值。最终结果是累积奖金永久冻结，总计约1100以太。然而，就在Vitalik Buterin在Reddit上建议支付“价值50 ETH的交易费，以将汽油限制提高到510万”后大约3个小时，有人开始为卡住的奖励付费。大约过了2个月，<a class="ae kb" href="https://etherscan.io/txsInternal?a=0xf45717552f12ef7cb65e95476f217ea008167ae3&amp;p=5" rel="noopener ugc nofollow" target="_blank">资金终于解锁，发给了坚持不懈的来电者。</a></p><p id="d919" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然GovernMental没有受到恶意用户/所有者的攻击，但它是调用堆栈攻击可能造成的损害的主要例子。它还展示了当涉及到基金所有权时，在处理数组和大型数据集时需要表现出的深思熟虑。</p><p id="f465" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">下面的代码<br/> </strong>是完整的政府智能合同代码，带有一些缩短的全局变量。我已经完整地包含了真实的合同，因为通过逐行检查这个合同可以学到很多东西，包括合同是如何构造的。人们可以看到<code class="eh lf lg lh li b">function lendGovernmentMoney()</code>引用了债权人的地址和重置或添加到现有数组所需的以太量。请注意，在这个相同的功能中，当自最后一个债权人加入以来已经过了12个小时时，资金是如何在合同所有者和最后一个债权人之间分配的— <code class="eh lf lg lh li b">credAddr[credAddr.length 1].send(profitFromCrash);</code>和<code class="eh lf lg lh li b">corruptElite.send(this.balance);</code> <strong class="je hv">。</strong></p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="0735" class="lr kd hu li b fv ls lt l lu lv"><strong class="li hv">contract Government {</strong></span><span id="25c4" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">  </strong>  // Global Variables<strong class="li hv"><br/>    uint32 public lastPaid;<br/>    uint public lastTimeOfNewCredit;<br/>    uint public profitFromCrash;<br/>    address[] public credAddr;<br/>    uint[] public credit;<br/>    address public corruptElite;<br/>    mapping (address =&gt; uint) buddies;<br/>    uint constant TWELVE_HOURS = 43200;<br/>    uint8 public round;<br/></strong></span><span id="e2c1" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    </strong>// constructor<strong class="li hv"><br/>    constructor() {</strong></span><span id="0f32" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">        profitFromCrash = msg.value;<br/>        corruptElite = msg.sender;<br/>        lastTimeOfNewCredit = block.timestamp;<br/>    }</strong></span><span id="8442" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    function lendGovernmentMoney(address buddy) returns (bool) {<br/>        uint amount = msg.value;<br/>        <br/>    </strong>    // check if the system already broke down. <br/>        // If 12h no new creditor gives new credit to <br/>        // the system it will brake down.<br/>        // 12h are on average = 60*60*12/12.5 = 3456</span><span id="5cd1" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">        if (lastTimeOfNewCredit + TWELVE_HOURS &lt; block.timestamp) <br/>            </strong>// Return money to sender<strong class="li hv"><br/>            msg.sender.send(amount);<br/>            <br/>            </strong>// Sends all contract money to the last creditor<strong class="li hv"><br/>            credAddr[credAddr.length - 1].send(profitFromCrash);<br/>            corruptElite.send(this.balance);<br/>           </strong> <br/>            // Reset contract state<strong class="li hv"><br/>            lastPaid = 0;<br/>            lastTimeOfNewCredit = block.timestamp; <br/>            profitFromCrash = 0;<br/>            </strong>// this is where the arrays are cleared<strong class="li hv"><br/>            credAddr = new address[](0);<br/>            credAmt = new uint[](0);<br/>            round += 1;<br/>            return false;<br/>        } <br/>        else {</strong></span><span id="b143" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">            </strong>// the system needs to collect at <br/>            // least 1% of the profit from a crash to stay alive<strong class="li hv"><br/>            if (amount &gt;= 10 ** 18) {</strong></span><span id="6e45" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">                </strong>// the System has received fresh money, <br/>                // it will survive at leat 12h more<strong class="li hv"><br/>                lastTimeOfNewCredit = block.timestamp;<br/>                <br/>                </strong>// register the new creditor and his <br/>                // amount with 10% interest rate<strong class="li hv"><br/>                credAddr.push(msg.sender);<br/>                credAmt.push(amount * 110 / 100);</strong></span><span id="48d1" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">                </strong>// now the money is distributed<br/>                // first the corrupt elite grabs 5% — thieves!<strong class="li hv"><br/>                corruptElite.send(amount * 5/100);</strong></span><span id="283d" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">                </strong>// 5% are going into the economy (they will increase<br/>                // the value for the person seeing the crash coming)<strong class="li hv"><br/>                if (profitFromCrash &lt; 10000 * 10**18)<br/>                    profitFromCrash += amount * 5/100;<br/>                }</strong></span><span id="cfb5" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">              </strong>  // if you have a buddy in the government (and he is<br/>                // in the creditor list) he can get 5% of your <br/>                // credits. Make a deal with him.<br/>                <strong class="li hv">if(buddies[buddy] &gt;= amount) {<br/>                    buddy.send(amount * 5/100);<br/>                }<br/>                buddies[msg.sender] += amount * 110 / 100;</strong></span><span id="510f" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">                </strong>// 90% of money used to pay out old creditors<strong class="li hv"><br/>                if (credAmt[lastPaid] &lt;= address(this).balance — profitFromCrash){<br/>                   credAddr[lastPaid].send(credAmt[lastPaid]);<br/>                   buddies[credAddr[lastPaid]] -= credAmt[lastPaid];<br/>                   lastPaid += 1;<br/>                }<br/>                return true;<br/>            } <br/>            else {<br/>                msg.sender.send(amount);<br/>                return false;<br/>            }<br/>        }<br/>    }</strong></span><span id="65b2" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv"><br/>   </strong> // fallback function<strong class="li hv"><br/>    function() {<br/>        lendGovernmentMoney(0);<br/>    }<br/>    <br/>    function totalDebt() returns (uint debt) {<br/>        for(uint i=lastPaid; i&lt;credAmt.length; i++){<br/>            debt += credAmt[i];<br/>        }<br/>    }</strong></span><span id="6273" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    function totalPayedOut() returns (uint payout) {<br/>        for(uint i=0; i&lt;lastPaid; i++){<br/>            payout += credAmt[i];<br/>        }<br/>    }</strong></span><span id="5243" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">  </strong>  // donate funds to "the government"<br/>    <strong class="li hv">function investInTheSystem() {<br/>        profitFromCrash += msg.value;<br/>    }</strong></span><span id="8288" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    </strong>// From time to time the corrupt elite <br/>    // inherits it’s power to the next generation<br/><strong class="li hv">    function inheritToNextGeneration(address nextGeneration) {<br/>        if (msg.sender == corruptElite) {<br/>            corruptElite = nextGeneration;<br/>        }<br/>    }</strong></span><span id="6096" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    function getCreditorAddresses() returns (address[]) {<br/>        return credAddr;<br/>    }<br/>  <br/>    function getCreditorAmounts() returns (uint[]) {<br/>        return credAmt;<br/>    }<br/>}</strong></span></pre><p id="92e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们假设一个攻击者写了下面这个契约来恶意攻击<code class="eh lf lg lh li b">contract Government {}</code>。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="e22d" class="lr kd hu li b fv ls lt l lu lv"><strong class="li hv">contract attackGov { </strong></span><span id="553f" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">function attackGov (address target, uint count) {<br/>   <br/>    if (0&lt;= count &amp;&amp; count&lt;1023) {<br/>        this.attackGov.gas(gasleft() - 2000)(target, count+1);<br/>    } <br/>    else {<br/>       attackGov(target).lendGovernmentMoney;</strong></span><span id="b141" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    }</strong></span><span id="0281" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">}</strong></span></pre><p id="e383" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">攻击者调用<code class="eh lf lg lh li b">contract attackGov{}</code>进行递归调用，直到堆栈大小达到1023。当堆栈达到1022时，以堆栈大小1023执行<code class="eh lf lg lh li b">function lendGovernmentMoney()</code> <em class="ka"> </em>。因为第1024次调用被设计为失败，并且<code class="eh lf lg lh li b">send()</code>不检查返回的代码，所以政府的<code class="eh lf lg lh li b">credAddr[credAddr.length — 1].send(profitFromCrash);</code>失败。然后，合同自行重置，下一轮谈判准备开始。因为支付失败，该合同现在具有上一轮的累积奖金，并且所有者将在下一轮完成时收到它，<code class="eh lf lg lh li b">corruptElite.send(this.balance);</code>。</p><p id="7dd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">解决方案<br/> </strong>那么到底如何才能避免调用栈攻击呢？幸运的是<a class="ae kb" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md" rel="noopener ugc nofollow" target="_blank">以太坊改进协议(EIP) 150 </a>包含了一个更新，使得调用栈深度1024几乎不可能达到。该规则规定，通话的孩子消耗的汽油不能超过父母的63/64。即使稍微接近调用堆栈的限制，代价也会高得令人难以置信，以至于攻击者会毫不犹豫地继续下去。</p><p id="6ea2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，处理大量数据时的最佳实践包括:</p><ul class=""><li id="4815" class="lx ly hu je b jf jg jj jk jn lz jr ma jv mb jz ml md me mf dt translated">编写合同，以便将数组清算工作划分到几个事务中，而不是一个或多个事务</li><li id="22dd" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz ml md me mf dt translated">以一种允许用户单独处理与他们自己关联的数组元素的方式编写协定。</li></ul><h1 id="e63f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">攻击# 3——不可变构造函数错误</h1><p id="c266" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">是什么让智能合约如此特别？它们是不可改变的。是什么让智能合同成为噩梦？它们是不可改变的。到目前为止，人们已经放弃了一个结论，即在撰写一份明智的合同时，可能会出现很多问题。在合同生效之前，必须对功能、全局变量和整体合同结构进行彻底审查。</p><p id="cc47" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果有一个智能合同将作为疏忽合同构造的海报儿童而载入以太坊历史，那无疑是Rubixi。Rubixi是另一个庞氏游戏，玩家将乙醚送到合同中，期望至少收到适度更多的乙醚。然而，在Rubixi开发期间的某个时间点，业主随意更改了合同名称，并且未能检查由于更改而导致的任何不一致。不用说，卢比西远远没有被贴上“成功”的标签。</p><p id="3a78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">攻击<br/> </strong>从Solidity v0.4.24开始，契约的构造函数表示为<code class="eh lf lg lh li b">construct()</code>。然而，当Rubixi契约被创建时，EVM通过共享与该契约相同的名称来标识构造函数。Rubixi的问题是，当部署契约时，构造函数被设置为<code class="eh lf lg lh li b">function DynamicPyramid()</code>而不是<code class="eh lf lg lh li b">function Rubixi()</code>，这意味着Rubixi最初可能被称为“DynamicPyramid”。由于这种不一致，合同没有在合同创建时指定所有者，城堡的钥匙是公开的。任何人都可以将自己指定为合同的所有者，并收取参与玩家产生的合同费用。</p><p id="b945" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">代码<br/> </strong>如果我们提取契约代码的前几行，您可以看到契约名称和预期构造函数之间的差异。如果您想查看Rubixi的原始合同，请点击此处。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="95ca" class="lr kd hu li b fv ls lt l lu lv"><strong class="li hv"><br/>contract Rubixi {</strong></span><span id="eac9" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    </strong>//Declare variables for storage critical to contract<strong class="li hv"><br/>    uint private balance = 0;<br/>    uint private collectedFees = 0;<br/>    uint private feePercent = 10;<br/>    uint private pyramidMultiplier = 300;<br/>    uint private payoutOrder = 0;</strong></span><span id="ba99" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    address private creator;</strong></span><span id="d5af" class="lr kd hu li b fv lw lt l lu lv"><strong class="li hv">    </strong>//Sets creator<strong class="li hv"><br/>    function DynamicPyramid() {<br/>        creator = msg.sender;<br/>    }</strong></span></pre><p id="57d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">攻击<br/> </strong>您现在可能已经知道了，攻击者所要做的就是创建一个名为<code class="eh lf lg lh li b">function DynamicPyramid()</code>的契约，从而授予他们所有权。从那里，攻击者可以打电话给<code class="eh lf lg lh li b">function collectAllFees()</code>并提取现金。虽然攻击相当直接，但Rubixi是另一个说明彻底审查合同重要性的典型例子。</p><pre class="lj lk ll lm fq ln li lo lp aw lq dt"><span id="8769" class="lr kd hu li b fv ls lt l lu lv"><strong class="li hv">contract extractRubixi {<br/> <br/>    address owner;<br/>    Rubixi r = Rubixi(0xe82...);<br/> <br/>    constructor() public {<br/>        owner=msg.sender;<br/>    }<br/> <br/>    function setAndGrab() public {<br/>        r.DynamicPyramid();<br/>        r.collectAllFees();<br/>    }<br/> <br/>}</strong></span></pre><p id="e08d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">解决方案<br/> </strong>幸运的是，Solidity已经更新，因此构造函数由<code class="eh lf lg lh li b">constructor() </code>定义，而不是由<code class="eh lf lg lh li b">contractName()</code>定义。我们可以从中学到的是，加倍、三倍、四倍地检查你的合同代码的每一个方面，并确保你在整个开发过程中保持一致。没有什么比部署一个不可变的契约却发现一个愚蠢的、代价高昂的错误更糟糕的了。</p><h1 id="c822" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">在一天结束的时候…</h1><p id="a391" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">庞氏骗局可能已经成为过去，但正如乔治·桑塔亚纳曾经说过的一句名言，<em class="ka">“那些不能从历史中吸取教训的人注定会重蹈覆辙”。通过从KotET、GovernMental和Rubixi的失败中吸取教训，我们都可以省去再次走上错误道路的头痛。希望你现在对可靠性有了更好的理解，并且对智能合同开发更有信心。如果你喜欢这篇文章，请随时留下“掌声”和/或评论！</em></p><h2 id="2505" class="lr kd hu bd ke mm mn mo ki mp mq mr km jn ms mt kq jr mu mv ku jv mw mx ky my dt translated">想写你的第一份智能合同吗？查看我的教程</h2><h2 id="da26" class="lr kd hu bd ke mm mn mo ki mp mq mr km jn ms mt kq jr mu mv ku jv mw mx ky my dt translated"><a class="ae kb" href="https://hackernoon.com/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0a" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">智能契约攻击【上篇】— 3攻击我们都要向刀</strong> </a>学习</h2><ul class=""><li id="cb31" class="lx ly hu je b jf la jj lb jn mz jr na jv nb jz ml md me mf dt translated">银箱</li></ul><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="nc nd l"/></div></figure></div></div>    
</body>
</html>