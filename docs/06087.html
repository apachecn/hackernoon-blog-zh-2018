<html>
<head>
<title>How to train neural network on browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在浏览器上训练神经网络</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-train-neural-network-on-browser-7a435132a1ed?source=collection_archive---------28-----------------------#2018-07-23">https://medium.com/hackernoon/how-to-train-neural-network-on-browser-7a435132a1ed?source=collection_archive---------28-----------------------#2018-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/050a86fd5fc46f16132b37ccd4f1843b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/1*BXT-5WQCFpyHAAMQJJGYFw.gif"/></div></figure><p id="a04d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">无论你是深度学习的新手还是经验丰富的老手，建立一个训练神经网络的环境有时会很痛苦。让训练一个神经网络变得像加载一个网页，然后点击几下，你就可以马上用它进行推理一样简单，这是不是很棒？</p><p id="00c9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在本教程中，我将向您展示如何使用浏览器上的框架TensorFlow.js以及从您的网络摄像头收集的数据和在您的浏览器上的训练来构建模型。为了让这个模型有用，我们将把一个网络摄像头变成传奇游戏“乒乓”的控制器。</p><h1 id="0f8b" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">让我们先玩游戏</h1><p id="38e8" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt kz translated"><span class="l la lb lc bm ld le lf lg lh di"> I </span>指令要在您的计算机上本地提供web应用程序，</p><ul class=""><li id="51b4" class="li lj hu ja b jb jc jf jg jj lk jn ll jr lm jv ln lo lp lq dt translated">下载<a class="ae lr" href="https://github.com/Tony607/webcam-pong/releases/download/V0.1/dist.zip" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> dist.zip </strong> </a>并解压到你的本地机器。</li><li id="ba81" class="li lj hu ja b jb ls jf lt jj lu jn lv jr lw jv ln lo lp lq dt translated">安装一个HTTP服务器，我的建议是npm全局安装<strong class="ja hv"> http-server </strong>，</li></ul><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="ee70" class="mg jx hu mc b fv mh mi l mj mk">npm install -g http-server</span></pre><p id="2c6f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你问什么是npm？它是Node.js的一个包安装程序，就像Python的pip一样，可以在这里<a class="ae lr" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">获得</a>。</p><ul class=""><li id="c153" class="li lj hu ja b jb jc jf jg jj lk jn ll jr lm jv ln lo lp lq dt translated">在命令行中运行下面的命令，其中<strong class="ja hv"> dist </strong>文件夹位于本地机器上的一个端口，比如1234。</li></ul><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="5530" class="mg jx hu mc b fv mh mi l mj mk">http-server dist --cors -p 1234 -s</span></pre><ul class=""><li id="989e" class="li lj hu ja b jb jc jf jg jj lk jn ll jr lm jv ln lo lp lq dt translated">将一个浏览器窗口指向<a class="ae lr" href="http://localhost:1234/" rel="noopener ugc nofollow" target="_blank"> http://localhost:1234 </a>，我在Chrome和Firefox上进行了测试。</li><li id="dec3" class="li lj hu ja b jb ls jf lt jj lu jn lv jr lw jv ln lo lp lq dt translated">当页面完成加载时，从收集左、中、右三个动作的训练图像开始。这里有一个提示，平衡训练样本，每个案例可能有大约20个样本。</li><li id="ef27" class="li lj hu ja b jb ls jf lt jj lu jn lv jr lw jv ln lo lp lq dt translated">单击“TRAIN ”,它将开始带有亏损显示的培训过程。</li><li id="82b1" class="li lj hu ja b jb ls jf lt jj lu jn lv jr lw jv ln lo lp lq dt translated">输了不改表示训练结束，现在点击“玩”开始游戏。</li><li id="8196" class="li lj hu ja b jb ls jf lt jj lu jn lv jr lw jv ln lo lp lq dt translated">如果您想重新开始，请单击“重置”。</li></ul><p id="0b0c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在你厌倦了用你的选择用头或手敲打电脑之后，让我们来看看这个游戏是如何构建的。本教程中使用了两个模型，第一个是从Keras导出的预训练卷积网络，它负责从网络摄像头图像中提取图像特征。第二个模型在你的浏览器上构建和训练，用图像特征对游戏控制进行预测。它是一个回归模型，预测值范围在-1~1之间，以控制玩家的球拍速度。本质上是一种迁移学习任务。更多关于迁移学习的话题，参考我之前的系列— <a class="ae lr" href="https://www.dlology.com/blog/gentle-guide-to-setup-keras-deep-learning-framework-and-build-a-travel-recommendation-engine/" rel="noopener ugc nofollow" target="_blank">温柔指南设置Keras深度学习框架，构建旅游推荐引擎</a>。不多说了，我们开始吧。你现在可以从我的GitHub repo<a class="ae lr" href="https://github.com/Tony607/webcam-pong" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">web cam-pong</strong></a>下载源代码。</p><h1 id="d108" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">将预训练模型导出到tfjs</h1><p id="b570" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt kz translated">如果你只是想学习web应用部分，你可以跳过这一节。</p><p id="a1a6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们首先将一个预先训练好的卷积网络导出为TensorFlow.js(tfjs)格式。在本教程中，我选择了用ImageNet数据集训练的DenseNet，但你也可以使用其他模型，如MobileNet。尽量避免大型深度卷积网络，如ResNets和VGGs，即使它们可能提供稍高的精度，但不适合边缘设备，如我们在浏览器上运行的情况。</p><p id="1c68" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一步是用Python脚本将预先训练好的DenseNet Keras模型保存到一个<strong class="ja hv"> .h5 </strong>文件中。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="cf7f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，我们运行转换脚本，将. h5文件转换为针对浏览器缓存优化的tfjs文件。在继续之前，通过pip3安装tensorflowjs转换脚本python包。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="6c90" class="mg jx hu mc b fv mh mi l mj mk">pip3 install tensorflowjs</span></pre><p id="d93f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们现在可以通过运行以下命令来生成tfjs文件，</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="b20e" class="mg jx hu mc b fv mh mi l mj mk">cd ./tfjs-densenet<br/>tensorflowjs_converter --input_format keras ./model.h5 ./model</span></pre><p id="5fd5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你会看到一个名为<strong class="ja hv">型号</strong>的文件夹，里面有几个文件。<strong class="ja hv"> model.json </strong>文件定义了模型结构和权重文件的路径。并且预先训练的模型准备好为web应用服务。例如，您可以将<strong class="ja hv"> model </strong>文件夹重命名为<strong class="ja hv"> serveDenseNet </strong>并复制到您的web app served文件夹，然后模型就可以这样加载了。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="9078" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh mn mo mp mc b">window.location.origin</code>是web应用程序的URL，或者如果您在1234端口本地提供它，它将是<code class="eh mn mo mp mc b">localhost:1234</code>。<code class="eh mn mo mp mc b">await</code>声明只是允许web应用程序在后台加载模型，而不冻结主用户界面。</p><p id="ef2d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，要认识到，由于我们加载的模型是一个图像分类模型，我们不需要顶部的图层，我们只需要模型的特征提取部分。解决方案是找到最顶层的卷积层，并截断前面代码片段中显示的模型。</p><h1 id="c777" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">从网络摄像头生成训练数据</h1><p id="617b" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt kz translated"><span class="l la lb lc bm ld le lf lg lh di">为了</span>准备回归模型的训练数据，我们将从网络摄像头中抓取一些图像，并使用web应用程序中的预训练模型提取它们的特征。为了简化用于采集训练数据的用户界面，我们仅使用三个值[-1，0，1]中的一个来标记图像。</p><p id="16aa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于通过网络摄像头获取的每幅图像，它将被输入预先训练的DenseNet，以提取特征并保存为训练样本。在将图像通过特征提取器模型之后，224×224的彩色图像将使其维数减少到形状为[7，7，1024]的图像特征张量。形状取决于你选择的预先训练好的模型，可以通过调用我们在上一节中选择的图层上的<code class="eh mn mo mp mc b">outputShape</code>来获得，就像这样。</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d724" class="mg jx hu mc b fv mh mi l mj mk">modelLayerShape = layer.outputShape.slice(1)</span></pre><p id="eee5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用提取的图像特征而不是原始图像作为训练数据的原因有两个。首先，它节省了存储训练数据的内存，其次，它通过不运行特征提取模型来减少训练时间。</p><p id="da13" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面的片段展示了如何通过网络摄像头捕捉图像，并提取和汇总其特征。请注意，所有图像特征都以张量的形式保存，这意味着如果您的模型与浏览器的WebGL后端一起运行，它在GPU内存中一次可以安全包含多少训练样本是有限制的。所以不要指望用数千甚至数百个图像样本训练你的模型取决于你的硬件。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="8c0a" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">建立和训练神经网络</h1><p id="6163" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt kz translated"><span class="l la lb lc bm ld le lf lg lh di"> B </span>在不上传到任何云服务的情况下建立和训练你的神经网络，保护你的隐私，因为数据永远不会离开你的设备，在你的浏览器上观察它会使它变得更酷。</p><p id="83da" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">回归模型将图像特征作为输入，将其展平为向量，然后跟随两个完全连接的层，并生成一个浮点数来控制游戏。最后一个完全连接的层没有激活函数，因为我们希望它产生-1到1之间的实数。我们选择的损失函数是训练期间的均方误差，以最小化损失。更多关于选择，看我的帖子— <a class="ae lr" href="https://www.dlology.com/blog/how-to-choose-last-layer-activation-and-loss-function/" rel="noopener ugc nofollow" target="_blank">如何选择最后一层激活和损失函数</a>。</p><p id="7d03" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以下代码将构建、编译和拟合模型。看起来很像Keras的工作流程吧？</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="f02f" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">将网络摄像头变成乒乓控制器</h1><p id="08b3" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt kz translated"><span class="l la lb lc bm ld le lf lg lh di"> As </span>你可能期望用一个类似Keras语法的图像来预测。图像首先被转换成图像特征，然后被传递到训练好的回归神经网络，该网络输出-1到1之间的控制器值。</p><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="d9d7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一旦你训练好了模型，游戏开始运行，预测值就会通过这个调用<code class="eh mn mo mp mc b">pong.updatePlayerSpeed(value)</code>向下传递，以控制玩家的球拍向左或向右变速运动的速度。您可以通过调用来开始和停止游戏，</p><ul class=""><li id="ef44" class="li lj hu ja b jb jc jf jg jj lk jn ll jr lm jv ln lo lp lq dt translated"><strong class="ja hv"> pong.startGameplay() </strong>按下<strong class="ja hv"> Play </strong>按钮就会发生</li><li id="12bf" class="li lj hu ja b jb ls jf lt jj lu jn lv jr lw jv ln lo lp lq dt translated"><strong class="ja hv">点击<strong class="ja hv">复位</strong>按钮，会调用pong.stopGameplay() </strong>。</li></ul><p id="37e5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">可以通过调用<code class="eh mn mo mp mc b">pong.updateMultiplier(multiplier)</code>来调整球拍移动的力度，当前的乘数值在Pong的类构造函数中被设置为12。</p><h1 id="bc8b" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">结论和进一步的思考</h1><p id="fd6d" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt kz translated"><span class="l la lb lc bm ld le lf lg lh di">在</span>这个教程中，你已经学会了如何在一个带有TensorFlow.js的浏览器上训练一个神经网络，并把你的网络摄像头变成一个Pong控制器来识别你的动作。请随意检查我的源代码，并对它进行实验，修改它，看看结果如何，如激活函数，损失函数和交换到另一个预先训练的模型等。在具有即时反馈的浏览器上训练神经网络的美妙之处在于，它使我们能够尝试新的想法，更快地获得结果，因为我们的原型也使它更容易被大众接受。在我的GitHub repo<a class="ae lr" href="https://github.com/Tony607/webcam-pong" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv">web cam-pong</strong></a>上查看完整源代码。</p><div class="mq mr fm fo ms mt"><a href="https://github.com/Tony607/webcam-pong" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab ej"><div class="mv ab mw cl cj mx"><h2 class="bd hv fv z el my eo ep mz er et ht dt translated">Tony 607/网络摄像头-乒乓</h2><div class="na l"><h3 class="bd b fv z el my eo ep mz er et ek translated">网络摄像头-乒乓-通过网络摄像头学习玩乒乓</h3></div><div class="nb l"><p class="bd b gc z el my eo ep mz er et ek translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh iw mt"/></div></div></a></div><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="fe ff ni"><img src="../Images/31cb4aa596bcfd16b26f68ee32f94871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QAW_6bbTxioTWFY6.png"/></div></div></figure></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><figure class="lx ly lz ma fq iv"><div class="bz el l di"><div class="nu mm l"/></div></figure><p id="99bc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="nv">原载于www.dlology.com</em><a class="ae lr" href="https://www.dlology.com/blog/how-to-train-neural-network-on-browser/" rel="noopener ugc nofollow" target="_blank"><em class="nv"/></a><em class="nv">。</em></p></div></div>    
</body>
</html>