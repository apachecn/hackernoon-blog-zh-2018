<html>
<head>
<title>State of Bliss: Handle Your State with React, Apollo, and Unstated</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">极乐状态:用反应、阿波罗和未陈述来处理你的状态</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/state-of-bliss-handle-your-state-with-react-apollo-and-unstated-f79f872224ad?source=collection_archive---------45-----------------------#2018-07-23">https://medium.com/hackernoon/state-of-bliss-handle-your-state-with-react-apollo-and-unstated-f79f872224ad?source=collection_archive---------45-----------------------#2018-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/22125a407784d5527fd303a9fe7fc5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aa2b4SBQyHtJygnC.jpg"/></div></div></figure><p id="390c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Apollo是使用客户端缓存管理远程数据的最佳解决方案。但是，如果您已经在使用Apollo(或另一个客户端缓存，如Relay ),问题是:您应该如何处理客户端状态的其余部分？React的新上下文API(在16.3中可用或作为polyfill)为处理应用程序状态开辟了新的可能性。在<a class="ae ka" href="https://www.okgrow.com/posts/www.okgrow.com" rel="noopener ugc nofollow" target="_blank"> OK成长！</a>，我们一直试图找到一种幸福的状态，将来自服务器的数据、组件状态和应用程序状态结合起来，这种状态并不总是平稳的。</p><h1 id="d131" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">应用程序状态很小</h1><p id="5a02" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在看了丹·阿布拉莫夫在ReactEurope的开创性演讲后，我对Redux产生了兴趣。在我学习了Redux的基础知识之后，我开始寻找关于“高级Redux”的信息但这让我直面Redux给<a class="ae ka" href="https://hackernoon.com/tagged/apollo" rel="noopener ugc nofollow" target="_blank"> Apollo </a>用户带来的问题:我发现的每一个教程都是在实现客户端缓存。您将学习用Redux实现异步的三种方法，然后实现这些异步操作来处理您的Redux存储。但是Apollo的客户端缓存已经做到了这一切。它处理我所有的加载和错误状态，它处理乐观的更新，你能想到的。那么还剩下什么需要管理呢？</p><p id="8dac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实证明，对于大多数应用程序来说，答案是非常少的。它的大部分应该只是生活在<a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank">里起反应的</a>组件。</p><h1 id="3813" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为了更好的可测试性，集中到Redux怎么样？</h1><p id="25ba" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我同意这使得测试非常容易，但是我有两个问题:</p><ol class=""><li id="7ef3" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">它打破了封装。拥有一个组件系统的全部意义在于封装。React允许您将状态放入组件中，这样当您在其他地方工作时，就不必考虑该组件中发生了什么。一旦您试图分离功能，您头脑中就记住了两件事，组件和状态(现在可能在一个单独的文件中，所以您需要打开更多的缓冲区)。不仅如此，还有风险是人家(绝对不是你！)将试图从不同的组件获取该状态。</li><li id="545c" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><strong class="je hv">从组件中移除状态感觉不太好。</strong>我听说过开发人员用功能组件制作整个应用程序，所有状态都来自Redux。嘿，我有一个“让我们使用所有功能组件！”相也。但拥有一个全球商店绕过了自上而下的数据流，让你的应用程序更难推理。此外，这需要更多的代码！</li></ol><p id="83eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种变化部分源于这样一个事实，即测试组件长期以来一直相当尴尬，但我认为我们可以使用像<a class="ae ka" href="https://reactjs.org/docs/test-renderer.html" rel="noopener ugc nofollow" target="_blank"> React Test Renderer </a>这样的工具来解决这个问题(在未来的帖子中会有更多相关内容)，或者可能使用像<a class="ae ka" href="https://github.com/react-cosmos/react-cosmos" rel="noopener ugc nofollow" target="_blank"> Cosmos </a>这样的新工具。</p><p id="ca74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一些应用程序将真正受益于Redux，所以我不是说不使用它。但是在我自己的工作中，一旦Apollo接管了远程数据同步和缓存，我还不能证明开销的合理性。</p><h1 id="697c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">剩下什么状态要管理？</h1><p id="4b3e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您将大部分状态放入组件中，并且有一个客户端缓存，那么还剩下什么呢？几乎没有。在一个应用程序中，我只需要管理一个全局状态变量。但是我尝试用旧的上下文API直接管理它，这使我确信应用程序范围的状态仍然是一个值得解决的问题！以下是我认为属于应用程序范围状态的一些合法内容:</p><ul class=""><li id="447a" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz ls lk ll lm dt translated"><strong class="je hv">表示需要在路线之间共享。</strong>当您遇到路由边界时，自顶向下的数据传播遇到了障碍。当然，您会将一些参数传递给相关的路由，但是传递共享状态会导致灾难。用应用状态代替就行了。</li><li id="3f86" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated"><strong class="je hv">到处都在使用的状态。当然，你可以把它放在你的根组件中，并把它传递下去，但是为什么呢？顺便说一下，我认为可以将当前会话信息(例如，用户是否登录)存储在state中，即使您也可以使用Apollo做到这一点。</strong></li></ul><p id="7b56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我工作的最后一个应用程序中，我们尝试了<a class="ae ka" href="https://www.apollographql.com/docs/link/links/state.html" rel="noopener ugc nofollow" target="_blank">阿波罗链接状态</a>。这种逻辑很有说服力:既然您已经有了一个很好的库来查询和更新数据库中的值，而且既然您的大部分数据已经是这种格式了，为什么不用同样的方式存储您的应用程序状态呢？这样就有了一种方法，可以使用现有的反应式查询组件来更新UI元素，而不管数据是本地的还是远程的。</p><p id="6d0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">公平地说，Apollo Link State完全可以工作，尽管我在Apollo的新增功能上遇到了一些尖锐的问题。真正的问题是，你生产和消费本地应用数据的方式与远程数据的模式不匹配。对远程数据的查询往往只针对应用程序的一部分，不会重复太多。这些查询故意是冗长的，以阐明客户机和服务器之间的关系，并且它们可以驻留在它们自己的文件中，并且可以具有乐观更新、基于突变的更新等选项。它们还广泛使用加载/错误状态、选择所需字段的能力等。但根据定义，应用程序数据无处不在且简单——通常是键值对，或者有时是在应用程序的多个位置读取和更新的各种组合中需要的对象。您不需要选择字段、处理加载状态等。为这些事情编写查询非常笨拙而且过于冗长，不要忘记查询和变异需要单独的代码。</p><p id="bb70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个例子:我们有一个从餐馆点菜的应用程序。如果你离开你的桌子，它应该清除未完成的订单，并删除你坐的桌号。但是如果你有一张未支付的标签(票)，你不应该能做那件事。我们在状态查询和突变中使用了带有渲染道具的组件，这是应用程序中出现的一段代码:</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="daf8" class="mc kc hu ly b fv md me l mf mg">&lt;ClearOrder<br/>    render={clearOrder =&gt; (<br/>      &lt;SetCurrentTable<br/>        render={setCurrentTable =&gt; (<br/>          &lt;GetOrderStatus<br/>            render={({ ticketId }) =&gt; (<br/>              &lt;HeaderButton<br/>                label="Leave Table"<br/>                disabled={!!ticketId}<br/>                onPress={() =&gt; {<br/>                  clearOrder();<br/>                  setCurrentTable({ qrCode: '' });<br/>                }}<br/>              /&gt;<br/>            )}<br/>          /&gt;<br/>        )}<br/>      /&gt;<br/>    )}<br/>  /&gt;</span></pre><p id="365d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这几乎足以让你回到更高阶的组件！😱实际上，我认为HOCs在这里是一个很好的解决方案，但是组合单个的操作仍然很繁重。</p><h1 id="637b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">输入未声明</h1><p id="b022" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在我们看无状态之前，我应该说你根本不需要使用任何其他的状态库！新的上下文API 非常好，可能就是你所需要的，允许你在根组件中保持状态。也就是说，这是用<a class="ae ka" href="https://github.com/jamiebuilds/unstated" rel="noopener ugc nofollow" target="_blank">编写的相同组件，没有声明</a></p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="ec2d" class="mc kc hu ly b fv md me l mf mg">&lt;Subscribe to={[Table, Order]}&gt;<br/>  {(currentTable, order) =&gt; (<br/>    &lt;HeaderButton<br/>      label="Leave Table"<br/>      disabled={!!order.state.ticketId}<br/>      onPress={() =&gt; {<br/>        order.clear();<br/>        currentTable.set({ qrCode: '' });<br/>      }}<br/>    /&gt;<br/>  )}<br/>&lt;/Subscribe&gt;</span></pre><p id="9866" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我发现它可读性更好，缩进层次更少，代码行更少。它以两种方式避开了末日金字塔:</p><ul class=""><li id="3f64" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz ls lk ll lm dt translated">Get和set功能可以在一个状态对象中共享，减少了导入。如果我们愿意的话，订单和表状态可以合并到一个对象中。我们正在处理类，所以我们可以在那个容器上组合尽可能多的东西。</li><li id="fd82" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz ls lk ll lm dt translated">在一个<code class="eh mh mi mj ly b">Subscribe</code>组件中有一个内置的方法来订阅多个状态容器——<code class="eh mh mi mj ly b">to</code>prop接受一个状态对象数组。</li></ul><p id="1742" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，如果我们比较执行<code class="eh mh mi mj ly b">clearOrder</code>的代码，其中一个动作，差别变得稍微明显一些:</p><p id="06b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL非常简单，但并没有告诉我们太多信息:</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="7e12" class="mc kc hu ly b fv md me l mf mg">mutation clearOrder {<br/>  clearOrder @client<br/>}</span></pre><p id="fea0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解析器最终看起来很像Redux reducer。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="1861" class="mc kc hu ly b fv md me l mf mg">clearOrder: (_, __, { cache }) =&gt; {<br/>  const data = cache.readQuery({ query: GET_ORDER });<br/><br/>  <em class="mk">// make sure you mutate your object correctly</em><br/>  <em class="mk">// or other state could be affected</em><br/>  data.items = [];<br/><br/>  cache.writeQuery({ query: GET_ORDER, data });<br/>  return null; <em class="mk">// if you forget to return null, you'll get errors</em><br/>},</span></pre><p id="9eba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">未声明类中的等效方法是一行代码:</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="4e52" class="mc kc hu ly b fv md me l mf mg"><em class="mk">// make sure you bind your method if you might pass it</em><br/><em class="mk">// as a prop</em><br/>clear = () =&gt; this.setState({ items: [] });</span></pre><p id="7355" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">啊，感觉好多了！</p><h1 id="5197" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">未声明的测试</h1><p id="0f41" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">因为Unstated创建了一个不是react组件的对象，所以您可以在不呈现组件的情况下测试它，就像使用Redux:</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="1a31" class="mc kc hu ly b fv md me l mf mg">test('clear order', () =&gt; {<br/>  <em class="mk">// instantiate and set up our state object for the test</em><br/>  const orderState = new OrderState();<br/>  orderState.setState({ items: ['hamburger'] });<br/><br/>  orderState.clear();<br/><br/>  expect(orderState.state.items).toEqual({ items: [] });<br/>});</span></pre><p id="b02d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者您可以通过使用<code class="eh mh mi mj ly b">inject</code> prop将它注入到组件树中来测试它:</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="650e" class="mc kc hu ly b fv md me l mf mg">test('clear rendered Orders', () =&gt; {<br/>  <em class="mk">// render an Orders component with the same orderState as above</em><br/>  <em class="mk">// (here with react-test-renderer)</em><br/>  const tree = TestRenderer.create(<br/>    &lt;Provider inject={[orderState]}&gt;<br/>      &lt;Orders /&gt;<br/>    &lt;/Provider&gt;,<br/>  );<br/>  <em class="mk">// make sure our order rendered (1 item)</em><br/>  expect(tree.root.findAllByType(OrderItem).length).toBe(1);<br/><br/>  <em class="mk">// "press" the leave-table button by calling its onPress, which will</em><br/>  <em class="mk">// call our `clear()` method</em><br/>  const leaveTableButton = tree.root.findByProps({<br/>    testId: 'leave-table-button',<br/>  });<br/>  button.props.onPress();<br/><br/>  expect(tree.root.findAllByType(OrderItem).length).toBe(0);<br/>});</span></pre><h1 id="f258" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">追随你的幸福</h1><p id="a23f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">事实上，Unstated非常容易使用，它可以很容易地用于任何事情，但这并不是本库的真正意图。不过，明智地使用它，它会填补您的状态管理中一个很小但非常重要的漏洞。在我目前的项目中使用Unstated感觉就像我终于得到了一个完整的数据解决方案，我不再希望有什么不同。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="cec6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mk">原载于【www.okgrow.com】<a class="ae ka" href="https://www.okgrow.com/posts/state-of-bliss" rel="noopener ugc nofollow" target="_blank"><em class="mk"/></a><em class="mk">。</em></em></p></div></div>    
</body>
</html>