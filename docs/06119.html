<html>
<head>
<title>Exploring Data Structures: Graphs and its traversal algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索数据结构:图及其遍历算法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphs-in-cs-and-its-traversal-algorithms-cfee5533f74e?source=collection_archive---------0-----------------------#2018-07-24">https://medium.com/hackernoon/graphs-in-cs-and-its-traversal-algorithms-cfee5533f74e?source=collection_archive---------0-----------------------#2018-07-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><p id="c307" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">绝大多数感兴趣的算法都是对数据进行操作的。因此，在算法的设计和分析中，有一些特殊的组织数据的方法起着关键的作用。由此，我们可以说数据结构只是组织数据的简单方式。</p><p id="f2ab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它们或者是线性的<strong class="ja hv">或者是非线性的</strong>。数组和链表是线性数据结构的例子。另一方面，图和树是非线性数据结构的形式。</p><ul class=""><li id="82f2" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated">例如，一种常见的数据结构是<strong class="ja hv">列表</strong>或<strong class="ja hv">数组</strong>，它们是有序的值序列。这里有一串数字:0，1，1，2，3，5，8，13。列表的概念并不局限于一种语言，它也用于日常生活中的编程之外——愿望列表、购物列表等等。</li></ul><p id="2c34" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">算法是逻辑执行问题的方法。它们不同于数据结构。如果算法工作得更快或更有效(使用更少的时间、内存或两者)，那么它们通常“更好”。</p><p id="bd99" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是在本文中，所有的内容都是关于查看非线性数据结构:图</p><h1 id="2f97" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">钻研图表</h1><p id="b621" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">图是一个系统，其中从任意点A到另一个任意点b可能有多种方式。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/23b1f9e1d2b7ed4d6fa85e3655e6f9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyq3u9YKdprcKdjpM5GUMw.jpeg"/></div></div></figure><p id="f1fc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个图通常被定义为一对集合(V，E)。v是一组称为顶点或节点的任意对象，E是一组成对的顶点，我们称之为边或(更少)弧。在无向图中，边是无序的对，或者只是两个顶点的集合。我一般写<strong class="ja hv"> u v </strong>而不是{u，v}来表示u和v之间的无向边。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lu"><img src="../Images/75cc0a56450f9fc563e03c1cb18657b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKikanKBE1Eo5h-PFMHDcQ.jpeg"/></div></div></figure><p id="f30a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在有向图中，边是有序的顶点对。在本文中，我将使用<strong class="ja hv"> u → v </strong>而不是(u，v)来表示从u到v的有向边，反之亦然。</p><p id="72a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">图也可以是无向的或有向的，循环的或非循环的(大部分是有向的)，或者加权的。</p><h1 id="01bc" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">遍历图形</h1><p id="c7b9" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">为了访问作为连通分量的每个节点或顶点，使用了基于树的算法。通过遍历图中的所有顶点，对检查时仍未访问的每个顶点执行算法，可以很容易地做到这一点。</p><p id="7c5b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">两种算法通常用于图的遍历:深度优先搜索(DFS)和广度优先搜索(BFS)。</p><h2 id="0940" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">深度优先搜索算法</h2><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mj"><img src="../Images/8ea59dda30e22495b69445572e9fdda3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kb_QRcGSw4fIAwQcB5Vo7Q.jpeg"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Visualizing DFS traversal</figcaption></figure><blockquote class="mo"><p id="a0b7" class="mp mq hu bd mr ms mt mu mv mw mx jv ek translated">深度优先搜索(DFS)是一种用于搜索<a class="ae my" href="https://brilliant.org/wiki/depth-first-search-dfs/(https://brilliant.org/wiki/graphs/)" rel="noopener ugc nofollow" target="_blank">图</a>或<a class="ae my" href="https://brilliant.org/wiki/trees-basic/" rel="noopener ugc nofollow" target="_blank">树</a>数据结构的<a class="ae my" href="https://brilliant.org/wiki/algorithm/" rel="noopener ugc nofollow" target="_blank">算法</a>。该算法从树的根(顶部)节点开始，沿着给定的分支(路径)尽可能远地前进，然后回溯，直到找到未探索的路径，然后探索它。该算法一直这样做，直到整个图都被探索完。</p><p id="6432" class="mp mq hu bd mr ms mz na nb nc nd jv ek translated">计算机科学中的许多问题都可以用图来思考。比如分析网络、绘制路由、调度、求生成树都是图的问题。为了分析这些问题，像深度优先搜索这样的图搜索算法是有用的。- <a class="ae my" href="https://brilliant.org/wiki/depth-first-search-dfs/" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="a6a9" class="pw-post-body-paragraph iy iz hu ja b jb ne jd je jf nf jh ji jj ng jl jm jn nh jp jq jr ni jt ju jv hn dt translated">最简单的伪代码是:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff nj"><img src="../Images/d62262a8fbbc075dc8ed2b0e4ddbcb0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j79l9kqIx3aCwWZhbSJS4A.jpeg"/></div></div></figure><p id="bc05" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">深度优先搜索是许多人在解决迷宫等问题时自然使用的一种常见方法。</p><p id="a68c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我们在迷宫中选择一条路径(为了这个例子，让我们根据我们事先制定的一些规则来选择一条路径),并沿着它走，直到我们走进死胡同或到达迷宫的尽头。如果给定的路径不起作用，我们回溯并从过去的交叉点选择一条替代路径，并尝试这条路径。</p><p id="6c11" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要把这个变成一个图遍历算法，我们基本上是用“邻居”代替“孩子”。但是为了防止无限循环，我们只想访问每个顶点一次。就像在BFS一样，我们可以使用标记来跟踪已经访问过的顶点，这样我们就不会再次访问它们。此外，就像在BFS一样，我们可以使用这种搜索来构建具有某些有用属性的生成树。</p><pre class="lj lk ll lm fq nk nl nm nn aw no dt"><span id="d59c" class="lv kg hu nl b fv np nq l nr ns">dfs(vertex v)<br/>    {<br/>    visit(v);<br/>    for each neighbor w of v<br/>        if w is unvisited<br/>        {<br/>        dfs(w);<br/>        add edge vw to tree T<br/>        }<br/>    }</span></pre><p id="893e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">下面是使用递归的Python实现:</strong></p><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="nt nu l"/></div></figure><p id="3d6e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是关于DFS如何工作的基本概述。如果你想深入研究，在互联网上和媒体上都有一些很棒的资料。</p><h2 id="d36f" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">广度优先搜索(BFS)算法</h2><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/efc9ac055aecefc80712d59a69f114d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*xjui2i7kEMqRx9QaIFQhaA.png"/></div></figure><p id="25b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它从树根(或图中的某个任意节点，有时称为“搜索关键字”)开始，在移动到下一个深度级别的节点之前，探索当前深度的所有邻居节点。</p><p id="6c2e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里唯一的问题是，与树不同，图可能包含循环，所以我们可能会再次来到同一个节点。为了避免多次处理一个节点，我们使用一个布尔访问数组。为简单起见，假设所有顶点都可以从起始顶点到达。</p><p id="184c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们在BFS所做的是一个简单的逐步过程:</p><ol class=""><li id="677e" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv nw kc kd ke dt translated">从一个顶点<strong class="ja hv"> S </strong>开始。设这个顶点在所谓的…“0级”。</li><li id="968d" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv nw kc kd ke dt translated">找到从这个起始顶点<strong class="ja hv"> S </strong>可以立即到达的所有其他顶点，也就是说，它们只有一条边之遥(相邻的顶点)。</li><li id="03c2" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv nw kc kd ke dt translated">将这些相邻的顶点标记为“级别1”。</li><li id="a821" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv nw kc kd ke dt translated">由于图中的循环或环，您可能会回到同一个顶点。如果发生这种情况，您的BFS将花费<strong class="ja hv"> ∞ </strong>时间。因此，您将只去那些没有将“级别”设置为某个值的顶点。</li><li id="9585" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv nw kc kd ke dt translated">标记当前顶点的父顶点，即访问当前顶点的顶点。对级别1的所有顶点执行此操作。</li><li id="43eb" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv nw kc kd ke dt translated">现在，找到所有那些离“级别1”上的顶点只有一条边的顶点。这些新的顶点集将位于“级别2”。</li><li id="c2d4" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv nw kc kd ke dt translated">重复这个过程，直到你用完图表。\</li></ol><p id="bea1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看这个—<a class="ae my" href="https://www.programiz.com/dsa/graph-bfs" rel="noopener ugc nofollow" target="_blank">https://www.programiz.com/dsa/graph-bfs</a></p><p id="6d21" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">使用队列的Python实现</strong></p></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="nt nu l"/></div></figure></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><h2 id="91dc" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">有向和无向图</h2></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff oc"><img src="../Images/511f49c07a42ce62596353a29fecece6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3At4zXqBkUdGSIUiIFnNhw.jpeg"/></div></div></figure><p id="1cf9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="od">无向图</em>是边没有方向的图。边缘(<em class="od"> x </em>、<em class="od"> y </em>)与边缘(<em class="od"> y </em>、<em class="od"> x </em>)相同。也就是说，它们不是有序的对，而是无序的对——即两个顶点的集合{ <em class="od"> x </em>，<em class="od"> y </em> }(或者在<a class="ae my" href="https://en.wikipedia.org/wiki/Loop_(graph_theory)" rel="noopener ugc nofollow" target="_blank">循环</a>的情况下是2-多重集)。没有回路的无向图的最大边数是<em class="od">n</em>(<em class="od">n</em>1)/2。</p><p id="8462" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于无向图中的任意边<code class="eh oe of og nl b">u</code>和<code class="eh oe of og nl b">v</code>，我们称u为v的邻居，反之亦然。一个节点的度是它的邻居数。在有向图中，我们有两种邻居。对于任何有向边<strong class="ja hv"> u — &gt; v </strong>，我们称u为v的前趋，v为u的后继。</p><h2 id="be8e" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">循环和非循环图</h2><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff oh"><img src="../Images/739fe48de35b62d4a1ba4ac092faac0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CbzKFAE5jNR8xMt1NLC2wA.jpeg"/></div></div></figure><p id="45bd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在图的许多性质中，有两个对于许多应用是重要的:连通性和非循环性。两者都基于路径的概念。</p><p id="0827" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">循环图是至少包含一个<a class="ae my" href="http://mathworld.wolfram.com/GraphCycle.html" rel="noopener ugc nofollow" target="_blank">图循环</a>的图。<strong class="ja hv">还要记住，循环图不能是树的形式，因为树的节点只能通过DFS或BFS(遍历方法)访问一次。</strong></p><p id="9e80" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">无环图是没有圈的图(一个圈是一个完整的回路)。当沿着图从一个节点到另一个节点时，您将不会两次访问同一个节点。</p><h2 id="e3ed" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">什么是有向无环图？</h2><p id="5418" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">有向无环图是指有方向但没有环的无环图。</p><blockquote class="mo"><p id="769e" class="mp mq hu bd mr ms mz na nb nc nd jv ek translated">树是有向无环图的一种形式</p></blockquote><figure class="oj ok ol om on ln fe ff paragraph-image"><div class="fe ff oi"><img src="../Images/570ba265aa7dcc432bf7912152faab99.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*FR_yAV48D0y-xQfS.png"/></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Source — <a class="ae my" href="http://www.statisticshowto.com/directed-acyclic-graph/" rel="noopener ugc nofollow" target="_blank">http://www.statisticshowto.com/directed-acyclic-graph/</a></figcaption></figure><p id="70b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">上图的各个部分是:</p><ul class=""><li id="6550" class="jw jx hu ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke dt translated"><a class="ae my" href="http://www.statisticshowto.com/integer/" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv">整数</strong> </a> =顶点的集合。</li><li id="597b" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv kb kc kd ke dt translated"><strong class="ja hv">顶点集</strong> = {1，2，3，4，5，6，7}。</li><li id="fd89" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv kb kc kd ke dt translated"><strong class="ja hv">边集</strong> = {(1，2)，(1，3)，(2，4)，(2，5)，(3，6)，(4，7)，(5，7)，(6，7)}。</li></ul><p id="c0f8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有向无环图有一个<strong class="ja hv">拓扑排序</strong>。这意味着节点是有序的，因此起始节点的值低于结束节点的值。如果一个DAG具有包含所有节点的有向路径，则它具有唯一的拓扑排序；在这种情况下，排序与节点在路径中出现的顺序相同。</p><p id="1a8e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在<a class="ae my" href="http://web.cecs.pdx.edu/~sheard/course/Cs163/Doc/Graphs.html" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中，dag也被称为<em class="od">等待图</em>。当DAG用于检测死锁时，它说明资源必须<em class="od">等待</em>另一个进程继续。</p><p id="59ec" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">我们如何检测图中的循环？</strong></p><p id="69f3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">事实证明，深度优先搜索算法特别擅长检测循环的原因是因为它在查找后向边缘方面很有效。我们将在本文后面研究DFS算法</p><h2 id="95aa" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">邻接矩阵和邻接表表示</h2><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff oo"><img src="../Images/4341ae08437269a896a4431c960bbea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vw3a7MIwydb5s4K1hqVJGw.jpeg"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Consider this graph as example for understanding adjacency lists and adjacency matrices</figcaption></figure><p id="fc3c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果图中有许多边，则使用边列表或邻接表来表示图来执行图算法会很麻烦。为了简化计算，图可以用矩阵来表示。这里将介绍两种常用于表示图形的矩阵。一种是基于顶点的邻接，另一种是基于顶点和边的关联。</p><p id="56a3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">给定一个邻接矩阵，我们可以在θ(1)时间内确定两个顶点是否由一条边连接，只需查看矩阵中合适的槽即可。我们也可以通过扫描相应的行(或列)来列出一个顶点在θ(V)时间内的所有邻居。</p><p id="efa3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">从上面给定的图像中理解邻接矩阵… </strong></p><p id="a42a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们来理解邻接矩阵是如何从上面给定的图像中构造出来的。为了简单起见，我只讨论了顶点“a”的情况。同样适用于所有顶点。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff op"><img src="../Images/bfa20d2798f7dace0e36c9947585f4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ndj8gAMzeTJCF97G6EL0wg.jpeg"/></div></div></figure><p id="c0b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">由于篇幅所限，我没有包括对<strong class="ja hv"> <em class="od"> a → d </em> </strong>和<strong class="ja hv"> <em class="od"> a → e. </em> </strong>的分析，因为从图像中我们可以得出结论，a → d和a → e分别有一条边。</p><p id="5f07" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">邻接表呢？</p><p id="d371" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">邻接表数据结构应该立刻让你想起带链接的哈希表；这两种数据结构是相同的。</p><p id="aa9d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">邻接表是一个链表数组，每个顶点一个链表。每个链表存储相应顶点的邻居。</p><p id="1c98" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">为例</strong> <code class="eh oe of og nl b"><strong class="ja hv">a</strong></code> <strong class="ja hv">顶点有边通向邻居为例</strong> <code class="eh oe of og nl b"><strong class="ja hv">b,d and e</strong></code> <strong class="ja hv">。所以它各自的链表包含通过边连接的顶点。</strong></p><blockquote class="mo"><p id="d24d" class="mp mq hu bd mr ms mz na nb nc nd jv ek translated">提醒→对于无向图，每条边(u，v)存储两次，一次在u的邻居列表中，一次在v的邻居列表中；对于有向图，每条边只存储一次。</p></blockquote><h2 id="2611" class="lv kg hu bd kh lw oq ly kl lz or mb kp jj os md kt jn ot mf kx jr ou mh lb mi dt translated">加权图</h2><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ov"><img src="../Images/78403ec51aeca016016aa46eab60df8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbGjl-sF7PI3KGfGuMruoA.jpeg"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Weighted graph. Source — <a class="ae my" href="https://cs.stackexchange.com" rel="noopener ugc nofollow" target="_blank">https://cs.stackexchange.com</a></figcaption></figure><p id="9238" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">加权图(或称加权有向图)是一个图(或称二向图),它的边都有编号。这些数字被称为重量或成本。对这种图的兴趣是由许多现实世界的应用激发的，例如在运输或通信网络中寻找两点之间的最短路径，或者<strong class="ja hv"> </strong> <a class="ae my" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv">旅行推销员问题</strong> </a> <strong class="ja hv">。</strong></p><h2 id="fcf7" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">现实生活中的图表示例</h2><p id="b677" class="pw-post-body-paragraph iy iz hu ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hn dt translated">谷歌地图——这只是一个大图！其中<strong class="ja hv">边代表街道，顶点代表十字路口。</strong></p></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff ow"><img src="../Images/c51392ba076673e107a12a99059e0576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*UjbqqPxNGAfNCb3pZGreEg.png"/></div></figure><p id="a29e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">图论是互联网的基础。它在网络代码中被大量使用(构建路由表等)，但它出现在各种场合，如构建互联网搜索引擎或社交媒体平台。</p><h2 id="76d7" class="lv kg hu bd kh lw lx ly kl lz ma mb kp jj mc md kt jn me mf kx jr mg mh lb mi dt translated">对于深入研究树，这篇文章是我选择的首选之一—<a class="ae my" href="https://medium.freecodecamp.org/all-you-need-to-know-about-tree-data-structures-bceacb85490c" rel="noopener ugc nofollow" target="_blank">https://medium . freecodecamp . org/all-you-need-to-know-about-tree-data-structures-BCE ABC 85490 c</a></h2></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><h1 id="85a8" class="kf kg hu bd kh ki ox kk kl km oy ko kp kq oz ks kt ku pa kw kx ky pb la lb lc dt translated">最重要的事实:</h1><ul class=""><li id="91ec" class="jw jx hu ja b jb ld jf le jj pc jn pd jr pe jv kb kc kd ke dt translated">所有的树都是图。不是所有的图都是树。</li><li id="37dc" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv kb kc kd ke dt translated">树是一种图，只有当它是连通的。例如，由顶点A和B组成的没有边的图不是树，尽管它是一个无环图。</li><li id="9d2c" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv kb kc kd ke dt translated">单个顶点也被认为是树(没有圈，空连接)。所以两个不相连的顶点组成了两棵树的森林。</li><li id="09dd" class="jw jx hu ja b jb nx jf ny jj nz jn oa jr ob jv kb kc kd ke dt translated">树是一种特殊的图，在那里从来没有多条路径，对于A和B的所有可能组合，从A到B总是只有一条路。</li></ul></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff pf"><img src="../Images/7ea277df110da571dab55a358c41ae0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EI6czOBmzzIl9MctzvPtBA.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Shot — <a class="ae my" href="https://dribbble.com/shots/3152667-Astronaut-Glove" rel="noopener ugc nofollow" target="_blank">https://dribbble.com/shots/3152667-Astronaut-Glove</a></figcaption></figure><p id="648a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">资源:</p><div class="pg ph fm fo pi pj"><a href="https://brilliant.org/wiki/depth-first-search-dfs/" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab ej"><div class="pl ab pm cl cj pn"><h2 class="bd hv fv z el po eo ep pp er et ht dt translated">深度优先搜索(DFS) |卓越的数学和科学维基</h2><div class="pq l"><h3 class="bd b fv z el po eo ep pp er et ek translated">深度优先搜索(DFS)是一种用于搜索图形或树数据结构的算法。算法从根开始…</h3></div><div class="pr l"><p class="bd b gc z el po eo ep pp er et ek translated">brilliant.org</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ls pj"/></div></div></a></div><div class="pg ph fm fo pi pj"><a href="https://www.geeksforgeeks.org/" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab ej"><div class="pl ab pm cl cj pn"><h2 class="bd hv fv z el po eo ep pp er et ht dt translated">极客论坛|极客的计算机科学门户</h2><div class="pq l"><h3 class="bd b fv z el po eo ep pp er et ek translated">极客的计算机科学门户。它包含写得很好，很好的思想和很好的解释计算机科学和…</h3></div><div class="pr l"><p class="bd b gc z el po eo ep pp er et ek translated">www.geeksforgeeks.org</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ls pj"/></div></div></a></div><div class="pg ph fm fo pi pj"><a href="https://www.khanacademy.org/computing/computer-science/algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab ej"><div class="pl ab pm cl cj pn"><h2 class="bd hv fv z el po eo ep pp er et ht dt translated">算法|计算机科学|计算|可汗学院</h2><div class="pq l"><h3 class="bd b fv z el po eo ep pp er et ek translated">我们与达特茅斯学院教授汤姆·科尔曼和德文·巴尔科姆合作教授计算机科学导论…</h3></div><div class="pr l"><p class="bd b gc z el po eo ep pp er et ek translated">www.khanacademy.org</p></div></div><div class="ps l"><div class="pz l pu pv pw ps px ls pj"/></div></div></a></div><div class="pg ph fm fo pi pj"><a href="https://www.hackerearth.com/practice/algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab ej"><div class="pl ab pm cl cj pn"><h2 class="bd hv fv z el po eo ep pp er et ht dt translated">线性搜索教程和笔记|算法|黑客地球</h2><div class="pq l"><h3 class="bd b fv z el po eo ep pp er et ek translated">关于线性搜索的详细教程，提高你对算法的理解。也尝试练习问题来测试&amp;…</h3></div><div class="pr l"><p class="bd b gc z el po eo ep pp er et ek translated">www.hackerearth.com</p></div></div><div class="ps l"><div class="qa l pu pv pw ps px ls pj"/></div></div></a></div><p id="05db" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae my" href="http://www.cs.uiuc.edu/~jeffe/teaching/algorithms" rel="noopener ugc nofollow" target="_blank">http://www.cs.uiuc.edu/~jeffe/teaching/algorithms</a></p></div></div>    
</body>
</html>