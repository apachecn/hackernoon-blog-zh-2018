<html>
<head>
<title>Async error handling: N² ways to shoot yourself in the foot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步错误处理:搬起石头砸自己的脚</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/n%C2%B2-ways-to-shoot-yourself-in-the-foot-error-handling-with-async-await-and-promises-87f30cda1681?source=collection_archive---------8-----------------------#2018-07-24">https://medium.com/hackernoon/n%C2%B2-ways-to-shoot-yourself-in-the-foot-error-handling-with-async-await-and-promises-87f30cda1681?source=collection_archive---------8-----------------------#2018-07-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b366" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">浏览器现在支持通过<code class="eh jp jq jr js b">async</code> / <code class="eh jp jq jr js b">await</code>进行异步调用。这很好。它本质上是对承诺的语法支持。</p><p id="a126" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，所有这一切的错误处理并不那么好。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff jt"><img src="../Images/5fb721f6195a7d3c006500b8e1640511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*Di6M2raU7iKia0FswDDaDw.gif"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek"><em class="kf">Real footage of the async error delegation mechanism</em></figcaption></figure><p id="366d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总而言之，我们要处理的是:</p><ul class=""><li id="e231" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">2非等价方式抛出错误。</li><li id="37bf" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">捕捉局部错误的两种基本相同的方法。</li><li id="f949" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">从0到1全局捕捉承诺错误的方法。</li><li id="e784" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">一种抛出这些机制都无法捕获的错误的方法。</li></ul><p id="8482" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">呃。</p><p id="3c15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们怎么会有这样的结局？当向系统添加新特性时，如果每个特性数n都必须与所有现有的n-1个特性进行交互，那么特性间的交互将增长O(n)。因此，对于功能的线性增长，你会得到复杂性的二次增长。这实际上解释了为什么大多数大型软件项目会失败，以及为什么理清特性如此重要。异步错误处理也是如此。我们从简单的回调函数开始。后来事实证明，试镜是一个烂摊子，所以我们用承诺解决了所有这些问题。后来发现Promises一塌糊涂，所以我们用async/await解决了所有这些问题。</p><p id="bf1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，让我们深入了解当前的混乱局面。</p><h1 id="cb64" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">在本地处理承诺中的错误</h1><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/1d4f2e6a59471f08207e42e32c5cf3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*e6mXs_zWY3Qa0Eti.png"/></div></figure><blockquote class="lt lu lv"><p id="a29e" class="ir is lw it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated"><em class="hu">承诺，有时会违背<br/>，有时会违背<br/>——在WHATWG邮件列表的帖子中的笔画</em></p></blockquote><h1 id="741b" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">抛出的错误</h1><p id="286b" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">当异步函数中抛出错误时，可以用<code class="eh jp jq jr js b">try {} catch {}</code>捕捉它。这正如你所料:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="3a43" class="mj kv hu js b fv mk ml l mm mn"><strong class="js hv">async</strong> <strong class="js hv">function</strong> <strong class="js hv">fails</strong>() {<br/>    throws Error();<br/>}<br/><br/><strong class="js hv">async</strong> <strong class="js hv">function</strong> <strong class="js hv">myFunc</strong>() {<br/>    <strong class="js hv">try</strong> {<br/>        <strong class="js hv">await</strong> fails();<br/>    } <strong class="js hv">catch</strong> (e) {<br/>        console.log("that failed", e); <br/>    }<br/>}</span></pre><p id="f8f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一种语法糖，适用于你之前可能对承诺做过的事情:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="f866" class="mj kv hu js b fv mk ml l mm mn">fails().catch(e =&gt; {<br/>    console.log("That also failed", e); <br/>});</span></pre><p id="0014" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，无论你在哪里使用关键字<code class="eh jp jq jr js b">await</code>，你都可以去掉<code class="eh jp jq jr js b">await</code>，进行传统的<code class="eh jp jq jr js b">.then()</code>和<code class="eh jp jq jr js b">.catch()</code>调用。这是因为<code class="eh jp jq jr js b">async</code>关键字隐式地为它的函数创建了一个<code class="eh jp jq jr js b">Promise</code>。</p><p id="41a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这两者之间唯一的区别是<code class="eh jp jq jr js b">catch()</code>的回调有它自己的执行上下文，也就是说，变量作用域像你期望的那样工作。</p><h1 id="ce3f" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">被拒绝的承诺</h1><p id="645b" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">对于承诺，除了使用throw之外，还有另一种抛出错误的方法。可以调用<code class="eh jp jq jr js b">reject()</code>:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="d0eb" class="mj kv hu js b fv mk ml l mm mn"><strong class="js hv">function</strong> <strong class="js hv">fails2</strong>() {<br/>    <strong class="js hv">return</strong> <strong class="js hv">new</strong> Promise((resolve, reject) =&gt; {<br/>        reject(<strong class="js hv">new</strong> Error());<br/>    });<br/>}<br/><br/><strong class="js hv">async</strong> <strong class="js hv">function</strong> <strong class="js hv">myFunc2</strong>() {<br/>    <strong class="js hv">try</strong> {<br/>        <strong class="js hv">await</strong> fails2();<br/>    } <strong class="js hv">catch</strong> (e) {<br/>        console.log("that failed", e); <br/>    }<br/>}</span></pre><p id="e51b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">传递给<code class="eh jp jq jr js b">reject()</code>的错误可以用<code class="eh jp jq jr js b">try {} catch {}</code>和<code class="eh jp jq jr js b">.catch()</code>方法捕捉。所以你有两种方法抛出错误，两种方法捕捉错误。这比我们希望的要复杂，但至少两种捕捉错误的方法都会捕捉到任何一种抛出错误的方法，所以这里的复杂性并没有想象中的那么糟糕。</p><h1 id="a0d4" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">在不同的调用堆栈中引发错误</h1><p id="a107" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">尽管会有更多的麻烦。如果你自己在创建<code class="eh jp jq jr js b">Promise</code>，你可能会使用一个<code class="eh jp jq jr js b">setTimeout()</code>或者一个<code class="eh jp jq jr js b">setInterval()</code>，或者在某个操作完成时以某种方式调用一个回调函数。这些回调将从不同的调用堆栈中调用，这意味着抛出的错误将传播到不是您的代码的地方。</p><p id="e4bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑这个例子:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="38a5" class="mj kv hu js b fv mk ml l mm mn"><strong class="js hv">function</strong> <strong class="js hv">fails3</strong>() {<br/>    <strong class="js hv">return</strong> <strong class="js hv">new</strong> Promise((resolve, reject) =&gt; {<br/>        setTimeout(<strong class="js hv">function</strong>() {<br/>            <strong class="js hv">throw</strong> <strong class="js hv">new</strong> Error();<br/>        }, 100);<br/>    });<br/>}<br/><br/><strong class="js hv">async</strong> <strong class="js hv">function</strong> <strong class="js hv">myFunc3</strong>() {<br/>    <strong class="js hv">try</strong> {<br/>        <strong class="js hv">await</strong> fails3();<br/>    } <strong class="js hv">catch</strong> (e) {<br/>        console.log("that failed", e); //&lt;-- never gets called<br/>    }<br/>}</span></pre><p id="0196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里产生的错误永远不会被<code class="eh jp jq jr js b">try {} catch {}</code>捕获，因为它是在不同的调用栈上抛出的。使用<code class="eh jp jq jr js b">.catch(() =&gt; {})</code>方法也会有同样的问题。</p><p id="6cc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让错误在这样的回调中传播的方法是使用reject()函数，如下所示:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="06dc" class="mj kv hu js b fv mk ml l mm mn"><strong class="js hv">function</strong> <strong class="js hv">fails4</strong>() {<br/>    <strong class="js hv">return</strong> <strong class="js hv">new</strong> Promise((resolve, reject) =&gt; {<br/>        setTimeout(<strong class="js hv">function</strong>() {<br/>            reject(<strong class="js hv">new</strong> Error());<br/>        }, 100);<br/>    });<br/>}<br/><br/><strong class="js hv">async</strong> <strong class="js hv">function</strong> <strong class="js hv">myFunc4</strong>() {<br/>    <strong class="js hv">try</strong> {<br/>        <strong class="js hv">await</strong> fails4();<br/>    } <strong class="js hv">catch</strong> (e) {<br/>        console.log("that failed", e); //&lt;-- this gets called<br/>    }<br/>}</span></pre><p id="7a98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这大概是最初引入拒绝/解决范式的主要原因。</p><h1 id="9fd8" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">旁注:为什么拒绝/解决有点糟糕。</h1><p id="6693" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">在promise中调用<code class="eh jp jq jr js b">reject(new Error())</code>很像做<code class="eh jp jq jr js b">throw Error()</code>，除了一个主要的区别:它只是一个函数调用，所以它不会像<code class="eh jp jq jr js b">throw</code>那样中断执行流。这意味着您可以编写矛盾的代码，既有<code class="eh jp jq jr js b">reject</code>又有<code class="eh jp jq jr js b">resolve</code>的，就像这样:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="33b4" class="mj kv hu js b fv mk ml l mm mn"><strong class="js hv">function</strong> <strong class="js hv">schrödinger</strong>() {<br/>    <strong class="js hv">return</strong> <strong class="js hv">new</strong> Promise((resolve, reject) =&gt; {<br/>        reject(<strong class="js hv">new</strong> Error());<br/>        resolve("great success");<br/>    });<br/>}</span></pre><p id="da4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里<code class="eh jp jq jr js b">reject()</code>和<code class="eh jp jq jr js b">resolve()</code>都将被调用。那么哪个会赢呢？答案是先调用<em class="lw">再调用</em>的函数。</p><p id="beb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在看看这个怪人:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="7249" class="mj kv hu js b fv mk ml l mm mn"><strong class="js hv">function</strong> <strong class="js hv">schrödinger2</strong>() {<br/>    <strong class="js hv">return</strong> <strong class="js hv">new</strong> Promise((resolve, reject) =&gt; {<br/>        <strong class="js hv">throw</strong> resolve("huh"); //&lt;-- this throw is executed<br/>    });<br/>}<br/><strong class="js hv">async</strong> <strong class="js hv">function</strong> <strong class="js hv">callAsync</strong>() {<br/>    <strong class="js hv">try</strong> {<br/>        <strong class="js hv">await</strong> schrödinger2();<br/>    } <strong class="js hv">catch</strong> (e) {<br/>        console.log("caught error", e);//&lt;-- yet, this isn't reached<br/>    }<br/>}</span></pre><p id="3763" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的promise只有一行代码，一个throw语句。然而，<code class="eh jp jq jr js b">try {} catch {}</code>从未被触发。这是因为调用了resolve，规则仍然是先调用<em class="lw">再调用</em>的获胜。所以throw被执行了，但是它被运行时默默地吞掉了。这势必会造成无尽的困惑。</p><p id="1bcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">出现这些问题是因为<code class="eh jp jq jr js b">resolve()</code>和<code class="eh jp jq jr js b">reject()</code>几乎是<code class="eh jp jq jr js b">return</code>和<code class="eh jp jq jr js b">throw</code>的重复。我认为我们拒绝/解决的唯一原因是能够跨越调用栈边界移动错误。但这是一个平庸的解决方案，原因有几个。它只移动您期望的错误，因此，例如，一个意外的NullReferenceException不会跨边界移动，除非您自己用它显式调用<code class="eh jp jq jr js b">reject()</code>。此外，它复制核心语言特性的事实会导致问题，如上所述。</p><p id="3a1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个有更简洁的设计。在人们开始在<a class="ae mo" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中谈论C#之前，它就已经有了<code class="eh jp jq jr js b">async</code> / <code class="eh jp jq jr js b">await</code>。在那里，异步回调中抛出的异常被捕获，然后重新抛出，以便它们传播到正在等待异步操作的站点。JavaScript可以通过为setTimeout和setInterval提供新的错误语义来实现这一点，我们可以抛弃这种<code class="eh jp jq jr js b">resolve</code> / <code class="eh jp jq jr js b">reject</code>的东西，转而使用<code class="eh jp jq jr js b">return</code> / <code class="eh jp jq jr js b">throw</code>。这也将削减90%的承诺规格。</p><h1 id="052e" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">全面处理承诺中的错误</h1><p id="b385" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">所以我们知道如何用<code class="eh jp jq jr js b">try {} catch {}</code>和类似的机制捕捉错误。当您想要为所有未处理的错误设置一个全局的捕获所有处理程序时，例如将这些错误记录到服务器中，该怎么办呢？</p><p id="9f5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，你怎么知道一个承诺中的错误是否没有被处理呢？在处理承诺时，你无法知道一个错误是否会在未来的某个时间得到处理。该承诺可能会调用<code class="eh jp jq jr js b">reject()</code>，10分钟后可能会出现一些代码，并对该承诺调用<code class="eh jp jq jr js b">.catch(() =&gt; {})</code>，在这种情况下，错误将被处理。正因如此，像Q和蓝鸟这样的Promise库中的全局错误处理程序被命名为<code class="eh jp jq jr js b">onPossiblyUnhandledRejection</code>，这是一个恰如其分的名字。在native Promises中，这个函数被称为<code class="eh jp jq jr js b">onunhandledrejection</code>，但是他们仍然只能判断到目前为止是否有拒绝未被处理<em class="lw"/>。</p><p id="382d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以像这样设置全局处理程序:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="fb19" class="mj kv hu js b fv mk ml l mm mn">window.onunhandledrejection = <strong class="js hv">function</strong>(evt) { /*Your code*/ }</span></pre><p id="7029" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者:</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="ac70" class="mj kv hu js b fv mk ml l mm mn">window.addEventListener("unhandledrejection", <strong class="js hv">function</strong>(evt) { })</span></pre><p id="e51a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的<code class="eh jp jq jr js b">evt</code>是一个类型为<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent" rel="noopener ugc nofollow" target="_blank"> PromiseRejectionEvent </a>的对象。<code class="eh jp jq jr js b">evt.promise</code>是被拒绝的承诺，<code class="eh jp jq jr js b">evt.reason</code>保存传递给<code class="eh jp jq jr js b">reject()</code>函数的任何对象。</p><p id="57e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一切都很好，除了:除了Chrome，没有人实现它(嗯，Chrome和基于Chrome的浏览器)。它即将登陆Firefox，估计也将登陆Safari和Edge。但还没有。更糟糕的是，对于这些浏览器来说，除了不使用原生Promises，而是依赖于像Q或Bluebird这样的库之外，没有什么好的办法。希望对这些浏览器的本地支持将很快到来。</p><h1 id="31a4" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">跟踪承诺中的错误</h1><p id="a9d5" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">你如何跟踪发生在你的网站上的JavaScript错误？为此，您可以使用<a class="ae mo" href="https://catchjs.com" rel="noopener ugc nofollow" target="_blank"> CatchJS </a>，这是一个JavaScript错误跟踪服务。它用一个全局错误处理程序装备浏览器，然后记录发生的任何未捕获的错误。部署只需放入一个脚本文件即可。</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="99b1" class="mj kv hu js b fv mk ml l mm mn">&lt;script src="//cdn.catchjs.com/catch.js"&gt;&lt;/script&gt;</span></pre><p id="6a51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样，未捕获的错误会被记录下来，还有各种遥测数据，包括截图和点击轨迹。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/19805fafaa8a2a5b7e7eff8d599fb9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*3mGAC0jXfeVXDKWZ7W8iUw.gif"/></div></figure><p id="3bd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于将来是否会处理承诺拒绝的模糊性，CatchJS不会将其自身附加到onunhandledrejection处理程序。如果需要，您可以手动设置这种转发。</p><pre class="ju jv jw jx fq mf js mg mh aw mi dt"><span id="f012" class="mj kv hu js b fv mk ml l mm mn">window.onunhandledrejection = <strong class="js hv">function</strong>(evt) {<br/>    console.error(evt.reason);<br/>}</span></pre><p id="ee71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CatchJS将检测console.error，因此这些错误将被记录到您的远程永久日志以及开发人员控制台中。</p><p id="1350" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">圣雄甘地说，违背诺言是对真理的卑鄙投降。话说回来，他对异步错误处理一无所知。</strong></p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="18d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">【catchjs.com】最初发表于<a class="ae mo" href="https://catchjs.com/Docs/AsyncAwait" rel="noopener ugc nofollow" target="_blank"><em class="lw"/></a><em class="lw">。</em></p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mx my l"/></div></figure></div></div>    
</body>
</html>