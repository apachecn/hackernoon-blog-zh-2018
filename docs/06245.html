<html>
<head>
<title>Finally, a use for my crypto wallet!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的加密钱包终于派上用场了！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/finally-a-use-for-my-crypto-wallet-66250af48728?source=collection_archive---------12-----------------------#2018-07-27">https://medium.com/hackernoon/finally-a-use-for-my-crypto-wallet-66250af48728?source=collection_archive---------12-----------------------#2018-07-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0236" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你拥有加密货币，你就是估计8%的美国人口中的一员。你可能会把硬币放在一个软件钱包里，要么放在比特币基地这样的交易所，要么使用以太坊钱包或比特币核心这样的开源选项。你们中的一些人可能已经采取了下一步，买了一个硬件钱包来保护你的钥匙。</p><p id="7a88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Trezor One、Ledger Nano S和KeepKey是当今市场上最受欢迎的硬件钱包。虽然它们在架构和支持的货币方面各有优势，但它们都可以安全地存储您的私钥。硬件钱包允许您直接在设备上签署交易，这样您的密钥就不会暴露在设备之外。这种方法的优点是，即使黑客破坏了你的桌面系统，他们也无法访问你的加密库或干扰你的<a class="ae jp" href="https://hackernoon.com/tagged/crypto" rel="noopener ugc nofollow" target="_blank">加密</a>交易。</p><p id="d869" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近买了一个Trezor。然而，在将一些货币转移到钱包后，我很快意识到，除了最初的货币转移，这些设备没有什么乐趣。随身携带这些钱包是没有意义的，因为加密货币基础设施在这个时候几乎不存在。因此，硬件钱包闲置在架子上或保险箱里，静静地保护着钥匙和硬币免受伤害。</p><p id="7e48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但那很无聊。对于这些硬件钱包，我们还能做些什么呢？来点游戏怎么样！鉴于crypto从游戏社区获得的一切——通过囤积采矿钻机推高GPU价格——现在是crypto回报的时候了。</p><p id="a31f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">女士们先生们，我向你们介绍一个在Trezor One上运行的永恒经典:Pong。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff fg"><img src="../Images/6693941c5d9cfe584feaf0d314f7fb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*t40nvND8SPQWC_rGsEQoRA.gif"/></div></div></figure><p id="58b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然显示屏相当小，只有两个按钮，但Trezor One仍然是一个有趣的学习如何对嵌入式设备进行编程的小设备。处理器是<a class="ae jp" href="https://www.st.com/content/ccc/resource/technical/document/datasheet/bc/21/42/43/b0/f3/4d/d3/CD00237391.pdf/files/CD00237391.pdf/jcr:content/translations/en.CD00237391.pdf" rel="noopener ugc nofollow" target="_blank">意法半导体STM32F205 </a>，它有一个ARM 32位Cortex-M3 CPU。大约有1MB的闪存和128KB的内存。该设备有一个128x64位有机发光二极管显示器和两个按钮。</p><p id="c51d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想为Trezor One编写自己的固件，这里有一些指导让你开始。</p><h1 id="4997" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">设置构建环境</h1><p id="f84d" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">这些说明假设你运行的是Ubuntu 18.04 LTS，但是稍加调整，它们可以在任何机器上运行。这些步骤适用于版本1.6.2的固件。</p><h2 id="9aea" class="le kc hu bd kd lf lg lh kh li lj lk kl jc ll lm kp jg ln lo kt jk lp lq kx lr dt translated">获取Trezor源代码</h2><p id="e5f9" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">第一步是下载Trezor源代码。</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="2714" class="le kc hu lt b fv lx ly l lz ma">$ mkdir workspace<br/>$ cd workspace<br/>$ git clone https://github.com/trezor/trezor-mcu.git</span></pre><h2 id="07ea" class="le kc hu bd kd lf lg lh kh li lj lk kl jc ll lm kp jg ln lo kt jk lp lq kx lr dt translated">安装依赖项</h2><p id="8922" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">接下来，您需要安装构建所需的所有依赖项。</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="a433" class="le kc hu lt b fv lx ly l lz ma">sudo apt install build-essential python python-pip libsdl2-dev</span></pre><p id="f3b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下载并解压<a class="ae jp" href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads" rel="noopener ugc nofollow" target="_blank"> GNU ARM嵌入式工具链</a>。</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="dec0" class="le kc hu lt b fv lx ly l lz ma">$ cd workspace<br/>$ tar -xjf ~/Downloads/gcc-arm-none-eabi-7-2018-q2-update-linux.tar.bz2<br/>$ echo "export PATH=~/workspace/gcc-arm-none-eabi-7-2018-q2-update/bin:$PATH" &gt;&gt; ~/.bashrc<br/>$ source ~/.bashrc</span></pre><p id="9b49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你还需要安装谷歌协议缓冲区。不幸的是，Ubuntu提供的软件包太过时了，所以你需要自己<a class="ae jp" href="https://github.com/google/protobuf/releases/" rel="noopener ugc nofollow" target="_blank">这里</a>获取最新版本。</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="67ab" class="le kc hu lt b fv lx ly l lz ma">$ cd workspace<br/>$ mkdir protoc<br/>$ cd protoc<br/>$ wget <a class="ae jp" href="https://github.com/google/protobuf/releases/download/v3.6.0/protoc-3.6.0-linux-x86_64.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/google/protobuf/releases/download/v3.6.0/protoc-3.6.0-linux-x86_64.zip</a><br/>$ unzip <a class="ae jp" href="https://github.com/google/protobuf/releases/download/v3.6.0/protoc-3.6.0-linux-x86_64.zip" rel="noopener ugc nofollow" target="_blank">protoc-3.6.0-linux-x86_64.zip</a><br/>$ echo "export PATH=~/workspace/protoc/bin:$PATH" &gt;&gt; ~/.bashrc<br/>$ source ~/.bashrc</span></pre><p id="5262" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，安装几个Python模块。</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="0658" class="le kc hu lt b fv lx ly l lz ma">$ pip install protobuf ecdsa</span></pre><h2 id="1ac0" class="le kc hu bd kd lf lg lh kh li lj lk kl jc ll lm kp jg ln lo kt jk lp lq kx lr dt translated">构建固件</h2><p id="05a9" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">既然已经安装了所有的依赖项，就可以开始构建固件了。要构建固件:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="e992" class="le kc hu lt b fv lx ly l lz ma">$ cd ~/workspace/trezor-mcu<br/>$ ./script/setup<br/>$ ./script/cibuild</span></pre><p id="54bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">新构建的映像将存储在firmware/trezor.bin中。稍后我们将讨论如何处理该映像。</p><h1 id="15f1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Trezor仿真器</h1><p id="8ed8" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">如果你计划创建你自己的Trezor固件，很有可能你第一次尝试的时候不会成功。为了缩短修改代码/构建/加载周期，您可以使用Trezor模拟器来测试您的更改，而不必在设备上实际加载固件。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/45f6f8dee8a7def9931c491e81ebb8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*vcodWXHM-5gXK99Vcj0D_A.png"/></div></figure><p id="7502" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是模拟器运行的截图。128x64有机发光二极管显示器出现在自己的窗口中。通过按下左箭头键和右箭头键来模拟按钮。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/21b5b63bca58b39758749e5d18541481.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*67yeNP7B40-KIe4lBXMopA.png"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Trezor One Emulator</figcaption></figure><p id="c024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要构建模拟器，您需要设置一些环境变量，并再次运行安装脚本来清除任何以前的构建工件。</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="dcc0" class="le kc hu lt b fv lx ly l lz ma">$ cd ~/workspace/trezor-mcu<br/>$ export EMULATOR=1 TREZOR_TRANSPORT_V1=1<br/>$ ./script/setup<br/>$ ./script/cibuild</span></pre><p id="6849" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仿真器可执行文件显示在固件目录中，可以这样运行:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="8c8e" class="le kc hu lt b fv lx ly l lz ma">$ ./firmware/trezor.elf</span></pre><h1 id="81eb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">自定义固件</h1><p id="40d6" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">好了，现在你已经准备好构建设备固件和模拟器了，所以你可以创建你自己的Trezor固件了！</p><p id="1b20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Trezor应用程序固件的入口点位于firmware/trezor.c中的main函数中。您可以在该函数初始化后删除所有内容，并开始编写自己的代码。</p><h2 id="cae4" class="le kc hu bd kd lf lg lh kh li lj lk kl jc ll lm kp jg ln lo kt jk lp lq kx lr dt translated">向显示器绘图</h2><p id="296c" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">你要做的第一件事就是在显示屏前画画。Trezor显示器是一个128x64的有机发光二极管，其中像素(0，0)位于屏幕的左上角。显示芯片硬件可通过SPI总线访问(见oled.c ),但无需直接与硬件交互。Trezor固件在oled.h中提供了一个简单的API，用于在显示器上绘图和打印。</p><p id="7f95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显示API包含在oled.h中，非常简单。</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="66b0" class="le kc hu lt b fv lx ly l lz ma">#define OLED_WIDTH   128<br/>#define OLED_HEIGHT  64<br/>#define OLED_BUFSIZE (OLED_WIDTH * OLED_HEIGHT / 8) </span><span id="fb3c" class="le kc hu lt b fv mh ly l lz ma">void oledInit(void);<br/>void oledClear(void);<br/>void oledRefresh(void); <br/>void oledSetDebugLink(bool set);<br/>void oledInvertDebugLink(void); <br/>void oledSetBuffer(uint8_t *buf);<br/>const uint8_t *oledGetBuffer(void);<br/>void oledDrawPixel(int x, int y);<br/>void oledClearPixel(int x, int y);<br/>void oledInvertPixel(int x, int y);<br/>void oledDrawChar(int x, int y, char c, int zoom);<br/>int oledStringWidth(const char *text, int font); <br/>void oledDrawString(int x, int y, const char* text, int font);<br/>void oledDrawStringCenter(int y, const char* text, int font);<br/>void oledDrawStringRight(int x, int y, const char* text, int font);<br/>void oledDrawBitmap(int x, int y, const BITMAP *bmp);<br/>void oledInvert(int x1, int y1, int x2, int y2);<br/>void oledBox(int x1, int y1, int x2, int y2, bool set);<br/>void oledHLine(int y);<br/>void oledFrame(int x1, int y1, int x2, int y2);<br/>void oledSwipeLeft(void);<br/>void oledSwipeRight(void);</span></pre><p id="067d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，要在某个位置(x，y)绘制像素:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="1665" class="le kc hu lt b fv lx ly l lz ma">oledDrawPixel(x,y);</span></pre><p id="406e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦理解了所需数据的格式，绘制位图也很简单。oledDrawBitmap函数采用一个指向位图结构的指针，如下所示:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="c8f0" class="le kc hu lt b fv lx ly l lz ma">typedef struct {<br/>    uint8_t width, height;<br/>    const uint8_t *data;<br/>} BITMAP;</span></pre><p id="0db1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“宽度”和“高度”字段指定图像的尺寸。“数据”数组由从图像左上角开始的像素数据组成。每个字节代表8个像素，最低有效位位置对应于最左边的像素(即小端)。比特值1表示白色，0表示黑色。如果你想显示标准的Windows位图文件，你必须做两件事。</p><p id="1302" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，你需要将图像缩小到128x64的尺寸。您可以使用Gimp之类的图像编辑器来完成，或者使用Linux上的convert实用程序更容易:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="ff57" class="le kc hu lt b fv lx ly l lz ma">convert title.bmp -resize 128x64 title_resize.bmp</span></pre><p id="b22d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二步是将位图文件转换成Trezor display API可用的C数组。我编写了一个脚本，将标准的Windows位图文件转换为Trezor API使用的C数组格式。输入位图必须是24位模式，这意味着每个像素存储为三个字节，每种颜色(红色、绿色和蓝色)一个字节。该脚本将中间字节(绿色)转换为0或1，因为Trezor显示是黑白的。你可以在 这里找到名为bmp2trz.py <a class="ae jp" href="https://github.com/syscall7/trezor-pong/blob/master/bmp2trz.py" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">的Python脚本。</strong></a></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/7de8f7ce17694317e83cfd79a86c5656.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*YNDDIkleuL-zN_Hid1N6pA.png"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Converting Bitmap forTrezor API</figcaption></figure><h2 id="4134" class="le kc hu bd kd lf lg lh kh li lj lk kl jc ll lm kp jg ln lo kt jk lp lq kx lr dt translated">阅读按钮</h2><p id="75d6" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">Trezor有两个按钮，分别称为“是”和“否”。button API在buttons.h中公开，有一个保存按钮状态的全局变量叫做“button”，这个结构有以下字段:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="6e83" class="le kc hu lt b fv lx ly l lz ma">struct buttonState {<br/>        volatile bool YesUp;<br/>        volatile int YesDown;<br/>        volatile bool NoUp;<br/>        volatile int NoDown;<br/>};</span></pre><p id="e28d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有两种方法可以读取按钮状态。您可以检查按钮当前是否被按下，也可以检查按钮是否被按下和释放。</p><p id="45f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在读取全局按钮变量之前，首先调用“buttonUpdate”来更新状态。然后，您可以直接测试全局按钮变量字段。例如，下面是无限期等待任一按钮被按下的示例代码:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="1641" class="le kc hu lt b fv lx ly l lz ma">do<br/>{<br/>    delay(100000);<br/>    buttonUpdate();<br/>} while (!button.YesUp &amp;&amp; !button.NoUp);</span></pre><h1 id="619e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">安装固件</h1><p id="2510" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">要将您的自定义固件加载到设备上，您首先需要让设备进入引导加载程序模式。将Trezor插入USB端口时，按住两个按钮即可进入引导加载程序模式。当您处于引导加载程序模式时，屏幕如下所示:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mj"><img src="../Images/a298a54914bf4ba8b88db76dca7a4032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-sVZiKI5pDc6uyjqIn6vA.jpeg"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Trezor One in Bootloader Mode</figcaption></figure><p id="9df8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当Trezor处于引导模式时，您可以使用trezorctl实用程序上传您的自定义固件映像。要安装trezorctl实用程序，您需要安装以下软件:</p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="8921" class="le kc hu lt b fv lx ly l lz ma">$ sudo apt-get install python3-dev python3-pip cython3 libusb-1.0-0-dev libudev-dev<br/>$ pip3 install --upgrade setuptools<br/>$ pip3 install trezor[hidapi]</span></pre><p id="8c97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后你可以安装你的固件，如下所示。</p><p id="75ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">这一步要小心！此操作将完全擦除图像以及您在设备上设置的任何键。如果你的钱包里有很多钱，并且你不确定你在做什么，不要继续。如果你的钱包里确实有现金，我建议你在将新固件加载到设备上之前，仔细检查你的种子词是否安全地存储在纸上。</strong></p><pre class="jq jr js jt fq ls lt lu lv aw lw dt"><span id="cba8" class="le kc hu lt b fv lx ly l lz ma">$ trezorctl firmware_update -f firmware/trezor.bin</span><span id="b921" class="le kc hu lt b fv mh ly l lz ma">Firmware fingerprint: f5392f9b390b6381bfaa24a39a7ed0f7eba2e9cbfa21b9c224ce500b38918766</span><span id="59b6" class="le kc hu lt b fv mh ly l lz ma">Please confirm action on device...</span></pre><p id="1872" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您必须确认您想要继续删除当前映像，并在设备上加载新的固件映像。</p><p id="1c6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一段视频展示了升级过程。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="d2ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要说明的是，在升级过程中以及之后的每次引导中，引导加载程序都会检测到Satoshi Labs没有对升级映像进行签名，并提示用户是否要继续使用未签名的固件。</p><p id="aff8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想让Pong在你的Trezor上运行，如果你不想的话，你不必从头开始实现这个游戏。用户flightcrank在github上有一个相当简单的实现，你可以在这里找到<a class="ae jp" href="https://github.com/flightcrank/pong" rel="noopener ugc nofollow" target="_blank"/>。我已经将那个版本移植到Trezor上，只做了很小的改动，所以如果你想从我的flightcrank的Pong实现移植到Trezor上开始，你可以在这里找到代码<a class="ae jp" href="https://github.com/syscall7/trezor-pong" rel="noopener ugc nofollow" target="_blank"/>。</p><div class="mm mn fm fo mo mp"><a href="https://github.com/syscall7/trezor-pong" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">syscall7/trezor-pong</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">trezor-pong -将pong移植到trezor上</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd jz mp"/></div></div></a></div><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ne"><img src="../Images/661040b8be367ca31f546fa57bb4dfe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIGJnUx4HS7UgPQanVC_Vw.jpeg"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Pong Start Screen</figcaption></figure><p id="c7eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编码快乐！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="nf ml l"/></div></figure></div></div>    
</body>
</html>