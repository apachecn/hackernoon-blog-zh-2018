<html>
<head>
<title>The hidden Power of JavaScript Generator and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript生成器和承诺的隐藏力量</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-javascript-generator-and-promises-77d7dc977?source=collection_archive---------6-----------------------#2018-07-29">https://medium.com/hackernoon/using-javascript-generator-and-promises-77d7dc977?source=collection_archive---------6-----------------------#2018-07-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fb680fd453901652f7ed9e75701126cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHx4vFlWiCB58-GjXryqgw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/EhOCnW4wnuQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Taton Moïse</a> on <a class="ae jg" href="https://unsplash.com/search/photos/factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4dc0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想象一下，你正在你的程序中做一个异步请求，你的任务是在你的服务器中获取一些数据。</p><p id="6f14" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您的代码可能如下所示。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kf"><img src="../Images/06c7d67e9e9927a9adcac1f868fcd7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91tzzOGCGO98GIrphK4Uxg.png"/></div></div></figure><p id="6c48" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里没有什么特别的，我们使用一个<strong class="jj hv"> getJSON() </strong>方法在服务器中获取一个<a class="ae jg" href="https://hackernoon.com/tagged/data" rel="noopener ugc nofollow" target="_blank">数据</a>。</p><p id="08d8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我们的代码中有一个大问题。当我们向服务器发送请求时，我们阻塞了<strong class="jj hv"> UI线程</strong>，我们的页面没有响应，我们不想让我们的用户经历这种情况。</p><p id="63cb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在<a class="ae jg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a> <strong class="jj hv">回调</strong>来救场。</p><p id="96da" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们重写了代码，看起来像这样，没有阻塞<strong class="jj hv"> UI线程</strong>。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/555b25e329d0c9a77b469f286f93a10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ws0FtTt17472R0tDPwQtuA.png"/></div></div></figure><p id="100a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，当我们重写我们的代码时，你会注意到它变得混乱，而且如果我们向这个链接方法添加更多的请求，我们的代码会产生一个<a class="ae jg" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> <em class="kl">回调地狱</em> </strong> </a>或请求金字塔。</p><p id="acbf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们如何修复这个代码？使用ES6 <strong class="jj hv">发生器功能</strong> s和<strong class="jj hv">承诺</strong>。</p><p id="2dda" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank"><em class="kl">MDN</em></a><em class="kl"/>发电机<em class="kl"> </em>是</p><blockquote class="km"><p id="ffc5" class="kn ko hu bd kp kq kr ks kt ku kv ke ek translated">“生成器是可以退出并在以后重新进入的功能。它们的上下文(变量绑定)将在重入时被保存。”</p></blockquote><p id="84dd" class="pw-post-body-paragraph jh ji hu jj b jk kw jm jn jo kx jq jr js ky ju jv jw kz jy jz ka la kc kd ke hn dt translated">现在，在开始我们的目标之前，让我们先讨论一下生成器函数是如何工作的。</p><p id="6009" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请看这个例子:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lb"><img src="../Images/263a6b09c1571945ff0e5877052383fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ETOC1_ie0cwrD1FzAWrfQ.png"/></div></div></figure><p id="9153" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用<strong class="jj hv">函数</strong>关键字末尾的<strong class="jj hv">星号(*) </strong>字符定义<strong class="jj hv">生成器函数</strong>。我们使用<strong class="jj hv"> yield </strong>关键字返回生成器主体内部的一个值，在我们的例子中我们返回两个值"<strong class="jj hv"> Hello Generators </strong>和"<strong class="jj hv"> Hello again Generators </strong>"。因此，每当生成器函数在其主体中看到yield关键字时，它就会暂停函数的执行。</p><p id="8393" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们调用发生器函数<strong class="jj hv">const foo Generator = foo()</strong>；它将创建一个迭代器对象，该对象具有属性<strong class="jj hv"> next() </strong>和<strong class="jj hv"> throw()。</strong></p><p id="9d24" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用<strong class="jj hv"> next() </strong>关键字在生成器主体中执行生成的值。每次我们调用next方法时，它都会暂停函数的执行，并返回第一个产生的值(在我们的例子中是<strong class="jj hv">const result = foo generator . next())；</strong>它将返回一个对象文字(例如:<strong class="jj hv">值</strong>和<strong class="jj hv">完成)</strong>。在我们的示例中，我们使用<strong class="jj hv">console . log(` result:$ { result . value } `)</strong>显示第一个生成的值；如果我们检查<strong class="jj hv"> done </strong>属性，它将设置为false，因为如果我们再次调用<strong class="jj hv">const result 1 = foo generator . next()，我们的生成器函数将多一个生成值；</strong>相同的执行过程重复了done被设置为false，因为如果我们在第三次<strong class="jj hv">const result 2 = foo generator . next()中再次调用<strong class="jj hv"> next() </strong>方法，我们的生成器会看到我们在它们的主体中有另一个生成的值；</strong>完成被设置为真，值将显示为未定义，这是因为在我们的生成器主体中没有更多的生成值。</p><p id="6d69" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在你看到了生成器函数的基本例子，让我们用Promise来使用它，并重构上面的代码，这使得回调变得很糟糕。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lc"><img src="../Images/97bcb1459ef3302ed4a74cb196989008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wP9JydyOh2Pl1UcAQE67aA.png"/></div></div></figure><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ld"><img src="../Images/552d0bc3480ddebbe54ae7e893c3746a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UACg6tzoJLUgqgP4_Nf1tw.png"/></div></div></figure><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/b12939e0d0e4ca84c54f65b40ef9efad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_UknJY312tEbYyul-VhVA.png"/></div></div></figure><p id="7b36" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在你可以看到我们的代码变得比前一个更优雅了。</p><p id="f730" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用Generator和Promises将带给我们更优雅的代码，并促进关注点的分离。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><p id="a89f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">希望有帮助！ˆ_ˆ</p><p id="5389" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在推特上关注我<a class="ae jg" href="https://twitter.com/llaudevc" rel="noopener ugc nofollow" target="_blank">【https://twitter.com/llaudevc】<em class="kl"/></a></p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure></div></div>    
</body>
</html>