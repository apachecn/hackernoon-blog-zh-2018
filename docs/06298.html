<html>
<head>
<title>Learn Functional Python in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟学会函数Python</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/learn-functional-python-in-10-minutes-to-2d1651dece6f?source=collection_archive---------0-----------------------#2018-07-30">https://medium.com/hackernoon/learn-functional-python-in-10-minutes-to-2d1651dece6f?source=collection_archive---------0-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/dee1275b71e6b0289d4623366bacb54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXixptvL4rzkx3EDuj38xw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/ieic5Tq8YMk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae jg" href="https://unsplash.com/search/photos/python-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="edac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文中，您将了解什么是函数范式，以及如何在Python中使用函数编程。你还会学到列表理解和其他形式的理解。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="7c3e" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">功能范式</strong></h1><p id="b893" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">在命令式范式中，你通过给计算机一系列任务来完成事情，然后它执行这些任务。在执行它们时，它可以改变状态。例如，假设您最初将A设置为5，然后稍后您更改了A的值。您拥有变量，因为变量内部的值是变化的。</p><p id="d362" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在函数范式中，你不告诉计算机做什么，而是告诉它东西是什么。一个数的最大公约数是多少，1到n的乘积是多少等等。</p><p id="4d8f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正因为如此，变量不能变化。一旦你设置了一个变量，它将永远保持这个状态(注意，在纯函数式语言中，它们不被称为变量)。正因为如此，函数在函数范式中没有T2副作用。副作用是函数改变了外部的一些东西。让我们看一个典型Python代码的例子:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="4a50" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码的输出是5。在函数范式中，改变变量是一大禁忌，让函数影响其范围之外的事情也是一大禁忌。函数唯一能做的就是计算一些东西并返回结果。</p><p id="4d2a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在你可能会想:“没有变量，没有副作用？这有什么好？”。好问题，奇怪的陌生人读到这里。</p><p id="de4d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果用相同的参数调用一个函数两次，它肯定会返回相同的结果。如果你已经了解了<a class="ae jg" rel="noopener" href="/brandons-computer-science-notes/a-primer-on-functions-9a51c1e9de80">数学函数</a>，你就会知道欣赏这种好处。这被称为<em class="lv">参照透明</em>。因为函数没有副作用，如果你正在构建一个计算事物的程序，你可以加速程序。如果程序知道func(2)等于3，我们可以将它存储在一个表中。这可以防止程序在我们已经知道答案的情况下重复运行同一个函数。</p><p id="154a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，在函数式编程中，我们不使用循环。我们使用递归。递归是一个数学概念，通常，它意味着“馈入自身”。对于递归函数，该函数反复调用自己作为子函数。下面是Python中递归函数的一个很好的例子:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="1a4f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有些编程语言也<strong class="jj hv">懒</strong>。这意味着他们不到最后一秒不会计算或做任何事情。如果你写一些代码来执行2 + 2，一个函数式程序只会在你实际需要使用结果的时候计算。我们将很快在Python中探索懒惰。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h2 id="7e20" class="lx kt hu bd ku ly lz ma ky mb mc md lc js me mf lg jw mg mh lk ka mi mj lo mk dt translated"><strong class="ak">地图</strong></h2><p id="075d" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">要理解map，我们先来看看什么是iterables。iterable是任何你可以迭代的东西。通常这些是列表或数组，但是Python有许多不同类型的可迭代对象。你甚至可以通过实现神奇的方法来创建你自己的可迭代对象。一个神奇的方法就像一个API，帮助你的对象变得更加Pythonic化。您需要实现两个神奇的方法来使一个对象成为可迭代的:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="5348" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第一个神奇的方法，“__iter__”或dunder iter(双下划线iter)返回迭代对象，这通常在循环开始时使用。Dunder next返回下一个对象是什么。</p><p id="982a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们进入一个简短的终端会话，看看这个:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="c990" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这会打印出来</p><pre class="kf kg kh ki fq ml mm mn mo aw mp dt"><span id="2633" class="lx kt hu mm b fv mq mr l ms mt">3<br/>4<br/>5<br/>6<br/>7<br/>8</span></pre><p id="a0e7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Python中，迭代器是一个只有__iter__ magic方法的对象。这意味着您可以访问对象中的位置，但不能循环访问对象。有些对象会有魔术方法__next__而没有__iter__魔术方法，比如sets(本文后面会谈到)。对于本文，我们将假设我们接触的所有东西都是可迭代的对象。</p><p id="ff87" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们知道了什么是iterable对象，让我们回到map函数。map函数允许我们将函数应用到iterable中的每一项。通常我们希望对列表中的每一项都应用一个函数，但是我们知道这对于大多数的可重复项都是可能的。Map有两个输入，要应用的函数和iterable对象。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="7fc1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设我们有一个数字列表，如下所示:</p><pre class="kf kg kh ki fq ml mm mn mo aw mp dt"><span id="0ed7" class="lx kt hu mm b fv mq mr l ms mt">[1, 2, 3, 4, 5]</span></pre><p id="9fc7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们想对每个数字求平方，我们可以写这样的代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="a66e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Python中的函数是懒惰的。如果我们不包含“list()”，函数将存储iterable的定义，而不是列表本身。我们需要明确地告诉Python“把它变成一个列表”来使用它。</p><p id="2ed8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Python中突然从非懒求值变成懒求值有点奇怪。如果你更多地用功能性思维而不是命令性思维来思考，你最终会习惯的。</p><p id="2ce9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在写一个像“square(num)”这样的普通函数很好但是看起来不对。我们必须定义一个完整的函数，仅仅是为了在地图中使用一次？嗯，我们可以使用lambda(匿名)函数在map中定义一个函数。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="e97d" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">λ表达式</strong></h1><p id="d7d0" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">lambda表达式是一个单行函数。例如，这个λ表达式对给定的一个数进行平方:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="a6ba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们运行这个:</p><pre class="kf kg kh ki fq ml mm mn mo aw mp dt"><span id="b268" class="lx kt hu mm b fv mq mr l ms mt">&gt;&gt;&gt; square(3)</span><span id="736b" class="lx kt hu mm b fv mu mr l ms mt">9</span></pre><p id="294a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我听到了。“布兰登，论据在哪里？这是什么鬼东西？那看起来一点也不像函数？”</p><p id="7d21" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗯，这有点令人困惑，但可以解释。所以我们给变量“square”赋值。这部分:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="4d2c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">告诉Python这是一个lambda函数，输入名为x。冒号后的任何内容都是您对输入所做的操作，它会自动返回结果。</p><p id="685b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了将我们的square程序简化成一行，我们可以:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="56aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以在lambda表达式中，所有的参数都在左边，你想用它们做的东西在右边。它变得有点乱，没人能否认。事实是，编写只有其他函数式程序员才能读懂的代码有某种乐趣。此外，把一个函数变成一行程序也非常酷。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="1ca7" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">减少</strong></h1><p id="574b" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">Reduce是一个把一个iterable变成一个东西的函数。通常，你对一个列表进行计算，<strong class="jj hv">将它减少到一个数字。Reduce看起来像这样:</strong></p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="68a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以(并且经常会)使用lambda表达式作为函数。</p><p id="9a24" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">列表的乘积是每个数字相乘的结果。为此，您需要编写:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="e50d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是使用reduce，您可以只写:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="24fb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">才能得到同样的产品。代码更短，有了函数式编程的知识，代码更整洁。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="e89c" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">滤镜</strong></h1><p id="eaea" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">filter函数获取一个iterable，并过滤掉该iterable中您不想要的所有内容。</p><p id="f9f3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常过滤器接受一个函数和一个列表。它将该函数应用于列表中的每一项，如果该函数返回True，则不执行任何操作。如果返回False，则从列表中删除该项。</p><p id="1414" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">语法如下所示:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="89e3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看一个小例子，如果没有过滤器，我们将写:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="325d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了过滤器，这就变成:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="498e" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">高阶函数</strong></h1><p id="e260" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">高阶函数可以将函数作为参数和返回函数。一个非常简单的例子是这样的:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="9919" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者第二个定义“返回函数”的一个更简单的例子是:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="6c1e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你知道我之前说过纯函数式编程语言没有变量吗？嗯，高阶函数使这变得更容易。如果您所做的只是通过一个长长的函数隧道传递数据，那么您不需要在任何地方存储变量。</p><p id="9513" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Python中的所有函数都是一级类对象。第一类对象被定义为具有这些特征中的一个或多个:</p><ul class=""><li id="14cb" class="mv mw hu jj b jk jl jo jp js mx jw my ka mz ke na nb nc nd dt translated">在运行时创建</li><li id="8739" class="mv mw hu jj b jk ne jo nf js ng jw nh ka ni ke na nb nc nd dt translated">赋给数据结构中的一个变量或元素</li><li id="5334" class="mv mw hu jj b jk ne jo nf js ng jw nh ka ni ke na nb nc nd dt translated">作为参数传递给函数</li><li id="0c91" class="mv mw hu jj b jk ne jo nf js ng jw nh ka ni ke na nb nc nd dt translated">作为函数的结果返回</li></ul><p id="d730" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以Python中的所有函数都是一级的，可以作为高阶函数使用。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="e19b" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">部分应用</strong></h1><p id="4a5d" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">部分应用程序(也称为闭包)有点奇怪，但是非常酷。您可以调用一个函数，而无需提供它需要的所有参数。让我们看一个例子。我们想创建一个函数，它有两个参数，一个底数和一个指数，并返回底数的指数幂，如下所示:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="ec2e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们希望有一个专用的平方函数，使用幂函数计算一个数的平方:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="58c9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是可行的，但是如果我们想要一个立方函数呢？还是4次方的函数？我们能永远写下去吗？你可以。但是程序员很懒。如果你一遍又一遍地重复同样的事情，这是一个迹象，表明有一种更快的方法可以加快速度，并且可以让你不再重复。我们可以在这里使用部分应用程序。让我们看一个使用部分应用程序的square函数的示例:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="e536" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">是不是很酷！我们可以调用需要两个参数的函数，只使用一个参数，告诉Python第二个参数是什么。</p><p id="d416" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们也可以使用一个循环来生成一个幂函数，从立方一直到1000次方。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="2d86" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">函数式编程不是Pythonic式的</strong></h1><p id="d661" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">你可能已经注意到了，但是我们在函数式编程中想做的很多事情都是围绕着列表的。除了reduce函数&amp; partial application，你见过的所有函数都生成列表。Guido(Python的发明者)不喜欢Python中的函数性东西，因为Python已经有了自己生成列表的方法。</p><p id="cf8f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您将“import this”写入Python空闲会话，您将得到:</p><pre class="kf kg kh ki fq ml mm mn mo aw mp dt"><span id="80f4" class="lx kt hu mm b fv mq mr l ms mt">&gt;&gt;&gt; import this</span><span id="4bd1" class="lx kt hu mm b fv mu mr l ms mt">The Zen of Python, by Tim Peters</span><span id="8b5d" class="lx kt hu mm b fv mu mr l ms mt">Beautiful is better than ugly.<br/>Explicit is better than implicit.<br/>Simple is better than complex.<br/>Complex is better than complicated.<br/>Flat is better than nested.<br/>Sparse is better than dense.<br/>Readability counts.<br/>Special cases aren’t special enough to break the rules.<br/>Although practicality beats purity.<br/>Errors should never pass silently.<br/>Unless explicitly silenced.<br/>In the face of ambiguity, refuse the temptation to guess.<br/>There should be one — and preferably only one — obvious way to do it.<br/>Although that way may not be obvious at first unless you’re Dutch.<br/>Now is better than never.<br/>Although never is often better than *right* now.<br/>If the implementation is hard to explain, it’s a bad idea.<br/>If the implementation is easy to explain, it may be a good idea.<br/>Namespaces are one honking great idea — let’s do more of those!</span></pre><p id="0790" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是Python的禅。这是一首关于蟒蛇意味着什么的诗。我们在这里要联系的部分是:</p><blockquote class="nj"><p id="a214" class="nk nl hu bd nm nn no np nq nr ns ke ek translated"><em class="nt">应该有一种——最好只有一种——显而易见的方法来做这件事。</em></p></blockquote><p id="7bdf" class="pw-post-body-paragraph jh ji hu jj b jk nu jm jn jo nv jq jr js nw ju jv jw nx jy jz ka ny kc kd ke hn dt translated">在Python中，map &amp; filter可以做与列表理解(接下来讨论)相同的事情。这打破了Python禅宗的一条规则，因此函数式编程的这些部分不被视为“Python化的”。</p><p id="78e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一个话题是Lambda。在Python中，lambda函数是一个普通函数。Lambda是句法糖。这两者是等价的:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="ec68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">常规函数可以做lambda函数能做的一切，但反过来就不行了。lambda函数不能做常规函数能做的所有事情。</p><p id="5e8c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个关于为什么函数式编程不能很好地融入整个Python生态系统的简短争论。你可能已经注意到我之前提到了列表理解，我们现在将讨论它们。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="1416" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated"><strong class="ak">列举理解</strong></h1><p id="5664" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">之前，我提到过你可以用地图或过滤器做的任何事情，你都可以用列表理解来做。这是我们将了解他们的部分。</p><p id="5ce0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">列表理解是用Python生成列表的一种方式。语法是:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="7671" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">举例来说，让我们对列表中的每个数字求平方:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="114b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好的，我们可以看看如何将一个函数应用于列表中的每一项。我们如何应用过滤器呢？好吧，看看前面的这段代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="7ec8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以把它转换成如下的列表理解:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="1b52" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">列表理解支持这样的if语句。你不再需要应用一百万个函数来得到你想要的东西。事实上，如果你想做一个清单，使用清单理解会看起来更简洁和容易。</p><p id="0a48" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们想对列表中每个小于0的数字求平方呢？嗯，使用lambda、map和filter，您将编写:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="de45" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这看起来很长，也有点复杂。对于列表理解，它只是:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="9f42" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">列表理解只对列表有用。映射和过滤可以在任何iterable上工作，那么这是怎么回事呢？嗯，你可以对你遇到的任何可重复的对象使用任何理解。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="ecc5" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">其他理解</h1><p id="5742" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">你可以创造出对任何事物的理解</p><p id="4148" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">任何可重复项都可以通过理解产生。从Python 2.7开始，你甚至可以生成一个字典(hashmap)。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="17c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果是可迭代的，就可以生成。让我们看看集合的最后一个例子。如果你不知道什么是set，可以看看我写的这篇<a class="ae jg" rel="noopener" href="/brandons-computer-science-notes/a-primer-on-set-theory-746cd0b13d13">其他文章</a>。TLDR是:</p><ul class=""><li id="c1ba" class="mv mw hu jj b jk jl jo jp js mx jw my ka mz ke na nb nc nd dt translated">集合是元素的列表，没有一个元素在列表中重复两次</li><li id="8d4b" class="mv mw hu jj b jk ne jo nf js ng jw nh ka ni ke na nb nc nd dt translated">集合中的顺序无关紧要。</li></ul><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="lw kk l"/></div></figure><p id="74aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能会注意到集合和字典有相同的花括号。Python真的很聪明。它会根据你是否为字典提供了额外的价值来判断你是在写字典理解还是集合理解。如果你想了解更多关于理解的知识，请查看<a class="ae jg" href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" rel="noopener ugc nofollow" target="_blank">这个</a>视觉指南。如果你想了解更多关于comprehensions &amp;生成器的知识，请查看这篇<a class="ae jg" href="https://medium.freecodecamp.org/python-list-comprehensions-vs-generator-expressions-cef70ccb49db" rel="noopener ugc nofollow" target="_blank">文章</a>。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h1 id="55d2" class="ks kt hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">结论</h1><p id="9272" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated">函数式编程很美很纯粹。功能代码可以是干净的，但也可能是杂乱的。一些铁杆Python程序员不喜欢Python中的函数范式。你应该用你想用的东西，用最好的工具。</p></div><div class="ab cl kl km hc kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hn ho hp hq hr"><h2 id="4dff" class="lx kt hu bd ku ly lz ma ky mb mc md lc js me mf lg jw mg mh lk ka mi mj lo mk dt translated">你喜欢这篇文章吗？在社交媒体上与我联系，讨论所有与计算机科学相关的事情😁</h2><p id="84d2" class="pw-post-body-paragraph jh ji hu jj b jk lq jm jn jo lr jq jr js ls ju jv jw lt jy jz ka lu kc kd ke hn dt translated"><a class="ae jg" href="https://twitter.com/brandon_skerrit" rel="noopener ugc nofollow" target="_blank">推特</a>|<a class="ae jg" href="http://instagram.com/brandon.codes" rel="noopener ugc nofollow" target="_blank">insta gram</a>|<a class="ae jg" href="https://www.linkedin.com/in/brandonls/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></p><p id="4531" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">别忘了点击那个👏拍手声👏按钮，以示感谢！</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="5217" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我写这篇文章没有得到报酬。如果你想支持我，请在下面给我买杯咖啡什么的😁</p><div class="nz oa fm fo ob oc"><a href="https://www.paypal.me/brandonskerritt" rel="noopener  ugc nofollow" target="_blank"><div class="od ab ej"><div class="oe ab of cl cj og"><h2 class="bd hv fv z el oh eo ep oi er et ht dt translated">用贝宝支付布兰登·斯凯里特。我</h2><div class="oj l"><h3 class="bd b fv z el oh eo ep oi er et ek translated">去paypal.me/BrandonSkerritt输入金额。既然是PayPal，那就简单又安全。没有PayPal…</h3></div><div class="ok l"><p class="bd b gc z el oh eo ep oi er et ek translated">www.paypal.me</p></div></div><div class="ol l"><div class="om l on oo op ol oq ja oc"/></div></div></a></div><div class="nz oa fm fo ob oc"><a href="https://monzo.me/brandonskerritt" rel="noopener  ugc nofollow" target="_blank"><div class="od ab ej"><div class="oe ab of cl cj og"><h2 class="bd hv fv z el oh eo ep oi er et ht dt translated">通过Monzo.me即时支付Brandon</h2><div class="oj l"><h3 class="bd b fv z el oh eo ep oi er et ek translated">点击链接向布兰登付款。你不需要创建一个账户，而且完全免费。</h3></div><div class="ok l"><p class="bd b gc z el oh eo ep oi er et ek translated">monzo.me</p></div></div><div class="ol l"><div class="or l on oo op ol oq ja oc"/></div></div></a></div></div></div>    
</body>
</html>