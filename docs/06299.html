<html>
<head>
<title>Enforcing a single web socket connection per user with Node.js, Socket.IO, and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js，socket对每个用户强制执行单个web套接字连接。IO和Redis</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/enforcing-a-single-web-socket-connection-per-user-with-node-js-socket-io-and-redis-65f9eb57f66a?source=collection_archive---------1-----------------------#2018-07-30">https://medium.com/hackernoon/enforcing-a-single-web-socket-connection-per-user-with-node-js-socket-io-and-redis-65f9eb57f66a?source=collection_archive---------1-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d7e963cabb61693927577fbd166a7ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RZRzYMtXYrBQsqi5"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“A black-and-white shot of a person working with a MacBook on their lap” by <a class="ae jg" href="https://unsplash.com/@szolkin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sergey Zolkin</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9f11" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近，我一直在做一个实时多人浏览器游戏，遇到了“单会话”问题。本质上，我想防止用户通过web套接字多次连接。这一点很重要，因为多次登录同一个帐户可能会造成不公平的情况，并使服务器逻辑更加复杂。因为web套接字连接是长期存在的，所以我需要找到一种方法来防止这种情况。</p><h2 id="d1e2" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">愿望单</h2><ul class=""><li id="a6fa" class="la lb hu jj b jk lc jo ld js le jw lf ka lg ke lh li lj lk dt translated">一个用户只能连接一次，不管他们打开了多少个浏览器标签。可以通过用户的认证令牌来识别用户。</li><li id="6f4d" class="la lb hu jj b jk ll jo lm js ln jw lo ka lp ke lh li lj lk dt translated">该系统必须在集群环境中工作。单个服务器节点应该能够在不影响系统其余部分的情况下关闭。</li><li id="15b1" class="la lb hu jj b jk ll jo lm js ln jw lo ka lp ke lh li lj lk dt translated">授权令牌不应通过查询参数传递，而应在连接建立后通过专用的身份验证事件传递。</li></ul><p id="65ba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于这个项目，我们将使用Node.js，Socket。木卫一和雷迪斯。</p><h1 id="3311" class="lq kg hu bd kh lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg dt translated">卑微的出身</h1><p id="da34" class="pw-post-body-paragraph jh ji hu jj b jk lc jm jn jo ld jq jr js mh ju jv jw mi jy jz ka mj kc kd ke hn dt translated">让我们建立我们的项目，开始行动吧。你可以点击查看完整的GitHub <a class="ae jg" href="https://github.com/mariotacke/blog-single-user-websocket" rel="noopener ugc nofollow" target="_blank">回购。首先，我们将设置我们的套接字。IO服务器接受来自前端的连接。</a></p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A Socket.IO server in its simplest form.</figcaption></figure><p id="191c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">默认情况下，服务器将侦听端口9000，并将每个客户端的连接状态回显到控制台。插座。IO提供了一个内置的机制来生成一个惟一的套接字id，我们将使用它来标识我们的客户机的套接字连接。</p><p id="eeb0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，我们创建一个示例页面来连接到我们的服务器。该页面包括一个状态显示、一个用于输入我们的秘密令牌的输入框(我们将使用它进行身份验证)以及连接和断开按钮。</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Sample front-end mark-up with inputs and buttons to connect and disconnect.</figcaption></figure><p id="30b3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，我们需要设置一些非常基本的逻辑来执行连接/断开，并连接我们的状态和令牌输入。</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Our basic front-end logic… for now.</figcaption></figure><p id="14b7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是设置基本web套接字客户机和服务器所需的一切。此时，我们可以连接、断开连接，并向用户记录连接状态。所有这些都是用普通的JavaScript编写的！🍻接下来:认证用户。</p><h1 id="db58" class="lq kg hu bd kh lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg dt translated">证明</h1><p id="7154" class="pw-post-body-paragraph jh ji hu jj b jk lc jm jn jo ld jq jr js mh ju jv jw mi jy jz ka mj kc kd ke hn dt translated">让用户在不知道自己是谁的情况下连接，对我们来说用处不大。让我们将基本令牌身份验证添加到连接中。我们假设连接在部署后使用SSL/TLS。切勿使用未加密的连接。永远不会。😶</p><p id="a0ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此时，我们有几个选择:a)在用户连接时将用户的令牌附加到查询字符串，或者b)让任何用户连接，并要求他们在连接后发送身份验证消息。Web Socket协议规范(<a class="ae jg" href="https://tools.ietf.org/html/rfc6455#section-10.5" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a>)并没有规定一种特定的身份验证方式，也不允许自定义头，而且由于服务器可能会记录查询参数，所以我选择了这个例子中的选项b)。</p><p id="b813" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将通过Socket的认证模块<a class="mu mv gr" href="https://medium.com/u/f89b781338d4?source=post_page-----65f9eb57f66a--------------------------------" rel="noopener" target="_blank"> Facundo Olano </a>实现与<code class="eh mq mr ms mt b">socketio-auth</code>的认证。IO允许我们在客户端连接后提示客户端输入令牌。如果用户在一定时间内没有提供，我们将关闭与服务器的连接。</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Hooking up socketio-auth with a dummy user lookup.</figcaption></figure><p id="2acd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们通过以三个事件的形式传递我们的<code class="eh mq mr ms mt b">io</code>实例和配置选项来连接<code class="eh mq mr ms mt b">socketAuth</code>:<code class="eh mq mr ms mt b">authenticate</code>、<code class="eh mq mr ms mt b">postAuthenticate</code>和<code class="eh mq mr ms mt b">disconnect</code>。首先，我们的<code class="eh mq mr ms mt b">authenticate</code>事件在客户端连接并发出一个带有用户令牌有效负载的后续<code class="eh mq mr ms mt b">authentication</code>事件后被触发。如果客户端没有在可配置的时间内发送该认证事件，<code class="eh mq mr ms mt b">socketio-auth</code>将终止连接。</p><p id="5bc8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦用户发送了他们的令牌，我们就根据数据库中已知的用户对其进行验证。出于举例的目的，我创建了一个异步<code class="eh mq mr ms mt b">verifyUser</code>方法，模拟真实的数据库或缓存查找。如果找到用户，则返回，否则拒绝承诺，理由<code class="eh mq mr ms mt b">USER_NOT_FOUND</code>。</p><p id="354f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果一切顺利，我们调用回调并将套接字标记为已验证，如果令牌无效，则返回<code class="eh mq mr ms mt b">UNAUTHORIZED</code>。</p><p id="c5c2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们必须修改前端代码，以便在连接时向我们发送用户令牌。我们修改我们的<code class="eh mq mr ms mt b">connect</code>函数如下:</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Modified front-end code to emit the user authentication token upon connection.</figcaption></figure><p id="ee2e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们添加了两件事情:<code class="eh mq mr ms mt b">socket.emit('authentication', { token })</code>告诉服务器我们是谁，以及一个事件监听器<code class="eh mq mr ms mt b">socket.on('unauthorized')</code>对来自服务器的拒绝做出反应。</p><p id="d806" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们有了一个系统，让我们对用户进行身份验证，如果他们在最初连接后没有向我们提供令牌，我们可以选择将他们踢出去。</p><p id="23ff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，这仍然不能阻止用户使用同一个令牌连接两次。打开一个单独的窗口，尝试一下。为了强制进行单个会话，我们的服务器必须进行智能处理。💡</p><h1 id="fa69" class="lq kg hu bd kh lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg dt translated">防止多重连接</h1><p id="8cdb" class="pw-post-body-paragraph jh ji hu jj b jk lc jm jn jo ld jq jr js mh ju jv jw mi jy jz ka mj kc kd ke hn dt translated">在一台服务器上，确保一个用户只连接一次非常简单，因为所有连接都位于内存中。我们可以简单地遍历所有连接的客户端，并将它们的id与新客户端进行比较。然而，当我们谈到集群时，这种方法就失效了。如果不对所有节点发出查询，就没有简单的方法来确定特定用户是否已连接。随着许多用户的连接，这就产生了一个瓶颈。肯定有更好的方法。</p><p id="921b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用Redis输入分布式锁。</p><p id="b212" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用Redis来锁定和解锁资源，在我们的例子中:用户会话。分布式锁很难，你可以在这里阅读关于它们的所有内容。对于我们的用例，我们将在单个Redis节点上实现一个资源锁。让我们开始吧。</p><p id="705b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们要做的第一件事是连接插座。IO到Redis，以跨多个套接字启用发布/订阅。IO服务器。我们将使用Socket.IO提供的<code class="eh mq mr ms mt b">socket.io-redis</code>适配器。</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">We use the Socket.IO Redis adapter to enable pub/sub</figcaption></figure><p id="e701" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该Redis服务器用于其发布/订阅功能，以跨多个套接字协调事件。IO实例，例如新套接字的加入、交换消息或断开连接。在我们的例子中，我们将为我们的资源锁重用同一个服务器，尽管它也可以使用不同的Redis服务器。</p><p id="bc5b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们将我们的Redis客户端创建为一个单独的模块，并保证我们可以使用<code class="eh mq mr ms mt b">async</code> / <code class="eh mq mr ms mt b">await</code>的方法。</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A sample Redis client module</figcaption></figure><p id="a4a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">先说一下理论。我们到底想要达到什么目标？我们希望防止用户在任何给定的时间拥有多个并发的web套接字连接。对于一个在线游戏来说，这很重要，因为我们希望避免用户同时使用他们的账号玩多个游戏。此外，如果我们能保证每个用户只有一个用户会话，我们的服务器逻辑就简化了。</p><p id="fece" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要做到这一点，我们必须跟踪每个连接，获取一个锁，并在同一用户试图再次连接时终止其他连接。为了获得一个锁，我们使用Redis' <code class="eh mq mr ms mt b">SET</code>方法，带有<code class="eh mq mr ms mt b">NX</code>和一个到期时间(稍后将详细介绍到期时间)。<code class="eh mq mr ms mt b">NX</code>将确保我们只设置不存在的密钥。如果是，命令返回<code class="eh mq mr ms mt b">null</code>。我们可以使用这个设置来确定一个会话是否已经存在，如果存在就中止。</p><p id="28ff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们修改我们的<code class="eh mq mr ms mt b">authenticate</code>函数如下:</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Modified authenticate event handler with Redis lock</figcaption></figure><p id="7136" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们验证了用户拥有有效的令牌，我们就试图为他们的会话获取一个锁(第6行)。如果Redis可以<code class="eh mq mr ms mt b">SET</code>这个键，就意味着它以前不存在。我们还在命令中添加了<code class="eh mq mr ms mt b">EX 30</code>,让锁在30秒后自动过期。这很重要，因为我们的服务器或Redis可能会崩溃，我们不想永远锁定我们的用户。我选择30秒的原因是因为Socket。IO的默认ping是25秒，也就是说，每隔25秒它将探测连接的用户，看他们是否仍然连接。在下一节中，我们将利用这一点来更新锁。</p><p id="59f8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了更新锁，我们将钩入套接字连接的<code class="eh mq mr ms mt b">packet</code>事件来拦截<code class="eh mq mr ms mt b">ping</code>包。默认情况下，每25秒接收一次。如果到那时还没有收到包裹。IO将终止连接。</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Hooking into the internal “packet” event of Socket.IO</figcaption></figure><p id="b39f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们使用<code class="eh mq mr ms mt b">postAuthenticate</code>事件来注册我们的<code class="eh mq mr ms mt b">packet</code>事件处理程序。然后，我们的处理程序检查套接字是否通过了<code class="eh mq mr ms mt b">socket.auth</code>认证，以及数据包的类型是否为<code class="eh mq mr ms mt b">ping</code>。为了更新锁，我们将再次使用Redis' <code class="eh mq mr ms mt b">SET</code>命令，这次用<code class="eh mq mr ms mt b">XX</code>代替<code class="eh mq mr ms mt b">NX</code>。<code class="eh mq mr ms mt b">XX</code>声明只有当它已经存在时才会被设置。我们使用这种机制每25秒刷新一次密钥的到期时间。</p><p id="78e5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们现在可以对用户进行身份验证，为每个用户id获取一个锁，并防止创建多个会话。只要客户端每25秒向我们的服务器报告一次，我们的锁就会一直有效。</p><p id="cc5b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，有一个用例我们忽略了:如果用户关闭他们的浏览器并试图重新连接，他们将会错误地收到一个<code class="eh mq mr ms mt b">ALREADY_LOGGED_IN</code>消息。这是因为先前的锁定仍然有效。为了在用户有意离开我们的站点时正确地解除锁定，我们必须在断开连接时从Redis中移除锁定。</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Removing the session lock when a user disconnects</figcaption></figure><p id="060a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的<code class="eh mq mr ms mt b">disconnect</code>事件中，我们检查套接字是否被认证，然后通过<code class="eh mq mr ms mt b">DEL</code>命令从Redis中移除锁。这将清除用户会话锁，并为下一次连接做准备。</p><p id="0442" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是全部了！要查看我们的连接流程，请打开两个浏览器窗口，并在每个窗口中使用相同的令牌单击Connect您将在后者上收到一个状态<code class="eh mq mr ms mt b">Disconnected: ALREADY_LOGGED_IN</code>。正是我们想要的。是时候坐下来放松了。😅</p><h1 id="5284" class="lq kg hu bd kh lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg dt translated">结论</h1><p id="8b15" class="pw-post-body-paragraph jh ji hu jj b jk lc jm jn jo ld jq jr js mh ju jv jw mi jy jz ka mj kc kd ke hn dt translated">在本文中，我描述了一种通过使用Node.js、socket来验证web socket连接并防止多个用户会话的方法。木卫一和雷迪斯。这种机制是无状态的，在集群服务器环境中工作。</p><p id="4a7f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了获得更好的会话控制和故障转移，我建议深入研究Redis的分布式锁，并阅读redlock算法。</p></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="10a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢您花时间通读我的文章。如果你喜欢，请按几下拍手按钮👏！如果这篇文章对你有帮助，请随意分享！</p><p id="03c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想了解我的更多信息，请务必在<a class="ae jg" href="https://twitter.com/MarioTacke" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，在<a class="ae jg" rel="noopener" href="/@mariotacke"> Medium </a>上关注我，或者查看我的<a class="ae jg" href="https://www.mariotacke.io" rel="noopener ugc nofollow" target="_blank">网站</a>！</p><h2 id="a496" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">参考</h2><ul class=""><li id="31e0" class="la lb hu jj b jk lc jo ld js le jw lf ka lg ke lh li lj lk dt translated"><a class="ae jg" href="https://redis.io/topics/distlock" rel="noopener ugc nofollow" target="_blank">带Redis的分布式锁</a></li><li id="b701" class="la lb hu jj b jk ll jo lm js ln jw lo ka lp ke lh li lj lk dt translated"><a class="ae jg" href="https://github.com/mariotacke/blog-single-user-websocket" rel="noopener ugc nofollow" target="_blank">样本项目库</a></li><li id="fb8b" class="la lb hu jj b jk ll jo lm js ln jw lo ka lp ke lh li lj lk dt translated"><a class="ae jg" href="https://github.com/socketio/socket.io-redis" rel="noopener ugc nofollow" target="_blank"> socket.io-redis库</a></li><li id="0ef4" class="la lb hu jj b jk ll jo lm js ln jw lo ka lp ke lh li lj lk dt translated"><a class="ae jg" href="https://github.com/facundoolano/socketio-auth" rel="noopener ugc nofollow" target="_blank"> socketio-auth存储库</a></li><li id="2c69" class="la lb hu jj b jk ll jo lm js ln jw lo ka lp ke lh li lj lk dt translated"><a class="ae jg" href="https://tools.ietf.org/html/rfc6455#section-10.5" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a></li><li id="b183" class="la lb hu jj b jk ll jo lm js ln jw lo ka lp ke lh li lj lk dt translated">Redis <a class="ae jg" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank">设置</a>和<a class="ae jg" href="https://redis.io/commands/del" rel="noopener ugc nofollow" target="_blank">删除</a>命令</li></ul></div></div>    
</body>
</html>