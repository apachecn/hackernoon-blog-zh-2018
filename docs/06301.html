<html>
<head>
<title>Time to Go! Learning Golang through Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">该走了！通过示例学习Golang</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/time-to-go-learning-golang-through-examples-480a90c5e7f9?source=collection_archive---------3-----------------------#2018-07-30">https://medium.com/hackernoon/time-to-go-learning-golang-through-examples-480a90c5e7f9?source=collection_archive---------3-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b158" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近对区块链开源社区产生了兴趣。我注意到的第一件事是，我遇到的大多数项目都是用Go编写的。围棋已经在我的雷达上很长时间了，因为社区对它非常兴奋，并对它大加赞赏。</p><h2 id="586b" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">为什么要去？</h2><p id="1e0f" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated"><strong class="it hv"> Go </strong>是一种静态类型的编译语言，类似于C++和Java。它遵循了C语言在语法和语义上的简单性，并具有一些额外的特性。</p><p id="c9d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">戈鲁丁斯</em>T5】</strong></p><p id="c597" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与旧的<a class="ae kq" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程语言</a>相比(Python、Java等。)Go是2009年最近才发布的。Go的构建考虑到了并发性和高效利用多处理器的能力。<a class="ae kq" href="https://vimeo.com/49718712" rel="noopener ugc nofollow" target="_blank"> Rob Pike (Go创造者)对此有深入的探讨。</a>最终结果是运行并发go例程比用Java等其他语言线程化要便宜得多。这允许我们同时运行数千个<strong class="it hv"><em class="kp">go routine</em></strong>(甚至在单个处理器上！)毫无顾虑，并使其成为需要扩展的问题的完美解决方案。</p><p id="d561" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">代码的性能</em> </strong></p><p id="8db6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go直接在底层硬件上运行。Go不在虚拟机上执行，这意味着我们的代码被直接编译成二进制文件，在我们的处理器上运行。消除中间的VM(例如Javas中的JVM)意味着perf是尽可能低的级别，我们有能力通过消除不必要的抽象和性能影响来微调和优化我们的代码，以获得最大的回报。</p><p id="ac6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">职能是一等公民</em> </strong></p><p id="035f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Go中，函数和其他数据类型一样。这意味着函数可以返回函数，接受函数等等。这使我们能够利用函数式编程范例(这是我喜欢的！！)，并写出更干净、更清晰的代码。</p><p id="add2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">维修性</em> </strong></p><p id="e7e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go语法简洁。此外，它有一个优秀的格式化程序，以单一的方式格式化代码。这听起来可能很痛苦，但实际上解决了许多关于编码约定等令人头疼的问题。Go去掉了很多(IMO)使代码难以理解的语言特性，比如继承、构造函数、注释、泛型等等。</p><h2 id="1e64" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">包装</h2><p id="492f" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Go允许对包中的相关代码进行分组。编译时，包共享一个命名空间。因此，您可以在单独的文件中编写代码，但仍然可以调用位于不同目录或文件中的代码。随着您的项目变得越来越复杂，您可以创建大量的包，每个包代表您的应用程序的一个不同的逻辑单元。然而，我们用一个特殊的名字来告诉Go我们想把它变成一个可以执行的文件。那个名字叫<strong class="it hv"><em class="kp"/></strong>【总管】。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/8f951e76f65ff1573ff56d2f75b6113c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*JKfg07Jynjoa6EGg8pzPxQ.png"/></div></figure><p id="f38b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以将一个包命名为“main”告诉Go我们希望它是可执行的。一旦Go知道这个文件是可执行的，它将要求我们定义一个名为<strong class="it hv"><em class="kp">“main”</em></strong>的函数。该<code class="eh kz la lb lc b">main </code>功能将在程序运行时自动调用。</p><p id="0e2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go有一个非常健壮的标准库。为了访问，我们只需在包声明下添加import语句。开始应该是这样的:</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="6c4b" class="jp jq hu lc b fv lh li l lj lk">package main</span><span id="bcc8" class="jp jq hu lc b fv ll li l lj lk">import (</span><span id="00a7" class="jp jq hu lc b fv ll li l lj lk">    "fmt"<br/>)</span><span id="c5f4" class="jp jq hu lc b fv ll li l lj lk">func main() {</span><span id="2262" class="jp jq hu lc b fv ll li l lj lk">    fmt.Println("Hello world") // Amazing logic here</span><span id="35cb" class="jp jq hu lc b fv ll li l lj lk">}</span></pre><h2 id="5cb1" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">变量</h2><p id="1bad" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在Go中使用变量是熟悉的，但又是不同的。让我们检查一下变量赋值，稍后我们将看看通过值和通过引用使用变量。这是在Go中初始化变量的普通方法。</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="1b0c" class="jp jq hu lc b fv lh li l lj lk">var currentDay string = “Saturday”</span></pre><p id="1c91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在一个示例中，它看起来像这样:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lm"><img src="../Images/3668d018802e008e7eeb3dd0288d60f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvDN51vdZVezWaBz1nZBKw.png"/></div></div></figure><p id="b768" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这太冗长了。Go允许将变量声明和赋值简化为:</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="5387" class="jp jq hu lc b fv lh li l lj lk">currentDay := “Saturday”</span></pre><p id="6a10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go在这里推断‘current day’是一个字符串，因此没有必要明确说明它。同样，Go知道下面是一个“整数”声明。</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="f792" class="jp jq hu lc b fv lh li l lj lk">luckyNumber := 3</span></pre><p id="dd46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，为了把这些放在一起，下面两种声明和初始化Go变量的方法是等效的。</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="f8ca" class="jp jq hu lc b fv lh li l lj lk">luckyNumber := 3</span><span id="600a" class="jp jq hu lc b fv ll li l lj lk">var luckyNumber int = 3 // oops! This will cause an error!</span></pre><p id="b392" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过要小心！在Go中，一个变量只能初始化一次。所以上面的代码片段会编译失败！</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lr"><img src="../Images/78ce734319a14ffeec147a20f3eec154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfkGfazM3UQeIfu0uzHFjw.png"/></div></div></figure><h2 id="4f00" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">功能</h2><p id="f78a" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Go是一种静态类型的编程语言，所以我们需要标注每个函数返回值的类型。下面的代码不会编译，因为我们还没有注释返回类型:</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="1c3d" class="jp jq hu lc b fv lh li l lj lk">func greetUser() { // function declaration is missing return type!</span><span id="f90b" class="jp jq hu lc b fv ll li l lj lk">  return “Hey friend!”</span><span id="351b" class="jp jq hu lc b fv ll li l lj lk">}</span></pre><p id="9ddf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要修复这个错误，我们只需在函数声明中添加一个返回类型。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ls"><img src="../Images/5a73e42bff2747b1dde323e61e771814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tR1Avh-P5uCF-1_ZRnWvFQ.png"/></div></div></figure><p id="f0e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从main方法中调用这个函数如下所示:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lt"><img src="../Images/0ebcbe0b4e1a56409f414888103efeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*if5xmNbpjUL42wOlIpk2lw.png"/></div></div></figure><p id="bdc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">酷毙了。让我们来看一个例子，在这个例子中，我们把到目前为止看到的所有东西都联系起来。让我们在不同的文件中声明greetUser，但是使用相同的包并调用它。回想一下，同一个包中的文件共享一个名称空间，可以自由地相互调用。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lu"><img src="../Images/02ef6ce72d383254eb8c964ee23858ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6VfU3bawTvQtUiYghaUYQ.png"/></div></div></figure><p id="ae95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们用以下方式构建上述内容</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="c9a3" class="jp jq hu lc b fv lh li l lj lk">go run utils.go main.go</span></pre><p id="8cb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们得到以下结果:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/4c92fa2bc576a36a1ffdf09a4f5c1c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*YEjpd0D68ciAxDh6VYmjVw.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">from our stdout</figcaption></figure><h2 id="4e12" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">切片和for循环</h2><p id="fb3d" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在Go中，数组是静态的，它们的长度需要在创建时指定。如果你想处理一个动态大小的数组，你需要使用一个<strong class="it hv"> <em class="kp">片</em> </strong>。声明一个切片非常简单:</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="da5d" class="jp jq hu lc b fv lh li l lj lk">fruits := []string{“Mango”, “Cherry”, “Apple”}</span></pre><p id="76c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，切片中只能有一种类型的值。因此，声明一个带有int和string的片将不会被编译。</p><p id="711e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们对水果切片进行一次基本迭代，并记录每个元素。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ma"><img src="../Images/82699c7c891037da5b93595ec8e2e282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHbcsMLnKofhcm2aTwu6Yw.png"/></div></div></figure><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="ebb4" class="jp jq hu lc b fv lh li l lj lk">Don’t forget to build with go run main.go</span></pre><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/65195dcad2aabe934e6aff52eb855a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*wpWlajgo2MX8PR97iyMtgQ.png"/></div></figure><p id="6201" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个问题是Go要求我们在代码中使用所有声明的变量。如果我们不想要这个索引，我们可以告诉Go忽略它，将它命名为“下划线”，如下所示:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mc"><img src="../Images/7616e699d61e95e855d6facdfe71c6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJt7Ir1Hav2-7EjRnXsIyw.png"/></div></div></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff md"><img src="../Images/399f15853b2db358cf0c9ba75fe85c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*unruvYO5ESv5Q63Q_HdO1Q.png"/></div></figure><h2 id="6cfc" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">切片是如何工作的</h2><p id="159a" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Go如何处理创建这些动态切片？Go的做法还是挺有意思的。当一个片被创建时<strong class="it hv">，两个数据结构被创建</strong>。第一个是数组，第二个是记录切片长度、切片容量和对该数组的引用的结构。</p><h2 id="5a06" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">Go是面向对象的语言吗？</h2><p id="ea5d" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">根据文件是和不是(耶，多么清晰的答案！).围棋采取了不同的方法，试图取得相似的结果。在围棋中，没有“类”。相反，Go允许我们为特定的数据类型声明“接收函数”。理解这一点最简单的方法是查看一些代码。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff me"><img src="../Images/fb00f921973e14ea9248d19ab3fb64a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*JjYDBn44ju-TTF5918ip6g.png"/></div></figure><p id="2c3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，尽管我们不能创建一个Day类(就像我们在经典的OOP语言中那样——想想现在的Java、Python甚至JS ),我们仍然可以很容易地为这些类型声明新的数据类型和方法。</p><p id="871f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，让我们把Go术语桥接起来，并把它与经典OOP中的一些东西进行比较。</p><blockquote class="mf mg mh"><p id="db3e" class="ir is kp it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">通过创建一个带有接收方的函数的新类型，我们为该类型的任何值添加了一个“方法”。(斯蒂芬·格里德)</p></blockquote><h2 id="8cd2" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">多个返回值</h2><p id="adf8" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">我非常喜欢Go的一个特性是从一个函数返回多个值的能力。让我们看看实际情况:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ml"><img src="../Images/a111d7667fd6e94bce61a12cd219122f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rahckts9wJZMp711W8KCA.png"/></div></div></figure><p id="9259" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结构</strong></p><p id="a43a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go的结构是可变字段 的<strong class="it hv"> <em class="kp">类型集合。如果你来自JS、python或Java，它本质上是一个对象。它们对于将数据组合在一起形成记录很有用。</em></strong></p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lr"><img src="../Images/19f51b7a85c6cb8fffce43b5023e2000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcDcIobDiGucK_IHgPZcVg.png"/></div></div></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/0419ecbc822a1ad492d2ace0ac89989e.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*dm2Tu4sn-zxJZW7hQieZ6A.png"/></div></figure><h2 id="69cc" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">地址和指针</h2><p id="e7e6" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Go区分两种不同的数据类型。</p><p id="7058" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">值类型</em> </strong> —包含原始数据类型的实际值的类型。想想<em class="kp"> int，float，strings，</em>等等。</p><p id="b2cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">引用类型</em> </strong> —包含对实际基础记录列表的引用的任何数据类型。</p><p id="2945" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是对话开始变得更有趣的地方。默认情况下<strong class="it hv">当传递参数类型——如int、float、string或struct到函数中时，Go复制每个参数并通过值传递。有了这些知识，下面的例子通过值传递。你希望它打印什么？</strong></p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mn"><img src="../Images/092382decd7b3d9d7bcf16088f7e75a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8L5o-eq9CjY2mdwbDAraAA.png"/></div></div></figure><p id="cb7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为Go复制“值类型”，并且不向它们发送引用，所以上面的输出:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/d4c8fcdf8b4229a539dbe2fb8913a9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*N_-rghjq1KzT5DxE0ACOfQ.png"/></div></figure><p id="f815" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们刚刚看到Go中的变量是按值传递的。就像我们之前提到的，当<strong class="it hv"> <em class="kp">片</em> </strong>被创建时，片上带有元数据的附加数据结构被创建。这包括对<strong class="it hv"> <em class="kp">切片</em> </strong>的引用。每当我们谈到切片时，都会用到和提到这个参考。因此，下面的示例将成功地改变切片的内容。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mp"><img src="../Images/2036ce37860163ad30f6b7847a063534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VRNk8Lr73wQ24lB8P41OQ.png"/></div></div></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/aaffa833842923e1c9eb7689410220fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*47QJEOzK9geirkN1ONgKBQ.png"/></div></figure><p id="31fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果我们想改变发送给函数的结构数据，会发生什么呢？我们需要通过引用来传递它。Go在这个概念上有点低级，需要我们传递变量和解引用指针的地址。</p><blockquote class="mf mg mh"><p id="1ea2" class="ir is kp it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">旁白:指针只是计算机内存中变量的地址。如果我们发送变量的地址而不是值，我们可以直接操作它。</p></blockquote><h2 id="69c0" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">获取变量的地址</h2><p id="7f24" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">我们总是可以通过使用&amp;操作符来获取变量<strong class="it hv">T3的地址。 </strong></p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mr"><img src="../Images/103500355a50cf7f5277fc103d1e2b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgnWLFtwiwXbQb8CUtOrvA.png"/></div></div></figure><p id="73b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将输出物理内存 中变量的<strong class="it hv"> <em class="kp">实际地址。</em></strong></p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/97d75ec657ed3b0d111cd4844416b5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*xceaNnYnPfX-YzXjjyFNZw.png"/></div></figure><p id="54dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了对变量(它的地址)的引用，我们可以通过<strong class="it hv"> <em class="kp">取消对指针</em>的引用并赋予新的内容</strong>来轻松地改变它的值。</p><blockquote class="mf mg mh"><p id="7481" class="ir is kp it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">旁白:<em class="hu">解引用是从地址中提取一个值的行为。我们用*运算符取消对地址的引用。</em></p></blockquote><p id="773f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果我们希望我们的函数接收一个指向<strong class="it hv"> <em class="kp">类型的日期的指针(我们上一个例子中的结构)</em> </strong>然后记录它的值，我们可以这样做:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mt"><img src="../Images/eb10f3778de285b212a105c94ca55a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jlgnm5gV5N32YodTYUvsiw.png"/></div></div></figure><p id="f874" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一个使用接收函数时<strong class="it hv">通过引用传递的例子。</strong></p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mu"><img src="../Images/58b583d865a9c6e2c62027c3463c5d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9z1t2BkQsE6SFEcF2Lupg.png"/></div></div></figure><p id="22f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，为什么这种方法现在行得通呢？我们已经修改了updateDaySuccess接收函数，以接受一个指向day类型的指针。</p><blockquote class="mf mg mh"><p id="60d1" class="ir is kp it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated"><em class="hu">重要提示:当调用方法时，Go识别出它需要一个指针，并隐式地为我们发送一个对该值的引用(谢谢Go！)然后，updateDaySuccess接收指针，用*运算符对其解引用，并赋一个新值。</em></p></blockquote><h2 id="ed9d" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">地图</h2><p id="c518" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">最有用的数据结构之一是哈希表。它们提供快速查找、添加和删除。Go提供了实现哈希表的内置映射类型。在Go中，键和值可以是几种不同的类型，有一个空的接口。<a class="ae kq" href="https://play.golang.org/p/-s76LSSTEqI" rel="noopener ugc nofollow" target="_blank">在这个Go playground链接中，声明了一个带有几种不同类型键的地图。除此之外，它们的工作方式也和你想象的非常相似。</a></p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mv"><img src="../Images/2e8bddddb4777eef297269906c963d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RhU74zuz7GCTrTVbEMHBAw.png"/></div></div></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mw"><img src="../Images/3615a966a8eeca3e31d7b8d333154907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mze76wSaD1e1PYTRkCXcLg.png"/></div></div></figure><p id="9c08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">接口</strong></p><p id="bfe5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go中的接口使代码更加灵活。接口允许我们指定一些需要的行为，而不是要求特定的类型。在Go中，接口是隐式满足的。也就是说我们不需要写<em class="kp">implements blahBlah</em><strong class="it hv"/>(我看的是你们Java ppl) <strong class="it hv">之类的东西。当我们说一个类型满足一个接口时，我们的意思是这个类型实现了接口定义中包含的所有功能。让我们来看一个基本的例子:</strong></p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mx"><img src="../Images/3b5e813730f39dd379b548684a360a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFyA7ImevEsOPqRAFu5TJQ.png"/></div></div></figure><p id="b7bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这里我们会说day结构满足dayDetails接口，因为它定义了一个返回字符串的接收函数getDay。因此，如果你遇到了任何其他语言的接口，其基本原理和好处将继续下去。</p><p id="5537" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">戈鲁丁</strong></p><p id="10fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">goroutine是与其他函数或方法同时运行的函数(接收器或普通)。goroutine基本上是一个线程，但是开销较小。因为goroutines比线程轻，所以go程序同时运行数千个例程是很常见的。启动goroutine很简单！只需在前面加上go关键字，就可以自动得到一个并发运行的go例程。尽管开始一个围棋程序很简单，但还是有一些问题。让我们看看这个例子:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff my"><img src="../Images/9249090ad98dc1c837ecbba0b900e1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxy4wf6uYD3JaZdttwe7Vg.png"/></div></div></figure><p id="115c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您期望的输出是什么？</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/986f8fd8faf93864c6dca258f1e3480f.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*4P0_9b_AQFTIcAgv1rGGyQ.png"/></div></figure><p id="9ca1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">它为什么不输出“星期六”？</strong></p><p id="96b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当创建一个新的go例程时，调用会立即返回。与函数不同的是，<strong class="it hv">控件不会等待goroutine完成执行。</strong>所以在这种情况下，程序的流程继续并结束，主程序终止自己和它拥有的goroutine。让我们通过休眠我们的程序来克服这个问题。这将给我们的goroutine足够的时间来完成执行。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff na"><img src="../Images/5a5f69188ff0530b17305bd9a986fc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RER9-s5oaYkVQin0VCiHvQ.png"/></div></div></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff nb"><img src="../Images/382029f104c125125b21e914e5a9d127.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*u2z3B6Bd2o5Y0zbl3g1ppw.png"/></div></div></figure><p id="2004" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是可行的，但是非常不安全，我们不应该采用这种做法。渠道让我们做得更好。</p><p id="96bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">频道</strong></p><p id="11e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经看到，生成围棋程序很容易。通道是允许goroutines进行通信的工具。通道允许我们将数据从一个goroutine传输到另一个go routine(甚至使用管道操作符！).每个通道都有一个与之关联的数据类型。与通道相关联的数据类型定义了我们可以通过管道传输哪些数据。例如下面的通道允许可以发送和接收布尔值:</p><pre class="ks kt ku kv fq ld lc le lf aw lg dt"><span id="e5a9" class="jp jq hu lc b fv lh li l lj lk">boolChannel := make(chan bool)</span></pre><p id="f1b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">通过通道发送和接收数据是阻塞动作，因此我们可以很容易地重写上面的程序，忽略睡眠黑客。</strong></p><p id="68cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看如何重写我们的程序！</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff nc"><img src="../Images/dbccbb0d21c593172f1bb10950dd6469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SVdQfxQ3Ku3iHpSswm9rw.png"/></div></div></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff nd"><img src="../Images/69e65197177fea1d2c604aa00db76922.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*Lt4ClLebY4HwznubhJy5Qw.png"/></div></div></figure><h2 id="537e" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">结论</h2><p id="cb37" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">这是对Go功能的一个快速概述。显然，这只是冰山一角，还有很多有待发现:)我对Go的最初印象是简洁而强大。最近，我越来越喜欢静态类型语言，因为它允许开发速度更快，没有运行时错误，并且消除了一整类耗时的错误！我对学习区块链相关项目、服务器和任何需要并发性的东西的Go很感兴趣，因为它看起来很有趣也很强大！</p><p id="3974" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我的下一篇博文将探索区块链，敬请关注！</strong></p><h2 id="8656" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">如果这篇文章有帮助，请订阅并点击鼓掌👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">你可以在<a class="ae kq" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae kq" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae kq" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>