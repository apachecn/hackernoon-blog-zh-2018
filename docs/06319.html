<html>
<head>
<title>Why Telegram Passport is not End to End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么电报护照不是端到端的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-telegram-passport-is-not-end-to-end-6d01945ac262?source=collection_archive---------21-----------------------#2018-07-30">https://medium.com/hackernoon/why-telegram-passport-is-not-end-to-end-6d01945ac262?source=collection_archive---------21-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c3e0ec98b1557cec9d83b80df229e3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pDZMpfCHJ1JvtYTmxWMbQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="jg">This is a translation of the </em><a class="ae jh" href="https://habr.com/post/418535/" rel="noopener ugc nofollow" target="_blank"><em class="jg">original article</em></a><em class="jg"> by </em><a class="ae jh" href="https://habr.com/users/Scratch/" rel="noopener ugc nofollow" target="_blank"><em class="jg">Scratch</em></a><em class="jg">.</em></figcaption></figure><p id="913a" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">关于新的<a class="ae jh" href="https://hackernoon.com/tagged/telegram" rel="noopener ugc nofollow" target="_blank"> Telegram </a> Passport服务的安全性有很多讨论，所以让我们谈谈这项服务如何加密你的个人数据，并了解真正的端到端是如何工作的。</p><p id="d7d9" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">Telegram Passport如何工作:</p><ul class=""><li id="f39e" class="kg kh hu jk b jl jm jp jq jt ki jx kj kb kk kf kl km kn ko dt translated">它使用密码在本地加密您的所有个人数据(姓名、电子邮件、护照扫描、其他文件)。</li><li id="8f3d" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">加密数据和<a class="ae jh" href="https://hackernoon.com/tagged/metadata" rel="noopener ugc nofollow" target="_blank">元数据</a>加载到电报云中。</li><li id="eed7" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">当您需要登录服务时，客户端从云中下载数据，用密码解密，用请求信息的服务的公钥重新加密，然后将数据发送给服务。</li></ul><p id="e939" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们来分析第一部分，它处理你的个人数据的加密和存储。</p><p id="f973" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">按照开发者对端到端的理解——电报云无法解密你的个人数据。</p><p id="28c5" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们检查一下<a class="ae jh" href="https://github.com/telegramdesktop/tdesktop/blob/a919737f6ef98b56cd7db41577ecfc269a60f444/Telegram/SourceFiles/passport/passport_encryption.cpp" rel="noopener ugc nofollow" target="_blank">加密算法</a>。它从密码开始，当它变成中间加密密钥时:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="dbd1" class="ld le hu kz b fv lf lg l lh li">bytes::vector CountPasswordHashForSecret(<br/>      bytes::const_span salt,<br/>      bytes::const_span password) {<br/>  return openssl::Sha512(bytes::concatenate(<br/>      salt,<br/>      password,<br/>      salt));<br/>}</span></pre><p id="b672" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">随机盐被取出并与密码连接两次，然后通过SHA-512散列发送。</p><p id="5acd" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们在2k18！一个好的图形处理器每秒可以处理超过10亿次SHA-512。10 GPU将在80天内处理8位密码的所有可能组合。一周就能管理一百个。</p><p id="ec5e" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有许多方法可以让那些在GPU上暴力破解密码的人日子不好过，但Telegram的开发者决定不去费心实现它。</p><p id="a4a1" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">此外，密码散列加密另一个<em class="lj">几乎是</em>的随机密钥，它是这样生成的:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="12ec" class="ld le hu kz b fv lf lg l lh li">bytes::vector GenerateSecretBytes() {<br/>   auto result = bytes::vector(kSecretSize);<br/>   memset_rand(result.data(), result.size());<br/>   const auto full = ranges::accumulate(<br/>       result,<br/>       0ULL,<br/>       [](uint64 sum, gsl::byte value) { return sum + uchar(value); });  <br/>   const auto mod = (full % 255ULL);<br/>   const auto add = 255ULL + 239 - mod;  <br/>   auto first = (static_cast&lt;uchar&gt;(result[0]) + add) % 255ULL; result[0] = static_cast&lt;gsl::byte&gt;(first);<br/>   return result;<br/>}</span></pre><p id="4f3f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">它“几乎”是随机的，因为电报开发者从未听说过HMAC和AEAD，他们没有使用常规工具来检查解密的正确性，而是确保密钥的字节和的除法余数等于239，这在解密时得到验证:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="bab5" class="ld le hu kz b fv lf lg l lh li">bool CheckBytesMod255(bytes::const_span bytes) {  <br/>    const auto full = ranges::accumulate(   <br/>        bytes,<br/>        0ULL,<br/>        [](uint64 sum, gsl::byte value) { return sum + uchar(value); });<br/>    const auto mod = (full % 255ULL);  <br/>    return (mod == 239); <br/>}</span></pre><p id="3d37" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这个字节数组不是随机的。蛮力的话会有很多误报。然而，计算解码后的字节数比HMAC简单得多，所以基本上这种设计是在加速蛮力。</p><p id="0c74" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">现在让我们观察数据加密方法:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="57c0" class="ld le hu kz b fv lf lg l lh li">EncryptedData EncryptData(   <br/>        bytes::const_span bytes,  <br/>        bytes::const_span dataSecret) {  <br/>    constexpr auto kFromPadding = kMinPadding + kAlignTo - 1;   <br/>    constexpr auto kPaddingDelta = kMaxPadding - kFromPadding;  <br/>    const auto randomPadding = kFromPadding   <br/>        + (rand_value&lt;uint32&gt;() % kPaddingDelta);  <br/>    const auto padding = randomPadding   <br/>        - ((bytes.size() + randomPadding) % kAlignTo);  <br/>    Assert(padding &gt;= kMinPadding &amp;&amp; padding &lt;= kMaxPadding);   </span><span id="0676" class="ld le hu kz b fv lk lg l lh li">    auto unencrypted = bytes::vector(padding + bytes.size());  <br/>    Assert(unencrypted.size() % kAlignTo == 0);   </span><span id="ef8c" class="ld le hu kz b fv lk lg l lh li">    unencrypted[0] = static_cast&lt;gsl::byte&gt;(padding);  <br/>    memset_rand(unencrypted.data() + 1, padding - 1);  <br/>    bytes::copy(   <br/>        gsl::make_span(unencrypted).subspan(padding),<br/>        bytes);</span></pre><p id="7b86" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">数据附加32到255个随机字节。它发展到多样化<br/>变量dataHash。这是混合了随机字节的未加密数据的散列。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="ccab" class="ld le hu kz b fv lf lg l lh li">    const auto dataHash = openssl::Sha256(unencrypted);  <br/>    const auto bytesForEncryptionKey = bytes::concatenate(   <br/>        dataSecret,   <br/>        dataHash);   </span><span id="3488" class="ld le hu kz b fv lk lg l lh li">    auto params = PrepareAesParams(bytesForEncryptionKey);  <br/>    return {<br/>        { dataSecret.begin(), dataSecret.end() },   <br/>        { dataHash.begin(), dataHash.end() },   <br/>        Encrypt(unencrypted, std::move(params))  <br/>    }; <br/>}</span></pre><p id="e0df" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">生成个人数据加密密钥。它是通过另一个来自几乎随机生成的密钥的SHA-512调用获得的，该密钥与dataHash连接在一起。</p><h2 id="45c6" class="ld le hu bd ll lm ln lo lp lq lr ls lt jt lu lv lw jx lx ly lz kb ma mb mc md dt translated">结论</h2><p id="4fd1" class="pw-post-body-paragraph ji jj hu jk b jl me jn jo jp mf jr js jt mg jv jw jx mh jz ka kb mi kd ke kf hn dt translated">云传输:</p><ul class=""><li id="f01b" class="kg kh hu jk b jl jm jp jq jt ki jx kj kb kk kf kl km kn ko dt translated">来自个人数据的散列与随机字节混合。</li><li id="b57c" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">密码加密的<em class="lj">差点</em>随机密钥。</li><li id="0f9c" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">盐</li><li id="5c37" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">加密数据</li></ul><p id="2a1b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这绝对不是一个“随机噪音”，这里有一切，包括密码保护的加密密钥，它可以让你获得用户数据，比蛮力强制所有可能的AES密钥组合(2 ^ 256)快得多。</p><p id="88b1" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">对Telegram团队而不是HMAC发明的关键验证机制有很多疑问。</p><p id="3350" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">强力算法的一个例子:</p><ul class=""><li id="fcec" class="kg kh hu jk b jl jm jp jq jt ki jx kj kb kk kf kl km kn ko dt translated">从密码和salt (GPU)生成哈希。</li><li id="5375" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">试图破译密钥(AES-NI)。</li><li id="5bc6" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">根据字节数过滤掉无效密码。</li><li id="3973" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">使用另一个SHA-512调用(GPU)生成用于数据解密的候选密钥。</li><li id="0ad4" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">尝试解码第一个数据块(AES-NI)。</li><li id="7c94" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">为了不浪费时间进行完全解码和另一次SHA-256，您可以像他们一样通过检查第一个对齐字节来加速暴力破解:</li></ul><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="4b1f" class="ld le hu kz b fv lf lg l lh li">if (padding &lt; kMinPadding   <br/>        || padding &gt; kMaxPadding   <br/>        || padding &gt; decrypted.size()) {</span></pre><p id="b3e6" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">由于JSON的使用，解密文本的第一个字节总是“{”或“[”。</p><p id="56b8" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们发现个人数据的加密关键取决于密码的复杂性。蛮力的所有阶段都由硬件完美加速，无论是使用GPU还是AES-NI指令。</p><p id="8b41" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">当然，你可以设置一个长的安全密码，并希望它能完成这项工作。但是你怎么想，两亿电报用户中有百分之几会把密码做的比八个字符还长？</p><p id="5b81" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">此外，不使用标准验证机制的生成密钥和验证解密信息有效性的可疑技术直接违反了<strong class="jk hv">“不要使用自己的密码”</strong>原则，很明显这不是端到端的。</p><p id="9615" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">E2E之所以这么叫，是因为它允许你向第三方展示加密数据，而不用担心他们的安全。正如你所看到的，电报护照不能满足这个条件。</p><p id="aad2" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">感谢您的关注。</p></div><div class="ab cl mj mk hc ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hn ho hp hq hr"><h2 id="44d5" class="ld le hu bd ll lm ln lo lp lq lr ls lt jt lu lv lw jx lx ly lz kb ma mb mc md dt translated">❤如果这篇文章有帮助，请点击小心脏！(在<a class="ae jh" href="https://twitter.com/alik_chebotar" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我)</h2><figure class="ku kv kw kx fq iv"><div class="bz el l di"><div class="mq mr l"/></div></figure></div></div>    
</body>
</html>