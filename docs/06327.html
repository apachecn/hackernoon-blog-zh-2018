<html>
<head>
<title>Beam: Database Power without Template Haskell!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Beam:没有模板的数据库能力Haskell！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/beam-database-power-without-template-haskell-77a2df12fa24?source=collection_archive---------29-----------------------#2018-07-30">https://medium.com/hackernoon/beam-database-power-without-template-haskell-77a2df12fa24?source=collection_archive---------29-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e6d75990952e16b8b37a9fb321caefc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKQuARojwSXDoIy2Ttxp9g.png"/></div></div></figure><p id="9dfa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为我们的<a class="ae ka" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>的一部分，我们检查了<a class="ae ka" href="http://hackage.haskell.org/package/persistent" rel="noopener ugc nofollow" target="_blank">持久性</a>和<a class="ae ka" href="http://hackage.haskell.org/package/esqueleto" rel="noopener ugc nofollow" target="_blank"> Esqueleto </a>库。第一种方法允许您以特殊的语法创建数据库模式。然后，您可以使用模板Haskell为您的类型生成所有必需的Haskell数据类型和实例。更好的是，您可以编写类似SQL的Haskell代码来查询这些内容。这些查询是类型安全的，这很棒。然而，用模板Haskell指定我们的模式的需求带来了一些缺点。例如，代码需要更长的时间来编译，对于初学者来说不容易理解。</p><p id="240d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本周在博客上，我们将探索另一个名为<a class="ae ka" href="https://tathougies.github.io/beam/" rel="noopener ugc nofollow" target="_blank"> Beam </a>的数据库。这个库允许我们使用模板Haskell指定我们的数据库模式<em class="kb">,而不需要</em>。有一些样板涉及，但它一点也不坏！和Persistent一样，Beam支持很多后端，比如SQLite和PostgresQL。与Persistent不同，Beam还支持连接查询作为其系统的内置部分。</p><p id="ee6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想了解更多关于高级库的想法，请务必查看我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">制作清单</a>！它包括几个不同的数据库选项。</p><h1 id="d2b1" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">指定我们的类型</h1><p id="743a" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">首先要注意的是，虽然Beam不需要模板Haskell，但是它需要很多其他的编译器扩展。你可以看看下面附录中的那些，或者看看Github上的<a class="ae ka" href="https://www.github.com/jhb563/BeamExample" rel="noopener ugc nofollow" target="_blank">示例代码</a>。现在让我们回想一下在使用Persistent时我们是如何指定模式的:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="de40" class="lo kd hu lk b fv lp lq l lr ls">import qualified Database.Persist.TH as PTH</span><span id="c9b7" class="lo kd hu lk b fv lt lq l lr ls">PTH.share [PTH.mkPersist PTH.sqlSettings, PTH.mkMigrate "migrateAll"] [PTH.persistLowerCase|<br/>  User sql=users<br/>    name Text<br/>    email Text<br/>    age Int<br/>    occupation Text<br/>    UniqueEmail email<br/>    deriving Show Read Eq</span><span id="8f67" class="lo kd hu lk b fv lt lq l lr ls">  Article sql=articles<br/>    title Text<br/>    body Text<br/>    publishedTime UTCTime<br/>    authorId UserId<br/>    UniqueTitle title<br/>    deriving Show Read Eq</span></pre><p id="4030" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于Beam，我们不会使用模板Haskell，所以我们实际上将创建普通的Haskell数据类型。尽管如此，还是会有一些奇怪的事情。首先，按照惯例，我们将在末尾用额外的字符<code class="eh lu lv lw lk b">T</code>来指定我们的类型。这是不必要的，但是约定帮助我们记住什么类型与表相关。我们还必须提供一个额外的类型参数<code class="eh lu lv lw lk b">f</code>，稍后我们会详细讨论:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0ef7" class="lo kd hu lk b fv lp lq l lr ls">data UserT f =<br/>  …</span><span id="d484" class="lo kd hu lk b fv lt lq l lr ls">data ArticleT f =<br/>  ...</span></pre><p id="991a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的下一个约定是在我们的字段名前面使用下划线。与Persistent不同，我们还将在字段名称中指定类型名称。有了这些约定，我遵从了图书馆创建者Travis的建议。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="eda3" class="lo kd hu lk b fv lp lq l lr ls">data UserT f =<br/>  { _userId :: ...<br/>  , _userName :: …<br/>  , _userEmail :: …<br/>  , _userAge :: …<br/>  , _userOccupation :: …<br/>  }</span><span id="c77d" class="lo kd hu lk b fv lt lq l lr ls">data ArticleT f =<br/>  { _articleId :: …<br/>  , _articleTitle :: …<br/>  , _articleBody :: …<br/>  , _articlePublishedTime :: …<br/>  }</span></pre><p id="691b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，当我们指定每个字段的实际类型时，我们只需放入相关的数据类型，如<code class="eh lu lv lw lk b">Int</code>、<code class="eh lu lv lw lk b">Text</code>或其他，对吗？不完全是。为了完成我们的类型，我们将用我们想要的类型填充每个字段，除了通过<code class="eh lu lv lw lk b">Columnar f</code>指定的。此外，我们将在这两种类型上派生<code class="eh lu lv lw lk b">Generic</code>，这将允许Beam发挥它的魔力:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="cee8" class="lo kd hu lk b fv lp lq l lr ls">data UserT f =<br/>  { _userId :: Columnar f Int64<br/>  , _userName :: Columnar f Text<br/>  , _userEmail :: Columnar f Text<br/>  , _userAge :: Columnar f Int<br/>  , _userOccupation :: Columnar f Text<br/>  } deriving (Generic)</span><span id="8736" class="lo kd hu lk b fv lt lq l lr ls">data ArticleT f =<br/>  { _articleId :: Columnar f Int64<br/>  , _articleTitle :: Columnar f Text<br/>  , _articleBody :: Columnar f Text<br/>  , _articlePublishedTime :: Columnar f Int64 -- Unix Epoch<br/>  } deriving (Generic)</span></pre><p id="4b4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在这个和我们之前的模式有一些小的不同。首先，我们将主键作为我们类型的显式字段。对于持久化，我们使用<code class="eh lu lv lw lk b">Entity</code>抽象将其分离。我们将在下面看到如何处理不知道密钥的情况。第二个区别是(目前)，我们在文章中省略了<code class="eh lu lv lw lk b">userId</code>字段。我们将在处理主键时添加这一点。</p><h1 id="820e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">圆柱的</h1><p id="2db8" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">那么这个<code class="eh lu lv lw lk b">Columnar</code>到底是关于什么的呢？在大多数情况下，我们希望用原始字段类型指定一个<code class="eh lu lv lw lk b">User</code>。但是在某些情况下，我们不得不对SQL表达式使用更复杂的类型。我们先从简单的案例开始。</p><p id="a6f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，<code class="eh lu lv lw lk b">Columnar</code>的工作方式是，如果我们使用<code class="eh lu lv lw lk b">Identity</code>来表示<code class="eh lu lv lw lk b">f</code>，我们可以使用原始类型来填充字段值。我们将专门为这种身份情况创建一个类型同义词。然后我们可以举一些例子:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="c469" class="lo kd hu lk b fv lp lq l lr ls">type User = UserT Identity<br/>type Article = ArticleT Identity</span><span id="88ce" class="lo kd hu lk b fv lt lq l lr ls">user1 :: User<br/>user1 = User 1 "James" "james@example.com" 25 "programmer"</span><span id="1fcb" class="lo kd hu lk b fv lt lq l lr ls">user2 :: User<br/>user2 = User 2 "Katie" "katie@example.com " 25 "engineer"</span><span id="a365" class="lo kd hu lk b fv lt lq l lr ls">users :: [User]<br/>users = [ user1, user2 ]</span></pre><p id="cb28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，如果你觉得重复<code class="eh lu lv lw lk b">Columnar</code>关键字很麻烦，你可以把它缩短为<code class="eh lu lv lw lk b">C</code>:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="3854" class="lo kd hu lk b fv lp lq l lr ls">data UserT f =<br/>  { _userId :: C f Int64<br/>  , _userName :: C f Text<br/>  , _userEmail :: C f Text<br/>  , _userAge :: C f Int<br/>  , _userOccupation :: C f Text<br/>  } deriving (Generic)</span></pre><p id="62dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们的初始示例将为所有字段分配原始值。因此，除了<code class="eh lu lv lw lk b">Identity</code>之外，我们最初不需要为<code class="eh lu lv lw lk b">f</code>参数使用任何东西。再往下，我们将处理自动递增主键的情况。在这种情况下，我们将使用<code class="eh lu lv lw lk b">default_</code>函数，它的类型实际上是一个SQL表达式的束形式。在这种情况下，我们将为<code class="eh lu lv lw lk b">f</code>使用不同的类型，但是灵活性将允许我们继续使用我们的<code class="eh lu lv lw lk b">User</code>构造函数！</p><h1 id="159d" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">我们类型的实例</h1><p id="858d" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">现在我们已经指定了我们的类型，我们可以使用<code class="eh lu lv lw lk b">Beamable</code>和<code class="eh lu lv lw lk b">Table</code>类型类告诉Beam更多关于我们的类型的信息。在我们将这些类型中的任何一个设为<code class="eh lu lv lw lk b">Table</code>之前，我们需要指定它的主键类型。所以让我们再做几个类型同义词来表示这些:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="235e" class="lo kd hu lk b fv lp lq l lr ls">type UserId = PrimaryKey UserT Identity<br/>type ArticleId = PrimaryKey ArticleT Identity</span></pre><p id="6e7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们将外键添加到我们的<code class="eh lu lv lw lk b">Article</code>类型中:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="bbd8" class="lo kd hu lk b fv lp lq l lr ls">data ArticleT f =<br/>  { _articleId :: Columnar f Int64<br/>  , _articleTitle :: Columnar f Text<br/>  , _articleBody :: Columnar f Text<br/>  , _articlePublishedTime :: Columnar f Int64<br/>  , _articleUserId :: PrimaryKey UserT f<br/>  } deriving (Generic)</span></pre><p id="3dcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在可以在主类型和主键类型上为<code class="eh lu lv lw lk b">Beamable</code>生成实例。我们还将派生出<code class="eh lu lv lw lk b">Show</code>和<code class="eh lu lv lw lk b">Eq</code>的实例:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="8398" class="lo kd hu lk b fv lp lq l lr ls">data UserT f =<br/>  …</span><span id="b613" class="lo kd hu lk b fv lt lq l lr ls">deriving instance Show User<br/>deriving instance Eq User</span><span id="bc81" class="lo kd hu lk b fv lt lq l lr ls">instance Beamable UserT<br/>instance Beamable (PrimaryKey UserT)</span><span id="a912" class="lo kd hu lk b fv lt lq l lr ls">data ArticleT f =<br/>  …</span><span id="11d6" class="lo kd hu lk b fv lt lq l lr ls">deriving instance Show Article<br/>deriving instance Eq Article</span><span id="80c9" class="lo kd hu lk b fv lt lq l lr ls">instance Beamable ArticleT<br/>instance Beamable (PrimaryKey ArticleT)</span></pre><p id="1f80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们将为<code class="eh lu lv lw lk b">Table</code>类创建一个实例。这将涉及一些类型族语法。我们将指定<code class="eh lu lv lw lk b">UserId</code>和<code class="eh lu lv lw lk b">ArticleId</code>作为我们的主键数据类型。然后我们可以填充<code class="eh lu lv lw lk b">primaryKey</code>函数来匹配正确的字段。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="537e" class="lo kd hu lk b fv lp lq l lr ls">instance Table UserT where<br/>  data PrimaryKey UserT f = UserId (Columnar f Int64) deriving Generic<br/>  primaryKey = UserId . _userId</span><span id="68c0" class="lo kd hu lk b fv lt lq l lr ls">instance Table ArticleT where<br/>  data PrimaryKey ArticleT f = ArticleId (Columnar f Int64) deriving Generic<br/>  primaryKey = ArticleId . _articleId</span></pre><h1 id="75ad" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">存取透镜</h1><p id="0ac5" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我们将再做一件事来模仿持久性。模板Haskell自动为我们生成镜片。我们可以在进行数据库查询时使用它们。下面，我们将使用类似的东西。但是我们将使用一个特殊的函数<code class="eh lu lv lw lk b">tableLenses</code>，来制作这些而不是模板Haskell。如果你还记得我们如何使用<a class="ae ka" href="https://hackage.haskell.org/package/servant-client" rel="noopener ugc nofollow" target="_blank"> Servant Client </a>库，我们可以通过使用<code class="eh lu lv lw lk b">client</code>并将其与模式匹配来创建客户端函数。我们将对<code class="eh lu lv lw lk b">tableLenses</code>做一些类似的事情。我们将在表的每个字段上使用<code class="eh lu lv lw lk b">LensFor</code>,并创建一个构造项目的模式。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0835" class="lo kd hu lk b fv lp lq l lr ls">User<br/>  (LensFor userId)<br/>  (LensFor userName)<br/>  (LensFor userEmail)<br/>  (LensFor userAge)<br/>  (LensFor userOccupation) = tableLenses</span><span id="dc82" class="lo kd hu lk b fv lt lq l lr ls">Article<br/>  (LensFor articleId)<br/>  (LensFor articleTitle)<br/>  (LensFor articleBody)<br/>  (LensFor articlePublishedTime)<br/>  (UserId (LensFor articuleUserId)) = tableLenses</span></pre><p id="2f13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意我们必须在<code class="eh lu lv lw lk b">UserId</code>中包装外键镜头。</p><h1 id="86ca" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">创建我们的数据库</h1><p id="1c3f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">与Persistent不同，我们将创建一个额外的类型来表示我们的数据库。我们的两个表在这个数据库中都有一个字段:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="3c12" class="lo kd hu lk b fv lp lq l lr ls">data BlogDB f = BlogDB<br/>  { _blogUsers :: f (TableEntity UserT)<br/>  , _blogArticles :: f (TableEntity ArticleT)<br/>  } deriving (Generic)</span></pre><p id="d7fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要让我们的数据库类型成为<code class="eh lu lv lw lk b">Database</code>类的一个实例。我们还将指定一组可以在数据库中使用的默认设置。这两项都将涉及一个参数<code class="eh lu lv lw lk b">be</code>，它代表后端(例如SQLite、Postgres)。我们暂时保留这个通用参数。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="a35b" class="lo kd hu lk b fv lp lq l lr ls">instance Database be BlogDB</span><span id="3eb6" class="lo kd hu lk b fv lt lq l lr ls">blogDb :: DatabaseSettings be BlogDB<br/>blogDb = defaultDbSettings</span></pre><h1 id="f6c6" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">插入我们的数据库</h1><p id="35df" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">现在，用Beam迁移我们的数据库比用Persistent稍微复杂一些。我们可能会在以后的文章中讨论这个问题。现在，我们将保持简单，使用SQLite数据库并自己迁移它。因此，让我们首先创建我们的表。在这里，我们必须遵循Beam的约定，特别是在外键的<code class="eh lu lv lw lk b">user_id__id</code>字段上:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="294e" class="lo kd hu lk b fv lp lq l lr ls">CREATE TABLE users \<br/>  ( id INTEGER PRIMARY KEY AUTOINCREMENT\<br/>  , name VARCHAR NOT NULL \<br/>  , email VARCHAR NOT NULL \<br/>  , age INTEGER NOT NULL \<br/>  , occupation VARCHAR NOT NULL \<br/>  );<br/>CREATE TABLE articles \<br/>  ( id INTEGER PRIMARY KEY AUTOINCREMENT \<br/>  , title VARCHAR NOT NULL \<br/>  , body VARCHAR NOT NULL \<br/>  , published_time INTEGER NOT NULL \<br/>  , user_id__id INTEGER NOT NULL \<br/>  );</span></pre><p id="e21c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们想写几个可以与数据库交互的查询。让我们从插入原始用户开始。我们首先打开一个SQLite连接，我们将编写一个使用该连接的函数:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="631d" class="lo kd hu lk b fv lp lq l lr ls">import Database.SQLite.Simple (open, Connection)</span><span id="188d" class="lo kd hu lk b fv lt lq l lr ls">main :: IO ()<br/>main = do<br/>  conn &lt;- open "blogdb1.db"<br/>  insertUsers conn</span><span id="2559" class="lo kd hu lk b fv lt lq l lr ls">insertUsers :: Connection -&gt; IO ()<br/>insertUsers = ...</span></pre><p id="5270" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们通过使用<code class="eh lu lv lw lk b">runBeamSqlite</code>并传递连接来开始我们的表达式。然后，我们使用<code class="eh lu lv lw lk b">runInsert</code>向Beam指定我们希望做一个insert语句。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="d681" class="lo kd hu lk b fv lp lq l lr ls">import Database.Beam<br/>import Database.Beam.SQLite</span><span id="1821" class="lo kd hu lk b fv lt lq l lr ls">insertUsers :: Connection -&gt; IO ()<br/>insertUsers conn = runBeamSqlite conn $ runInsert $<br/>  ...</span></pre><p id="4800" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们将使用<code class="eh lu lv lw lk b">insert</code>函数，并发出信号通知我们希望从数据库中删除哪一个表:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="a969" class="lo kd hu lk b fv lp lq l lr ls">insertUsers :: Connection -&gt; IO ()<br/>insertUsers conn = runBeamSqlite conn $ runInsert $<br/>  insert (_blogUsers blogDb) $ ...</span></pre><p id="1bd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，由于我们正在插入原始值(<code class="eh lu lv lw lk b">UserT Identity</code>，我们使用<code class="eh lu lv lw lk b">insertValues</code>函数来完成这个调用:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="3a83" class="lo kd hu lk b fv lp lq l lr ls">insertUsers :: Connection -&gt; IO ()<br/>insertUsers conn = runBeamSqlite conn $ runInsert $<br/>  insert (_blogUsers blogDb) $ insertValues users</span></pre><p id="a0d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以检查并验证我们的用户是否存在！</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0c8b" class="lo kd hu lk b fv lp lq l lr ls">SELECT * FROM users;<br/>1|James|james@example.com|25|programmer<br/>2|Katie|katie@example.com|25|engineer</span></pre><p id="ab69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们对文章做同样的事情。我们将使用<code class="eh lu lv lw lk b">pk</code>函数来访问特定<code class="eh lu lv lw lk b">User</code>的主键:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="585c" class="lo kd hu lk b fv lp lq l lr ls">article1 :: Article<br/>article1 = Article 1 "First article" <br/>  "A great article" 1531193221 (pk user1)</span><span id="a9fa" class="lo kd hu lk b fv lt lq l lr ls">article2 :: Article<br/>article2 = Article 2 "Second article" <br/>  "A better article" 1531199221 (pk user2)</span><span id="2185" class="lo kd hu lk b fv lt lq l lr ls">article3 :: Article<br/>article3 = Article 3 "Third article" <br/>  "The best article" 1531200221 (pk user1)</span><span id="ce73" class="lo kd hu lk b fv lt lq l lr ls">articles :: [Article]<br/>articles = [ article1, article2, article3]</span><span id="6777" class="lo kd hu lk b fv lt lq l lr ls">insertArticles :: Connection -&gt; IO ()<br/>insertArticles conn = runBeamSqlite conn $ runInsert $<br/>  insert (_blogArticles blogDb) $ insertValues articles</span></pre><h1 id="b727" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">选择查询</h1><p id="3285" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">现在我们已经插入了一些元素，让我们运行一些基本的select语句。一般来说，对于select，我们需要<code class="eh lu lv lw lk b">runSelectReturningList</code>函数。如果需要，我们还可以查询具有不同功能的单个元素:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="4b9d" class="lo kd hu lk b fv lp lq l lr ls">findUsers :: Connection -&gt; IO ()<br/>findUsers conn = runBeamSqlite conn $ do<br/>  users &lt;- runSelectReturningList $ ...</span></pre><p id="103b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们将使用<code class="eh lu lv lw lk b">select</code>而不是上一个查询中的<code class="eh lu lv lw lk b">insert</code>。我们还将在数据库中的用户字段上使用函数<code class="eh lu lv lw lk b">all_</code>来表示我们想要所有用户。这就是我们所需要的！：</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="8a63" class="lo kd hu lk b fv lp lq l lr ls">findUsers :: Connection -&gt; IO ()<br/>findUsers conn = runBeamSqlite conn $ do<br/>  users &lt;- runSelectReturningList $ select (all_ (_blogUsers blogDb))<br/>  mapM_ (liftIO . putStrLn . show) users</span></pre><p id="4778" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要进行过滤查询，我们将从相同的框架开始。但是现在我们需要将我们的<code class="eh lu lv lw lk b">select</code>语句增强为一元表达式。我们将从从所有用户中选择<code class="eh lu lv lw lk b">user</code>开始:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="d9ff" class="lo kd hu lk b fv lp lq l lr ls">findUsers :: Connection -&gt; IO ()<br/>findUsers conn = runBeamSqlite conn $ do<br/>  users &lt;- runSelectReturningList $ select $ do<br/>   user &lt;- (all_ (_blogUsers blogDb))<br/>    ...<br/>  mapM_ (liftIO . putStrLn . show) users</span></pre><p id="b746" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们现在将通过使用<code class="eh lu lv lw lk b">guard_</code>和应用我们的一个镜头来过滤。我们使用一个<code class="eh lu lv lw lk b">==.</code>操作符来表示等式，就像持久化一样。我们还必须用<code class="eh lu lv lw lk b">val</code>包装我们的原始比较值:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="53d3" class="lo kd hu lk b fv lp lq l lr ls">findUsers :: Connection -&gt; IO ()<br/>findUsers conn = runBeamSqlite conn $ do<br/>  users &lt;- runSelectReturningList $ select $ do<br/>    user &lt;- (all_ (_blogUsers blogDb))<br/>    guard_ (user ^. userName ==. (val_ "James"))<br/>    return user<br/>  mapM_ (liftIO . putStrLn . show) users</span></pre><p id="ad61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我们所需要的！Beam将为我们生成SQL！现在让我们试着做一个连接。这在Beam中实际上比在Persistent/Esqueleto中简单得多。我们所需要的只是在文章的“选择”中添加一些陈述。我们将按用户ID过滤它们！</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1903" class="lo kd hu lk b fv lp lq l lr ls">findUsersAndArticles :: Connection -&gt; IO ()<br/>findUsersAndArticles conn = runBeamSqlite conn $ do<br/>  users &lt;- runSelectReturningList $ select $ do<br/>    user &lt;- (all_ (_blogUsers blogDb))<br/>    guard_ (user ^. userName ==. (val_ "James"))<br/>    articles &lt;- (all_ (_blogArticles blogDb))<br/>    guard_ (article ^. articleUserId ==. user ^. userId)<br/>    return user<br/>  mapM_ (liftIO . putStrLn . show) users</span></pre><p id="e090" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是全部了！</p><h1 id="03a8" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">自动递增主键</h1><p id="8dc0" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在上面的例子中，我们硬编码了所有的id。但是这通常不是您想要的。我们应该让数据库通过某种规则分配ID，在我们的例子中是自动递增的。在这种情况下，我们将创建一个“表达式”，而不是创建一个<code class="eh lu lv lw lk b">User</code>“值”。这可以通过我们类型中的多态参数<code class="eh lu lv lw lk b">f</code>来实现。我们将省略类型签名，因为它有点令人困惑。但是下面是我们要创建的表达式:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="6ca3" class="lo kd hu lk b fv lp lq l lr ls">user1' = User<br/>  default_ <br/>  (val_ "James")<br/>  (val_ "james@example.com")<br/>  (val_ 25)<br/>  (val_ "programmer")</span></pre><p id="a6c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用<code class="eh lu lv lw lk b">default_</code>来表示一个告诉SQL使用默认值的表达式。然后我们用<code class="eh lu lv lw lk b">val_</code>提升我们所有的其他值。最后，我们将在Haskell表达式中使用<code class="eh lu lv lw lk b">insertExpressions</code>而不是<code class="eh lu lv lw lk b">insertValues</code>。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="c88d" class="lo kd hu lk b fv lp lq l lr ls">insertUsers :: Connection -&gt; IO ()<br/>insertUsers conn = runBeamSqlite conn $ runInsert $<br/>  insert (_blogUsers blogDb) $ insertExpressions [ user1' ]</span></pre><p id="fbad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们将有我们的自动递增键！</p><h1 id="f14f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">结论</h1><p id="7b89" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我们对<code class="eh lu lv lw lk b">Beam</code>图书馆的介绍到此结束。正如我们所看到的，Beam是一个很棒的库，它允许您在不使用任何模板Haskell的情况下指定数据库模式。更多细节，请务必查看<a class="ae ka" href="https://tathougies.github.io/beam/" rel="noopener ugc nofollow" target="_blank">文档</a>！</p><p id="9d9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要更深入地了解如何使用Haskell库制作web应用程序，请务必阅读我们的<a class="ae ka" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>。它讲述了一些数据库机制以及创建API和测试。作为一个额外的挑战，尝试重写该系列中的代码以使用Beam而不是Persistent。看看需要修改多少<code class="eh lu lv lw lk b">Servant</code>代码来适应这种情况。</p><p id="29c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更多酷库的例子，请下载我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！您可以查看更多的数据库和API库！</p><h1 id="cd9c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">附录:编译器扩展</h1><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="06cf" class="lo kd hu lk b fv lp lq l lr ls">{-# LANGUAGE DeriveGeneric #-}<br/>{-# LANGUAGE GADTs #-}<br/>{-# LANGUAGE OverloadedStrings #-}<br/>{-# LANGUAGE FlexibleContexts #-}<br/>{-# LANGUAGE FlexibleInstances #-}<br/>{-# LANGUAGE TypeFamilies #-}<br/>{-# LANGUAGE TypeApplications #-}<br/>{-# LANGUAGE StandaloneDeriving #-}<br/>{-# LANGUAGE TypeSynonymInstances #-}<br/>{-# LANGUAGE NoMonoMorphismRestriction #-}</span></pre></div></div>    
</body>
</html>