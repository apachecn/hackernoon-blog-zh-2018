<html>
<head>
<title>Monitoring Laravel’s background queues in realtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实时监控Laravel的后台队列</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/monitoring-laravels-background-queues-in-realtime-629cf3fac5c5?source=collection_archive---------31-----------------------#2018-07-30">https://medium.com/hackernoon/monitoring-laravels-background-queues-in-realtime-629cf3fac5c5?source=collection_archive---------31-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="1d99" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">你需要在你的机器上安装PHP 7或更高版本，Laravel CLI，Composer，Node和npm。你应该对PHP和Laravel有所了解。</p></blockquote><p id="4833" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当构建大型应用程序时，使其具有可伸缩性通常是一个关注点。像页面加载需要多长时间这样的统计数据通常非常重要。因此，像处理大型图像、发送电子邮件和短信这样的事情可以推到后台队列中，稍后再处理。</p><p id="1c7f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">但是，因为队列在后台工作，所以它们有时会失败。然后，可能有必要能够监控后台队列。</p><p id="35c8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在本文中，我们将考虑实时监控Laravel后台队列的方法。我们将假设我们创建了一个发送电子邮件的应用程序。电子邮件将在后台排队，稍后发送。然后，我们将有一个报告页面，显示已发送和未发送的电子邮件。</p><p id="6133" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这是我们将要构建的内容的屏幕记录:</p><figure class="jx jy jz ka fq kb fe ff paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="fe ff jw"><img src="../Images/d9c5fccbf9d5141fe1e5921cf37dee46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O2-C5Jyv7RK3geod.gif"/></div></div></figure><h1 id="8109" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">教程要求</h1><p id="e8cf" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">为了完成本教程，我们需要以下东西:</p><ul class=""><li id="5030" class="ll lm hu ix b iy iz jc jd jt ln ju lo jv lp js lq lr ls lt dt translated">PHP 7.0+安装在你的机器上。</li><li id="464a" class="ll lm hu ix b iy lu jc lv jt lw ju lx jv ly js lq lr ls lt dt translated">安装在您机器上的Laravel CLI 。</li><li id="9958" class="ll lm hu ix b iy lu jc lv jt lw ju lx jv ly js lq lr ls lt dt translated"><a class="ae lz" href="https://getcomposer.org/doc/00-intro.md#installation-linux-unix-osx" rel="noopener ugc nofollow" target="_blank"> Composer </a>安装在您的机器上。</li><li id="95d7" class="ll lm hu ix b iy lu jc lv jt lw ju lx jv ly js lq lr ls lt dt translated">PHP和Laravel的知识。</li><li id="e99a" class="ll lm hu ix b iy lu jc lv jt lw ju lx jv ly js lq lr ls lt dt translated"><a class="ae lz" href="https://docs.npmjs.com/getting-started/installing-node" rel="noopener ugc nofollow" target="_blank"> Node.js和NPM </a>安装在你的机器上。</li><li id="fcbb" class="ll lm hu ix b iy lu jc lv jt lw ju lx jv ly js lq lr ls lt dt translated">Vue.js和JavaScript的基础知识。</li><li id="8328" class="ll lm hu ix b iy lu jc lv jt lw ju lx jv ly js lq lr ls lt dt translated">推送应用程序。在这里创建一个<a class="ae lz" href="https://pusher.com" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="c060" class="ll lm hu ix b iy lu jc lv jt lw ju lx jv ly js lq lr ls lt dt translated">一个邮件陷阱帐户来测试发送的电子邮件。在这里创建一个<a class="ae lz" href="https://mailtrap.io" rel="noopener ugc nofollow" target="_blank"/>。</li></ul><p id="9591" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">一旦你准备好了这些需求，让我们开始吧。</p><h1 id="32d5" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">设置您的Laravel应用程序</h1><p id="b21c" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">打开终端并运行下面的命令来创建一个Laravel应用程序:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="ec4a" class="mf kj hu mb b fv mg mh l mi mj">$ laravel new app_name</span></pre><h1 id="6235" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">设置数据库连接和迁移</h1><p id="c518" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">安装完成后，我们可以继续设置数据库。打开<code class="eh mk ml mm mb b">.env</code>文件并替换以下配置:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="f0ac" class="mf kj hu mb b fv mg mh l mi mj">DB_CONNECTION=mysql<br/>    DB_HOST=127.0.0.1<br/>    DB_PORT=3306<br/>    DB_DATABASE=homestead<br/>    DB_USERNAME=homestead<br/>    DB_PASSWORD=secret</span></pre><p id="4820" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">使用:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="d376" class="mf kj hu mb b fv mg mh l mi mj">DB_CONNECTION=sqlite</span></pre><p id="b7aa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将把SQLite设置为我们的默认数据库连接(您可以使用MySQL或任何其他您想要的数据库连接)。</p><p id="43d0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在终端<code class="eh mk ml mm mb b">cd</code>到你的项目的根目录。运行以下命令创建SQLite数据库文件:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="ad02" class="mf kj hu mb b fv mg mh l mi mj">$ touch database/database.sqlite</span></pre><p id="a075" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面的命令将创建一个空文件，供SQLite使用。运行以下命令创建迁移:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="72b7" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan make:migration create_queued_emails_table</span></pre><p id="5b71" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开上面的命令刚刚创建的迁移文件，用下面的代码替换<code class="eh mk ml mm mb b">up</code>方法:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="cb2d" class="mf kj hu mb b fv mg mh l mi mj">public function up()<br/>    {<br/>        Schema::create('queued_emails', function (Blueprint $table) {<br/>            $table-&gt;increments('id');<br/>            $table-&gt;string('email');<br/>            $table-&gt;string('description');<br/>            $table-&gt;boolean('run')-&gt;default(false);<br/>            $table-&gt;timestamps();<br/>        });<br/>    }</span></pre><p id="2e99" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在运行下面的命令来迁移我们的数据库:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="d641" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan migrate</span></pre><h1 id="bea4" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">为电子邮件测试设置邮件陷阱</h1><p id="0f81" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">打开您的<code class="eh mk ml mm mb b">.env</code>文件，并输入您从邮件陷阱仪表板获得的密钥。下面列出了相关的键:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="f85a" class="mf kj hu mb b fv mg mh l mi mj">MAIL_DRIVER=smtp<br/>    MAIL_HOST=smtp.mailtrap.io<br/>    MAIL_PORT=2525<br/>    MAIL_USERNAME=null<br/>    MAIL_PASSWORD=null<br/>    MAIL_ENCRYPTION=null<br/>    MAIL_FROM="john@doe.com"<br/>    MAIL_NAME="John Doe"</span></pre><p id="df93" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，当电子邮件被发送时，电子邮件将在邮件陷阱收件箱中可见。</p><h1 id="ba1d" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">设置身份验证</h1><p id="218a" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">我们需要做的下一件事是设置身份验证。打开您的终端，输入以下命令:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="2ca2" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan make:auth</span></pre><p id="4175" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将生成一个认证框架。这就是关于身份验证您需要做的全部工作。</p><h1 id="0a14" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">配置推动器</h1><p id="c846" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">将<code class="eh mk ml mm mb b">.env</code>文件中的<code class="eh mk ml mm mb b">PUSHER_*</code>键替换为您从推钢机仪表板上获得的正确键:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="6489" class="mf kj hu mb b fv mg mh l mi mj">PUSHER_APP_ID="PUSHER_APP_ID"<br/>    PUSHER_APP_KEY="PUSHER_APP_KEY"<br/>    PUSHER_APP_SECRET="PUSHER_APP_SECRET"</span></pre><p id="f048" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开终端，输入下面的命令来安装Pusher PHP SDK:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="d3bc" class="mf kj hu mb b fv mg mh l mi mj">$ composer require pusher/pusher-php-server "~3.0"</span></pre><p id="dafd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">安装完成后，打开<code class="eh mk ml mm mb b">config/broadcasting.php</code>文件并滚动到<code class="eh mk ml mm mb b">pusher</code>部分。用以下内容替换<code class="eh mk ml mm mb b">options</code>键:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="7314" class="mf kj hu mb b fv mg mh l mi mj">'options' =&gt; [<br/>        'encrypt' =&gt; true,<br/>        'cluster' =&gt; 'PUSHER_APP_CLUSTER'<br/>    ],</span></pre><h1 id="5262" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">配置其他杂项</h1><p id="45f7" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">打开<code class="eh mk ml mm mb b">.env</code>文件，将<code class="eh mk ml mm mb b">BROADCAST_DRIVER</code>改为<code class="eh mk ml mm mb b">pusher</code>，将<code class="eh mk ml mm mb b">QUEUE_DRIVER</code>改为<code class="eh mk ml mm mb b">database</code>。为了确保我们有使用<code class="eh mk ml mm mb b">database</code>作为我们的<code class="eh mk ml mm mb b">QUEUE_DRIVER</code>所必需的表，运行下面的命令来生成数据库迁移:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="e208" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan queue:table</span></pre><p id="07f3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后运行migrate命令来迁移数据库:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="02a2" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan migrate</span></pre><p id="2381" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将创建将我们的数据库用作队列驱动程序所需的数据库表。</p><blockquote class="ir is it"><p id="9301" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡</em> <strong class="ix hv"> <em class="hu">在生产环境中，最好使用Redis或Memcached这样的内存存储作为队列驱动。内存存储比使用关系数据库更快，因此性能更好。</em> </strong></p></blockquote><h1 id="4a56" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">构建我们应用程序的后端</h1><p id="0e80" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">现在让我们创建应用程序的后端。在您的终端中运行以下命令:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="bdd8" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan make:model QueuedEmails</span></pre><p id="e3ed" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将在<code class="eh mk ml mm mb b">app</code>目录中创建一个新模型。打开文件并用以下内容替换其内容:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="cd59" class="mf kj hu mb b fv mg mh l mi mj">&lt;?php</span><span id="0b3e" class="mf kj hu mb b fv mn mh l mi mj">    namespace App;</span><span id="5419" class="mf kj hu mb b fv mn mh l mi mj">    use Illuminate\Database\Eloquent\Model;</span><span id="7c25" class="mf kj hu mb b fv mn mh l mi mj">    class QueuedEmails extends Model<br/>    {<br/>        protected $fillable = ['description', 'run', 'email'];<br/>        protected $casts = ['run' =&gt; "boolean"];<br/>    }</span></pre><p id="7221" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们定义了类的<code class="eh mk ml mm mb b">fillable</code>属性。这将防止在我们尝试向数据库创建新条目时出现批量分配异常错误。我们还指定了一个<code class="eh mk ml mm mb b">casts</code>属性，它将指示concertive将属性类型化为数据类型。</p><p id="e1f0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，打开<code class="eh mk ml mm mb b">HomeController</code>并使用以下代码替换内容:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="b7e8" class="mf kj hu mb b fv mg mh l mi mj">&lt;?php<br/>    namespace App\Http\Controllers;</span><span id="2553" class="mf kj hu mb b fv mn mh l mi mj">    use Mail;<br/>    use App\QueuedEmails;<br/>    use App\Mail\SimulateMail;<br/>    use Faker\Factory as Faker;</span><span id="16b8" class="mf kj hu mb b fv mn mh l mi mj">    class HomeController extends Controller<br/>    {<br/>        /**<br/>         * Create a new controller instance.<br/>         *<br/>         * @return void<br/>         */<br/>        public function __construct()<br/>        {<br/>            $this-&gt;middleware('auth');</span><span id="e313" class="mf kj hu mb b fv mn mh l mi mj">            $this-&gt;faker = Faker::create();<br/>        }</span><span id="f317" class="mf kj hu mb b fv mn mh l mi mj">        /**<br/>         * Show the application dashboard.<br/>         *<br/>         * @return \Illuminate\Http\Response<br/>         */<br/>        public function index()<br/>        {<br/>            return view('home', ['jobs' =&gt; $this-&gt;jobs()]);<br/>        }</span><span id="ea7c" class="mf kj hu mb b fv mn mh l mi mj">        /**<br/>         * Return all the jobs.<br/>         *<br/>         * @return array<br/>         */<br/>        public function jobs()<br/>        {<br/>            return QueuedEmails::orderBy('created_at', 'DESC')-&gt;get()-&gt;toArray();<br/>        }</span><span id="99a8" class="mf kj hu mb b fv mn mh l mi mj">        /**<br/>         * Simulate sending the email.<br/>         *<br/>         * @return mixed<br/>         */<br/>        public function simulate()<br/>        {<br/>            $email = $this-&gt;faker-&gt;email;</span><span id="8d93" class="mf kj hu mb b fv mn mh l mi mj">            Mail::to($email)-&gt;send(<br/>                new SimulateMail([<br/>                    "email" =&gt; $email,<br/>                    "description" =&gt; $this-&gt;faker-&gt;sentence()<br/>                ])<br/>            );</span><span id="7633" class="mf kj hu mb b fv mn mh l mi mj">            return redirect()-&gt;route('home');<br/>        }<br/>    }</span></pre><p id="855e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的控制器中，我们有4个方法，大部分都是不言自明的。在这个类中，我们使用了<a class="ae lz" href="https://github.com/fzaninotto/Faker" rel="noopener ugc nofollow" target="_blank"> Faker库</a>，它帮助我们生成随机的假值。在<code class="eh mk ml mm mb b">simulate</code>方法中，我们使用faker库来生成一个假的电子邮件地址和描述。我们实例化一个<code class="eh mk ml mm mb b">SimulateMail</code>T21。</p><p id="7e62" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开终端，输入以下命令:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="2d21" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan make:mail SimulateMail</span></pre><p id="68c3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开<code class="eh mk ml mm mb b">SimulateMail</code>类，输入下面的代码:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="b4b3" class="mf kj hu mb b fv mg mh l mi mj">&lt;?php<br/>    namespace App\Mail;</span><span id="64bd" class="mf kj hu mb b fv mn mh l mi mj">    use App\QueuedEmails;<br/>    use Illuminate\Bus\Queueable;<br/>    use Illuminate\Mail\Mailable;<br/>    use Illuminate\Queue\SerializesModels;<br/>    use App\Events\{EmailQueued, EmailSent};<br/>    use Illuminate\Contracts\Queue\ShouldQueue;<br/>    use Illuminate\Contracts\Queue\Factory as Queue;<br/>    use Illuminate\Contracts\Mail\Mailer as MailerContract;</span><span id="4245" class="mf kj hu mb b fv mn mh l mi mj">    class SimulateMail extends Mailable implements ShouldQueue<br/>    {<br/>        use Queueable, SerializesModels;</span><span id="d363" class="mf kj hu mb b fv mn mh l mi mj">        protected $mail;</span><span id="bc77" class="mf kj hu mb b fv mn mh l mi mj">        /**<br/>         * Create a new message instance.<br/>         *<br/>         * @return void<br/>         */<br/>        public function __construct(array $mail)<br/>        {<br/>            $this-&gt;mail = QueuedEmails::create($mail);<br/>        }</span><span id="e821" class="mf kj hu mb b fv mn mh l mi mj">        /**<br/>         * Build the message.<br/>         *<br/>         * @return $this<br/>         */<br/>        public function build()<br/>        {<br/>            return $this-&gt;subject("Queuer: Welcome to queuer")-&gt;view('email.welcome');<br/>        }</span><span id="15c9" class="mf kj hu mb b fv mn mh l mi mj">        /**<br/>         * Send the mail<br/>         */<br/>        public function send(MailerContract $mailer)<br/>        {<br/>            $this-&gt;mail-&gt;update(['run' =&gt; true]);</span><span id="eee4" class="mf kj hu mb b fv mn mh l mi mj">            event(new EmailSent($this-&gt;mail));</span><span id="130a" class="mf kj hu mb b fv mn mh l mi mj">            parent::send($mailer);<br/>        }</span><span id="456b" class="mf kj hu mb b fv mn mh l mi mj">        /**<br/>         * Queue the email<br/>         */<br/>        public function queue(Queue $queue)<br/>        {<br/>            event(new EmailQueued($this-&gt;mail));</span><span id="cf15" class="mf kj hu mb b fv mn mh l mi mj">            return parent::queue($queue);<br/>        }<br/>    }</span></pre><blockquote class="ir is it"><p id="b9a7" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡</em> <strong class="ix hv"> <em class="hu">通过实现</em> </strong> <code class="eh mk ml mm mb b"><strong class="ix hv"><em class="hu">ShouldQueue</em></strong></code> <strong class="ix hv"> <em class="hu">接口，我们告诉Laravel，邮件应该排队，而不是立即发送。</em> </strong></p></blockquote><p id="7350" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的类中，我们有一个构造函数在<code class="eh mk ml mm mb b">queued_emails</code>表中创建了一个新条目。在<code class="eh mk ml mm mb b">build</code>方法中，我们构建将要发送的邮件消息。</p><p id="e8ca" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mk ml mm mb b">send</code>方法中，我们将<code class="eh mk ml mm mb b">queued_emails</code>条目的<code class="eh mk ml mm mb b">run</code>列标记为<code class="eh mk ml mm mb b">true</code>。我们还触发了一个名为<code class="eh mk ml mm mb b">EmailSent</code>的事件。在<code class="eh mk ml mm mb b">queue</code>方法中，我们还触发了一个名为<code class="eh mk ml mm mb b">EmailQueued</code>的事件。</p><p id="f7ad" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们创建在上述方法中触发的事件。在您的终端中运行以下命令:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="172d" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan make:event EmailSent<br/>    $ php artisan make:event EmailQueued</span></pre><p id="2923" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mk ml mm mb b">EmailSent</code>事件类中，粘贴以下代码:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="79a9" class="mf kj hu mb b fv mg mh l mi mj">&lt;?php<br/>    namespace App\Events;</span><span id="ecc3" class="mf kj hu mb b fv mn mh l mi mj">    use App\QueuedEmails;<br/>    use Illuminate\Broadcasting\Channel;<br/>    use Illuminate\Queue\SerializesModels;<br/>    use Illuminate\Foundation\Events\Dispatchable;<br/>    use Illuminate\Broadcasting\InteractsWithSockets;<br/>    use Illuminate\Contracts\Broadcasting\ShouldBroadcast;</span><span id="21ae" class="mf kj hu mb b fv mn mh l mi mj">    class EmailSent implements ShouldBroadcast<br/>    {<br/>        use Dispatchable, InteractsWithSockets, SerializesModels;</span><span id="38d1" class="mf kj hu mb b fv mn mh l mi mj">        public $mail;</span><span id="cb77" class="mf kj hu mb b fv mn mh l mi mj">        public function __construct($mail)<br/>        {<br/>            $this-&gt;mail = $mail;<br/>        }</span><span id="f8a6" class="mf kj hu mb b fv mn mh l mi mj">        public function broadcastOn()<br/>        {<br/>            return new Channel('email-queue');<br/>        }</span><span id="9eab" class="mf kj hu mb b fv mn mh l mi mj">        public function broadcastAs()<br/>        {<br/>            return 'sent';<br/>        }<br/>    }</span></pre><p id="158c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们只是使用Laravel中的<a class="ae lz" href="https://laravel.com/docs/5.5/broadcasting#defining-broadcast-events" rel="noopener ugc nofollow" target="_blank">广播</a>向Pusher发送一些数据。</p><p id="2e11" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开<code class="eh mk ml mm mb b">EmailQueued</code>事件类并粘贴以下代码:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="2856" class="mf kj hu mb b fv mg mh l mi mj">&lt;?php</span><span id="072c" class="mf kj hu mb b fv mn mh l mi mj">    namespace App\Events;</span><span id="b422" class="mf kj hu mb b fv mn mh l mi mj">    use App\QueuedEmails;<br/>    use Illuminate\Broadcasting\Channel;<br/>    use Illuminate\Queue\SerializesModels;<br/>    use Illuminate\Foundation\Events\Dispatchable;<br/>    use Illuminate\Broadcasting\InteractsWithSockets;<br/>    use Illuminate\Contracts\Broadcasting\ShouldBroadcast;</span><span id="2c95" class="mf kj hu mb b fv mn mh l mi mj">    class EmailQueued implements ShouldBroadcast<br/>    {<br/>        use Dispatchable, InteractsWithSockets, SerializesModels;</span><span id="0626" class="mf kj hu mb b fv mn mh l mi mj">        public $mail;</span><span id="05a7" class="mf kj hu mb b fv mn mh l mi mj">        public function __construct($mail)<br/>        {<br/>            $this-&gt;mail = $mail;<br/>        }</span><span id="b4ab" class="mf kj hu mb b fv mn mh l mi mj">        public function broadcastOn()<br/>        {<br/>            return new Channel('email-queue');<br/>        }</span><span id="bdab" class="mf kj hu mb b fv mn mh l mi mj">        public function broadcastAs()<br/>        {<br/>            return 'add';<br/>        }<br/>    }</span></pre><p id="f8c3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这个类和<code class="eh mk ml mm mb b">EmailSent</code>事件类几乎一样。略微不同的是<code class="eh mk ml mm mb b">broadcastAs</code>方法。它返回一个不同的别名来广播事件。</p><p id="92c0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，打开路由文件<code class="eh mk ml mm mb b">routes/web.php</code>并用以下代码替换:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="8dbe" class="mf kj hu mb b fv mg mh l mi mj">Auth::routes();<br/>    Route::name('jobs')-&gt;get('/jobs', 'HomeController@jobs');<br/>    Route::name('simulate')-&gt;get('/simulate', 'HomeController@simulate');<br/>    Route::name('home')-&gt;get('/home', 'HomeController@index');<br/>    Route::view('/', 'welcome');</span></pre><p id="5d56" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">太好了！现在让我们转到应用程序的前端。</p><h1 id="aa3f" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">构建我们应用程序的前端</h1><p id="28de" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">既然我们已经设置了大部分后端，我们将创建应用程序的前端。打开<code class="eh mk ml mm mb b">resources/views/home.blade.php</code>文件，将代码替换为以下内容:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="49cd" class="mf kj hu mb b fv mg mh l mi mj">@extends('layouts.app')</span><span id="6a75" class="mf kj hu mb b fv mn mh l mi mj">    @section('content')<br/>    &lt;div class="container"&gt;<br/>        &lt;div class="row"&gt;<br/>            &lt;div class="col-md-12"&gt;<br/>                &lt;div class="panel panel-default"&gt;<br/>                    &lt;div class="panel-heading clearfix"&gt;<br/>                        &lt;span class="pull-left"&gt;Queue Reports&lt;/span&gt;<br/>                        &lt;a href="{{ route('simulate') }}" class="btn btn-sm btn-primary pull-right"&gt;Simulate&lt;/a&gt;<br/>                    &lt;/div&gt;<br/>                    &lt;div class="panel-body"&gt;<br/>                        &lt;jobs :jobs='@json($jobs)'&gt;&lt;/jobs&gt;&lt;/jobs&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    @endsection</span></pre><p id="5eb2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面代码中值得注意的一点是<code class="eh mk ml mm mb b">jobs</code>标签。这是对我们接下来将创建的Vue组件的引用。我们还有一个“模拟”按钮，可以引导到一条<code class="eh mk ml mm mb b">/simulate</code>路线。此路由模拟对要发送的电子邮件进行排队。</p><p id="ea01" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开您的终端，键入以下命令:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="112a" class="mf kj hu mb b fv mg mh l mi mj">$ npm install --save laravel-echo pusher-js</span></pre><p id="c505" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将安装<a class="ae lz" href="https://laravel.com/docs/5.5/broadcasting#installing-laravel-echo" rel="noopener ugc nofollow" target="_blank"> Laravel Echo </a>和<a class="ae lz" href="https://github.com/pusher/pusher-js" rel="noopener ugc nofollow" target="_blank"> Pusher JS SDK </a>。安装完成后，运行以下命令安装其他NPM依赖项:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="543d" class="mf kj hu mb b fv mg mh l mi mj">$ npm install</span></pre><h1 id="5fe6" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">构建我们的Vue组件</h1><p id="2369" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">让我们构建前面提到的<code class="eh mk ml mm mb b">jobs</code> Vue组件。打开<code class="eh mk ml mm mb b">resources/assets/js/app.js</code>文件，替换下面的代码:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="c9db" class="mf kj hu mb b fv mg mh l mi mj">Vue.component('example', require('./components/ExampleComponent.vue'));</span></pre><p id="d2a3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">使用:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="5c32" class="mf kj hu mb b fv mg mh l mi mj">Vue.component('jobs', require('./components/JobsComponent.vue'));</span></pre><p id="3948" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在在<code class="eh mk ml mm mb b">resources/assets/js/components/</code>目录下创建一个新的<code class="eh mk ml mm mb b">JobsComponent.vue</code>文件。在文件中，粘贴以下代码:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="2a1b" class="mf kj hu mb b fv mg mh l mi mj">&lt;template&gt;<br/>        &lt;table class="table"&gt;<br/>            &lt;tbody&gt;<br/>                &lt;tr v-for="(job, index) in allJobs" :key="index" v-bind:class="{success: job.run, danger: !job.run}"&gt;<br/>                    &lt;td width="80%"&gt;{{ job.description }}&lt;/td&gt;<br/>                    &lt;td&gt;{{ job.created_at }}&lt;/td&gt;<br/>                &lt;/tr&gt;<br/>            &lt;/tbody&gt;<br/>        &lt;/table&gt;<br/>    &lt;/template&gt;</span><span id="ba06" class="mf kj hu mb b fv mn mh l mi mj">    &lt;script&gt;<br/>    export default {<br/>        props: ['jobs'],<br/>        data() {<br/>            return {allJobs: this.jobs}<br/>        },<br/>        created() {<br/>            let vm = this<br/>            vm.refreshAllJobs = (e) =&gt; axios.get('/jobs').then((e) =&gt; (vm.allJobs = e.data))<br/>            Echo.channel('email-queue')<br/>                .listen('.add', (e)  =&gt; vm.refreshAllJobs(e))<br/>                .listen('.sent', (e) =&gt; vm.refreshAllJobs(e))<br/>        }<br/>    }<br/>    &lt;/script&gt;</span></pre><p id="ad7f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的Vue组件中，我们定义了一个<code class="eh mk ml mm mb b">template</code>。在那里，我们遍历<code class="eh mk ml mm mb b">jobs</code>数组，列出每个作业的描述和时间戳。</p><p id="8472" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在Vue组件<code class="eh mk ml mm mb b">script</code>的<code class="eh mk ml mm mb b">created</code>方法中，我们有一个<code class="eh mk ml mm mb b">refreshAllJobs</code>函数，它使用<a class="ae lz" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>(一个默认内置Laravel的HTTP请求库)向<code class="eh mk ml mm mb b">/jobs</code>路由发出请求。然后，我们将响应分配给<code class="eh mk ml mm mb b">allJobs</code>属性。</p><p id="e9c0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">同样的方法，我们使用<a class="ae lz" href="https://laravel.com/docs/5.5/broadcasting#installing-laravel-echo" rel="noopener ugc nofollow" target="_blank"> Laravel Echo </a>监听Pusher通道并等待事件被触发。每当事件<code class="eh mk ml mm mb b">.add</code>和<code class="eh mk ml mm mb b">.sent</code>被触发时，我们调用<code class="eh mk ml mm mb b">refreshAllJobs</code>方法。</p><blockquote class="ir is it"><p id="72af" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡</em> <strong class="ix hv"> <em class="hu">事件名称前面有一个点是因为，在Laravel中，每当你使用</em> </strong> <code class="eh mk ml mm mb b"><strong class="ix hv"><em class="hu">broadcastAs</em></strong></code> <strong class="ix hv"> <em class="hu">方法定义一个别名时你都需要加上这个点。如果没有点，你的事件将不会被听众捕捉到。如果不提供别名，Laravel将使用namespace + class作为广播事件的名称。</em> </strong></p></blockquote><p id="0691" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开<code class="eh mk ml mm mb b">resources/assets/js/bootstrap.js</code>文件。在文件底部，添加以下代码:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="16e4" class="mf kj hu mb b fv mg mh l mi mj">import Echo from 'laravel-echo'</span><span id="a838" class="mf kj hu mb b fv mn mh l mi mj">    window.Pusher = require('pusher-js');</span><span id="a9ad" class="mf kj hu mb b fv mn mh l mi mj">    window.Echo = new Echo({<br/>        broadcaster: 'pusher',<br/>        key: 'PUSHER_APP_KEY',<br/>        encrypt: true,<br/>        cluster: 'PUSHER_APP_CLUSTER'<br/>    });</span></pre><blockquote class="ir is it"><p id="87fd" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> ⚠️ </em> <strong class="ix hv"> <em class="hu">确保用您的Pusher应用密钥和集群替换</em> </strong> <code class="eh mk ml mm mb b"><strong class="ix hv"><em class="hu">PUSHER_APP_KEY</em></strong></code> <strong class="ix hv"> <em class="hu">和</em> </strong> <code class="eh mk ml mm mb b"><strong class="ix hv"><em class="hu">PUSHER_APP_CLUSTER</em></strong></code> <strong class="ix hv"> <em class="hu">。</em> </strong></p></blockquote><p id="daa9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，运行下面的命令来构建您的资产:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="fb51" class="mf kj hu mb b fv mg mh l mi mj">$ npm run dev</span></pre><h1 id="798d" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">测试我们的应用</h1><p id="f224" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">构建完成后，如果还没有启动PHP服务器，请通过运行以下命令启动它:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="87fb" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan serve</span></pre><p id="95c2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将创建一个PHP服务器，这样我们就可以预览我们的应用程序。终端上会提供URL，但默认为<a class="ae lz" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8000 </a>。</p><p id="a74b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当您看到Laravel主页时，使用页面右上角的“注册”链接创建一个新帐户。现在，单击“模拟”按钮，您应该会看到一个新的排队电子邮件条目。</p><p id="b807" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，我们将使用<code class="eh mk ml mm mb b">queue:listen</code> artisan命令手动执行队列中的流程。打开新的终端窗口并运行以下命令:</p><pre class="jx jy jz ka fq ma mb mc md aw me dt"><span id="8383" class="mf kj hu mb b fv mg mh l mi mj">$ php artisan queue:listen</span></pre><p id="dbec" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这应该开始执行它看到的任何队列。只要终端是打开的并且<code class="eh mk ml mm mb b">queue:listen</code>命令正在运行，当你点击“模拟”按钮时，队列将立即运行。如果您取消了<code class="eh mk ml mm mb b">queue:listen</code>命令，队列条目将保留在那里，不会被触发。</p><blockquote class="ir is it"><p id="e6dd" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">💡</em> <strong class="ix hv"> <em class="hu">在生产环境中，您无法保持</em> </strong> <code class="eh mk ml mm mb b"><strong class="ix hv"><em class="hu">queue:listen</em></strong></code> <strong class="ix hv"> <em class="hu">运行，您可能需要一个工作进程在后台运行；类似</em> </strong> <a class="ae lz" href="http://supervisord.org/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv"> <em class="hu">的东西主管</em> </strong> </a> <strong class="ix hv"> <em class="hu">。你可以在</em> </strong>  <strong class="ix hv"> <em class="hu">这里阅读更多关于你如何做的</em> </strong> <a class="ae lz" href="https://laravel.com/docs/5.5/queues#running-the-queue-worker" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv"> <em class="hu">。</em> </strong></a></p></blockquote><h1 id="fc1d" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结论</h1><p id="cb49" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">在本文中，我们已经能够使用Pusher和Vue创建一个实时的Laravel队列监视器。拥有可以跟踪和量化的队列会很有用。希望你从这篇文章中有所收获。如果你有任何问题或反馈，欢迎在评论区提问。</p><p id="8d31" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">源代码可以在<a class="ae lz" href="https://github.com/neoighodaro/monitoring-laravel-queues" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="05a3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这篇文章最初发表在<a class="ae lz" href="https://pusher.com/tutorials/monitoring-laravel-background-queues" rel="noopener ugc nofollow" target="_blank"> Pusher上。</a></p></div></div>    
</body>
</html>