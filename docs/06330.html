<html>
<head>
<title>Building a Network Command Line Interface in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建网络命令行界面</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-network-command-line-interface-in-go-fd57b31df3fe?source=collection_archive---------32-----------------------#2018-07-30">https://medium.com/hackernoon/building-a-network-command-line-interface-in-go-fd57b31df3fe?source=collection_archive---------32-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b3dfabd91b8e64dc4993e38caa28af92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSXJUJT9XXMxwm54sIyV5w.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">credit — <a class="ae ih" href="http://www.lighthouseabudhabi.org/global-network/" rel="noopener ugc nofollow" target="_blank">http://www.lighthouseabudhabi.org/global-network/</a></figcaption></figure><div class=""/><p id="c6de" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文中，我们将使用Github上的<code class="eh kf kg kh ki b">urfave/cli</code>包在Go中构建一个非常简单的命令行界面:<a class="ae ih" href="https://github.com/urfave/cli" rel="noopener ugc nofollow" target="_blank">https://github.com/urfave/cli</a>。</p><p id="8750" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近，我在不同的主机提供商之间进行了一两次域名迁移，我认为开发一个工具或程序来查询网站的域名服务器、域名、IP地址等等是一个很酷的想法。</p><p id="2b26" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇特别教程的总体目标是给你一个如何构建你自己的CLI的想法，它可以做各种各样的事情，比如网络监控、图像处理等等。</p><blockquote class="kj kk kl"><p id="228a" class="jh ji km jj b jk jl jm jn jo jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd ke hn dt translated"><em class="ik">本教程的完整代码可以在这里找到:</em><a class="ae ih" href="https://github.com/TutorialEdge/Go/tree/master/go-cli-tutorial" rel="noopener ugc nofollow" target="_blank"><em class="ik">TutorialEdge/Go/Go-CLI-tutorial</em></a></p></blockquote><h1 id="b8ff" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">热门项目</h1><p id="4ac1" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">Golang越来越受欢迎，我们已经看到像Hashicorp这样的大型企业在许多不同的工具和系统中采用了这种语言。出于很好的理由，Go的设计非常适合这些类型的应用程序，并且能够轻松地为所有主要平台交叉编译二进制可执行文件是一个巨大的胜利。</p><h1 id="c9e4" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">入门指南</h1><p id="7612" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">让我们在计算机上创建一个名为<code class="eh kf kg kh ki b">go-cli/</code>的新目录，或者类似的东西。我们将为我们的项目创建一个如下所示的目录结构:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="8c99" class="mb kr ik ki b fv mc md l me mf">go-cli/<br/>- pkg/<br/>- cmd/my-cli/<br/>- vendor/<br/>- README.md<br/>- ...</span></pre><blockquote class="kj kk kl"><p id="9a22" class="jh ji km jj b jk jl jm jn jo jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd ke hn dt translated"><em class="ik">这种结构遵循了Github上广泛接受的</em> <a class="ae ih" href="https://github.com/golang-standards/project-layout" rel="noopener ugc nofollow" target="_blank"> <em class="ik"> Go项目布局</em> </a> <em class="ik">指南。</em></p></blockquote><h1 id="c415" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">进入代码</h1><p id="6e49" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">现在我们已经有了一个基本的项目结构，我们可以开始我们的应用程序了。首先，在新的<code class="eh kf kg kh ki b">cmd/my-cli/</code>目录中，我们需要一个名为<code class="eh kf kg kh ki b">cli.go</code>的新文件。我们将用一个非常简单的<code class="eh kf kg kh ki b">Hello World</code>类型的应用程序来填充它，并将它作为我们发展的基础。</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="b0ce" class="mb kr ik ki b fv mc md l me mf">// cmd/my-cli/cli.go<br/>package main<br/><br/>import (<br/>  "fmt"<br/>)<br/><br/>func main() {<br/>  fmt.Println("Go CLI v0.01")<br/>}</span></pre><p id="a8ee" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们可以通过键入以下命令，尝试从项目的根目录运行该命令:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="ab86" class="mb kr ik ki b fv mc md l me mf">➜ go run cmd/my-cli/cli.go Go CLI v0.01</span></pre><p id="a7cf" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">太好了，我们已经完成了新CLI的构建，现在让我们看看如何添加一些命令并使其变得有用。</p><h1 id="89a7" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">我们的第一个命令</h1><p id="15ad" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">因为我们将使用<code class="eh kf kg kh ki b">urfave/cli</code>包，所以我们需要在本地下载这个包以便使用它，我们可以通过一个简单的<code class="eh kf kg kh ki b">go get</code>命令这样做:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="d69b" class="mb kr ik ki b fv mc md l me mf">$ go get github.com/urfave/cli</span></pre><p id="dc9d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们有了必要的包，让我们更新我们的<code class="eh kf kg kh ki b">cli.go</code>文件来使用这个包，并为我们创建一个新的CLI应用程序:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="ed67" class="mb kr ik ki b fv mc md l me mf">// cmd/my-cli/cli.go<br/>import (<br/>  "log"<br/>  "os"<br/><br/>  "github.com/urfave/cli"<br/>)<br/><br/>func main() {<br/>  err := cli.NewApp().Run(os.Args)<br/>  if err != nil {<br/>    log.Fatal(err)<br/>  }<br/>}</span></pre><p id="0157" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们现在运行时，您会看到它充实了我们的程序响应，并添加了版本、我们如何使用cli以及我们可以使用的各种命令等内容。</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="5ca6" class="mb kr ik ki b fv mc md l me mf">➜  go run cmd/my-cli/cli.go<br/>NAME:<br/>   cli - A new cli application<br/><br/>USAGE:<br/>   cli [global options] command [command options] [arguments...]<br/><br/>VERSION:<br/>   0.0.0<br/><br/>COMMANDS:<br/>     help, h  Shows a list of commands or help for one command<br/><br/>GLOBAL OPTIONS:<br/>   --help, -h     show help<br/>   --version, -v  print the version</span></pre><p id="ea90" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">太棒了，这很快开始看起来像一个更完美的项目，而不仅仅是一个次要的项目！</p><p id="6afb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们现在可以开始添加我们自己的<code class="eh kf kg kh ki b">Commands</code>。这些命令中的每一个都将与我们的一个测试相匹配，所以我们将有一个命令:<code class="eh kf kg kh ki b">ns</code>，当它被触发并被提供了一个<code class="eh kf kg kh ki b">url</code>时，它将关闭并查找那个特定主机的名称服务器。</p><p id="c93c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们最终的命令列表如下所示:</p><ul class=""><li id="837d" class="mg mh ik jj b jk jl jo jp js mi jw mj ka mk ke ml mm mn mo dt translated"><code class="eh kf kg kh ki b">ns</code> -将检索名称服务器</li><li id="906a" class="mg mh ik jj b jk mp jo mq js mr jw ms ka mt ke ml mm mn mo dt translated"><code class="eh kf kg kh ki b">cname</code> -将查找给定主机的CNAME</li><li id="f1b4" class="mg mh ik jj b jk mp jo mq js mr jw ms ka mt ke ml mm mn mo dt translated"><code class="eh kf kg kh ki b">mx</code> -将查找给定主机的邮件交换记录</li><li id="34c2" class="mg mh ik jj b jk mp jo mq js mr jw ms ka mt ke ml mm mn mo dt translated"><code class="eh kf kg kh ki b">ip</code> -将查找给定主机的IP地址。</li></ul><p id="8a85" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">简单明了，让我们从创建第一个命令开始:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="016f" class="mb kr ik ki b fv mc md l me mf">package main<br/><br/>import (<br/>	"fmt"<br/>	"log"<br/>	"net"<br/>	"os"<br/><br/>	"github.com/urfave/cli"<br/>)<br/><br/>func main() {<br/>	app := cli.NewApp()<br/>	app.Name = "Website Lookup CLI"<br/>	app.Usage = "Let's you query IPs, CNAMEs, MX records and Name Servers!"<br/><br/>	// We'll be using the same flag for all our commands<br/>	// so we'll define it up here<br/>	myFlags := []cli.Flag{<br/>		cli.StringFlag{<br/>			Name:  "host",<br/>			Value: "tutorialedge.net",<br/>		},<br/>	}<br/><br/>	// we create our commands<br/>	app.Commands = []cli.Command{<br/>		{<br/>			Name:  "ns",<br/>			Usage: "Looks Up the NameServers for a Particular Host",<br/>			Flags: myFlags,<br/>			// the action, or code that will be executed when<br/>			// we execute our `ns` command<br/>			Action: func(c *cli.Context) error {<br/>				// a simple lookup function<br/>				ns, err := net.LookupNS(c.String("url"))<br/>				if err != nil {<br/>					return err<br/>				}<br/>				// we log the results to our console<br/>				// using a trusty fmt.Println statement<br/>				for i := 0; i &lt; len(ns); i++ {<br/>					fmt.Println(ns[i].Host)<br/>				}<br/>				return nil<br/>			},<br/>		},<br/>	}<br/><br/>	// start our application<br/>	err := app.Run(os.Args)<br/>	if err != nil {<br/>		log.Fatal(err)<br/>	}<br/>}</span></pre><p id="5905" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们可以通过键入以下命令来运行它:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="0006" class="mb kr ik ki b fv mc md l me mf">$ go run cmd/my-cli/cli.go ns --url tutorialedge.net</span></pre><p id="062c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将返回我的站点的名称服务器，并在终端中打印出来。我们还可以运行help命令，该命令将向我们展示如何在CLI中使用我们的新命令。</p><h1 id="841f" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">查找IP地址</h1><p id="7a96" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">在我们的程序中，我们所有的命令定义看起来都很相似，除了我们如何打印结果。<code class="eh kf kg kh ki b">net.LookupIP()</code>函数返回一部分IP地址，因此我们必须迭代这些地址，以便以一种漂亮的方式打印出来:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="cf6e" class="mb kr ik ki b fv mc md l me mf">{<br/>	Name:  "ip",<br/>	Usage: "Looks up the IP addresses for a particular host",<br/>	Flags: myFlags,<br/>	Action: func(c *cli.Context) error {<br/>		ip, err := net.LookupIP(c.String("host"))<br/>		if err != nil {<br/>			fmt.Println(err)<br/>		}<br/>		for i := 0; i &lt; len(ip); i++ {<br/>			fmt.Println(ip[i])<br/>		}<br/>		return nil<br/>	},<br/>},</span></pre><h1 id="7126" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">仰望我们的CNAME</h1><p id="4a10" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">然后我们可以添加我们的<code class="eh kf kg kh ki b">cname</code>命令，该命令将使用<code class="eh kf kg kh ki b">net.LookupCNAME()</code>函数和我们传入的主机，并返回一个CNAME字符串，然后我们可以打印出来:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="4535" class="mb kr ik ki b fv mc md l me mf">{<br/>	Name:  "cname",<br/>	Usage: "Looks up the CNAME for a particular host",<br/>	Flags: myFlags,<br/>	Action: func(c *cli.Context) error {<br/>		cname, err := net.LookupCNAME(c.String("host"))<br/>		if err != nil {<br/>			fmt.Println(err)<br/>		}<br/>		fmt.Println(cname)<br/>		return nil<br/>	},<br/>},</span></pre><h1 id="4c70" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">查找MX记录</h1><p id="96a0" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">最后，我们希望能够查询给定主机的邮件交换记录，我们可以通过使用<code class="eh kf kg kh ki b">net.LookupMX()</code>函数并传入我们的主机来实现。这将返回mx记录的一部分，像我们的IPs一样，我们必须迭代才能打印出来:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="a481" class="mb kr ik ki b fv mc md l me mf">{<br/>	Name:  "mx",<br/>	Usage: "Looks up the MX records for a particular host",<br/>	Flags: myFlags,<br/>	Action: func(c *cli.Context) error {<br/>		mx, err := net.LookupMX(c.String("host"))<br/>		if err != nil {<br/>			fmt.Println(err)<br/>		}<br/>		for i := 0; i &lt; len(mx); i++ {<br/>			fmt.Println(mx[i].Host, mx[i].Pref)<br/>		}<br/>		return nil<br/>	},<br/>},<!-- --> </span></pre><h1 id="ef12" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">构建我们的CLI</h1><p id="bf44" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">既然我们已经有了一个基本的CLI并在运行，是时候构建它了，这样我们就可以在生气时使用它。</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="d6c1" class="mb kr ik ki b fv mc md l me mf">$ go build cmd/my-cli/cli.go</span></pre><p id="7259" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将编译一个<code class="eh kf kg kh ki b">cli</code>可执行文件，我们可以像这样运行它:</p><pre class="lt lu lv lw fq lx ki ly lz aw ma dt"><span id="d5b7" class="mb kr ik ki b fv mc md l me mf">$ ./cli help<br/>NAME:<br/>   Website Lookup CLI - Let's you query IPs, CNAMEs, MX records and Name Servers!<br/><br/>USAGE:<br/>   cli [global options] command [command options] [arguments...]<br/><br/>VERSION:<br/>   0.0.0<br/><br/>COMMANDS:<br/>     ns       Looks Up the NameServers for a Particular Host<br/>     cname    Looks up the CNAME for a particular host<br/>     ip       Looks up the IP addresses for a particular host<br/>     mx       Looks up the MX records for a particular host<br/>     help, h  Shows a list of commands or help for one command<br/><br/>GLOBAL OPTIONS:<br/>   --help, -h     show help<br/>   --version, -v  print the version</span></pre><p id="07e1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如您所见，我们所有的命令都成功地列在了输出的commands部分。</p><h1 id="01a8" class="kq kr ik bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">结论</h1><p id="b873" class="pw-post-body-paragraph jh ji ik jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">因此，在本教程中，我们成功地使用Github的<code class="eh kf kg kh ki b">urface/cli</code>包构建了一个非常简单而有效的CLI。CLI可以针对任何主要的操作系统进行交叉编译，而且它具有生产级命令行界面的所有功能。</p><p id="98b0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢我的文章并希望支持我，那么请随时查看我的YouTube频道:</p><div class="ht hu fm fo hv mu"><a href="https://youtube.com/tutorialedge" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd il fv z el mz eo ep na er et ij dt translated">教学大纲</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">嗨伙计们！欢迎来到我的频道，TutorialEdge！这是我将张贴我所有视频教程的地方…</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">youtube.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ib mu"/></div></div></a></div></div><div class="ab cl nj nk hc nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hn ho hp hq hr"><p id="cb76" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="km">原载于【tutorialedge.net】<a class="ae ih" href="https://tutorialedge.net/golang/building-a-cli-in-go/" rel="noopener ugc nofollow" target="_blank"><em class="km"/></a><em class="km">。</em></em></p><figure class="lt lu lv lw fq hw"><div class="bz el l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>