<html>
<head>
<title>Why CSS Selectors are the most useful Selenium WebDriver locators?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么CSS选择器是最有用的Selenium WebDriver定位器？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-css-selectors-are-the-most-useful-selenium-webdriver-locators-28082be1cd3b?source=collection_archive---------37-----------------------#2018-07-30">https://medium.com/hackernoon/why-css-selectors-are-the-most-useful-selenium-webdriver-locators-28082be1cd3b?source=collection_archive---------37-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="012e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当前端开发人员需要在网页上定位元素时，他们使用CSS选择器！为什么不支持selenium webdriver自动化？</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/d4feee228ce6cebc3a06fa24842825e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wR0Db7EtmodgSOTI.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">image created via carbon.now.sh</figcaption></figure><p id="a147" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Selenium Web驱动程序自动化中使用了各种各样的定位器。当你问“你经常使用的定位器是什么，为什么？”时，CSS选择器排在最后</p><p id="a13d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> XPath </strong>是最适合所有解决方案的解决方案。即使有合适的<code class="eh kf kg kh ki b">id</code>可用，也有使用<code class="eh kf kg kh ki b">XPath</code>的趋势。</p><p id="3054" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，缺乏对CSS选择器的了解也会驱使他们选择其他选项。人们提到，他们能够用其他选择器完成这项工作。很公平，没有造成伤害。</p><h1 id="3edb" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">为什么一定要关注CSS选择器？</h1><p id="d85c" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">回答这个问题。当你想在墙上钉钉子时，你会用砖头、鹅卵石还是锤子？</p><p id="6ebc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">砖和鹅卵石可以做这项工作。但是，<strong class="it hv">锤子</strong>是这项工作的工具。</p><p id="d505" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像这样，有很多方法可以识别HTML文档/DOM中的元素。但是CSS选择器是这项工作的工具。他们有一个浏览器需要遵循的<a class="ae lm" href="https://www.w3.org/TR/selectors-3/" rel="noopener ugc nofollow" target="_blank">规范</a></p><p id="f218" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是一个从事UI自动化的自动化工程师，花时间学习CSS选择器(通读文章的其余部分怎么样？).你将获得更多的好处。</p><p id="43dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我能听到你的问题:“但是，复制XPath太容易了。CSS选择器怎么样？”相信我，在许多浏览器中，选项就在<code class="eh kf kg kh ki b">Copy XPath</code>旁边。你会发现<code class="eh kf kg kh ki b">Copy CSS Selector</code>或<code class="eh kf kg kh ki b">Copy Selector</code>。</p><p id="4b76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你知道为什么吗？因为前端开发人员甚至在测试之前就使用CSS选择器来应用网页的视觉效果和行为。</p><h1 id="2fea" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">为什么发明CSS选择器？</h1><p id="5f8c" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">你有没有想过为什么那些类和id都在那里？你有没有问过任何人，我需要在这些元素中包含一些ID/类，以便我可以对这个UI进行自动化测试？</p><p id="97f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果不是你，那么谁要求这些属性？</p><p id="1e86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个故事可以追溯到样式被添加到HTML文档的时代。这是在UI测试自动化之前。每个浏览器都有自己的文档样式。文档(HTML)作者无法控制他们的文档如何呈现给读者。作者需要一种方法来定位标签和应用样式，以达到他们想要的布局。<a class="ae lm" href="https://www.w3.org/Style/CSS20/history.html" rel="noopener ugc nofollow" target="_blank">hkon Wium Lie</a>提出了现在流行的层叠风格语言。</p><p id="964f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CSS工作组正式指定了针对特定元素的选择器。浏览器开发人员将该规范作为需求，构建支持CSS的浏览器。</p><p id="f012" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像<code class="eh kf kg kh ki b">id</code>和<code class="eh kf kg kh ki b">class</code>这样的属性被作为钩子添加到特定的元素中。它们帮助前端开发人员设计样式并将行为附加到元素上。<strong class="it hv">自动化工程师可以搭载</strong>相同的条款，CSS选择器，来识别元素。</p><h1 id="cc05" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">CSS选择器是如何使用的？</h1><p id="caf3" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">要设计元素的样式，前端开发人员需要首先找到元素，然后应用样式规则。</p><p id="65fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看起来是这样的:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="68e1" class="lr kk hu ki b fv ls lt l lu lv">#logo{ color: white; background: black; }</span></pre><p id="05a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那个CSS片段说，将<code class="eh kf kg kh ki b">color</code>和<code class="eh kf kg kh ki b">background</code>样式应用到任何ID为<code class="eh kf kg kh ki b">logo</code>的元素。通常，ID在任何精心制作的HTML文档中都是唯一的。但是在同一个页面上工作的多个开发人员有可能对不同的元素使用同一个ID。大多数时候，在不知道它已经被使用的情况下。不要担心，他们最终会发现这个错误，但关键是浏览器不会发出警告。当你发现这样的场景时，你应该告诉开发者。</p><p id="36be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想要尝试一下<code class="eh kf kg kh ki b">logo</code>的JavaScript开发人员编写如下代码:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="f615" class="lr kk hu ki b fv ls lt l lu lv">let element=document.querySelector("#logo"); <br/>rotate(element);</span></pre><p id="3528" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要管<code class="eh kf kg kh ki b">rotate</code>的实现，只看第一行。<code class="eh kf kg kh ki b">document.querySelector</code>是一个本地API，可用于在浏览器中选择元素。…它采用CSS选择器语法。</p><p id="f19e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，您可以在<strong class="it hv"> JavascriptExecutor </strong>中使用它。</p><p id="0381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于前端开发人员使用CSS选择器来定位元素(或者样式化它们/修改元素/将行为附加到元素)，UI测试自动化工程师也使用相同的API来定位元素是有意义的。</p><p id="bdf4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">深信不疑？这里是一个由CSS选择器替换的不同选择器的预览。</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="baed" class="lr kk hu ki b fv ls lt l lu lv">Other Selectors          =&gt; By.cssSelector <br/>------------------------ =&gt; -------------- <br/>By.className("register") =&gt; ".register" <br/>By.tagName("table")      =&gt; "table" <br/>By.id("unique_id")       =&gt; "#unique_id" <br/>By.name("login")         =&gt; "[name=login]" <br/>By.xpath("//body/nav")   =&gt; "body &gt; nav" <br/>By.xpath("//body//nav")  =&gt; "body nav"</span></pre><h1 id="d2a6" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">四个选择器</h1><p id="4c60" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">让我们从原始选择器开始。你只需要掌握4种，这是最简单的部分。</p><h2 id="70d8" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">id的散列值<code class="eh kf kg kh ki b">#</code></h2><p id="728a" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">任何具有特定ID的元素都可以使用<code class="eh kf kg kh ki b">By.cssSelector</code>定位，方法是在ID前面加上一个散列<code class="eh kf kg kh ki b">#</code>。</p><p id="7015" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="1274" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector("#logout")</span></pre><p id="aa2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kf kg kh ki b">#logout</code>将帮助您定位ID值为<code class="eh kf kg kh ki b">logout</code>的元素。标签名是什么并不重要。它可能是一个链接或按钮，但<code class="eh kf kg kh ki b">cssSelector</code>找到了它。</p><p id="616f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，ID是唯一的。这是一个公平的假设，通常有一个。假设可能会出错。二十个开发人员在一个非常繁忙的UI上工作，最终可能会将同一个ID放在两个不同的元素上。所以，如果你想把它和一个标签配对，你可以这样做。将标签名称放在ID前面。</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="6cad" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector("a#logout")</span></pre><p id="d8af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个选择器更加具体。它说，<em class="mj">找到一个ID值为</em> <code class="eh kf kg kh ki b"><em class="mj">logout</em></code>的锚标签(一个链接)。</p><h2 id="46c5" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">点<code class="eh kf kg kh ki b">.</code>为类</h2><p id="64e3" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">现在我们知道了如何处理id，通过类名定位元素只会比以前更容易。</p><p id="7f0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您需要在类名前面加一个点<code class="eh kf kg kh ki b">.</code>来查找包含这样一个类的元素。</p><p id="9025" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">过期示例:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="47a0" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector(".btn_red")</span></pre><p id="e908" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将是一个红色按钮(如果开发人员添加了相关的样式)，但我们不要担心这个。该选择器将使用类<code class="eh kf kg kh ki b">btn_red</code>来标识一个元素。如果找到多个元素，则返回第一个元素。</p><p id="2db3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想把标签名和类名结合起来。</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="e9ab" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector("a.btn_red")</span></pre><p id="a752" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很有道理，不是吗？</p><h2 id="375f" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">标签保持不变</h2><p id="8bb6" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">现在，这个更简单。如果您想使用特定元素的标记名来定位它，该怎么办呢？<strong class="it hv">无前缀，无后缀</strong>。只要标签名就可以了。</p><p id="3089" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将为您提供页面上的第一个表格。</p><h2 id="8bce" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated"><code class="eh kf kg kh ki b">[attr]</code>为属性</h2><p id="a590" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">四个中的最后一个选择器。这完全基于元素中的属性。HTML元素倾向于拥有诸如<code class="eh kf kg kh ki b">id</code>、<code class="eh kf kg kh ki b">name</code>、<code class="eh kf kg kh ki b">class</code>、<code class="eh kf kg kh ki b">type</code>、<code class="eh kf kg kh ki b">src</code>、<code class="eh kf kg kh ki b">href</code>、<code class="eh kf kg kh ki b">alt</code>等属性，并且在<code class="eh kf kg kh ki b">data-</code>前缀下还有更多属性。</p><p id="8a21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您知道元素的属性是唯一可识别的，那么所有这些属性都可以用来识别元素。</p><p id="1db0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个例子:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="d849" class="lr kk hu ki b fv ls lt l lu lv">&lt;img src="logo.png" class="top"&gt;</span></pre><p id="39a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">定位器可以是以下任何一种:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="3847" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector("[src]") <br/>By.cssSelector("[src=logo.png]") <br/>By.cssSelector("img[src=logo.png]")<br/>By.cssSelector("img.top[src=logo.png]"</span></pre><ul class=""><li id="56ea" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">第一个标识所有具有<code class="eh kf kg kh ki b">src</code>属性的元素</li><li id="8e80" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">第二个通过具有特定值的<code class="eh kf kg kh ki b">src</code>属性定位</li><li id="131d" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">第三种使用标签名称、属性及其值</li><li id="16b4" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated">第四种使用标签名、类名、属性和特定值</li></ul><p id="bdc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们都有各自不同的特点。最后一个很具体，第一个很笼统。</p><p id="8adf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也可以为属性值指定条件，如<code class="eh kf kg kh ki b">starts with</code>、<code class="eh kf kg kh ki b">ends with</code>或<code class="eh kf kg kh ki b">contains</code>。</p><p id="0197" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几个例子:</p><p id="f9c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先是html:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="0b08" class="lr kk hu ki b fv ls lt l lu lv">&lt;input type="text" class="form_text"&gt;<br/>&lt;input type="email" class="form_email"&gt; <br/>&lt;input type="radio" class="form_radio"&gt;</span></pre><p id="1fc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和一些使用属性的定位器:</p><p id="4fe9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">By.cssSelector描述<code class="eh kf kg kh ki b">"input[type*=form]"</code>输入元素的类型属性中包含文本<code class="eh kf kg kh ki b">form</code>的值<code class="eh kf kg kh ki b">"input[type^=form]"</code>输入元素的类型属性以<code class="eh kf kg kh ki b">form</code>开头<code class="eh kf kg kh ki b">"input[type$=radio]"</code>输入元素的类型属性以<code class="eh kf kg kh ki b">radio</code>结尾</p><h1 id="2653" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">四个组合子</h1><p id="132e" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我们看到了四种不同的选择器，它们构成了CSS选择器家族的基础。我们现在来看看赋予CSS选择器特殊能力的四个组合子。</p><h2 id="7573" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">加<code class="eh kf kg kh ki b">+</code>为相邻兄弟</h2><p id="4a30" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">如果想要选择另一个元素之后的元素，可以使用带有加号的相邻兄弟组合符<code class="eh kf kg kh ki b">+</code>。</p><p id="9021" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们建立一些样本HTML:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="bfbf" class="lr kk hu ki b fv ls lt l lu lv">&lt;div id='profile'&gt; <br/>  &lt;img src='head.png'&gt; <br/>  &lt;h1&gt;Mr.Neo&lt;/h1&gt; <br/>  &lt;p&gt;The one&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="3770" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想要选择紧接在<code class="eh kf kg kh ki b">img</code>标签之后的所有<code class="eh kf kg kh ki b">h1</code>标签，您可以使用以下命令:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="e089" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector('img + h1')</span></pre><p id="eb0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想选择跟在<code class="eh kf kg kh ki b">h1</code>标签后面的所有<code class="eh kf kg kh ki b">p</code>标签，这将有所帮助:</p><p id="e264" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">选择的是最右边的元素。例如，当使用<code class="eh kf kg kh ki b">h1 + p</code>时，选择<code class="eh kf kg kh ki b">p</code>元素。<code class="eh kf kg kh ki b">h1</code>有没有当配角。</p><p id="fda9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，如果您想从前面的HTML片段中选择<code class="eh kf kg kh ki b">img</code>标记，该怎么办？精神食粮。</p><h2 id="a170" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">通用同级的颚化符<code class="eh kf kg kh ki b">~</code></h2><p id="4cc7" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我们看到了plus <code class="eh kf kg kh ki b">+</code>的功能。如果您想检查一个元素是否是另一个元素的兄弟，而不一定是直接兄弟，该怎么办？</p><p id="fc99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是一般的兄弟组合子来拯救的地方。它使用颚化符<code class="eh kf kg kh ki b">~</code>符号来表示一般的兄弟。</p><p id="fc0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们设置一个显示您的姓名和照片的HTML片段:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="2ad4" class="lr kk hu ki b fv ls lt l lu lv">&lt;div&gt; <br/>  &lt;h1&gt; Your name!&lt;/h1&gt; <br/>  &lt;img src='pic1.png'&gt; <br/>  &lt;img src='pic2.png'&gt; <br/>  &lt;img src='pic3.png'&gt; <br/>&lt;/div&gt;</span></pre><p id="485a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想访问所有与<code class="eh kf kg kh ki b">h1</code>标签同级的图像，您可以使用通用同级组合符。如果只有一个<code class="eh kf kg kh ki b">img</code>，你就会得到那个。</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="182d" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector('h1 ~ img')</span></pre><p id="bca0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，<code class="eh kf kg kh ki b">img</code>标签是否紧跟在<code class="eh kf kg kh ki b">h1</code>后面并不重要。重要的是，它们都有相同的父标签，并且<code class="eh kf kg kh ki b">img</code>标签是<code class="eh kf kg kh ki b">h1</code>的兄弟标签。</p><p id="154f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果用<code class="eh kf kg kh ki b">img ~ img</code>呢？你会得到最后两个。去想想。</p><p id="d3d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一句，你最亲爱的<code class="eh kf kg kh ki b">xpath</code>给了你一个通过特殊函数按兄弟获取元素的方法:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="64d1" class="lr kk hu ki b fv ls lt l lu lv">By.xpath("//img/following-sibling::h1")</span></pre><h2 id="741c" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">儿童角码<code class="eh kf kg kh ki b">&gt;</code></h2><p id="5e39" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">兄弟姐妹都很好。但是现在孩子们开始哭了。让我们关注他们。这些也是广泛使用的组合子。您可以使用右尖括号<code class="eh kf kg kh ki b">&gt;</code>符号定位父元素的直接子元素。</p><p id="ff89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以重用一些早期的HTML片段:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="7847" class="lr kk hu ki b fv ls lt l lu lv">&lt;div id='profile'&gt;<br/>  &lt;img src='head.png'&gt;<br/>  &lt;h1&gt;Mr.Neo&lt;/h1&gt;<br/>  &lt;p&gt;The one&lt;/p&gt;</span><span id="534a" class="lr kk hu ki b fv my lt l lu lv">  &lt;div id='crew'&gt;<br/>    &lt;img src='crew1.png'&gt;<br/>    &lt;h2&gt;Mr. Morpheus&lt;/h2&gt;<br/>    &lt;p&gt;The other one&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="d5d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用以下选项可以找到所有三个元素:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="e350" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector('#profile &gt; img')<br/>By.cssSelector('#profile &gt; h1')<br/>By.cssSelector('#profile &gt; p')</span></pre><p id="b197" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些选择器不在<code class="eh kf kg kh ki b">crew</code>部分内定位<code class="eh kf kg kh ki b">img</code>或<code class="eh kf kg kh ki b">p</code>标签。因为他们不是<code class="eh kf kg kh ki b">#profile</code>元素的直系子孙。他们是后代，但不是孩子。</p><h2 id="9492" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">后代的空间</h2><p id="4786" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我们现在来看第四个也是最后一个组合子，后代组合子由一个空格表示。</p><p id="998d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们使用相同的HTML:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="9da4" class="lr kk hu ki b fv ls lt l lu lv">&lt;div id='profile'&gt;<br/>  &lt;img src='head.png'&gt;<br/>  &lt;h1&gt;Mr.Neo&lt;/h1&gt;<br/>  &lt;p&gt;The one&lt;/p&gt;<br/>  <br/>  &lt;div id='crew'&gt; <br/>    &lt;img src='crew1.png'&gt; <br/>    &lt;h2&gt;Mr. Morpheus&lt;/h2&gt; <br/>    &lt;p&gt;The other one&lt;/p&gt; <br/>  &lt;/div&gt; <br/>&lt;/div&gt;</span></pre><p id="158b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事情是这样的:</p><p id="e77e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">定位器描述<code class="eh kf kg kh ki b">#profile img</code>锁定两个<code class="eh kf kg kh ki b">img</code>标签<code class="eh kf kg kh ki b">#profile h1</code>锁定唯一的<code class="eh kf kg kh ki b">h1</code>标签<code class="eh kf kg kh ki b">#profile h2</code>锁定唯一的<code class="eh kf kg kh ki b">h2</code>标签<code class="eh kf kg kh ki b">#profile p</code>锁定两个<code class="eh kf kg kh ki b">p</code>标签</p><p id="b5db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你看到区别了。Descendant combinator选择所有匹配的标签，只要它们是给定的父元素的后代。</p><p id="be96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个小小的空格就有这么多的意义！</p><h1 id="3456" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">24个伪类</h1><p id="3a7d" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">大概有24个伪类可以帮到你。你可以在<a class="ae lm" href="https://www.w3.org/TR/selectors-3/#pseudo-classes" rel="noopener ugc nofollow" target="_blank">的说明书</a>中找到它们。但是，我们会看四个来激起你的兴趣。</p><h2 id="955f" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">:不是</h2><p id="8879" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">这一条是否定你到目前为止所学的一切。没有底片会怎样？假设您想要将一个没有特定类/id/属性的元素作为目标。会来帮助你的。</p><p id="0650" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">HTML:</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="53d7" class="lr kk hu ki b fv ls lt l lu lv">&lt;input type="text" class="required" /&gt;<br/>&lt;input type="text" class="required"/&gt;<br/>&lt;input type="text"&gt;<br/>&lt;input type="radio"&gt;<br/>&lt;input type="email"&gt;</span></pre><p id="a27a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想定位一个非强制的输入框(可以说它没有类<code class="eh kf kg kh ki b">required</code>):</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="a9bf" class="lr kk hu ki b fv ls lt l lu lv">By.cssSelector('input:not(.required)')</span></pre><p id="7905" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想选择所有非<code class="eh kf kg kh ki b">email</code>类型的输入，那么<code class="eh kf kg kh ki b">'input:not([type=email])'</code>也可以。</p><p id="9786" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你也可以把它们链接起来，就像这样:<code class="eh kf kg kh ki b">input:not([type=radio]).not(.required)</code>。这将为您提供所有不是单选按钮并且没有类<code class="eh kf kg kh ki b">required</code>的输入。在这种情况下，那只是一个<code class="eh kf kg kh ki b">text</code>型和另一个<code class="eh kf kg kh ki b">email</code>型输入。</p><h2 id="ddbf" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">:第n个孩子</h2><p id="7f3d" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">这有助于您根据特定元素的位置来定位它。</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="b8ee" class="lr kk hu ki b fv ls lt l lu lv">&lt;div id='profile'&gt; <br/>  &lt;h1&gt;Name&lt;/h1&gt; &lt;img src='pic.png' /&gt; <br/>  &lt;img src='background.png' /&gt; <br/>  &lt;p&gt;Summary...&lt;/p&gt; <br/>  &lt;p&gt;Details...&lt;/p&gt; <br/>  &lt;p&gt;Conclusion...&lt;/p&gt; <br/>&lt;/div&gt;</span></pre><p id="6431" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住前面章节中的子选择器。我们要用它。你怎么说，“给我找个人资料里的第二个孩子”。<code class="eh kf kg kh ki b">#profile &gt; *:nth-child(2)</code>会的。<code class="eh kf kg kh ki b">*</code>表示任何标签，<code class="eh kf kg kh ki b">nth-child</code>根据你给的号码查找特定的孩子。</p><p id="3b64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以使用正确的标签名来代替<code class="eh kf kg kh ki b">*</code>，比如<code class="eh kf kg kh ki b">#profile &gt; img:nth-child(2)</code>。当标记名不匹配时，您需要小心。如果使用不存在的标记名，将不会选择任何元素。例如，<code class="eh kf kg kh ki b">#profile &gt; h1:nth-child(2)</code>返回nothing，因为第二个子标签不是<code class="eh kf kg kh ki b">h1</code>标签。</p><p id="598f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kf kg kh ki b">:nth-child</code>像数字一样接受输入，<code class="eh kf kg kh ki b">odd</code>，<code class="eh kf kg kh ki b">even</code>和<code class="eh kf kg kh ki b">3n+2</code>。你可以从第二个元素开始，每三个元素读一次<code class="eh kf kg kh ki b">3n+2</code>。MDN将其定义为<code class="eh kf kg kh ki b">An+B</code>。这更多地用于样式元素。可能不太适合测试自动化。让我们把它放在那里。</p><p id="eeaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一个是得到一个倒数第二的元素:<strong class="it hv">:n-last-child</strong>。例如，<code class="eh kf kg kh ki b">#profile &gt; *:nth-last-child(1)</code>将给出最后一个子元素，也就是文本为“结论…”的<code class="eh kf kg kh ki b">p</code>标签。该规范将<code class="eh kf kg kh ki b">:last-child</code>作为一个伪类，会给你类似的结果。</p><p id="525f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我让你猜猜第一个孩子会回来。</p><h2 id="0af3" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">:第n种类型</h2><p id="39f0" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">当<code class="eh kf kg kh ki b">nth-child</code>考虑所有孩子时，<code class="eh kf kg kh ki b">nth-of-type</code>只考虑标签类型。让我们使用同一段代码。</p><pre class="jq jr js jt fq ln ki lo lp aw lq dt"><span id="ad92" class="lr kk hu ki b fv ls lt l lu lv">&lt;div id='profile'&gt;<br/>  &lt;h1&gt;Name&lt;/h1&gt;<br/>  &lt;img src='pic.png' /&gt;<br/>  &lt;img src='background.png' /&gt;<br/>  &lt;p&gt;Summary...&lt;/p&gt;<br/>  &lt;p&gt;Details...&lt;/p&gt;<br/>  &lt;p&gt;Conclusion...&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="cf19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经看到，<code class="eh kf kg kh ki b">#profile &gt; img:nth-child(1)</code>将不返回任何内容，因为第一个孩子是<code class="eh kf kg kh ki b">h1</code>，但是<code class="eh kf kg kh ki b">#profile &gt; img:nth-of-type(1)</code>返回第一个图像。该规范还有一个简称为<code class="eh kf kg kh ki b">:first-of-type</code>的东西。</p><p id="545d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你是怎么从下往上数的(逆序)？是的，<strong class="it hv">:n-last-of-type</strong>会来帮你。您还可以使用<strong class="it hv"> :last-of-type </strong>来获取指定类型的最底层子元素。</p><h2 id="08e9" class="lr kk hu bd kl lw lx ly kp lz ma mb kt jc mc md kx jg me mf lb jk mg mh lf mi dt translated">:已禁用</h2><p id="b534" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我们要看的最后一个伪类是<code class="eh kf kg kh ki b">:disabled</code>。当您查找一个被禁用或启用的特定元素时，这很方便。事实上，<a class="ae lm" href="https://www.w3.org/TR/selectors-3/#pseudo-classes" rel="noopener ugc nofollow" target="_blank">规范</a>有类似<code class="eh kf kg kh ki b">:enabled</code>、<code class="eh kf kg kh ki b">:checked</code>等伪类供你使用。</p><h1 id="10cb" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">为Xpath辩护</h1><blockquote class="mz na nb"><p id="f726" class="ir is mj it b iu iv iw ix iy iz ja jb nc jd je jf nd jh ji jj ne jl jm jn jo hn dt translated"><em class="hu">知道CSS选择器然后选择XPath作为解决方案，和不知道CSS选择器选择XPath是不一样的。</em></p></blockquote><p id="21fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一句话，如果你一直在使用<code class="eh kf kg kh ki b">XPath</code>，不要气馁。到现在为止，你应该已经看到它们在本质上非常相似。它们各有利弊。<code class="eh kf kg kh ki b">cssSelectors</code>运行良好，因为它们是浏览器的原生程序。<code class="eh kf kg kh ki b">XPath</code>在某些情况下更具可读性。只要能完成工作就可以了。其中之一使你的代码可读？去吧。比另一个表现好，选择那个。只是不要限制你的选择。</p><p id="1f57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据我的经验，测试自动化工程师开始普遍使用<code class="eh kf kg kh ki b">XPath</code>。因此，本文将为<code class="eh kf kg kh ki b">cssSelectors</code>添加一个配重，以便天平与<code class="eh kf kg kh ki b">XPath</code>保持平衡。事实上，jQuery的创建者John Resig曾经写过这样一个对比，展示xPath 有多强大(几年前)。</p><p id="a667" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">参考</p><ul class=""><li id="1a91" class="mk ml hu it b iu iv iy iz jc mm jg mn jk mo jo mp mq mr ms dt translated">尝试这个晚餐游戏来练习。</li><li id="2b7b" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated"><a class="ae lm" href="https://www.w3.org/TR/selectors-3/" rel="noopener ugc nofollow" target="_blank">官方规格三级</a></li><li id="d4bd" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated"><a class="ae lm" href="https://drafts.csswg.org/selectors-4/" rel="noopener ugc nofollow" target="_blank">正式草案四级</a></li><li id="bc03" class="mk ml hu it b iu mt iy mu jc mv jg mw jk mx jo mp mq mr ms dt translated"><a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors" rel="noopener ugc nofollow" target="_blank">永远友好的MDN参考</a></li></ul><p id="d7b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧！谢谢你的时间。你觉得这有用吗？用你的掌声让我知道。</p></div><div class="ab cl nf ng hc nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hn ho hp hq hr"><p id="da25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mj">原载于</em><a class="ae lm" href="https://www.pineboat.in/post/css-selectors-selenium-webdriver-find-element-xpath-replaced/" rel="noopener ugc nofollow" target="_blank"><em class="mj">www . pine boat . in</em></a><em class="mj">。你应该</em> <a class="ae lm" href="http://eepurl.com/cYynNv" rel="noopener ugc nofollow" target="_blank"> <em class="mj">在这里订阅</em> </a> <em class="mj">，等我写了新的东西会让你知道。如果你是</em> <a class="ae lm" href="https://www.pineboat.in/index.xml" rel="noopener ugc nofollow" target="_blank"> <em class="mj">回到RSS源</em> </a> <em class="mj">，你就有保障了。</em></p></div></div>    
</body>
</html>