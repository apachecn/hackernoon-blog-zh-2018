<html>
<head>
<title>A View Inside TeamCI’s Check Run Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TeamCI检查运行代码的内部视图</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/inside-teamcis-check-code-b12770de57a5?source=collection_archive---------40-----------------------#2018-07-30">https://medium.com/hackernoon/inside-teamcis-check-code-b12770de57a5?source=collection_archive---------40-----------------------#2018-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ce722aaf795db1ef6991e3c0093082af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wHrewC1Dyf2Au_qEqwWcg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/B3l0g6HLxr8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Blake Connally</a> on <a class="ae jg" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7b9f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://teamci.co" rel="noopener ugc nofollow" target="_blank"> TeamCI的</a>核心针对代码运行多个静态分析工具，并向<a class="ae jg" href="https://blog.github.com/2018-05-07-introducing-checks-api/" rel="noopener ugc nofollow" target="_blank"> GitHub检查API </a>报告。团队使用多种语言，这意味着工具用不同的语言编写，以不同的方式发布。TeamCI的check builder必须考虑到多样性，同时足够灵活地采用新的工具和语言。我还希望授权用户改进他们的工具。这就是为什么<a class="ae jg" href="https://github.com/teamci/builder" rel="noopener ugc nofollow" target="_blank">检查生成器</a>是开源的。任何人都可以在GitHub上扔代码，并将其标记为开源，但这并不足以让人们开始攻击。这篇文章通过例子介绍了代码。除此之外，这只是一个有趣的例子，说明你可以通过努力和泼洒Bash(国王万岁)来完成什么。</p><h2 id="e4ba" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">高级设计</h2><p id="4b2a" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我在以前的一篇文章中写过关于建立TeamCI的内容。如果您不熟悉TeamCI的工作方式，这是一个很好的起点。</p><div class="lf lg fm fo lh li"><a rel="noopener follow" target="_blank" href="/wipchat/building-a-faster-mvp-with-github-checks-52f0a91e5191"><div class="lj ab ej"><div class="lk ab ll cl cj lm"><h2 class="bd hv fv z el ln eo ep lo er et ht dt translated">使用GitHub检查构建更快的MVP</h2><div class="lp l"><h3 class="bd b fv z el ln eo ep lo er et ek translated">我是如何节省时间、精力并打造MVP的。</h3></div><div class="lq l"><p class="bd b gc z el ln eo ep lo er et ek translated">medium.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw ja li"/></div></div></a></div><p id="029a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章涵盖了TeamCI实际工作背后的技术细节。</p><p id="e13e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每张支票(<code class="eh lx ly lz ma b">rubocop</code>、<code class="eh lx ly lz ma b">shellcheck</code>、<code class="eh lx ly lz ma b">eslint</code>等)都是一个Docker图像。使用Docker使得支持任何语言或运行时变得微不足道。Docker Compose管理配置。Docker容器运行时在<code class="eh lx ly lz ma b">/code</code>安装测试代码，在<code class="eh lx ly lz ma b">/config</code>共享配置。<code class="eh lx ly lz ma b">/code</code>也是工作目录。基于高山的图像是优选的。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="ab fr cl mf"><img src="../Images/f32e191596ff81a92e26396680e37863.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dVU4BGj8RV9fJsEZCk-cvg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">TeamCI checks as seen in Github.</figcaption></figure><p id="88ca" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">TeamCI使用<a class="ae jg" href="https://testanything.org/tap-version-13-specification.html" rel="noopener ugc nofollow" target="_blank"> TAP输出</a>解析结果并创建<a class="ae jg" href="https://developer.github.com/v3/checks/runs/#annotations-object" rel="noopener ugc nofollow" target="_blank"> Github检查注释</a>。没有一个工具输出符合TeamCI要求的TAP。幸运的是，它们都输出JSON，所以每个Docker图像都包含一个将JSON输出转换为TeamCI的TAP的程序。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/7c08efd16da535de17133b96bf17e1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WX0uQgNXRy_Hth6asL984w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">TAP annotations results in action on PR diff</figcaption></figure><p id="cb70" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个Docker图像包括一个包装脚本。包装器脚本处理设置CLI选项、解析JSON以进行TAP，并确定退出代码。示例职责是检查<code class="eh lx ly lz ma b">/config</code>中的文件，并添加适当的<code class="eh lx ly lz ma b">--config FILE</code>和<code class="eh lx ly lz ma b">--output</code>选项。包装脚本以后缀<code class="eh lx ly lz ma b">-tap</code>命名。所以<code class="eh lx ly lz ma b">shellcheck</code>的包装变成了<code class="eh lx ly lz ma b">shellcheck-tap</code>。包装器脚本可能不仅仅是设置选项，它们还可能指定要测试的文件。它们也是Dockerfile的<code class="eh lx ly lz ma b">CMD</code>。简而言之，它们负责正确调用底层工具，输出TAP，并确定退出代码。</p><p id="359c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">TeamCI使用三种退出代码:</p><ul class=""><li id="4888" class="mh mi hu jj b jk jl jo jp js mj jw mk ka ml ke mm mn mo mp dt translated"><code class="eh lx ly lz ma b">0</code>为了成功</li><li id="4fab" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated"><code class="eh lx ly lz ma b">1</code>针对任何类型的故障</li><li id="7029" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated"><code class="eh lx ly lz ma b">7</code>用于跳过(比如运行一个Ruby linter，但是没有Ruby文件)</li></ul><p id="241b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只有当工具通过退出代码或输出传递结果时，才能确定跳过结果。不是每个工具都这样做，所以在这种情况下使用退出代码<code class="eh lx ly lz ma b">0</code>。不幸的是，这在Github PR UI中表现为“通过”而不是“中立”。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="ab fr cl mf"><img src="../Images/000ba1a337b9cc6aebc066460fa6b743.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1jP3HlX4CicI8h0Uj46tZw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A Check Suite as a Buildkite pipeline. Note that each check is step in the pipeline. Steps execute in parallel.</figcaption></figure><p id="0420" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">TeamCI通过<a class="ae jg" href="https://buildkite.io" rel="noopener ugc nofollow" target="_blank"> Buildkite </a>执行检查。使用Buildkite消除了管理基础设施的需要。TeamCI使用<a class="ae jg" href="https://github.com/buildkite/elastic-ci-stack-for-aws" rel="noopener ugc nofollow" target="_blank"> Buildkite Elastic stack </a>，它提供了可扩展的基础设施和功能性Docker stack。GitHub检查运行触发Buildkite构建。每个检查作为一个构建步骤运行。TeamCI在每个完成的步骤上接收一个webhook，并将结果反馈给GitHub。</p><p id="8947" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个检查构建步骤克隆测试代码和相关的<code class="eh lx ly lz ma b">ORG/teamci</code>配置报告并导出环境变量。<a class="ae jg" href="https://github.com/teamci/builder/blob/master/.buildkite/hooks/pre-command" rel="noopener ugc nofollow" target="_blank">预命令钩子</a>完成所有这些，因为它在所有构建步骤之间共享。这导致了精简的构建脚本。构建脚本使用<code class="eh lx ly lz ma b">docker-compose run</code>和在<code class="eh lx ly lz ma b">/code</code>和<code class="eh lx ly lz ma b">/config</code>装载的卷运行相关检查。</p><p id="ca3e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">验收测试涵盖所有检查。验收测试是用<a class="ae jg" href="https://github.com/sstephenson/bats." rel="noopener ugc nofollow" target="_blank">球棒</a>写的。测试涵盖了<code class="eh lx ly lz ma b">0,</code>、<code class="eh lx ly lz ma b">1</code>和<code class="eh lx ly lz ma b">7</code>退出案例以及定制配置案例(例如，<code class="eh lx ly lz ma b">/config</code>中存在一个配置文件)。测试通过BuildKite <a class="ae jg" href="https://github.com/teamci/builder/blob/master/test/emulate-buildkite" rel="noopener ugc nofollow" target="_blank">仿真包装器</a>运行，该包装器导出相关的BuildKite环境变量并执行钩子。命令在测试中被<code class="eh lx ly lz ma b">test/stubs/bin</code>中的可执行文件存根化，并将<code class="eh lx ly lz ma b">test/stubs/bin</code>追加到<code class="eh lx ly lz ma b">$PATH</code>，从而优先于真正的可执行文件。测试套件<a class="ae jg" href="https://github.com/teamci/builder/blob/9571020d6f278e8360c6294f3a8771b045d6eaf3/test/stubs/bin/git" rel="noopener ugc nofollow" target="_blank">让git命令</a>使用fixture代码，而不是实际的git库。没有它，测试套件就无法工作。</p><h2 id="8cd4" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">检查代码演练</h2><div class="lf lg fm fo lh li"><a href="https://github.com/teamci/builder/pull/10" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab ej"><div class="lk ab ll cl cj lm"><h2 class="bd hv fv z el ln eo ep lo er et ht dt translated">通过hawkins拉动请求#10 teamci/builder添加stylelint</h2><div class="lp l"><h3 class="bd b fv z el ln eo ep lo er et ek translated">这个PR加了stylelint。不需要预先配置。如果…则使用标准配置文件</h3></div><div class="lq l"><p class="bd b gc z el ln eo ep lo er et ek translated">github.com</p></div></div><div class="lr l"><div class="mv l lt lu lv lr lw ja li"/></div></div></a></div><p id="f324" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们通过一个具体的检查来看看这在实践中是如何工作的。stylelint PR是一个很好的介绍。让我们从<a class="ae jg" href="https://github.com/teamci/builder/pull/10/files#diff-06c23813453c5cf411b828fb74a93c56" rel="noopener ugc nofollow" target="_blank">测试</a>开始:</p><pre class="mb mc md me fq mw ma mx my aw mz dt"><span id="2a74" class="kf kg hu ma b fv na nb l nc nd">@test "stylelint: invalid repo fails" {<br/>	buildkite-agent meta-data set 'teamci.repo.slug' 'stylelint/code'<br/>	buildkite-agent meta-data set 'teamci.head_branch' 'fail'<br/><br/>	run test/emulate-buildkite script/stylelint<br/><br/>	[ $status -eq 1 ]<br/>	[ -n "${output}" ]<br/><br/>	[ "$(echo "${output}" | grep -cF -- '--- TAP')" -eq 2 ]<br/><br/>	# Test for annotation keys<br/>	echo "${output}" | grep -qF 'filename:'<br/>	echo "${output}" | grep -qF 'blob_href:'<br/>	echo "${output}" | grep -qF 'start_line:'<br/>	echo "${output}" | grep -qF 'end_line:'<br/>	echo "${output}" | grep -qF 'warning_level:'<br/>	echo "${output}" | grep -qF 'message:'<br/>	echo "${output}" | grep -qF 'title:'<br/><br/>	[ -n "$(buildkite-agent meta-data get 'teamci.stylelint.title')" ]<br/>}</span></pre><p id="2f01" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">前两行是设置方法。TeamCI通过构建元数据传递git repo、branch和commit，因此校验码知道要克隆哪个代码。这两行设置了映射到git fixture的值。<a class="ae jg" href="https://github.com/teamci/builder/tree/master/test/fixtures" rel="noopener ugc nofollow" target="_blank">夹具</a>住<code class="eh lx ly lz ma b">test/fixtures/$REPO/$BRANCH</code>。<code class="eh lx ly lz ma b">git</code> <a class="ae jg" href="https://github.com/teamci/builder/blob/master/test/stubs/bin/git" rel="noopener ugc nofollow" target="_blank">是</a>实现的存根模式。</p><p id="75aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下一行通过buildkite仿真包装器执行检查，随后是对退出代码和输出的断言。这个测试断言TAP输出带有正确形状的注释。</p><p id="5ba2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">测试涵盖了剩余的成功和配置文件案例。下面是对用户提供的配置文件的测试:</p><pre class="mb mc md me fq mw ma mx my aw mz dt"><span id="0157" class="kf kg hu ma b fv na nb l nc nd">@test "stylelint: config file exists" {<br/>	buildkite-agent meta-data set 'teamci.repo.slug' 'stylelint/code'<br/>	buildkite-agent meta-data set 'teamci.head_branch' 'config_file'<br/>	buildkite-agent meta-data set 'teamci.config.repo' 'stylelint/config'<br/>	buildkite-agent meta-data set 'teamci.config.branch' 'config_file'<br/><br/>	run test/emulate-buildkite script/stylelint<br/><br/>	# The configured options should make the failing fixture pass<br/>	[ $status -eq 0 ]<br/>	[ -n "${output}" ]<br/><br/>	[ -n "$(buildkite-agent meta-data get 'teamci.stylelint.title')" ]<br/>}</span></pre><p id="de98" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了提供的配置repo fixture之外，结构是相同的。这些测试使用的夹具在使用默认配置时会失败，但在使用定制配置时会通过。因此，预期结果是<code class="eh lx ly lz ma b">0</code>。</p><p id="4797" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">PR包括预期的代码变更:</p><ul class=""><li id="aab7" class="mh mi hu jj b jk jl jo jp js mj jw mk ka ml ke mm mn mo mp dt translated">从<code class="eh lx ly lz ma b">/stylelint</code>构建的<code class="eh lx ly lz ma b">stylelint</code> Docker图像</li><li id="0b45" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated"><code class="eh lx ly lz ma b">/stylelint</code>中的<code class="eh lx ly lz ma b">stylelint-tap</code>包装</li><li id="b8dd" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">一个<code class="eh lx ly lz ma b">tapify.rb</code>，用于在<code class="eh lx ly lz ma b">/stylelint</code>中将JSON转换为<code class="eh lx ly lz ma b">tap</code>。</li><li id="b5f9" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">对<code class="eh lx ly lz ma b">docker-compose.yml</code>的补充</li><li id="01c4" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">对<code class="eh lx ly lz ma b">Makefile</code>的补充</li><li id="0aa1" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">使用相应的夹具在<code class="eh lx ly lz ma b">test/acceptance</code>中进行测试。</li></ul><p id="0281" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“通过测试的有效回购”也可能会给fixture带来不相关的代码文件。Stylelint测试样式表(例如<code class="eh lx ly lz ma b">**/*.css</code>，所以代码目录中的一个分散的Ruby文件应该不会导致失败。测试这个依赖于工具。Stylelint需要一个显式的文件列表，所以使用了glob。然而，对于像php代码嗅探器这样自己检测PHP文件的东西来说，情况并非如此。</p><h2 id="b42f" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">包裹</h2><p id="9267" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">一旦你理解了结构，添加一个新的检查就很简单了。我从最近的检查开始复制和粘贴，因为它们都足够相似。然后我调整测试、<code class="eh lx ly lz ma b">-tap</code>包装器和<code class="eh lx ly lz ma b">tapify.rb</code>。我从测试退出代码1开始。这允许我测试工具的预期工作，并检查JSON输出。事后再拧<code class="eh lx ly lz ma b">tapify.rb</code>很容易。然后是创建传递装置、配置文件和Docker映像的繁重工作。</p><p id="20c2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在以下情况下，添加新工具最为简单:</p><ul class=""><li id="b2b5" class="mh mi hu jj b jk jl jo jp js mj jw mk ka ml ke mm mn mo mp dt translated">该工具自动检测可测试的文件</li><li id="c483" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">可以提供显式配置文件</li><li id="890a" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">该工具将JSON打印到标准输出</li><li id="aeb2" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">错误和无关信息打印到标准错误</li><li id="66d0" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">该工具发出信号(通过退出代码或输出)表明没有找到可测试的文件</li><li id="983c" class="mh mi hu jj b jk mq jo mr js ms jw mt ka mu ke mm mn mo mp dt translated">有一些排除文件的方法</li></ul><p id="69e8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我很喜欢写生成器。这是一项简单的任务，而且验收测试套件给了我足够的信心。这种体验也暴露了我在这些工具中偏好的语义。</p><p id="5d64" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你觉得怎么样？想要添加您自己的支票吗？请随意发送PR，让TeamCI对您更有用。如果没有，那么至少你知道了用Bash(国王万岁)进行TDD是可能的——而且很有趣。<a class="ae jg" href="https://teamci.co" rel="noopener ugc nofollow" target="_blank">测试期间免费测试TeamCI</a>。</p><div class="lf lg fm fo lh li"><a href="https://teamci.co" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab ej"><div class="lk ab ll cl cj lm"><h2 class="bd hv fv z el ln eo ep lo er et ht dt translated">TeamCI——执行团队代码标准</h2><div class="lp l"><h3 class="bd b fv z el ln eo ep lo er et ek translated">根据团队编码标准自动测试团队代码仓库。</h3></div><div class="lq l"><p class="bd b gc z el ln eo ep lo er et ek translated">teamci.co</p></div></div><div class="lr l"><div class="ne l lt lu lv lr lw ja li"/></div></div></a></div></div></div>    
</body>
</html>