<html>
<head>
<title>Creating a New Programming Language That Will Allow Anyone to Make Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创造一种新的编程语言，让任何人都可以制作软件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-new-programming-language-that-will-allow-anyone-to-make-software-7a8c73238dc2?source=collection_archive---------3-----------------------#2018-07-31">https://medium.com/hackernoon/creating-a-new-programming-language-that-will-allow-anyone-to-make-software-7a8c73238dc2?source=collection_archive---------3-----------------------#2018-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ca164990feff311f5c5b7899302ad33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YvNKC76-2kGR7RHR"/></div></div></figure><h2 id="c57f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">在过去的7个月里，我一直在开发一种新的编程语言，叫做MSON。这是一个关于我为什么这么做，它是如何工作的，以及我想把它带到哪里的无聊帖子。</h2><h1 id="93f5" class="ka jd hu bd je kb kc kd ji ke kf kg jm kh ki kj jq kk kl km ju kn ko kp jy kq dt translated">已经有数十亿种编程语言，为什么我们还需要另一种呢？</h1><p id="036e" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">软件继续蚕食世界，软件开发工具也在以闪电般的速度发展，但是开发软件仍然需要深入了解编程语言。当然，有数以百万计的开源项目可以融合在一起，强大的云平台可以让这个过程变得更容易，但让所有这些技术协同工作需要相当高的技能。当我展望未来时，我想象普通人能够制作软件，就像普通人今天能够创建电子表格一样。</p><p id="105b" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">创建电子表格已经变得司空见惯，这在很大程度上是MS Excel中直观的用户界面(UI)的结果。开发软件；然而，仍然只有相对少数的人使用复杂的编程语言来完成。有人可能会说，创建一个生成代码的UI有些琐碎，但要逆转这个过程并消化编码的逻辑几乎是不可行的，因为大多数编程语言有几乎无限多种表示逻辑的方式。换句话说，我们通常不知道一个软件将如何执行，直到我们实际执行它。创建一种真正直观的软件开发方式需要一种新的范式，一种易于UI读取、修改和编写的新语言。</p><p id="3194" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">早在2003年，当PHP非常流行的时候，我开始构建一个叫做FORMfields的框架。当时，FORMfields非常酷，因为你可以用PHP对象创建表单，然后FORMfields会自动生成相应的HTML、CSS和JS。在创建了FORMfields后不久，我与人合伙创办了一家名为GoExpo的公司，生产基于FORMfields的事件管理软件。GoExpo每年为世界上一些最大的贸易展处理数百万美元的展位销售，这是FORMfields有效性的证明。</p><p id="bb61" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">这些年来，FORMfields在允许我们的团队创建一个可以快速修改的一致的UI方面仍然是必不可少的(记住，这是在Twitter Bootstrap和更现代的UI框架出现之前的日子)。然而，随着浏览器变得越来越强大，更多的逻辑转移到了前端；而用PHP写的FORMfields只在后端运行。</p><p id="fb9b" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">快进到2018年，JavaScript是网络的主力，前端和后端的区别就像白天和黑夜。GoExpo已经被收购，我现在有时间用一个更现代的堆栈来重新审视表单域的概念。我希望下一代表单域既能在浏览器中运行，也能在后端运行，是开源的，并成为大众可以使用的东西的基础。</p><p id="61af" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">这种思路催生了<a class="ae ls" href="https://github.com/redgeoff/mson" rel="noopener ugc nofollow" target="_blank"> MSON </a>，这是一种可扩展的声明式语言，可以通过用户界面轻松操作。MSON只由几个构件组成，但是它和它的非声明性对应物一样强大。</p><p id="085f" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">这个初始帖子的目的是介绍<a class="ae ls" href="https://github.com/redgeoff/mson" rel="noopener ugc nofollow" target="_blank"> MSON </a>编程语言的核心原则，并阐述其独特的设计。我计划稍后写一篇后续文章，从外行人的角度解释MSON。这个帖子；然而，它是相当技术性的，因为它是关于MSON的开发人员层的东西，而不是关于我将在其上编写的通用UI层。我将阐述以下主题:</p><ol class=""><li id="dd9b" class="lt lu hu kt b ku lm ky ln jn lv jr lw jv lx ll ly lz ma mb dt translated">声明语法</li><li id="f063" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">组件、验证器、事件和监听器</li><li id="c1f8" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">访问控制</li><li id="d9dc" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">继承、模板参数和组合</li><li id="fa76" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">聚合组件</li><li id="08ee" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">模式和自我文档</li><li id="0228" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">用户定义的JavaScript组件</li><li id="241d" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">在任何JavaScript代码中使用MSON</li><li id="028d" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">在整个堆栈中重用MSON代码</li><li id="2fe0" class="lt lu hu kt b ku mc ky md jn me jr mf jv mg ll ly lz ma mb dt translated">输入/输出属性</li></ol><p id="7fb9" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">然后，我将以一份关于我计划如何将MSON货币化并使其成为一个自我维持的项目的声明来结束我的发言。我很想听听你的想法。</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h1 id="ba18" class="ka jd hu bd je kb mo kd ji ke mp kg jm kh mq kj jq kk mr km ju kn ms kp jy kq dt translated">语言原则</h1><h2 id="76ca" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">声明语法</h2><p id="4803" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">MSON是模型脚本对象符号的缩写，它有意类似于JSON (JavaScript对象符号)。事实上，MSON是JSON的子集，所以如果你知道JSON，那么你就知道MSON的语法！</p><p id="6349" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">声明性语言对于软件来说更容易阅读和编写，因为它们定义了软件必须做什么，而没有确切地说明如何做。JSON是一个很好的基础。它只包含几个主要的构造，无处不在，并由一个巨大的生态系统支持。</p><h2 id="e2bd" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">成分</h2><p id="c073" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">MSON最小的建筑块叫做组件。组件维护状态，也可以控制表示，非常类似于大多数web框架中常见的组件。组件可以继承、包含或包装其他组件。渲染层支持不同环境的插件，默认插件支持React和Material-UI。呈现层的使用是可选的，因此组件可以在前端和后端使用。</p><p id="cdef" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">用于收集姓名和电子邮件地址的简单表单组件如下所示:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="138d" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyForm',<br/>  component: 'Form',<br/>  fields: [<br/>    {<br/>      name: 'name',<br/>      component: 'TextField',<br/>      label: 'Name',<br/>      required: true<br/>    },<br/>    {<br/>      name: 'email',<br/>      component: 'EmailField',<br/>      label: 'Email'<br/>    },<br/>    {<br/>      name: 'submit',<br/>      component: 'ButtonField',<br/>      label: 'Submit',<br/>      icon: 'CheckCircle'<br/>    }<br/>  ]<br/>}</span></pre><p id="0f59" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">当它呈现时，看起来像是:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/1580845da2f3207e9a4163f409ffdddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*-BKbMsMjqtlwsMQSbi65rA.png"/></div></figure><p id="8e5f" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">而且，实时验证是自动进行的:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/30420c8cb9adaec5e431875bcb943ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*hwXpIMcoJTfB-QjHYKwHfA.png"/></div></figure><p id="c703" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">这篇文章中剩下的大部分例子将集中在表单组件上，因为它们易于可视化，但是MSON可以支持任何类型的组件，例如菜单、快捷菜单、重定向等。此外，你可以使用JavaScript创建用户定义的组件，这些组件可以做你能想到的任何事情。</p><h2 id="bd0e" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">验证器</h2><p id="d2f8" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">每个字段都有一组默认的验证器，例如email字段确保电子邮件地址的格式有效。您还可以为特定的字段甚至整个表单扩展这些验证器。</p><p id="1ba1" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">例如，您可以阻止用户输入<em class="lr">nope@example.com</em>:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="a686" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyForm',<br/>  component: 'Form',<br/>  fields: ...,<br/>  validators: [<br/>    {<br/>      where: {<br/>        'fields.email.value': '<a class="ae ls" href="mailto:nope@example.com" rel="noopener ugc nofollow" target="_blank">nope@example.com</a>'<br/>      },<br/>      error: {<br/>        field: 'email',<br/>        error: 'must not be {{fields.email.value}}'<br/>      }<br/>    }<br/>  ]<br/>}</span></pre><p id="c2ce" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">像<code class="eh ni nj nk my b">{{fields.email.value}}</code>这样的模板参数可以用来注入字段的值。并且，您可以在<code class="eh ni nj nk my b">where</code>中使用任何<a class="ae ls" href="https://docs.mongodb.com/manual/reference/operator/query/" rel="noopener ugc nofollow" target="_blank"> MongoDB风格的查询</a>。例如，如果您有<code class="eh ni nj nk my b">password</code>和<code class="eh ni nj nk my b">retypePassword</code>字段，您可以确保它们等价于:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="df61" class="jc jd hu my b fv nc nd l ne nf">where: {<br/>  'retypePassword.fields.value': {<br/>    $ne: '{{fields.password.value}}'<br/>  },<br/>  error: ...<br/>}</span></pre><p id="f10d" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">事件&amp;监听器</strong></p><p id="4ea8" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">对组件中属性的更改会生成事件，您可以创建用操作响应这些事件的侦听器。有设置、发出、电子邮件、联系API等基本动作，也可以使用JavaScript构建自定义动作。</p><p id="b5d0" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">以下示例根据用户单击<code class="eh ni nj nk my b">submit</code>按钮时在<code class="eh ni nj nk my b">name</code>字段中提供的值设置<code class="eh ni nj nk my b">email</code>字段的值:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="b98d" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyForm',<br/>  component: 'Form',<br/>  fields: ...,<br/>  validators: ...,<br/>  listeners: [<br/>    {<br/>      event: 'submit',<br/>      actions: [<br/>        {<br/>          component: 'Set',<br/>          name: 'fields.email.value',<br/>          value: '{{fields.name.value}}<a class="ae ls" href="http://twitter.com/example" rel="noopener ugc nofollow" target="_blank">@example</a>.com'<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="19be" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我们也可以使该操作有条件，例如，仅在<code class="eh ni nj nk my b">email</code>为空时设置它:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="6200" class="jc jd hu my b fv nc nd l ne nf">listeners: [<br/>  {<br/>    event: 'submit',<br/>    actions: [<br/>      {<br/>        component: 'Set',<br/>        if: {<br/>          'fields.email': {<br/>            $or: [<br/>              {<br/>                value: null<br/>              },<br/>              {<br/>                value: ''<br/>              }<br/>            ]<br/>          }<br/>        },<br/>        name: 'fields.email.value',<br/>        value: '{{fields.name.value}}<a class="ae ls" href="http://twitter.com/example" rel="noopener ugc nofollow" target="_blank">@example</a>.com'<br/>      }<br/>    ]<br/>  }<br/>]</span></pre><p id="00c6" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">有时我们希望嵌套操作，以便在执行所有操作之前满足一个条件:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="f58c" class="jc jd hu my b fv nc nd l ne nf">listeners: [<br/>  {<br/>    event: 'submit',<br/>    actions: [<br/>      {<br/>        component: 'Action',<br/>        if: {<br/>          'fields.email': {<br/>            $or: [<br/>              {<br/>                value: null<br/>              },<br/>              {<br/>                value: ''<br/>              }<br/>            ]<br/>          }<br/>        },<br/>        actions: [<br/>          {<br/>            component: 'Set',<br/>            name: 'fields.email.value',<br/>            value: '{{fields.name.value}}<a class="ae ls" href="http://twitter.com/example" rel="noopener ugc nofollow" target="_blank">@example</a>.com'<br/>          },<br/>          {<br/>            component: 'Set',<br/>            name: 'fields.name.value',<br/>            value: '{{fields.name.value}} Builder'<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>]</span></pre><p id="0bf4" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">访问控制</strong></p><p id="b2a5" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">与大多数编程语言不同，access control是MSON的一等公民，所以它很容易使用，不需要做很多工作。对于创建、读取、更新和归档操作，可以在表单或字段层限制访问。(MSON旨在鼓励数据存档而不是删除，以便在数据意外存档时可以恢复。当然，您可以在需要时永久删除数据)。</p><p id="fad6" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">每个用户可以拥有任意数量的用户定义的角色，并且访问权限仅限于拥有指定角色的用户。还有一个为数据所有者定义的系统角色<code class="eh ni nj nk my b">owner</code>。首先检查字段层访问，如果缺少字段层访问，将级联检查表单层访问。如果在表单层没有定义访问权限(也没有在字段层定义)，所有用户都有访问权限。</p><p id="4946" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">下面是一个配置示例:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="c4f0" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyForm',<br/>  component: 'Form',<br/>  fields: ...,<br/>  validators: ...,<br/>  listeners: ...,<br/>  access: {<br/>    form: {<br/>      create: ['admin', 'manager'],<br/>      read: ['admin', 'employee'],<br/>      update: ['admin', 'owner', 'manager'],<br/>      archive: ['admin']<br/>    },<br/>    fields: {<br/>      name: {<br/>        create: ['admin'],<br/>        update: ['owner']<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="5737" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">其中，只有拥有<code class="eh ni nj nk my b">admin</code>或<code class="eh ni nj nk my b">manager</code>角色的用户可以创建记录。此外，只有记录的所有者可以修改<code class="eh ni nj nk my b">name</code>。</p><p id="5488" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">继承</strong></p><p id="38c9" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">继承用于向组件添加额外的功能。例如，我们可以扩展<code class="eh ni nj nk my b">MyForm</code>并添加一个电话号码:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="9b30" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyFormExtended',<br/>  component: 'MyForm',<br/>  fields: [<br/>    {<br/>      name: 'phone',<br/>      component: 'PhoneField',<br/>      label: 'Phone Number',<br/>      before: 'submit'<br/>    }<br/>  ]<br/>}</span></pre><p id="50f0" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我们可以在这个新的层定义新的验证器、监听器、访问等等。例如，我们可以预先填充一些数据，将所有字段放在同一行上，并通过为<code class="eh ni nj nk my b">create</code>事件创建一个监听器来禁用电子邮件字段:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="1d72" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyFormExtended',<br/>  component: 'MyForm',<br/>  fields: ...,<br/>  listeners: [<br/>    {<br/>      event: 'create',<br/>      actions: [<br/>        {<br/>          component: 'Set',<br/>          name: 'value',<br/>          value: {<br/>            name: 'Bob Builder',<br/>            email: '<a class="ae ls" href="mailto:bob@example.com" rel="noopener ugc nofollow" target="_blank">bob@example.com</a>',<br/>            phone: '(206)-123-4567'<br/>          }<br/>        },<br/>        {<br/>          component: 'Set',<br/>          name: 'fields.name.block',<br/>          value: false<br/>        },<br/>        {<br/>          component: 'Set',<br/>          name: 'fields.email.block',<br/>          value: false<br/>        },<br/>        {<br/>          component: 'Set',<br/>          name: 'fields.email.disabled',<br/>          value: true<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="1769" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">这将表现为:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/3882ca11c2447c0f69c94b683f8a04c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQ2DbxNFptPd-8oqUmPMdA.png"/></div></div></figure><p id="f84b" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">模板参数</strong></p><p id="b691" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">模板参数在创建可重用组件时很有帮助，因为它们允许您将组件的各个部分动态化。例如，假设我们希望第一个字段和第二个字段的标签是动态的:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="6dc1" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyTemplatedForm',<br/>  component: 'Form',<br/>  fields: [<br/>    '{{firstField}}',<br/>    {<br/>      name: 'secondField',<br/>      label: '{{secondFieldLabel}}',<br/>      component: 'EmailField'<br/>    }<br/>  ]<br/>}</span></pre><p id="4f29" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">然后我们可以扩展<code class="eh ni nj nk my b">MyTemplatedForm</code>并填充片段:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="8d32" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyFilledTemplatedForm',<br/>  component: 'MyTemplatedForm',<br/>  firstField: {<br/>    name: 'firstName',<br/>    component: 'TextField',<br/>    label: 'First Name'<br/>  },<br/>  secondFieldLabel: 'Email Address'<br/>}</span></pre><p id="eb65" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">构图</strong></p><p id="3a78" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">属性允许您包装组件，使您的可重用组件能够转换任何组件。例如，我们可以使用组合来创建一个添加电话号码的可重用组件:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="c6ea" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'AddPhone',<br/>  component: 'Form',<br/>  componentToWrap: '{{baseForm}}',<br/>  fields: [<br/>    {<br/>      name: 'phone',<br/>      component: 'PhoneField',<br/>      label: 'Phone Number',<br/>      before: 'submit'<br/>    }<br/>  ]<br/>}</span></pre><p id="51e0" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">然后传入要包装的组件:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="750f" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyFormWithPhone',<br/>  component: 'AddPhone',<br/>  baseForm: {<br/>    component: 'MyForm'<br/>  }<br/>}</span></pre><p id="e611" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">您甚至可以扩展包装组件，为由其他组件组成的聚合组件的丰富生态系统铺平道路。</p><p id="57e6" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">骨料成分</strong></p><p id="dfa2" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">MSON附带了许多聚合组件，如<code class="eh ni nj nk my b">RecordEditor</code>和<code class="eh ni nj nk my b">RecordList</code>，这使得只需几行代码就可以轻松地将表单组件转换成可编辑的ui。</p><p id="baca" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">让我们定义一个用户组件:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="8f7c" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyAccount',<br/>  component: 'Form',<br/>  fields: [<br/>    {<br/>      name: 'firstName',<br/>      component: 'TextField',<br/>      label: 'First Name'<br/>    },    <br/>    {<br/>      name: 'lastName',<br/>      component: 'TextField',<br/>      label: 'Last Name'<br/>    },<br/>    {<br/>      name: 'email',<br/>      component: 'EmailField',<br/>      label: 'Email'<br/>    }<br/>  ]<br/>}</span></pre><p id="2871" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">然后，我们可以使用<code class="eh ni nj nk my b">RecordEditor</code>来允许用户编辑她的/他的帐户:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="7d07" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyAccountEditor',<br/>  component: 'RecordEditor',<br/>  baseForm: {<br/>    component: 'MyAccount'<br/>  },<br/>  label: 'Account'<br/>}</span></pre><p id="29a6" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">渲染为:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/a30e6f67f66999287fd25cc588aee0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*U8rdyso8zE-yigI51QJupA.png"/></div></figure><p id="a537" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">如果你点击<em class="lr">编辑</em>按钮，你会看到:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/b24f71fefd40476bf15c549d799fe987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-cZQ5xnxRqApU-24kUwTA.png"/></div></div></figure><p id="630f" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">您也可以使用<code class="eh ni nj nk my b">RecordList</code>来显示这些帐户的可编辑列表:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="8dc2" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyAccountsList',<br/>  component: 'RecordList',<br/>  label: 'Accounts',<br/>  baseFormFactory: {<br/>    component: 'Factory',<br/>    product: {    <br/>      component: 'MyAccount'<br/>    }<br/>  }<br/>}</span></pre><p id="3416" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">渲染为:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff no"><img src="../Images/762a5495cc2f299bb68e55c7aa33252c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2nPBMRyVLNFQaaJ1qlvIA.png"/></div></div></figure><p id="7109" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">模式和自我文档</strong></p><p id="c36d" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">必须为所有组件定义架构，这意味着MSON是强类型的。例如，定义布尔和日期属性的模式可能如下所示:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="5632" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyComponent',<br/>  component: 'Component',<br/>  schema: {<br/>    component: 'Form',<br/>    fields: [<br/>      {<br/>        name: 'hidden',<br/>        component: 'BooleanField',<br/>        help: 'Whether or not the component is hidden'<br/>      },<br/>      {<br/>        name: 'updatedAt',<br/>        component: 'DateTimeField',<br/>        required: true, <br/>        help: 'When the component was updated'<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="efce" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">模式还可以通过<code class="eh ni nj nk my b">help</code>属性包含文档，这意味着组件是自文档化的！此外，模式是继承的，可以被覆盖以允许更多甚至更少的约束。</p><p id="2304" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">用户自定义的JavaScript组件</strong></p><p id="0149" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">MSON编译器是用JavaScript编写的，可以在浏览器和Node.js中运行。因此，您可以使用任何自定义js(包括外部JS库)来创建自己的组件。</p><p id="e2c1" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">例如，下面是一个使用<a class="ae ls" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> Moment.js </a>将<code class="eh ni nj nk my b">currentDay</code>属性设置为当天的组件:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="78f7" class="jc jd hu my b fv nc nd l ne nf">import compiler from 'mson/lib/compiler';<br/>import Component from 'mson/lib/component';<br/>import Form from 'mson/lib/form';<br/>import { TextField } from 'mson/lib/fields';<br/>import moment from 'moment';</span><span id="7a97" class="jc jd hu my b fv np nd l ne nf">class MyComponent extends Component {<br/>  _create(props) {<br/>    super._create(props);</span><span id="0c3e" class="jc jd hu my b fv np nd l ne nf">    this.set({<br/>      // Define a currentDay property<br/>      schema: new Form(<br/>        fields: [<br/>          new TextField({<br/>            name: 'currentDay'<br/>          })<br/>        ]<br/>      ),</span><span id="4c74" class="jc jd hu my b fv np nd l ne nf">      // Default currentDay<br/>      currentDay: moment().format('dddd')<br/>    });<br/>  }<br/>}</span><span id="fd84" class="jc jd hu my b fv np nd l ne nf">compiler.registerComponent('MyComponent', MyComponent);</span></pre><p id="ad8f" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">然后<code class="eh ni nj nk my b">MyComponent</code>可以用在任何MSON码中。</p><p id="2647" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">您还可以定义自定义异步操作，例如发布表单数据的操作:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="46e8" class="jc jd hu my b fv nc nd l ne nf">import compiler from 'mson/lib/compiler';<br/>import Action from 'mson/lib/actions/action';<br/>import Form from 'mson/lib/form';<br/>import { TextField } from 'mson/lib/fields';</span><span id="381c" class="jc jd hu my b fv np nd l ne nf">class MyAction extends Action {<br/>  _create(props) {<br/>    super._create(props);</span><span id="f699" class="jc jd hu my b fv np nd l ne nf">    this.set({<br/>      schema: new Form(<br/>        fields: [<br/>          new TextField({<br/>            name: 'foo'<br/>          })<br/>        ]<br/>      )<br/>    });<br/>  }</span><span id="e767" class="jc jd hu my b fv np nd l ne nf">  async act(props) {<br/>    const form = new FormData();<br/>    form.append('foo', this.get('foo'));</span><span id="d1ff" class="jc jd hu my b fv np nd l ne nf">    const account = props.component;<br/>    form.append('firstName', account.get('firstName');<br/>    form.append('lastName', account.get('lastName');<br/>    form.append('email', account.get('email');</span><span id="251b" class="jc jd hu my b fv np nd l ne nf">    return fetch({<br/>      '<a class="ae ls" href="https://api.example.com'" rel="noopener ugc nofollow" target="_blank">https://api.example.com'</a>,<br/>      {<br/>        method: 'POST',<br/>        body: form<br/>      }<br/>    })<br/>  }<br/>}</span><span id="eab6" class="jc jd hu my b fv np nd l ne nf">compiler.registerComponent('MyAction', MyAction);</span></pre><p id="f0ec" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">然后你可以在你的MSON代码中使用它:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="492e" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyAccountExtended',<br/>  component: 'MyAccount',<br/>  listeners: [<br/>    {<br/>      event: 'submit',<br/>      actions: [<br/>        {<br/>          component: 'MyAction',<br/>          foo: 'bar'<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="21f2" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">在任何JavaScript代码中使用MSON</strong></p><p id="6f0b" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">编译和未编译组件之间总是存在奇偶校验，因此编译和未编译代码都支持相同的功能集。例如，我们同样可以将<code class="eh ni nj nk my b">MyAccount</code>组件定义为:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="de28" class="jc jd hu my b fv nc nd l ne nf">import Form from 'mson/lib/form';<br/>import { TextField, Email } from 'mson/lib/fields';</span><span id="74ee" class="jc jd hu my b fv np nd l ne nf">class MyAccount extends Form {<br/>  _create(props) {<br/>    super._create(props);</span><span id="41fb" class="jc jd hu my b fv np nd l ne nf">    this.set({<br/>      fields: [<br/>        new TextField({<br/>          name: 'firstName',<br/>          label: 'First Name'<br/>        }),<br/>        new TextField({<br/>          name: 'lastName',<br/>          label: 'Last Name'<br/>        }),<br/>        new EmailField({<br/>          name: 'email',<br/>          label: 'Email'<br/>        })<br/>      ]<br/>    })<br/>  }<br/>}</span></pre><p id="728b" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">事实上，将MSON代码转换成这种类型的代码基本上就是编译器的工作。虽然，编译器实际上并没有将MSON转换成JS，它只是基于MSON定义实例化了JS代码。</p><p id="3c16" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">因为所有的MSON代码都可以被编译成JS代码，所以你可以在任何JS代码中使用MSON组件。例如，您可以设置一些字段并验证数据:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="168a" class="jc jd hu my b fv nc nd l ne nf">import compiler from 'mson/lib/compiler';</span><span id="2c96" class="jc jd hu my b fv np nd l ne nf">// Compile the MyAccount component<br/>const MyAccount = compiler.compile({<br/>  component: 'MyAccount'<br/>});</span><span id="5822" class="jc jd hu my b fv np nd l ne nf">// Instantiate the JS class with a default value<br/>const myAccount = new MyAccount({<br/>  // Default values<br/>  value: {<br/>    firstName: 'Bob'<br/>  }<br/>});</span><span id="8cfb" class="jc jd hu my b fv np nd l ne nf">// Set the remaining data<br/>myAccount.set({<br/>  lastName: 'Builder',<br/>  email: 'invalid-email@'<br/>});</span><span id="4424" class="jc jd hu my b fv np nd l ne nf">// Make sure the values are valid<br/>myAccount.validate();<br/>if (myAccount.hasErr()) {<br/>  console.log(myAccount.getErrs());<br/>}</span></pre><p id="cd43" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">换句话说，您可以在现有的JS代码中使用MSON来节省编写复杂代码的时间。通过在MSON中声明组件，您将删除大量样板代码，并减少出现错误的可能性。您还将拥有具有标准结构且与框架无关的代码。这些代码不会向您的代码库添加任何不需要的框架或后端依赖项。</p><p id="cdc1" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">在整个堆栈中重用MSON代码</strong></p><p id="d78f" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">MSON组件可以由前端和后端共享，允许关键逻辑编写一次，然后重用。例如，相同的表单验证规则可以在浏览器中强制执行，也可以由您的后端API强制执行。</p><p id="d942" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">此外，动作可以被限制到<code class="eh ni nj nk my b">backEnd</code>或<code class="eh ni nj nk my b">frontEnd</code>，以便相同的组件可以根据主机环境进行调整。例如，您可能希望联系人表单在后端使用时向用户发送电子邮件，但只在前端显示一个<a class="ae ls" href="https://material-ui.com/demos/snackbars/" rel="noopener ugc nofollow" target="_blank"> snackbar </a>:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="f2ef" class="jc jd hu my b fv nc nd l ne nf">{<br/>  component: 'Form',<br/>  fields: [<br/>    {<br/>      name: 'email',<br/>      component: 'EmailField',<br/>      label: 'Email'<br/>    },<br/>    {<br/>      name: 'message',<br/>      component: 'TextField',<br/>      label: 'Message'<br/>    },<br/>    {<br/>      name: 'Submit',<br/>      component: 'ButtonField',<br/>      label: 'Submit'<br/>    }<br/>  ],<br/>  listeners: [<br/>    {<br/>      event: 'submit',<br/>      actions: [<br/>        {<br/>          // Send an email on the back end<br/>          component: 'Email',<br/>          layer: 'backEnd',<br/>          from: '{{fields.email.value}}',<br/>          to: '<a class="ae ls" href="mailto:noreply@example.com" rel="noopener ugc nofollow" target="_blank">noreply@example.com</a>',<br/>          subject: 'My message',<br/>          body: '{{fields.message.value}}',</span><span id="47ef" class="jc jd hu my b fv np nd l ne nf">          // Detach so that user doesn't have to wait for email<br/>          // to send<br/>          detach: true<br/>        },<br/>        {<br/>          // Display a message to the user on the front end<br/>          component: 'Snackbar',<br/>          layer: 'frontEnd',<br/>          message: 'Thanks for the message'<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="95f0" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><strong class="kt hv">输入/输出属性</strong></p><p id="03b1" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">有时您希望数据存在，但不希望从后端写入或读取数据。例如，您的默认用户组件可能不允许读取或编辑密码:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="fa26" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'MyUser',<br/>  component: 'Form',<br/>  fields: [<br/>    {<br/>      name: 'name',<br/>      component: 'TextField',<br/>      label: 'Name'<br/>    },<br/>    {<br/>      name: 'email',<br/>      component: 'EmailField',<br/>      label: 'Email'<br/>    },<br/>    {<br/>      name: 'password',<br/>      component: 'PasswordField',<br/>      label: 'Password',<br/>      hidden: true,<br/>      in: false,<br/>      out: false<br/>    }<br/>  ]<br/>}</span></pre><p id="e63a" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">但是，您的<code class="eh ni nj nk my b">EditPasswordForm</code>可能需要允许这样的访问:</p><pre class="mt mu mv mw fq mx my mz na aw nb dt"><span id="93a5" class="jc jd hu my b fv nc nd l ne nf">{<br/>  name: 'EditPasswordForm',<br/>  component: 'MyUser',<br/>  listeners: [<br/>    {<br/>      event: 'create',<br/>      actions: [<br/>        {<br/>          // Hide all fields<br/>          component: 'Set',<br/>          name: 'hidden',<br/>          value: true<br/>        },<br/>        {<br/>          // Show password field<br/>          component: 'Set',<br/>          name: 'fields.password.hidden',<br/>          value: false<br/>        },<br/>        {<br/>          // Allow user to write password to the back end<br/>          component: 'Set',<br/>          name: 'fields.password.out',<br/>          value: true<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h1 id="ffb5" class="ka jd hu bd je kb mo kd ji ke mp kg jm kh mq kj jq kk mr km ju kn ms kp jy kq dt translated">后续步骤</h1><p id="cf60" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">在发表这篇文章之前，我只向少数人展示过MSON。对于一个开源项目来说，这可能看起来很奇怪，但这是有意的，因为我想在进行更广泛的发布之前充实语言。我不希望人们开始使用构建模块会发生剧烈变化的东西。因此，我从编译器的基本原型开始，然后开始构建一个用MSON语言编写的示例应用程序。这让我能够使用迭代的方法来查看什么可行，什么不可行。在几次重写编译器之后，感谢单元测试和一个耐心的妻子，我已经能够实现一个全功能的应用程序了。我确信这种语言会继续发展，但是我现在相信MSON是一个坚实的基础。</p><p id="c8a1" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">MSON编译器完全用JS编写，既可以在浏览器中运行，也可以在Node.js上运行。repo托管在https://github.com/redgeoff/mson的github上——如果你喜欢这个想法，请给它打个星。</p><p id="0c95" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我还计划通过开发mson.co来实现这个想法，它将拥有一个任何人都可以用来制作软件的用户界面。UI将在后台读取、修改和编写MSON，并且会根据您的组件定义自动创建一个后端。对于开发人员来说，你可以选择使用尽可能多的mson.co堆栈，例如，你可以使用MSON UI Builder引导你的应用程序，然后用你最喜欢的技术替换/定制前端(mson.co后端通过GraphQL API公开)。或者，您可以只在前端使用MSON，并创建自己的自定义后端API。</p><p id="9124" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我希望你喜欢读这篇文章，我很想听听你的想法。可以在<a class="ae ls" rel="noopener" href="/@redgeoff">中</a>、<a class="ae ls" href="https://twitter.com/redgeoff7" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae ls" href="https://github.com/redgeoff" rel="noopener ugc nofollow" target="_blank"> github </a>上关注我。</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><h1 id="5337" class="ka jd hu bd je kb mo kd ji ke mp kg jm kh mq kj jq kk mr km ju kn ms kp jy kq dt translated">关于作者</h1><p id="2940" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">杰夫·考克斯是MSON的创造者，这是一种新的声明式编程语言，它将允许任何人可视化地开发软件。他喜欢承担雄心勃勃但令妻子抓狂的项目，如<a class="ae ls" href="https://github.com/delta-db/deltadb" rel="noopener ugc nofollow" target="_blank">创建数据库</a>和<a class="ae ls" href="https://github.com/redgeoff/spiegel" rel="noopener ugc nofollow" target="_blank">分布式数据同步系统</a>。你可以在<a class="ae ls" href="https://redgeoff.com" rel="noopener ugc nofollow" target="_blank">redgeoff.com</a>或者联系他<a class="ae ls" href="https://twitter.com/coxgeoffrey" rel="noopener ugc nofollow" target="_blank"> @CoxGeoffrey </a>或者在<a class="ae ls" href="https://github.com/redgeoff" rel="noopener ugc nofollow" target="_blank"> github </a>阅读他的更多帖子。</p></div></div>    
</body>
</html>