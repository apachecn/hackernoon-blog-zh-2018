<html>
<head>
<title>TCP Three-Way Handshake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TCP三次握手</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tcp-three-way-handshake-4161eb8aba32?source=collection_archive---------5-----------------------#2018-07-31">https://medium.com/hackernoon/tcp-three-way-handshake-4161eb8aba32?source=collection_archive---------5-----------------------#2018-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bde6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你真的了解它吗？—阿里巴巴技术团队的最佳实践</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/7a83cf037144d6a12c0cb3e011475e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ig0W49EXUV6mvDM_0-Yw9A.jpeg"/></div></div></figure><p id="e2f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">任锡军是阿里巴巴中间件技术团队的成员。最近，他遇到了一个客户端通信服务器不断抛出异常的问题。但令他沮丧的是，尽管他在互联网上搜索信息，并反复尝试找到原因，但他无法找到任何有助于解释这两个队列或如何观察它们的指标的东西。</p><p id="7b03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他没有被吓倒，自己承担起了弄清问题的责任。他写了这篇文章来记录他是如何发现并解决这个问题的。</p><h1 id="b727" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">令人烦恼的问题</h1><p id="85f9" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在Java中，客户端和服务器使用套接字进行通信。在本例中，使用了NIO服务器。出现了以下状态:</p><p id="1803" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了在客户端和服务器之间创建连接，间歇性地执行了三次握手，但是listen套接字没有响应。</p><p id="5859" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个问题同时出现在许多其他连接中。</p><p id="bf10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">NIO选择器没有被销毁和重新创建。用的总是第一个。</p><p id="dd10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些问题在程序启动时就出现了，之后又断断续续地出现。</p><h1 id="365f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">回顾:TCP三次握手是如何工作的？</h1><p id="d314" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">我做的第一件事是提醒自己建立TCP连接时三次握手的标准过程。标准过程如下进行:</p><p id="ad49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.客户端向服务器发送一个SYN数据包来发起握手。</p><p id="0d1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.收到这个消息后，服务器向客户机发送一个SYN-ACK包。</p><p id="6f5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.最后，客户机向服务器发送一个ACK包，表明它已经收到了服务器的SYN-ACK包。(此时，已经通过客户端的端口56911建立了到服务器的连接。)</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/1a40ee36aad2563a56fe2501bd363b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*FZozH_jN1LiZTf5qIJ0DXw.png"/></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Process of a TCP three-way handshake</figcaption></figure><h1 id="3b71" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">快速解决办法</h1><p id="2e9a" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">根据对问题的描述判断，这听起来类似于在TCP连接建立期间TCP完整连接队列(或接受队列，将在后面讨论)已满的情况。为了证实这一点，我通过netstat-s | egrep“listen”检查了队列的溢出统计数据。</p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="e44d" class="lp kd hu ll b fv lq lr l ls lt">667399 times the listen queue of a socket overflowed</span></pre><p id="f4e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查了三遍，发现数值在不断增加。很明显，服务器上的接受队列已经溢出。</p><p id="66f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后就可以看到操作系统是如何处理溢出的。</p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="cbb7" class="lp kd hu ll b fv lq lr l ls lt"># cat /proc/sys/net/ipv4/tcp_abort_on_overflow<br/>0</span></pre><p id="604d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在tcp_abort_on_overflow为0的情况下，如果在三次握手的第三步中接受队列已满，则服务器会丢弃客户端发送的ACK包，因为它认为服务器端尚未建立连接。</p><p id="94f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了证明该异常与完整的连接队列相关，我首先将tcp_abort_on_overflow更改为1。如果在第三步中整个连接队列已满，服务器将向客户端发送一个重置数据包，指示它应该结束握手过程和连接。(连接实际上没有在服务器端建立。)</p><p id="e65f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我继续进行测试，发现客户机中有许多“由对等体重置连接”的异常。我们得出的结论是，整个连接队列的溢出反过来导致了客户端错误，这有助于我们快速识别问题的关键部分。</p><p id="3ebf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开发团队查看了Java源代码，发现socket backlog的默认值是50(这个值控制着完整连接队列的大小，后面会详细介绍)。我增加了该值并再次运行，在超过12小时的压力测试后，我注意到错误不再出现，溢出也没有增加。</p><p id="8dcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，就这么简单。在发生TCP三次握手之后，有一个完整的连接队列溢出，只有在进入这个队列之后，服务器才能从Listen变为accept。backlog的默认值是50，很容易溢出。如果溢出，在握手的第三步，服务器忽略客户端发送的ACK包。服务器将定期重复第二步(向客户端发送SYN-ACK包)。如果连接没有排队，将导致异常。</p><p id="3eab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是尽管我们已经解决了问题，我仍然不满意。我想把整个遭遇作为一次学习经历，所以我进一步研究了这个问题。</p><h1 id="ad8e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">深入研究:TCP握手过程和队列</h1><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lu"><img src="../Images/3e198ea1ad70bf5d8944e5b62ae11760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YY4Dty28hdCV5p_h9SX5pg.jpeg"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">(Source: <a class="ae lv" href="http://www.cnxct.com/something-about-phpfpm-s-backlog/" rel="noopener ugc nofollow" target="_blank">http://www.cnxct.com/something-about-phpfpm-s-backlog/</a>)</figcaption></figure><p id="0aa8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如上所示，有两个队列:一个SYN队列(或不完整连接队列)和一个接受队列(或完整连接队列)。</p><p id="4d0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在三次握手中，从客户端接收到SYN数据包后，服务器将连接信息放入SYN队列，并将SYN-ACK数据包发送回客户端。</p><p id="8ed0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，服务器从客户端接收ACK数据包。如果接受队列未满，您应该从SYN队列中移除信息并将其放入接受队列，或者按照tcp_abort_on_overflow的指示执行。</p><p id="d068" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，如果接受队列已满，tcp_abort_on_overflow为0，服务器在一定时间后再次向客户端发送SYN-ACK包(换句话说，重复握手的第二步)。如果客户端经历了很短的超时，就很容易遇到客户端异常。</p><p id="68b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的操作系统中，第二步默认重试两次(CentOS为五次)。</p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="4d8c" class="lp kd hu ll b fv lq lr l ls lt">net.ipv4.tcp_synack_retries = 2</span></pre><h1 id="19bc" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">新方法</h1><p id="7484" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">上面详述的解决方案有点令人困惑，您可能想知道是否有更快或更简单的方法来解决这些问题。让我们先来看看一些有用的命令。</p><h2 id="a1af" class="lp kd hu bd ke lw lx ly ki lz ma mb km jc mc md kq jg me mf ku jk mg mh ky mi dt translated">命令</h2><p id="4879" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated"><strong class="it hv">netstat–s</strong></p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="8a79" class="lp kd hu ll b fv lq lr l ls lt">[root@server ~]#  netstat -s | egrep "listen|LISTEN" <br/>667399 times the listen queue of a socket overflowed<br/>667399 SYNs to LISTEN sockets ignored</span></pre><p id="53fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，这里的667399表示接受队列溢出的次数。每隔几秒钟执行一次这个命令，如果数量增加，接受队列一定是满的。</p><p id="9ed5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">近卫军命令</strong></p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="0e7e" class="lp kd hu ll b fv lq lr l ls lt">[root@server ~]# ss -lnt<br/>Recv-Q Send-Q Local Address:Port  Peer Address:Port <br/>0        50               *:3306             *:*</span></pre><p id="8be8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，第二列中的Send-Q值为50，表示监听端口(第三列)上的接受队列最多为50。第一列Recv-Q表示当前正在使用的接受队列的数量。</p><p id="7c76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接受队列的大小取决于分钟数(backlog，somaxconn)。在建立通讯端时会传入backlog，而somaxconn是OS层级的系统参数。</p><p id="d689" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我们可以与我们的代码建立联系。例如，当Java创建ServerSocket时，它将允许您传入积压的值。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mj"><img src="../Images/305ab3fd24fa521de7e39a5d56740077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ME7eJr48QTS76gQBUjPqGg.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">(Source: <a class="ae lv" href="https://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html" rel="noopener ugc nofollow" target="_blank">https://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html</a>)</figcaption></figure><p id="5c1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SYN队列的大小取决于max(64，/proc/sys/net/IP v4/TCP _ max _ SYN _ backlog)，不同版本的OSs可能不同。</p><p id="995c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> netstat命令</strong></p><p id="1f9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Send-Q和Recv-Q也可以通过netstat命令显示，就像使用ss命令一样。但是，如果连接未处于“监听”状态，Recv-Q表示接收到的数据仍在缓存中，进程尚未读取。此值表示进程尚未读取的字节数。Send是发送队列中未被远程主机确认的字节数。</p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="6225" class="lp kd hu ll b fv lq lr l ls lt">$netstat -tn  <br/>Active Internet connections (w/o servers)<br/>Proto Recv-Q Send-Q Local Address   Foreign Address State  <br/>tcp0  0 100.81.180.187:8182  10.183.199.10:15260 SYN_RECV   <br/>tcp0  0 100.81.180.187:43511 10.137.67.18:19796  TIME_WAIT   <br/>tcp0  0 100.81.180.187:2376  100.81.183.84:42459 ESTABLISHED</span></pre><p id="9f11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的是，netstat -tn显示的Recv-Q数据与接受队列或SYN队列无关。这里必须强调这一点，以免与ss -lnt显示的Recv-Q数据混淆。</p><p id="777c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，下面的netstat -t看到Recv-Q积累了大量数据，这通常是由CPU处理失败引起的。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mk"><img src="../Images/e33bfcc68108fc71fcc4acc1ca7e87d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrhag3S1s32wki64T8E5LQ.png"/></div></div></figure><h2 id="1263" class="lp kd hu bd ke lw lx ly ki lz ma mb km jc mc md kq jg me mf ku jk mg mh ky mi dt translated">核查进程</h2><p id="5896" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">要验证上述详细信息，请将Java中的backlog值更改为10(值越小，溢出越容易)，然后继续运行压力测试。然后，客户端开始报告异常，之后可以通过服务器上的ss命令观察到以下情况。</p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="8e34" class="lp kd hu ll b fv lq lr l ls lt">Fri May  5 13:50:23 CST 2017<br/>Recv-Q Send-QLocal Address:Port  Peer Address:Port<br/>11         10         *:3306               *:*</span></pre><p id="3be3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们可以看到，端口3306上的服务接受队列最多为10，但现在队列中有11个连接。必须有一个无法排队且将溢出的队列。与此同时，溢出的值确实在不断增加。</p><h2 id="6ae3" class="lp kd hu bd ke lw lx ly ki lz ma mb km jc mc md kq jg me mf ku jk mg mh ky mi dt translated">在Tomcat和Nginx中接受队列大小</h2><p id="8db0" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">Tomcat默认为临时连接。在Ali-Tomcat中，积压的默认值(在Tomcat中是“接受计数”)是200。在Apache Tomcat中，这个数字是100。</p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="f4fe" class="lp kd hu ll b fv lq lr l ls lt">#ss -lnt<br/>Recv-Q Send-Q   Local Address:Port Peer Address:Port<br/>0       100                 *:8080            *:*</span></pre><p id="d4df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Nginx中，待定项的默认值为511。</p><pre class="jr js jt ju fq lk ll lm ln aw lo dt"><span id="6fc4" class="lp kd hu ll b fv lq lr l ls lt">$sudo ss -lnt<br/>State  Recv-Q Send-Q Local Address:PortPeer Address:Port<br/>LISTEN    0     511              *:8085           *:*<br/>LISTEN    0     511              *:8085           *:*</span></pre><p id="df41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Nginx以多进程模式运行，因此有多个数字8085，这意味着多个进程都在监听同一个端口，以避免上下文切换并提高性能。</p><h1 id="49b1" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">摘要</h1><p id="980a" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">一旦发生溢出，CPU和线程的状态就会正常，但压力不会上升。从客户端的角度来看，响应时间(网络+队列+服务时间)很长，但考虑到服务器日志中的真正服务时间，实际上非常短。在JDK和Netty等一些框架中，积压的默认值很小，在某些情况下可能会导致性能问题。</p><p id="a685" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这篇文章能够帮助您理解SYN队列和accept队列在建立TCP连接中的概念、原理和功能。接受队列和SYN队列的溢出问题很容易被忽略，但它很关键，尤其是在使用瞬时连接的场景中(比如Nginx和PHP，尽管它们也支持持久连接)。</p><p id="7e3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">(Original article by Ren Xijun任喜军)</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><h1 id="941b" class="kc kd hu bd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae lv" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">“阿里巴巴科技”</strong> </a>。推特:<a class="ae lv" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">【阿里巴巴技术】</strong> </a>。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><h1 id="090f" class="kc kd hu bd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz dt translated">参考</h1><p id="7d8e" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated"><a class="ae lv" href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html" rel="noopener ugc nofollow" target="_blank">http://veithen . github . io/2014/01/01/how-TCP-backlog-works-in-Linux . html</a></p><p id="39b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lv" href="http://www.cnblogs.com/zengkefu/p/5606696.html" rel="noopener ugc nofollow" target="_blank">http://www.cnblogs.com/zengkefu/p/5606696.html</a></p><p id="1d5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lv" href="http://www.cnxct.com/something-about-phpfpm-s-backlog/" rel="noopener ugc nofollow" target="_blank">http://www.cnxct.com/something-about-phpfpm-s-backlog/</a></p><p id="3ef2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lv" href="http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" rel="noopener ugc nofollow" target="_blank">http://jaseywang . me/2014/07/20/TCP-queue-% E7 % 9A % 84% E4 % B8 % 80% E4 % BA % 9B % E9 % 97% AE % E9 % A2 % 98/</a></p><p id="d0bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lv" href="http://jin-yang.github.io/blog/network-synack-queue.html" rel="noopener ugc nofollow" target="_blank">http://jin-yang.github.io/blog/network-synack-queue.html#</a></p><p id="4604" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae lv" href="http://blog.chinaunix.net/uid-20662820-id-4154399.html" rel="noopener ugc nofollow" target="_blank">http://blog.chinaunix.net/uid-20662820-id-4154399.html</a></p></div></div>    
</body>
</html>