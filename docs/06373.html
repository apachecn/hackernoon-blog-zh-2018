<html>
<head>
<title>Log evasion: Log me if You can!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日志规避:如果你能，记录我！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/log-evasion-log-me-if-you-can-51a3b7fc1770?source=collection_archive---------24-----------------------#2018-07-31">https://medium.com/hackernoon/log-evasion-log-me-if-you-can-51a3b7fc1770?source=collection_archive---------24-----------------------#2018-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/799d71f851353fede34705f741ff5d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*OTZKi1jyp3vQLFB9__5cOQ.png"/></div></figure><p id="8d0f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">关于日志记录，有不同的方法:尽可能详细地记录每个输入，或者在保存之前清理日志事件和用户输入。这两种方法各有利弊。无论您选择哪种方法，在分析这些日志事件时记住您的选择是很重要的。仅仅..路上不要有任何意外。</p><p id="c3e6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我将尝试用下面的AWS S3服务器访问日志例子来说明我的观点。尽管我带来了一个基于S3的例子，但是请记住，还有其他应用服务器具有类似的“日志记录特性”。因此，请确保您对您的系统如何处理事件日志有一个很好的了解。</p><h1 id="ca10" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">序言</h1><ol class=""><li id="6d34" class="ku kv hu ja b jb kw jf kx jj ky jn kz jr la jv lb lc ld le dt translated">我创建了我的S3桶并启用了服务器访问日志记录。可以参考<a class="ae lf" href="https://docs.aws.amazon.com/AmazonS3/latest/user-guide/server-access-logging.html" rel="noopener ugc nofollow" target="_blank">亚马逊的教程</a>。</li><li id="5ef0" class="ku kv hu ja b jb lg jf lh jj li jn lj jr lk jv lb lc ld le dt translated">为了分析S3访问日志，我将日志文件下载到我的本地存储库中，并使用GNU命令行工具来分析事件。为了获取日志文件，我写了一个<a class="ae lf" href="https://bitbucket.org/tiitha/poc-ruby/src/master/aws_logs.rb" rel="noopener ugc nofollow" target="_blank"> ruby脚本</a>，搜索新的日志文件，并通过<a class="ae lf" href="https://docs.aws.amazon.com/AmazonS3/latest/API/Welcome.html" rel="noopener ugc nofollow" target="_blank"> AWS S3 REST API </a>下载它们。</li><li id="d322" class="ku kv hu ja b jb lg jf lh jj li jn lj jr lk jv lb lc ld le dt translated">我已经上传了两个文件到bucket:public . txt是一个公开的文档，semi.txt是一个不与所有人共享的文档。这对理解后面的例子很重要。</li><li id="7156" class="ku kv hu ja b jb lg jf lh jj li jn lj jr lk jv lb lc ld le dt translated">请记住，这只是一个演示，而不是一个简单的攻击载体。</li></ol><h1 id="86d0" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">记录事件</h1><p id="b32f" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv hn dt translated">AWS S3服务器访问日志格式与Apache web服务器访问日志非常相似。其中一个重要的区别是<strong class="ja hv"> AWS S3服务器访问日志被保存为原始数据</strong>！在将事件保存到日志文件之前，不会进行数据验证，也不会对不可打印的符号进行转义。这不是一个错误，但是在以后分析日志文件或者选择日志分析工具时，这是一个需要记住的重要方面。如果您的日志包含未转义的原始数据，那么您的分析工具必须准备好应对恶意内容或针对日志的攻击。</p><h1 id="97ba" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">等待..有什么好大惊小怪的？</h1><p id="9f4e" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv hn dt translated">我来举几个例子解释一下。当从AWS S3存储桶请求文件时，HTTP GET请求被发送到AWS，文件的内容将被返回，事件将被记录到服务器访问日志中。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="b57f" class="ly jx hu lu b fv lz ma l mb mc">GET /<em class="ll">&lt;bucket_name&gt;</em>/public.txt HTTP/1.1<br/>Host: s3.eu-central-1.amazonaws.com<br/>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 TESTIME Firefox/61.0</span></pre><p id="cd1d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">将被写入日志事件如下:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="2191" class="ly jx hu lu b fv lz ma l mb mc"><em class="ll">&lt;bucket_owner&gt; &lt;bucket_name&gt;</em> [30/Jul/2018:17:16:55 +0000] 328.496.13.534 — <em class="ll">&lt;request_id&gt;</em> REST.GET.OBJECT public.txt "GET /<em class="ll">&lt;bucket_name&gt;</em>/public.txt HTTP/1.1" 200 – 19 19 7 7 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 TESTIME Firefox/61.0" -</span></pre><p id="121a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">到目前为止一切顺利。但是正如我提到的，在AWS S3日志中，不可打印的字符没有被转义。这意味着当使用命令行工具分析日志时，您必须记住，不可打印的符号可能会被解释为转义序列，并且屏幕上的事件可能不会像写入文件时那样。这可能会在查看日志文件时造成混乱。让我们通过提出另一个请求来说明这一点。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="5ad9" class="ly jx hu lu b fv lz ma l mb mc">GET /<em class="ll">&lt;bucket_name&gt;</em>/public.txt?a=<em class="ll">&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;&lt;08&gt;</em>semi.txt HTTP/1.1<br/>Host: s3.eu-central-1.amazonaws.com<br/>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 TESTIME Firefox/61.0</span></pre><p id="e9c5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请求中的<em class="ll"> &lt; 08 &gt; </em>字符是十六进制表示退格的<a class="ae lf" href="https://www.asciitable.com" rel="noopener ugc nofollow" target="_blank"> ascii符号</a>。文件仍然像以前一样被返回。屏幕上日志事件中的日志事件有些不同</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff md"><img src="../Images/d5f23321bb6a867df2a5d868369cb1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5LuTBVJZuE_QtYwsn2Yhg.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Log event for the unescaped backspaces</figcaption></figure><p id="e7a6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">由于应用程序服务器在将事件写入日志文件之前没有退出退格键，终端将其解释为一个命令，并从显示中删除了13个字符。理解这一点很重要:删除只发生在屏幕上<strong class="ja hv">:日志文件仍然包含原始文本和反斜杠字符。终端从您的视图中删除了字符。相同的文件与'六'或十六进制编辑器将揭示真相</strong></p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mm"><img src="../Images/91d85ce49f29de0d74a0b5f3d0d3bd5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jq1X5H6qS-qgYBPlyvgtCA.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Log event seen in VI</figcaption></figure><p id="6b30" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用“grep”时，情况可能会更加混乱。</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mn"><img src="../Images/b3a3387a3c7f624f4fc278ea25319d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_g9LqhB1x1pQ_FtPEgYPWA.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Grepping the unescaped characters</figcaption></figure><p id="4a67" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如您所见，我标记了参数名称，当显示在屏幕上时，该名称将被删除。想象一下，当您在事故中偶然发现这类事件时:窃取实际上并不存在的东西(例如用户名或其他用户输入值)。</p><h1 id="7fb5" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">退格..就这样吗？</h1><p id="8a6e" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv hn dt translated">不完全是。用ASCII字符毒害日志文件并不是破坏命令行日志分析的唯一可能性。另一种方法是使用<a class="ae lf" href="http://ascii-table.com/ansi-escape-sequences-vt-100.php" rel="noopener ugc nofollow" target="_blank"> ANSI转义序列</a>。您可能已经使用这些转义序列和颜色代码为您的终端创建了您喜欢的CLI屏幕。这里也可以应用相同的方法。想象一个如下的请求:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="f96c" class="ly jx hu lu b fv lz ma l mb mc">GET /<em class="ll">&lt;bucket_name&gt;</em>/public.txt HTTP/1.1<br/>Host: s3.eu-central-1.amazonaws.com<br/>User-Agent: <strong class="lu hv">&lt;<em class="ll">1b</em>&gt;[31;49m</strong>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 TESTIME Firefox/61.0<strong class="lu hv"><em class="ll">&lt;1b&gt;</em>[0;49m</strong></span></pre><p id="d1e4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">查看用户代理前后的转义码，其中<em class="ll"> &lt; 1b &gt; </em>是转义码的十六进制表示。当抓取日志时，您会在屏幕上看到以下输出</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mo"><img src="../Images/a98a5cc58d8a2dabe5b1b3fd926aa7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*weHVvMM84Tnu8-Ob_ss0uw.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Coloured events</figcaption></figure><h2 id="567f" class="ly jx hu bd jy mp mq mr kc ms mt mu kg jj mv mw kk jn mx my ko jr mz na ks nb dt translated">好吧，呜哇杜:给提示着色。就这样吗？</h2><p id="6ae6" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv hn dt translated">不完全是。ANSI转义序列允许你做更多的事情，而不仅仅是给终端中的字符着色。日志文件中的代码可以在屏幕上重新定位你的光标，重新配置你的终端设置，以及用它做许多其他“有趣”的事情。回到日志回避，考虑下面的请求:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="6be8" class="ly jx hu lu b fv lz ma l mb mc">GET /<em class="ll">&lt;bucket_name&gt;</em>/public.txt HTTP/1.1<br/>Host: s3.eu-central-1.amazonaws.com<br/>User-Agent: &lt;<em class="ll">1b</em>&gt;[21D401<em class="ll">&lt;1b&gt;</em>[18CMozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 TESTIME Firefox/61.0</span></pre><p id="4782" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">转义序列是指“<em class="ll">左移21位，写</em><strong class="ja hv"><em class="ll">401</em></strong><em class="ll">，右移18位</em>”。或者换句话说:更改响应代码。</p><figure class="lp lq lr ls fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mm"><img src="../Images/f00a0e4efdae5248217e5dc1a80747cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wcmx69nbD4HxDLeqziQNYw.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Response changed with escape sequence</figcaption></figure><p id="b92b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当浏览您的日志时，您可能会发现自己对结果很满意，所有的请求都用<em class="ll"> HTTP-40x </em>进行了响应。想象一下当对手告诉你他确实看到了文件时会有多惊讶。</p><p id="e932" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">或者，如果对手将转义序列<strong class="ja hv"><em class="ll">&lt;1b&gt;【2A</em></strong>("<em class="ll">将光标上移两行"</em>)附加到用户代理头值，光标将指向日志事件的开头，从而用下一个事件覆盖该事件。或者换句话说:当使用像'<em class="ll"> cat </em>或'<em class="ll"> more </em>'这样的GNU命令行工具时，您的日志事件将被隐藏起来。这些只是几个例子，展示了在分析日志时要考虑什么。</p><h1 id="ec84" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">我现在该怎么办？</h1><p id="f0b9" class="pw-post-body-paragraph iy iz hu ja b jb kw jd je jf kx jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv hn dt translated">输入验证总是很重要的！不仅在编写应用程序时，而且在记录应用程序行为时也是如此。在我带来的例子中，如果您在记录日志事件时或者在将日志事件加载到您的分析环境时进行验证，这主要是一个品味问题。请记住，您必须在某个地方完成它，并分别设计日志分析环境的其余部分。</p><p id="9168" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这两种方法都有优点和缺点，例如，当有人试图用意想不到的输入来毒害您的日志时，理解这一点是很有用的。无论如何——不要以原始格式保存数据，您可以考虑对不可打印的符号进行转义，不列入白名单或忽略它们。</p><p id="15a9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不时地从您的日志中搜索这种不可打印的符号也将是有益的，以查看是否有人试图逃避您的日志系统。</p></div></div>    
</body>
</html>