<html>
<head>
<title>Midas Open Sources its Service Discovery Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Midas开源其服务发现库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/midas-open-sources-its-service-discovery-library-6796c57053e2?source=collection_archive---------36-----------------------#2018-07-31">https://medium.com/hackernoon/midas-open-sources-its-service-discovery-library-6796c57053e2?source=collection_archive---------36-----------------------#2018-07-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/1ff4d54601771e89ea99006f6db8f9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*1sk8Py7s1adAMOsqUMXObg.png"/></div></figure><div class=""/><p id="272f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们的大部分代码目前运行在<a class="ae jw" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>上。在推广微服务架构的过程中，我们和其他许多人一样，很快就面临了服务发现的问题。当其他人也面临这些问题时，你可能会认为用你选择的搜索引擎搜索<code class="eh jx jy jz ka b">aws service discovery</code>会给你很多好的解决方案。嗯，我们很失望。这就是为什么我们编写了我们自己的服务发现库，并以开源为荣。这篇文章解释了动机和为什么我们认为我们的方法实际上是最好的。</p><h2 id="fdb1" class="kb kc ib bd kd ke kf kg kh ki kj kk kl jj km kn ko jn kp kq kr jr ks kt ku kv dt translated">找到真相的唯一点</h2><p id="83fc" class="pw-post-body-paragraph iy iz ib ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">服务发现的核心是向单一事实点提出正确的问题。了解您的所有服务以及如何获得这些服务的点。让我们考虑几个显而易见的解决方案。</p><p id="5c19" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一步是宣布网络本身为单点真理。您可以使用一种通常涉及发送多播或广播消息的协议。由于AWS VPC不支持这些功能，因此我们的用例排除了这种可能性。</p><p id="7089" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第二个选择是建立一个额外的服务，像<a class="ae jw" href="https://zookeeper.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Zookeeper </a>，你的服务在启动时注册。发现一个服务只是对这个附加服务的一个查询。但是等等，你原来的服务是怎么知道Zookeeper在哪里的？我们在这里面对的是一个古老的好问题:先有鸡还是先有蛋。虽然肯定有办法解决这个问题，但它们并不能让我们满意。此外，Zookeeper成为该解决方案中的单点故障。</p><p id="3621" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在AWS领域，还有第三种选择:使用AWS本身进行服务发现。AWS实际上是<em class="lb">知道你的哪个服务/机器/lambdas/你的名字-它正在运行的唯一事实点。有了<a class="ae jw" href="https://aws.amazon.com/sdk-for-java/" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>，我们可以轻松地询问如何到达这些实例。此外，不存在单点故障。当然，AWS可能会停机(或者至少是它们的API查询端点)。但是不管怎样，我们可能不得不逃到另一个地区。</em></p><p id="9097" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">虽然仔细想想这个解决方案似乎很明显。你很难在栈溢出文献中找到这个建议。</p><h2 id="9720" class="kb kc ib bd kd ke kf kg kh ki kj kk kl jj km kn ko jn kp kq kr jr ks kt ku kv dt translated">配置地狱</h2><p id="7905" class="pw-post-body-paragraph iy iz ib ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">所以我们的想法是围绕AWS SDK写一个薄薄的层。但是我们应该如何向我们的客户公开这个功能呢？一个好的API总是好的，但是当涉及到服务发现的时候就不是很有用了。您通常不希望在代码中直接硬编码带有所有过滤器的组件。您的发现在您的本地开发环境中可能与在您的CI测试环境中非常不同。这反过来又不同于筹备和生产。</p><p id="80b8" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，服务发现本身应该可以通过一个简单的配置文件进行配置。现在，配置语法通常会以某种方式出错。除非您自己是库的维护者，否则您要么有太多的选项使整个东西不可用。或者你只有少数几个选项，可以让你很容易地完成简单的任务，但是一旦它变得更复杂，库就会达到极限。</p><p id="3377" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">服务发现尤其棘手。您需要某种特定于领域的语言(DSL ),这种语言使得定义您想要发现的对象、它们应该满足的约束以及您实际需要的对象的属性变得容易。不管怎样，开发好的DSL是一项艰巨的任务。所以我们四处寻找现有的解决方案来填补这个空白。我们找到的答案可能会令人惊讶:<a class="ae jw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>。</p><p id="829d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">GraphQL最初由脸书开发，并于2015年公开发布。大量语言有几种实现Scala有<a class="ae jw" href="https://sangria-graphql.org/" rel="noopener ugc nofollow" target="_blank"> Sangria </a>。GraphQL是一种简单的查询语言，倾向于JSON风格的语法。在开发HTTP APIs时，您可能更愿意将它作为REST的替代方案。我们用它来做不同的事情。</p><h2 id="d5ec" class="kb kc ib bd kd ke kf kg kh ki kj kk kl jj km kn ko jn kp kq kr jr ks kt ku kv dt translated">请举例！</h2><p id="cfe5" class="pw-post-body-paragraph iy iz ib ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">为了了解GraphQL是如何工作的，让我们直接看一个例子。假设您想要发现EC2实例及其id和私有IP地址:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="3868" class="kb kc ib ka b fv lk ll l lm ln">query {<br/>    ec2Instances {<br/>        id<br/>        privateIpAddress<br/>    }<br/>}</span></pre><p id="0b34" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这一切都非常清楚明了。JSON格式的答案如下所示:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="ea8d" class="kb kc ib ka b fv lk ll l lm ln">{<br/>    "data" : {<br/>        "ec2Instances" : [<br/>            {<br/>                "id" : "i-5bc9450cebf76ff90",<br/>                "privateIpAddress" : "172.18.42.252"<br/>            },<br/>            {<br/>                "id" : "i-48eb0089ee2cf0324",<br/>                "privateIpAddress" : "172.18.17.226"<br/>            },<br/>            {<br/>                "id" : "i-f54ee382cf9e1f773",<br/>                "privateIpAddress" : "172.12.57.132"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="8101" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看看如何只返回我们请求的属性(即<code class="eh jx jy jz ka b">id</code>和<code class="eh jx jy jz ka b">privateIpAddress</code>)?这实际上是GraphQL的突出特点和优雅之处。</p><p id="68a5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">添加一个过滤器怎么样，因为您只想要名为<code class="eh jx jy jz ka b">midas-rocks</code>和<code class="eh jx jy jz ka b">midas-is-awsome</code>的机器:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="5293" class="kb kc ib ka b fv lk ll l lm ln">query {<br/>    ec2Instances(<br/>        filters: [{<br/>            name: "tag:Name",<br/>            values: ["midas-rocks", "midas-is-awsome"]<br/>        }]<br/>    ) {<br/>        id<br/>        privateIpAddress<br/>    }<br/>}</span></pre><p id="0eaf" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这不会变得太复杂，对吧？过滤器被简单地映射到<a class="ae jw" href="http://aws-java-sdk-javadoc.s3-website-us-west-2.amazonaws.com/latest/software/amazon/awssdk/services/ec2/model/Filter.html" rel="noopener ugc nofollow" target="_blank"> AWS的过滤器</a>参数。因此，你实际上可以使用所有的<a class="ae jw" href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html" rel="noopener ugc nofollow" target="_blank">过滤器</a>。该查询的输出将类似于上面列出的输出，但是只包含具有正确名称的机器。</p><p id="3ae7" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，对于更复杂的东西:ECS。如果您想发现您的服务在ECS上的什么地方运行，您必须发现它运行的EC2实例。(不知道这是否会随着Fargate而改变。)要获得属于ECS集群的所有EC2实例，您可以使用:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="58e7" class="kb kc ib ka b fv lk ll l lm ln">query {<br/>    ecsClusters {<br/>        tasks {<br/>            containerInstance {<br/>                ec2Instance {<br/>                    privateIpAddress<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="e1d5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样，几乎每个查询级别都有一个过滤器。例如，如果您只想获取ARN以<code class="eh jx jy jz ka b">cluster/my-test-cluster</code>结尾的集群，而在这个集群中，您只想运行属于<code class="eh jx jy jz ka b">foobar</code>家族的任务的实例:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="3a66" class="kb kc ib ka b fv lk ll l lm ln">query {<br/>    ecsClusters(filterArn: ".*cluster/my-test-cluster") {<br/>        tasks(family: "foobar") {<br/>            // ...<br/>        }<br/>    }<br/>}</span></pre><p id="1450" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">前一个查询将产生如下结果:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="5bed" class="kb kc ib ka b fv lk ll l lm ln">{<br/>  "data" : {<br/>    "ecsClusters" : [<br/>      {<br/>        "tasks" : [<br/>          {<br/>            "containerInstance" : {<br/>              "ec2Instance" : {<br/>                "privateIpAddress" : "172.18.42.252"<br/>              }<br/>            }<br/>          },<br/>          {<br/>            "containerInstance" : {<br/>              "ec2Instance" : {<br/>                "privateIpAddress" : "172.18.17.226"<br/>              }<br/>            }<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="9bb9" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里事情变得有点复杂，如果你想从这个例子中提取有趣的部分，需要做很多工作。此外，如上所述，查询将在配置文件中定义。所以，在你的代码中，你没有任何线索来映射到这个结构中，以便得到有趣的部分。这就是提取者进入游戏的地方。</p><p id="7e2a" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">提取器挂钩到Sangrias <a class="ae jw" href="https://sangria-graphql.org/learn/#query-reducers" rel="noopener ugc nofollow" target="_blank">查询缩减器</a>机制，该机制提供了一种在早期准备步骤中遍历查询的方法。我们使用它来生成一个定制的查询函数，该函数只从查询结果中提取字段。让我们看看它是如何交互工作的:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="d503" class="kb kc ib ka b fv lk ll l lm ln">scala&gt; import scala.concurrent.Await<br/>scala&gt; import scala.concurrent.duration._<br/>scala&gt; import scala.concurrent.ExecutionContext.Implicits.global<br/>scala&gt; import sangria.macros._<br/>scala&gt; val query = graphql"""<br/>     | query {<br/>     |   ecsClusters {<br/>     |     tasks {<br/>     |       containerInstance {<br/>     |         ec2Instance {<br/>     |           privateIpAddress<br/>     |         }<br/>     |       }<br/>     |     }<br/>     |   }<br/>     | }<br/>     | """<br/>query: sangria.ast.Document = // [...]<br/><br/>scala&gt; import social.midas.discovery.common<br/>scala&gt; val fut = common.prepareQuery(<br/>     |   query, extractors=List(common.Ip4Extractor),<br/>     | )<br/>fut: scala.concurrent.Future // [...]<br/><br/>scala&gt; val prepared = Await.result(fut, 10.seconds)<br/>prepared: sangria.execution.PreparedQuery // [...]<br/><br/>scala&gt; val extractor = prepared.userContext.extractor.get<br/>extractor: Any =&gt; Seq[Any] = // [...]<br/><br/>scala&gt; val result = Await.result(prepared.execute(), 10.seconds)<br/>result: Any = // [...]<br/><br/>scala&gt; extractor(result).asInstanceOf[Seq[String]]<br/>res0: Seq[String] = Vector(172.18.42.252, 172.18.17.226)</span></pre><h2 id="526d" class="kb kc ib bd kd ke kf kg kh ki kj kk kl jj km kn ko jn kp kq kr jr ks kt ku kv dt translated">“哥们，这太复杂了！”</h2><p id="e97c" class="pw-post-body-paragraph iy iz ib ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">当然，这太复杂了。因此有一个总体总结函数，它从配置文件中读取查询和提取器，并在一个<code class="eh jx jy jz ka b">Future</code>中交付最终结果:</p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="9bb0" class="kb kc ib ka b fv lk ll l lm ln">scala&gt; Await.result(common.discoverFromConfig(), 2.seconds)<br/>     | .asInstanceOf[Seq[String]]<br/>res3: Seq[String] = Vector(172.18.42.252, 172.18.17.226)</span></pre><p id="cc9f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们使用Lightbend 的<a class="ae jw" href="https://github.com/lightbend/config" rel="noopener ugc nofollow" target="_blank">配置库。配置文件如下所示:</a></p><pre class="lc ld le lf fq lg ka lh li aw lj dt"><span id="bbc3" class="kb kc ib ka b fv lk ll l lm ln">discovery.aws.region = "eu-central-1"<br/>discovery.extractors = [ "social.midas.discovery.common.Ip4Extractor$" ]<br/>discovery.query = """<br/>query {<br/>  ecsClusters {<br/>    tasks {<br/>      containerInstance {<br/>        ec2Instance {<br/>          privateIpAddress<br/>        }<br/>      }<br/>    }<br/>  }<br/>}<br/>"""</span></pre><p id="0d4f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们的主例程中，我们简单地调用<code class="eh jx jy jz ka b">discoverFromConfig</code>并获取作为ECS集群一部分的EC2实例的所有IP地址。</p><h2 id="09e6" class="kb kc ib bd kd ke kf kg kh ki kj kk kl jj km kn ko jn kp kq kr jr ks kt ku kv dt translated">它是什么，不是什么。</h2><p id="a261" class="pw-post-body-paragraph iy iz ib ja b jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr la jt ju jv hn dt translated">不要期望一个完全成熟的库会在AWS上发现所有类型的服务！在撰写本文时，这个库只支持在EC2和ECS上发现IP4地址。然而，它正在大力发展。虽然我们不指望API会有显著的变化，但肯定有改进的空间。主要是你可以预期发现服务和提取器在不久的将来会快速增长。</p><p id="f0cc" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">毕竟，我们开源这个软件是为了得到你的反馈。我们认为将AWS SDK包装在GraphQL等查询语言中的建议解决方案在服务发现任务方面非常优秀。告诉我们你对它的看法。我们希望收到您的来信！</p><figure class="lc ld le lf fq hw"><div class="bz el l di"><div class="lo lp l"/></div></figure></div></div>    
</body>
</html>