<html>
<head>
<title>Making the Most of Flutter: From Basics to Customization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">充分利用Flutter:从基础到定制</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-the-most-of-flutter-from-basics-to-customization-433171581d01?source=collection_archive---------2-----------------------#2018-08-01">https://medium.com/hackernoon/making-the-most-of-flutter-from-basics-to-customization-433171581d01?source=collection_archive---------2-----------------------#2018-08-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="96f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开源SDK Flutter为开发人员提供了一种为Android和iOS应用程序轻松部署定制用户界面的方式——只要你知道如何优化它的功能。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/229eb85557b22ba02dcdf67a65324958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avadfL55qX0ij0TqTkqKVQ.jpeg"/></div></div></figure><p id="1c1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">本文是阿里巴巴</em> <a class="ae kc" rel="noopener" href="/@alitech_2017/utilizing-flutter-best-practice-from-alibaba-236a53aa32c8"> <strong class="it hv"> <em class="jp">利用旋舞</em> </strong> </a> <em class="jp">系列的一部分。</em></p><p id="fbca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于开发者来说，像谷歌的Flutter这样的软件开发工具包提供了一种构建原生Android和iOS移动界面的方法，同时避免了许多相关的负担，包括纯粹的时间需求。尽管如此，一些人可能会想知道Flutter项目与纯Android或iOS项目有何不同，例如它们的渲染或事件交付机制，或者它们如何让开发人员在建设停滞时修改错误并实施项目。</p><p id="ca68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了帮助解决这些问题，并阐明其工作方式，阿里巴巴今天从全球视角看待Flutter，使用“hello_flutter”示例项目。接下来的部分将首先介绍Flutter的原理，然后讨论定制和优化功能，以及有兴趣探索Flutter的开发人员可以遵循的具体步骤。</p><h1 id="50e2" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">颤振的基本原理</h1><h2 id="e7b1" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">体系结构</h2><p id="a54a" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">作为一个程序，Flutter的架构建立在三个不同的层面上:框架、引擎和嵌入器。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lu"><img src="../Images/d2a8660bff0055dfdd7b0a576e228f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXUhqyod87IqP0pVXPVjhg.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Overview of Flutter’s architecture</figcaption></figure><p id="d3d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter的框架在Dart中实现，包含材质设计风格的小部件、Cupertino风格的小部件(用于iOS)、基于文本/图像/按钮的小部件、渲染、动画、手势等等。这一层的核心代码包括flutter资源库下的flutter包和sky_engine资源库(dart:ui库提供了flutter框架和引擎之间的接口)下的包，如io、async和ui包。</p><p id="ed6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter的引擎是用C++实现的，包括Skia、Dart和Text。Skia是一个开源的2D图形库，它为各种硬件和软件平台提供了一个通用的API。它已经被用作Google Chrome、Chrome OS、Android、Mozilla Firefox、Firefox OS和许多其他产品的图形引擎。支持的平台有Windows7+，macOS 10.10.5+，iOS8+，Android4.1+，Ubuntu14.04+等等。</p><p id="a89c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">引擎的Dart部分主要包括Dart运行时和垃圾收集(GC)。如果Flutter在调试模式下运行，还包括JIT(实时)支持，而在发布和配置文件模式下，dart代码由AOT(提前)编译成本机“arm”代码，因此不存在JIT。文本是指具有以下呈现级别的文本呈现:libtxt库(用于字体选择和分隔线)，派生自minikin和HartBuzz(用于字形选择和整形)。Skia充当渲染后端，在Android和Fuchsia上使用FreeType渲染，在iOS上使用CoreGraphics渲染。<br/> <br/>嵌入器是在各种平台中嵌入Flutter的嵌入层。这里的主要任务是渲染表面设置、线程设置和插件。我们可以看到，与平台相关的Flutter层很少，平台(如iOS)只是提供一个画布，其余的渲染相关逻辑发生在Flutter内部，这有助于实现良好的跨平台一致性。</p><h2 id="959e" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">工程结构</h2><p id="969e" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">本文使用的开发环境是Flutter beta v0.3.1，对应引擎commit : 09d05a389。</p><p id="e926" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于我们简单的“hello_flutter”项目示例，flutter的工程结构如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/4786edbe90380219699b4134eaaf0c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*ZyVnh295B95ZD8IRUziKag.png"/></div></figure><p id="e08c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的例子中，“ios”是iOS的代码，用CocoaPods管理依赖关系，“android”是Android的代码，用Gradle管理依赖关系，“lib”是dart代码，用pub管理依赖关系。类似于iOS中Cocoapods的Podfile和Podfile.lock，pub中对应的是pubspec.yaml和pubspec.lock。</p><h2 id="06da" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">模式</h2><p id="d78f" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">Flutter支持常见的模式，包括调试、发布和概要分析，但是有一些显著的区别。</p><p id="4054" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter的调试模式对应Dart的JIT模式，也称为检查模式或慢速模式，支持iOS和Android的设备和仿真器。在这种模式下，断言功能(包括所有调试信息、服务扩展和调试辅助工具，如“观察站”)被启用。该模式针对快速开发和操作进行了优化，但不针对执行速度、包大小或部署。在这种模式下，编译基于JIT技术，支持流行的亚秒级有状态热重装。</p><p id="c1a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter的发布模式与Dart的AOT模式相对应，后者面向最终用户部署，支持真实机器，但不支持模拟器。在这种模式下，所有断言都被禁用，为了尽可能多地移除调试信息，所有调试工具也被禁用。该模式针对快速启动、快速执行和数据包大小进行了优化，同时禁止所有调试辅助工具和服务扩展。</p><p id="7f9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter的profile模式与它的release模式相似，因为这种模式只增加了对服务扩展和跟踪的支持，并最小化了使用跟踪信息所需的依赖性。例如，“观察台”可以连接到流程。profile模式不支持仿真器的原因是仿真器上的诊断并不代表真实的性能。</p><p id="2e56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于Flutter的profile模式和release模式在编译原理上没有区别，所以本文只讨论它的调试模式和发布模式。</p><p id="236f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，在Flutter中进行的一个iOS或Android项目，仍然是标准的iOS或Android项目。Flutter只通过在BuildPhase添加shell生成并嵌入一个App.framework和Flutter.framework (iOS)并通过Gradle添加flutter.jar和VM/isolate _ snapshot _ data/instr(Android)编译相关代码并嵌入到native app中。因此，本文主要讨论由颤振引入的构造和执行原理。虽然编译目标包括arm、x64、x86、arm64，但是原理都很相似，只讨论与arm相关的原理。(如无特别说明，安卓默认armv7。)</p><h1 id="b60a" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">更深入:iOS的代码编译和执行</h1><h2 id="1593" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">发布模式下的编译</h2><p id="d5e2" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">在发布模式下，Flutter下iOS项目dart代码的构建过程如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ma"><img src="../Images/241e0770eb29fbd5478106e9dcc6c24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUGNe6G8LnwbTS6MMQTELw.png"/></div></div></figure><p id="8d7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在图中，gen_snapshot是Dart编译器，它使用树抖动技术(类似于可以生成最小包的依赖树逻辑，这样Dart支持的反射在Flutter中被禁用)生成汇编形式的机器码，然后通过xcrun等编译工具链生成最终的App.framework。换句话说，对于所有的dart代码，包括业务逻辑代码和第三方包代码，它们所依赖的flutter framework (dart)代码最终都变成了App.framework。</p><p id="2894" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">摇树函数位于gen_snapshot中。要查看相应的逻辑，您可以访问:</p><p id="1b78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">engine/src/third _ party/dart/runtime/VM/compiler/AOT/precompiler . cc</p><p id="9ce8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">dart代码最终对应于App.framework的符号如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mb"><img src="../Images/f3863d6a0ac888668c4c82e22dd677bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIbHiuHtxbvWf7iCVVKDmw.png"/></div></div></figure><p id="e3cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其实类似于Android发布的产品(见下文)，App.framework也包括四个部分:kDartVmSnapshotData、kDartVmSnapshotInstructions、kDartIsolateSnapshotData、kDartIsolateSnapshotInstructions。为什么iOS用App.framework而不是Android的四档？原因是在iOS下，由于系统限制，Flutter引擎无法在运行时将内存页面标记为可执行，而在Android下可以。</p><p id="0904" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter.framework对应于Flutter架构的引擎和嵌入器。实际上，Flutter.framework位于Flutter存储库的/bin/cache/artifacts/engine/IOs *中，默认情况下从Google存储库中拉出。当需要自定义更改时，您可以使用Ninja construction系统通过下载引擎的源代码来生成它。</p><p id="5a45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter相关代码的最终产品是App.framework(由Dart代码生成)和Flutter.framework(引擎)。从Xcode项目来看，Generated.xcconfig描述了flutter相关环境的配置信息，然后在Runner项目设置中新增的Build Phases的xcode_backend.sh实现了复制(从Flutter框架库到Runner项目根目录下的Flutter目录)和嵌入Flutter.framework以及编译嵌入App.framework。</p><p id="e25c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终生成的Runner.app中与颤振相关的产品如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mc"><img src="../Images/2f2c8210012da9f97a94dbadf47e3644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vzUOgLR7yrnQfvXDiWAOA.png"/></div></div></figure><p id="45ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果，flutter_assets是flutter资源，代码是App.framework和Flutter.framework，位于framework目录中。</p><h2 id="0e0c" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">在发布模式下执行</h2><p id="c2b7" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">与颤振相关的渲染、事件和通信处理的逻辑如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff md"><img src="../Images/7eb17458ff3573aa30ad5bde56b752c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXKblZUUBkj_GBaI8UaEnw.png"/></div></div></figure><p id="a233" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Dart中main函数的调用堆栈如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff me"><img src="../Images/5352f47e9a0e3a5005a2658b3e1ecff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDLUyFkTWiX5oulB-1WvcQ.png"/></div></div></figure><h2 id="7456" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">调试模式下的编译</h2><p id="0cea" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">在调试模式下，Flutter的编译结构类似于发布模式。差异主要表现在两点:</p><p id="8d0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 1。Flutter.framework </strong></p><p id="f665" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在调试模式下，框架包含JIT支持，而在发布模式下没有JIT支持。</p><p id="1ab1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2。App.framework </strong></p><p id="a659" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与App.framework在AOT模式下是dart代码对应的本机代码不同，在JIT模式下App.framework只有几个简单的API，它的Dart代码存在于snapshot_blob.bin文件中。这部分中的快照是一个脚本快照，带有简单的带标签的源代码。所有注释和空白字符都被删除，常量被规范化，并且不存在机器码、树抖动或混乱。</p><p id="929b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">App.framework中的符号表如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mf"><img src="../Images/c7ecd664ec051564634f9a67fc0aae08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CviWFp6a3XLPAbxgZh8Pag.png"/></div></div></figure><p id="1475" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Runner.app/flutter_assets/snapshot_blob.bin上运行字符串命令，查看以下内容:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mg"><img src="../Images/490aa31d582f7d15214e5aaffdeee0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qNjKfOG73TSGBSxYGtvaQ.png"/></div></div></figure><p id="1ad1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调试模式下主条目的调用堆栈如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mh"><img src="../Images/cd2e502286ea43ba1cb8fd2e94af20d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2jpI2fDrdS7F3YO1fXY5g.png"/></div></div></figure><h1 id="935d" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">Android的代码编译和执行</h1><p id="1790" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">除了Android和iOS的一些平台相关的特性，其他的逻辑比如对应AOT的Release和对应JIT的Debug会很相似，只有两个关键的区别需要注意。</p><h2 id="d2c8" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">发布模式下的编译</h2><p id="4b4a" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">在发布模式下，Android Flutter项目中Dart代码的构造链接如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mi"><img src="../Images/17562e6383c10b76db3022dcf1c0393e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CvnBijKtNXsp0550Expzg.png"/></div></div></figure><p id="9737" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在该图中，vm/isolate_snapshot_data/instr项是arm指令，由引擎在运行时加载并标记为可执行。VM_snapshot_data/instr用于初始化DartVM。有关其调用入口，请参见Dart_Initialize (dart_api.h)。Isolate_snapshot_data/instr对应于我们创建新隔离的App代码；有关其调用入口，请参见Dart_CreateIsolate(dart_api.h)。</p><p id="4b5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter.jar类似于iOS的Flutter.framework，包括引擎的代码(Flutter.jar中的libflutter.so)和一组将Flutter嵌入Android的类和接口(FlutterMain、FlutterView、FlutterNativeView等等)。事实上，flutter.jar位于flutter资源库的/bin/cache/artifacts/engine/Android *中，默认从Google资源库中拉出。当需要自定义修改时，可以通过下载引擎的源代码，使用Ninja构造系统生成flutter.jar。</p><p id="d9c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以isolate_snapshot_data/instr为例，运行disarm命令的结果如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mj"><img src="../Images/8bb64c924177f5b260b0e63bef2d5e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S69z9lXtBKD8nqEvgRwdyw.png"/></div></div></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mk"><img src="../Images/ccccc777f171fb70161e839360a45d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5S449N4lpMc_Tt2pJJozVw.png"/></div></div></figure><p id="e97a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其APK结构如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ml"><img src="../Images/a144db513dc6758a7eecb1bb29296721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MR23BSNi6trOmWjzqbNRLA.png"/></div></div></figure><p id="9ad7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">新安装APK后，使用时间戳判断(packageinfo中的versionCode结合lastUpdateTime)来决定是否将assets中的flutter产品复制到本地app数据目录中。复制的内容如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mm"><img src="../Images/f90dd25ca528225fa39d0d5d93b25355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-2DQ1JC6NO8MJ1c5dEbcQ.png"/></div></div></figure><p id="4086" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Isolate/vm_snapshot_data/instr最终位于应用程序的本地数据目录中，在那里它是可写的。因此，应用程序的整个替换和更新可以通过下载和替换那些快照来完成。</p><h2 id="93f4" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">在发布模式下执行</h2><p id="2536" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">下图显示了发布模式下的执行逻辑:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mn"><img src="../Images/b8e9a579ce8e7c12dad32c23160bf3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5PSYJrF0LJb0y2t0QS1sw.png"/></div></div></figure><h2 id="8079" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">调试模式下的编译</h2><p id="f765" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">和iOS的情况一样，Android中调试模式和发布模式的区别主要在于以下两个组件:</p><p id="6b35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 1。flutter.jar </strong></p><p id="2e6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的区别与之前对iOS的描述完全相同。</p><p id="64d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2。App代码</strong></p><p id="3107" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">app代码位于flutter_assets下的snapshot_blob.bin中，iOS也是如此。</p><p id="b9a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在介绍了关于iOS和Android的Flutter编译原则之后，我们现在将关注如何配置Flutter及其引擎，以实现完全的定制和优化。由于Flutter正处于敏捷开发阶段，其中出现的问题的当前性质在未来可能并不相关。因此，下一节的重点不是解决问题，而是可以说明解决问题的原则的不同类型的场景。</p><h1 id="9bc5" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">颤振的定制和优化开发</h1><p id="fc9e" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">颤振是一个复杂的系统。除了上面提到的三层架构，它还包括Flutter Android Studio (Intellij)插件、发布库管理和许多其他组件。然而，定制和优化通常与Flutter的工具链有关；代码位于flutter库的flutter_tools包中。我们现在来看看如何分别为Android和iOS定制这一部分。</p><h2 id="1e92" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">定制Android</h2><p id="32a4" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">Android的Flutter定制相关的内容有flutter.jar、libflutter.so(在flutter.jar下)、gen_snapshot、flutter.gradle、flutter_tools。定制颤振时，应考虑以下因素:</p><p id="14f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 1。将Android中的目标定义为armeabi </strong></p><p id="cf2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一节是构造的一部分，其逻辑在flutter.gradle下，当app通过armeabi支持armv7/arm64时，必须修改flutter的默认逻辑如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mo"><img src="../Images/1d924b64464fa674212e6464fda71162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7JK-JDmoS9N9sH731jaAw.png"/></div></div></figure><p id="5338" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于Gradle本身的特性，该部分可以被构造并在修改后生效。</p><p id="a809" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2。设置Android在启动时默认使用第一个可启动的活动。</strong> <br/> <br/>本节与颤振_工具有关，修改如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mp"><img src="../Images/09fe333187f19148e8b2d5936790d15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3cQGw1JF6ga9sshvYfIKg.png"/></div></div></figure><p id="7ce8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的重点不是如何修改，而是如何让修改生效。原则上，对于“flutter run/build/analyze/test/upgrade”等命令，实际运行的是Flutter脚本(Flutter _ repo _ dir/bin/Flutter)；然后通过这个脚本，通过Dart运行flutter_tools.snapshot(由packages/flutter_tools生成)。逻辑如下:</p><pre class="jr js jt ju fq mq mr ms mt aw mu dt"><span id="c5b7" class="lb ke hu mr b fv mv mw l mx my">if [[ ! -f "SNAPSHOT_PATH" ]] || [[ ! -s "STAMP_PATH" ]] || [[ "(cat "STAMP_PATH")" != "revision" ]] || [[ "FLUTTER_TOOLS_DIR/pubspec.yaml" -nt "$FLUTTER_TOOLS_DIR/pubspec.lock" ]]; then<br/>        rm -f "$FLUTTER_ROOT/version"<br/>        touch "$FLUTTER_ROOT/bin/cache/.dartignore"<br/>        "$FLUTTER_ROOT/bin/internal/update_dart_sdk.sh"<br/>        echo Building flutter tool...<br/>    if [[ "$TRAVIS" == "true" ]] || [[ "$BOT" == "true" ]] || [[ "$CONTINUOUS_INTEGRATION" == "true" ]] || [[ "$CHROME_HEADLESS" == "1" ]] || [[ "$APPVEYOR" == "true" ]] || [[ "$CI" == "true" ]]; then<br/>      PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_bot"<br/>    fi<br/>    export PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_install"<br/><br/>    if [[ -d "$FLUTTER_ROOT/.pub-cache" ]]; then<br/>      export PUB_CACHE="${PUB_CACHE:-"$FLUTTER_ROOT/.pub-cache"}"<br/>    fi<br/><br/>    while : ; do<br/>      cd "$FLUTTER_TOOLS_DIR"<br/>      "$PUB" upgrade --verbosity=error --no-packages-dir &amp;&amp; break<br/>      echo Error: Unable to 'pub upgrade' flutter tool. Retrying in five seconds...<br/>      sleep 5<br/>    done<br/>    "$DART" --snapshot="$SNAPSHOT_PATH" --packages="$FLUTTER_TOOLS_DIR/.packages" "$SCRIPT_PATH"<br/>    echo "$revision" &gt; "$STAMP_PATH"<br/>    fi</span></pre><p id="55da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由此可见，如果你想重新构建flutter_tools，可以删除flutter _ repo _ dir/bin/cache/flutter _ tools . stamp(以便重新生成)，或者屏蔽掉if/fi判断(每次都重新生成)。</p><p id="0f08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.在Android项目的调试模式中使用发布模式颤振</p><p id="07bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您发现Flutter在开发中似乎有些滞后，并且猜测这可能是由逻辑或调试模式的某个因素引起的，您可以在发布模式中构造APK，或者将Flutter强制到发布模式，如下所示:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mz"><img src="../Images/84d2a61f7ba6935e33631cb2569e96c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQiVcCiZ_S9fxXb0Gpi1fg.png"/></div></div></figure><h2 id="837a" class="lb ke hu bd kf lc ld le kj lf lg lh kn jc li lj kr jg lk ll kv jk lm ln kz lo dt translated">自定iOS</h2><p id="12fe" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">iOS开发定制Flutter相关的内容有Flutter.framework、gen_snapshot、xcode_backend.sh、flutter_tools。定制颤振时，应考虑以下因素:</p><p id="ff20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 1。优化建造过程中反复更换颤振框架导致的重新编译</strong></p><p id="6b3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本节的这个逻辑与构造有关，位于xcode_backend.sh中，为了保证每次都能获得正确的Flutter.framework，Flutter每次都会根据其配置(见生成的. xcconfig配置)寻找并替换Flutter.framework。然而，这会导致依赖于该框架的项目代码的重新编译。必要的修改如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff na"><img src="../Images/65e15d068b7e4c01e519dbe2b56ceac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nAV6oeFr38SAOnXmY-86A.png"/></div></div></figure><p id="cfd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 2。在iOS项目的调试模式中使用发布模式颤振</strong></p><p id="5823" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要进行这种定制，需要将Generated.xcconfig中的FLUTTER_BUILD_MODE改为“Release”，FLUTTER_FRAMEWORK_DIR改为“Release”对应的路径。</p><p id="b0ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> 3。设置对armv7 </strong>的支持</p><p id="6e72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于这个场景的原始文档，请参见<a class="ae kc" href="https://github.com/flutter/engine/wiki/iOS-Builds-Supporting-ARMv7" rel="noopener ugc nofollow" target="_blank">https://github . com/flutter/engine/wiki/iOS-Builds-Supporting-arm V7</a>。</p><p id="d5df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其实在iOS中，Flutter本身是支持armv7的，但是目前没有提供官方支持，所以你必须修改相关逻辑如下:</p><p id="6530" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> a. </strong>生成默认逻辑:</p><p id="5ec1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter.framework(arm64)</p><p id="7fac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> b. </strong>修改Flutter，使flutter_tools每次都能重建。修改build_aot.dart和mac.dart，将iOS的相关arm64改为armv7，将gen_snapshot改为i386架构。</p><p id="2709" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">i386架构下的gen_snapshot可以通过以下命令生成:</p><pre class="jr js jt ju fq mq mr ms mt aw mu dt"><span id="1cdf" class="lb ke hu mr b fv mv mw l mx my">./flutter/tools/gn --runtime-mode=debug --ios --ios-cpu=arm<br/>ninja -C out/ios_debug_arm</span></pre><p id="aaed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里隐含着一种逻辑:</p><p id="eea3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构造gen_snapshot的CPU相关预定义宏(x86_64/__i386等)。目标gen_snapshot和最终App.framework架构的arch必须保持一致。即使用x86_64-&gt;x86_64-&gt;arm64或者i386-&gt;i386-&gt;armv7。</p><p id="88a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> c. </strong>在iPhone4S上，当gen_snapshot生成不支持的SDIV命令时，会出现EXC _坏指令(EXC _ ARM _未定义)错误，可以通过在gen_snapshot(位于build_aot.dart)中添加参数“—不使用整数除法”来实现。其背后的逻辑如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nb"><img src="../Images/567224bf384e58494b4e47da3f125057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSxwxxwh2sGsH0KeSFUwOA.png"/></div></div></figure><p id="6f8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">d .</strong>“Lipo create”基于a和b生成的Flutter.framework生成一个同时支持armv7和arm64的Flutter.framework。</p><p id="edfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> e. </strong>修改Flutter.framework下的Info.plist，删除:</p><pre class="jr js jt ju fq mq mr ms mt aw mu dt"><span id="c1db" class="lb ke hu mr b fv mv mw l mx my">&lt;key&gt;UIRequiredDeviceCapabilities&lt;/key&gt;<br/>  &lt;array&gt;<br/>    &lt;string&gt;arm64&lt;/string&gt;<br/>  &lt;/array&gt;</span></pre><p id="38fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，您必须在App.framework上执行相同的操作，以避免受到来自AppStore的应用精简的影响。</p><h1 id="16a8" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">调试颤振工具</h1><p id="41c6" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">如果您想知道在调试模式下构造APK时在Flutter中执行的具体逻辑，您可以采用以下方法:</p><p id="88b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> a. </strong>了解flutter_tools命令的参数。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nc"><img src="../Images/268155223ec08eb1070022310cf6dfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arUXxU1_1Bv6YzD-Xhrbig.png"/></div></div></figure><p id="f246" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> b. </strong>打开packages/flutter_tools作为Dart项目，添加新的“Dart命令行App”配置。将Dart文件设置为“flutter_tools.dart”，将工作目录设置为您的flutter项目的路径，并将程序参数设置为前面获得的参数。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nd"><img src="../Images/2efd7c4ff35a07c1cdba44bf29cede00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ngt_B9PUBJ2o26lTnohHWA.png"/></div></div></figure><h1 id="ee13" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">引擎定制和调试</h1><p id="757d" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">考虑下面的场景。假设我们基于Flutter beta v0.3.1定制开发了一个服务，为了保证稳定性，SDK在一定时期内不升级。同时，在主服务器上修改了flutter v0.3.1上的一个bug，标记为fix_bug_commit。您如何跟踪和管理这种情况？</p><p id="8401" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.Flutter beta v0.3.1将其对应的引擎提交指定为09d05a389。请参见:颤振/箱/内部/发动机.版本</p><p id="99bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.获取发动机代码。</p><p id="425e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.由于主代码是在第二步中获得的，我们需要的是与特定提交(09d05a389)相对应的代码库，那么您将从这个提交中拉出一个新的分支:custom_beta_v0.3.1。</p><p id="8f99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.基于custom_beta_v0.3.1运行“g client sync ”( commit:09d 05 a 389)获取对应于flutter beta v0.3.1的所有引擎代码。</p><p id="62be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">5.使用“git cherry-pick fix_bug_commit”将主服务器的更改同步到custom_beta_v0.3.1。如果更改对最新更新有许多依赖关系，可能会出现编译失败。</p><p id="ac95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">6.针对与iOS相关的更改运行以下代码:</p><pre class="jr js jt ju fq mq mr ms mt aw mu dt"><span id="852d" class="lb ke hu mr b fv mv mw l mx my">./flutter/tools/gn --runtime-mode=debug --ios --ios-cpu=arm<br/>ninja -C out/ios_debug_arm<br/><br/>./flutter/tools/gn --runtime-mode=release --ios --ios-cpu=arm<br/>ninja -C out/ios_release_arm<br/><br/>./flutter/tools/gn --runtime-mode=profile --ios --ios-cpu=arm<br/>ninja -C out/ios_profile_arm<br/><br/>./flutter/tools/gn --runtime-mode=debug --ios --ios-cpu=arm64<br/>ninja -C out/ios_debug<br/><br/>./flutter/tools/gn --runtime-mode=release --ios --ios-cpu=arm64<br/>ninja -C out/ios_release<br/><br/>./flutter/tools/gn --runtime-mode=profile --ios --ios-cpu=arm64<br/>ninja -C out/ios_profile</span></pre><p id="d340" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要调试Flutter.framework源代码，请在构造中使用以下命令:</p><pre class="jr js jt ju fq mq mr ms mt aw mu dt"><span id="d979" class="lb ke hu mr b fv mv mw l mx my">./flutter/tools/gn --runtime-mode=debug --unoptimized --ios --ios-cpu=arm64<br/>ninja -C out/ios_debug_unopt</span></pre><p id="3161" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用生成的产品替换Flutter中的Flutter.framework和gen_snapshot，调试引擎源代码。</p><p id="2fb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">7.最后，运行以下代码，查看与Android相关的更改:</p><pre class="jr js jt ju fq mq mr ms mt aw mu dt"><span id="069a" class="lb ke hu mr b fv mv mw l mx my">./flutter/tools/gn --runtime-mode=debug --android --android-cpu=arm<br/>ninja -C out/android_debug<br/><br/>./flutter/tools/gn --runtime-mode=release --android --android-cpu=arm<br/>ninja -C out/android_release<br/><br/>./flutter/tools/gn --runtime-mode=profile --android --android-cpu=arm<br/>ninja -C out/android_profile</span></pre><p id="ca17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以用构造的产品替换flutter/bin/cache/artifacts/engine/android *下的gen_snapshot和flutter.jar，生成Android的arm&amp;debug/release/profile产品。</p><p id="0403" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">(Original article by Wang Kang王康)</p></div><div class="ab cl ne nf hc ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hn ho hp hq hr"><h1 id="4d04" class="kd ke hu bd kf kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw np ky kz la dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae kc" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">“阿里巴巴科技”</strong> </a>。推特:<a class="ae kc" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">【阿里巴巴技术】</strong> </a>。</p></div></div>    
</body>
</html>