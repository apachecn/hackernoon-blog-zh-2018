<html>
<head>
<title>From Zero to GraphQL Subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到GraphQL订阅</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-zero-to-graphql-subscriptions-416b9e0284f3?source=collection_archive---------4-----------------------#2018-08-01">https://medium.com/hackernoon/from-zero-to-graphql-subscriptions-416b9e0284f3?source=collection_archive---------4-----------------------#2018-08-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c151" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇博文中，我将介绍从头构建GraphQL订阅的理论、实现和挑战。如果你不熟悉GraphQL，这里有一本入门书:GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL于2015年开源，订阅操作(2017年加入规范)允许你订阅GraphQL中的实时数据。GraphQL订阅为脸书的许多功能提供了动力，包括对直播视频的实时评论和流媒体反应。如果你想更全面地了解GraphQL，请查看graphql.org的<a class="ae jp" href="http://graphql.org" rel="noopener ugc nofollow" target="_blank"/>。<br/> <br/>假设我们正在构建一个具有两个基本特性的电子邮件客户端:</p><ol class=""><li id="00e8" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">当用户启动应用程序时，获取并显示收件箱中的所有电子邮件。对于每封电子邮件，显示接收时间、发件人的电子邮件和主题行。</li><li id="cd63" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">当新邮件到达时，将其添加到收件箱，显示接收时间、发件人的电子邮件和主题行。</li></ol><p id="9841" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于需求#1，客户端可以通过一个简单的GraphQL查询获取相关字段:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="d593" class="kn ko hu kj b fv kp kq l kr ks">query FetchEmailsOnStart($viewer: ID!) {<br/>  allEmailsForViewer(viewer: $viewer) {<br/>    receiveTime,<br/>    sender,<br/>    subject<br/>  }<br/>}</span></pre><p id="6301" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于需求#2，客户机需要请求服务器在新邮件到达时得到通知。例如，服务器通过pubsub(发布-订阅)API公开此功能:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="4059" class="kn ko hu kj b fv kp kq l kr ks">newEmails.Subscribe(viewerContext, onPublish: (newEmailId) =&gt; {<br/>  // execute a GraphQL query to fetch the relevant fields from the new email<br/>});</span><span id="8cda" class="kn ko hu kj b fv kt kq l kr ks">// Elsewhere in the server-side code, we need to detect the arrival of new emails and publish:<br/>newEmails.Publish(viewerID, newEmailId);</span></pre><p id="c4c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当触发onPublish回调函数时，我们执行另一个GraphQL查询，如下所示:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="fb67" class="kn ko hu kj b fv kp kq l kr ks"># query to run in response to a new email<br/>query FetchEmailById($viewer: ID!, $newEmailId: ID!) {<br/>  email(viewer: $viewer, id: $newEmailId) {<br/>    receiveTime,<br/>    sender,<br/>    subject<br/>  }<br/>}</span></pre><p id="0f4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在可以定义任何反应式GraphQL系统的三个关键职责:</p><ol class=""><li id="fc70" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">定义并跟踪数据更改时要运行的查询。</li><li id="ff4e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">捕获并检测会触发重新评估查询的条件。</li><li id="92c9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">重新评估查询并返回结果。</li></ol><p id="93d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们尝试在客户端上做这些事情会怎么样？通过显式订阅底层源事件流，客户端包含了如何检测“新电子邮件事件”的命令性逻辑。现在这不是一个大问题，但是想象一下这个代码在一个移动应用程序中，其中一小部分用户从来没有升级过那个版本。如果命令性逻辑更改包括多个pubsub事件或一个不同的pubsub事件，这些客户端很容易被破坏。如果我们把责任转移到服务器上会怎么样？换句话说，客户机可以向服务器发送一个GraphQL文档。那么服务器将:</p><ol class=""><li id="162a" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">持久化并跟踪GraphQL文档</li><li id="6536" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">捕获触发条件(源事件流)</li><li id="b4a4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">重新评估查询并返回结果。</li><li id="685c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">维护到客户端的持久通道，并将结果推回客户端。</li></ol><p id="424a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过在服务器上执行这些操作，步骤#2的细节对客户端是隐藏的，并且可以在服务器上自由更改，并且查询变得完全是声明性的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="4a0a" class="kn ko hu kj b fv kp kq l kr ks">subscription SubscribeToNewEmails($viewer: ID!) {<br/>  newEmail(viewer: $viewer) {<br/>    receiveTime,<br/>    sender,<br/>    subject<br/>  }<br/>}</span></pre><p id="0e76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与客户端解决方案相比，我们节省了网络往返，避免了在后端暴露源事件流，并且消除了指定<em class="ku"> newEmailId </em>的需要。客户端仍然知道<em class="ku">为什么数据改变了</em>，但是<em class="ku">为什么(新邮件到达)</em>与<em class="ku">如何(pubsub事件调用包含新邮件Id的新邮件)</em>是分离的。</p><figure class="ke kf kg kh fq kw fe ff paragraph-image"><div class="fe ff kv"><img src="../Images/50a68970d206e27fa4c71305c2cbc5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Wkej-2glXzodFNNA_D_24A.gif"/></div></figure><h1 id="7dbf" class="kz ko hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">缩放和操作</h1><p id="1bee" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">这听起来很有希望，但是服务器现在需要维护更多的状态，并管理与潜在的数亿客户端的持久连接。有状态系统比无状态系统更难监控和调试，GraphQL也不例外。强调几个挑战:</p><ul class=""><li id="bc0b" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo mb jw jx jy dt translated">系统将如何扩展以处理数百万并发用户？</li><li id="13d8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo mb jw jx jy dt translated">n平方扇出:当一个聊天室有一百万个参与者，每个人都在同一时间打字，会发生什么？</li><li id="654a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo mb jw jx jy dt translated">对于有序的、一次且只有一次的交付，我们能做出什么样的保证？这在延迟和可用性方面有什么样的折衷？</li><li id="2d56" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo mb jw jx jy dt translated">我们如何衡量系统的可靠性？</li><li id="10c7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo mb jw jx jy dt translated">在部署期间，我们如何将客户端连接从一个节点转移到另一个节点？</li><li id="75d8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo mb jw jx jy dt translated">系统如何处理单个节点上的过载？</li><li id="2351" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo mb jw jx jy dt translated">有状态层和无状态层应该集成还是分开？</li></ul><p id="5e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些都是没有正确答案的难题。但是在构建大规模实时API之前考虑它们是一个好主意。</p><h1 id="5dc5" class="kz ko hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">开放源码</h1><p id="d7e7" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">社区表达了对GraphQL订阅的一贯兴趣，所以我们去年将它添加到了GraphQL规范中。以下是规格文本:</p><blockquote class="mc"><p id="0157" class="md me hu bd mf mg mh mi mj mk ml jo ek translated"><em class="mm">如果操作是订阅，则结果是称为“响应流”的事件流，其中事件流中的每个事件是对底层“源流”上的每个新事件执行操作的结果。</em></p><p id="2049" class="md me hu bd mf mg mh mi mj mk ml jo ek translated"><em class="mm">执行订阅会在服务器上创建一个持久函数，该函数将底层的源流映射到返回的响应流。</em></p></blockquote><p id="a233" class="pw-post-body-paragraph ir is hu it b iu mn iw ix iy mo ja jb jc mp je jf jg mq ji jj jk mr jm jn jo hn dt translated">将此映射到我们的示例中，“源流”是“newEmails pubsub事件”。“服务器上的持久功能”记住GraphQL查询并监听事件的源数据流。每次新邮件到达时，映射函数都使用来自源流事件的输入来执行存储的GraphQL文档。<br/> <br/> GraphQL订阅可以从主要的社区合作伙伴那里获得，例如<a class="ae jp" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>和<a class="ae jp" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>，但是我希望这篇博客已经为您提供了构建自己的GraphQL订阅实现的知识！</p></div></div>    
</body>
</html>