<html>
<head>
<title>Dynamic Programming for Brute-Forcers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蛮力者的动态编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dynamic-programming-for-brute-forcers-36f26c2466cf?source=collection_archive---------9-----------------------#2018-08-01">https://medium.com/hackernoon/dynamic-programming-for-brute-forcers-36f26c2466cf?source=collection_archive---------9-----------------------#2018-08-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c020" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">互联网上有大量关于这个话题的资料，但是我们(我和我的朋友)在很长一段时间内都无法理解，直到我们修改代码，跟踪输入的每一个变化。所以这篇文章正是为我们这样的人而写的，让从贪婪的T2到动态的T4编程变得更容易。这只是对动态编程的一个介绍，因此人们可以从这里开始学习。我添加了额外的练习资源和其他在线教程，我发现它们在最后有点帮助。它是为那些习惯于暴力的程序员准备的，可能不适合绝对的初学者。</p><h1 id="efca" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">定义</h1><p id="b731" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">那么什么是动态编程呢？我们先来看一个更正式的定义。</p><p id="187b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">动态规划(也称为动态优化)是一种解决复杂问题的方法，它将复杂问题分解为一系列更简单的子问题，每个子问题只解决一次，然后存储它们的解决方案。下一次出现相同的子问题时，不用重新计算它的解，只需查找先前计算的解，从而节省计算时间，代价是(希望)适度地消耗存储空间。(每个子问题解决方案都以某种方式被索引，通常基于其输入参数的值，以便于查找)<a class="ae jp" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank"> (Source-Wiki) </a>。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff kt"><img src="../Images/70a233ead96943c7fc7054e11abc2a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89wcP4LUhvVPUJXpQ-vWeA.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">It’s that simple</figcaption></figure><p id="4069" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者更简单地说，它是一种以任何合适的格式保存计算中的中间结果的技术，以便该结果可以用于进一步的计算，而不是在附加输入到达时重新计算它。听起来够简单吧？是的，的确是这样，让我们来看一个例子来说明这一点。</p><p id="59fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在此之前，我们需要确定一个问题是否具有以下性质，以便通过动态规划(DP)来解决</p><ol class=""><li id="e91c" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated"><a class="ae jp" href="http://www.geeksforgeeks.org/dynamic-programming-set-1/" rel="noopener ugc nofollow" target="_blank">重叠子问题</a></li><li id="832d" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><a class="ae jp" href="http://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/" rel="noopener ugc nofollow" target="_blank">最佳结构</a></li></ol><h1 id="1b7a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">问题</h1><ol class=""><li id="6a70" class="lj lk hu it b iu ko iy kp jc lx jg ly jk lz jo lo lp lq lr dt translated">最小成本问题</li><li id="bdc1" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated">最长增长子序列</li></ol><h1 id="cd73" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">最小成本问题</h1><p id="5cdf" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">给定一个成本矩阵cost[][]和cost[][]中的一个位置(m，n)，写一个函数，返回从(0，0)到达(m，n)的最小成本路径的成本。矩阵的每个单元代表穿过该单元的成本。到达(m，n)的路径的总成本是该路径上所有成本的总和(包括源和目的地)。您只能从给定的单元格向下、向右和斜下方遍历单元格，即从给定的单元格(I，j)开始，可以遍历单元格(i+1，j)、(I，j+1)和(i+1，j+1)。你可以假设所有的成本都是正整数。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/26b96358b93d6cc26104547fce767416.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*AvdW-76uv-nljCgTSFcDJw.png"/></div></figure><p id="7c54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">解决方案:</strong></p><p id="c70c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我:</strong>那你会如何继续解决这个问题呢？<br/> <strong class="it hv">朋友:</strong>哦，我看的《性质》讲的是把子问题保存起来，让计算更容易！<br/> <strong class="it hv">我:</strong>这里有哪些子问题？<br/> <strong class="it hv">朋友:</strong>哎呀，太彪悍了。<br/> <strong class="it hv">我:</strong>不，不是我们一起工作。</p><p id="b978" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你通常如何解决它，暂时忘记代码。<br/>你可能会查看所有的单元格，沿着路径添加成本，直到到达目的地。但是你不知道它是否是最小值，所以你通过遍历不同的方向重新开始加法。然后，也许在考虑了所有的途径之后，你会得出一个最低的成本。</p><p id="2fac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">差不多就是这样。</p><p id="ac0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的朋友打断，<br/> <strong class="it hv">朋友:</strong>但是上面的方法只解决了一个特定目的地的问题，如果我们要计算到达不同目的地的总成本呢？<br/> <strong class="it hv">我:</strong>说得好！<br/> <strong class="it hv">朋友:</strong>这就是为什么我们存储从第一个单元格到达数组中每个单元格的最小代价。这样，当我们填满所有单元格时，我们将得到每个单元格的溶液。<br/> <strong class="it hv">朋友:</strong>我在那里把你弄丢了。<br/> <strong class="it hv">我:</strong>哈哈，让我说完。</p><p id="801f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前我们知道些什么？</p><ul class=""><li id="e75c" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo mb lp lq lr dt translated">这是一个数组，我们可以向右，向下，再向下移动。</li><li id="4565" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated">我们需要打印穿越到给定目的地的最小成本。</li><li id="ca43" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated">我们从第一个细胞开始。</li></ul><p id="04e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">分解问题:</strong></p><p id="fc1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我:</strong>从[0，0]转移到[0，1]的简单成本是多少？<br/> <strong class="it hv">朋友:</strong>是<code class="eh mc md me mf b">2 + 1 = 3</code> <br/> <strong class="it hv">我:</strong>从[0，0]移动到[0，1]的最小成本是多少？<br/> <strong class="it hv">朋友:</strong>还是3，因为我们只能向右、向下或斜下方移动，所以没有其他方法可以到达[0，1]。我们只能<strong class="it hv">从【0，0】到达【0，1】。<br/> <strong class="it hv">我:</strong>优秀！那么从[0，1]到[0，2]的最小成本是多少呢？<br/> <strong class="it hv">朋友:</strong>哦等等，从<strong class="it hv"> [0，0]移动到【0，1】</strong>的代价是<strong class="it hv"> 3 </strong>，因此<strong class="it hv">【0，1】到【0，2】</strong>将是<code class="eh mc md me mf b">3 + cost of getting to (0,1)</code>，也就是<code class="eh mc md me mf b">3 + 3 = 6</code>。<br/> <strong class="it hv"> Me: </strong>现在我们要不要把这个获得的对应于每个单元格的代价存储在一个不同的数组里，这样当单元格是目的地的时候，我们就可以把它们返回来？<br/> <strong class="it hv">朋友:</strong>够公平。</strong></p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/49fe1496a92c1712be0b7cf00a66dfad.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*Z-bOxf1KMT6zfMGMTpoahw.png"/></div></figure><p id="ee4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么不把它也编码起来？</p><pre class="ku kv kw kx fq mh mf mi mj aw mk dt"><span id="a7c5" class="ml jr hu mf b fv mm mn l mo mp">minarr[0][0] = a[0][0];</span><span id="d660" class="ml jr hu mf b fv mq mn l mo mp">for(i=1;i&lt;n;i++)<br/>  minarr[0][i] = minarr[0][i-1] + a[0][i];</span></pre><p id="d07e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中n是行数</p><p id="80ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将第一个元素原样转移到min cost表中，并计算该行中其他元素的成本。</p><p id="f2fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">朋友:为什么不是专栏？第一列中的单元格也只有一种到达它们的方式，即从第一个单元格向下。我:是的，那是我们的下一步。</p><p id="a426" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，我们通过将该列中的单元格与之前的单元格相加来计算到达每一列的成本。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/86309221c3d630b748ed2dd75699fb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*R0ZpbAfZhfSJPO4mxaDRdw.png"/></div></figure><p id="104f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们也会把它编码的！</p><pre class="ku kv kw kx fq mh mf mi mj aw mk dt"><span id="9ad5" class="ml jr hu mf b fv mm mn l mo mp">for(i=1;i&lt;m;i++)<br/>  minarr[i][0] = minarr[i-1][0] + a[i][0];</span></pre><p id="c655" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中m是列数</p><p id="e6f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">朋友:</strong>现在，我们如何计算到达cell [1，1]的最小代价？<br/> <strong class="it hv"> Me: </strong>我们知道我们只能遍历左侧、下方或斜下方的单元格。因此，我们只能从单元格[0，0]或[0，1]或[1，0]到达单元格[1，1]。现在我们的表已经有了达到[0，0]，[0，1]和[1，0]的最小值，只需将这三个值的最小值加上达到单元格[1，1]的成本就可以得到我们的结果。</p><p id="9f4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以<code class="eh mc md me mf b">cost to reach cell [1,1] = a[1,1] + min(minarr[0,0], minarr[0,1], minarr[1,0])</code></p><p id="bd06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mc md me mf b">minarr[1,1] = 8 + min(1,3,5)</code> <br/>如此，<code class="eh mc md me mf b">minarr[1,1] = 9</code></p><p id="895e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，我们从1，1开始对所有单元格进行操作。</p><p id="c97e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们重新编码，</p><pre class="ku kv kw kx fq mh mf mi mj aw mk dt"><span id="2341" class="ml jr hu mf b fv mm mn l mo mp">for(i=1;i&lt;n;i++)<br/>  for(j=1;j&lt;m;j++)<br/>    minarr[i][j] = (a[i][j] + min(minarr[i-1][j-1],minarr[i][j-1],minarr[i-1][j]));</span></pre><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/87c52648be02f8c1b9c0374470f6ec24.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*DkNGbNSfhmW9SFwGP4Cd7A.png"/></div></figure><p id="c90a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们的表已经填满了，我们只需返回最小成本数组中给定目的地的单元格。完整的代码是<a class="ae jp" href="https://github.com/nobodyme/Dynamic-Programming/blob/master/minimum-cost-path.C" rel="noopener ugc nofollow" target="_blank">这里给出的</a>。这里有一个<a class="ae jp" href="http://practice.geeksforgeeks.org/problems/largest-zigzag-sequence/0" rel="noopener ugc nofollow" target="_blank">类似的问题</a>，自己试试<a class="ae jp" href="https://github.com/nobodyme/dynamic-programming/blob/master/Count-all-paths.C" rel="noopener ugc nofollow" target="_blank">库中又增加了一个类似的问题</a>。</p><p id="2c5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，通过一个接一个地考虑元素，我们已经建立了我们的解决方案，或者用DP术语，我们已经以自下而上的方式(列表法)从子问题中获得了我们的解决方案。还有一种方法叫做记忆化。两者之间的区别在这里的<a class="ae jp" href="http://www.geeksforgeeks.org/tabulation-vs-memoizatation/" rel="noopener ugc nofollow" target="_blank">文章</a>中有解释。</p><h1 id="0c68" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">最长增长子序列</h1><p id="7e6f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">最长递增子序列(LIS)问题是寻找给定序列的最长子序列的长度，使得该子序列的所有元素按递增顺序排序。例如，{10，12，32，2，22，23，25，30}的LIS长度是6，LIS是{10，12，22，23，25，30}</p><p id="ecd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">解决方案:</strong></p><p id="dbc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如何继续解决这个问题？为了使计算更容易，你会存储什么？简单地说，你如何使用<strong class="it hv">强力</strong>解决上述问题，就像你如何执行<a class="ae jp" href="https://en.wikipedia.org/wiki/Selection_sort" rel="noopener ugc nofollow" target="_blank">选择排序</a>！</p><p id="4da1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">10 12 32 2 22 23 25 30 k，国际法院</p><p id="e57b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">朋友:</strong>我会将每个元素与其他每个元素进行比较，如果它大于当前元素，我会增加count变量并打印最大的计数，我得到。大致来说，我会把它编码成这样</p><p id="5632" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="mt">伪代码</em> </strong>(我朋友的代码不懂也没关系)</p><pre class="ku kv kw kx fq mh mf mi mj aw mk dt"><span id="68e7" class="ml jr hu mf b fv mm mn l mo mp">for(i=0;i&lt;n-1;i++)<br/>{   <br/>  count = 1;<br/>  for(j=i+1,k=i;j&lt;n,k&lt;n-1;j++)<br/>  {<br/>    if(a[j] &gt; a[k])<br/>    {<br/>      k=j;<br/>  count++;<br/>    }<br/>    if(count&gt;maxi)<br/>      maxi = count;<br/>  }<br/>}<br/>printf("\nMax-length = %d\n",maxi);</span></pre><p id="47ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我:我们跑吧。<br/> <strong class="it hv">朋友:</strong>呃？好吧。<br/> <strong class="it hv">我:</strong>那么输出是多少？<br/> <strong class="it hv">朋友:</strong>程序返回，<code class="eh mc md me mf b">max-length = 5</code>，我猜是{2，22，23，24，25}。但是我们知道是6，LIS是{10，12，22，23，25，30}。<br/>为什么无法捕捉到上面的lis？</p><p id="96cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我:</strong>因为在遍历{10，12，32，22，23，25，30}时，代码将如下运行，它将检查，<br/>如果(10 &gt; 12) yes → count是2，那么<br/>如果(32 &gt; 12) yes → count是3，那么<br/>在这一点上<strong class="it hv"> count = 3 </strong>，从那里开始count不会增加，因为下面的元素小于32，因此条件像(1)</p><p id="c954" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">朋友:</strong>如果它知道通过<strong class="it hv">避开32 </strong>并遍历数组的其余部分，我们将实际获得结果<code class="eh mc md me mf b">max-length = 6</code>就好了。<br/> <strong class="it hv"> Me: </strong>这正是我们使用DP为计算存储的信息。在蛮力术语中，我们在数组中存储所有可能的遍历选择的count变量，然后简单地找到它的最大值(注意:不是说蛮力不能解决问题，一种不同的方法可能但肯定是在指数时间内)。</p><p id="f7eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>我的朋友最初设置了<code class="eh mc md me mf b">count=1</code>而不是0，因为当我们遇到数组中所有数字都相同的情况，即{2，2，2，2}时，我们必须返回count为<strong class="it hv"> 1 </strong>，因为一个元素仍然是更大元素的子数组，而更大的元素只是{ 2 },因此返回0是错误的。</p><p id="2cd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">动力定位解决方案:</strong></p><p id="e93e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我:那么你如何在dp中编写同样的代码呢，实际上这更简单。<br/> <strong class="it hv">朋友:</strong>既然你说我们存储所有变量的计数，那我们初始化一个对应计数大小相同的数组？我:确切地说，我们首先创建另一个数组来存储我们讨论过的数组中每个成员的计数，并将它们全部初始化为<strong class="it hv"> 1 </strong>。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/dae3efca89996e2b598a8725c55fe5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*19WcJc0qNOSJ4txW8c-G0g.png"/></div></figure><p id="9bf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">朋友:现在我们用类似的方法检查？我:是的，但是现在，让我们只考虑数组中存在的元素<strong class="it hv"> 10 </strong>。<br/> <strong class="it hv">朋友:</strong>为什么？<br/> <strong class="it hv">我:</strong>说简单点？！还能为什么？一起听。那么最长的增长序列是什么呢？<br/> <strong class="it hv">朋友:</strong> 1当然和LIS是{10}。我:所以现在，比方说，我们加上12，并把它的初始计数设为1</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff mv"><img src="../Images/522d0809ff5497a8ecc6ba9f062a00f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*zmv5t1cWr4zfxWCe-840BA.png"/></div></div></figure><p id="2c49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">朋友:我们检查<strong class="it hv"> if(12 &gt; 10) </strong>所以12的计数增加了？<br/> <strong class="it hv"> Me: </strong>是的，既然12 &gt; 10，12的计数就变成了<code class="eh mc md me mf b">count of 10 + 1</code>，因为计数10已经代表了用现有元素可以得到的最长的递增子序列。12的计数现在表示{10} + {12} = {10，12}或者简单地表示为2的<code class="eh mc md me mf b">count[i] = count[j]+1;</code></p><p id="7404" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">朋友:</strong>让我澄清一下，当10是单独的时，列表是1，现在添加了12，我们发现{10，12}可以从12开始列出&gt; 10，所以我们将10的计数添加到12的计数中，并加1以包括该数字本身。<br/> <strong class="it hv"> Me: </strong>没错而且数组变成了，</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/23388dffbff8f2fad676826d52813391.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*NcyPEbohPOe6fn-xg9G2Lw.png"/></div></figure><p id="07fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们考虑32，将<code class="eh mc md me mf b">i to 32 and j to 10</code>即j递增到数组的起始元素，并从头开始遍历，以查看<strong class="it hv">加上32 </strong>提供了更长的子序列。<br/>阵列变成，</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/9cb35f5e8930b4bcd7e823031c0230e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*xh_qeBjA1zPayEqW2FJSoQ.png"/></div></figure><p id="0298" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">朋友:是的，它确实证明更长。由于<strong class="it hv"> (32 &gt; 10) </strong>因此我们递增32的计数→count[I]= count[j]+1；</p><p id="edff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我:</strong>我们检查32之前的所有数字，看能不能和它相加形成一个序列，所以递增j，继续填方框！</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff my"><img src="../Images/fa794c657df88931bd9faaa30679ed6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/1*EvQyNhfMQU9oPAiV7Ip4Tg.gif"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">gif showing the 32’s count increment and increment on j</figcaption></figure><p id="51a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">朋友</strong>:好的我会，所以<strong class="it hv"> if(32 &gt; 12) </strong> → 32的计数= 12的计数+ 1 = (2+1) = 3</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/e9b7e1e00af987ade47c6ba17df25402.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*2D34mc1_UQtakFaRkuEKKQ.png"/></div></figure><p id="c72e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，<strong class="it hv">考虑元素2 </strong>数组变成，</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff na"><img src="../Images/21659dc225119ff2ff5b48a13c6da20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*dE03Bc9slNbWm6WOjDesww.png"/></div></figure><p id="75cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于每次检查<strong class="it hv"> if(2 &gt; 10) </strong>、<strong class="it hv"> if(2 &gt; 12) </strong>或<strong class="it hv"> if(2 &gt; 32) </strong>失败，数组保持不变，其计数变量保持不变。</p><p id="10de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我添加下一个数字，<strong class="it hv"> 22 </strong>并检查10、12、32，与上一个类似，对于10和12，计数22增加到3，对于32，它失败并保持为3，j增加到点2。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/3a85345f33ea9f1f3d3ee7e9e1f75598.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*EjcfSofLMFsfx9vIHAFjbA.png"/></div></figure><p id="ed46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在<strong class="it hv">如果(22&gt;2)</strong>→22的计数变成<code class="eh mc md me mf b">count[j]+1</code>即2？<br/> <strong class="it hv">我:</strong>哈哈，很高兴你停下来问，总之<strong class="it hv">没有</strong>，我们知道count反映的是最长的子序列。通过遍历数组中的其他元素，我们获得了22的最长子序列3。那么为什么要降低到2呢？因此，在添加<code class="eh mc md me mf b">count[i] = count[j]+1</code>时，要确保它有益于事业。因此，将<code class="eh mc md me mf b">count[i] = max(count[j]+1,count[i])</code> ie放置在两个数字中的最大值，以避免这种情况。</p><p id="235e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，数组的其余部分被遍历，</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/31165a1e40c06b7d00e469790ae5a492.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Xf6bsIZCrwgJJCS2brkpsw.png"/></div></figure><p id="0aa6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为最大值是6，这给出了最长的递增子序列，所以上面遍历的视频在这里是<a class="ae jp" href="https://youtu.be/Ns4LCeeOFS4" rel="noopener ugc nofollow" target="_blank">链接的(不同的例子)</a>。下面我们来看看相同的代码片段。正如我们所知，</p><ul class=""><li id="1327" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo mb lp lq lr dt translated">我们将计数数组初始化为1</li><li id="0f4f" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated">然后计算每个元素的数量</li></ul><pre class="ku kv kw kx fq mh mf mi mj aw mk dt"><span id="d96f" class="ml jr hu mf b fv mm mn l mo mp">for(i=0;i&lt;n;i++)<br/>count[i] = 1;</span><span id="5b98" class="ml jr hu mf b fv mq mn l mo mp">for(i=1;i&lt;n;i++)<br/>{<br/> for(j=0;j&lt;i;j++)<br/> {<br/> if(array[i] &gt; array[j])<br/>  count[i] = max(count[i],count[j]+1);<br/> }<br/>}</span></pre><p id="3e7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们找到计数数组的最大值并打印出来，<a class="ae jp" href="https://github.com/nobodyme/Dynamic-Programming/blob/master/longest-increasing-sub-sequence.C" rel="noopener ugc nofollow" target="_blank">完整的代码片段在这里</a>和一个看起来相似的问题，只是有一对<a class="ae jp" href="https://github.com/nobodyme/dynamic-programming/blob/master/lis-pair.C" rel="noopener ugc nofollow" target="_blank">数字</a>。</p><h1 id="3944" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">要记住的要点</h1><ul class=""><li id="dd39" class="lj lk hu it b iu ko iy kp jc lx jg ly jk lz jo mb lp lq lr dt translated">动态编程就像任何其他类型的编程一样，你得到一些，你没有得到一些实践会使一切变得更好。我也有很多事要做。</li><li id="b213" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated">根据我的经验，这类似于暴力，但不是探索整个输入空间，而是找到一种方法来存储输入产生的中间结果，并彻底探索所需的结果。</li><li id="bca9" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated">没错，的确是一种用空间换时间的方法。递归方法可能会占用较少的空间，但动态编程方法更快。</li></ul><h1 id="1e7d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">其他资源</h1><ul class=""><li id="ff98" class="lj lk hu it b iu ko iy kp jc lx jg ly jk lz jo mb lp lq lr dt translated"><a class="ae jp" href="https://www.hackerearth.com/practice/notes/dynamic-programming-i-1/" rel="noopener ugc nofollow" target="_blank"> Hackerearth文章解释了更多关于“为什么动态编程”的内容</a></li><li id="91e6" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated"><a class="ae jp" href="https://www.quora.com/What-are-some-good-ways-to-approach-a-dynamic-programming-question/answer/Paul-Baltescu" rel="noopener ugc nofollow" target="_blank">如何使用Quora上的Paul Baltescu的动态编程</a></li><li id="2211" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated"><a class="ae jp" href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/#DynamicProgramming" rel="noopener ugc nofollow" target="_blank">极客帮极客教程</a></li><li id="8023" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated"><a class="ae jp" href="https://www.hackerearth.com/practice/notes/dynamic-programming-problems-involving-grids/" rel="noopener ugc nofollow" target="_blank">关于网格问题的黑客文章</a></li></ul><h1 id="170c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">来自不同网站的问题列表</h1><ul class=""><li id="a3b5" class="lj lk hu it b iu ko iy kp jc lx jg ly jk lz jo mb lp lq lr dt translated"><a class="ae jp" href="http://practice.geeksforgeeks.org/topics/Dynamic-Programming/" rel="noopener ugc nofollow" target="_blank">练习题——极客给极客</a></li><li id="c9c2" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated"><a class="ae jp" href="https://apps.topcoder.com/forums/?module=Thread&amp;start=0&amp;threadID=674592" rel="noopener ugc nofollow" target="_blank">问题列表—顶部编码器</a></li><li id="db87" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated"><a class="ae jp" href="http://codeforces.com/problemset/tags/dp?order=BY_SOLVED_DESC" rel="noopener ugc nofollow" target="_blank">问题集——代码强制</a></li><li id="16e9" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo mb lp lq lr dt translated"><a class="ae jp" href="https://www.hackerrank.com/domains/algorithms/dynamic-programming" rel="noopener ugc nofollow" target="_blank"> Dp挑战赛— Hackerrank </a></li></ul><p id="ea20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在我的<a class="ae jp" href="https://github.com/nobodyme/dynamic-programming" rel="noopener ugc nofollow" target="_blank"> github链接这里</a>找到更多。希望对你有所帮助。把你的问题写在下面。如果有可以改进的地方，也许可以给我一个拉动请求。<br/>欢迎<a class="ae jp" href="https://twitter.com/_nobodyme_" rel="noopener ugc nofollow" target="_blank">在推特上关注我</a>！<br/>如果你觉得有用，也许<a class="ae jp" href="https://www.patreon.com/nobodyme" rel="noopener ugc nofollow" target="_blank">可以帮我买一台笔记本电脑</a>，干杯！</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><a href="https://www.patreon.com/nobodyme"><div class="fe ff nd"><img src="../Images/b0ccb4e32a4f14f6e7315acecd333fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*i0Mh94LoR2TlVq897jKhMQ@2x.png"/></div></a></figure><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>