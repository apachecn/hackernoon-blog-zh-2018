<html>
<head>
<title>Test code, not sanity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试代码，而不是健全</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/test-code-not-sanity-1e4c0ee51d06?source=collection_archive---------7-----------------------#2018-08-03">https://medium.com/hackernoon/test-code-not-sanity-1e4c0ee51d06?source=collection_archive---------7-----------------------#2018-08-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a272" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">简单的测试变得简单</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/0b1e9e4371fa9a8943632ed52ca7d01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbjV5uRbxrAanpFYJa_31A.jpeg"/></div></div></figure><p id="a284" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">简单这个词有着漫长而肮脏的历史。随着时间的推移，这个意思已经淡化了，以至于今天simple被用作一个普通的无冒犯性的赞美词。让我们快速浏览一下simple的一些常用含义，看看它们如何应用于软件测试<a class="ae kr" href="https://hackernoon.com/tagged/testing" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="b2b5" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">容易的</h1><p id="7084" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">这是最常用的简单定义之一，也可能是最危险的定义之一。<a class="ae kr" href="https://twitter.com/richhickey" rel="noopener ugc nofollow" target="_blank">里奇·希基</a> (Clojure的终身仁慈独裁者)做了一个关于<a class="ae kr" href="https://youtu.be/rI8tNMsozo0?t=50s" rel="noopener ugc nofollow" target="_blank">简单vs容易</a>的完整演讲，但总结一下:容易是主观的，简单是客观的。这个衡量标准更多地依赖于个人能力和经验，而不是任何可以普遍衡量的东西。任务的容易程度与完成任务所需的努力和痛苦成反比。</p><p id="65df" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当应用到测试领域时，这种思维方式导致了<a class="ae kr" href="https://facebook.github.io/jest/docs/en/snapshot-testing.html" rel="noopener ugc nofollow" target="_blank">快照测试</a>和类似的方法。虽然这些肯定很容易设置和编写，但我个人认为它们的价值相当低。他们记录并盲目信任现有的软件实现，而不是指定软件<em class="lp">应该</em>的行为。</p><h1 id="40f5" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">最小的</h1><p id="a683" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">这个定义被被评估的软件的大小和/或数量所困扰。虽然这些方法可以代表简单性，但是还有其他更直接的方法来进行评估。这是第一个意义，有一个客观的衡量标准，可用于比较方法，这是一个积极的。</p><p id="440c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在测试领域，这将引导我们使用单个<code class="eh lq lr ls lt b">assert</code>类型的函数，像<a class="ae kr" href="https://nodejs.org/api/assert.html#assert_assert_value_message" rel="noopener ugc nofollow" target="_blank"> Node.js已经提供的</a>。用户将负责运行测试，并在出现故障时提供故障排除消息。诸如监视模式或代码覆盖率之类的其他特性肯定会被完全忽略。这种工具已经成为测试库广泛期待的工具。最终，用户将创建他们自己的特定测试运行程序代码，这些代码最好作为专用库的一部分来编写。</p><h1 id="2b40" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">整顿</h1><p id="feda" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">这个含义直接来源于单词simple 的词源:</p><blockquote class="lu lv lw"><p id="8b6d" class="jv jw lp jx b jy jz iv ka kb kc iy kd lx kf kg kh ly kj kk kl lz kn ko kp kq hn dt translated">源自中古英语simple，源自古法语和法语simple，源自拉丁语simplex(“simple”，字面意思为“onefold”)，源自sim-(“the same”)+plica re(“to fold”)。</p></blockquote><p id="190b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Rich Hickey坚信simple的这种用法，并在我之前链接的他的演讲中详细阐述了这一点。为了理解我们的意思，我们从几条直线的图表开始:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ma"><img src="../Images/d121e182d3291bfaf1df8aeb85cdaa86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85dKGTcoqQoVlk7GxboCDw.png"/></div></div></figure><p id="708f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">想象这些线是软件依赖或执行的线程。显而易见的是，这些是没有缠结的，因此是简单的。</p><p id="a5f1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，如果我们增加线的数量，但没有线重叠，这仍然是简单的:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ma"><img src="../Images/042bf91bccf165284831739be6b3c144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbO6o5TC0s322FWlivClyQ.png"/></div></div></figure><p id="e199" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">仍然可以独立考虑任何一条线。</p><p id="34f7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，如果相同数量的线纠缠在一起，那么我们就引入了复杂性:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ma"><img src="../Images/7469f46b6d6f893ecba4203923069c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYwHilffiu4kIpWVt55v6g.png"/></div></div></figure><p id="a2eb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">减少行数也不会使这变得简单:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ma"><img src="../Images/9243d1f8e7ba7ea426c6a49cbeaf0c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ft7QWGR2thEphxNgtMARLg.png"/></div></div></figure><p id="0343" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果不考虑第二线和第三线之间的相互影响，仍然不可能孤立地对它们进行推理。避免混乱是你的软件的一个很好的目标。这是简单的必要前提，但不是充分条件。为了填补空白，我们必须看看simple的原始定义，而不仅仅是它的词源。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mb"><img src="../Images/174e03d75bf79745eb363f1053390716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAi66gvABXI4_-eD-cRDaA.jpeg"/></div></div></figure><h1 id="c425" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">非化合的</h1><p id="b7f9" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">对于simple的最终用法，我们需要看一下<a class="ae kr" href="https://en.wiktionary.org/wiki/simple#Adjective" rel="noopener ugc nofollow" target="_blank">技术词典的定义</a>:</p><ol class=""><li id="01ab" class="mc md hu jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">(<em class="lp">化学</em>)由单一物质组成的；<strong class="jx hv">未复合</strong>。</li><li id="24df" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">(<em class="lp">数学</em>)群的:没有正规子群的。</li><li id="9b2e" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">(<em class="lp">植物学</em> ) <strong class="jx hv">不是</strong> <strong class="jx hv">复叶</strong>，但可能有裂片。</li><li id="86e8" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">(<em class="lp">动物学</em>)由单个个体或动物群组成的；<strong class="jx hv">非复合</strong>。</li></ol><p id="c895" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这些定义的共同主题是明确的。如果一个东西可以被分解成独立有用的部分，那么这个意义上的它可以变得更简单。项目管理中的许多最佳实践都是围绕着将任务分解成可消化/可理解的部分，这些都有相关的动机。这个概念类似于术语<em class="lp">原子</em>，因为它涉及到计算机科学。Stuart hallo way(clo jure的另一个主要贡献者)有他自己的关于简单性的<a class="ae kr" href="https://youtu.be/cidchWg74Y4?t=10m25s" rel="noopener ugc nofollow" target="_blank">演讲</a>，非常全面地涵盖了简单的这个和其他定义。</p><p id="8442" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">虽然uncompounded是相对客观的(类似于untangled)，但确定评估简单性的适当级别是很重要的。一般来说，这种方法应用于软件，特别是应用于代码时，会有一些实际的限制。编译器和相关工具引入了复杂性，但避免在汇编、机器码甚至处理器背后的底层物理等层次上考虑太简单的程序。</p><p id="4871" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">达到这个目标需要重新思考应该用什么基本元素来构建软件。世界上的Lisps很久以前就通过将代码表示为数据解决了这个问题。很难想出一个比列表更不可分割的结构，以一种仍然是图灵完整的方式来表示代码。这将指针从命令式代码移向声明式代码。如果我们可以为我们的测试做一些类似的事情呢？</p><h2 id="eb2f" class="mq kt hu bd ku mr ms mt ky mu mv mw lc ke mx my le ki mz na lg km nb nc li nd dt translated">这个悬念的答案在我的下一篇文章中:</h2><div class="ne nf fm fo ng nh"><a href="https://hackernoon.com/ban-software-defects-c96cb4d015dc" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab ej"><div class="nj ab nk cl cj nl"><h2 class="bd hv fv z el nm eo ep nn er et ht dt translated">禁止软件缺陷</h2><div class="no l"><h3 class="bd b fv z el nm eo ep nn er et ek translated">被认为有害的测试</h3></div><div class="np l"><p class="bd b gc z el nm eo ep nn er et ek translated">hackernoon.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jt nh"/></div></div></a></div></div><div class="ab cl nw nx hc ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="hn ho hp hq hr"><p id="e889" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">欢迎给我留言或者发牢骚到<a class="ae kr" href="http://twitter.com/okwolf" rel="noopener ugc nofollow" target="_blank"> @okwolf </a>！</p><h1 id="2b20" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt">🐺</h1><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="od oe l"/></div></figure></div></div>    
</body>
</html>