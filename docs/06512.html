<html>
<head>
<title>Using Ethereum smart contracts on the client side</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在客户端使用以太坊智能合约</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-ethereum-smart-contracts-on-the-client-side-3d1337b2820a?source=collection_archive---------8-----------------------#2018-08-04">https://medium.com/hackernoon/using-ethereum-smart-contracts-on-the-client-side-3d1337b2820a?source=collection_archive---------8-----------------------#2018-08-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="86cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近在做一个项目，试图构建一个从客户端部署的智能契约。这个想法是允许人们上传乘车请求(以及任何种类的购买请求)作为以太坊网络上的智能合同。任何人都可以对它出价，然后所有者可以选择他想从谁那里购买。交易在以太网和weis中进行，每个人都需要存款作为参与交易的担保。</p><p id="01bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多方法可以做到这一点。你可以信任每一个使用你服务的人，并把你的信用借给他们。你可以代表参与者自己持有担保。你可以让银行参与进来。所有这些之间的区别在于谁在充当托管人。</p><p id="7ceb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想在以太坊上使用可靠性合同。我有三种方法可以做到这一点。我可以运行一个与我维护的后端通信的前端。后端将与区块链通信，并将交易信息反馈给客户端。这包括建立一个用户账户管理系统——我最终也完成了——和一个与区块链对话的节点服务器。这也会使用户的UX更加容易。</p><p id="35e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我可以尝试整合第三方钱包提供商，如coinbase或其他。这也会保持UX的简单，也允许其他货币的交易。在这两种情况下，我都必须运行后端。我很好奇要让它完全去中心化。</p><p id="a312" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我想在应用程序的前端部署区块链并与之交互。我可以通过编写和测试智能合同来做到这一点。一旦我确定了它的正确性，我就会编译它并把它放到网上。然后，应用程序可以获取此合同，并部署/使用它。理想情况下，我也希望在前端进行编译，但这可能会给前端带来不必要的开销。目前的方法是好的。</p><p id="978a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会进入UI和其他服务，这是应用程序的一部分。无论应用程序的其他部分如何，与区块链的通信都是一样的。</p><div class="jp jq fm fo jr js"><a href="https://github.com/O-LAP/contracts/blob/master/contracts/DeliveryRequest.sol" rel="noopener  ugc nofollow" target="_blank"><div class="jt ab ej"><div class="ju ab jv cl cj jw"><h2 class="bd hv fv z el jx eo ep jy er et ht dt translated">o-LAP/合同</h2><div class="jz l"><h3 class="bd b fv z el jx eo ep jy er et ek translated">合同-O-LAP的合同</h3></div><div class="ka l"><p class="bd b gc z el jx eo ep jy er et ek translated">github.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg kh js"/></div></div></a></div><p id="3899" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是用白纸黑字写的合同。这是一个非常简单的投标合同。我做了一些非常基本的测试。</p><div class="jp jq fm fo jr js"><a href="https://remix.ethereum.org" rel="noopener  ugc nofollow" target="_blank"><div class="jt ab ej"><div class="ju ab jv cl cj jw"><h2 class="bd hv fv z el jx eo ep jy er et ht dt translated">混合可靠性集成开发环境</h2><div class="jz l"><h3 class="bd b fv z el jx eo ep jy er et ek translated">编辑描述</h3></div><div class="ka l"><p class="bd b gc z el jx eo ep jy er et ek translated">remix.ethereum.org</p></div></div></div></a></div><p id="95c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我使用<a class="ae ki" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"> remix </a>来编译合同，以获得合同ABI和字节码。我把这两个硬编码到我的应用程序中，但理想情况下，我想把它们放在网上，只在应用程序中存储链接。</p><div class="jp jq fm fo jr js"><a href="https://ethereum.stackexchange.com/questions/27536/where-to-find-contract-abi-in-new-version-of-online-remix-solidity-compiler" rel="noopener  ugc nofollow" target="_blank"><div class="jt ab ej"><div class="ju ab jv cl cj jw"><h2 class="bd hv fv z el jx eo ep jy er et ht dt translated">在哪里可以找到新版本的在线混音可靠性编译器的合同ABI？</h2><div class="jz l"><h3 class="bd b fv z el jx eo ep jy er et ek translated">在线remix solidity编译器最近更改设计后，我想不出在哪里可以找到合同的…</h3></div><div class="ka l"><p class="bd b gc z el jx eo ep jy er et ek translated">ethereum.stackexchange.com</p></div></div><div class="kb l"><div class="kj l kd ke kf kb kg kh js"/></div></div></a></div><p id="2ba6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个链接对于提取合同的ABI和字节码可能很有用。</p><p id="4317" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当有人创建新的购买请求并从已部署的合同中读取值以显示信息时，应用程序部署新的合同，并调用不同的方法从合同中投标、奖励和要求奖励。我假设客户会安装<a class="ae ki" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank">元掩码</a>来管理他们的钱包。</p><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="3c4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个要点显示了我是如何根据用户请求部署合同的。我遇到的一种情况是，我试图部署一个契约，并立即调用它的一个方法。因此，用户将单击按钮，这将从MetaMask打开部署契约请求，几秒钟后(mainnet上为几分钟)调用契约上的一个方法，用相关信息初始化它。理想情况下，用户只需一次点击就能完成。</p><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="7b14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我有了部署的契约地址，这就是我调用契约上的方法的方式。</p><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="c6b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我有了地址，我就是这样从已部署的契约中读取值的。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="1efb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我仍然遇到一个CORS的问题，我需要解决。但我对此有一些想法。</p><p id="2ec6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">优点:</p><ul class=""><li id="44cb" class="ky kz hu it b iu iv iy iz jc la jg lb jk lc jo ld le lf lg dt translated">分散的</li><li id="3d3a" class="ky kz hu it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg dt translated">我不运行任何后端。*</li><li id="83fb" class="ky kz hu it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg dt translated">应用程序可以始终保持最新。</li></ul><p id="1b75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">骗局</p><ul class=""><li id="d06a" class="ky kz hu it b iu iv iy iz jc la jg lb jk lc jo ld le lf lg dt translated">UX受到限制。</li><li id="61cd" class="ky kz hu it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg dt translated">期望用户有元掩码。</li><li id="d125" class="ky kz hu it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg dt translated">部署合同中的错误是不可修复的。</li><li id="7d09" class="ky kz hu it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg dt translated">我确实需要为应用程序的其他部分运行后端服务器。</li></ul><p id="6005" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这看起来是一个值得尝试的方法。缺点中列出的问题是可以解决的，或者是我们已经存在的问题。</p></div><div class="ab cl kr ks hc kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hn ho hp hq hr"><p id="915e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lm">Amit Nambiar为O-lap撰写的文章</em></p></div></div>    
</body>
</html>