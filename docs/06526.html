<html>
<head>
<title>How to create a navigation UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建导航用户界面</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-create-a-navigation-ui-bac94a9e51fa?source=collection_archive---------6-----------------------#2018-08-05">https://medium.com/hackernoon/how-to-create-a-navigation-ui-bac94a9e51fa?source=collection_archive---------6-----------------------#2018-08-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5129" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">用普通Javascript创建交互式信息图(第二部分)</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/2eb05b6cbecab2b26ff2c5df21e5688b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Iodzg4afa-nQKOsavUqQag.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Navigation UI for large canvases</figcaption></figure><h2 id="bb5c" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">概述</h2><p id="0469" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">本文是关于用普通Javascript创建交互式信息图的五部分系列文章。</p><p id="ab13" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">到目前为止，我们已经设计了一个模式和一个视图引擎。然而，信息图表设计的可用性仍然受到浏览器窗口大小的限制。为了支持更大的画布，我们可以从原生Javascript中找到现成的答案。</p><h2 id="4a27" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">目标</h2><p id="c7db" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">让我们创建浏览大画布的导航功能。</p><h2 id="f117" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">介绍</h2><p id="2d92" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">把信息图想象成一片森林。有了大量的信息要呈现，设计者可能会想把整个森林挤进一个浏览器窗口。文本、形状和图像变得过于网状，人眼看起来不舒服。</p><p id="aae1" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">另一方面，设计师可能会将布局分割成更小的部分，并以独立页面的形式呈现。游客可能看到了树木，却失去了森林。</p><p id="5d36" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">为什么不让用户调整细节的级别，使信息量总是与用户的需求相关联呢？</p><h2 id="1f17" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">概念</h2><p id="5519" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">想象在地图上拿着一面“镜子”。我们移动地图本身，而不是移动镜子来检查地图的不同部分。这个效果是通过一个叫做<code class="eh lv lw lx ly b">overflow</code>的CSS特性实现的。通过操作其属性，我们可以创建4种强大的导航效果:</p><ul class=""><li id="5ba5" class="lz ma hu kz b la lq ld lr kk mb ko mc ks md lp me mf mg mh dt translated">滚动(通过X和Y滚动条)</li><li id="38b0" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated">平移(根据光标的相对位置)</li><li id="a117" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated">抓取并拖动(通过光标的移动)</li><li id="db83" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated">放大(或缩小)</li></ul><h2 id="61a8" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">开始—准备画布</h2><p id="d5d2" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">创建一个名为<code class="eh lv lw lx ly b">canvas</code>的变量来引用地图。这是父容器。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="a34b" class="jz ka hu ly b fv mr ms l mt mu">var canvas = document.getElementById(“parent<!-- -->Container<!-- -->”);</span></pre><h2 id="acf9" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">卷起</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mv"><img src="../Images/18461541fbff59eb3a292d3ea43d02c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fIRjfdVkqJFJlsDPwsvZ0A.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Scroll vertically and horizontally</figcaption></figure><p id="28a7" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">第一种技术<code class="eh lv lw lx ly b">scroll</code>是用一个简单的CSS创建的:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="510a" class="jz ka hu ly b fv mr ms l mt mu">div {<br/>    overflow:scroll;<br/>}</span></pre><p id="435c" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><code class="eh lv lw lx ly b">overflow</code>控制内容的显示方式。把这个属性想象成一个中间有一个剪切窗口的假想覆盖图。<code class="eh lv lw lx ly b">overflow</code>是我们的虚拟镜子。</p><p id="2222" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">玻璃下面是森林(即<code class="eh lv lw lx ly b">canvas</code>)本身。<code class="eh lv lw lx ly b">scroll</code>告诉浏览器水平或垂直移动底层画布(或通过触控板同时移动)。透过那个窗口只能看到森林中暴露的部分。</p><h2 id="d172" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">防止意外相互作用</h2><p id="1110" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">我们不希望用户在浏览其他内容时无意中移动了<code class="eh lv lw lx ly b">canvas</code>。您可以通过一个基本的HTML按钮在<code class="eh lv lw lx ly b">scroll</code>和<code class="eh lv lw lx ly b">hidden</code>的UI状态之间切换来防止这种情况。你可能希望<code class="eh lv lw lx ly b">hidden</code>成为默认的CSS行为(即锁定X和Y滚动)。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="2b96" class="jz ka hu ly b fv mr ms l mt mu">canvas.style.overflow = "hidden";</span></pre><p id="7874" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">当游客准备好探索<code class="eh lv lw lx ly b">canvas</code>时，让他们切换到<code class="eh lv lw lx ly b">scroll</code>。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="8db8" class="jz ka hu ly b fv mr ms l mt mu">canvas.style.overflow = "scroll";</span></pre><p id="d4df" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><code class="eh lv lw lx ly b">scroll</code>是默认的浏览器功能。您不必编写任何自定义处理程序。</p><p id="9497" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">让我们继续下一个导航功能。</p><h2 id="85f0" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">平底锅</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mw"><img src="../Images/bb51abbd679b651d3b7e239e7adddbaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yFauAHbcofKqduzBn_asPA.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Pan by holding down the right mouse button and moving the mouse simultaneously</figcaption></figure><p id="b63a" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">无论<code class="eh lv lw lx ly b">canvas</code>的大小如何，都可以快速浏览整个画布，而无需使用鼠标垫。按住鼠标右键并同时移动鼠标即可激活此功能。</p><p id="57fd" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">使用鼠标光标的位置计算新的相对滚动值(见粗体)。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="134c" class="jz ka hu ly b fv mr ms l mt mu">canvas.addEventListener("mousemove", handlerMove, false);<br/>function handlerMove(event) {<br/>    if (event.which == 3) { // use right button to pan<br/>    <strong class="ly hv">canvas.scrollTo( event.clientX , event.clientY );</strong><br/>    }<br/>}</span></pre><ul class=""><li id="8456" class="lz ma hu kz b la lq ld lr kk mb ko mc ks md lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">mousemove</code>监听任何被按下(未释放)的鼠标按键。</li><li id="008b" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">event.which == 3</code>检测鼠标右键。<code class="eh lv lw lx ly b">event.which == 1</code>探测左侧。<code class="eh lv lw lx ly b">event.which == 2</code>检测中间的滚动按钮。</li><li id="9479" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">event.clientX</code>和<code class="eh lv lw lx ly b">event.clientY</code>提供鼠标光标的当前坐标。</li></ul><p id="d403" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><strong class="kz hv">设置鼠标按键</strong>。让我们为“平移”导航保留鼠标右键。由于浏览器默认显示鼠标右键的上下文菜单，我们需要指示浏览器给我们这样的控制:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="ff1b" class="jz ka hu ly b fv mr ms l mt mu">canvas.addEventListener(‘contextmenu’, <br/>    function(event) {<br/>        event.preventDefault();<br/>    },<br/>false);</span></pre><h2 id="614b" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">抓住并拖动</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mx"><img src="../Images/3791feb89c7afd3013109ef92e3cfe25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mcafopjWRQS8xCoO0bJG_A.gif"/></div></div></figure><p id="4650" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">两个概念协力创造了这种效果。</p><p id="966a" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><strong class="kz hv">动作和反应</strong>。让我们把<code class="eh lv lw lx ly b">canvas</code>放在桌面上，把鼠标光标想象成我们的手指。当我们用一个手指抵住画布并推动它时，我们的手指被认为移动了一定的X和Y距离。类似地，画布移动相同的X和Y距离。手指引起了一个<strong class="kz hv">动作。</strong>反应是<strong class="kz hv">反映</strong>画布移动的程度。</p><p id="fe7f" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><strong class="kz hv">鼠标光标增量。</strong>我们想要<strong class="kz hv">镜像</strong>这个距离作为画布上的反应。换句话说，画布应该精确地移动光标移动的距离。让我们称这个值为鼠标光标增量。</p><p id="42a8" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">用一个非常简单的公式计算:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="302c" class="jz ka hu ly b fv mr ms l mt mu">start coordinates - end coordinates</span></pre><p id="d3de" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">结果应该实时更新为新的滚动值。透过我们想象中的窗口，一个访问者会觉得好像她用鼠标拖动了画布。</p><p id="c8b7" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><em class="my">提示:“鼠标增量值”只是一个标签，与</em> <code class="eh lv lw lx ly b"><em class="my">WheelEvent.deltaX</em></code> <em class="my">浏览器事件不同。</em></p><p id="ee50" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><strong class="kz hv">实现</strong>。添加一个事件监听器<code class="eh lv lw lx ly b">mousedown</code>来检测鼠标左键的按下。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="52a6" class="jz ka hu ly b fv mr ms l mt mu">canvas.addEventListener("mousedown", handlerGrab, false);</span><span id="bfcf" class="jz ka hu ly b fv mz ms l mt mu">function handlerGrab(event) {<br/>    if (event.which == 1) {<br/>        mouseDownBoolean = true;<br/>        // Find the initial scroll value<br/>        // Capture the initial mouse cursor position<br/>        ...<br/>    };<br/>}</span></pre><ul class=""><li id="acd1" class="lz ma hu kz b la lq ld lr kk mb ko mc ks md lp me mf mg mh dt translated">用<code class="eh lv lw lx ly b">event.which == 1</code>分配鼠标左键。</li><li id="ea51" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">mouseDownBoolean</code>告知其他相关功能鼠标左键当前是否按下。</li></ul><p id="5afc" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">一前一后添加<code class="eh lv lw lx ly b">mousemove</code>和<code class="eh lv lw lx ly b">mouseup</code>监听器来拖动和释放画布。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="6162" class="jz ka hu ly b fv mr ms l mt mu">canvas.addEventListener("mousemove", elementDrag, false);</span><span id="fed5" class="jz ka hu ly b fv mz ms l mt mu">function elementDrag(event) {<br/>    if (mouseDownBoolean){<br/>        // Calculate the delta after the mouse cursor has moved<br/>        // scroll to the new position<br/>        ...<br/>    }<br/>};</span><span id="9220" class="jz ka hu ly b fv mz ms l mt mu">canvas.addEventListener("mouseup", elementDragclose, false);</span><span id="da30" class="jz ka hu ly b fv mz ms l mt mu">function elementDragclose() {<br/>    if (mouseDownBoolean){<br/>        mouseDownBoolean = true;  // "releases" the drag<br/>        //  change the cursor icon dynamically<br/>    }<br/>};</span></pre><ul class=""><li id="c92e" class="lz ma hu kz b la lq ld lr kk mb ko mc ks md lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">mousemove</code>触发自定义函数<code class="eh lv lw lx ly b">elementDrag</code>拖动画布。</li><li id="8da1" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">mouseDownBoolean</code>仅当鼠标左键也按下时(由<code class="eh lv lw lx ly b">handlerGrab</code>设置)，动作才有效。</li><li id="cc0a" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">mouseup</code>检测到<strong class="kz hv">三步序列</strong>的结束，调用<code class="eh lv lw lx ly b">elementDragclose</code>复位UI状态。</li></ul><p id="d8a8" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">按顺序检测所有三个动作:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="f29b" class="jz ka hu ly b fv mr ms l mt mu">1. Press &amp; hold the left mouse button<br/>2. Grab and drag the cursor some X and Y distances<br/>3. Release the mouse button</span></pre><p id="551a" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">在<strong class="kz hv"> </strong> <code class="eh lv lw lx ly b">if (event.which == 1) {…}</code>代码块内，我们可以用<code class="eh lv lw lx ly b">getBoundingClientRect()</code>找到起始滚动值:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="9ce6" class="jz ka hu ly b fv mr ms l mt mu">var distanceToTop = canvas.getBoundingClientRect().top;<br/>var distanceToLeft = canvas.getBoundingClientRect().left;</span></pre><p id="aa10" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">并捕捉鼠标光标的初始位置(在它移动之前):</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="625f" class="jz ka hu ly b fv mr ms l mt mu">var posXdelta = 0, posYdelta = 0, posX = 0, posY = 0;</span><span id="0486" class="jz ka hu ly b fv mz ms l mt mu">myBox = e || window.event;<br/>posX = myBox.clientX - distanceToLeft;<br/>posY = myBox.clientY - distanceToTop;</span></pre><p id="77dd" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">在代码块<code class="eh lv lw lx ly b">elementDrag(event),</code>中找到终点坐标，并计算最终的增量值:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="0a59" class="jz ka hu ly b fv mr ms l mt mu">posXdelta = pos3 - ( myBox.clientX - distanceToLeft );<br/>posYdelta = pos4 - ( myBox.clientY - distanceToTop );</span></pre><p id="cdee" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">并命令浏览器“滚动”到其新的相对位置:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="9d3c" class="jz ka hu ly b fv mr ms l mt mu">var newX = canvas.scrollLeft + posXdelta;<br/>var newY = canvas.scrollTop + posYdelta;<br/>canvas.scrollTo( newX , newY );</span></pre><ul class=""><li id="d0bd" class="lz ma hu kz b la lq ld lr kk mb ko mc ks md lp me mf mg mh dt translated">管理您的变量<code class="eh lv lw lx ly b">mouseDownBoolean</code>、<code class="eh lv lw lx ly b">pos1</code>、<code class="eh lv lw lx ly b">pos2</code>、<code class="eh lv lw lx ly b">pos3</code>、<code class="eh lv lw lx ly b">pos4</code>、<code class="eh lv lw lx ly b">distanceToTop</code>、<code class="eh lv lw lx ly b">distanceToLeft</code>，以便上面提到的函数可以访问它们。</li></ul><p id="5c88" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><em class="my">提示:如果你将一个节点元素显示为带有</em> <code class="eh lv lw lx ly b"><em class="my">&lt;img&gt;</em></code> <em class="my">标签的图像，那么要防止它被意外拖出窗口。</em></p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="2937" class="jz ka hu ly b fv mr ms l mt mu">itemElementName[i].ondragstart = function(){ return false; };</span></pre><h2 id="057b" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">不要遗漏次要的细节</h2><p id="690e" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">用尖尖的箭头光标拖动东西会不会感觉怪怪的？换成代码块<code class="eh lv lw lx ly b">elementDrag(event)</code>内的<code class="eh lv lw lx ly b">grab</code>光标(即手形图标)怎么样？</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="5cd0" class="jz ka hu ly b fv mr ms l mt mu">canvas.style.cursor = "-webkit-grab";<br/>// supports Chrome, Safari and Opera</span></pre><p id="1a9b" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">更好的是，添加一个动画效果<code class="eh lv lw lx ly b">grabbing</code>,每当鼠标按钮被按下时显示“正在抓取”。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="a64b" class="jz ka hu ly b fv mr ms l mt mu">canvas.style.cursor = "-webkit-grabbing";</span></pre><p id="1324" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">请记住，一旦松开鼠标按钮，就在代码块<code class="eh lv lw lx ly b">elementDragclose()</code>处重置UI状态。</p><h2 id="1d5c" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">一款云视频会议软件</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff na"><img src="../Images/9e33415a7b497c07367477ea453b2edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QvtbWjRhw1tyDk3CcmmjLQ.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Zoom with mouse-scroll button</figcaption></figure><p id="6389" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">使用滚动按钮进行缩放。要放大并查看细节，请向上滚动。要缩小并查看更大的图片，请向下滚动。像这样使用<code class="eh lv lw lx ly b">wheel</code>:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="1887" class="jz ka hu ly b fv mr ms l mt mu">canvas.addEventListener("wheel", handlerWheel);</span></pre><p id="573a" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><code class="eh lv lw lx ly b">zoom</code>通过操纵数值。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="5914" class="jz ka hu ly b fv mr ms l mt mu">canvas.style.zoom = 1;</span></pre><p id="ddcf" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">结构如下:</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="12f7" class="jz ka hu ly b fv mr ms l mt mu">canvas.addEventListener("wheel", handlerWheel);</span><span id="07ab" class="jz ka hu ly b fv mz ms l mt mu">function handlerWheel(event) {</span><span id="ceb9" class="jz ka hu ly b fv mz ms l mt mu">    if (zoomAllow) {<br/>        if (event.wheelDelta === 100) {<br/>            zoomLevel = zoomLevel + 0.1;<br/>            if (zoomLevel &gt; 3){<br/>                ...<br/>            }<br/>        } else if (event.wheelDelta === -100) {<br/>            zoomLevel = zoomLevel - 0.1;<br/>            if (zoomLevel &lt; 0.3){<br/>                ...<br/>            }<br/>        }<br/>    }</span><span id="6ead" class="jz ka hu ly b fv mz ms l mt mu">}</span></pre><ul class=""><li id="3014" class="lz ma hu kz b la lq ld lr kk mb ko mc ks md lp me mf mg mh dt translated">防止意外的<code class="eh lv lw lx ly b">wheel</code>交互是一个很好的做法。我们还应该区分窗口<code class="eh lv lw lx ly b">scroll</code>动作和<code class="eh lv lw lx ly b">zoom</code>动作。使用布尔值<code class="eh lv lw lx ly b">zoomAllow</code>在缩放和滚动“模式”之间切换。</li><li id="bd33" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated">使用<code class="eh lv lw lx ly b">event.wheelDelta</code>设置缩放计数的阈值。</li><li id="e3b0" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated">保持一个变量<code class="eh lv lw lx ly b">zoomLevel</code>以递增和平滑地缩放。值越小，缩放越精细。接受小数。考虑添加缓动行为以平滑地制作动画。</li><li id="771c" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated">使用条件语句<code class="eh lv lw lx ly b">if (zoomLevel &gt; myNumber)</code>设置最大和最小缩放范围。</li></ul><p id="ae72" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><strong class="kz hv">保持焦点</strong>。缩放后，绝对X和Y滚动值将保持不变。这将在每次缩放时将画布“跳转”到新的相对滚动位置。让我们写一个方法来“记住”原来的焦点区域。</p><pre class="jk jl jm jn fq mn ly mo mp aw mq dt"><span id="aff7" class="jz ka hu ly b fv mr ms l mt mu">var prevRatioX = (canvas.scrollLeft) / (canvas.scrollWidth - canvas.clientWidth);<br/>var prevRatioY = (canvas.scrollTop) / (canvas.scrollHeight - canvas.clientHeight);</span><span id="28f6" class="jz ka hu ly b fv mz ms l mt mu">var newX = prevRatioX * (canvas.scrollWidth - canvas.clientWidth);<br/>var newY = prevRatioY * (canvas.scrollHeight - canvas.clientHeight)</span><span id="d24e" class="jz ka hu ly b fv mz ms l mt mu">canvas.scrollTo( newX , newY );</span></pre><ul class=""><li id="e62d" class="lz ma hu kz b la lq ld lr kk mb ko mc ks md lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">prevRatioX</code>和<code class="eh lv lw lx ly b">prevRatioY</code>计算滚动比(缩放前)。</li><li id="d58e" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">newX</code>和<code class="eh lv lw lx ly b">newY</code>重新计算新的相对滚动值(缩放后)。</li><li id="634d" class="lz ma hu kz b la mi ld mj kk mk ko ml ks mm lp me mf mg mh dt translated"><code class="eh lv lw lx ly b">scrollTo</code>告诉浏览器回到之前的相对位置。</li></ul><h2 id="3a5b" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">后续步骤</h2><p id="eb41" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">我们通过4个导航功能增强了视图引擎。</p><p id="9262" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">让我们用导航小工具让它更上一层楼。</p></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><h2 id="7681" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">到其他部分的链接</h2><p id="180d" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">第一部分为设计交互式信息图奠定了基础。</p><p id="2c8c" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><strong class="kz hv">第二部分→ </strong> <em class="my">你现在在这里。</em></p><p id="1043" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><a class="ae ni" rel="noopener" href="/@PageiiStudio/how-to-create-a-two-way-navigation-map-e96600a73cbd"> <strong class="kz hv"> Part-three </strong>增加动态小地图，增强导航。</a></p><p id="2934" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><a class="ae ni" rel="noopener" href="/@PageiiStudio/how-to-create-a-progressive-ui-to-enhance-presentation-cc42fe97360c"> <strong class="kz hv"> Part-four </strong>增加了一个内嵌UI来访问分层内容。</a></p><p id="64ee" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">第五部分展示了为什么创建具有人情味的用户界面如此容易。</p></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><p id="11f0" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">如果你喜欢这个故事，你可以在<a class="ae ni" href="https://pageii.com/story;title=How-to-create-a-navigation-UI" rel="noopener ugc nofollow" target="_blank"> Pageii工作室</a>找到更多。</p></div></div>    
</body>
</html>