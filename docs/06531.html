<html>
<head>
<title>Demystified Big O: On Computational Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘大O:论计算复杂性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/demystified-big-o-on-computational-complexity-2d25b0ae0dac?source=collection_archive---------11-----------------------#2018-08-05">https://medium.com/hackernoon/demystified-big-o-on-computational-complexity-2d25b0ae0dac?source=collection_archive---------11-----------------------#2018-08-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3e57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你曾经有机会和你的工程师同事讨论软件性能，你可能已经注意到，我们很多人喜欢用这个臭名昭著的“<a class="ae jp" href="https://hackernoon.com/tagged/big-o" rel="noopener ugc nofollow" target="_blank"> Big O </a>”来解释为什么某些东西运行得慢(或快)。</p><p id="e86c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能听说过“在多项式时间内运行”或“指数”或“<a class="ae jp" href="https://hackernoon.com/tagged/logarithmic" rel="noopener ugc nofollow" target="_blank">对数</a>”的东西，以及其中一些如何比其他的更好，但你从未听到过它们为什么更好的实际解释。</p><p id="4d9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我个人的经验是，当谈到算法讨论时，人们很少费心去解释与其他算法相比，某个算法在哪些方面表现得更好？如果我告诉你，谈到驾驶速度，宝马比越野车快得多，你可能会立即注意到有一个问题——测量它们性能的条件截然不同。</p><p id="247e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们讨论算法时，可以也应该使用同样的逻辑——在贴上标签之前考虑一下上下文。但是，在我们深入实际的定义和解释之前，让我们快速浏览一下在讨论算法性能时对大O的常见误解。</p><h1 id="8b83" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">常见的误解</h1><ul class=""><li id="2d31" class="ko kp hu it b iu kq iy kr jc ks jg kt jk ku jo kv kw kx ky dt translated">大O测量速度</li></ul><p id="cd3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是你在与还没有完全掌握概念的人讨论复杂性时最有可能听到的一句话。大多数时候，大O不能告诉你任何关于算法实际运行时间的信息。</p><ul class=""><li id="a694" class="ko kp hu it b iu iv iy iz jc kz jg la jk lb jo kv kw kx ky dt translated">大O是关于时间的陈述</li></ul><p id="e006" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然部分正确，但根据定义，这不仅仅是时间的问题。大O可以用来描述空间复杂度以及时间复杂度，或者任何其他复杂度，如果你愿意的话。</p><h1 id="95f8" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">大O其实是什么？</h1><p id="57f7" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">从软件工程的角度来看，我喜欢使用的一个定义是，大O实际上代表了<em class="lf">事情变得非常糟糕的速度</em>。例如，看看下面的问题:</p><ul class=""><li id="bd62" class="ko kp hu it b iu iv iy iz jc kz jg la jk lb jo kv kw kx ky dt translated"><em class="lf">在我的web服务器出现故障之前，我可以承受的流量增加量是多少？</em></li><li id="57ba" class="ko kp hu it b iu lg iy lh jc li jg lj jk lk jo kv kw kx ky dt translated"><em class="lf">在我的定制JSON反序列化器失败之前，HTTP请求体可以变得多大？</em></li><li id="6f8a" class="ko kp hu it b iu lg iy lh jc li jg lj jk lk jo kv kw kx ky dt translated"><em class="lf">为什么我的图像处理器可以很好地处理2 KB的图像，但处理10KB的图像却需要很长时间？</em></li></ul><p id="5363" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这些是你发现自己无法回答的问题，你可能有一个需要正确的时间复杂性识别和潜在补救措施的问题。能够认识到复杂性的潜在问题可能会为您节省数小时或数天不必要的性能监控和检查。</p><p id="7c93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们深入研究，尝试一个不同的定义。</p><blockquote class="ll lm ln"><p id="603f" class="ir is lf it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">给定大小为n的输入，Big O描述了算法需要执行的相关原始操作数的上限。</p></blockquote><p id="f67e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这在数学上是不正确的，也有些模糊，但仍然是一个很好的起点——让我们深入研究一下，稍后我们将讨论更正式的定义。</p><h2 id="37ff" class="lr jr hu bd js ls lt lu jw lv lw lx ka jc ly lz ke jg ma mb ki jk mc md km me dt translated">原始操作</h2><p id="3b2b" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">什么是原始操作？</p><blockquote class="ll lm ln"><p id="d8e1" class="ir is lf it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated"><strong class="it hv">原始操作</strong>是由算法执行的基本计算。例如，计算表达式、给变量赋值、索引数组、调用方法、从方法返回等等。它们在伪代码中很容易识别，并且在很大程度上独立于编程语言。</p></blockquote><p id="b82c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一个例子:</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="f0c1" class="lr jr hu mk b fv mo mp l mq mr">public void SimpleFunction(List&lt;int&gt; n)<br/>{<br/>  int a = 1;<br/>  int b = 2;<br/>  int sum = a + b;<br/>  Console.WriteLine(sum);<br/>}</span></pre><p id="43ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们这里有多少原始操作？让我们来分解一下:</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="c310" class="lr jr hu mk b fv mo mp l mq mr">public void SimpleFunction(List&lt;int&gt; n)<br/>{<br/>  int a; // declaration<br/>  a = 1; // assignment<br/>  int b; // declaration<br/>  b = 2; // assignment<br/>  int sum; // declaration<br/>  sum = a + b; // two primitive operations, addition and assignment<br/>  Console.WriteLine(sum); // method call<br/>}</span></pre><p id="2468" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，我们有三个声明，三个赋值，加法和一个方法调用。如果我们同意这是我们的基本操作，我们应该能够计算出:给定n的输入大小，该函数将执行的操作数是8，或者更正式地说，f(n) = 8。</p><p id="1dbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以清楚地看到，输入的大小在这里一点也不重要，这个函数将总是执行相同的、恒定数量的操作。</p><p id="a7f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们尝试一个不同的方法:</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="46ed" class="lr jr hu mk b fv mo mp l mq mr">public void SumFunction(List&lt;int&gt; n)<br/>{<br/>  int sum = 0;<br/>  for (int i = 0; i &lt; n.Count; i++)<br/>  {<br/>    sum = sum + i;<br/>  }<br/>  Console.WriteLine(sum);<br/>}</span></pre><p id="0a21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个看起来更难打破，但是让我们试一试。让我们更容易的一件事是将这个for循环转换成一个相同的while循环。</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="f877" class="lr jr hu mk b fv mo mp l mq mr">public void SumFunction(List&lt;int&gt; n)<br/>{<br/>  int sum; <br/>  sum = 0; <br/>  int i; <br/>  i = 0;<br/>  <br/>  while (i &lt; n.Count) // n comparisons<br/>  { <br/>    sum = sum + i; // n additions and assignments<br/>    i = i + 1; // n additions and assignments<br/>  }</span><span id="2965" class="lr jr hu mk b fv ms mp l mq mr">  sum = sum + 5; // one addition and one assignment<br/>  Console.WriteLine(sum);<br/>}</span></pre><p id="e490" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很明显，我们最初有两个声明和两个赋值，但是还有其他的。这个循环将对<code class="eh mt mu mv mk b">i</code>和<code class="eh mt mu mv mk b">n</code>精确地评估<em class="lf"> n次</em>，并执行同样多的加法和赋值。此外，我们将在最后增加一个新的内容。这就是我们现在的情况:2次声明，2次赋值，n次比较，n次加法，n次赋值，1次加法，1次赋值和1次方法调用。</p><p id="323f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还记得上一个定义，如果我们想测量某个东西，我们需要决定哪一个基本操作与我们相关。一旦我们这样做了，我们将忽略所有其他的，我们将认为它们的执行不占用任何资源——时间或空间，我们将只关注相关的、原始的操作。</p><p id="1434" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，声明什么是原语操作很大程度上取决于许多因素，如编译器实现或处理器架构。然而，出于实用的目的，您可以基于您想要用作视点的抽象级别将任何东西声明为原始操作。</p><p id="38bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对我们来说，合理的做法是选择加法作为我们的原始操作，并查看这个函数根据它的输入执行了多少次加法——这将是n次加法，最后还有一次。我们将把它记为:</p><p id="eaf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lf"> f(n) = n + 1 </em></p><p id="6831" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，给定大小为n的输入，我们将需要执行n + 1次加法。100个数字的列表会给我们101个加法，1000个数字的列表会给我们1001个加法。现在，根据我们之前对大O的定义，我们可以推断，上面的SumFunction大约执行n次相关的原始操作，或者它在<strong class="it hv"> <em class="lf"> O(n) </em> </strong>时间内执行。你可能知道，f(n) = n + 1称为线性函数(函数值随输入值线性增长)— O(n)作为近似值因此称为<strong class="it hv"> <em class="lf">线性时间</em> </strong>。</p><figure class="mf mg mh mi fq mx fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/63a4b22ca5a473b9ef50dee735f2eaf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*M-ea15ci2pAcTqWzSzfzGw.png"/></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">Linear function f(n) = n + 1</figcaption></figure><p id="9f61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我们之前的函数<em class="lf"> f(n) = 8 </em>呢？首先，我们需要为它定义一个相关的原始操作——选择加法将得到<em class="lf"> f(n) = 1 </em>。在时间复杂性理论中，这被称为<strong class="it hv"> <em class="lf">恒定时间</em> </strong>，记为<strong class="it hv"> <em class="lf"> O(1) </em> </strong>。</p><p id="439f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们考虑以下情况:</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="7c36" class="lr jr hu mk b fv mo mp l mq mr">public void DoSomething(List&lt;int&gt; n)<br/>{<br/>  SimpleFunction(n);<br/>  SumFunction(n);<br/>}</span></pre><p id="dcee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个O(1)和O(n)依次运行的函数。这将给我们一个O(n) + O(1)的运行时间。添加大O近似值遵循最高阶函数优先的规则，其他所有的都被忽略。那将意味着<em class="lf"> O(n+1) = O(n) </em>和<em class="lf"> O(n) + O(1) = O(n)。同样，我们可以忽略任何常数——f(n)= 3n+5属于O(n)阶。这对我们来说非常重要，因为我们需要找出薄弱点——一个增长最快的功能，一个会让我们的系统崩溃的功能。</em></p><p id="a028" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们讨论上界和其他函数阶之前，让我们回到原始运算。正如我提到的，你可以选择你的相关的，原始的操作，我会给你一个例子来说明这在实践中意味着什么。让我们来看看这段代码:</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="6ac6" class="lr jr hu mk b fv mo mp l mq mr">public void Email(List&lt;Employee&gt; employees)<br/>{<br/>  for (int i = 0; i &lt; employees.Count; i++)<br/>  {<br/>    _emailService.SendHolidayNotificationEmail(employees[i].Email);<br/>    _logger.Log("Email sent");<br/>  }<br/>}</span></pre><p id="41df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们知道发送一封电子邮件要比登录花费更多的时间，我们选择它作为这个功能的基本操作是合理的。该函数本身可能会产生O(n)个不同的原始操作(例如，基于电子邮件长度的验证)，但我们可以将其抽象掉，因为这不是我们方法的input  的<strong class="it hv"> <em class="lf">函数。改变雇员列表的大小不会改变<em class="lf">SendHolidayNotificationEmail</em>方法的运行时间。</em></strong></p><p id="5612" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以放心地忽略日志记录，将其视为微不足道的操作(正如我们在实践中大多数时候所做的那样)。对于什么应该是原始操作，没有硬性的规则，但是您应该始终记住，在您尝试测量性能之前，您需要为您的函数定义一个原始操作，否则这只是胡乱猜测。</p><h2 id="93d2" class="lr jr hu bd js ls lt lu jw lv lw lx ka jc ly lz ke jg ma mb ki jk mc md km me dt translated">但是上限呢？</h2><p id="450f" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">考虑下面这段代码:</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="7625" class="lr jr hu mk b fv mo mp l mq mr">public void FindItem(List&lt;Employee&gt; employees)<br/>{<br/>  string name = "";<br/>  for (int i = 0; i &lt; n.Count; i++)<br/>  {<br/>    if (employees[i].Name == "Mark")<br/>      break;<br/>  }<br/>  Console.WriteLine(name);<br/>}</span></pre><p id="2e67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个函数的运行时间是多少？…</p><p id="f3f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗯，这取决于列表中是否有那个名字的员工及其职位。将数组访问声明为原始操作，给定大小为n的列表，我们可以执行1到n个数组访问。没有具体的统计分布，我们可以安全地假设，平均来说，Mark会在中间的某个地方被找到，我们需要执行大约<em class="lf"> n/2 </em>次数组访问来找到他。</p><p id="1785" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是大O不是关于一般情况，而是关于<strong class="it hv">最坏情况</strong>，最坏情况将是<em class="lf"> n </em>数组访问。更具体地说，说某事在O(n)时间内执行意味着某个算法将需要执行小于或等于n  次运算的<strong class="it hv"> <em class="lf">。</em></strong></p><h2 id="9063" class="lr jr hu bd js ls lt lu jw lv lw lx ka jc ly lz ke jg ma mb ki jk mc md km me dt translated">函数的阶</h2><p id="02d5" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">有不同类型的运行时间。看一下这个例子:</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="995f" class="lr jr hu mk b fv mo mp l mq mr">public void Multiplies(int n)<br/>{<br/>  for (int i = 0; i &lt; n; i++)<br/>  {<br/>    for (int j = 0; j &lt; n; j++)<br/>    { <br/>      Console.WriteLine(i * j);<br/>    }<br/>  }<br/>}</span></pre><p id="04ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着原始操作是控制台写，我们可以看到我们需要执行n * n次操作或n .这是<strong class="it hv">二次时间</strong>或<strong class="it hv"> O(n ) </strong>。</p><p id="884c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这个呢？</p><pre class="mf mg mh mi fq mj mk ml mm aw mn dt"><span id="6457" class="lr jr hu mk b fv mo mp l mq mr">public void MultipliesWithCatch(int n)<br/>{<br/>  for (int i = 0; i &lt; n; i++)<br/>  {<br/>    for (int j = 0; j &lt; 5; j++) // &lt;-- only to 5<br/>    { <br/>      Console.WriteLine(i * j);<br/>    }<br/>  }<br/>}</span></pre><p id="1bae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是O(n)吗？</p><p id="8152" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不，不是的。给定输入n的大小，执行的最大操作数将是5 * n，这使它处于O(n)阶。这是一个非常重要的注意事项— <strong class="it hv">大O描述了相对于输入大小的函数增长</strong>。改变输入的大小不会影响内循环中的操作数，因为它总是5。现在我们有进展了！</p><p id="bd86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，还有其他类型的函数，所以肯定有其他类型的大O符号，对吗？三次函数会给我们三次运行时间，指数函数会给我们指数运行时间等等。</p><figure class="mf mg mh mi fq mx fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/054eb7a35a81188f22e174a9bae671f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*_XBpTH1jbIjIuJk8Tm1GlA.png"/></div><figcaption class="na nb fg fe ff nc nd bd b be z ek">Different types of functions</figcaption></figure><p id="8688" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是还有更复杂的函数——它们呢？正如我们已经看到的，最高阶函数优先，其他函数被忽略。因此，让我们假设我们已经测量了某个函数执行的原始操作的确切数量，并且我们得到了以下结果:</p><p id="e7f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">f(n) = n⁵ + 6n + 5</p><p id="6bf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据提到的规则，这属于O(n⁵).有无限的变化，但运行时间总是由函数增长最快的部分来声明。这些称为多项式运行时间，其中O(n)和O(n)是的子集。还有其他类型的运行时间，如指数、对数或阶乘以及某些著名的算法。</p><p id="12fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在下一部分讨论通过大O符号描述的其他常见运行时间。</p><figure class="mf mg mh mi fq mx"><div class="bz el l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>