<html>
<head>
<title>How to create a progressive UI to enhance presentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建渐进式用户界面来增强演示效果</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-create-a-progressive-ui-to-enhance-presentation-cc42fe97360c?source=collection_archive---------14-----------------------#2018-08-05">https://medium.com/hackernoon/how-to-create-a-progressive-ui-to-enhance-presentation-cc42fe97360c?source=collection_archive---------14-----------------------#2018-08-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5e3f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">用普通Javascript创建交互式信息图(第四部分)</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/4e011f7799731415ab89e64260b33440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PCGPxn0y9BsK5PGNka7qw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Creating a progressive UI to simplify information architectures and enhance presentation</figcaption></figure><h2 id="9c50" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">概述</h2><p id="dfbd" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">本文是关于用普通Javascript创建交互式信息图的五部分系列文章。</p><p id="3f92" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">之前我们设计了一个双向地图定位器来增强用户导航。在本文中，我们将继续基于谷歌云平台(GCP)产品的UI示例来呈现具有复杂架构的内容。</p><p id="bfa9" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">观看我们如何使产品信息易于使用。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lv lw l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Video demo: how to simplify information architectures with a progressive UI design</figcaption></figure><h2 id="67bd" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">目标</h2><p id="cb80" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">让我们设计一个UI来呈现多方面的内容。</p><h2 id="1de5" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">介绍</h2><p id="97e6" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">将信息组织成层次结构是有好处的。你可以对话题进行分类，逐步揭示有意义的关系。</p><p id="1cf0" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">例如，在知识门户上，动物学家可能对关于杰克·拉塞尔斯的话题感兴趣。她沿着一条特定的信息路径前进:</p><pre class="jk jl jm jn fq lx ly lz ma aw mb dt"><span id="d32e" class="jz ka hu ly b fv mc md l me mf">Animals &gt; Mammals &gt; Carnivore &gt; Canis &gt; Dogs &gt; Jack Russells</span></pre><p id="0313" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">假设她也在研究哈士奇、鬣狗和狐狸。与杰克·拉塞尔斯相比，表达相关信息的好方法是什么？如何提供上下文信息，而又不至于让用户不堪重负？</p><p id="01dc" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">一种方法是将数据分成小段，然后跨多个独立的页面重新连接它们。随着每一个页面的加载，用户会跳转到新的类别和网页中去寻找更多的细节。然而，突出上下文关系变得更加困难。过多的页面加载也会使用户迷失方向或感到沮丧。结果是用户体验下降。</p><p id="5e6a" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">一定有更好的方法来引导用户实现他们的目标。这个等式的一部分在我们之前的讨论中已经解决了。我们可以把一张完整的地图，或者动物王国，放到画布上，仍然可以盈利地导航。</p><p id="f116" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">我们现在剩下的是“Jack Russell”问题——在不影响信息流的情况下，让UI向下显示详细内容的设计挑战。</p><h2 id="09b8" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">概念</h2><p id="24e2" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">可以把扩展(节点的)信息路径想象成添加一个HTML容器。像使用便利贴一样，我们可以将这些容器“粘贴”到浏览器窗口上，以显示分层信息。不需要页面加载。我们基本上描述了一个<strong class="kz hv">内嵌UI </strong>。</p><p id="96fb" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">现在是激动人心的部分。当访问者从一个节点“跳到”另一个节点时，这些容器会换进换出以显示更新的内容。我们将通过制作UI动画向用户展示正在发生的事情。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mg"><img src="../Images/a0a3519e5284182c2b64466de4c2c880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5kJgDIYyEy29x8WtoRUs3A.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Animated revealers for layered content</figcaption></figure><p id="cb5e" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">用户现在可以访问详细的内容，而不会丢失大画面。更好的是，它们总是在一个一致和持久的用户界面之上。</p><p id="1048" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><em class="mh">提示:如果你正在编写一个单页应用程序(SPA ),比如React或Angular，通过动态地优化路径来创造最好的用户体验。例如，当用户点击一个直接带她到animalchart.com/jack-russells,路线的反向链接时，SPA应该提取相关数据，自动聚焦在节点上，并在用户不做任何事情的情况下启动动画。</em></p><h2 id="56c8" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">入门指南</h2><p id="5ebf" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">实现很简单。</p><ul class=""><li id="b7a8" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated">便利贴机制仅仅是一个在运行时创建或销毁的div容器。</li><li id="ce7a" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated">动画是带有缓动效果的普通CSS。</li><li id="40a8" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated">数据存储重用了<code class="eh mw mx my ly b">legend[]</code>数组(来自第一部分的讨论)。</li></ul><h2 id="50fe" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">步骤1:准备画布</strong></h2><p id="49f3" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">在主<code class="eh mw mx my ly b">while</code>循环中添加一个<code class="eh mw mx my ly b">click</code>监听器(第一部分讨论)。</p><pre class="jk jl jm jn fq lx ly lz ma aw mb dt"><span id="2a69" class="jz ka hu ly b fv mc md l me mf">while (item[i]) {<br/>    ...<br/>    itemElementName[i].addEventListener("click", showLayeredContent)<br/>}</span></pre><ul class=""><li id="8b20" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated">为每个节点添加一个<code class="eh mw mx my ly b">click</code>监听器。</li><li id="57e3" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">click</code>将触发自定义功能<code class="eh mw mx my ly b">showLayeredContent</code>。</li></ul><p id="3c3c" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><code class="eh mw mx my ly b">showLayeredContent</code>运行指令以:</p><ul class=""><li id="c5c5" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated">从<code class="eh mw mx my ly b">legend[]</code>中检索数据。</li><li id="e411" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated">创建一个显示内容的div容器。</li><li id="0551" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated">将容器“粘贴/粘贴”到浏览器窗口或<code class="eh mw mx my ly b">canvas</code>。</li><li id="a338" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated">将容器的初始位置放置在视口的“下方”,以便它在激活后可以“向上滑动”。</li></ul><pre class="jk jl jm jn fq lx ly lz ma aw mb dt"><span id="56ac" class="jz ka hu ly b fv mc md l me mf"><em class="mh">function</em> showLayeredContent(event) {<br/><br/>    var div = document.createElement('div');<br/>    div.id = "some HTML" + deepContent;<br/><em class="mh">    //  add your CSS<br/>    //  add your animation</em></span><span id="4b83" class="jz ka hu ly b fv mz md l me mf">    // attach the new container to the DOM<br/>    document.body.appendChild(div);<br/>    //  ... add animation to show what's going on<br/><br/>    anotherLayeredElement(<em class="mh">this</em>.id);<br/>    //  ... more "post-it notes", if any</span><span id="a298" class="jz ka hu ly b fv mz md l me mf">}</span></pre><ul class=""><li id="ae12" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">document.createElement(‘div’)</code>动态创建“便利贴”容器。</li><li id="160e" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">div.id = “some HTML” + ‘deepContent’</code>填充容器。</li><li id="5e84" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">deepContent</code>包含实际内容。使用<code class="eh mw mx my ly b">this.id</code>作为索引键从<code class="eh mw mx my ly b">legend[]</code>数据存储中检索记录。</li><li id="7b92" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">document.body.appendChild(div)</code>将容器附加到DOM中进行渲染。<code class="eh mw mx my ly b">document.body</code>是通用的。使用<code class="eh mw mx my ly b">canvas</code>或者你自己的容器元素。</li><li id="91b6" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">anotherLayeredElement(this.id)</code>添加更多容器。在我们的演示视频中，我们总共使用了3个“粘性”容器。</li></ul><p id="0bc7" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">技巧1:动态地生成容器元素和它的CSS，这样我们就可以快速地使引擎适应其他项目。</p><p id="2ae2" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">技巧2:记得在换入新的容器之前，先把旧的容器拿走。</p><h2 id="30b8" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">步骤2:用动画指导用户操作</h2><p id="6812" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">将第一个“粘性”容器作为全高元件放置在右侧。它的入口以<strong class="kz hv">自下而上</strong>的动作动画化。</p><pre class="jk jl jm jn fq lx ly lz ma aw mb dt"><span id="fc94" class="jz ka hu ly b fv mc md l me mf">var sticky01 = document.getElementById( myContainerID );</span><span id="4ad2" class="jz ka hu ly b fv mz md l me mf">//  Stage the container's pre-animation position<br/>sticky01.style.bottom = "-100vh";<br/>sticky01.style.right = "0%";</span><span id="24b4" class="jz ka hu ly b fv mz md l me mf">//  Attach CSS class to the RHS container.<br/>sticky01.classList.add("myCssClass");</span><span id="8d57" class="jz ka hu ly b fv mz md l me mf">//  Once your container is ready, animate its entrance.<br/>sticky01.style.transform = "translateY(0px)";<br/>...</span></pre><ul class=""><li id="811a" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">sticky01</code>引用第一个容器</li></ul><p id="366f" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><em class="mh">提示:将</em> <code class="eh mw mx my ly b"><em class="mh">translateY</em></code> <em class="mh">改为</em> <code class="eh mw mx my ly b"><em class="mh">translate3d</em></code> <em class="mh">，利用硬件加速来提高性能。</em></p><pre class="jk jl jm jn fq lx ly lz ma aw mb dt"><span id="24e5" class="jz ka hu ly b fv mc md l me mf">layeredContainerRHS {<br/>    position: fixed;<br/>    overflow-y: scroll;<br/>    top: 0;<br/>    right: 0;<br/>    width: 50vw;<br/>    height: 100vh;<br/>    zIndex: 9;<br/>    transition: all 200ms cubic-bezier(0.165, 0.84, 0.44, 1);<br/>}</span></pre><ul class=""><li id="0c7a" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">position: fixed</code>“粘贴”容器到<code class="eh mw mx my ly b">canvas</code> UI上。</li><li id="7647" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">overflow-y: scroll</code>可以通过垂直滚动显示无限内容。</li><li id="91be" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">top: 0</code>设置容器在画布“下方”的预入口位置。</li><li id="2adb" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">right: 0</code>、<code class="eh mw mx my ly b">width: 50vw</code>和<code class="eh mw mx my ly b">height: 100vh</code>将容器的样式设置为占据浏览器窗口的右侧。</li><li id="5d8f" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">zIndex: 9</code>指定分层顺序。</li><li id="c5d9" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">transition</code>创建动画效果。<code class="eh mw mx my ly b">cubic-bezier</code>产生柔滑的运动。</li></ul><h2 id="e4d7" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">步骤3:添加多个“粘性”容器</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff na"><img src="../Images/3f8cd5ab742d7f26f487d3cfdf6c2786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KbK_cikifwju1tkz-v9Zhg.gif"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Opening and closing “sticky” containers</figcaption></figure><p id="b09b" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">到目前为止，我们已经创建了一个全高的“粘性”容器来显示详细信息。同时，用户仍然可以浏览其他主题。</p><p id="4f57" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">如果您希望将信息分层到更多的层，只需添加更多的容器。在我们的演示视频中，我们添加了两个较小的容器来显示摘要信息:</p><ul class=""><li id="b011" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated">摘要文本和特征图像的“中间”容器。</li><li id="4818" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated">“左”容器突出显示相关信息、参考或外部资源链接。在我们的例子中，我们用它来显示流程图。</li></ul><pre class="jk jl jm jn fq lx ly lz ma aw mb dt"><span id="275c" class="jz ka hu ly b fv mc md l me mf">function middleSticky(ID) {<br/>    ...<br/>    // "middle" sticky container (#02)<br/>    div.style.left = "25vw";<br/>    div.style.height = "44vh";<br/>    div.style.width = "30vw";<br/>    div.style.background = "#000";<br/>    ...<br/>    middleSticky.style.transform = “translateY(0vh)”;<br/>    ...<br/>}</span><span id="72d8" class="jz ka hu ly b fv mz md l me mf">function leftSticky(ID) {<br/>    ...<br/>    // "left-most" sticky container (#03)<br/>    div.style.left = "0vw";<br/>    div.style.height = "21vh";<br/>    div.style.width = "25vw";<br/>    div.style.background = "#e68717";<br/>    ...<br/>    leftMostSticky.style.transform = “translateY(0vh)”;<br/>    ...<br/>    }</span></pre><ul class=""><li id="d0b8" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">translateY(0vh)</code>启动动画起始位置:</li><li id="283e" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated">用CSS区分每个容器。</li></ul><h2 id="28e6" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第四步:清理</h2><p id="e6d5" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">一旦动物学家完成了任何主题，UI关闭粘性容器以最大化主导航UI。以相反的顺序，“滑下”粘性容器，并将其从场景后面的DOM中移除。</p><pre class="jk jl jm jn fq lx ly lz ma aw mb dt"><span id="da2d" class="jz ka hu ly b fv mc md l me mf">function closeStickyWindows(id){<br/>    div.style.transform= "translateY(0vh)";<br/>    setTimeout(() =&gt; {<br/>        div.parentNode.removeChild(div);<br/>    }, 500);<br/>}</span></pre><ul class=""><li id="a4ee" class="mi mj hu kz b la lq ld lr kk mk ko ml ks mm lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">500</code>例如(最后一个动画开始于300毫秒)+(200毫秒完成动画)。</li><li id="a355" class="mi mj hu kz b la mr ld ms kk mt ko mu ks mv lp mn mo mp mq dt translated"><code class="eh mw mx my ly b">div.parentNode.removeChild(div)</code>删除DOM元素(即垃圾收集)。如果ES6向后兼容性不成问题，请使用<code class="eh mw mx my ly b">.remove()</code>。</li></ul><h2 id="29d7" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">后续步骤</h2><p id="21a5" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated">用户可以以更精细的方式浏览内容。</p><p id="10ca" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">在这个系列的最后一部分，我们将讨论赋予ui人性化的想法。</p></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><h2 id="0108" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">到其他部分的链接</h2><p id="f6f2" class="pw-post-body-paragraph kx ky hu kz b la lb iv lc ld le iy lf kk lg lh li ko lj lk ll ks lm ln lo lp hn dt translated"><a class="ae ni" rel="noopener" href="/@PageiiStudio/how-to-build-an-interactive-infographic-from-scratch-94128678c83b"> <strong class="kz hv">第一部分</strong>为设计交互式信息图奠定了基础。</a></p><p id="2c8c" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><a class="ae ni" rel="noopener" href="/@PageiiStudio/how-to-create-a-navigation-ui-bac94a9e51fa"> <strong class="kz hv"> Part-two </strong>增加浏览内容的导航功能。</a></p><p id="607f" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><a class="ae ni" rel="noopener" href="/@PageiiStudio/how-to-create-a-two-way-navigation-map-e96600a73cbd"> <strong class="kz hv">第三部</strong>增加动态小地图，增强导航。</a></p><p id="1043" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated"><strong class="kz hv"> Part-four → </strong> <em class="mh">你来了。</em></p><p id="f79f" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">第五部分展示了为什么创建人性化的用户界面如此容易。</p></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><p id="11f0" class="pw-post-body-paragraph kx ky hu kz b la lq iv lc ld lr iy lf kk ls lh li ko lt lk ll ks lu ln lo lp hn dt translated">如果你喜欢这个故事，你可以在<a class="ae ni" href="https://pageii.com/story;title=How-to-create-a-progressive-UI-to-enhance-presentation" rel="noopener ugc nofollow" target="_blank"> Pageii工作室</a>找到更多。</p></div></div>    
</body>
</html>