<html>
<head>
<title>Setting up Android product flavors and XCode targets in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Native中设置Android产品风格和XCode目标</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/setting-up-android-like-product-flavors-in-react-native-39b6c011061b?source=collection_archive---------6-----------------------#2018-08-06">https://medium.com/hackernoon/setting-up-android-like-product-flavors-in-react-native-39b6c011061b?source=collection_archive---------6-----------------------#2018-08-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="b296" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">Android开发人员应对原生问题的路线图——第4部分</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/69b77db233f9253cd04c11892e9bb8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X72yQdEnRCU-9RMl"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/@echaparro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Edgar Chaparro</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1aeb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果您来自原生开发背景，您可能知道Android Studio和XCode都提供了一个功能，可以从相同的代码创建不同的应用程序。这些在Android Studio中被称为风味，在XCode中被称为目标。这个想法是创建不同的包，它们具有相同的核心功能，但是在特性上有微小的不同。这可以包括不同的配色方案，品牌或一些功能独特的包装。一个常见的例子是创建同一应用程序的免费和付费版本，其中付费版本具有与免费版本相同的核心功能，并添加了一些功能和特性。由于主要功能是相同的，所以不需要创建不同的项目，而是在运行时处理特定于风格/目标的更改。我希望你明白我的意思。如果没有，请点击这些链接了解更多信息。</p><div class="kw kx fm fo ky kz"><a href="https://proandroiddev.com/advanced-android-flavors-part-1-building-white-label-apps-on-android-ade16af23bcf" rel="noopener  ugc nofollow" target="_blank"><div class="la ab ej"><div class="lb ab lc cl cj ld"><h2 class="bd hv fv z el le eo ep lf er et ht dt translated">高级Android风格第1部分——在Android上构建白标应用</h2><div class="lg l"><h3 class="bd b fv z el le eo ep lf er et ek translated">开始使用Android风格，轻松在您的应用中创建变体</h3></div><div class="lh l"><p class="bd b gc z el le eo ep lf er et ek translated">proandroiddev.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jt kz"/></div></div></a></div><div class="kw kx fm fo ky kz"><a rel="noopener follow" target="_blank" href="/@andersongusmao/xcode-targets-with-multiples-build-configuration-90a575ddc687"><div class="la ab ej"><div class="lb ab lc cl cj ld"><h2 class="bd hv fv z el le eo ep lf er et ht dt translated">具有多个构建配置的Xcode“目标”</h2><div class="lg l"><h3 class="bd b fv z el le eo ep lf er et ek translated">如何创建区分和共享部分源代码的多个应用程序</h3></div><div class="lh l"><p class="bd b gc z el le eo ep lf er et ek translated">medium.com</p></div></div><div class="li l"><div class="lo l lk ll lm li ln jt kz"/></div></div></a></div><p id="072c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="lp">为了简单起见，我将使用Android术语</em> <code class="eh lq lr ls lt b"><em class="lp">flavors</em></code> <em class="lp">来表示React Native中的不同产品版本。</em></p><h2 id="3859" class="lu lv hu bd lw lx ly lz ma mb mc md me kj mf mg mh kn mi mj mk kr ml mm mn mo dt translated">现在，让我们转到手头的问题上来</h2><p id="e6b1" class="pw-post-body-paragraph ka kb hu kc b kd mp iv kf kg mq iy ki kj mr kl km kn ms kp kq kr mt kt ku kv hn dt translated">我从事的项目严重依赖于构建风格，而React Native没有内置的功能来处理同样的问题。当然，您可以从<code class="eh lq lr ls lt b">react-native-cli</code>中创建不同的风格，但这只是决定了构建过程，而不是需要进行的实际运行时更改。这是我想出来的，来弥补native和React Native之间的差距。</p><h1 id="7a86" class="mu lv hu bd lw mv mw mx ma my mz na me ja nb jb mh jd nc je mk jg nd jh mn ne dt translated">设置</h1><h2 id="ff4b" class="lu lv hu bd lw lx ly lz ma mb mc md me kj mf mg mh kn mi mj mk kr ml mm mn mo dt translated">步骤1:配置(本机)</h2><p id="9239" class="pw-post-body-paragraph ka kb hu kc b kd mp iv kf kg mq iy ki kj mr kl km kn ms kp kq kr mt kt ku kv hn dt translated">第一步是在Android Studio中设置产品风格，并在XCode中构建目标。出于本教程的目的，我们的应用程序将被称为<code class="eh lq lr ls lt b">NoteTaker</code>。这个应用程序有两种风格:<code class="eh lq lr ls lt b">lite</code>和<code class="eh lq lr ls lt b">pro</code>。你可以阅读上面提到的文章来帮助你在Android Studio和Xcode上设置配置。</p><h2 id="3085" class="lu lv hu bd lw lx ly lz ma mb mc md me kj mf mg mh kn mi mj mk kr ml mm mn mo dt translated">步骤2:本机模块</h2><p id="dce9" class="pw-post-body-paragraph ka kb hu kc b kd mp iv kf kg mq iy ki kj mr kl km kn ms kp kq kr mt kt ku kv hn dt translated">一旦我们在本机端设置了风味，我们需要一种方法在运行时将产品风味标识符从本机传递到react-native。这无疑要求我们为Android和iOS创建本地模块或桥接方法。为了简单起见，我们将保持我们的风格标识符为字符串。在安卓系统中，味道存储在<code class="eh lq lr ls lt b">BuildConfig</code>中，而在iOS系统中，你可以从<code class="eh lq lr ls lt b">info.plist</code>中使用<code class="eh lq lr ls lt b">TargetName</code></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/1f9db41aee0733ed00a7a2d16518bad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOE-yk97BvNQcxIeD-guDg.png"/></div></div></figure><p id="10b1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果您不知道React Native中的本机模块是什么，请查看以下文档。</p><div class="kw kx fm fo ky kz"><a href="https://facebook.github.io/react-native/docs/native-modules-android" rel="noopener  ugc nofollow" target="_blank"><div class="la ab ej"><div class="lb ab lc cl cj ld"><h2 class="bd hv fv z el le eo ep lf er et ht dt translated">本机模块反应本机</h2><div class="lg l"><h3 class="bd b fv z el le eo ep lf er et ek translated">有时一个应用程序需要访问一个平台API，而React Native还没有相应的模块。也许…</h3></div><div class="lh l"><p class="bd b gc z el le eo ep lf er et ek translated">facebook.github.io</p></div></div><div class="li l"><div class="ng l lk ll lm li ln jt kz"/></div></div></a></div><h2 id="eaf7" class="lu lv hu bd lw lx ly lz ma mb mc md me kj mf mg mh kn mi mj mk kr ml mm mn mo dt translated">步骤3: Flavor.js</h2><p id="4d0d" class="pw-post-body-paragraph ka kb hu kc b kd mp iv kf kg mq iy ki kj mr kl km kn ms kp kq kr mt kt ku kv hn dt translated">接下来，我们创建一个JavaScript文件，作为React Native中风味的实用程序类。该文件公开了一个从本机获取当前产品风味的方法和一个在从本机获取该信息后存储该信息的变量。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nh"><img src="../Images/5c8437ec6a5add6fdcb064d81b917b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nefaMDH4I3mGeLneZHxxrQ.png"/></div></div></figure><h2 id="0d3a" class="lu lv hu bd lw lx ly lz ma mb mc md me kj mf mg mh kn mi mj mk kr ml mm mn mo dt translated">第四步:Colors.js</h2><p id="0d0f" class="pw-post-body-paragraph ka kb hu kc b kd mp iv kf kg mq iy ki kj mr kl km kn ms kp kq kr mt kt ku kv hn dt translated">由于我们的<code class="eh lq lr ls lt b">lite</code>和<code class="eh lq lr ls lt b">pro</code>版本有不同的配色方案，我们创建了一个<code class="eh lq lr ls lt b">Colors.js</code>文件，其中包含了特定风味的颜色。此外，该文件还导出了一个方法来根据产品味道获取相关的颜色。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ni"><img src="../Images/845ed627ecefa5294ec6016fa8ab968a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBXA-fqD-vS1zvTq8najvw.png"/></div></div></figure><p id="dab7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们的设置现在差不多完成了。我们只需要在react本机应用程序开始时调用build flavor方法。但是有一个问题。因为构建风格是异步的，所以我们需要确保只有当风格已经从本地获取时才挂载第一个组件。为此，我们最初在组件的render方法中传递null，在收到来自<code class="eh lq lr ls lt b">buildFlavor</code>方法的回调时，我们使用<code class="eh lq lr ls lt b">setState</code>重新呈现组件</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nj"><img src="../Images/dc2b9adc8e5a5395caf1b3af2f40bc50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVgpF2spw1ey-rOyVOwPlQ.png"/></div></div></figure><h1 id="ae22" class="mu lv hu bd lw mv mw mx ma my mz na me ja nb jb mh jd nc je mk jg nd jh mn ne dt translated">履行</h1><h2 id="ec5b" class="lu lv hu bd lw lx ly lz ma mb mc md me kj mf mg mh kn mi mj mk kr ml mm mn mo dt translated">实现风味特定的功能</h2><p id="4688" class="pw-post-body-paragraph ka kb hu kc b kd mp iv kf kg mq iy ki kj mr kl km kn ms kp kq kr mt kt ku kv hn dt translated">既然我们的风味已经从native中获取，并且可以在任何组件中访问我们的产品风味，那么编写特定于风味的代码就是小菜一碟。事实上，我们已经在<code class="eh lq lr ls lt b">getThemeColors</code>方法中看到了这样的实现。考虑一个只有在<code class="eh lq lr ls lt b">pro</code>版本中才有的向便笺添加图像的特性</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nk"><img src="../Images/5f6fe4d340e81eca3759db8a3ddc83c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7IS9_ok5XN1O38kA-dLDw.png"/></div></div></figure><h2 id="2a71" class="lu lv hu bd lw lx ly lz ma mb mc md me kj mf mg mh kn mi mj mk kr ml mm mn mo dt translated">实施配色方案</h2><p id="372e" class="pw-post-body-paragraph ka kb hu kc b kd mp iv kf kg mq iy ki kj mr kl km kn ms kp kq kr mt kt ku kv hn dt translated">当定义一个组件的样式时，你可以使用两种方法。使用样式属性<br/> 2直接应用样式。使用样式表</p><p id="1980" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">第一种方法没有任何问题，因为样式是在安装特定组件时在运行时评估和应用的。因此<code class="eh lq lr ls lt b">getThemeColors</code>方法被正确评估，我们得到了所需的颜色。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nk"><img src="../Images/4504290752f03c448ac97148b3edfd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlwj3yAq15Tbq81UJBRp0w.png"/></div></div></figure><p id="4f2c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是，使用样式表时，会在文件加载到JavaScript运行时环境中时评估样式。这意味着即使组件没有被安装，它的样式也已经被评估了。因此，在我们的例子中，在风格被获取之后，组件在<code class="eh lq lr ls lt b">App.js</code>中的延迟呈现不能达到它的目的，因为即使组件没有被挂载，它的样式已经被评估了。因此，<code class="eh lq lr ls lt b">getThemeColors</code>返回一组错误的颜色。为了克服这个问题，我们只需要在将要安装组件时为组件创建样式表。我们通过用<code class="eh lq lr ls lt b">componentWillMount</code>生命周期方法创建样式表来实现这一点。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nl"><img src="../Images/cfa5796fc048421064ed4348010042eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jw1NuhPe2urAVKlTitnT3A.png"/></div></div></figure><p id="bd28" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">所以现在我们有了产品风味的具体特征和配色方案。这种设置的唯一缺点是样式和配色方案现在是在运行时生成的，而不是在编译时生成的。这并不是说它对性能有很大的影响，但仍然落后了一步。如果您有任何改进此设置的想法，请随时在回复中或通过电子邮件与我分享。</p></div><div class="ab cl nm nn hc no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hn ho hp hq hr"><p id="36e1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这是“一个Android开发者的本地反应路线图”系列的第四部分。您可以通过以下链接阅读本系列以前的文章:</p><blockquote class="nt nu nv"><p id="82a5" class="ka kb lp kc b kd ke iv kf kg kh iy ki nw kk kl km nx ko kp kq ny ks kt ku kv hn dt translated">第一部分:<a class="ae jz" rel="noopener" href="/@rohanx96/an-android-developers-roadmap-to-react-native-part-1-5ec20cf93757">https://medium . com/@ rohan x96/an-Android-developers-roadmap-to-react-native-Part-1-5ec 20 cf 93757</a><br/>第二部分:<a class="ae jz" rel="noopener" href="/@rohanx96/set-up-your-own-react-native-ide-f7d52c90da43">https://medium . com/@ rohan x96/set-up-your-own-react-native-ide-f 7d 52 c 90 da 43</a><br/>第三部分:<a class="ae jz" href="https://blog.usejournal.com/redux-an-intro-and-beyond-92d694bc314f" rel="noopener ugc nofollow" target="_blank">https://blog . use journal . com/redux-an-an</a></p></blockquote></div></div>    
</body>
</html>