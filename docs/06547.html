<html>
<head>
<title>Why Microservices Fail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务失败的原因</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-microservices-fail-6cdc006f9540?source=collection_archive---------7-----------------------#2018-08-06">https://medium.com/hackernoon/why-microservices-fail-6cdc006f9540?source=collection_archive---------7-----------------------#2018-08-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="88a2" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">免责声明:这是因为您将业务逻辑放在了服务类中</h2></div><p id="6447" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近偶然看到一个<a class="ae kf" href="https://segment.com/blog/goodbye-microservices/" rel="noopener ugc nofollow" target="_blank">帖子</a>讲的是作者使用微服务的经历。这种经历相当负面，但原因是如此典型和根本，以至于我决定写一篇后续文章。但是在说微服务本身之前，我们先从更低级的问题说起。</p><h2 id="618d" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">程序思维是什么样子的</h2><p id="caf4" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Procedural_programming" rel="noopener ugc nofollow" target="_blank">过程思维</a>与<a class="ae kf" href="https://hackernoon.com/solid-principles-530b2cc2badf" rel="noopener ugc nofollow" target="_blank"> OOP </a>的不同之处在于，当你使用前者时，你把你的程序视为一系列对数据执行某些动作的步骤。因此，数据和行为本质上是分离的。</p><p id="219c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">考虑下面的例子。您的系统收到一个<code class="eh lg lh li lj b">register card transaction</code>请求。首先，您应该验证它，然后处理一些业务规则(以防您区分验证和业务规则)，然后向一些外部支付服务发送http请求，然后解析它的响应，然后基于它的结果执行一些业务逻辑—例如，向客户发送电子邮件并记住一张卡。这是一个你用程序方法想象出来的心流图像:</p><figure class="ll lm ln lo fq lp fe ff paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="fe ff lk"><img src="../Images/e33423b6bc9bc4e88bd3064aa7c218ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcp5ELQhynMIB69REIUwOw.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Typical procedural mindset represented as data flow and sequence of actions that operate upon that data</figcaption></figure><p id="cb68" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">实现这个场景的典型类是什么？嗯，很简单:<code class="eh lg lh li lj b">CardPaymentRequestValidationService</code>、<code class="eh lg lh li lj b">BankPaymentRequestSender</code>、<code class="eh lg lh li lj b">BankPaymentResponseParser</code>、<code class="eh lg lh li lj b">EmailSendingService</code>和<code class="eh lg lh li lj b">CardRememberingService</code>。</p><h2 id="5e0c" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">整个过程式系统最终看起来是什么样的</h2><p id="6586" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">接下来发生的事情是，您必须为另一家银行实现一些业务逻辑(考虑到第一家银行称为Bank1，第二家银行称为Bank2)。因此，如果你不懒惰，你可以修改你的类，使每个类只处理一个库，并提取一个公共的父类。所以你的类集合变成了如下:<code class="eh lg lh li lj b">Bank1PaymentRequestValidationService</code>(现在扩展了<code class="eh lg lh li lj b">CardPaymentRequestValidationService</code>)，<code class="eh lg lh li lj b">Bank1PaymentRequestSender</code>(现在扩展了<code class="eh lg lh li lj b">CommonBankPaymentRequestSender</code>)，<code class="eh lg lh li lj b">Bank1PaymentResponseParser</code>(现在扩展了<code class="eh lg lh li lj b">CommonBankPaymentResponseParser</code>)，Bank2也是一样。<code class="eh lg lh li lj b">EmailSendingService</code>会怎么样？每个银行需要单独上课吗？嗯，也许是，也许不是。也许不是:只有两家银行，这两家银行的逻辑几乎完全相同。因此，现在您的代码结构很可能如下所示:</p><figure class="ll lm ln lo fq lp fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/bbe778a9ce555d1948c3cc84604fb38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*uFrs-5LwGHbLTOO6yJPFdg.png"/></div></figure><p id="4dce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将所有这些<code class="eh lg lh li lj b">Common</code>类提取到一个名为<code class="eh lg lh li lj b">common</code>或<code class="eh lg lh li lj b">core</code>或<code class="eh lg lh li lj b">base</code>的目录中似乎是一个好主意，或者，如果你已经<em class="ma">到了</em>那么远的话，<code class="eh lg lh li lj b">shared</code>。因此，使用后一个名称，在自己的微服务中提取每个银行相关代码变得绝对合法，并附带有<code class="eh lg lh li lj b">common</code>库:</p><figure class="ll lm ln lo fq lp fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/d3f50ed8dfd803c0337aba5fbbdd74f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*G941qrfMG_yGODtqMSanpA.png"/></div></figure><p id="cbe5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">几十家银行之后，你发现自己正处于与<a class="ae kf" href="https://segment.com/" rel="noopener ugc nofollow" target="_blank">部门</a>开发人员完全相同的棘手境地:你的共享库在规模和复杂性方面都有了显著增长，包含了许多特定于客户的细节，而且你害怕修改它，因为依赖它的客户太多了。</p><p id="8a43" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，简而言之，这就是分布式整体结构的创建过程。</p><h2 id="9fa8" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">分布式monolith有什么问题</h2><p id="4e1c" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">对我来说，这种方法有三个主要缺点。第一个是与特定技术的耦合，这样你就不能用最适合的技术来解决手头的问题。第二个问题是，在共享库被修改的情况下，必须同时部署所有服务，因此整个系统中断的可能性更高。第三个是我之前已经提到的:客户端相关的代码不可避免地在共享库中蔓延。所以共享库的整个概念本质上是脆弱的。</p><p id="0562" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这不是微服务失败的唯一原因，实际上还有更多原因，但这是非常突出的一个原因。</p><h2 id="9568" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">为什么服务类会导致糟糕的设计</h2><p id="1d18" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">因为是<a class="ae kf" href="https://hackernoon.com/you-dont-need-a-domain-service-class-in-ddd-9ecd3140782" rel="noopener ugc nofollow" target="_blank">服务类</a>的概念导致了分布式的整体，你一定想知道为什么会这样。第一眼看上去，他们很棒。它们是可重用的，有时是可组合的。它们唯一的问题是它们不属于OOP领域。为什么？OOP的核心原则是<a class="ae kf" href="https://martinfowler.com/bliki/AnemicDomainModel.html" rel="noopener ugc nofollow" target="_blank">行为和数据属于同一个</a>。而且这个原则在服务类中即使不总是被违反，也是大多数时候被违反的。</p><p id="66f0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，那又怎样？毕竟，我们不是OOP狂热者，盲目地遵循它的原则。为什么服务类会导致糟糕的设计？</p><p id="92ba" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个有点哲学的问题。如今的软件工程与其说是一门工程科学，不如说是一门社会和行为科学。没有一成不变的原则一定会让你取得伟大的成就。有一些技术可以促进达到好的结果，也有一些方法会使它变得更加困难。服务类就是这样。您可以保持代码的整洁，但是使用服务类更难做到。</p><p id="2703" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想了很久，我得出了为什么会这样的主要主观原因。服务类没有身份感，没有属于特定上下文的感觉，比如说，一个用户故事。所以从心理上来说，增加一个依赖于客户的if子句更容易。因此，它们中的大多数最终都是一样的:看似可重用的服务类被依赖于客户端的逻辑所膨胀。创建一个共享库和一堆微服务只会让情况变得更糟。</p><p id="e32a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据定义，包含客户端特定代码的共享库是糟糕的抽象。抽象应该是，嗯，抽象。如果你经常不得不修改你认为是抽象的代码，那么你就创建了错误的抽象。基于服务类提出糟糕的抽象的原因(感觉更像是一种主观感觉)是很难提出好的只是动作的抽象。就我个人而言，我的思维倾向于首先识别一个名词，其次——一个动词，也就是它的行为。</p><h2 id="a6dc" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">如何避免失败的微服务</h2><p id="a8bc" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">首先，专注于形成内聚<a class="ae kf" href="https://hackernoon.com/how-to-define-service-boundaries-251c4fc0f205" rel="noopener ugc nofollow" target="_blank">业务能力</a>的用户故事。然后，在每一个里面，把注意力集中在拥有一些身份和行为的对象上。这就是如何获得用<a class="ae kf" href="https://martinfowler.com/bliki/DDD_Aggregate.html" rel="noopener ugc nofollow" target="_blank"> DDD聚合</a>(通常是<a class="ae kf" href="https://hackernoon.com/service-boundaries-identification-example-in-e-commerce-a2c01a1b8ee9" rel="noopener ugc nofollow" target="_blank">传奇</a>)表达的业务流程的更高层次视图。将其余的逻辑放在值对象中。因此，您可能最终几乎没有服务类。</p><p id="8e9d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我心目中的优质服务大概是这样的:</p><figure class="ll lm ln lo fq lp fe ff paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="fe ff md"><img src="../Images/4b4b4cf0386ab5abeaab9e1fda58ab26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxUo8AGprmCMr9xsVcPxZw.png"/></div></div></figure><h2 id="29ee" class="kg kh hu bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la dt translated">介意提供一些例子吗？</h2><p id="a536" class="pw-post-body-paragraph jj jk hu jl b jm lb iv jo jp lc iy jr js ld ju jv jw le jy jz ka lf kc kd ke hn dt translated">当然可以。你可以在这里找到一些<a class="ae kf" href="https://hackernoon.com/service-boundaries-identification-example-in-e-commerce-a2c01a1b8ee9" rel="noopener ugc nofollow" target="_blank"/>——普遍使用的电子商务，在这里找到<a class="ae kf" href="https://hackernoon.com/example-of-service-boundaries-identification-e9077c513560" rel="noopener ugc nofollow" target="_blank"/>，还有支付服务提供商的细节。此外，InfoQ 上有我想法的摘要。</p></div></div>    
</body>
</html>