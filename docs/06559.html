<html>
<head>
<title>Keeping it Clean: Haskell Code Formatters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持整洁:Haskell代码格式化程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/keeping-it-clean-haskell-code-formatters-32ca25c59c70?source=collection_archive---------19-----------------------#2018-08-06">https://medium.com/hackernoon/keeping-it-clean-haskell-code-formatters-32ca25c59c70?source=collection_archive---------19-----------------------#2018-08-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/cba9195c33ccf857af2af435017b8d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzPPIx3SWNPSJAiIjzfAnQ.png"/></div></div></figure><p id="df3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很久以前，我们有一篇文章介绍了一些关于<a class="ae ka" href="https://www.mmhaskell.com/blog/2017/5/8/4-steps-to-a-better-imports-list" rel="noopener ugc nofollow" target="_blank">如何组织你的进口陈述</a>的技巧。就我记忆所及，那是我们在代码格式化方面做过的唯一一件事。但是当你和更多的人一起工作时，格式是你需要考虑的一件事，以使每个人都保持理智。您希望在整个代码库中保持一致的风格。这样，代码审查中的争议就少了，人们也不需要花太多心思来更新代码。他们不应该对遵循风格指南或代码片段中存在什么感到疑惑。</p><p id="2d2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本周，我们将介绍三种不同的Haskell代码格式化工具。我们将考察<a class="ae ka" href="https://github.com/jaspervdj/stylish-haskell" rel="noopener ugc nofollow" target="_blank">时髦的哈斯克尔</a>、<a class="ae ka" href="https://github.com/commercialhaskell/hindent" rel="noopener ugc nofollow" target="_blank">欣登</a>和<a class="ae ka" href="https://github.com/lspitzner/brittany" rel="noopener ugc nofollow" target="_blank">布列塔尼</a>。正如我们将看到的，这些都有其优缺点。</p><p id="ec86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于Haskell项目的一些想法，请下载我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>。您也可以参加我们免费的<a class="ae ka" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>，学习如何使用Stack来组织您的代码！</p><h1 id="2a78" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">时尚Haskell</h1><p id="e7a8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们要看的第一个工具是<a class="ae ka" href="https://github.com/jaspervdj/stylish-haskell" rel="noopener ugc nofollow" target="_blank">时尚的Haskell </a>。这是一个简单易用的工具，因为它不需要任何配置就可以做一些很酷的事情。让我们来看看我们的<a class="ae ka" href="https://www.mmhaskell.com/blog/2018/7/30/beam-database-power-without-template-haskell" rel="noopener ugc nofollow" target="_blank"> Beam文章</a>中一个格式不佳的代码版本。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0ccc" class="ln kc hu lj b fv lo lp l lq lr">{-# LANGUAGE DeriveGeneric #-}<br/>{-# LANGUAGE FlexibleContexts #-}<br/>{-# LANGUAGE FlexibleInstances #-}<br/>{-# LANGUAGE GADTs #-}<br/>{-# LANGUAGE MultiParamTypeClasses #-}<br/>{-# LANGUAGE OverloadedStrings #-}<br/>{-# LANGUAGE StandaloneDeriving #-}<br/>{-# LANGUAGE TypeApplications #-}<br/>{-# LANGUAGE TypeFamilies #-}<br/>{-# LANGUAGE TypeSynonymInstances #-}<br/>{-# LANGUAGE ImpredicativeTypes #-}</span><span id="f577" class="ln kc hu lj b fv ls lp l lq lr">module Schema where</span><span id="7594" class="ln kc hu lj b fv ls lp l lq lr">import Database.Beam<br/>import Database.Beam.Backend<br/>import Database.Beam.Migrate<br/>import Database.Beam.Sqlite<br/>import Database.SQLite.Simple (open, Connection)</span><span id="abb5" class="ln kc hu lj b fv ls lp l lq lr">import Data.Int (Int64)<br/>import Data.Text (Text)<br/>import Data.Time (UTCTime)<br/>import qualified Data.UUID as U</span><span id="4549" class="ln kc hu lj b fv ls lp l lq lr">data UserT f = User<br/>  { _userId :: Columnar f Int64<br/>  , _userName :: Columnar f Text<br/>  , _userEmail :: Columnar f Text<br/>  , _userAge :: Columnar f Int<br/>  , _userOccupation :: Columnar f Text<br/>  } deriving (Generic)</span></pre><p id="f2b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有很多不可取的东西。我们的语言pragmas不会将它们的右括号排成一行。它们也没有任何可辨别的顺序。我们的导入也没有对齐，我们的数据类型中的字段也没有对齐。</p><p id="9355" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">时尚的Haskell可以解决这一切。首先，我们将在全球范围内安装它:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="be44" class="ln kc hu lj b fv lo lp l lq lr">stack install stylish-haskell</span></pre><p id="d4d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(也可以用<code class="eh lt lu lv lj b">cabal</code>代替<code class="eh lt lu lv lj b">stack</code>)。然后我们可以在一个文件上调用<code class="eh lt lu lv lj b">stylish-haskell</code>命令。默认情况下，它会将结果输出到终端。但是如果我们传递了<code class="eh lt lu lv lj b">-i</code>标志，它将就地更新文件。这将使所有我们想要的改变在我们的文件中排列各种各样的陈述！</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4217" class="ln kc hu lj b fv lo lp l lq lr">&gt;&gt; stylish-haskell -i Schema.hs</span><span id="37ef" class="ln kc hu lj b fv ls lp l lq lr">--- Result:</span><span id="a499" class="ln kc hu lj b fv ls lp l lq lr">{-# LANGUAGE DeriveGeneric         #-}<br/>{-# LANGUAGE FlexibleContexts      #-}<br/>{-# LANGUAGE FlexibleInstances     #-}<br/>{-# LANGUAGE GADTs                 #-}<br/>{-# LANGUAGE ImpredicativeTypes    #-}<br/>{-# LANGUAGE MultiParamTypeClasses #-}<br/>{-# LANGUAGE OverloadedStrings     #-}<br/>{-# LANGUAGE StandaloneDeriving    #-}<br/>{-# LANGUAGE TypeApplications      #-}<br/>{-# LANGUAGE TypeFamilies          #-}<br/>{-# LANGUAGE TypeSynonymInstances  #-}</span><span id="05d9" class="ln kc hu lj b fv ls lp l lq lr">module Schema where</span><span id="b7e9" class="ln kc hu lj b fv ls lp l lq lr">import           Database.Beam<br/>import           Database.Beam.Backend<br/>import           Database.Beam.Migrate<br/>import           Database.Beam.Sqlite<br/>import           Database.SQLite.Simple (Connection, open)</span><span id="f045" class="ln kc hu lj b fv ls lp l lq lr">import           Data.Int               (Int64)<br/>import           Data.Text              (Text)<br/>import           Data.Time              (UTCTime)<br/>import qualified Data.UUID              as U</span><span id="7891" class="ln kc hu lj b fv ls lp l lq lr">data UserT f = User<br/>  { _userId         :: Columnar f Int64<br/>  , _userName       :: Columnar f Text<br/>  , _userEmail      :: Columnar f Text<br/>  , _userAge        :: Columnar f Int<br/>  , _userOccupation :: Columnar f Text<br/>  } deriving (Generic)</span></pre><p id="878e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">时尚的Haskell与大多数常见的编辑器集成得很好。例如，如果您使用Vim，您也可以在编辑器中运行该命令:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d065" class="ln kc hu lj b fv lo lp l lq lr">:%!stylish-haskell</span></pre><p id="b240" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们无需任何配置即可获得所有这些功能。如果我们想改变一些事情，我们可以创建一个配置文件。我们将使用以下命令创建一个默认文件:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="915e" class="ln kc hu lj b fv lo lp l lq lr">stylish-haskell --defaults &gt; .stylish-haskell.yaml</span></pre><p id="812f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们愿意，我们可以稍微修改一下。举个例子，我们在全球范围内调整了我们的进口。这意味着它们都为<code class="eh lt lu lv lj b">qualified</code>留出了空间。但是，如果没有合格的导入，我们可以决定不希望一组导入拥有该空间。在配置中有这方面的设置。默认情况下，它看起来像这样:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6430" class="ln kc hu lj b fv lo lp l lq lr">imports:<br/>  align: global</span></pre><p id="210c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以将其更改为<code class="eh lt lu lv lj b">group</code>,以确保我们的导入只在他们的分组内对齐。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="87f7" class="ln kc hu lj b fv lo lp l lq lr">imports:<br/>  align: group</span></pre><p id="4631" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，当我们运行该命令时，我们将得到一个不同的结果:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="e153" class="ln kc hu lj b fv lo lp l lq lr">module Schema where</span><span id="700f" class="ln kc hu lj b fv ls lp l lq lr">import Database.Beam<br/>import Database.Beam.Backend<br/>import Database.Beam.Migrate<br/>import Database.Beam.Sqlite<br/>import Database.SQLite.Simple (Connection, open)</span><span id="61e0" class="ln kc hu lj b fv ls lp l lq lr">import           Data.Int  (Int64)<br/>import           Data.Text (Text)<br/>import           Data.Time (UTCTime)<br/>import qualified Data.UUID as U</span></pre><p id="cbd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以简而言之，时髦的Haskell对于有限的范围来说是一个伟大的工具。它对几个领域如进口和pragmas有无可争议的建议。它还删除了尾随空格，并合理地调整了case语句。也就是说，它不会影响您的主Haskell代码。让我们来看几个可以做到这一点的工具。</p><h1 id="a3b1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">欣登</h1><p id="77a3" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们可以使用的另一个程序是<code class="eh lt lu lv lj b"><a class="ae ka" href="https://github.com/commercialhaskell/hindent" rel="noopener ugc nofollow" target="_blank">hindent</a></code>。顾名思义，它处理空白和缩进级别的更新。让我们看一个非常简单的例子。考虑这段代码，它改编自我们的Beam文章:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="cdb5" class="ln kc hu lj b fv lo lp l lq lr">user1' = User default_  (val_ "James")  (val_ "james@example.com")  (val_ 25)  (val_ "programmer")</span><span id="a4cd" class="ln kc hu lj b fv ls lp l lq lr">findUsers :: Connection -&gt; IO ()<br/>findUsers conn = runBeamSqlite conn $ do<br/>    users &lt;- runSelectReturningList $ select $ do<br/>        user &lt;- (all_ (_blogUsers blogDb))<br/>        article &lt;- (all_ (_blogArticles blogDb))<br/>        guard_ (user ^. userName ==. (val_ "James"))<br/>        guard_ (article ^. articleUserId ==. user ^. userId) <br/>        return (user, article)<br/>    mapM_ (liftIO . putStrLn . show) users</span></pre><p id="9a52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有些事情我们可以改变。首先，我们可能希望更新缩进级别，使其为2而不是4。其次，让我们将行大小限制为80。当我们在这个文件上运行<code class="eh lt lu lv lj b">hindent</code>时，它会做出改变。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="614f" class="ln kc hu lj b fv lo lp l lq lr">user1' =<br/>  User<br/>    default_<br/>    (val_ "James")<br/>    (val_ "james@example.com")<br/>    (val_ 25)<br/>    (val_ "programmer")</span><span id="7ae9" class="ln kc hu lj b fv ls lp l lq lr">findUsers :: Connection -&gt; IO ()<br/>findUsers conn =<br/>  runBeamSqlite conn $ do<br/>    users &lt;-<br/>      runSelectReturningList $<br/>      select $ do<br/>        user &lt;- (all_ (_blogUsers blogDb))<br/>        article &lt;- (all_ (_blogArticles blogDb))<br/>        guard_ (user ^. userName ==. (val_ "James"))<br/>        guard_ (article ^. articleUserId ==. user ^. userId)<br/>        return (user, article)<br/>    mapM_ (liftIO . putStrLn . show) users</span></pre><p id="564a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Hindent也是可配置的。我们可以创建一个文件<code class="eh lt lu lv lj b">.hindent.yaml</code>。默认情况下，我们将具有以下配置:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="25d9" class="ln kc hu lj b fv lo lp l lq lr">indent-size: 2<br/>line-length: 80<br/>force-trailing-newline: true</span></pre><p id="db58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，如果我们愿意，我们可以更改它，使缩进级别为3:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="30bb" class="ln kc hu lj b fv lo lp l lq lr">indent-size: 3</span></pre><p id="f78d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，当我们运行它时，我们实际上会看到它发生了变化，以反映:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8936" class="ln kc hu lj b fv lo lp l lq lr">findUsers :: Connection -&gt; IO ()<br/>findUsers conn =<br/>   runBeamSqlite conn $ do<br/>      users &lt;-<br/>         runSelectReturningList $<br/>         select $ do<br/>            user &lt;- (all_ (_blogUsers blogDb))<br/>            article &lt;- (all_ (_blogArticles blogDb))<br/>            guard_ (user ^. userName ==. (val_ "James"))<br/>            guard_ (article ^. articleUserId ==. user ^. userId)<br/>            return (user, article)<br/>      mapM_ (liftIO . putStrLn . show) users</span></pre><p id="02c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">据我所知，Hindent还有一些其他的效果是不可配置的。可以看到上面没有保留分割线。在另一个例子中，它分隔了我在另一个文件中分组的实例定义:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="e9be" class="ln kc hu lj b fv lo lp l lq lr">-- BEFORE<br/>deriving instance Show User<br/>deriving instance Eq User<br/>deriving instance Show UserId<br/>deriving instance Eq UserId</span><span id="53b6" class="ln kc hu lj b fv ls lp l lq lr">-- AFTER<br/>deriving instance Show User</span><span id="d858" class="ln kc hu lj b fv ls lp l lq lr">deriving instance Eq User</span><span id="cc7d" class="ln kc hu lj b fv ls lp l lq lr">deriving instance Show UserId</span><span id="c6cb" class="ln kc hu lj b fv ls lp l lq lr">deriving instance Eq UserId</span></pre><p id="871f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在使用它之前，请确保您了解它的所有功能。像<code class="eh lt lu lv lj b">stylish-haskell</code>，<code class="eh lt lu lv lj b">hindent</code>与文本编辑器集成得很好。</p><h1 id="8e41" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">布列塔尼</h1><p id="c984" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Brittany是Hindent的替代方法，用于修改表达式定义。它主要关注在你的代码中水平空间的使用。据我所知，它不像<code class="eh lt lu lv lj b">stylish-haskell</code>那样排列语言编译指令或改变导入语句。它也不涉及数据类型声明。相反，它试图重新格式化你的代码，以最大限度地利用空间，同时避免过长的代码行。作为一个例子，我们可以看看我们的<code class="eh lt lu lv lj b">Beam</code>例子中的这一行:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="e895" class="ln kc hu lj b fv lo lp l lq lr">insertArticles :: Connection -&gt; IO ()<br/>insertArticles conn = runBeamSqlite conn $ runInsert $ <br/>  insert (_blogArticles blogDb) $ insertValues articles</span></pre><p id="94d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在哪里分割线的决定有点武断。但至少我们不会试图将所有内容都塞进一行。但是，如果我们有上面的方法或单行版本，Brittany会将其更改为:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4632" class="ln kc hu lj b fv lo lp l lq lr">brittany --write-mode=inplace MyModule.hs</span><span id="73e0" class="ln kc hu lj b fv ls lp l lq lr">--</span><span id="b364" class="ln kc hu lj b fv ls lp l lq lr">insertArticles :: Connection -&gt; IO ()<br/>insertArticles conn =<br/>  runBeamSqlite conn $ runInsert $ insert (_blogArticles blogDb) $ insertValues<br/>    articles</span></pre><p id="dd35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这使得水平空间得到“更好”的利用，因为我们在第一行得到了同样多的空间。也就是说，有人会说我们的第一种方法看起来更好。Brittany还可以更改超出行限制的类型签名。假设我们有这个任意类型的签名，它对于一行来说太长了:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="c08b" class="ln kc hu lj b fv lo lp l lq lr">myReallyLongFunction :: State ComplexType Double -&gt; Maybe Double -&gt; Either Double ComplexType -&gt; IO a -&gt; StateT ComplexType IO a</span></pre><p id="93cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Brittany将对其进行修改，以便每个参数类型都在一行中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="70a2" class="ln kc hu lj b fv lo lp l lq lr">myReallyLongFunction<br/>  :: State ComplexType Double<br/>  -&gt; Maybe Double<br/>  -&gt; Either Double ComplexType<br/>  -&gt; IO a<br/>  -&gt; StateT ComplexType IO a</span></pre><p id="82d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这在类型非常复杂的项目中非常有用。该结构使您更容易向各种参数添加Haddock注释。</p><h1 id="32ce" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">危险</h1><p id="95be" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当然，使用这样的工具有(小)危险。如果你要使用它们，你要确保项目中的每个人都在使用它们。假设人A没有使用程序，并且提交了不是由程序格式化的代码。然后，人员B可能会仔细检查代码，他们的编辑器会更正文件。这将给他们留下与他们正在做的任何工作都不相关的文件本地更改。当他们提交代码进行评审时，这会导致很多混乱。无论是谁审查他们的代码，都必须仔细检查格式的变化，这减慢了审查的速度。</p><p id="544d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">人们也可能对代码格式有(不合理的)强烈意见。因此，这通常是你希望在项目早期就确定下来，并避免事后改变的事情。对于本文中的例子，我认为在项目中使用时髦的Haskell是一件容易的事情。但是，在H-Indent和Brittany中做出的具体选择可能会更有争议。因此，在整个项目范围内建立这些机制可能会导致更多的问题，而不是解决更多的问题。</p><h1 id="bc52" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="6b05" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">代码格式化可能会损失大量的生产力。所以尽早和经常地确定标准是很重要的。代码格式化程序可以使特定标准的实施变得容易。使用<code class="eh lt lu lv lj b">stack</code>和你选择的编辑器，它们也很容易被整合到你的项目中！</p><p id="7c2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然你已经知道了如何格式化你的代码，还需要一些关于下一步工作的建议吗？看看我们的<a class="ae ka" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！它会给你一些很酷的库的想法，你可以用它来构建Haskell web应用程序等等！</p></div></div>    
</body>
</html>