<html>
<head>
<title>Python stories, July 2018</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python故事，2018年7月</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/python-stories-july-2018-c0b5443faff?source=collection_archive---------32-----------------------#2018-08-06">https://medium.com/hackernoon/python-stories-july-2018-c0b5443faff?source=collection_archive---------32-----------------------#2018-08-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7c7e235bdcc3a1fe7fdadb4fb7638226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EdeQ8QvBdLMMnTSp.png"/></div></div></figure><p id="a8a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我正在运行<a class="ae ka" href="https://t.me/pythonetc" rel="noopener ugc nofollow" target="_blank"> @pythonetc </a>，一个关于Python和<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的电报频道。以下是2018年7月最好的帖子。</p><h1 id="f05a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">常规语言</h1><p id="e7ac" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">正则语言是一种可以被有限状态机(<!-- --> FSM <!-- -->)识别的正式语言。简单地说，这意味着要一个字符一个字符地处理文本，你只需要记住当前的状态，而这样的状态的数量是有限的。</p><p id="d190" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">美丽而简单的例子是一台机器，它检查输入是否是一个简单的数字，如<code class="eh le lf lg lh b">-3</code>、<code class="eh le lf lg lh b">2.2</code>或<code class="eh le lf lg lh b">001</code>。本文开头的图片是一个有限状态机图。双圆圈表示<em class="li">接受状态</em>，它们表示机器可以停止的位置。</p><p id="232c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">机器从①开始，可能匹配负号，然后在③处理所需数量的数字。之后可能会匹配一个点(③ → ④)后面必须跟一个数字(④ → ⑤)，但可能更多(⑤ → ⑤)。</p><p id="5593" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非正则语言的典型例子是一系列字符串，如:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="5e2f" class="lr kc hu lh b fv ls lt l lu lv">a-b<br/>aaa-bbb<br/>aaaaa-bbbbb</span></pre><p id="8787" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">形式上，我们需要一行包含<code class="eh le lf lg lh b">a</code>的<code class="eh le lf lg lh b">N</code>次出现，然后是<code class="eh le lf lg lh b">-</code>，然后是<code class="eh le lf lg lh b">b</code>的N次出现。<code class="eh le lf lg lh b">N</code>是大于零的整数。你不能用一个有限的机器来做这件事，因为你必须记住你遇到的<code class="eh le lf lg lh b">a</code>字符的数量，这导致你有无限多的状态。</p><p id="4b19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正则表达式只能匹配正则语言。记住要检查FSM是否可以处理您要处理的行。<code class="eh le lf lg lh b">JSON</code>、<code class="eh le lf lg lh b">XML</code>甚至仅仅是带嵌套括号的算术表达式都不能。</p><p id="1cad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有趣的是，很多现代正则表达式引擎<em class="li">并不是正则的</em>。例如，<a class="ae ka" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a> <code class="eh le lf lg lh b">regex</code>模块支持递归(<!-- -->将帮助<!-- -->解决那个<code class="eh le lf lg lh b">aaa-bbb</code>问题)。</p><h1 id="1a7a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">动态调度</h1><p id="dde1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当Python执行一个方法调用时，比如说<code class="eh le lf lg lh b">a.f(b, c, d)</code>，它应该首先选择正确的<code class="eh le lf lg lh b">f</code>函数。由于多态性，选择什么取决于<code class="eh le lf lg lh b">a</code>的类型。选择方法的过程通常称为<em class="li">动态调度</em>。</p><p id="aea4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Python只支持单分派多态性，这意味着单个对象(示例中的<code class="eh le lf lg lh b">a</code>)单独影响方法选择。然而，其他一些语言也可能考虑<code class="eh le lf lg lh b">b</code>、<code class="eh le lf lg lh b">c</code>和<code class="eh le lf lg lh b">d</code>的类型。这种机制叫做<em class="li">多重调度</em>。C#是支持这种技术的语言的一个显著例子。</p><p id="4627" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，可以通过单个分派来模拟多个分派。<em class="li"> visitor </em>设计模式正是为此而创建的。<em class="li">访问者</em>本质上只是使用两次单调度来模仿双调度。</p><p id="d96a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，重载方法的能力(像在Java和C++中)不同于多重分派。动态调度在运行时工作，而重载只影响编译时。</p><p id="484a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一些更好理解主题的代码示例:<!-- --> Python visitor示例<!-- -->、<!-- --> Java重载不作为多分派<!-- -->、<!-- --> C#多分派<!-- -->。</p><h1 id="c4fd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">内置名称</h1><p id="ef61" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在Python中，您可以轻松地修改全局名称空间中可用的所有标准变量:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="2db3" class="lr kc hu lh b fv ls lt l lu lv">&gt;&gt;&gt; print = 42<br/>&gt;&gt;&gt; print(42)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'int' object is not callable</span></pre><p id="6b3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您的模块定义了一些与内置函数同名的函数，这可能会有所帮助。如果您练习元编程并接受任意字符串作为标识符，也会发生这种情况。</p><p id="a9be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，即使您隐藏了一些内置名称，您仍然可能想要访问它们最初引用的内容。<code class="eh le lf lg lh b">builtins</code>模块正是为此而存在的:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="e792" class="lr kc hu lh b fv ls lt l lu lv">&gt;&gt;&gt; import builtins<br/>&gt;&gt;&gt; print = 42<br/>&gt;&gt;&gt; builtins.print(1)<br/>1</span></pre><p id="1e9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">__builtins__</code>变量在大多数模块中也是可用的。不过有一个问题。首先，这是一个<code class="eh le lf lg lh b">cpython</code>实现细节，通常根本不应该使用。其次，<code class="eh le lf lg lh b">__builtins__</code>可能指的是<code class="eh le lf lg lh b">builtins</code>或<code class="eh le lf lg lh b">builtins.__dict__</code>，这取决于当前模块是如何加载的。</p><h1 id="cea2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">斯特拉斯</h1><p id="88c0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有时软件在生产中开始表现怪异。您可能希望了解到底发生了什么，以便稍后可以修复它，而不是简单地重新启动它。</p><p id="fe4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显而易见的方法是分析程序做什么，并试图猜测哪段代码正在执行。当然，适当的日志记录会使这项任务变得更容易，但是您的应用程序的日志可能不够详细，这可能是设计使然，也可能是因为配置中设置了高级别的日志记录。</p><p id="8af3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在那种情况下，<code class="eh le lf lg lh b">strace</code>可能是相当有益的。这是一个Unix工具，可以为你跟踪系统调用。您可以提前运行它— <code class="eh le lf lg lh b">strace python script.py</code> —但是通常连接到已经执行的应用程序更合适:<code class="eh le lf lg lh b">strace -p PID</code>。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="bc93" class="lr kc hu lh b fv ls lt l lu lv">$ cat test.py<br/>with open('/tmp/test', 'w') as f:<br/>    f.write('test')<br/>$ strace python test.py 2&gt;&amp;1 | grep open | tail -n 1<br/>open("/tmp/test", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3</span></pre><p id="eb8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">跟踪中的每一行都包含系统调用名，后跟括号中的参数及其返回值。由于一些参数用于从系统调用返回结果，而不是向其中传递数据，所以行输出可能会被中断，直到系统调用结束。</p><p id="5738" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本例中，输出被中断，直到有人写入STDIN:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="2ddc" class="lr kc hu lh b fv ls lt l lu lv">$ strace python -c 'input()'<br/>read(0,</span></pre><h1 id="d3c0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">元组文字</h1><p id="a21b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Python语法中最不一致的部分之一是元组文字。</p><p id="f19e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本上，要创建一个tuple，你只需要写一些用逗号分隔的值:<code class="eh le lf lg lh b">1, 2, 3</code>。好的，到目前为止，一切顺利。只包含一个元素的tuple怎么办？您只需在唯一的值:<code class="eh le lf lg lh b">1,</code>中添加尾随逗号。嗯，这有点难看而且容易出错，但是有道理。</p><p id="8dbd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">空元组怎么办？难道是光秃秃的<code class="eh le lf lg lh b">,</code>？不，是<code class="eh le lf lg lh b">()</code>。圆括号和逗号一样可以创建元组吗？不，他们没有，<code class="eh le lf lg lh b">(4)</code>不是元组，只是<code class="eh le lf lg lh b">4</code>。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="6563" class="lr kc hu lh b fv ls lt l lu lv">In : a = [<br/>...:     (1, 2, 3),<br/>...:     (1, 2),<br/>...:     (1),<br/>...:     (),<br/>...: ]</span><span id="edad" class="lr kc hu lh b fv lw lt l lu lv">In : [type(x) for x in a]<br/>Out: [tuple, tuple, int, tuple]</span></pre><p id="4df7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使事情更加模糊，元组常需要额外的括号。如果你想让一个元组成为一个函数的唯一参数，那么<code class="eh le lf lg lh b">f(1, 2, 3)</code>不工作的原因很明显，你需要<code class="eh le lf lg lh b">f((1, 2, 3))</code>来代替。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure></div></div>    
</body>
</html>