<html>
<head>
<title>Docker Tutorial Series Part 1: Images, Layers and Dockerfile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker教程系列第1部分:图像、图层和docker文件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/docker-tutorial-series-part-1-images-layers-and-dockerfile-249f88041c82?source=collection_archive---------40-----------------------#2018-08-06">https://medium.com/hackernoon/docker-tutorial-series-part-1-images-layers-and-dockerfile-249f88041c82?source=collection_archive---------40-----------------------#2018-08-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="13c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文是关于<a class="ae jp" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank">码头工人</a>系列文章的第一篇。今天我们要介绍Docker的核心概念。然后我们将使用Dockerfile构建我们的第一个Docker映像，然后实例化一个容器。</p><p id="7383" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您想获得容器和虚拟机的简要概述，请访问此链接:</p><div class="jq jr fm fo js jt"><a rel="noopener follow" target="_blank" href="/@adityadixit06/age-of-docker-containers-vs-virtual-machines-c164c9e914bc"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hv fv z el jy eo ep jz er et ht dt translated">Docker时代:容器vs虚拟机</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">虚拟机和容器执行相同的任务—它们隔离应用程序及其依赖项，允许它…</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">medium.com</p></div></div></div></a></div><p id="ce88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker是一个<a class="ae jp" href="https://hackernoon.com/tagged/platform" rel="noopener ugc nofollow" target="_blank">平台</a>，它允许你将你的应用从你的基础设施中分离出来。这种分离使得开发、扩展和运行应用程序变得更加容易。Docker基于客户机-服务器架构。“Docker守护进程”执行构建、部署和管理对象的繁重任务。而‘Docker客户端’是与Docker守护进程交互的命令行界面。</p><p id="d55e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开始之前，我想介绍几个我们将在Docker的这篇文章中用到的术语:</p><ul class=""><li id="320f" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk dt translated">图:带有创建Docker容器说明的只读模板。</li><li id="f2bd" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">容器:图像的可运行实例。它是可配置的，并与其他容器隔离。</li><li id="bdf3" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">服务:允许您定义应用程序的预期状态。</li><li id="8e9d" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">Dockerfile:包含创建图像的说明的文本文件。</li><li id="170f" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk dt translated">Docker Store:Docker图像的公共存储库。</li></ul><p id="8296" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Docker的第一步是获取映像的基础版本，然后在这个基础映像上安装应用程序文件和库。我们可以手动执行这个过程，但是随着复杂性的增加，这种方法很可能变得无法管理。一个更好的选择是使用Dockerfile。Dockerfile文件是创建图像的一系列指令。它位于应用程序的根文件夹中。这个Dockerfile文件由build命令使用，以生成应用程序的自定义映像。</p><p id="b1ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最简单的Dockerfile将执行以下操作:</p><ol class=""><li id="0f8b" class="kc kd hu it b iu iv iy iz jc ke jg kf jk kg jo kq ki kj kk dt translated">从Docker存储中提取操作系统和程序的基本映像</li><li id="25f4" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kq ki kj kk dt translated">安装库和二进制文件</li><li id="9b6e" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kq ki kj kk dt translated">将应用程序文件复制到容器</li><li id="795b" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kq ki kj kk dt translated">设置工作目录</li><li id="a22f" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kq ki kj kk dt translated">开放港口与外界交流</li><li id="206e" class="kc kd hu it b iu kl iy km jc kn jg ko jk kp jo kq ki kj kk dt translated">设置容器启动时运行的命令</li></ol><p id="92ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建图像的构建过程将消耗Dockerfile并生成我们的图像。然后，这个映像用于运行保存我们的应用程序的容器。</p><p id="4a5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kr ks kt ku b">docker image build -t [container-name] . </code> <br/> <code class="eh kr ks kt ku b">docker container run [container-name]</code></p><p id="86ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图像不是单一的整体块。它由几层组成，每个Dockerfile指令通常代表一个单独的层。每一层都是不可变的，并且建立在先前层的基础上。一个专用层跟踪对图像所做的更改。因此，当我们重建一个映像时，这个过程并不是从零开始的。如果构建图层所需的底层文件保持不变，则不会触及图层，而是使用缓存版本。重建过程从发现与先前版本有差异的层开始。这种协调方法使得构建过程非常快。</p><p id="9f27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，在编写docker文件时，每天更新几次的源代码文件应该放在更高的层中，以加快构建过程。而安装诸如第三方模块和内置库之类的应用程序依赖项应该更早进行。如果没有记住这一点，就意味着您将不得不在每次映像构建时重新安装所有的依赖项，从而大大降低映像构建过程的速度。</p></div><div class="ab cl kv kw hc kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hn ho hp hq hr"><p id="1609" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lc">原载于</em><a class="ae jp" href="http://blog.adityadixit.me/docker-tutorial-series-part-1.html" rel="noopener ugc nofollow" target="_blank"><em class="lc">blog . adityadixit . me</em></a><em class="lc">。</em></p><figure class="ld le lf lg fq lh"><div class="bz el l di"><div class="li lj l"/></div></figure></div></div>    
</body>
</html>