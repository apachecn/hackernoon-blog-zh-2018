<html>
<head>
<title>Serlina: A progressive React serverside-rendering framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Serlina:一个渐进式React服务器端渲染框架</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serlina-a-progressive-react-serverside-rendering-framework-a4de2d71d984?source=collection_archive---------31-----------------------#2018-08-07">https://medium.com/hackernoon/serlina-a-progressive-react-serverside-rendering-framework-a4de2d71d984?source=collection_archive---------31-----------------------#2018-08-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e79f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于<a class="ae jp" href="https://github.com/zeit/next.js/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>是一个轻量级且体验良好的服务器端渲染<a class="ae jp" href="https://hackernoon.com/tagged/framework" rel="noopener ugc nofollow" target="_blank">框架</a>，我喜欢在我的项目中使用它。它节省了我处理样板代码<a class="ae jp" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank">的时间。我写了React代码，它就工作了。</a></p><p id="a250" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是当我想在一个运行它自己的服务器的项目上使用它时，发生了一些事情。当调用<code class="eh jq jr js jt b">app.render</code>时，Next.js完全控制http上下文，而<a class="ae jp" href="https://github.com/eggjs/egg/issues/328#issuecomment-321962783" rel="noopener ugc nofollow" target="_blank">我们的服务器对上下文</a>有一些影响。</p><p id="3773" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我读了Next.js的代码，试图找到类似于<code class="eh jq jr js jt b">nextjs/core</code>的东西，但是没有。</p><p id="a23f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我决定做一个不运行服务器的服务器端渲染框架。它只进行编译，把你的页面转换成字符串。并让您自己的服务器将字符串呈现给客户端。并像Next.js一样保持良好的体验。</p><p id="5b0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是<a class="ae jp" href="https://github.com/djyde/serlina" rel="noopener ugc nofollow" target="_blank">瑟琳娜</a>是什么。让我们看看最简单的Serlina应用程序是怎样的:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="8781" class="kc kd hu jt b fv ke kf l kg kh">npm i serlina react react-dom --save</span></pre><p id="4e43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建如下所示的文件夹结构:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="fd65" class="kc kd hu jt b fv ke kf l kg kh">├── index.js # Your server<br/>├── page # Your React pages<br/>│   └── page1.js</span></pre><p id="0100" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您的服务器:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="3241" class="kc kd hu jt b fv ke kf l kg kh">// index.js<br/><br/>const { Serlina } = require('serlina')<br/>const path = require('path')<br/><br/>const http = require('http')<br/><br/>const serlina = new Serlina({<br/>  baseDir: path.resolve(__dirname, './')<br/>})<br/><br/>serlina.prepare()<br/>  .then(() =&gt; {<br/>    http.createServer(async (req, res) =&gt; {<br/>        res.writeHead(200, { 'Content-Type': 'text/html' })<br/>        if (req.url === '/page1') {<br/>          const rendered = await serlina.render('page1')<br/>          res.write(rendered.string)<br/>        } else {<br/>          res.write('works!')<br/>        }<br/>        res.end()<br/>    }).listen(8090)<br/>  })<br/>  .catch(console.error)</span></pre><p id="9e72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您的页面:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="2e56" class="kc kd hu jt b fv ke kf l kg kh">// page/page1.js<br/><br/>export default () =&gt; {<br/>  return &lt;div&gt;Hello Serlina!&lt;/div&gt;<br/>}</span></pre><p id="444e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，运行<code class="eh jq jr js jt b">node index.js</code>并访问<a class="ae jp" href="http://localhost:8090." rel="noopener ugc nofollow" target="_blank">http://localhost:8090/page 1。</a>您将看到React页面。</p><p id="0524" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，有两种主要方法:</p><ul class=""><li id="555b" class="ki kj hu it b iu iv iy iz jc kk jg kl jk km jo kn ko kp kq dt translated">prepare()做编译工作。</li><li id="2660" class="ki kj hu it b iu kr iy ks jc kt jg ku jk kv jo kn ko kp kq dt translated">render()呈现一个页面，并获取将被发送到客户端的呈现字符串。</li></ul><p id="fe4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与Next.js不同，Serlina需要手动注入您在<code class="eh jq jr js jt b">getInitialProps</code>中使用的有效负载:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="c4c6" class="kc kd hu jt b fv ke kf l kg kh">// index.js<br/><br/>const { Serlina } = require('serlina')<br/>const path = require('path')<br/><br/>const http = require('http')<br/><br/>const serlina = new Serlina({<br/>  baseDir: path.resolve(__dirname, './')<br/>})<br/><br/>serlina.prepare()<br/>  .then(() =&gt; {<br/>    http.createServer(async (req, res) =&gt; {<br/>+       serlina.injectPayload({ req }) // manually inject. globally</span><span id="e6bf" class="kc kd hu jt b fv kw kf l kg kh">        res.writeHead(200, { 'Content-Type': 'text/html' })<br/>        if (req.url === '/page1') {<br/>+         const rendered = await serlina.render('page1', { foo: 'bar' }) // manually inject. specifically.<br/>          res.write(rendered.string)<br/>        } else {<br/>          res.write('works!')<br/>        }<br/>        res.end()<br/>    }).listen(8090)<br/>  })<br/>  .catch(console.error)</span></pre><p id="f8ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您可以使用有效负载:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="c26d" class="kc kd hu jt b fv ke kf l kg kh">// page/page1.js<br/>import * as React from 'react'<br/><br/>export default class Page1 extends React.Component {<br/><br/>  static async getInitialProps ({ req }) {<br/>    return {<br/>      url: req.url<br/>    }<br/>  }<br/><br/>  render () {<br/>    return &lt;div&gt;You are now at {this.props.url}&lt;/div&gt;<br/>  }<br/>}</span></pre><p id="f69a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过<a class="ae jp" href="http://serlina.js.org" rel="noopener ugc nofollow" target="_blank">http://serlina.js.org</a>或<a class="ae jp" href="https://github.com/djyde/serlina" rel="noopener ugc nofollow" target="_blank">https://github.com/djyde/serlina</a>深入了解塞雷娜</p><p id="baa7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以在现有的代码库中轻松使用它。只需编写一个新的路由器，<code class="eh jq jr js jt b">prepare()</code>在启动你的服务器之前，<code class="eh jq jr js jt b">render()</code>一个页面，并将渲染后的字符串返回给客户端。那就是。这就是我称之为进步的原因。</p><p id="bc43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再比如<a class="ae jp" href="https://github.com/serlina-community/egg-serlina" rel="noopener ugc nofollow" target="_blank"> egg-serlina </a>，这也是我创作serlina的主要原因。它为<a class="ae jp" href="https://eggjs.org" rel="noopener ugc nofollow" target="_blank"> Egg.js </a>带来了最好的服务器端渲染解决方案。</p><figure class="ju jv jw jx fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure></div></div>    
</body>
</html>