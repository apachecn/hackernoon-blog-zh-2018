<html>
<head>
<title>Android: Location Tracking with a Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:位置追踪服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/android-location-tracking-with-a-service-80940218f561?source=collection_archive---------1-----------------------#2018-08-08">https://medium.com/hackernoon/android-location-tracking-with-a-service-80940218f561?source=collection_archive---------1-----------------------#2018-08-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d7c0b40fd26c97861af5b035066e82d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r7BobMvmbEYoSPJW"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@pathum_danthanarayana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pathum Danthanarayana</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d290" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我心中有一个目标:我需要一个GPS跟踪应用程序，它可以取代我的手持GPS设备作为位置跟踪器，并自动将轨迹(或部分轨迹)加载到我想要的位置，供其他人查看。</p><h1 id="fe10" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">背景</h1><p id="6b0c" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">有一段时间，我使用我的GeoApe门户网站与其他人分享我的GPS轨迹。我曾经四处旅行，用手持GPS追踪我的路线，然后我会上传路线给别人看。这在10年前非常有用。今天，我主要使用手机导航，携带GPS只是为了跟踪似乎不太合理。我也想在网上分享我的路线。</p><p id="9c38" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我决定编写我的第一个Android应用程序，它具有以下功能:</p><ol class=""><li id="d4b0" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">该应用程序使用设备的GPS，每0.7秒获取我的位置；</li><li id="750b" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">每分钟收集一次数据并上传到我的网络服务(或者如果没有互联网连接，则缓冲数据并在网络连接可以建立时发送)；</li><li id="9b2c" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">由于我将使用另一个导航应用程序，我的跟踪器必须能够在后台运行。</li></ol><h1 id="97fe" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">教程和示例</h1><p id="ef16" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">有很多很好的例子。不幸的是，他们没有帮助我完成我的“功能需求”的第三点。大多数示例在导航到桌面或打开“概述”屏幕时停止。我查看了后台服务，使用了pendingIntents，创建了自定义的locationListeners等等，但是似乎都没有用。</p><h1 id="0afb" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">问题的根源</h1><p id="15ab" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">Android开发者网站有一篇名为“<a class="ae jg" href="https://developer.android.com/about/versions/oreo/background-location-limits" rel="noopener ugc nofollow" target="_blank">后台位置限制</a>”的文章，揭示了这种行为的原因:“为了降低功耗，Android 8.0 (API level 26)限制了后台应用程序检索用户当前位置的频率。应用程序每小时只能接收几次位置更新<strong class="jj hv"/>。或者换句话说:如果你像我一样需要频繁的位置更新，就不要使用后台服务进行位置服务！</p><h1 id="eecd" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">解决办法</h1><p id="da4e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">然而，这并不意味着没有解决方案:像谷歌地图等应用程序仍然在后台使用你的位置，所以必须有一个解决方案。同一个页面给你一些提示:</p><blockquote class="lw lx ly"><p id="3405" class="jh ji lz jj b jk jl jm jn jo jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd ke hn dt translated">如果满足以下任一条件，应用程序将被视为处于前台:<br/> *它有一个可见的活动，无论该活动是开始还是暂停。它有一个前台服务。<br/> *另一个前台应用连接到应用/../</p></blockquote><p id="116b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以作为解决方案:<strong class="jj hv">创建一个前台服务</strong>！</p><p id="52b3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有人说可以将服务绑定为前台服务，如下所示:</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="d7d8" class="mm kg hu mi b fv mn mo l mp mq">final Intent intent = new Intent(this.getApplication(), BackgroundService.class);<br/> this.getApplication().<strong class="mi hv">startForegroundService</strong>(intent);<br/> this.getApplication().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</span></pre><p id="affa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为某些原因，这没用。所以我采取了不同的方法。我创建了一个通知生成器</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="7561" class="mm kg hu mi b fv mn mo l mp mq">private Notification getNotification() {<br/>  NotificationChannel channel = new NotificationChannel(<br/>    “channel_01”,<br/>    “My Channel”, <br/>    NotificationManager.IMPORTANCE_DEFAULT<br/>  );</span><span id="c2fd" class="mm kg hu mi b fv mr mo l mp mq">  NotificationManager notificationManager = getSystemService(NotificationManager.class);<br/> notificationManager.createNotificationChannel(channel);</span><span id="9871" class="mm kg hu mi b fv mr mo l mp mq">  Notification.Builder builder = new Notification.Builder(getApplicationContext(), “channel_01”);</span><span id="0f6a" class="mm kg hu mi b fv mr mo l mp mq">  return builder.build();<br/>}</span></pre><p id="2c85" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">并将以下内容添加到我的服务的onCreate()方法中:</p><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="1951" class="mm kg hu mi b fv mn mo l mp mq"><a class="ae jg" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>public void onCreate() {<br/>  startForeground(12345678, getNotification());<br/>}</span></pre><p id="ed4a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后<em class="lz">瞧</em>:应用程序根据需要工作。即使将应用程序发送到后台很长一段时间，它仍然会获取坐标并能够处理它们。</p><p id="a7a3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完整的PoC应用程序可在<a class="ae jg" href="https://bitbucket.org/tiitha/backgroundserviceexample/src/master/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。<br/> <strong class="jj hv"> NB！</strong>要知道，Android 8.0之前不需要通知通道(<em class="lz"> API level 26 </em>)。</p></div></div>    
</body>
</html>