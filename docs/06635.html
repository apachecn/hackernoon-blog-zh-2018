<html>
<head>
<title>Continuous integration in projects using monorepo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用monorepo在项目中持续集成</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/continuous-integration-in-projects-using-monorepo-9b828d7a8dfa?source=collection_archive---------2-----------------------#2018-08-08">https://medium.com/hackernoon/continuous-integration-in-projects-using-monorepo-9b828d7a8dfa?source=collection_archive---------2-----------------------#2018-08-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9ccc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在每个项目的开始，我们必须承诺一些重要的决定。在我们在<a class="ae jp" href="https://www.codenation.com.br" rel="noopener ugc nofollow" target="_blank"> Code:Nation </a>做出的正确决策中，我可以举出Go语言的使用、<a class="ae jp" rel="noopener" href="/@eminetto/clean-architecture-using-golang-b63587aa5e3f"> Clean Architecture </a>和<a class="ae jp" href="https://jamstack.org/" rel="noopener ugc nofollow" target="_blank"> JAMStack </a>的采用，以及我们将代码存储在Github的<em class="jq"> monorepo </em>中的选择。在这篇文章中，我将讨论后者，以及我们如何解决<em class="jq"> monorepo </em> <a class="ae jp" href="https://hackernoon.com/tagged/architecture" rel="noopener ugc nofollow" target="_blank">架构</a>带来的一个常见挑战。</p><p id="cbf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着现代项目越来越复杂，微服务和独特的用户界面消耗资源，团队需要决定是将代码分成多个存储库还是使用monorepo方法。一些公司如谷歌和数字海洋采用了<em class="jq"> monorepo </em>，我们可以在下面的帖子中看到:</p><ul class=""><li id="6b6f" class="jr js hu it b iu iv iy iz jc jt jg ju jk jv jo jw jx jy jz dt translated"><a class="ae jp" href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext" rel="noopener ugc nofollow" target="_blank">为什么谷歌在一个存储库中存储了数十亿行代码</a></li><li id="1679" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">克苏鲁:在可伸缩的回购协议中组织Go代码</li></ul><p id="46f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">依我拙见，使用<em class="jq"> monorepo </em>的主要原因是简单的存储库管理和跨团队的代码重用。</p><p id="54c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这个选择给项目带来的挑战之一是自动化构建和部署的潜在复杂性。考虑到一个复杂项目的所有代码都存储在同一个存储库中，单个文件中的更改可能会触发持续几分钟(或者几小时)的构建。这对团队来说是一种真正的痛苦，会降低日常工作效率。在我之前引用的DigitalOcean的帖子中，他们开发了一个内部解决方案，叫做<em class="jq"> gta </em> (Go Test Auto)，这不是开源的。为了解决这个问题，我们创建了一个类似的解决方案，但是使用了Shell脚本。</p><p id="3671" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前，这是我们项目的目录结构:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="052d" class="ko kp hu kk b fv kq kr l ks kt"><strong class="kk hv">api</strong> = API and documentation <br/><strong class="kk hv">chatbots</strong> = telegram, facebook and slack chatbots <br/><strong class="kk hv">cli</strong> = codenation cli, used by developers to run the challenges <br/><strong class="kk hv">cmd</strong> = utils and fixtures <br/><strong class="kk hv">core</strong> = Go core packages, used by all the project <br/><strong class="kk hv">docs</strong> = source code of internal docs (hosted at Github Pages) <strong class="kk hv">frontend</strong> = Vue.js project and templates used by Sam <br/><strong class="kk hv">infra</strong> = configuration files used by staging and production servers <strong class="kk hv">lambda</strong> = lambda functions <br/><strong class="kk hv">research</strong> = Python notebooks and other research assets <br/><strong class="kk hv">sam</strong> = cli tool used by us to generate pages, include challenges and other admin tasks <br/><strong class="kk hv">scripts</strong> = shell scrips used by CI/CD and other admin tasks <br/><strong class="kk hv">web</strong> = ReactJS project (Signin, Signup, Forgot password) - IN PROCESS OF DEPRECATION <br/><strong class="kk hv">workers</strong> = workers that consume SQS queues <br/><strong class="kk hv">.drone.yml</strong> = CI/CD configuration file <br/><strong class="kk hv">.goreleaser.yml</strong> = Goreleaser configuration file. Used to deploy the codenation-cli to Github, Homebrew <br/><strong class="kk hv">docker-compose.yml</strong> = Docker configuration used by local and staging environments <br/><strong class="kk hv">Gopkg.*</strong> = Go dependencies configuration files <br/><strong class="kk hv">Makefile</strong> = build and admin tasks</span></pre><p id="a33b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用<a class="ae jp" href="http://drone.io" rel="noopener ugc nofollow" target="_blank"> Drone.io </a>作为我们的CI/CD解决方案，这是我们做出的另一个好选择。下图中可以看到我们的构建管道:</p><figure class="kf kg kh ki fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff ku"><img src="../Images/daa24dc69c3b683cd30a6d1ea4dd8990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCXqVpCWw1ajDYtzZKQfKw.png"/></div></div></figure><p id="4e8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们的<em class="jq"> .drone.yml </em>配置文件的示例:</p><figure class="kf kg kh ki fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="fe ff lc"><img src="../Images/2729b4e1a6bc33fabf8ac63657d75609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJm0BEEuldpPRGl4fzDwbA.png"/></div></div></figure><p id="23dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以看到，步骤<em class="jq"> golang-build-api </em>执行脚本<em class="jq"> drone_go_build_api.sh </em>，即:</p><figure class="kf kg kh ki fq kv"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="9b78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在变量<em class="jq"> watch </em>中，我们存储了需要监控的目录列表，以便管道决定是否需要运行构建。这个决定是由脚本<em class="jq"> shouldIBuild.sh </em>做出的:</p><figure class="kf kg kh ki fq kv"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="a9a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个脚本中，首先测试的是变量<em class="jq"> DRONE_DEPLOY_TO </em>，它定义了当前的执行是部署还是构建。如果是这样，该步骤应该运行。否则，脚本将检查“<em class="jq"> watch </em>”变量中列出的目录之一是否已被该提交更改。如果是这样，该步骤应该运行。<em class="jq">detectchangedfolders . sh</em>的代码为:</p><figure class="kf kg kh ki fq kv"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="29ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Drone使用的所有脚本中都存在相同的配置。这样，前端的变化不会触发API或聊天机器人部分代码的构建。使用这种方法，我们将构建时间从超过五分钟减少到几秒钟，这取决于在存储库中提交的变更。</p><p id="7145" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我相信这种方法可以与其他不同于Drone的工具一起使用，我希望这可以帮助更多的团队满怀信心地坚持monorepo决策。</p><figure class="kf kg kh ki fq kv"><div class="bz el l di"><div class="lf le l"/></div></figure></div></div>    
</body>
</html>