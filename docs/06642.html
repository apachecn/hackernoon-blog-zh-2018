<html>
<head>
<title>How to Not Destroy Millions in Smart Contracts (Pt. 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在智能合约中不毁掉几百万(Pt。1)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-not-destroy-millions-in-smart-contracts-pt-1-bdefac3656b7?source=collection_archive---------9-----------------------#2018-08-08">https://medium.com/hackernoon/how-to-not-destroy-millions-in-smart-contracts-pt-1-bdefac3656b7?source=collection_archive---------9-----------------------#2018-08-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="33f8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="3670" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">随着基于区块链的加密货币的兴起，智能合约变得越来越流行。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ko"><img src="../Images/befa5b9eaa0ae33a71df0c82c83eaeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Um61rZvLmd396W26TlMrQw.png"/></div></div></figure><p id="1682" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">加密初创公司正在利用智能合同来创建可以在“<strong class="jr hv"><em class="lf"/></strong>”无信任环境中执行的智能协议。智能合同去掉了中间人，并根据制定的规则自动执行合同条款。虽然智能合约有很多承诺，但我们已经看到了一段令人担忧的智能合约被黑客攻击的历史，其中价值数亿美元的加密货币已经丢失或被盗。</p><p id="d3db" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">我对加密货币和基于区块链的<a class="ae kn" href="https://hackernoon.com/tagged/technology" rel="noopener ugc nofollow" target="_blank">技术</a>越来越感兴趣，这促使我研究和调查这些黑客攻击，以更好地了解<strong class="jr hv"> <em class="lf">它们是如何被黑客攻击的。</em>T11】</strong></p><p id="cea1" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">本文是3部分系列</strong>的第1部分，我们将深入探讨最臭名昭著的黑客攻击。<strong class="jr hv"> <em class="lf">我们将研究天才的笔触，或者细微的错误是如何在密码世界中引起地震的。</em> </strong></p><blockquote class="lg lh li"><p id="9958" class="jp jq lf jr b js la ju jv jw lb jy jz lj lc kc kd lk ld kg kh ll le kk kl km hn dt translated">旁白:本文基于<a class="ae kn" href="https://www.linkedin.com/in/leonidb/" rel="noopener ugc nofollow" target="_blank"> Leonid Beder </a>在<a class="ae kn" href="https://www.youtube.com/watch?v=xv7JNIBYR7A" rel="noopener ugc nofollow" target="_blank">区块链学院的精彩演讲——如何不摧毁数百万人。</a>我强烈推荐观看这个演讲，以及Youtube 频道上的所有其他材料。</p></blockquote><h1 id="3947" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">智能合同</h1><blockquote class="lg lh li"><p id="83cb" class="jp jq lf jr b js la ju jv jw lb jy jz lj lc kc kd lk ld kg kh ll le kk kl km hn dt translated">智能合同是一组以数字形式规定的承诺，包括各方履行这些承诺的协议— Nick Szabo，1996</p></blockquote><p id="ee9d" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">让我们逐项分解这个定义。</p><p id="ec54" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">合同</strong></p><p id="35c2" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">普通合同的一个例子是销售合同。</p><p id="f1d5" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">卖方<strong class="jr hv"> <em class="lf">承诺</em> </strong>为买方交货。</p><p id="0c01" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">买方<strong class="jr hv"> <em class="lf">承诺</em> </strong>支付想要的价格。</p><p id="0e7e" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">数字形式</strong></p><p id="e608" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">数字形式意味着合同必须用机器可读的代码编程。我们希望契约本质上是确定性的，因此每次都基于相同的输入提供相同的结果。</p><p id="7b29" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">协议</strong></p><p id="8c7a" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">例如，假设双方同意用比特币支付购买的商品。显而易见，比特币协议将是首选协议。</p><p id="1d7a" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">智能</strong></p><p id="c527" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">这听起来很酷。</p><p id="86f2" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">智能合约编程语言的流行实现</strong></p><p id="6d6f" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">以太坊</strong></p><p id="30e4" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">在其著名的智能契约框架区块链上实现了一种接近图灵完备的语言。我们说近似图灵完全b/c为了完全图灵完全，我们需要无限的计算能力。</p><p id="b9a2" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">比特币</strong></p><p id="ad6c" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">实现一种图灵不完全脚本语言，允许创建有限的智能合同，例如:</p><ul class=""><li id="639b" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">多重签名账户</li><li id="ae22" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">支付渠道</li><li id="bccb" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">escrows</li><li id="304b" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">时间锁</li><li id="d5c2" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">原子跨链交易</li><li id="9fdf" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">神谕</li></ul><h2 id="f5df" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">以身作则</h2><p id="58cb" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">Solidity是一种编写智能合约的OOP语言(大部分？)上以太坊。我们将从一个名为<strong class="jr hv"> Greeter的智能契约的简单示例开始，它将:</strong></p><ul class=""><li id="c825" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">用问候信息初始化(例如，“你好，世界！”)</li><li id="fa7a" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">提供读取/查询问候消息的方法。</li><li id="cf99" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">提供编写/修改问候语的方法。</li><li id="98cd" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">对于这些例子，我们将使用官方在线混音IDE @<a class="ae kn" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank">https://remix.ethereum.org</a></li></ul><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff mo"><img src="../Images/f850573f203a58aca43e08410d66b370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhrg767zkamqPGoDfMVHxg.png"/></div></div></figure><p id="fd26" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">目前最好的做法是明确指定我们正在使用的solidity的版本，因为我们不知道在未来的版本中会引入哪些bug。</p><p id="75a4" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">Solidity的语法与JS相似。我们正在定义一个名为<em class="lf"> Greeter的契约。</em>另外，我们有一个名为greeting的string类型的公共状态变量和两个方法(constructor和setGreeting)。</p><h2 id="b586" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated"><strong class="ak">基础:执行模型</strong></h2><ul class=""><li id="53d7" class="lm ln hu jr b js jt jw jx ka mp ke mq ki mr km lr ls lt lu dt translated">每个智能合约在部署到网络之前都需要编译成字节码。部署意味着存储在以太坊网络上。这可以是生产网络、测试网络或专用网络。</li><li id="5c25" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">以太坊中的每个事务或消息调用都由每个以太坊节点上的<strong class="jr hv">以太坊虚拟机(EVM)执行。(miner或者只是一个完整的节点)。</strong></li><li id="f54f" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">由于<strong class="jr hv">每个智能契约</strong>都在EVM上运行，并且<strong class="jr hv">每个单个操作</strong>都由网络中的<strong class="jr hv">每个节点</strong>同时执行，因此应该有一种机制<strong class="jr hv">来限制每个契约使用的资源</strong>。以太坊限制资源的机制是气体。</li><li id="a007" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">每一项操作都有一个确定的(但有时难以预测的)成本，以天然气为单位。很难确定gas成本，因为条件控制流可以改变在运行时执行哪些操作。想象一下下面的程序</li></ul><pre class="kp kq kr ks fq ms mt mu mv aw mw dt"><span id="8c21" class="ma is hu mt b fv mx my l mz na">if (condition is true) {</span><span id="0e59" class="ma is hu mt b fv nb my l mz na"> // do something super simple which is very cheap in gas terms</span><span id="625a" class="ma is hu mt b fv nb my l mz na">} else {</span><span id="480c" class="ma is hu mt b fv nb my l mz na">// do something really complicated which will be very expensive!</span><span id="3724" class="ma is hu mt b fv nb my l mz na">}</span></pre><ul class=""><li id="2291" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">交易消耗的每个气体单位必须基于由交易发送者设定的气体/乙醚价格以乙醚支付。每个发送者决定他愿意支付多少。这个想法对你来说越重要或越紧急，你就越愿意花钱。</li><li id="a931" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">交易还有一个<strong class="jr hv">气体限制参数，它是交易可以消耗多少气体的上限</strong></li><li id="672b" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">为什么需要气体极限参数？我们有一个上限b/c，我们并不总是清楚一个事务的执行会花费多少，我们想限制我们在它上面花费的开销！</li></ul><p id="99fa" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">让我们将合同上传到Remix IDE，创建并部署它。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/732eb8a192a3b9a5febd3b2f435d90e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*L-ya9PoC43wswdyKrXX5lQ.png"/></div></figure><p id="7467" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">混合可以对抗主网和测试网。对抗以太坊模拟真的很方便。当使用模拟时，我们可以假装拥有数百万个以太，而不是等待以太坊交易被处理，这使得开发速度大大加快。通过Remix运行智能合约是完全免费的，所以我建议你在家试一试:)</p><p id="8a8b" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">一旦部署了契约，我们就会在框中的已部署契约部分看到它(参见箭头！).请注意，我们可以轻松地更改构造函数参数并重新部署到网络。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nd"><img src="../Images/f13be8119e6c0cb1ec07e70070cab001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TCwOKw_SRtL37kQcV5Z9sA.gif"/></div></div></figure><h2 id="c3d3" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated"><strong class="ak">基础:特殊变量和函数</strong></h2><p id="c5b0" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">有一些特殊的变量和函数<strong class="jr hv">总是存在于全局名称空间中。这些是我们今天要讨论的</strong></p><ul class=""><li id="8813" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated"><strong class="jr hv"> <em class="lf"> msg.sender </em> </strong>(以太坊地址):消息的发送方(当前通话)。Thsi属于事务的原始调用者。这可以是用户帐户，也可以是另一个智能合同的地址。以太坊安全模型保证msg.sender不能被伪造。</li><li id="8047" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated"><strong class="jr hv"> <em class="lf"> msg.value </em> </strong>(单位):随消息发送的魏号。卫是乙醚的最小单位(认为美分是美元。)因此，这指定了我们通过购买、交易等功能发送了多少以太...</li></ul><h2 id="8088" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">基础:函数和状态变量的可见性</h2><p id="310e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在固体中，有四种类型的可见性:</p><p id="45af" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">对于功能:</p><ul class=""><li id="c6cb" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated"><strong class="jr hv">外部</strong>:可以从其他账户/合同外部调用。需要注意的是，我们不能从脚本中调用这段代码。我们需要创建一个额外的事务来从外部调用它。这对于需要公开访问的方法来说非常好，但是您希望避免在自己的代码中使用它们。</li><li id="f229" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated"><strong class="jr hv">公共</strong>(默认)<strong class="jr hv"> : </strong>大家都可以调用。</li><li id="550a" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated"><strong class="jr hv">内部</strong>:只能从我们的智能合约或者从我们的智能合约继承的智能合约内部调用。</li><li id="8932" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated"><strong class="jr hv"> private: </strong>只能在内部调用，并且只能从契约本身调用。</li></ul><p id="1056" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">对于状态变量:</p><ul class=""><li id="34ca" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated"><strong class="jr hv">公共</strong>:所有人都可以访问。Solidity自动为公共变量生成一个getter。</li><li id="d04e" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated"><strong class="jr hv">内部</strong>(默认):只能在内部访问，并且只能从合同本身访问。</li><li id="e233" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated"><strong class="jr hv">私有</strong>:只能在内部访问，并且只能从合同本身访问。</li></ul><h2 id="d845" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">基础:函数修饰符</h2><p id="9fe7" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">修饰符可以用来修改函数的行为。这让我们可以在函数调用之前、之后甚至前后添加功能。(例如日志记录)</p><p id="46a7" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">修饰符非常类似于其他编程语言中的before/after/around/hooks。</p><p id="9731" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">例如，让我们将我们的迎宾智能合同扩展到:</p><ul class=""><li id="7c32" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">拥有一个所有者(在我们的例子中，是智能契约的部署者)</li><li id="642a" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">确保只有所有者可以进一步修改问候语</li></ul><p id="ac0e" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">在接下来的例子中以及在野外，我们会经常看到这种模式。此外，让我们添加一个条件，即只有所有者可以更改问候语。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/5e8e3e1c8d70e08f5508bf9ea5ba0597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*q-pugopim9SFHsU_OKhGSw.png"/></div></figure><blockquote class="lg lh li"><p id="9498" class="jp jq lf jr b js la ju jv jw lb jy jz lj lc kc kd lk ld kg kh ll le kk kl km hn dt translated">需要注意的是，require在Solidity中是谓语。如果它的评估返回false，那么将抛出一个异常，在contract中完成的所有更改都将完全回滚。</p></blockquote><p id="0999" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">下划线相当于屈服。这基本上意味着在这个地方执行函数的剩余代码。</p><h2 id="bbed" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">基础:回退功能</h2><p id="46b6" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">一个智能契约只能有一个未命名的函数。</p><p id="027f" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">当调用约定并且没有其他函数匹配给定的函数标识符时，调用该函数。回退功能的一个常见用途是当乙醚被转移到合同时。这将触发回退功能的调用。因此，为了设置一个能够接收乙醚的账户，最起码(在大多数情况下)要设置这个功能。</p><h2 id="b615" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">基础:应付款修改量</h2><p id="c3ba" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了接收以太网，<strong class="jr hv">每个功能都必须标记为应付</strong>。这是为了保护我们不意外地将以太发送到一个不期望它的契约。</p><ul class=""><li id="b61f" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">当发送Ether作为函数调用的一部分时，该函数必须标记为<strong class="jr hv"> payable。</strong></li><li id="d42b" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">当直接向合同发送Ether时，其后备功能必须标记为应付。</li></ul><p id="4efc" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">如果不存在该功能，合同<strong class="jr hv">将无法通过常规交易</strong>接收乙醚。</p><h2 id="b9fa" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">事件示例</h2><p id="1e0c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是一种在以太坊进行日志记录的奇特方式。</p><blockquote class="lg lh li"><p id="5322" class="jp jq lf jr b js la ju jv jw lb jy jz lj lc kc kd lk ld kg kh ll le kk kl km hn dt translated">旁白:我们有一个名为<em class="hu">的函数来记录回报和事件。这对于拥有一个读取日志并管理所有捐赠的离链客户端的情况可能很有用。</em></p></blockquote><p id="2768" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">我们有一个函数叫做<em class="lf">捐赠</em>是<strong class="jr hv">应付</strong>(我们添加了应付修饰符)。我们还有一个叫<em class="lf">巨魔</em>的函数是<strong class="jr hv">不应付款</strong>，所以这种情况下发送以太应该会失败(应付款修饰符缺失)。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nf"><img src="../Images/d431fb0e36cbbc121f24a4c851428c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yf-l_cauQzeMvrGdMRp2Qg.png"/></div></div></figure><p id="8191" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">让我们将这个契约部署到Remix，这样我们就可以验证通过这些方法汇款的结果。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ng"><img src="../Images/333e1648477ef141180fa41fa941fcb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yXMbdxPp2Cxv3fnqsGRF0Q.gif"/></div></div></figure><p id="bef6" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">在上面的gif中我们可以看到，调用<em class="lf">捐赠</em>方法导致一个交易，其中价值为5魏被转移，而当我们调用<em class="lf">巨魔</em>方法时，没有钱被转移。</p><h2 id="6dc2" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">让我们摧毁一些以太</h2><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/50a73c9a27c910487aab43828c9721e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*T9C0NtwuAe1XHcuL.jpg"/></div></figure><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ni"><img src="../Images/754b37e9ef09f4f056331b42f490e022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DysyBfW3V3WsBCuEAzH2fg.png"/></div></div></figure><p id="b7a2" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">作为回报，我们可以看到在<em class="lf">地址和一个uint之间有一个映射。</em>我们在这里使用了一个所有者的概念，这样我们的所有者可以调用<em class="lf"> setReward </em>方法，决定一个特定的地址应该获得一定数量的魔法令牌。此外，我们有<em class="lf"> claimReward </em>方法，每个人都可以公开访问。这个方法给你属于你的地址的奖励，然后为奖励发出一个事件。</p><p id="86fd" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">有人能指出这有什么问题吗？</p><p id="d81b" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">注意，当我们声明<em class="lf">奖励</em>映射时，它是从<em class="lf">地址到无符号整数的映射。</em></p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nj"><img src="../Images/bcf3cd2d53790bb750dba5c2ab6dfdb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZuvNBMgSH7lAtkkJDjong.png"/></div></div></figure><p id="e0db" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">我们在这里做减法，却没有检查必要的资金是否可用！因此，任何情况下，当我们的奖励达到负值时，都会导致下溢。</p><blockquote class="lg lh li"><p id="6616" class="jp jq lf jr b js la ju jv jw lb jy jz lj lc kc kd lk ld kg kh ll le kk kl km hn dt translated">旁白:一个<a class="ae kn" href="https://math.stackexchange.com/questions/534670/arithmetic-overflow-and-underflowing" rel="noopener ugc nofollow" target="_blank"> n下溢</a>，将会把一个负值变成一个非常大的正值。查看链接，获得关于下溢如何工作的进一步解释。</p></blockquote><p id="fd0d" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">考虑下面的例子。提出500个单位的奖励要求。现在，我们的黑客将尝试并要求1000美元。理论上，这应该行不通，因为我们只剩下500块了。运行此交易<em class="lf">后，索赔者</em>将拥有无限数量的硬币！</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nk"><img src="../Images/a9fbcbf6732058d43854767d215bfc63.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*ldeu2zwofp2zBGwgJ21t0g.gif"/></div></div></figure><h1 id="89d5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">错误:溢出/下溢</h1><ul class=""><li id="336f" class="lm ln hu jr b js jt jw jx ka mp ke mq ki mr km lr ls lt lu dt translated">Solidity最多可以处理256位数</li><li id="17ae" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">溢出是指一个数的增量超过了它的最大值。所以0x fffffffffffffffffffffffffffffffff加1得到0。</li><li id="8e0d" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated"><strong class="jr hv">下溢</strong>是相反的情况，当数字无符号时，递减将下溢数字。反之亦然，从0x00000000000000000000中减去1得到0xFFFFFFFFFFFFFFFFFFFFF。</li></ul><p id="edf8" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">缓解#1:正确性测试</strong></p><ul class=""><li id="b113" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">在执行任何操作之前测试正确性。对此的一个快速解决方法是执行一个检查来验证索赔是否小于当前帐户余额。</li></ul><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nl"><img src="../Images/25b6b27401f6ab063a2740fd7d932d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3BDWQ7wjIuM6BNm4bSlvw.png"/></div></div></figure><p id="e43b" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">缓解#2:安全数学</strong></p><ul class=""><li id="5ec8" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">总是使用(事实上的)标准安全数学库。</li><li id="3b32" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">在OpenZeppelin的Github repo中找到好的、相对稳定的、聪明的合约。</li><li id="5a54" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">该库所做的是以一种安全的方式实现数学运算，这样，如果发生溢出，它将回滚事务。Assert与revert非常相似，它回滚错误的事务。</li><li id="aef3" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">在下面的例子中，我们已经导入了SafeMath，并将其注入到<em class="lf"> unit256 </em>中使用，因此库将恢复任何导致第30行下溢的事务。</li></ul><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ni"><img src="../Images/e73e3c717f7982a74e323ff9ccda0196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Me3kXWXIQzJ5kRvkgEI1-w.png"/></div></div></figure><h2 id="2735" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">设置功能可见性</h2><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff nm"><img src="../Images/fb5b002e6524e808c7a87d9031270f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VD3Nhu2q2_ILstS-qZH3Q.png"/></div></div></figure><p id="30ac" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">你能发现慈善合同中的一个错误吗？我们来分解一下。我们有一个可支付的后备功能和一个提取功能，所有者可以提取他的资金。你可以想象，在某个时候，所有者可能想要提取他的资金，这样他就可以用它们做一些事情。</p><p id="7622" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">现在，让我们来看看<em class="lf">设置者</em>的方法。它使用了所有者范式。它没有隐私。<strong class="jr hv">在Solidity中函数默认是公共的！</strong>任何人都可以改变所有者，从而将资金转移到自己手中。</p><p id="fa75" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">黑客场景:</strong></p><p id="15ce" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">爱丽丝为这个例子存了1000魏。鲍勃试图退出，但失败了，因为他不是慈善机构的所有者。现在，Bob调用setOwner，将所有者改为他自己。鲍勃拿走了所有的资金。这一切都是因为有人忘了定义可见性！</p><p id="41d7" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated"><strong class="jr hv">缓解#3:始终定义可见性！</strong></p><ul class=""><li id="9cc3" class="lm ln hu jr b js la jw lb ka lo ke lp ki lq km lr ls lt lu dt translated">始终定义可见性</li><li id="fd43" class="lm ln hu jr b js lv jw lw ka lx ke ly ki lz km lr ls lt lu dt translated">尽可能限制函数的可见性</li></ul><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/8d842ad8ccb5da0c293c480e215cf26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/1*_vmy2677_kiqRzyzN6tfvQ.gif"/></div></figure><h1 id="e17c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="879f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这是Solidity语言的初级读本，我们已经研究了在智能契约开发过程中可能犯的一些简单而危险的错误。</p><p id="7f9d" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">本系列的下一篇文章将深入探讨臭名昭著的、天才的和细致入微的黑客攻击，这些攻击在过去几年中已经耗费了价值数亿美元的密码。</p><p id="d00d" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">如果你正在寻找区块链世界的资源，我强烈推荐(再次)查看<a class="ae kn" href="https://www.youtube.com/channel/UCZ0z9fRKhW-GEjQs-_Jxfyg" rel="noopener ugc nofollow" target="_blank"> Kin生态系统Youtube频道</a>，因为它有一个高质量、技术讨论和讲座的精彩清单。非常感谢<a class="ae kn" href="https://www.linkedin.com/in/leonidb/" rel="noopener ugc nofollow" target="_blank"> Leonid Beder </a>建立这个讲座并在区块链学院教授它！</p><h2 id="7cb8" class="ma is hu bd it mb mc md ix me mf mg jb ka mh mi jf ke mj mk jj ki ml mm jn mn dt translated">如果这篇文章有帮助，请订阅并点击鼓掌👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">你可以在<a class="ae kn" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae kn" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae kn" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我。</p><figure class="kp kq kr ks fq kt"><div class="bz el l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>