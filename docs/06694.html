<html>
<head>
<title>Collecting logs from serverless Fn functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从无服务器Fn功能收集日志</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/collecting-logs-from-serverless-fn-functions-a3bc6a7d8ec9?source=collection_archive---------24-----------------------#2018-08-09">https://medium.com/hackernoon/collecting-logs-from-serverless-fn-functions-a3bc6a7d8ec9?source=collection_archive---------24-----------------------#2018-08-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0bb32f492db412668b3382a56648f006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8mzzRIXkn06XJmD4J9Jdg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@aleskrivec" rel="noopener ugc nofollow" target="_blank">Ales Krivec</a> on <a class="ae jg" href="https://unsplash.com/search/photos/log" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="81c7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt kf translated">日志记录是做好一件非常重要的事情，尤其是在(微)服务和功能世界中，你必须跟踪数百个服务和功能中发生的事情。</p><p id="32a3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将简要介绍如何从Fn函数中收集日志</p><h2 id="ce5c" class="ko kp hu bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li dt translated">先决条件</h2><ul class=""><li id="4f55" class="lj lk hu jj b jk ll jo lm js ln jw lo ka lp ke lq lr ls lt dt translated"><a class="ae jg" href="https://github.com/fnproject/cli" rel="noopener ugc nofollow" target="_blank"> Fn CLI </a></li><li id="161f" class="lj lk hu jj b jk lu jo lv js lw jw lx ka ly ke lq lr ls lt dt translated">Fn服务器(您可以使用<code class="eh lz ma mb mc b">fn start</code>命令调出本地服务器)</li></ul></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="d3dc" class="mk kp hu bd kq ml mm mn ku mo mp mq ky mr ms mt lb mu mv mw le mx my mz lh na dt translated">创建一个简单的Go函数</h1><p id="8e38" class="pw-post-body-paragraph jh ji hu jj b jk ll jm jn jo lm jq jr js nb ju jv jw nc jy jz ka nd kc kd ke hn dt kf translated">从使用Fn CLI ( <code class="eh lz ma mb mc b">fn init --runtime go</code>)创建新功能开始。我在函数中添加了两个日志语句——hello和goodbye，如下所示:</p><figure class="nf ng nh ni fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/2f7b8d5b99fc59e7651b71b50bcdfe44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CQeovhu_GNuJAztK14m9Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Boilerplate Fn function with two logging statements added</figcaption></figure><p id="209e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们像这样部署和调用这个函数:</p><pre class="nf ng nh ni fq nj mc nk nl aw nm dt"><span id="273f" class="ko kp hu mc b fv nn no l np nq">$ fn deploy --app logtest</span><span id="9930" class="ko kp hu mc b fv nr no l np nq">... deploy output ...</span><span id="7858" class="ko kp hu mc b fv nr no l np nq">$ fn call logtest /logtest<br/>{"message":"Hello World"}</span></pre><blockquote class="ns nt nu"><p id="6a59" class="jh ji nv jj b jk jl jm jn jo jp jq jr nw jt ju jv nx jx jy jz ny kb kc kd ke hn dt translated">注意:除了运行<code class="eh lz ma mb mc b">fn call</code>，你还可以列出你的应用程序的路线(<code class="eh lz ma mb mc b">fn list routes [appname]</code>)，然后直接调用实际的端点。</p></blockquote><p id="01ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们从函数中得到响应——但是日志在哪里呢？</p><p id="46a6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Fn CLI有一个命令，允许您检索指定应用程序和呼叫id的日志。应用程序名称不足以获取日志——您需要更加具体，并提供一个调用ID，该ID在您每次调用函数时都会被创建。要获得呼叫，你运行<code class="eh lz ma mb mc b">fn list calls</code>命令并提供你的应用程序名称。</p><pre class="nf ng nh ni fq nj mc nk nl aw nm dt"><span id="244d" class="ko kp hu mc b fv nn no l np nq">$ fn list calls logtest</span></pre><p id="fd57" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您将收到一个响应，其中列出了对您的函数的所有调用，每个调用都有唯一的ID、时间戳、应用程序和路线信息及状态:</p><pre class="nf ng nh ni fq nj mc nk nl aw nm dt"><span id="70f8" class="ko kp hu mc b fv nn no l np nq">ID: 01CMFXT9D3R2M0250ZJ0000004<br/>App Id: 01CMFXG599R2M0250ZJ0000001<br/>Route: /logtest<br/>Created At: 2018-08-09T11:05:11.459-07:00<br/>Started At: 2018-08-09T11:05:11.992-07:00<br/>Completed At: 2018-08-09T11:05:11.996-07:00<br/>Status: success</span><span id="fd86" class="ko kp hu mc b fv nr no l np nq">ID: 01CMFXK7KPR2M0250ZJ0000002<br/>App Id: 01CMFXG599R2M0250ZJ0000001<br/>Route: /logtest<br/>Created At: 2018-08-09T11:01:20.246-07:00<br/>Started At: 2018-08-09T11:01:20.776-07:00<br/>Completed At: 2018-08-09T11:01:20.794-07:00<br/>Status: success</span></pre><blockquote class="ns nt nu"><p id="9a13" class="jh ji nv jj b jk jl jm jn jo jp jq jr nw jt ju jv nx jx jy jz ny kb kc kd ke hn dt translated"><strong class="jj hv">注意</strong>:您的函数可能会被调用很多次——您可以通过指定<code class="eh lz ma mb mc b">--from-time</code>或<code class="eh lz ma mb mc b">--to-time</code>选项，或者通过函数路径(<code class="eh lz ma mb mc b">--path</code>)或返回的调用次数(<code class="eh lz ma mb mc b">-n</code>)来过滤调用，从而轻松过滤出您想要的调用</p></blockquote><p id="8030" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们获取其中一个呼叫id并获取其日志:</p><pre class="nf ng nh ni fq nj mc nk nl aw nm dt"><span id="2bf9" class="ko kp hu mc b fv nn no l np nq">$ fn get logs logtest 01CMFXK7KPR2M0250ZJ0000002<br/>2018/08/09 18:01:20 Hello MyHandler<br/>2018/08/09 18:01:20 Goodbye MyHandler</span></pre><p id="a9e8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">耶——我们得到了我们的日志！这一切都很好，但是对于数百个函数和跨越所有函数的成千上万个调用，没有人能够手动做到这一点。如果我们能在某个中心地方收集所有这些日志，那就方便多了。</p><h1 id="ae25" class="mk kp hu bd kq ml nz mn ku mo oa mq ky mr ob mt lb mu oc mw le mx od mz lh na dt translated">收集日志</h1><p id="73a4" class="pw-post-body-paragraph jh ji hu jj b jk ll jm jn jo lm jq jr js nb ju jv jw nc jy jz ka nd kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di">我</span>已经决定尝试<a class="ae jg" href="https://papertrail.com" rel="noopener ugc nofollow" target="_blank"> Papertrail </a>，看看如何将它与Fn连接起来，将我所有的功能日志发送到那里。</p><p id="c21a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我已经在他们的网站上注册了，并快速完成了日志设置，以获得可以向其发送日志的端点——类似于<code class="eh lz ma mb mc b">logsXYZ.papertrail.com:12345</code>。有了这个URL，我可以配置我的应用程序，并告诉它我希望所有的日志都转到这个URL。</p><p id="858c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为此我们。需要在app上这样设置<code class="eh lz ma mb mc b">syslog-url</code>设置:</p><pre class="nf ng nh ni fq nj mc nk nl aw nm dt"><span id="34b7" class="ko kp hu mc b fv nn no l np nq">$ fn update app logtest --syslog-url=tls://[papertrail-endpoint]<br/>app logtest update</span></pre><p id="655f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">用和前面一样的方法测试它——通过对函数进行几次调用。函数的输出仍然是相同的，如果我们检查调用日志，我们仍然应该看到与以前相同的日志。</p><p id="04d3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，我们也会在Papertrail中获得相同的日志，如下所示:</p><figure class="nf ng nh ni fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oe"><img src="../Images/a7d04bbd64ff826ce32412f49fdf4f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28Gf_XkLlXkFbZHnTJTVcQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Logs being sent to Papertrail</figcaption></figure><p id="70a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">中央日志收集系统的好处是，它让您能够保留日志，搜索它们，甚至设置警报，如果你想。此外，您还可以通过应用程序名称或ID或功能或调用名称来过滤日志。这样，诊断发生了什么和哪里出了问题就变得容易多了。</p><h1 id="6231" class="mk kp hu bd kq ml nz mn ku mo oa mq ky mr ob mt lb mu oc mw le mx od mz lh na dt translated">结论</h1><p id="cd78" class="pw-post-body-paragraph jh ji hu jj b jk ll jm jn jo lm jq jr js nb ju jv jw nc jy jz ka nd kc kd ke hn dt kf translated"><span class="l kg kh ki bm kj kk kl km kn di">在</span>这篇短文中，我们创建了一个样板文件<a class="ae jg" href="https://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn </a>函数，并将我们的应用配置为自动将所有日志发送到云日志收集系统(在我们的例子中，我们使用了<a class="ae jg" href="https://papertrail.com" rel="noopener ugc nofollow" target="_blank"> Papertrail </a>，但是您也可以使用任何其他提供者)。</p><h1 id="2381" class="mk kp hu bd kq ml nz mn ku mo oa mq ky mr ob mt lb mu oc mw le mx od mz lh na dt translated">感谢阅读！</h1><p id="2b63" class="pw-post-body-paragraph jh ji hu jj b jk ll jm jn jo lm jq jr js nb ju jv jw nc jy jz ka nd kc kd ke hn dt kf translated">非常欢迎对本文的任何反馈！你也可以在<a class="ae jg" href="http://twitter.com/pjausovec" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae jg" href="http://github.com/peterj" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。如果你喜欢这个并且想在我写更多东西的时候得到通知，你应该订阅<a class="ae jg" href="https://tinyletter.com/pjausovec" rel="noopener ugc nofollow" target="_blank">我的时事通讯</a>！</p></div></div>    
</body>
</html>