<html>
<head>
<title>Escaping Sandbox Using Callbacks on iOS 11.4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS 11.4上使用回调逃离沙盒</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/escaping-sandbox-using-callbacks-on-ios-11-4-73fb1b818f35?source=collection_archive---------7-----------------------#2018-08-10">https://medium.com/hackernoon/escaping-sandbox-using-callbacks-on-ios-11-4-73fb1b818f35?source=collection_archive---------7-----------------------#2018-08-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4ac3" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated"><em class="jj">阿里巴巴技术团队的操作系统越狱内幕</em></h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/93381c5eeb61396102db13391b745cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZXxuOoo3_NPXYLJigaK4A.jpeg"/></div></div></figure><p id="ac9a" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt">(Article by Zheng Min郑旻 and Bai Xiaolong白小龙 from the <strong class="jy hv">Alibaba Security Lab</strong>)</p><h1 id="da7b" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">沙箱</h1><p id="9406" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">苹果的沙盒在macOS 10.5中被称为“安全带”，这是MACF政策的第一次全面实施。苹果在macOS上试用成功后，将沙盒机制应用到了iOS 6上。在实施过程中，该政策与数十项业务挂钩。当新的系统调用或新发现的威胁出现时，挂钩的数量一直在稳步增长。下表显示了不同XNU版本中沙盒的挂钩计数:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/30af8b9ca0817407269ac52531663e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*-n23yKXUOSTl3spCZg6TRA.png"/></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">From *OS internals</figcaption></figure><p id="4738" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">最初，苹果的沙盒使用黑名单方法，这意味着苹果最初集中于已知的危险API并阻止它们，默认情况下允许所有其他API。然而，随着苹果沙盒的发展，它采用了白名单方法，拒绝所有API，只允许苹果信任的安全API。</p><p id="9898" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">在macOS中，描述文件是可见的，并储存在/System/Library/Sandbox/Profiles中。在iOS中，概要文件被硬编译到/usr/libexec/sandboxd中。我们很难解码沙盒配置文件，但我们可以遍历所有Mach服务，根据返回值获得mach-lookup列表(例如，通过JL的sbtool)。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/fd40bc1a4759700411dd7cbe5b9e8ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*vuxpKCKdBmTIrgneXEmEZQ.png"/></div></figure><p id="ff23" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">为了发现漏洞，我们需要分解和分析包含相关Mach服务的处理函数的二进制文件。幸运的是，/System/Library/LaunchDaemons包含了大多数Mach服务的配置列表。在plist文件中，“ProgramArguments”显示二进制文件的路径，“MachServices”显示相关的Mach服务。因此，通过将LaunchDaemons plist文件与mach-lookup列表相结合，我们可以获得所有可以在沙箱内部访问的mach服务和相关二进制文件。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/0315144402f4d0545357906d9b96df61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*c0SbZBJ32sbv6uv8PaNhEw.png"/></div></figure><h1 id="6125" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">iOS IPC:马赫、XPC和NSXPC</h1><p id="f095" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">iOS上有一组丰富的IPC机制(例如URL方案、Mach、管道),其中大多数可供第三方应用程序使用。在本文中，我们主要关注Mach IPC，它提供了一个面向消息和基于能力的IPC工具。Mach IPC代表了其前身(即Accent和RIG)使用的类似方法的演变。Mach的低级IPC实现利用VM子系统，在写入时复制优化的帮助下高效地传输大量数据。此外，Mach消息包含类型化数据，其中可能包含端口权限和对大内存区域的引用。</p><p id="4fba" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">基于Mach message，Apple开发了XPC，这是一个轻量级机制，用于集成GCD和launchd的基本进程间通信。与原始马赫消息相比，XPC更安全，更易于使用。但是，XPC服务维护的成本很高。NSXPC消息建立在XPC消息的基础上，允许抽象XPC连接和远程对象。通过马赫消息、XPC消息和NSXPC消息，沙盒应用可以与未沙盒的马赫服务、XPC服务和NSXPC服务进行通信。因此，如果服务没有以预期的方式处理消息，它们可能会被沙盒应用程序损坏。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/0e7bc85ad5af591a727f94841fa5a498.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*LdgbkmiCXcKCYWNzpbBEwQ.png"/></div></figure><h1 id="9b33" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">从老虫子到0天虫子</h1><p id="68ca" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">在iOS 11.2.5中，苹果修复了bluetooth d(CVE-2018–4087作者@raniXCH)中的一个会话劫持漏洞。bluetoothd的“com . apple . server . bluetooth”Mach服务中有132个功能。并且漏洞存在于BTLocalDeviceAddCallbacks()函数中。沙盒应用可以使用BTSessionAttach为bluetoothd创建一个session_token，然后使用BTLocalDeviceAddCallbacks()为事件通知注册一个回调。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/580aae267afb200e1ab46c637b542279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*-SyQl1gtYVFq8gX96juJhQ.png"/></div></figure><p id="9f76" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">然而，Bluetoothd仅使用会话令牌来识别进程，这意味着我们可以使用沙盒应用程序通过会话令牌劫持bluetoothd和未沙盒进程之间的通信，然后控制未沙盒进程的PC指针。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ly"><img src="../Images/379f2c86f014afb986dc1e0f45227142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdn6FRPf4uAHvM3EvzzPWg.png"/></div></div></figure><p id="2d81" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">此外，会话令牌太容易被暴力破解，因为它只有0x10000 (0x0000 -0xFFFF)个可能值。在iOS 11.2.5中，苹果通过在每个会话中添加一个user_id (=arc4random())修复了这个问题。只有进程知道user_id，bluetoothd将使用user_id检查ses_token的映射。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/f41794cf381410bed4e65d3cd2ca5640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*Cnx52nIInkzRrgXJQ3grew.png"/></div></figure><p id="2f19" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">然而，在分析了其他函数后，我们发现了两个新的零日bug。第一个bug存在于BTAccessoryManagerAddCallbacks()中。与BTLocalDeviceAddCallbacks()相同，BTAccessoryManagerAddCallbacks()将为BTAccessoryManger注册一个回调，但攻击者不需要提供user_id。但是，只有当iOS设备连接到新设备时，才能触发回调事件。这意味着我们需要手动点击设置中的蓝牙设备来触发回调事件。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/68caf1bce2841fa544cf43db2c7632b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*z68A01xpPo5qnkNIytkoMA.png"/></div></figure><p id="9620" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">幸运的是，我们发现了蓝牙发现代理中存在的另一个bug。沙盒应用程序可以使用BTDiscoveryAgentCreate()为其他进程创建发现代理回调，然后使用BTDiscoveryAgentStartScan()触发回调事件，而无需手动单击。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mb"><img src="../Images/807d66f3d7922ec1e681f2e322338ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCGGQCIPohZWMdYXk-6C7g.png"/></div></div></figure><p id="b002" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated"><strong class="jy hv"> <em class="mc">更新:6月7日向苹果报告了这两个“零日”漏洞，苹果在iOS 11.4.1以及CVE-2018–4330和CVE-2018–4327的iOS 12 beta中修复了它们。请将您的iOS更新到最新的iOS 11.4.1，以防御潜在的攻击。</em>T3】</strong></p><h1 id="36c6" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">从PC控制到ROP</h1><p id="5994" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">我们利用的目标是不仅控制PC指针，而且控制整个过程。所以我们需要创建一个ROP链，为目标进程做一个堆喷。在这种情况下，我们使用MACH_MSGH_BITS_COMPLEX Mach msg和MACH_MSG_OOL_DESCRIPTOR内存来进行堆喷射。如果我们向目标进程发送这种消息，而没有收到消息，ROP链将持久地停留在目标的内存空间中。此外，我们可以使用一个神奇的地址(0x105400000)来设置回调地址，以便PC跳转。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff md"><img src="../Images/e9c3ba24411fd43a5a272c33ff5f5c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*nUvYByVuXtJlLnVhMo1Mtw.png"/></div></figure><p id="46fa" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">为了方便地控制程序流程，我们需要控制堆栈寄存器。因此，我们需要找到一个小工具来做堆栈透视。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff me"><img src="../Images/b27f892cdb0a32f639269dcc0302f843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o288cTItTNK5oT7NW4to5Q.png"/></div></div></figure><p id="1252" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">可以在libsystem_platform.dylib找到一个很棒的stack pivot小工具，通过使用这个小工具，我们可以通过X0寄存器来控制SP寄存器。之后，我们可以设置X30寄存器，然后使用“ret”小工具来执行任意的ROP链。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mf"><img src="../Images/1a041998283facc5b131c0249c89ea3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPgCGWLayZcNaMG0s4-ZkQ.png"/></div></div></figure><h1 id="27fd" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">从ROP到任务端口</h1><p id="e1ef" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">在iOS/macOS中，端口为IPC提供端点。消息可以发送到端口或从端口接收。此外，端口可以包含权限，并且端口权限可以在消息中传递。一个进程最重要的端口是它的任务端口，可以通过mach_task_self()获得。你可以通过任务端口控制一个进程的内存和所有寄存器。例如，mach _ VM _ allocate(target _ task _ port，&amp;remote_addr，remote_size，1)可用于在远程进程中分配内存，mach_vm_write(target_task_port，remote_address，local_address，length)可用于将数据复制到远程进程中。因此，如果我们能够获得一个进程的任务端口，就可以很容易地通过Mach msg控制整个进程。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/5c213bb31e818f8d38765b5d4d8c931b.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*Lt4lbw2D25eV9YBHpeuAbA.png"/></div></figure><p id="9843" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">从Mach_portal学到的一些技巧:一种用户态利用技术是在远程进程中执行ROP，并将远程进程的任务端口发回攻击app。首先，我们使用mach_port_allocate()在攻击应用程序中分配0x1000个端口，然后使用mach_port_insert_right()向这些端口插入一个发送权限。之后，我们可以通过MACH_MSG_PORT_DESCRIPTOR类型的OOL Mach消息将这些端口发送给远程进程。下一步是进行堆喷射，以便将ROP链发送到远程进程，然后使用bluetoothd bug来控制PC。为了通过ROP链将任务端口发送回我们的攻击app，我们需要知道我们的攻击app的端口号。然而，我们不能使用launchd来帮助我们。幸运的是，端口号可以靠蛮力猜出来(0x103+0x100*N)。这就是为什么我们给远程进程发送0x1000个端口(为了增加成功率)，用ROP链调用mach_msg() 0x100次来猜测端口号。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mh"><img src="../Images/2eeb73c77c52a28be670a22ce2b7d044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*jw1euy5MlxDYHeYr-soiig.png"/></div></div></figure><p id="4fe9" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">得到unsandboxed进程的任务端口后，我们就可以完全控制它了。然而，iOS 11(不在macOS10.13中)将限制扩展到沙盒应用程序进程的所有任务端口的使用，我们无法使用之前的方法获得任务端口:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/dc963d619f0ffc2d34f3d4f5353886ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*SBl0sbKXogeskrIvJ4UlYQ.png"/></div></figure><h1 id="477d" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">B计划</h1><p id="9291" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">即使我们不能获得任务端口，我们仍然可以使用ROP。可以在CoreFoundation中找到用于带有任意参数的函数调用的通用原语:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mj"><img src="../Images/0840af4d4a4e277cfbf2f5321414fa02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMBswEMd7M0a9hPZMzw20Q.png"/></div></div></figure><p id="4858" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">通过使用这些ROP小工具，我们可以控制未打包的系统服务，并通过更多的攻击面进一步攻击内核。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mk"><img src="../Images/b074fe5ef32252f0410b49d7ce08883d.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*UxT3Lo2qlLcwvTiM4IVqGA.png"/></div></div></figure><h1 id="39e5" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated"><strong class="ak">参考文献</strong></h1><p id="1bfc" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">1.MacOS和*OS内部【http://newosxbook.com/ T2</p><p id="bc42" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">2.盘古9内件<a class="ae ml" href="https://www.blackhat.com/docs/us-16/materials/us-16-Wang-Pangu-9-Internals.pdf" rel="noopener ugc nofollow" target="_blank">https://www . black hat . com/docs/us-16/materials/us-16-Wang-Pangu-9-Internals . pdf</a></p><p id="1945" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">3.三重_获取<a class="ae ml" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1247" rel="noopener ugc nofollow" target="_blank">https://bugs.chromium.org/p/project-zero/issues/detail?id=1247 </a></p><p id="6f3c" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">4.<a class="ae ml" href="https://blog.zimperium.com/cve-2018-4087-poc-escaping-sandbox-misleading-bluetoothd/" rel="noopener ugc nofollow" target="_blank">https://blog . zimperium . com/CVE-2018-4087-POC-逃避-沙盒-误导-蓝牙d/ </a></p><p id="1791" class="pw-post-body-paragraph jw jx hu jy b jz ka iv kb kc kd iy ke kf kg kh ki kj kk kl km kn ko kp kq kr hn dt translated">5.马赫门户<a class="ae ml" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=965" rel="noopener ugc nofollow" target="_blank">https://bugs.chromium.org/p/project-zero/issues/detail?id=965 </a></p><h1 id="2f41" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">更新</h1><p id="338a" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated"><strong class="jy hv"> <em class="mc">这两个“零日”bug在6月7日被报告给了苹果，苹果在iOS 11.4.1以及iOS 12 beta中修复了它们，CVE-2018–4330和CVE-2018–4327。请将您的iOS更新到最新的iOS 11.4.1，以防御潜在的攻击。</em>T15】</strong></p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h1 id="6367" class="ks kt hu bd ku kv mt kx ky kz mu lb lc ja mv jb le jd mw je lg jg mx jh li lj dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph jw jx hu jy b jz lk iv kb kc ll iy ke kf lm kh ki kj ln kl km kn lo kp kq kr hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae ml" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="jy hv">《阿里巴巴技术》</strong> </a>。推特:<a class="ae ml" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"><strong class="jy hv">【AlibabaTech】</strong></a>。</p></div></div>    
</body>
</html>