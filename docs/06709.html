<html>
<head>
<title>Testing Redux Sagas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Redux传奇</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-redux-sagas-c64dbba05935?source=collection_archive---------9-----------------------#2018-08-10">https://medium.com/hackernoon/testing-redux-sagas-c64dbba05935?source=collection_archive---------9-----------------------#2018-08-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a025" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管我很想从这篇文章中获得荣誉，但这篇文章大部分是由约翰·皮普金写的。它真的很好，对我帮助很大，我想和全世界分享它。</p><p id="c85e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jr" rel="noopener" href="/@johnpipkin_79120/conceptualizing-unit-tests-with-redux-sagas-71c49fd8b08f?source=linkShare-1ef30430402c-1533944212">点击这里阅读他的完整文章</a></p></div><div class="ab cl js jt hc ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hn ho hp hq hr"><p id="6c0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以测试生成器时，最好把它们想象成一个循环，当你让它们执行时，它们就会执行。</p><h1 id="16a2" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第一步</h1><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="a0e2" class="lg ka hu lc b fv lh li l lj lk">it(‘should return 6’, () =&gt; {<br/> // we’ve set up the generator, but we haven’t called next yet so we’re not at a yield<br/> const gen = count()</span><span id="0306" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next().value).toEqual(call(addNumber, number, 1))</span><span id="2469" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(1).value).toEqual(call(addNumber, number, 2))</span><span id="1f66" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(3).value).toEqual(call(addNumber, number, 3))</span><span id="e687" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(6).value).toEqual(put(something(6)))<br/>})</span><span id="7d92" class="lg ka hu lc b fv ll li l lj lk">function *count() {<br/> -&gt; // We haven’t told the generator to exicute anything yet so we’re not at a yield<br/> let number = 0</span><span id="73d6" class="lg ka hu lc b fv ll li l lj lk">number = yield call(addNumber, number, 1)<br/> number = yield call(addNumber, number, 2) //3<br/> number = yield call(addNumber, number, 3) //6<br/> yield.put(something(number))<br/>}</span></pre><p id="e42e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一步中，我们还没有告诉生成器做任何事情，所以我们没有要测试的东西。</p><h1 id="4b0e" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第二步</h1><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="47b9" class="lg ka hu lc b fv lh li l lj lk">it(‘should return 6’, () =&gt; {<br/> const gen = count()</span><span id="cb7f" class="lg ka hu lc b fv ll li l lj lk">// This next is called, we’re seeing what the yield will be<br/> expect(gen.next().value).toEqual(call(addNumber, number, 1))</span><span id="0846" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(1).value).toEqual(call(addNumber, number,2))</span><span id="a312" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(3).value).toEqual(call(addNumber, number, 3))</span><span id="f128" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(6).value).toEqual(put(something(6)))<br/>})</span><span id="060a" class="lg ka hu lc b fv ll li l lj lk">function *count() {<br/> let number = 0</span><span id="2497" class="lg ka hu lc b fv ll li l lj lk">// Generator is paused here, waiting. The yield call(addNumber, number, 1) hasn’t executed<br/> -&gt; number = yield call(addNumber, number, 1)<br/> number = yield call(addNumber, number, 2) //3<br/> number = yield call(addNumber, number, 3) //6<br/> yield.put(something(number))<br/>}</span></pre><p id="5578" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们已经执行了<code class="eh lm ln lo lc b">gen.next()</code>。我们已经告诉生成器使用收益声明并等待。所以现在我们在<code class="eh lm ln lo lc b">-&gt;</code>暂停了，但是我们并没有真正运行代码。</p><p id="a2e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们在这里得到<code class="eh lm ln lo lc b">gen.next().value</code>时，我们只是得到收益率会做什么。</p><h1 id="d72c" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第三步</h1><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="35a6" class="lg ka hu lc b fv lh li l lj lk">it(‘should return 6’, () =&gt; {<br/> const gen = count()</span><span id="45cc" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next().value).toEqual(call(addNumber, number, 1))</span><span id="003a" class="lg ka hu lc b fv ll li l lj lk">// called next here, this evaluated the previous line. We pass in the return value from the last line<br/> expect(gen.next(1).value).toEqual(call(addNumber, number, 2))</span><span id="aac8" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(3).value).toEqual(call(addNumber, number, 3))</span><span id="99ee" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(6).value).toEqual(put(something(6)))<br/>})</span><span id="cf06" class="lg ka hu lc b fv ll li l lj lk">function *count() {<br/> let number = 0</span><span id="a307" class="lg ka hu lc b fv ll li l lj lk">number = yield call(addNumber, number, 1)<br/> // We evaluated the previous line, now were waiting at the this yield<br/> -&gt; number = yield call(addNumber, number, 2) <br/> number = yield call(addNumber, number, 3) //6<br/> yield.put(something(number))<br/>}</span></pre><p id="a6ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们又调用了<code class="eh lm ln lo lc b">gen.next()</code>。生成器看到该命令，并执行其暂停处的yield，然后继续下一个“yield”语句。它将在这里暂停<code class="eh lm ln lo lc b">-&gt;</code>。<code class="eh lm ln lo lc b">gen.next()</code>告诉yield语句它正在执行，我们可以把我们想要的从那里返回的内容传递给调用<br/>我们在<code class="eh lm ln lo lc b">yield call(addNumber, number, 1)</code>暂停，我们想要它返回<code class="eh lm ln lo lc b">1</code>，所以当我们实际执行那一行时，我们把它传递进去。</p><h1 id="0394" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第四步</h1><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="1037" class="lg ka hu lc b fv lh li l lj lk">it(‘should return 6’, () =&gt; {<br/> const gen = count()</span><span id="e219" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next().value).toEqual(call(addNumber, number,1))</span><span id="04e1" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(1).value).toEqual(call(addNumber, number, 2))</span><span id="2116" class="lg ka hu lc b fv ll li l lj lk">// Called next again, we evaluated the call to (number, 2) and specifiy its return value in this next<br/> expect(gen.next(3).value).toEqual(call(addNumber, number, 3))</span><span id="4823" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(6).value).toEqual(put(something(6)))<br/>})</span><span id="c2a5" class="lg ka hu lc b fv ll li l lj lk">function *count() {<br/> let number = 0</span><span id="af09" class="lg ka hu lc b fv ll li l lj lk">number = yield call(addNumber, number, 1)<br/> number = yield call(addNumber, number, 2) //3<br/> -&gt; number = yield call(addNumber, number,3) //6<br/> yield.put(something(number))<br/>}</span></pre><p id="4fc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一步和上一步一样，只是为了说明我在说什么。对<code class="eh lm ln lo lc b">call(addNumber, number, 2)</code>的让步应该返回<code class="eh lm ln lo lc b">3</code>，所以我们把它传递给对<code class="eh lm ln lo lc b">gen.next(3)</code>的调用，因为我们已经告诉生成器执行那行代码，我们希望它返回<code class="eh lm ln lo lc b">3</code>。</p><h1 id="638a" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第五步</h1><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="4abb" class="lg ka hu lc b fv lh li l lj lk">it(‘should return 6’, () =&gt; {<br/> const gen = count()</span><span id="ff30" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next().value).toEqual(call(addNumber, number, 1))</span><span id="b8f2" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(1).value).toEqual(call(addNumber, number, 2))</span><span id="a4d4" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(3).value).toEqual(call(addNumber, number, 3))</span><span id="53f9" class="lg ka hu lc b fv ll li l lj lk">// Called next again, we evaluated the call to (number, 3) and specifiy its return value in this next.<br/> // I’ve intentionally returned the wrong value from the call to (addNumber, number, 3) to illustrate how the return in next works<br/> expect(gen.next(8).value).toEqual(put(something(8)))<br/>})</span><span id="491b" class="lg ka hu lc b fv ll li l lj lk">function *count() {<br/> let number = 0</span><span id="9056" class="lg ka hu lc b fv ll li l lj lk">number = yield call(addNumber, number, 1)<br/> number = yield call(addNumber, number, 2) //3<br/> number = yield call(addNumber, number, 3) //6<br/> -&gt; yield.put(something(number))<br/>}</span></pre><p id="7b06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们再次调用了<code class="eh lm ln lo lc b">gen.next()</code>,所以现在我们在等待卖出。在这个例子中，你可以看到我故意在<code class="eh lm ln lo lc b">gen.next()</code>中返回了错误的值‘8’。这是为了说明next接受前一次执行的返回值。这种情况下基本上是模拟数据。现在我们看到我们暂停的收益率是<code class="eh lm ln lo lc b">put(number)</code>。因为本例中的<code class="eh lm ln lo lc b">number</code>是<code class="eh lm ln lo lc b">8</code>(因为那是我们告诉<code class="eh lm ln lo lc b">call(addNumber, number, 3)</code>要返回的，那就是我们要找的。</p><h1 id="1fee" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第六步</h1><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="d167" class="lg ka hu lc b fv lh li l lj lk">it(‘should return 6’, () =&gt; {<br/> const gen = count()</span><span id="31a2" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next().value).toEqual(call(addNumber, number, 1))</span><span id="f9d3" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(1).value).toEqual(call(addNumber, number, 2))</span><span id="b2ae" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(3).value).toEqual(call(addNumber, number, 3))</span><span id="f883" class="lg ka hu lc b fv ll li l lj lk">expect(gen.next(8).value).toEqual(put(something(8)))</span><span id="0c24" class="lg ka hu lc b fv ll li l lj lk">// Finally call next again to see there are no more yields<br/> expect(gen.next().done).toBeTruthy()<br/>})</span><span id="51ed" class="lg ka hu lc b fv ll li l lj lk">function *count() {<br/> let number = 0</span><span id="7f04" class="lg ka hu lc b fv ll li l lj lk">number = yield call(addNumber, number, 1)<br/> number = yield call(addNumber, number, 2) //3<br/> number = yield call(addNumber, number, 3) //6<br/> yield.put(something(number))<br/> -&gt;<br/>}</span></pre><p id="88e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们再次调用<code class="eh lm ln lo lc b">gen.next()</code>。既然没有更多的收益需要等待，我们可以看到传奇已经结束。</p></div></div>    
</body>
</html>