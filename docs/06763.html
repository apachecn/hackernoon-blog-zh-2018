<html>
<head>
<title>Face recognition with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go进行人脸识别</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/face-recognition-with-go-676a555b8a7e?source=collection_archive---------3-----------------------#2018-08-12">https://medium.com/hackernoon/face-recognition-with-go-676a555b8a7e?source=collection_archive---------3-----------------------#2018-08-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5aff8779a2a807f4c05cfe2d64fe3534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhP1cpR3Un6BMonp4-RPYw.png"/></div></div></figure><p id="ab3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">本文讲述了围棋语言</em> <a class="ae kb" href="https://github.com/Kagami/go-face" rel="noopener ugc nofollow" target="_blank"> <em class="ka">人脸识别库</em> </a> <em class="ka">的创建和使用过程。</em></p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="b94b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">神经网络今天非常流行，人们用它们来完成各种任务。一个特别有用的设备是人脸识别。</p><p id="765c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近，我意识到我的爱好项目，一个带有Go后端的论坛软件，将受益于人脸识别功能。如果有一种方法可以识别上传照片上的人(流行歌手)，让新人不需要问照片上的人是谁，那就太好了。这听起来是个好主意，所以我决定试一试。</p><p id="d4d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有一点需要注意的是，我试图保持该软件的系统要求非常低，这样更多的人可以使用便宜的服务器安装它。这就是为什么实现不能用CUDA或者要求GPU的原因。虽然今天你可以很容易地租到这样的服务器，但价格会更高，从而降低了潜在的听觉。如果它能只在CPU上工作就更好了，最好没有外来的依赖。</p><h2 id="4f70" class="kj kk hu bd kl km kn ko kp kq kr ks kt jn ku kv kw jr kx ky kz jv la lb lc ld dt translated">选择语言</h2><p id="81f8" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">如果你问数据科学家或参与神经网络实践经验的人，几乎所有人都会推荐你使用Python语言来解决机器学习任务。这绝对是一个明智的选择，因为社区、可用的库数量、语言的简单性等等。不用说，你可以很容易地找到非常流行的Python人脸识别库，里面有很好的例子和文档。</p><p id="c2f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，我还是决定选择Go，原因有几个:</p><ul class=""><li id="6e9e" class="lj lk hu je b jf jg jj jk jn ll jr lm jv ln jz lo lp lq lr dt translated">我的论坛是用Go写的，我真的很喜欢单二进制后端的便利，所以如果能将人脸识别例程与后端的其余部分简单集成就好了，而不是实现一些IPC和需要Python依赖。</li><li id="d7db" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">Go通常比Python更快，更重要的是消耗更少的内存。当然，任何高性能Python库的关键部分都是用C/C++编写的，但无论如何，你都会有Python VM的开销。如果我们在谈论主机，你总是可以租一台内存更大的机器，但是我更喜欢更快的语言，除非它会严重影响开发时间。我不会使用C或C++作为我编写web应用程序的主要语言，但是Go很好，几乎和Python一样简单。</li><li id="3ab6" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">我还没有为Go找到人脸识别库，所以写一个既有趣又对社区有帮助。</li></ul><h2 id="bc8d" class="kj kk hu bd kl km kn ko kp kq kr ks kt jn ku kv kw jr kx ky kz jv la lb lc ld dt translated">选择框架</h2><p id="c61d" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">如前所述，神经网络以及实现它们的框架非常普遍。只有在计算机视觉中你才有Caffe，Torch，TensorFlow等。</p><p id="bc8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是有一个特别酷的图书馆<a class="ae kb" href="http://dlib.net" rel="noopener ugc nofollow" target="_blank"> dlib </a>几乎立刻吸引了我的注意。首先，它是用C++编写的，所以你可以很容易地用cgo创建Go绑定。第二，它<a class="ae kb" href="http://blog.dlib.net/2017/02/high-quality-face-recognition-with-deep.html" rel="noopener ugc nofollow" target="_blank">声称</a>在野生基准测试中对标记的人脸有99.38%的准确率，这听起来相当令人印象深刻。第三，流行的人脸识别库，如<a class="ae kb" href="https://github.com/ageitgey/face_recognition" rel="noopener ugc nofollow" target="_blank"> face_recognition </a>和<a class="ae kb" href="https://github.com/cmusatyalab/openface" rel="noopener ugc nofollow" target="_blank"> openface </a>在底层使用dlib，因此它看起来是一个非常好的选择。</p><h2 id="22dd" class="kj kk hu bd kl km kn ko kp kq kr ks kt jn ku kv kw jr kx ky kz jv la lb lc ld dt translated">安装依赖项</h2><p id="07e9" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">选择了框架，但是我们如何在开发和生产机器上使用它呢？C++依赖项可能很难安装，你不能使用方便的“go get”或“pip install”命令。要么它在你的操作系统的库中提供，要么期待一个乏味的编译过程。如果你是库的所有者，并要求你的用户自己编译软件，这个问题会更加严重。例如<a class="ae kb" href="https://gist.github.com/ageitgey/629d75c1baac34dfa5ca2a1928a7aeaf" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以看到有多少真实的人遇到了dlib编译的问题。</p><p id="c15d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，有更好的选择:如果用户的目标系统是已知的，我们可以构建dlib的二进制包，这将大大简化安装。既然我们在谈论服务器软件，Ubuntu几乎是这里的标准，所以你真的想首先支持它。</p><p id="eef9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Ubuntu的标准回购中有dlib，但版本太旧了:人脸识别支持仅在dlib 19.3中添加。所以我们需要构建自己的包。我为Ubuntu 16.04和18.04创建了<a class="ae kb" href="https://launchpad.net/~kagamih/+archive/ubuntu/dlib" rel="noopener ugc nofollow" target="_blank"> PPA </a>(自定义库)，这是两个最新的LTS版本。安装非常简单:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="457c" class="kj kk hu mc b fv mg mh l mi mj">sudo add-apt-repository ppa:kagamih/dlib<br/>sudo apt-get update<br/>sudo apt-get install libdlib-dev</span></pre><p id="7274" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它将安装最新的dlib(目前为19.15)和英特尔的数学内核库，这似乎是标准BLAS和LAPACK接口的最快实现，至少对于英特尔处理器来说是如此。</p><p id="4c56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于Debian sid和Ubuntu 18.10(尚未发布)来说是个好消息，相当新鲜的dlib在标准回购中可用。你只需要:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d68e" class="kj kk hu mc b fv mg mh l mi mj">sudo apt-get install libdlib-dev libopenblas-dev</span></pre><p id="5e00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将使用OpenBLAS实现，而不是MKL，它也非常快。或者你可以<a class="ae kb" href="https://serverfault.com/a/240921" rel="noopener ugc nofollow" target="_blank">启用非自由软件包</a>并安装<code class="eh mk ml mm mc b">libmkl-dev</code>来代替。</p><p id="b74d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还需要libjpeg来加载jpeg图像，在Ubuntu上安装<code class="eh mk ml mm mc b">libjpeg-turbo8-dev</code>包，在Debian上安装<code class="eh mk ml mm mc b">libjpeg62-turbo-dev</code>(不要问我为什么名字如此不同)。</p><p id="25a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我没有其他系统的说明，所以<a class="ae kb" href="https://github.com/Kagami/go-face/issues" rel="noopener ugc nofollow" target="_blank">让我知道</a>如果你有获得dlib的问题。至少为最受欢迎的食谱提供简短而精确的食谱是很有意义的。</p><p id="e4a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我正在考虑也为dlib提供Docker镜像(已经存在的很少)，许多具有复杂依赖关系的项目倾向于使用这种分发方法。但在我看来，原生包总是能提供更好的用户体验。您不需要在控制台中编写长命令或处理沙盒环境，一切都像以前一样工作。</p><h2 id="cc30" class="kj kk hu bd kl km kn ko kp kq kr ks kt jn ku kv kw jr kx ky kz jv la lb lc ld dt translated">编写库</h2><p id="19d3" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">现代人脸识别库的工作原理是为照片上的每张脸返回一组数字(向量嵌入或描述符)，这样你就可以将它们相互比较，并通过比较这些数字找到所传图像上的人的名字(通常通过向量之间的<a class="ae kb" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>，距离最小的两张脸应该属于同一个人)。这个概念已经在其他文章中描述过了，所以我在这里不再赘述。</p><p id="f6a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从传过来的图像中创建面部描述符的基本代码很简单，它非常符合<a class="ae kb" href="https://github.com/davisking/dlib/blob/v19.15/examples/dnn_face_recognition_ex.cpp" rel="noopener ugc nofollow" target="_blank">官方示例</a>。查看<a class="ae kb" href="https://github.com/Kagami/go-face/blob/ex/facerec.cc" rel="noopener ugc nofollow" target="_blank"> facerec.cc </a>。对应的头文件<a class="ae kb" href="https://github.com/Kagami/go-face/blob/ex/facerec.h" rel="noopener ugc nofollow" target="_blank"> facerec.h </a>定义了Go和dlib之间交互的5个函数和几个结构。</p><p id="56c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我和dlib讨论了一件不幸的事情。虽然它支持所有流行的图像格式，但它只能从文件中加载它们。这可能是非常令人困惑限制，因为您通常只将图像数据保存在内存中，而将它写入临时文件则是一团乱麻。所以我不得不使用libjpeg编写自己的<a class="ae kb" href="https://github.com/Kagami/go-face/blob/ex/jpeg_mem_loader.cc" rel="noopener ugc nofollow" target="_blank">图像加载器</a>。因为大多数照片都是以这种格式存储的，所以现在应该足够了，以后可能会添加其他格式。</p><p id="fdee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae kb" href="https://github.com/Kagami/go-face/blob/ex/face.go" rel="noopener ugc nofollow" target="_blank"> face.go </a>中放置了一个连接C++和Go的微小粘合层。它提供了<code class="eh mk ml mm mc b">Face</code>结构，用于保存图像上人脸的坐标及其描述符。和实际识别等所有操作的<code class="eh mk ml mm mc b">Recognizer</code>接口。</p><p id="7378" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们有了描述符，我们该做什么？如前所述，在最简单的情况下，您可以比较未知描述符和所有已知描述符之间的欧几里德距离。它并不完美，就目前的技术水平而言，有时你会得到错误的答案。如果我们想改善一点结果，我们会为每个人使用许多图像，并检查是否至少有几个非常接近提供的脸。</p><p id="ffbf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正是<a class="ae kb" href="https://github.com/Kagami/go-face/blob/ex/classify.cc" rel="noopener ugc nofollow" target="_blank"> classify.cc </a>所做的。首先，它计算距离，然后对它们进行排序，然后计算同一个人在前10个最小距离中的命中次数。</p><p id="fdda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这项任务，有更好的算法存在，例如<a class="ae kb" href="https://en.wikipedia.org/wiki/Support_vector_machine" rel="noopener ugc nofollow" target="_blank">支持向量机</a>经常被使用。dlib甚至提供了方便的<a class="ae kb" href="http://dlib.net/ml.html#svm_multiclass_linear_trainer" rel="noopener ugc nofollow" target="_blank"> API </a>来训练这类模型。我很少看到有人提到大型数据集上的SVM可能会很慢，所以我需要先在大型数据集上测试它，我还没有这样做。</p><h2 id="677d" class="kj kk hu bd kl km kn ko kp kq kr ks kt jn ku kv kw jr kx ky kz jv la lb lc ld dt translated">使用</h2><p id="403c" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">生成的库可在<a class="ae kb" href="https://github.com/Kagami/go-face" rel="noopener ugc nofollow" target="_blank">github.com/Kagami/go-face</a>获得，照常将其包含在您的Go项目中:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="e943" class="kj kk hu mc b fv mg mh l mi mj">import "github.com/Kagami/go-face"</span></pre><p id="5307" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有结构和方法的概述见<a class="ae kb" href="https://godoc.org/github.com/Kagami/go-face" rel="noopener ugc nofollow" target="_blank"> GoDoc文档</a>。它们并不多，典型的工作流程是:</p><ol class=""><li id="a371" class="lj lk hu je b jf jg jj jk jn ll jr lm jv ln jz mn lp lq lr dt translated">初始化识别器</li><li id="95b1" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz mn lp lq lr dt translated">识别所有已知图像，收集描述符</li><li id="aef6" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz mn lp lq lr dt translated">将具有相应类别的已知描述符传递给识别器</li><li id="86d4" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz mn lp lq lr dt translated">获取未知图像的描述符</li><li id="e6de" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz mn lp lq lr dt translated">分类它的类别</li></ol><p id="bc33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是说明上述所有步骤的工作示例:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="e808" class="kj kk hu mc b fv mg mh l mi mj">package main</span><span id="dbd8" class="kj kk hu mc b fv mo mh l mi mj">import (<br/>  "fmt"<br/>  "log"<br/>  "path/filepath"</span><span id="b46d" class="kj kk hu mc b fv mo mh l mi mj">  "github.com/Kagami/go-face"<br/>)</span><span id="3629" class="kj kk hu mc b fv mo mh l mi mj">// Path to directory with models and test images. Here it's<br/>// assumed it points to the<br/>// &lt;<a class="ae kb" href="https://github.com/Kagami/go-face-testdata" rel="noopener ugc nofollow" target="_blank">https://github.com/Kagami/go-face-testdata</a>&gt; clone.<br/>const dataDir = "testdata"</span><span id="4931" class="kj kk hu mc b fv mo mh l mi mj">// This example shows the basic usage of the package: create an<br/>// recognizer, recognize faces, classify them using few known<br/>// ones.<br/>func main() {<br/>  // Init the recognizer.<br/>  rec, err := face.NewRecognizer(dataDir)<br/>  if err != nil {<br/>    log.Fatalf("Can't init face recognizer: %v", err)<br/>  }<br/>  // Free the resources when you're finished.<br/>  defer rec.Close()</span><span id="1b89" class="kj kk hu mc b fv mo mh l mi mj">  // Test image with 10 faces.<br/>  testImagePristin := filepath.Join(dataDir, "pristin.jpg")<br/>  // Recognize faces on that image.<br/>  faces, err := rec.RecognizeFile(testImagePristin)<br/>  if err != nil {<br/>    log.Fatalf("Can't recognize: %v", err)<br/>  }<br/>  if len(faces) != 10 {<br/>    log.Fatalf("Wrong number of faces")<br/>  }</span><span id="a0d8" class="kj kk hu mc b fv mo mh l mi mj">  // Fill known samples. In the real world you would use a lot of<br/>  // images for each person to get better classification results<br/>  // but in our example we just get them from one big image.<br/>  var samples []face.Descriptor<br/>  var cats []int32<br/>  for i, f := range faces {<br/>    samples = append(samples, f.Descriptor)<br/>    // Each face is unique on that image so goes to its own<br/>    // category.<br/>    cats = append(cats, int32(i))<br/>  }<br/>  // Name the categories, i.e. people on the image.<br/>  labels := []string{<br/>    "Sungyeon", "Yehana", "Roa", "Eunwoo", "Xiyeon",<br/>    "Kyulkyung", "Nayoung", "Rena", "Kyla", "Yuha",<br/>  }<br/>  // Pass samples to the recognizer.<br/>  rec.SetSamples(samples, cats)</span><span id="dddf" class="kj kk hu mc b fv mo mh l mi mj">  // Now let's try to classify some not yet known image.<br/>  testImageNayoung := filepath.Join(dataDir, "nayoung.jpg")<br/>  nayoungFace, err := rec.RecognizeSingleFile(testImageNayoung)<br/>  if err != nil {<br/>    log.Fatalf("Can't recognize: %v", err)<br/>  }<br/>  if nayoungFace == nil {<br/>    log.Fatalf("Not a single face on the image")<br/>  }<br/>  catID := rec.Classify(nayoungFace.Descriptor)<br/>  if catID &lt; 0 {<br/>    log.Fatalf("Can't classify")<br/>  }<br/>  // Finally print the classified label. It should be "Nayoung".<br/>  fmt.Println(labels[catID])<br/>}</span></pre><p id="2018" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要运行它，请执行以下操作:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="1863" class="kj kk hu mc b fv mg mh l mi mj">mkdir -p ~/go &amp;&amp; cd ~/go  # Or cd to your $GOPATH<br/>mkdir -p src/go-face-example &amp;&amp; cd src/go-face-example<br/>git clone <a class="ae kb" href="https://github.com/Kagami/go-face-testdata" rel="noopener ugc nofollow" target="_blank">https://github.com/Kagami/go-face-testdata</a> testdata<br/>edit main.go  # Paste example code<br/>go get .<br/>../../bin/go-face-example</span></pre><p id="8fc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编译go-face需要一些时间(在我的i7上大约1分钟)，因为dlib的代码中大量使用了C++模板。幸运的是，Go缓存了构建输出，所以将来的构建会快得多。</p><p id="ac11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例应打印“Nayoung ”,表明未知图像被正确识别。</p><h2 id="099c" class="kj kk hu bd kl km kn ko kp kq kr ks kt jn ku kv kw jr kx ky kz jv la lb lc ld dt translated">模型</h2><p id="391d" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">go-face需要<code class="eh mk ml mm mc b">shape_predictor_5_face_landmarks.dat</code>和<br/> <code class="eh mk ml mm mc b">dlib_face_recognition_resnet_model_v1.dat</code>型号进行工作。您可以从<a class="ae kb" href="https://github.com/davisking/dlib-models" rel="noopener ugc nofollow" target="_blank"> dlib-models </a>资源库下载:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="8a8f" class="kj kk hu mc b fv mg mh l mi mj">mkdir models &amp;&amp; cd models<br/>wget <a class="ae kb" href="https://github.com/davisking/dlib-models/raw/master/shape_predictor_5_face_landmarks.dat.bz2" rel="noopener ugc nofollow" target="_blank">https://github.com/davisking/dlib-models/raw/master/shape_predictor_5_face_landmarks.dat.bz2</a><br/>bunzip2 shape_predictor_5_face_landmarks.dat.bz2<br/>wget <a class="ae kb" href="https://github.com/davisking/dlib-models/raw/master/dlib_face_recognition_resnet_model_v1.dat.bz2" rel="noopener ugc nofollow" target="_blank">https://github.com/davisking/dlib-models/raw/master/dlib_face_recognition_resnet_model_v1.dat.bz2</a><br/>bunzip2 dlib_face_recognition_resnet_model_v1.dat.bz2</span></pre><p id="0cb7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它们也可以在<a class="ae kb" href="https://github.com/Kagami/go-face-testdata" rel="noopener ugc nofollow" target="_blank"> go-face-testdata </a>存储库中获得，您已经克隆了该存储库来运行示例。</p><h2 id="1a32" class="kj kk hu bd kl km kn ko kp kq kr ks kt jn ku kv kw jr kx ky kz jv la lb lc ld dt translated">未来的想法</h2><p id="7884" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我对结果相当满意，库有简单的API，体面的识别质量，可以很容易地嵌入到Go应用程序中。但是当然总有改进的空间:</p><ul class=""><li id="937d" class="lj lk hu je b jf jg jj jk jn ll jr lm jv ln jz lo lp lq lr dt translated">为了简单和快速，go-face目前在创建描述符时不<a class="ae kb" href="https://github.com/davisking/dlib/blob/v19.15/examples/dnn_face_recognition_ex.cpp#L182-L190" rel="noopener ugc nofollow" target="_blank">抖动面部图像</a>，但是绝对值得为此添加选项，因为它可能会提高识别质量。</li><li id="4504" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">dlib支持很多图像格式(JPEG、PNG、GIF、BMP、DNG ),但是go-face目前只支持JPEG，如果能支持更多格式就更好了。</li><li id="f22d" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">正如dlib的作者Davis 所建议的那样，多类SVM可能会给出比搜索最小距离更好的分类结果，所以这需要额外的测试。</li><li id="cc8e" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">在go-face中，我尽量不复制值，除非真的有必要，但还没有实际测试过大量(10，000+)人脸样本的性能，可能会有一些瓶颈。</li><li id="54d7" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">从人脸提取特征向量是一个强大的概念，因为你不需要收集自己的训练数据，这是一项非常雄心勃勃的任务(Davis <a class="ae kb" href="http://blog.dlib.net/2017/02/high-quality-face-recognition-with-deep.html" rel="noopener ugc nofollow" target="_blank">提到</a>用于创建dlib的ResNet模型的300万人脸数据集)，但这可能是不可避免的，以获得更高质量的识别，因此值得提供工具来训练你自己的模型。</li></ul></div></div>    
</body>
</html>