<html>
<head>
<title>Communicating between components in Java Using Guava Event Bus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Guava事件总线在Java组件间通信</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/communicating-between-components-in-java-using-guava-event-bus-2f8a1e4e18dd?source=collection_archive---------0-----------------------#2018-08-13">https://medium.com/hackernoon/communicating-between-components-in-java-using-guava-event-bus-2f8a1e4e18dd?source=collection_archive---------0-----------------------#2018-08-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a242e3a81c7fa39248fcd173e87634b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9fw9-AbGIqjEskbK-Rf6A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://raw.githubusercontent.com/greenrobot/EventBus/master/EventBus-Publish-Subscribe.png" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/greenrobot/EventBus/master/EventBus-Publish-Subscribe.png</a></figcaption></figure><p id="6f92" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在构建企业应用程序时，一个常见的情况是在一个流程<a class="ae jg" href="https://hackernoon.com/tagged/successful" rel="noopener ugc nofollow" target="_blank">成功</a>后<a class="ae jg" href="https://hackernoon.com/tagged/implementing" rel="noopener ugc nofollow" target="_blank">实现</a>一系列业务流程，例如，如果您正在构建一个购物网站，您可能希望在产品付款成功后执行以下操作</p><ol class=""><li id="f7c7" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">购买后减少商店中可用的商品数量。</li><li id="6049" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">给店主寄一张购物收据。</li><li id="6cea" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">向买家发送购物收据。</li></ol><p id="62a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在某些情况下，您可能希望这些过程是与产品购买相关的<strong class="jj hv">原子</strong>，即<strong class="jj hv">在产品购买发生后，商品数量必须减少，如果减少可用商品数量</strong>出现问题，则恢复产品购买。您通常会希望在<a class="ae jg" href="https://en.wikipedia.org/wiki/Transaction_processing" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">事务</strong> </a>中这样做，以使流程原子化。</p><p id="94f8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在其他一些情况下，第二个过程可能不够重要，不足以在第一个阶段失败时恢复第一个阶段的执行，例如，您可能不希望向客户或卖方发送收据的过程影响付款过程。在这种情况下，您会希望尽可能地分离处理两个流程的组件，以便它们可以独立地执行它们的操作，这就是<strong class="jj hv">事件总线</strong>可以帮助我们的地方。</p><p id="e33f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">什么是事件总线？</strong></p><blockquote class="kt ku kv"><p id="3efb" class="jh ji kw jj b jk jl jm jn jo jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd ke hn dt translated">Eventbus是一种机制，它允许不同的组件在不了解彼此的情况下相互通信。一个组件可以将一个事件发送到Eventbus，而不知道谁将获得它或者有多少其他人将获得它。组件也可以监听Eventbus上的事件，而不知道是谁发送了事件。这样，组件就可以相互通信而不依赖对方。此外，替换一个组件非常容易。只要新组件理解正在发送和接收的事件，其他组件就永远不会知道。</p><p id="db25" class="jh ji kw jj b jk jl jm jn jo jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd ke hn dt translated"><a class="ae jg" href="http://www.rribbit.org/eventbus.html" rel="noopener ugc nofollow" target="_blank">http://www.rribbit.org/eventbus.html</a></p></blockquote><p id="8c43" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本教程中，我们将使用<a class="ae jg" href="https://github.com/google/guava/wiki/EventBusExplained" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">谷歌番石榴事件总线</strong> </a>实现来展示我们如何在java应用程序中分离组件</p><p id="d64a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:这个库的文档是这样描述事件总线的</p><blockquote class="kt ku kv"><p id="5205" class="jh ji kw jj b jk jl jm jn jo jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd ke hn dt translated"><code class="eh la lb lc ld b">EventBus</code>允许组件之间发布-订阅式的通信，而不需要组件彼此显式注册(从而知道彼此)。它专门设计用来取代使用显式注册的传统Java进程内事件分发。它不是一个通用的发布-订阅系统，也不是用于进程间通信。</p></blockquote><p id="ab98" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的例子中，我们将通过模拟本文开头提到的支付过程来演示如何使用事件总线。</p><p id="8e1f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是我们的应用程序中涉及的组件</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff le"><img src="../Images/1fb0fe058dc8f7a27b4ff517c4826bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*c8D-DnP5FeYjFSv8sKUhZg.png"/></div></figure><ul class=""><li id="1eb2" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke lj kl km kn dt translated">第一个组件应该处理与成功支付直接相关的流程，比如减少商店中剩余的商品数量。</li><li id="9359" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke lj kl km kn dt translated">第二个组件处理向客户发送收据。</li><li id="501a" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke lj kl km kn dt translated">第三个组件处理发送、接收给卖方。</li></ul><p id="3d43" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以通过用不同的方法实现这些过程来将它们链接在一起，并按顺序调用它们</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/7fa7c8a0e14dc8c80c817722ccead84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*kyb5ng5AiA8PHc-5GWZbdw.png"/></div></figure><p id="59f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以这样实现它</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="33bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是这种方法的问题是组件没有正确地解耦，并且当一个过程中出现错误时，它可能会影响另一个过程。此外，如果我们必须在成功支付后添加更多要执行的流程，我们将不得不手动转到onPaymentRecievedMethod()并添加方法调用，这并不好，我们将使用事件总线<strong class="jj hv"> Google Guava事件总线</strong>来解决这个问题。</p><p id="084b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是我们实现的样子</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/387e0d96db62f4f3bb53b719b4aa090f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*A9DhulF8SlpgQ5c-odpuKw.png"/></div></figure><p id="4e6f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">支付组件和收据发送组件完全不知道对方，事件总线负责将信息从发布者传送到所有订阅者。</p><h2 id="e80a" class="lo lp hu bd lq lr ls lt lu lv lw lx ly js lz ma mb jw mc md me ka mf mg mh mi dt translated">番石榴事件总线是如何工作的？</h2><p id="6e8c" class="pw-post-body-paragraph jh ji hu jj b jk mj jm jn jo mk jq jr js ml ju jv jw mm jy jz ka mn kc kd ke hn dt translated">让我们有一些快速提示。</p><ul class=""><li id="bb3a" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke lj kl km kn dt translated">Guava事件总线中的一些重要概念是</li></ul><p id="4c48" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">i. <strong class="jj hv">事件总线</strong>:这是一个对象，它被委托负责将事件数据从一个组件传送到另一个组件，您通常希望有一个事件总线的实例，以便生产者和订户可以使用相同的事件总线，这是事件总线正常工作所必需的。您可以使用singleton模式来确保只创建该类的一个实例，并在需要事件总线实例时使用IOC容器来提供该实例。</p><p id="b687" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kw">注意:</em>如果您想要不同的事件总线来处理不同的组件集，您可以有多个事件实例，但是只需知道如果发布者和订阅者必须相互通信，它们必须使用相同的事件总线。</p><p id="a124" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">二。<strong class="jj hv">生产者</strong>:生产者负责发出事件，然后这些事件被传递给事件总线，并被发送给订阅该事件的所有侦听器。</p><p id="110b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">三。<strong class="jj hv">侦听器</strong>:侦听器订阅一个事件，当事件从生产者处发布时它被触发，您可以根据您所使用的事件总线的类型同步或异步运行一个侦听器方法。为了让监听器方法同步运行，您可以使用同步事件总线，这是默认的<strong class="jj hv">事件总线</strong>类，为了让它异步运行，您必须使用<strong class="jj hv">异步事件总线</strong>类，它是<strong class="jj hv">事件总线</strong>的子类，它的构造函数需要一个<a class="ae jg" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">执行器</strong> </a>，用于在一个单独的线程上执行该方法。在我们的例子中，我们将使用异步事件总线。</p><p id="b68e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">四。<strong class="jj hv">事件</strong>:在Guava event bus中，事件只是一个使用类名唯一标识的对象。因此，要创建一个支付成功事件，我们只需要创建一个PaymentSuccessfulEvent.java类，并在支付成功时发布该类的一个实例。</p><h2 id="d9fa" class="lo lp hu bd lq lr ls lt lu lv lw lx ly js lz ma mb jw mc md me ka mf mg mh mi dt translated"><strong class="ak">如何使用事件总线库</strong></h2><ol class=""><li id="9ea5" class="kf kg hu jj b jk mj jo mk js mo jw mp ka mq ke kk kl km kn dt translated"><strong class="jj hv">将谷歌番石榴库添加到您的项目中</strong></li></ol><p id="9da8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以使用你最喜欢的依赖管理工具来实现，让我们使用maven:</p><pre class="lf lg lh li fq mr ld ms mt aw mu dt"><span id="7d4f" class="lo lp hu ld b fv mv mw l mx my">&lt;dependency&gt;</span><span id="e058" class="lo lp hu ld b fv mz mw l mx my">&lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><span id="5615" class="lo lp hu ld b fv mz mw l mx my">&lt;artifactId&gt;guava&lt;/artifactId&gt;</span><span id="172a" class="lo lp hu ld b fv mz mw l mx my">&lt;version&gt;26.0-jre&lt;/version&gt;</span><span id="7821" class="lo lp hu ld b fv mz mw l mx my">&lt;/dependency&gt;</span></pre><p id="9bcf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.<strong class="jj hv">创建工厂方法来提供我们的事件总线实例。</strong></p><p id="9758" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将只使用一个静态类成员来保存事件总线的实例，并忘记在这个演示中添加IOC容器的复杂性。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="fd16" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">EventBusFactory类有一个getEventBus()方法，该方法返回异步事件总线的单个实例。</p><p id="348a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">3.<strong class="jj hv">创建支付成功事件。</strong></p><p id="b4ce" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就像我们前面说过的，事件只是一个简单的类，每个事件都由类名来标识。因此，让我们创建一个<strong class="jj hv">成功支付</strong>事件。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="dc78" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，当支付成功时，该事件将被发布。</p><p id="3cdb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">4.<strong class="jj hv">为支付成功事件创建监听器。</strong></p><p id="d02b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Guava Event Bus中，侦听器是一个用@Subscribe注释修饰的方法，只要其参数中的事件被发布，它就会被触发。让我们创建一个支付成功事件监听器</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="0cb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">5.<strong class="jj hv">注册事件列表器。</strong></p><p id="c598" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在应用程序启动时，我们必须将Receipt sender类注册为事件侦听器，告诉guava event bus它包含用@Subscribe注释修饰的方法。这是通过将RecieptSender类的实例传递给eventBus.register()方法来实现的。</p><pre class="lf lg lh li fq mr ld ms mt aw mu dt"><span id="1df9" class="lo lp hu ld b fv mv mw l mx my">EventBusFactory.<em class="kw">getEventBus</em>().register(new RecieptSender());</span></pre><p id="9073" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">6.<strong class="jj hv">发布事件。</strong></p><p id="b292" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，只要付款成功，我们就会发布事件。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="9f84" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将触发所有将支付事件作为参数并具有@Subscribe注释的方法。</p></div><div class="ab cl na nb hc nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hn ho hp hq hr"><p id="f74c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">欢迎在评论中分享你的想法，我想听听你实施这种模式的经验。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="nh lm l"/></div></figure></div></div>    
</body>
</html>