<html>
<head>
<title>JavaScript for Algorithmic Competitive Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于算法竞争编程的JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-for-algorithms-competitive-programming-45cf723cd16f?source=collection_archive---------7-----------------------#2018-08-13">https://medium.com/hackernoon/javascript-for-algorithms-competitive-programming-45cf723cd16f?source=collection_archive---------7-----------------------#2018-08-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="807a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">去年，我花了一些时间参加竞争性编程竞赛，你必须在有限的时间内解决算法问题。不过，我仍然处于开始阶段，这已经很有趣了，并给了我一些好处。</p><p id="22d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将把我的故事分成三部分:</p><ul class=""><li id="3650" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">动机</li><li id="93aa" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">JavaScript特性</li><li id="77ae" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">对初学者的一些观察和建议</li></ul><h1 id="b20f" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">动机</h1><p id="c155" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我经常听到算法和数据结构的良好知识以及在竞争性编程中的成功在实际工作中并没有真正的帮助。</p><p id="658a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他们帮助很大，这就是为什么。</p><p id="27a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你在途中学习你的语言。我学到了很多关于JavaScript的东西，这些东西可能会在以后的生产中对我产生影响，因为这些问题相对较少，所以我几乎不会提前考虑它们(比如大量的数据)。</p><p id="d014" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你解决有趣的问题。是的，一些自然的问题，比如做一些任务的最佳方式是什么，并且花费最少的时间。</p><p id="0e04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你获得的知识是最基本的。如果你像我一样是一名前端人员，并且对你不得不经常扔掉你昨天才学到的东西感到厌倦，这可以为你节省港口——这是你多年来学习的东西。如果不是量子计算机我甚至会说几百年呵呵。</p><p id="db05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">编程肌肉——半年前，我经常理解解决方案，但很难将它写入代码。现在，情况往往相反——一旦我理解了编码算法，它就像是在用母语说话，这肯定会提高我的工作效率。</p><p id="6f64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就引出了另一项重要的技能——学会如何把事情分成更小的部分，这样你就不会在任何特定的时刻把整个画面留在你的大脑里。这来自一些算法设计，如分治或动态编程，然后了解如何准备从算法的一个步骤到另一个步骤的数据，以便您保持低时间复杂度，但仍具有便于处理的数据格式。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h1 id="e677" class="kd ke hu bd kf kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la dt translated">JavaScript特性</h1><p id="9913" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我选择JavaScript是因为我比其他人更了解这种语言。</p><p id="2f8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然与C、Python和Java相比，它并不是很受欢迎的竞争性编程语言，我可以猜到一些历史原因，但在我自己尝试之后，我认为我可能也会看到一些非历史原因(但我仍然热爱JS)。</p><h2 id="0c2e" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">大数字</h2><p id="abea" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">乍一看，Javascript中允许的最大整数相当大:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="664a" class="ls ke hu ml b fv mp mq l mr ms">Number.MAX_SAFE_INTEGER === 9007199254740991</span></pre><p id="4230" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">直到你碰到一个问题，最大允许输入已经比那个大了(<a class="ae mt" href="https://code.google.com/codejam/contest/3264486/dashboard#s=p2" rel="noopener ugc nofollow" target="_blank">谷歌代码堵塞2017 </a>和<a class="ae mt" href="https://code.google.com/codejam/contest/6254486/dashboard#s=p3&amp;a=2" rel="noopener ugc nofollow" target="_blank">谷歌代码堵塞2016 </a>等等)。).</p><p id="0752" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，有时问题甚至可能被隐藏起来——当您执行数十亿次乘法时，或者当您在生产中使用数字作为id时，在某一点上，所有大于<code class="eh mu mv mw ml b">MAX_SAFE_INTEGER</code>的id将被Javascript视为相等:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="30fe" class="ls ke hu ml b fv mp mq l mr ms">Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 // true</span></pre><p id="adc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一些处理大数字的库，也有Chrome团队的<a class="ae mt" href="https://developers.google.com/web/updates/2018/05/bigint" rel="noopener ugc nofollow" target="_blank">倡议，所以我们期待一个更光明的未来，但谁知道它会多快到来。现在我们必须处理它。</a></p><h2 id="3c8e" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">浮点数</h2><p id="c257" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">下面的陈述是众所周知的，您可以在整个社区的文章中经常看到:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="3f26" class="ls ke hu ml b fv mp mq l mr ms">0.1 + 0.2 === 0.3 // false</span></pre><p id="4d1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是JavaScript特有的，对于这种现象有很多很好的解释。然而，我从未想过有一天我会想到这一点，直到我试图解决<a class="ae mt" href="https://code.google.com/codejam/contest/5304486/dashboard#s=p1" rel="noopener ugc nofollow" target="_blank">谷歌代码堵塞2017年1A回合</a>问题，我不得不计算一个人可以用每种成分的数量作为输入的最大数量，以及将一份数量作为常数所需的偏差。</p><p id="8c17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">考虑下面我用来求解的函数:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="16a7" class="ls ke hu ml b fv mp mq l mr ms">function getMinMaxWrong(total, serving) {<br/>  var min = Math.ceil(total <strong class="ml hv">/ (1.1</strong> * serving));<br/>  var max = Math.floor(total <strong class="ml hv">/ (0.9</strong> * serving));<br/>  return min &gt; max ? [0, 0] : [min, max];<br/>}</span><span id="2c99" class="ls ke hu ml b fv mx mq l mr ms">console.log(getMinMaxWrong(2376, 3)); // [720, <strong class="ml hv">879</strong>]</span></pre><p id="9150" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">似乎是正确的，但是让我们用整数重写它:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="77bb" class="ls ke hu ml b fv mp mq l mr ms">function getMinMaxRight(total, serving) {<br/>  var min = Math.ceil(total <strong class="ml hv">* 10 / (11</strong> * serving));<br/>  var max = Math.floor(total <strong class="ml hv">* 10 / (9</strong> * serving));<br/>  return min &gt; max ? [0, 0] : [min, max];<br/>}</span><span id="7f35" class="ls ke hu ml b fv mx mq l mr ms">console.log(getMinMaxRight(2376, 3)); // [720, <strong class="ml hv">880</strong>]</span></pre><p id="89a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数学上这两个公式是一样的。但是当您在NodeJS环境中执行它们时，您会得到两个不同的结果，第一个解决方案不会通过。</p><h2 id="c167" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">阵列方法纯度</h2><p id="1356" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我很快就习惯了函数式方法和不可变数组方法，比如<code class="eh mu mv mw ml b">map</code>、<code class="eh mu mv mw ml b">filter</code>、<code class="eh mu mv mw ml b">slice</code>和<code class="eh mu mv mw ml b">reduce</code>。即使简单的for循环更有表现力，我也使用它们，只是因为我觉得很酷😎。</p><p id="c944" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">后来，它让我相信所有其他数组方法都是浅拷贝，总是返回新数组而不是原始数组。</p><p id="da4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想在执行了下面的代码后，我仍然使用未排序的<code class="eh mu mv mw ml b">arr</code>:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="8237" class="ls ke hu ml b fv mp mq l mr ms">arrSorted = arr.sort((a, b) =&gt; a — b)</span></pre><p id="39a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我错了，因为<code class="eh mu mv mw ml b">sort</code>和<code class="eh mu mv mw ml b">reverse</code>改变了数组对象的位置。</p><p id="0ad8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">确保你知道哪些方法会改变你的数组，哪些不会。</p><p id="ddca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对此要小心的另一个原因是，当你使用递归时，你很容易在每个递归函数调用中使用浅层拷贝来增加空间复杂度。</p><h2 id="1a1a" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">最大调用堆栈</h2><p id="cae6" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">关于递归的另一点是最大调用堆栈大小。</p><p id="f727" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为每个JavaScript开发人员一生中至少会看到一次由于无限<code class="eh mu mv mw ml b">while</code>或<code class="eh mu mv mw ml b">for</code>循环执行而产生的消息:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="3706" class="ls ke hu ml b fv mp mq l mr ms">Maximum call stack size exceeded.</span></pre><p id="e3b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题是——这不仅仅是无限循环。它也防止你用大量的迭代进行递归。</p><p id="f1f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您曾经实现过深度优先搜索树遍历，那么您很可能是这样做的:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="4e84" class="ls ke hu ml b fv mp mq l mr ms">1  <strong class="ml hv">procedure</strong> DFS(<em class="my">G</em>,<em class="my">v</em>):<br/>2    label <em class="my">v</em> as discovered<br/>3    <strong class="ml hv">for all</strong> edges from <em class="my">v</em> to <em class="my">w</em> <strong class="ml hv">in</strong> <em class="my">G</em>.adjacentEdges(<em class="my">v</em>) <strong class="ml hv">do</strong><br/>4      <strong class="ml hv">if</strong> vertex <em class="my">w</em> is not labeled as discovered <strong class="ml hv">then</strong><br/>5        recursively call DFS(<em class="my">G</em>,<em class="my">w</em>)</span></pre><p id="dfb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我也解决了一个关于Codeforces的问题。同样适用于<code class="eh mu mv mw ml b">C++</code>的解决方案在<code class="eh mu mv mw ml b">Node</code>中并不适用，因为在一次测试中确实超过了最大调用堆栈大小。</p><p id="45cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过使用<a class="ae mt" href="https://stackoverflow.com/questions/5278580/non-recursive-depth-first-search-algorithm" rel="noopener ugc nofollow" target="_blank">非递归深度优先搜索</a>有一个很好的方法，它有一些限制，但在特定问题中工作良好。同样的问题和走来走去适用于<a class="ae mt" href="https://en.wikipedia.org/wiki/Flood_fill" rel="noopener ugc nofollow" target="_blank">洪水填充</a>算法，我相信其他人也一样。</p><p id="e593" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您仍然想使用递归解决方案，并且知道输入限制(这是经常发生的情况)，您可以通过执行摘自<a class="ae mt" href="http://2ality.com/2014/04/call-stack-size.html" rel="noopener ugc nofollow" target="_blank">Axel Rauschmayer博士博客文章</a>的以下代码片段来计算JavaScript引擎的最大调用堆栈:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="4308" class="ls ke hu ml b fv mp mq l mr ms">function computeMaxCallStackSize() {<br/>  try {<br/>    return 1 + computeMaxCallStackSize();<br/>  } catch (e) {<br/>    // Call stack overflow<br/>    return 1;<br/>  }<br/>}</span></pre><p id="9bc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看最坏情况下递归迭代的次数是否不超过这个数。</p><h2 id="8ed1" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">数组方法复杂性</h2><p id="1e0a" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Codeforces上的同一个问题让我学到了关于JavaScript数组方法的另一件事:即使它们看起来做了同样的事情，它们也有不同的时间复杂度。</p><p id="6008" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们在长度为O(N)的数组上使用<code class="eh mu mv mw ml b">push/pop</code> vs <code class="eh mu mv mw ml b">shift/unshift</code>方法。</p><p id="ec6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">前两种方法复杂度为O(1 ),因为它们</p><ul class=""><li id="ca58" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">读取数组<code class="eh mu mv mw ml b">length</code>的属性— O(1)</li><li id="9a0d" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">向数组对象再添加一个属性— O(1)</li><li id="d00d" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">更新数组<code class="eh mu mv mw ml b">length</code>的属性— O(1)</li></ul><p id="d0bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结束。</p><p id="1db1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外两个方法不仅要更新数组长度，还要更新所有O(N)属性的值，因为它们的值向前或向后移动，这使得O(N)复杂度几乎与O(1)相同。</p><h2 id="175d" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">字符串是不可变的</h2><p id="6296" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我经常忘记的一件小事，也不是JS特有的，就是你可以用下面的方法更新一个数组:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="9ea3" class="ls ke hu ml b fv mp mq l mr ms">arr = ['n', 'o']<br/>arr[0] = 'y'<br/>print(arr.join('')) // 'yo'</span></pre><p id="0a9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是您不能像这样改变字符串:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="b806" class="ls ke hu ml b fv mp mq l mr ms">str = 'no'<br/>str[0] = 'y'<br/>print(str)) // 'no'</span></pre><p id="98d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我经常使用技巧将字符串转换为数组，对其进行处理，然后再转换回字符串:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="1aaa" class="ls ke hu ml b fv mp mq l mr ms">// str -&gt; arr<br/>arr = str.split('')</span><span id="9cea" class="ls ke hu ml b fv mx mq l mr ms">// arr -&gt; str<br/>str = arr.join('')</span></pre><p id="9670" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从空间复杂性的角度来看，这并不是最佳的，但是在许多情况下，这使得代码更易读并且更容易实现。</p><h2 id="0220" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">JS还是不是JS</h2><p id="f909" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">竞赛引擎通常将NodeJS版本限制为某个旧版本，例如Google Code Jam支持v4.8.2，这意味着<a class="ae mt" href="https://node.green/" rel="noopener ugc nofollow" target="_blank">不能使用classes、let/const或destructuring，这有时会在试图弄清楚你现在是在参加竞赛还是在从事web项目的过程中分裂你的思维。</a></p><p id="20af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大数字问题显然阻碍了JavaScript中某些问题的解决，最大调用栈问题也带来了一些不便。</p><p id="4049" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很乐意使用JS来解决限定问题，尤其是处理数组的方式，但是对于进一步的步骤，我可能会使用Python。它没有一些限制，广泛用于机器学习，是仅有的两种允许参加著名的<a class="ae mt" href="https://www.quora.com/What-is-Google%E2%80%99s-Foobar" rel="noopener ugc nofollow" target="_blank"> Google foobar挑战赛</a>的语言之一🙃。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h1 id="3479" class="kd ke hu bd kf kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la dt translated">如何准备资格赛</h1><p id="faed" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">如果你想弄脏自己的手，为未来的比赛做准备，无论你想加强哪种语言，我建议你复习前几年的问题，积累一些经验，当你无法窥视解决方案时，这种自信是真正需要的。</p><h2 id="a089" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">小型与大型数据集</h2><p id="0ef2" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">通常在Code Jam中，你会得到大小不同的数据集。虽然大数据集解决方案几乎总是考虑时间复杂度限制，但是小数据集通常可以用蛮力来解决。</p><p id="ee5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这为您带来了以下好处:</p><ul class=""><li id="a3af" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">您可以观察小数据集结果中的模式，并获得一些优化算法的见解，特别是当它是一个数学问题时</li><li id="369e" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">您可以在从强力解决方案获得的小数据集结果上验证您的大数据集解决方案</li><li id="3441" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">有时强力甚至对大型数据集也有效(只需注意输入限制和算法复杂性)</li></ul><h2 id="0e6c" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">数学</h2><p id="9778" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">有很多数学题考虑二进制表示、<a class="ae mt" href="https://en.wikipedia.org/wiki/Divisibility_rule" rel="noopener ugc nofollow" target="_blank">被不同数整除</a>、质数等。我猜这很难准备，所以我个人只是依靠我在学校参加数学竞赛的经验，在解决前几年的竞赛练习时积累一些知识。</p><h2 id="e21b" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">概率论</h2><p id="4084" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">令人惊讶的是，概率问题经常发生。</p><p id="39bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据我的观察，通常足以知道，例如如果你有p <em class="my"> 1 </em>，p <em class="my"> 2 </em>，..，p <em class="my"> n </em>不同事件发生的概率，则概率为:</p><ul class=""><li id="8fe0" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">至少有一个事件发生是:p <em class="my"> 1 + </em> p <em class="my"> 2 +。</em>..+ p <em class="my"> n </em></li><li id="bbe1" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">至少一个没有发生的事件是:(1—p<em class="my">1)+</em>(1—p<em class="my">2)+</em>……+(1—p<em class="my">n)</em></li><li id="b0ac" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">所有发生的事件是:p<em class="my">1 *</em>p<em class="my">2 *</em>……* p<em class="my">n</em></li><li id="cd78" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">没有事件发生是:(1—p<em class="my">1)*</em>(1—p<em class="my">2)*</em>……*(1—p<em class="my">n)</em></li></ul><p id="67aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例:<a class="ae mt" href="https://codejam.withgoogle.com/codejam/contest/3274486/dashboard#s=p2&amp;a=1" rel="noopener ugc nofollow" target="_blank">第1C轮2017 </a></p><h2 id="90cf" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">位运算</h2><p id="a46c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">整个编程世界都是基于信号的二进制性质，因此肯定存在需要了解位运算的问题。</p><p id="a221" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:<a class="ae mt" href="https://codejam.withgoogle.com/codejam/contest/975485/dashboard#s=a&amp;a=2" rel="noopener ugc nofollow" target="_blank">2011年资格赛</a></p><h2 id="27c7" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">贪婪，散列，DP</h2><p id="41ab" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">几乎所有资格赛的算法任务都可以用<a class="ae mt" href="https://en.wikipedia.org/wiki/Greedy_algorithm" rel="noopener ugc nofollow" target="_blank">贪婪</a>方法、<a class="ae mt" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">散列</a>或<a class="ae mt" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态规划</a>或它们的组合来解决。它只是需要一些练习来建立在哪里使用它们的直觉。</p><figure class="mg mh mi mj fq na fe ff paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="fe ff mz"><img src="../Images/686080e2b91d83bc3b35b297eb461652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alr-XIEVAftcrVAJHoSEmQ.jpeg"/></div></div></figure><h1 id="994f" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">下一步是什么</h1><p id="23bc" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">尽管JavaScript在竞争对手中并不流行，但有一些很棒的项目填补了这一空白:</p><div class="nh ni fm fo nj nk"><a href="https://github.com/trekhleb/javascript-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">trekhleb/JavaScript-算法</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">javascript-算法-用JavaScript实现的算法和数据结构，带有解释和链接，可以进一步…</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny nf nk"/></div></div></a></div><div class="nh ni fm fo nj nk"><a href="https://github.com/mgechev/javascript-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">mgechev/JavaScript-算法</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">不同计算机科学算法的javascript实现。</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">github.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny nf nk"/></div></div></a></div><p id="8f88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我的知识库，里面有一些关于代码阻塞资格的解决方案:</p><div class="nh ni fm fo nj nk"><a href="https://github.com/romanovma/google-codejam" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">romanovma/google-codejam</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">GitHub是人们构建软件的地方。超过2800万人使用GitHub来发现、分享和贡献超过…</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">github.com</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny nf nk"/></div></div></a></div><p id="f357" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">祝你玩得开心，感谢你的阅读。</p><h2 id="1495" class="ls ke hu bd kf lt lu lv kj lw lx ly kn jc lz ma kr jg mb mc kv jk md me kz mf dt translated">给我一些爱，❤️❤️❤️</h2><p id="091a" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">如果你喜欢这篇文章，请做一些👏因此，我进一步写作的动力上升了。</p></div></div>    
</body>
</html>