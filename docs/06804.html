<html>
<head>
<title>Clojure —Lessons from Laziness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">clo jure——懒惰的教训</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/clojure-lessons-from-laziness-252ca7fc4fa7?source=collection_archive---------23-----------------------#2018-08-13">https://medium.com/hackernoon/clojure-lessons-from-laziness-252ca7fc4fa7?source=collection_archive---------23-----------------------#2018-08-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c970" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">懒惰可能是一件好事。也许是最好的东西？</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/30fb0e84aa6ed5e1bb753cc26d45ea13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VgAf-kRm0x29k6XbjsuVow.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Image source — <a class="ae jz" href="https://winnin.com/battle/357860-Cute-Animals-Who%27ll-Make-You-Feel-Less-Lazy?force_lang=es" rel="noopener ugc nofollow" target="_blank">https://winnin.com/battle/357860-Cute-Animals-Who%27ll-Make-You-Feel-Less-Lazy?force_lang=es</a></figcaption></figure><p id="4dec" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">毫无疑问，在计算的后端，懒惰是非常强大的。<a class="ae jz" href="https://hackernoon.com/tagged/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure </a>美在很多方面，<a class="ae jz" href="https://hackernoon.com/tagged/laziness" rel="noopener ugc nofollow" target="_blank">懒</a>是核心成分。大量关于它、关于它和围绕它的文章。它们涵盖了如何编写这样的代码的各个方面。大多数情况下，例如斐波那契或通用数字生成器。一些问题应该随之而来。我肯定有一些-</p><ul class=""><li id="92b7" class="kw kx hu kc b kd ke kg kh kj ky kn kz kr la kv lb lc ld le dt translated">对于一个新手，或者来自其他编程风格的人来说，它容易理解吗？收养障碍？</li><li id="9e53" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv lb lc ld le dt translated">如何把它和你我正在研究的一个现实问题联系起来？</li><li id="ec40" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv lb lc ld le dt translated">采用并将其转移到“生产”的障碍是什么？</li><li id="e244" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv lb lc ld le dt translated">有哪些陷阱和谬误？</li></ul><p id="ce4a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因此，这里有一个尝试来回答我在变懒时学到的教训。</p><h2 id="e729" class="lk ll hu bd lm ln lo lp lq lr ls lt lu kj lv lw lx kn ly lz ma kr mb mc md me dt translated">什么是懒惰？</h2><p id="e030" class="pw-post-body-paragraph ka kb hu kc b kd mf iv kf kg mg iy ki kj mh kl km kn mi kp kq kr mj kt ku kv hn dt translated">首先是“什么”。懒惰，也就是说，懒惰求值是直到绝对需要它们的返回值时才完成求值的代码部分。把这想象成类似于我们把报税表推迟到最后一刻才提交。与此同时，去做一些实际上有用的事情对我们来说是非常强大的。我们可以早点把它们归档，但是我们没有也不需要归档。绝对让我觉得“高效”。(旁注:为了更好的双关语，查看下面参考资料中的帖子(: )</p><p id="0135" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">回到后端，有些表达式直到流程的后面才需要进行完整的计算。在这个层面上说得通。现在是“如何”。对于这一部分，让我们仔细看看Clojure的核心原则。懒evals绝对是其中之一。特别是，惰性是通过惰性序列构建的，惰性序列可以在函数之间传递，并且只有在发出eval命令时才会被评估。这里是我的意思的快速浏览(在<a class="ae jz" href="https://clojuredocs.org/clojure.core/lazy-seq" rel="noopener ugc nofollow" target="_blank">https://clojuredocs.org/clojure.core/lazy-seq</a>中给出)</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="0179" class="lk ll hu ml b fv mp mq l mr ms">;; The following defines a lazy-seq of all positive numbers.  Note that <br/>;; the lazy-seq allows us to make a recursive call in a safe way because<br/>;; the call does not happen immediately but instead creates a closure.<br/><br/>user=&gt; (defn positive-numbers <br/>	([] (positive-numbers 1))<br/>	([n] (lazy-seq (cons n (positive-numbers (inc n))))))<br/>#'user/positive-numbers<br/><br/>user=&gt; (take 5 (positive-numbers))<br/>(1 2 3 4 5)</span></pre><p id="1664" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">厉害！就这样，这是我学到的第一课</p><p id="203f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">第一课——我想偷懒，这很好，但是我到底想在什么方面偷懒呢？</p><h2 id="bcce" class="lk ll hu bd lm ln lo lp lq lr ls lt lu kj lv lw lx kn ly lz ma kr mb mc md me dt translated">为什么是懒惰？</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/286e36b8b830a15ce36bacaf21a52211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*Kpp08cXDKeanqJo9_lSEUw.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Source - imgflip.com</figcaption></figure><p id="05d6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">“为什么？”，你问。总有一些代码直到被要求时才需要完成。即使他们这样做了，我们也不需要评估的所有返回val，也许只需要从<code class="eh mu mv mw ml b">(count allresults)</code>中选择<code class="eh mu mv mw ml b">n</code>，这听起来是一个公平的优势。</p><p id="574e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们拿出<code class="eh mu mv mw ml b">positive-numbers</code>的例子，不要懒惰和潜在的成本。</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="5210" class="lk ll hu ml b fv mp mq l mr ms">(defn not-lazy-positive-numbers [n]<br/>  (mapv<br/>    #(let [v (inc %)]<br/>       ; to know when evaluation happens<br/>      (println "executing" v)<br/>      v)<br/>    (range (- n 1) (+ n 10))))</span><span id="3f41" class="lk ll hu ml b fv mx mq l mr ms">;returns n to n+10 values starting from n<br/>(not-lazy-positive-numbers 10)<br/>;executing 10<br/>;executing 11<br/>;executing 12<br/>;executing 13<br/>;executing 14<br/>;executing 15<br/>;executing 16<br/>;executing 17<br/>;executing 18<br/>;executing 19<br/>;executing 20<br/>;[10 11 12 13 14 15 16 17 18 19 20]</span></pre><p id="f5ab" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><code class="eh mu mv mw ml b">not-lazy-positive-numbers</code>立即评估。为了说明这一点，假设我们必须从10到40之间的正数池中挑选15个数字。</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="eb5a" class="lk ll hu ml b fv mp mq l mr ms">(take 15 (concat (not-lazy-positive-numbers 10) (not-lazy-positive-numbers 20) (not-lazy-positive-numbers 30)))<br/>;executing 10<br/>;executing 11<br/>;executing 12<br/>;executing 13<br/>;executing 14<br/>;executing 15<br/>;executing 16<br/>;executing 17<br/>;executing 18<br/>;executing 19<br/>;executing 20<br/>;executing 20<br/>;executing 21<br/>;executing 22<br/>;executing 23<br/>;executing 24<br/>;executing 25<br/>;executing 26<br/>;executing 27<br/>;executing 28<br/>;executing 29<br/>;executing 30<br/>;executing 30<br/>;executing 31<br/>;executing 32<br/>;executing 33<br/>;executing 34<br/>;executing 35<br/>;executing 36<br/>;executing 37<br/>;executing 38<br/>;executing 39<br/>;executing 40<br/>(10 11 12 13 14 15 16 17 18 19 20 20 21 22 23)</span></pre><p id="1638" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">哇，它评估一切，即30+，即使我们只需要其中的15个值。</p><p id="2935" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">第二课——有很多代码段做了多余的事情，寻找它们</strong></p><p id="9af1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在，从最初的例子中应用一些懒惰，</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="3025" class="lk ll hu ml b fv mp mq l mr ms">(defn lazy-positive-numbers [n]<br/>  (println "executing" n) ; to know what's executing, returns a lazy seq of max 1+10 executions<br/>  (lazy-seq (cons n (take 10 (lazy-positive-numbers (inc n))))))</span><span id="d1c3" class="lk ll hu ml b fv mx mq l mr ms">(lazy-positive-numbers 10)<br/>;executing 10<br/>;executing 11<br/>;executing 12<br/>;executing 13<br/>;executing 14<br/>;executing 15<br/>;executing 16<br/>;executing 17<br/>;executing 18<br/>;executing 19<br/>;executing 20<br/>;executing 21<br/>;(10 11 12 13 14 15 16 17 18 19 20)</span></pre><p id="6877" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><code class="eh mu mv mw ml b">lazy-positive-numbers</code>总是返回10个值，作为惰性序列。(旁注lazy seq的丑陋代码可能是线程化的:/)</p><p id="d8e0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">同样，假设我们必须从10到40之间的正数中选择15个数字。这一次懒洋洋地</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="5fb3" class="lk ll hu ml b fv mp mq l mr ms">(take 15 (concat (lazy-positive-numbers 10) (lazy-positive-numbers 20) (lazy-positive-numbers 30)))<br/>;executing 10<br/>;executing 20<br/>;executing 30<br/>;executing 11<br/>;executing 12<br/>;executing 13<br/>;executing 14<br/>;executing 15<br/>;executing 16<br/>;executing 17<br/>;executing 18<br/>;executing 19<br/>;executing 20<br/>;executing 21<br/>;executing 21<br/>;executing 22<br/>;executing 23<br/>;executing 24<br/>;(10 11 12 13 14 15 16 17 18 19 20 20 21 22 23)</span></pre><p id="36ad" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">厉害！使用惰性eval，执行次数减少到18次(对于主数据源的初始化为- 3次)。</p><p id="2c2f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">第三课——懒惰伴随着创建顶层初始化的开销。更多的懒惰源，更多的开销。</strong></p><h2 id="2fe0" class="lk ll hu bd lm ln lo lp lq lr ls lt lu kj lv lw lx kn ly lz ma kr mb mc md me dt translated">与懒惰有关</h2><p id="cd55" class="pw-post-body-paragraph ka kb hu kc b kd mf iv kf kg mg iy ki kj mh kl km kn mi kp kq kr mj kt ku kv hn dt translated"><em class="my">(不重要的一课——IRL = "在现实生活中")</em></p><p id="c253" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在让我们举一个真实世界的例子。我们正在呈现一个包含帖子和更新的用户反馈页面。返回的帖子数量基于某些相关性参数，并进行分页。这些帖子来自多个来源，根据收到的不同信号构建实时反馈。就像配器一样。源可以来自数据库、ML数据模型、缓存，用一些预置数据回填。所有来源都有检索数据的计算和延迟成本。在伪代码中，它应该是这样的</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="96b7" class="lk ll hu ml b fv mp mq l mr ms">posts = [];<br/>until(posts.length &gt;= limit;<br/>  sourcelist = get-data-sources()<br/>  data = get-data-from-sources()<br/>  remdata = data.slice(posts.length - limit - data.length)<br/>  posts.push(remdata))</span></pre><p id="d6a3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">看上去注定要变得懒惰。sourcelist中的每个条目都是一个生成器，即返回一系列数据，这些数据可以汇集在一起，进行转换并添加到返回的帖子中。应用懒惰原则，看起来所有的方法</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="1cc8" class="lk ll hu ml b fv mp mq l mr ms">(defn get-data-sources []<br/>  (lazy-seq<br/>    [#(lazy-positive-numbers 10) ;data generators, can be replaced with actual db calls<br/>      #(lazy-positive-numbers 20)<br/>      #(lazy-positive-numbers 30)]))</span><span id="7d40" class="lk ll hu ml b fv mx mq l mr ms">(defn get-data-from-sources [sourcelist]<br/>  (map #(apply % []) sourcelist))</span><span id="8ad9" class="lk ll hu ml b fv mx mq l mr ms">(defn get-posts [limit]<br/>  (-&gt;&gt;<br/>    (get-data-sources) ;returns seq of data-sources<br/>    (get-data-from-sources) ;returns a lazy-seq of results<br/>    (apply concat) ;concat all lazy-seq before taking<br/>    (take limit)))</span><span id="f746" class="lk ll hu ml b fv mx mq l mr ms">;Executing should call other data sources only after exhausting the current one</span><span id="8f33" class="lk ll hu ml b fv mx mq l mr ms">(get-posts 15)<br/>;executing 10<br/>;executing 20<br/>;executing 30<br/>;executing 11<br/>;executing 12<br/>;executing 13<br/>;executing 14<br/>;executing 15<br/>;executing 16<br/>;executing 17<br/>;executing 18<br/>;executing 19<br/>;executing 20<br/>;executing 21<br/>;executing 21<br/>;executing 22<br/>;executing 23<br/>;executing 24<br/>;(10 11 12 13 14 15 16 17 18 19 20 20 21 22 23)</span></pre><p id="1b99" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">呜哇！想象一下，执行40个调用来检索15个条目，唷。</p><p id="be74" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">第四课——懒惰有利于从不同的来源填充一个序列。</p><p id="c10a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">另一个不明显的重要注意事项是，每个动作都被分解成伪代码中的函数。不用功能就用懒惰会难很多。</p><p id="e956" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">第五课——如果没有功能性，就很难偷懒。</strong></p><h2 id="f958" class="lk ll hu bd lm ln lo lp lq lr ls lt lu kj lv lw lx kn ly lz ma kr mb mc md me dt translated">懒惰有多快？</h2><p id="6974" class="pw-post-body-paragraph ka kb hu kc b kd mf iv kf kg mg iy ki kj mh kl km kn mi kp kq kr mj kt ku kv hn dt translated">懒惰通常给人一种速度慢的感觉。但事实是这样吗？向输出添加一个微小的仪器</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="188f" class="lk ll hu ml b fv mp mq l mr ms">(defn eval-not-lazy []<br/>  (time<br/>    (let [result (take 15 (concat (not-lazy-positive-numbers 10) (not-lazy-positive-numbers 20) (not-lazy-positive-numbers 30)))]<br/>      (println result))))</span><span id="11c6" class="lk ll hu ml b fv mx mq l mr ms">(defn eval-lazy []<br/>  (time<br/>    (let [result (take 15 (concat (lazy-positive-numbers 10) (lazy-positive-numbers 20) (lazy-positive-numbers 30)))]<br/>      (println result))))</span><span id="de14" class="lk ll hu ml b fv mx mq l mr ms">(eval-not-lazy)<br/>;(10 11 12 13 14 15 16 17 18 19 20 20 21 22 23)<br/>;"Elapsed time: 0.571285 msecs"<br/>;nil</span><span id="fec2" class="lk ll hu ml b fv mx mq l mr ms">;(eval-lazy)<br/>;(10 11 12 13 14 15 16 17 18 19 20 20 21 22 23)<br/>;"Elapsed time: 0.415577 msecs"<br/>;nil</span></pre><p id="cf74" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">绝对和非懒版本速度在一个数量级。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/d0ce0b16ba9e0730b3a03db4798b5c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*Y7tygGbyrmcWAj1lVTOZXQ.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Source — imgflip.com</figcaption></figure><p id="28fd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">第六课——懒惰不会对速度产生负面影响，它可以和你一样，甚至更好</strong></p><h2 id="35d3" class="lk ll hu bd lm ln lo lp lq lr ls lt lu kj lv lw lx kn ly lz ma kr mb mc md me dt translated">并发和懒惰</h2><p id="feeb" class="pw-post-body-paragraph ka kb hu kc b kd mf iv kf kg mg iy ki kj mh kl km kn mi kp kq kr mj kt ku kv hn dt translated">现在，让我们看看懒惰对并发执行的反应，以及并发是否甚至可以使用。对于我们的例子，使用<code class="eh mu mv mw ml b">pmap</code>来进行并行执行。(Clojure的乐趣:)。</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="4dd9" class="lk ll hu ml b fv mp mq l mr ms">(defn parallel-get-data-from-sources [sourcelist]<br/>  (pmap #(apply % []) sourcelist))</span><span id="ce4e" class="lk ll hu ml b fv mx mq l mr ms">(defn parallel-get-posts [limit]<br/>  (-&gt;&gt;<br/>    (get-data-sources) ;returns seq of data-sources<br/>    (parallel-get-data-from-sources) ;returns a lazy-seq of results<br/>    (apply concat) ;concat all lazy-seq before taking<br/>    (take limit)))</span><span id="44bc" class="lk ll hu ml b fv mx mq l mr ms">(parallel-get-posts 15)<br/>;executingexecuting  1020<br/><br/>;executing 30<br/>;executing 11<br/>;executing 12<br/>;executing 13<br/>;executing 14<br/>;executing 15<br/>;executing 16<br/>;executing 17<br/>;executing 18<br/>;executing 19<br/>;executing 20<br/>;executing 21<br/>;executing 21<br/>;executing 22<br/>;executing 23<br/>;executing 24<br/>;(10 11 12 13 14 15 16 17 18 19 20 20 21 22 23)</span></pre><p id="568f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">是的，它可以被使用，但是它没有意义，因为我们正在填充一个序列，除非有可以并行发生的初始化。</p><p id="5ecf" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">第七课——并发不影响懒惰，顺序按顺序填充</strong></p><h2 id="9b95" class="lk ll hu bd lm ln lo lp lq lr ls lt lu kj lv lw lx kn ly lz ma kr mb mc md me dt translated">明白了</h2><p id="dbad" class="pw-post-body-paragraph ka kb hu kc b kd mf iv kf kg mg iy ki kj mh kl km kn mi kp kq kr mj kt ku kv hn dt translated">像所有的锤子一样，这是一把为特殊的钉子服务的锤子，理解它什么时候不应该被使用是很好的。许多核心Clojure函数，如<code class="eh mu mv mw ml b">take</code>、<code class="eh mu mv mw ml b">map</code>、<code class="eh mu mv mw ml b">repeat</code>等。返回懒惰序列。在整组表达式都要求值的情况下，懒惰要短路求值全部。</p><p id="4213" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在我们的例子中，短路可以由<code class="eh mu mv mw ml b">doall</code>触发</p><pre class="jk jl jm jn fq mk ml mm mn aw mo dt"><span id="f326" class="lk ll hu ml b fv mp mq l mr ms">(-&gt;&gt;<br/>  (concat<br/>    (lazy-positive-numbers 10)<br/>    (lazy-positive-numbers 20)<br/>    (lazy-positive-numbers 30))<br/>  (doall)<br/>  (take 15))<br/>;executing 10<br/>;executing 20<br/>;executing 30<br/>;executing 11<br/>;executing 12<br/>;executing 13<br/>;executing 14<br/>;executing 15<br/>;executing 16<br/>;executing 17<br/>;executing 18<br/>;executing 19<br/>;executing 20<br/>;executing 21<br/>;executing 21<br/>;executing 22<br/>;executing 23<br/>;executing 24<br/>;executing 25<br/>;executing 26<br/>;executing 27<br/>;executing 28<br/>;executing 29<br/>;executing 30<br/>;executing 31<br/>;executing 31<br/>;executing 32<br/>;executing 33<br/>;executing 34<br/>;executing 35<br/>;executing 36<br/>;executing 37<br/>;executing 38<br/>;executing 39<br/>;executing 40<br/>;executing 41<br/>;(10 11 12 13 14 15 16 17 18 19 20 20 21 22 23)</span></pre><p id="e3bb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果我们错过了<code class="eh mu mv mw ml b">doall</code>，所有的表达将不会被评估。</p><p id="dd9c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">第八课—警惕核心Clojure函数— </strong> <code class="eh mu mv mw ml b"><strong class="kc hv">map != mapv</strong></code> <strong class="kc hv">、</strong> <code class="eh mu mv mw ml b"><strong class="kc hv">filter != filterv </strong></code> <strong class="kc hv">等等</strong></p><p id="594f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">第九课——用</strong> <code class="eh mu mv mw ml b"><strong class="kc hv">doall</strong></code> <strong class="kc hv">短路懒惰，评估所有</strong></p><p id="b103" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">总之，“懒”，你是牛逼的。</p><p id="729f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">上述经验来自Swym公司的一次内部开发/工程讲座。这个演讲对Clojure的功能模式有一个更广泛的概述，我希望在我的下一篇文章中讨论。</p><p id="129f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">特别感谢<a class="na nb gr" href="https://medium.com/u/112fc50018ce?source=post_page-----252ca7fc4fa7--------------------------------" rel="noopener" target="_blank"> Saumitra </a>、<a class="na nb gr" href="https://medium.com/u/f533d3b186c4?source=post_page-----252ca7fc4fa7--------------------------------" rel="noopener" target="_blank"> Supritha </a>和Shivam帮助使这篇文章看起来很好。希望你喜欢阅读它，就像我们喜欢一起破解它一样。请随意发表你的想法。感谢您的评论和问题！:)</p><p id="3235" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">页（page的缩写）也许是最好的东西？不抱歉。有点像“希望”的意思。我没这么说。安迪·杜弗兰说过:)</p><h2 id="64b6" class="lk ll hu bd lm ln lo lp lq lr ls lt lu kj lv lw lx kn ly lz ma kr mb mc md me dt translated">参考</h2><ol class=""><li id="9a30" class="kw kx hu kc b kd mf kg mg kj nc kn nd kr ne kv nf lc ld le dt translated">https://clojuredocs.org/clojure.core/lazy-seq——关于如何写“懒惰的生产者”的大量例子</li><li id="d57c" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" href="https://clojure.org/reference/lazy" rel="noopener ugc nofollow" target="_blank">https://clojure.org/reference/lazy</a></li><li id="22cd" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" href="http://clojure-doc.org/articles/language/laziness.html" rel="noopener ugc nofollow" target="_blank">http://clojure-doc.org/articles/language/laziness.html</a></li><li id="1a47" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" rel="noopener" href="/lazy-eval/lazy-seq-in-clojure-da06f6d35971">https://medium . com/lazy-eval/lazy-seq-in-clo jure-da 06 f6d 35971</a></li><li id="c326" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" href="https://stuartsierra.com/2015/08/25/clojure-donts-lazy-effects" rel="noopener ugc nofollow" target="_blank">https://Stuart Sierra . com/2015/08/25/clo jure-donts-lazy-effects</a></li><li id="d87a" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" href="https://github.com/danielmiladinov/joy-of-clojure/blob/master/src/joy-of-clojure/chapter6/laziness.clj" rel="noopener ugc nofollow" target="_blank">https://github . com/danielmiladinov/joy-of-clo jure/blob/master/src/joy-of-clo jure/chapter 6/lazy . clj</a></li><li id="3d4a" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" href="https://noobtuts.com/clojure/being-lazy-in-clojure" rel="noopener ugc nofollow" target="_blank">https://noobtuts.com/clojure/being-lazy-in-clojure</a></li><li id="f7c6" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" href="https://practicalli.github.io/clojure/thinking-functionally/lazy-evaluation.html" rel="noopener ugc nofollow" target="_blank">https://practical Li . github . io/clo jure/thinking-functional/lazy-evaluation . html</a></li><li id="30d2" class="kw kx hu kc b kd lf kg lg kj lh kn li kr lj kv nf lc ld le dt translated"><a class="ae jz" href="http://www.thesoftwaresimpleton.com/blog/2014/09/08/lazy-seq/" rel="noopener ugc nofollow" target="_blank">http://www . thesoftware simpleton . com/blog/2014/09/08/lazy-seq/</a></li></ol><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>