<html>
<head>
<title>Checklist for Writing Highly Reusable Components in React and Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React和Vue中编写高度可重用组件的清单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/checklist-for-writing-highly-reusable-components-in-react-and-vue-531f963864bd?source=collection_archive---------1-----------------------#2018-08-14">https://medium.com/hackernoon/checklist-for-writing-highly-reusable-components-in-react-and-vue-531f963864bd?source=collection_archive---------1-----------------------#2018-08-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ae44056d874eebbf3e5ea7dd57298bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N5vG6PgPa7noEPW-"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/@krisguico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kris Guico</a> on <a class="ae ih" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="9b66" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有如此多的最佳实践和先进的<em class="kf"> </em>模式——问题是在开发新的组件时要跟踪它们并牢记在心。</p><p id="2825" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我写这个清单是为了帮助自己记住在构建高度可重用组件的过程中需要考虑的所有事情。</p><p id="bdb6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这份清单同样适用于<strong class="jj il">Vue和React。</strong></p><p id="1d7d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">真的，你用哪个框架都没关系，因为<strong class="jj il">T5【组件组合】T6的原理完全一样</strong>。设计组件的一般过程也没有改变。</p><p id="2c6f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj il">帖子最后的浓缩清单。</strong></p><h1 id="7085" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">避免猜测性的笼统</h1><p id="33bd" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">这听起来很明显，但我发现自己总是忘记这一点。</p><p id="8b35" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你需要完全理解<em class="kf">你的</em>用例，并且只实现它。如果你不先思考就一头扎进代码，你最终会写出一堆永远不会用到的特性。那是对你宝贵时间的巨大浪费。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="e62b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当编写一个应该在许多不同用例中重用的组件时，提供越来越多抽象的诱惑更容易被证明是正当的。</p><p id="ba58" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，如果你把组件写得很好，以后回来添加你不能预料的新用例应该是相当容易的。</p><p id="7df4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是<strong class="jj il"> 80/20思维</strong>派上用场的地方。您实现的一些特性将负责处理大多数用例。关注那些。</p><p id="e611" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我将留给你最后一条关于API设计的推文:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="9dad" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">简化API</h1><p id="968a" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">现在我们已经停下来思考了，让我们尽可能地简化我们的API。</p><p id="5c94" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您还试图在简单性和灵活性之间找到最佳平衡点。正如<a class="ae ih" href="https://twitter.com/ken_wheeler" rel="noopener ugc nofollow" target="_blank">肯·惠勒</a>在<a class="ae ih" rel="noopener" href="/codezillas/a-bitter-guide-to-open-source-a8e3b6a3c1c4">开源的苦涩指南</a>中所说:</p><blockquote class="lp"><p id="febe" class="lq lr ik bd ls lt lu lv lw lx ly ke ek translated">您希望在开箱即用和按需配置之间找到完美的平衡。最重要的是，你要保持事情清晰，明确和平易近人。不要太聪明，否则你会惹恼所有人。</p></blockquote><p id="bce1" class="pw-post-body-paragraph jh ji ik jj b jk lz jm jn jo ma jq jr js mb ju jv jw mc jy jz ka md kc kd ke hn dt translated">太简单了，而且没有涵盖足够多有用的用例。太灵活了，理解如何做任何事情都变得太难了。</p><p id="f996" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">看看这个<a class="ae ih" href="http://api.jqueryui.com/datepicker/" rel="noopener ugc nofollow" target="_blank"> jQuery Datepicker </a>有多少选项。太恐怖了！</p><p id="6d51" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是更高级的合成模式真正派上用场的地方。</p><p id="a2aa" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，您会在简单性和灵活性之间进行权衡。但是像<strong class="jj il">渲染道具</strong>和<strong class="jj il">复合组件</strong>这样的技术可以让你在降低复杂度的同时获得<strong class="jj il">更多的灵活性。</strong></p><h1 id="47f7" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">研究现有技术</h1><p id="caca" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我们对我们现在正在建造的东西有一个很好的想法，但是首先我们需要看看外面还有什么。</p><p id="4148" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这有几个原因:</p><p id="20d6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们可以<strong class="jj il">为我们的实现获得伟大的想法</strong>。</p><p id="8f87" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们看看成熟的开源项目，它们或多或少会有一些完整的特性。这让我们再次检查我们可能需要构建的假设。</p><p id="4ba3" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还可以看到API是如何构建的，使用了哪些抽象，甚至可能看到一些我们没有考虑到的实现细节。</p><p id="f3f2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第二，我们有可能为自己节省一些工作。</p><p id="7cc3" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们很有可能会找到一些可以用来加速开发的东西。我们甚至可能找到符合我们所有需求的东西，并最终缩短整个过程。</p><p id="ed85" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在他的<a class="ae ih" href="https://courses.totalreact.com/p/advanced-react-free" rel="noopener ugc nofollow" target="_blank">高级React.js课程</a>中，<a class="ae ih" href="https://twitter.com/ryanflorence" rel="noopener ugc nofollow" target="_blank"> Ryan Florence </a>提到他喜欢检查jQuery插件。它们经受住了时间的考验，并且很可能拥有你曾经考虑放入UI元素的所有特性。</p><p id="f110" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个很好的起点是在令人敬畏的repos:</p><ul class=""><li id="cb51" class="me mf ik jj b jk jl jo jp js mg jw mh ka mi ke mj mk ml mm dt translated"><a class="ae ih" href="https://github.com/enaqx/awesome-react" rel="noopener ugc nofollow" target="_blank">牛逼-反应</a></li><li id="82d9" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated"><a class="ae ih" href="https://github.com/vuejs/awesome-vue" rel="noopener ugc nofollow" target="_blank"> Awesome-Vue </a></li></ul><h1 id="e0ca" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">将组件分成小块</h1><p id="d067" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">组合框架使用组件作为其主要的抽象技术(相对于面向对象中的对象或函数式编程中的函数)。</p><p id="0261" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你把所有东西都塞进一个或两个巨大的组件中，你根本没有利用这一点！</p><p id="a1a0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">组件越小越好:</p><ul class=""><li id="441f" class="me mf ik jj b jk jl jo jp js mg jw mh ka mi ke mj mk ml mm dt translated">更好的抽象使你的代码更干净，更容易理解，更容易维护</li><li id="e155" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">鼓励代码的可重用性</li><li id="f85f" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">必要为了使用更多的<strong class="jj il">先进的</strong>花裤构图技术</li></ul><p id="f2cc" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">考虑拆分组件有两种主要方法:</p><h2 id="5deb" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated"><strong class="ak">从展示中分离行为</strong></h2><p id="e61a" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在一个组件中有状态和逻辑，有一个独立的组件负责呈现。我们通常通过渲染道具和无状态功能组件来实现。</p><h2 id="dd32" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">抽象层次</h2><p id="3b7c" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在一个组件中保持抽象层次的一致性通常是一个好主意。组件要么处理原生DOM元素，如<code class="eh ng nh ni nj b">div</code>、<code class="eh ng nh ni nj b">p</code>、<code class="eh ng nh ni nj b">span</code>，要么处理框架组件。</p><p id="9628" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只是要小心，因为你不想走极端，创建太多组件<strong class="jj il"/>！肯特·c·多兹(Kent c . Dodds)有一篇关于<a class="ae ih" href="https://blog.kentcdodds.com/when-to-break-up-a-component-into-multiple-components-4ee75ab53bbc" rel="noopener ugc nofollow" target="_blank">如何知道什么时候事情应该被分开</a>的很棒的文章。</p><h1 id="75b9" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">只在需要的地方使用强大的合成模式</h1><p id="baf2" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">渲染道具，提供者模式，高阶组件。这些模式很诱人，用起来也很有趣。</p><p id="cef8" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是它们并不总是这项工作的合适工具。知道何时最大限度地利用每一种方法是很重要的。否则<strong class="jj il">您可能会使用错误的工具</strong>来完成工作，并把自己挖成一个洞。</p><p id="7b5b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想了解更多，我强烈建议看看Kent C. Dodd关于React中的高级模式的文章:</p><h2 id="e075" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">复合组件</h2><p id="e561" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">将组件的各个部分分解成更小的部分，可以用不同的方式重新组合。</p><p id="5656" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，把你的<code class="eh ng nh ni nj b">Table</code>组件分解成<code class="eh ng nh ni nj b">TableHeader</code>、<code class="eh ng nh ni nj b">TableBody</code>和<code class="eh ng nh ni nj b">TableFooter</code>组件。大多数人使用常规的<code class="eh ng nh ni nj b">Table</code>都没问题，但是现在有人可以构建自己的表格，并为其构建自定义标题，而不会太麻烦。</p><h2 id="dd29" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">高阶组件</h2><p id="f8ce" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">将一个组件包装在另一个组件中，为其添加功能。这个概念是从mixin的面向对象思想发展而来的，但已经在很大程度上取代了它(尽管Vue仍然支持mixin)。</p><p id="67c7" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当React第一次出现时，mixins给了开发人员一个出口，允许他们回到面向对象世界中熟悉的地方。</p><p id="ee6e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">过了一段时间，我们发现<a class="ae ih" rel="noopener" href="/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750">合成比</a>遗传好得多，所以更高阶的成分成为了标准。</p><h2 id="19bc" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">渲染道具和无渲染组件</h2><p id="0408" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">现在我们看到了另一个转变。这一次远离更高级的组件，并朝向所谓的<em class="kf">渲染道具</em>(或<em class="kf">作为子功能)。</em></p><p id="2ce7" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">渲染道具让我们<strong class="jj il">将渲染</strong>委托给父组件，让我们在行为和表现之间有更清晰的分离。如果将这种模式与prop getters和setters模式结合起来，就可以用很少几行代码构建出极其灵活和富有表现力的组件。</p><h2 id="ed96" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">受控和非受控道具</h2><p id="843a" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">是组件控制状态，还是它的父组件控制状态？这就是不受控制的和受控制的道具之间的区别。</p><p id="608b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，使用不受控制的道具，因为它们允许我们将复杂性和状态封装在组件中。然而，如果你想要更多的灵活性——这是我们在编写一个高度可重用的组件时所需要的——你可以允许一个道具由父级来控制。</p><h2 id="5da4" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">状态缩减器</h2><p id="c816" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">这是我从肯特·c·多兹的项目<a class="ae ih" href="https://github.com/paypal/downshift" rel="noopener ugc nofollow" target="_blank">降档</a> ( <a class="ae ih" href="https://blog.kentcdodds.com/when-to-use-control-props-or-state-reducers-6cd83e42c5b" rel="noopener ugc nofollow" target="_blank">这里有更多解释</a>)中学到的模式。</p><p id="3177" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你要暴露一个要控制的道具，为什么不暴露整个状态缩减器呢？然后<strong class="jj il">你可以对组件的行为进行非常细粒度的控制</strong>——但是你不需要重写任何逻辑。</p><p id="d9d4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">太棒了。</p><h2 id="48ff" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">提供商模式</h2><p id="6b72" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">如果你用过Redux或者VueX或者类似的东西，你大概知道这个模式。</p><p id="e2e0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你只需简单地将它们“注入”到需要它们的地方，而不是整天把道具传来传去，并通过许多许多层次的组件传递下去。</p><p id="0f38" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在React中，这可以通过使用上下文或<a class="ae ih" href="https://vuejs.org/v2/api/#provide-inject" rel="noopener ugc nofollow" target="_blank">在Vue中提供和注入</a>来完成<a class="ae ih" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b795" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">可访问性不是事后才想到的</h1><p id="e5c5" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我还不太擅长无障碍。</p><p id="14f2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不过，这是我最近越来越擅长的事情，因为我相信<strong class="jj il">让网络变得更好</strong>非常重要。</p><p id="036d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我不是这方面的专家，所以我会让你读一读Addy Osmani写的这篇文章。您还可以查看A11Y项目的大量资源。</p><div class="ht hu fm fo hv nk"><a rel="noopener follow" target="_blank" href="/@addyosmani/accessible-ui-components-for-the-web-39e727101a67"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd il fv z el np eo ep nq er et ij dt translated">Web的可访问用户界面组件</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">为了便于访问，UI组件需要在不同屏幕尺寸和不同种类的设备上工作</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ib nk"/></div></div></a></div><h1 id="fcb3" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">让造型变得简单</h1><p id="37d5" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">对于消费者来说，按照他们需要的方式来设计你的组件有多容易？</p><p id="779a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其目的是您的组件将被广泛使用。在各种各样的环境中。它将会被用在你做梦都想不到的地方。</p><p id="778d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您需要确保其他开发人员可以轻松地设计和更改组件的布局，而无需求助于难看的CSS覆盖。</p><p id="bfce" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">无渲染组件使这变得非常简单。你可以<strong class="jj il">将所有渲染</strong>委托给任何使用你组件的人。</p><p id="71ea" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，在许多情况下，默认渲染是有用的。这里一个好的方法是<a class="ae ih" rel="noopener" href="/@GarrettLevine/react-components-b-e-m-168f199f35b">在你的组件中使用BEM</a>并提供容易被覆盖的CSS类。</p><h2 id="bb16" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">但是CSS不是图灵完整的！</h2><p id="ab42" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">或者，你可以采用<strong class="jj il">酷孩子的方法</strong>并使用CSS-in-JS(它并不适合所有人)。</p><p id="1532" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当这个想法开始时，大多数库都是使用内联样式实现的。这导致了一些性能问题和其他一些问题。</p><p id="05e2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如今，大多数库都是通过将样式表动态附加到DOM上来工作的，最大的问题已经解决了。我已经有一段时间没有机会深入研究这些了，但是它在我的清单上！</p><p id="6ef6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想了解更多，有大量的图书馆、讲座和文章，但是这里的<a class="ae ih" href="https://hackernoon.com/all-you-need-to-know-about-css-in-js-984a72d48ebc" rel="noopener ugc nofollow" target="_blank">是React </a>和Vue 的好起点。</p><h1 id="1630" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">你测试过吗，兄弟？</h1><p id="2a42" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">你不希望有成千上万的人使用你漂亮的新组件，只是让它在边缘情况下剥落。或者上帝禁止你添加一个漂亮的新功能——但它打破了其他一切。</p><p id="a52e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当你像这样构建一个可重用的组件时，你可能不会做任何集成或者端到端的测试。您将编写<strong class="jj il">单元测试</strong>，重点测试复杂的逻辑并确保组件正确呈现。</p><p id="3f67" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您需要开始，这里有一些关于测试React和Vue组件的好文章:</p><div class="ht hu fm fo hv nk"><a href="https://www.fullstackreact.com/30-days-of-react/day-22/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd il fv z el np eo ep nq er et ij dt translated">Fullstack React:测试简介</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">测试套件是一种前期投资，在系统的生命周期中会有回报。今天我们要介绍的话题是…</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">www.fullstackreact.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny ib nk"/></div></div></a></div><div class="ht hu fm fo hv nk"><a href="https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing-Tools-and-Jest/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd il fv z el np eo ep nq er et ij dt translated">使用官方Vue测试工具和Jest对Vue.js组件进行单元测试| Alex Jover Morales</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">Vue.js已经成为年度框架。它非常灵活，高性能，易于学习，导致大量的…</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">alexjoverm.github.io</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny ib nk"/></div></div></a></div><h1 id="647e" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">文档——这是最重要的</h1><p id="1cf8" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">“我以后再写文档”，当你向Github提交最后一个漂亮的提交时，你这样想。“我的意思是，即使我不去做这件事，也没有人会真的关心这件事。”</p><p id="5742" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">毕竟，你是用Javascrip   <em class="kf"> t </em>语言写作的专家，而不是人类所说的这些<a class="ae ih" href="https://hackernoon.com/tagged/natural" rel="noopener ugc nofollow" target="_blank">自然</a>语言中的一种。</p><p id="3e0e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是好的文档是把好的组件变成好的组件的关键。</p><p id="8c2f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当你试图弄清楚如何让一个库做一些事情，或者你对React(或Vue)的生命周期方法感到困惑时，你知道这种感觉。如果不能很快找到答案，那就超级沮丧。</p><p id="32bb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有时你甚至会放弃这个库，因为<strong class="jj il">你不知道</strong>如何让它工作！</p><p id="180e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要因为缺少好的文档而让你闪亮的全新组件浪费掉。</p></div><div class="ab cl ob oc hc od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hn ho hp hq hr"><h1 id="0eee" class="kg kh ik bd ki kj oi kl km kn oj kp kq kr ok kt ku kv ol kx ky kz om lb lc ld dt translated">简明清单</h1><p id="cf51" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">现在我们已经了解了所有这些，下面是易于参考的版本:</p><h2 id="2c1f" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">避免猜测性的笼统</h2><h2 id="8af7" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">简化API</h2><h2 id="9430" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">研究现有技术</h2><h2 id="bf7b" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">将组件分成小块</h2><ul class=""><li id="5635" class="me mf ik jj b jk le jo lf js on jw oo ka op ke mj mk ml mm dt translated">将状态+行为与表现分开</li><li id="5a25" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">按抽象层次划分</li></ul><h2 id="a7b2" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">只在需要的地方使用强大的合成模式</h2><ul class=""><li id="a76e" class="me mf ik jj b jk le jo lf js on jw oo ka op ke mj mk ml mm dt translated">复合组件</li><li id="112d" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">高阶组件</li><li id="0c2d" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">渲染道具和无渲染组件</li><li id="138d" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">受控/非受控道具</li><li id="1e44" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">状态缩减器</li><li id="dcf1" class="me mf ik jj b jk mn jo mo js mp jw mq ka mr ke mj mk ml mm dt translated">提供商模式</li></ul><h2 id="40b5" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">可访问性不是事后才想到的</h2><h2 id="60ff" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">让造型变得简单</h2><h2 id="61c3" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">你测试过吗，兄弟？</h2><h2 id="c19f" class="ms kh ik bd ki mt mu mv km mw mx my kq js mz na ku jw nb nc ky ka nd ne lc nf dt translated">文档——这是最重要的</h2></div><div class="ab cl ob oc hc od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hn ho hp hq hr"><p id="7d5c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">我的文章一出来就在</em><a class="ae ih" href="http://michaelnthiessen.com" rel="noopener ugc nofollow" target="_blank"><em class="kf">michaelnthiessen.com</em></a><em class="kf">看看吧！几个星期后，我把它们重新贴在这里。</em></p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="oq lo l"/></div></figure></div></div>    
</body>
</html>