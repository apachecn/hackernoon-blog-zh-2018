<html>
<head>
<title>DApp Infrastructure Design (Part I): Reliable Ethereum Event Tracking with Kubernetes, Docker, and Parity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DApp基础设施设计(第一部分):使用Kubernetes、Docker和奇偶校验进行可靠的以太坊事件跟踪</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ethereum-dapp-infrastructure-2b4f1e6bfa38?source=collection_archive---------6-----------------------#2018-08-14">https://medium.com/hackernoon/ethereum-dapp-infrastructure-2b4f1e6bfa38?source=collection_archive---------6-----------------------#2018-08-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/adab12a50f0c56ac975abce92a3b37b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xg0rrwznNbGSqb5hKs3aQ.jpeg"/></div></div></figure><p id="cc6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">学习可靠性和编写智能合同相对容易，但我们发现更难的技术挑战是设计一个安全、可扩展、快速的后端基础设施<a class="ae kb" href="https://hackernoon.com/tagged/dapp" rel="noopener ugc nofollow" target="_blank"><em class="ka">【DApp】</em></a><em class="ka">。与传统应用不同，DApps依赖于</em> <a class="ae kb" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank"> <em class="ka">区块链</em> </a> <em class="ka">状态的固有概率性质，并利用相对较新且正在积极开发中的以太坊组件。这是关于架构模式和实践的系列文章的第一部分，我们学到的这些可能对其他DApp开发人员有益。</em></p><p id="8709" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt kc translated">对于任何在以太坊上开发DApps的人来说，最早的经验之一就是在智能合约中记录事件是一种报告状态变化和跟踪所执行操作的有效方式。由于事件在区块链上发出并可以重放，同时从技术上讲不会存储在昂贵的区块链状态(即内存或存储)中，因此它们是“存储”区块链数据的一种经济高效的变通方法。事件也是实时发出的，允许实时发现和报告操作。</p><figure class="km kn ko kp fq iv fe ff paragraph-image"><div class="fe ff kl"><img src="../Images/726dd1723cd0f059a17c953e5e0a51fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/0*-8KzLW6P1NUzJe6p.gif"/></div></figure><blockquote class="kq"><p id="8016" class="kr ks hu bd kt ku kv kw kx ky kz jz ek translated">事件听起来很棒！大家都要用事件！</p></blockquote><p id="d95a" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">等等，不要这么快…DApp开发者的另一个早期的、可能是痛苦的教训是，事件观察是不可靠的:<strong class="je hv">只有当你的DApp在需要时检测到它，事件才是有用的</strong>。<strong class="je hv"> </strong>如果您需要实时数据，但事件发现被延迟或事件被完全错过，这可能会导致用户体验不佳或完全DApp失败。</p><blockquote class="lf lg lh"><p id="f692" class="jc jd ka je b jf jg jh ji jj jk jl jm li jo jp jq lj js jt ju lk jw jx jy jz hn dt translated">我们的解决方案:需要可靠事件跟踪的DApp开发者应该考虑将Kubernetes/Docker添加到他们的工具包中。虽然这些技术确实有一点学习曲线，但它们巧妙地解决了当前以太坊技术生态系统中非常具体的问题，主要源于可靠性。</p></blockquote></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="0379" class="ls lt hu bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp dt translated"><strong class="ak">当前以太坊基础设施技术的问题</strong></h1><figure class="km kn ko kp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/e4ed68a0851393662c32caa6f04a5138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1Y940vVl27alNKggL8Wog.png"/></div></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek">CoinAlpha Node Monitor</figcaption></figure><p id="7a64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae kb" href="https://coinalpha.com" rel="noopener ugc nofollow" target="_blank"> CoinAlpha </a>，我们已经对以太坊基础设施和可靠性进行了大量的实验和研究，以支持我们的产品。除了运行我们自己的本地节点之外，我们一直在使用不同的云提供商，如AWS、Google Cloud和Digital Ocean来托管节点。我们设置了节点监视器，允许我们跟踪节点性能和可靠性，如示例屏幕截图所示。</p><p id="cf4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们的项目需要尽可能接近实时的事件跟踪，我们不得不提出解决方案来解决以太坊基础设施的当前问题:</p><ol class=""><li id="b4b5" class="mv mw hu je b jf jg jj jk jn mx jr my jv mz jz na nb nc nd dt translated"><strong class="je hv">以太坊节点不断丢弃对等点</strong>:由于多种原因，以太坊节点会周期性地出现故障；他们要么停止同步，要么落后，无法获得最新的区块链信息。造成这种情况的主要原因是对等点数量的<strong class="je hv">下降，这对任何节点来说都是死亡之吻。对等点数量随时可能下降，通常是因为节点卡在已经重组的“坏”块上，或者在侧链上结束。以太坊节点像流行的儿童桌一样工作；如果您的节点在一个坏块上结束，您的节点会被列入黑名单或被感染，所有对等节点都会试图丢弃它并阻止它重新连接。</strong></li><li id="7760" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz na nb nc nd dt translated"><strong class="je hv"> Infura websockets不可靠</strong>:几个月前，<a class="ae kb" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"> Infura </a>发布了支持事件跟踪的websockets连接能力。这为开发人员提供了跟踪事件的能力，而不必运行他们自己的节点。虽然这相对于完全不支持事件的<a class="ae kb" href="https://ethereum.stackexchange.com/questions/25451/infura-web3-provider-for-events-get-watch" rel="noopener ugc nofollow" target="_blank">来说是一个实质性的改进，但它仍然不是一个完美的解决方案。Infura的web sockets不能保持持续的连接，每隔几分钟就会掉线。任何使用过第一版</a><a class="ae kb" href="https://github.com/AugurProject/augur-app" rel="noopener ugc nofollow" target="_blank">auger桌面客户端</a>的人都可能注意到了这种效果，该客户端使用Infura来构建和维护一个与auger相关的事件的数据库。</li><li id="35af" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz na nb nc nd dt translated"><strong class="je hv">使用</strong> <code class="eh nj nk nl nm b"><strong class="je hv">watch()</strong></code> <strong class="je hv">观看实时事件可能会错过事件</strong>:节点在同步时会定期落后几个块。其中一个主要原因是硬盘的读/写速度。支付高速SSD驱动器是一个可能的缓解措施，但随着当前以太坊mainnet数据库超过100GB，云托管账单开始迅速滚雪球。此外，这仍然没有解决对等掉线问题。如果您的节点落后，然后进行同步追赶，我们发现现场活动可能会被错过。</li></ol></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><h1 id="a7e9" class="ls lt hu bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp dt translated">解决方案:冗余和监控</h1><p id="3adf" class="pw-post-body-paragraph jc jd hu je b jf nn jh ji jj no jl jm jn np jp jq jr nq jt ju jv nr jx jy jz hn dt translated">容错以太坊事件监视系统可以检测故障，进行分类，并继续运行，就像什么都没发生一样。我们是这样设计的:</p><ol class=""><li id="12a4" class="mv mw hu je b jf jg jj jk jn mx jr my jv mz jz na nb nc nd dt translated"><strong class="je hv">节点冗余</strong>:我们运行多个以太坊节点，每个节点都连接有事件跟踪器，以便在单个或多个节点出现故障/延迟时提供冗余。</li><li id="ad03" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz na nb nc nd dt translated"><strong class="je hv">事件重放</strong>:由于实时事件跟踪不可靠，我们循环我们的事件观察器来重放事件，并在节点之间错开重放时间。为了提高效率，我们菊花链重放；我们在每次重放时记下当前的块号，以便随后的重放将仅从先前的当前块号开始重放。</li><li id="1897" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz na nb nc nd dt translated"><strong class="je hv">事件聚合器</strong>:我们的事件观察器向集中的事件聚合器报告事件。我们的事件聚合器跟踪它已经看到的事件，并将新发现的独特事件分派给我们需要处理该事件的不同服务。</li></ol><p id="a544" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">结果是我们有了一个如下所示的体系结构，下面是对组件的附加讨论:</p><figure class="km kn ko kp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7b9ba058b7923c8c48563c52995fa5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcq6VQm97dTfAf3bNC4lqQ.jpeg"/></div></div><figcaption class="mr ms fg fe ff mt mu bd b be z ek">Ethereum event watcher architecture with Kubernetes and Docker</figcaption></figure></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><blockquote class="lf lg lh"><p id="7f4d" class="jc jd ka je b jf jg jh ji jj jk jl jm li jo jp jq lj js jt ju lk jw jx jy jz hn dt translated"><strong class="je hv">下面是对我们一些架构选择的一些解释和讨论。</strong>还有一些我们喜欢的Kubernetes很酷的地方。我知道有很多方法可以解决我提出的问题。如果您有任何意见、问题或建议，您可以通过我们的<a class="ae kb" href="https://t.me/cryptobaskets" rel="noopener ugc nofollow" target="_blank">密码电报组</a>或<a class="ae kb" href="mailto:dev@coinalpha.com" rel="noopener ugc nofollow" target="_blank">发送电子邮件</a>联系我们的团队。</p></blockquote><h2 id="5405" class="ns lt hu bd lu nt nu nv ly nw nx ny mc jn nz oa mg jr ob oc mk jv od oe mo of dt translated">为什么要Dockerize？</h2><p id="43e3" class="pw-post-body-paragraph jc jd hu je b jf nn jh ji jj no jl jm jn np jp jq jr nq jt ju jv nr jx jy jz hn dt translated">对于我们的应用程序来说，使用docker的好处是，我们只需启动可以链接到我们的奇偶校验实例的新容器，就可以添加需要访问区块链的额外服务。每个容器独立运行，因此更改、添加和升级都可以在不中断任何其他现有运行容器/服务的情况下完成。</p><p id="e6e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，我们只有三个容器连接到奇偶校验数据:(1)节点监视器，(App 1的事件监视器，以及(App 2的事件监视器。但是当我们的需求改变时，我们可以很容易地添加更多的容器。</p><h2 id="7325" class="ns lt hu bd lu nt nu nv ly nw nx ny mc jn nz oa mg jr ob oc mk jv od oe mo of dt translated">为什么是Kubernetes？</h2><p id="70d3" class="pw-post-body-paragraph jc jd hu je b jf nn jh ji jj no jl jm jn np jp jq jr nq jt ju jv nr jx jy jz hn dt translated">管理多个节点集群(以太坊客户端和它们连接的服务)会变得非常复杂和混乱。不仅存在多个相互链接和依赖的服务，更新和维护配置以及管理机密(如API密钥)也需要协调，并且会产生潜在的安全漏洞。此外，在越来越大的系统中，监视服务器和服务的故障并重启故障容器会变得很有挑战性。这就是Kubernetes的用武之地；它处理所有这些问题。</p><p id="2d44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是我们认为特别有用的一些功能:</p><ul class=""><li id="fb6a" class="mv mw hu je b jf jg jj jk jn mx jr my jv mz jz og nb nc nd dt translated"><strong class="je hv">副本/扩展</strong> : Kubernetes非常适合冗余，因为它内置了可扩展性。默认情况下，您可以自动复制节点集群(以太坊客户端及其附属服务)，或者通过单个命令行指令进行复制。不需要单独配置每个集群。</li><li id="c3e8" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz og nb nc nd dt translated"><strong class="je hv">添加新服务</strong>:通过向Kubernetes部署或有状态集添加容器，您可以简单地添加需要访问以太坊节点的新服务或跟踪器。</li><li id="89d4" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz og nb nc nd dt translated"><strong class="je hv">具有状态集的持久卷</strong> : Docker容器本质上是短暂的。对于同步Ethereum节点，您并不真的希望每次节点出现故障并且必须重启时都同步100GB以上的数据库。Kubernetes允许您创建持久卷，这是一个维护其数据和状态的独立数据存储。如果您的以太坊客户端重新启动，它将重新连接到永久卷，并从上次停止的地方恢复。</li><li id="78e8" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz og nb nc nd dt translated"><strong class="je hv">安全性</strong>:使用Kubernetes的秘密是存储API密匙和任何其他敏感数据的一种简洁方式。敏感数据仅在秘密创建时暴露；一旦它创造了一个秘密，它就被加密了。然后，可以将这些机密作为一个卷安装到任何需要访问它的容器中；不需要重新共享原始的未加密数据。</li><li id="210d" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz og nb nc nd dt translated"><strong class="je hv"> IPC连接用于增加安全性和访问控制</strong>:通过将服务聚集在一起并提供对共享卷(如持久卷)的每次访问，需要连接到奇偶校验的服务可以通过集群的文件系统经由IPC ( <a class="ae kb" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener ugc nofollow" target="_blank">进程间通信</a>)来访问它。这有助于防止对以太坊客户端的未授权访问，从而增加了安全性。默认情况下，大多数开发人员会通过互联网<em class="ka">使用RPC ( <a class="ae kb" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank">远程过程调用</a> ) http连接<em class="ka"> web3.httpProvider() </em>来连接web3提供者。</em>与通过IPC的连接不同，RPC连接可能会对公众和互联网开放，从而产生未经授权的用户发现并连接到您的RPC web3提供程序的风险，并使您的客户端超载。最坏的情况是，通过RPC web3从internet连接的人将能够从任何可能被无意中解锁的帐户发送交易。</li><li id="30e2" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz og nb nc nd dt translated"><strong class="je hv">活性和准备就绪探测器</strong> : Kubernetes允许您创建监视器，用于重启或使出现故障或尚未准备就绪的pod退出服务。例如，如果以太坊客户端尚未完全同步，您可以使用就绪探测器来阻止它接受任何传入的连接。</li><li id="1338" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz og nb nc nd dt translated"><strong class="je hv">实时、滚动更新/无停机时间</strong>:当部署实时应用程序的更新时，kubernetes在销毁旧的、现有的pod之前，巧妙地创建了新的<strong class="je hv">pod</strong>。当新的吊舱正在被制造和准备时(等待<em class="ka">号准备就绪</em>号探测器)，现有的吊舱仍在服役。只有更新的吊舱准备好并投入使用，旧的吊舱才会被销毁。</li><li id="88e9" class="mv mw hu je b jf ne jj nf jn ng jr nh jv ni jz og nb nc nd dt translated"><strong class="je hv"> Nginx入口控制器</strong> : Kubernetes允许在Nginx入口控制器上进行设置，将流量定向到集群上的不同服务，这些服务通过使用的URL地址进行路由。在您的域管理器中，您只需将所有子域定向到您的入口地址，这样您就不必在服务器的IP地址发生变化时单独管理每个子域。nginx入口控制器还管理https路由和TLS证书。在DApp生态系统中，这也可以应用于为前端应用程序创建web3提供商。默认情况下，以太坊客户端只提供不安全的http连接。</li></ul><h2 id="2439" class="ns lt hu bd lu nt nu nv ly nw nx ny mc jn nz oa mg jr ob oc mk jv od oe mo of dt translated">奇偶校验与Geth</h2><p id="9424" class="pw-post-body-paragraph jc jd hu je b jf nn jh ji jj no jl jm jn np jp jq jr nq jt ju jv nr jx jy jz hn dt translated">尽管该公司之前有过失误(<a class="ae kb" href="https://paritytech.io/the-multi-sig-hack-a-postmortem/" rel="noopener ugc nofollow" target="_blank">多签名黑客</a>、<a class="ae kb" href="https://paritytech.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/" rel="noopener ugc nofollow" target="_blank">库黑客</a>)，但奇偶校验的一个优点是他们创造了一个可靠的以太坊客户端(好吧……让我们暂时忽略<a class="ae kb" href="https://paritytech.io/parity-ethereum-client-issue-report/" rel="noopener ugc nofollow" target="_blank">共识漏洞</a>)。虽然大多数开发人员开始使用Ethereum " <a class="ae kb" href="https://github.com/ethereum/go-ethereum/wiki/geth" rel="noopener ugc nofollow" target="_blank"> Geth </a>"的Go实现，但快速的google/stack exchange搜索将揭示同步Geth的许多挫折和问题。我们发现，在实践中，Geth节点需要更长的时间来同步，并且比奇偶校验节点更容易落后(您甚至可以在上面的节点监视器仪表板截图中看到这一点)。另一方面，我们发现奇偶校验节点将从头开始同步，并在几小时到一天内可供使用。</p><p id="e403" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为相对较新的技术，像奇偶校验和Geth这样的以太坊客户端一直在更新和改进，这就是为什么我们维护这两种类型的节点。</p><h1 id="1c5b" class="ls lt hu bd lu lv oh lx ly lz oi mb mc md oj mf mg mh ok mj mk ml ol mn mo mp dt translated">结论</h1><p id="64de" class="pw-post-body-paragraph jc jd hu je b jf nn jh ji jj no jl jm jn np jp jq jr nq jt ju jv nr jx jy jz hn dt translated">分散式应用有一个光明的未来，但是考虑到对它们来说技术栈的不成熟，大量的后端工作是必要的，以使它们感觉像集中式web和移动应用一样响应迅速和可靠。幸运的是，我们发现一种谨慎、有意识的架构设计方法使这变得可行，我们将在未来发布关于其他重要方面的帖子，如安全性。</p><figure class="km kn ko kp fq iv"><div class="bz el l di"><div class="om on l"/></div></figure></div></div>    
</body>
</html>