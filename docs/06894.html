<html>
<head>
<title>Creating a Chrome extension in 2018: The good, the bad and the meh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在2018年创建一个Chrome扩展:好的，坏的和不好的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh-8efcf6d28322?source=collection_archive---------7-----------------------#2018-08-16">https://medium.com/hackernoon/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh-8efcf6d28322?source=collection_archive---------7-----------------------#2018-08-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/73db658f63db83606bea70b3f897d988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yhGcZiRd8ikc-Ccv.jpg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“Actors as Construction Workers” by Utagawa Kunisada (1860) — <a class="ae jg" href="https://www.mfa.org/collections/object/a-roof-raising-ceremony-on-an-auspicious-day-kisshin-medetai-muneage-no-zu-actors-sawamura-tanosuke-iii-nakamura-shikan-iv-r-kawarazaki-gonj%C3%BBr%C3%B4-i-ichikawa-kodanji-iv-c-ichikawa-ichiz%C3%B4-iii-and-onoe-baik%C3%B4-45-later-jitsukawa-enjaku-i-l" rel="noopener ugc nofollow" target="_blank">Museum of Fine Arts, Boston.</a></figcaption></figure><p id="77bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上周，我们发布了<a class="ae jg" href="https://chrome.google.com/webstore/detail/puppeteer-recorder/djeegiggegleadkkbgopoonhjimgehda" rel="noopener ugc nofollow" target="_blank">木偶记录器</a>的初始版本，这是一个谷歌Chrome扩展，记录你的浏览器交互并生成木偶脚本。</p><p id="64d0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">事实证明，Chrome扩展开发<em class="kf">几乎</em>像真正的web开发，但是混合了一点奇怪的准嵌入式开发。</p><p id="ff5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章向您介绍了创建扩展时的开发生命周期，并列出了一些架构上的问题。相关扩展的源代码在<a class="ae jg" href="https://github.com/checkly/puppeteer-recorder" rel="noopener ugc nofollow" target="_blank"> github </a>上。</p><h1 id="a450" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">体系结构</h1><p id="01de" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">谷歌的文档很好地向你介绍了扩展的所有活动部分，包括他们的<a class="ae jg" href="https://developer.chrome.com/extensions/getstarted" rel="noopener ugc nofollow" target="_blank">入门指南</a>。然而，这些文档混合解释了次要的关注点/方面，如安全性、打包、设置图标等。拥有五个核心架构组件。您最好设置项目的代码结构来反映这五个核心组件，即</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/31be5774778a458e81578cecde6eba84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XJnaZongrFzmVHwe.png"/></div></div></figure><p id="4443" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此它们反映了扩展中的组件:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/161bf8f9ae548f3b0a2de7effe0f679e.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*roeBAz36bz1azsm6.png"/></div></figure><ul class=""><li id="875c" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">manifest.json</li></ul><p id="8e5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个文件引导您的扩展并提供元数据，如版本控制。没有这个，你就没有分机。</p><ul class=""><li id="993c" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">后台脚本</li></ul><p id="0f89" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你扩展的核心和灵魂。您可以在这里创建一个监听器，当用户单击您的图标时实际触发弹出窗口。所有“硬”业务逻辑和原生浏览器交互应该尽可能放在这里。</p><ul class=""><li id="77f6" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">内容脚本</li></ul><p id="0b17" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">内容脚本可以注入到浏览器的选项卡中，并在浏览器会话的上下文中访问DOM。您可以在这里添加新的DOM元素，添加额外的侦听器等。注意:内容脚本是可选的</p><ul class=""><li id="c7fa" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">弹出用户界面</li></ul><p id="9a22" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">点击/激活分机时看到的小应用。可以用任何框架构建，比如React或Vue，或者只是普通的JS。我们用了Vue。</p><ul class=""><li id="004c" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">选项页面用户界面</li></ul><p id="1bdd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">定制扩展设置的专用页面。这个页面应该将所有设置保存到存储中，以便插件的其他部分再次获取。</p><h1 id="1035" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">chrome global</h1><p id="548e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">见见你的新好朋友👫的，<code class="eh ly lz ma mb b">chrome</code>全局。你们会有很多时间在一起！其主要职能是:</p><ol class=""><li id="df13" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke mc lv lw lx dt translated"><strong class="jj hv">在浏览器导航和界面点击上注册监听器&amp;处理程序</strong>。在下面的例子中，你可以看到当你点击弹出界面中的“记录”时运行的<code class="eh ly lz ma mb b">start()</code>函数的缩略版本。</li></ol><pre class="lk ll lm ln fq md mb me mf aw mg dt"><span id="d569" class="mh kh hu mb b fv mi mj l mk ml">function start () { </span><span id="037e" class="mh kh hu mb b fv mm mj l mk ml">  // Inject the content script<br/>  chrome.tabs.executeScript({file: 'content-script.js'}) </span><span id="516a" class="mh kh hu mb b fv mm mj l mk ml">  // add various handlers to events     <br/>  chrome.runtime.onMessage.addListener(MessageHandler)   <br/>  chrome.webNavigation.onCompleted.addListener(NavigationHandler) <br/>  chrome.webNavigation.onBeforeNavigate.addListener(WaitHandler)</span><span id="8e35" class="mh kh hu mb b fv mm mj l mk ml">  // update the icon<br/>  chrome.browserAction.setIcon({ path: './images/icon-green.png' })   <br/>  chrome.browserAction.setBadgeText({ text: badgeState })  <br/>  chrome.browserAction.setBadgeBackgroundColor({ color: '#FF0000' })<br/>}</span></pre><p id="8084" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">导航和打开/关闭弹出用户界面时需要保存的任何东西都应该放入<code class="eh ly lz ma mb b">session</code>或<code class="eh ly lz ma mb b">sync</code>存储中。<code class="eh ly lz ma mb b">sync</code>商店应该通过与Chrome Sync连接的Chrome浏览器进行同步。更多信息，请参见下面的<a class="ae jg" href="https://checklyhq.com/blog/2018/08/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh/#state" rel="noopener ugc nofollow" target="_blank">状态</a>。</p><p id="5ae6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“全球化是坏的，米凯”。例如，测试任何使用它们的东西可能会很麻烦。当在多个通常松散耦合的对象上使用global时，事情很快变得棘手。话虽如此，Chrome团队在保持<code class="eh ly lz ma mb b">chrome</code>全球界面的最小化方面做得很好。将尽可能多的调用放在你的弹出用户界面之外，在那里你可能会使用一个“现代”的web框架，这将使事情保持理智。</p><h1 id="9f53" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">状态</h1><p id="a6c1" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">使用本机<code class="eh ly lz ma mb b">chrome.storage</code> API持久化状态。没有别的办法了。这将获取/设置你给它的Javascript对象，很像<code class="eh ly lz ma mb b">localStorage</code> API。将它包装在某个非全局函数中有助于保持事物的理性。确保检查从存储返回的值，例如:</p><pre class="lk ll lm ln fq md mb me mf aw mg dt"><span id="430e" class="mh kh hu mb b fv mi mj l mk ml">function loadState (cb) {   <br/>  this.$chrome.storage.local.get(['controls', 'code'], ({<br/>    controls, code }) =&gt; {<br/>     console.debug('loaded controls', controls<br/>     if (controls) {<br/>       this.isRecording = controls.isRecording<br/>       this.isPaused = controls.isPaused<br/>     } if (code) {<br/>       this.code = code<br/>    } cb() <br/>  })<br/>} </span><span id="3ee5" class="mh kh hu mb b fv mm mj l mk ml">function storeState () {<br/>  this.$chrome.storage.local.set({<br/>    code: this.code,<br/>    controls: { <br/>     isRecording: this.isRecording,<br/>     isPaused: this.isPaused<br/>    }<br/>  })<br/>}</span></pre><p id="2297" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个架构组件对状态的处理略有不同:</p><p id="7bfb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当通过点击工具栏上的图标来打开和关闭扩展时，弹出菜单会释放所有状态。您需要将所有内容写入会话存储，并在打开时重新加载它。</p><h2 id="3080" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">后台脚本的状态确实存在</h2><p id="3c17" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">后台脚本的行为有点像工作线程，因为除非调用显式的reload方法，否则它不会被重新加载。这意味着它应该(可能)作为你真理的主要来源</p><h2 id="f837" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">内容脚本的状态取决于许多因素</h2><p id="9c6e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">内容脚本完全取决于页面重新加载以及如何/是否/何时注入。在木偶记录器的特定情况下，内容脚本将消息处理程序附加到当前页面中的元素。这些处理程序将我们想要记录的事件消息发送给后台工作人员。</p><h2 id="71a3" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">存储有非常严格的限制</h2><p id="ac22" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">是的，本地为5，242，880字节/ 5Mb，同步为102，400字节/ 0.1Mb。对存储中的个别项目也有限制。参见<a class="ae jg" href="https://developer.chrome.com/apps/storage#property-local" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="205e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">浏览器环境中的状态总是很棘手，不是真正的扩展问题。努力的分数🤙</p><h1 id="0c2e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">信息发送</h1><p id="96cc" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">组件之间的通信是通过发送消息和在<code class="eh ly lz ma mb b">chrome</code>全局上添加监听器来完成的。</p><pre class="lk ll lm ln fq md mb me mf aw mg dt"><span id="77f2" class="mh kh hu mb b fv mi mj l mk ml">chrome.runtime.onMessage.removeListener(handleMsg) chrome.runtime.sendMessage(msg) function handleMsg (msg) { console.log(msg) }</span></pre><p id="9118" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这应该是所有JS开发者都非常熟悉的。没有虚饰，只是作品。竖起双拇指👍 👍</p><h1 id="593a" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">编码</h1><p id="9b35" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">除了<code class="eh ly lz ma mb b">chrome</code>全局和它的消息传递和状态函数之外，对您编写的实际代码基本上没有任何限制。任何Node.js或前端开发人员都应该非常熟悉。</p><p id="035f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将ES6/7与Vue.js一起用于弹出窗口，并使用了Vue.js eco(以及更大的)系统的大多数常见部分，如Webpack、Vue测试实用程序和单个文件组件。见<a class="ae jg" href="https://checklyhq.com/blog/2018/08/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh/#building" rel="noopener ugc nofollow" target="_blank">建筑</a>了解更多关于这个话题。</p><p id="20dd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">重新加载一个扩展有一些怪癖</strong>，因为你的内容脚本被绑定到一个动态分配的端口，这个端口在完全重新加载后会消失。这是意料之中的，但是console.log受到了错误的攻击。除了在连接周围添加一个<code class="eh ly lz ma mb b">try/catch</code>块并丢弃消息之外，我没有找到其他解决方法。</p><pre class="lk ll lm ln fq md mb me mf aw mg dt"><span id="c673" class="mh kh hu mb b fv mi mj l mk ml">function sendMessage (msg) {<br/>  console.debug('sending message', msg) try {   <br/>   chrome.runtime.sendMessage(msg)<br/>  } catch (err) {<br/>  console.debug('caught err', err) }<br/>}</span></pre><h1 id="e1dc" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">排除故障</h1><p id="fd43" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">Chrome的开发工具非常适合调试代码，在构建扩展时也是如此。然而，您可能需要打开多达四个单独的开发工具窗口来获得完整的画面:内容脚本、背景、弹出UI和选项UI都在单独的上下文中运行。</p><ul class=""><li id="017d" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated"><strong class="jj hv">内容脚本</strong>使用当前浏览器窗口的开发者工具。</li><li id="92f8" class="lp lq hu jj b jk na jo nb js nc jw nd ka ne ke lu lv lw lx dt translated"><strong class="jj hv">背景</strong>使用定制的开发者工具，可从您的扩展页面访问。</li></ul><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/d1552faf97cd66640da5dad815b2611d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*94wEqbeUpUgcfdUd.png"/></div></div></figure><ul class=""><li id="57f1" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated"><strong class="jj hv">弹出和选项</strong>通过在弹出/选项窗口的UI中点击右键，点击<strong class="jj hv">检查</strong>打开</li></ul><p id="aff2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">准备做一些漂亮的窗口俄罗斯！当然，从技术上来说这是有意义的，但是工作流程会受到极大的影响，尤其是当你习惯于React、Vue或普通JS应用程序开发，并且你有一个所有调试语句的需求时间表时。在一个控制台中。</p><h1 id="078b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">建筑物</h1><p id="9879" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">公平地说，你实际上不需要来构建任何东西。你可以只写普通的JS，把它打包成一个. zip就完成了。然而，当你习惯了像Vue.js和ES6/ES7语法这样的技术，你就会进入巴别塔和Webpack的土地:</p><ul class=""><li id="46f4" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">传输ESx</li><li id="3148" class="lp lq hu jj b jk na jo nb js nc jw nd ka ne ke lu lv lw lx dt translated">Vue.js单一文件组件</li><li id="02a3" class="lp lq hu jj b jk na jo nb js nc jw nd ka ne ke lu lv lw lx dt translated">萨斯/SCSS汇编</li></ul><p id="fc27" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">获得正确的构建有点棘手，因为具体的Webpack示例和相应的版本似乎比光速还快。</p><p id="730b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，长话短说，看看Github上的<a class="ae jg" href="https://github.com/checkly/puppeteer-recorder/blob/master/webpack.config.babel.js" rel="noopener ugc nofollow" target="_blank"> webpack config </a>和相应的<a class="ae jg" href="https://github.com/checkly/puppeteer-recorder/blob/master/webpack.config.babel.js" rel="noopener ugc nofollow" target="_blank"> package.json </a>，你就能知道什么适用于木偶录制器。</p><h1 id="b728" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">测试</h1><p id="9080" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我们使用<a class="ae jg" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>进行测试。我们不追求100%的测试覆盖率，正如我们所说的，测试正在增加。它们分为三类:</p><ol class=""><li id="b002" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke mc lv lw lx dt translated">模块或功能级别的单元测试</li><li id="e6be" class="lp lq hu jj b jk na jo nb js nc jw nd ka ne ke mc lv lw lx dt translated">UI测试渲染Vue.js组件并使用Jest <a class="ae jg" href="https://jestjs.io/docs/en/snapshot-testing#snapshot-testing-with-jest" rel="noopener ugc nofollow" target="_blank">快照</a>来验证正确性</li><li id="8d5f" class="lp lq hu jj b jk na jo nb js nc jw nd ka ne ke mc lv lw lx dt translated">End 2结束构建和安装扩展的测试。</li></ol><p id="11cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于1和2，除了你必须…</p><h2 id="fe01" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">模拟调用<code class="eh ly lz ma mb b">chrome</code>全局</h2><p id="1d1d" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">它的方法。您可以在这里发疯，但我们设法(目前)通过一个相当简单的模拟。下面的(编辑过的)例子显示了一个Vue组件被挂载、注入了一个mock并被断言。实际测试在Github上的<a class="ae jg" href="https://github.com/checkly/puppeteer-recorder/blob/master/src/popup/components/__tests__/App.spec.js" rel="noopener ugc nofollow" target="_blank"> App.spec.js </a>进行。</p><pre class="lk ll lm ln fq md mb me mf aw mg dt"><span id="0351" class="mh kh hu mb b fv mi mj l mk ml">import { mount } from '@vue/test-utils'<br/>import App from '../App'</span><span id="a599" class="mh kh hu mb b fv mm mj l mk ml">const chrome = {<br/>  storage: {<br/>   local: { get: jest.fn() } },<br/>   extension: { connect: jest.fn() <br/>  } <br/>}</span><span id="251c" class="mh kh hu mb b fv mm mj l mk ml">const mocks = { $chrome: chrome }</span><span id="fa92" class="mh kh hu mb b fv mm mj l mk ml">describe('App.vue', () =&gt; {<br/>  test('it has the correct pristine / empty state', () =&gt; {<br/>   const wrapper = mount(App, { mocks })    <br/>   expect(wrapper.element).toMatchSnapshot()<br/>  }) <br/>})</span></pre><h2 id="7151" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">使用木偶师检查构建和安装</h2><p id="371b" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">最后，您需要向Google提交一个包含代码的zip文件，以便在网络商店上发布。您可能想知道可分发的“二进制文件”实际上是如何安装的。你可以用木偶师测试一下。下面的例子展示了我们如何构建代码并将其作为扩展安装在Chrome实例中。</p><p id="cd81" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当使用Jest时，一定要通过使用<code class="eh ly lz ma mb b">--runInBand</code>标志按顺序运行这些测试用例。</p><pre class="lk ll lm ln fq md mb me mf aw mg dt"><span id="ed07" class="mh kh hu mb b fv mi mj l mk ml">import puppeteer from 'puppeteer'<br/>import path from 'path'<br/>import { scripts } from '../../package.json'<br/>const util = require('util') const exec = util.promisify(require('child_process').exec) </span><span id="895b" class="mh kh hu mb b fv mm mj l mk ml">const extensionPath = path.join(__dirname, '../../dist')</span><span id="a356" class="mh kh hu mb b fv mm mj l mk ml">describe('build &amp; install', () =&gt; {<br/>  // Calls the standard 'npm dist' script used to build the<br/>distributable  </span><span id="742b" class="mh kh hu mb b fv mm mj l mk ml">  test('it builds the extension', async () =&gt; {<br/>    const { stderr } = await exec(scripts.dist) <br/>    expect(stderr).toBeFalsy() <br/>   }, 15000) <br/>  <br/>  // boots a Chrome instance using Puppeteer and adds the extension we build in the earlier test </span><span id="268d" class="mh kh hu mb b fv mm mj l mk ml">  test('it installs the extension', async () =&gt; {<br/>   const options = {<br/>     headless: false, ignoreHTTPSErrors: true,<br/>     args: [<br/>       `--disable-extensions-except=${extensionPath}`,<br/>       `--load-extension=${extensionPath}`,<br/>       '--no-sandbox',<br/>       '--disable-setuid-sandbox'<br/>   ]<br/>  } <br/>  const browser = await puppeteer.launch(options) <br/>  expect(browser).toBeTruthy() <br/>  await browser.close()<br/> }, 5000)<br/>})</span></pre><h1 id="180f" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">分配</h1><p id="aca3" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在网上商店获得扩展是一个分三部分的过程。</p><h2 id="b57a" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">1.将您的代码打包成一个zip文件</h2><p id="f557" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">您的扩展需要以zip格式上传到Google。您可以让构建工具为您创建一个zip文件。我们从<a class="ae jg" href="https://github.com/Kocal/vue-web-extension" rel="noopener ugc nofollow" target="_blank"> Kocal的vue-web-extension </a> repo中“偷”了这个脚本，在<a class="ae jg" href="https://github.com/checkly/puppeteer-recorder/tree/master/scripts" rel="noopener ugc nofollow" target="_blank">脚本目录</a>中检查它。<br/>感谢Kocal和Google保持了像zip文件一样简单的分发格式👌。</p><h2 id="d8e1" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">2.创建一个Chrome网络商店开发者账户</h2><p id="6b2e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在<a class="ae jg" href="https://chrome.google.com/webstore/developer/dashboard" rel="noopener ugc nofollow" target="_blank">https://chrome.google.com/webstore/developer/dashboard</a>的网上商店设立开发者账户</p><p id="a2bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">注意:在发布之前，你必须一次性支付5美元的费用。好吧，不管怎样，看起来很公平。</em></p><h2 id="c8aa" class="mh kh hu bd ki mn mo mp km mq mr ms kq js mt mu ku jw mv mw ky ka mx my lc mz dt translated">3.提供图片和视频</h2><p id="98b6" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">不要吝啬这个！我们用荷兰语说，意思是“不要让眼睛看不见！”。感谢谷歌为你提供了许多品牌和推广选项:图标，各种尺寸的推广图片，Youtube上的演示链接等等。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><p id="e10e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">最初发表于</em><a class="ae jg" href="https://checklyhq.com/blog/2018/08/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh/" rel="noopener ugc nofollow" target="_blank"><em class="kf">【checklyhq.com】</em></a><em class="kf">。</em></p><p id="735d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">附:如果你喜欢这篇文章，请用<strong class="jj hv">鼓掌</strong>来表达你的欣赏👏下面还有<a class="ae jg" href="https://twitter.com/tim_nolet" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">在Twitter上关注我</strong> </a> <strong class="jj hv">！</strong>但是等等，还有更多！</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div class="ab fr cl no"><img src="../Images/168ff830e8a48e117ba544a329931875.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Hrals4uqMNwa6CyswGE4CA.png"/></div></figure></div></div>    
</body>
</html>