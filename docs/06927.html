<html>
<head>
<title>Android RecyclerView onItemClickListener &amp; getAdapterPosition(): A Better Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android recycle view onItemClickListener &amp; getAdapterPosition():更好的方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/android-recyclerview-onitemclicklistener-getadapterposition-a-better-way-3c789baab4db?source=collection_archive---------0-----------------------#2018-08-17">https://medium.com/hackernoon/android-recyclerview-onitemclicklistener-getadapterposition-a-better-way-3c789baab4db?source=collection_archive---------0-----------------------#2018-08-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="021d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">一个更简单的方法来顺利完成那件事。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/36ccfd422ce17964fa372b4ee2c31fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAFAiAxqZVrOVLBTo9tf6w.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/photos/xrVDYZRGdw4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Émile Perron</a> on <a class="ae jz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dd79" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">更新1 </strong>:包含lambda函数作为替代。<br/> <strong class="kc hv">更新2 </strong>:包含了GitHub  上<a class="ae jz" href="https://github.com/RohitSurwase/RvClickListenerExample" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">实现实例App的链接。</strong></a></p><blockquote class="kw kx ky"><p id="b22d" class="ka kb kz kc b kd ke iv kf kg kh iy ki la kk kl km lb ko kp kq lc ks kt ku kv hn dt translated"><strong class="kc hv">TL；DR <br/>最好通过回收审查。<strong class="kc hv"> ViewHolder </strong>使用视图。在你的视图中设置标签()</strong>，然后从视图中设置<strong class="kc hv">getAdapterPosition()</strong>(…和许多其他的东西)。<strong class="kc hv"> getTag() </strong>即<strong class="kc hv"> ViewHolder的</strong>对象在你的活动/片段/视图里面。<br/> <a class="ae jz" href="https://github.com/RohitSurwase/RvClickListenerExample" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">在GitHub上实现示例App</strong></a></p></blockquote><h1 id="bd6e" class="ld le hu bd lf lg lh li lj lk ll lm ln ja lo jb lp jd lq je lr jg ls jh lt lu dt translated"><strong class="ak">最流行的方式；</strong>问题</h1><p id="9946" class="pw-post-body-paragraph ka kb hu kc b kd lv iv kf kg lw iy ki kj lx kl km kn ly kp kq kr lz kt ku kv hn dt translated">我知道您一定已经找到了为RecyclerView适配器获取onItemClickListener()的方法。但有时我们思考的方式并不总是正确的或更好的方式。每当有人试图在他们的活动/片段/视图中找到getAdapterPosition()的方法时。他或她遇到了众所周知的以<strong class="kc hv"> <em class="kz">视图</em> </strong>和<strong class="kc hv"> <em class="kz">位置</em> </strong>为参数创建自定义界面的模式。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="be5c" class="mf le hu mb b fv mg mh l mi mj">public <strong class="mb hv">interface ItemClickListener</strong> {<br/>    void onItemClick(View view, int position);<br/>}</span></pre><p id="43e8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">稍后，我们使用公共setter初始化ItemClickListener实例。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="a9ce" class="mf le hu mb b fv mg mh l mi mj">private<strong class="mb hv"> ItemClickListener </strong>onItemClickListener;</span><span id="f241" class="mf le hu mb b fv mk mh l mi mj">...</span><span id="f4a1" class="mf le hu mb b fv mk mh l mi mj">public void setItemClickListener(<strong class="mb hv">ItemClickListener</strong> clickListener) {<br/>    onItemClickListener = clickListener;<br/>}</span></pre><p id="1997" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">或者…通过构造函数传递ItemClickListener实例。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ml mm l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Constructor of RecyclerViewAdapter</figcaption></figure><p id="aaea" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">最后我们把我们的<strong class="kc hv"> <em class="kz">视图</em> </strong> <em class="kz"> </em>和<strong class="kc hv"> <em class="kz">适配器位置</em> </strong>传递给监听器。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="be52" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们对剩下的部分了如指掌。大多数文章都描述了同样的事情。但是有一个问题。</p><p id="f65e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当我们说<em class="kz"> itemView </em> <strong class="kc hv"> <em class="kz">的时候。setOnClickListener(新视图。onclick listener()……</em>T59】</strong></p><blockquote class="kw kx ky"><p id="0a19" class="ka kb kz kc b kd ke iv kf kg kh iy ki la kk kl km lb ko kp kq lc ks kt ku kv hn dt translated">它创建了一个匿名的内部类，实现了我们的ItemClickListener监听器。</p></blockquote><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="718e" class="mf le hu mb b fv mg mh l mi mj"><strong class="mb hv">class</strong> AnonymousItemClickListener <strong class="mb hv">implements ItemClickListener</strong>{<br/>    @Override<br/>    public void onItemClick(View view, int position) {<br/>        <br/>    }<br/>}</span></pre><p id="5249" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们最终为一个点击监听器创建并初始化了多个匿名内部类。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="aee3" class="mf le hu mb b fv mg mh l mi mj">new AnonymousItemClickListener(){<br/>        @Override<br/>        public void onItemClick(View view, int position) {<br/>            <br/>        }<br/>    };</span></pre><p id="05cf" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我以前也是这样。因为这是我们在网上看到的。</p><div class="mn mo fm fo mp mq"><a href="https://psiloveyou.xyz/introverts-decoded-why-am-i-still-single-a046d1596d1e" rel="noopener follow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">内向者解码:恋爱中未说出口的困境</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">他们从不告诉任何人的事情。</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">psiloveyou.xyz</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jt mq"/></div></div></a></div></div><div class="ab cl nf ng hc nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hn ho hp hq hr"><blockquote class="kw kx ky"><p id="2e86" class="ka kb kz kc b kd ke iv kf kg kh iy ki la kk kl km lb ko kp kq lc ks kt ku kv hn dt translated"><strong class="kc hv">更新:</strong> <br/>正如<a class="nm nn gr" href="https://medium.com/u/f02e354ffc0c?source=post_page-----3c789baab4db--------------------------------" rel="noopener" target="_blank"> Sachin Chandil </a>在评论部分所建议的，我们可以使用Java8的<strong class="kc hv"> Lambda函数</strong>来摆脱编译时的匿名类创建。Lambda函数与SAM类型(具有单一抽象方法的接口)一起工作，它不创建匿名内部类的原因是Java 7中引入的InvokeDynamic指令。因此，使用Lambdas，我们可以将上述函数转换如下:</p></blockquote><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="dfe6" class="mf le hu mb b fv mg mh l mi mj">itemView.setOnClickListener(view -&gt; onItemClickListener.onItemClick(view, getAdapterPosition());</span></pre><h2 id="8f75" class="mf le hu bd lf no np nq lj nr ns nt ln kj nu nv lp kn nw nx lr kr ny nz lt oa dt translated">由于某些原因，你不能使用Java8的Lambda函数，那么继续下去，因为下面的方法对你来说仍然是一个更好的选择。</h2><h1 id="c49e" class="ld le hu bd lf lg lh li lj lk ll lm ln ja lo jb lp jd lq je lr jg ls jh lt lu dt translated">更好的方法；解决方案</h1><p id="1a8c" class="pw-post-body-paragraph ka kb hu kc b kd lv iv kf kg lw iy ki kj lx kl km kn ly kp kq kr lz kt ku kv hn dt translated">但是，最近我从一位<a class="ae jz" rel="noopener" href="/@aalap_shah"> <strong class="kc hv">同事</strong> </a>那里得到一个建议，用一种更好更轻便的方式来实现它。让我们看看<em class="kz">我们如何在我们的活动/片段/视图中获取</em> <strong class="kc hv"> <em class="kz">适配器位置、</em> </strong> <em class="kz"> </em> <strong class="kc hv"> <em class="kz">项目id</em></strong>(…以及其他许多东西)<em class="kz">。</em></p><p id="cb8f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">因此，我们将使用<strong class="kc hv">视图，而不是创建新的自定义界面。OnClickListener </strong>并按照我们以前的方式初始化它。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="baf5" class="mf le hu mb b fv mg mh l mi mj">private<strong class="mb hv"> View.OnClickListener </strong>onItemClickListener;</span><span id="b6e8" class="mf le hu mb b fv mk mh l mi mj">...</span><span id="d4cf" class="mf le hu mb b fv mk mh l mi mj">public void setItemClickListener(<strong class="mb hv">View.OnClickListener</strong> clickListener) {<br/>    onItemClickListener = clickListener;<br/>}</span></pre><p id="52fa" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">并且我们将使用<strong class="kc hv"> setTag() </strong>通过<strong class="kc hv"> itemView </strong>将<strong class="kc hv"> <em class="kz"> ViewHolder </em> </strong>的<em class="kz">实例</em>传递给监听器。</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="5211" class="mf le hu mb b fv mg mh l mi mj">private class MyViewHolder extends RecyclerView.ViewHolder {<br/>    public MyViewHolder(View itemView) {<br/>        super(itemView);<br/>        <strong class="mb hv">itemView.setTag(this);</strong><br/>    }<br/>}</span></pre><p id="fe61" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这样，我们不需要创建匿名内部类，因为我们可以直接给出<strong class="kc hv"> onItemClickListener </strong>的引用</p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="034a" class="mf le hu mb b fv mg mh l mi mj">private class MyViewHolder extends RecyclerView.ViewHolder {<br/>    public MyViewHolder(View itemView) {<br/>        super(itemView);<br/>        itemView.setTag(this);<br/>        <strong class="mb hv">itemView.setOnClickListener(onItemClickListener);</strong><br/>    }<br/>}</span></pre><p id="dd49" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">最后我们可以从<strong class="kc hv"><em class="kz"><em class="kz">中得到<strong class="kc hv"> <em class="kz">适配器位置</em> <strong class="kc hv"> <em class="kz">和</em></strong><em class="kz">项目id</em>(…以及其他许多东西)<em class="kz">在我们的活动/片段/视图</em><strong class="kc hv"><em class="kz">ViewHolder</em></strong><em class="kz">实例中。</em></strong></em></em></strong></p><pre class="jk jl jm jn fq ma mb mc md aw me dt"><span id="3d78" class="mf le hu mb b fv mg mh l mi mj">RecyclerView.ViewHolder <strong class="mb hv">viewHolder</strong> = (RecyclerView.ViewHolder) <strong class="mb hv">view.getTag()</strong>;</span><span id="c1df" class="mf le hu mb b fv mk mh l mi mj">int <strong class="mb hv">position</strong> = viewHolder.<strong class="mb hv">getAdapterPosition()</strong>;<br/>// viewHolder.<strong class="mb hv">getItemId()</strong>;<br/>// viewHolder.<strong class="mb hv">getItemViewType()</strong>;<br/>// viewHolder.<strong class="mb hv">itemView</strong>;</span></pre><p id="1b9a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">简单！</strong>不是吗？请在评论区告诉我你对此的看法和建议。</p><p id="a443" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果你还有些疑惑，下面是GitHub   <strong class="kc hv">上<a class="ae jz" href="https://github.com/RohitSurwase/RvClickListenerExample" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">实现示例App的源代码。</strong></a></strong></p><p id="fc8b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">感谢阅读！<br/> <strong class="kc hv"> Rohit Surwase </strong></p><p id="b9b2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果你喜欢这篇文章，拍手拍手拍手👏👏👏尽可能多的次数。</p><p id="8b7b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">太喜欢了！介质允许高达<strong class="kc hv"> 50拍</strong>。<br/>也在 <a class="ae jz" href="https://twitter.com/Rohit5rss" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> Twitter </strong> </a>上发布一条<strong class="kc hv">的推文。</strong></p><p id="54a5" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们成为<a class="ae jz" href="http://in.linkedin.com/in/rohitss5" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> <em class="kz"> LinkedIn </em> </strong> </a>，<a class="ae jz" rel="noopener" href="/@rohitss"><strong class="kc hv"><em class="kz">Medium</em></strong></a><strong class="kc hv"><em class="kz">，</em></strong><a class="ae jz" href="https://twitter.com/Rohit5rss" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv">Twitter</strong></a><strong class="kc hv"/>和<a class="ae jz" href="http://github.com/RohitSurwase/" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv"><em class="kz">GitHub</em></strong></a><strong class="kc hv"><em class="kz">。</em> </strong></p><blockquote class="kw kx ky"><p id="a4e1" class="ka kb kz kc b kd ke iv kf kg kh iy ki la kk kl km lb ko kp kq lc ks kt ku kv hn dt translated">我的最新故事</p></blockquote><div class="mn mo fm fo mp mq"><a href="https://proandroiddev.com/best-architecture-for-android-mvi-livedata-viewmodel-71a3a5ac7ee3" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hv fv z el mv eo ep mw er et ht dt translated">Android最佳架构:MVI + LiveData + ViewModel = ❤️</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">MVVM和MVI架构模式的精华合二为一，成为任何Android项目的完美架构。</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">proandroiddev.com</p></div></div><div class="mz l"><div class="ob l nb nc nd mz ne jt mq"/></div></div></a></div></div></div>    
</body>
</html>