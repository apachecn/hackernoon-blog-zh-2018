<html>
<head>
<title>Strengthen TLS in React Native through Certificate Pinning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过证书锁定增强React Native中的TLS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/strengthen-tls-in-react-native-through-certificate-pinning-e6e8d53e8254?source=collection_archive---------6-----------------------#2018-08-18">https://medium.com/hackernoon/strengthen-tls-in-react-native-through-certificate-pinning-e6e8d53e8254?source=collection_archive---------6-----------------------#2018-08-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c791" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">增强React Native的网络API保护，无需接触您的Javascript代码或手动编辑本机代码项目。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/24a059f34cf564f59a1eb9c203991162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1O5yUKecExIJaBF8uLlCnw.jpeg"/></div></div></figure><p id="2984" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从2018年7月68版本开始，Chrome开始将所有不运行HTTPS (TLS over HTTP)的网站标记为“不安全”。TLS使用站点证书建立信任链，并在传输层加密通信。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/48665325cccea0f15ee5c857d182a7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*tcZAWF4tQFyn1Sss.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Source: <a class="ae kw" href="https://security.googleblog.com/2018/02/a-secure-web-is-here-to-stay.html" rel="noopener ugc nofollow" target="_blank">Google Security Blog</a></figcaption></figure><p id="bcb6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这在网络和API安全性方面是一个显著的提升，但尤其是在移动设备上，这可能还不够。不幸的是，欺骗移动设备信任由意想不到的证书颁发机构签署的证书太容易了。<a class="ae kw" href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank">证书锁定</a>应用于限制对网站叶证书的信任，或仅限于应用本身信任的中间或根授权机构。</p><p id="2e41" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于实施和维护上的困难，证书锁定并没有得到应有的普及。对于React Native，这甚至更具挑战性，因为实现锁定所需的网络接口没有在javascript层公开。</p><p id="0618" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">目前可用的支持React Native中证书锁定的包需要<a class="ae kw" href="https://www.npmjs.com/package/react-native-pinch" rel="noopener ugc nofollow" target="_blank">替换内置网络包</a>或<a class="ae kw" href="http://www.madebymany.com/stories/a-year-of-react-native-ssl-pinning" rel="noopener ugc nofollow" target="_blank">手动更改本机代码</a>。这个npm包，<a class="ae kw" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank"> react-native-cert-pinner </a>，不需要对javascript代码做任何修改就可以锁定网络获取。用于固定连接的底层本机代码完全由开发人员指定的JSON配置文件生成。这是一项正在进行中的工作，目前在Android上可用，随后将在iOS上推出，并提供额外的软件包自动化和安全性。</p><h1 id="28a2" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">防止中间人攻击</h1><p id="d07b" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated"><a class="ae kw" href="http://www.madebymany.com/stories/a-year-of-react-native-ssl-pinning" rel="noopener ugc nofollow" target="_blank">一年的React Native: SSL Pinning </a>很好地描述了移动连接的风险，甚至在使用TLS时也是如此。对证书颁发机构或移动设备的损害会导致应用程序不正确地信任假冒的服务器证书，并允许攻击者将其自身插入到连接中，静默地解密、观察、可能修改和重新加密本应安全的通信。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lu"><img src="../Images/b51fe81cd04fbaf3650d96ff30558e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtkndRJQ4MOmt98AVw6C_Q.png"/></div></div></figure><p id="5fdc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">证书锁定基于现有的HTTPS(HTTP上的SSL或TLS)技术。使用TLS，移动设备会跟踪证书链，直到到达由它信任的机构签署的证书。</p><p id="d932" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">证书锁定用于识别特定证书或限制受信任为目标网站签名的证书颁发机构的数量。通过在应用程序中固定受信任服务器证书的有限列表，欺诈性签名的证书，即使其证书颁发机构受到设备的信任，也将被应用程序拒绝。该应用程序可以锁定服务器的叶证书和中间证书。</p><p id="345b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通常建议固定多个证书的公钥，以便在其他密钥泄露的情况下，应用程序仍然可以信任一个密钥。</p><p id="a06a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">SSL固定是一种缓解方法，旨在降低通过假冒后端服务器的SSL证书实现的MiTM攻击的有效性。锁定中间密钥简化了证书轮换和更新。检查公钥的散列是方便的，并且对任何攻击者隐藏了证书信息。</p><h1 id="87f1" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">React本机示例应用程序</h1><p id="c7e6" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">npm react-native-cert-pinner模块包含一个示例应用程序，我们将使用它来演示证书锁定。应用程序检查与<code class="eh lv lw lx ly b">demo-server.approovr.io</code>服务器的HTTPS连接:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="3d82" class="md ky hu ly b fv me mf l mg mh">$ curl <a class="ae kw" href="https://demo-server.approovr.io" rel="noopener ugc nofollow" target="_blank">https://demo-server.approovr.io</a></span><span id="3cb7" class="md ky hu ly b fv mi mf l mg mh">Hello World!</span></pre><p id="82b9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于TLS不是通过fetch()等React原生网络调用公开的，所以必须引入原生模块，Expo环境不容易用于开发。</p><p id="ada5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先使用<code class="eh lv lw lx ly b">react-native-cli</code>初始化一个React本地项目:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="0936" class="md ky hu ly b fv me mf l mg mh">$ react-native init example<br/>Installing react-native...</span></pre><p id="9aea" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来安装<code class="eh lv lw lx ly b"><a class="ae kw" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank">react-native-cert-pinner</a></code>包:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="4bc2" class="md ky hu ly b fv me mf l mg mh">$ cd example<br/>$ npm install -S react-native-cert-pinner<br/>+ react-native-cert-pinner@0.3.0<br/>added 4 packages from 2 contributors and audited packages in 6.689s<br/>found 0 vulnerabilities</span></pre><p id="87df" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用<code class="eh lv lw lx ly b">react-native</code>自动链接cert pinner本机模块:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="38f8" class="md ky hu ly b fv me mf l mg mh">$ react-native link<br/>Scanning folders for symlinks in /Users/skiph/Projects/<br/>  rn-pinning/rncp-test/example/node_modules (13ms)<br/>rnpm-install info Linking react-native-cert-pinner ios dependency<br/>rnpm-install info Platform 'ios' module react-native-cert-pinner has<br/>  been successfully linked<br/>rnpm-install info Linking react-native-cert-pinner android<br/>  dependency<br/>rnpm-install info Platform 'android' module react-native-cert-pinner<br/>  has been successfully linked</span></pre><p id="443a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">删除默认的<code class="eh lv lw lx ly b">index.js</code>和<code class="eh lv lw lx ly b">App.js</code>文件，并从cert pinner包中的示例目录安装<code class="eh lv lw lx ly b">index.js and src/</code>文件:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="50df" class="md ky hu ly b fv me mf l mg mh">$ rm ./index.js ./App.js<br/>$ cp ./node_modules/react-native-cert-pinner/example/index.js ./<br/>$ cp -r ./node_modules/react-native-cert-pinner/example/src ./</span></pre><p id="512b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您应该准备好构建和运行应用程序。确保Android模拟器正在运行或Android设备已连接，并启动应用程序:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="6379" class="md ky hu ly b fv me mf l mg mh">$ react-native run-android<br/>...<br/>installing APK 'app-debug.apk' on 'Pixel_2_API_25' for app:debug<br/>Installed on 1 device.</span><span id="508e" class="md ky hu ly b fv mi mf l mg mh">BUILD SUCCESSFUL</span><span id="cff8" class="md ky hu ly b fv mi mf l mg mh">Total time: 15.768 secs<br/>Running adb -s emulator-5554 reverse tcp:8081 tcp:8081<br/>Starting the app on emulator-5554 (adb -s emulator-5554 shell am start -n com.example/com.example.MainActivity)<br/>...<br/>Starting: Intent { cmp=com.example/.MainActivity }</span></pre><p id="aae4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在打开的屏幕上，按下<code class="eh lv lw lx ly b">TEST HELLO</code>按钮。成功的连接将显示一个笑脸:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/f432f713c7cf7235b2dc222687ac68e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*n8jzYpOzifl12I1u3lnnNQ.png"/></div></figure><p id="6cac" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">尽管通过TLS成功建立了连接，但没有使用证书锁定。</p><h1 id="9934" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">固定可信证书</h1><p id="dbe7" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">要添加证书固定，首先要在示例项目的主目录中初始化一个pinset配置文件:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="e2d6" class="md ky hu ly b fv me mf l mg mh">$ npx pinset init<br/>File './pinset.json' initialized.</span></pre><p id="e71f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，从用于<code class="eh lv lw lx ly b">demo-server.approovr.io</code>的证书链中确定几个公钥散列。在https://report-uri.com/home/pkp_hash<a class="ae kw" href="https://report-uri.com/home/pkp_hash" rel="noopener ugc nofollow" target="_blank"/>有方便的查询服务。在撰写本文时，可用的公钥散列是:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mk"><img src="../Images/63a9f3b096e44dea7e8467b534fb607d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKUHG2SuOglxZNZMNY48rg.png"/></div></div></figure><p id="3df7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">编辑<code class="eh lv lw lx ly b">pinset.json</code>以锁定一些关键散列:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="65e2" class="md ky hu ly b fv me mf l mg mh">{<br/>  "domains": {<br/>    "*.approovr.io": {<br/>      "pins": [<br/>        "sha256/oq+Uj+2TYMg13txh1pXW0/VLAkonU3TnoPr5hfxPZVc=",<br/>        "sha256/8Rw90Ej3Ttt8RRkrg+WYDS9n7IS03bk5bjP/UXPtaY8="<br/>      ] <br/>    } <br/>  } <br/>}</span></pre><p id="cf79" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在生产应用程序中，您需要为应用程序与之通信的每个服务器域添加pin。如果您连接到许多服务器，考虑使用一个<a class="ae kw" href="https://hackernoon.com/whitelists-and-indirection-go-together-like-chocolate-and-peanut-butter-a350786f8381" rel="noopener ugc nofollow" target="_blank"> API代理网关</a>来提高API保护并减少您需要管理的pin集数量。</p><p id="5951" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过运行<code class="eh lv lw lx ly b">pinset gen</code>生成所需的本地项目文件:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="f13f" class="md ky hu ly b fv me mf l mg mh">$ npx pinset gen<br/>Reading config file './pinset.json'.<br/>Writing java file './android/app/src/main/java/com/criticalblue/reactnative/<br/>  GeneratedCertificatePinner.java'.<!-- --> </span></pre><p id="c188" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您认为发布公钥证书的散列是一种安全违规，您可能希望从存储库中删除或忽略pinset配置和生成的文件。在根“. gitignore”文件中，添加:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="0acd" class="md ky hu ly b fv me mf l mg mh"># default configuration file<br/>./pinset.json</span><span id="0061" class="md ky hu ly b fv mi mf l mg mh"># default generated android source<br/>./android/app/src/main/java/com/criticalblue/reactnative/GeneratedCertificatePinner.java</span></pre><p id="d56a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">重新构建并启动修改后的应用程序。您应该会再次看到一个成功的连接，但是这一次连接被至少一个公钥哈希锁定。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/f432f713c7cf7235b2dc222687ac68e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*n8jzYpOzifl12I1u3lnnNQ.png"/></div></figure><h1 id="4e65" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">拒绝无法识别的证书</h1><p id="1500" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">要测试证书锁定，请更改<code class="eh lv lw lx ly b">pinset.json</code>中的<code class="eh lv lw lx ly b">*.approovr.io</code>公钥散列，使它们不匹配任何预期值:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="8e42" class="md ky hu ly b fv me mf l mg mh">{<br/>  "domains": {<br/>    "*.approovr.io": {<br/>      "pins": [<br/>        "sha256/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"<br/>      ] <br/>    } <br/>  } <br/>}</span></pre><p id="d9f8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过运行<code class="eh lv lw lx ly b">pinset gen</code>重新生成本地项目文件:</p><pre class="jk jl jm jn fq lz ly ma mb aw mc dt"><span id="a5f9" class="md ky hu ly b fv me mf l mg mh">$ npx pinset gen<br/>Reading config file './pinset.json'.<br/>Writing java file './android/app/src/main/java/com/criticalblue/reactnative/<br/>  GeneratedCertificatePinner.java'.</span></pre><p id="d412" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">重新构建并启动修改后的应用程序。这一次您应该会看到一个连接失败，因为应用程序找不到与其预期pin匹配的公钥散列。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/5a0580e284eb7ce0ace7193a105baf71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*fEdEH69P_DTES34fxnKNyQ.png"/></div></figure><h1 id="77a9" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">暂时结束</h1><p id="55ed" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">您已经成功演示了Android上React Native的pinning实用程序，它使用内置的fetch() API，不需要对原生Android代码进行任何手动编辑。</p><p id="0068" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">未来的增强功能包括:</p><ul class=""><li id="8025" class="ml mm hu jx b jy jz kb kc ke mn ki mo km mp kq mq mr ms mt dt translated">添加等效的iOS支持。</li><li id="8cc2" class="ml mm hu jx b jy mu kb mv ke mw ki mx km my kq mq mr ms mt dt translated">每当管脚集配置改变时，自动重新生成本地源文件。</li><li id="1d8c" class="ml mm hu jx b jy mu kb mv ke mw ki mx km my kq mq mr ms mt dt translated">将源代码重新生成和git忽略添加到大部分自动反应的本地链接步骤中。</li><li id="65d6" class="ml mm hu jx b jy mu kb mv ke mw ki mx km my kq mq mr ms mt dt translated">将证书公钥散列查找添加到<code class="eh lv lw lx ly b">pinset</code>实用程序中。</li><li id="71e3" class="ml mm hu jx b jy mu kb mv ke mw ki mx km my kq mq mr ms mt dt translated">加强应用程序中pinset信息的安全性。</li></ul><p id="b085" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过简化React本地应用的证书锁定，<code class="eh lv lw lx ly b"><a class="ae kw" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank">react-native-cert-pinner</a></code>包应该可以帮助更多的开发者使用这些技术来加强他们的移动API连接的完整性。</p></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="61c4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要了解更多关于API安全性和相关主题的信息，请访问<a class="ae kw" href="https://www.approov.io/" rel="noopener ugc nofollow" target="_blank">approv . io</a>或在twitter上关注<a class="ae kw" href="https://twitter.com/critblue" rel="noopener ugc nofollow" target="_blank"> @critblue </a>。</p></div></div>    
</body>
</html>