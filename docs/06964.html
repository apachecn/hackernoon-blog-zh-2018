<html>
<head>
<title>Why I felt the need to use GraphQL!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我觉得有必要使用GraphQL！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-i-felt-the-need-to-use-graphql-b451d16e7369?source=collection_archive---------20-----------------------#2018-08-18">https://medium.com/hackernoon/why-i-felt-the-need-to-use-graphql-b451d16e7369?source=collection_archive---------20-----------------------#2018-08-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我们将讨论GitHub的REST API不够高效的场景，以及GitHub的<a class="ae jp" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> <a class="ae jp" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>如何帮助我们解决问题。</p><p id="7136" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在从事<a class="ae jp" href="https://github.com/AmrishJhaveri/Git-Repo-Analyzer" rel="noopener ugc nofollow" target="_blank"> Git Repository Analyzer </a>项目时，我们广泛使用了Octokit的GitHub REST API客户端。Node.js异步调用的使用有助于同时进行HTTP调用，但是为了检索所需的数据而进行的HTTP调用太多了。让我们看看如何通过使用GitHub的GraphQL API来克服这些问题。</p><h1 id="7c01" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">数据要求</h1><ol class=""><li id="21e4" class="ko kp hu it b iu kq iy kr jc ks jg kt jk ku jo kv kw kx ky dt translated">基于搜索参数搜索GitHub储存库；例如<em class="kz">语言:java </em>。</li><li id="c2bf" class="ko kp hu it b iu la iy lb jc lc jg ld jk le jo kv kw kx ky dt translated">按照在存储库中找到的<em class="kz">星</em>的数量降序排列这些存储库。</li><li id="9c13" class="ko kp hu it b iu la iy lb jc lc jg ld jk le jo kv kw kx ky dt translated">对于每个存储库，获取前30个拉请求。</li><li id="d1e8" class="ko kp hu it b iu la iy lb jc lc jg ld jk le jo kv kw kx ky dt translated">对于每个拉取请求，获取问题和补丁/差异数据。通过进行两次单独的HTTP调用，可以获得问题数据和补丁数据。<em class="kz">补丁是一个小文件，表示存储库中发生了什么变化。</em></li></ol><h1 id="131f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用GitHub REST API v3</h1><p id="6c65" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">基于上述要求，我们以下列方式检索数据。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/9d3f38a8d7397a2b3e1308ca36b076c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ytd-VByT9jHavTXX"/></div></div></figure><h1 id="0c75" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">问题</h1><p id="7f29" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">让我们看看上述方法面临的问题:</p><ul class=""><li id="dc0c" class="ko kp hu it b iu iv iy iz jc lu jg lv jk lw jo lx kw kx ky dt translated"><strong class="it hv">HTTP调用次数</strong></li></ul><p id="6bf3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我想从5个GitHub存储库中获取所需的数据。</p><ol class=""><li id="5a40" class="ko kp hu it b iu iv iy iz jc lu jg lv jk lw jo kv kw kx ky dt translated">获取存储库详细信息的HTTP调用(计数:1)</li><li id="8117" class="ko kp hu it b iu la iy lb jc lc jg ld jk le jo kv kw kx ky dt translated">对于每个存储库，我们得到30个拉请求数据(计数:5)</li><li id="8a93" class="ko kp hu it b iu la iy lb jc lc jg ld jk le jo kv kw kx ky dt translated">对于每个pull请求，我们进行1次HTTP调用来获取pull请求的问题数据(计数:30*5 = 150)</li><li id="9480" class="ko kp hu it b iu la iy lb jc lc jg ld jk le jo kv kw kx ky dt translated">对于每个pull请求，我们进行1次HTTP调用来获取pull请求的补丁/差异数据(计数:30*5 = 150)</li></ol><p id="ff50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们总共进行了<strong class="it hv"><em class="kz">【306】HTTP</em></strong><strong class="it hv">调用</strong>来获取基于搜索查询的5个存储库的问题和补丁数据。</p><ul class=""><li id="6064" class="ko kp hu it b iu iv iy iz jc lu jg lv jk lw jo lx kw kx ky dt translated"><strong class="it hv">删除未使用的数据</strong></li></ul><p id="3b75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次HTTP调用后，响应中只有少数字段用于后续调用。从响应中删除未使用的数据变得必要，以便减小最终输出的大小。</p><h1 id="1501" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">GraphQL是什么？</h1><p id="d1a0" class="pw-post-body-paragraph ir is hu it b iu kq iw ix iy kr ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">来自graphql.org的:</p><blockquote class="ly lz ma"><p id="b5ad" class="ir is kz it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。</p></blockquote><h1 id="5012" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么要用GitHub的GraphQL API？</h1><ul class=""><li id="2af8" class="ko kp hu it b iu kq iy kr jc ks jg kt jk ku jo lx kw kx ky dt translated"><strong class="it hv">HTTP呼叫大幅减少</strong></li></ul><p id="1131" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的场景中，当我们使用GitHub的REST API时，我们进行了306次HTTP调用来检索数据。所有这些数据现在都可以通过很少的HTTP调用来接收。我们将在下一篇文章中看到HTTP调用的精确计数和关于实现的细节。</p><ul class=""><li id="7ee3" class="ko kp hu it b iu iv iy iz jc lu jg lv jk lw jo lx kw kx ky dt translated"><strong class="it hv">只获取必填字段</strong></li></ul><p id="6ce8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们只收到我们要求的数据——不多也不少。我们不再需要删除未使用的数据。</p><ul class=""><li id="e380" class="ko kp hu it b iu iv iy iz jc lu jg lv jk lw jo lx kw kx ky dt translated"><strong class="it hv">单端点</strong></li></ul><p id="fb51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们不再需要使用不同的URL(如REST API调用)来检索数据。GraphQL有一个独立于所需数据的端点。</p><p id="7b29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前，GitHub的GraphQL API不支持上述用例。一个<a class="ae jp" href="https://platform.github.community/t/schema-request-get-patch-diff-file-for-the-pull-request/7035?u=amrishjhaveri" rel="noopener ugc nofollow" target="_blank">请求</a>也是为了同样的目的。</p><div class="me mf fm fo mg mh"><a href="https://github.com/AmrishJhaveri/Git-Repo-Analyzer" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">amrishjaveri/Git-Repo-Analyzer</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">Git-Repo-Analyzer -使用它的REST API从Github获取数据，然后在补丁中查找模式…</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">github.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ls mh"/></div></div></a></div></div><div class="ab cl mw mx hc my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hn ho hp hq hr"><p id="d846" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kz">原载于2018年8月18日</em><a class="ae jp" href="https://www.linkedin.com/pulse/why-i-felt-need-use-graphql-amrish-jhaveri/" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://www.linkedin.com</em></a><em class="kz">。</em></p><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>