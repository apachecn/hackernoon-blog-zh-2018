<html>
<head>
<title>How to run a Sanity backed blog with React and Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React和Next.js运行一个健全的博客</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-run-a-sanity-backed-blog-with-react-and-next-js-805f4b466413?source=collection_archive---------4-----------------------#2018-08-19">https://medium.com/hackernoon/how-to-run-a-sanity-backed-blog-with-react-and-next-js-805f4b466413?source=collection_archive---------4-----------------------#2018-08-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9e74" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">有时候你只是需要一个博客。那么为什么不用一些闪亮的东西来构建它呢，比如Sanity、React和Next.js？</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/bc01506d0c38659e2a80ff2dc2c15aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oU56bUWBQ6rZ-aw5_FXuJg.png"/></div></div></figure><p id="08b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae kr" href="http://foo.bar/" rel="noopener ugc nofollow" target="_blank">有时候你只需要一个博客。虽然有大量的博客平台，但有很好的理由让你的博客内容与你的其他内容一起存在，无论是文档(就像我们的情况)，产品，投资组合还是其他什么。博客的内容模型，或者说数据模式，也是一个简单的起点，可以让你开始制作一些无头的东西，有着</a><a class="ae kr" href="https://hackernoon.com/tagged/sanity" rel="noopener ugc nofollow" target="_blank">的健全性</a>和一个分离的前端。</p><p id="ed06" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本教程中，我们将使用Sanity作为内容后端，使用基于React的框架Next.js来呈现网页。</p><p id="97e2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您不想输入以下所有内容，您也可以:</p><p id="e070" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">👉<a class="ae kr" href="https://github.com/sanity-io/sanity-blog-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">查看Github上的代码</strong> </a> <strong class="jx hv">👈</strong></p><h1 id="6961" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">1.安装Sanity和预配置的博客模式</h1><p id="04ea" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">如果您还没有这样做，请使用npm安装Sanity命令行(CLI)工具。</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="3c4e" class="lu kt hu lq b fv lv lw l lx ly">npm i -g @sanity/cli.</span></pre><p id="334a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这允许您在项目文件夹中运行<code class="eh lz ma mb lq b">sanity init</code>命令，事实上，这是下一步。你将被要求在Google或Github上创建一个账户。之后，您可以创建一个新项目，这时会要求您选择一个项目模板。选择博客模式模板。首先，您需要为您的项目和数据集命名(如果您需要一个数据集用于测试，您可以添加更多的数据集)，并为您想要存储content studio文件的位置选择一个路径。</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="c676" class="lu kt hu lq b fv lv lw l lx ly">$ Select project to use: Create new project <br/>$ Informal name for your project: sanity-tutorial-blog <br/>$ Name of your first data set: production <br/>$ Output path: ~/Sites/sanity-tutorials/blog <br/>$ Select project: template Blog (schema)</span></pre><p id="49fe" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">安装完成后，您可以运行<code class="eh lz ma mb lq b">sanity start</code>来启动Content Studio，在这里您可以开始编辑您的内容。一旦点击发布，这些内容将立即同步到云中，并通过API提供。通过运行<code class="eh lz ma mb lq b">sanity deploy</code>，你将上传这个工作室，并让那些有访问权限的人可以在网上使用它(你可以通过导航到<a class="ae kr" href="https://manage.sanity.io/" rel="noopener ugc nofollow" target="_blank"> manage.sanity.io </a>来添加用户)。</p><p id="b84f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt">—</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/d8d13f2767b0b79de81f547901eb0f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/0*9lV4kj-A0alAJAR9.png"/></div></figure><p id="5287" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">明白了<br/> </strong>您可以继续操作并使您的数据集私有，但是如果您这样做，您需要在<a class="ae kr" href="https://manage.sanity.io/" rel="noopener ugc nofollow" target="_blank"> manage.sanity.io </a>上为自己创建一个令牌，并将其添加到下面的客户端配置中。</p><p id="515f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt">—</p><p id="1c5f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以对存储在项目文件夹中的模式做很多事情，但是这是另一个教程的内容。现在，我们只想让我们的博客运行起来！</p><h1 id="9f4e" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">2.安装Next.js并让它运行</h1><p id="ae41" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">Next.js (由牛逼公司<a class="ae kr" href="https://zeit.co/" rel="noopener ugc nofollow" target="_blank"> Zeit </a>开发)提供了一个简洁的设置，用于制作基于React的网页，在第一次请求时提供服务器渲染，以及许多其他有用的功能。如果你已经习惯了<a class="ae kr" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>，或者已经尝试过create-react-app，这应该不难上手。</p><p id="2c55" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为您的前端文件创建一个文件夹，并运行<code class="eh lz ma mb lq b">npm init</code>为您的项目创建一个package.json文件。然后安装Next.js依赖项</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="f2ca" class="lu kt hu lq b fv lv lw l lx ly">npm install --save next react react-dom</span></pre><p id="54b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">并将以下内容添加到package.json中:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="eb8e" class="lu kt hu lq b fv lv lw l lx ly">{ <br/>  "scripts": { <br/>    "dev": "next", <br/>    "build": "next build", <br/>    "start": "next start"<br/>  }<br/>}</span></pre><p id="d9e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Next.js根据您在文件系统中的位置进行路由。因此，如果你添加一个名为<code class="eh lz ma mb lq b">pages</code>的文件夹，并添加<code class="eh lz ma mb lq b">index.js</code>，它将成为你网站的首页。同样，如果你在<code class="eh lz ma mb lq b">/pages</code>中添加<code class="eh lz ma mb lq b">about.js</code>，一旦你启动项目，这将显示在<code class="eh lz ma mb lq b"><a class="ae kr" href="http://localhost:3000/about" rel="noopener ugc nofollow" target="_blank">localhost:3000/about</a></code>上。为了确保一切就绪，尝试将以下代码添加到<code class="eh lz ma mb lq b">pages/index.js</code>，并在shell中键入<code class="eh lz ma mb lq b">npm run dev</code>:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="e1af" class="lu kt hu lq b fv lv lw l lx ly">const Index = (props) =&gt; &lt;div&gt;Hello world!&lt;/div&gt; export default Index</span></pre><p id="a464" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，如果你在浏览器中前往<code class="eh lz ma mb lq b"><a class="ae kr" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">localhost:3000</a></code>，你应该有一个对世界的问候。</p><h1 id="503f" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">3.制作动态页面模板</h1><p id="6200" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">到目前为止一切顺利，但现在是有趣的部分:让我们从Sanity中获取一些内容，并在React中呈现出来。首先安装连接到Sanity API所需的依赖项:<code class="eh lz ma mb lq b">npm install @sanity/client --save</code>。在根前端文件夹中创建一个名为<code class="eh lz ma mb lq b">client.js</code>的新文件。打开文件，放入以下内容:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="fa2c" class="lu kt hu lq b fv lv lw l lx ly">import sanityClient from '@sanity/client'<br/>export default sanityClient({<br/>  projectId: 'your-project-id',<br/>  dataset: 'production',<br/>  useCdn: true<br/>})</span></pre><p id="e54e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为每个新的博客条目添加一个新文件是不切实际的。甚至是一场争论。因此，让我们制作一个页面模板，使我们能够使用来自Sanity的URL slugs。不幸的是，Next.js没有开箱即用的动态页面。为了解决这个问题，我们必须添加一些服务器代码。让我们重用来自<code class="eh lz ma mb lq b">nextjs/examples</code>的代码，并使用以下代码在根文件夹中添加一个<code class="eh lz ma mb lq b">server.js</code>文件:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="095c" class="lu kt hu lq b fv lv lw l lx ly">const { createServer } = require('http')<br/>const { parse } = require('url')<br/>const next = require('next')<br/>const pathMatch = require('path-match')</span><span id="76cc" class="lu kt hu lq b fv md lw l lx ly">const port = parseInt(process.env.PORT, 10) || 3000<br/>const dev = process.env.NODE_ENV !== 'production'<br/>const app = next({ dev })<br/>const handle = app.getRequestHandler()<br/>const route = pathMatch()<br/>const match = route('/blog/:slug')</span><span id="e127" class="lu kt hu lq b fv md lw l lx ly">app.prepare().then(() =&gt; {<br/>  createServer((req, res) =&gt; {<br/>    const { pathname, query } = parse(req.url, true)<br/>    const params = match(pathname)<br/>    if (params === false) {<br/>      handle(req, res)<br/>      return<br/>    }<br/>    // assigning `query` into the params means that we still<br/>    // get the query string passed to our application<br/>    // i.e. /blog/foo?show-comments=true<br/>    app.render(req, res, '/blog', Object.assign({}, query, params))<br/>  }).listen(port, err =&gt; {<br/>    if (err) throw err<br/>    console.log(`&gt; Ready on <a class="ae kr" href="http://localhost:${port}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`</a>)<br/>  })<br/>})</span></pre></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/9e9c7403b1873ccb89c66f1085bb94cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/0*b_oowmJJYdZJPpkR.png"/></div></figure><p id="aa5b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">明白了</strong></p><p id="4ef5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您对<code class="eh lz ma mb lq b">server.js </code>或<code class="eh lz ma mb lq b">package.json</code>进行更改，您必须重启<code class="eh lz ma mb lq b">npm run dev</code></p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="c57c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您还应该运行<code class="eh lz ma mb lq b">npm install http url path-match --save </code>以获得必要的依赖项，并将<code class="eh lz ma mb lq b">package.json</code>中的脚本部分更改为:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="c603" class="lu kt hu lq b fv lv lw l lx ly">{ <br/>  "scripts": { <br/>    "dev": "node server.js",<br/>    "build": "next build",<br/>    "start": "NODE_ENV=production node server.js" <br/>  } <br/>}</span></pre><p id="b7db" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您的前端文件夹现在应该如下所示:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="d035" class="lu kt hu lq b fv lv lw l lx ly">~/blog/frontend<br/>$ tree -I node_modules<br/>.<br/>├── client.js<br/>├── package-lock.json<br/>├── package.json<br/>└── pages<br/>    ├── blog.js<br/>    └── index.js<br/>├── server.js<br/>1 directory, 6 files</span></pre><p id="13de" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Next.js附带了一个名为<code class="eh lz ma mb lq b">getInitialProps</code>的特殊函数，在<code class="eh lz ma mb lq b">/pages</code>中呈现模板之前，调用该函数并向react组件返回道具。这是获取页面所需数据的绝佳位置。</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/3468474ca4b060ed80525d27e39aead3.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/0*YLKY8lmz9XneGYSc.png"/></div></figure><p id="3102" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">抓住你了</strong></p><p id="0dfc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh lz ma mb lq b">getInitialProps</code>只对pages文件夹中的文件<em class="ml">起作用，并用于路由，也就是说，它不会被包含在这些页面中的react组件调用。<a class="ae kr" href="https://github.com/zeit/next.js/#user-content-fetching-data-and-component-lifecycle" rel="noopener ugc nofollow" target="_blank">阅读Next.js文档了解更多信息。</a></em></p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="0927" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有很多不同的方法可以编写react页面组件，这只是一个简单的例子，可以让你更容易上手。将以下内容放入blog.js。这里我们将slug设置为标题，只是为了在添加从Sanity获取内容的代码之前测试代码是否有效:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="31e3" class="lu kt hu lq b fv lv lw l lx ly">const Post = ({ title = 'No title' }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{title}&lt;/h1&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="f674" class="lu kt hu lq b fv md lw l lx ly">Post.getInitialProps = ({ query: { slug = '' } }) =&gt; { <br/>  const title = slug<br/>  return { title }<br/>}</span><span id="1703" class="lu kt hu lq b fv md lw l lx ly">export default Post</span></pre><p id="2c80" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你转到<code class="eh lz ma mb lq b">localhost:3000/blog/whatever</code>，你现在应该看到“whatever”作为H1打印在页面上。</p><h1 id="f629" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">4.从理智中获取一些内容</h1><p id="159b" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">我们现在已经为Next.js设置了一个用于首页的模板(index.js)和一个自定义服务器，该服务器使blog.js模板可以将/blog/下的slug作为查询。现在有趣的部分开始了，让我们给这个组合增加一些理智:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="fed6" class="lu kt hu lq b fv lv lw l lx ly">import client from '../client'</span><span id="ac2a" class="lu kt hu lq b fv md lw l lx ly">const BlogPost = ({ title = 'No title' }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{title}&lt;/h1&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="2a28" class="lu kt hu lq b fv md lw l lx ly">BlogPost.getInitialProps = async ({ query: { slug } }) =&gt; {<br/>  const { title } = await client.fetch('*[_type == "post" &amp;&amp; slug.current == $slug][0]', { slug })<br/>  return { title }<br/>}</span><span id="bdd3" class="lu kt hu lq b fv md lw l lx ly">export default BlogPost</span></pre><p id="b415" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们使用async/await，因为我们正在进行异步API调用，这使得代码更容易理解。<code class="eh lz ma mb lq b">client.fetch()</code>接受两个参数:<a class="ae kr" href="https://www.sanity.io/docs/data-store/how-queries-work" rel="noopener ugc nofollow" target="_blank">一个查询</a>和一个带有参数和值的对象。</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/dcd37f287d8c06c57a5df1450cd675ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/0*WzeV8FOOEH4anQ4u.png"/></div></figure><p id="274d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">亲提示</strong></p><p id="b9b9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">本教程中的GROQ语法可以这样理解:</p><p id="1c32" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh lz ma mb lq b">*</code>👈选择所有文档</p><p id="c39a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh lz ma mb lq b">[_type == 'post' &amp;&amp; slug.current == $slug]</code>👈将所选内容向下过滤到类型为“post”的文档，以及那些与我们在参数中的slug相同的文档</p><p id="e822" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh lz ma mb lq b">[0]</code>👈选择列表中的第一个也是唯一一个</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="daf5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了让前端服务器真正从Sanity获取数据，我们必须将其域添加到<a class="ae kr" href="https://www.sanity.io/docs/front-ends/cors" rel="noopener ugc nofollow" target="_blank"> CORS设置</a>。换句话说，我们必须将<code class="eh lz ma mb lq b">localhost:3000</code>(以及最终你的博客所在的域名)添加到Sanity的CORS源设置中。如果您在shell中输入<code class="eh lz ma mb lq b">sanity manage</code>,您将在浏览器中看到该项目的设置。导航到设置并添加<code class="eh lz ma mb lq b">http://localhost:3000</code>作为新的原点。</p><p id="7162" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，你可以创建并发布一个至少有一段文字和一个标题的帖子:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mm"><img src="../Images/ecbe57d082bb72457a01f0c6d61fcd3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T65nvLuJahq__ncB"/></div></div></figure><p id="28eb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你向世界致意，世界最终也会向你致意</p><p id="1970" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">转到<a class="ae kr" href="http://localhost:3000/hello-world" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/Hello-world</a>并确认H1拼写为“Hello world！”。现在，您已经成功地将前端与理智连接起来。🎉</p><h1 id="c25f" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">5.添加作者和类别署名</h1><p id="ee9f" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">在Content Studio中，您会发现，您可以为作者和类别添加条目。去添加至少一个有图片的作者。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/598f8d659c8951684eda8c264d8ef345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/0*UjvLr9JRyRA7UVKG"/></div></figure><p id="ed0c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我</p><p id="cd1a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">回到你的博客文章，在作者栏附上这个作者，像这样:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/6f20cd17d29d00fc8dac4b0d227f71fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*_il5bbGrC-J9qPVn"/></div></figure><p id="2acc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">发布更改，然后回到代码编辑器。我们刚刚做的是<em class="ml">引用</em>一个来自博客帖子的作者。引用是健全性的一个强大部分，它使得跨类型连接和重用内容成为可能。如果<em class="ml">检查</em>您的块文档(<code class="eh lz ma mb lq b">Ctrl + alt/opt + i</code>)，您会看到该对象看起来像这样:</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="7fec" class="lu kt hu lq b fv lv lw l lx ly">"author": {<br/>  "_ref": "fdbf38ad-8ac5-4568-8184-1db8eede5d54",<br/>  "_type": "reference"<br/>}</span></pre><p id="66f0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果我们现在只取出了author变量(<code class="eh lz ma mb lq b">const { title, author } = await client.fetch('*[slug.current == $slug][0]',{ slug })</code>)，这就是我们将得到的内容，在这种情况下这对我们不是很有用。这就是GROQ中的<em class="ml">投影</em>派上用场的地方。<a class="ae kr" href="https://www.sanity.io/docs/data-store/query-cheat-sheet#object-projections" rel="noopener ugc nofollow" target="_blank"> Projections是GROQ </a>的一个强大特性，允许我们指定API-response来满足我们的需求。</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="6a39" class="lu kt hu lq b fv lv lw l lx ly">import client from '../client'</span><span id="a803" class="lu kt hu lq b fv md lw l lx ly">const BlogPost = ({ title = 'No title', name = 'No name' }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{title}&lt;/h1&gt;<br/>    &lt;span&gt;By {name}&lt;/span&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="a558" class="lu kt hu lq b fv md lw l lx ly">BlogPost.getInitialProps = async ({ query: { slug } }) =&gt; {<br/>  const document = await client.fetch('*[_type == "post" &amp;&amp; slug.current == $slug][0]{title, "name": author-&gt;name}', { slug })<br/>  return document<br/>}</span><span id="157b" class="lu kt hu lq b fv md lw l lx ly">export default BlogPost</span></pre><p id="9730" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这里，我将投影<code class="eh lz ma mb lq b">{title, "name": author-&gt;name}</code>添加到我们的查询中。在这里，我指定我希望在API调用中返回文档中的什么内容。我们需要为作者姓名创建一个键，并使用箭头<code class="eh lz ma mb lq b">-&gt;</code>跟踪对作者文档上name-property的引用。换句话说，我们要求Sanity遵循<code class="eh lz ma mb lq b">_ref</code>下的id，并从该文档中返回名为<code class="eh lz ma mb lq b">name</code>的变量的值。</p><p id="46bc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们试着对类别做同样的事情。首先，在Content Studio中创建至少两个类别。我给<em class="ml"> Next.js </em>加了一个，给<em class="ml">教程</em>加了一个。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/26cd1966ff8456f318b3c193c523b912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/0*EAlaz407MWF8sGSd"/></div></figure><p id="91df" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将类别添加到您的博客文章中</p><p id="c9e4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们的博客文章中有了一系列对类别的引用。如果您在文档检查器中取一个峰值，您会看到这些显示为作者条目，带有<code class="eh lz ma mb lq b">_ref</code> -id的对象。所以我们也必须使用投影来得到这些。</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="e7b2" class="lu kt hu lq b fv lv lw l lx ly">import client from '../client'</span><span id="57d5" class="lu kt hu lq b fv md lw l lx ly">const BlogPost = ({ title = 'No title', name = 'No name', categories = [] }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{title}&lt;/h1&gt;<br/>    &lt;span&gt;By {name}.&lt;/span&gt;<br/>    {categories &amp;&amp; (<br/>      &lt;ul&gt;Posted in<br/>        { categories.map(category =&gt; (<br/>          &lt;li key={category}&gt;{category}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>      )<br/>    }<br/>  &lt;/div&gt;<br/>)</span><span id="b6ec" class="lu kt hu lq b fv md lw l lx ly">BlogPost.getInitialProps = async ({ query: { slug } }) =&gt; {<br/>  const document = await client.fetch('*[_type == "post" &amp;&amp; slug.current == $slug][0]{title, "name": author-&gt;name, "categories": categories[]-&gt;title}', { slug })<br/>  return document<br/>}</span><span id="1f84" class="lu kt hu lq b fv md lw l lx ly">export default BlogPost</span></pre><p id="b723" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">类别的投影与author非常相似，唯一的区别是我在关键类别上加了方括号，因为这是一个引用数组。</p><p id="b555" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是我们也想把作者的照片添加到署名中！Sanity中的图像和文件资产也是引用，这意味着如果我们要获得作者图像，我们首先必须遵循对作者文档和图像资产的引用。我们可以通过访问<code class="eh lz ma mb lq b">"imageUrl": author-&gt;image.asset-&gt;url</code>直接检索imageUrl，但是这里使用我们制作的<a class="ae kr" href="https://www.sanity.io/docs/front-ends/presenting-images" rel="noopener ugc nofollow" target="_blank">图像Url包</a>更容易。用<code class="eh lz ma mb lq b">npm i --save @sanity/image-url</code>在前端工程中安装包。它获取图像对象并确定从哪里获取图像，这使得使用焦点特征等变得更加容易。</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="90c8" class="lu kt hu lq b fv lv lw l lx ly">import client from '../client'<br/>import imageUrlBuilder from '<a class="ae kr" href="http://twitter.com/sanity/image-url" rel="noopener ugc nofollow" target="_blank">@sanity/image-url</a>'<br/>const builder = imageUrlBuilder(client)</span><span id="0ea2" class="lu kt hu lq b fv md lw l lx ly">function urlFor(source) {<br/>  return builder.image(source)<br/>}</span><span id="5d09" class="lu kt hu lq b fv md lw l lx ly">const BlogPost = ({ title = 'No title', name = 'No name', categories = [], authorImage = {} }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{title}&lt;/h1&gt;<br/>    &lt;span&gt;By {name}.&lt;/span&gt;<br/>    {categories &amp;&amp; (<br/>      &lt;ul&gt;Posted in<br/>        { categories.map(category =&gt; (<br/>          &lt;li key={category}&gt;{category}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>      )<br/>    }<br/>    &lt;div&gt;<br/>      &lt;img src={urlFor(authorImage).width(50).url()} /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="111f" class="lu kt hu lq b fv md lw l lx ly">BlogPost.getInitialProps = async ({ query: { slug } }) =&gt; {<br/>  const document = await client.fetch(`*[_type == "post" &amp;&amp; slug.current == $slug][0]{<br/>      title,<br/>      "name": author-&gt;name,<br/>      "categories": categories[]-&gt;title,<br/>      "authorImage": author-&gt;image<br/>    }`, { slug })<br/>  return document<br/>}</span><span id="f3eb" class="lu kt hu lq b fv md lw l lx ly">export default BlogPost</span></pre><p id="bb51" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">放入图像URL构建器的代码行后，我们可以在<code class="eh lz ma mb lq b">urlFor()</code>函数中发送来自Sanity的图像对象，并在不同的方法(例如<code class="eh lz ma mb lq b">.width(50)</code>)后面添加<code class="eh lz ma mb lq b">.url()</code>-方法。</p><h1 id="2b77" class="ks kt hu bd ku kv kw kx ky kz la lb lc ja ld jb le jd lf je lg jg lh jh li lj dt translated">6.添加富文本内容</h1><p id="2e82" class="pw-post-body-paragraph jv jw hu jx b jy lk iv ka kb ll iy kd ke lm kg kh ki ln kk kl km lo ko kp kq hn dt translated">如果没有对文本内容的强大支持，一个博客就没有意义了。Sanity中的富文本是以一种允许我们在许多不同的上下文中使用它的方式构建的:从浏览器中的HTML到语音界面中的语音实现。关于块内容和它的可扩展性有很多要说的，但在本教程中，我们将只使用包<a class="ae kr" href="https://github.com/sanity-io/block-content-to-react" rel="noopener ugc nofollow" target="_blank">块内容反应</a>附带的现成特性。用<code class="eh lz ma mb lq b">npm install --save @sanity/block-content-to-react</code>安装。</p><pre class="jk jl jm jn fq lp lq lr ls aw lt dt"><span id="a4e8" class="lu kt hu lq b fv lv lw l lx ly">import BlockContent from '<a class="ae kr" href="http://twitter.com/sanity/block-content-to-react" rel="noopener ugc nofollow" target="_blank">@sanity/block-content-to-react</a>'<br/>import imageUrlBuilder from '<a class="ae kr" href="http://twitter.com/sanity/image-url" rel="noopener ugc nofollow" target="_blank">@sanity/image-url</a>'<br/>import client from '../client'<br/>const builder = imageUrlBuilder(client)<br/>function urlFor(source) {<br/>  return builder.image(source)<br/>}<br/>const BlogPost = ({ title = 'No title', name = 'No name', categories = [], authorImage = {}, body = [] }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{title}&lt;/h1&gt;<br/>    &lt;span&gt;By {name}.&lt;/span&gt;<br/>    {categories &amp;&amp; (<br/>      &lt;ul&gt;Posted in<br/>        { categories.map(category =&gt; (<br/>          &lt;li key={category}&gt;{category}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>      )<br/>    }<br/>    &lt;div&gt;<br/>      &lt;img src={urlFor(authorImage).width(50).url()} /&gt;<br/>    &lt;/div&gt;<br/>    &lt;BlockContent<br/>      blocks={body}<br/>      imageOptions={{w: 320, h: 240, fit: 'max'}}<br/>      projectId={client.clientConfig.projectId}<br/>      dataset={client.clientConfig.dataset}<br/>    /&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="f11d" class="lu kt hu lq b fv md lw l lx ly">BlogPost.getInitialProps = async ({ query: { slug } }) =&gt; {<br/>  const document = await client.fetch(`*[_type == "post" &amp;&amp; slug.current == $slug][0]{<br/>      title,<br/>      "name": author-&gt;name,<br/>      "categories": categories[]-&gt;title,<br/>      "authorImage": author-&gt;image,<br/>      body<br/>    }`, { slug })<br/>  return document<br/>}</span><span id="d41b" class="lu kt hu lq b fv md lw l lx ly">export default BlogPost</span></pre><p id="91de" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们将react-component作为<code class="eh lz ma mb lq b">BlockContent</code>导入，并从post-document获取主体。我们将主体作为<code class="eh lz ma mb lq b">blocks-prop</code>发送，并添加<code class="eh lz ma mb lq b">projectID</code>和来自<code class="eh lz ma mb lq b">client-config</code>的数据集，以便让<code class="eh lz ma mb lq b">BlockContent</code>组件知道从哪里获取可能出现在富文本字段中的图像。</p><p id="480b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我还加了一个道具叫<code class="eh lz ma mb lq b">imageOptions</code>，控制图片默认输出。就是这样！您可以<a class="ae kr" href="https://github.com/sanity-io/block-content-to-react" rel="noopener ugc nofollow" target="_blank">定制不同元素的输出，甚至通过发送我们称之为“序列化器”的东西来添加您自己的定制块类型</a>——我们将在另一篇博客文章中介绍这些。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/e808695b8d2fd5a63af64ce82e7aae6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/0*ZdXb7CNz8oPa0nSZ"/></div></figure><p id="131a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果一切顺利，您应该有一个基本的博客模板</p><p id="522b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">本教程到此结束！当谈到为一个非常常见的内容设置编写前端层时，我们现在已经涉及了很多内容，但是仅仅涉及了我们可以通过结合使用Sanity和React来完成的功能和漂亮的事情的冰山一角。</p><p id="24ef" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您可以从GitHub 下载<a class="ae kr" href="https://github.com/sanity-io/sanity-blog-tutorial" rel="noopener ugc nofollow" target="_blank">示例项目，并随时向我们询问关于</a><a class="ae kr" href="https://slack.sanity.io" rel="noopener ugc nofollow" target="_blank"> Slack </a>的问题，或者您可能找到我们的其他方式。</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="63c2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="ml">最初发布于</em><a class="ae kr" href="https://www.sanity.io/blog/build-your-own-blog-with-sanity-and-next-js" rel="noopener ugc nofollow" target="_blank"><em class="ml">www . sanity . io</em></a><em class="ml">。</em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>