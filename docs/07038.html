<html>
<head>
<title>With TypeScript 3, you are already missing out when mocking or faking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript 3，您已经错过了嘲笑或伪造的机会</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/with-typescript-3-and-substitute-js-you-are-already-missing-out-when-mocking-or-faking-a3b3240c4607?source=collection_archive---------5-----------------------#2018-08-21">https://medium.com/hackernoon/with-typescript-3-and-substitute-js-you-are-already-missing-out-when-mocking-or-faking-a3b3240c4607?source=collection_archive---------5-----------------------#2018-08-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="cd87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们开始之前，我知道以下几点:</p><ul class=""><li id="6394" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">我用了一个点击半点击的标题让你来到这里。</li><li id="8522" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">我无耻地分享了许多现有框架中的另一个<a class="ae kd" href="https://hackernoon.com/tagged/mocking" rel="noopener ugc nofollow" target="_blank">嘲讽</a>/作伪框架(<code class="eh ke kf kg kh b">substitute.js</code>)。</li><li id="af10" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">我是这个框架的作者。</li><li id="06bd" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">我不是脸书或谷歌，只是一个像你一样的开发者。</li><li id="f13d" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">我甚至不是一个作家——你一定已经猜到了这一点。</li></ul><p id="f605" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以为什么要注意，甚至给我多一分钟你的时间？</p><p id="8c62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单。我几乎可以肯定，我可以把那一分钟还给你，在未来，我还可以把更多的时间还给你。</p><p id="c21c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会详细讨论什么是假装或嘲笑，或者为什么这是个好主意。这篇文章假设你已经知道了。</p><h2 id="20d7" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">目录</h2><ul class=""><li id="fe1c" class="jp jq hu it b iu ld iy le jc lf jg lg jk lh jo ju jv jw jx dt translated"><a class="ae kd" rel="noopener" href="/p/a3b3240c4607#d827">用代码样本比较框架</a></li><li id="3981" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated"><a class="ae kd" rel="noopener" href="/p/a3b3240c4607#28f2">限制</a></li><li id="fdb2" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated"><a class="ae kd" rel="noopener" href="/@mathiaslykkegaardlorenzen/with-typescript-3-and-substitute-js-you-are-already-missing-out-when-mocking-or-faking-a3b3240c4607#a048">获取substitute.js </a></li></ul></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="d827" class="lp kj hu bd kk lq lr ls ko lt lu lv ks lw lx ly kv lz ma mb ky mc md me lb mf dt translated">将框架与代码示例进行比较</h1><p id="6439" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">下面所有的例子都假设有一个名为<code class="eh ke kf kg kh b">RealCalculator</code>的类和一个支持它的名为<code class="eh ke kf kg kh b">CalculatorInterface</code>的接口。这些分别定义如下。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="8fbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了这些类型的定义，让我们继续。我希望这些例子不言自明，并且您会同意以下观点:</p><ul class=""><li id="e087" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">那个<code class="eh ke kf kg kh b">substitute.js</code>语法更容易记，更容易学，写起来更快。</li><li id="1579" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">由于对TDD的影响，伪造/模仿接口的能力是现有框架的一个巨大优势。</li></ul></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="994e" class="lp kj hu bd kk lq lr ls ko lt lu lv ks lw lx ly kv lz ma mb ky mc md me lb mf dt translated">创建一个类的模拟</h1><h2 id="2bfe" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="c8ad" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">使用<code class="eh ke kf kg kh b">ts-mockito</code>,你首先创建一个模仿的“类”或“构造函数”,然后你可以从这个模仿创建一个真正的非伪造的实例。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="6c71" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="3946" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">typemoq</code>也是如此。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="8d8f" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="b18f" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">substitute.js</code>，实例和赝品是一回事。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="ebda" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">创建界面的模拟</h1><p id="e61c" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">从一个接口创建一个mock使得<a class="ae kd" href="https://hackernoon.com/tagged/tdd" rel="noopener ugc nofollow" target="_blank"> TDD </a>变得更加容易，代码也少了很多，同时还能继续编译。使用界面模拟，您可以:</p><ol class=""><li id="2128" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo mv jv jw jx dt translated">从定义接口开始(没有实现)。</li><li id="edfb" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo mv jv jw jx dt translated">依赖于代码中的那些接口。</li><li id="64a8" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo mv jv jw jx dt translated">使用fakes为接口编写测试(您可以在不首先编写类的情况下伪造接口！).</li><li id="859d" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo mv jv jw jx dt translated">用真实的类实现代码。</li><li id="ccef" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo mv jv jw jx dt translated">微笑。你能够拥有完整的强类型，以及实际上在整个过程中一直编译的东西。没有弯弯曲曲的线条，只有纯粹愉快的TDD。</li></ol><h2 id="054c" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="0c11" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">遗憾的是，这不受支持。</p><h2 id="5ffe" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="8f81" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">typemoq</code>也是一样——不支持。</p><h2 id="2f9f" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="9c76" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">在<code class="eh ke kf kg kh b">substitute.js</code>中，你可以从一个<a class="ae kd" href="https://hackernoon.com/tagged/interface" rel="noopener ugc nofollow" target="_blank">接口</a>伪造就可以了。由于ES6代理，这背后的魔力是可能的。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="acc2" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">存根方法</h1><p id="9290" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">在这个例子中，我们将比较三个框架如何处理方法的存根。</p><h2 id="ab6e" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="1df1" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">使用<code class="eh ke kf kg kh b">ts-mockito</code>,您可以在包装函数中指定模拟对象的参数和返回值。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="393b" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="4eaf" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">typemoq</code>也是如此。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="858a" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="3e3d" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">substitute.js</code>，您可以在mock本身上定义返回值，并以流畅和强类型的方式使用它。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="6482" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">存根属性</h1><p id="f7e4" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">在这个例子中，我们将比较三个框架如何处理属性的存根。</p><h2 id="4a08" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="806c" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">使用<code class="eh ke kf kg kh b">ts-mockito</code>可以在包装函数中指定模拟对象的返回值。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="409b" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="e507" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">typemoq</code>也是如此。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="15e7" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="a568" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">substitute.js</code>，您可以在mock本身上定义返回值，并以流畅和强类型的方式使用它。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="ca2d" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">投掷错误</h1><p id="a3c6" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">在这个例子中，我们将比较三个框架如何处理抛出错误。所有框架中相同的语法也以类似于上面描述的方式应用于方法，所以我们不会再赘述。</p><h2 id="c878" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="cdc7" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">使用<code class="eh ke kf kg kh b">ts-mockito</code>,您可以在包装器函数中指定要在模拟对象上抛出的异常。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="a56f" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="a852" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">typemoq</code>也是如此。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="80f9" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="42a8" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">substitute.js</code>，您使用<code class="eh ke kf kg kh b">returns</code>函数并将其封装在lambda中以抛出错误。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="03c8" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">呼叫计数验证</h1><p id="ada6" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">在这个例子中，我们将比较三个框架如何处理调用计数验证。所有框架中相同的语法也适用于属性，所以我们不会详细讨论。</p><p id="b8ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mw">注意</em> <code class="eh ke kf kg kh b"><em class="mw">substitute.js</em></code> <em class="mw">不支持“至少</em> <code class="eh ke kf kg kh b"><em class="mw">n</em></code> <em class="mw">次”验证，也不支持“少于</em> <code class="eh ke kf kg kh b"><em class="mw">n</em></code> <em class="mw">次”验证，因为我个人认为这是不好的做法——你的测试应该总是确定性的。你应该总是知道在测试中预期的调用数量。</em></p><h2 id="8b39" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="290f" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">使用<code class="eh ke kf kg kh b">ts-mockito</code>,您可以在包装函数中指定要匹配的模拟对象的操作。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="a08c" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="35af" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">typemoq</code>也是一样。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="67f7" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="858b" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">substitute.js</code>，您使用<code class="eh ke kf kg kh b">received</code>函数并对其返回值调用操作。</p><p id="6436" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，你也可以使用<code class="eh ke kf kg kh b">didNotReceive</code>,它完全符合你的预期。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="31e3" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">代理呼叫</h1><p id="5cea" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">如果你想让你的假方法做别的事情，代理调用可能是有用的。</p><h2 id="de4e" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="a4e3" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">使用<code class="eh ke kf kg kh b">ts-mockito</code>,您可以在包装器函数中指定匹配模拟对象的操作，然后使用另一个函数来指定代理调用哪个方法。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="7ab9" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="6a36" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">typemoq</code>也是如此。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="4cc8" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="cf1f" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">substitute.js</code>，您使用<code class="eh ke kf kg kh b">mimicks</code>函数，并指定将调用代理到哪个函数。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="bb41" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">匹配参数</h1><p id="230a" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">参数匹配器可以让你更明确地知道什么时候你想伪造什么，或者你希望收到什么样的呼叫。</p><h2 id="e31e" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="28f4" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">使用<code class="eh ke kf kg kh b">ts-mockito</code>，您可以使用像<code class="eh ke kf kg kh b">anything</code>和<code class="eh ke kf kg kh b">between</code>这样的函数来匹配参数。</p><p id="f1db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mw">我还没有找到在</em> <code class="eh ke kf kg kh b"><em class="mw">ts-mockito</em></code> <em class="mw">中指定自定义lambda来表达自定义匹配器的方法——如果你知道的话，请在评论部分告诉我。</em></p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="8a0b" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="13a2" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">几乎和<code class="eh ke kf kg kh b">ts-mockito</code>一样，但是支持lambdas。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="86ff" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="f9ab" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">在这里，语法清晰明了。一个很好的小细节是，即使在您键入时，也一直有强类型，有完整的类型推断(它甚至知道<code class="eh ke kf kg kh b">Arg.is</code>函数中的<code class="eh ke kf kg kh b">x</code>是什么类型)。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="1910" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">呼叫验证产生的错误</h1><p id="05ea" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">如果你想让你的假方法做别的事情，代理调用可能是有用的。</p><h2 id="a0c6" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">ts-mockito</h2><p id="c033" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated"><code class="eh ke kf kg kh b">ts-mockito</code>显示方法名称和参数以及预期的调用次数，但不显示记录的总调用次数。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="9164" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码抛出:</p><blockquote class="mx my mz"><p id="3b3b" class="ir is mw it b iu iv iw ix iy iz ja jb na jd je jf nb jh ji jj nc jl jm jn jo hn dt translated">应该至少调用1次“add(strictEqual(1)，strictEqual(2)”。但已被调用0次。</p></blockquote><h2 id="c8e1" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">类型起订量</h2><p id="5ca0" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">typemoq</code>来说也是一样，除了它还显示一个电话记录列表</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="9e0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码抛出:</p><blockquote class="mx my mz"><p id="347a" class="ir is mw it b iu iv iw ix iy iz ja jb na jd je jf nb jh ji jj nc jl jm jn jo hn dt translated">应至少调用real calculator . add(it . is value(1)，it . is value(2))1次，调用了0次</p><p id="787b" class="ir is mw it b iu iv iw ix iy iz ja jb na jd je jf nb jh ji jj nc jl jm jn jo hn dt translated">已配置的设置:<br/>real calculator . add(it . is value(1)，It.isValue(2))</p><p id="dbc7" class="ir is mw it b iu iv iw ix iy iz ja jb na jd je jf nb jh ji jj nc jl jm jn jo hn dt translated">执行的调用:<br/> RealCalculator.add(3，4)</p></blockquote><h2 id="c899" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">替代品. js</h2><p id="28a1" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">对于<code class="eh ke kf kg kh b">substitute.js</code>,您使用<code class="eh ke kf kg kh b">mimicks</code>函数并指定将调用代理到哪个函数。</p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="1204" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的代码会抛出:</p><blockquote class="mx my mz"><p id="7e4e" class="ir is mw it b iu iv iw ix iy iz ja jb na jd je jf nb jh ji jj nc jl jm jn jo hn dt translated">应使用参数[1，2]对方法c进行一次或多次调用，但未收到任何此类调用。<br/>收到的对方法c的所有调用:<br/> - &gt; 1个带有参数[3，4]的调用</p></blockquote><h1 id="28f2" class="lp kj hu bd kk lq mq ls ko lt mr lv ks lw ms ly kv lz mt mb ky mc mu me lb mf dt translated">限制</h1><p id="c80d" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">以上看起来都挺好的吧？但是像其他框架一样，<code class="eh ke kf kg kh b">substitute.js</code>也有局限性。</p><p id="6b5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面列出了其他框架能做而<code class="eh ke kf kg kh b">substitute.js</code>不能做的事情，以及不支持它的原因。</p><h2 id="990d" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">部分模拟</h2><p id="420e" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">如果你仅仅依赖于几个伪造的方法，部分模仿通常是不好的。通常在测试时，你想要伪造所有的东西或者几乎所有的东西。</p><p id="b7ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然<code class="eh ke kf kg kh b">substitute.js</code>不支持部分模仿，但是您可以显式代理您想要从真实实例中“模仿”的每个方法。</p><h2 id="b914" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">呼叫订单验证</h2><p id="3225" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">外界(使用你的单元的公共接口)不应该关心你的单元调用它的依赖项的方法的顺序。我认为这是一种反模式，这也是它不被支持的原因。</p><h2 id="af70" class="ki kj hu bd kk kl km kn ko kp kq kr ks jc kt ku kv jg kw kx ky jk kz la lb lc dt translated">更多？</h2><p id="b867" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">是否有更多的例子是<code class="eh ke kf kg kh b">substitute.js</code>做不到而其他人能做到的？请在评论中告诉我，我会添加它或者解释为什么它没有被添加到框架中。</p><p id="c558" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">试图使你99%情况下使用的伪装操作变得简单，但是如果你愿意牺牲好看的语法，它仍然应该足够灵活以覆盖复杂的情况。</p></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h1 id="a048" class="lp kj hu bd kk lq lr ls ko lt lu lv ks lw lx ly kv lz ma mb ky mc md me lb mf dt translated"><code class="eh ke kf kg kh b">Getting substitute.js</code></h1><p id="9c21" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hn dt translated">下面是安装<code class="eh ke kf kg kh b">substitute.js</code>所需的命令。注意，它需要<a class="ae kd" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a> 3或更高版本。</p><p id="b356" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ke kf kg kh b">npm install @fluffy-spoon/substitute --save-dev</code></p><p id="f1ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">GitHub:</strong>T18】https://github.com/ffMathy/FluffySpoon.JavaScript.Testing .作伪<br/>https://www.npmjs.com/package/@fluffy-spoon/substitute<a class="ae kd" href="https://www.npmjs.com/package/@fluffy-spoon/substitute" rel="noopener ugc nofollow" target="_blank">T21</a></p><figure class="mj mk ml mm fq mn"><div class="bz el l di"><div class="nd mp l"/></div></figure></div></div>    
</body>
</html>