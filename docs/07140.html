<html>
<head>
<title>How to schedule ‘the Boring Stuff’ with Django and Celery Beat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何安排姜戈和芹菜节拍的“无聊的东西”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-schedule-the-boring-stuff-with-django-and-celery-beat-1817b6f1e9c0?source=collection_archive---------24-----------------------#2018-08-23">https://medium.com/hackernoon/how-to-schedule-the-boring-stuff-with-django-and-celery-beat-1817b6f1e9c0?source=collection_archive---------24-----------------------#2018-08-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/932f06001807fe11a46e34bebac748a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZnpSmH-mcxdvTf5DtwLHSg.png"/></div></div></figure><div class=""/><p id="19e3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">软件开发人员的工作充满了生成定期报告、处理大量的导入或导出、备份、频繁的API请求，或者只是浏览一批电子邮件。将所有这些任务自动化并完美调度，难道不是开发人员的天堂吗？它会——幸运的是，有了芹菜段的帮助。</p><p id="de74" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">什么是芹菜末？</strong>它结合了<strong class="je ig">芹菜</strong>，一个众所周知的任务委托工具，和一个叫做<strong class="je ig"> Beat </strong>的漂亮的调度器。在本指南中，你将发现<strong class="je ig">它如何帮助你管理甚至是最乏味的任务</strong>。我们开始工作吧！</p><h1 id="5151" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">如何开始芹菜的工作？</h1><p id="e67e" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">首先，你需要有芹菜。它的最新版本(4.2)仍然支持<strong class="je ig"> Python 2.7 </strong>，但由于新版本不支持，<strong class="je ig">如果你想处理芹菜，建议使用Python 3。</strong></p><p id="4b59" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于本文的目的，<strong class="je ig">我正在Docker容器</strong>中运行Python 3.6.5映像的Django 2.0.6。要知道芹菜是一个资金极少的项目，不支持微软Windows。</p><p id="ef2e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要让芹菜上路，您需要一个代理来发送和接收消息。我的选择是<strong class="je ig"> Redis 4.0.10 </strong>，它也部署在容器中。Redis的另一个选择是<strong class="je ig">rabbit MQ</strong>——你可以在官方芹菜文档<a class="ae ld" href="http://docs.celeryproject.org/en/latest/getting-started/brokers/" rel="noopener ugc nofollow" target="_blank">中读到更多。</a></p><p id="c3ff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Redis有一个安装和管理起来容易得多的名声，这使得我的选择很简单。安装Redis后，您只需调用“redis-server”即可运行它。就是这样。这里有一个快速测试:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="bdea" class="ln kb if lj b fv lo lp l lq lr">$ redis-cli ping<br/>PONG</span></pre><p id="66d8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下一步中，您需要确保您的虚拟环境或容器配备了包:celery==4.20和redis==2.10.6 。皮普可以很方便地将它们安装到位。在后期，你还会用到<strong class="je ig">django _ celery _ beat = = 1 . 1 . 1</strong>的好处。</p><h1 id="b1a5" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">怎么用芹菜打？</h1><p id="a334" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">芹菜配置有时可能是棘手的，即使是顶级软件开发人员。在本指南中，我将使用标准Django结构:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ed1e" class="ln kb if lj b fv lo lp l lq lr">proj<br/>     /manage.py<br/>     /proj/__init__.py<br/>          /apps.py<br/>          /celery.py<br/>          /tasks.py<br/>          /settings.py<br/>     /my_app/__init__.py<br/>            /apps.py<br/>            /tasks.py</span></pre><p id="1461" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记得设置所有的<strong class="je ig"> apps.py文件</strong>。此外，每个应用程序__init__。py应该指向默认配置:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="abc6" class="ln kb if lj b fv lo lp l lq lr">default_app_config = 'my_app.apps.MyAppConfig'</span></pre><p id="3919" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例外是__init__。py在您的项目文件夹中，其中存储了<strong class="je ig">芹菜配置</strong>:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ae3d" class="ln kb if lj b fv lo lp l lq lr">from __future__ import absolute_import, unicode_literals<br/>from .celery import app as celery_app   <br/>__all__ = ('celery_app',)</span></pre><p id="a6ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">配置到这里，下一步是转到<strong class="je ig"> celery.py </strong>:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="01b4" class="ln kb if lj b fv lo lp l lq lr">from __future__ import absolute_import, unicode_literals <br/>import os <br/>from celery import Celery </span><span id="c738" class="ln kb if lj b fv ls lp l lq lr"># Set default Django settings os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'proj.settings') </span><span id="711f" class="ln kb if lj b fv ls lp l lq lr">app = Celery('proj')   </span><span id="9eda" class="ln kb if lj b fv ls lp l lq lr"># Celery will apply all configuration keys with defined namespace  app.config_from_object('django.conf:settings', namespace='CELERY')   </span><span id="b86b" class="ln kb if lj b fv ls lp l lq lr"># Load tasks from all registered apps <br/>app.autodiscover_tasks()</span></pre><p id="13ba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了使用‘config _ from _ object’之外，另一种配置方式是<strong class="je ig">直接在应用</strong> — <a class="ae ld" href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html#celerytut-configuration" rel="noopener ugc nofollow" target="_blank">中分配配置值，查看文档</a>了解更多细节。</p><p id="d007" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了基础的东西，让我们继续设置。py和<strong class="je ig">设置芹菜段的细节</strong>。最简单的配置如下所示:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="af07" class="ln kb if lj b fv lo lp l lq lr">CELERY_BROKER_URL = 'redis://localhost:6379'   </span><span id="2891" class="ln kb if lj b fv ls lp l lq lr"># If time zones are active (USE_TZ = True) define your local CELERY_TIMEZONE = 'Europe/Warsaw'   </span><span id="52df" class="ln kb if lj b fv ls lp l lq lr"># We're going to have our tasks rolling soon, so that will be handy CELERY_BEAT_SCHEDULE = {}</span></pre><p id="db2f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在最新版本的芹菜杆中引入了新的小写设置标准。然而，不必急着更新它，因为这种适应良好的格式仍然受支持。</p><h1 id="397b" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">芹菜节拍中的调度任务</h1><p id="3904" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">到目前为止做得很好——现在是时候移动到应用模块中的<strong class="je ig"> tasks.py了。</strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4ac3" class="ln kb if lj b fv lo lp l lq lr">from celery import task <br/>from celery import shared_task </span><span id="e51f" class="ln kb if lj b fv ls lp l lq lr"># We can have either registered task </span><span id="2ed2" class="ln kb if lj b fv ls lp l lq lr">@task(name='summary') <br/>def send_import_summary():<br/>     # Magic happens here ... <br/># or </span><span id="3416" class="ln kb if lj b fv ls lp l lq lr">@shared_task <br/>def send_notifiction():<br/>     print(‘Here I\’m’)<br/>     # Another trick</span></pre><p id="ad7e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">无论任务是注册的还是共享的，Celery都能发现它。</strong>如果你写的任务会服务于不能依赖于项目本身的可重用app，那么app实例就不能直接导入。在这种情况下，使用<strong class="je ig"> @shared_task decorator </strong>是确保一切就绪的正确方法。</p><p id="1b62" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">准备好任务的功能后，<strong class="je ig">让我们回到settings.py来添加一个时间表</strong>:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ea92" class="ln kb if lj b fv lo lp l lq lr">from celery.schedules import crontab   </span><span id="b423" class="ln kb if lj b fv ls lp l lq lr">CELERY_BROKER_URL = 'redis://localhost:6379' <br/>CELERY_TIMEZONE = 'Europe/Warsaw'   </span><span id="e32d" class="ln kb if lj b fv ls lp l lq lr"># Let's make things happen <br/>CELERY_BEAT_SCHEDULE = {<br/> 'send-summary-every-hour': {<br/>       'task': 'summary',<br/>        # There are 4 ways we can handle time, read further <br/>       'schedule': 3600.0,<br/>        # If you're using any arguments<br/>       'args': (‘We don’t need any’,),<br/>    },<br/>    # Executes every Friday at 4pm<br/>    'send-notification-on-friday-afternoon': { <br/>         'task': 'my_app.tasks.send_notification', <br/>         'schedule': crontab(hour=16, day_of_week=5),<br/>        },          <br/>}</span></pre><p id="484f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，你已经使用了<strong class="je ig">两种处理时间的方法:</strong></p><ul class=""><li id="001a" class="lt lu if je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated"><strong class="je ig">简单的</strong> <strong class="je ig">时间表示</strong>以秒来声明重复之间的间隔；</li><li id="d60e" class="lt lu if je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated"><strong class="je ig"> crontab </strong>，作为“运行频率”使用，让您指定确切的时间、星期/月和一年中的月份。</li></ul><p id="4ecc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，众所周知的<strong class="je ig"> Python timedelta方法</strong>可以应用于设置“按时钟”时间表。芹菜打提出的另一个奇特选项是<strong class="je ig">根据太阳活动执行任务</strong>:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="2637" class="ln kb if lj b fv lo lp l lq lr">from celery.schedules import solar<br/>       # [...]         <br/>'schedule': solar('sunset', -37.81753, 144.96715),</span></pre><h1 id="f274" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">是时候运行您的第一个工人了！</h1><p id="9bc6" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">设置已完成并尘埃落定。让我们试一试。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0732" class="ln kb if lj b fv lo lp l lq lr">$ celery -A proj beat -l INFO  # For deeper logs use DEBUG</span></pre><p id="4955" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Beat可以嵌入<strong class="je ig">普通芹菜工</strong>以及带-B参数的<strong class="je ig">。但是，不建议在生产中使用:</strong></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4919" class="ln kb if lj b fv lo lp l lq lr">$ celery -A proj worker -B -l INFO</span></pre><p id="af30" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认调度程序将数据存储在本地celerybeat-schedule文件中，并基于硬编码设置。但是，如果你也想让应用程序管理员甚至用户创建或简单地调整时间表呢？</p><h1 id="2436" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">姜戈芹菜节拍来了</h1><p id="4825" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">Celery允许使用<strong class="je ig">定制调度类</strong>。为什么我们不能<strong class="je ig">将它保存在数据库中，并方便地显示在管理界面</strong>中？因为这正是这个扩展所做的，对您和其他用户来说没有任何麻烦。</p><p id="da96" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你已经安装了django_celery_beat==1.1.1，<strong class="je ig">所以让我们把它添加到settings.py </strong>中的INSTALLED_APPS中。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d5bd" class="ln kb if lj b fv lo lp l lq lr">INSTALLED_APPS = (<br/>     ...,<br/>     'django_celery_beat', <br/>)</span></pre><p id="a2d1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Django Celery Beat使用<strong class="je ig">自己的模型来存储所有与时间表相关的数据</strong>，因此让它通过应用迁移在您的数据库中构建一个新表:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9e43" class="ln kb if lj b fv lo lp l lq lr">$ python manage.py migrate</span></pre><p id="21d1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一步是<strong class="je ig">通知你的工人读取自定义调度程序:django _ celery _ beat . schedulers:database scheduler。</strong>为此，您需要重新运行它:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8f58" class="ln kb if lj b fv lo lp l lq lr">$ celery -A proj beat -l INFO --scheduler django_celery_beat.schedulers:DatabaseScheduler <br/>... <br/>LocalTime -&gt; 2018-07-13 09:29:25 <br/>Configuration -&gt;<br/>     . broker -&gt; redis://redis:6379//<br/>     . loader -&gt; celery.loaders.app.AppLoader<br/>     . scheduler -&gt; django_celery_beat.schedulers.DatabaseScheduler<br/>     . logfile -&gt; [stderr]@%DEBUG<br/>     . maxinterval -&gt; 5.00 seconds (5s) <br/>[2018-07-13 09:29:25,212: INFO/MainProcess] beat: Starting... <br/>[2018-07-13 09:29:25,212: INFO/MainProcess] Writing entries...</span></pre><p id="377b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">瞧啊。让我们看看<strong class="je ig">管理面板</strong>:</p><figure class="le lf lg lh fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mh"><img src="../Images/5f1625e5c8c726786884bc968cc3c451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Ax8q8rgd47mGyQ9.png"/></div></div></figure><p id="3de3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于你可以<strong class="je ig">快速点击所有“无聊的东西”或者将它外包给其他人</strong>，所有先前根植于代码中的设置现在都可以在手边使用。就这么简单。</p><p id="d04d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们添加一个新的周期性任务:</p><figure class="le lf lg lh fq hw fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/826f3ffaf15a628c11e8481b8a6498a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/0*4lm5OoxNJeSvzg69.png"/></div></figure><p id="30c7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给你！</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="72bf" class="ln kb if lj b fv lo lp l lq lr">[2018-07-13 10:25:03,120: DEBUG/MainProcess] DatabaseScheduler: Fetching database schedule <br/>[2018-07-13 10:25:03,231: WARNING/ForkPoolWorker-1] Here I'm! <br/>[2018-07-13 10:25:03,232: INFO/ForkPoolWorker-1] Task my_app.tasks.send_notification succeeded in 0.0005994100356474519s: None <br/>&lt;ModelEntry: Random my_app.tasks.send_notification(*[], **{}) &lt;freq: 30.00 seconds&gt;&gt;</span></pre><p id="32bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然你可能有一个印象，配置需要很多努力，但重要的是<strong class="je ig">不要错过任何初始设置步骤，以确保你的芹菜是健全的，并发现所有任务</strong>。这肯定会使您免于进一步的调试！</p><p id="a92a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有一个提示:如果您使用数据库，<strong class="je ig">不要将Django模型对象传递给Celery任务</strong>。而不是传递它的主键来直接从数据库中获取对象的最新状态。这将有助于避免对象被更改，然后被下一次任务执行覆盖的情况。</p><h1 id="7e58" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">为什么要在你的编码程序中加入芹菜节拍？</h1><p id="75d3" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在阅读的过程中，你已经成功地设置了Celery并创建了项目中的第一个任务。在芹菜节拍的支持下，你的任务已经被安排在特定的时间执行。为了让您和您的用户的过程更加简单，我添加了Django Celery Beat和一个数据库调度器<strong class="je ig">来管理您的任务，而不会干扰代码</strong>，直接从Django管理面板。所有让你烦心的繁琐任务，现在都在芹菜节拍的控制下顺利运行。</p><p id="a13c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">*仅供参考，标题的一部分来自阿尔·斯威加特的书:用Python自动化枯燥的东西<strong class="je ig">——我强烈推荐去看看</strong>！</p></div><div class="ab cl mj mk hc ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hn ho hp hq hr"><p id="8454" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mq">原载于</em><a class="ae ld" href="https://www.merixstudio.com/blog/django-celery-beat/" rel="noopener ugc nofollow" target="_blank"><em class="mq">www.merixstudio.com</em></a><em class="mq">。</em></p></div></div>    
</body>
</html>