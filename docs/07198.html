<html>
<head>
<title>Gitflow is a Poor Branching Model Hack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gitflow是一个糟糕的分支模型黑客</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/gitflow-is-a-poor-branching-model-hack-d46567a156e7?source=collection_archive---------1-----------------------#2018-08-26">https://medium.com/hackernoon/gitflow-is-a-poor-branching-model-hack-d46567a156e7?source=collection_archive---------1-----------------------#2018-08-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0e31" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">原因如下。</h2></div><p id="fa56" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我重复一遍:<a class="ae kf" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> gitflow </a>只是一个糟糕的分支流黑客，表明你的团队的工程实践水平低下。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/98b4afdfa7c95c1daf015dced19677f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9V9v68-IOjanNs3MscSwg.jpeg"/></div></div></figure><p id="4f57" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，在你生吞我之前，让我解释一下。</p><h2 id="1646" class="ks kt hu bd ku kv kw kx ky kz la lb lc js ld le lf jw lg lh li ka lj lk ll lm dt translated">版本控制系统的主观简史</h2><p id="c6c4" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated"><strong class="jl hv">风投前的日子</strong> <br/>基于除功能之外的任何东西的独立开发导致了可能持续数年的集成地狱。</p><p id="f524" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">SVN  <br/> SVN在我20多岁的时候抓住了我，当时我的编程文化显然比现在低。我没有编写单元测试，我的面向对象编程很差，我既不了解SCRUM也不了解任何其他敏捷方法，但SVN教会了我一件事，那就是责任。我无法签入不起作用的代码。可能没有单元测试，代码可能一塌糊涂，但它必须工作。</p><p id="b7ea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> Git </strong></p><p id="842e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> Git + CI </strong> <br/>大量的分支并连续合并成develop分支。</p><p id="ef22" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，相当多的人抓住了至少三个主要的风投里程碑，以及他们所有的理念。这里有一个问题:什么是对的，什么是错的？使用什么分支策略？开发分支应该稳定不稳定，或者稳定到什么程度？</p><p id="5da4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗯，其实是反过来的。您的分支模型应该反映您团队的工作流程。</p><h2 id="89b9" class="ks kt hu bd ku kv kw kx ky kz la lb lc js ld le lf jw lg lh li ka lj lk ll lm dt translated">编写代码</h2><p id="5b5e" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">你写单元测试吗？什么时候？你把它们和代码一起写吗？你的代码覆盖率是多少？如果你所有的测试都通过了，你能确定一切都很好吗？或者，换句话说，您能否将您的功能分支与主功能分支合并，并立即进行部署？如果没有，很明显，你的代码需要进一步的测试——无论是手工测试还是功能测试。因此，如果您有一个对应于当前生产环境的主分支，或者用Fowler的话来说，一个主线——您不能只是将您的分支合并到其中:从合并到测试该特性并修复所有错误的时间可能是很重要的。如果您认为这不是问题，请想一想当生产中出现一个关键错误，您需要尽快修复它的情况。但是您不能:在您的主分支中要么有未测试的代码，要么没有工作(或者两者都有)。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/125f2b1353996875f72cdd816efb51b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*sYOw4irwuIpuPUn64ysPcg.png"/></div></figure><p id="1e9b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以现在你有两个选择。要么你<a class="ae kf" href="https://martinfowler.com/bliki/FeatureBranch.html" rel="noopener ugc nofollow" target="_blank">遵循持续集成实践</a>并且有一个额外的不稳定分支，在那里你的团队持续地将他们的代码合并到:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/0563b833c1cddf5f1c4a54ae4b741ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*kYnGsf1lxuw0HCN5Vlg-Mw.png"/></div></figure><p id="541d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者您根本不合并代码，而是将它保存在自己的特性分支中:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/ca2896b8031ee4bbdfc1317fce57b815.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*HbwPes8G6mEDQb_gi8piYw.png"/></div></figure><p id="0419" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在后一种情况下，QA不能并行测试特性，因为在主线中将它们合并在一起后，可能会出现冲突。最糟糕的是当git悄悄合并代码，但是逻辑冲突还在，你看不到:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/2cbeb8fcb5802d13321c12419ea6833c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*sp0g8Ai4mErgAaDLdaWuFw.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Logical conflicts when testing branches in parallel</figcaption></figure><p id="fc4c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以唯一可行的选择是在它们的分支中测试这些特性，然后合并到主分支中，这样它们就不会不可预测地互相干扰，但是在下一节中会有更多的测试。</p><h2 id="a5e4" class="ks kt hu bd ku kv kw kx ky kz la lb lc js ld le lf jw lg lh li ka lj lk ll lm dt translated">测试</h2><p id="8c8c" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">你的QA团队编写功能测试吗？什么时候？主要的问题是一样的:在什么时间点你可以确定你做了正确的事情并且没有破坏任何东西？</p><p id="5010" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">典型方法<br/> </strong>你写一些代码，可能还要进行一些单元测试。但是你没有信心认为一切都很好。无论如何，当你完成你的用户故事的时候，你不能确定<a class="ae kf" href="https://www.seguetech.com/what-characteristics-make-good-agile-acceptance-criteria/" rel="noopener ugc nofollow" target="_blank">一切都像预期的那样工作</a>并且你没有破坏任何东西。你能做的最糟糕的事情就是将这些代码放在它自己的分支中，将代码集成不可避免的痛苦推迟到sprint的最后。如前所述，更好的选择是将它合并到develop branch中。之后，你的同事把develop拉进自己的分支。即使他们都不写测试，他们也有可能遇到错误的行为，但是修复它更容易，因为他们知道是最近的<code class="eh ma mb mc md b">git pull origin develop</code>破坏了他们的分支。因此，他们不是在两周的代码堆中寻找bug，而是浏览昨天的工作。很有可能，如果他们在他们的开发聊天中或在他们都坐的房间里询问问题，他们会马上得到答案。再说一次:如果从错误出现到被发现的时间间隔很短，就更容易找到错误行为的原因。</p><p id="dd06" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不管怎样，在sprint接近尾声的时候，你的QA团队加入进来，开始测试sprint用户故事。如果他们真的开始测试sprint的结尾，我打赌他们会手动测试。在sprint期间手动测试用户故事是没有任何意义的，因为任何后续的提交都会破坏事情。此外，万一测试过程停滞不前，它不应该阻止开发人员从下一个sprint实现用户故事。所以QA团队必须有自己的分支来测试sprint。这是它的样子:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff me"><img src="../Images/a146b347e41283c72bd61c113ff238bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bB5TZgDZQqTXWulldQtK3Q.png"/></div></div></figure><p id="dd74" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你知道这个工作流程对应什么分支策略吗？对，是gitflow。</p><p id="1fbb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">好方法<br/> </strong>坏的工程实践经常导致上面讨论的延迟和不可预测的部署。因此，一般来说，你的测试套件不仅应该包含单元测试，而且至少应该包含功能测试。这自然意味着QA团队应该尽快开始编写他们的测试。所以在这种情况下，你的处境与我在前一章描述的完全相反。简而言之，只要代码准备好了，你就可以部署它，你只需要一个分支，这个分支总是稳定的。对了，这叫<a class="ae kf" href="https://continuousdelivery.com/" rel="noopener ugc nofollow" target="_blank">连续发货</a>。</p><h2 id="5557" class="ks kt hu bd ku kv kw kx ky kz la lb lc js ld le lf jw lg lh li ka lj lk ll lm dt translated">部署</h2><p id="ed1a" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">您是否手动部署？<a class="ae kf" href="https://puppet.com/blog/continuous-delivery-vs-continuous-deployment-what-s-diff" rel="noopener ugc nofollow" target="_blank">自动</a>？需要多长时间？您准备好在主分支中部署每个提交了吗？如果没有，您可能需要至少一个稳定的分支，该分支当前正在生产中，用于紧急的bug修复，而第二个分支虽然稳定，但是由于部署过程的困难，每天部署一次。因此，这里有另一个适合您的工作流的分支模型。</p><h2 id="ac80" class="ks kt hu bd ku kv kw kx ky kz la lb lc js ld le lf jw lg lh li ka lj lk ll lm dt translated">摘要</h2><p id="4924" class="pw-post-body-paragraph jj jk hu jl b jm ln iv jo jp lo iy jr js lp ju jv jw lq jy jz ka lr kc kd ke hn dt translated">理想的分支模型是不存在的。根据您团队的工作流程(这反过来又取决于它的工程文化水平)，一些特定的分支工作流程最适合您。在切换到另一个分支模型之前，确保你的团队已经准备好了。</p></div><div class="ab cl mf mg hc mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hn ho hp hq hr"><p id="b6ed" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">查看我关于以下主题的纯粹主义帖子:<br/> *讨论<a class="ae kf" href="https://hackernoon.com/solid-principles-530b2cc2badf" rel="noopener ugc nofollow" target="_blank">坚实原则</a>背后的具体基础以及它们所基于的价值观；<br/> *如何构建弹性可靠的<a class="ae kf" rel="noopener" href="/@wrong.about/how-to-implement-soa-dc6bf08fba9a">SOA</a>；<br/> *在创建<a class="ae kf" href="https://hackernoon.com/why-microservices-fail-6cdc006f9540" rel="noopener ugc nofollow" target="_blank">微服务</a>时最需要提防什么，以及最常见的失败原因；<br/> *我的承担以下无处不在的概念:<a class="ae kf" href="https://hackernoon.com/inheritance-based-on-internal-structure-is-evil-7474cc8e64dc" rel="noopener ugc nofollow" target="_blank">实现继承(恶！)</a>、<a class="ae kf" href="https://hackernoon.com/on-good-domain-decomposition-385ee8ce5a3" rel="noopener ugc nofollow" target="_blank">如何分解域</a>和<a class="ae kf" href="https://hackernoon.com/how-to-avoid-anemic-domain-model-5e1c3e6fe4d0" rel="noopener ugc nofollow" target="_blank">避免贫血域模型</a>、<a class="ae kf" href="https://hackernoon.com/how-to-decompose-a-system-into-modules-796bd941f036" rel="noopener ugc nofollow" target="_blank">如何将一个系统分解成模块</a>、<a class="ae kf" href="https://codeburst.io/static-classes-are-evil-or-make-your-dependencies-explicit-af3e73bd29dd" rel="noopener" target="_blank">静态类(又恶！)</a>、<a class="ae kf" href="https://hackernoon.com/you-dont-need-a-dependency-injection-container-10a5d4a5f878" rel="noopener ugc nofollow" target="_blank">迪容器(无用的恶)</a>、<a class="ae kf" href="https://hackernoon.com/you-dont-need-an-orm-7ef83bd1b37d" rel="noopener ugc nofollow" target="_blank"> ORM(也是恶)</a>、<a class="ae kf" href="https://hackernoon.com/you-dont-need-a-domain-service-class-in-ddd-9ecd3140782" rel="noopener ugc nofollow" target="_blank">域服务类(正、恶)</a>。</p></div></div>    
</body>
</html>