<html>
<head>
<title>JavaScript Execution Context and Lexical Environment Explained.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了JavaScript执行上下文和词汇环境。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/javascript-execution-context-and-lexical-environment-explained-528351703922?source=collection_archive---------6-----------------------#2018-08-26">https://medium.com/hackernoon/javascript-execution-context-and-lexical-environment-explained-528351703922?source=collection_archive---------6-----------------------#2018-08-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/576088cf090daec01a03261405ac4227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUif8A5X81bOpkLssOTbcg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/1ZZ96uESRJQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Shane Rounce</a> on <a class="ae jg" href="https://unsplash.com/search/photos/machine?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5df2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为一名<a class="ae jg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>程序员，你有没有想过当JavaScript引擎在<a class="ae jg" href="https://hackernoon.com/tagged/browser" rel="noopener ugc nofollow" target="_blank">浏览器</a>中运行时，它是如何执行你的代码的？以及它们在执行时如何使用<strong class="jj hv"> <em class="kf">词法环境</em> </strong>来跟踪局部范围？</p><p id="46bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将向你解释它是如何在幕后工作的。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="ed7e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当您的代码在JavaScript引擎中运行时。你的代码的每一条语句都是在某个<strong class="jj hv"> <em class="kf">执行上下文</em> </strong> <em class="kf">中执行的。</em></p><p id="4731" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在JavaScript环境中，有两种主要类型的执行上下文。首先是<strong class="jj hv"> <em class="kf">全局执行上下文</em>，</strong>当您的代码最初运行时，即使它是使用<strong class="jj hv"> <em class="kf"> &lt;脚本/ &gt; </em> </strong>标签跨页面运行的，JavaScript也会创建一个全局执行上下文，当它们在浏览器内部执行和运行时，您的代码会被放置在其中。第二个是<strong class="jj hv"> <em class="kf">函数执行上下文</em> </strong>来自单词本身，它是在您调用您定义的函数时创建的。</p><p id="0268" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每次你调用一个函数，它都会创建一个新的<strong class="jj hv">函数执行上下文。T29】</strong></p><p id="07b2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">例如:</strong></p><pre class="kn ko kp kq fq kr ks kt ku aw kv dt"><span id="ddd4" class="kw kx hu ks b fv ky kz l la lb">var message = ‘Hello there’;</span><span id="d7c3" class="kw kx hu ks b fv lc kz l la lb">function foo(message) {<br/>  bar(message);<br/>}</span><span id="c85c" class="kw kx hu ks b fv lc kz l la lb">function bar(message) {<br/>  console.log(message);<br/>}</span><span id="b9be" class="kw kx hu ks b fv lc kz l la lb">foo(message);</span></pre><p id="1ef2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码运行时，JavaScript引擎创建一个<strong class="jj hv"> <em class="kf">全局执行上下文</em> </strong>并将其推送到<strong class="jj hv"> <em class="kf">执行上下文堆栈</em> </strong>。</p><blockquote class="ld"><p id="20be" class="le lf hu bd lg lh li lj lk ll lm ke ek translated"><em class="ln">执行上下文堆栈——是处理和操作全局和函数执行上下文的地方。</em></p></blockquote><p id="782f" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">当我们调用函数<strong class="jj hv"> foo，</strong>全局执行上下文被暂停，因为<strong class="jj hv"> <em class="kf"> JavaScript是单线程环境</em> </strong>它们一次只能执行一个代码。之后，JavaScript引擎将为foo创建一个新的函数执行上下文<strong class="jj hv"> </strong>并将其推入<strong class="jj hv"> </strong>执行上下文堆栈，当<strong class="jj hv"> foo </strong>函数执行时，我们调用<strong class="jj hv"> foo </strong>定义<strong class="jj hv">中的<strong class="jj hv">栏</strong>。</strong> JavaScript引擎暂停了<strong class="jj hv"> foo </strong>函数中的执行上下文，并为<strong class="jj hv">栏</strong>创建一个新的<strong class="jj hv">函数执行上下文</strong>，并将其推入堆栈。当<strong class="jj hv">条</strong>执行完毕后，它将在<strong class="jj hv"> <em class="kf">执行上下文堆栈</em> </strong>中弹出，并返回<strong class="jj hv"> foo </strong>继续执行。相同的过程将应用于<strong class="jj hv"> foo </strong>直到我们完成并返回到全局执行上下文并继续执行。</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/e6e905ca2b705ae8f7841353791810da.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/1*_s_6UBs5lYOZ7oCa77LXqg.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">How Execution Context push in Execution Context Stack.</figcaption></figure><p id="d135" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如我们已经知道JavaScript执行上下文是如何工作的，让我们深入到<strong class="jj hv"> <em class="kf">词汇环境</em> </strong>并解释它们是如何工作的。</p><p id="bfe0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最有可能的是<strong class="jj hv"> <em class="kf">词法环境</em> </strong>在<strong class="jj hv">代码嵌套</strong>中工作，当你有一个函数并且在那个函数中你有另一个函数。</p><p id="5e0a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">例如:</strong></p><pre class="kn ko kp kq fq kr ks kt ku aw kv dt"><span id="cc6b" class="kw kx hu ks b fv ky kz l la lb">var a = ‘a’;</span><span id="72de" class="kw kx hu ks b fv lc kz l la lb">function foo() {</span><span id="de79" class="kw kx hu ks b fv lc kz l la lb">  var b = ‘b’;</span><span id="1649" class="kw kx hu ks b fv lc kz l la lb">  function bar() {<br/>    var c = ‘c’;</span><span id="5c1a" class="kw kx hu ks b fv lc kz l la lb">    console.log(c); // You can access me here.   <br/>    console.log(b); // You can access me too..<br/>    console.log(a); // You can also access me..<br/>  }</span><span id="af11" class="kw kx hu ks b fv lc kz l la lb">  bar();</span><span id="13f6" class="kw kx hu ks b fv lc kz l la lb">}</span><span id="13dd" class="kw kx hu ks b fv lc kz l la lb">foo();</span></pre><p id="e40b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">没什么特别的，我们在代码中定义了一个嵌套函数。</p><p id="86ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当这段代码最初运行时，一个<strong class="jj hv">全局环境</strong>被创建，并且<strong class="jj hv">一个</strong>和<strong class="jj hv"> foo </strong>被存储在其中。当我们调用下面的<strong class="jj hv">函数</strong> <strong class="jj hv"> foo </strong>时，一个新的环境被创建并存储了foo环境中的<strong class="jj hv">变量b </strong>，它只对<strong class="jj hv"> bar函数</strong>可见，因为bar是<strong class="jj hv"> foo </strong>环境中的内部函数。当调用<strong class="jj hv"> foo() </strong>时，我们也调用了<strong class="jj hv"> bar()函数</strong>，这也为它们的定义创建了一个新的环境。</p><blockquote class="ld"><p id="ad61" class="le lf hu bd lg lh li lj lk ll lm ke ek translated"><em class="ln">“每当我们调用一个函数时，都会创建一个新的函数执行上下文，并与新关联的词法环境</em><strong class="ak"><em class="ln">[[Environment]</em></strong><em class="ln">”一起推入执行上下文堆栈。</em></p></blockquote><figure class="lv lw lx ly lz iv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/ba8ec4ee0c45e3df79b004c2b481e218.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*XlcoywV53p6PVTKy68h4vQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Diagram for Lexical Environment how they works</figcaption></figure><p id="7d6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<strong class="jj hv">栏函数</strong>中，我们进行日志记录来检查我们创建的变量是否可见，以及我们是否可以在它们的环境中访问它。</p><p id="7584" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当<strong class="jj hv">变量</strong> <strong class="jj hv"> c </strong>登录到酒吧环境中时，因为在他的环境中，所以显示成功。</p><p id="d976" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，当我们记录变量<strong class="jj hv"> b </strong>和变量<strong class="jj hv"> a </strong>时，它也被成功显示。这是怎么发生的？</p><p id="47ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们讨论一下。</p><p id="7a6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在第二次日志记录中，我们调用不在<strong class="jj hv">条函数</strong>范围<strong class="jj hv">内的<strong class="jj hv">变量b </strong>。</strong>所以javascript在内部这样做，在其他的<strong class="jj hv"> <em class="kf">外部环境</em> </strong>中搜索，直到找到那个变量。在我们的例子中，他们在<strong class="jj hv"> foo函数</strong>处找到了变量<strong class="jj hv"> b </strong>，因为bar函数引用了foo函数，所以foo函数环境不会在执行上下文中弹出！当<strong class="jj hv">变量a </strong>被记录时，它也被成功显示，因为<strong class="jj hv">变量a </strong>存储在全局执行上下文中。每个人都可以访问全局执行上下文中的作用域。</p><figure class="kn ko kp kq fq iv fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/2c03257a0698fa91aad76b34d4b1028c.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*4OspcQmLKGXvCCxa6UZ1lg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Accessing other environment</figcaption></figure><p id="3a8c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既然您已经理解了JavaScript中的执行上下文和词法环境是如何工作的。现在，您可以避免JavaScript程序中的一些细微错误。</p><p id="3a8d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢读这篇文章，请为我鼓掌…</p><p id="c9ff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">希望对^_^有帮助</p><p id="35f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">谢了。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="cc1d" class="mb kx hu bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx dt translated"><strong class="ak">“不要做一个平庸的JavaScript。”</strong></h1><p id="62cd" class="pw-post-body-paragraph jh ji hu jj b jk my jm jn jo mz jq jr js na ju jv jw nb jy jz ka nc kc kd ke hn dt translated">在推特上关注我<a class="ae jg" href="https://twitter.com/llaudevc/followers" rel="noopener ugc nofollow" target="_blank"><strong class="jj hv"><em class="kf">https://twitter.com/llaudevc/</em></strong></a></p><figure class="kn ko kp kq fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>