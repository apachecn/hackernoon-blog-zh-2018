<html>
<head>
<title>Go WebAssembly — Building a Calculator Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go WebAssembly —构建计算器教程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/go-webassembly-building-a-calculator-tutorial-70fff89db6a9?source=collection_archive---------10-----------------------#2018-08-26">https://medium.com/hackernoon/go-webassembly-building-a-calculator-tutorial-70fff89db6a9?source=collection_archive---------10-----------------------#2018-08-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/50eba447e4746a88a34a31a418ecfd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4ndDSZ5uUdEjlzmn8bXGA.png"/></div></div></figure><p id="d985" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">欢迎大家！随着Go v1.11的发布，包括了一个WebAssembly的实验性移植，我认为看到我们如何编写自己的Go程序直接编译到WebAssembly会很棒！</p><p id="743c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在本文中，我们将构建一个非常简单的计算器，让我们了解如何编写可以暴露给前端的函数，评估DOM元素，然后用我们调用的任何函数的结果更新任何DOM元素。</p><p id="3218" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将有希望向你展示为你的前端应用程序编写和编译你自己的基于Go的程序需要做些什么。</p><blockquote class="ka kb kc"><p id="d765" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><em class="hu">如果你还没有从开篇就猜到，那么为了让这个</em> <a class="ae kh" href="https://hackernoon.com/tagged/tutorial" rel="noopener ugc nofollow" target="_blank"> <em class="hu">教程</em> </a> <em class="hu">正常工作，Go v1.11将是必需的！</em></p></blockquote><h1 id="c639" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">视频教程</h1><p id="00e3" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如果你想支持我和我的努力，那么看看这个教程的视频版本，并订阅我的频道！</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><h1 id="5443" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">介绍</h1><p id="7c71" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">那么这对Go和Web开发者来说到底意味着什么呢？嗯，它让我们能够使用Go语言编写我们的前端web应用程序，以及随之而来的所有很酷的特性，比如它的类型安全，它的<a class="ae kh" href="https://tutorialedge.net/golang/concurrency-with-golang-goroutines/" rel="noopener ugc nofollow" target="_blank"> goroutines </a>等等。</p><p id="a62b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，这不是我们第一次看到Go语言被用于前端。GopherJS已经存在了很长一段时间，并且相当成熟，然而，不同之处在于它将Go代码编译成JS而不是WebAssembly。</p><h1 id="b704" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">简单的例子</h1><p id="62f9" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">让我们从一个非常简单的例子开始，每当我们点击网页中的一个按钮时，它都会在控制台中简单地输出<code class="eh lr ls lt lu b">Hello World</code>。我知道这听起来很令人兴奋，但是我们可以很快将它变成更实用、更酷的东西:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="d4df" class="lz kj hu lu b fv ma mb l mc md">package main<br/><br/>func main() {<br/>	println("Hello World")<br/>}</span></pre><p id="6e79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，为了编译它，你必须设置<code class="eh lr ls lt lu b">GOARCH=wasm</code>和<code class="eh lr ls lt lu b">GOOS=js</code>，你还必须使用<code class="eh lr ls lt lu b">-o</code>标志指定你的文件名，如下所示:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="3630" class="lz kj hu lu b fv ma mb l mc md">$ GOARCH=wasm GOOS=js go build -o lib.wasm main.go</span></pre><p id="fceb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个命令应该将我们的代码编译成当前工作目录下的一个<code class="eh lr ls lt lu b">lib.wasm</code>文件。我们将使用<code class="eh lr ls lt lu b">WebAssembly.instantiateStreaming()</code>函数将它加载到我们的<code class="eh lr ls lt lu b">index.html</code>页面中。注意——这段代码是从官方Go语言repo里偷来的:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="d4f9" class="lz kj hu lu b fv ma mb l mc md">&lt;!doctype html&gt;<br/>&lt;!--<br/>Copyright 2018 The Go Authors. All rights reserved.<br/>Use of this source code is governed by a BSD-style<br/>license that can be found in the LICENSE file.<br/>--&gt;<br/>&lt;html&gt;<br/><br/>&lt;head&gt;<br/>	&lt;meta charset="utf-8"&gt;<br/>	&lt;title&gt;Go wasm&lt;/title&gt;<br/>&lt;/head&gt;<br/><br/>&lt;body&gt;<br/><br/>	&lt;script src="wasm_exec.js"&gt;&lt;/script&gt;<br/><br/>	&lt;script&gt;<br/>		if (!WebAssembly.instantiateStreaming) { // polyfill<br/>			WebAssembly.instantiateStreaming = async (resp, importObject) =&gt; {<br/>				const source = await (await resp).arrayBuffer();<br/>				return await WebAssembly.instantiate(source, importObject);<br/>			};<br/>		}<br/><br/>		const go = new Go();<br/>		<br/>		let mod, inst;<br/><br/>		WebAssembly.instantiateStreaming(fetch("lib.wasm"), go.importObject).then((result) =&gt; {<br/>			mod = result.module;<br/>			inst = result.instance;<br/>			document.getElementById("runButton").disabled = false;<br/>		});<br/><br/>		async function run() {<br/>			await go.run(inst);<br/>			inst = await WebAssembly.instantiate(mod, go.importObject); // reset instance<br/>		}<br/><br/>	&lt;/script&gt;<br/><br/>	&lt;button onClick="run();" id="myButton" disabled&gt;Run&lt;/button&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="f4ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还需要<code class="eh lr ls lt lu b">wasm_exec.js</code>文件，可以在这里找到<a class="ae kh" href="https://github.com/golang/go/blob/master/misc/wasm/wasm_exec.js" rel="noopener ugc nofollow" target="_blank">。下载并保存在你的<code class="eh lr ls lt lu b">index.html</code>旁边。</a></p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="debc" class="lz kj hu lu b fv ma mb l mc md">$ wget <a class="ae kh" href="https://github.com/golang/go/blob/master/misc/wasm/wasm_exec.js" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/go/blob/master/misc/wasm/wasm_exec.js</a></span></pre><p id="9f2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，我们还有一个简单的基于<code class="eh lr ls lt lu b">net/http</code>的文件服务器，也是从这里的<a class="ae kh" href="https://github.com/golang/go/wiki/WebAssembly" rel="noopener ugc nofollow" target="_blank">偷来的</a>，用来提供我们的<code class="eh lr ls lt lu b">index.html</code>和我们的各种其他WebAssembly文件:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="9c58" class="lz kj hu lu b fv ma mb l mc md">package main<br/><br/>import (<br/>	"flag"<br/>	"log"<br/>	"net/http"<br/>)<br/><br/>var (<br/>	listen = flag.String("listen", ":8080", "listen address")<br/>	dir    = flag.String("dir", ".", "directory to serve")<br/>)<br/><br/>func main() {<br/>	flag.Parse()<br/>	log.Printf("listening on %q...", *listen)<br/>	log.Fatal(http.ListenAndServe(*listen, http.FileServer(http.Dir(*dir))))<br/>}</span></pre><p id="cf45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你导航到<code class="eh lr ls lt lu b">localhost:8080</code>一旦你启动了这个服务器，你应该会看到<code class="eh lr ls lt lu b">Run</code>按钮是可点击的，如果你在浏览器中打开你的控制台，你应该会看到每次你点击这个按钮都会打印出<code class="eh lr ls lt lu b">Hello World</code>！</p><p id="7e33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太棒了，我们已经成功地编译了一个非常简单的Go -&gt; WebAssembly项目，并让它在浏览器中工作。</p><h1 id="07c3" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">一个更复杂的例子</h1><p id="b48f" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">好消息来了。比方说，我们想要创建一个更复杂的例子，它具有DOM操作、可以绑定到按钮点击的自定义Go函数等等。谢天谢地，这并不太难！</p><h1 id="2fab" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">注册功能</h1><p id="7cda" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">我们将从创建一些我们自己的函数开始，我们希望将这些函数暴露给我们的前端。我今天感觉相当没有创意，所以这些将只是<code class="eh lr ls lt lu b">add</code>和<code class="eh lr ls lt lu b">subtract</code>。</p><p id="8f91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些函数接受一个类型为<code class="eh lr ls lt lu b">js.Value</code>的数组，并使用<code class="eh lr ls lt lu b">js.Global().Set()</code>函数将<code class="eh lr ls lt lu b">output</code>设置为等于在我们的函数中完成的任何计算的结果。为了更好地衡量，我们还将结果打印到控制台:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="f90d" class="lz kj hu lu b fv ma mb l mc md">func add(i []js.Value) {<br/>	js.Global().Set("output", js.ValueOf(i[0].Int()+i[1].Int()))<br/>	println(js.ValueOf(i[0].Int() + i[1].Int()).String())<br/>}<br/><br/>func subtract(i []js.Value) {<br/>	js.Global().Set("output", js.ValueOf(i[0].Int()-i[1].Int()))<br/>	println(js.ValueOf(i[0].Int() - i[1].Int()).String())<br/>}<br/><br/>func registerCallbacks() {<br/>	js.Global().Set("add", js.NewCallback(add))<br/>	js.Global().Set("subtract", js.NewCallback(subtract))<br/>}<br/><br/>func main() {<br/>	c := make(chan struct{}, 0)<br/><br/>	println("WASM Go Initialized")<br/>	// register functions<br/>	registerCallbacks()<br/>	&lt;-c<br/>}</span></pre><p id="fad3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您会注意到，我们通过调用<code class="eh lr ls lt lu b">make</code>并创建一个新的通道，对<code class="eh lr ls lt lu b">main</code>函数进行了轻微的修改。这有效地将我们以前短暂的程序变成了长期运行的程序。我们还调用了另一个函数<code class="eh lr ls lt lu b">registerCallbacks()</code>,它的行为几乎像一个路由器，但是它创建了新的回调函数，有效地将新创建的函数绑定到我们的前端。</p><p id="fde5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了实现这一点，我们必须稍微修改一下<code class="eh lr ls lt lu b">index.html</code>中的<a class="ae kh" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>代码，以便在获取程序实例后立即运行它:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="f017" class="lz kj hu lu b fv ma mb l mc md">const go = new Go();<br/>let mod, inst;<br/>WebAssembly.instantiateStreaming(fetch("lib.wasm"), go.importObject).then(async (result) =&gt; {<br/>	mod = result.module;<br/>	inst = result.instance;<br/>	await go.run(inst)<br/>});</span></pre><p id="e22e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再次在您的浏览器中加载它，您应该会看到，无需按任何按钮，<code class="eh lr ls lt lu b">WASM Go Initialized</code>就会在控制台中打印出来。这意味着一切都正常。</p><p id="5c2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们可以开始从类似<code class="eh lr ls lt lu b">&lt;button&gt;</code>的元素中调用这些函数，如下所示:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="471b" class="lz kj hu lu b fv ma mb l mc md">&lt;button onClick="add(2,3);" id="addButton"&gt;Add&lt;/button&gt;<br/>&lt;button onClick="subtract(10,3);" id="subtractButton"&gt;Subtract&lt;/button&gt;</span></pre><p id="581b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">移除现有的<code class="eh lr ls lt lu b">Run</code>按钮，并将这两个新按钮添加到您的<code class="eh lr ls lt lu b">index.html</code>中。当您在浏览器中重新加载页面并打开控制台时，您应该能够看到这个函数的输出。</p><p id="2d96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们正缓慢但肯定地开始有所进展！</p><h1 id="dcb6" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">评估DOM元素</h1><p id="8931" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">所以，我想下一步是开始评估DOM元素，并使用它们的值来代替硬编码的值。</p><p id="385e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们修改一下<code class="eh lr ls lt lu b">add()</code>函数，这样我可以传入2个<code class="eh lr ls lt lu b">&lt;input/&gt;</code>元素的<code class="eh lr ls lt lu b">id</code>，然后将这些元素的值相加，如下所示:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="b397" class="lz kj hu lu b fv ma mb l mc md">func add(i []js.Value) {<br/>	value1 := js.Global().Get("document").Call("getElementById", i[0].String()).Get("value").String()<br/>	value2 := js.Global().Get("document").Call("getElementById", i[1].String()).Get("value").String()<br/>	js.Global().Set("output", value1+value2)<br/>	println(value1 + value2)<br/>}</span></pre><p id="4ab0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们可以更新我们的<code class="eh lr ls lt lu b">index.html</code>,得到下面的代码:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="dbcd" class="lz kj hu lu b fv ma mb l mc md">&lt;input type="text" id="value1"/&gt;<br/>&lt;input type="text" id="value2"/&gt;<br/><br/>&lt;button onClick="add('value1', 'value2');" id="addButton"&gt;Add&lt;/button&gt;</span></pre><p id="9773" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您在我们的两个输入中输入一些数值，然后单击<code class="eh lr ls lt lu b">Add</code>按钮，您应该有希望在控制台中看到两个值的连接。</p><p id="9606" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们忘记了什么？我们需要将这些字符串值解析为int值:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="b76c" class="lz kj hu lu b fv ma mb l mc md">func add(i []js.Value) {<br/>	value1 := js.Global().Get("document").Call("getElementById", i[0].String()).Get("value").String()<br/>	value2 := js.Global().Get("document").Call("getElementById", i[1].String()).Get("value").String()<br/><br/>	int1, _ := strconv.Atoi(value1)<br/>	int2, _ := strconv.Atoi(value2)<br/><br/>	js.Global().Set("output", int1+int2)<br/>	println(int1 + int2)<br/>}</span></pre><p id="bb3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会注意到，我没有在这里处理错误，因为我觉得很懒，这只是为了展示。</p><p id="313d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在尝试重新编译这段代码并重新加载您的浏览器，您应该会注意到，如果我们在两个输入中都输入了值<code class="eh lr ls lt lu b">22</code>和<code class="eh lr ls lt lu b">3</code>，它会在控制台中成功输出<code class="eh lr ls lt lu b">25</code>。</p><h1 id="01a7" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">操作DOM元素</h1><p id="fd29" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如果我们的计算器不能在页面中报告结果，它就不会很好，所以现在让我们通过引入第三个<code class="eh lr ls lt lu b">id</code>来解决这个问题，我们将把结果输出到:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="39db" class="lz kj hu lu b fv ma mb l mc md">func add(i []js.Value) {<br/>	value1 := js.Global().Get("document").Call("getElementById", i[0].String()).Get("value").String()<br/>	value2 := js.Global().Get("document").Call("getElementById", i[1].String()).Get("value").String()<br/><br/>	int1, _ := strconv.Atoi(value1)<br/>	int2, _ := strconv.Atoi(value2)<br/><br/>	js.Global().Get("document").Call("getElementById", i[2].String()).Set("value", int1+int2)<br/>}</span></pre><p id="ff3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，让我们更新我们的减法方法:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="4984" class="lz kj hu lu b fv ma mb l mc md">func subtract(i []js.Value) {<br/>	value1 := js.Global().Get("document").Call("getElementById", i[0].String()).Get("value").String()<br/>	value2 := js.Global().Get("document").Call("getElementById", i[1].String()).Get("value").String()<br/><br/>	int1, _ := strconv.Atoi(value1)<br/>	int2, _ := strconv.Atoi(value2)<br/><br/>	js.Global().Get("document").Call("getElementById", i[2].String()).Set("value", int1-int2)<br/>}</span></pre><p id="5b72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们完成的<code class="eh lr ls lt lu b">index.html</code>应该是这样的:</p><pre class="ll lm ln lo fq lv lu lw lx aw ly dt"><span id="b302" class="lz kj hu lu b fv ma mb l mc md">&lt;!doctype html&gt;<br/>&lt;!--<br/>Copyright 2018 The Go Authors. All rights reserved.<br/>Use of this source code is governed by a BSD-style<br/>license that can be found in the LICENSE file.<br/>--&gt;<br/>&lt;html&gt;<br/><br/>&lt;head&gt;<br/>	&lt;meta charset="utf-8"&gt;<br/>	&lt;title&gt;Go wasm&lt;/title&gt;<br/>&lt;/head&gt;<br/><br/>&lt;body&gt;<br/><br/>	&lt;script src="wasm_exec.js"&gt;&lt;/script&gt;<br/><br/>	&lt;script&gt;<br/>		if (!WebAssembly.instantiateStreaming) { // polyfill<br/>			WebAssembly.instantiateStreaming = async (resp, importObject) =&gt; {<br/>				const source = await (await resp).arrayBuffer();<br/>				return await WebAssembly.instantiate(source, importObject);<br/>			};<br/>		}<br/><br/>		const go = new Go();<br/>		let mod, inst;<br/>		WebAssembly.instantiateStreaming(fetch("lib.wasm"), go.importObject).then(async (result) =&gt; {<br/>			mod = result.module;<br/>			inst = result.instance;<br/>			await go.run(inst)<br/>		});<br/><br/>	&lt;/script&gt;<br/><br/>	&lt;input type="text" id="value1"/&gt;<br/>	&lt;input type="text" id="value2"/&gt;<br/><br/>	&lt;button onClick="add('value1', 'value2', 'result');" id="addButton"&gt;Add&lt;/button&gt;<br/>	&lt;button onClick="subtract('value1', 'value2', 'result');" id="subtractButton"&gt;Subtract&lt;/button&gt;<br/><br/>	&lt;input type="text" id="result"&gt;<br/><br/>&lt;/body&gt;<br/><br/>&lt;/html&gt;</span></pre><h1 id="ccb1" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结论</h1><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/344457aed7e42b2fce51007803bb3fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9ehcShXgOwJGqiqtzldyA.png"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">The finished product!</figcaption></figure><p id="70d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在本教程中，我们设法学习了如何使用新的Go语言1.11版将我们的Go程序编译成WebAssembly。我们创建了一个非常简单的计算器，它将函数从我们的Go代码暴露给我们的前端，还做了一些DOM解析和引导操作。</p><p id="e7fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你觉得这篇文章有用/有趣！如果你有，那么我很乐意在下面的评论区听到你的意见。如果你希望支持我的工作，请随时订阅我的YouTube频道:<a class="ae kh" href="https://youtube.com/tutorialedge" rel="noopener ugc nofollow" target="_blank"> TutorialEdge </a>。</p></div><div class="ab cl mj mk hc ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hn ho hp hq hr"><p id="fad6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kd">原载于</em><a class="ae kh" href="https://tutorialedge.net/golang/go-webassembly-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="kd">tutorialedge.net</em></a><em class="kd">。</em></p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="mq lq l"/></div></figure></div></div>    
</body>
</html>