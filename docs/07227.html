<html>
<head>
<title>8 Tips for Containerizing Django Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器化Django应用的8个技巧</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/8-tips-for-containerizing-django-apps-5340647632a4?source=collection_archive---------11-----------------------#2018-08-27">https://medium.com/hackernoon/8-tips-for-containerizing-django-apps-5340647632a4?source=collection_archive---------11-----------------------#2018-08-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/18de50ee48b48baa0cd645828b1e4b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60NgzfV6VIQEeY5IK7kQOQ.png"/></div></div></figure><p id="d945" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近我和Django一起做了一个小网站，反应非常快，但是当涉及到部署时，我开始感到恼火。我必须写部署脚本和詹金斯的工作，还必须处理生产配置以及秘密！我开始考虑对这类小网站使用容器。我从阅读一本docker书开始，令人惊讶的是，我只用了一个小时就看完了这本书！(三年前我读了同一本书，读了大约两周，仍然不知道它在讲什么，所以看看当你实际上有需求时，效率有多高。)</p><p id="e3ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二天，当我试图将我网站的API服务容器化时，我遇到了很多问题。虽然有很多关于docker的教程，但是很少有关于最佳实践的。所以我觉得如果我能把我的问题和解决方法写下来会有所帮助。现在我们开始吧。</p><h1 id="890a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">体系结构</h1><p id="23a7" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我做的网站由一个用Django写的API服务组成，用<a class="ae ld" href="http://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> gunicorn </a>服务，一个用React写构建的前端。数据库是MySQL。nginx服务于前端静态文件，并将<code class="eh le lf lg lh b">/api/</code>代理给API服务。</p><p id="7ff1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最初，我考虑将所有东西都打包到一个容器中，但发现这种方法没有可伸缩性(尽管个人服务没有可伸缩性)。所以最后我决定只将Django API服务部分容器化。主机上的nginx将代理API对容器的请求。nginx将直接从一个目录中提供前端静态文件。这样，我可以在必要时将静态文件转移到AWS S3或将API转移到EC2。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff li"><img src="../Images/292f060151809deb0fed246c72e0e6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*S-e4zf5mt9zypfvebv5GgQ.png"/></div></figure><h1 id="3d84" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧1:在开发和生产中使用相同的操作系统</h1><p id="f67c" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我的开发环境是Ubuntu 18.04，所以使用Ubuntu进行生产也是很自然的。然而，我想尝试一下<a class="ae ld" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine </a>，因为它很安全，而且非常小，所以它非常适合容器(压缩后，<a class="ae ld" href="https://hub.docker.com/r/library/alpine/tags/3.8/" rel="noopener ugc nofollow" target="_blank">最新的alpine:3.8图像只需要2.1MB </a>！).</p><p id="943c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我从<code class="eh le lf lg lh b">python:3.6.6-alpine3.8</code>开始，一切都很顺利，直到我开始安装依赖项。我的项目的一些依赖依赖于本地库(如<code class="eh le lf lg lh b">libxslt</code>和<code class="eh le lf lg lh b">libmysqlclient</code>)并包含C代码，所以我必须安装<code class="eh le lf lg lh b">gcc</code>、<code class="eh le lf lg lh b">g++</code>和许多库和头文件。而且将来还有潜在的其他兼容性问题！这原来是一项繁琐的工作，很快让我放弃了。</p><p id="5f5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我决定从<code class="eh le lf lg lh b">ubuntu:18.04</code>开始建立自己的形象。我从中得到的教训是，如果你不熟悉alpine，坚持使用你用于开发的OS。这可能会导致更大的图像尺寸，但会为您节省大量时间。</p><h1 id="ca47" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧2:调整Dockerfile以减小图像大小</h1><p id="e033" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated"><code class="eh le lf lg lh b">apt</code>在没有任何选项的情况下调用时会安装很多“建议”但通常无用的包。然而，在容器上下文中，我们需要精确的包来使容器映像小而安全。</p><p id="97e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个窍门是添加<code class="eh le lf lg lh b">--no-install-recommends</code>选项。此选项可以显著减小图像大小。在下面的例子中，<code class="eh le lf lg lh b">3.6–1</code>由<code class="eh le lf lg lh b">apt install -y --no-install-recommends python3 python3-pip wget</code>产生，<code class="eh le lf lg lh b">3.6</code>由相同的命令产生，除了<code class="eh le lf lg lh b">--no-install-recommends</code>选项。看看差别有多大！</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="ad0d" class="lr kb hu lh b fv ls lt l lu lv">REPOSITORY          TAG    IMAGE ID        CREATED             SIZE<br/>odacharlee/python   3.6-1  ffe5c583b8c4    3 minutes ago       124MB<br/>odacharlee/python   3.6    188132621a87    3 hours ago         405MB</span></pre><p id="d423" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个技巧是在安装后删除缓存。添加<code class="eh le lf lg lh b">rm -rf /var/lib/apt/lists/*</code>将减少图像大小约40MB。</p><p id="0f96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一个技巧是对<code class="eh le lf lg lh b">apt update</code>和<code class="eh le lf lg lh b">apt install</code>只使用一个<code class="eh le lf lg lh b">RUN</code>语句。这可以在图像中生成较少的层。</p><p id="7efe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总而言之，您的docker文件应该是这样的:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="bff5" class="lr kb hu lh b fv ls lt l lu lv">RUN apt update \<br/>    &amp;&amp; apt install -y --no-install-recommends python3 python3-pip \<br/>    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></pre><h1 id="7fb7" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧3:处理pip依赖性</h1><p id="ad46" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">对于python应用程序，我们需要<code class="eh le lf lg lh b">pip</code>来安装依赖项。如果有任何包依赖于本地库，那就变得更棘手了，因为<code class="eh le lf lg lh b">pip</code>需要从源代码中编译依赖项。</p><p id="02aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，我的应用程序要求在运行<code class="eh le lf lg lh b">pip</code>之前安装<code class="eh le lf lg lh b">libmysqlclient-dev</code>、<code class="eh le lf lg lh b">python3-dev</code>，以便安装<code class="eh le lf lg lh b">mysqlclient</code>包。当然还需要一个编译器<code class="eh le lf lg lh b">gcc</code>。然而，这些包在<code class="eh le lf lg lh b">pip install</code>完成后就没用了，可以移除。所以Dockerfile可以写成:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="82e9" class="lr kb hu lh b fv ls lt l lu lv">RUN buildDeps='gcc libmysqlclient-dev python3-dev' \<br/>    &amp;&amp; apt update \<br/>    &amp;&amp; apt install -y --no-install-recommends $buildDeps \<br/>    &amp;&amp; pip install wheel setuptools \<br/>    &amp;&amp; pip install -r requirements.txt \<br/>    &amp;&amp; apt purge -y --auto-remove $buildDeps \<br/>    &amp;&amp; apt install -y libmysqlclient20 \<br/>    &amp;&amp; rm -rf /var/lib/apt/lists/* \<br/>    &amp;&amp; rm -rf /root/.cache</span></pre><p id="57f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">apt purge</code>行删除这些包，<code class="eh le lf lg lh b">rm -rf /root/.cache</code>删除pip缓存。注意<code class="eh le lf lg lh b">libmysqlclient20</code>在<code class="eh le lf lg lh b">apt purge</code>之后被重新安装，因为运行时需要这个包。</p><h1 id="b99e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧4:在云服务上构建注册中心</h1><p id="d5bc" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">一个注册服务用来存储你的docker镜像，比如<a class="ae ld" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。但有时我们需要为私有图像创建自己的注册表。</p><p id="2c48" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然你可以在<code class="eh le lf lg lh b">docker run registry</code>之前启动一个注册服务，但我建议你使用云服务，而不是自己托管你的注册。谷歌和亚马逊都提供容器注册服务。</p><ul class=""><li id="43c3" class="lw lx hu je b jf jg jj jk jn ly jr lz jv ma jz mb mc md me dt translated"><a class="ae ld" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册表</a>:存储:0.026美元/GB/月，数据传出:0.12美元/GB</li><li id="547d" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated"><a class="ae ld" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank">亚马逊弹性容器注册表</a>:存储:$ 0.10/GB/月，数据转出:$0.09/GB，每月第一GB免费</li></ul><p id="032a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据您的使用情况选择一个。</p><h1 id="5602" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧5:为MySQL设置根密码</h1><p id="e1e1" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">如果你知道正确的命令，MySQL容器非常容易设置。看起来是这样的:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="8182" class="lr kb hu lh b fv ls lt l lu lv">$ <strong class="lh hv">docker run -d \<br/>    --name db_mysql5 \<br/>    --network web-net \<br/>    --env MYSQL_RANDOM_ROOT_PASSWORD=1 \<br/>    mysql:5</strong></span></pre><p id="dfea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">-d</code>会将您的终端从集装箱上拆下。没有<code class="eh le lf lg lh b">-d</code>，你将被困在集装箱里，唯一的出路就是从另一个码头运行<code class="eh le lf lg lh b">docker stop db_mysql5</code>。</p><p id="c779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">--name db_mysql5</code>给容器命名，<code class="eh le lf lg lh b">--network web-net</code>将容器连接到一个名为<code class="eh le lf lg lh b">web-net</code>的网络，这个网络是我事先用<code class="eh le lf lg lh b">docker network create -d bridge web-net</code>创建的。</p><p id="ffc9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">--env MYSQL_RANDOM_ROOT_PASSWORD=1</code>告诉MySQL在初始化时为root用户生成一个随机密码。可以从容器控制台看到密码:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="1c46" class="lr kb hu lh b fv ls lt l lu lv">$ <strong class="lh hv">docker logs db_mysql5 2&gt;/dev/null</strong><br/>Initializing database<br/>Database initialized<br/>Initializing certificates<br/>Certificates initialized<br/>MySQL init process in progress...<br/>GENERATED ROOT PASSWORD: raew8pej9noomohGhaew3WoP4euch6za</span></pre><p id="199a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">mysql容器启动后，您可以像这样更改docke密码:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="46f8" class="lr kb hu lh b fv ls lt l lu lv">$ <strong class="lh hv">docker exec -i -t db_mysql5 mysql -uroot -p</strong><br/>Enter password: <strong class="lh hv">raew8pej9noomohGhaew3WoP4euch6za</strong><br/>...<br/>mysql&gt; <strong class="lh hv">alter user 'root'@'localhost' identified by 'mypassword';</strong></span></pre><h1 id="eeda" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧6:对MySQL用户主机使用%</h1><p id="2931" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">这是关于为您的web应用程序创建mysql帐户。</p><p id="dc40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于app server与mysql不在同一个容器上运行，所以它不能使用“localhost”用户(比如<code class="eh le lf lg lh b">web@localhost</code>)连接mysql。所以我们必须指定<code class="eh le lf lg lh b">%</code>作为用户的主机部分:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="dfd8" class="lr kb hu lh b fv ls lt l lu lv">mysql&gt; create user 'web'@'%' identified by 'webpassword';</span></pre><h1 id="47fb" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧7:将秘密传递给应用程序容器</h1><p id="99c2" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">mysql用户名和密码之类的秘密不能写入源代码(例如django的<code class="eh le lf lg lh b">settings.py</code>),所以我们需要另一种方法将它们传递给app容器。虽然<a class="ae ld" href="https://docs.docker.com/engine/swarm/secrets/" rel="noopener ugc nofollow" target="_blank"> docker secrets </a>可以优雅地做到这一点，但是只能在Swarm中使用，我感觉对我的服务来说大材小用了。所以我决定简单地使用环境变量。</p><p id="b152" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在我的应用程序容器中创建了一个入口点脚本:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="ed21" class="lr kb hu lh b fv ls lt l lu lv">#!/bin/sh</span><span id="d5c5" class="lr kb hu lh b fv mk lt l lu lv"># Check production environment variables<br/>if [ -z "$EC_MYSQL_USER" -o -z "$EC_MYSQL_PASS" ]; then<br/>    echo &gt;&amp;2 'error: Must specify EC_MYSQL_USER and EC_MYSQL_PASS'<br/>    exit 1<br/>fi</span><span id="bb93" class="lr kb hu lh b fv mk lt l lu lv">if [ "$1" = "gunicorn" ]; then<br/>    ./manage.py migrate<br/>fi</span><span id="f66d" class="lr kb hu lh b fv mk lt l lu lv"># Start process<br/>exec "$@"</span></pre><p id="75ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Dockerfile中:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="568a" class="lr kb hu lh b fv ls lt l lu lv">ENTRYPOINT ["/app/entrypoint.sh"]<br/>CMD ["gunicorn", "-c", "/app/gunicorn.conf", "myapp.wsgi"]</span></pre><p id="8b8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要忘记在django <code class="eh le lf lg lh b">settings.py</code>中使用这些变量:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="f92b" class="lr kb hu lh b fv ls lt l lu lv">DATABASES = {<br/>    'default': {<br/>        'ENGINE': 'django.db.backends.mysql',<br/>        'NAME': 'mydatabase',<br/>        'HOST': 'db_mysql5',<br/>        'USER': os.environ.get('EC_MYSQL_USER'),<br/>        'PASSWORD': os.environ.get('EC_MYSQL_PASS'),<br/>    }<br/>}</span></pre><p id="a339" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此可以在docker命令行中指定这些秘密:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="2033" class="lr kb hu lh b fv ls lt l lu lv">$ docker run -it --network web-net --name myapp \<br/>    --env EC_MYSQL_USER=web \<br/>    --env EC_MYSQL_PASS=mysecret \<br/>    -p 12345:12345 \<br/>    myapp:latest</span></pre><p id="a68f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在实际部署中，秘密将存储在詹金斯和<a class="ae ld" href="https://plugins.jenkins.io/mask-passwords" rel="noopener ugc nofollow" target="_blank">屏蔽密码</a>插件可用于隐藏从詹金斯日志的密码。</p><h1 id="0a22" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">技巧8:向所有接口公开端口</h1><p id="403d" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">gunicorn用于运行应用服务器。如果没有容器，我们会让gunicorn监听<code class="eh le lf lg lh b">127.0.0.1:12345</code>，nginx会将请求代理到这个端口。但是当应用服务器在容器内部运行，而nginx在主机上时，gunicorn必须监听所有接口:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="4a55" class="lr kb hu lh b fv ls lt l lu lv"># gunicorn.conf<br/>bind = '0.0.0.0:12345'   # '127.0.0.1:12345' will not work!</span></pre><p id="929f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只有这样，容器端口映射才能工作:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="2ccf" class="lr kb hu lh b fv ls lt l lu lv">$ docker run -it --network web-net --name myapp \<br/>    --env EC_MYSQL_USER=web \<br/>    --env EC_MYSQL_PASS=mysecret \<br/>    -p 12345:12345 \<br/>    myapp:latest</span></pre></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="0228" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们今天的问题不是缺乏信息。问题是我们有如此多的信息，以至于我们无法找出哪一部分最符合我们的需求。希望这篇帖子可以帮助初学者在学习docker后开始第一个docker项目时做出正确的决定。</p><p id="296d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读，如果觉得有用请为我鼓掌！</p></div></div>    
</body>
</html>