<html>
<head>
<title>Build a cryptocurrency alert app using Kotlin and Go: Part 1 — The frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin和Go构建加密货币警报应用程序:第1部分—前端</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-cryptocurrency-alert-app-using-kotlin-and-go-part-1-the-frontend-3b240cf75672?source=collection_archive---------17-----------------------#2018-08-27">https://medium.com/hackernoon/build-a-cryptocurrency-alert-app-using-kotlin-and-go-part-1-the-frontend-3b240cf75672?source=collection_archive---------17-----------------------#2018-08-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="7fd6" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">你需要在你的机器上安装Android Studio 3+和Go 1.10.2+。你应该熟悉Android开发和Kotlin语言。</p></blockquote><p id="e15b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">加密货币是当今的热门话题之一，因此，许多人购买了许多加密货币。然而，市场是不可预测的，经常变化，所以人们倾向于关注他们资产价格的变化。</p><p id="19f7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在这篇文章中，我们将创建一个应用程序，实时观察加密货币的价值变化，并在变化发生时通知用户。我们将重点关注两种非常流行的加密货币——比特币和以太坊。当我们完成后，当比特币和以太坊的价值超过或低于您在应用程序设置中指定的值时，您的手机会收到推送通知。</p><p id="2efa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">下面是我们将要构建的内容的屏幕记录:</p><figure class="jx jy jz ka fq kb fe ff paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="fe ff jw"><img src="../Images/c2cd56f333962901af2c120309afd563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9g0iD4TbKe_gBYrI.gif"/></div></div></figure><h1 id="4777" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">先决条件</h1><p id="65cf" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">要继续操作，您需要安装以下软件:</p><ul class=""><li id="c3b4" class="ll lm hu ix b iy iz jc jd jt ln ju lo jv lp js lq lr ls lt dt translated">机器上安装的Android Studio(v3 . x或更高版本)。<a class="ae lu" href="https://developer.android.com/studio/index.html" rel="noopener ugc nofollow" target="_blank">在这里下载</a>。</li><li id="cf39" class="ll lm hu ix b iy lv jc lw jt lx ju ly jv lz js lq lr ls lt dt translated">Go版本1.10.2或更高版本<a class="ae lu" href="https://golang.org/doc/install#install" rel="noopener ugc nofollow" target="_blank">已安装</a>。</li><li id="6f04" class="ll lm hu ix b iy lv jc lw jt lx ju ly jv lz js lq lr ls lt dt translated"><a class="ae lu" href="http://www.sqlitetutorial.net/download-install-sqlite/" rel="noopener ugc nofollow" target="_blank"> SQLite安装</a>在你的机器上。</li><li id="ccb3" class="ll lm hu ix b iy lv jc lw jt lx ju ly jv lz js lq lr ls lt dt translated">使用Android Studio IDE的基本知识。</li><li id="0ca7" class="ll lm hu ix b iy lv jc lw jt lx ju ly jv lz js lq lr ls lt dt translated">Kotlin编程语言基础知识。见<a class="ae lu" href="https://kotlinlang.org/docs/reference/" rel="noopener ugc nofollow" target="_blank">正式文件</a>。</li><li id="fde1" class="ll lm hu ix b iy lv jc lw jt lx ju ly jv lz js lq lr ls lt dt translated">Go和<a class="ae lu" href="https://echo.labstack.com/" rel="noopener ugc nofollow" target="_blank"> Echo框架</a>的基础知识。</li></ul><h1 id="6ba3" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">构建我们的Android应用程序</h1><p id="93b0" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">首先，启动Android Studio并创建一个新的应用程序。输入应用程序的名称，例如<strong class="ix hv"> CryptoAlert </strong>，然后输入软件包名称。确保<strong class="ix hv">启用Kotlin支持</strong>复选框被选中。选择最小SDK，点击<strong class="ix hv">下一步，</strong>选择一个<strong class="ix hv">空活动</strong>模板，坚持主活动命名方案，然后点击<strong class="ix hv">完成</strong>。</p><figure class="jx jy jz ka fq kb fe ff paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="fe ff ma"><img src="../Images/f9ec1fcbe07d6b83de4932db5c5e4740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XPzEpFui_aWHSWJi.png"/></div></div></figure><h2 id="dfb0" class="mb kj hu bd kk mc md me ko mf mg mh ks jt mi mj kw ju mk ml la jv mm mn le mo dt translated">创建推杆梁应用程序</h2><p id="1129" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">由于推杆梁依赖于Firebase，我们需要一个FCM密钥和一个<code class="eh mp mq mr ms b">google-services.json</code>文件。进入你的<a class="ae lu" href="https://console.firebase.google.com/u/0/" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>，点击<strong class="ix hv">添加</strong>项目<strong class="ix hv">卡片，初始化app创建向导。</strong></p><p id="d2c3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">添加项目名称，例如，<code class="eh mp mq mr ms b">crypto-`</code> alert `，阅读并接受条件条款。此后，您将被引导至项目概述屏幕。选择<strong class="ix hv">将Firebase添加到您的Android应用程序</strong>选项。</p><p id="0197" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">下一个屏幕将要求您的应用程序的包名。你可以在你的app-module <code class="eh mp mq mr ms b">build.gradle</code>文件中找到你的应用的包名。留意<code class="eh mp mq mr ms b">applicationId</code>值。输入包名，点击<strong class="ix hv">下一步</strong>。系统会提示您下载一个<code class="eh mp mq mr ms b">google-services.json</code>文件。下载文件并跳过剩余的过程。将下载的文件添加到您的项目- <code class="eh mp mq mr ms b">name-of-project/app</code>的app文件夹中。</p><p id="b6fd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">要获取FCM密钥，请转到Firebase上的项目设置，在云消息选项卡下，您应该会看到服务器密钥。</p><figure class="jx jy jz ka fq kb fe ff paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="fe ff ma"><img src="../Images/9d80af4ddde6f6ca53d18b17e096f9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qIxv6a4JRR2EHHau.png"/></div></div></figure><p id="51ae" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，登录新的<a class="ae lu" href="https://dash.pusher.com/" rel="noopener ugc nofollow" target="_blank">推杆仪表板</a>。如果您还没有帐户，您应该注册。</p><p id="11c3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开推杆梁仪表板，创建一个新的推杆梁应用程序。</p><figure class="jx jy jz ka fq kb fe ff paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="fe ff ma"><img src="../Images/c33009d71f975efc06aa786bebd43eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ji54gBEIGwhg4S3b.png"/></div></div></figure><p id="e4c9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">创建实例后，您将看到一个快速入门指南。选择<strong class="ix hv">安卓快速入门</strong>。添加FCM密钥后，您可以退出快速入门指南。</p><h2 id="c4b3" class="mb kj hu bd kk mc md me ko mf mg mh ks jt mi mj kw ju mk ml la jv mm mn le mo dt translated">向我们的应用程序添加功能</h2><p id="11fc" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">为了让我们的应用程序工作，我们需要引入几个依赖项。为此，将以下内容添加到项目<code class="eh mp mq mr ms b">build-gradle</code>文件中:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="b4f8" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: ./build.gradle</em><br/>    buildscript {<br/>        <em class="iw">// [...]</em></span><span id="bfdb" class="mb kj hu ms b fv nb my l mz na">        dependencies {<br/>            <em class="iw">// [...]</em></span><span id="ebd7" class="mb kj hu ms b fv nb my l mz na">            classpath 'com.google.gms:google-services:4.0.0'<br/>        }<br/>    }</span><span id="3a44" class="mb kj hu ms b fv nb my l mz na">    <em class="iw">// [...]</em></span></pre><p id="8684" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，将以下内容添加到应用程序模块<code class="eh mp mq mr ms b">build.gradle</code>文件中:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="499b" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: ./app/build.gradle</em><br/>    dependencies {<br/>        implementation 'com.squareup.retrofit2:retrofit:2.4.0'<br/>        implementation 'com.squareup.retrofit2:converter-scalars:2.4.0'<br/>        implementation 'com.google.firebase:firebase-messaging:17.1.0'<br/>        implementation 'com.pusher:push-notifications-android:0.10.0'<br/>        [...]<br/>    }</span><span id="c018" class="mb kj hu ms b fv nb my l mz na">    <em class="iw">// Add this line to the end of the file</em><br/>    apply plugin: 'com.google.gms.google-services'</span></pre><p id="10fe" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面我们包括了<a class="ae lu" href="https://github.com/square/retrofit" rel="noopener ugc nofollow" target="_blank">改型</a>——一个用于打网络电话的包，然后是用于发送推送通知的Pusher Beams包。附加的Google服务是Pusher Beams包的依赖项。同步您的gradle文件，使库可供使用。</p><p id="56d0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，创建一个名为<code class="eh mp mq mr ms b">ApiService</code>的新接口，并粘贴下面的代码:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="2292" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: ./app/src/main/java/{package-name}/ApiService.kt</em></span><span id="dfb6" class="mb kj hu ms b fv nb my l mz na">    import okhttp3.RequestBody<br/>    import retrofit2.Call<br/>    import retrofit2.http.Body<br/>    import retrofit2.http.GET<br/>    import retrofit2.http.POST</span><span id="3f74" class="mb kj hu ms b fv nb my l mz na">    interface ApiService {</span><span id="f1db" class="mb kj hu ms b fv nb my l mz na">      <strong class="ms hv">@POST("/btc-pref")</strong><br/>      fun saveBTCLimit(<strong class="ms hv">@Body</strong> body: RequestBody): Call&lt;String&gt;</span><span id="8a86" class="mb kj hu ms b fv nb my l mz na">      <strong class="ms hv">@POST("/eth-pref")</strong><br/>      fun saveETHLimit(<strong class="ms hv">@Body</strong> body: RequestBody): Call&lt;String&gt;</span><span id="0583" class="mb kj hu ms b fv nb my l mz na">      <strong class="ms hv">@GET("/fetch-values")</strong><br/>      fun getValues():Call&lt;String&gt;</span><span id="05ed" class="mb kj hu ms b fv nb my l mz na">    }</span></pre><p id="3337" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">该文件用于通过改造来了解要访问的端点。第一个端点<code class="eh mp mq mr ms b">/btc-pref</code>用于设置比特币限额。下一个端点<code class="eh mp mq mr ms b">/eth-pref</code>用于保存以太坊限制。最后一个端点<code class="eh mp mq mr ms b">/fetch-values</code>用于获取加密货币的当前值。</p><p id="d419" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">要在您的应用程序中使用网络服务，请在您的<code class="eh mp mq mr ms b">AndroidManifest.xml</code>文件中添加internet权限，如下所示:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="a8c3" class="mb kj hu ms b fv mx my l mz na">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"<br/>      package="com.example.cryptoalat"&gt;</span><span id="6244" class="mb kj hu ms b fv nb my l mz na">      &lt;uses-permission android:name="android.permission.INTERNET"/&gt;<br/>      [...]</span><span id="0cd9" class="mb kj hu ms b fv nb my l mz na">    &lt;/manifest&gt;</span></pre><p id="8119" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们将在应用程序中管理通知。创建一个名为<code class="eh mp mq mr ms b">NotificationsMessagingService</code>的新服务并粘贴它:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="d6ad" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: ./app/src/main/java/{package-name}/NotificationsMessagingService.kt</em><br/>    import android.app.NotificationChannel<br/>    import android.app.NotificationManager<br/>    import android.app.PendingIntent<br/>    import android.content.Intent<br/>    import android.os.Build<br/>    import android.support.v4.app.NotificationCompat<br/>    import android.support.v4.app.NotificationManagerCompat<br/>    import com.google.firebase.messaging.RemoteMessage<br/>    import com.pusher.pushnotifications.fcm.MessagingService</span><span id="5306" class="mb kj hu ms b fv nb my l mz na">    class NotificationsMessagingService : MessagingService() {</span><span id="2d89" class="mb kj hu ms b fv nb my l mz na">        override fun onMessageReceived(remoteMessage: RemoteMessage) {<br/>            val notificationId = 10<br/>            val channelId  = "crypto_channel"<br/>            lateinit var channel: NotificationChannel<br/>            val intent = Intent(this, MainActivity::class.java)<br/>            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK<br/>            val pendingIntent = PendingIntent.getActivity(this, 0, intent, 0)</span><span id="22ff" class="mb kj hu ms b fv nb my l mz na">            val mBuilder = NotificationCompat.Builder(this, channelId)<br/>                    .setSmallIcon(R.mipmap.ic_launcher)<br/>                    .setContentTitle(remoteMessage.notification!!.title!!)<br/>                    .setContentText(remoteMessage.notification!!.body!!)<br/>                    .setContentIntent(pendingIntent)<br/>                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)<br/>                    .setAutoCancel(true)</span><span id="b043" class="mb kj hu ms b fv nb my l mz na">            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {<br/>                val notificationManager = applicationContext.getSystemService(NotificationManager::class.java)<br/>                val name = getString(R.string.channel_name)<br/>                val description = getString(R.string.channel_description)<br/>                val importance = NotificationManager.IMPORTANCE_DEFAULT<br/>                channel = NotificationChannel("crypto_channel", name, importance)<br/>                channel.description = description<br/>                notificationManager!!.createNotificationChannel(channel)<br/>                notificationManager.notify(notificationId, mBuilder.build())<br/>            } else {<br/>                val notificationManager =  NotificationManagerCompat.from(this)<br/>                notificationManager.notify(notificationId, mBuilder.build())<br/>            }<br/>        }<br/>    }</span></pre><p id="f163" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">因为Android O中推送通知有重大变化，所以我们在处理通知之前检查了Android版本。如果我们使用Android O或更新版本，我们必须创建一个通知通道，用于对我们发送的通知类型进行分类。这对于发送不同类型通知的应用程序特别有用。</p><p id="dd7b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们还利用存储在<code class="eh mp mq mr ms b">strings.xml</code>文件中的一些文件来描述通知通道描述和通道名称。将这些添加到<code class="eh mp mq mr ms b">strings.xml</code>文件中:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="fe9c" class="mb kj hu ms b fv mx my l mz na"><em class="iw">&lt;!-- File: /app/src/main/res/values/strings.xml --&gt;</em><br/>    &lt;string name="channel_name"&gt;Crypto&lt;/string&gt;<br/>    &lt;string name="channel_description"&gt;To receive updates about changes in cryptocurrency value&lt;/string&gt;</span></pre><p id="577d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mp mq mr ms b">AndroidManifest.xml</code>文件中注册服务:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="3309" class="mb kj hu ms b fv mx my l mz na">&lt;application<br/>      &gt;<br/>      [...]<br/>      &lt;service android:name=".NotificationsMessagingService"&gt;<br/>          &lt;intent-filter android:priority="1"&gt;<br/>              &lt;action android:name="com.google.firebase.MESSAGING_EVENT" /&gt;<br/>          &lt;/intent-filter&gt;<br/>      &lt;/service&gt;<br/>    &lt;/application&gt;</span></pre><p id="a722" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，让我们准备我们的布局。首先，我们将设计活动的布局。创建应用程序时，<code class="eh mp mq mr ms b">activity_main.xml</code>文件应该已经存在于布局文件夹中。打开它并替换为:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="2921" class="mb kj hu ms b fv mx my l mz na"><em class="iw">&lt;!-- File: ./app/src/main/res/layout/activity_main.xml --&gt;</em><br/>    <strong class="ms hv">&lt;?</strong>xml version="1.0" encoding="utf-8"<strong class="ms hv">?&gt;</strong><br/>    &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>      xmlns:app="http://schemas.android.com/apk/res-auto"<br/>      xmlns:tools="http://schemas.android.com/tools"<br/>      android:layout_width="match_parent"<br/>      android:layout_height="match_parent"<br/>      tools:context=".MainActivity"&gt;</span><span id="b020" class="mb kj hu ms b fv nb my l mz na">      &lt;TextView<br/>        android:id="@+id/bitcoinValue"<br/>        android:padding="20dp"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:layout_marginStart="8dp"<br/>        android:layout_marginTop="8dp"<br/>        android:text="1 BTC"<br/>        android:textSize="16sp"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;</span><span id="1855" class="mb kj hu ms b fv nb my l mz na">      &lt;TextView<br/>        android:id="@+id/etherumValue"<br/>        android:padding="20dp"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:layout_marginTop="16dp"<br/>        android:layout_marginStart="8dp"<br/>        android:text="1 ETH"<br/>        android:textSize="16sp"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toBottomOf="@+id/bitcoinValue"/&gt;</span><span id="1997" class="mb kj hu ms b fv nb my l mz na">    &lt;/android.support.constraint.ConstraintLayout&gt;</span></pre><p id="31c5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">该布局包含两个显示比特币和以太坊价格的<code class="eh mp mq mr ms b">TextView</code>。我们还使这些<code class="eh mp mq mr ms b">TextView</code>可点击，这样我们可以设置限制，以便在超过限制时得到通知。</p><p id="a117" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们将设计警报对话框的布局。创建一个名为<code class="eh mp mq mr ms b">alert_layout</code>的新布局文件并粘贴:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="fd23" class="mb kj hu ms b fv mx my l mz na"><em class="iw">&lt;!-- File: ./app/src/main/res/layout/alert_layout.xml --&gt;</em><br/>    <strong class="ms hv">&lt;?</strong>xml version="1.0" encoding="utf-8"<strong class="ms hv">?&gt;</strong><br/>    &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>      android:orientation="vertical" android:layout_width="match_parent"<br/>      android:padding="20dp"<br/>      android:layout_height="match_parent"&gt;</span><span id="9887" class="mb kj hu ms b fv nb my l mz na">      &lt;EditText<br/>        android:id="@+id/minimumValue"<br/>        android:background="@drawable/text_background"<br/>        android:hint="Minimum value"<br/>        android:paddingStart="10dp"<br/>        android:paddingEnd="10dp"<br/>        android:inputType="number"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="60dp" /&gt;</span><span id="8749" class="mb kj hu ms b fv nb my l mz na">      &lt;EditText<br/>        android:layout_marginTop="10dp"<br/>        android:background="@drawable/text_background"<br/>        android:hint="Maximum value"<br/>        android:inputType="number"<br/>        android:id="@+id/maximumValue"<br/>        android:layout_width="match_parent"<br/>        android:paddingStart="10dp"<br/>        android:paddingEnd="10dp"<br/>        android:layout_height="60dp" /&gt;</span><span id="5787" class="mb kj hu ms b fv nb my l mz na">      &lt;Button<br/>        android:id="@+id/save"<br/>        android:layout_marginTop="10dp"<br/>        android:layout_gravity="center"<br/>        android:text="SAVE"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content" /&gt;<br/></span><span id="3abb" class="mb kj hu ms b fv nb my l mz na">    &lt;/LinearLayout&gt;</span></pre><p id="a53e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将是对话框显示的布局。它包含两个文本字段和一个<strong class="ix hv">保存</strong>按钮，我们为<code class="eh mp mq mr ms b">TextView</code> s使用了一个自定义设计的背景。创建一个名为<code class="eh mp mq mr ms b">text_background</code>的新的可绘制文件并粘贴它:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="e6c5" class="mb kj hu ms b fv mx my l mz na"><em class="iw">&lt;!-- File: /app/src/main/res/drawable/text_background.xml --&gt;</em><br/>    &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt;<br/>      &lt;solid android:color="@android:color/white" /&gt;<br/>      &lt;stroke android:width="1dip" android:color="@android:color/darker_gray"/&gt;<br/>    &lt;/shape&gt;</span></pre><p id="ac6e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将转到<code class="eh mp mq mr ms b">MainActivity</code>来完成我们应用程序的功能。打开您的<code class="eh mp mq mr ms b">MainActivity</code>，用以下内容替换内容:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="a3d7" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: ./app/src/main/java/{package-name}/MainActivity.Kt</em><br/>    import android.os.Bundle<br/>    import okhttp3.MediaType<br/>    import okhttp3.RequestBody<br/>    import org.json.JSONObject<br/>    import retrofit2.Call<br/>    import retrofit2.Callback<br/>    import retrofit2.Response<br/>    import android.support.v7.app.AlertDialog<br/>    import android.support.v7.app.AppCompatActivity<br/>    import android.util.Log<br/>    import android.view.LayoutInflater<br/>    import android.widget.Button<br/>    import android.widget.EditText<br/>    import com.pusher.pushnotifications.PushNotifications<br/>    import kotlinx.android.synthetic.main.activity_main.*<br/>    import okhttp3.OkHttpClient<br/>    import retrofit2.Retrofit<br/>    import retrofit2.converter.scalars.ScalarsConverterFactory</span><span id="817f" class="mb kj hu ms b fv nb my l mz na">    class MainActivity : AppCompatActivity() {</span><span id="ffc5" class="mb kj hu ms b fv nb my l mz na">        private var prefs: Prefs? = null</span><span id="7bd7" class="mb kj hu ms b fv nb my l mz na">        private val retrofit: ApiService by lazy {<br/>            val httpClient = OkHttpClient.Builder()<br/>            val builder = Retrofit.Builder()<br/>                    .baseUrl("http://10.0.2.2:9000/")<br/>                    .addConverterFactory(ScalarsConverterFactory.create())</span><span id="e95b" class="mb kj hu ms b fv nb my l mz na">            val retrofit = builder<br/>                    .client(httpClient.build())<br/>                    .build()<br/>            retrofit.create(ApiService::class.java)<br/>        }</span><span id="215c" class="mb kj hu ms b fv nb my l mz na">        override fun onCreate(savedInstanceState: Bundle?) {<br/>            super.onCreate(savedInstanceState)<br/>            setContentView(R.layout.activity_main)<br/>            fetchCurrentPrice()<br/>            setupPushNotifications()<br/>            setupClickListeners()<br/>        }<br/>    }</span></pre><blockquote class="ir is it"><p id="628c" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">上面使用的</em> <code class="eh mp mq mr ms b"><em class="hu">URL</em></code> <em class="hu">，</em> <code class="eh mp mq mr ms b"><em class="hu">http://10.0.2.2:9000/</em></code> <em class="hu">，是Android模拟器识别为localhost的URL。</em></p></blockquote><p id="f4aa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面，我们创建了一个用于网络调用的<code class="eh mp mq mr ms b">retrofit</code>对象。设置完<code class="eh mp mq mr ms b">retrofit</code>对象后，我们在<code class="eh mp mq mr ms b">onCreate</code>方法中添加布局，并调用其他三个函数:</p><ol class=""><li id="0aab" class="ll lm hu ix b iy iz jc jd jt ln ju lo jv lp js nc lr ls lt dt translated"><code class="eh mp mq mr ms b">fetchCurrentPrice</code> -该函数将从我们的服务器获取比特币和以太坊的当前价格。在类中创建一个新函数，并像这样设置它:</li></ol><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="615f" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: /app/src/main/java/{package-name}/MainActivity.kt</em><br/>    private fun fetchCurrentPrice() {<br/>        retrofit.getValues().enqueue(object: Callback&lt;String&gt; {<br/>            override fun onResponse(call: Call&lt;String&gt;?, response: Response&lt;String&gt;?) {<br/>                val jsonObject = JSONObject(response!!.body())<br/>                bitcoinValue.text = "1 BTC = $"+ jsonObject.getJSONObject("BTC").getString("USD")<br/>                etherumValue.text = "1 ETH = $"+ jsonObject.getJSONObject("ETH").getString("USD")<br/>            }</span><span id="67df" class="mb kj hu ms b fv nb my l mz na">            override fun onFailure(call: Call&lt;String&gt;?, t: Throwable?) {<br/>                Log.e("MainActivity",t!!.localizedMessage)<br/>            }<br/>        })<br/>    }</span></pre><p id="a7cc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上图中，进行了一个网络调用来获取当前的比特币和以太坊的美元价格。当收到响应时，我们解析JSON数据，并通过在布局中设置文本视图的文本将其显示在屏幕上。</p><ol class=""><li id="ea0c" class="ll lm hu ix b iy iz jc jd jt ln ju lo jv lp js nc lr ls lt dt translated"><code class="eh mp mq mr ms b">setupPushNotifications</code> -此功能是我们开始收听我们选择接收通知的兴趣所在。利息名称是这样的格式<strong class="ix hv">{ device _ uuid } _ { currency } _ changed</strong>。<em class="iw"> ** </em>我们注册两个利息，每种货币一个。打开<code class="eh mp mq mr ms b">MainActivity</code>类并添加以下方法:</li></ol><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="d87c" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: /app/src/main/java/{package-name}/MainActivity.Kt</em><br/>    private fun setupPushNotifications() {<br/>        PushNotifications.start(applicationContext, "PUSHER_BEAMS_INSTANCE_ID")<br/>        val fmt = "%s_%s_changed"<br/>        PushNotifications.subscribe(java.lang.String.format(fmt, deviceUuid(), "BTC"))<br/>        PushNotifications.subscribe(java.lang.String.format(fmt, deviceUuid(), "ETH"))<br/>    }</span></pre><blockquote class="ir is it"><p id="515d" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">将</em> <code class="eh mp mq mr ms b"><em class="hu">PUSHER_BEAMS_INSTANCE_ID</em></code> <em class="hu">替换为推杆梁仪表板上的实例ID。</em></p></blockquote><ol class=""><li id="09c9" class="ll lm hu ix b iy iz jc jd jt ln ju lo jv lp js nc lr ls lt dt translated"><code class="eh mp mq mr ms b">setupClickListeners</code> -在这个函数中，我们将为布局中的文本视图设置点击监听器。在同一个<code class="eh mp mq mr ms b">MainActivity</code>类中，添加以下方法:</li></ol><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="ce0c" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: /app/src/main/java/{package-name}/MainActivity.Kt</em><br/>    private fun setupClickListeners() {<br/>        bitcoinValue.setOnClickListener {<br/>            createDialog("BTC")<br/>        }</span><span id="3f2c" class="mb kj hu ms b fv nb my l mz na">        etherumValue.setOnClickListener {<br/>            createDialog("ETH")<br/>        }<br/>    }</span></pre><p id="890b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当任何文本视图被点击时，我们调用<code class="eh mp mq mr ms b">createDialog</code>方法，然后打开一个布局让用户输入限制。</p><p id="6dab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mp mq mr ms b">MainActivity</code>类中，添加方法<code class="eh mp mq mr ms b">createDialog</code>，如下所示:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="f097" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: /app/src/main/java/{package-name}/MainActivity.Kt</em><br/>    private fun createDialog(source:String){<br/>      val builder: AlertDialog.Builder = AlertDialog.Builder(this)<br/>      val view = LayoutInflater.from(this).inflate(R.layout.alert_layout,null)</span><span id="bc80" class="mb kj hu ms b fv nb my l mz na">      builder.setTitle("Set limits")<br/>          .setMessage("")<br/>          .setView(view)</span><span id="0a72" class="mb kj hu ms b fv nb my l mz na">      val dialog = builder.create()<br/>      val minEditText: EditText = view.findViewById(R.id.minimumValue)<br/>      val maxEditText: EditText = view.findViewById(R.id.maximumValue)</span><span id="2af3" class="mb kj hu ms b fv nb my l mz na">      view.findViewById&lt;Button&gt;(R.id.save).setOnClickListener {<br/>        if (source == "BTC"){<br/>          saveBTCPref(minEditText.text.toString(), maxEditText.text.toString())<br/>        } else {<br/>          saveETHPref(minEditText.text.toString(), maxEditText.text.toString())<br/>        }<br/>        dialog.dismiss()<br/>      }<br/>      dialog.show()<br/>    }</span></pre><p id="5dea" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">该对话框获取最小值和最大值，并将其发送到后端服务器。这样做是为了当加密货币的价格变化时，如果它在设定的限制范围内，我们会收到推送通知。</p><p id="8542" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的函数中，我们调用了两个新方法。在<code class="eh mp mq mr ms b">MainActivity</code>类中添加两个方法，如下所示:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="e7e7" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: /app/src/main/java/{package-name}/MainActivity.Kt</em><br/>    private fun saveBTCPref(min:String, max:String){<br/>        val jsonObject = JSONObject()<br/>        jsonObject.put("minBTC", min)<br/>        jsonObject.put("maxBTC", max)<br/>        jsonObject.put("uuid", deviceUuid())</span><span id="e41a" class="mb kj hu ms b fv nb my l mz na">        val body = RequestBody.create(<br/>                MediaType.parse("application/json"),<br/>                jsonObject.toString()<br/>        )</span><span id="ae93" class="mb kj hu ms b fv nb my l mz na">        retrofit.saveBTCLimit(body).enqueue(object: Callback&lt;String&gt; {<br/>            override fun onResponse(call: Call&lt;String&gt;?, response: Response&lt;String&gt;?) {}<br/>            override fun onFailure(call: Call&lt;String&gt;?, t: Throwable?) {}<br/>        })<br/>    }</span><span id="e9e6" class="mb kj hu ms b fv nb my l mz na">    private fun saveETHPref(min:String, max:String){<br/>        val jsonObject = JSONObject()<br/>        jsonObject.put("minETH",min)<br/>        jsonObject.put("maxETH",max)<br/>        jsonObject.put("uuid", deviceUuid())</span><span id="2974" class="mb kj hu ms b fv nb my l mz na">        val body = RequestBody.create(<br/>                MediaType.parse("application/json"),<br/>                jsonObject.toString()<br/>        )</span><span id="3624" class="mb kj hu ms b fv nb my l mz na">        retrofit.saveETHLimit(body).enqueue(object: Callback&lt;String&gt; {<br/>            override fun onResponse(call: Call&lt;String&gt;?, response: Response&lt;String&gt;?) {}<br/>            override fun onFailure(call: Call&lt;String&gt;?, t: Throwable?) {}<br/>        })<br/>    }</span></pre><p id="9d81" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mp mq mr ms b">saveBTCPref</code>和<code class="eh mp mq mr ms b">saveETHPref</code>中，我们试图将用户设置的限制发送给API，以便为该用户保存。</p><p id="22f5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在发送的同时，我们还发送了设备的唯一标识符<code class="eh mp mq mr ms b">uuid</code>。让我们创建将为每个设备生成并保存这个UUID的<code class="eh mp mq mr ms b">deviceUuid()</code>方法。在<code class="eh mp mq mr ms b">MainActivity</code>类中，添加以下代码:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="1c1c" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: /app/src/main/java/{package-name}/MainActivity.Kt</em><br/>    private fun deviceUuid() : String {<br/>        prefs = Prefs(this)<br/>        var uuid: String = prefs!!.deviceUuid</span><span id="3f3d" class="mb kj hu ms b fv nb my l mz na">        if (uuid == "") {<br/>            uuid = java.util.UUID.randomUUID().toString().replace("-", "_")<br/>            prefs!!.deviceUuid = uuid<br/>        }</span><span id="ddc4" class="mb kj hu ms b fv nb my l mz na">        return uuid<br/>    }</span></pre><p id="7321" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在在这个函数中，我们引用了一个<code class="eh mp mq mr ms b">Prefs</code>类。创建一个新的<code class="eh mp mq mr ms b">Prefs</code>类，并将以下代码粘贴到其中:</p><pre class="jx jy jz ka fq mt ms mu mv aw mw dt"><span id="d125" class="mb kj hu ms b fv mx my l mz na"><em class="iw">// File: /app/src/main/java/{package-name}/Prefs.Kt</em><br/>    import android.content.Context<br/>    import android.content.SharedPreferences</span><span id="8660" class="mb kj hu ms b fv nb my l mz na">    class Prefs (context: Context) {<br/>        val PREFS_FILENAME = "com.example.coinalert.prefs"<br/>        val DEVICE_UUID = "device_uuid"<br/>        val prefs: SharedPreferences = context.getSharedPreferences(PREFS_FILENAME, 0);</span><span id="a3fd" class="mb kj hu ms b fv nb my l mz na">        var deviceUuid: String<br/>            get() = prefs.getString(DEVICE_UUID, "")<br/>            set(value) = prefs.edit().putString(DEVICE_UUID, value).apply()</span><span id="1ef0" class="mb kj hu ms b fv nb my l mz na">    }</span></pre><p id="e203" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">申请到此为止。此时，应用程序应该能够成功构建，但是不能按预期运行。在下一部分的<a class="ae lu" href="https://pusher.com/tutorials/cryptocurrency-kotlin-go-part-2" rel="noopener ugc nofollow" target="_blank">中，我们将构建应用程序的后端，这样它就可以按预期工作。</a></p><h1 id="a8bb" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结论</h1><p id="f735" class="pw-post-body-paragraph iu iv hu ix b iy lg ja jb jc lh je jf jt li ji jj ju lj jm jn jv lk jq jr js hn dt translated">在本文中，我们学习了如何使用推送光束来通知用户对加密货币的更改。您可以在这里找到本文中构建的应用程序的存储库。</p><p id="7ab9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这篇文章最初出现在<a class="ae lu" href="https://pusher.com/tutorials/cryptocurrency-kotlin-go-part-1" rel="noopener ugc nofollow" target="_blank"> Pusher博客</a>上。</p></div></div>    
</body>
</html>