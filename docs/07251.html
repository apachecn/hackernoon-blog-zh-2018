<html>
<head>
<title>Build a cryptocurrency alert app using Kotlin and Go: Part 2 — The backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin和Go构建加密货币警报应用程序:第2部分—后端</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-cryptocurrency-alert-app-using-kotlin-and-go-part-2-the-backend-fef4c92c70f6?source=collection_archive---------35-----------------------#2018-08-27">https://medium.com/hackernoon/build-a-cryptocurrency-alert-app-using-kotlin-and-go-part-2-the-backend-fef4c92c70f6?source=collection_archive---------35-----------------------#2018-08-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="0582" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">你需要在你的机器上安装Android Studio 3+和Go 1.10.2+。你应该熟悉Android开发和Kotlin语言。</p></blockquote><p id="07cc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在本文的第一部分<a class="ae jw" href="https://pusher.com/tutorials/cryptocurrency-kotlin-go-part-1" rel="noopener ugc nofollow" target="_blank">中，我们通过创建我们的Android应用程序开始构建我们的服务。然而，该应用程序需要后端才能正常工作。所以在这一部分，我们将创建应用程序的后端。</a></p><p id="d3ed" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们将使用Go来构建应用程序的后端。我们将在Go中使用的框架是<a class="ae jw" href="https://echo.labstack.com/" rel="noopener ugc nofollow" target="_blank"> Echo </a>。</p><p id="1bab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">作为一个总结，这里是一个屏幕记录，当我们完成时，我们将建立什么:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/8a54fe0c7faa89477664124c83bc3910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i6Kn3b-sXv-EfPo_.gif"/></div></div></figure><h1 id="8152" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">先决条件</h1><p id="fdfb" class="pw-post-body-paragraph iu iv hu ix b iy lh ja jb jc li je jf jt lj ji jj ju lk jm jn jv ll jq jr js hn dt translated">要跟进，您需要:</p><ul class=""><li id="28bc" class="lm ln hu ix b iy iz jc jd jt lo ju lp jv lq js lr ls lt lu dt translated">完成文章的第一部分。</li><li id="4742" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js lr ls lt lu dt translated">机器上安装的Android Studio(v3 . x或更高版本)。<a class="ae jw" href="https://developer.android.com/studio/index.html" rel="noopener ugc nofollow" target="_blank">此处下载</a>。</li><li id="aa5a" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js lr ls lt lu dt translated">Go版本1.10.2或更高版本<a class="ae jw" href="https://golang.org/doc/install#install" rel="noopener ugc nofollow" target="_blank">已安装</a>。</li><li id="e63d" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js lr ls lt lu dt translated"><a class="ae jw" href="http://www.sqlitetutorial.net/download-install-sqlite/" rel="noopener ugc nofollow" target="_blank"> SQLite安装在您的机器上</a>。</li><li id="f365" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js lr ls lt lu dt translated">使用Android Studio IDE的基本知识。</li><li id="9f57" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js lr ls lt lu dt translated">Kotlin编程语言基础知识。见<a class="ae jw" href="https://kotlinlang.org/docs/reference/" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</li><li id="6d4e" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js lr ls lt lu dt translated">Go和<a class="ae jw" href="https://echo.labstack.com/" rel="noopener ugc nofollow" target="_blank"> Echo框架</a>的基础知识。</li></ul><h1 id="6214" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">构建我们的Go API</h1><h2 id="86f6" class="ma kk hu bd kl mb mc md kp me mf mg kt jt mh mi kx ju mj mk lb jv ml mm lf mn dt translated">安装</h2><p id="4995" class="pw-post-body-paragraph iu iv hu ix b iy lh ja jb jc li je jf jt lj ji jj ju lk jm jn jv ll jq jr js hn dt translated">首先，为您的应用程序创建一个新的项目目录。我们将创建一个名为<code class="eh mo mp mq mr b">backend</code>的。建议您在您的<code class="eh mo mp mq mr b">$GOPATH</code>中创建它，但是这不是必需的。</p><p id="586a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在项目目录中，创建三个新目录:</p><ol class=""><li id="10c3" class="lm ln hu ix b iy iz jc jd jt lo ju lp jv lq js ms ls lt lu dt translated">数据库</li><li id="5f6a" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js ms ls lt lu dt translated">通知</li><li id="8c19" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js ms ls lt lu dt translated">路线</li></ol><p id="d2c4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mo mp mq mr b">database</code>目录中，创建一个名为<code class="eh mo mp mq mr b">model</code>的新目录。在这个<code class="eh mo mp mq mr b">database</code>目录中，我们将存储所有与数据库相关的东西，包括SQLite数据库文件、<code class="eh mo mp mq mr b">model</code>和<code class="eh mo mp mq mr b">database</code>包。</p><p id="2aa1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mo mp mq mr b">notification</code>目录中，我们将有一个包，其中包含向设备发送推送通知所需的一切。</p><p id="65f5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，在<code class="eh mo mp mq mr b">routes</code>目录中，我们将拥有<code class="eh mo mp mq mr b">routes</code>包，其中包含每个HTTP请求的逻辑。</p><p id="ac2e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在让我们开始构建应用程序。</p><p id="3f79" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在项目的根目录下创建一个新的<code class="eh mo mp mq mr b">main.go</code>文件。在这个文件中，我们将添加项目的核心。我们将设置路由、中间件和数据库。</p><p id="a3b9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mo mp mq mr b">main.go</code>文件中，粘贴以下代码:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="cc1f" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// File: ./main.go</em><br/>    package main</span><span id="3c38" class="ma kk hu mr b fv nb my l mz na">    import (<br/>        "./database"<br/>        "./routes"</span><span id="762c" class="ma kk hu mr b fv nb my l mz na">        "github.com/labstack/echo"<br/>        "github.com/labstack/echo/middleware"<br/>    )</span><span id="8a11" class="ma kk hu mr b fv nb my l mz na">    func main() {<br/>        db := database.Initialize("./database/db.sqlite")<br/>        database.Migrate(db)</span><span id="55a1" class="ma kk hu mr b fv nb my l mz na">        e := echo.New()</span><span id="6ae9" class="ma kk hu mr b fv nb my l mz na">        e.Use(middleware.Logger())<br/>        e.Use(middleware.Recover())</span><span id="8a4d" class="ma kk hu mr b fv nb my l mz na">        e.GET("/fetch-values", routes.GetPrices())<br/>        e.POST("/btc-pref", routes.SaveDeviceSettings(db))<br/>        e.POST("/eth-pref", routes.SaveDeviceSettings(db))<br/>        e.GET("/simulate", routes.SimulatePriceChanges(db))</span><span id="3ca8" class="ma kk hu mr b fv nb my l mz na">        e.Start(":9000")<br/>    }</span></pre><p id="d235" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们首先导入了一些包，Go脚本将需要这些包才能工作。然后我们使用导入的<code class="eh mo mp mq mr b">database</code>子包实例化数据库。接下来，我们在<code class="eh mo mp mq mr b">db</code>实例上运行迁移。这将创建应用程序需要运行的数据库表(如果它还不存在)。</p><p id="168a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们创建一个新的Echo实例<code class="eh mo mp mq mr b">e</code>。然后，我们使用该实例注册<a class="ae jw" href="https://echo.labstack.com/middleware/logger" rel="noopener ugc nofollow" target="_blank">记录器</a>中间件和<a class="ae jw" href="https://echo.labstack.com/middleware/recover" rel="noopener ugc nofollow" target="_blank">恢复</a>中间件。</p><blockquote class="ir is it"><p id="c701" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">日志记录器中间件记录关于每个HTTP请求的信息。</em></p><p id="ea2f" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">恢复中间件从链中任何地方的死机中恢复，打印堆栈跟踪并将控制处理给集中式</em><a class="ae jw" href="https://echo.labstack.com/guide/customization#http-error-handler" rel="noopener ugc nofollow" target="_blank"><em class="hu">HTTPErrorHandler</em></a><em class="hu">。</em></p></blockquote><p id="be11" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后，我们注册我们的路由，并使用我们导入的<code class="eh mo mp mq mr b">routes</code>包将一个处理程序映射到它们。这些路线是:</p><ol class=""><li id="7bb5" class="lm ln hu ix b iy iz jc jd jt lo ju lp jv lq js ms ls lt lu dt translated"><code class="eh mo mp mq mr b">GET /fetch-values</code> -获取所有受支持货币的当前价格，并返回一个JSON响应。</li><li id="b0f2" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js ms ls lt lu dt translated"><code class="eh mo mp mq mr b">POST /btc-pref</code> -存储BTC在收到通知并返回JSON响应之前必须为设备支付的最低和最高价格。</li><li id="2ec2" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js ms ls lt lu dt translated"><code class="eh mo mp mq mr b">POST /eth-pref</code> -存储设备在收到通知并返回JSON响应之前ETH必须超过的最低和最高价格。</li><li id="cff8" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js ms ls lt lu dt translated"><code class="eh mo mp mq mr b">GET /simulate</code> -模拟受支持货币的价格变化。</li></ol><p id="a532" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">完成路由后，我们在端口9000上启动服务器。</p><blockquote class="ir is it"><p id="52ba" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果正在使用9000，您可以选择不同的端口，只要记得在您的 <code class="eh mo mp mq mr b"><em class="hu">MainActivity.kt</em></code> <em class="hu">文件中也进行更改即可。</em></p></blockquote><p id="daa8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在我们有了<code class="eh mo mp mq mr b">main.go</code>文件，让我们引入脚本需要的所有导入。打开您的终端并运行以下命令:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="15bc" class="ma kk hu mr b fv mx my l mz na">$ go get github.com/labstack/echo<br/>    $ go get github.com/labstack/echo/middleware</span></pre><p id="66d7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这将引入Echo包和Echo中间件包。对于另外两个包，<code class="eh mo mp mq mr b">database</code>和<code class="eh mo mp mq mr b">routes</code>，我们将手动创建它们。让我们现在做那件事。</p><h2 id="b7b2" class="ma kk hu bd kl mb mc md kp me mf mg kt jt mh mi kx ju mj mk lb jv ml mm lf mn dt translated">创建内部Go包</h2><p id="4c0b" class="pw-post-body-paragraph iu iv hu ix b iy lh ja jb jc li je jf jt lj ji jj ju lk jm jn jv ll jq jr js hn dt translated">如前所述，我们将创建一些内部包，使应用程序更加模块化，所以让我们从<code class="eh mo mp mq mr b">database</code>包开始。</p><p id="015b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mo mp mq mr b">database</code>目录下，创建一个新的<code class="eh mo mp mq mr b">init.go</code>文件，并粘贴以下代码:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="68be" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// File: ./database/init.go</em><br/>    package database</span><span id="f4ca" class="ma kk hu mr b fv nb my l mz na">    import (<br/>        "database/sql"</span><span id="d06e" class="ma kk hu mr b fv nb my l mz na">        _ "github.com/mattn/go-sqlite3"<br/>    )</span><span id="c083" class="ma kk hu mr b fv nb my l mz na">    <em class="iw">// Initialize initialises the database</em><br/>    func Initialize(filepath string) *sql.DB {<br/>        db, err := sql.Open("sqlite3", filepath)<br/>        if err != nil || db == nil {<br/>            panic("Error connecting to database")<br/>        }</span><span id="76c4" class="ma kk hu mr b fv nb my l mz na">        return db<br/>    }</span><span id="077c" class="ma kk hu mr b fv nb my l mz na">    <em class="iw">// Migrate migrates the database</em><br/>    func Migrate(db *sql.DB) {<br/>        sql := `<br/>            CREATE TABLE IF NOT EXISTS devices(<br/>                    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,<br/>                    uuid VARCHAR NOT NULL,<br/>                    btc_min INTEGER,<br/>                    btc_max INTEGER,<br/>                    eth_min INTEGER,<br/>                    eth_max INTEGER<br/>            );<br/>       `</span><span id="afa9" class="ma kk hu mr b fv nb my l mz na">        _, err := db.Exec(sql)<br/>        if err != nil {<br/>            panic(err)<br/>        }<br/>    }</span></pre><p id="ac85" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的文件中，我们首先导入两个包，一个是内置的<code class="eh mo mp mq mr b">database/sql</code>，另一个是<a class="ae jw" href="http://github.com/mattn/go-sqlite3" rel="noopener ugc nofollow" target="_blank"> mattn/go-sqlite3 </a>包，这是一个使用<code class="eh mo mp mq mr b">database/sql</code>的go的sqlite3驱动程序。打开终端并运行以下命令:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="bc54" class="ma kk hu mr b fv mx my l mz na">$ go get github.com/mattn/go-sqlite3</span></pre><p id="c9d3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们创建了一个名为<code class="eh mo mp mq mr b">Initialize</code>的函数，在这个函数中，我们初始化了SQLite数据库。如果数据库文件不存在，这将创建一个新的数据库文件，或者使用现有的文件。</p><p id="38c6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们还有一个<code class="eh mo mp mq mr b">Migrate</code>函数，用于指定应用程序初始化时要运行的SQL查询。从查询中可以看出，只有当表<code class="eh mo mp mq mr b">devices</code>不存在时，我们才创建它。</p><p id="f48a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><code class="eh mo mp mq mr b">init.go</code>文件到此为止。</p><p id="5973" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mo mp mq mr b">routes</code>目录下创建一个新的<code class="eh mo mp mq mr b">routes.go</code>文件，并粘贴以下代码:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="478d" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// File: ./routes/routes.go</em><br/>    package routes</span><span id="92bb" class="ma kk hu mr b fv nb my l mz na">    import (<br/>        "database/sql"<br/>        "errors"<br/>        "net/http"<br/>        "strconv"</span><span id="2294" class="ma kk hu mr b fv nb my l mz na">        "../database/model"</span><span id="bdd4" class="ma kk hu mr b fv nb my l mz na">        "github.com/labstack/echo"<br/>    )</span></pre><p id="f150" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在让我们开始定义在<code class="eh mo mp mq mr b">main.go</code>文件中使用的路由处理器。</p><p id="9d0f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，我们将添加<code class="eh mo mp mq mr b">GetPrices</code>功能。在同一文件的底部粘贴以下代码:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="666f" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// GetPrices returns the coin prices</em><br/>    func GetPrices() echo.HandlerFunc {<br/>        return func(c echo.Context) error {<br/>            prices, err := model.GetCoinPrices(true)<br/>            if err != nil {<br/>                return c.JSON(http.StatusBadGateway, err)<br/>            }</span><span id="9738" class="ma kk hu mr b fv nb my l mz na">            return c.JSON(http.StatusOK, prices)<br/>        }<br/>    }</span></pre><p id="9bf5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上面的函数很简单。我们只是从<code class="eh mo mp mq mr b">model.GetCoinPrices</code>函数中获取价格，并将其作为JSON响应返回。</p><p id="ba39" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">注意，我们向<code class="eh mo mp mq mr b">GetCoinPrices</code>函数传递了一个布尔值。这个布尔值用来标记是模拟价格还是直接从API获取。因为我们正在测试，我们想模拟价格，所以它经常变化。</p><p id="1359" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">添加到<code class="eh mo mp mq mr b">routes.go</code>文件的下一个函数是<code class="eh mo mp mq mr b">SaveDeviceSettings</code>函数。在同一文件中，将以下代码粘贴到文件的底部:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="0710" class="ma kk hu mr b fv mx my l mz na">var postedSettings map[string]string</span><span id="9f91" class="ma kk hu mr b fv nb my l mz na">    func formValue(c echo.Context, key string) (string, error) {<br/>        if postedSettings == nil {<br/>            if err := c.Bind(&amp;postedSettings); err != nil {<br/>                return "", err<br/>            }<br/>        }</span><span id="4c0e" class="ma kk hu mr b fv nb my l mz na">        return postedSettings[key], nil<br/>    }</span><span id="83c7" class="ma kk hu mr b fv nb my l mz na">    func getCoinValueFromRequest(key string, c echo.Context) (int64, error) {<br/>        value, _ := formValue(c, key)<br/>        if value != "" {<br/>            setting, err := strconv.ParseInt(value, 10, 64)<br/>            if err == nil {<br/>                return setting, nil<br/>            }<br/>        }</span><span id="4452" class="ma kk hu mr b fv nb my l mz na">        return 0, errors.New("Invalid or empty key for: " + key)<br/>    }</span><span id="c046" class="ma kk hu mr b fv nb my l mz na">    <em class="iw">// SaveDeviceSettings saves the device settings</em><br/>    func SaveDeviceSettings(db *sql.DB) echo.HandlerFunc {<br/>        return func(c echo.Context) error {<br/>            uuid, _ := formValue(c, "uuid")        <br/>            field := make(map[string]int64)</span><span id="ebd9" class="ma kk hu mr b fv nb my l mz na">            if btcmin, err := getCoinValueFromRequest("minBTC", c); err == nil {<br/>                field["btc_min"] = btcmin<br/>            }</span><span id="680a" class="ma kk hu mr b fv nb my l mz na">            if btcmax, err := getCoinValueFromRequest("maxBTC", c); err == nil {<br/>                field["btc_max"] = btcmax<br/>            }</span><span id="b234" class="ma kk hu mr b fv nb my l mz na">            if ethmin, err := getCoinValueFromRequest("minETH", c); err == nil {<br/>                field["eth_min"] = ethmin<br/>            }</span><span id="bfa6" class="ma kk hu mr b fv nb my l mz na">            if ethmax, err := getCoinValueFromRequest("maxETH", c); err == nil {<br/>                field["eth_max"] = ethmax<br/>            }</span><span id="fabc" class="ma kk hu mr b fv nb my l mz na">            defer func() { postedSettings = nil }()</span><span id="bb2d" class="ma kk hu mr b fv nb my l mz na">            device, err := model.SaveSettings(db, uuid, field)<br/>            if err != nil {<br/>                return c.JSON(http.StatusBadRequest, err)<br/>            }</span><span id="45af" class="ma kk hu mr b fv nb my l mz na">            return c.JSON(http.StatusOK, device)<br/>        }<br/>    }</span></pre><p id="0ce3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们有三个函数。前两个是助手函数。我们需要它们从请求中获取已发布的表单值。</p><p id="6dfe" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mo mp mq mr b">SaveDeviceSettings</code>函数中，我们获取设备的<code class="eh mo mp mq mr b">uuid</code>，并有条件地获取硬币的最小值和最大值。我们使用<code class="eh mo mp mq mr b">model.SaveSettings</code>函数将值保存到数据库中，并返回一个JSON响应。</p><p id="5130" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">要添加的最后一个函数是<code class="eh mo mp mq mr b">Simulate</code>函数。将以下代码添加到文件的底部:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="c85e" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// SimulatePriceChanges simulates the prices changes</em><br/>    func SimulatePriceChanges(db *sql.DB) echo.HandlerFunc {<br/>        return func(c echo.Context) error {<br/>            prices, err := model.GetCoinPrices(true)<br/>            if err != nil {<br/>                panic(err)<br/>            }</span><span id="27b5" class="ma kk hu mr b fv nb my l mz na">            devices, err := model.NotifyDevicesOfPriceChange(db, prices)<br/>            if err != nil {<br/>                panic(err)<br/>            }</span><span id="9fe7" class="ma kk hu mr b fv nb my l mz na">            resp := map[string]interface{}{<br/>                "prices":  prices,<br/>                "devices": devices,<br/>                "status":  "success",<br/>            }</span><span id="c86f" class="ma kk hu mr b fv nb my l mz na">            return c.JSON(http.StatusOK, resp)<br/>        }<br/>    }</span></pre><p id="8a28" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的函数中，我们获取硬币的价格，然后将其发送给<code class="eh mo mp mq mr b">model.NotifyDevicesOfPriceChange</code>函数，该函数找到符合条件的设备，并向它们发送推送通知。然后我们返回一个<code class="eh mo mp mq mr b">prices</code>、<code class="eh mo mp mq mr b">devices</code>和<code class="eh mo mp mq mr b">status</code>的JSON响应。</p><p id="0527" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">路线就这些了。</p><p id="92e1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，让我们定义模型。在<code class="eh mo mp mq mr b">database/model</code>目录下创建一个新的<code class="eh mo mp mq mr b">models.go</code>文件，并粘贴以下代码:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="f387" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// File: ./database/model/models.go</em><br/>    package model</span><span id="f2ea" class="ma kk hu mr b fv nb my l mz na">    import (<br/>        "database/sql"<br/>        "encoding/json"<br/>        "fmt"<br/>        "io/ioutil"<br/>        "math/big"<br/>        "math/rand"<br/>        "net/http"<br/>        "time"</span><span id="11de" class="ma kk hu mr b fv nb my l mz na">        "errors"</span><span id="0ace" class="ma kk hu mr b fv nb my l mz na">        "../../notification"<br/>    )</span></pre><p id="18ee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，让我们定义对象资源的结构。在同一文件中，将以下内容粘贴到底部:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="fe42" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// CoinPrice represents a single coin resource</em><br/>    type CoinPrice map[string]interface{}</span><span id="a056" class="ma kk hu mr b fv nb my l mz na">    <em class="iw">// Device represents a single device resource</em><br/>    type Device struct {<br/>        ID     int64  `json:"id"`<br/>        UUID   string `json:"uuid"`<br/>        BTCMin int64  `json:"btc_min"`<br/>        BTCMax int64  `json:"btc_max"`<br/>        ETHMin int64  `json:"eth_min"`<br/>        ETHMax int64  `json:"eth_max"`<br/>    }</span><span id="6bc3" class="ma kk hu mr b fv nb my l mz na">    <em class="iw">// Devices represents a collection of Devices</em><br/>    type Devices struct {<br/>        Devices []Device `json:"items"`<br/>    }</span></pre><p id="d217" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">以上，我们有<code class="eh mo mp mq mr b">CoinPrice</code>图。这将用于处理来自我们的应用程序将使用的API的响应。当得到来自API的响应时，我们将其绑定到<code class="eh mo mp mq mr b">CoinPrice</code>映射。</p><p id="106c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">下一个是<code class="eh mo mp mq mr b">Device</code>结构。这代表设备资源。它与我们在本文前面创建的表的SQL模式相匹配。当我们想要创建一个新的设备资源来存储在数据库中或者检索一个时，我们将使用<code class="eh mo mp mq mr b">Device</code>结构。</p><p id="c9a0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">最后，我们有一个<code class="eh mo mp mq mr b">Devices</code>结构，它只是多个<code class="eh mo mp mq mr b">Device</code>结构的集合。如果我们想返回一个<code class="eh mo mp mq mr b">Device</code>的集合，我们就用这个。</p><blockquote class="ir is it"><p id="33aa" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> Go不允许在结构名中使用下划线，所以我们将使用</em><code class="eh mo mp mq mr b"><em class="hu">json:`</em></code><em class="hu"/><code class="eh mo mp mq mr b"><em class="hu">key_name</em></code><em class="hu">" `格式来自动与指定键的属性相互转换。</em></p></blockquote><p id="febf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们开始定义我们的模型函数。</p><p id="9bb2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在同一文件中，将以下代码粘贴到页面底部:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="26ce" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// CreateSettings creates a new device and saves it to the db</em><br/>    func CreateSettings(db *sql.DB, uuid string) (Device, error) {<br/>        device := Device{UUID: uuid, BTCMin: 0, BTCMax: 0, ETHMin: 0, ETHMax: 0}</span><span id="db01" class="ma kk hu mr b fv nb my l mz na">        stmt, err := db.Prepare("INSERT INTO devices (uuid, btc_min, btc_max, eth_min, eth_max) VALUES (?, ?, ?, ?, ?)")<br/>        if err != nil {<br/>            return device, err<br/>        }</span><span id="1d75" class="ma kk hu mr b fv nb my l mz na">        res, err := stmt.Exec(device.UUID, device.BTCMin, device.BTCMax, device.ETHMin, device.ETHMax)<br/>        if err != nil {<br/>            return device, err<br/>        }</span><span id="d7a4" class="ma kk hu mr b fv nb my l mz na">        lastID, err := res.LastInsertId()<br/>        if err != nil {<br/>            return device, err<br/>        }</span><span id="f159" class="ma kk hu mr b fv nb my l mz na">        device.ID = lastID</span><span id="5692" class="ma kk hu mr b fv nb my l mz na">        return device, nil<br/>    }</span></pre><p id="b816" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">上述功能用于为新设备创建设置。在该函数中，使用<code class="eh mo mp mq mr b">Device</code>结构创建了一个新设备。然后，我们编写想要用来创建新设备的SQL查询。</p><p id="1d78" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们对SQL查询运行<code class="eh mo mp mq mr b">Exec</code>来执行查询。如果没有错误，我们从查询中获取最后插入的ID，并将其分配给我们之前创建的<code class="eh mo mp mq mr b">Device</code>结构。然后我们返回被创造的<code class="eh mo mp mq mr b">Device</code>。</p><p id="27b3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们添加下一个函数。在同一文件中，将以下代码粘贴到底部:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="e6aa" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// GetSettings fetches the settings for a single user from the db</em><br/>    func GetSettings(db *sql.DB, uuid string) (Device, error) {<br/>        device := Device{}</span><span id="fa69" class="ma kk hu mr b fv nb my l mz na">        if len(uuid) &lt;= 0 {<br/>            return device, errors.New("Invalid device UUID")<br/>        }</span><span id="2c2f" class="ma kk hu mr b fv nb my l mz na">        err := db.QueryRow("SELECT * FROM devices WHERE uuid=?", uuid).Scan(<br/>            &amp;device.ID,<br/>            &amp;device.UUID,<br/>            &amp;device.BTCMin,<br/>            &amp;device.BTCMax,<br/>            &amp;device.ETHMin,<br/>            &amp;device.ETHMax)</span><span id="aa7a" class="ma kk hu mr b fv nb my l mz na">        if err != nil {<br/>            return CreateSettings(db, uuid)<br/>        }</span><span id="10de" class="ma kk hu mr b fv nb my l mz na">        return device, nil<br/>    }</span></pre><p id="2721" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的<code class="eh mo mp mq mr b">GetSettings</code>函数中，我们创建了一个空的<code class="eh mo mp mq mr b">Device</code>结构。我们运行查询，从<code class="eh mo mp mq mr b">devices</code>表中获取与<code class="eh mo mp mq mr b">uuid</code>匹配的设备。然后，我们使用数据库包的<code class="eh mo mp mq mr b">Scan</code>方法将行值保存到<code class="eh mo mp mq mr b">Device</code>实例中。</p><p id="7e10" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果没有找到设备，使用我们之前创建的<code class="eh mo mp mq mr b">CreateSettings</code>函数创建一个新设备，否则返回找到的设备。</p><p id="6f28" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们添加下一个函数。在同一文件中，将以下代码粘贴到底部:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="a059" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// SaveSettings saves the devices settings</em><br/>    func SaveSettings(db *sql.DB, uuid string, field map[string]int64) (Device, error) {<br/>        device, err := GetSettings(db, uuid)<br/>        if err != nil {<br/>            return Device{}, err<br/>        }</span><span id="1f33" class="ma kk hu mr b fv nb my l mz na">        if btcmin, isset := field["btc_min"]; isset {<br/>            device.BTCMin = btcmin<br/>        }</span><span id="e36a" class="ma kk hu mr b fv nb my l mz na">        if btcmax, isset := field["btc_max"]; isset {<br/>            device.BTCMax = btcmax<br/>        }</span><span id="9561" class="ma kk hu mr b fv nb my l mz na">        if ethmin, isset := field["eth_min"]; isset {<br/>            device.ETHMin = ethmin<br/>        }</span><span id="c633" class="ma kk hu mr b fv nb my l mz na">        if ethmax, isset := field["eth_max"]; isset {<br/>            device.ETHMax = ethmax<br/>        }</span><span id="1f71" class="ma kk hu mr b fv nb my l mz na">        stmt, err := db.Prepare("UPDATE devices SET btc_min = ?, btc_max = ?, eth_min = ?, eth_max = ? WHERE uuid = ?")<br/>        if err != nil {<br/>            return Device{}, err<br/>        }</span><span id="625e" class="ma kk hu mr b fv nb my l mz na">        _, err = stmt.Exec(device.BTCMin, device.BTCMax, device.ETHMin, device.ETHMax, device.UUID)<br/>        if err != nil {<br/>            return Device{}, err<br/>        }</span><span id="5f39" class="ma kk hu mr b fv nb my l mz na">        return device, nil<br/>    }</span></pre><p id="5d81" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的<code class="eh mo mp mq mr b">SaveSettings</code>函数中，我们使用<code class="eh mo mp mq mr b">GetSettings</code>函数获取现有设置，然后有条件地更新现有值。然后，我们编写一个SQL查询，用新值更新数据库。在这之后，我们返回<code class="eh mo mp mq mr b">Device</code>结构。</p><p id="b81c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们添加下一个函数。在同一文件中，将以下代码粘贴到底部:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="29a6" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// GetCoinPrices gets the current coin prices</em><br/>    func GetCoinPrices(simulate bool) (CoinPrice, error) {<br/>        coinPrice := make(CoinPrice)<br/>        currencies := [2]string{"ETH", "BTC"}</span><span id="e605" class="ma kk hu mr b fv nb my l mz na">        for _, curr := range currencies {<br/>            if simulate == true {<br/>                min := 1000.0<br/>                max := 15000.0<br/>                price, _ := big.NewFloat(min + rand.Float64()*(max-min)).SetPrec(8).Float64()<br/>                coinPrice[curr] = map[string]interface{}{"USD": price}<br/>                continue<br/>            }</span><span id="a90f" class="ma kk hu mr b fv nb my l mz na">            url := fmt.Sprintf("https://min-api.cryptocompare.com/data/pricehistorical?fsym=%s&amp;tsyms=USD&amp;ts=%d", curr, time.Now().Unix())<br/>            res, err := http.Get(url)<br/>            if err != nil {<br/>                return coinPrice, err<br/>            }</span><span id="c007" class="ma kk hu mr b fv nb my l mz na">            defer res.Body.Close()</span><span id="928c" class="ma kk hu mr b fv nb my l mz na">            body, err := ioutil.ReadAll(res.Body)<br/>            if err != nil {<br/>                return coinPrice, err<br/>            }</span><span id="9789" class="ma kk hu mr b fv nb my l mz na">            var f interface{}</span><span id="edc1" class="ma kk hu mr b fv nb my l mz na">            err = json.Unmarshal([]byte(body), &amp;f)<br/>            if err != nil {<br/>                return coinPrice, err<br/>            }</span><span id="e53e" class="ma kk hu mr b fv nb my l mz na">            priceMap := f.(map[string]interface{})[curr]<br/>            for _, price := range priceMap.(map[string]interface{}) {<br/>                coinPrice[curr] = map[string]interface{}{"USD": price.(float64)}<br/>            }<br/>        }</span><span id="3ee4" class="ma kk hu mr b fv nb my l mz na">        return coinPrice, nil<br/>    }</span></pre><p id="160a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的函数中，我们创建了一个新的<code class="eh mo mp mq mr b">coinPrice</code>实例，然后我们创建了一个数组，包含我们想要获取的两种货币，ETH和BTC。然后我们遍历货币，如果<code class="eh mo mp mq mr b">simulate</code>是<code class="eh mo mp mq mr b">true</code>，我们就返回硬币的模拟价格。如果是<code class="eh mo mp mq mr b">false</code>，那么对于每种货币，我们执行以下操作:</p><ul class=""><li id="dc85" class="lm ln hu ix b iy iz jc jd jt lo ju lp jv lq js lr ls lt lu dt translated">从API获取货币的价格。</li><li id="7da3" class="lm ln hu ix b iy lv jc lw jt lx ju ly jv lz js lr ls lt lu dt translated">将货币价格添加到<code class="eh mo mp mq mr b">coinPrice</code>地图中。</li></ul><p id="bd21" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">完成后，我们返回价格。</p><p id="8d95" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们要添加的下一个也是最后一个函数是<code class="eh mo mp mq mr b">NotifyDevicesOfPriceChange</code>函数。它负责获取与最小和最大阈值匹配的设备，并向它们发送推送通知。</p><p id="0eed" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在同一个文件中，粘贴以下代码:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="8b95" class="ma kk hu mr b fv mx my l mz na">func minMaxQuery(curr string) string {<br/>        return `(` + curr + `_min &gt; 0 AND ` + curr + `_min &gt; ?) OR (` + curr + `_max &gt; 0 AND ` + curr + `_max &lt; ?)`<br/>    }</span><span id="c1ad" class="ma kk hu mr b fv nb my l mz na">    <em class="iw">// NotifyDevicesOfPriceChange returns the devices that are within the range</em><br/>    func NotifyDevicesOfPriceChange(db *sql.DB, prices CoinPrice) (Devices, error) {<br/>        devices := Devices{}<br/>        for currency, price := range prices {<br/>            pricing := price.(map[string]interface{})<br/>            rows, err := db.Query("SELECT * FROM devices WHERE "+minMaxQuery(currency), pricing["USD"], pricing["USD"])<br/>            if err != nil {<br/>                return devices, err<br/>            }<br/>            defer rows.Close()<br/>            for rows.Next() {<br/>                device := Device{}<br/>                err = rows.Scan(&amp;device.ID, &amp;device.UUID, &amp;device.BTCMin, &amp;device.BTCMax, &amp;device.ETHMin, &amp;device.ETHMax)<br/>                if err != nil {<br/>                    return devices, err<br/>                }<br/>                devices.Devices = append(devices.Devices, device)<br/>                notification.SendNotification(currency, pricing["USD"].(float64), device.UUID)<br/>            }<br/>        }<br/>        return devices, nil<br/>    }</span></pre><p id="d407" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们有两个函数，第一个是<code class="eh mo mp mq mr b">minMaxQuery</code>，它是一个帮助函数，帮助我们为货币的最小值和最大值生成SQL查询。</p><p id="56df" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">第二个功能是<code class="eh mo mp mq mr b">NotifyDevicesOfPriceChange</code>功能。在这里，我们循环遍历货币价格，对于每个价格，我们检查数据库中匹配最低和最高价格的设备。</p><p id="516d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当我们有了设备后，我们循环访问它们，并使用<code class="eh mo mp mq mr b">notification.SendNotification</code>方法发送推送通知。然后，我们返回我们发送通知的设备。</p><p id="f30e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">模特套餐到此为止。我们还有最后一个要添加的包，那就是<code class="eh mo mp mq mr b">notification</code>包。我们在上面的代码中使用它来发送推送通知，所以让我们来定义它。</p><p id="b3f8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<code class="eh mo mp mq mr b">notifications</code>目录下，创建一个<code class="eh mo mp mq mr b">push.go</code>文件并粘贴以下代码:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="8b43" class="ma kk hu mr b fv mx my l mz na"><em class="iw">// File: ./notification/push.go</em><br/>    package notification</span><span id="4a4e" class="ma kk hu mr b fv nb my l mz na">    import (<br/>        "fmt"<br/>        "strconv"</span><span id="de78" class="ma kk hu mr b fv nb my l mz na">        "github.com/pusher/push-notifications-go"<br/>    )</span><span id="6f2f" class="ma kk hu mr b fv nb my l mz na">    const (<br/>        instanceID = "PUSHER_BEAMS_INSTANCE_ID"<br/>        secretKey  = "PUSHER_BEAMS_SECRET_KEY"<br/>    )</span><span id="3342" class="ma kk hu mr b fv nb my l mz na">    <em class="iw">// SendNotification sends push notification to devices</em><br/>    func SendNotification(currency string, price float64, uuid string) error {<br/>        notifications, err := pushnotifications.New(instanceID, secretKey)<br/>        if err != nil {<br/>            return err<br/>        }</span><span id="d57e" class="ma kk hu mr b fv nb my l mz na">        publishRequest := map[string]interface{}{<br/>            "fcm": map[string]interface{}{<br/>                "notification": map[string]interface{}{<br/>                    "title": currency + " Price Change",<br/>                    "body":  fmt.Sprintf("The price of %s has changed to $%s", currency, strconv.FormatFloat(price, 'f', 2, 64)),<br/>                },<br/>            },<br/>        }</span><span id="aaed" class="ma kk hu mr b fv nb my l mz na">        interest := fmt.Sprintf("%s_%s_changed", uuid, currency)</span><span id="4c9b" class="ma kk hu mr b fv nb my l mz na">        _, err = notifications.Publish([]string{interest}, publishRequest)<br/>        if err != nil {<br/>            return err<br/>        }</span><span id="eae3" class="ma kk hu mr b fv nb my l mz na">        return nil<br/>    }</span></pre><blockquote class="ir is it"><p id="73c4" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">将</em> <code class="eh mo mp mq mr b"><em class="hu">PUSHER_BEAMS_*</em></code> <em class="hu">键替换为Pusher仪表盘中的凭证。</em></p></blockquote><p id="57a5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在上面的代码中，我们有<code class="eh mo mp mq mr b">SendNotification</code>函数。在这里，我们使用函数上面定义的<code class="eh mo mp mq mr b">InstanceID</code>和<code class="eh mo mp mq mr b">secretKey</code>实例化一个新的推杆梁实例。</p><p id="d4c9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">然后我们创建一个包含Android通知负载的<code class="eh mo mp mq mr b">publishRequest</code>变量。这个有效载荷就是我们将发送到Pusher Beams后端的内容，它将包含向Android设备发送通知所需的所有内容。</p><p id="a6e7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，我们创建一个<code class="eh mo mp mq mr b">interest</code>变量，它将是我们想要向其推送通知的兴趣。兴趣的格式将与我们在本教程第一部分中订阅的格式相匹配。接下来，我们调用Pusher Beams包的<code class="eh mo mp mq mr b">Publish</code>函数向设备发送通知。</p><p id="0d1a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们需要做的最后一件事是将推杆组件拉入我们的<code class="eh mo mp mq mr b">$GOPATH</code>中。打开您的终端并运行以下命令:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="1252" class="ma kk hu mr b fv mx my l mz na">$ go get github.com/pusher/push-notifications-go</span></pre><p id="dd35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">当命令成功执行后，我们现在可以运行应用程序了。</p><h1 id="1d9f" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">运行应用程序</h1><p id="79d9" class="pw-post-body-paragraph iu iv hu ix b iy lh ja jb jc li je jf jt lj ji jj ju lk jm jn jv ll jq jr js hn dt translated">现在我们已经完成了应用程序的构建，我们需要运行后端和Android应用程序。</p><p id="c6a1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">打开您的终端，从项目的根目录执行以下命令来运行Go应用程序:</p><pre class="jy jz ka kb fq mt mr mu mv aw mw dt"><span id="b309" class="ma kk hu mr b fv mx my l mz na">$ go run main.go</span></pre><p id="51ab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这应该会在端口9000上启动服务器。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff nc"><img src="../Images/5102603b9f081651f120f6c57af2544e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ymLE_t0BqYLSI8Lk.png"/></div></div></figure><p id="ab9d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">接下来，进入Android Studio，启动你的Android项目。现在，您可以看到这个应用程序了。您可以继续设置BTC和瑞士法郎的最小和最大限额。</p><p id="6ac4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在最小化模拟器中的应用程序，打开通知中心。访问网址<a class="ae jw" href="http://localhost:9000/simulate" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/simulate</a>模拟货币变化。您应该会看到通知进入设备，如下所示:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/29794bed8c9076a5e625ea8a2f8702c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*auRNaAH28kGrYVXT.gif"/></div></div></figure><h1 id="b072" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">结论</h1><p id="d425" class="pw-post-body-paragraph iu iv hu ix b iy lh ja jb jc li je jf jt lj ji jj ju lk jm jn jv ll jq jr js hn dt translated">在本文中，我们已经能够看到如何使用Pusher Beams和Go为Android创建加密货币观察器应用程序。这个教程在iOS上也有<a class="ae jw" href="https://pusher.com/tutorials/cryptocurrency-tracking-swift-laravel-part-1" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="ba43" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">本文中构建的应用程序的源代码可以在<a class="ae jw" href="https://github.com/neoighodaro/kotlin-cryptocurrency-watcher-with-push-notification" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="07fb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这篇文章最初出现在<a class="ae jw" href="https://pushcomer./tutorials/cryptocurrency-kotlin-go-part-2" rel="noopener ugc nofollow" target="_blank">的博客</a>上。</p></div></div>    
</body>
</html>