<html>
<head>
<title>Get your GraphQL server ready using GoLang in 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GoLang在5分钟内准备好您的GraphQL服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphql-with-golang-6e8da2054c25?source=collection_archive---------1-----------------------#2018-08-28">https://medium.com/hackernoon/graphql-with-golang-6e8da2054c25?source=collection_archive---------1-----------------------#2018-08-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d18ce81b3158d29474cb8dcc33fd5e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BNR42geWYQPtDojgc8xEQ.png"/></div></div></figure><p id="32cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在脸书将其开源后，GraphQL在过去几年中一直是一个热门词汇，所以我用Node.js尝试了GraphQL，我完全同意关于GraphQL的所有讨论，它的优点和简单性。</p><p id="f2ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近，我在Node.js的新项目中使用了Go-lang，并决定使用Go-lang来尝试GraphQL。Go-lang没有太多的库选项，但我已经尝试了这4个库。<a class="ae ka" href="https://github.com/samsarahq/thunder" rel="noopener ugc nofollow" target="_blank">雷霆</a>、<a class="ae ka" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank"> graphql </a>、<a class="ae ka" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank"> graphql-go </a>、<a class="ae ka" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank"> gqlgen </a>。我不得不说，在我尝试过的所有库中，gqlgen 赢得了所有的地盘。</p><p id="b4b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank">在撰写本文时，gqlgen </a>仍处于测试阶段，其最新版本为<a class="ae ka" href="https://github.com/99designs/gqlgen/releases/tag/v0.4.4" rel="noopener ugc nofollow" target="_blank"> v0.4.4 </a>，并且正在快速发展。你可以在这里找到他们的路线图。现在99designs正式赞助他们，所以我们将会看到这个令人敬畏的开源项目更快的发展速度。vektah 和<a class="ae ka" href="https://github.com/neelance" rel="noopener ugc nofollow" target="_blank"> neelance </a>是这个的主要贡献者，neelance 之前也写过<a class="ae ka" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank"> graphql-go </a>。</p><p id="de80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以让我们深入研究一下库语义，假设你有基本的graphql知识。</p><h1 id="a33a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">亮点</strong></h1><p id="8ab7" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">正如他们的标题所说</p><blockquote class="le lf lg"><p id="0ed3" class="jc jd lh je b jf jg jh ji jj jk jl jm li jo jp jq lj js jt ju lk jw jx jy jz hn dt translated">这是一个用于在golang中快速创建严格类型的graphql服务器的库。</p></blockquote><p id="a12e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我认为这是一个库最有前途的地方，你永远不会在这里看到，因为它使用了严格类型化的方法。</p><p id="f645" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除此之外，它还使用了<strong class="je hv">模式优先的方法</strong>:所以你可以使用graphql <a class="ae ka" href="http://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">模式定义语言</a>来定义你的API，并且拥有自己强大的代码生成工具，可以自动生成你所有的graphql代码，你只需要实现接口方法的核心逻辑。</p><blockquote class="lp"><p id="06d3" class="lq lr hu bd ls lt lu lv lw lx ly jz ek translated">该版本现已被弃用。请关注这篇文章，了解最新的更新。</p></blockquote><p id="d23b" class="pw-post-body-paragraph jc jd hu je b jf lz jh ji jj ma jl jm jn mb jp jq jr mc jt ju jv md jx jy jz hn dt translated"><a class="ae ka" href="https://medium.freecodecamp.org/deep-dive-into-graphql-with-golang-d3e02a429ac3" rel="noopener ugc nofollow" target="_blank">https://medium . freecodecamp . org/deep-dive-into-graph QL-with-golang-d3e 02 a 429 AC 3</a></p><h1 id="4f24" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">密码</h1><p id="7b22" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">因为这是一种模式优先的方法，所以让我们快速定义一个模式。我们以一个求职论坛为例。</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="4d62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在库提供了codegen命令<code class="eh ll lm ln lo b">gqlgen init</code>,它将为项目文件生成所有需要的文件</p><ul class=""><li id="50f5" class="mk ml hu je b jf jg jj jk jn mm jr mn jv mo jz mp mq mr ms dt translated">gqlgen . yml—gqlgen配置文件，用于控制生成的代码。</li><li id="6fb4" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">generated . go——graph QL执行运行时，生成的大部分代码</li><li id="1317" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">models _ gen . go-构建图形所需的生成模型。通常你会用你自己写的模型覆盖这些。对输入类型还是很有用的。</li><li id="2116" class="mk ml hu je b jf mt jj mu jn mv jr mw jv mx jz mp mq mr ms dt translated">resolver.go —这是您的应用程序代码所在的位置。generated.go将调用这个来获取用户请求的数据。</li></ul><p id="a395" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据docs stats，如果您不提供模型定义，它将自动生成模型，但在大多数情况下，您将编写自己的模型，因为您将对数据类型进行更细粒度的控制，并且您可以在需要时使用第三方结构(如您可以使用AWS或任何其他库的结构进行凭据、配置等)。</p><p id="1f82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以让我们覆盖生成<code class="eh ll lm ln lo b">gqlgen.yml</code>文件:</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="1181" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们给出了所有模型的路径。在<code class="eh ll lm ln lo b">schema.graphql</code>文件中，我们已经定义了一个自定义标量<code class="eh ll lm ln lo b">Timestamp</code>，所以我们需要告诉graphql如何封送和解封它们。</p><p id="0826" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里是我们的<code class="eh ll lm ln lo b">models.go</code>文件，上面所有的结构都在这里定义:</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="0699" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果你已经注意到我们没有为<code class="eh ll lm ln lo b">Timestamp</code>定义任何结构，只是为时间戳定义了编组和解组方法。所以这个库会处理这个问题，你只需要写这两个方法。</p><p id="8665" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个需要注意的重要事情是，我们还没有为输入(<code class="eh ll lm ln lo b">NewJob</code>和<code class="eh ll lm ln lo b">NewApplication</code>)定义一个结构。因此，正如库所承诺的，它将根据<code class="eh ll lm ln lo b">gqlgen.yml</code>文件中给定的配置在<code class="eh ll lm ln lo b">models/inputs.go</code>中自动生成，并通知您不要编辑该文件。</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="e8d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们来看看最重要的文件，那就是<code class="eh ll lm ln lo b">generated.go</code>，它有所有神奇的代码，显然它有一个很长的文件，但是让我们来看看需要的代码。</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div><figcaption class="my mz fg fe ff na nb bd b be z ek">snippet from generated.go</figcaption></figure><p id="68eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">gqlgen生成的另一个文件是<code class="eh ll lm ln lo b">resolver.go</code>,您可以在这个文件中放置所有的逻辑。以下是自动生成的存根文件(对注释、格式和软件包更改进行了少许编辑)</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="0803" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你需要做的就是用这些方法写出你的逻辑。</p><p id="df8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我正在编写一个示例方法，在Firebase实时数据库的帮助下创建和获取所有作业。为了这篇文章的长度，你可以在这里找到<a class="ae ka" href="https://github.com/ridhamtarpara/go-graphql-example/tree/feat/blog-1" rel="noopener ugc nofollow" target="_blank"/>来减少数据库代码。</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="24e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们尝试一下，点击服务器，运行第一次变异</p><pre class="me mf mg mh fq nc lo nd ne aw nf dt"><span id="e7c2" class="ng kc hu lo b fv nh ni l nj nk">$ go run server/server.go</span></pre><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/3a349555d8269c4919bf3cb060968674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDQ3kseiQmgRBruRDcONAA.png"/></div></div></figure><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nm"><img src="../Images/3b003719cefe327410ae98a487fe2840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6sGeRLDwyIUAHxA35VF6w.png"/></div></div></figure><p id="8024" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们所看到的，在Position的节点下创建了一个作业(如数据库层中所配置的)，我们在graphql中也获得了相同的响应，并且具有新创建的id。</p><p id="b374" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们测试查询:</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/47a9459a04e5f356c609de5c25d752c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfGVoAmuO9Ax0in7SuGcSw.png"/></div></div></figure><p id="f7b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是等等，哇！我们出错了。不要惊慌，因为graphql不知道如何从一个<code class="eh ll lm ln lo b">CreatedBy</code> userId中获取<code class="eh ll lm ln lo b">CreatedBy</code>用户对象，所以我们需要为当前声明<code class="eh ll lm ln lo b">panic(<strong class="je hv">“not implemented”</strong>)</code>的对象实现解析器方法。</p><figure class="me mf mg mh fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="c2e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以现在再次点击查询:</p><figure class="me mf mg mh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/b38aaf888a0de918f481de15bd9ab01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsbiYSbVjs09QqBXFotflQ.png"/></div></div></figure><p id="8122" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一切正常。</p><h1 id="3a12" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">现在怎么办？</h1><p id="4dfa" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">本文只是给出了一个如何在golang中实现graphql server的基本演示(我知道代码和结构可能会有很多变化)。这个代码在<a class="ae ka" href="https://github.com/ridhamtarpara/go-graphql-example/tree/feat/blog-1" rel="noopener ugc nofollow" target="_blank"> Github </a>上。我将很快撰写文章来添加Golang gqlgen服务器CORS、验证、认证和配置。直到那时快乐编码。</p><p id="4abc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第2部分即将推出！</p></div></div>    
</body>
</html>