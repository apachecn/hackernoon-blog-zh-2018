<html>
<head>
<title>Programming: How to improve application performance by understanding the CPU Cache levels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程:如何通过了解CPU缓存级别来提高应用程序性能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/programming-how-to-improve-application-performance-by-understanding-the-cpu-cache-levels-df0e87b70c90?source=collection_archive---------8-----------------------#2018-08-28">https://medium.com/hackernoon/programming-how-to-improve-application-performance-by-understanding-the-cpu-cache-levels-df0e87b70c90?source=collection_archive---------8-----------------------#2018-08-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/b6fa317f0c5c33389d1f85483b3e8468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nT3RAGnOAWmKmvOBnizNtw.png"/></div></figure><blockquote class="iy iz ja"><p id="0d59" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">CPU缓存是计算机中央处理器(CPU)使用的硬件缓存，用于降低从主内存访问数据的平均成本。高速缓存是一种更小、更快的内存，更靠近处理器内核，它存储来自经常使用的主内存位置的数据副本。大多数CPU都有不同的独立缓存，包括指令和数据缓存，其中数据缓存通常由多个缓存级别组成。</p></blockquote><h1 id="1991" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">CPU缓存级别:</h1><h2 id="8c81" class="ky kb hu bd kc kz la lb kg lc ld le kk lf lg lh ko li lj lk ks ll lm ln kw lo dt translated">一级缓存</h2><p id="b27e" class="pw-post-body-paragraph jb jc hu je b jf lp jh ji jj lq jl jm lf lr jp jq li ls jt ju ll lt jx jy jz hn dt translated">L1缓存驻留在每个内核中。这是最快的可访问内存。L1高速缓存分为以下两种类型:</p><p id="f68a" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated"><strong class="je hv">指令缓存</strong> —存储可执行指令，使取指令操作更快。</p><p id="9aa9" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated"><strong class="je hv">数据缓存</strong> —存储要处理的数据，加速数据提取操作。</p><h2 id="eb79" class="ky kb hu bd kc kz la lb kg lc ld le kk lf lg lh ko li lj lk ks ll lm ln kw lo dt translated">L2高速缓存</h2><p id="4ff4" class="pw-post-body-paragraph jb jc hu je b jf lp jh ji jj lq jl jm lf lr jp jq li ls jt ju ll lt jx jy jz hn dt translated">L2缓存比L1缓存大且慢。它位于内核或主板中。最新的英特尔酷睿处理器将L2高速缓存与L1高速缓存集成到了内核中。</p><h2 id="1cf8" class="ky kb hu bd kc kz la lb kg lc ld le kk lf lg lh ko li lj lk ks ll lm ln kw lo dt translated">L3缓存</h2><p id="4325" class="pw-post-body-paragraph jb jc hu je b jf lp jh ji jj lq jl jm lf lr jp jq li ls jt ju ll lt jx jy jz hn dt translated">它是最大的缓存，位于核心之外。访问三级高速缓存比L2高速缓存慢，因为它更大，处理器必须搜索三级高速缓存中的所有可用数据。</p><h2 id="af77" class="ky kb hu bd kc kz la lb kg lc ld le kk lf lg lh ko li lj lk ks ll lm ln kw lo dt translated">英特尔酷睿i7–4770s处理器</h2><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff lu"><img src="../Images/2351889b5c8109e92500ee2f56531c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4DuEIzXUkbAGb2-f9B6BA.png"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Intel® Core™ i7–4770S processor internal die photograph</figcaption></figure><p id="82ca" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">在英特尔酷睿i7–4770s处理器中，L1高速缓存和L2高速缓存集成到内核中，三级高速缓存驻留在处理器中。</p><h2 id="7d19" class="ky kb hu bd kc kz la lb kg lc ld le kk lf lg lh ko li lj lk ks ll lm ln kw lo dt translated">命中率和失误率</h2><blockquote class="iy iz ja"><p id="4aa7" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从缓存中成功获取数据称为命中率。</p><p id="11d7" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从缓存中不成功的提取被称为未命中率。</p></blockquote><p id="bc80" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">如果处理器在L1缓存中找不到它要找的东西，那么这就是L1缓存的未命中率。然后处理器前进到L2高速缓存并寻找数据。如果数据可用，则处理器将使用它，或者处理器将前进到L3进行数据查找。</p><p id="ef82" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">同样，如果数据在</p><h1 id="5f64" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">CPU缓存对编程的影响</h1><p id="8551" class="pw-post-body-paragraph jb jc hu je b jf lp jh ji jj lq jl jm lf lr jp jq li ls jt ju ll lt jx jy jz hn dt translated">考虑下面的C#代码</p><figure class="lv lw lx ly fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="19f7" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">上述代码以两种方式处理某个字符串。它必须完成以下操作:</p><ol class=""><li id="5a59" class="mj mk hu je b jf jg jj jk lf ml li mm ll mn jz mo mp mq mr dt translated">对于给定的循环次数，将给定的字符串追加到字符串生成器中。</li><li id="8fa3" class="mj mk hu je b jf ms jj mt lf mu li mv ll mw jz mo mp mq mr dt translated">方法“<em class="jd">GetStringByCombinedExecution</em>”在同一个循环中将字符串追加到两个字符串生成器中，并打印以毫秒为单位的时间。</li><li id="86c3" class="mj mk hu je b jf ms jj mt lf mu li mv ll mw jz mo mp mq mr dt translated">方法"<em class="jd">getstringbyperateexecution</em>"在不同的循环中将字符串追加到两个字符串生成器中，并打印以毫秒为单位的时间。</li></ol><p id="69fb" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">让我们将<em class="jd">循环计数</em>的值设置为10，下面是结果。它显示了组合执行比单独执行更快。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/cadf9b1511b845cecd881d140f85dfbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*o9EZifYzwtYkbbq-fgveUQ.png"/></div></figure><p id="06e9" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">让我们将<em class="jd">循环计数</em>的值设置为100，结果如下。这些数字给出了不同的结果，现在分开执行更快了。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/0900d1e8db3bae1e2f2d6f44ecf26563.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*O2K1WpdBYZePwZ3f0ulR7A.png"/></div></figure><p id="3f2d" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">让我们将<em class="jd">循环计数</em>的值设置为1000，结果如下。单独执行更快。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/47133e197068c4fb2b1abbe33bc4b1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*bkqka742ZjrECi5b2hsYTg.png"/></div></figure><p id="90a7" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">让我们将<em class="jd">循环计数</em>的值设置为10000，下面是结果。单独执行快了10毫秒。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/66ea721f1a35a52a059dfc32b2de094c.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*OcrMXrNbZzxkING1AsG0Vw.png"/></div></figure><blockquote class="iy iz ja"><p id="e80f" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">发生什么事了？为什么只是通过拆分执行，数字就不一样了？</p><p id="f8be" class="jb jc jd je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">因为CPU缓存。</strong></p></blockquote><p id="3529" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">在组合执行的情况下，两个字符串生成器对象在L1缓存中可能并不总是可用。因此，它增加了未命中率，命中率将下降，这导致处理器需要更多的CPU周期来完成操作。</p><p id="c7dd" class="pw-post-body-paragraph jb jc hu je b jf jg jh ji jj jk jl jm lf jo jp jq li js jt ju ll jw jx jy jz hn dt translated">虽然执行是单独发生的，但命中率会很高，因为该过程只发生在字符串生成器的单个实例上，它将在L1缓存中可用。因此处理器能够在更少的CPU周期内完成操作。</p><h1 id="3f33" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论:</h1><p id="70df" class="pw-post-body-paragraph jb jc hu je b jf lp jh ji jj lq jl jm lf lr jp jq li ls jt ju ll lt jx jy jz hn dt translated">这些循环是不可避免的，必须在日常的<a class="ae na" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程中实现。最近我在工作中做了一个性能优化。由此我了解到我的</a><a class="ae na" href="https://hackernoon.com/tagged/application" rel="noopener ugc nofollow" target="_blank">应用程序</a>的效率与我做的PoC相比非常慢。我的应用程序中唯一的变化是，我在同一个循环中用不同的对象做了更多的操作。因此，经过长时间的研究和分析，我开始将操作分割成单独的循环，这实际上极大地提高了我们应用程序的性能。在我们将所有操作分解成单独的循环后，我们从10秒下降到200毫秒，这促使我写了这篇文章。</p><figure class="lv lw lx ly fq iv"><div class="bz el l di"><div class="nb mi l"/></div></figure></div></div>    
</body>
</html>