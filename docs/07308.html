<html>
<head>
<title>How I ported 10K lines of Scala to Kotlin in one week?!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在一周内将Scala的10K代码移植到Kotlin？！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-ported-10k-lines-of-scala-to-kotlin-in-one-week-c645732d3c1?source=collection_archive---------6-----------------------#2018-08-29">https://medium.com/hackernoon/how-i-ported-10k-lines-of-scala-to-kotlin-in-one-week-c645732d3c1?source=collection_archive---------6-----------------------#2018-08-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/a78aff7b8108e2f06f4bf1d28e487ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pfJricpvP3sey52X8hF1aA.jpeg"/></div></div></figure><div class=""/><blockquote class="jc jd je"><p id="5f32" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上周在科特林，有几个事件——将在下面描述——引导我将Scala的postgresql-async  移植到<a class="ae ke" href="https://github.com/jasync-sql/jasync-sql" rel="noopener ugc nofollow" target="_blank"> <strong class="ji ig"> jasync-sql </strong> </a>。仍然有许多缺失的部分，但是alpha版本是可用的，工作仍在进行中。</p></blockquote><p id="3188" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在这篇文章中，我想分享我是如何将代码从Scala转换到Kotlin的，以及我从中学到了什么，这样它可以帮助其他开发人员处理同样的任务。</p><p id="2cea" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">但首先，为什么？(而之后，如何？)</p><h1 id="da6d" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">为什么？</h1><p id="b3fe" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">我转到了Outbrain的一个新团队，我的任务之一是协调我们的模块从Scala 2.10升级到2.11。事实证明这是可能的，但是这是一个棘手的问题，因为这需要我们为多个工件“修补”我们所有的JVM模块，如这里所描述的<a class="ae ke" href="https://www.youtube.com/watch?v=oq3s-Du-4Qk" rel="noopener ugc nofollow" target="_blank"/>。甚至我们的Java模块！因为它们都依赖于<a class="ae ke" href="https://github.com/outbrain/ob1k/" rel="noopener ugc nofollow" target="_blank"> ob1k-db </a>，而ob1k-db又依赖于pstgresql-async，而pstgresql-async又依赖于具有不同工件的Scala 2.10/2.11。</p><p id="92d6" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">因此，去除所有外部模块中Scala依赖性可能是个好主意...你知道我有多喜欢Scala和Kotlin，在我之前的文章中:</p><div class="ht hu fm fo hv ll"><a rel="noopener follow" target="_blank" href="/@OhadShai/scala-pack-your-bags-kotlin-is-coming-5169f737cfe8"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd ig fv z el lq eo ep lr er et ie dt translated">Scala -打包你的行李；科特林来了！</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">TL；DR——很多人问我为什么我认为Kotlin比Scala更好，或者相反，所以在这篇文章中我将…</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">medium.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz ib ll"/></div></div></a></div><p id="b3f4" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">此外，上周，在一年多的不活动之后，终于有一个commit批准不再维护<a class="ae ke" href="https://github.com/mauricio/postgresql-async/commit/5716ac43818b6be0dc4fcc2b2655dde3411cdbe0" rel="noopener ugc nofollow" target="_blank">postgres-SQL</a>。这是最后一根稻草。</p><p id="9eaa" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">此外，我们正在使用MySQL异步风格的库，并且没有找到替代它的插件。</p><p id="bc91" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">一个很大的优势是Scala和Kotlin非常相似——在特性和语法方面——所以尝试移植<a class="ae ke" href="https://hackernoon.com/tagged/code" rel="noopener ugc nofollow" target="_blank">代码</a>相对来说很有诱惑力。</p><h1 id="4ec8" class="ki kj if bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">怎么会？</h1><p id="a27d" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">在我们深入所有那些油腻的语法细节之前，休息一下，通过一次访问和一个明星为新的开源库做贡献😉：</p><div class="ht hu fm fo hv ll"><a href="https://github.com/jasync-sql/jasync-sql" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd ig fv z el lq eo ep lr er et ie dt translated">jasync-sql/jasync-sql</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">用于PostgreSQL和MySQL的异步、基于Netty的JVM数据库驱动程序，用Kotlin - jasync-sql/jasync-sql编写</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">github.com</p></div></div><div class="lu l"><div class="ma l lw lx ly lu lz ib ll"/></div></div></a></div><p id="7d38" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">转换本身分为两个主要步骤:</p><ul class=""><li id="6fd9" class="mb mc if ji b jj jk jn jo kf md kg me kh mf kd mg mh mi mj dt translated">自动逐行查找和替换脚本，以节省一些耗时的猴子打字。</li><li id="59e1" class="mb mc if ji b jj mk jn ml kf mm kg mn kh mo kd mg mh mi mj dt translated">手动检查文件并修复所有编译错误，决定如何转换并改进脚本。</li></ul><h2 id="aed0" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">剧本</h2><p id="dbc2" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">这真的是一个简单而愚蠢的<a class="ae ke" href="https://github.com/holgerbrandl/kscript" rel="noopener ugc nofollow" target="_blank"> kscript </a>，甚至可能是令人尴尬的愚蠢。有些行甚至没有被替换成有效的完整语句:例如，请参见模式匹配和转换。</p><p id="13e5" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我既没有时间也没有专业知识来使用像<a class="ae ke" href="http://www.antlr.org/" rel="noopener ugc nofollow" target="_blank"> antlr </a>这样的东西，并编写一个解析器或一个成熟的转换器，此外，我还有一些非常定制的和特定的需求。但是我们非常欢迎你这么做。</p><p id="fc4f" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">因此，事不宜迟，下面是该脚本的简化/清理版本:</p><figure class="nd ne nf ng fq hw"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="c9c1" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这个脚本是一个<a class="ae ke" href="https://github.com/holgerbrandl/kscript" rel="noopener ugc nofollow" target="_blank"> kscript </a>，它有一个参数:或者是一个已经重命名的Scala文件<code class="eh nj nk nl nm b">.kt</code>，或者是一个递归转换文件的目录。</p><p id="eca8" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">该脚本做了一个简单的逐行查找和替换:<code class="eh nj nk nl nm b">def</code>到<code class="eh nj nk nl nm b">fun</code>，<code class="eh nj nk nl nm b">trait</code>到<code class="eh nj nk nl nm b">interface</code>等。没什么特别的。但是正如我之前提到的，语言有相似的语法是有帮助的。例如，转换为Java可能更复杂。</p><h2 id="794a" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">吸取的教训/我做出的决定</h2><p id="3d3b" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">我写这篇博客的原因是提醒我自己我做了什么。一些文件仍然需要转换，其他人也有所贡献，所以这也有所帮助。</p><p id="4847" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">其余的只是一个没有特定顺序的条目列表，将来也可能会更新。</p><h2 id="bc17" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">未来-&gt; CompletableFuture</h2><p id="9676" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">原始代码广泛使用Scala Future，我必须找到一个替代方案。而且有很多:</p><ul class=""><li id="65d3" class="mb mc if ji b jj jk jn jo kf md kg me kh mf kd mg mh mi mj dt translated">Netty future —语法似乎冗长而过时。</li><li id="18b6" class="mb mc if ji b jj mk jn ml kf mm kg mn kh mo kd mg mh mi mj dt translated">JavaRX/Guava/ Other lib future —需要另一个外部依赖项。</li><li id="9e18" class="mb mc if ji b jj mk jn ml kf mm kg mn kh mo kd mg mh mi mj dt translated">Java 8可完成的未来——至少必须依赖Java 8。</li><li id="733f" class="mb mc if ji b jj mk jn ml kf mm kg mn kh mo kd mg mh mi mj dt translated">kot Lin deferred——主要用于couroutines，所以不太丰富，不确定java用户是否感到舒适。对我来说，找到如何作曲有点困难。</li></ul><p id="0938" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">决定使用CompletableFuture，因为这主要是一个后端库，这意味着我看不到在Android中使用反应式关系型sql库的理由，而且Java 8在Android之外被广泛使用。</p><p id="5284" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">注意CompletableFuture替换Scala Future和Promise。</p><h2 id="b142" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">属国</h2><p id="7de0" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">由于这是一种驱动程序库，我试图最小化外部依赖的数量，这影响了关于使用的其他决定。</p><h2 id="db8a" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">完成</h2><p id="4383" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">事实证明，在Kotlin中，您不必重写finalize方法。</p><h2 id="fa34" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">数据结构</h2><p id="1d72" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">我不记得所有，但这里是我做的转换，并记得:</p><ul class=""><li id="b8a7" class="mb mc if ji b jj jk jn jo kf md kg me kh mf kd mg mh mi mj dt translated">序列-&gt;列表</li><li id="cc85" class="mb mc if ji b jj mk jn ml kf mm kg mn kh mo kd mg mh mi mj dt translated">IndexedSeq -&gt;列表</li><li id="e8c3" class="mb mc if ji b jj mk jn ml kf mm kg mn kh mo kd mg mh mi mj dt translated">ArrayBuffer -&gt;可变列表</li></ul><h2 id="05f7" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">比特拨弄</h2><p id="ddf5" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">Kotlin对<code class="eh nj nk nl nm b">byte</code>有点奇怪，因为它还没有包含所有的操作符。我把一些类转换成了Java，其他的我留在了Kotlin中，希望我没弄错，因为我不是100%确定Scala是如何处理的。欢迎就此发表意见。</p><h2 id="679a" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">扩展方法和属性</h2><p id="6bca" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">一开始我并不明白，但在某个时候我意识到我可以通过扩展让Kotlin变得非常类似于Scala，这非常酷。</p><p id="06cc" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">例如，科特林在列表中有<code class="eh nj nk nl nm b">size</code>，而在Scala中是<code class="eh nj nk nl nm b">length</code>。</p><p id="7911" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">问题？扩展。</p><h2 id="d1ec" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">尝试</h2><p id="eaff" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">我决定从Scala+Arrow移植/使用一个类似的类。</p><h2 id="34ec" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">方法声明和调用中的大括号</h2><p id="7ff1" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">Scala并不强制执行，有时转换起来非常混乱和痛苦。</p><h2 id="659b" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">期限-&gt;期限</h2><p id="38e4" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">决定使用java.util.Duration</p><h2 id="88c0" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">执行上下文和隐式参数</h2><p id="ba1a" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">我发现这个特性非常令人困惑，所以我将所有隐式参数都改为强制参数。它使代码更加冗长，但是更加清晰。</p><p id="9b0b" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">我使用公共池作为默认的执行上下文，尽管在ob1k中我们使用另一个，我们只是显式地传递它。</p><h2 id="42c3" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">试验</h2><p id="ba07" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">最初的库使用specs2。最初我想把它们留在Scala中一段时间，但是由于大量的内部代码被修改，这看起来似乎需要做很多工作。多亏了其他贡献者，转换仍然是WIP。</p><h2 id="d05d" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">[计]选项</h2><p id="3790" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">我主要用可空类型替换了它，用一些扩展帮助器:<a class="ae ke" href="https://github.com/jasync-sql/jasync-sql/blob/master/db-async-common/src/main/java/com/github/jasync/sql/db/util/NullableUtils.kt" rel="noopener ugc nofollow" target="_blank">https://github . com/ja sync-SQL/ja sync-SQL/blob/master/d b-async-common/src/main/Java/com/github/ja sync/SQL/db/util/nullable utils . kt</a></p><p id="9249" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在这里，我认为Kotlin方式是更好的方法，因为在Scala中有时会使用<code class="eh nj nk nl nm b">Option</code>，但有时也会直接使用null。</p><p id="b4b4" class="pw-post-body-paragraph jf jg if ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">也有可能用java <code class="eh nj nk nl nm b">Optional</code>代替。</p><h2 id="63fb" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">版本-&gt; kotlinsversion</h2><p id="c98c" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">它有一个特定的逻辑，但是看起来很标准，所以我找到了<code class="eh nj nk nl nm b">KotlinVersion</code>类来匹配它。</p><h2 id="7fec" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">隐式转换</h2><p id="c3d1" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">万恶之源(加上过早优化)。在我们的例子中，用扩展方法和Java静态方法替换用法非常容易。这个例子可以在第25行中看到<a class="ae ke" href="https://github.com/mauricio/postgresql-async/blob/master/mysql-async/src/main/scala/com/github/mauricio/async/db/mysql/binary/decoder/BigDecimalDecoder.scala" rel="noopener ugc nofollow" target="_blank">，我们通过第25行</a>中定义的<a class="ae ke" href="https://github.com/mauricio/postgresql-async/blob/master/db-async-common/src/main/scala/com/github/mauricio/async/db/util/ChannelWrapper.scala" rel="noopener ugc nofollow" target="_blank">方法隐式地将ByteBuf转换为ChannelWrapper。在Kotlin中，我在ByteBuf上使用了扩展方法，比如这里的</a><a class="ae ke" href="https://github.com/jasync-sql/jasync-sql/blob/master/db-async-common/src/main/java/com/github/jasync/sql/db/util/ByteBufExtensions.kt" rel="noopener ugc nofollow" target="_blank"/>，并用静态方法制作了ChannelWrapper。</p><h2 id="65bb" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">特征-&gt;接口+通过类委托</h2><p id="aa33" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">原来特征只是多重遗传的替代物，因为它们可以有状态。我设法用<a class="ae ke" href="https://github.com/jasync-sql/jasync-sql/blob/master/mysql-async/src/main/java/com/github/jasync/sql/db/mysql/MySQLConnection.kt" rel="noopener ugc nofollow" target="_blank">类委托(第55行)</a>替换了它。缺点是实现需要抛出异常的方法，如果没有被重写，这些方法在运行时会失败。<a class="ae ke" href="https://github.com/jasync-sql/jasync-sql/blob/master/db-async-common/src/main/java/com/github/jasync/sql/db/pool/TimeoutScheduler.kt" rel="noopener ugc nofollow" target="_blank">见此处第51行</a>。</p></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><h2 id="d802" class="mp kj if bd kk mq mr ms ko mt mu mv ks kf mw mx kw kg my mz la kh na nb le nc dt translated">就是这样。感谢阅读。</h2><p id="a6ca" class="pw-post-body-paragraph jf jg if ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">一如既往，欢迎评论！</p><blockquote class="jc jd je"><p id="6a4f" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">标题图片由<a class="ae ke" href="https://unsplash.com/photos/EeCfOPSeRik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安朵斯瓦斯</a>从<a class="ae ke" href="https://unsplash.com/search/photos/driver?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></blockquote><figure class="nd ne nf ng fq hw"><div class="bz el l di"><div class="nu ni l"/></div></figure></div></div>    
</body>
</html>