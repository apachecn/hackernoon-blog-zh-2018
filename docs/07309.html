<html>
<head>
<title>Why Do We Need JPEG Compression and How It’s Technically Working?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们需要JPEG压缩，它在技术上是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-do-we-need-jpeg-compression-and-how-its-technically-working-52a3a9ced55d?source=collection_archive---------7-----------------------#2018-08-29">https://medium.com/hackernoon/why-do-we-need-jpeg-compression-and-how-its-technically-working-52a3a9ced55d?source=collection_archive---------7-----------------------#2018-08-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b713" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很难说人们每年生产多少张数码照片，但总数估计每年超过1万亿张。大量的照片大多来自手机，而且这些图像通常以JPEG格式存储。除此之外，许多工业相机还会生成大量的jpegs文件。图像扩展。jpg是最常见的选择，这实际上是许多智能手机和相机中的默认设置。缩写JPEG表示图像格式和用于图像编码和解码的有损压缩算法。</p><p id="9639" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JPEG的意思是<a class="ae jp" href="https://jpeg.org/jpeg/index.html" rel="noopener ugc nofollow" target="_blank">联合摄影专家组</a>，它创建了标准。JPEG标准的第一个草案发布于1992年。JPEG标准规定了编解码器，它定义了如何将图像压缩成字节流，然后再解压缩成图像。这不是一个全新的算法，但这是一个坚实的基础和非常受欢迎的方法来存储压缩图像。让我们来看看为什么这是一个好的解决方案，以及它实际上是如何工作的。</p><p id="738c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> JPEG图像压缩</strong>算法总是有损的，这意味着我们不会存储原始图像的全部数据。这实际上不是一个问题——算法去除了大多数人看不到的图像细节。这种方法被称为“<strong class="it hv">视觉无损压缩</strong>”，以强调图像质量损失水平可能非常低。在大多数情况下，我们可以获得10-12倍的压缩比，这为我们节省了大量的硬盘/固态硬盘空间。</p><p id="0e89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是JPEG压缩导致图像质量极度下降的一个例子。您可以看到TIFF格式的原始Lena图像(512x512，24位，769 kB，无压缩)和JPEG格式的相同图像，质量压缩系数为50%，子采样为4:2:0，24位，图像大小为23 kB。在100%缩放比例下，您能看到任何明显的差异吗？请注意，这是压缩比约为33的极端情况，不过，对于视觉无损的JPEG压缩，推荐值约为10–12。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/1bbaadfaaa4ac091b79501a8bac57bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*QmU6B8aA_gdgqCbX"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Original Lena image, 769 kB</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/4a300cf87c2db9c5354d9ae66508f479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*9lU9tMxBMKKnDXMh"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Compressed Lena image, 23 kB</figcaption></figure><p id="b699" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JPEG压缩和解压缩过去被认为计算量大且速度慢。一个关于<a class="ae jp" href="https://www.fastcompression.com/" rel="noopener ugc nofollow" target="_blank">快速图像压缩</a>的想法远非真实。从那时起，新的硬件和并行编程的新方法使得JPEG快速、可靠和普及。</p><h1 id="0b95" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">图像压缩的一般方法包含以下阶段</h1><ol class=""><li id="bc3f" class="la lb hu it b iu lc iy ld jc le jg lf jk lg jo lh li lj lk dt translated">从RGB到YCbCr的颜色变换以及偏移</li><li id="3665" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">子采样和分割</li><li id="4b4a" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">变换到频域</li><li id="bf3a" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">从图像中去除高频细节</li><li id="7155" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">重新排序以获得更好的压缩</li><li id="360e" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">零级数的去除</li><li id="ff17" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">无损熵编码去除一些额外的数据</li><li id="82cb" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">最终包装</li></ol><h1 id="22d5" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">从RGB到YCbCr的颜色转换</h1><p id="ed5d" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">这种转变是基于我们的生理经验。人类视觉系统可以感知亮度的微小变化，尽管对于具有相同亮度的区域，它对颜色(图像的色度分量)的变化的响应要小得多。这就是为什么我们可以对色度应用更强的压缩，以获得压缩图像的更小图像大小。我们获取RGB图像，并将其转换为亮度/色度表示，以便将亮度和色度分开，并分别进行处理。</p><p id="c1ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">亮度通常被称为Y(强度、亮度)，色度分量被称为Cb和Cr(这些实际上是差值Cb = B — Y和Cr = R — Y)。该转换与数据移位同时进行，以便为处理阶段准备数据，这称为DCT(离散余弦变换)。</p><h1 id="9836" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">子采样和分割</h1><p id="5df9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">一旦我们认为色度分量没有亮度重要，我们就可以减少色度像素的总数。例如，我们可以在水平或垂直方向上平均色度。在最极端的情况下，我们可以对矩形2x2中的4个相邻色度值进行平均，以获得一个新值。这种模式被称为4:2:0，是二次采样最流行的选择。</p><p id="abfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了进一步处理，我们将整个图像分成8×8的亮度和色度块。这种分割方案允许我们独立处理每个块，尽管我们必须记住每个块的坐标，这在图像解码中是必不可少的。</p><h1 id="1570" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">DCT:离散余弦变换</h1><p id="6ddb" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">DCT是一种傅立叶相关变换，类似于离散傅立叶变换(DFT ),但仅使用实数。你可以在<a class="ae jp" href="https://en.wikipedia.org/wiki/Discrete_cosine_transform" rel="noopener ugc nofollow" target="_blank"> Wiki </a>获得更多信息。实际上，我们将2D变换应用于图像每个8×8的块。主要思想是获得其他数据表示，并从空间域移动到频率域。DCT的结果是频域中的数据阵列，这是一个非常聪明的步骤，可以不直接处理亮度和色度，而是处理图像的亮度和色度频率。图像上的大对象被认为是低频数据，尽管小/微小的对象被认为是高频元素。</p><p id="5a93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在新的8×8块中，左上的元素被称为DC(这是来自原始块的所有像素的平均值)，所有其他元素被称为AC。如果我们从每个块的DC元素合成一幅新图像，我们得到的是分辨率降低的原始图像。新的宽度和高度将是原始图像的1/8。这只是说明DCT如何工作以及什么是DC和交流。</p><p id="872e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这听起来可能很奇怪，但在这一步，我们没有任何数据简化。一点也不。相反，在DCT之后，与上一步的数据大小相比，我们得到了更多的数据，但这仍然是一个非常重要的操作。新的表示很快会让我们实现强大的压缩，但不是现在。我们确实需要一些耐心，这将很快得到回报。</p><h1 id="8b98" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">量化和重新排序</h1><p id="2213" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">我们已经到了不得不引入一些数据丢失的地步。这个阶段被称为量子化。首先，我们创建一个带有系数的特殊量化矩阵8×8。在矩阵的左上部分，这些系数等于1或更大，但是朝向右下部分，它们变得更大。量化意味着将来自8×8块的每个值除以来自量化矩阵的相应系数。</p><p id="732a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这样的划分和舍入之后，我们得到每个8×8块的减少的值，并且这里最重要的问题是，我们得到靠近块右下部分的值的许多零。我们经常可以看到块的某些区域被零填充。这正是我们希望得到的——一系列零。这就是量化检测要丢弃的高频元素的方式。</p><p id="21a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了进一步处理，我们应用所谓的Zig-Zag算法从块中创建值的线性阵列。当我们开始从方块的左上角移动到右下角时，这是通过一个类似之字形的路径来完成的。在这样的重新排序之后，我们得到每个8×8块的一系列值。我们现在不处理块，我们将处理这些重新排序的数据。</p><p id="86de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">量化后，我们不仅有更少的数据，我们已经引入了一些原始图像的损失。JPEG压缩算法的大部分损失都来自这里。这就是为什么量化矩阵的选择是获得可接受的压缩图像质量的关键。JPEG标准没有定义这样的矩阵，许多相机和软件制造商投入大量精力来开发最佳的解决方案。</p><h1 id="948c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">DC编码</h1><p id="4969" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">从这一点开始，我们将分别处理DC和交流元素。我们从DC的德尔塔编码开始。我们只是从每个块中取第一个值(这是DC分量),并存储与前一个块的DC值之差。这非常简单明了。由DC组件组成的缩略图可以用作原始图像的缩减像素采样版本。</p><h1 id="88a0" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">RLE:游程编码</h1><p id="7ab0" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">从这里开始，我们将只处理交流元素，我们记得每个模块由63个这样的值组成。实际上，我们已经到了最终可以进行数据简化的地步。在每组交流元素中，我们可以看到一系列的零，现在我们可以用一些短码来代替它们，这些短码可以存储相同的信息。这是无损算法，我们在这里不引入任何图像损失。</p><p id="b769" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">RLE方法将值序列转换为对序列。该对的第一个元素称为符号，该对的第二个元素是非零值。对于每个序列，我们在符号中编码前面零的数量和非零值的位长度。RLE的思想是只存储一个值，即我们从交流数据中看到的下一个非零值之前的连续零的数量。这里我们有很大的数据减少，这是无损转换！这是缩小交流元件中所有零点序列的方法。但这不是全部，我们可以得到更多的压缩。</p><h1 id="dfa2" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">霍夫曼编码</h1><p id="e535" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">这种无损压缩算法是以该方法的发明者霍夫曼的名字命名的。它也被称为熵编码算法，在RLE之后，它被应用于获得更好的压缩。</p><p id="717b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该算法的思想是比较我们在RLE之后得到的所有代码，并为那些出现频率更高的代码选择具有更少比特的最短表示。在霍夫曼阶段，我们计算每个符号的频率，并为每个符号创建最佳的位代码。我们不会在这里进入更多的细节，你可以在<a class="ae jp" href="https://en.wikipedia.org/wiki/Huffman_coding" rel="noopener ugc nofollow" target="_blank"> Wiki </a>看到完整的信息。</p><h1 id="942d" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">最终包装</h1><p id="6765" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">完成压缩后，我们需要打包来自所有块的压缩数据，为jpg添加正确的头，设置文件名，并将压缩文件存储到HDD。</p><p id="64eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个相机和智能手机的功能都差不多。我们刚刚看了一下它是如何在全球范围内每天运行数十亿次的。</p><h1 id="f4ac" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">提示和技巧</h1><p id="7b9e" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">JPEG算法被用来压缩真实的照片图像。它不擅长人工图像压缩，例如带有文本的图像。如果我们尝试用JPEG压缩这样的人工图像，结果还不错，但是压缩算法并不是为这样的任务而创建的。</p><p id="91c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于DCT的标准JPEG压缩从定义上来说不可能是无损的。即使我们将压缩质量定义为100%(这意味着没有量化)，由于颜色变换和DCT，我们仍然会有一些轻微的损失，因为在DCT之后，我们会得到浮点值，这些浮点值必须转换为整数值，因此我们应用舍入，这是有损操作。请注意，无损JPEG是存在的，但这是完全不同的算法，尽管名称相同。</p><p id="463c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您的软件要求您将图像保存为JPEG格式时，请注意有许多方法可以定义质量参数，因此建议值可能与您的预期相差很大。通常，我们使用的JPEG压缩质量参数在0–100%之间，但在现实生活中，它不低于50%。视觉无损JPEG压缩被认为是质量90%及以上的情况。为了直观地检查，您可以尝试在100%缩放时发现轻微的矩形边框。如果您看不到它们，这意味着在您的观看条件下，您的压缩在视觉上是无损的，这很好。</p><p id="d425" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">jpeg标准允许在JPEG字节流中建立所谓的重新开始标记，它们旨在提供更快的JPEG解压缩。然而，大多数相机和软件产生的jpeg图像没有重启标记。您可以使用JpegSnoop软件检查jpegs中重启标记的数量。Jpegtran实用程序可以帮助您在jpeg图像中插入所需数量的重新开始标记。</p><p id="2b76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些软件制造商利用他们自己的压缩质量单位，如“jpg for web”或“质量等级从1到12”，所以你需要准备检查。证明这种符合性的最佳方式可能是JpegSnoop软件，它可以以标准单位显示亮度和色度的压缩质量的真实值，以及亮度和色度的量化矩阵。</p><p id="4c0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您需要检查JPEGs文件的内部结构，并快速进行编码或解码，请查看以下链接:</p><ol class=""><li id="6f38" class="la lb hu it b iu iv iy iz jc lt jg lu jk lv jo lh li lj lk dt translated">非常有用的软件，可以检查你的jpeg图片里面有什么，包括所有的元标签和内部参数:【https://github.com/ImpulseAdventure/JPEGsnoop】T2</li><li id="fae9" class="la lb hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">【CUDA上的快速图像压缩(GPU上最快的JPEG编解码解决方案)<a class="ae jp" href="https://www.fastcompression.com/" rel="noopener ugc nofollow" target="_blank">https://www.fastcompression.com/</a></li></ol><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/b97e10ada4eefe6252422f4b79fcdfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/0*-sNlSrAr9hkFfrR0"/></div></figure><blockquote class="lx ly lz"><p id="a721" class="ir is ma it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">本文由Fastvideo的首席执行官兼创始人<strong class="it hv"> Fyodor Serzhenko合作撰写。基于CUDA(<a class="ae jp" href="https://www.fastcompression.com/" rel="noopener ugc nofollow" target="_blank">Fastcompression.com</a>)的高性能成像解决方案设计</strong></p></blockquote></div></div>    
</body>
</html>