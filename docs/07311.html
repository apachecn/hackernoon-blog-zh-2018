<html>
<head>
<title>Code Your Own Popularity Based Recommendation System WITHOUT a Library in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写你自己的基于流行度的推荐系统，不需要库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/popularity-based-song-recommendation-system-without-any-library-in-python-12a4fbfd825e?source=collection_archive---------9-----------------------#2018-08-29">https://medium.com/hackernoon/popularity-based-song-recommendation-system-without-any-library-in-python-12a4fbfd825e?source=collection_archive---------9-----------------------#2018-08-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8deb6f446381bdc1b9efadc4c4e96443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NatSh_3HrqT3xk7BV48Nww.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="http://thedatascientist.com/right-way-recommender-system-startup/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="72fb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">推荐系统现在无处不在，像亚马逊、网飞和Airbnb。所以，这可能会让你想知道这些引擎是如何工作的，所以在这篇文章中，我将尝试解释基于流行度的推荐系统。</p><p id="a85b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">推荐系统的类型如下:</p><ol class=""><li id="06d2" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">基于流行度的推荐系统</li><li id="1a19" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">协同推荐系统</li><li id="3f61" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">基于内容的推荐系统</li><li id="958e" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">基于人口统计的推荐系统</li><li id="234f" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">基于效用的推荐系统</li><li id="2326" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">基于知识的推荐系统</li><li id="31c0" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">混合推荐系统</li></ol><h2 id="222b" class="kt ku hu bd kv kw kx ky kz la lb lc ld js le lf lg jw lh li lj ka lk ll lm ln dt translated">基于流行度的推荐系统</h2><p id="e8c0" class="pw-post-body-paragraph jh ji hu jj b jk lo jm jn jo lp jq jr js lq ju jv jw lr jy jz ka ls kc kd ke hn dt translated">顾名思义，基于流行度的推荐系统顺应了这一趋势。它基本上使用了现在流行的东西。例如，如果任何产品通常被每个新用户购买，那么就有可能向刚刚注册的用户推荐该产品。</p><p id="5aaf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">基于流行度的推荐系统也存在一些问题，并且它也解决了一些问题。</p><p id="3196" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">基于流行度的推荐系统的问题在于，这种方法不能实现个性化，也就是说，即使你知道用户的行为，你也不能相应地推荐项目。</p><p id="07dd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，我希望你现在对基于流行度的推荐系统有足够的了解。所以，让我们用代码弄脏我们的手。我的笔记本和数据的链接是<a class="ae jg" href="https://github.com/vyashemang/popularity_based_recommendation" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="5e6d" class="kt ku hu bd kv kw kx ky kz la lb lc ld js le lf lg jw lh li lj ka lk ll lm ln dt translated">让我们开始编码部分</h2><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="eaa8" class="kt ku hu ly b fv mc md l me mf"><strong class="ly hv">import</strong> <strong class="ly hv">pandas</strong><br/><strong class="ly hv">import</strong> <strong class="ly hv">numpy</strong> <strong class="ly hv">as</strong> <strong class="ly hv">np</strong><br/><strong class="ly hv">import</strong> <strong class="ly hv">Recommender</strong></span></pre><p id="2774" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们将导入我们将经常使用的熊猫和熊猫，以及我们创建的<a class="ae jg" href="https://github.com/vyashemang/popularity_based_recommendation/blob/master/Recommender.py" rel="noopener ugc nofollow" target="_blank">类</a>，它包括像<em class="mg">创建</em>这样的方法，它基本上创建了推荐和<em class="mg">推荐</em>，它向用户推荐项目。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="55a4" class="kt ku hu ly b fv mc md l me mf">triplets_file = 'https://static.turi.com/datasets/millionsong/10000.txt'</span><span id="ac7d" class="kt ku hu ly b fv mh md l me mf">songs_metadata_file = 'song_data.csv'</span></pre><p id="ea56" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本节中，我们将数据集导入为一个<em class="mg">三元组_文件</em>和<em class="mg">歌曲_元数据_文件。</em><em class="mg">三元组文件</em>包含<em class="mg">用户标识、歌曲标识和收听计数</em>。<em class="mg"> songs_metadata_file </em>包含<em class="mg"> song_id、title、release_by和artist_name </em>。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="9ec4" class="kt ku hu ly b fv mc md l me mf">song_df_1 = pandas.read_table(triplets_file,header=<strong class="ly hv">None</strong>)<br/>song_df_1.columns = ['user_id', 'song_id', 'listen_count']</span></pre><p id="27d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">之后，我们必须合并我们导入的两个数据集。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="688f" class="kt ku hu ly b fv mc md l me mf">song_df_2 = pandas.read_csv(songs_metadata_file)<br/>song_df = pandas.merge(song_df_1, song_df_2.drop_duplicates(['song_id']), on="song_id", how="left")</span></pre><p id="186f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这一节中，我们通过删除重复的歌曲id来合并两者。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="7376" class="kt ku hu ly b fv mc md l me mf">song_df = song_df.head(10000)</span></pre><p id="d908" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为这是一个大型数据集，所以我只考虑了前10k行。</p><p id="bfbe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">改变数据集的长度后，我做了一些额外的修改。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="2131" class="kt ku hu ly b fv mc md l me mf">song_df['song'] = song_df['title'].map(str) + " - " + song_df['artist_name']</span></pre><p id="23a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中我包含了一个名为<em class="mg"> song </em>的列，它连接了歌曲的标题和艺术家。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="c22b" class="kt ku hu ly b fv mc md l me mf">song_df_grouped = song_df.groupby(['song']).agg({'listen_count': 'count'}).reset_index()<br/>song_df_grouped.sort_values('listen_count',ascending = 0)</span></pre><p id="2670" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面所示的步骤中，数据集使用pandas函数<em class="mg"> groupby </em> by <em class="mg"> song </em>字段进行分组，并使用<em class="mg"> listen_count </em>字段进行聚合，之后根据<em class="mg"> listen_count对值进行非递增排序。</em></p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="8b33" class="kt ku hu ly b fv mc md l me mf">users = song_df['user_id'].unique()<br/>len(users)</span><span id="636d" class="kt ku hu ly b fv mh md l me mf">items = song_df['song'].unique()<br/>len(items)</span></pre><p id="a984" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一步找出数据集中唯一的用户和项目。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="5d35" class="kt ku hu ly b fv mc md l me mf">from sklearn.cross_validation import train_test_split<br/>train_data, test_data = train_test_split(song_df, test_size = 0.20, random_state=0)</span></pre><p id="c66c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这部分代码使用80–20的比率将数据集分为训练数据集和测试数据集。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="2247" class="kt ku hu ly b fv mc md l me mf">pr = Recommender.Popularity_Recommender()<br/>pr.create(train_data, 'user_id', 'song')</span></pre><p id="fad1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里，实例是由类<em class="mg"> Popularity_Recommender()创建的。</em>函数<em class="mg"> create </em>接受三个参数:训练数据、为其创建推荐的用户id以及您想要为其进行推荐的项目的列(在我们的示例中是<em class="mg"> song)。</em></p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="7c8f" class="kt ku hu ly b fv mc md l me mf">pr.recommend(users[5])</span></pre><p id="34ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如我之前说过的，方法recommend向用户提供推荐，并作为参数传递。因此，它为用户返回流行歌曲的列表，但是因为它是基于流行度的推荐系统，所以对用户的推荐不会受到影响。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/586bd67a8cdecff8ca33ef2ff1f1941b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCkX7aGzTVfos2O8b8Qwkw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Result of the recommendation system for 6th user</figcaption></figure><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="1e6d" class="kt ku hu ly b fv mc md l me mf">pr.recommend(users[100])</span></pre><p id="4f17" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，正如你在这里看到的，虽然我们改变了用户，但我们从系统中得到的结果是相同的，因为它是一个基于流行度的推荐系统。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/586bd67a8cdecff8ca33ef2ff1f1941b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCkX7aGzTVfos2O8b8Qwkw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Result of the recommendation system for 99th user</figcaption></figure><p id="300c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">别忘了鼓掌，放下对文章的想法。谢谢:)</p><p id="c1fd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">来源:</p><ol class=""><li id="c905" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated"><a class="ae jg" href="https://www.youtube.com/watch?v=39vJRxIPSxw&amp;t=734s" rel="noopener ugc nofollow" target="_blank"> Divya Sardana |使用Python构建推荐系统</a></li><li id="e947" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated"><a class="ae jg" href="https://github.com/llSourcell/recommender_live" rel="noopener ugc nofollow" target="_blank">https://github.com/llSourcell/recommender_live</a></li></ol></div></div>    
</body>
</html>