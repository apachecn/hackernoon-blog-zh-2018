<html>
<head>
<title>Effects of Redis on an API Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis对API服务器的影响</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/effects-of-redis-on-an-api-server-1e228a624f15?source=collection_archive---------20-----------------------#2018-08-29">https://medium.com/hackernoon/effects-of-redis-on-an-api-server-1e228a624f15?source=collection_archive---------20-----------------------#2018-08-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d7930344e8dd5c427ecfe11b931965ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6K5vmzalJUxn44v3cm6wBw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by thomas kvistholt on <a class="ae jg" href="https://unsplash.com/search/photos/robots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3a66" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你好！我们将研究redis对我们的API服务器性能的影响。<a class="ae jg" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>(远程字典服务器)可以作为数据库，缓存和其他几个东西。对于这个项目，我们将使用Redis进行缓存。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="766b" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated"><strong class="ak">我们为什么需要缓存？</strong></h1><ul class=""><li id="27b9" class="lk ll hu jj b jk lm jo ln js lo jw lp ka lq ke lr ls lt lu dt translated">它帮助我们减少了服务器必须处理的大量API请求和响应所带来的开销。</li><li id="e7d3" class="lk ll hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">由于减少了等待时间，用户请求或服务器响应将得到更快的响应。</li></ul><p id="fae2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Redis基本上会帮助我们缓存数据，然后在发出特定请求时提供数据。</p><p id="a091" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，如果我们使用一个允许用户注册并在网站上购物的服务器，我们知道“购物数据”(向购物车中添加商品、向钱包中添加钱、从购物车中移除商品、使用不同的网关支付订单等。)与注册时使用信息形成的用户简档相比更加动态。“注册数据”(用户名、用户地址、用户邮件等。)不太可能改变，并且这种类型的数据可以存储在高速缓存中，然后周期性地更新或刷新高速缓存。这将有助于提高时间效率。如果服务器试图通过查询数据库或API来访问网络(互联网),则比访问L1缓存或RAM更消耗CPU资源。这意味着访问缓存比持续查询数据库更有效。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="3ea1" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">创建服务器</h1><p id="d780" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">用于实现该服务器的堆栈将是:</p><ul class=""><li id="8afe" class="lk ll hu jj b jk jl jo jp js md jw me ka mf ke lr ls lt lu dt translated">节点JS + Express</li><li id="10d3" class="lk ll hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated"><a class="ae jg" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>(数据库)</li><li id="079f" class="lk ll hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">Redis(缓存)</li></ul></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><p id="71cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们下载<a class="ae jg" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>安装程序，它带有psql(SQL shell)和pgAdmin(确保在安装过程中注意‘用户’、‘密码’和‘端口’)。澄清一下，我在这个项目中使用的是windows操作系统。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/86a5c273a2013bbc3f63367e8b470355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nv0NwYq0rWG0-XqGcmOujw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A snippet of the pgAdmin home page.</figcaption></figure><p id="606c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以为自己创建一个数据库，只需打开在浏览器中运行的pgAdmin应用程序，然后单击“Servers/postgreSQL/Databases ”,右键单击“Databases ”,然后单击“create”即可创建一个新的数据库。对于这个项目，名称是“用户”。</p><p id="9738" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们可以通过单击“用户/模式/表”来创建一个表，然后右键单击“创建”来创建一个新表。该表的名称是“数据”。</p><p id="4b17" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们现在可以使用express generator创建我们的文件夹。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="04e3" class="mq kn hu mm b fv mr ms l mt mu">express myapi</span></pre><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The files and folders needed in the ‘myapi’ folder.</figcaption></figure><p id="1977" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“myapi”文件夹中应该有所有这些文件，让我们做好，以确保我们的路线工作正常。</p><h1 id="6126" class="km kn hu bd ko kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj dt translated">索引. js</h1><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The index.js file</figcaption></figure><p id="bac6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个文件只是为我们的基本CRUD应用程序创建了路由，并包含了crudController，它具有处理所有路由的功能。</p><h1 id="f82a" class="km kn hu bd ko kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj dt translated">crud-controller . js</h1><p id="ed50" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">首先，我们需要安装一些软件包。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="e1f9" class="mq kn hu mm b fv mr ms l mt mu">npm install --save redis response-time pg-promise</span></pre><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">crud-controllers.js</figcaption></figure><p id="16b1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个文件只是创建redis客户机，然后设置连接到postgreSQL数据库的“初始化选项”。</p><p id="8d6e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要连接到数据库，我们需要获取数据库的URL，通常采用以下形式:</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="b0fc" class="mq kn hu mm b fv mr ms l mt mu">postgresql://[user[:password]@][netloc][:port][/dbname]</span></pre><p id="b363" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">默认情况下:</p><ul class=""><li id="b998" class="lk ll hu jj b jk jl jo jp js md jw me ka mf ke lr ls lt lu dt translated">用户:<strong class="jj hv"> postgres </strong></li><li id="ae15" class="lk ll hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">netloc : <strong class="jj hv">本地主机</strong></li><li id="3165" class="lk ll hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">港口:<strong class="jj hv"> 5432 </strong></li><li id="bd11" class="lk ll hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">数据库名:我们数据库的名称是<strong class="jj hv">用户</strong></li><li id="bfaf" class="lk ll hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">然后，您可以输入安装时设置的密码。</li></ul><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A continuation of the crud-controller.js file</figcaption></figure><p id="e865" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们安装了“pg-promise ”,它帮助我们使用promises来处理postgreSQL，而“initializationOptions”帮助我们检查错误。</p><p id="9614" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们使用“connectionString”连接到我们的数据库。如果一切都做得正确，我们应该看到“成功！！!"当我们启动服务器的时候。</p><p id="74c7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们将在由“crudController.getSingle”控制的“/get/:id”路径上使用redis客户端。我们可以在index.js文件中看到这条路线。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mv mw l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The crudeController.getSingle function</figcaption></figure><p id="00d9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，在getSingle函数中，我们获取用户的id。由于redis基于键和值工作，我们<strong class="jj hv">设置</strong>键并获取<strong class="jj hv">值</strong>。</p><p id="9754" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们检查是否可以从用户ID中获得任何值，如果有结果，我们发送一个响应，说明数据是从redis-cache中获得的。如果没有结果，我们查询数据库，然后当得到结果时，我们现在将它存储在缓存中。</p><p id="6e28" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这肯定会在每个新请求期间发生，然后在第一个请求之后，数据将被保存。我们使用了<strong class="jj hv"> setex </strong>以便我们可以设置<strong class="jj hv">键</strong>即用户ID，以及到期时间<strong class="jj hv"> 60 </strong>秒。因此<strong class="jj hv"> setex </strong>是SET和EXPIRY的组合，最后我们添加数据作为<strong class="jj hv">值。</strong>所以60秒是这个键-值对的TTL(生存时间)。</p><p id="5045" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以检查API服务器查询db所用的时间，然后检查从缓存中获取数据所用的时间。</p><p id="989a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要将响应时间包添加到app.js文件中</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="6a9c" class="mq kn hu mm b fv mr ms l mt mu">//At the top<br/>var<em class="nc"> </em>responseTime<em class="nc"> </em>=<em class="nc"> require</em>('response-time');<br/>.<br/>.<br/>.<br/>//Above the routes<br/>app<em class="nc">.</em>use(responseTime());</span></pre><p id="7c81" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">响应时间包在我们的头中添加了一个“X-Response-Time”键，并向我们显示花费的时间。</p><p id="b556" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以将数据添加到我们的“数据”表中，这样我们就可以使用数据了。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/9523047d7be111e2451fed65ece847c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*NVl7Z_cVB1LsZnytekQYaw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">A snippet of the DB.</figcaption></figure><p id="b5be" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，让我们使用<strong class="jj hv"> npm start </strong>启动我们的服务器，然后转到我们的浏览器，键入URL<strong class="jj hv">“localhost:3000/get/2”</strong>，因为我们有id为1、2和3的项目。</p><p id="d707" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我们可以打开chrome开发者工具，进入网络，点击id。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/1197fe9788a2d36a5926f3e9fe78cfb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zo5JTHXqgqGy4Kc4Z3WLBg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Response from DB</figcaption></figure><p id="1642" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为这是第一个请求，所以它不在缓存中，然后直接查询数据库。在屏幕底部，我们可以看到X响应时间为<strong class="jj hv">124.092毫秒。</strong></p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/6de7c913d7c00ac5908ddfe7e0d2d004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWT2pw3PQXC0xY-rm_LfIw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Response from cache</figcaption></figure><p id="d5dd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从响应中，我们可以看到源是redis-cache，X-Response-Time是<strong class="jj hv">1.224毫秒。</strong></p><p id="1e68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们可以看到缓存更加有效，特别是当我们有更多的用户并且数据库不再本地托管时。</p><p id="e9cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">非常感谢您的阅读！</p></div></div>    
</body>
</html>