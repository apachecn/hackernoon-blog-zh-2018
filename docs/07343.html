<html>
<head>
<title>Sharding Writes with MySQL and Increment Offsets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MySQL和增量偏移量进行分片写入</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sharding-writes-with-mysql-and-increment-offsets-48df32379563?source=collection_archive---------41-----------------------#2018-08-29">https://medium.com/hackernoon/sharding-writes-with-mysql-and-increment-offsets-48df32379563?source=collection_archive---------41-----------------------#2018-08-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="3ef5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="c819" class="jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">我们使用PKs上的增量偏移量来分片写入并避免冲突</li><li id="5432" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">每个数据中心都包含本地写服务器</li><li id="fd10" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">我们在读取服务器上使用多源复制，因此它们包含来自所有数据中心的所有数据，并按月进行分区</li></ul><h1 id="a617" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">一开始，事情很简单</h1><p id="ee9c" class="pw-post-body-paragraph km kn hu jr b js jt ko kp ju jv kq kr jw ks kt ku jy kv kw kx ka ky kz la kc hn dt translated">我们使用的是MySQL:一个主数据库用于写，几个从数据库用于读。除了<em class="lc">复制滞后</em>(稍后会有更多介绍)，它运行良好。然后你扩大规模。然后就失败了！主人是一个SPOF——“<strong class="jr hv">S</strong>single<strong class="jr hv">P</strong>point<strong class="jr hv">O</strong>F<strong class="jr hv">F</strong>failure”。</p><p id="41aa" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">无论是流程失败、虚拟机崩溃，还是我们必须在服务器上进行维护，只有一个“主机”需要写入数据都意味着服务会中断几分钟。这是不可接受的。</p><p id="5c33" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">我们实现的第一件事是基于数据“类型”的<strong class="jr hv">分片</strong>:有“stats”集群(一个主+ N个从)、“calls”集群、“customers”集群等等。这使得服务器的维护更加容易，因为我们可以在一个集群上工作，而不会影响其他集群。</p><p id="a27e" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">但是在每个集群中仍然有一个SPOF:主人。</p><h1 id="f0b2" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">选择</h1><p id="d531" class="pw-post-body-paragraph km kn hu jr b js jt ko kp ju jv kq kr jw ks kt ku jy kv kw kx ka ky kz la kc hn dt translated">为了摆脱主节点是SPOF的主从架构，我们需要一种解决方案，可以在任何节点上写入，如果前一个节点不可用，可以故障转移到另一个节点。对于读取，我们需要一个可以针对“联邦”数据(从每个节点读取)运行查询的解决方案。</p><p id="b30c" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">这并不像听起来那么简单。在分布式系统上工作时，您必须使用:</p><ul class=""><li id="cb52" class="jp jq hu jr b js ld ju le jw li jy lj ka lk kc kd ke kf kg dt translated">一致性</li><li id="9e2c" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated"><strong class="jr hv">一</strong>可用性</li><li id="ada1" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">P 分割公差</li></ul><p id="3bf0" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">是的，<a class="ae lb" href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noopener ugc nofollow" target="_blank">上限定理</a>。</p><p id="f55c" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">如果在一个节点上更新一行，同时在另一个节点上更新同一行，会发生什么情况？数据协调很难(有时甚至不可能)。</p><p id="0483" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">如果网络出现故障，并且节点之间的数据不一致，该怎么办？你相信哪一个？</p><p id="26fa" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">我们研究了许多技术。存在“主-主”拓扑。MySQL Cluster是一个不错的选择。还有Galera集群、钨复制器、MySQL代理……(当时，MySQL组复制还没有做好生产准备)。</p><p id="ff70" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">我们也观察了NoSQL世界。Cassandra，MongoDB，HBase…但是:</p><ul class=""><li id="3c13" class="jp jq hu jr b js ld ju le jw li jy lj ka lk kc kd ke kf kg dt translated">我们在团队中对MySQL有很深的了解</li><li id="b7a3" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">我们对它很有信心，它很稳定，我们知道如何运行它</li><li id="8db0" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">我们想尽可能少地改变我们的代码</li></ul><blockquote class="ll"><p id="32fd" class="lm ln hu bd lo lp lq lr ls lt lu kc ek translated">新技术肯定很性感。但是当你经营一家企业时，稳定性和维护是关键。</p></blockquote><p id="2431" class="pw-post-body-paragraph km kn hu jr b js lw ko kp ju lx kq kr jw ly kt ku jy lz kw kx ka ma kz la kc hn dt translated"><em class="lc">注意:现在有很多解决方案，尤其是如果你是“在云端”并且从头开始。如果您有一个现有的MySQL基础设施、一个现有的代码库、有MySQL经验的人，并且需要在不改变整个存储层的情况下进行扩展，那么我们在此公开的解决方案会非常有效。</em></p><h1 id="7a5c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">我们的解决方案</h1><p id="3fe8" class="pw-post-body-paragraph km kn hu jr b js jt ko kp ju jv kq kr jw ks kt ku jy kv kw kx ka ky kz la kc hn dt translated">我们处理两种类型的数据:</p><ul class=""><li id="d780" class="jp jq hu jr b js ld ju le jw li jy lj ka lk kc kd ke kf kg dt translated"><strong class="jr hv">【永久】</strong>数据:运营商、电话号码、路由配置文件、拨号代码等。数据很少变化，我们必须“永久”保存它(除了根据GDPR和其他法规强制删除)，并且它随着时间的推移增长非常缓慢。</li><li id="9198" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated"><strong class="jr hv">【用法】</strong>数据:通话、短信、API请求、事件、webhooks、日志。<strong class="jr hv">成长非常迅速</strong>。写过一次。可能会在小时内更新。</li></ul><p id="abc5" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">对于永久数据，我们使用主-主拓扑。这里没什么特别的。我们总是在同一个母版上书写。如果它失败了，或者如果我们需要做维护，我们就切换到另一个主机。</p><p id="38cd" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated"><strong class="jr hv">这里的故事是针对使用数据的。</strong></p><p id="7f85" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">我们称之为<strong class="jr hv">“DBRW”架构</strong>，因为我们拆分了读/写。</p><h1 id="a653" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">它是如何工作的</h1><p id="2c08" class="pw-post-body-paragraph km kn hu jr b js jt ko kp ju jv kq kr jw ks kt ku jy kv kw kx ka ky kz la kc hn dt translated">我们的实现非常简单:当我们需要插入数据时，<strong class="jr hv">我们随机选择一个写服务器</strong> (*)。如果它不可用，或者如果错误让我们进行故障转移，我们尝试另一个写服务器。嘣！<strong class="jr hv">SPOF不见了！</strong></p><p id="60bb" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">写服务器只包含已经写入其中的数据。它们的数据在读取服务器上异步复制。</p><p id="ecf1" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">读取服务器使用多源复制联合来自所有写入服务器的数据。我们对连接应用与写服务器相同的规则:我们随机选择一个服务器(*)，如果它不可用，就进行故障转移。</p><p id="0a47" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated"><em class="lc"> (*)我们的系统更聪明一点:它避开了正在维护或被监管机构降级的服务器，对“随机”进行了加权，并且我们总是首先尝试同一个数据中心的服务器。</em></p><figure class="mc md me mf fq mg fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/0f0f02d5b612ba86f1da2cbdf14411b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*UvsNvfPreQlGvO9Z.png"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">DBRW illustrated</figcaption></figure><p id="d826" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">写服务器上的我们<code class="eh mn mo mp mq b">INSERT</code>和<code class="eh mn mo mp mq b">UPDATE</code>。我们<code class="eh mn mo mp mq b">SELECT</code>在阅读服务器上。</p><h1 id="dab5" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">写服务器</h1><ul class=""><li id="453f" class="jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">数据每天清除，他们只需要有限的存储空间</li><li id="87e9" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">我们使用非常快速的固态硬盘来获得最佳性能</li><li id="26f0" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">除了主键之外没有索引(所以插入非常快)</li><li id="709b" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">可以关闭服务器进行维护，这不会影响系统</li></ul><h1 id="c1de" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">读取服务器</h1><ul class=""><li id="e548" class="jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">相同的模式+索引+分区(按月)</li><li id="d816" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">索引允许快速搜索查询(但是占用空间)</li><li id="42e4" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">分区让我们可以在磁盘之间移动数据，或者在几毫秒内丢弃旧数据</li></ul><h1 id="585e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">增量偏移解释</h1><p id="0e6b" class="pw-post-body-paragraph km kn hu jr b js jt ko kp ju jv kq kr jw ks kt ku jy kv kw kx ka ky kz la kc hn dt translated">通过利用多源复制，读取服务器接收并“合并”来自所有写入服务器的数据。为了避免主键冲突，我们在写服务器上使用一个增量<a class="ae lb" href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-master.html#sysvar_auto_increment_increment" rel="noopener ugc nofollow" target="_blank">增量</a> + <a class="ae lb" href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-master.html#sysvar_auto_increment_offset" rel="noopener ugc nofollow" target="_blank">偏移量</a>。例如:</p><ul class=""><li id="73c1" class="jp jq hu jr b js ld ju le jw li jy lj ka lk kc kd ke kf kg dt translated">服务器DBW1(增量20，偏移量1): 1，21，41，61，81</li><li id="708a" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">服务器DBW2(增量20，偏移量2): 2，22，42，62，82</li><li id="0f13" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">服务器DBW3(增量20，偏移量3): 3，23，43，63，83</li></ul><p id="bcb9" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">这样，插入就不会发生冲突。</p><p id="bf0d" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">当我们需要更新时，<strong class="jr hv">我们需要在拥有数据</strong>的服务器上进行。写服务器仅保留数据几天，旧数据将被清除。幸运的是，一旦写入，<strong class="jr hv">使用数据很少更新</strong>，或者在几个小时内更新。</p><p id="88ea" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">显然，这种体系结构不适用于需要随时间不断更新的数据！</p><p id="16d8" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">要知道哪个服务器保存了带有主键的数据，我们需要做的就是应用增量的模，它会给我们一个偏移量，也就是服务器。例子:<code class="eh mn mo mp mq b">41 mod 20 = 1</code> (DBW1)或者<code class="eh mn mo mp mq b">62 mod 20 = 2</code> (DBW2)。</p><h1 id="9b91" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">这种架构的优势</h1><ul class=""><li id="845b" class="jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">任何服务器都可以关闭，而不会影响服务</li><li id="1b25" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">写服务器很轻，速度极快(没有索引)</li><li id="f38e" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">适用于多数据中心拓扑:</li><li id="46be" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">➡️写服务器可以“本地”放置在每个数据中心</li><li id="aebf" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">➡️读取服务器可以是“远程”的，因为MySQL复制在广域网上运行良好</li><li id="3bd5" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">读取服务器包含所有数据，因此搜索查询可以按预期工作</li><li id="0fec" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">有了分区，读服务器的维护相当容易</li><li id="03ca" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">扩展写入很容易</li></ul><h1 id="a27a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">骗局</h1><ul class=""><li id="f9a6" class="jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">读取服务器需要很大的空间(“垂直扩展”)，但是分区使它变得很容易</li><li id="d9be" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated">在读取服务器上复制和聚合的写入服务器的主键不连续，也不按顺序排列，因为它在每个写入服务器上独立递增</li></ul><p id="2b7b" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">我们已经使用这个架构很多年了，到目前为止，它一直工作得很好。</p><h1 id="4b9d" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">履行</h1><p id="b58b" class="pw-post-body-paragraph km kn hu jr b js jt ko kp ju jv kq kr jw ks kt ku jy kv kw kx ka ky kz la kc hn dt translated">实现读/写拆分可能很棘手。在我们的例子中，我们的大多数项目都有一个“数据存储”层，在这个层中我们可以很容易地实现分割和<a class="ae lb" href="https://hackernoon.com/tagged/sharding" rel="noopener ugc nofollow" target="_blank">分片</a>。</p><p id="161f" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated">最重要的是，在进行更新时，或者当复制延迟成为问题时，不要忘记<strong class="jr hv">读取您自己的写入内容</strong>。</p><h1 id="c17c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">推荐阅读</h1><ul class=""><li id="b01c" class="jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated"><a class="ae lb" href="https://www.amazon.fr/High-Performance-MySQL-Baron-Schwartz/dp/1449314287/ref=sr_1_1?ie=UTF8&amp;qid=1535544569&amp;sr=8-1&amp;keywords=mysql+performance" rel="noopener ugc nofollow" target="_blank">高性能MySQL </a>是一本好书，不幸的是没有最新版本的MySQL</li><li id="03d6" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated"><a class="ae lb" href="https://dataintensive.net/" rel="noopener ugc nofollow" target="_blank">设计数据密集型应用</a>，虽然不是专门针对MySQL的，但却是一本好书</li><li id="260f" class="jp jq hu jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg dt translated"><a class="ae lb" href="https://www.percona.com/blog/" rel="noopener ugc nofollow" target="_blank">珀科纳博客</a>真的很棒</li></ul></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="39ed" class="pw-post-body-paragraph km kn hu jr b js ld ko kp ju le kq kr jw lf kt ku jy lg kw kx ka lh kz la kc hn dt translated"><em class="lc">原载于2018年8月29日</em><a class="ae lb" href="https://blog.callr.tech/sharding-writes-with-mysql-increment-offsets/" rel="noopener ugc nofollow" target="_blank"><em class="lc">blog . callr . tech</em></a><em class="lc">。</em></p><figure class="mc md me mf fq mg"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>