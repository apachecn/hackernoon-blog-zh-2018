<html>
<head>
<title>Pushing the right buttons : How Uno implements views — Under the hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按正确的按钮:Uno如何实现视图——在引擎盖下</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/pushing-the-right-buttons-how-uno-implements-views-under-the-hood-a5e93ea86688?source=collection_archive---------15-----------------------#2018-08-30">https://medium.com/hackernoon/pushing-the-right-buttons-how-uno-implements-views-under-the-hood-a5e93ea86688?source=collection_archive---------15-----------------------#2018-08-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/5d267f3445fce0626ea937000ca6ca5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9R4KTJeMpxfTDBHuDBzB_w.jpeg"/></div></div></figure><div class=""/><p id="2109" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" rel="noopener" href="/@unoplatform/under-the-hood-an-introduction-to-uno-platform-6064a765d6a">之前的一篇文章</a>中，我概述了<a class="ae ka" href="https://platform.uno/" rel="noopener ugc nofollow" target="_blank"> Uno平台</a>的三项主要工作，以便在iOS、Android和浏览器上运行UWP应用程序:</p><ol class=""><li id="ff6c" class="kb kc if je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">解析XAML文件；</li><li id="f978" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">实现数据绑定；</li><li id="b199" class="kb kc if je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">为每个平台实现<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/design/controls-and-patterns/controls-by-function" rel="noopener ugc nofollow" target="_blank"> UWP框架</a>中的视图套件。</li></ol><p id="ce5a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我想集中讨论最后一点。Uno如何贯彻UWP的观点？作为一个案例研究，我将使用无处不在的UI控件，按钮。</p><h1 id="103b" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">这个数字上升了</h1><p id="5516" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我提出一个可以想象的最简单的交互应用程序，比“Hello World”高一步:</p><p id="2776" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">XAML:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="9a5e" class="mb kq if lx b fv mc md l me mf">&lt;Page x:Class="UnoExtTestbed.MainPage" <br/>       <br/>      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" <br/>      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" <br/>      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" <br/>      mc:Ignorable="d"&gt; </span><span id="246a" class="mb kq if lx b fv mg md l me mf">    &lt;StackPanel&gt; <br/>        &lt;TextBlock x:Name="ClickTextBlock" <br/>                   Text="Button wasn't clicked yet" /&gt; <br/>        &lt;Button Content="Click me" <br/>                Click="Button_Click" /&gt; <br/>    &lt;/StackPanel&gt; <br/>&lt;/Page&gt;</span></pre><p id="5a75" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代码隐藏:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="c09d" class="mb kq if lx b fv mc md l me mf">using System; <br/>using Windows.UI.Xaml; <br/>using Windows.UI.Xaml.Controls;  </span><span id="4984" class="mb kq if lx b fv mg md l me mf">namespace UnoExtTestbed <br/>{ <br/>    public sealed partial class MainPage : Page <br/>    { <br/>        public MainPage() <br/>        { <br/>            this.InitializeComponent(); <br/>        } </span><span id="bc30" class="mb kq if lx b fv mg md l me mf">        private int _clickCount = 0; <br/>        private void Button_Click(object sender, RoutedEventArgs e) <br/>        { <br/>            _clickCount++; <br/>            ClickTextBlock.Text = $"Button was clicked {_clickCount} times."; <br/>        } <br/>    } <br/>}</span></pre><p id="3fed" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我使用<a class="ae ka" href="https://marketplace.visualstudio.com/items?itemName=nventivecorp.uno-platform-addin" rel="noopener ugc nofollow" target="_blank"> Uno解决方案模板</a>制作了一个空白的应用程序，并将这段代码放在主页上。每当点击<a class="ae ka" href="https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.controls.button" rel="noopener ugc nofollow" target="_blank">按钮</a>时，数字上升。再添加一点chrome，我们就能有一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Cow_Clicker" rel="noopener ugc nofollow" target="_blank">病毒式的成功</a>。</p><p id="e0f1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，XAML在这里是有用的，但不是必须的，无论是在UWP还是在Uno上。如果我们真的想的话，我们可以用C#定义和创建我们所有的视图。这种灵活性非常方便。</p><h1 id="b895" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">附录A——视觉树</h1><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mh"><img src="../Images/9857e55c256486228567294d8721c395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0Q8HhXDzJ5JeE45F.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek"><em class="mm">Visual tree information for UWP</em></figcaption></figure><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mn"><img src="../Images/f28c4e73832e04eaea47c584bbd3970c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mocsv-aECZq2Se0q.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek"><em class="mm">Visual tree information for Android</em></figcaption></figure><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mo"><img src="../Images/631afaecc24d98d39da6e0d089fe7438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OSWF5ZcskQa0THiP.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek"><em class="mm">Visual tree information for iOS</em></figcaption></figure><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mp"><img src="../Images/538cc726a79135115c167d3257749952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u9DfKS7ezs_itg3T.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek"><em class="mm">Visual tree information for WASM</em></figcaption></figure><p id="e985" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那我们得到了什么？您可以在每个目标平台上看到生成的可视化树。它们基本上都相似。顶层包装略有不同，但在里面我们可以看到我们在XAML定义的<code class="eh mq mr ms lx b">MainPage</code>、<code class="eh mq mr ms lx b">StackPanel</code>、<code class="eh mq mr ms lx b">TextBlock</code>和<code class="eh mq mr ms lx b">Button</code>。(<code class="eh mq mr ms lx b">Frame</code>是在项目模板附带的股票<code class="eh mq mr ms lx b">App.xaml.cs</code>代码中创建的。)</p><p id="041d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能会注意到在<code class="eh mq mr ms lx b">Button</code>中有几个额外的视图没有在XAML中明确定义。这些是按钮的默认模板的一部分。如果你不熟悉UWP/WPF/Silverlight/etc的控制模板的概念，关于主题的<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/design/controls-and-patterns/control-templates" rel="noopener ugc nofollow" target="_blank">有很多要说的，但是它的要点是任何从<code class="eh mq mr ms lx b">Control</code>继承的视图都是一个白板，一个空容器，它将被其模板中定义的内部视图填充。(其中一些子视图本身可能是模板化的控件。)这是定制可重用控件外观的有力手段。</a></p><p id="445e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何从XAML定义的逻辑树变成本地的可视化树？</p><p id="3452" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们继续播放视觉教具。我们将创建一个从<code class="eh mq mr ms lx b">Button</code>继承的空类，并看看它的继承层次。</p><div class="ls lt lu lv fq ab cb"><figure class="mt hw mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><img src="../Images/f611569c0c151f8d78199ee56028d519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*1ebed9dmdBOu6m3lEVl5sw.png"/></div></figure><figure class="mt hw mz mv mw mx my paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><img src="../Images/f003cb2e73af4d86efa4b673cbdfe820.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*VnvumWl7J62hWdz3-3o3Fg.png"/></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek na di nb nc"><em class="mm">Inheritance chains for the Button class on UWP, Android, iOS, and WASM</em></figcaption></figure></div><p id="ce86" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像视觉树一样，特定于平台的继承链在“向叶”端非常相似(事实上是相同的),在根端有点不同。让我们关注一下它们的不同之处:在UIElement类之后，UWP的<a class="ae ka" href="https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.uielement" rel="noopener ugc nofollow" target="_blank">基本视图类型</a>。</p><p id="8ed2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在UWP上，<code class="eh mq mr ms lx b">UIElement</code>继承自<a class="ae ka" href="https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.dependencyobject" rel="noopener ugc nofollow" target="_blank"> DependencyObject </a>，它是支持使用<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/dependency-properties-overview" rel="noopener ugc nofollow" target="_blank"> DependencyProperty </a>值进行数据绑定的类型的基类。</p><p id="43ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Uno。Android和Uno.iOS，任何<code class="eh mq mr ms lx b">UIElement</code>都是原生基本视图类型(<a class="ae ka" href="https://developer.android.com/reference/android/view/View" rel="noopener ugc nofollow" target="_blank"> Android)的实例。视图视图</a>和<a class="ae ka" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank"> UIKit。UIView </a>，通过<a class="ae ka" href="https://visualstudio.microsoft.com/xamarin/" rel="noopener ugc nofollow" target="_blank"> Xamarin </a>的魔力映射到托管类型。所以在XAML定义的视图也是本地视图。这意味着，例如，可以将对Uno一无所知的本地视图直接整合到应用程序的XAML中。以下内容适用于iOS:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="7cb4" class="mb kq if lx b fv mc md l me mf">&lt;Page x:Class="UnoExtTestbed.MainPage"<br/>            ...<br/>            xmlns:uikit="using:UIKit"&gt;<br/>    ...<br/>    &lt;StackPanel&gt; <br/>            &lt;uikit:UILabel Text="Native label"/&gt; <br/>    &lt;/StackPanel&gt;<br/>&lt;/Page&gt;</span></pre><p id="b926" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这在Uno中是非常容易做到的。我们谈论“留有退路”:目标是100%代码重用，但是如果你必须使用特定于平台的特性或视图库，灵活性就在那里。</p><p id="8f50" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是等等，<code class="eh mq mr ms lx b">DependencyObject</code>呢？</p><p id="8aa8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为这是UWP合同的重要部分，我们不想把<code class="eh mq mr ms lx b">DependencyObject</code>排除在外，但我们也必须能够支持根本不是观点的<code class="eh mq mr ms lx b">DependencyObjects</code>。(<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/design/style/brushes" rel="noopener ugc nofollow" target="_blank">笔刷</a>和<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/design/layout/transforms" rel="noopener ugc nofollow" target="_blank">变换</a>，仅举几例。)因此<code class="eh mq mr ms lx b">DependencyObject</code>被定义为一个<a class="ae ka" href="https://github.com/nventive/Uno/blob/39b0046ddc34cb3f023eff8db7c6e5ebc16ca670/doc/articles/api-differences.md#dependencyobject-is-an-interface" rel="noopener ugc nofollow" target="_blank">接口</a>。然而，这是一个“特殊”的接口:Uno的代码生成会在找到像<code class="eh mq mr ms lx b">MyDependencyObject : DependencyObject</code>这样的类时自动添加支持方法，允许为UWP编写的代码基本上“正常工作”我将在以后关于Uno中的代码生成的文章中详细讨论它。</p><p id="8c98" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在WebAssembly中，现在继承层次稍微简单一些，并且<code class="eh mq mr ms lx b">UIElement</code>位于类型树的根。截图中可以看到，Uno。WASM正在为视觉树中的每个视图生成<code class="eh mq mr ms lx b">&lt;div&gt;</code>元素。</p><h1 id="c005" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">风格点</h1><p id="62ba" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">上面的代码为我们提供了一个非常普通的按钮，但是我们可以很容易地增加它的趣味。我们将<code class="eh mq mr ms lx b">Content</code>属性设置为一个文本字符串，但是<code class="eh mq mr ms lx b">Content</code>可以是任何东西，甚至是另一个视图。我们的按钮可以是一个<a class="ae ka" href="https://github.com/nventive/Uno.Playground/blob/master/src/Uno.Playground.Shared/Samples/Image.xaml" rel="noopener ugc nofollow" target="_blank">图像</a>，一个<a class="ae ka" href="https://github.com/nventive/Uno.Playground/blob/master/src/Uno.Playground.Shared/Samples/Shapes.xaml" rel="noopener ugc nofollow" target="_blank">形状</a>，或者一个复杂的视觉层次。它甚至可以有另一个按钮在里面。</p><p id="87da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想反方向走呢？如果我们想完全放弃对按钮外观的控制呢？</p><p id="c14e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Uno实施的许多控制措施(包括在内)支持“本地”风格的概念。你得到的不是一个在你的应用程序的所有版本中都一致的按钮，而是一个目标平台的用户所期望的按钮。</p><p id="d017" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它通过设置一个预定义的<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/design/controls-and-patterns/xaml-styles" rel="noopener ugc nofollow" target="_blank">样式</a>来支持，该样式将本地控件的一个实例放入XAML控件中。在上面的代码中，我们可以写:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="2f5e" class="mb kq if lx b fv mc md l me mf">&lt;Button Content="Click me" <br/>                Click="Button_Click" <br/>      Style="{StaticResource NativeDefaultButton}" /&gt;</span></pre><p id="92a3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于Android的默认按钮看起来与UWP的非常相似，我将使用不同的控件<a class="ae ka" href="https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.controls.toggleswitch" rel="noopener ugc nofollow" target="_blank"> ToggleSwitch </a>来展示一个更直观的例子。我将使用来自<a class="ae ka" href="https://github.com/nventive/Uno.Playground#uno-playground" rel="noopener ugc nofollow" target="_blank"> Uno Gallery </a>应用程序的<a class="ae ka" href="https://github.com/nventive/Uno.Playground/blob/master/src/Uno.Playground.Shared/Samples/ToggleSwitch.xaml" rel="noopener ugc nofollow" target="_blank">样本</a>。</p><div class="ls lt lu lv fq ab cb"><figure class="mt hw nd mv mw mx my paragraph-image"><img src="../Images/dd482573e426eb09984342ff534de0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/0*kX8Q2-mT-aSBw3US.jpg"/></figure><figure class="mt hw ne mv mw mx my paragraph-image"><img src="../Images/c8cd9574369a6b87fc8b793a5aa18578.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*iZq_tOqh8zf0fwES.jpg"/><figcaption class="mi mj fg fe ff mk ml bd b be z ek nf di ng nc"><em class="mm">Uno’s ToggleSwitch control on Android and iOS, using default and native styles.</em></figcaption></figure></div><p id="9c81" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认风格的<code class="eh mq mr ms lx b">ToggleSwitch</code>在所有平台上看起来都一样，无论是静态的还是动态的。然而，在Android和iOS上，<code class="eh mq mr ms lx b">NativeDefaultToggleSwitch</code>风格的<code class="eh mq mr ms lx b">ToggleSwitch</code>复制了每个平台的原生切换控制。当然，您仍然可以像往常一样绑定到它在XAML的属性。这是另一个强大的选择:对于一些应用程序来说，看起来尽可能“原生”是有意义的，对于其他应用程序来说，拥有一个丰富的、定制的用户界面是可取的。你甚至可能想在你的应用中为不同的屏幕混合搭配不同的方法。使用Uno很简单。</p><h1 id="7c96" class="kp kq if bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">我不喜欢纽扣怎么办？</h1><p id="4512" class="pw-post-body-paragraph jc jd if je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">事实上<code class="eh mq mr ms lx b">UIElement</code>实现了类似<a class="ae ka" href="https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.uielement.pointerpressed" rel="noopener ugc nofollow" target="_blank"> PointerPressed </a>、<code class="eh mq mr ms lx b">PointerReleased</code>等原始交互事件，所以Uno中的所有视图都可以处理触摸/点击，而不仅仅是<code class="eh mq mr ms lx b">Button</code>。(除了MVVM友好的<code class="eh mq mr ms lx b">Command</code>属性之外，使用<code class="eh mq mr ms lx b">Button</code>的最大优点是它实现了<a class="ae ka" href="https://docs.microsoft.com/en-us/previous-versions/windows/apps/jj819808(v=win.10)" rel="noopener ugc nofollow" target="_blank">视觉状态</a>来激活你的按钮。)</p><p id="091c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有很多要谈的，比如UWP的API被连接到每个平台的原生输入检测的方式，或者about是如何完成的，但现在就这些了。</p><p id="7827" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">试用 Uno，如果有任何问题，请联系我们。</p></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff no"><img src="../Images/9289c79ecb6e83095c577997480a3ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuA1qdX7eUziOMnkRBJ_Gw.png"/></div></div></figure></div></div>    
</body>
</html>