<html>
<head>
<title>Building a Polyfill for React Suspense</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为React Suspense构建聚合填充</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-polyfill-for-react-suspense-f1c7baf18ca1?source=collection_archive---------6-----------------------#2018-08-31">https://medium.com/hackernoon/building-a-polyfill-for-react-suspense-f1c7baf18ca1?source=collection_archive---------6-----------------------#2018-08-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/537a97ce6f807ceb2f857b5f24563a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RHL0QJNBkqUKmcFMb9JXg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">I chose this image for no other reason than because it showed up in the <a class="ae jg" href="https://unsplash.com/search/photos/suspense" rel="noopener ugc nofollow" target="_blank">Unsplash</a> search results for “suspense.” There may or may not be some deeper symbolism discussed later in this article regarding how the polyfill is only halfway faithful much like how this doll has been torn in half, but let’s get back to the subject at hand.</figcaption></figure><blockquote class="jh"><p id="b21a" class="ji jj hu bd jk jl jm jn jo jp jq jr ek translated">理解一个软件概念的最好方法是尝试自己构建它。结核病</p></blockquote><p id="8fd1" class="pw-post-body-paragraph js jt hu ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko jr hn dt translated">如果你喜欢React，你可能听说过一些关于<a class="ae jg" href="https://github.com/sw-yx/fresh-async-react" rel="noopener ugc nofollow" target="_blank">即将上映的悬疑API</a>的事情，但即使在看了一个<a class="ae jg" href="https://github.com/acdlite/suspense-ssr-demo" rel="noopener ugc nofollow" target="_blank">演示</a>或<a class="ae jg" href="https://slides.com/swyx/react-suspense#/" rel="noopener ugc nofollow" target="_blank">两个</a>之后，我也很难说出<strong class="ju hv">到底是如何悬疑的。</strong></p><p id="ca75" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">因此，我戴上了计算机科学的帽子，决定尝试用React v16的当前版本重新创建它。</p><p id="75db" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">在我们开始之前，我虚构的法律团队想回避一些免责声明。</p><p id="5eb5" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">React将发布的悬疑的实际版本比这个聚合填充中的版本更加复杂和高效。本教程&amp;附带模块主要用于学习和实验目的。此外，目前的polyfill可能无法很好地与SSR配合使用。</p><p id="f311" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Here_be_dragons" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hv">龙嗝！</strong> </a></p><blockquote class="ku kv kw"><p id="67f2" class="js jt kx ju b jv kp jx jy jz kq kb kc ky kr kf kg kz ks kj kk la kt kn ko jr hn dt translated">如果你只关心代码，看看<a class="ae jg" href="https://github.com/transitive-bullshit/react-suspense-polyfill" rel="noopener ugc nofollow" target="_blank"><strong class="ju hv">react-suspension-poly fill</strong></a>，否则就来吧！</p></blockquote><h1 id="d1c2" class="lb lc hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">搭建舞台</h1><p id="130a" class="pw-post-body-paragraph js jt hu ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko jr hn dt translated">IMHO，悬念是对核心React API surface的一个非常强大的补充，我相信它将对几年后如何编写务实的React代码产生深远的影响。</p><p id="6381" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">如果您没有从这篇文章中获得任何其他东西，请理解这一点:</p><blockquote class="jh"><p id="b5bf" class="ji jj hu bd jk jl me mf mg mh mi jr ek translated">React Suspense的核心是允许一个异步组件从它的<code class="eh mj mk ml mm b">render</code>方法抛出一个承诺。</p></blockquote><p id="fbdb" class="pw-post-body-paragraph js jt hu ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko jr hn dt translated">这个polyfill通过在<a class="ae jg" href="https://github.com/transitive-bullshit/react-suspense-polyfill/blob/master/src/timeout.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hv">超时</strong> </a>组件中实现一个<a class="ae jg" href="https://github.com/transitive-bullshit/react-suspense-polyfill/blob/master/src/timeout.js#L24" rel="noopener ugc nofollow" target="_blank">错误边界</a>来模仿React对此行为的内部支持。如果错误边界遇到一个抛出的承诺，它会等待，直到该承诺解决，然后尝试重新呈现其子级。如果承诺需要很长时间来解决，它还处理回退到加载内容。(详细解释如下)</p><p id="6072" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">我希望这个模块和附带的演示能让你更容易跟上React悬念的发展。😄</p><h1 id="abad" class="lb lc hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">做出反应。占位符</h1><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="7cf3" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated"><strong class="ju hv">占位符</strong>是React悬念暴露的主要面向公众的组件。它的界面相对简单，公开了以下属性:</p><ul class=""><li id="d732" class="mt mu hu ju b jv kp jz kq kd mv kh mw kl mx jr my mz na nb dt translated"><code class="eh mj mk ml mm b">delayMs</code> -显示回退/加载内容前等待的时间(毫秒)。在显示回退内容之前添加延迟的主要原因是为了防止在主异步内容加载之前加载指示器闪烁过快，这可能会干扰用户界面。</li><li id="34e4" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr my mz na nb dt translated"><code class="eh mj mk ml mm b">fallback</code> -一个React节点，在 <code class="eh mj mk ml mm b">delayMs</code>过去后，只有 <em class="kx">有子组件加载<em class="kx">时才会显示。这通常是某种类型的装载旋转器。</em></em></li><li id="7d6d" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr my mz na nb dt translated"><code class="eh mj mk ml mm b">suspense</code> -在 <code class="eh mj mk ml mm b">delayMs</code>过去之前 <em class="kx">加载<em class="kx">任何子组件时将显示的React节点。注意:这个可选道具是react-suspension-poly fill专用的，严格来说是为了演示悬念是如何工作的。</em></em></li><li id="cda5" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr my mz na nb dt translated"><code class="eh mj mk ml mm b">children</code> -一个React节点，表示这个占位符组件的主要内容，在加载异步资源时可能会也可能不会抛出承诺。参见<a class="ae jg" href="https://github.com/palmerhq/react-async-elements" rel="noopener ugc nofollow" target="_blank"> react-async-elements </a>获得一些超级性感的、异步友好的子组件的例子。</li></ul><p id="4c61" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated"><strong class="ju hv">占位符</strong>是你最有可能在代码中使用的组件，但是本着理解它如何工作的精神，大部分复杂性由<strong class="ju hv">超时</strong>处理。</p><h1 id="855b" class="lb lc hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">做出反应。超时</h1><figure class="mn mo mp mq fq iv"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="8e7f" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated"><strong class="ju hv">超时</strong>组件有点复杂，所以让我们一步一步地分析发生了什么:</p><ol class=""><li id="0c6f" class="mt mu hu ju b jv kp jz kq kd mv kh mw kl mx jr nh mz na nb dt translated"><code class="eh mj mk ml mm b">render</code>方法(第50行)将首先调用它的<code class="eh mj mk ml mm b">children</code>呈现函数，该函数带有一个布尔值，表示自从安装和遇到异步工作负载以来，该组件是否达到了超时<code class="eh mj mk ml mm b">ms</code>。</li><li id="8a46" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr nh mz na nb dt translated">如果<code class="eh mj mk ml mm b">children</code>渲染成功，一切正常，React继续正常运行。😃</li><li id="9638" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr nh mz na nb dt translated">如果<code class="eh mj mk ml mm b">children</code>子树<strong class="ju hv">中的任何组件从其<code class="eh mj mk ml mm b">render</code>方法抛出一个承诺</strong>，它将被超时的错误边界<code class="eh mj mk ml mm b">componentDidCatch</code>捕获(第24行)。</li><li id="c4e9" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr nh mz na nb dt translated">错误处理程序首先为这个异步工作启动一个超时(第28行)，这样当<code class="eh mj mk ml mm b">ms</code>超时到期时，超时将返回到显示加载内容。</li><li id="02f0" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr nh mz na nb dt translated">在这个承诺可能到期之前的<code class="eh mj mk ml mm b">ms</code>时间内，<code class="eh mj mk ml mm b">Timeout</code>是<strong class="ju hv">【暂挂】</strong>(第29行和第63行)，这基本上意味着我们正在等待加载一些资源，但是还没有花费足够长的时间来证明显示回退/加载内容是正确的。</li><li id="4acf" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr nh mz na nb dt translated">一旦承诺解决(第43行)，超时再次调用它的<code class="eh mj mk ml mm b">children</code>呈现属性(第39行),期望这一次，初始异步资源将同步解决<strong class="ju hv">和</strong>,世界将再次变得美好。😃</li></ol><p id="aa8e" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">注意，一个子树完全可能包含多个独立的异步资源，在这种情况下，<strong class="ju hv"> Timeout </strong>组件可能会对每个需要解析的异步资源重复步骤3-6一次。或者，<strong class="ju hv">占位符</strong> &amp; <strong class="ju hv">超时</strong>可以像任何React组件一样嵌套，因此完全有可能更高级别的<strong class="ju hv">超时</strong>不需要处理在React组件树中被抛出的异步请求，如果该请求被更接近其来源的超时捕获。这非常接近React错误边界的公共行为。</p><p id="c3c6" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">希望<strong class="ju hv">占位符</strong>和底层<strong class="ju hv">超时</strong>组件现在在预期行为方面更加具体。</p><p id="0426" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">99%的时间你将使用一个简单的<strong class="ju hv">占位符</strong>组件，并忽略<strong class="ju hv">超时</strong>中的这些细节，但是我相信拥有这种更深层次的心智模型是非常有益和强大的，因为React Suspense支持这种从根本上改变游戏规则的模式。</p><p id="04bd" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">记住这一点，让我们谈一谈这个基本的心智模型与极具天赋的React核心团队正在炮制的官方版本有何不同！</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/2de3354dc300a53914b4cb8f092d31a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IqyWMCz8XRw8CoPYdWG2Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Subtrees upon subtrees upon trees. (Image Credit: <a class="ae jg" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a>)</figcaption></figure><h1 id="d811" class="lb lc hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">对比官方反应悬念</h1><p id="375a" class="pw-post-body-paragraph js jt hu ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko jr hn dt translated">这个<a class="ae jg" href="https://github.com/transitive-bullshit/react-suspense-polyfill" rel="noopener ugc nofollow" target="_blank"> polyfill </a>与即将正式实现的React suspension相比，有两个主要的局限性。</p><h2 id="292b" class="nj lc hu bd ld nk nl nm lh nn no np ll kd nq nr lp kh ns nt lt kl nu nv lx nw dt translated">正确性</h2><p id="916d" class="pw-post-body-paragraph js jt hu ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko jr hn dt translated">好吧，我们可能有一点作弊😉在多填充正确行为方面，我们在实现中忽略了一个重要的细节。</p><p id="93fc" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">你能猜出它是什么吗？</p><p id="fa40" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">如果你不确定，那也没关系。在我意识到<a class="nx ny gr" href="https://medium.com/u/a3a8af6addc1?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>指出了这种方法的一个潜在缺陷之前，我已经完成了整个编码练习，所以如果你一无所获，不要担心…</p></div><div class="ab cl nz oa hc ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="hn ho hp hq hr"><p id="b097" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">这种方法的一个潜在的正确性问题(据我所知)是，一旦抛出错误，React就会卸载<strong class="ju hv">超时</strong>子树，这有一个意想不到的副作用，即每次抛出或解析异步资源时，都会重置所有子树组件及其状态。</p><p id="f9b5" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">React的悬念内部实现不会受到这个问题的影响，因为它们完全控制跟踪组件状态，因此可以确保在解析悬念资源后，部分呈现的子树被正确恢复。</p><p id="9b2e" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">然而，这里的好消息是，这在很大程度上是一种边缘情况，根据经验，我认为这不会经常发生。只要你遵循95%的用例，其中占位符<strong class="ju hv">的直接子元素</strong>是唯一潜在的异步子组件，并且<em class="kx">异步子组件急切地预先加载所有异步状态</em>，而不是说，响应用户交互，你就不会遇到任何问题。👍</p><p id="61b0" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">实际上，我很好奇React core实施这一限制是否有意义…</p><h2 id="c3b9" class="nj lc hu bd ld nk nl nm lh nn no np ll kd nq nr lp kh ns nt lt kl nu nv lx nw dt translated">效率</h2><p id="ce25" class="pw-post-body-paragraph js jt hu ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko jr hn dt translated">这是React悬念的用户实现无法接近官方核心实现的地方。否则，我肯定React团队会考虑在React上实现这种模式，而不是扩展核心React API表面。</p><p id="96ef" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">特别是，React团队在过去一年左右的时间里做了大量工作，以实现更智能地重用部分渲染，以及暂停低优先级更新以支持更高优先级更新的能力，这些更新更接近于影响用户对应用程序响应性的感知。</p><p id="e6ca" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">这项工作被统称为React Fiber，React悬念应该被视为React core中启用的第一个主要优化之一，这是React Fiber建立的惊人基础的直接结果。</p><p id="fb01" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">感谢<a class="nx ny gr" href="https://medium.com/u/62e7de0d6312?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">塞巴斯蒂安·马克伯格</a>、<a class="nx ny gr" href="https://medium.com/u/6025bd347b9a?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">安德鲁·克拉克</a>、<a class="nx ny gr" href="https://medium.com/u/a3a8af6addc1?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>、<a class="nx ny gr" href="https://medium.com/u/b610e3f3fee2?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">索菲·阿尔珀特</a>，以及React团队的其他成员和贡献者在这一领域的工作！</p><h2 id="5830" class="nj lc hu bd ld nk nl nm lh nn no np ll kd nq nr lp kh ns nt lt kl nu nv lx nw dt translated">和睦相处</h2><p id="f505" class="pw-post-body-paragraph js jt hu ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko jr hn dt translated">该聚合填充目前不支持React <code class="eh mj mk ml mm b">v15</code>，因为在React <code class="eh mj mk ml mm b">v16</code>之前错误边界不被正确支持。如果你有关于如何添加对React <code class="eh mj mk ml mm b">v15</code>的支持的想法，请提交一个<a class="ae jg" href="https://github.com/transitive-bullshit/react-suspense-polyfill/issues" rel="noopener ugc nofollow" target="_blank">问题</a>让我们一起讨论！</p><p id="822d" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">请注意，React将在使用此聚合填充时记录一个关于抛出错误的控制台错误，但是<em class="kx">可以安全地忽略此控制台消息</em>。不幸的是，对于这些类型的有意用例，没有办法<a class="ae jg" href="https://github.com/facebook/react/issues/11098" rel="noopener ugc nofollow" target="_blank">禁用</a>该错误报告。:感叹:</p><h1 id="bb1a" class="lb lc hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">包扎</h1><p id="b483" class="pw-post-body-paragraph js jt hu ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko jr hn dt translated">如果你已经读到这里，请查看完整的源代码和⭐️回购，以示感谢！</p><p id="2a6b" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">我真的希望这篇文章对你有所帮助。如果你是React迷，这里有一些相关链接:</p><ul class=""><li id="a418" class="mt mu hu ju b jv kp jz kq kd mv kh mw kl mx jr my mz na nb dt translated"><a class="ae jg" rel="noopener" href="/@pete_gleeson/creating-suspense-in-react-16-2-dcf4cb1a683f">在v16.2 </a>中制造React悬念——<a class="nx ny gr" href="https://medium.com/u/ba66bcf17eeb?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">皮特·格里森</a>的类似实验。</li><li id="e5a7" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr my mz na nb dt translated"><a class="ae jg" href="https://github.com/palmerhq/react-suspense-starter" rel="noopener ugc nofollow" target="_blank">react-suspension-starter</a>-备选方案，捆绑了一个预建版本的悬疑启用React，允许您尝试React悬疑右喵。由<a class="nx ny gr" href="https://medium.com/u/fb7a3c353cc1?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">贾里德·帕尔默</a>。</li><li id="570f" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr my mz na nb dt translated"><a class="ae jg" href="https://github.com/palmerhq/react-async-elements" rel="noopener ugc nofollow" target="_blank"> react-async-elements </a> -针对常见情况的悬念友好型异步react元素。由<a class="nx ny gr" href="https://medium.com/u/fb7a3c353cc1?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank">贾里德·帕尔默</a>。</li><li id="cfdf" class="mt mu hu ju b jv nc jz nd kd ne kh nf kl ng jr my mz na nb dt translated"><a class="ae jg" href="https://github.com/sw-yx/fresh-async-react" rel="noopener ugc nofollow" target="_blank">新鲜-异步-反应</a> -更多悬念的东西(代码、演示和讨论)。通过<a class="nx ny gr" href="https://medium.com/u/547f259e265e?source=post_page-----f1c7baf18ca1--------------------------------" rel="noopener" target="_blank"> Swyx </a>。</li></ul><p id="13f9" class="pw-post-body-paragraph js jt hu ju b jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl kt kn ko jr hn dt translated">有没有我漏掉的想法？请在评论中告诉我！❤️</p></div><div class="ab cl nz oa hc ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="hn ho hp hq hr"><h2 id="4a80" class="nj lc hu bd ld nk nl nm lh nn no np ll kd nq nr lp kh ns nt lt kl nu nv lx nw dt translated">在你走之前…</h2><p id="e375" class="pw-post-body-paragraph js jt hu ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko jr hn dt translated"><em class="kx">如果您喜欢这篇文章，请点击👏下面，并与他人分享，这样他们也可以享受它。</em></p></div></div>    
</body>
</html>