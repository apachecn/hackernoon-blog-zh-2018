<html>
<head>
<title>Machine Learning Model Pipelines: Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习模型管道:第一部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/machine-learning-model-pipelines-part-i-e138b7a7c1ef?source=collection_archive---------7-----------------------#2018-08-31">https://medium.com/hackernoon/machine-learning-model-pipelines-part-i-e138b7a7c1ef?source=collection_archive---------7-----------------------#2018-08-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/2732c9a78a1f7b75ab3530697c89602b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mlw91giWi_OKqvdk"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/@worldsbetweenlines?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Patrick Hendry</a> on <a class="ae ih" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="7fa5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">人工智能系统正从开发和测试转向生产。在本质上，人工智能系统只是简单的计算，因此远程部署系统可以提供远程计算。如果该系统涉及多个计算步骤，那么通过将该计算作为可以组合的可组合块来提供，可以获得许多优势。</p><p id="00bd" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我正在描述一个通常被称为<strong class="jj il">管道</strong>的概念。你把每一点计算打包成一个组件。然后，您按顺序通过多个组件发送数据。管道可能是非常有价值的部署工具。它们允许我们重用少量的计算，使我们的架构更加灵活，允许我们灵活地响应新的需求。</p><p id="3fa4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章分为两部分。第一篇(你现在正在阅读的)用一个具体的例子解释了构建机器学习管道的方法。<a class="ae ih" rel="noopener" href="/@vishvananda/machine-learning-model-pipelines-part-ii-23ebd1e6b714">的第二部分</a>深入探讨了用<a class="ae ih" href="https://oracle.github.io/graphpipe" rel="noopener ugc nofollow" target="_blank"> GraphPipe </a>实现不同架构的所有精彩细节，包括一个现实世界示例的实现。</p><h2 id="795b" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">为什么是管道？</h2><p id="1350" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">构建管道提供了许多与软件开发中解耦相同的优势。这些优势包括:</p><ol class=""><li id="b21a" class="lf lg ik jj b jk jl jo jp js lh jw li ka lj ke lk ll lm ln dt translated"><strong class="jj il">灵活性:</strong>计算单位很容易替换。如果您发现一个块有更好的实现，您可以替换它而不改变系统的其余部分。</li><li id="fdfd" class="lf lg ik jj b jk lo jo lp js lq jw lr ka ls ke lk ll lm ln dt translated"><strong class="jj il">可伸缩性:</strong>每一点计算都通过一个公共接口公开。如果任何部分成为瓶颈，您可以独立地扩展该组件。常见的扩展技术可能涉及负载平衡器或额外的后端。</li><li id="8ce5" class="lf lg ik jj b jk lo jo lp js lq jw lr ka ls ke lk ll lm ln dt translated"><strong class="jj il">可扩展性:</strong>当系统被分成有意义的部分时，它为新功能创建了自然的扩展点。</li></ol><p id="89c9" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj il">上等图像识别</strong></p><p id="a4fe" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过一个具体的例子，流水线操作变得更加清晰。让我们讨论如何构建一个示例应用程序的后端。我们的示例应用程序是<strong class="jj il"> Classy </strong>，<strong class="jj il"> </strong>一个对图像进行分类的移动应用程序。该应用程序允许用户选择一个或多个图像，并确定每个图像的类别。它还允许用户输入一个或多个URL来从web上获取图像的分类。我们的目标用户是使用旧手机和有限移动带宽的用户，所以我们的大部分计算必须在服务器端完成。我们将设计(和管道！)上等的服务器组件。</p><p id="0f62" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于分类，我们将使用古老的VGG模型(几年前赢得ImageNet竞赛的卷积分类模型)的实现。我们可以从使用GraphPipe服务器部署VGG模型开始。通常，VGG接受浮点值的224x224x3数组形式的图像。此外，它期望通过将图像按BGR顺序(而不是正常的RGB)进行预处理，并通过减去一个常量值(该常量值是该通道在整个ImageNet数据集上的平均值)来对每个通道进行归一化。</p><h2 id="c5f9" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">初始架构</h2><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/ed5598b11d8f159bb414508a4f01af7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/1*Rdd5jItx20TTKbUvsd1E1g.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Classy Initial Architecture</figcaption></figure><p id="9a7e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们系统最简单的架构是在移动端进行预处理。应用程序从内部存储加载图像或从URL下载图像，在内部进行预处理，然后将数据发送到远程VGG进行推断。</p><p id="44f9" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们最初的架构有几个缺点:</p><ol class=""><li id="bd20" class="lf lg ik jj b jk jl jo jp js lh jw li ka lj ke lk ll lm ln dt translated">发送未压缩的像素数据是低效的。一个224x224x3的浮动数组大约是600K。如果我们能直接发送压缩的jpg(几K)或URL(几个字节)就好得多了。</li><li id="8be1" class="lf lg ik jj b jk lo jo lp js lq jw lr ka ls ke lk ll lm ln dt translated">手机上的预处理使用cpu，可能会耗尽电池(不可否认，加载一个jpg并不是处理器密集型的，但人们可以想象更复杂的预处理步骤，这将是一个问题)。</li><li id="b9a8" class="lf lg ik jj b jk lo jo lp js lq jw lr ka ls ke lk ll lm ln dt translated">客户端的预处理将客户端耦合到服务器实现。如果您决定用另一个模型如Inception(它有不同的预处理需求)来代替VGG，您将不得不更新您的客户端代码。</li></ol><p id="4963" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们改进的架构将试图消除这些缺点。</p><h2 id="25f2" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">客户端排序</h2><p id="bad1" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">第一个成功是将预处理器移到服务器端。这将成为一个组件，它接受一个或多个jpg，并为VGG做必要的预处理。注意，我们可以在VGG模型本身中包含预处理，但是保持它的独立性允许其他预处理程序插入后端；例如，我们可能希望支持png或gif。</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/c33c3387d0b7d9914d252b505ef7261f.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*K2RALdl1LY0D3KBF0VzYvw.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Client Sequencing Architecture</figcaption></figure><p id="a76a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的新架构中，Classy加载图像，将其发送给预处理器，然后将结果发送给VGG。我们将这种模式称为<strong class="jj il">客户端排序</strong>。每个模型提供一些计算，客户端依次向每个模型发出远程请求。客户端排序是最灵活的方法:计算可以单独使用，甚至重新排序。</p><p id="15dc" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这个新的体系结构，Classy现在没有特定的逻辑将其与服务器分类实现联系起来。也不需要烧cpu做预处理。不幸的是，带宽要求实际上变得更差了！它现在必须发送和接收比初始架构中更多的数据。我们将在下一次迭代中解决这个问题。</p><h2 id="dcc1" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">服务器排序</h2><p id="37ff" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">比起将数据发送给两个不同的模型，Classy将jpg发送给预处理器，然后让预处理器将数据发送给VGG，检索类，并返回它们，这样效率会高得多。</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/dc40402918b6b43c44b1bdcf80c42744.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/1*chk6FeneITL6ofwn7QqwVA.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Server Sequencing Architecture</figcaption></figure><p id="ad04" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们称这种架构为<strong class="jj il">服务器排序</strong>。这种方法的一个优点是与VGG通信的逻辑隐藏在预处理器之后。就Classy而言，它只与期望jpg并返回类的单个模型进行交互。这是以在预处理器中嵌入与VGG通信的代码为代价的。</p><p id="fd65" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一般来说，服务器排序比客户端排序更有效，特别是当第一个和第二个组件像我们的设计一样物理上很接近的时候。然而，它确实牺牲了一些灵活性。预处理器与VGG紧密耦合。在我们的例子中，这是有意义的，但有时我们更喜欢一些更灵活的东西。</p><h2 id="6828" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">混合测序</h2><p id="e112" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们的系统还有一个低效之处。当我们根据网址对图像进行分类时，我们必须首先下载它们。我们可以使用一个组件来为我们下载图像并将它们传递给预处理器，从而节省带宽。该组件接受一个URL列表，并返回它从预处理器获得的分类。</p><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/b6285b75f31b3cb37b05cb961f593e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*QfDshKofSCYJi1gFDq4bWQ.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Hybrid Sequencing Architecture</figcaption></figure><p id="6b34" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以对这个组件使用服务器排序，但是下载图像并将它们传递给其他组件在许多管道中都是有用的。因此，我们将使用一种叫做杂交测序的改良方法。</p><p id="7170" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种架构中，下载器向预处理器发送数据，就像在服务器排序中一样。不同之处在于，Classy应该提供指定预处理器位置的配置。这使得下载器也可以被其他管道中的其他客户端使用。</p><p id="7fdc" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本质上，客户端发送数据时会附带一条信息:“进行计算，然后将结果发送给位于那里的模型，并将结果返回给我”。这保持了服务器排序的性能，但是恢复了客户端排序的一些灵活性。与客户端排序方法相比，它确实有一些限制。例如，第一个模型的中间结果不能在本地检索和使用。</p><h2 id="10e4" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">把它放在一起</h2><figure class="lu lv lw lx fq hw fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/2bc6b83f68717c300a359919dd15d625.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*IeilMW-Dmuq-L-iu5taU0A.png"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Classy Final Architecture</figcaption></figure><p id="cc82" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将把最后两种排序架构合并成最终架构。Classy需要支持本地图像以及远程URL，所以在这个版本中，Classy可以与下载器或预处理器通信。注意，因为我们使用标准协议进行远程通信，所以下载器可以使用与Classy内部使用的预处理器相同的客户端代码。</p><p id="c0e2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种架构很灵活:Classy可以将本地jpg发送给预处理器，也可以将URL发送给下载器。当它与下载器对话时，它发送预处理器的位置作为下一阶段。如果我们决定用一个可替换的实现替换VGG，我们可以简单地替换VGG和预处理器；下载器和客户端不需要改变。</p><p id="1a33" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种架构是可伸缩的:所有的通信都是基于http的GraphPipe。我们可以将模型放在一起进行有效的传输，或者我们可以将负载平衡器和多个后端放在管道中过载的任何部分。</p><p id="cdf1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，这种架构是可扩展的:我们可以添加另一个预处理程序来处理png或gif，并在其背后使用相同的VGG模型。如果我们在请求中提供指向新预处理器的配置，我们甚至可以使用相同的URL下载器。</p><h2 id="1779" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">结论</h2><p id="e751" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">这篇文章使用一个真实的示例应用程序概述了机器学习模型流水线。随着我们看到人工智能系统广泛部署到生产中，流水线将变得更加普遍。本系列的第二部分展示了如何实现上面讨论的三种排序方法，并介绍了Classy的实现。</p></div></div>    
</body>
</html>