<html>
<head>
<title>Advanced Testing in Go - Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go教程中的高级测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/advanced-testing-in-go-tutorial-28b89d3a813?source=collection_archive---------8-----------------------#2018-08-31">https://medium.com/hackernoon/advanced-testing-in-go-tutorial-28b89d3a813?source=collection_archive---------8-----------------------#2018-08-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="afaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">欢迎各位编码员！在这个<a class="ae jp" href="https://hackernoon.com/tagged/tutorial" rel="noopener ugc nofollow" target="_blank">教程</a>中，我们将看看Go语言开发者在官方<a class="ae jp" href="https://hackernoon.com/tagged/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a> /go repo中使用的一些更高级的测试实践。</p><p id="1434" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我觉得这种实际研究生产系统中所做的事情的方法，将有望给你一些关于测试你自己的生产级围棋程序的最佳方法的见解。</p><blockquote class="jq jr js"><p id="8c85" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><em class="hu">如果你刚刚开始测试你的基于围棋的程序，那么我建议你看看我的另一个教程:</em> <a class="ae jp" href="https://tutorialedge.net/golang/intro-testing-in-go/" rel="noopener ugc nofollow" target="_blank"> <em class="hu">围棋测试介绍</em> </a></p></blockquote><h1 id="988c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">视频教程</h1><p id="3b2e" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">本教程有视频格式。如果你希望支持我和我的内容，那么请喜欢和订阅！:D</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><h1 id="ed5e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">用表格驱动测试实现良好的覆盖率</h1><p id="4227" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">让我们从<code class="eh lh li lj lk b">strings</code>包开始我们的旅程。如果您看一下<code class="eh lh li lj lk b">src/strings/</code>中的<code class="eh lh li lj lk b">strings_test.go</code>文件的顶部，您应该会看到许多已定义和填充的数组。</p><p id="cf63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，看看<code class="eh lh li lj lk b">lastIndexTests</code>，它是一个<code class="eh lh li lj lk b">IndexTest</code>类型的数组:</p><pre class="la lb lc ld fq ll lk lm ln aw lo dt"><span id="e046" class="lp jy hu lk b fv lq lr l ls lt">var lastIndexTests = []IndexTest{<br/>	{"", "", 0},<br/>	{"", "a", -1},<br/>	{"", "foo", -1},<br/>	{"fo", "foo", -1},<br/>	{"foo", "foo", 0},<br/>	{"foo", "f", 0},<br/>	{"oofofoofooo", "f", 7},<br/>	{"oofofoofooo", "foo", 7},<br/>	{"barfoobarfoo", "foo", 9},<br/>	{"foo", "", 3},<br/>	{"foo", "o", 2},<br/>	{"abcABCabc", "A", 3},<br/>	{"abcABCabc", "a", 6},<br/>}</span></pre><p id="24de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该数组用于测试<code class="eh lh li lj lk b">strings.go</code>文件中的<code class="eh lh li lj lk b">LastIndex</code>函数，其中包含大量的正负情况。这些<code class="eh lh li lj lk b">IndexTest</code>元素中的每一个都有一个标准的<code class="eh lh li lj lk b">string</code>、一个分隔符和一个<code class="eh lh li lj lk b">out</code>整数值，并有一个如下所示的<code class="eh lh li lj lk b">struct</code>:</p><pre class="la lb lc ld fq ll lk lm ln aw lo dt"><span id="e352" class="lp jy hu lk b fv lq lr l ls lt">type IndexTest struct {<br/>	s   string<br/>	sep string<br/>	out int<br/>}</span></pre><p id="a907" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后这些测试由<code class="eh lh li lj lk b">TestLastIndex()</code>函数触发，该函数运行所有这些测试用例，并检查从<code class="eh lh li lj lk b">lastIndex</code>函数返回的结果是否与数组中列出的预期结果相匹配。</p><p id="3ef5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于许多不同的函数，这种相同的做法被重复了许多次，这有助于保证当对这些函数进行任何代码更改时，预期的功能不会改变。</p><h1 id="a303" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">使用testdata目录</h1><p id="84fb" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">在某些情况下，您不能像上面的例子那样将预期的输入和输出指定为一个元素数组。您可能正在尝试测试如何在文件系统上读写文件，或者如何解析专有数据格式等等。</p><p id="a881" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果是这种情况，那么一个选择是创建一个<code class="eh lh li lj lk b">testdata</code>目录，并在该目录中存储测试可能需要的任何文件。</p><p id="260d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh lh li lj lk b">src/archive/tar/</code>下的标准库中可以再次找到一个很好的例子，其中定义了一个<code class="eh lh li lj lk b">testdata/</code>目录，并包含许多随后用于测试的<code class="eh lh li lj lk b">.tar</code>文件。</p><p id="2f91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这些文件的一些相当复杂的测试例子可以在<code class="eh lh li lj lk b">reader_test.go</code>文件中找到。</p><pre class="la lb lc ld fq ll lk lm ln aw lo dt"><span id="ccec" class="lp jy hu lk b fv lq lr l ls lt">func TestReader(t *testing.T) {<br/>	vectors := []struct {<br/>		file    string    // Test input file<br/>		headers []*Header // Expected output headers<br/>		chksums []string  // MD5 checksum of files, leave as nil if not checked<br/>		err     error     // Expected error to occur<br/>	}{{<br/>		file: "testdata/gnu.tar",<br/>		headers: []*Header{{<br/>			Name:     "small.txt",<br/>			Mode:     0640,<br/>			Uid:      73025,<br/>			Gid:      5000,<br/>			Size:     5,<br/>			ModTime:  time.Unix(1244428340, 0),<br/>			Typeflag: '0',<br/>			Uname:    "dsymonds",<br/>			Gname:    "eng",<br/>			Format:   FormatGNU,<br/>		}, {<br/>			Name:     "small2.txt",<br/>			Mode:     0640,<br/>			Uid:      73025,<br/>			Gid:      5000,<br/>			Size:     11,<br/>			ModTime:  time.Unix(1244436044, 0),<br/>			Typeflag: '0',<br/>			Uname:    "dsymonds",<br/>			Gname:    "eng",<br/>			Format:   FormatGNU,<br/>		}},<br/>		chksums: []string{<br/>			"e38b27eaccb4391bdec553a7f3ae6b2f",<br/>			"c65bd2e50a56a2138bf1716f2fd56fe9",<br/>		},<br/>  }, <br/>  // more test cases</span></pre><p id="a99f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的函数中，您将看到核心开发人员将我们在这里介绍的第一种技术与来自<code class="eh lh li lj lk b">testdata/</code>目录的文件相结合，以确保当一个示例<code class="eh lh li lj lk b">.tar</code>文件被打开时，这些文件及其校验和符合他们的期望。</p><h1 id="5ab2" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">模仿HTTP请求</h1><p id="64f3" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">一旦您开始编写生产级API和服务，您很可能会开始与其他服务交互，并且能够测试您与这些服务交互的方式与测试您代码库的其他部分一样重要。</p><p id="964f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，您可能会与在数据库上执行CRUD操作的REST APIs进行交互，因此，当您只是试图测试工作正常时，您不希望这些更改实际提交到您的数据库中。</p><p id="1c86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，为了解决这个问题，我们可以使用<code class="eh lh li lj lk b">net/http/httptest</code>包来模拟HTTP响应，这是我们在这些情况下最好的朋友。</p><pre class="la lb lc ld fq ll lk lm ln aw lo dt"><span id="df5e" class="lp jy hu lk b fv lq lr l ls lt">package main_test<br/><br/>import (<br/>	"fmt"<br/>	"io"<br/>	"io/ioutil"<br/>	"net/http"<br/>	"net/http/httptest"<br/>	"testing"<br/>)<br/><br/>func TestHttp(t *testing.T) {<br/>  // <br/>	handler := func(w http.ResponseWriter, r *http.Request) {<br/>    // here we write our expected response, in this case, we return a<br/>    // JSON string which is typical when dealing with REST APIs<br/>		io.WriteString(w, "{ \"status\": \"expected service response\"}")<br/>	}<br/><br/>	req := httptest.NewRequest("GET", "https://tutorialedge.net", nil)<br/>	w := httptest.NewRecorder()<br/>	handler(w, req)<br/><br/>	resp := w.Result()<br/>	body, _ := ioutil.ReadAll(resp.Body)<br/>haha<br/>	fmt.Println(resp.StatusCode)<br/>	fmt.Println(resp.Header.Get("Content-Type"))<br/>	fmt.Println(string(body))<br/>}</span></pre><p id="2e9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的测试案例中，我们基本上覆盖了我们期望的来自URL的响应，然后继续测试依赖于该响应的系统的其他部分。</p><h1 id="a88e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">独立包装的使用</h1><p id="e7fd" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">如果我们看一下<code class="eh lh li lj lk b">strings_test.go</code>文件并检查顶部的包，你应该注意到它不在<code class="eh lh li lj lk b">strings.go</code>文件所在的包中。</p><p id="9bfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这其中的原因？它帮助您避免循环导入。在某些场景中，您需要在您的<code class="eh lh li lj lk b">*_test.go</code>文件中导入一个包来充分地编写您的测试。如果您在中导入的包已经引用了您正在尝试测试的包，您可能会看到循环依赖关系的问题。</p><h1 id="2aaa" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">区分您的单元测试和集成测试</h1><blockquote class="jq jr js"><p id="bed1" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><em class="hu">我最初是从</em><a class="ae jp" rel="noopener" href="/@povilasve/go-advanced-tips-tricks-a872503ac859"><em class="hu">Go Advanced Tips Tricks</em></a>找到这个技巧的</p></blockquote><p id="3410" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你正在为大型企业Go系统编写测试，那么你将很有可能拥有一组既有<code class="eh lh li lj lk b">integration</code>又有<code class="eh lh li lj lk b">unit</code>的测试来确保你的系统的有效性。</p><p id="8adf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，通常情况下，你会发现你的集成测试比你的单元测试运行的时间要长得多，因为它们可能会影响到其他系统。</p><p id="9874" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，将您的集成测试放到<code class="eh lh li lj lk b">*_integration_test.go</code>文件中，并将<code class="eh lh li lj lk b">// +build integration</code>添加到测试文件的顶部是有意义的:</p><pre class="la lb lc ld fq ll lk lm ln aw lo dt"><span id="b637" class="lp jy hu lk b fv lq lr l ls lt">// +build integration<br/><br/>package main_test<br/><br/>import (<br/>	"fmt"<br/>	"testing"<br/>)<br/><br/>func TestMainIntegration(t *testing.T) {<br/>	fmt.Println("My Integration Test")<br/>}</span></pre><p id="fdb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了运行这套集成测试，您可以像这样调用<code class="eh lh li lj lk b">go test</code>:</p><pre class="la lb lc ld fq ll lk lm ln aw lo dt"><span id="301f" class="lp jy hu lk b fv lq lr l ls lt">➜  advanced-go-testing-tutorial git:(master) ✗ go test -tags=integration<br/>My Integration Test<br/>PASS<br/>ok      _/Users/elliot/Documents/Projects/tutorials/golang/advanced-go-testing-tutorial 0.006s</span></pre><h1 id="f857" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="924a" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">因此，在本教程中，我们看了一些由Go语言维护者使用的更高级的测试技术和技巧。</p><p id="b553" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望您发现这很有用，它给了您继续改进您自己的go测试所需的洞察力。如果你觉得它有用，或者有任何进一步的问题，请不要犹豫，在下面的评论区告诉我！</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="9589" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">最初发表于</em><a class="ae jp" href="https://tutorialedge.net/golang/advanced-go-testing-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a><em class="jt">。</em></p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="mb lg l"/></div></figure></div></div>    
</body>
</html>