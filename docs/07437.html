<html>
<head>
<title>Singleton Object Creation in swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift中的单例对象创建</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/singleton-object-creation-in-swift-b249d2f0d594?source=collection_archive---------8-----------------------#2018-09-01">https://medium.com/hackernoon/singleton-object-creation-in-swift-b249d2f0d594?source=collection_archive---------8-----------------------#2018-09-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7672" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在swift(iOS)中，Singleton类将仅实例化一次，并将在整个应用生命周期内存中。因此，我们可以说，在应用程序生命周期中的任何给定时间点，只使用了singleton对象的一个实例，它提供了从项目中的任何位置访问它的全局访问点。</p><p id="950a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以它有全局访问权，如果在项目中开始使用许多单例对象，那会给我们带来很多麻烦。例如，你有一个单例对象来改变你的应用程序中某个特定屏幕的字体，你不可能知道这个改变是在哪里被触发的(从哪个控制器),你在不同的控制器中分配多个字体给单例对象。这就导致app出现了很多bug。</p><p id="6d70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">单身显然是有原因的，有时候他们是你的最佳选择。如果你需要控制对共享资源的访问，比如应用程序设置或钥匙串，singletons是一个完美的选择。</p><p id="e2b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了不损坏我们的数据，我们需要控制singleton中的写访问。我们可以做到这一点的方法之一是提高调度障碍。调度屏障将确保一段代码被执行，并且当它被执行时，没有其他代码被执行。这一点非常重要。有了这个简单的GCD标志，我们就能解决我们的问题。</p><p id="8ffd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如:</p><blockquote class="jp jq jr"><p id="284e" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">MyClass类{</p><p id="3582" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><em class="hu"> private init() {} </em></p><p id="1df8" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated"><strong class="it hv">public static let shared = my class()</strong></p><p id="50a9" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt translated">func some function(){</p><p id="b8d4" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt">}</p><p id="ea66" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hn dt">}</p></blockquote><p id="ac3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像上面的例子那样创建一个单例是很好的，并且是线程安全的。它将被实例化一次，并将在应用程序生命周期的所有时间内存中。有时候我们不使用它，那么它存在于内存中又有什么用呢？。这种方法的缺点是，即使从未使用过，类get也会加载到内存中。</p><p id="f3ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，在上面的例子中，它有私人初始化器，以限制对象创建，即使是在应用程序的其他部分意外。这确保了我们只有一个实例。</p><p id="bff1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了在需要的时候将单例实例加载到内存中，我们需要使用lazy关键字来创建它。一旦创建，它将驻留在内存中，直到应用程序终止。</p><figure class="jw jx jy jz fq ka"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="00e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设上面的单例对象被两个线程访问，这两个线程稍微一个接一个地运行。在这种情况下，单例对象可能有机会被创建两次。因此，为了解决这种重复或多重创建，我们在创建对象时设置了障碍来停止所有当前正在运行的任务。它可以确保在iOS的多线程环境中，任何情况下都只能在应用程序中创建一个对象。</p><p id="059e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">— — — — — — — — — *********************** — — — — — — — — —</p><p id="40cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢我的教程请关注我的<strong class="it hv"> <em class="js">中</em>、</strong> <a class="ae kd" href="https://twitter.com/Leelakrishn4" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="js">推特</em></strong></a>&amp;<a class="ae kd" href="https://www.linkedin.com/in/leela-prasad-penumutchu-b44023157/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"><em class="js">linkedIn</em></strong></a><strong class="it hv"><em class="js"/></strong>账号</p><p id="cdf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读…</p><p id="d05f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">****************************!！！再见！！！****************************</p></div></div>    
</body>
</html>