<html>
<head>
<title>The practical guide for Building REST API in Nodejs and MongoDB include Passport and JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Nodejs和MongoDB中构建REST API的实用指南包括Passport和JWT</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-practical-guide-for-building-rest-api-in-nodejs-and-mongodb-include-passport-and-jwt-476720b70da0?source=collection_archive---------0-----------------------#2018-09-02">https://medium.com/hackernoon/the-practical-guide-for-building-rest-api-in-nodejs-and-mongodb-include-passport-and-jwt-476720b70da0?source=collection_archive---------0-----------------------#2018-09-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ec2d9016a50ba0870e0ddf2aa6109924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ifQIqoJ2o8UH4YCcZcWcQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">include Passport and JWT</figcaption></figure><p id="b14f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这一课中，我们将用<a class="ae ke" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>和<a class="ae ke" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>数据库开始我们的REST APIs之旅。如果你以前没有Nodejs和MongoDB的经验</p><p id="2985" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">参加这个有助于你快速起步的课程</p><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.922484&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fthe-complete-nodejs-developer-course-2%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">完整的Node.js开发人员课程(第二版)</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">你以前学过Node吗？你开了一门新课程，老师让你安装一堆库…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw ja ki"/></div></div></a></div><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.1000574&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fthe-complete-developers-guide-to-mongodb%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">MongoDB | Udemy开发人员完全指南</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">用测试驱动的方法掌握MongoDB和Mongoose设计</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="kx l kt ku kv kr kw ja ki"/></div></div></a></div><h2 id="df6e" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">为什么是这个教程？</h2><p id="4a33" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">当我开始学习编程时，我在寻找解决问题的方法，并且找到了。但问题是我不知道为什么有些东西在工作的时候会工作，为什么会不工作。我不得不复制别人的源代码，并在不知道为什么的情况下使用它。</p><p id="43c9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">本教程将帮助你浏览所有你可以使用的样板代码，并理解其中的每一部分。</p><h2 id="2621" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">我们会做什么？</h2><p id="b019" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将制作一个非常类似于REST标准的中型网站。我们还将使用以下功能:</p><ul class=""><li id="2bae" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">本地认证+ JWT</li><li id="b28f" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">用户可以创建帖子</li><li id="61f9" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">用户可以删除和更新自己的帖子</li><li id="5344" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">用户可以关注另一个用户的帖子</li><li id="54a5" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">用户收到他所关注的用户发布的帖子的通知</li><li id="d73e" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">用户可以喜欢帖子</li><li id="6c1f" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">用户可以看到他喜欢的所有职位的列表</li></ul><p id="c85f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">听起来很有趣，对吧？让我们看看我们将使用什么来制作这个精彩的应用程序。</p><h2 id="eefc" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">应用的技术堆栈</h2><p id="8832" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将使用Javascript，ES6 + ES7，我们将使用babel和Webpack v2编译我们的源代码。你应该熟悉JS承诺和异步工作。</p><p id="51e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于数据库，我们将使用MongoDB。</p><p id="6b5f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://github.com/krissnawat/nodejs-restapi" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">Github中的所有代码在这里</strong> </a></p><h2 id="2f07" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">设置工具</h2><p id="10a6" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">从本系列的第1部分开始，我们将使用以下工具设置我们的环境:</p><ul class=""><li id="b040" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">编辑器配置</li><li id="2c01" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">表达</li><li id="ef3b" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">埃斯林特</li><li id="d410" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">巴比伦式的城市</li><li id="fb8c" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">网络包2</li></ul><p id="37b8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦我们完成这篇文章，我们将有一个简单的快速服务器启动和运行。我们开始吧！</p><p id="5859" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">只需为您的项目创建一个新目录。我把它叫做<em class="mm">’</em><code class="eh mn mo mp mq b"><em class="mm">makenodejsrestapi</em></code><em class="mm">’</em>。我将使用<code class="eh mn mo mp mq b"><a class="ae ke" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank">yarn</a></code>包来安装我的工具。在目录中，我们首先创建一个名为'的新文件。gitignore '并添加以下内容:</p><p id="d10d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">node_modules/</code></p><p id="502f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们将通过运行以下命令来初始化我们的项目:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="9e97" class="ky kz hu mq b fv mz na l nb nc">yarn init</span></pre><p id="187c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你会被问到各种各样的问题，我只是按下回车键，让<code class="eh mn mo mp mq b">yarn</code>取默认值。一旦该命令完成其工作，您将在项目目录中看到一个名为<code class="eh mn mo mp mq b"><em class="mm">package.json</em></code>的新文件，其内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="3b38" class="ky kz hu mq b fv mz na l nb nc">{ <br/> “name”: “makenodejsrestapi”, <br/> “version”: “1.0.0”, <br/> “main”: “index.js”, <br/> “license”: “MIT” <br/>}</span></pre><p id="62cc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个文件只包含我们项目的元数据。接下来，我们将开始在我们的项目中添加express。接下来运行以下命令:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="da11" class="ky kz hu mq b fv mz na l nb nc">yarn add express</span></pre><p id="88f0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果这个包裹最初没有被发现，<em class="mm">纱</em>会花一些时间来找到它，但它肯定会。一旦命令运行完毕，我们的<em class="mm"> package.json </em>将会更新如下内容:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/cbe7c115737000bf3fff6f8e11ae3a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*s9cJoh4HWlp05UXC"/></div></figure><p id="88e0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们在项目中创建一个名为src的新目录，并在其中创建一个名为index.js的新文件。放入以下内容:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="cc69" class="ky kz hu mq b fv mz na l nb nc">import express from 'express';<br/> const app = express();<br/> const PORT = process.env.PORT || 3000;<br/> app.listen(PORT, err =&gt; {<br/>     if (err) {<br/>         throw err;<br/>     } else {<br/>         console.log(Server running on port: $ {<br/>             PORT<br/>         }-- - Running on $ {<br/>             process.env.NODE_ENV<br/>         }-- - Make something great!)<br/>     }<br/> });</span></pre><p id="98bf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意，如果没有在环境变量中设置端口，我们将使用端口3000。现在，我们将在package.json文件中添加一个“脚本”,这样我们就可以在运行我们的using babel时使用dev profile。以下是修改后的文件:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/8a439cfe9dbb212b2e61e786ce295c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/0*QAj0S75VKrJRvdkE"/></div></figure><p id="531e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，用这个命令安装cross-env with yarn:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="ee40" class="ky kz hu mq b fv mz na l nb nc">yarn add cross-env</span></pre><p id="7df1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是更新后的package.json文件:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="2b8f" class="ky kz hu mq b fv mz na l nb nc">{<br/>     "name": "makenodejsrestapi",<br/>     "version": "1.0.0",<br/>     "main": "index.js",<br/>     "license": "MIT",<br/>     "scripts": {<br/>         "dev": "NODE_ENV=development node src/index.js"<br/>     },<br/>     "dependencies": {<br/>         "cross-env": "^5.1.3",<br/>         "express": "^4.16.2"<br/>     }<br/> }</span></pre><p id="ce59" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在我们可以用这个命令添加babel依赖项:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="f067" class="ky kz hu mq b fv mz na l nb nc">yarn add -D babel-preset-env babel-plugin-transform-object-rest-spread</span></pre><p id="9fd3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">运行该命令后，您可以创建一个名为。你可以在其中提供应用程序的环境和插件信息。这是我们接下来要做的:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="97d0" class="ky kz hu mq b fv mz na l nb nc">{<br/>     "presets": [<br/>         ["env", {<br/>             "targets": {<br/>                 "node": "current"<br/>             }<br/>         }]<br/>     ],<br/>     "plugins": [<br/>         ["transform-object-rest-spread", {<br/>             "useBuiltIns": true<br/>         }]<br/>     ]<br/> }</span></pre><p id="19fb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">transform-object-rest-spread插件用于为对象析构赋值转换rest属性。现在，我们也将使用webpack 2:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="478e" class="ky kz hu mq b fv mz na l nb nc">yarn add -D webpack babel-core babel-loader webpack-node-externals</span></pre><p id="a720" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，我们将配置webpack，并在上面添加了它的依赖项:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="caa3" class="ky kz hu mq b fv mz na l nb nc">const nodeExternals = require('webpack-node-externals');<br/> const path = require('path');<br/> module.exports = {<br/>     target: 'node',<br/>     externals: [nodeExternals()],<br/>     entry: {<br/>         'index': './src/index.js'<br/>     },<br/>     output: {<br/>         path: path.join(__dirname, 'dist'),<br/>         filename: '[name].bundle.js',<br/>         libraryTarget: 'commonjs2',<br/>     },<br/>     module: {<br/>         rules: [{<br/>             test: /\.js$/,<br/>             exclude: /node_modules/,<br/>             use: 'babel-loader'<br/>         }]<br/>     }<br/> }</span></pre><p id="3a82" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们也运行我们的package.json脚本:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="c780" class="ky kz hu mq b fv mz na l nb nc">"scripts": { "dev:build": "webpack -w", "dev": "cross-env NODE_ENV=development node dist/index.bundle.js" }</span></pre><p id="a484" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，我们可以运行我们的应用程序:</p><p id="d151" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">用图形来看，下面是我们运行构建时的输出:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/ab258786580c9568c1a8e1f49d4795cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/0*bG6n-GuaNGmSXW6X"/></div></figure><p id="9204" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">注意，我们在上面运行了两个命令:</p><ul class=""><li id="2f97" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">第一个命令只是构建了应用程序并准备了babel build</li><li id="2313" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">第二个命令实际运行请求，您可以在控制台中看到输出</li></ul><p id="85e4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们将最终安装ES Lint:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="c44f" class="ky kz hu mq b fv mz na l nb nc">yarn add -D eslint eslint-config-equimper</span></pre><p id="0077" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，创建一个名为'的新文件。“eslintrc”并增加以下内容:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="2d17" class="ky kz hu mq b fv mz na l nb nc">{ “extends” : “equimper” }</span></pre><p id="f10f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦这样做了，如果您没有遵循正确的ES标准，您将开始收到警告。当您需要为您的项目遵循严格的约定时，这个工具非常有用。</p><h2 id="9257" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">Udemy的一些有趣的节点API</h2><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.1628502&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fajax-api-exercise%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">AJAX API练习加密货币数据应用程序</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">学习AJAX以及如何从节点服务器发出请求。连接到web APIs检索数据并将JSON数据输出到HTML中</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="ng l kt ku kv kr kw ja ki"/></div></div></a></div><h1 id="8847" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">接下来我们将添加什么？</h1><p id="59d3" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">在本节中，我们将设置该应用程序后端所需的更多工具:</p><ul class=""><li id="ba4b" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">添加猫鼬，身体解析器，摩根，压缩，头盔</li><li id="8bf5" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">安装配置文件夹</li><li id="f941" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">设置常数</li></ul><h2 id="9b3a" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">添加猫鼬</h2><p id="0665" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">要将mongoose和其他提到的模块添加到您的应用程序中，请运行以下命令:</p><p id="4889" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">纱线添加猫鼬身体解析压缩头盔&amp;&amp;纱线添加-D摩根</p><p id="f330" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">需要注意的是，我们指定模块的顺序，它们的下载顺序也是一样的。</p><p id="8978" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了确保我们在同一轨道上，下面是我的package.json文件的样子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ny"><img src="../Images/96fa925a19ecc54c0ccf9d90ce674074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2iDhcVve2TdeDEja"/></div></div></figure><p id="119c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们将使用以下命令再次编译我们的项目:</p><p id="d74f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">纱线开发</p><p id="b3dd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">只要确保项目仍在运行。现在，在src文件夹中创建一个新的config文件夹，并创建一个名为constants.js的文件，其内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="0cc1" class="ky kz hu mq b fv mz na l nb nc">const devConfig = {};<br/>const testConfig = {};<br/>const prodConfig = {};<br/>const defaultConfig = {</span><span id="129a" class="ky kz hu mq b fv nz na l nb nc">PORT: process.env.PORT || 3000,<br/>};</span><span id="f666" class="ky kz hu mq b fv nz na l nb nc">function envConfig(env) {<br/>     switch (env) {<br/>         case 'development':<br/>             return devConfig;<br/>         case 'test':<br/>             return testConfig;<br/>         default:<br/>             return prodConfig;<br/>     }<br/> }<br/> <br/> //Take defaultConfig and make it a single object <br/> //So, we have concatenated two objects into one <br/> export default { ...defaultConfig,<br/>     ...envConfig(process.env.NODE_ENV),<br/> };</span></pre><p id="f340" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，回到index.js文件，我们将为这个常量文件添加依赖项，并将对PORT的引用更改为使用这个文件，如下所示:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="c41a" class="ky kz hu mq b fv mz na l nb nc">import express from 'express';<br/>import constants from './config/constants';<br/>const app = express();<br/>app.listen(constants.PORT, err =&gt; {<br/>    if (err) {<br/>        throw err;<br/>    } else {<br/>        console.log(`Server running on port: ${constants.PORT} --- Running on ${process.env.NODE_ENV} --- Make something great.!`)<br/>    }<br/>});</span></pre><p id="d4cf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，在config文件夹中创建一个名为database.js的新文件，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="68ef" class="ky kz hu mq b fv mz na l nb nc">import mongoose from 'mongoose';<br/> import constants from './constants';<br/> <br/> //Removes the warning with promises <br/> mongoose.Promise = global.Promise;<br/> <br/> //Connect the db with the url provided <br/> try {<br/>     mongoose.connect(constants.MONGO_URL)<br/> } catch (err) {<br/>     mongoose.createConnection(constants.MONGO_URL)<br/> }<br/> mongoose.connection.once('open', () =&gt; console.log('MongoDB Running')).on('error', e =&gt; {<br/>     throw e;<br/> })</span></pre><p id="fda3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还在constants.js文件中将mongoose连接的配置修改为:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="8911" class="ky kz hu mq b fv mz na l nb nc">const devConfig = { MONGO_URL: 'mongodb://localhost/makeanodejsapi-dev', }; <br/> const testConfig = { MONGO_URL: 'mongodb://localhost/makeanodejsapi-test', }; <br/> const prodConfig = { MONGO_URL: 'mongodb://localhost/makeanodejsapi-prod', };</span></pre><p id="a4be" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将确保当我们用不同的概要文件和环境运行我们的应用程序时，所使用的数据库是不同的。您可以继续运行该应用程序。</p><p id="dec7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当您在所述端口上运行数据库时，您可以成功地开始使用您的应用程序。</p><h1 id="da51" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">设计中间件</h1><p id="fd0d" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在，我们将开始制作应用程序的中间件。</p><p id="b32b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在config文件夹中，新建一个文件，命名为middleware.js，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="dd17" class="ky kz hu mq b fv mz na l nb nc">import morgan from 'morgan';<br/> import bodyParser from 'body-parser';<br/> import compression from 'compression';<br/> import helmet from 'helmet';<br/> import {<br/>     isPrimitive<br/> } from 'util';<br/> const isDev = process.env.NODE_ENV === 'development';<br/> const isProd = process.env.NODE_ENV === 'production';<br/> export default app =&gt; {<br/>     if (isProd) {<br/>         app.use(compression());<br/>         app.use(helmet());<br/>     }<br/>     app.use(bodyParser.json());<br/>     app.use(bodyParser.urlencoded({<br/>         extended: true<br/>     }));<br/>     if (isDev) {<br/>         app.use(morgan('dev'));<br/>     }<br/> };</span></pre><p id="d53f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要使用这个配置，还需要将导入添加到索引文件，如下所示:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="8869" class="ky kz hu mq b fv mz na l nb nc">import express from 'express';<br/> import constants from './config/constants';<br/> import './config/database';<br/> import middlewareConfig from './config/middleware';<br/> const app = express(); //passing the app instance to middlewareConfig <br/> <br/> middlewareConfig(app);<br/> app.listen(constants.PORT, err =&gt; {<br/>     if (err) {<br/>         throw err;<br/>     } else {<br/>         console.log(`Server running on port: ${constants.PORT} --- Running on ${process.env.NODE_ENV} --- Make something great.!`)<br/>     }<br/> });</span></pre><p id="cf61" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，运行您的应用程序，它应该在端口3000上服务一个GET请求！</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/0434c48ec5a26f3a0734d613e8018173.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/0*eRzm2qeKCV6xLmIc"/></div></figure><h2 id="c6c5" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">Udemy的一些有趣的节点API</h2><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.399220&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fphoto-webapp-instagramapi%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">使用Node.js中的Instagram API构建照片web应用程序</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">使用Instagram API构建照片应用程序！</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="oa l kt ku kv kr kw ja ki"/></div></div></a></div><h1 id="6645" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">注册用户</h1><p id="c202" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">在本节中，我们将使用上节课中的MongoDB设置，并在此基础上构建一个应用程序，允许用户在我们的应用程序中注册。不要错过，我们最新的package.json文件如下所示:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ny"><img src="../Images/9d9f63bf3df34bfcfd50bbb3cf840d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gF1QpFwmxs0b2KFL"/></div></div></figure><p id="6e92" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这一节中，我们将进一步开发允许用户在我们的应用程序上注册的功能。我们还将制作用户模型，以便数据可以保存在数据库中。</p><p id="61ab" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">完成本节后，您将至少拥有以下文件结构:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ob"><img src="../Images/713b42ad3cfb68c21b9a585499c9d37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/0*D3tjs_QLhGbBvgjJ"/></div></figure><p id="55af" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">只需跟随这一课如何变成这样！</p><h1 id="e10a" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">定义模型</h1><p id="2383" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将从制作用户模型开始。为此，在src &gt; modules &gt; users中创建一个新文件，并将其命名为user.model.js，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="0274" class="ky kz hu mq b fv mz na l nb nc">import mongoose, {<br/>     Schema<br/> } from 'mongoose';<br/> import validator from 'validator';<br/> import {<br/>     passwordReg<br/> } from './user.validations';<br/> const UserSchema = new Schema({<br/>     email: {<br/>         type: String,<br/>         unique: true,<br/>         required: [true, 'Email is required!'],<br/>         trim: true,<br/>         validate: {<br/>             validator(email) {<br/>                 return validator.isEmail(email);<br/>             },<br/>             message: '{VALUE} is not a valid email!',<br/>         },<br/>     },<br/>     firstName: {<br/>         type: String,<br/>         required: [true, 'FirstName is required!'],<br/>         trim: true,<br/>     },<br/>     lastName: {<br/>         type: String,<br/>         required: [true, 'LastName is required!'],<br/>         trim: true,<br/>     },<br/>     userName: {<br/>         type: String,<br/>         required: [true, 'UserName is required!'],<br/>         trim: true,<br/>         unique: true,<br/>     },<br/>     password: {<br/>         type: String,<br/>         required: [true, 'Password is required!'],<br/>         trim: true,<br/>         minlength: [6, 'Password need to be longer!'],<br/>         validate: {<br/>             validator(password) {<br/>                 return passwordReg.test(password);<br/>             },<br/>             message: '{VALUE} is not a valid password!',<br/>         },<br/>     },<br/> });<br/> export default mongoose.model('User', UserSchema);</span></pre><p id="3fa9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们刚刚用各种属性定义了用户模型的模式，例如:</p><ul class=""><li id="adf1" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">为用户定义的属性</li><li id="dbe7" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">还提供了关于它们类型的属性、它们的唯一性以及应该如何验证这些数据的元信息</li><li id="46b0" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">请注意，我们也提供了一个验证函数。当我们将数据插入Mongo集合时，这使得事情变得非常容易</li></ul><h2 id="fc9c" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">定义控制器</h2><p id="a008" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在，我们将通过在控制器定义中使用用户模型来使用它。在src &gt; modules &gt; users中创建一个新文件，将其命名为user.controllers.js，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="cb65" class="ky kz hu mq b fv mz na l nb nc">import User from './user.model';<br/> export async function signUp(req, res) {<br/>     try {<br/>         const user = await User.create(req.body);<br/>         return res.status(201).json(user);<br/>     } catch (e) {<br/>         return res.status(500).json(e);<br/>     }<br/> }</span></pre><p id="1681" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们刚刚定义了一个带有请求和响应对象作为参数的注册函数，并使用我们刚刚在上面定义的用户模型创建了它。</p><p id="1353" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还返回了相应的响应及其代码，以便在交易成功时通知用户。</p><h2 id="85b7" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">定义应用程序路线</h2><p id="2128" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将为我们的应用程序定义路由，其中我们可以指定用户必须访问的映射，以查看我们制作的应用程序。在src &gt; modules &gt; users中创建一个新文件，将其命名为user.routes.js，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="a831" class="ky kz hu mq b fv mz na l nb nc">import {<br/>     Router<br/> } from 'express';<br/> import * as userController from './user.controllers';<br/> const routes = new Router();<br/> routes.post('/signup', userController.signUp);<br/> export default routes;</span></pre><p id="e2bd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意，这在上不起作用。我们必须在模块文件夹中定义模块index.js，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="d916" class="ky kz hu mq b fv mz na l nb nc">import userRoutes from './users/user.routes';<br/> export default app =&gt; {<br/>     app.use('/api/v1/users', userRoutes);<br/> };</span></pre><p id="f712" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在我们可以运行我们的应用程序，这将是我们应用程序的第一个版本。我们现在需要对我们的根index.js文件进行最后的修改:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oc"><img src="../Images/e80d9766997da14aebf0ac4bc2f625be.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*v-K621fKR233TJDt"/></div></figure><p id="f97b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是更新的内容:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="3426" class="ky kz hu mq b fv mz na l nb nc">/* eslint-disable no-console */<br/> import express from 'express';<br/> import constants from './config/constants';<br/> import './config/database';<br/> import middlewaresConfig from './config/middlewares';<br/> import apiRoutes from './modules';<br/> const app = express();<br/> middlewaresConfig(app);<br/> app.get('/', (req, res) =&gt; {<br/>     res.send('Hello world!');<br/> });<br/> apiRoutes(app);<br/> app.listen(constants.PORT, err =&gt; {<br/>     if (err) {<br/>         throw err;<br/>     } else {<br/>         console.log(` Server running on port: ${constants.PORT} --- Running on ${process.env.NODE_ENV} --- Make something great `);<br/>     }<br/> });</span></pre><p id="cf93" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，当我们运行应用程序时，我们仍然可以看到我们的应用程序正在运行:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff od"><img src="../Images/7734d7c0d48cd027dd29a8a2797d70e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/0*Fv6ilPWSyzQSlPwB"/></div></figure><h1 id="9894" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">使用MongoDB和Postman</h1><p id="ebdd" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们现在将使用两个必要的工具:</p><ol class=""><li id="6c10" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd oe me mf mg dt translated">Robomongo:在这里下载<a class="ae ke" href="https://robomongo.org/" rel="noopener ugc nofollow" target="_blank"/>。这是一个非常棒的工具，可以可视化Mongo数据并使用它进行查询。也是免费的！这适用于所有操作系统平台。</li><li id="edd5" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd oe me mf mg dt translated">邮递员:在这里下载<a class="ae ke" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank">。它是一个点击API并获得响应的工具。它有很好的可视化功能，你也可以保存请求格式，这样可以节省你很多时间。还是那句话，免费！这适用于所有操作系统平台。</a></li></ol><p id="3479" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当您打开Robomongo并连接到您的本地MongoDB实例时，您可以看到已经为我们呈现的DB:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff of"><img src="../Images/eed49d51782539ed1fa9b89c0307dce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*jVMqG890GBHASaiv"/></div></figure><p id="86ed" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们已经准备好了一个由我们的应用程序制作的系列，它看起来像:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff og"><img src="../Images/59f38f27d4561b13e490646a1e4632f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/0*8jpnc4XxGzUflHgW"/></div></figure><p id="61ad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将是空的，因为我们现在还没有创建任何数据。我们很快就会这样做！</p><h1 id="4393" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">尝试用户注册</h1><p id="652c" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">让我们现在打开邮差。我们将使用此URL访问一个API:</p><p id="507e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="http://localhost:3000/api/v1/users/signup" rel="noopener ugc nofollow" target="_blank">http://本地主机:3000/api/v1/users/signup </a></p><p id="ce97" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在postman中，它看起来像这样:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oh"><img src="../Images/f92f5372cd9eb12579a2f924618e0e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*72Oty7LLTKoCLiA3"/></div></div></figure><p id="6b7d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在使用这个API之前，我们将尝试一个Hello World版本。看看这个API中发生了什么:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oi"><img src="../Images/90143cf7ce77d087e47d788b4bc2178c.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/0*RVeWGycU5bVJv4vd"/></div></figure><p id="d9fe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，回到注册API。在成功命中之前，我们将尝试提供无效值，并查看我们面临的错误。如果电子邮件无效，结果如下:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oj"><img src="../Images/41edd6986c5c7b88a9c53e3482f52321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NW2xUb_IWfyHkfU8"/></div></div></figure><p id="0ade" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们也将尝试使用正确的数据。我们试试吧！</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ok"><img src="../Images/7b55e11e83633eb5450b1f64a70c2842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W4rWrsbMRj8MZRFc"/></div></div></figure><p id="0bb9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">嗯，故事还没有结束。我们还可以看到数据现在被插入到MongoDB数据库中:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ol"><img src="../Images/50c8bc218f92fc1f5e80892825cc4774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*112djiMpMauwGezi"/></div></div></figure><p id="74eb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">太棒了。</p><h2 id="2dfc" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">Udemy的一些有趣的节点API</h2><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.1692166&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fbuilding-an-api-with-node%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">使用Express和MongoDB构建ESM ready Node.js APIs</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">用Node学习API设计。Js、Express和MongoDB应用程序使用最新的ECMAScript模块用于Node。射流研究…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="om l kt ku kv kr kw ja ki"/></div></div></a></div><h1 id="c7ed" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">添加更多验证</h1><p id="6752" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">尽管我们已经在用户模型中添加了一些验证，但是如果我们还想保存在另一个文件中呢！为此，在<code class="eh mn mo mp mq b">src &gt; modules &gt; users </code>处创建一个新文件，并将其命名为user.validations.js，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="9545" class="ky kz hu mq b fv mz na l nb nc">import Joi from 'joi';<br/> export const passwordReg = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}/;<br/> export default {<br/>     signup: {<br/>         email: Joi.string().email().required(),<br/>         password: Joi.string().regex(passwordReg).required(),<br/>         firstName: Joi.string().required(),<br/>         lastName: Joi.string().required(),<br/>         userName: Joi.string().required(),<br/>     },<br/> };</span></pre><p id="f648" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，也在路由器文件中添加这种验证:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="28dd" class="ky kz hu mq b fv mz na l nb nc">import {<br/>       Router<br/>   } from 'express';<br/>   import validate   from 'express-validation';<br/>   import * as   userController from './user.controllers';<br/>   import   userValidation from './user.validations';<br/>   const routes = new Router();<br/>   routes.post('/signup', validate(userValidation.signup),   userController.signUp);<br/>   export default   routes;</span></pre><p id="822a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意:</p><ul class=""><li id="f70b" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">我们从express添加了一个验证导入</li><li id="1b52" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">我们还通过了一个新的注册用户验证功能</li></ul><p id="8f0a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，当我们尝试让用户使用相同的凭据注册时，我们会收到一个错误:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff on"><img src="../Images/6d42d6dea1eeede5e37e07640ddbe780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cesPC1QnIDDbgqIG"/></div></div></figure><p id="e82a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这实际上不是因为验证，而是因为我们试图用相同的电子邮件插入另一个用户。让我们尝试一些不同的东西:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oo"><img src="../Images/6c30a838b05a5cbff5ce6102fd8fdf60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BdYL3f1TRSy0jQe4"/></div></div></figure><p id="4fc8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们可以纠正这一点，并查看MongoDB数据库中出现的数据:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff op"><img src="../Images/88bcec780288ec2ebe8c673ec2cde268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ykPMTNd5EkzFVew8"/></div></div></figure><p id="3f37" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">太棒了。我们能够向我们的项目添加强大的验证。</p><h1 id="8212" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">密码加密和用户登录</h1><p id="e502" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将更多地与我们的用户合作。在上一课中，我们能够保存一个新用户。这种方法的主要问题是用户的密码以纯文本的形式保存。这将是我们现在将在应用程序中进行的更改之一。</p><p id="1a91" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请不要错过，我们最新的<code class="eh mn mo mp mq b">package.json</code>文件如下所示:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oq"><img src="../Images/8c4860a3be7666c79e42bb0a7981a5f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aktBPkIZ-KqsNpVr"/></div></div></figure><p id="ed08" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本课中，我们将进一步开发加密用户密码的功能。除此之外，我们还将做出如下改变:</p><ul class=""><li id="3987" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">在webpack构建中添加rimraf和clean dist</li><li id="a045" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">加密用户的密码</li><li id="0776" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">用passport创建本地策略</li><li id="47b6" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">允许用户登录</li></ul><h2 id="fec4" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">添加rimraf依赖项</h2><p id="2ced" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">首先，我们将使用以下命令在项目中添加rimraf依赖项:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="d7f1" class="ky kz hu mq b fv mz na l nb nc">yarn add -D rimraf</span></pre><p id="2d2f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要再次构建您的项目，请运行以下命令:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="b5f5" class="ky kz hu mq b fv mz na l nb nc">yarn</span></pre><p id="daee" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，让我们也将rimraf添加到package.json文件中:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="05f6" class="ky kz hu mq b fv mz na l nb nc">“scripts”: {<br/> “clean”: “rimraf dist”,<br/> “dev:build”: “yarn run clean &amp;&amp; webpack -w”,<br/> “dev”: “cross-env NODE_ENV=development nodemon dist/index.bundle.js”<br/>}</span></pre><p id="0496" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，运行以下命令:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="0e94" class="ky kz hu mq b fv mz na l nb nc">yarn dev:build</span></pre><p id="f793" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">运行此命令时，dist文件夹将被刷新，并在构建过程完成后返回:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff or"><img src="../Images/5ee9d11cca6324ca9be61e365f5bc189.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/0*grZMe6C6mQWKP_Mi"/></div></figure><h1 id="b6ce" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">要加密密码的库</h1><p id="b81a" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在，我们将向我们的项目添加一个库，以便我们可以在将用户密码保存到数据库之前对其进行加密。这样，即使数据库被黑客攻击，我们也能确保它的安全。</p><p id="d2ad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">运行以下命令:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="b0b3" class="ky kz hu mq b fv mz na l nb nc">yarn add bcrypt-nodejs</span></pre><p id="2250" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这样，库将被添加到我们的项目中。</p><h2 id="c435" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">修改模型</h2><p id="0c59" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在，我们必须修改我们的模型，以便当请求中出现明文密码时，可以在其中设置加密密码。在<code class="eh mn mo mp mq b">user.model.js</code>中增加以下内容</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="3822" class="ky kz hu mq b fv mz na l nb nc">UserSchema.pre('save', function(next) {<br/>     if (this.isModified('password')) {<br/>         this.password = this._hashPassword(this.password);<br/>     }<br/>     return next();<br/> });<br/> UserSchema.methods = {<br/>     _hashPassword(password) {<br/>         return hashSync(password);<br/>     },<br/>     authenticateUser(password) {<br/>         return compareSync(password, this.password);<br/>     },<br/> };</span></pre><p id="11b2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在上面的代码中，这指的是请求中提到的当前用户。此外，一旦我们尝试登录，authenticateUser就会被调用，并且用户会传递一个明文形式的密码。我们对这个密码进行哈希运算，只有在此之后，我们才会将其与数据库中的值进行比较。</p><p id="89a4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，让我们尝试提出一个新的请求，并检查这是否可行。这是我的要求:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff os"><img src="../Images/c4779b5af2727f3ccdf014f0baab00ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*swUvU197JKTFNF83"/></div></figure><p id="6525" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当我运行这个请求时，我们得到的响应是:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ot"><img src="../Images/bedfc4e8073bb8ebba5d2fa5c92f88bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/0*eqR2nC_zEyarBrrO"/></div></figure><p id="ca6c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在让我们来看看数据库，我们也会在那里看到类似的场景:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ou"><img src="../Images/f5c7653871ab922b9d4fe062e1ae3513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/0*RNerH49iB20jWIEC"/></div></figure><p id="88b4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们将成为应用程序的登录API。</p><h2 id="ab73" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">使用Passport登录</h2><p id="3d0c" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将使用一个名为<code class="eh mn mo mp mq b"><a class="ae ke" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">Passport</a></code>的图书馆。你可以自由使用任何其他认证库，如脸书，谷歌等。</p><p id="05f4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了继续，我们需要向我们的项目添加两个库。让我们通过运行以下命令来实现这一点:</p><p id="d2c4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">yarn add passport passport-local</code></p><p id="6c18" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">完成后，让我们在src文件夹中创建一个名为services的新文件夹。我们将在services文件夹中创建一个名为auth.services.js的新文件，其内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="d859" class="ky kz hu mq b fv mz na l nb nc"> import passport from 'passport';<br/> import LocalStrategy from 'passport-local';<br/> import User from '../modules/users/user.model';<br/> const localOpts = {<br/>     usernameField: 'email',<br/> };<br/> const localStrategy = new LocalStrategy(localOpts, async (email, password, done) =&gt; {<br/>     try {<br/>         const user = await User.findOne({<br/>             email<br/>         });<br/>         if (!user) {<br/>             return done(null, false);<br/>         } else if (!user.authenticateUser(password)) {<br/>             return done(null, false);<br/>         }<br/>         return done(null, user);<br/>     } catch (e) {<br/>         return done(e, false);<br/>     }<br/> });<br/> passport.use(localStrategy);<br/> export const authLocal = passport.authenticate('local', {<br/>     session: false<br/> });</span></pre><p id="f513" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里，我们尝试了一个本地策略，它本质上是异步的，数据作为用户的电子邮件和密码被发送到passport库。然后，库将对用户进行身份验证，并返回响应。</p><p id="b953" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还将添加Passport作为我们的中间件。以下是修改后的文件:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="a129" class="ky kz hu mq b fv mz na l nb nc"> import morgan from 'morgan';<br/> import bodyParser from 'body-parser';<br/> import compression from 'compression';<br/> import helmet from 'helmet';<br/> import passport from 'passport';<br/> <br/> const isDev = process.env.NODE_ENV === 'development';<br/> const isProd = process.env.NODE_ENV === 'production';<br/> <br/> export default app =&gt; {<br/>     if (isProd) {<br/>         app.use(compression());<br/>         app.use(helmet());<br/>     }<br/>     app.use(bodyParser.json());<br/> <br/>     app.use(bodyParser.urlencoded({<br/>         extended: true<br/>     }));<br/>     app.use(passport.initialize());<br/> <br/>     if (isDev) {<br/>         app.use(morgan('dev'));<br/>     }<br/> };</span></pre><p id="2c41" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里，我们也用我们的应用程序实例初始化了Passport库。</p><h2 id="5b2c" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">将登录添加到控制器</h2><p id="f61a" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在是我们将登录功能也添加到控制器层的时候了。向我们的控制器添加以下功能:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="d422" class="ky kz hu mq b fv mz na l nb nc">export function login(req, res, next) {<br/> res.status(200).json(req.user);<br/> return next();<br/>}</span></pre><p id="893a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">请注意，这是我们最终的控制器文件的样子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ov"><img src="../Images/9cc47a5c9b543d976416da9d764d75db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/0*JRv1EjaZcaKQaFGI"/></div></div></figure><p id="56a2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">提供登录路径</p><p id="e632" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还必须提供一个登录API的路径。我们将在<code class="eh mn mo mp mq b">user.routes.js</code>文件中进行这一更改。将此路线与导入一起添加到文件中:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="8449" class="ky kz hu mq b fv mz na l nb nc">import {<br/> authLocal<br/>} from ‘../../services/auth.services’;</span><span id="e739" class="ky kz hu mq b fv nz na l nb nc">routes.post(‘/login’, authLocal, userController.login);</span></pre><p id="3eb9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是我们最终文件的样子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ow"><img src="../Images/813f5b077c109be31de08f8d082cd63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S4MOiPmAcAJOi6Dw"/></div></div></figure><p id="7dff" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">尝试登录功能</p><p id="5d1c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们将使用之前创建的凭据尝试以下POST API:</p><p id="bc0e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="http://localhost:3000/api/v1/users/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/v1/users/登录</a></p><p id="26f3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当凭据正确时，会发生以下情况:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff os"><img src="../Images/94c06edab87fdfd75b94c4be350e6ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*9LySuMHA7BfFzhY4"/></div></div></figure><p id="e5a7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这不是很好吗？我们能够登录到一个现有的用户，我们也能够通过加密来保护他的密码。</p><h1 id="0c68" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">添加JWT身份验证</h1><p id="d1ae" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">到目前为止，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/d054528e5ee8fd46353ac6a62d911632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*-FjZr1c6ExUan3JF"/></div></figure><p id="812e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/13472159b65b9ba39a9d64474de5defd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*3wTXKzcY4Angmghi"/></div></figure><p id="eca0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在知道我们将在这篇文章中做什么之前，让我们最后看看我们当前的<code class="eh mn mo mp mq b"><em class="mm">package.json</em></code>文件是什么样子的:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oz"><img src="../Images/de7dd8ef80d27d0e81da0148a11c952a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r3f_TS5pHBrH29rg"/></div></div></figure><p id="a1e7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本节中，我们将添加以下功能:</p><ul class=""><li id="e1fe" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">我们将实现JWT认证并添加一个加密密码</li><li id="5250" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">添加新的passport-jwt库</li><li id="cd7f" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">添加jsonwebtoken库</li><li id="f566" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">在JSON中只发送必填字段作为响应</li></ul><h2 id="7d61" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">JSON web token如何存储数据？</h2><p id="ca14" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">当我们提供要加密的数据和加密密码时，它会被加密以形成JWT令牌的各个部分，例如:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pa"><img src="../Images/996bc6f0686a60be19605b00790f14b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u07ctNWmmz_EeXH2"/></div></div></figure><p id="1d8a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如上所示，一个令牌可以包含一个用户的身份和其他与他相关的数据。</p><h2 id="cdb8" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">添加JWT秘密</h2><p id="068f" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">让我们继续我们的<code class="eh mn mo mp mq b"><em class="mm">constants.js</em></code>文件，并在开发配置中添加一个JWT的秘密:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="6c20" class="ky kz hu mq b fv mz na l nb nc">const devConfig = {<br/> MONGO_URL: ‘mongodb://localhost/makeanodejsapi-dev’,<br/> JWT_SECRET: ‘thisisasecret’,<br/>};</span></pre><p id="af9f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将使用以下命令安装两个库:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="acaf" class="ky kz hu mq b fv mz na l nb nc">yarn add jsonwebtoken passport-jwt</span></pre><p id="4a6c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，移动到授权服务文件和文件中的JWT服务，代码如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="de33" class="ky kz hu mq b fv mz na l nb nc">import { Strategy as JWTStrategy, ExtractJwt } from ‘passport-jwt’;</span><span id="c35a" class="ky kz hu mq b fv nz na l nb nc">import User from ‘../modules/users/user.model’;<br/>import constants from ‘../config/constants’;</span></pre><p id="755c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，让passport使用指定的策略:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="bf04" class="ky kz hu mq b fv mz na l nb nc">// Jwt strategy<br/> const jwtOpts = {<br/>   jwtFromRequest: ExtractJwt.fromAuthHeader('authorization'),<br/>   secretOrKey: constants.JWT_SECRET,<br/> };<br/> <br/> const jwtStrategy = new JWTStrategy(jwtOpts, async (payload, done) =&gt; {<br/>   try {<br/>     //Identify user by ID<br/>     const user = await User.findById(payload._id);<br/> <br/>     if (!user) {<br/>       return done(null, false);<br/>     }<br/>     return done(null, user);<br/>   } catch (e) {<br/>     return done(e, false);<br/>   }<br/> });<br/> <br/> passport.use(localStrategy);<br/> passport.use(jwtStrategy);<br/> <br/> export const authLocal = passport.authenticate('local', { session: false });<br/> export const authJwt = passport.authenticate('jwt', { session: false });</span></pre><p id="b687" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了测试这是否可行，我们现在将在route JS文件中使用一个私有路由。最终的文件内容将如下所示:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="e038" class="ky kz hu mq b fv mz na l nb nc">import userRoutes from ‘./users/user.routes’;<br/>import { authJwt } from ‘../services/auth.services’;</span><span id="3286" class="ky kz hu mq b fv nz na l nb nc">export default app =&gt; {<br/> app.use(‘/api/v1/users’, userRoutes);<br/> app.get(‘/hello’, authJwt, (req, res) =&gt; {<br/> res.send(‘This is a private route!!!!’);<br/> });<br/>};</span></pre><h2 id="3766" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">验证JWT</h2><p id="993e" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">让我们试试这个，验证JWT现在在《邮差》工作:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pb"><img src="../Images/a41a79b3cb66392b685dca5ec11ee697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lg6KgE6p3D283j-S"/></div></div></figure><p id="d455" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们现在需要在请求中添加一个JWT令牌，它只属于一个特定的用户。</p><p id="bfe0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将向用户模型添加功能，以便当用户登录时，它也包含JWT令牌。因此，让我们向用户模型JS文件添加更多的库:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="c251" class="ky kz hu mq b fv mz na l nb nc">import jwt from ‘jsonwebtoken’;<br/>import constants from ‘../../config/constants’;</span></pre><p id="b59b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们可以解密一个令牌并获得一个用户信息。</p><h2 id="17c5" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">创建JWT令牌</h2><p id="e0aa" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们还必须创建一个为用户创建令牌的方法。现在让我们添加这个方法:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="2555" class="ky kz hu mq b fv mz na l nb nc">UserSchema.methods   = {<br/>   <br/>     createToken() {<br/>       return jwt.sign(<br/>         {<br/>           _id: this._id,<br/>         },<br/>         constants.JWT_SECRET,<br/>       );<br/>     },<br/>     toJSON() {<br/>       return {<br/>         _id: this._id,<br/>         userName: this.userName,<br/>         token: `JWT ${this.createToken()}`,<br/>       };<br/>     },<br/>   };</span></pre><p id="fd7b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用toJSON()方法也很重要。我们在令牌前面附加了JWT，因为passport library使用它来识别JWT令牌。</p><p id="6a80" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，让我们再次尝试登录用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pb"><img src="../Images/ce70e7da140cd429207df376c818b73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Y8OSgPkmoJUEKcD"/></div></div></figure><p id="12dc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这一次，我们甚至得到了一个JWT代币作为回应。这个令牌还将包含用户ID和用户名。我们现在有了一个JWT的工作范例！</p><p id="ba4a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，让我们复制JWT值并尝试私有路线:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pc"><img src="../Images/79243a87b17c57a5ddce97ecdf76587b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7jVsEmWC1DwIg5RK"/></div></div></figure><h1 id="e4b1" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">通过用户和对象关联发帖</h1><p id="7487" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">接下来，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/1ec01ea17d6155e6e4a462b8b47d47e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*WV39oyRO-kozDG5C"/></div></figure><p id="de31" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/03852bf21104c7693fb40dc5b90b2b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*fHQP3oNRag3uqXoj"/></div></figure><p id="1ab0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在知道我们将在这篇文章中做什么之前，让我们最后看看我们当前的<em class="mm"> package.json </em>文件看起来怎么样:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pd"><img src="../Images/08bc2195aa22fbb5dcb2c9e4baeddfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jpDWr_x0yPNgJb2k"/></div></div></figure><p id="2cfb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本节中，我们将添加以下功能:</p><ul class=""><li id="21bd" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">我们将为帖子创建一个新的资源。现在，用户也可以创建帖子</li><li id="707b" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">让用户成为文章的作者</li><li id="3e37" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">处理一些我们在过去的帖子中提出的问题</li></ul><h2 id="704b" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">为帖子创建模型</h2><p id="95c5" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">就像我们为用户模型所做的一样，它也需要为Post模型做，就像创建一个新文件夹一样。本课结束时，您将了解项目中的新文件夹和文件:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pe"><img src="../Images/0faae113f9848136bf0ae2cff6e0fa33.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/0*cFs8SrAViT7v-wXa"/></div></figure><p id="68c5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将从创建Post模型开始。我们还将包括我们需要的验证。让我们为mongoose唯一验证添加另一个库:</p><p id="35a5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">yarn add mongoose-unique-validator</code></p><p id="8b26" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还将添加一个新的Slug库。为此，请使用以下命令安装它:</p><p id="40f1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">yarn add slug</code></p><p id="3ff1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你想知道什么是slugify，一篇文章的URL应该看起来像文章的标题。这看起来不错，帖子的一瞥也可以在它的URL中看到，这是一个很好的过程。</p><p id="2bf2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们也可以添加这个库。我们的模型将如下所示:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="3b18" class="ky kz hu mq b fv mz na l nb nc">import mongoose, { Schema } from 'mongoose';<br/>   import slug from   'slug';<br/>   import   uniqueValidator from 'mongoose-unique-validator';<br/>   <br/>   const   PostSchema = new   Schema({<br/>     title: {<br/>       type: String,<br/>       trim: true,<br/>       required: [true, 'Title   is required!'],<br/>       minlength: [3, 'Title   need to be longer!'],<br/>       unique: true,<br/>     },<br/>     text: {<br/>       type: String,<br/>       trim: true,<br/>       required: [true, 'Text   is required!'],<br/>       minlength: [10, 'Text   need to be longer!'],<br/>     },<br/>     slug: {<br/>       type: String,<br/>       trim: true,<br/>       lowercase: true,<br/>     },<br/>     user: {<br/>       type: Schema.Types.ObjectId,<br/>       ref: 'User',<br/>     },<br/>     favoriteCount: {<br/>       type: Number,<br/>       default: 0,<br/>     },<br/>   }, { timestamps: true   });<br/>   <br/>   PostSchema.plugin(uniqueValidator, {<br/>     message: '{VALUE} already taken!',<br/>   });<br/>   <br/>   PostSchema.pre('validate', function (next) {<br/>     this._slugify();<br/>   <br/>     next();<br/>   });<br/>   <br/>   PostSchema.methods = {<br/>     _slugify() {<br/>       this.slug = slug(this.title);<br/>     },<br/>   };<br/>   <br/>   PostSchema.statics = {<br/>     createPost(args, user) {<br/>       return this.create({<br/>         ...args,<br/>         user,<br/>       });<br/>     },<br/>   };<br/>   <br/>   export default   mongoose.model('Post', PostSchema);</span></pre><p id="9da5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们在上述模型中做了以下工作:</p><ul class=""><li id="5395" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">为发布模型定义的字段</li><li id="2a6c" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">添加了对每个字段的验证</li><li id="e18c" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">添加了对整体发布对象的验证</li><li id="94b0" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">我们根据文章的标题对文章进行分类，同时也保存了这个值</li></ul><p id="af5d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在上面显示的代码中，我们将在控制器中添加createPost方法。</p><h2 id="3f40" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">创建后控制器</h2><p id="f6eb" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们现在将需要一个控制器，以便用户能够真正地执行与Post相关的操作。</p><p id="1102" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">根据上面显示的目录结构，在post模块本身中定义一个新文件post.controller.js文件，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="2863" class="ky kz hu mq b fv mz na l nb nc">import Post from './post.model';<br/> <br/> export async function createPost(req, res) {<br/>   try {<br/>     const post = await Post.createPost(req.body, req.user._id);<br/>     return res.status(201).json(post);<br/>   } catch (e) {<br/>     return res.status(400).json(e);<br/>   }<br/> }</span></pre><p id="f642" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当我们面临一个错误或者我们能够成功地创建一个新帖子时，我们返回适当的响应。</p><h2 id="8246" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">创建投递路线</h2><p id="6261" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在，让我们在应用程序的post模块下名为post.route.js的文件中创建到Post控制器的路由，内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="ed5a" class="ky kz hu mq b fv mz na l nb nc">import { Router } from 'express';<br/> <br/> import * as postController from './post.controllers';<br/> import { authJwt } from '../../services/auth.services';<br/> <br/> const routes = new Router();<br/> <br/> routes.post(<br/>   '/',<br/>   authJwt,<br/> );<br/> <br/> export default routes;</span></pre><p id="954e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们为此也修改一下<code class="eh mn mo mp mq b">index.js</code>文件。最终内容将是:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="5655" class="ky kz hu mq b fv mz na l nb nc">import userRoutes from ‘./users/user.routes’;<br/>import postRoutes from ‘./posts/post.routes’;</span><span id="369e" class="ky kz hu mq b fv nz na l nb nc">export default app =&gt; {<br/> app.use(‘/api/v1/users’, userRoutes);<br/> app.use(‘/api/v1/posts’, postRoutes);<br/>};</span></pre><p id="90a9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">验证发布API</p><p id="9700" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们现在将尝试POST API来创建一个新帖子。</p><p id="be29" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，尝试登录一个用户，这样您就可以获得一个JWT令牌来点击这个URL上的Create Post API:</p><p id="5a0e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b"><a class="ae ke" href="http://localhost:3000/api/v1/posts" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/v1/posts</a></code></p><p id="17ad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是我们的尝试和回应:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/90361bd57a0f637cc8ebbe703d5063c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*6wYLdVZvGzFMby8A"/></div></figure><p id="cde1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还填充了日期和slug字段。这还包含用户ID。让我们也在MongoDB上看看这个帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pg"><img src="../Images/0daf7be5dc51bf69799bb01b85cf7497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/0*c1VRpUIzBJXBUyHV"/></div></div></figure><p id="fec1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果我们再次点击这个API来创建文章，将会失败，因为标题已经被占用:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ph"><img src="../Images/f96a839ac856bcf86c9e0ff913271339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*fKECl9WpElFvwha0"/></div></figure><p id="9d6b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这意味着我们的验证也运行良好。</p><h1 id="d321" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">使标题成为强制性的</h1><p id="193e" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们可以实现更多的验证，比如让文章的标题成为强制的。</p><p id="1c77" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们在posts模块中创建一个名为post.validations.js的新文件，其内容如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="f31e" class="ky kz hu mq b fv mz na l nb nc">import Joi from 'joi';<br/>   <br/>   export const   passwordReg = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}/;<br/>   export default   {<br/>     signup: {<br/>       body: {<br/>         email:   Joi.string().email().required(),<br/>         password:   Joi.string().regex(passwordReg).required(),<br/>         firstName:   Joi.string().required(),<br/>         lastName:   Joi.string().required(),<br/>         userName:   Joi.string().required(),<br/>       },<br/>     },<br/>   };</span></pre><p id="e8c3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还必须修改routes文件来包含这个验证。以下是修改后的文件:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="b773" class="ky kz hu mq b fv mz na l nb nc">import { Router } from 'express';<br/> import validate from 'express-validation';<br/> import * as postController from './post.controllers';<br/> import { authJwt } from '../../services/auth.services';<br/> import postValidation from './post.validations';<br/> <br/> const routes = new Router();<br/> routes.post(<br/>   '/',<br/>   authJwt,<br/>   validate(postValidation.createPost),<br/>   postController.createPost,<br/> );<br/> <br/> export default routes;</span></pre><p id="9d61" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们能够从上面使用的<code class="eh mn mo mp mq b">authJwt</code>对象中获得用户ID。我们现在收到的信息是:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pi"><img src="../Images/15cc6c5dd4b31b17561848c600e2df3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iiD8fpWigQPI6zQ2"/></div></div></figure><p id="a293" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将很快改变回答，使之更加优雅。</p><h1 id="4638" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">通过ID获取数据并将一个对象填充到另一个对象中</h1><p id="9773" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">接下来，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/33a244ccb339fa079d102d610f2a1340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*ZeDkk9MFnk-8158y"/></div></figure><p id="c826" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/3a9b5586bf4067310d8195a3ff8310c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*AKGhBA-ZMslNsDjl"/></div></figure><p id="c776" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够创建一个与用户相关的帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/9b4669a98700c62f99650adfce42fbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*MsgwdrXhOQze8Zod"/></div></figure><p id="5cb5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本节中，我们将添加以下功能:</p><ul class=""><li id="d04b" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">我们将通过它的ID得到一个帖子</li><li id="9f6e" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">我们还将创建控制器和路线</li><li id="9631" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">我们将向您展示如何在帖子中填充用户信息</li><li id="0dbf" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">我们将使用的其他库</li></ul><h2 id="646a" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">将HTTP状态库添加到控制器</h2><p id="ef53" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">要添加此库，请运行以下命令:</p><p id="a7d5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">yarn add http-status</code></p><p id="69c3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们也可以在用户控制器中使用这个库。让我们从导入这个库开始:</p><p id="60aa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">import HTTPStatus from ‘http-status’;</code></p><p id="401c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，不要使用200等状态。在我们的控制器中，我们将把这个库提供的状态修改为:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="6dbe" class="ky kz hu mq b fv mz na l nb nc">export   async function signUp(req, res) {<br/>     try {<br/>       const user = await User.create(req.body);<br/>       return res.status(HTTPStatus.CREATED).json(user.toAuthJSON());<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }<br/>   <br/>   export function login(req, res, next) {<br/>       res.status(HTTPStatus.OK).json(req.user.toAuthJSON());<br/>     return next();<br/>   }</span></pre><p id="ba40" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将在Post控制器中做同样的事情:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="ff6d" class="ky kz hu mq b fv mz na l nb nc">import HTTPStatus from 'http-status';<br/>   import Post from   './post.model';<br/>   <br/>   export async function createPost(req, res) {<br/>     try {<br/>       const post = await Post.createPost(req.body, req.user._id);<br/>         return   res.status(HTTPStatus.CREATED).json(post);<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }</span></pre><h2 id="c257" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">通过ID获取帖子</h2><p id="a0ab" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将在Post控制器中定义一个新函数，用于通过ID获取帖子:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="44ea" class="ky kz hu mq b fv mz na l nb nc">export async function getPostById(req, res) {<br/>   try {<br/>     const post = await Post.findById(req.params.id);<br/>     return res.status(HTTPStatus.OK).json(post);<br/>   } catch (e) {<br/>     return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>   }<br/> }</span></pre><p id="da7c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们来定义此功能的路线:</p><p id="0b77" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">routes.get(‘/:id’, postController.getPostById);</code></p><p id="652d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为我们的Mongo数据库中有以下帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pj"><img src="../Images/dd457e999bd91d459aa8f6d3285e24e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/0*TU8kZigBK78m1K8G"/></div></figure><p id="d931" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将通过我们的API获得这个帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pk"><img src="../Images/f5b73fb79fc7ebd8ae3e22a0a07948ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*QBJj46Ity0JEfA8K"/></div></figure><p id="cf09" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个响应的问题是，我们也得到了MongoDB中的所有字段。我们不想这样。让我们在Post模型中对此进行更改:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="2372" class="ky kz hu mq b fv mz na l nb nc">PostSchema.methods = {<br/>   _slugify() {<br/>     this.slug = slug(this.title);<br/>   },<br/>   toJSON() {<br/>     return {<br/>       _id: this._id,<br/>       title: this.title,<br/>       text: this.text,<br/>       createdAt: this.createdAt,<br/>       slug: this.slug,<br/>       user: this.user,<br/>       favoriteCount: this.favoriteCount,<br/>     };<br/>   },<br/> };</span></pre><p id="95ef" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦我们在模型中应用了<code class="eh mn mo mp mq b">toJSON()</code>函数，这就是我们现在得到的响应:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pl"><img src="../Images/e3481ee0d1a5c9632194abce3d1239e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/0*0fUfVfrQySXcpXuR"/></div></figure><h2 id="f6cd" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">在Post响应中获取用户数据</h2><p id="4f06" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">如果我们仔细观察上面的<code class="eh mn mo mp mq b">JSON</code>，我们实际上有一个保存其ID的用户字段。但是如果我们也希望它的信息在同一个对象中呢？</p><p id="a13a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">只需稍微修改getPostById函数，并将函数中的post const修改为:</p><p id="8c83" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">const post = await Post.findById(req.params.id).populate(‘user’);</code></p><p id="ce5d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们刚刚添加了一个填充调用，现在响应将是:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pm"><img src="../Images/817458419c588f6008a5d1c40ad24b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-8k75lhe7LayBLGY"/></div></div></figure><p id="1800" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">toJSON</code>也将在我们填充用户对象时工作。这是这里的一个问题，因为我们还拿回了上面的令牌字段，这是永远不会发生的！</p><p id="fbb2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们修改用户模型来改进这一点:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="54ed" class="ky kz hu mq b fv mz na l nb nc">UserSchema.methods = {<br/>   _hashPassword(password) {<br/>     ...<br/>   },<br/>   authenticateUser(password) {<br/>     ...<br/>   },<br/>   createToken() {<br/>     ...<br/>   },<br/>   toAuthJSON() {<br/>     ...<br/>   },<br/>   toJSON() {<br/>     return {<br/>       _id: this._id,<br/>       userName: this.userName,<br/>     };<br/>   },</span></pre><p id="94c9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们修改了上面的<code class="eh mn mo mp mq b">toJSON</code>方法，因此令牌字段不包含在响应本身中。</p><p id="6967" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个问题实际上仍然存在。让我们看看当我尝试让一个用户登录时会发生什么:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pn"><img src="../Images/6fd4409311eb1dfb6fbb976a5582f57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/0*3f5Aiy0R8UVuo4tX"/></div></figure><p id="1752" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">看，这里也没有令牌字段。要解决这个问题，进入<code class="eh mn mo mp mq b">User controller</code>中的登录功能，修改如下:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="fe70" class="ky kz hu mq b fv mz na l nb nc">export function login(req, res, next) {<br/> res.status(HTTPStatus.OK).json(req.user.toAuthJSON());<br/> return next();<br/>}</span></pre><p id="5b6c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我已经使用了<code class="eh mn mo mp mq b">toAuthJSON</code>函数本身。如果您现在尝试，登录将像以前一样工作！</p><h1 id="e303" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">从数据库获取所有数据</h1><p id="6f71" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">接下来，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/f0ac9777a0a0193b575fbf455aff181b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*xIGj9uZAjAg8rxjx"/></div></figure><p id="dbfc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/f7a8f4460a129e8773a16db57e010521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*oZS5uOTGqZgaKUGk"/></div></figure><p id="ab07" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够创建一个与用户相关的帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/4b9f74dfea378d633afeb0f5420744e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*upUoB-2cM9pKThVw"/></div></figure><p id="62e9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本节中，我们将添加以下功能:</p><ul class=""><li id="3161" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">在后控制器上工作以添加更多功能</li></ul><h1 id="da0b" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">扩展控制器</h1><p id="4aae" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">到目前为止，我们的Post控制器只有以下功能:</p><ul class=""><li id="c4c6" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">创建帖子</li><li id="f21d" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">按ID获取帖子</li></ul><p id="591f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们还将添加更多的功能，我们将从获取列表中的所有帖子开始。</p><h2 id="b73e" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">获取所有帖子</h2><p id="d068" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">让我们通过添加一个获取所有帖子的新方法来扩展Post控制器的功能:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="389c" class="ky kz hu mq b fv mz na l nb nc">export   async function getPostsList(req, res) {<br/>     try {<br/>       const posts = await Post.find().populate('user');<br/>       return res.status(HTTPStatus.OK).json(posts);<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }</span></pre><p id="562d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这里，我们退回了帖子。让我们修改路由文件以使用我们在上面添加的函数:</p><p id="114c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">routes.get(‘/’, postController.getPostsList);</code></p><p id="770c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们没有在认证中加入这一点，即使是未经认证的用户也可以至少允许他发帖。现在让我们试试这个API:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff po"><img src="../Images/7ffc14abea67237d31b5f5296aecc115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/0*L3af2pnd_Zs3-BoO"/></div></figure><p id="815c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们有11个职位在数据库中，所以，上述API显示没有问题。但是五万多的帖子会怎么样呢？在这种情况下，我们会遇到严重的性能问题。</p><h2 id="956a" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">分页拯救世界</h2><p id="42f8" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们可以根据用户的要求返回有限数量的帖子。在<code class="eh mn mo mp mq b">post</code>模型中，我们可以提供分页参数，如:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="63b2" class="ky kz hu mq b fv mz na l nb nc">PostSchema.statics   = {<br/>     createPost(args, user) {<br/>       ...<br/>     },<br/>     list({ skip = 0, limit = 5 } = {}) {<br/>       return this.find()<br/>         .sort({ createdAt: -1 })<br/>         .skip(skip)<br/>         .limit(limit)<br/>         .populate('user');<br/>     },<br/>   };</span></pre><p id="1e82" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">list所做的是，它最初只返回前5个帖子。如果skip为5，list函数将返回5篇文章，但在跳过前5篇文章之后。让我们也修改控制器:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="2c89" class="ky kz hu mq b fv mz na l nb nc">export async function getPostsList(req, res) {<br/>   const limit = parseInt(req.query.limit, 0);<br/>   const skip = parseInt(req.query.skip, 0);<br/>   try {<br/>     const posts = await Post.list({ limit, skip });<br/>     return res.status(HTTPStatus.OK).json(posts);<br/>   } catch (e) {<br/>     return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>   }<br/> }</span></pre><p id="afdd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，当我们提供这些值时，我们得到这样的响应:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pp"><img src="../Images/bb83fd2775052257022749f0254a786b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*6T-IPs7jRQ8X6BxG"/></div></figure><h2 id="190b" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">更新帖子并添加验证</h2><p id="18dc" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">接下来，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/5c34c7fc8f27fd9b3e783869718bc463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*E_T64VB2Gof06O82"/></div></figure><p id="7979" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/9f87797b58d22c78dfe29aabe3d75744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*QSNjJ1W8nSTTUBPR"/></div></figure><p id="8d02" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够创建一个与用户相关的帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/4887a27c4a0b4b0cc46e474b5dff5268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*wdvakfb45Xl55sc4"/></div></figure><p id="a43b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本课中，我们将添加以下功能:</p><ul class=""><li id="ebe7" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">我们将更新帖子，并确保更新帖子的用户是其作者</li><li id="0bf3" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">创建验证字段</li></ul><p id="571c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在接下来的课程中，我们将在帖子上添加更多的操作。</p><h2 id="df64" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">扩展控制器</h2><p id="bfd5" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">到目前为止，我们的Post控制器只有以下功能:</p><ul class=""><li id="1ef1" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">创建一个pos</li><li id="07ef" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">按ID获取帖子</li><li id="4a6f" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">获取所有帖子的列表</li></ul><p id="5715" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们还将添加更多的功能，我们将从允许用户更新帖子开始。</p><h2 id="888b" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">更新帖子</h2><p id="a9c4" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">让我们通过添加一个更新帖子的新方法来扩展Post控制器的功能:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="3acd" class="ky kz hu mq b fv mz na l nb nc">export   async function updatePost(req, res) {<br/>     try {<br/>       const post = await Post.findById(req.params.id);<br/>       if (!post.user.equals(req.user._id)) {<br/>         return res.sendStatus(HTTPStatus.UNAUTHORIZED);<br/>       }<br/>   <br/>       Object.keys(req.body).forEach(key   =&gt; {<br/>         post[key] = req.body[key];<br/>       });<br/>   <br/>       return res.status(HTTPStatus.OK).json(await post.save());<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }</span></pre><p id="7b0e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是我们在上面所做的:</p><ul class=""><li id="76e3" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">从JWT令牌确认用户是否与发布对象中的用户相同</li><li id="81c4" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">如果用户不同，我们返回一个<code class="eh mn mo mp mq b">UNAUTHORIZED</code>响应</li><li id="415f" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">如果一个用户是相同的，我们得到请求中传递的每个键，并基于此更新帖子</li><li id="0c80" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">一旦所有更新完成，我们返回OK响应</li></ul><p id="ad64" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们修改验证文件以使用我们在上面添加的函数:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="2b0d" class="ky kz hu mq b fv mz na l nb nc">import Joi from 'joi';<br/>   <br/>   export default   {<br/>     createPost: {<br/>       body: {<br/>         title: Joi.string().min(3).required(),<br/>         text: Joi.string().min(10).required(),<br/>       },<br/>     },<br/>     updatePost: {<br/>       body: {<br/>         title: Joi.string().min(3),<br/>         text: Joi.string().min(10),<br/>       },<br/>     },<br/>   };</span></pre><p id="ce13" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们刚刚在updatePost函数中为两个字段的最小长度添加了验证。现在发送文件的时间:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="4b4b" class="ky kz hu mq b fv mz na l nb nc">routes.patch(<br/>   '/:id',<br/>   authJwt,<br/>   validate(postValidation.updatePost),<br/>   postController.updatePost,<br/> );</span></pre><h2 id="48c6" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">更新帖子</h2><p id="7e16" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在工作已经完成了，我们将验证上面所做的工作。让我们向邮递员发出这样一个<code class="eh mn mo mp mq b">PATCH</code>请求:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pq"><img src="../Images/808c4d83261e6fa7e05be683ca74466a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/0*dhxvpUE58Fsa5GaV"/></div></figure><p id="2caa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">太好了，成功了！甚至帖子的内容也更新了。只要确保我们在Post模型中有这个方法:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="d9b4" class="ky kz hu mq b fv mz na l nb nc">PostSchema.pre(‘validate’, function (next) {<br/> this._slugify();<br/> next();<br/>});</span></pre><p id="0680" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">继续尝试同样的文章。</p><h1 id="b031" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">授权用户删除帖子</h1><p id="0bbf" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">到目前为止，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/32954f7f1d7200ab71f8e3788bb21897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*QM2CQ_cZQ2VjKqKR"/></div></figure><p id="1b06" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/a954c80e11f5fdebdfe5350a0d1bf018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*cesI4HfbAcBe2Naj"/></div></figure><p id="cdc6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们能够创建与用户相关的帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/38ae00324d019f2e7d6b325709c62223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*qkX7pkNYdMwnNg6e"/></div></figure><p id="92cc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本课中，我们将添加以下功能:</p><ul class=""><li id="63f0" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">我们将允许作者删除帖子</li><li id="997f" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">授权功能</li><li id="da44" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">添加一个叫做<code class="eh mn mo mp mq b">prettie</code>的工具</li></ul><h2 id="69d5" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">扩展控制器</h2><p id="5ed7" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">到目前为止，我们的Post控制器只有以下功能:</p><ul class=""><li id="a954" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">创建帖子</li><li id="c312" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">按ID获取帖子</li><li id="2c6e" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">获取所有帖子的列表</li><li id="6e99" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">更新帖子</li></ul><p id="5335" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们还将添加更多的功能，我们将从允许用户删除帖子开始。</p><h2 id="14da" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">删除帖子</h2><p id="3ebe" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">让我们通过添加一个删除帖子的新方法来扩展Post控制器的功能:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="14f8" class="ky kz hu mq b fv mz na l nb nc">export async function deletePost(req, res) {<br/>     try {<br/>         const post =   await Post.findById(req.params.id);<br/>   <br/>       if (!post.user.equals(req.user._id)) {<br/>         return res.sendStatus(HTTPStatus.UNAUTHORIZED);<br/>       }<br/>   <br/>       await post.remove();<br/>       return res.sendStatus(HTTPStatus.OK);<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }</span></pre><p id="49f0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是我们在上面所做的:</p><ul class=""><li id="b3e0" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">从JWT令牌确认用户是否与发布对象中的用户相同</li><li id="7442" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">如果用户不同，我们将返回一个未授权的响应</li><li id="4ac5" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">如果用户是相同的，我们删除帖子</li><li id="08c1" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">一旦帖子被删除，我们返回OK响应</li></ul><p id="2387" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在发送文件的时间:</p><p id="4703" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">routes.delete(‘/:id’, authJwt, postController.deletePost);</code></p><h2 id="8a45" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">删除帖子</h2><p id="6ef8" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在工作已经完成了，我们将验证上面所做的工作。让我们向邮递员提出这样一个<code class="eh mn mo mp mq b">DELETE</code>请求:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pr"><img src="../Images/5a108ab4c448024f0d88482d7c3aeb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DHMmMd-WUcKH5k5j"/></div></div></figure><p id="6383" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，您可以使用以下查询来验证这篇文章是否存在于Get all Post API和MongoDB中:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ps"><img src="../Images/af53ad4a51fcaee4cb81500a7f76e409.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/0*8WvIgaoEhXQmUz98"/></div></figure><h1 id="6e46" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">添加更漂亮的库</h1><p id="a676" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们可以用下面的yarn命令添加漂亮的库:</p><p id="2ade" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">yarn add -D prettier</code></p><p id="a7f7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">完成后，这里是我更新的<code class="eh mn mo mp mq b">package.json</code>文件:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="4e94" class="ky kz hu mq b fv mz na l nb nc">{<br/>     "name": "makeanodejsrestapi",<br/>     ...,<br/>     "scripts": {<br/>       ...,<br/>       "prettier": "prettier --single-quote   --print-width 80 --trailing-comma all --write 'src/**/*.js'"<br/>     },<br/>     "dependencies": {<br/>       ...<br/>     },<br/>     "devDependencies": {<br/>       ...,<br/>       "prettier": "^1.3.1",<br/>       ...<br/>     }<br/>   }</span></pre><p id="4e2f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们只显示了所做的更改。我们还将使用以下命令添加一个ES lint库:</p><p id="ffe7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">yarn add -D eslint-config-prettie</code></p><p id="bd98" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们将创建一个名为。带有以下注释的eslintrc:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="c3ff" class="ky kz hu mq b fv mz na l nb nc">{<br/> “extends”: [<br/> “equimper”,<br/> “prettier”<br/> ]<br/>}</span></pre><p id="0e43" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，如果您忘记添加分号或缩进，您只需运行以下命令，它们就会为您添加:</p><p id="4b69" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">yarn prettier</code></p><p id="f438" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这不是很神奇吗？:)这还显示了哪些文件发生了更改:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pt"><img src="../Images/17c32d578b0abad616624dbb025e88d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/0*1Vp0auIKb5EJfrAH"/></div></figure><p id="03ba" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将继续使用这个命令和库，因为这确实简化了我们的工作！</p><h1 id="307a" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">收藏帖子和管理帖子统计</h1><p id="af44" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">接下来，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/be30672f50afd3bcc31515dc52f94930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*PYNPZvhRhfLkxnWM"/></div></figure><p id="67ad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/1d5078a458dd43020f0571d354285581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*ekpL3Idzf0LDhxyB"/></div></figure><p id="3e6b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们能够创建与用户相关的帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/8df1ab2f5df970bda87c020c8d24e7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*_IkpuW39shl3bWeL"/></div></figure><p id="79b3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本节中，我们将添加以下功能:</p><ul class=""><li id="5034" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">用户可以在通过身份验证后收藏帖子，这也将增加favoriteCount计数器变量</li><li id="6e96" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">为此修改用户和发布的模型</li><li id="7d3e" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">在Post上添加增量/减量静态</li></ul><h2 id="2a5a" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">修改用户模型</h2><p id="f2e1" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们将添加一个新字段来存储用户喜欢的帖子。让我们编辑<em class="mm"> user.model.js </em>文件来实现这一点，并在密码字段后添加一个新字段:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="9199" class="ky kz hu mq b fv mz na l nb nc">favorites:   {<br/>         posts: [{<br/>           type: Schema.Types.ObjectId,<br/>           ref: 'Post'<br/>         }]<br/>       }</span></pre><p id="5e69" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还将添加一个函数来使用该字段:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="e554" class="ky kz hu mq b fv mz na l nb nc">UserSchema.methods   = {<br/>     _hashPassword(password) {<br/>       ...<br/>     },<br/>     authenticateUser(password) {<br/>       ...<br/>     },<br/>     createToken() {<br/>       ...<br/>     },<br/>     toAuthJSON() {<br/>       ...<br/>     },<br/>     toJSON() {<br/>       ...<br/>     },<br/>   <br/>     _favorites: {<br/>       async posts(postId) {<br/>         if (this.favorites.posts.indexOf(postId)   &gt;= 0) {<br/>           this.favorites.posts.remove(postId);<br/>         } else {<br/>           this.favorites.posts.push(postId);<br/>         }<br/>         return this.save();<br/>       }<br/>     }<br/>   };</span></pre><h2 id="16d3" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">扩展后控制器</h2><p id="1eb8" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">让我们在这里添加一个函数来使用我们在模型中定义的功能。从使用<code class="eh mn mo mp mq b"> <em class="mm">post.controller.js</em> </code>文件中的导入开始:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="70a8" class="ky kz hu mq b fv mz na l nb nc">import User from ‘../users/user.model’;</span></pre><p id="6435" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们调用<code class="eh mn mo mp mq b">User</code>模型函数:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="fd27" class="ky kz hu mq b fv mz na l nb nc">export   async function favoritePost(req, res) {<br/>     try {<br/>       const user = await User.findById(req.user._id);<br/>       await   user._favorites.posts(req.params.id);<br/>       return res.sendStatus(HTTPStatus.OK);<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }</span></pre><p id="5a6a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们最后修改我们的<code class="eh mn mo mp mq b"><em class="mm">post.routes.js</em></code>文件来访问这个函数:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="a9a0" class="ky kz hu mq b fv mz na l nb nc">routes.post(‘/:id/favorite’, authJwt, postController.favoritePost);</span></pre><p id="3fae" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在该测试这条路线了。在Postman中，从数据库或Get all post API中选择一个<code class="eh mn mo mp mq b">Post</code> ID后，向收藏的API发出一个<code class="eh mn mo mp mq b">GET</code>请求:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pg"><img src="../Images/8a6a47cc797f15bf220eea6058b316d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/0*eAoBsPt_90MFZXQD"/></div></figure><p id="5437" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们验证这在MongoDB上是否有效:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pu"><img src="../Images/89d3448b088c3c3514c43841194b2fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*0cAp0jrT7a3lLsd1"/></div></figure><p id="4399" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们只保留了对象ID，因为这样可以避免我们复制数据。如果你再次点击同一个API，你会看到一些奇怪的东西，文章ID现在从用户模型的收藏夹中删除了！</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pv"><img src="../Images/aab7a302b1fee38d79807b87980e8e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RcBKJGQG5d1VYktj"/></div></div></figure><p id="761b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还在帖子模型中保留了最受欢迎人数。让我们现在就让它发挥作用。我们将在<code class="eh mn mo mp mq b">Post</code>模型类中包含此逻辑:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="4aa6" class="ky kz hu mq b fv mz na l nb nc">PostSchema.statics = {<br/>   createPost(args, user) {<br/>     ...<br/>   },<br/>   list({ skip = 0, limit = 5 } = {}) {<br/>     ...<br/>   },<br/> <br/>   incFavoriteCount(postId) {<br/>     return this.findByIdAndUpdate(postId, { $inc: { favoriteCount: 1 } });<br/>   },<br/> <br/>   decFavoriteCount(postId) {<br/>     return this.findByIdAndUpdate(postId, { $inc: { favoriteCount: -1 } });<br/>   }<br/> };</span></pre><p id="bc1d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">incFavoriteCount和decFavoriteCount方法首先使用Mongo的findByIdAndUpdate方法来查找文章ID，然后使用$inc操作符在收藏增加的情况下添加1，或者在收藏减少的情况下添加-1。</p><p id="448f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在让我们也修改一下用户模型。首先添加此导入语句:</p><p id="08f7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh mn mo mp mq b">import Post from ‘../posts/post.model’;</code></p><p id="5148" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后，在此修改<code class="eh mn mo mp mq b">_favorites</code>方法功能:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="ce70" class="ky kz hu mq b fv mz na l nb nc">_favorites:   {<br/>       async posts(postId) {<br/>         if (this.favorites.posts.indexOf(postId)   &gt;= 0) {<br/>           this.favorites.posts.remove(postId);<br/>           await   Post.decFavoriteCount(postId);<br/>         } else {<br/>           this.favorites.posts.push(postId);<br/>           await   Post.incFavoriteCount(postId);<br/>         }<br/>   <br/>         return this.save();<br/>       }<br/>     }</span></pre><p id="0949" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们上面提到的用户模型问题将会解决，Post模型中的favoriteCount也将工作:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pw"><img src="../Images/7d7b8a782c076b1e591933c41ee660e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/0*UeQRcrXmp2twYPWo"/></div></figure><p id="3e66" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你一次又一次地点击同一个API，结果是不会改变的。太棒了。我们有工作的API，用户也可以喜欢一个帖子。</p><h1 id="f2e5" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">识别帖子是否已经是用户的最爱</h1><p id="407f" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">最后一部分，我们能够在我们的应用程序中注册一个新用户:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/5fed3c5c2952c988cbc2df505cb1966d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*hKB0gglsUcHogEdz"/></div></figure><p id="fe86" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还能够允许用户登录我们的应用程序:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/1b2d0420eab0e322beb8fa91cafb861f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*H2kd9TMZdua-_Bwj"/></div></figure><p id="d58e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们能够创建与用户相关的帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pf"><img src="../Images/fb03f7e48ae01e1b8030eb4b8cec8873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*0TYd1pSo_hhdB2Xo"/></div></figure><p id="ac70" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">更新帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff pq"><img src="../Images/39894e9fba96cb482a30d194a4361239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/0*0ew-HEfcORChXZJA"/></div></figure><p id="1421" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">并删除一个帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff pr"><img src="../Images/7ee9c2fe2222d950db7373b819d7a221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dMCzJ-h7AhIyZx17"/></div></div></figure><p id="baaa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本节中，我们将添加以下功能:</p><ul class=""><li id="4085" class="ly lz hu ji b jj jk jn jo jr ma jv mb jz mc kd md me mf mg dt translated">我们将发送他们，如果当前的职位是最喜爱的用户或没有，使前端可以根据这一事实作出决定</li><li id="0988" class="ly lz hu ji b jj mh jn mi jr mj jv mk jz ml kd md me mf mg dt translated">我们将对路线进行修改，并对控制器功能进行改进</li></ul><h2 id="caf4" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">延伸路线</h2><p id="b30b" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我们只需要对我们的<code class="eh mn mo mp mq b"> <em class="mm">post.route.js</em></code>文件做很少的修改:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="3029" class="ky kz hu mq b fv mz na l nb nc">routes.get(‘/:id’, authJwt, postController.getPostById);<br/>routes.get(‘/’, authJwt, postController.getPostsList);</span></pre><p id="94eb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们只是在这两个现有的行中添加了authJwt。一旦完成，如果我试图获取没有授权头的Post列表，我们将得到一个错误:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff px"><img src="../Images/b139d7c6d825ab6433ace67b609f4f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*64wmF3U7lLH7nPg5"/></div></div></figure><h2 id="dc36" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">扩展用户模型</h2><p id="3b73" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">现在，如果对当前的<code class="eh mn mo mp mq b">Authorized</code>用户有利，我们将在post JSON中添加更多信息。</p><p id="bb25" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">移动到<code class="eh mn mo mp mq b"><em class="mm">user.model.js</em></code>文件，将此功能添加到_收藏夹:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="24b8" class="ky kz hu mq b fv mz na l nb nc">isPostIsFavorite(postId)   {<br/>     if (this.favorites.posts.indexOf(postId)   &gt;= 0) {<br/>       return true;<br/>     }<br/>    return false;<br/>    }</span></pre><p id="26a0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在移动到<code class="eh mn mo mp mq b"><em class="mm">post.controller.js</em></code>文件，修改<code class="eh mn mo mp mq b">getPostById</code>功能:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="f46c" class="ky kz hu mq b fv mz na l nb nc">export   async function getPostById(req, res) {<br/>     try {<br/>       const promise = await Promise.all([<br/>         User.findById(req.user._id),<br/>           Post.findById(req.params.id).populate('user')<br/>       ]);<br/>   <br/>       const favorite = promise[0]._favorites.isPostIsFavorite(req.params.id);<br/>       const post = promise[1];<br/>   <br/>       return res.status(HTTPStatus.OK).json({<br/>         ...post.toJSON(),<br/>         favorite<br/>       });<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }</span></pre><p id="b930" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里，我们刚刚添加了一个新的字段收藏夹，它将反映在如下的Post API中:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/6a9df21ad77fde4d0ed19d667d278206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/0*vn80tbNVK94N5vaC"/></div></figure><p id="e0b4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还将修改我们的<code class="eh mn mo mp mq b">getPostsList</code>函数，以包含一个承诺并返回适当的响应:</p><pre class="mr ms mt mu fq mv mq mw mx aw my dt"><span id="74ac" class="ky kz hu mq b fv mz na l nb nc">export   async function getPostsList(req, res) {<br/>     const limit = parseInt(req.query.limit, 0);<br/>     const skip = parseInt(req.query.skip, 0);<br/>     try {<br/>       const promise = await Promise.all([<br/>         User.findById(req.user._id),<br/>         Post.list({ limit, skip })<br/>       ]);<br/>   <br/>       const posts = promise[1].reduce((arr, post) =&gt; {<br/>         const favorite = promise[0]._favorites.isPostIsFavorite(post._id);<br/>   <br/>         arr.push({<br/>           ...post.toJSON(),<br/>           favorite<br/>         });<br/>   <br/>         return arr;<br/>       }, []);<br/>   <br/>       return res.status(HTTPStatus.OK).json(posts);<br/>     } catch (e) {<br/>       return res.status(HTTPStatus.BAD_REQUEST).json(e);<br/>     }<br/>   }</span></pre><p id="7296" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们现在运行并获取所有帖子:</p><figure class="mr ms mt mu fq iv fe ff paragraph-image"><div class="fe ff py"><img src="../Images/6c88058c275175453f1be56066e22dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*qXD8F_L18EcTdES6"/></div></figure><p id="6b8f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">非常好。最后但并非最不重要的是，API有越来越多的话题，我们应该知道，如安全性，速率限制，最佳做法，我希望你喜欢这个，不要浪费你的时间</p><h1 id="e20e" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">信用</h1><p id="58d4" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">这篇文章中的所有知识来自于youtube系列</p><h1 id="3415" class="nh kz hu bd la ni nj nk le nl nm nn li no np nq ll nr ns nt lo nu nv nw lr nx dt translated">如果您想了解更多关于节点API的知识</h1><h2 id="f455" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated"><a class="ae ke" href="http://flyy.link/nodejs-api-udemy" rel="noopener ugc nofollow" target="_blank"> Node.js:构建RESTful APIs的完整指南(2018) </a></h2><p id="3c5f" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated"><strong class="ji hv">4.7(1775评分)| | 10171学员|| 15小时</strong> <br/>学习用Node、Express和MongoDB构建快速、可伸缩、安全的RESTful服务，从设置到生产<a class="ae ke" href="http://flyy.link/nodejs-api-udemy" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">了解更多</strong> </a>。</p><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.1638522&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fnodejs-master-class%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">Node.js:构建RESTful APIs的完整指南(2018)</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">从安装到生产，学习使用Node、Express和MongoDB构建快速、可扩展和安全的RESTful服务</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="pz l kt ku kv kr kw ja ki"/></div></div></a></div><h2 id="bdb4" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated"><a class="ae ke" href="http://flyy.link/API-development-in-Node" rel="noopener ugc nofollow" target="_blank">Node、Express、ES6、&amp; MongoDB </a>的API开发初学者</h2><p id="8826" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated"><strong class="ji hv">4.0(1164评分)| | 10282名学生|| 18小时<br/> </strong>构建iOS应用可以对话的API&amp;Android应用可以在Node中将API部署到live服务器在API可以对话的服务器上部署live MongoDB实例在ES6中编写代码用于API开发或用于一般编程<br/> <a class="ae ke" href="http://flyy.link/API-development-in-Node" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">了解更多</strong>。</a></p><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.1009254&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fapi-development%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">Node、Express、ES6和MongoDB中的初级API开发</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">REST API后端开发。构建节点API和restful express API</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="qa l kt ku kv kr kw ja ki"/></div></div></a></div><h2 id="41fb" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">或者更高级的话题</h2><h2 id="7b84" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated"><a class="ae ke" href="http://flyy.link/node-advance" rel="noopener ugc nofollow" target="_blank">节点JS:高级概念</a></h2><p id="b2dc" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated"><strong class="ji hv">4.7(1570收视率)| | 11815</strong><strong class="ji hv">学员|| 16小时<br/> </strong>用Node进阶。Js！用Redis学习缓存，通过集群加速，用S3和Node添加图片上传！<a class="ae ke" href="http://flyy.link/node-advance" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">了解更多</strong> </a>。</p><div class="kf kg fm fo kh ki"><a href="https://click.linksynergy.com/link?id=qt/jYwyHv8A&amp;offerid=358574.1587718&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fadvanced-node-for-developers%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">Node JS:高级概念| Udemy</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">使用Node获得高级功能。Js！用Redis学习缓存，通过集群加速，用S3和…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">click.linksynergy.com</p></div></div><div class="kr l"><div class="qb l kt ku kv kr kw ja ki"/></div></div></a></div><h2 id="0caa" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">结束语:</h2><p id="ba1b" class="pw-post-body-paragraph jg jh hu ji b jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd hn dt translated">我在<a class="ae ke" href="http://reactninja.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv"> React Ninja </strong> </a>上发表关于Node、Laravel、React、React Native以及其他一切与web开发相关的文章。一定要在<a class="ae ke" href="https://twitter.com/reactninjaio" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">推特</strong> </a>上关注我。</p><p id="9a48" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">想雇佣我为你的博客写稿请查看我的</strong><a class="ae ke" href="https://www.fiverr.com/krissanawat/write-programming-blogs-or-articles" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">Fiverr</strong></a><strong class="ji hv">page</strong></p><p id="b7dd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">加入我们的<a class="ae ke" href="https://reactninja.io/subscribe-our-newsletter/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hv">简讯</strong> </a> <strong class="ji hv"> </strong>获取最新最棒的内容，让你成为更好的开发者。</p><h2 id="d189" class="ky kz hu bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls dt translated">如果这篇文章有帮助，请点击拍手👏按钮下面几下，以示支持！⬇⬇</h2></div></div>    
</body>
</html>