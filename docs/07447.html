<html>
<head>
<title>Event Sourcing Using Writer Monad</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Writer Monad的事件源</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/event-sourcing-using-writer-monad-b26a390285a?source=collection_archive---------4-----------------------#2018-09-02">https://medium.com/hackernoon/event-sourcing-using-writer-monad-b26a390285a?source=collection_archive---------4-----------------------#2018-09-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8be8847a1dc1caf4bf3c2a62e504a180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*goFqVeok6d7I9gbL"/></div></div></figure><p id="f048" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在之前的帖子中(<a class="ae ka" href="https://hackernoon.com/a-monad-writer-for-f-26aa987e4a3a" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="kb">【A Writer Monad for F #</em></strong></a><strong class="je hv"><em class="kb">，</em> </strong> <a class="ae ka" href="https://hackernoon.com/how-to-log-in-apache-spark-a-functional-approach-e48ffbbd935b" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> <em class="kb">如何登录Apache Spark，A Functional Approach</em></strong></a>)，我们讨论了使用Writer Monad作为聚合事件的方式的想法。然而，我们使用的是一个简单的文本记录器，与我们在应用程序中使用的任何常规记录器只有一些小的不同。</p><p id="3e2a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从这个角度来看Writer monad，它似乎只是为日志聚合付出了额外的努力，实现细节可能会让这个概念的新手不知所措。</p><p id="2d1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我们将把Writer monad作为一个事件聚合器，它可以以一种更通用的方式用于不同的用例，这表明它具有更广泛的可用性。我们还将使用c#来展示这个概念不仅局限于所谓的纯T21函数式语言，而且可以在我们选择的任何环境中使用。</p><p id="7ad5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">主要思想是使用事件源概念以及作为主要数据结构的Writer monad来提供一种聚合事件的方法，以支持这项工作。</p><h1 id="80e1" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">活动采购</h1><p id="4321" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">事件源是一种使用不可变结构记录传入系统的事件的方法，这样我们就可以跟踪影响系统状态的事件。这些事件应该可以在任何时候重放，并且连续的事件流应该集中在一个系统状态上，该状态可以通过以时序方式重放记录的事件来恢复或复制。</p><h1 id="0aa5" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">为什么是作家莫纳德？</h1><p id="aced" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Writer monad呈现了与上述相同的特性，它可以记录使当前系统状态发生变化的一般事件。同时，事件被记录在不可变的结构中，而当前状态仅通过新事件的应用而改变。</p><h1 id="e604" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">计算器日志</h1><p id="28ef" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">让我们从一个简单的例子开始，一个计算器实现。</p><p id="602b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的计算器可以做一些运算，但是它使用Writer monad跟踪它所做的运算。这个最初的例子类似于我们在以前的文章中展示的。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="be96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们的计算器是基于一个我们称之为<code class="eh ll lm ln lo b">Writer</code>的结构定义的，我们将在下面定义这个结构。主要思想是每个操作只知道如何用它所做的操作创建一个<code class="eh ll lm ln lo b">Writer</code>。</p><p id="5a5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">书写者单子可以定义如下。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="cd25" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们定义了以下操作。</p><ul class=""><li id="7b8f" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated"><code class="eh ll lm ln lo b">Bind</code>，通过构造函数，允许我们创建新的<code class="eh ll lm ln lo b">Writer</code>。</li><li id="37e5" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ll lm ln lo b">Map</code>允许我们改变当前状态。</li><li id="1f8e" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ll lm ln lo b">FlatMap</code>改变当前状态，同时记录状态变化如何发生。</li><li id="52dc" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ll lm ln lo b">Unsafe</code>检索当前状态和事件日志。</li></ul><p id="3c7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，改变状态的唯一方法是通过<code class="eh ll lm ln lo b">.Map</code>和<code class="eh ll lm ln lo b">.FlatMap</code>。</p><p id="142f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用这种结构，我们可以按以下方式使用计算器。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="62dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用<code class="eh ll lm ln lo b">.UnSafe()</code>，我们可以获得当前状态和事件日志。</p><p id="d5b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个特殊的例子中，我们只使用Writer monad作为一个<em class="kb">字符串</em>日志，也许正因为如此，这看起来并不那么有趣。然而，这些是我们下一个例子的基础。</p><h1 id="165d" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">总和聚集器</h1><p id="17dd" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">这个例子展示了我们如何使用Writer monad来记录系统中发生的一系列整数事件，同时保存流处理器接收到的值的总和。</p><p id="ea7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">先定义一下我们的出处。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="252c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们所见，我们将使用一个由随机整数组成的无界/无限<em class="kb">流</em>。</p><p id="da5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们看看如何使用Writer monad来接收和处理这些事件。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="6f6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个非常清晰的事件源示例，当事件不变时，通过重放它们，我们可以获得完全相同的最终状态，在这种特定情况下，它是收到的值的总和。</p><h1 id="2c8b" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">银行账户用例</h1><p id="06f5" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我们的最后一个例子将展示如何使用Writer monad来处理发送到银行帐户的事件。一个银行账户支持两个基本的操作，存钱和取钱。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="649a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，假设我们有一个事件生成器，它生成的事务将由我们的编写器monad作为流处理器来处理。</p><p id="eb1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事务由类型<code class="eh ll lm ln lo b">Extraction</code>和<code class="eh ll lm ln lo b">Deposit</code>表示，这两个是我们将要处理的事件类型。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="1f79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有了一个事务源，我们从初始化初始状态开始。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="5c18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们处理一些事件，在这种情况下，我们对其中的100个事件感兴趣，但实际上，这可能是任何数字。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="68ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，对于每笔交易，我们都通过<code class="eh ll lm ln lo b">accountState</code>上的<code class="eh ll lm ln lo b">.FlatMap</code>对银行账户执行相应的操作。</p><p id="ab87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们能够检索帐户的当前(最终)状态和已处理的事件。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="02de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有趣的是，当我们以相同的初始状态开始，然后将Writer monad日志上相同的事务应用到初始状态时，我们应该以相同的最终状态结束。值的状态变化是日志中记录的操作的直接结果。</p><h1 id="823c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">使用纯功能方法</h1><p id="8405" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">对于那些希望使用纯函数方法并避免变量<code class="eh ll lm ln lo b">accountState</code>突变的人，我们可以在<code class="eh ll lm ln lo b">IEnumerable&lt;T&gt;</code>中添加<code class="eh ll lm ln lo b">.FoldLeft</code>方法。让我们看看怎么做。</p><p id="c82e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们添加一个扩展方法，这样我们就可以在<strong class="je hv"> C# </strong>中做<code class="eh ll lm ln lo b">.FoldLeft</code>。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="2a4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么我们只需要改变我们处理事件的方式。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="f04f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，通过这种方式，我们已经消除了对Writer monad的变异，取而代之的是，我们使用<code class="eh ll lm ln lo b">.FoldLeft</code>和<code class="eh ll lm ln lo b">.FlatMap</code>构建新的变异。</p><h1 id="3dcf" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">结论</h1><p id="275f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">作者monad提出了一种使用不可变日志跟踪变化的函数式方法，这种日志可以在任何编程语言中使用，包括<strong class="je hv"> C# </strong>。</p><p id="a83a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，<code class="eh ll lm ln lo b">.FlatMap</code>的使用允许我们以一种流畅的方式链接操作，这种方式提供了一种促进不变性的声明式流控制。</p><p id="2079" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有时候，写monad被误解了，它只与应用程序日志有关，而应用程序日志是由副作用库控制的空间。然而，Writer monad不仅仅是一个日志记录器，它还是一个事件源，可以用来以一种简洁优雅的方式记录状态变化。</p><p id="91d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还展示了<strong class="je hv"> C# </strong>如何支持这种方法，证明了单子并不局限于<em class="kb">如此纯粹的</em>函数式语言。</p></div></div>    
</body>
</html>