<html>
<head>
<title>Three Patterns for an Effective Cloud Native Development Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的云原生开发工作流的三种模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/three-patterns-for-an-effective-cloud-native-development-workflow-6f59525f5bf1?source=collection_archive---------6-----------------------#2018-09-02">https://medium.com/hackernoon/three-patterns-for-an-effective-cloud-native-development-workflow-6f59525f5bf1?source=collection_archive---------6-----------------------#2018-09-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="59cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多开发人员正在转向“<a class="ae jp" href="https://hackernoon.com/tagged/cloud-native" rel="noopener ugc nofollow" target="_blank">云原生</a>”<a class="ae jp" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a>，无论是利用公共云的服务和便利，还是在他们自己的内部云上部署服务。然而，作为云原生开发空间的一部分出现的新架构和技术——微服务、容器、编排器——需要<a class="ae jp" href="https://www.slideshare.net/dbryant_uk/cncf-webinar-series-creating-an-effective-developer-experience-on-kubernetes" rel="noopener ugc nofollow" target="_blank">新的开发人员工作流模式</a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/6fdc94fa9c3785440190d9c4700c4525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mE50n_PtCA30WiqhubLqwA.png"/></div></div></figure><p id="f704" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我将介绍三种模式，它们是我在过去几年中学习使用云技术时发现的有用模式。</p><h1 id="02df" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">创造一个有效的内部发展循环</h1><p id="538f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">将云<a class="ae jp" href="https://hackernoon.com/infrastructure-as-code-tutorial-e0353b530527" rel="noopener ugc nofollow" target="_blank">基础设施定义为代码</a>并随需应变的能力在我们部署软件的方式上是革命性的。然而，尽管基础设施的初始化很快，但它通常不是瞬时的(如您可能希望的那样，在TDD周期中)。这意味着需要提供基础设施以完成构建和部署周期的开发人员通常无法获得他们所需的快速反馈。这可能导致任务/上下文切换成为一个问题。对此的解决方案包括模拟本地开发基础设施、可重用的远程基础设施和本地生产开发。</p><p id="3ba7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<a class="ae jp" href="https://github.com/awslabs/aws-sam-cli" rel="noopener ugc nofollow" target="_blank"> AWS SAM Local </a>可以看到模拟的本地开发基础设施模式。该工具提供了一个基于CLI和Docker的生产无服务器环境的复制，以支持使用相关AWS服务(如Amazon API Gateway和DynamoDB)的AWS Lambda功能的高效本地开发。这个工具可以通过服务虚拟化(见下文)来进一步扩展，以模拟服务、内存中的数据存储和中间件，例如<a class="ae jp" href="https://github.com/localstack/localstack" rel="noopener ugc nofollow" target="_blank"> LocalStack </a>，它可以用于模拟像Kinesis和SQS这样的AWS服务。</p><p id="ec14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可重用的远程基础设施模式通常以定制的方式实现，平台团队提供多个测试环境，工程师可以按需租用这些环境。通常，当租约完成时，配置和相应的状态(数据存储)被重置，这使得下一个开发人员可以使用它。开源的Kubernaut工具也为Kubernetes提供了同样的体验，并维护了一个可以按需租用的初始化集群集合。</p><p id="d070" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从本地到生产的开发模式可以说是最<a class="ae jp" href="https://www.datawire.io/what-is-cloud-native/" rel="noopener ugc nofollow" target="_blank">的云原生模式</a>，因为这涉及到开发人员针对生产编写应用程序。为了获得最准确的反馈，开发和测试环境必须尽可能地高保真，显然最像生产的环境是生产本身。Azure提供了<a class="ae jp" href="https://docs.microsoft.com/en-us/azure/dev-spaces/azure-dev-spaces" rel="noopener ugc nofollow" target="_blank">开发空间</a>，允许工程师按需启动托管的Kubernetes集群，并将本地VSCode编辑器连接到其中。该工具管理任何代码变更到容器中的构建和部署，然后近乎实时地部署到开发空间中。</p><p id="2194" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CNCF托管的<a class="ae jp" href="https://www.telepresence.io/" rel="noopener ugc nofollow" target="_blank"> Telepresence </a>工具允许开发人员将他们的本地开发环境代理到Kubernetes集群中，这允许工程师在本地运行和调试任何代码和应用程序，就像在集群中一样。这允许实时开发人员反馈循环，因为可以使用转发到<a class="ae jp" href="http://datawire.io/guide/development/development-environments-microservices/" rel="noopener ugc nofollow" target="_blank">本地开发环境</a>的实际流量(或影子流量)针对本地调试的生产应用和服务发出请求。</p><h1 id="bb9e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">隔离测试范围:服务虚拟化和契约</h1><p id="ecf0" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">云原生系统通常被开发为模块化(基于服务的)系统，这意味着测试单个服务可能具有挑战性，因为需要与外部服务依赖进行交互。显然，服务应该被设计成尽可能的<a class="ae jp" href="https://itnext.io/microservice-testing-coupling-and-cohesion-all-the-way-down-a9f100cda523" rel="noopener ugc nofollow" target="_blank">内聚和松散耦合</a>，这意味着可以独立开发。然而，当这不实际时，或者工程师想要驱动更像生产的测试时，像服务虚拟化和消费者驱动的契约这样的技术可能是有用的模式。</p><p id="8e2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像<a class="ae jp" href="https://hoverfly.io/" rel="noopener ugc nofollow" target="_blank"> Hoverfly </a>、<a class="ae jp" href="http://wiremock.org/" rel="noopener ugc nofollow" target="_blank"> WireMock </a>和<a class="ae jp" href="http://www.mbtest.org/" rel="noopener ugc nofollow" target="_blank"> Mountebank </a>这样的现代服务虚拟化工具充当代理，位于服务和系统之间，捕获流量供以后重放。这允许执行跨多个服务的测试，并记录来自相关服务的相关请求和响应。然后，可以在不运行实际的依赖项本身的情况下重放记录，这对于在CI/CD构建管道中运行隔离测试非常有价值。这两个工具还可以用来从尚不存在的服务生成虚拟响应，Hoverfly允许注入故障，这可以用来以确定的方式测试故障的处理。</p><p id="6b92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">消费者驱动的契约(CDC)不仅可以用来驱动由外向内的服务设计(即API的TDD)，还可以用来验证服务是否提供了所需的功能，并且不会随着服务的发展而退化。Martin Fowler的博客<a class="ae jp" href="https://martinfowler.com/articles/consumerDrivenContracts.html" rel="noopener ugc nofollow" target="_blank">上有一篇关于这方面的优秀文章</a>，尽管这个过程乍看起来令人望而生畏，但以我的经验来看，一旦一个团队对这个方法进行了几次迭代，它就会变得相当机械。</p><h1 id="a020" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">用Canary版本验证功能</h1><p id="60ca" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">云原生系统非常复杂且不断发展，因此生产前的测试通常无法提供功能的完整验证以及与当前生产中运行的系统的交互。这个问题的解决方案是通过金丝雀来减少部署的影响——最初只针对新服务(煤矿中的金丝雀)路由一小部分生产流量，并观察行为和其他KPI，然后逐渐增加流量的百分比，直到新服务接管所有流量。</p><p id="d300" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于与Kubernetes合作的开发人员来说，基于<a class="ae jp" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使代理</a>构建的开源<a class="ae jp" href="https://www.getambassador.io" rel="noopener ugc nofollow" target="_blank">大使API网关</a>，提供了<a class="ae jp" href="https://www.getambassador.io/reference/canary" rel="noopener ugc nofollow" target="_blank">金丝雀测试功能</a>，该功能通过Kubernetes服务上的简单注释来驱动。Istio服务网格还提供了canarying功能，但这必须在Kubernetes之外进行配置。通过一点粘合代码，这两个系统都可以提供功能的自动化金丝雀发布，以及在检测到问题时的自动化回滚。</p><p id="00cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于使用无服务器代码的开发人员，许多云供应商都提供了类似的功能。例如，<a class="ae jp" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda使用函数别名来提供流量转移</a>，可以对其进行编排以提供金丝雀展示。与上面的Kubernetes方法一样，开发人员可以编写一些粘合代码来基于AWS CloudWatch指标自动执行逐步发布和回滚。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lf lg l"/></div></figure></div></div>    
</body>
</html>