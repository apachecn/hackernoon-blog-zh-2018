<html>
<head>
<title>Create SVG line chart in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中创建SVG折线图</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/create-svg-line-chart-in-react-e4dabb009180?source=collection_archive---------7-----------------------#2018-09-02">https://medium.com/hackernoon/create-svg-line-chart-in-react-e4dabb009180?source=collection_archive---------7-----------------------#2018-09-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a5f49cf2f732f840437f615b59e6b3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjWZ5kLRSabG72SPmnnGVQ.png"/></div></div></figure><figure class="jd je jf jg fq iv fe ff paragraph-image"><a href="http://flyy.link/one-month-javscript"><div class="fe ff jc"><img src="../Images/3ef31919498697dd9872b11d7e1a51f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hEPfIK7CeirWjZz41j-1nQ.png"/></div></a></figure><p id="1021" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">今天，我们将在React中创建一个非常简单的svg图表，不需要外部库。</p><p id="0173" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">JavaScript知识是必需的，与react熟悉预期。假设您已经安装了节点<code class="eh kf kg kh ki b">create-react-app</code>。如果你还没有设置好工具，我已经在另一个教程中详细讲解过了。跟着那个，然后回来。</p><p id="e99f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是我们的图表最后的样子。</p><p id="4b48" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用创建react应用程序</p><p id="95a2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">create-react-app reactdev-svg-chart</code></p><p id="489e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用以下命令转到目录</p><p id="df58" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">cd reactdev-svg-chart</code></p><p id="f127" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">启动应用程序时使用</p><p id="a64a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">npm start</code></p><p id="3a7a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它应该会在您的默认浏览器上打开一个欢迎屏幕。</p><figure class="jd je jf jg fq iv fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/9e3700e23d2282409619fbff85e5f176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/0*6sVIWk73YPiP0vKI"/></div></figure><h1 id="7e2d" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">什么是SVG？</h1><p id="213d" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们正在创建一个SVG图表，所以你必须知道什么是SVG。</p><blockquote class="lo lp lq"><p id="b413" class="jh ji lr jj b jk jl jm jn jo jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd ke hn dt translated">SVG代表可缩放矢量图形。它允许创建基于矢量的形状。矢量图形是独立的，是根据数学规则创建的，如直线或圆。它们加载速度快，可搜索，模块化。</p></blockquote><h1 id="6a77" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">如何创建一个SVG？</h1><p id="983d" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">让我们看一个简单的SVG:</p><p id="8480" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">&lt;path d = "M 50 60 L 100 100 z"&gt;</code></p><p id="31a2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">path</code>在创建svg的标签中</p><p id="cee9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">d</code>包含路径指令列表</p><p id="5ae3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">M</code>表示<em class="lr">移动到</em>。</p><p id="218d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">50 60</code>是坐标。x =50，y = 60</p><p id="89cb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">L</code>表示<code class="eh kf kg kh ki b">Line To</code></p><p id="81e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">100 100</code>是另一个坐标。</p><p id="2380" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">z</code>表示结束或关闭</p><p id="704e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以<code class="eh kf kg kh ki b">&lt;path d = "M 50 60 L 100 100 z"&gt;</code>可以用简单的英语解释为</p><blockquote class="lo lp lq"><p id="fde6" class="jh ji lr jj b jk jl jm jn jo jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd ke hn dt translated">移动到(50，60)并创建一条到(100，100)的线，然后关闭SVG元素。</p></blockquote><p id="c43e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该路径包含在要呈现的svg标记中。</p><p id="3bce" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很简单，对吧？还有更多的属性可以使用，在<a class="ae kj" href="https://www.w3schools.com/graphics/svg_path.asp" rel="noopener ugc nofollow" target="_blank"> W3Schools </a>查阅。</p><h1 id="fe75" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">那么我们在React上用SVG做什么呢？</h1><p id="6e2c" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们将使用来自React的数据来创建基于SVG的图表。</p><h1 id="e070" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">在React上创建数据</h1><p id="6621" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">这是第一个任务，创建将传递给svg元素的数据。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="c492" class="lz km hu ki b fv ma mb l mc md">import React, { Component } from 'react'<br/>import './App.css'<br/><br/>class App extends Component {<br/>  randomArray = (total = 10) =&gt; {<br/>    let data = []<br/>    for (let element = 0; element &lt; total; element++) {<br/>      const y = Math.floor(Math.random() * 50) + 50<br/>      const obj = {<br/>        x: element,<br/>        y,<br/>      }<br/>      data.push(obj)<br/>    }<br/>    return data<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        {/*Render SVG Chart here!*/}<br/>        {/**/}<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}<br/>export default App</span></pre><p id="cb30" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">randomArray()</code>为我们的目的创建对象w =的随机数组。</p><p id="9e89" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要像<code class="eh kf kg kh ki b">[{x:0, y:54}, {x:1, y:72}, ...]</code>这样的数据。y坐标将介于50和100之间。</p><p id="edf1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以手动提供这些数据，但是我选择随机提供。需要的随机值的数量可以作为参数传递，或者使用默认值。</p><blockquote class="lo lp lq"><p id="723d" class="jh ji lr jj b jk jl jm jn jo jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd ke hn dt translated"><strong class="jj hv">注意:</strong><code class="eh kf kg kh ki b">(0, 0)</code>坐标位于屏幕左上角，<code class="eh kf kg kh ki b">(maxX, maxY)</code>位于右下角。不要混淆！</p></blockquote><h1 id="d9fe" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">折线图</h1><p id="c7ef" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">在<code class="eh kf kg kh ki b">./src/</code>中创建另一个文件<code class="eh kf kg kh ki b">LineChart.js</code>。它将包含<code class="eh kf kg kh ki b">LineChart</code>组件。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="d5b5" class="lz km hu ki b fv ma mb l mc md">import React, { Component } from 'react'<br/>import './LineChart.css'<br/>class LineChart extends Component {<br/>  render() {<br/>    return &lt;svg /&gt;<br/>  }<br/>}<br/>LineChart.defaultProps = {<br/>  data: [],<br/>color: '#ff4500',<br/>  svgHeight: 200,<br/>  svgWidth: 600,<br/>}<br/>export default LineChart</span></pre><p id="2145" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">道具:</p><p id="0b88" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">data</code>空数组，数据将被传递。</p><p id="ee50" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">color</code>默认为橙色</p><p id="774c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">svgHeight</code>和<code class="eh kf kg kh ki b">svgWidth</code>指的是svg元素的高度和宽度。</p><p id="05f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">linechart . CSS文件在哪里？</strong></p><p id="51bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它在这里，但是如果你卡住了，所有的代码都在这个GitHub库上。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="e9c0" class="lz km hu ki b fv ma mb l mc md">.linechart_path {<br/>  stroke-width: 2;<br/>  fill: none;<br/>}<br/><br/>.linechart_axis {<br/>  stroke: #000000;<br/>}</span></pre><h1 id="a1f6" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">SVG的最小和最大值！</h1><p id="eb83" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">在绘制数据图表之前，我们需要知道数据中的最小值和最大值。</p><p id="fc1f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">getMinX和getMinY是用于此目的的辅助函数。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="9a17" class="lz km hu ki b fv ma mb l mc md">getMinX() {<br/>        const {data} = this.props <br/>       const  only_x = data.map(obj =&gt; obj.x)<br/>        const min_x = Math.min.apply(null, only_x),<br/>        return min_x<br/>    }<br/>    getMinY() {<br/>        const { data } = this.props <br/>        const  only_y = data.map(obj =&gt; obj.y)<br/>        const min_y = Math.min.apply(null, only_y),<br/>        return min_y<br/>    }<br/>    getMaxX() {<br/>        const {data} = this.props <br/>       const  only_x = data.map(obj =&gt; obj.x)<br/>        const max_x = Math.max.apply(null, only_x),<br/>        return max_x<br/>    }<br/>    getMaxY() {<br/>        const { data } = this.props <br/>        const  only_y = data.map(obj =&gt; obj.y)<br/>        const max_y = Math.max.apply(null, only_y),<br/>        return max_y<br/>    }</span></pre><p id="bb9f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们有了最小和最大的x和y坐标，我们还需要svg坐标。</p><h1 id="803b" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">SVG坐标创建器</h1><p id="91a4" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">它将为对应于我们数据中的点的每个点创建svg坐标。</p><p id="402f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要x和y坐标，所以我们使用两个函数。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="3e38" class="lz km hu ki b fv ma mb l mc md">getSvgX(x){<br/>        const { svgWidth } = this.props;<br/>        return (x / this.getMaxX() * svgWidth);<br/>    }<br/>    getSvgY(y) {<br/>        const { svgHeight } = this.props;<br/>        return svgHeight - (y / this.getMaxY() * svgHeight);<br/>    }</span></pre><p id="de10" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">x/MaxX * width</code>均匀划分svg元素的宽度。</p><h1 id="7320" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">创建svg折线图</h1><p id="f6a2" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们需要为每个元素创建路径，为此我们调用了另一个函数<code class="eh kf kg kh ki b">makePath()</code>。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="b570" class="lz km hu ki b fv ma mb l mc md">makePath() {<br/>    const { data, color } = this.props<br/>    let pathD = ` M  ${this.getSvgX(data[0].x)} ${this.getSvgY(data[0].y)} `<br/><br/>    pathD += data.map((point, i) =&gt; {<br/>      return `L ${this.getSvgX(point.x)} ${this.getSvgY(point.y)}  `<br/>    })</span></pre><p id="3cd9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它从道具中获取数据和颜色。</p><p id="5840" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">pathD使路径移动到第一个坐标，这是指路径中的d属性。</p><p id="9bec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于数据中的每个坐标值，返回从上一个到当前的行。</p><p id="861e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一新行附加在前一行的后面。</p><p id="76c0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">className</code>用于造型。</p><h1 id="4542" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">创建网格</h1><p id="8271" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">图表已创建，但它没有容器，因此图表中的点没有意义。</p><p id="3051" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了使图表有意义，必须有轴。轴是:左垂直，下水平。</p><p id="a7a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为此，我们使用了另一个辅助函数<code class="eh kf kg kh ki b">makeAxis()</code>。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="c169" class="lz km hu ki b fv ma mb l mc md">makeAxis() {<br/>    const minX = this.getMinX()<br/>    const maxX = this.getMaxX()<br/>    const minY = this.getMinY()<br/>    const maxY = this.getMaxY()<br/>    return (<br/>      &lt;g className="linechart_axis"&gt;<br/>        &lt;line<br/>          x1={this.getSvgX(minX)}<br/>          y1={this.getSvgY(minY)}<br/>          x2={this.getSvgX(maxX)}<br/>          y2={this.getSvgY(minY)}<br/>        /&gt;<br/>        &lt;line<br/>          x1={this.getSvgX(minX)}<br/>          y1={this.getSvgY(minY)}<br/>          x2={this.getSvgX(minX)}<br/>          y2={this.getSvgY(maxY)}<br/>        /&gt;<br/>      &lt;/g&gt;<br/>    )<br/>  }</span></pre><p id="3cde" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们得到最大值和最小值。</p><p id="b0f8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在<code class="eh kf kg kh ki b">g</code>标签中返回两行。它是svg的容器标签，就像其他标签的<code class="eh kf kg kh ki b">div</code>一样。</p><p id="7e3d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">getSvgX</code>和<code class="eh kf kg kh ki b">getSvgY</code>实现起点和终点的坐标。</p><h1 id="0f48" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">绘制轴和线图</h1><p id="904a" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们拥有了我们需要的一切…我们需要做的就是返回<code class="eh kf kg kh ki b">makePath</code>和<code class="eh kf kg kh ki b">makeAxis</code>。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="6c9b" class="lz km hu ki b fv ma mb l mc md">render() {<br/>    const { svgHeight, svgWidth } = this.props<br/><br/>    return (<br/>      &lt;svg viewBox={`0 0 ${svgWidth} ${svgHeight}`}&gt;<br/>        {this.makePath()}<br/>        {this.makeAxis()}<br/>      &lt;/svg&gt;<br/>    )<br/>  }</span></pre><p id="a739" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">视图框从(0，0)开始，一直到我们定义的尺寸。</p><h1 id="6a82" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">主文件</h1><p id="d035" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">除了更新之外，我们什么都做了。</p><pre class="jd je jf jg fq lv ki lw lx aw ly dt"><span id="a45c" class="lz km hu ki b fv ma mb l mc md">import React, { Component } from 'react'<br/>import './App.css'<br/>import LineChart from './LineChart'<br/><br/>class App extends Component {<br/>  randomArray = (total = 10) =&gt; {<br/>    let data = []<br/>    for (let element = 0; element &lt; total; element++) {<br/>      const y = Math.floor(Math.random() * 50) + 50<br/>      const obj = {<br/>        x: element,<br/>        y,<br/>      }<br/>      data.push(obj)<br/>    }<br/>    return data<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;div className="App"&gt;<br/>          &lt;div className="header"&gt;ReactDev SVG Chart&lt;/div&gt;<br/>          &lt;LineChart data={this.randomArray()} /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}<br/>export default App</span></pre><p id="f91a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">导入折线图并返回此组件。数据从<code class="eh kf kg kh ki b">randomArray()</code>通过props传递！</p><figure class="jd je jf jg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/e8faace2d8abcbce96ad148ad9707613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R-bnLI0HTSM4Oxfr"/></div></div></figure><p id="74de" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你的图表不会像上面那样，因为它每次都使用随机数据。</p><p id="d1b1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="lr">最初发表于</em> <a class="ae kj" href="https://reactninja.io/2018/06/20/create-svg-line-chart-in-react/" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">反应过来的忍者</strong> </a> <em class="lr">。</em></p><h1 id="c552" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">特色React JS课程</h1><h2 id="bdbc" class="lz km hu bd kn mf mg mh kr mi mj mk kv js ml mm kz jw mn mo ld ka mp mq lh mr dt translated"><a class="ae kj" href="http://thebestdevlist.link/react-the-complete-16-guide-incl-redux" rel="noopener ugc nofollow" target="_blank"> React 16 —完整指南(包括React路由器4 &amp; Redux) </a></h2><p id="f88e" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">4.7/5星<strong class="jj hv"> || </strong> 33.5小时视频<strong class="jj hv">| |</strong>61597名学生</p><p id="5215" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">学习反应或深入研究。学习理论，解决作业，在演示项目中实践，并构建一个在整个课程中不断改进的大型应用程序:汉堡生成器！<a class="ae kj" href="http://thebestdevlist.link/react-the-complete-16-guide-incl-redux" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">了解更多。</strong>T19】</a></p><div class="ms mt fm fo mu mv"><a href="http://thebestdevlist.link/react-the-complete-16-guide-incl-redux" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">React 16 —完整指南(包括React Router 4和Redux)</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">投身其中，从头开始学习React！了解Reactjs、Redux、React Routing、动画、Next.js基础知识以及更多内容！</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">thebestdevlist.link</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ja mv"/></div></div></a></div><h2 id="1489" class="lz km hu bd kn mf mg mh kr mi mj mk kv js ml mm kz jw mn mo ld ka mp mq lh mr dt translated">【React专业化的全栈Web开发</h2><p id="3dc5" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">构建完整的Web和混合移动解决方案。在Coursera <a class="ae kj" href="http://thebestdevlist.link/coursera-full-stack-react" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">注册的四门综合课程中掌握前端web、混合移动应用程序和服务器端开发，开始为期7天的完全免费试用。</strong>T25】</a></p><div class="ms mt fm fo mu mv"><a href="http://thebestdevlist.link/coursera-full-stack-react" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab ej"><div class="mx ab my cl cj mz"><h2 class="bd hv fv z el na eo ep nb er et ht dt translated">使用React | Coursera进行全栈Web开发</h2><div class="nc l"><h3 class="bd b fv z el na eo ep nb er et ek translated">香港科技大学React的全栈Web开发。学习前端和…</h3></div><div class="nd l"><p class="bd b gc z el na eo ep nb er et ek translated">thebestdevlist.link</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ja mv"/></div></div></a></div><h1 id="e66f" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">结束语:</h1><p id="ba1b" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我在<a class="ae kj" href="http://reactninja.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> React Ninja </strong> </a>上发表React、React Native以及其他一切与web开发相关的文章。一定要在<a class="ae kj" href="https://twitter.com/reactninjaio" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">推特</strong> </a>上关注我。</p><p id="b7dd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">加入我们的<a class="ae kj" href="https://reactninja.io/subscribe-our-newsletter/" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">简讯</strong> </a> <strong class="jj hv"> </strong>获取最新最棒的内容，让你成为更好的开发者。</p><h2 id="d189" class="lz km hu bd kn mf mg mh kr mi mj mk kv js ml mm kz jw mn mo ld ka mp mq lh mr dt translated">如果这篇文章有帮助，请点击拍手👏按钮下面几下，以示支持！⬇⬇</h2></div></div>    
</body>
</html>