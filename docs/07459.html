<html>
<head>
<title>Which Data Structure Should I Use? An Elixir Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我应该使用哪种数据结构？灵丹妙药秘籍</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/which-data-structure-should-i-use-an-elixir-cheat-sheet-80b662185e5b?source=collection_archive---------16-----------------------#2018-09-02">https://medium.com/hackernoon/which-data-structure-should-i-use-an-elixir-cheat-sheet-80b662185e5b?source=collection_archive---------16-----------------------#2018-09-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/b7e2957bcb26acb99d4b0c618b908a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*rucT5KfD0pNLg6JfyYlVxg.jpeg"/></div></figure><p id="caef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">作为一个Elixir新手，我认为开始使用<br/> Elixir最困难的事情之一是弄清楚使用哪种数据结构。我的团队最近开始全力以赴研究长生不老药，所以我一直在认真温习。然而，我经常会阅读我团队的一些代码，甚至很难理解我在看什么。语法看起来非常类似于Ruby(我对此非常了解)，但是模式、约定和数据结构只是略有不同。在我看来，这是有意义的，因为它是一种函数式语言，而不是面向对象的语言:在Ruby中使用对象，而在Elixir中可能正在生成进程。</p><p id="54de" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是不管怎样，既然我现在正在学习Elixir，我认为提供一个备忘单或者我作为一个探索Elixir的ruby专家所注意到的数据结构差异的概述是有用的。</p><h2 id="7311" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">数据类型</h2><p id="41ab" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">如果您来自Ruby(或大多数其他编程语言)，那么整数、<br/>浮点数、范围和正则表达式可能对您来说都很熟悉<br/>。幸运的是，这些都存在于长生不老药中。有几个<br/>区别，但是我还没有过多处理。</p><p id="7667" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">原子就像红宝石中的符号。它们以冒号开头，它们的名字就是它们的值。例如，<code class="eh ky kz la lb b">:hello</code>是酏剂中的有效原子。它们通常被用来标记值。</p><p id="1130" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">仙丹里也有字符串。字符串总是有双引号，而查理斯是单引号。字符串是二进制的，charlists实际上只是代码点的列表。到目前为止我很少用查理斯。</p><p id="3ad4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">以下是这些类型的快速浏览</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="0dce" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; 2         # integer<br/>iex&gt; 2.0       # floating point<br/>iex&gt; false     # boolean<br/>iex&gt; 1..4      # range<br/>iex&gt; ~r/hello/ # regular expression<br/>iex&gt; :hello    # atom<br/>iex&gt; “world”   # string<br/>iex&gt; ‘world’   # charlist</span></pre><p id="a456" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Elixir有额外的数据类型，<code class="eh ky kz la lb b">Port</code>和<code class="eh ky kz la lb b">PID</code>，它们在进程通信中使用<br/>。它们是通过Erlang VM可用的实体。</p><h2 id="2b2b" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">港口</h2><p id="f4ac" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">一个<code class="eh ky kz la lb b">Port</code>用于与<br/>应用程序外部的资源进行通信(读/写)。它们非常适合启动操作系统进程并与它们通信。例如，你可能想打开一个端口来运行一个操作系统命令，比如<code class="eh ky kz la lb b">echo.</code></p><p id="ce69" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可以打开一个端口并向它发送一条消息，就像这样:</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="1e47" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; port = Port.open({:spawn, “echo sup”}, [:binary])<br/>#Port&lt;0.1305&gt;</span></pre><p id="f0fa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，您可以使用<code class="eh ky kz la lb b">flush()</code> IEx助手打印来自<br/>端口的消息。</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="0e0f" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; port = Port.open({:spawn, “echo sup”}, [:binary])<br/>#Port&lt;0.1305&gt;<br/>iex&gt; flush()<br/>iex&gt; {#Port&lt;0.1305&gt;, {:data, “sup\n”}}<br/>iex&gt; :ok</span></pre><p id="9e2c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可以向端口发送您想要执行的二进制文件的任何名称。比如从我的jekyll博客的目录下<br/>打开一个<code class="eh ky kz la lb b">iex</code>会话，打开一个<br/>端口，然后发送<code class="eh ky kz la lb b">bundle install</code>命令，安装了所有的<br/> Ruby gem依赖项。下面是输出的一个片段。</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="5267" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; port = Port.open({:spawn, “bundle install”}, [:binary])<br/>#Port&lt;0.1306&gt;<br/>iex&gt; flush()<br/>{#Port&lt;0.1306&gt;, {:data, “Using concurrent-ruby 1.0.5\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using i18n 0.9.5\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using minitest 5.11.3\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using thread_safe 0.3.6\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using tzinfo 1.2.5\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using activesupport 4.2.10\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using public_suffix 2.0.5\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using addressable 2.5.2\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using bundler 1.16.2\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using coffee-script-source 1.11.1\n”}}<br/>{#Port&lt;0.1306&gt;, {:data, “Using execjs 2.7.0\n”}}<br/>{#Port&lt;0.1306&gt;,<br/> {:data,<br/> “Bundle complete! 4 Gemfile dependencies, 85 gems now installed.\nUse `bundle info [gemname]` to see where a bundled gem is installed.\n”}}<br/>:ok</span></pre><h2 id="f4a7" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">PID</h2><p id="9a08" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">一个<code class="eh ky kz la lb b">PID</code>是对一个进程的引用。每当你产生一个新的进程，你就会得到一个新的PID。预计会谈论很多关于PID的内容。您可能需要将<br/>放在PID上，这样您就可以发送不同的进程消息。</p><p id="3923" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是一个生成进程并取回PID的例子。</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="f2bd" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; pid = spawn fn -&gt; IO.puts(“hello world”) end<br/>iex&gt; hello world<br/>iex&gt; #PID&lt;0.123.0&gt;</span></pre><p id="7da5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">该进程在完成其工作后终止。PID和端口保证它们自己独立的post，但是现在，我认为只要知道它们的存在就足够了。</p><p id="d531" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们已经添加了新的类型，这是我们的基本备忘单。</p><h1 id="bfa5" class="lo jz hu bd ka lp lq lr ke ls lt lu ki lv lw lx kl ly lz ma ko mb mc md kr me dt translated">Elixir数据类型备忘单</h1><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="6077" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; 2         # integer<br/>iex&gt; 2.0       # floating point<br/>iex&gt; false     # boolean<br/>iex&gt; 1..4      # range<br/>iex&gt; ~r/hello/ # regular expression<br/>iex&gt; :hello    # atom<br/>iex&gt; “world”   # string<br/>iex&gt; ‘world’   # charlist<br/>iex&gt; #Port&lt;0.1306&gt; # port<br/>iex&gt; #PID&lt;0.123.0&gt; # pid</span></pre><p id="176a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不过，在我看来，使用Elixir的真正挑战是弄清楚如何<br/>将这些基本数据类型组织成您可以使用的结构。所以让我们来看一看<br/>不同的集合类型以及为什么你会使用每一种。</p><h1 id="46c2" class="lo jz hu bd ka lp lq lr ke ls lt lu ki lv lw lx kl ly lz ma ko mb mc md kr me dt translated">集合类型</h1><p id="d092" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">以下是您可能会遇到的集合类型:<br/> -元组<br/> -列表<br/> -关键字列表<br/> -映射<br/> -结构</p><p id="ddab" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可能以前听过这些词，至少是顺便听过，但是如果你习惯了Ruby，你可能会想为什么你需要所有这些额外类型的集合。我们来调查一下。</p><h2 id="a209" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">元组</h2><p id="7d69" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">元组是值的有序集合。它们看起来像这样:</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="5ad9" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; {:hello, “world”}<br/>iex&gt; {1, 2}<br/>iex&gt; {:ok, “this is amazing!”, 2}</span><span id="72ea" class="jy jz hu lb b fv mf ll l lm ln"># You can check if it’s really a tuple<br/>iex&gt; tuple = { “hello”, “world”}<br/>iex&gt; is_tuple tuple<br/>iex&gt; true</span><span id="d37a" class="jy jz hu lb b fv mf ll l lm ln"># and then you can get an element from a tuple by index<br/>iex&gt; elem(tuple, 1)<br/>iex&gt; “world”</span></pre><p id="c67c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我觉得元组有点野。我的意思是，它们看起来应该是散列，但它们的行为有点像Ruby数组。然后就叫元组！当我第一百次感到困惑的时候，我一直告诉自己，熟悉他们会有回报的。</p><p id="be6c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">元组在长生不老药里到处出现。函数的返回值通常是可以进行模式匹配的元组，所以通过元组来看世界是有意义的。元组通常有两到四个元素，在这一点上，它们是我的首选数据结构。当您处理具有四个以上元素的数据结构时，这可能是使用map或struct的好例子。</p><h2 id="d0d0" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">列表</h2><p id="ee1a" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">列表是链接的数据结构。它们看起来像这样:</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="dc57" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; [1, 2, 3, 4]<br/>iex&gt; [“hello”, “world”]</span></pre><p id="1a50" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在Ruby中，你会认为那是一个数组，但是在Elixir中，它是一个列表！因为列表是作为链接数据结构实现的，所以它们适合递归，但是不适合随机检索元素或者计算长度，因为您需要遍历整个列表来计算大小。迄今为止，我大多使用元组而不是列表。如果您必须在它们之间做出选择，我想您需要考虑集合的预期大小以及您将对其执行何种操作。</p><h2 id="a153" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">关键词列表</h2><p id="4590" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">让事情变得更复杂的是，在Elixir中还有关键字列表这样的东西。本质上，这是一个二值元组列表。</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="019e" class="jy jz hu lb b fv lk ll l lm ln"># keyword list<br/>iex&gt; [ phrase: “oh hello”, name: “tracy” ]</span><span id="ac4b" class="jy jz hu lb b fv mf ll l lm ln"># is actually two-value tuples<br/>iex&gt; [ {:phrase, “oh hello”}, {:name, “tracy”} ]</span></pre><p id="e167" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这继续困扰着我，尽管我意识到它的普遍存在。关键字列表的酷之处在于，在一个关键字列表中可以有两个相同的关键字。</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="210f" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; keyword_list = [food: “peanut butter”, food: “ice cream”, flavor: “chocolate”] # a valid keyword list</span></pre><p id="4150" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">关键字列表适用于命令行参数和选项。</p><h2 id="47e5" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">地图</h2><p id="e7d8" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">接下来是地图。如果你想要一个真正的键值存储，而不是键值列表，这就是你要找的。它们看起来有点像Ruby中的散列。</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="9260" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; %{“greeting” =&gt; “hello”, “noun” =&gt; “world”}<br/>iex&gt; %{:greeting =&gt; “hello”, :noun =&gt; “world”}<br/>iex&gt; %{greeting: “hello”, noun: “world”} # if the keys are atoms, you can skip the hash rockets.</span><span id="a20b" class="jy jz hu lb b fv mf ll l lm ln">iex&gt; greeting = %{spanish: “hola”, chinese: “ni hao”, english: “hello”}<br/>iex&gt; greeting[:spanish]<br/>iex&gt; “hola”<br/>iex&gt; greeting.chinese<br/>iex&gt; “ni hao”</span></pre><p id="d354" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">映射有利于传递关联数据，以及几乎所有大于元组大小的数据。</p><h2 id="9a31" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">结构</h2><p id="018a" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">结构就像增强的映射。它们只允许某些键，而且这些键必须是原子。需要用合理的默认值在模块中定义结构。它们是有规则的地图。</p><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="fca0" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; defmodule IceCream do<br/>…. defstruct flavor: “”, quantity: 0<br/>…. end</span><span id="6e03" class="jy jz hu lb b fv mf ll l lm ln">iex&gt; chocolate = %IceCream{flavor: “chocolate”}<br/>iex&gt; chocolate.flavor<br/>iex&gt; “chocolate”</span></pre><p id="d250" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您将看到该结构是用与map相同的<code class="eh ky kz la lb b">%</code>百分号定义的，但是它后面是模块的名称。这就是我如何提醒自己，他们只是更严格的地图。</p><p id="9ef6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">旧版本的Elixir曾经也包含了用于处理超过几百个值的地图的<code class="eh ky kz la lb b">HashDict</code>，但是这个模块已经被弃用，取而代之的是老式的<code class="eh ky kz la lb b">Map</code>。</p><p id="80a1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就把我们带到了您将在Elixir中看到的常见数据类型和集合类型的末尾。虽然这两种语言有许多不同之处，但也有一些相似之处。当然，关于长生不老药、约定以及您可以做的很酷的事情，还有很多需要学习，但是这(我认为)是熟悉这门语言的良好开端。希望这将作为一个体面的指导，破译任何你可能很快遇到的灵丹妙药！</p><h1 id="acfc" class="lo jz hu bd ka lp lq lr ke ls lt lu ki lv lw lx kl ly lz ma ko mb mc md kr me dt translated">长生不老药收藏备忘单</h1><pre class="lc ld le lf fq lg lb lh li aw lj dt"><span id="8ca4" class="jy jz hu lb b fv lk ll l lm ln">iex&gt; {:ok, “this is amazing!”, 2} # tuple<br/>iex&gt; [“hello”, “world”]           # list<br/>iex&gt; [ phrase: “oh hello”, name: “tracy” ] # keyword list<br/>iex&gt; greeting = %{spanish: “hola”, chinese: “ni hao”, english: “hello”} # map<br/>iex&gt; chocolate = %IceCream{flavor: “chocolate”} # struct</span></pre><h2 id="5f7d" class="jy jz hu bd ka kb kc kd ke kf kg kh ki jj kj kk kl jn km kn ko jr kp kq kr ks dt translated">资源</h2><p id="a5f8" class="pw-post-body-paragraph iy iz hu ja b jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr kx jt ju jv hn dt translated">- <a class="ae jw" href="https://elixir-lang.org/getting-started/basic-types.html" rel="noopener ugc nofollow" target="_blank">基础类型</a>上仙丹<br/>-<a class="ae jw" href="https://pragprog.com/book/elixir16/programming-elixir-1-6" rel="noopener ugc nofollow" target="_blank">-<em class="jx">编程仙丹</em>-</a>下迪夫·托马斯<br/> - <a class="ae jw" href="https://hexdocs.pm/elixir/" rel="noopener ugc nofollow" target="_blank">十六进制文档</a></p></div></div>    
</body>
</html>