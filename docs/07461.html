<html>
<head>
<title>Predicting Cost of Tender with 99.24% Accuracy : Miracle!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以99.24%的准确率预测投标成本:奇迹！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/predicting-cost-of-tender-with-99-24-accuracy-miracle-6cc264621972?source=collection_archive---------18-----------------------#2018-09-02">https://medium.com/hackernoon/predicting-cost-of-tender-with-99-24-accuracy-miracle-6cc264621972?source=collection_archive---------18-----------------------#2018-09-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3751" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>正在达到新的水平，模型也是如此。但是使用简单的特征工程和简单的<strong class="it hv">决策树分类器</strong>达到令人欢呼的99.24%的准确率？</p><p id="7c75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那是新的！</p><p id="444d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大家好，今天我将向大家展示我的模型，它可以预测<a class="ae jp" href="https://www.kaggle.com/city-of-seattle/seattle-trade-permits" rel="noopener ugc nofollow" target="_blank">西雅图贸易许可</a>中投标的价值范围，其高精度为<strong class="it hv"> 99.24 % </strong>(有一些明显的注意事项，我将在最后讨论)。</p><p id="911e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的内核:<a class="ae jp" href="https://www.kaggle.com/uds5501/yet-another-value-prediction" rel="noopener ugc nofollow" target="_blank">又一个值预测</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/b44127d352f6c4f58a462e40ef13f8c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWKFRc7bkJTmqfJY-f4Zow.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">The code reference for this blog</figcaption></figure><h1 id="09c6" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">基础EDA</h1><p id="c168" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">这次，我将使用Python中的plotly库。这实际上是交互式剧情的最佳选择，如果你真的访问了内核，你就会明白为什么。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="b6ac" class="lo kh hu lk b fv lp lq l lr ls">mySummingGroup = df.drop(columns=['Longitude', 'Latitude', 'Application/Permit Number']).groupby(by = 'Contractor').agg({'Value':sum})<br/>x = mySummingGroup['Value'].nlargest(10)<br/>data1 = [Bar(<br/>            y=x,<br/>            x=x.keys(),<br/>            marker = dict(<br/>            color = 'rgba(25, 82, 1, .9)'<br/>            ),<br/>            name = "Contractor's amount earned per project"<br/>    )]</span><span id="d29c" class="lo kh hu lk b fv lt lq l lr ls">layout1 = go.Layout(<br/>    title="Top Grossing Contractors",<br/>    xaxis=dict(<br/>        title='Contractor',<br/>        titlefont=dict(<br/>            family='Courier New, monospace',<br/>            size=18,<br/>            color='#7f7f7f'<br/>        )<br/>    ),<br/>    yaxis=dict(<br/>        title='Total Amount Earned',<br/>        titlefont=dict(<br/>            family='Courier New, monospace',<br/>            size=18,<br/>            color='#7f7f7f'<br/>        )<br/>    )<br/>)<br/>myFigure2 = go.Figure(data = data1 , layout = layout1)<br/>iplot(myFigure2)</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/acfb51512e027770cf7903d15dfced4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lRMj8ezDOOHFW_iN5PJsgg.png"/></div></figure><p id="1440" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们将重点检查西雅图地区总收入最高的承包商，他们从招标收购中获利最多。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="06fc" class="lo kh hu lk b fv lp lq l lr ls">catCount = df.groupby('Category')['Permit Type'].count()<br/>fig = { <br/>    "data":[{<br/>        "values":catCount,<br/>        "labels":catCount.keys(),<br/>        "domain": {"x": [0, 1]},<br/>        "name": "Categories",<br/>        "hoverinfo":"label+percent+name",<br/>        "hole": .4,<br/>        "type": "pie",<br/>        "textinfo": "value"<br/>    }],<br/>    "layout":{<br/>        "title":"Categorical Distribution of Tenders",<br/>        "annotations": [<br/>            {<br/>                "font": {<br/>                    "size": 15<br/>                },<br/>                "showarrow": False,<br/>                "text": "DISTRIBUTION",<br/>                "x": 0.5,<br/>                "y": 0.5<br/>            }]<br/>    }<br/>}</span><span id="dc4a" class="lo kh hu lk b fv lt lq l lr ls">trace = go.Pie(labels = catCount.keys(), values=catCount,textinfo='value', hoverinfo='label+percent', textfont=dict(size = 15))<br/>iplot(fig)</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/4c2adbff929cfc236d302431462d509c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*pc-FBTzYuuZUfTFzWD15kQ.png"/></div></figure><p id="a4a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，人们可以绘制出另一个图表来显示每个项目的收入。但是另一件引起我注意的事情是一个非常高的单户型/复式组合(约占数据的75%)</p><p id="6095" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，有了这个基本的EDA计划，让我们移动到功能<a class="ae jp" href="https://hackernoon.com/tagged/engineering" rel="noopener ugc nofollow" target="_blank">工程</a>！</p><h1 id="cba6" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">特征工程</h1><p id="90ae" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">首先，我们将通过下面列出的编码器对投标值进行编码，这很容易理解。它只是将价值分为5类。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="670a" class="lo kh hu lk b fv lp lq l lr ls"># My Value Encoder<br/>def valueEncoder(value):<br/>    if value &gt; 10000000:<br/>        return 4<br/>    elif value &gt; 100000:<br/>        return 3<br/>    elif value &gt; 10000:<br/>        return 2<br/>    elif value &gt; 100:<br/>        return 1<br/>    else:<br/>        return 0<br/>df['ValueLabel'] = df['Value'].apply(valueEncoder)</span></pre><p id="ca37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这之后，我们继续讨论分类变量的编码。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="d304" class="lo kh hu lk b fv lp lq l lr ls">cat_ohe = OneHotEncoder()<br/>cat_feature_arr = cat_ohe.fit_transform(df[['CategoryLabel']]).toarray()<br/>cat_feature_labels = list(genLabel_cat.classes_)<br/>cat_features = pd.DataFrame(cat_feature_arr, columns=cat_feature_labels)</span><span id="a30e" class="lo kh hu lk b fv lt lq l lr ls">cat_features.head(10)</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/c660742ff1b0420d122664362c185641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1QemG-Hflo5QL2GvGxUWLA.png"/></div></figure><p id="2e60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来的步骤是简单地对状态栏进行二进制编码。之后，如果我们查看Action列，它提到存在21个唯一条目。现在21个特征的二进制编码是不合理的。使用特征哈希怎么样？</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="87ba" class="lo kh hu lk b fv lp lq l lr ls">from sklearn.feature_extraction import FeatureHasher</span><span id="f544" class="lo kh hu lk b fv lt lq l lr ls">fh = FeatureHasher(n_features = 5, input_type = 'string')<br/>hashed_features = fh.fit_transform(df2['Action Type'])<br/>hashed_features = hashed_features.toarray()<br/>df2 = pd.concat([df2, pd.DataFrame(hashed_features)], <br/>          axis=1).dropna()</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/2dc3a2c2c4467162b959eebb471f0039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*D_eAn0exu1dOMcJ07jjY2g.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Example for feature hashing</figcaption></figure><p id="007d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们所有的特性都准备好了，现在是模型开发的时候了！</p><h1 id="b9d0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">模型编程</h1><p id="cfff" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我们用<code class="eh lv lw lx lk b">max_depth = 5</code>做一个简单的决策树分类器，防止过拟合！</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="6e6b" class="lo kh hu lk b fv lp lq l lr ls">from sklearn.tree import DecisionTreeClassifier<br/>myClassifier2 = DecisionTreeClassifier(max_depth = 5, min_samples_leaf = 2)<br/>myClassifier2.fit(X_train, y_train)<br/>predictions2 = myClassifier2.predict(X_test)</span><span id="4bad" class="lo kh hu lk b fv lt lq l lr ls">cnf2 = confusion_matrix(y_test, predictions2)<br/>score2 = accuracy_score(y_test, predictions2)</span><span id="1ad7" class="lo kh hu lk b fv lt lq l lr ls">print ("Confusion Matrix for our Decision Tree classifier is :\n ", cnf2)</span><span id="9406" class="lo kh hu lk b fv lt lq l lr ls">print("While the accuracy score for the same is %.2f percent" % (score2 * 100))</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/b89b2b2b1a747fe7ab0ff1fa8eaa4e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PNDHj57O-1pLM2TnJew0xQ.png"/></div></figure><p id="3411" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如你所见，这对我很有效。高达99.24%的准确率！</p><h1 id="11a4" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">警告！</h1><p id="07c7" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在，现在，在电报讨论中，许多人被准确性得分震惊了。这个模型的召回率和精确度都很好。但是，哪里会出错呢？</p><p id="fb18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我想提醒大家注意，该数据集主要由一个类别控制:单/双工。在对数据集进行了深入了解后，我发现值标签分布如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/f5a472948b98c28c9b65a176a60c071d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*ljYxx6OTOBPdPOgI-4LLDA.png"/></div></figure><p id="cc62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着约99.15 %的数据集由单一价值标签的偿付所支配。</p><p id="1fb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以说实话。如果我的模型仍然在黑暗中射箭，它仍然有98%的机会正确陈述给定的标签，输入是这个数据集的子集！</p><h1 id="0397" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结论</h1><p id="49d2" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">最后，如果你选择的算法是正确的，那么在这样一个有偏差的数据集中获得一个高性能的分类器是非常容易的(你可能需要访问内核来真正理解我为什么这么说)</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>