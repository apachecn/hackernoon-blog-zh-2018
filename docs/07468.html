<html>
<head>
<title>Everything you need to know about React’s Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React的上下文API你需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/everything-you-need-to-know-about-reacts-context-api-e5c8c32ef202?source=collection_archive---------2-----------------------#2018-09-03">https://medium.com/hackernoon/everything-you-need-to-know-about-reacts-context-api-e5c8c32ef202?source=collection_archive---------2-----------------------#2018-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/152ed74f4de8a242df85260adc9d1a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhPdCUJUjuYWsSevEADb9w.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Image credits: <a class="ae ih" href="https://www.robinwieruch.de" rel="noopener ugc nofollow" target="_blank">https://www.robinwieruch.de</a></figcaption></figure><div class=""/><p id="4a46" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React 就是这样一个用户界面库，它在几个月内频繁升级新的特性和概念。在<a class="ae ih" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" rel="noopener ugc nofollow" target="_blank">版本16.3 </a>中的一个额外的概念或特性给了我们上下文<a class="ae ih" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>，它是React中旧的上下文概念的升级版本，允许组件在父子关系之外共享数据。</p><p id="9ef9" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文中，我将向您介绍新的上下文API的基础知识，以及为什么要在下一个基于React的项目中使用它。</p><p id="191e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们开始吧！</p><h1 id="ee4a" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">React中为什么需要上下文API？</h1><p id="932a" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在我们深入研究React升级到Context API的原因之前，让我们先熟悉一些用于介绍React中的数据操作和更新的基本术语。</p><p id="6b00" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在React中，通过使用一些我们称之为道具和状态的术语来更新和操作数据。</p><p id="d72c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">属性可以理解为从父组件传递给子组件的数据或信息。</p><p id="eb1c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">而状态可以很容易地理解为在组件本身中被管理的数据。</p><p id="dbc1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，如果每个组件管理自己的状态，如何在嵌套组件之间共享数据呢？是的，我们确实有传递数据的道具，但这只在父子关系的情况下有效。</p><p id="ab30" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">举例来说，让我们以一个由不同类型的嵌套组件组成的应用程序为例:</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff li"><img src="../Images/f1fd186a9383a816c0db8dcb0cf4b4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnA953CTaUmjcG7jGice0w.png"/></div></div></figure><p id="4491" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如上图所示，Child2是Child的孩子，Child也是Parent的孩子。这使得Child2成为Parent的孙辈。</p><p id="6a03" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，让我们用更简单的方式来理解一些代码:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="ccda" class="ls kg ik lo b fv lt lu l lv lw">class Parent extends React.Component {<br/> state = {<br/> value: ‘Some value’<br/> };<br/> <br/> render() {<br/> return(<br/> &lt;Child value={this.state.value} /&gt;<br/> );<br/> }<br/>}<br/> <br/>const Child = (props) =&gt; (<br/> &lt;Child2 value={props.value} /&gt;<br/>);<br/> <br/>const Child2 = (props) =&gt; (<br/> &lt;div&gt;{props.value}&lt;/div&gt;<br/>);</span></pre><p id="32d8" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的例子中，我们从父组件(这里是父组件)通过它的子组件child发送值，这个子组件应该在组件Child2中使用。在这里，子组件不关心值(prop)，它只传递要在组件Child2中使用的prop。现在，这个例子对你来说可能看起来很简单，你可能会想这有什么问题。</p><p id="35d4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们想象一下，如果我们不仅有一个子组件，还有孙子1和孙子2，或者在父组件和子组件之间有更多的组件。在这种情况下，您需要将道具进一步向下传递到树的每个组件。但是，根据上面提到的道具的定义，值只能在父节点和子节点之间传递。</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff li"><img src="../Images/cee7e8ed6e8c3dc22e64d134eaa8040c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8ds6m4es9z3ZRWwbb2NXQ.png"/></div></div></figure><p id="3a90" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种可能对<a class="ae ih" href="https://www.simform.com/react-performance/" rel="noopener ugc nofollow" target="_blank">反应性能</a>造成严重破坏的问题被称为适当钻孔。简单来说，它涉及到从上层(即父级)到下层组件(如子级、孙级等)的属性传递。在组件树中，中间的组件不关心这些属性。</p><p id="80a2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然你有像Redux这样的库来减轻这种复杂性，但是在这种情况下使用Redux是没有价值的，因为它会使你的应用程序的逻辑更加复杂。然而，这正是React中上下文API的概念发挥作用的地方。</p><h1 id="7a9c" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么时候应该使用React的新上下文API？</h1><p id="1c51" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">使用上下文最适合这样的用例:您的代码库由许多依赖于单个数据的组件组成，但是这些组件嵌套在组件树的深处。</p><p id="b0ea" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下图将让您了解上层、中层和下层组件在组件树中的嵌套深度:</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lx"><img src="../Images/004d02fb5b5cf7203d23f46a1741ae66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xSPwDqBONrPa4zF-xMAPg.png"/></div></div></figure><h1 id="0566" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">使用React新的上下文API之前需要熟悉的事情</h1><p id="56d8" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如上所述，React的新上下文API提供了一种方法，可以在React组件树中传递和存储数据，而无需将数据写入组件层次结构的每一层。它通过利用两种类型的组件来做到这一点:</p><p id="7201" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj il">提供者</strong> —提供者组件用于树的更高层次。它接受一个名为as Value的属性。它充当分层树中的根组件，使得树中的任何子节点都可以访问由上下文提供者提供的值。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="10c5" class="ls kg ik lo b fv lt lu l lv lw">render() {return (<br/>&lt;Provider value={this.state.contextValue}&gt;<br/>{this.props.children}<br/>&lt;/Provider&gt;<br/>);<br/>}</span></pre><p id="91fd" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj il">消费者</strong>——顾名思义，消费者消费被传递的数据，不管它在组件树中的嵌套有多深。这意味着，消费者不一定是提供者的孩子。相反，它可以从组件树的任何地方访问数据。</p><p id="451c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">消费者通过使用render prop API来呈现数据。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="382c" class="ls kg ik lo b fv lt lu l lv lw">render() {return (<br/>&lt;Consumer&gt;<br/>{contextValue =&gt; &lt;Child arbitraryProp={contextValue} /&gt;}<br/>&lt;/Consumer&gt;<br/>)<br/>}</span></pre><h1 id="1060" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">如何在React应用程序中使用上下文？</h1><p id="3bfd" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">既然您已经非常熟悉新的上下文API，现在是时候让您了解如何在应用程序中使用上下文了。</p><p id="cb06" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在React中，您有一个预定义的函数来创建上下文:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="706f" class="ls kg ik lo b fv lt lu l lv lw">const Context = React.createContext();</span></pre><p id="f636" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">React.createContext用于初始化上下文，并传递初始值。它返回一个带有提供者和使用者的对象。提供者和消费者是成对出现的，也就是说，对于每个提供者，都有一个相应的消费者。</p><p id="f339" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面解释的例子非常容易理解。但是，您总是需要处理更复杂的数据，并找到一种方法将这些数据存储在组件树中，以便其他组件可以使用。</p><p id="9335" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们用上下文API重新实现上面的例子:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="a701" class="ls kg ik lo b fv lt lu l lv lw">const Context = React.createContext();<br/>class Parent extends React.Component {<br/>state = { x: 1 };<br/>handleContextChange = x =&gt; this.setState({ x });<br/>render() {<br/>const contextValue = {<br/>data: this.state,<br/>handleChange: this.handleContextChange<br/>};<br/>return (<br/>&lt;Context.Provider value={contextValue}&gt;<br/>&lt;Child/&gt;<br/>&lt;/Context.Provider&gt;<br/>);<br/>}<br/>}<br/>const Child = props =&gt; &lt;div&gt;&lt;GrandChild/&gt;&lt;/div&gt;;<br/>const GrandChild = props =&gt; (<br/>&lt;Context.Consumer&gt;<br/>{({ handleChange, data }) =&gt; (<br/>&lt;div&gt;<br/>&lt;button onClick={() =&gt; handleChange(2)}&gt;Change&lt;/button&gt;<br/>&lt;Child2 text={data.x} /&gt;<br/>&lt;/div&gt;<br/>)}<br/>&lt;/Context.Consumer&gt;<br/>);<br/>const Child2 = props =&gt; &lt;p&gt;{props.text}&lt;/p&gt;;</span></pre><p id="1416" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的代码片段中，我们从初始化一个上下文开始。然后我们在属于父组件的顶层使用它。父组件的状态是Context.Provider的值。提供程序获取新值。父组件也被用作我们的状态存储的存储，以便上下文可以将它向下传递到层次结构。</p><p id="39d2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在组件孙中，我们使用了上下文。通过其子渲染属性接收函数的消费者。Upn改变上下文的值。提供者，这个函数被反复调用，最后用新值呈现。</p><p id="68bd" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里，位于父代和孙代之间的组件子代不知道整个上下文安排。子组件2和按钮元素也是如此，因为它们也不知道上下文。这些组件只接收通过它们的prop传递的数据和changeHandler函数，并可以像使用任何其他prop一样进一步使用它们。</p><h1 id="0dd2" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">最后的话</h1><p id="d887" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">React的新上下文API绝对不是Redux或MobX等状态管理库的替代品。两者都不依赖于沿着组件树向下传递上下文。相反，它提供了提供者-消费者组件对来在层次结构中的嵌套组件之间进行通信。</p><p id="302d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">顶层组件提供数据，底层组件使用数据，而不必将数据一层一层地向下传递到组件分层树。</p><p id="12bc" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过这篇文章，您可以开始在应用程序中使用React的上下文API。如果你想进一步了解更多关于API的相关信息，不要忘记阅读官方文档。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="ly lz l"/></div></figure></div></div>    
</body>
</html>