<html>
<head>
<title>C# Async API: The Missing Parts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#异步API:缺失的部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/c-async-api-the-missing-parts-2229a2b3732?source=collection_archive---------3-----------------------#2018-09-03">https://medium.com/hackernoon/c-async-api-the-missing-parts-2229a2b3732?source=collection_archive---------3-----------------------#2018-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e1503b893e63c44dd790689ee9c2b52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dL1SGRDzARZlnU9WfgKfg.jpeg"/></div></div></figure><p id="73ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">许多年前，<strong class="je hv"> C# </strong>介绍了一种运行异步操作的方法，这种方法真正改变了我们编写并发代码的方式。<strong class="je hv"> C# </strong>异步API用于推动并发执行的许多方面。<code class="eh ka kb kc kd b">async / await</code>的引入，以及类似API的<em class="ke">一元</em>，使得这种美丽的语言(<strong class="je hv"> C# </strong>)在编写多线程工作负载时非常受欢迎。然而，时过境迁，其他语言在不断更新其API的同时。NET保持不变。</p><p id="5933" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我们将探索一些<strong class="je hv"> C# </strong>异步API特性，同时将它们与现代<strong class="je hv"> Java </strong>提供的特性进行比较。这并不是要批评这些特性，而是通过编写一些小代码来分析它们，这些代码可能会真正改进这些API。</p><h1 id="1b75" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">运行任务</h1><p id="278c" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">下面的代码显示了如何在<strong class="je hv"> C# </strong>中运行一个简单的任务。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="ec7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们使用<code class="eh ka kb kc kd b">.Result</code>来获取任务返回的值。如您所料，该操作将一直阻塞到值可用，换句话说，它将一直阻塞到任务完成。</p><p id="6026" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在C# 中，一种流行的非阻塞操作方法是使用<code class="eh ka kb kc kd b">async / await</code>，这是这种语言中最有趣的特性之一。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="235d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用<code class="eh ka kb kc kd b">await</code>，我们可以指定计算的下一步(<code class="eh ka kb kc kd b">.WriteLine</code>)，而不用考虑回调，最重要的是，不用阻塞。<code class="eh ka kb kc kd b">await</code>关键字后的代码通过编译器为我们做的一系列转换成为回调。</p><p id="0eb0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最新代码的等价物(在<strong class="je hv"> C# </strong>中)如下。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="67b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，<code class="eh ka kb kc kd b">.ContinueWith</code>中的<em class="ke">λ</em>与上例中的<code class="eh ka kb kc kd b">await</code>代码相同。事实上，这就是编译器在将一个转换成另一个时所做的事情。在这两种方式中，计算都是在没有任何阻塞的情况下执行的，最大化了异步执行。</p><p id="b47f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们刚刚看到的这两个选项展示了我们在<strong class="je hv"> C# </strong>中链接计算阶段的唯一方法，在大多数情况下，它们就足够了。</p><p id="b5aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je hv"> Java </strong>中，前面的例子看起来几乎一样。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="0dfa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，它们基本上是相同的，只是在每个平台上改变了API结构。</p><p id="76f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个有趣的区别是，在<strong class="je hv"> Java </strong>中，<code class="eh ka kb kc kd b">.thenApply</code>函数接收前面计算的结果，而在<strong class="je hv"> C#, </strong> <code class="eh ka kb kc kd b">.ContinueWith</code>接收一个任务，然后我们要从中提取<code class="eh ka kb kc kd b">.Result</code>。</p><p id="767e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je hv"> Java </strong>中，我们也可以像<em class="ke">艺电</em> ( <strong class="je hv"> EA </strong>)提供的那样，通过<a class="ae lo" href="https://github.com/electronicarts/ea-async" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> <em class="ke">库</em> </strong> </a>来使用<code class="eh ka kb kc kd b">await</code>。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="ff1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，<code class="eh ka kb kc kd b">await</code>不是<strong class="je hv"> Java中的保留关键字，</strong>而是一个被调用的函数。不过使用方法和<strong class="je hv"> C# </strong>完全一样。<strong class="je hv"> EA </strong>库执行一些字节码操作，以便获得由<strong class="je hv"> C# </strong>编译器生成的相同结果。</p><h1 id="4940" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">链接阶段</h1><p id="4e3a" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">当在<strong class="je hv"> C# </strong>中链接计算阶段时，我们仅限于上面看到的构造，但是让我们更深入地看看它们。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="c59b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意<code class="eh ka kb kc kd b">.ContinueWith</code>提供了返回不同类型的重载函数，比如<code class="eh ka kb kc kd b">Task&lt;T&gt;</code>和<code class="eh ka kb kc kd b">Task</code>。换句话说，它可用于链接阶段，其中该阶段返回新值，或者该阶段仅<em class="ke">运行</em>某个<em class="ke">副作用</em>操作并且不返回任何值(<strong class="je hv"> void </strong>)。</p><p id="cb93" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je hv"> Java </strong>中，这是通过使用不共享相同名称的不同一元运算来完成的。<strong class="je hv"> Java </strong> API减少了重载函数的数量，并根据它们的功能按名称分组。</p><p id="76ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看同样的例子是如何在<strong class="je hv"> Java </strong>中完成的</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="ce60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了命名上的变化，这是完全相同的功能。然而，注意<code class="eh ka kb kc kd b">.thenApply</code>和<code class="eh ka kb kc kd b">.thenAccept</code>有不同的含义，其背后的意图在它们的名字中被清楚地标记出来。在<strong class="je hv"> C# </strong>中情况并非如此，这里<code class="eh ka kb kc kd b">.ContinueWith</code>是唯一使用的方法。</p><h1 id="ec1b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">内部异步操作</h1><p id="dda6" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">现在，我们来看看<strong class="je hv"> C# </strong>落后了一点。</p><p id="cf63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们有这样的东西。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="5b52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们想把这两个操作结合起来。下面是一种自然的方法。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="6609" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，<code class="eh ka kb kc kd b">final</code>是一个<code class="eh ka kb kc kd b">Task&lt;Task&lt;string&gt;&gt;</code>肯定不是我们想要的值。</p><p id="eaa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问题是<code class="eh ka kb kc kd b">.ContinueWith</code>没有<strong class="je hv">拉平</strong>它的结果。</p><p id="4bb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了做到这一点，我们将不得不以下面的方式写另一个函数。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="a03a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使这样，我们也不能继续连锁经营，打破我们从一开始就遵循的模式。此外，它非常具体，所以我们可能想以某种方式推广这个函数(继续阅读)。</p><p id="62d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，Java有各种合适的函数可以使用。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="e79b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意<code class="eh ka kb kc kd b">.thenCompose</code>是如何拉平<code class="eh ka kb kc kd b">str</code>获得的结果<code class="eh ka kb kc kd b">CompletionStage&lt;String&gt;</code>，这是我们期望的值。</p><h1 id="a4af" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">改进C#？</h1><p id="121f" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">事实上，<strong class="je hv"> C# </strong> API的设计早于其他API。即使它有一个非常简单的方法，并且扩展使用了<code class="eh ka kb kc kd b">async / await</code>，它也可能需要一些改进才能赶上。</p><p id="b388" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对我们来说幸运的是，<strong class="je hv"> C# </strong>有<em class="ke">扩展方法</em>，实现这个缺失的功能只需要理解所有这些需要一起工作的部分。</p><p id="4283" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将在现有API的基础上添加三个函数。<code class="eh ka kb kc kd b">Map</code>、<code class="eh ka kb kc kd b">FlatMap</code>和<code class="eh ka kb kc kd b">ForEach</code>。</p><ul class=""><li id="5a6c" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated"><code class="eh ka kb kc kd b">Map</code>基本上与<code class="eh ka kb kc kd b">.ContinueWith</code>相同，但我们将使用这个新名称，因为它与其他人使用的名称很匹配。</li><li id="15c1" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ka kb kc kd b">FlatMap</code>展平之前任务的结果，所以它相当于<strong class="je hv"> Java中的<code class="eh ka kb kc kd b">.thenCompose</code>。</strong></li><li id="24a6" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ka kb kc kd b">ForEach</code>将用于链接不返回值的任务。这是一个已经存在的功能，但是拥有一个独立的功能可以让意图更加清晰。</li></ul><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="63b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们扩展了<code class="eh ka kb kc kd b">Task&lt;T&gt;</code>，但是我们使用<code class="eh ka kb kc kd b">await</code>来链接操作。</p><p id="163d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们实现<code class="eh ka kb kc kd b">FlatMap</code>。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="a0b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是使用我们之前的<code class="eh ka kb kc kd b">flatten</code>的通用实现的另一个扩展。注意<code class="eh ka kb kc kd b">fn</code>返回<code class="eh ka kb kc kd b">Task&lt;Result&gt;</code>而不是<code class="eh ka kb kc kd b">Map</code>中的<code class="eh ka kb kc kd b">Result</code>。然后使用<code class="eh ka kb kc kd b">await</code>展平内部任务。</p><p id="2f52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后我们加上<code class="eh ka kb kc kd b">ForEach</code>。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="4cd2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">ForEach</code>用于副作用和<strong class="je hv">无效</strong>操作，<code class="eh ka kb kc kd b">fn</code>不返回值。<code class="eh ka kb kc kd b">ForEach</code>相当于<strong class="je hv"> Java </strong>中的<code class="eh ka kb kc kd b">.thenAccept</code>。</p><p id="5539" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们可以使用这个结构来编写前面的例子，如下所示。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="002d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="a7de" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">C#  async API足够强大和简单，可以在几乎11年的时间里保持不变。然而，通过使用<strong class="je hv"> C# </strong> <em class="ke">扩展方法</em>，可以简单地填补一些空白，而无需修改现有的构造。</p><p id="d9a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">另一方面，Java </strong>可以重载许多不同的方法来做同样的事情，但是它的API涵盖了所有种类的用例。在像Scala这样的语言中可能会找到一种平衡的方法，在这种语言中，大多数构造，比如我们看到的这种，被用于整个语言，以便在不同的API之间维护一些标准。</p><p id="a6ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关键是我们应该能够识别这些错误，然后努力用最少的努力来纠正它们。C# 已经提供了简单的工具来整合新特性，所以让我们使用它们。</p><p id="0cf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ke">快乐编码……</em></p></div></div>    
</body>
</html>