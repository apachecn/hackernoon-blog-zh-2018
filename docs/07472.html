<html>
<head>
<title>Vue state management from the ground up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue自下而上的状态管理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/vue-state-management-from-the-ground-up-a31eb87c668d?source=collection_archive---------6-----------------------#2018-09-03">https://medium.com/hackernoon/vue-state-management-from-the-ground-up-a31eb87c668d?source=collection_archive---------6-----------------------#2018-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7dc1" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">让我们管理一些州💃</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/c5ea3f83668767d7162c05c33590528c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0kNknqS3A_I2e-hnIvLYA.png"/></div></div></figure><blockquote class="jv jw jx"><p id="5d00" class="jy jz ka kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">计算机科学只有两个硬东西:缓存失效和事物命名。— <em class="hu">菲尔·卡尔顿</em></p></blockquote><p id="a92b" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">嗯，我想菲尔·卡尔顿从来没有在前端处理过管理状态..！</p><p id="ea49" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">国家管理就是<em class="ka">那些事情</em>之一。后端翻白眼，前端藏桌子底下。毕竟，管理状态是前端开发人员最难的部分:您需要将UI看作是随时间变化的东西。而且我们也不是特别擅长。</p><p id="e94e" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">在这篇文章中，我们将从头开始探索如何在Vue应用程序中处理状态。我们将最终创建我们自己的状态管理器生成器！</p></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><p id="b37e" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">让我们开始吧:</p><h1 id="36f4" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">第一步:我们的第一个应用程序。选举日！</h1><p id="766f" class="pw-post-body-paragraph jy jz hu kb b kc lx iv ke kf ly iy kh kv lz kk kl kw ma ko kp kx mb ks kt ku hn dt translated">首先，我们需要一个应用。没有应用程序，我们就无法管理应用程序状态，对吗？</p><p id="cc61" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">让我们创建一个投票应用程序，让你们为下一任总统投票(？):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Yes, I merged Single File Components and inline components.</figcaption></figure><p id="75c4" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated"><em class="ka"> TODO(发布前删除):避免开政治玩笑。不是时候，不是时候。</em></p><p id="1de3" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">上面的代码呈现了如下漂亮的东西:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/a55033684f185533784a45085067bc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*iwyBQkT2vuOIg3XaeBuh9Q.png"/></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">It looks like the browser failed to load the CSS</figcaption></figure><p id="1a2c" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">我能听到你的大脑在尖叫:</p><p id="b3ea" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">”<em class="ka">老兄，你不是管理国家的。您只是将道具传递给每个组件。你向国家管理层保证过。你最好把</em>送过来。</p><p id="7a29" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">嗯，传道具不就是最简单的“状态管理”形式吗？难道我们的主要组件不是拥有我们的状态片段<code class="eh mj mk ml mm b">red</code>和<code class="eh mj mk ml mm b">blue</code>吗？</p><p id="035d" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated"><em class="ka">(答案是肯定的和肯定的)</em></p><p id="4b14" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">但是，是的，我听到了。传道具不好看不舒服也不可升级，我们试试别的吧。</p><h1 id="2687" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">步骤2:隔离状态</h1><p id="0e3c" class="pw-post-body-paragraph jy jz hu kb b kc lx iv ke kf ly iy kh kv lz kk kl kw ma ko kp kx mb ks kt ku hn dt translated">让我们创建一个“状态持有者”对象，并从那里管理我们的整个状态。</p><pre class="jk jl jm jn fq mn mm mo mp aw mq dt"><span id="3284" class="mr lg hu mm b fv ms mt l mu mv">const <strong class="mm hv">state</strong> = {<br/>  red: 0,<br/>  blue: 0,<br/>}</span></pre><p id="df66" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">在那里！我们的应用程序状态，正确保存和封装。没那么难。</p><p id="c37e" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">现在，从我们的组件中，我们可以执行如下操作:</p><pre class="jk jl jm jn fq mn mm mo mp aw mq dt"><span id="067f" class="mr lg hu mm b fv ms mt l mu mv">const <strong class="mm hv">TotalVotes</strong> = {<br/>  render: h =&gt; h('div', `Total votes: ${state.red + state.blue}`)<br/>}</span><span id="e9b5" class="mr lg hu mm b fv mw mt l mu mv">const <strong class="mm hv">Results</strong> = {<br/>  render: h =&gt; h('div', `Red: ${state.red} - Blue: ${state.blue}`),<br/>}</span><span id="43d1" class="mr lg hu mm b fv mw mt l mu mv">// ...and, inside our main component,...<br/>methods: {<br/>  voteForRed () { state.red++ },<br/>  voteForBlue () { state.blue++ },<br/>},</span></pre><p id="ed6f" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">剧透:<strong class="kb hv">这个不行</strong>。为什么？</p><p id="f6af" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">因为Vue使用<code class="eh mj mk ml mm b">data</code>的方法来触发它的“魔法反应力”。如果不将我们的数据传递给<code class="eh mj mk ml mm b">data</code> (heh)，Vue将无法跟踪值的变化并相应地更新我们的组件。</p><p id="efdc" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">轻松说，<em class="ka">轻松(？)</em>固定:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="f65a" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">那里发生了一些事情:</p><ol class=""><li id="6670" class="mx my hu kb b kc kd kf kg kv mz kw na kx nb ku nc nd ne nf dt translated">听着，妈妈，没有道具！<em class="ka">(第8、9行)</em></li><li id="5724" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">每个组件都在它们的<code class="eh mj mk ml mm b">data</code>方法中注册我们的状态。现在Vue能够跟踪状态变化，所以当我们投票给🔴我们所有的组件<em class="ka">都用正确的值重新渲染</em>。<em class="ka">(第20、27、35行)</em></li><li id="f9d7" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">我们不得不从渲染函数中移除漂亮的箭头函数，因为现在我们正在使用<code class="eh mj mk ml mm b">this</code>。<em class="ka">(第21、28行)</em></li><li id="3445" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">现在我们的状态与组件“隔离”。<em class="ka">免费啤酒</em>。<em class="ka">(14行)</em></li></ol><p id="8d82" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">好了，现在我们已经把状态从“UI实现”中分离出来了，但是有一些注意事项:<strong class="kb hv">我们需要把状态注册到<code class="eh mj mk ml mm b">data()</code>中的每个组件</strong>，我们不能在渲染函数中使用漂亮的箭头函数…</p><p id="51f0" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">酪</p><p id="eaa0" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">等等。</p><p id="5f23" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">我刚才是不是说“<em class="ka"> Vue需要在</em> <code class="eh mj mk ml mm b"><em class="ka">data()</em></code> <em class="ka">中注册数据，使其反应性？</em>”。</p><p id="f676" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">是的，我做到了。</p><p id="a9cf" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">但是在我的解决方案中，我使用每个组件实例来使完全相同的数据具有反应性，对吗？</p><p id="2606" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">是的。</p><p id="efae" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">我是否可以创建一个共享的Vue实例来保持这种反应，这样我的组件就不必这样了？</p><p id="861c" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">嗯，是的。让我写一个大标题:</p><h1 id="3e4f" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">步骤3:创建一个共享Vue实例来保存反应</h1><p id="85c1" class="pw-post-body-paragraph jy jz hu kb b kc lx iv ke kf ly iy kh kv lz kk kl kw ma ko kp kx mb ks kt ku hn dt translated">因此，存储在<code class="eh mj mk ml mm b">data()</code>中的信息变成了“默认反应”。我们想让哪条信息起反应？</p><p id="6193" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">我们的州！</p><p id="8da1" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">如果我们这么做了呢？</p><pre class="jk jl jm jn fq mn mm mo mp aw mq dt"><span id="b3a9" class="mr lg hu mm b fv ms mt l mu mv">const state = new Vue({<br/>  data () {<br/>    return {<br/>      red: 0,<br/>      blue: 0,<br/>    }<br/>  },<br/>})</span></pre><p id="77d9" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">整洁！现在我们的状态是被动的。我们将为所有数据共享一个Vue实例，但这将比我以前的解决方案更干净，对吗？</p><p id="e852" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">但是等等。等等。等等。我们现在有一个Vue实例。除了反应性数据，您知道Vue实例还能保存什么吗？</p><p id="4748" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">正是:<strong class="kb hv">方法</strong>。</p><p id="f958" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">现在我们的<code class="eh mj mk ml mm b">voteforRed()</code>和<code class="eh mj mk ml mm b">voteForBlue()</code>方法可以<strong class="kb hv">搭配</strong>我们的状态了！</p><p id="502d" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">让我们来看看:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="4433" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">Vuetiful！让我强调一下我们取得的进步:</p><ol class=""><li id="922e" class="mx my hu kb b kc kd kf kg kv mz kw na kx nb ku nc nd ne nf dt translated">状态和改变我们状态的方法现在被<strong class="kb hv">放在一起</strong>。不再泄露实现细节！注意，我们的voteFor方法非常简单，但是它们可以根据需要变得复杂。<em class="ka">(第9、10行)</em></li><li id="2d57" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">我们仍然需要从组件中调用这些方法。<em class="ka">(第25、26行)</em></li><li id="fbab" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">回到带箭头的渲染函数。<em class="ka">(第15、19行)</em></li></ol><p id="aa17" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">我们删除了许多样板代码(所有的<code class="eh mj mk ml mm b">data()</code>声明)。</p></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><p id="f00e" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">好的，目前为止一切顺利！我们当前的解决方案简洁、简单且符合习惯。</p><p id="af92" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">但是我们需要导入Vue，然后创建一个新的实例。虽然这本身并不“糟糕”，但我觉得我们可以做得更好，不是吗？</p><p id="8efc" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">例如，我们的解决方案现在不能在项目间共享。我需要教人们创建一个Vue实例，填充它的<code class="eh mj mk ml mm b">data</code>方法，然后注册一些方法来修改状态…太多了。</p><p id="005b" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">是时候…</p><h1 id="7dec" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">步骤4:将我们的状态封装在一个函数中</h1><p id="29e9" class="pw-post-body-paragraph jy jz hu kb b kc lx iv ke kf ly iy kh kv lz kk kl kw ma ko kp kx mb ks kt ku hn dt translated">幸运的是，Javascript为我们提供了一个很酷的特性，它允许我们隐藏所有这些细节，让事情变得简单:函数。我们将创建我们的<a class="ae nl" rel="noopener" href="/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1">工厂函数</a>。</p><p id="c4f9" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">让我们定义一下我们的<code class="eh mj mk ml mm b">createStore</code>函数。API是什么？我希望:</p><ol class=""><li id="63c8" class="mx my hu kb b kc kd kf kg kv mz kw na kx nb ku nc nd ne nf dt translated">一个<em class="ka">数据</em>参数来设置我们的初始状态。为了清楚起见，我们可以称这个参数为“状态”。</li><li id="6a0d" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">需要时，一系列的突变功能会改变我的状态。为了清楚起见，我们可以称这个参数为“突变”。</li></ol><p id="a5a7" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">最后，我希望我们的<code class="eh mj mk ml mm b">createStore</code>公开一个泛型方法，允许我的组件“运行”突变。为了清楚起见，我们可以称这个参数为“提交”(你通常<em class="ka">提交突变</em>，对吗？).</p><p id="f6a2" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">你知道我要去哪里，不是吗？</p><p id="f707" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">我们想以此结束:</p><pre class="jk jl jm jn fq mn mm mo mp aw mq dt"><span id="75bc" class="mr lg hu mm b fv ms mt l mu mv">const store = createStore({<br/>  <strong class="mm hv">state</strong>: { red: 0, blue: 0 },<br/>  <strong class="mm hv">mutations</strong>: {<br/>    voteForRed (state) { state.red++ },<br/>    voteForBlue (state) { state.blue++ },<br/>  },<br/>})</span></pre><p id="0313" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">很不错，对吧？而且非常简单。</p><p id="22f9" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">现在，我们将如何实现这个<code class="eh mj mk ml mm b">createStore</code>助手呢？请记住，我们应该使用Vue实例来利用它的反应能力:</p><pre class="jk jl jm jn fq mn mm mo mp aw mq dt"><span id="f56c" class="mr lg hu mm b fv ms mt l mu mv">const <strong class="mm hv">createStore</strong> = ({ state, mutations }) =&gt;<br/>  new Vue({<br/>    data () {<br/>      return { state }<br/>    },<br/>    methods: {<br/>      commit (mutationName) {<br/>        mutations[mutationName](this.state)<br/>      },<br/>    },<br/>  })</span></pre><p id="7d38" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">那里发生了一些事情:</p><ol class=""><li id="f3d9" class="mx my hu kb b kc kd kf kg kv mz kw na kx nb ku nc nd ne nf dt translated">首先，我们返回一个新的Vue实例。到目前为止一切顺利。</li><li id="2fab" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">然后，我们将状态参数注册到实例的<code class="eh mj mk ml mm b">data()</code>方法中。嘭！我们的国家现在是被动的。</li><li id="ca77" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">最后，我们创建我们的公共<code class="eh mj mk ml mm b">commit()</code>方法。该方法将一个变异的名称作为参数，然后运行完全相同的变异(并传递我们的状态)。如果我们调用<code class="eh mj mk ml mm b">commit('someMutation')</code>，我们的方法就会调用<code class="eh mj mk ml mm b">mutations.someMutation(this.state)</code>。请注意，在实际的实现中，我们应该处理不存在的突变！</li></ol><p id="8e9a" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">那么，我们的组件现在看起来怎么样？</p><pre class="jk jl jm jn fq mn mm mo mp aw mq dt"><span id="44fc" class="mr lg hu mm b fv ms mt l mu mv">const TotalVotes = {<br/>  render: h =&gt; h('div', `Total votes: ${store.state.red + store.state.blue}`),<br/>}</span><span id="249a" class="mr lg hu mm b fv mw mt l mu mv">const Results = {<br/>  render: h =&gt; h('div', `Red: ${store.state.red} - Blue: ${store.state.blue}`),<br/>}</span><span id="48e0" class="mr lg hu mm b fv mw mt l mu mv">export default {<br/>  components: { TotalVotes, Results },<br/>  methods: {<br/>    voteForRed () { store.commit('voteForRed') },<br/>    voteForBlue () { store.commit('voteForBlue') },<br/>  },<br/>}</span></pre><p id="1304" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">现在我们访问<code class="eh mj mk ml mm b">store.state</code>来获取我们的状态，并使用<code class="eh mj mk ml mm b">store.commit</code>来修改它(注意，我们将所需的突变名称作为参数传递)。</p><p id="0b27" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">所有人现在在一起！：</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="b704" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">是不是很酷？</p><p id="eda7" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">现在我们可以通过提供一个简单的<code class="eh mj mk ml mm b">createStore</code>方法来生成数十万个商店。您可能希望将您的<code class="eh mj mk ml mm b">createStore</code>放在一个文件中并导出它，这样您就可以将它导入到您的应用程序中并创建一个全新的商店。如果你调用这个文件<code class="eh mj mk ml mm b">Vuex.js</code>😁。</p></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><h1 id="5459" class="lf lg hu bd lh li nm lk ll lm nn lo lp ja no jb lr jd np je lt jg nq jh lv lw dt translated">✅，结束了！</h1><p id="1d71" class="pw-post-body-paragraph jy jz hu kb b kc lx iv ke kf ly iy kh kv lz kk kl kw ma ko kp kx mb ks kt ku hn dt translated"><code class="eh mj mk ml mm b">state</code>、<code class="eh mj mk ml mm b">mutations</code>……你听着耳熟吗？好吧，如果你曾经用过<a class="ae nl" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>，它肯定应该。在我们的例子中，我们有效地映射了Vuex API。</p><p id="1818" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">我们遗漏了getters和actions，但是我希望你明白Vuex是我们已经知道的东西的抽象<strong class="kb hv">。这是一个很好的抽象，非常完美、有用、可扩展。但毕竟是一种抽象。我们只是不断地给框架的核心增加层次:<strong class="kb hv">反应</strong>。那是触发一切的核心特征。</strong></p><blockquote class="nr"><p id="dc7d" class="ns nt hu bd nu nv nw nx ny nz oa ku ek translated">Vuex是我们已经知道的事物的抽象。</p></blockquote></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><p id="5e89" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">快速回顾一下:</p><ol class=""><li id="2936" class="mx my hu kb b kc kd kf kg kv mz kw na kx nb ku nc nd ne nf dt translated">前端的状态管理是可伸缩的。我个人的建议:尽可能从小做起，在添加新的东西之前，要三思而后行。Vuex是惊人的(真的是！)，但是你真的需要它吗？</li><li id="f5ab" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated"><strong class="kb hv">反应性</strong>是Vue之王。一切，我是说一切，都依赖于数据的反应。这很好，因为我们可以利用这种反应能力，创造出漂亮、有用的抽象概念。</li><li id="306e" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">现在我们有点明白Vuex在做什么了，这很酷。</li><li id="8df6" class="mx my hu kb b kc ng kf nh kv ni kw nj kx nk ku nc nd ne nf dt translated">有时，<strong class="kb hv">冗长胜过简洁</strong>，如果它为我们的代码提供了上下文、意图和可重复性(例如，步骤4比步骤2需要更多的代码)。</li></ol></div><div class="ab cl ky kz hc la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hn ho hp hq hr"><p id="1387" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">想吃吗？<a class="ae nl" href="https://github.com/afontcu/vue-state-management/commits/master" rel="noopener ugc nofollow" target="_blank">我用4次提交创建了一个Github repo</a>: post的每一步提交一次。请随意使用它，检查每一个变化。</p><p id="c3b5" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">你想用我们的解决方案练习一下吗？这里有一个挑战:你将如何实现<code class="eh mj mk ml mm b">getters</code>？还有<code class="eh mj mk ml mm b">actions</code>？还有… <a class="ae nl" href="https://vuex.vuejs.org/guide/modules.html" rel="noopener ugc nofollow" target="_blank">模块</a>？😏</p><p id="7d7a" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kv kj kk kl kw kn ko kp kx kr ks kt ku hn dt translated">希望有帮助！</p></div></div>    
</body>
</html>