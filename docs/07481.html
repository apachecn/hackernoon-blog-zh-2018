<html>
<head>
<title>Value Object instead of Form</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">值对象而不是形式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/value-object-instead-of-form-777f1a559b1?source=collection_archive---------15-----------------------#2018-09-03">https://medium.com/hackernoon/value-object-instead-of-form-777f1a559b1?source=collection_archive---------15-----------------------#2018-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8c7189f8da03de168d6642a17297d148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Htt__QhEl0XXiywwfNnlQ.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">You think handling forms it’s the only way? But, is there any options?</figcaption></figure><div class=""/><div class=""><h2 id="0961" class="pw-subtitle-paragraph jg ii ij bd b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ek translated">用价值对象代替形式的实际好处</h2></div><p id="834a" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">让我们考虑一下价值对象(VO) " <em class="ku">设计模式"</em>如何帮助你处理web表单，简化你的生活。</p><h2 id="5c33" class="kv kw ij bd kx ky kz la lb lc ld le lf kh lg lh li kl lj lk ll kp lm ln lo lp dt translated">形式</h2><p id="fa8f" class="pw-post-body-paragraph jy jz ij ka b kb lq jk kd ke lr jn kg kh ls kj kk kl lt kn ko kp lu kr ks kt hn dt translated">假设我们需要在PHP中处理HTTP请求(在这两种情况下:“application/x-www-form-urlencoded”或“application/json”转换这两种请求的参数并使用它们在PHP中填充表单非常简单)。<br/>通常我们会这样做(这里我要用<code class="eh lv lw lx ly b">symfony/form</code>，因为它非常简单明了，很流行，你可以在github上找到它):<br/> 1)创建<code class="eh lv lw lx ly b">form</code>类:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="0c7c" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">2)创建表单实例:<code class="eh lv lw lx ly b">$task = new Form();</code> <br/> 3)用来自HTTP请求的参数填充表单:</p><pre class="lz ma mb mc fq mf ly mg mh aw mi dt"><span id="106b" class="kv kw ij ly b fv mj mk l ml mm">$form-&gt;handleRequest($request);</span></pre><p id="c333" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">现在我们可以处理这个表格了。到目前为止还没什么困难… <br/>但是等一下…让我们回答下一个问题:</p><ol class=""><li id="b1a5" class="mn mo ij ka b kb kc ke kf kh mp kl mq kp mr kt ms mt mu mv dt translated">这个表格有效吗？</li><li id="1604" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">是否所有参数都填充了请求中的值？</li><li id="26bb" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">我可以修改任何参数值吗？</li><li id="4459" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">我可以在下游服务、层等中松散地重用这种形式吗？</li></ol><p id="6492" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">答案:</p><ol class=""><li id="645c" class="mn mo ij ka b kb kc ke kf kh mp kl mq kp mr kt ms mt mu mv dt translated">没想法，只好跑:<code class="eh lv lw lx ly b">$form-&gt;isValid()</code></li><li id="235c" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">不确定。如果有人遗漏了(这种情况很少见，但在技术上是可能的):<code class="eh lv lw lx ly b">$form-&gt;handleRequest($request);<br/></code>意味着表单包含空白的初始化值，在我们的例子中<br/> <code class="eh lv lw lx ly b">$form-&gt;getName()</code>将返回<code class="eh lv lw lx ly b">null</code>。</li><li id="fb49" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">是的。只需调用公共setter。</li><li id="14c9" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">肯定不是。因为表单不仅可以包含有效值，也可以包含无效值，这意味着我们必须用代码淹没服务，如:</li></ol><pre class="lz ma mb mc fq mf ly mg mh aw mi dt"><span id="1ebd" class="kv kw ij ly b fv mj mk l ml mm">if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {<br/>    // ...<br/>}</span></pre><h2 id="798f" class="kv kw ij bd kx ky kz la lb lc ld le lf kh lg lh li kl lj lk ll kp lm ln lo lp dt translated">价值对象</h2><p id="a04e" class="pw-post-body-paragraph jy jz ij ka b kb lq jk kd ke lr jn kg kh ls kj kk kl lt kn ko kp lu kr ks kt hn dt translated">让我们处理相同的HTTP请求:<br/> 1)创建VO类:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="7063" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">2)创建VO实例:<code class="eh lv lw lx ly b">$vo = new<strong class="ka ik"> </strong>ValueObject($request);</code></p><p id="e4bf" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">就这样，不需要额外的步骤。我们来回答之前的问题:</p><ol class=""><li id="fa14" class="mn mo ij ka b kb kc ke kf kh mp kl mq kp mr kt ms mt mu mv dt translated">这个VO有效吗？</li><li id="e583" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">是否所有参数都填充了请求中的值？</li><li id="8a43" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">我可以修改任何参数值吗？</li><li id="0f74" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">我可以在下游服务、层等中松散地重用这个VO吗？</li></ol><p id="f2bc" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">答案:</p><ol class=""><li id="aced" class="mn mo ij ka b kb kc ke kf kh mp kl mq kp mr kt ms mt mu mv dt translated">是啊！自VO创建—有效，因为VO在<code class="eh lv lw lx ly b">__costruct</code>方法中包含自验证。如果提供的参数无效，将不会创建VO，将会引发异常。</li><li id="addf" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">是啊！否则将抛出异常，并且不会创建VO。</li><li id="5340" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">不要！VO是不可变的，你改变不了什么。</li><li id="4d06" class="mn mo ij ka b kb mw ke mx kh my kl mz kp na kt ms mt mu mv dt translated">是啊！VO总是有效的，你可以在任何应用程序层依赖它，你可以在方法中使用它作为类型提示，比如:<br/> <code class="eh lv lw lx ly b">public function doSomething(ValueObject $vo)<br/></code>并且你不必用冗余的<code class="eh lv lw lx ly b">if</code>块来淹没你的代码(更具声明性的风格)。</li></ol><h2 id="4cba" class="kv kw ij bd kx ky kz la lb lc ld le lf kh lg lh li kl lj lk ll kp lm ln lo lp dt translated">批评</h2><p id="054d" class="pw-post-body-paragraph jy jz ij ka b kb lq jk kd ke lr jn kg kh ls kj kk kl lt kn ko kp lu kr ks kt hn dt translated">您可能认为在构造函数中编写所有验证内容可能会让人不知所措——我在这里只使用了一个简单的小例子，目的是以最简单的方式提供主要思想。但是你可以考虑使用类似于<code class="eh lv lw lx ly b">kint/vo</code>的选项，更多信息你可以在这里找到<a class="ae nb" href="https://packagist.org/packages/kint/vo" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="fa9c" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">你也可以把在<code class="eh lv lw lx ly b">__construct</code>期间的异常看作是用<code class="eh lv lw lx ly b">try-catch</code>块淹没你的代码，但是在现实生活中，你必须为整个应用程序只有一个这样的块(不管它有多大),它将捕捉你的定制异常，并将所有错误提供到响应中，就像在<code class="eh lv lw lx ly b">kint/vo</code>的情况下，你只是在一个地方捕捉<code class="eh lv lw lx ly b">ValueObject\Exception\ValidationException</code>。</p><p id="14d9" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">如果你不喜欢在值对象的构造函数中包含所有这些东西，也不想使用<code class="eh lv lw lx ly b">new</code>关键字，你可以考虑下一个例子:</p><figure class="lz ma mb mc fq hw"><div class="bz el l di"><div class="md me l"/></div></figure><p id="6cc4" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">主要思想保持不变，唯一的区别是你如何创建(<code class="eh lv lw lx ly b">$vo = ValueObject::fromArray([‘namex’ =&gt; ‘bond’]);</code>)和使用你的值对象。</p><h2 id="1f4e" class="kv kw ij bd kx ky kz la lb lc ld le lf kh lg lh li kl lj lk ll kp lm ln lo lp dt translated">结论</h2><p id="1902" class="pw-post-body-paragraph jy jz ij ka b kb lq jk kd ke lr jn kg kh ls kj kk kl lt kn ko kp lu kr ks kt hn dt translated">现在您知道了值对象如何帮助您以声明式方式编写更严格、更健壮、不可变的代码。</p><p id="7d12" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hn dt translated">希望这篇文章对你有所帮助，你不仅可以使用VO来处理HTTP请求，还可以在你的组件、服务等之间建立完整的交互。在你的申请中。</p></div></div>    
</body>
</html>