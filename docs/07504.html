<html>
<head>
<title>Making the Jump II: Using More Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跳跃II:使用更多的单子</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-the-jump-ii-using-more-monads-bce44a7c3550?source=collection_archive---------38-----------------------#2018-09-03">https://medium.com/hackernoon/making-the-jump-ii-using-more-monads-bce44a7c3550?source=collection_archive---------38-----------------------#2018-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/34c1eefc2f4e7db343789be3602a1880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZbZE1oLOlHztQngYK8QvzA.jpeg"/></div></figure><p id="63d9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">答<a class="ae jw" href="https://www.mmhaskell.com/blog/2018/7/23/making-the-jump-advancing-past-beginner-haskell" rel="noopener ugc nofollow" target="_blank">几周前</a>，我们讨论了一些重要的步骤，以超越Haskell的“初学者”阶段。我们学习了如何组织您的项目以及如何找到相关的文档。本周，我们将继续关注另一个我们可以取得巨大进步的地方。我们将探索如何扩大我们的单子用法的词汇。</p><p id="3ab4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">单子是Haskell的重要组成部分。除非你知道如何合并它们的一元函数，否则你不能使用很多库。这些函数通常涉及到该库定制的monad。当你第一次开始时，可能很难知道如何将这些单子合并到程序的其余部分。</p><p id="8a7c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在本文中，我们将重点关注一种许多单子和库使用的特定模式。我把这种模式称为“运行”模式。通常，你会使用一个名字类似于<code class="eh jx jy jz ka b">runXXX</code>或<code class="eh jx jy jz ka b">runXXXT</code>的函数，其中<code class="eh jx jy jz ka b">XXX</code>是单子的名字。这些函数总是将一元表达式作为它们的第一个参数。然后它们还会获取一些其他的初始化信息，最后返回一些输出。这个输出可以是纯形式的，也可以是你已经在使用的不同的单子，比如<code class="eh jx jy jz ka b">IO</code>。我们将首先看看这是如何与<code class="eh jx jy jz ka b">State</code>单子一起工作的，然后再看看其他一些库。</p><p id="4a3c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一旦抓住了这个话题，看起来就很简单了。但是我们中的很多人最初学习单子时都有一个不好的心理模型。例如，我了解到的关于单子的第一件事是它们有副作用。因此，你只能从有相同副作用的地方调用它们。这适用于木卫一，但不适用于其他单子。所以即使现在看起来很明显，我一开始也很难理解这个想法。但是让我们开始看看这种模式的一些例子。</p><p id="0b08" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要更深入地了解单子，请查看我们关于<a class="ae jw" href="https://www.mmhaskell.com/monads" rel="noopener ugc nofollow" target="_blank">函数数据结构</a>的系列文章！我们从学习更简单的东西开始，比如函子。然后我们最终发展到单子，甚至单子变形金刚！</p><h1 id="29f5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">“运行”的基础:状态单子</h1><p id="d131" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">先来回忆一下<code class="eh jx jy jz ka b">State</code>单子。这个monad只有一个类型参数，我们可以将这个类型作为一个全局读/写状态来访问。下面是一个用<code class="eh jx jy jz ka b">State</code>单子编写的函数示例:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e932" class="lm kc hu ka b fv ln lo l lp lq">stateExample :: State Int (Int, Int, Int)<br/>stateExample = do<br/>  a &lt;- get<br/>  modify (+1)<br/>  b &lt;- get<br/>  put 5<br/>  c &lt;- get<br/>  return (a, b, c)</span></pre><p id="6eb2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果这个函数令人困惑，你应该看看 <code class="eh jx jy jz ka b"><a class="ae jw" href="http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html" rel="noopener ugc nofollow" target="_blank">State</a></code>的<a class="ae jw" href="http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html" rel="noopener ugc nofollow" target="_blank">文档。它至少会显示相关的类型签名。首先我们读取初始状态。然后我们用一些函数修改它。最后我们彻底改变它。</a></p><p id="cfc2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的例子中，如果我们的初始状态是1，我们将返回<code class="eh jx jy jz ka b">(1,2,5)</code>作为结果。如果初始状态是2，我们将返回<code class="eh jx jy jz ka b">(2,3,5)</code>。但是假设我们有一个纯函数。我们如何调用我们的状态函数？</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="7401" class="lm kc hu ka b fv ln lo l lp lq">pureFunction :: Int -&gt; Int<br/>pureFunction = ???</span></pre><p id="cf9e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">答案是<code class="eh jx jy jz ka b">runState</code>功能。我们可以检查文档并找到它的类型:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="e3ae" class="lm kc hu ka b fv ln lo l lp lq">runState :: State s a -&gt; s -&gt; (a, s)</span></pre><p id="8b02" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个函数有两个参数。首先是一次<code class="eh jx jy jz ka b">State</code>行动。我们将把上面的函数作为这个参数来传递！第二个是初始状态，这是我们将如何配置它。那么结果就是纯粹的。它包含我们的结果，以及状态的最终值。这里有一个例子，我们可以在纯函数中给出这个一元表达式。我们将从一个<code class="eh jx jy jz ka b">where</code>子句调用它，并丢弃最终状态:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="ec79" class="lm kc hu ka b fv ln lo l lp lq">pureFunction :: Int -&gt; Int<br/>pureFunction input = a + b + c<br/>  where<br/>    ((a,b,c), _) = runState stateExample input</span></pre><p id="8c8f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我们如何使用<code class="eh jx jy jz ka b">runXXX</code>模式的最简单的例子。</p><h1 id="6d6f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">升级到变压器</h1><p id="58da" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">现在，假设我们的<code class="eh jx jy jz ka b">State</code>函数不太纯。它现在想要打印它的一些输出，所以它需要<code class="eh jx jy jz ka b">IO</code>单子。这意味着它将使用<code class="eh jx jy jz ka b">StateT</code> monad变压器，而不是<code class="eh jx jy jz ka b">IO</code>:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="77de" class="lm kc hu ka b fv ln lo l lp lq">stateTExample :: StateT Int IO (Int, Int, Int)<br/>stateTExample = do<br/>  a &lt;- get<br/>  lift $ print “Initial Value:”<br/>  lift $ print a<br/>  modify (+1)<br/>  b &lt;- get<br/>  lift $ putStrLn “After adding 1:”<br/>  lift $ print b<br/>  put 5<br/>  c &lt;- get<br/>  lift $ putStrLn “After setting as 5:”<br/>  lift $ print c<br/>  return (a, b, c)</span></pre><p id="0ccf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们需要从一个<code class="eh jx jy jz ka b">IO</code>函数中调用它，而不是从一个纯格式中调用这个函数。但是我们将再次使用一个<code class="eh jx jy jz ka b">runXXX</code>函数。现在，虽然，因为我们使用的是monad转换器，我们不会得到一个纯粹的结果。相反，我们将在底层单子中得到我们的结果。这意味着我们可以从<code class="eh jx jy jz ka b">IO</code>调用这个函数。所以让我们检查一下<code class="eh jx jy jz ka b">runStateT</code>函数的类型。我们用<code class="eh jx jy jz ka b">IO</code>代替了一般的单子参数<code class="eh jx jy jz ka b">m</code>:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="905c" class="lm kc hu ka b fv ln lo l lp lq">runStateT :: StateT s IO a -&gt; s -&gt; IO (a, s)</span></pre><p id="2f92" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">它看起来很像<code class="eh jx jy jz ka b">runState</code>，除了额外的<code class="eh jx jy jz ka b">IO</code>参数！它不是返回结果的纯元组，而是返回包含该结果的<code class="eh jx jy jz ka b">IO</code>动作。因此我们可以从<code class="eh jx jy jz ka b">IO</code>单子上调用它。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="67fc" class="lm kc hu ka b fv ln lo l lp lq">main :: IO ()<br/>main = do<br/>  putStrLn “Please enter a number.”<br/>  input &lt;- read &lt;$&gt; getLine<br/>  results &lt;- runStateT stateTExample input<br/>  print results</span></pre><p id="23ec" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将得到以下输出结果:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="a054" class="lm kc hu ka b fv ln lo l lp lq">Please enter a number.<br/>10<br/>Initial Value:<br/>10<br/>After adding 1<br/>11<br/>After setting as 5<br/>5<br/>(10, 11, 5)</span></pre><h1 id="8aa7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">对库使用“运行”</h1><p id="e24e" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">这种模式通常会扩展到您使用的库中。例如，在我们关于解析的<a class="ae jw" href="https://www.mmhaskell.com/parsing" rel="noopener ugc nofollow" target="_blank">系列中，我们研究了</a><a class="ae jw" href="http://hackage.haskell.org/package/megaparsec" rel="noopener ugc nofollow" target="_blank"> Megaparsec </a>库。该库中的许多解析器组合子存在于<code class="eh jx jy jz ka b">Parsec</code>或<code class="eh jx jy jz ka b">ParsecT</code>单子中。所以我们可以把一堆不同的解析器组合成一个函数。</p><p id="7fb8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是要从普通的<code class="eh jx jy jz ka b">IO</code>代码(或另一个单子)中运行该函数，您需要使用<code class="eh jx jy jz ka b">runParserT</code>函数。让我们看看它的类型签名:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="a488" class="lm kc hu ka b fv ln lo l lp lq">runParserT<br/>  :: Monad m<br/>  -&gt; ParsecT e s m a<br/>  -&gt; String -- Name of source file<br/>  -&gt; s -- Input for parser<br/>  -&gt; m (Either (ParseError (Token s) e) a)</span></pre><p id="4538" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">那里有很多类型参数，你不需要理解。但是结构是一样的。我们的<code class="eh jx jy jz ka b">run</code>函数的第一个参数是一元动作。然后我们会提供一些我们需要的其他输入。然后我们得到一些结果，包裹在一个外部单子里(比如<code class="eh jx jy jz ka b">IO</code>)。</p><p id="39ea" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们使用<code class="eh jx jy jz ka b">servant-client</code>库进行客户端API调用，我们可以看到相同的模式。您对API的任何调用都将在<code class="eh jx jy jz ka b">ClientM</code>单子中。下面是<code class="eh jx jy jz ka b">runClientM</code>函数的类型签名:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="ed36" class="lm kc hu ka b fv ln lo l lp lq">runClientM :: ClientM a -&gt; ClientEnv -&gt; IO (Either ServantError a)</span></pre><p id="1b20" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同样的模式再次出现。我们将编写一元操作，并将其作为第一个参数传递。然后我们将提供一些初始状态，在这个例子中是一个<code class="eh jx jy jz ka b">ClientEnv</code>。最后，我们将得到包裹在外部单子(<code class="eh jx jy jz ka b">IO</code>)中的结果(<code class="eh jx jy jz ka b">Either ServantError a</code>)。</p><h1 id="7576" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">表达式中的单子</h1><p id="fb33" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">同样重要的是要记住，许多基本的单子甚至不需要<code class="eh jx jy jz ka b">runXXX</code>函数就可以工作！例如，您可以使用<code class="eh jx jy jz ka b">Maybe</code>或<code class="eh jx jy jz ka b">Either</code>单子来提取一些错误处理逻辑:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="062c" class="lm kc hu ka b fv ln lo l lp lq">divideIfEven :: Int -&gt; Maybe Int<br/>divideIfEven x = if x `mod` 2 == 0<br/>  then Just (x `quot` 2)<br/>  else Nothing</span><span id="b1dc" class="lm kc hu ka b fv lr lo l lp lq">dividesBy8 :: Int -&gt; Bool<br/>dividesBy8 = case thirdResult of<br/>  Just _ -&gt; True<br/>  Nothing -&gt; False<br/>  where<br/>    thirdResult :: Maybe Int<br/>    thirdResult = do<br/>      y &lt;- divideIfEven x<br/>      z &lt;- divideIfEven y<br/>      divideIfEven z</span></pre><h1 id="5b63" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="19bb" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">单子是使用许多不同Haskell库的关键。但是当你第一次开始的时候，如何从你的代码中调用这些函数是非常混乱的。这同样适用于一些常见的单子变压器，如<code class="eh jx jy jz ka b">Reader</code>和<code class="eh jx jy jz ka b">State</code>。最常见的模式是<code class="eh jx jy jz ka b">runXXXT</code>模式。掌握了这种模式，你就能更好地理解单子，写出更好的Haskell！</p><p id="0f06" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了更深入地了解单子和类似的结构，请务必阅读我们关于<a class="ae jw" href="https://www.mmhaskell.com/monads" rel="noopener ugc nofollow" target="_blank">函数数据结构</a>的系列文章。如果本文中的代码令人困惑，您绝对应该检查一下！如果你从未编写过Haskell，但想开始，下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>！</p></div></div>    
</body>
</html>