<html>
<head>
<title>Using “React render props” to create a Paginated Lists.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“React渲染道具”创建分页列表。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-react-render-props-to-create-a-paginated-lists-b618d839b369?source=collection_archive---------15-----------------------#2018-09-04">https://medium.com/hackernoon/using-react-render-props-to-create-a-paginated-lists-b618d839b369?source=collection_archive---------15-----------------------#2018-09-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9b4d0d4952bab13b08ec5f5db06d6c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_cxbFU5GHUzn43-FCnd_w.png"/></div></div></figure><p id="7be7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想知道如何使用渲染道具？</p><p id="dcb6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了！这件物品会适合你。我将向你展示如何用<a class="ae ka" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>渲染道具创建一个分页列表。</p><blockquote class="kb"><p id="9bd8" class="kc kd hu bd ke kf kg kh ki kj kk jz ek translated">React render props允许我们封装想要与其他组件共享的数据。通过这种设计，它将在您的应用程序中促进高度可重用的组件。</p></blockquote><pre class="kl km kn ko kp kq kr ks kt aw ku dt"><span id="5b6e" class="kv kw hu kr b fv kx ky l kz la">class PaginatedLists extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    <br/>    // By default let's start the page by 0...<br/>    this.state = { currentPage: 0 }; <br/>    <br/>    this.onClickPageNumber = this.onClickPageNumber.bind(this);<br/>  }<br/>  <br/>  getNumberOfPages(lists, itemsPerPage) {<br/>    <br/>    // Calculate the number pages to be displayed...<br/>    const numberOfPages = Math.ceil(lists.length / itemsPerPage);<br/>    return Array.from(Array(numberOfPages).keys());<br/>  }<br/>  <br/>  paginatedLists(lists, itemsPerPage) {<br/>    const { currentPage } = this.state;<br/>    <br/>    if (!Array.isArray(lists)) new Error('Invalid supplied Lists.');</span><span id="0ed1" class="kv kw hu kr b fv lb ky l kz la">// Use array slice to create Paginated lists...<br/>    return lists.slice(<br/>      currentPage * parseInt(itemsPerPage, 0),<br/>      (currentPage + 1) * parseInt(itemsPerPage, 0)<br/>    );<br/>  }<br/>  <br/>  onClickPageNumber(page) {<br/>    this.setState({ currentPage: page });<br/>  }<br/>    <br/>  render() {<br/>    const { currentPage } = this.state;<br/>    const { lists, itemsPerPage } = this.props;<br/>    <br/>    return(<br/>      &lt;div&gt;<br/>        {this.props.render(this.paginatedLists(lists,          itemsPerPage))}<br/>        <br/>        &lt;PageNumbers <br/>          items={this.getNumberOfPages(lists, itemsPerPage)} <br/>          currentPage={currentPage}<br/>          onClickPageNumber={this.onClickPageNumber}<br/>          /&gt;<br/>      &lt;/div&gt;<br/>    ); <br/>  }<br/>}</span><span id="430d" class="kv kw hu kr b fv lb ky l kz la">const PageNumbers = ({ <br/>  items, <br/>  currentPage, <br/>  onClickPageNumber <br/>}) =&gt; {<br/>  return(<br/>   &lt;ul&gt;<br/>    {items.map((item,index) =&gt; {<br/>       return (<br/>         &lt;Item<br/>            key={index}<br/>            item={item}<br/>            currentPage={currentPage}<br/>            onClickPageNumber={onClickPageNumber}<br/>          /&gt;<br/>         );<br/>       })}<br/>    &lt;/ul&gt;<br/>  );<br/>}</span><span id="fdc5" class="kv kw hu kr b fv lb ky l kz la">// Page number...<br/>const Item = ({ <br/>  item, <br/>  currentPage, <br/>  onClickPageNumber <br/>}) =&gt; {<br/>  return (<br/>    &lt;li<br/>      onClick={() =&gt; onClickPageNumber(item)}&gt;<br/>      {item === currentPage ? <br/>      (&lt;p&gt;{item + 1}&lt;/p&gt;) : <br/>      (&lt;a href="#"&gt;{item + 1}&lt;/a&gt;)}<br/>    &lt;/li&gt;<br/>  );<br/>};</span><span id="127f" class="kv kw hu kr b fv lb ky l kz la">const UsersLists = ({ lists }) =&gt; {<br/>  return (<br/>    &lt;PaginatedLists <br/>      lists={lists}<br/>      itemsPerPage={3}<br/>      render={(paginatedLists) =&gt; (<br/>        &lt;ul&gt;<br/>         {paginatedLists.map((item, id) =&gt; {<br/>            return &lt;li key={item.id}&gt;{item.first_name} {item.last_name}&lt;/li&gt;;<br/>         })}<br/>        &lt;/ul&gt;<br/>      )}<br/>     /&gt;);<br/>}</span><span id="4b26" class="kv kw hu kr b fv lb ky l kz la">ReactDOM.render(<br/>  &lt;UsersLists lists={users}/&gt;, <br/>  document.getElementById('root')<br/>);</span></pre><p id="080a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们完成的PaginatedList组件，我将在这里解释我是如何实现这些代码的。</p><pre class="lc ld le lf fq kq kr ks kt aw ku dt"><span id="2490" class="kv kw hu kr b fv kx ky l kz la">const UsersLists = ({ lists }) =&gt; {<br/>  return (<br/>    &lt;PaginatedLists <br/>      lists={lists}<br/>      itemsPerPage={3}<br/>      <strong class="kr hv">render={(paginatedLists) =&gt; (<br/>        &lt;ul&gt;<br/>         {paginatedLists.map((item, id) =&gt; {<br/>            return &lt;li key={item.id}&gt;{item.first_name}      {item.last_name}&lt;/li&gt;;<br/>         })}<br/>        &lt;/ul&gt;<br/>      )}</strong><br/>     /&gt;);<br/>}</span></pre><p id="7b43" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的<strong class="je hv"> PaginatedLists </strong>组件中，我们有三个道具。第一个道具是用于<strong class="je hv">列表</strong>的项目，这些项目稍后将被分页。第二个支柱是<strong class="je hv"> itemsPerPage </strong>，它将决定每页显示多少项。第三个道具就是我们所说的<strong class="je hv">渲染道具，</strong>在这个道具中<strong class="je hv"> </strong>你接受一个函数返回另一个组件。后来<em class="lg">每次我们点击页码，这个道具就会被触发并接收一个回调函数，这个函数传递了新更新的分页列表并在其中呈现组件。</em></p><p id="e50a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">渲染道具</strong>可以用你想要的名字命名。我们将其命名为<strong class="je hv"> render </strong>，因为这是ReactJS中的一个约定。</p><pre class="lc ld le lf fq kq kr ks kt aw ku dt"><span id="e48b" class="kv kw hu kr b fv kx ky l kz la">paginatedLists(lists, itemsPerPage) {<br/>  const { currentPage } = this.state;<br/>    <br/>  if (!Array.isArray(lists)) new Error('Invalid supplied Lists.');</span><span id="6bbd" class="kv kw hu kr b fv lb ky l kz la">  // Use array slice to create Paginated lists...<br/>  <strong class="kr hv">return lists.slice(<br/>    currentPage * parseInt(itemsPerPage, 0),<br/>    (currentPage + 1) * parseInt(itemsPerPage, 0)<br/>  );</strong><br/>}</span></pre><p id="d0a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的PaginatedLists组件中，我们有一个函数<strong class="je hv"><em class="lg">paginated lists</em></strong>，它将通过使用<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>内置<strong class="je hv"> slice </strong>函数使我们的列表分页。</p><pre class="lc ld le lf fq kq kr ks kt aw ku dt"><span id="81fd" class="kv kw hu kr b fv kx ky l kz la"><strong class="kr hv">onClickPageNumber(page) {<br/>  </strong>this.setState({ currentPage: page });<strong class="kr hv"><br/>}</strong></span></pre><p id="20ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每次我们点击页码时，<strong class="je hv"> onClickPageNumber </strong>更新我们的<strong class="je hv">当前页面</strong>状态和我们的列表。</p><pre class="lc ld le lf fq kq kr ks kt aw ku dt"><span id="2496" class="kv kw hu kr b fv kx ky l kz la">render() {<br/>    const { currentPage } = this.state;<br/>    const { lists, itemsPerPage } = this.props;<br/>    <br/>    return(<br/>      &lt;div&gt;<br/>        {<br/>          <strong class="kr hv">this.props.render(<br/>           this.paginatedLists(lists, itemsPerPage)<br/>          )</strong><br/>        }<br/>        <br/>        &lt;PageNumbers <br/>          items={this.getNumberOfPages(lists, itemsPerPage)} <br/>          currentPage={currentPage}<br/>          onClickPageItem={this.onClickPageItem}<br/>          /&gt;<br/>      &lt;/div&gt;<br/>    ); <br/>}</span></pre><p id="b099" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在return函数内的render方法中，您可能会注意到<strong class="je hv">this . props . render(this . paginatedLists(lists，itemsPerPage)) </strong>并调用paginated lists函数对列表进行分页<strong class="je hv">。</strong>这段代码将调用<strong class="je hv">呈现属性</strong>，我们之前在调用组件<strong class="je hv"> &lt;分页列表/ &gt; </strong>时看到过，每次我们更新当前页面状态时，这一行代码都会触发，呈现属性方法也会调用并重新呈现其中的组件。</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/483cd1cce40b71b1a4a8e3ae9bb6709e.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/1*KKLrOtLgeKGEklU3BPWcRA.gif"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Output of our PaginatedLists Component.</figcaption></figure><p id="ee28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您可以在应用程序中使用这个PaginatedLists组件来使项目列表分页。</p><p id="f15e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢读这篇文章，给我一个掌声…</p><p id="c9ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望对^_^有帮助</p><p id="8218" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谢了。</p></div><div class="ab cl lm ln hc lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hn ho hp hq hr"><h1 id="c706" class="lt kw hu bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp dt translated">“不要做一个JavaScript庸才。”</h1><p id="62cd" class="pw-post-body-paragraph jc jd hu je b jf mq jh ji jj mr jl jm jn ms jp jq jr mt jt ju jv mu jx jy jz hn dt translated">在推特上关注我<a class="ae ka" href="https://twitter.com/llaudevc/followers" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">【https://twitter.com/llaudevc/】T2</strong>T5】</a></p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="mv mw l"/></div></figure></div></div>    
</body>
</html>