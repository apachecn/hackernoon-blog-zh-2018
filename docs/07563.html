<html>
<head>
<title>Lessons Learned: Code Splitting with Webpack and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验教训:使用Webpack和React进行代码拆分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lessons-learned-code-splitting-with-webpack-and-react-f012a989113?source=collection_archive---------1-----------------------#2018-09-05">https://medium.com/hackernoon/lessons-learned-code-splitting-with-webpack-and-react-f012a989113?source=collection_archive---------1-----------------------#2018-09-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e9bf90fe357e16de54dc6b69228878a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LN1L-vuR_vEcJosbO7vtCQ.jpeg"/></div></div></figure><p id="9f79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">注:本文写于</em> <strong class="je hv"> <em class="ka">懒</em> </strong> <em class="ka">和</em> <strong class="je hv"> <em class="ka">悬疑</em> </strong> <em class="ka">上映之前。我将很快重写它，但记住一些例子可以改进！</em></p><p id="e269" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">毫无疑问，网络性能非常重要。我们的应用和网站应该快速加载，以保持用户的注意力，让他们参与进来，并提供积极的体验。</p><p id="8d47" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，开发通常是在连接到强大网络的高于平均水平的机器上完成的。然而，并非所有用户都通过强大的设备或强信号访问网络。</p><p id="1b91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们想要实现的是不让用户认为我们的应用程序正在加载。即使我们不能立刻满足他的所有需求，我们也想给他必要的反馈，让他参与进来。为了确保我们的web应用程序是高性能的，我们需要为最坏的情况编程，而不是最好的情况。</p><p id="490a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">有个TL；如果你只想要要点和学到的教训，你可以在文章的最后找到博士。</em></p><h1 id="acf8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">JavaScript的成本</strong></h1><p id="a9da" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当我们谈论性能时，我们需要考虑两个成本。第一个是将代码发送到用户浏览器的成本。我们发送的文件越小，用户的浏览器接收文件的速度就越快。</p><p id="80ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个成本是浏览器需要解析和执行我们发送给他的JavaScript的动作。本质上，我们希望一个块一个块地发送少量的JavaScript代码，并确保我们发送的所有内容都用于避免将浏览器的资源花费在将<strong class="je hv">而不是</strong>执行的代码上。</p><h1 id="cb57" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">懒惰的概念</h1><p id="2cc8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当我们谈论性能时，我们需要首先理解懒惰这两个概念。</p><p id="570d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，如果我们不做某件事，我们就不会在这件事上浪费资源。这意味着我们不需要在那些对用户的产品体验没有好处的流程上浪费时间和内存。</p><p id="39c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个概念是，如果我们可以以后做某事，我们就永远不想现在做。也就是说，如果我们可以推迟向浏览器发送特定的资源，我们应该总是这样做。</p><p id="d488" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本文中的例子将基于我使用<strong class="je hv"> React </strong>和<strong class="je hv"> Webpack </strong>的经验，但它们也可以应用于其他技术。</p><h1 id="05a0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">代码拆分</strong></h1><p id="b2ea" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">代码分割是一种技术，通过这种技术，我们既可以解决加载JavaScript的成本，同时又可以遵从懒惰的概念。</p><p id="c96e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我开始从事web开发时，将所有代码放在一个文件中，然后缩小，这是将JavaScript交付给用户的最佳方式。然而，随着应用程序规模的增长，我们的代码规模也急剧增加。</p><p id="1e0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要向用户发送越来越多的代码，当我们追求性能时，发送一个包含整个应用程序的巨大包并不理想。</p><p id="57ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种技术背后的思想是在任何给定的时间只给用户他所需要的。如果他打开一个特定的页面，他只需要该页面的代码，而不是整个应用程序。</p><p id="4933" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在传统方法中，我们给他发送一大堆JavaScript，然后需要由浏览器解析和执行，即使最终用户在打开应用程序时实际上只使用了一小部分代码。</p><p id="dc4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用更小的包，我们可以更加懒散地<strong class="je hv"/>发送最少的包，以确保用户获得积极的体验，而不会走神去想他是否关掉了烤箱。一旦他使用了应用程序，我们就可以在后台预加载其他包。</p><h1 id="0956" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">未使用的代码</strong></h1><p id="087f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">你可以实际看到从Chrome开发工具发送过来的<strong class="je hv">未使用代码</strong>的数量。一旦你打开它们，按下<code class="eh le lf lg lh b">Cmd + Shift + P</code>并输入<code class="eh le lf lg lh b">coverage</code>。从下拉列表中选择第一个选项，然后点击重新加载图标。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/d6b6c992739f3ee67a1b006502cf862a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFTQpub5xHm3Jtzm3-Oyjg.png"/></div></div></figure><p id="41d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将显示我们已经加载的所有脚本，以及在特定页面上没有使用的代码量。即使没有运行，这段JavaScript代码仍然会被<strong class="je hv">解析和评估</strong>，这需要时间。</p><h1 id="5196" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">动态导入</strong></h1><p id="751f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们向Webpack发出信号，告诉它我们想把什么拆分成一个单独的包的方法是使用动态导入。<code class="eh le lf lg lh b">import</code>关键字可以被用作一个函数，它获取我们希望被分割成一个独立包的模块的路径，并返回一个承诺。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ln"><img src="../Images/662ce11281baedb20862b986986cd630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyrxUDs3k0WVtDgJSttPCA.png"/></div></div></figure><p id="05ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当模块被加载并且承诺被解析时，我们可以访问它导出的内容。需要注意的是，如果你的模块有一个<strong class="je hv">默认</strong>导出，你需要从<code class="eh le lf lg lh b">module</code>对象获取<code class="eh le lf lg lh b">default</code>属性来访问它。</p><p id="812b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在React的上下文中，我们将要拆分的模块将是不同的组件。为此，我们可以使用<strong class="je hv"> React Loadable </strong>。它让我们可以访问一个<strong class="je hv">高阶组件</strong>来进行动态导入。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/f19886c46a4cb1c74e51deba5c92410b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnHQXJy2jpv06CH8LF91Dw.png"/></div></div></figure><p id="5bdb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里需要注意的是，像<strong class="je hv"> React Loadable </strong>或者<strong class="je hv"> Loadable Components </strong>这样的库，只是给我们提供了一个<strong class="je hv">高阶组件</strong>，让动态导入感觉更优雅。引擎盖背后的魔法都是由<strong class="je hv"> Webpack </strong>完成的。</p><p id="654f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，请记住<strong class="je hv"> React 17 </strong>将给生态系统带来一些变化，可能会让我们不需要使用这样的包装器组件。</p><h1 id="5b3b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">路由级代码拆分</h1><p id="aa70" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">代码拆分中最常见的范例之一是在<strong class="je hv">路由级别</strong>拆分组件。这将为我们留下每个顶级路由的单独包。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/e3edbf101a5a35c1ffabba7c9f541fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HegVgTy-dBz1g3fHTSBZnA.png"/></div></div></figure><p id="7718" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在这里得到的改进是，用户只需为他访问的页面加载<strong class="je hv">和</strong>资源。</p><p id="10a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这是将代码库分割成更小块的一种很好的方式，但通常最大的性能损失来自单个库或组件。</p><p id="f87f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">文档生成库可能非常大。我见过一些可以进入<strong class="je hv"> 2mb </strong>范围的。因此，即使我们已经将不同的路径分成单独的组件，当用户想要访问导出页面时，他将需要处理大量的JavaScript。</p><p id="49bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多方法可以优雅地处理这种情况。我们将在本文的稍后部分研究如何在用户的浏览器空闲时在背景中加载这样的信息。</p><h1 id="0b09" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">动态导入路线</strong></h1><p id="13e9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">由于import可以作为一个函数，自然的思路是我们将能够传递变量给它，并动态地请求不同的块。</p><p id="449a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这不完全是错的，但也不完全是对的。块必须在构建时创建，所以当Webpack看到我们在导入路径中使用了一个变量时，它会先做一些准备工作。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/df19759c1b6bc311fa73f214bf47b808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxWCYlHs8c1-5FteWAbb6w.png"/></div></div></figure><p id="3109" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当我们做这样的事情时，Webpack将进入<code class="eh le lf lg lh b">themes</code>文件夹，并为那里的每个文件<strong class="je hv">创建一个单独的<strong class="je hv">块</strong>。因此，无论我们向它请求什么，都已经有一个同名的包可供我们使用。</strong></p><h1 id="89b7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">命名捆绑包</strong></h1><p id="ae2a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Webpack通过给每个块一个id来跟踪块。因此，当您获取一个动态加载的包时，您很可能会在开发人员工具中看到一个名称类似于<code class="eh le lf lg lh b">1.bundle.js</code>的文件。</p><p id="e779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，通过使用Webpack的<strong class="je hv">神奇注释</strong>并对<strong class="je hv">配置</strong>做一点小小的改变，我们可以给不同的块起一个更具描述性的名字。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/4fa69131e16fde1a41603146038be023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvrMv1VtPnrCreK9I2CIow.png"/></div></div></figure><p id="3b8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">公平地说，我不太喜欢神奇的评论，但我认为这是<em class="ka">最清晰的处理命名的方式。你可以在<strong class="je hv"> React Loadable </strong>中使用神奇的注释，但是为了清楚起见，我只留下了<code class="eh le lf lg lh b">import</code>语句。</em></p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/bb4368b58a738aa52a23086c9403a092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-91-SUdXwrndthev_nYQGg.png"/></div></div></figure><p id="f05d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Webpack配置中添加这一行将指示它使用您指定的名称，并添加一个用于缓存目的的块散列。</p><h1 id="03db" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">预加载和预取</strong></h1><p id="07e5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">除了代码分割之外，预加载和预取是我们可以用来进一步提高性能的两种技术。</p><p id="a1a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在进入另一个概念的技术细节和实现之前，我们首先需要理解为什么我们需要它。</p><p id="0816" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文的前面，我们讨论了当一些组件使用昂贵的库时，组件级拆分的重要性。然而，当用户按下按钮时加载块仍然不理想，因为它可能导致空内容的闪烁或在我们需要的内容呈现之前UI的短暂冻结。</p><p id="252c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当我们确信用户将需要某个特定的包时，我们可以在明确需要之前使用预加载或预取来提取它。这也是通过Webpack magic comment实现的。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/5cb57177e4fe2c6268168f0ccd7cfe05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibzic8EP8LyJUXgA5J4Xuw.png"/></div></div></figure><p id="d217" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">两者有什么区别，什么时候用一个比另一个好？虽然预加载和预取都会在实际需要之前获取数据块，但它们的重要性不同。</p><p id="1399" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">预加载的</strong>块将以更高的优先级与其父块并行加载。只有当你确信用户<strong class="je hv">会</strong>立即<strong class="je hv">与它们交互</strong>时，才标记要预加载的块。这可以是下拉列表或选项卡的内容。</p><p id="016a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">预取的</strong>块优先级较低，将在浏览器空闲时加载。换句话说，标记要预取的块，如果用户<strong class="je hv">可能</strong>在某个时候需要它们。这可能是他最有可能访问的下一页。他不会马上提出要求，但你希望他提出要求时，它就在那里。</p><p id="37c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> React Loadable </strong>为组件提供静态方法<code class="eh le lf lg lh b">preload</code>。它让您可以手动控制何时获取组件的包。当我们想要懒惰时，这是非常有用的。</p><p id="ee81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以等到完全确定用户需要一个昂贵的功能来预加载它。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/bc0775cd9487e5c2fae3d37947426798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0R3k8Ky-fdalFuu_9RfRA.png"/></div></div></figure><h1 id="5323" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">更多关于魔术的评论</h1><p id="182a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Webpack配置我们正在加载的程序块的方式是通过所谓的<strong class="je hv">魔法注释</strong>。老实说，除了我们到目前为止看到的那些基本的，我真的没有用过更多的。然而，很高兴知道我们没有被限制，如果我们需要的话，我们有更多的选择。</p><p id="c756" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">webpackMode</code>注释用于告诉Webpack如何解析给定的块。默认情况下，所有块都以<code class="eh le lf lg lh b">lazy</code>模式加载。这意味着将为他们创建一个单独的块。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/01af0de8ff11e3c3bf0beb77a895b097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAdqgsyGEcONUwKaTXBCZA.png"/></div></div></figure><p id="73b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其他选项有<code class="eh le lf lg lh b">lazy-once</code>、<code class="eh le lf lg lh b">eager</code>和<code class="eh le lf lg lh b">weak</code>。总而言之，我没有用过它们，所以我不能对它们发表评论。到目前为止，我遇到的问题都可以用默认的<code class="eh le lf lg lh b">lazy</code>模式解决。你可以在Webpack的<a class="ae lq" href="https://webpack.js.org/api/module-methods/#import-" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多内容。</p><p id="d2d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数情况下，您会希望指定一个块名，并将该块标记为要预取或预加载。谢天谢地，我们可以根据需要使用多个，用<strong class="je hv">逗号</strong>分隔它们。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lr"><img src="../Images/4d3873d5abc6fcefa3a2c52aabaf5546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5BxZZvXE7fJDVtY58Jtlw.png"/></div></div></figure><h1 id="bc5f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">分析</h1><p id="19a7" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">除非有我们可以<strong class="je hv">测量</strong>的东西，否则我们无法真正谈论性能。为了知道哪里需要改进，我们需要一些洞察力。在代码分割的上下文中，我们需要知道<strong class="je hv">我们的包有多大</strong>以及它们里面到底有什么<strong class="je hv"/>。</p><p id="6b63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有<a class="ae lq" href="https://github.com/webpack-contrib/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Webpack捆绑包分析器</strong> </a>是你最大的朋友。它为您提供了应用程序块的可视化表示，因此您可以看到每个块中的内容。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/32c44fff422110094f27e11d34ee68b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dusVhPiL44VDoS4gJHMWSg.gif"/></div></div></figure><p id="78ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以看到每个模块占用了多少空间以及它被放在哪个块中。这也是找到不需要的代码的好方法。例如，如果你看到你已经添加了整个<strong class="je hv"> lodash </strong>库，你可能应该检查你的代码，只提取你需要的函数。</p><h1 id="642e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">未来的考虑和HTTP/2</h1><p id="57b2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当谈到性能改进时，我坚信代码分割是能给你带来最大好处的技术。</p><p id="c252" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在采用这些概念时，一个常见的担忧是它们是否经得起未来的考验。换句话说，代码拆分不再适用，留给您整个代码库来修改的可能性有多大。</p><p id="7f2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个值得考虑的问题，要记住，直到最近，最好的做法是将所有内容捆绑在一个文件中。然而，我认为如果你的团队计划跟上技术的发展，引入代码分割是最好的决定之一。</p><p id="ed5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了HTTP/2，一次发送多个文件将不再是问题。将所有内容捆绑在一起的主要原因是为了避免发送多个请求。</p><p id="1785" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，通过使用<strong class="je hv"> HTTP/2 Push </strong>，我们将能够一次发送多个文件，而不会有任何额外的开销。</p><h1 id="b920" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated"><strong class="ak">TL；博士</strong></h1><ul class=""><li id="a187" class="lt lu hu je b jf kz jj la jn lv jr lw jv lx jz ly lz ma mb dt translated">为了确保我们的应用程序是高性能的，我们需要为最坏的情况编程。</li><li id="8e18" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">就性能而言，以懒惰的方式装载东西是一种美德</li><li id="9655" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">代码拆分可以用最小的努力给我们带来最大的收益。当项目开始增长时，将它引入我们的团队将为团队将来的可伸缩性做好准备。</li><li id="3259" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">当我们想要确保用户预先拥有他需要的一切时，我们可以利用预取和预加载。</li><li id="4755" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">分析你的包，以最少的未使用代码为目标，删除不必要添加的库。</li><li id="bf83" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">代码分割是未来的证明。</li></ul><h1 id="dd16" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">时事通讯</h1><p id="3aa5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">嘿，我正在经营一个小的时事通讯，在里面我分享关于软件开发的随机想法、思考和见解。没有教程，没有广告。只是一些我发现值得思考的事情每隔几周就会发送到你的收件箱。如果这听起来对你有吸引力，你可以在这里订阅<a class="ae lq" href="https://buttondown.email/kondov" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="94f2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">鼓掌并分享</h1><p id="cbae" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果这篇文章的内容对你有帮助，我会很感激你按住鼓掌按钮一会儿。这样，它将触及并帮助更多的人。与可能会觉得有用的朋友和同事分享，并将任何反馈发送给我！</p></div></div>    
</body>
</html>