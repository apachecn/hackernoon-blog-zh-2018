<html>
<head>
<title>Putting China’s Second-Hand Economy on the Map with GeoHash Matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GeoHash匹配把中国的二手经济放到地图上</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/putting-chinas-second-hand-economy-on-the-map-with-geohash-matching-f6eb7626ff96?source=collection_archive---------7-----------------------#2018-09-06">https://medium.com/hackernoon/putting-chinas-second-hand-economy-on-the-map-with-geohash-matching-f6eb7626ff96?source=collection_archive---------7-----------------------#2018-09-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0acc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">阿里巴巴的先宇科技团队如何记录GPS数据并将十亿件商品映射到当地的“商业区”</em></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/040e3512e57f7e9e33bf59d1b757c9d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJZRNZq3SL88MPoa_owzJQ.jpeg"/></div></div></figure><p id="d9d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">Among China’s rising e-commerce platforms, Alibaba’s Xianyu(闲鱼) has emerged as a popular new destination for buying and selling second-hand goods, with over a billion user-submitted items already listed nationwide. The sheer volume of that inventory, dispersed not among warehouses but among households in “business districts” throughout the country, has challenged the app’s designers to expedite the flow of goods using GPS location data for both items and buyers — a challenge that conventional processing methods have thus far proved no match for.</p><p id="c0aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了建立一个可扩展的系统来有效地将商品和买家与商业区匹配，Xianyu团队使用了一套基于GeoHash精确匹配的算法来记录位置数据，这有助于大大减少完成交易所需的计算量。这种方法还提供了一种新的方法，用于推断与算法识别的区域相邻的区域的代码，再次减少了繁重的计算。</p><p id="af54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们更仔细地看看鲜宇成就背后的努力，以及该应用程序的框架如何在编码环境中简化空间关系。</p><h1 id="7f9f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">解决这个问题</h1><p id="b738" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">为了有效地将城市划分为更小的商业区，先宇首先评估交通网络、商场和住宅区的分布等因素，然后相应地绘制分区图，阿里巴巴的家乡杭州就是如此。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lf"><img src="../Images/9b1ff2b1e4694cf00af8caa8bf3adf2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u4IxeBheY7Kezjsv3GHkxw.png"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek"><em class="lk">Map of Xianyu business districts in Hangzhou city</em></figcaption></figure><p id="3b85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于用户共享的GPS信息，平台上列出的项目首先被编码为点数据，点数据以无序的方式分布在整个区域地图上。Xianyu使用这种GPS数据盘点位于商业区内的商品，并向位于同一地区的潜在买家推荐这些商品。因此，有用的推荐依赖于对属于特定商业区的项目的准确计算。</p><p id="16ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就仙寓数据库中的计算而言，商业区充当形状和大小不同且彼此不重叠的多边形数据参数。同时，项目是GPS标记的点数据。问题是，那么，仙芋如何快速准确地确定这些海量数据点属于哪个商圈呢？传统的方法是使用空间关系方程来计算点-面关系，但这涉及到处理大量的数据-考虑到仙寓上的商品交易量，这项任务已经超出了可行性。</p><p id="3fa4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总体而言，中国的城市被划分为大约10，000个不同规模的商业区，每个商业区有10到80条参数线。使用上述方法将项目与商业区进行匹配，将需要完成20万亿次基本运算来处理全部数据量。使用阿里巴巴内部离线计算集群尝试采取这种方法，在运行该问题两天多后没有任何结果。</p><p id="7a15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">面对创新的需求，Xianyu使用了基于GeoHash的精确匹配算法和粗略GeoHash匹配，并在一定程度上使用了基于空间关系方程的精确匹配算法。在一天的时间内，这种方法能够成功地返回相同重大任务的结果，精确匹配10亿个商品和10，000个商业区的数据。</p><h1 id="7be7" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">地理哈希点数据的技术原理</h1><p id="aed2" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在最基本的层面上，GeoHash将2D地理坐标编码为字母和数字字符串。这些字符串中的每一个都代表一个特定的地理矩形，并由落在该矩形内的所有坐标共享。因此，字符串越长，对应的矩形就越小，定义也越精确。</p><p id="565b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对地理位置进行编码时，会计算目标纬度和经度，以确定它们是落在纬度的原始区间[-90，90]内还是经度的原始区间[-180，180]内。落在左侧部分的点记为0，落在右侧的点记为1。然后，将前一步骤中获得的间隔对折，以执行进一步的搜索功能，这又返回新的二进制代码。当该过程产生长度达到所需精度的二进制代码时，该代码随后根据经度值放置在偶数比特上而纬度值放置在奇数比特上的规则进行交织，从而产生新的二进制串。在最后一步中，根据Base32表将该二进制字符串转换为字符串，从而产生地理坐标的精确GeoHash字符串。</p><p id="bd99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面给出了GeoHash字符串计算的一个示例，坐标为“30.280245，120.027162”。首先，纬度是根据以下步骤编码的二进制:</p><p id="e659" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.将[-90，90]分成相等的两半。“30.280245”位于右边部分(0，90)，因此第一位为1。</p><p id="f38d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.将[0，90]分成相等的两半。“30.280245”落在左边部分(0，45)，因此第二位为0。</p><p id="8e80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.不断重复这个过程，使合成的区间越来越小，其两个端点越来越接近“30.280245”。</p><p id="a44d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下图所示的过程详细说明了第一轮迭代:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ll"><img src="../Images/7bc31b04926e84c5ba2d03e0073eddd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fsYZu77LclVgBFq5iRREEQ.png"/></div></div></figure><p id="a9c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些迭代继续进行，直到代码的长度达到要求的精度。15位二进制代码的完整迭代表如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/84d1bc18cb2c2f5539fbb0ce656377ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*I2Ll1FkiPs7fj9iQjqpeIA.png"/></div></figure><p id="8462" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">纬度的结果二进制代码是10101 01100 01000。</p><p id="cd13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经度的二进制代码通过相同的迭代过程得到:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/86319d260f44223eb5330c751947d9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*fEOoGBA5Mhv_aOw8l1ikAw.png"/></div></figure><p id="ce1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经度的结果二进制代码是11010 10101 01101。</p><p id="377a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">遵循经度值放在偶数位置比特上，纬度值放在奇数位置比特上的规则，纬度和经度的二进制码然后被交织以产生最终的二进制码:11100 11001 10011 10010 00111 00010。</p><p id="1743" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，确定Base32码，每五个二进制码对应一个二进制码。因此，五个二进制位被转换为十进制位，返回值为28、25、19、18、7、2。基于下面的Base32代码表，生成的代码是wtmk72。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/87c113701b5af770fa7a60e6dbbb8a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*XFTypvBVI4rj2GPtzX7Zcg.png"/></div></figure><p id="99c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些结果随后可以在geohash.org得到验证。在这种情况下，验证结果如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lp"><img src="../Images/2a9c6421f5e54283f7a4a7829825bde4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNXkZnoUSYb2EC-bhlfWOA.png"/></div></div></figure><p id="fbc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">geohash.org结果中显示的前几位与之前的计算结果一致。通过二进制除法程序进行多轮迭代同样可以返回更长、更精确的结果，如核查网站所示。</p><p id="2fb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GeoHash字符串长度对应于精度，如下所示:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lq"><img src="../Images/b6dd08c093d09b12aa7f1c7c2f5e771f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YtZi82kFBkeMtAQYdnuK2g.png"/></div></div></figure><h1 id="374a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">获取表面数据的GeoHash代码</h1><p id="470f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">上一节介绍的标准GeoHash算法只能计算2D点坐标的GeoHash代码。然而，为了完成位置匹配任务，Xianyu还需要一种方法来确定相关表面数据(地理信息系统(GIS)中的多边形对象)的GeoHash代码。这需要进一步扩展先前工作中应用的算法。</p><p id="5f4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该方法的第一步是确定相关多边形的最小外接矩形(MBR ),然后计算MBR西南角坐标的GeoHash代码。在逆GeoHash编码过程中确定对应于该GeoHash码的矩形GeoHash块。从这个GeoHash块开始，Xianyu的机制然后在北面和东面搜索相同大小的相邻GeoHash块，继续进行，直到从MBR完全定义了一个GeoHash块。如此定位的一些GeoHash块的边可能不与所讨论的多边形相交，如果是这样，则必须通过后续步骤中详述的一系列计算来移除这些块。</p><p id="88f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于上面的示例，结果的高清图像如下所示，其中蓝色GeoHash块与原始多边形部分相交，橙色GeoHash块完全包含在原始多边形中。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lr"><img src="../Images/6bb79f8ed72d2a8cc16573e011182d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIz2KhRPdPmE-1sNfotHRQ.png"/></div></div></figure><p id="d9ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的流程图演示了上述算法:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ls"><img src="../Images/8555a180dea30bed4e209d8e1e2916fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKEEnNE1XtM8fuHovhovvw.jpeg"/></div></div></figure><h1 id="134e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">一种快速查找相邻GeoHash块的算法</h1><p id="f571" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在上一节的GeoHash编码流程图中，用青绿色和橙色标记的两个步骤分别用于查找东面和北面的相邻GeoHash字符串。</p><p id="6f85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用传统方法，可以使用描述当前解码的GeoHash块的信息来获得相邻块内的一个点的坐标。然后对该点进行GeoHash编码，结果用作相邻块的GeoHash代码。如下图所示，获取“wtmk72”周围8个相邻块的代码包括将“wtmk72”解码为4个顶点(N1、N2、N3和N4)的坐标，这是使用逆GeoHash编码过程完成的。然后，这些坐标用于计算N5的坐标，N5是右侧相邻区块内的一个随机点。然后对N5进行GeoHash编码，得到“wtmk78”，即右边相邻块的代码。“wtmk72”周围的其他7个相邻块的代码可以用同样的方法获得。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lt"><img src="../Images/e53e0ead0170b48672524a6f6fcf2420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EOmnBiSdw_U_2ufQ9DKJQ.png"/></div></div></figure><p id="b2ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法需要解码过程，然后是编码过程。这会占用大量时间，特别是如果指定的GeoHash字符串很长(因此需要许多解码-编码循环)。</p><p id="bab8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过观察GeoHash编码表的模式和Z-order曲线的特征，Xianyu能够验证一种通过查表快速确定相邻GeoHash字符串的方法。</p><p id="ef7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里继续使用GeoHash字符串“wtmk72”作为示例是有意义的。对应的十进制数为“28，25，19，18，7，2”，二进制码为11100 11001 10011 10010 00111 00010。其中w对应分别代表“经度、纬度、经度、纬度、经度”的5个二进制码11100，t对应分别代表“纬度、经度、纬度、经度、纬度”的5个二进制码11001。概括地说，GeoHash字符串中的奇数位字符(本例中为“w”、“m”和“7”)表示对应于“经度、纬度、经度、纬度、经度”的二进制位，而偶数位字符(本例中为“t”、“k”和“2”)表示对应于“纬度、经度、纬度、经度、纬度”的二进制位。</p><p id="4f7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“w”的二进制代码是11100，翻译成“右、上、右、下、左”。“t”的二进制代码是11001，翻译成“上、右、下、左、上”。</p><p id="0749" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种字符方向转换揭示了下表中显示的奇数位的字符位置映射:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lt"><img src="../Images/e643bea84f1286d28074eb1ae57d02c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4oW-ITlxCpjEiqNNG1N5g.png"/></div></div></figure><p id="ad4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是偶数位的字符位置映射表:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/12a85f7ef3e0c2dd7b03dc25e1f1bdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*dldBTCiHBa-or65qKLEm0A.png"/></div></figure><p id="56c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有趣的是，这两个表可以通过反转它们的轴并相应地转置来相互转换。</p><p id="6531" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这两个表可以让仙宇的系统快速确定每个字符周围的8个字符。要计算给定GeoHash字符串周围的8个GeoHash值:</p><p id="1304" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果字符串的最后一个字符没有超出这个方向的边界，方法是保持前几个字符不变，取这个方向的相邻字符。</p><p id="d820" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果最后一个字符在这个方向上超出了表格边界，方法是找到这个方向上倒数第二个字符的相邻字符，然后是同方向上最后一个字符的循环相邻字符。</p><p id="af1a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果该方向上倒数第二个字符的相邻字符也落在表格边界之外，则需要首先找到该方向上倒数第三个字符的相邻字符，依此类推。</p><p id="2192" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以“wtmk72”为例，查找这个GeoHash字符串周围的8个字符串相当于定位最后一个字符“2”的相邻字符。偶数位置位表适用于“2”，它的8个相邻字符是“1”、“3”、“9”、“0”、“8”、“p”、“r”、“x”，其中，“p”、“r”和“x”位于表的下边界之下，相邻关系是通过连接偶数位置位表的上部分和下部分获得的。对于这3个落在边界下的字符，方法是找到倒数第二个字符“7”正下方的相邻字符。“7”位于奇数位，因此奇数位位表适用于此处。表中紧接在“7”下面的相邻字符是“5”。因此，“wtmk72”的8个相邻GeoHash字符串是“wtmk71”、“wtmk73”、“wtmk79”、“wtmk70”、“wtmk78”、“wtmk5p”、“wtmk5r”和“wtmk5x”。</p><p id="09c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了这种以相邻字符为中心的快速算法，上一节流程图中详述的表面数据GeoHash编码算法的效率大大提高。</p><h1 id="466b" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">将海量点数据与表面数据连接起来</h1><p id="0406" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">Xianyu在海量点数据和表面数据之间建立联系的新方法包括计算项目GPS数据(点数据)和商业区AOI数据(多边形数据)的GeoHash码，如使用上述算法所详述的。这些GeoHash码长度相同，每个点数据都有一个唯一的GeoHash字符串。同样，每一条地表数据对应一个或几个GeoHash码，这些geo hash码要么“完全包含”，要么“部分包含”。</p><p id="3a62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了继续处理这些完全包含的字符串，Xianyu将所有项目的GeoHash字符串加入到商业区字符串中。由此产生的<items business="" district="">数据使其能够确定这些商品属于哪个商业区。</items></p><p id="a8e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于仍然需要确定适当商业区的其他项目，方法是将它们的GeoHash字符串加入到部分包含的商业区字符串中。得到的<items business="" districts="">数据表明了可能的“商业区-项目”包含模式。为了验证这种包含关系，将几何关系运算应用于项目的GPS数据和商业区AOI数据。</items></p><p id="30e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如下图所示，项目1的点数据的GeoHash代码为“wtmk70j”，成功地将其与表面数据的完全包含字符串“wtmk70j”连接起来。这证实了项目1可以被归类为属于该表面数据。</p><p id="fb94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">项目2的点数据的GeoHash代码为“wtmk70r”，成功地将其连接到表面数据的部分包含的字符串“wtmk70r”。因此，第2项似乎属于表面数据，尽管这需要进一步的几何点-表面计算来确认。项目3的点数据的GeoHash代码与任何曲面数据的GeoHash块代码都不匹配，这可以快速确认项目3不是此曲面数据的一部分。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lv"><img src="../Images/92302f7d7746ec76f8e4f9f7e6ab61fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xiCfdl33ZUYu4G6ODBlHlw.png"/></div></div></figure><p id="e17b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在实际场景中，需要有效地协调来自中国各地的大量项目GPS数据和大量商业区数据。通常，由于完全包含在表面数据的第一个实例中，大多数项目可以一步分配给商业区。对于其他项目，GeoHash匹配可以将匹配项目和商业区的几何计算从“1个项目x全国所有商业区”笛卡尔乘积尺度减少到“1个项目x 1个(或几个)商业区”笛卡尔乘积尺度。这样，可以避免绝大多数不必要的几何计算，节省大量时间。</p><p id="6ed3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，在使用本文中详细介绍的quick算法处理10亿个项目和10，000个商业区的数据时，Xianyu使用了10亿次GeoHash点编码计算、10，000次GeoHash表面编码计算和500万次确定点是否落在表面内的计算，总共大约需要1，800亿次基本操作，这只是传统方法所需的20万亿次基本计算的一小部分。使用本文详细介绍的算法，阿里巴巴的离线计算平台在不到一天的时间内完成了这一壮举。</p><p id="1601" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多几何算法可以确定给定点和多边形之间的包含关系。最常用的是光线投射算法。简单地说，这包括从该点画一条射线，并计算射线与多边形的线相交的次数。如果数字是奇数，则该点在多边形内部；如果不是，那一定是在它之外。</p><p id="f7cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本质上，使用GeoHash简化海量点数据与面数据之间的空间关系计算，是一种空间索引方法。许多有用的空间索引技术已经在GIS领域得到应用，包括R树系列(R树、R +树、R *树)、四叉树、K-D树和格网索引，每种索引技术都有自己鲜明的特点。除了处理点-面关系问题，本文中的方法还可以快速处理点-点、面-面、点-线和线-线关系。例子包括快速确定大规模公共汽车站属于哪条道路，以及多条道路或铁路是否相交，等等。</p><p id="358e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">(Original article by Luo Junfeng罗俊沣)</p><h1 id="5184" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">参考</h1><p id="7165" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">[1]<a class="ae lw" href="https://en.wikipedia.org/wiki/Geohash" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Geohash</a></p><p id="8085" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[2]<a class="ae lw" href="https://en.wikipedia.org/wiki/Pointinpolygon" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Pointinpolygon</a></p><p id="9044" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[3]<a class="ae lw" href="https://www.geeksforgeeks.org/how-to-check-if-a-given-point-lies-inside-a-polygon" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/how-to-check-if-a-given-point-lies-in-a-polygon</a></p><p id="0c74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[4]<a class="ae lw" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geohashgrid-aggregation.html" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/guide/en/elastic search/reference/current/search-aggregations-bucket-geohashgrid-aggregation . html</a></p><p id="02be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">[5]<a class="ae lw" href="http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves" rel="noopener ugc nofollow" target="_blank">http://blog . not dot . net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-quad trees-and-Hilbert-Curves</a></p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><h1 id="0fa6" class="kc kd hu bd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae lw" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">【阿里巴巴科技】</strong> </a>。Twitter:<a class="ae lw" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">【AlibabaTech】</strong></a>。</p></div></div>    
</body>
</html>