<html>
<head>
<title>The curious case of Hebrew rendering in Java swing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java swing中希伯来语渲染的奇特案例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-curious-case-of-hebrew-rendering-in-java-swing-2c656537c98b?source=collection_archive---------17-----------------------#2018-09-06">https://medium.com/hackernoon/the-curious-case-of-hebrew-rendering-in-java-swing-2c656537c98b?source=collection_archive---------17-----------------------#2018-09-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f9ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最近遇到了一个有点深奥的问题:Java Swing应用程序的渲染性能。等等，什么？2018年谁用Swing？嗯，说到桌面应用程序，Swing仍然有几个优势:它是平台无关的(这是Java的一部分特性)，健壮，丰富和强大。当然，它也有缺点，但这不是我们今天的话题…</p><h2 id="861b" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">希伯来语(实际上非英语)字符串呈现性能</h2><p id="335f" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">在我从事的一个项目中，有一个奇怪的问题:渲染一长串希伯来语字符串要花很多时间。我说的是当一个列表被渲染时，几秒钟的GUI被冻结。当我用英文(ASCII)字符串替换列表项时，一切都很顺利。</p><p id="4f60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在深入研究了代码之后，看起来问题的根源在Swing代码的内部——在JRE本身的一个类中。幸运的是，Java是一种开源语言，所以我能够深入研究JRE类并找到这个缓慢渲染问题的原因。</p><h2 id="65c3" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">如何测量弦</h2><p id="c52c" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">让我们看一个简单的例子:一个JComboBox，带有一个基于字符串的模型。这是基本的Swing组件之一，基本上由一个输入字段和一个下拉列表组成。</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/d355245ee440121d8a5f323c1e2948ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*Q0xiPAbQ3N0v4PoK9xxnfw.png"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">A simple test application with two JComboBoxs (the right one is populated with Hebrew strings)</figcaption></figure><p id="df57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当这个组件呈现在屏幕上时，列表中的字符串应该绘制在屏幕上。在呈现过程的某个时刻，会计算字符串的宽度，以确定列表的维度。有趣的部分来了:ASCII字符与非ASCII字符的处理方式不同。在我们看代码之前，理解为什么ASCII和非ASCII字符被不同地处理是很重要的:在一个只包含ASCII字符的字符串中，我们可以有把握地说字符串的宽度等于构建它的字符的宽度。这句话听起来微不足道，但事实上并不是所有语言都如此，正如在<a class="ae jp" href="https://docs.oracle.com/javase/8/docs/technotes/guides/2d/spec/j2d-fonts.html" rel="noopener ugc nofollow" target="_blank"> Java文档</a>中所解释的:</p><blockquote class="lc ld le"><p id="b29b" class="ir is lf it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">字形是一个或多个字符的可视表示。字形的形状、大小和位置取决于它的上下文。根据字体和样式，可以使用许多不同的字形来表示单个字符或字符组合。</p><p id="4852" class="ir is lf it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">例如，在手写的草书文本中，特定的字符可以呈现不同的形状，这取决于它与相邻字符的连接方式。"</p></blockquote><p id="757c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记住这一点，让我们来看看<code class="eh lj lk ll lm b">FontDesignMetrics</code>类中一个名为<code class="eh lj lk ll lm b">stringWidth</code>的方法内部的代码(<a class="ae jp" href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/687fd7c7986d/src/share/classes/sun/font/FontDesignMetrics.java" rel="noopener ugc nofollow" target="_blank">这里是原始源文件</a>)。顾名思义，该方法获取一个字符串，并在呈现后返回它的宽度(以任意印刷单位):</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ln"><img src="../Images/2ff9625687e19ed4c9c929fc8b9d170c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UM20pksAgYmDdmnCci-3EQ.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">The original stringWidth method (from the FontDesignMetrics class)</figcaption></figure><p id="344c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想特别注意从第473行开始的for循环(在上图中)。这个循环遍历被测字符串的字符。在ASCII字符串的情况下(0x100等于十进制256)，宽度聚合为字符宽度的总和。字符宽度通过<code class="eh lj lk ll lm b">getLatinCharWidth</code>方法获得，该方法使用内部缓存优化性能。</p><p id="8c5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么非ASCII字符呢？如果对<code class="eh lj lk ll lm b">FontUtilities::isNonSimpleChar</code>(第477行)的调用将返回true(对于希伯来字符来说，确实如此)，那么将计算整个字符串的宽度，并且for循环将会中断。这意味着每个字符串必须作为一个整体呈现，以确定其宽度。这正是我们性能问题的原因。</p><p id="8b50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有趣的部分来了。在大多数情况下，我们可以像对待拉丁字符一样对待希伯来字母。换句话说，我们实际上可以说希伯来语字符串的宽度等于其字符的总和。考虑到这一点，我们可以只计算一次每个希伯来字符的宽度，并缓存结果(基本上与拉丁字符得到的处理相同)。</p><p id="1984" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是修改后的代码:</p><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ls"><img src="../Images/9c399d776d9d7b79d3076bc4080f380a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9FyvH8p9pstp1Gl14f6QQ.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">The revised stringWidth method</figcaption></figure><p id="5df6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第481行，希伯来字符(值在<code class="eh lj lk ll lm b">0x0590</code>和<code class="eh lj lk ll lm b">0x05ff</code>之间的字符)现在被区别对待，使用缓存的值将宽度累加为字符的总和。</p><h2 id="1130" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">替换一个JRE类。</h2><p id="fad0" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">这在理论上很棒——但现在我们面临另一个问题。<code class="eh lj lk ll lm b">FontDesignMetrics</code>类驻留在<code class="eh lj lk ll lm b">sun.font</code>包中，它是JRE运行时jar (rt.jar文件)的一部分。当Java类加载器寻找一个类时，它首先扫描引导类(包括rt.jar ),如果在那里找到了该类——将使用该类的这个版本，所以我们不能通过将它克隆到我们的<a class="ae jp" href="https://hackernoon.com/tagged/codebase" rel="noopener ugc nofollow" target="_blank">代码库</a> ( <a class="ae jp" href="https://docs.oracle.com/javase/tutorial/ext/basics/load.html" rel="noopener ugc nofollow" target="_blank">参见Java文档</a>)来隐藏原始类。怎么还能用这个类的自定义版本？有许多选项，在<a class="ae jp" href="https://stackoverflow.com/questions/33631419/replace-a-class-within-the-java-class-library-with-a-custom-version" rel="noopener ugc nofollow" target="_blank">这个有趣的stackoverflow线程</a>中也有讨论:</p><ol class=""><li id="d843" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated">更改源代码并重新构建JRE二进制文件。这个选项有很多缺点:首先，这不是一个简单的任务。此外，客户将不得不在他们的机器上安装我们的修订版JRE，使他们暴露于可能的安全漏洞。此外，还有交易的法律方面(尽管使用OpenJDK应该不成问题)。最后——因为单个类中的微小变化而重新构建JRE就像用大锤砸坚果一样…</li><li id="50f0" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">使用<code class="eh lj lk ll lm b">Xboothclasspath/p</code> JVM标志将类添加到类路径中。这是一个非标准的标志，由于许可证问题(它“违反了JRE二进制代码许可证”，如<a class="ae jp" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" rel="noopener ugc nofollow" target="_blank"> java命令文档</a>中所述)，它不打算用于生产。</li><li id="ecc7" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated">使用Java instrumentation API在运行时替换类文件。我相信这是最优雅的解决方案——所以让我们看看它的实际应用吧！</li></ol><h2 id="bf22" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">构建java代理</h2><p id="fa18" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">Java instrumentation API<a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html" rel="noopener ugc nofollow" target="_blank">允许运行时字节码操作。这个API是通过使用Instrumentation对象来访问的，该对象是以一种特殊的方式获得的，甚至是在调用main方法之前。</a></p><p id="c61e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要获得这个特殊的对象，必须实现一个Java代理——一个具有特殊清单属性的JAR文件和一个实现<code class="eh lj lk ll lm b">premain</code>方法的类。顾名思义，这个方法由JVM在程序的main方法之前调用，并获取一个Instrumentation对象的实例作为参数。</p><p id="d92d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代理代码可在<a class="ae jp" href="https://bitbucket.org/ShayArtzi/swingfixagent/" rel="noopener ugc nofollow" target="_blank">这个位存储库</a>中获得。代理类包含<code class="eh lj lk ll lm b">premain</code>方法，如清单文件中所示。在这个方法中，我使用了Instrumentation实例来注册一个<code class="eh lj lk ll lm b">ClassFileTransformer</code>实现，它能够在运行时拦截类加载器调用并替换请求的类。当这个代理处于活动状态时，将检查对类加载器的每个调用，如果请求的类是我们想要替换的类，它将返回该类的修改版本。</p><h2 id="9c47" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">结果</h2><p id="afe9" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">那么…真的有用吗？下面是测试应用程序的加载时间:</p><ul class=""><li id="faed" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo mh lz ma mb dt translated">没有代理注入修改的类7232 ms</li><li id="74fa" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo mh lz ma mb dt translated">有了代理，仅需290毫秒！</li></ul><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mi"><img src="../Images/108b3df1aa7f7099477b3d6895e12e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwHKxL0_KCcGkBnPTT0gkA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Test application loading time without the agent — more than 7(!) seconds</figcaption></figure><figure class="kr ks kt ku fq kv fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mi"><img src="../Images/be769c0dd55a94a78915183209b7ed55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BATBjxRaDwbmRSdEG9sknQ.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Now with the agent — less than 300ms…</figcaption></figure><h2 id="261d" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">最后的想法</h2><p id="1b55" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">在大多数情况下，引入对JRE类文件的更改可能不是最好的主意，但有时别无选择:Swing维护并不是语言路线图中的首要任务。</p><p id="5fac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，对于这个问题，我们可以采取另一种方法:通过在内存中保存完整的列表模型并在必要时提供列表，简单地不呈现长列表。这解决了渲染性能问题，但增加了代码的复杂性。</p><p id="d244" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不管怎样，我认为从JRE和工具API的这个小旅程中可以学到很多东西。</p><p id="20a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章中的所有代码都可以在<a class="ae jp" href="https://bitbucket.org/ShayArtzi/swingfixagent" rel="noopener ugc nofollow" target="_blank">我的Bitbucket知识库</a>中找到。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>