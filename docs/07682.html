<html>
<head>
<title>Image Feature Extraction: Local Binary Patterns with Cython</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像特征提取:基于Cython的局部二值模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/image-feature-extraction-local-binary-patterns-with-cython-b31171ad5dc9?source=collection_archive---------3-----------------------#2018-09-10">https://medium.com/hackernoon/image-feature-extraction-local-binary-patterns-with-cython-b31171ad5dc9?source=collection_archive---------3-----------------------#2018-09-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="c6b8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="0a2d" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">特征提取的共同目标是将原始数据表示为一组精简的特征，以更好地描述其主要特征和属性[1]。这样，我们可以减少原始输入的维数，并使用新的特征作为输入来训练模式识别和分类技术。</p><p id="2356" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">虽然我们可以从图片中提取一些特征，但局部二进制模式(LBP)是一种理论上简单但有效的灰度和旋转不变纹理分类方法。它们之所以有效，是因为最常见的模式对应于原始的微观特征，如边缘、拐角、斑点、平坦区域[2]。</p><p id="4c7a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在[2]中，Ojala等人表明，均匀图案的离散出现直方图是一种非常强大的纹理特征。图像纹理被定义为由两个属性表征的二维现象:(1)空间结构(图案)和(2)对比度。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/6ae28eb5d413fe61e52442215def775c.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*gdZTOBV43FcDZ2fL13-ncA.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Fig 1. Image used to test the local binary patterns methodology</figcaption></figure><h1 id="2b2f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">方法学</h1><h2 id="4062" class="le is hu bd it lf lg lh ix li lj lk jb ka ll lm jf ke ln lo jj ki lp lq jn lr dt translated">循环对称邻居集</h2><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/912f37fc893f13c093ed98e2cdaa7d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*hz77sz7Odqf7jNq7aLvsBQ.png"/></div></figure><p id="7e86" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">给定像素<em class="lt"> gc </em>的循环对称邻居集由围绕半径为<em class="lt"> R </em>的圆上的中心点的坐标为(I，j)的点和多个元素<em class="lt"> P </em>定义。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff lu"><img src="../Images/8ec6f3d660a19689766d149c19be7abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2m88xYYha-nu24SFnSvwFA.png"/></div></div></figure><h2 id="8ed7" class="le is hu bd it lf lg lh ix li lj lk jb ka ll lm jf ke ln lo jj ki lp lq jn lr dt translated">纹理</h2><p id="cf15" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们将纹理定义为灰度图像中的像素集合</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/2fbe058cb40500379520c6a0adc0ca8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*jldNZvm_cTqT5XE3GF3B3w.png"/></div></figure><p id="8bc0" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">其中<em class="lt"> gp </em>对应于<em class="lt"> p </em>局部邻域的灰度值。</p><h2 id="c4bd" class="le is hu bd it lf lg lh ix li lj lk jb ka ll lm jf ke ln lo jj ki lp lq jn lr dt translated">插入文字</h2><p id="9f40" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当邻居不位于像素的中心时，应该通过插值计算该邻居灰度值。因此，我们需要定义一个函数，给定一个坐标，返回插值后的灰度值。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff ma"><img src="../Images/ee9f178dfecbe80b4d77abebceef1151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcRZXPjQMXwh-P1MUFtVaw.png"/></div></div></figure><h2 id="83ce" class="le is hu bd it lf lg lh ix li lj lk jb ka ll lm jf ke ln lo jj ki lp lq jn lr dt translated">实现灰度不变性</h2><p id="c74b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">考虑到可能的信息损失，可以将纹理转化为关节差。为了计算它，我们将中心像素的灰度值减去所有相邻像素的灰度值。联合差分分布是一种高分辨率的纹理算子。它记录了P维直方图中每个像素附近各种模式的出现情况。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/c559726c48a926a77829e3a8c2d5cb86.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*Z0n150Dg1ClInWA2wEN_0g.png"/></div></figure><p id="e890" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">其中<em class="lt"> gp </em>是<em class="lt"> p </em>邻居的灰度值。这种分布对于灰度变化是不变的。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mc"><img src="../Images/a4902c1657217f401c3f003bd6f7ae52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*riZx1aGFh8s4rHNmr6gidA.png"/></div></div></figure><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff md"><img src="../Images/c6e4a38317fd027619bce7dc6d0f1bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDyXiwGPP-GdE4KwxpCyMg.png"/></div></div></figure><h2 id="77eb" class="le is hu bd it lf lg lh ix li lj lk jb ka ll lm jf ke ln lo jj ki lp lq jn lr dt translated">局部二元模式</h2><p id="b6d2" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="lt"> LBP_{P，R} </em>算子根据定义相对于灰度的任何单调变换是不变的。只要灰度值的顺序保持不变，<em class="lt"> LBP_{P，R} </em>算子的输出就保持不变。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff me"><img src="../Images/906bfdb74ca5155f93d6f30e258443ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*Ck7qIll7lJJrvNuxOeFkEQ.png"/></div></figure><p id="6e62" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">在哪里</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/99a580c6e3dce007bb004dd251d10eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*2Y8bhZxwp-HKIgJYVuL3eA.png"/></div></figure><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mg"><img src="../Images/ad3029d51eedafcf36de9db0b9933a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYyGfJIIybKCyS3h4fN5WA.png"/></div></div></figure><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mh"><img src="../Images/2a2c3d19e4ed85a838ee8ec3439aaf4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zm9KaRVrt1SCNodF2b0JRQ.png"/></div></div></figure><h2 id="baf9" class="le is hu bd it lf lg lh ix li lj lk jb ka ll lm jf ke ln lo jj ki lp lq jn lr dt translated">均匀局部二元模式</h2><p id="859f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在[2]中，Ojala提到在他们的实践经验中，LBP不是一个好的鉴别者。他们建议只选择局部二进制模式的集合，使得空间转换(逐位0/1变化)的数量不超过2。例如，图案‘1111’具有0个空间过渡，图案‘1100’具有1个空间过渡，图案‘1101’具有2个空间过渡。每个统一模式都有一个唯一的索引。创建指数的公式是从这里的<a class="ae mi" href="https://github.com/scikit-image/scikit-image/blob/master/skimage/feature/_texture.pyx" rel="noopener ugc nofollow" target="_blank">借用过来的</a>。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mj"><img src="../Images/4105a445fee09f335c116a6b97d904e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HceA9dFmkzNi0jgKNh3qyA.png"/></div></div></figure><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mg"><img src="../Images/7ff5ac09e370f84ecef7d0a1efa4bc1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mx1-EV_MFboNJV31obK_0A.png"/></div></div></figure><p id="f30e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">现在，我们可以计算中心像素的局部二进制模式。下一步是计算所有像素的局部二进制模式。</p><p id="41e8" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated"><em class="lt">提示:为了简单起见，我不考虑所选索引为负的情况(即img_gray[-1][0]返回第一列的最后一个像素)。如果我们想有一个更准确的计算，我们应该考虑这种情况，并对待它。</em></p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mk"><img src="../Images/130c048a6a43b8304129dd3de5a77b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTk6SacSRwRGz8t_fjxLVA.png"/></div></div></figure><h1 id="76df" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">Cython代码</h1><p id="50a1" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">之前的代码并不完善；然而，真正让它慢的是我们遍历所有的图像像素。如果我们考虑到我们还必须训练模式识别技术，那么等待1分10秒来计算我们的特征是很多的。因此，我们需要一个对于循环来说速度更快的替代实现。在这种情况下，我们将使用Cython。下一张图中显示了代码，这是一大段代码。它的某些部分还可以改进，但它已经快得多了。如果你对代码有不理解的地方，请留下你的评论。</p><p id="7486" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">代码的编写方式使得大部分代码完全在C API中运行。这种策略大大加快了执行速度，同时也让我们能够利用Cython的并行模块。我们将在CPU的多个内核之间分配任务。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="d744" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">使用4个线程，我们可以在不到150毫秒的时间内计算所有像素的局部二进制模式。这是如此之快，我甚至懒得计算多少次。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mn"><img src="../Images/5d34a14cbcb2b8193746dd52f44958e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyPMaKjtugduosBbJmOVZw.png"/></div></div></figure><h1 id="89a7" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">与类似图像的比较</h1><p id="365b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">让我们采取另一个形象的砖，但这将有一个不同的纹理。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/b51d917394524c4b491f8e2519c8f35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*fuCCrhY3p-HOAiuN0QMJ-w.png"/></div></figure><p id="6090" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">两个直方图非常相似，应该是，最后两个都是砖块。尽管如此，从20岁到40岁的特征在两幅图像中非常不同。这意味着有了好的机器学习算法，我们可以正确地对它们进行分类。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="fe ff mp"><img src="../Images/e76c7cb0b1ac1fb8bd413d29e9532ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ym__TGkaeVY2_typ5Hzoyw.png"/></div></div></figure><h1 id="8456" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="9be4" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">局部二进制模式是简单但有效的特征。背后的理论不难理解，也很容易编码。然而，如果我们完全用Python来编写它们，我们会有一些性能问题。我们用Cython解决了这个问题，并取得了令人印象深刻的结果。下一步是收集不同的纹理图像，训练你喜欢的机器学习算法进行分类。</p><h1 id="250e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">Jupyter笔记本</h1><p id="55c7" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae mi" href="https://github.com/ocampor/notebooks/blob/master/notebooks/image/features/local-binary-patterns.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/oc import/notebooks/blob/master/notebooks/image/features/local-binary-patterns . ipynb</a></p><h1 id="11db" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">文献学</h1><p id="18b2" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">[1]马克斯·奥(2011年)。使用MATLAB进行实际的图像和视频处理。约翰·威利父子公司。</p><p id="885e" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">[2]茨韦塔纳·奥贾拉、米韦塔纳·皮蒂凯宁和梅恩佩·茨韦塔纳(2002年)。基于局部二值模式的多分辨率灰度和旋转不变纹理分类。IEEE模式分析和机器智能汇刊，24(7)，971–987。</p></div></div>    
</body>
</html>