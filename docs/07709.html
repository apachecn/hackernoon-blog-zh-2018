<html>
<head>
<title>Common (But not so Common) Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见(但不太常见)的单子</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/common-but-not-so-common-monads-ae7ded7911d2?source=collection_archive---------30-----------------------#2018-09-10">https://medium.com/hackernoon/common-but-not-so-common-monads-ae7ded7911d2?source=collection_archive---------30-----------------------#2018-09-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/aa59e878f4e939995d33bf6ef4c085d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*e7GNcsqJCg4x6D2HzhMERA.png"/></div></figure><p id="92ac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae jw" href="https://james-bowen-c4sg.squarespace.com/blog/2018/8/27/TODO" rel="noopener ugc nofollow" target="_blank">上周</a>我们看了单子如何帮助你在Haskell开发中进行下一次跳跃。我们回顾了<code class="eh jx jy jz ka b">runXXXT</code>模式，以及它是如何成为我们从其余代码中使用某些单子的一个常见途径。但有时回到基础也会有所帮助。事实上，我花了很长时间都没有真正掌握如何使用一些基本的单子。或者最起码，我不明白怎么把它们当单子用。</p><p id="fa9c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在本文中，我们将看看如何使用列表单子和函数单子。列表和函数是任何Haskeller从一开始就知道的核心概念。但是列表数据结构和函数应用也是单子！理解它们是如何工作的可以让我们更多地了解单子是如何工作的。</p><p id="430a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">关于单子的深入讨论，请查看我们的<a class="ae jw" href="https://www.mmhaskell.com/monads" rel="noopener ugc nofollow" target="_blank">函数数据结构系列</a>！</p><h1 id="3a75" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Do语法的一般模式</h1><p id="40e3" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">使用<code class="eh jx jy jz ka b">do</code>语法是理解如何实际使用单子的关键之一。bind操作符使得很难跟踪你的参数在哪里。Do语法保持了结构的整洁，并允许您轻松地传递结果。让我们看看这是如何与<code class="eh jx jy jz ka b">IO</code>一起工作的，它是许多Haskellers学习的第一个单子。这里有一个例子，我们从一个文件中读取第二行:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="a565" class="lm kc hu ka b fv ln lo l lp lq">readLineFromFile :: IO String<br/>readLineFromFile = do<br/>  handle &lt;- openFile “myFile.txt” ReadMode<br/>  nextLine &lt;- hGetLine handle<br/>  secondLine &lt;- hGetLine handle<br/>  _ &lt;- hClose handle<br/>  return secondLine</span></pre><p id="db81" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">通过记住所有<code class="eh jx jy jz ka b">IO</code>函数的类型签名，我们可以开始看到do语法的一般模式。让我们将每个表达式替换为它的类型:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="b754" class="lm kc hu ka b fv ln lo l lp lq">openFile :: FilePath -&gt; IOMode -&gt; IO Handle<br/>hGetLine :: Handle -&gt; IO String<br/>hClose :: Handle -&gt; IO ()<br/>return :: a -&gt; IO a</span><span id="3f3a" class="lm kc hu ka b fv lr lo l lp lq">readLineFromFile :: IO String<br/>readLineFromFile = do<br/>  (Handle) &lt;- (IO Handle)<br/>  (String) &lt;- (IO String)<br/>  (String) &lt;- (IO String)<br/>  () &lt;- (IO ())<br/>  IO String</span></pre><p id="473e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">do表达式中的每一行(除了最后一行)都使用赋值操作符<code class="eh jx jy jz ka b">&lt;-</code>。然后它在右边有一个表达式<code class="eh jx jy jz ka b">IO a</code>，它在左边给它赋值<code class="eh jx jy jz ka b">a</code>。最后一行的类型匹配这个函数的最终返回值。现在重要的是认识到我们可以将这种结构推广到任何单子:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5b2f" class="lm kc hu ka b fv ln lo l lp lq">monadicFunction :: m c<br/>monadicFunction = do<br/>  (_ :: a) &lt;- (_ :: m a)<br/>  (_ :: b) &lt;- (_ :: m b)<br/>  (_ :: m c)</span></pre><p id="42fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如，如果我们在<code class="eh jx jy jz ka b">Maybe</code>单子中有一个函数，我们可以使用它并为上面的<code class="eh jx jy jz ka b">m</code>插入它:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="b255" class="lm kc hu ka b fv ln lo l lp lq">myMaybeFunction :: a -&gt; Maybe a</span><span id="0dd2" class="lm kc hu ka b fv lr lo l lp lq">monadicMaybe :: a -&gt; Maybe a<br/>monadicMaybe x = do<br/>  (y :: a) &lt;- myMaybeFunction x<br/>  (z :: a) &lt;- myMaybeFunction y<br/>  (Just z :: Maybe a)</span></pre><p id="78c7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">需要记住的重要一点是，单子捕获的是计算上下文。对于<code class="eh jx jy jz ka b">IO</code>，这种情况是计算可能与终端或网络交互。对于<code class="eh jx jy jz ka b">Maybe</code>，上下文是计算可能失败。</p><h1 id="36d6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">单子单子单子</h1><p id="0c63" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">现在要绘制单子，我们需要知道它的计算环境。我们可以将任何返回列表的函数视为<strong class="ja hv">不确定的</strong>。它可以有许多不同的值。因此，如果我们将这些计算串联起来，我们的最终结果是每一种可能的组合。也就是说，我们的第一个计算可以返回一个值列表。然后我们想检查我们从这些不同的结果中得到什么，作为下一个函数的输入。然后我们会得到所有的结果。诸如此类。</p><p id="ac39" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了看到这一点，让我们想象我们有一个游戏。我们可以用一个特定的数字<code class="eh jx jy jz ka b">x</code>开始游戏。在每一轮，我们可以减一，加一，或者保持数字不变。我们想知道5轮后所有可能的结果，以及可能性的分布。所以我们从写非确定性函数开始。它接受一个输入并返回可能的游戏输出:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="6ee7" class="lm kc hu ka b fv ln lo l lp lq">runTurn :: Int -&gt; [Int]<br/>runTurn x = [x - 1, x, x + 1]</span></pre><p id="8413" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面是我们如何在这个5回合游戏中应用。我们将添加类型签名，以便您可以看到一元结构:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="338b" class="lm kc hu ka b fv ln lo l lp lq">runGame :: Int -&gt; [Int]<br/>runGame x = do<br/>  (m1 :: Int) &lt;- (runTurn x :: [Int])<br/>  (m2 :: Int) &lt;- (runTurn m1 :: [Int])<br/>  (m3 :: Int) &lt;- (runTurn m2 :: [Int])<br/>  (m4 :: Int) &lt;- (runTurn m3 :: [Int])<br/>  (m5 :: Int) &lt;- (runTurn m4 :: [Int])<br/>  return m5</span></pre><p id="397b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在右边，每个表达式都有类型<code class="eh jx jy jz ka b">[Int]</code>。然后在左边，我们把我们的<code class="eh jx jy jz ka b">Int</code>拿出来。所以每一个<code class="eh jx jy jz ka b">m</code>表情代表<strong class="ja hv">我们将从<code class="eh jx jy jz ka b">runTurn</code>那里得到的众多解决方案中的一个</strong>。然后我们运行剩下的函数，想象我们只使用其中一个。但实际上，我们将运行它们，因为list monad是如何定义其绑定操作符的。这个心理跳跃有点棘手。当我们做列表计算时，坚持使用<code class="eh jx jy jz ka b">where</code>表达式通常更直观。但是看到像这样的模式在意想不到的地方出现是很酷的。</p><h1 id="3a3b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">函数单子</h1><p id="4adc" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">函数monad是另一个我花了很长时间才理解的函数。在某些方面，它和<code class="eh jx jy jz ka b">Reader</code>单子是一样的。它封装了我们可以传递给不同函数的单个参数的上下文。但是和<code class="eh jx jy jz ka b">Reader</code>的定义不一样。当我试图寻找定义时，它对我来说没有多大意义:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="aa1c" class="lm kc hu ka b fv ln lo l lp lq">instance Monad ((-&gt;) r) where<br/>  return x = \_ -&gt; x<br/>  h &gt;&gt;= f = \w -&gt; f (h w) w</span></pre><p id="950f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh jx jy jz ka b">return</code>的定义很有道理。我们将有一个函数，它接受一些参数，忽略那个参数，并给出值作为输出。绑定操作符稍微复杂一些。当我们将两个函数绑定在一起时，我们将得到一个带参数的新函数<code class="eh jx jy jz ka b">w</code>。我们将对我们的第一个函数(<code class="eh jx jy jz ka b">(h w)</code>)应用这个论点。然后我们将得到结果，应用到<code class="eh jx jy jz ka b">f</code>，然后再次应用参数<code class="eh jx jy jz ka b">w</code>。有点难以理解。</p><p id="ef5d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是让我们在do语法的上下文中考虑这个问题。右边的每一个表达式都将是一个以我们的类型为唯一参数的函数。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="b14d" class="lm kc hu ka b fv ln lo l lp lq">myFunctionMonad :: a -&gt; (x, y, z)<br/>myFunctionMonad = do<br/>  x &lt;- :: a -&gt; b<br/>  y &lt;- :: a -&gt; c<br/>  z &lt;- :: a -&gt; d<br/>  return (x, y, z)</span></pre><p id="8294" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在让我们想象我们将传递一个<code class="eh jx jy jz ka b">Int</code>并使用几个不同的可以接受一个<code class="eh jx jy jz ka b">Int</code>的函数。这是我们将得到的:</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="5b12" class="lm kc hu ka b fv ln lo l lp lq">myFunctionMonad :: Int -&gt; (Int, Int, String)<br/>myFunctionMonad = do<br/>  x &lt;- (1 +)<br/>  y &lt;- (2 *)<br/>  z &lt;- show<br/>  return (x, y, z)</span></pre><p id="2c1f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们有了有效的do语法！那么当我们运行这个函数时会发生什么呢？我们将在同一个输入上调用不同的函数。</p><pre class="le lf lg lh fq li ka lj lk aw ll dt"><span id="46dd" class="lm kc hu ka b fv ln lo l lp lq">&gt;&gt; myFunctionMonad 3<br/>(4, 6, "3")<br/>&gt;&gt; myFunctionMonad (-1)<br/>(0, -2, "-1")</span></pre><p id="c905" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们在第一个例子中传递3时，我们在第一行加1，在第二行乘以2，在第三行<code class="eh jx jy jz ka b">show</code>它。我们做这些都没有明确地陈述论点！棘手的是，所有的函数都必须将输入参数作为它们的最后一个参数。所以你可能要做一点争论。</p><h1 id="ba17" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="9a00" class="pw-post-body-paragraph iy iz hu ja b jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv hn dt translated">在本文中，我们探讨了列表和函数，这是Haskell中最常见的两个概念。我们一般不用这些做单子。但是我们看到它们仍然符合一元结构。我们可以在do语法中使用它们，并遵循我们已经知道的模式来使事情工作。</p><p id="f6e7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">也许你以前尝试过学习Haskell，但是发现单子有点太复杂了。希望这篇文章有助于阐明单子的结构。如果你想重新开始你的Haskell之旅，下载我们的<a class="ae jw" href="https://www.mmhaskell.com/beginners-checklist" rel="noopener ugc nofollow" target="_blank">初学者清单</a>！或者从头开始学习单子，阅读我们关于<a class="ae jw" href="https://www.mmhaskell.com/monads" rel="noopener ugc nofollow" target="_blank">函数数据结构</a>的系列文章！</p></div></div>    
</body>
</html>