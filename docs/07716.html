<html>
<head>
<title>Microjob: a tiny multithreading library for Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">micro job:node . js的小型多线程库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/microjob-a-tiny-multithreading-library-for-node-js-92d0500b07d5?source=collection_archive---------2-----------------------#2018-09-11">https://medium.com/hackernoon/microjob-a-tiny-multithreading-library-for-node-js-92d0500b07d5?source=collection_archive---------2-----------------------#2018-09-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="033a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对CPU负载不再有限制</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/d674a3fce25b207c680725a77d875993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuJ6ClNVAzlVo-e3OzP43Q.jpeg"/></div></div></figure><h1 id="f48e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">TL；DR；</h1><p id="89dd" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">Node.js 10.5引入了<a class="ae le" href="https://nodejs.org/en/blog/release/v10.5.0/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> worker threads </strong> </a>和<a class="ae le" href="https://github.com/wilk/microjob" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> microjob </strong> </a>是围绕它们的一个微小包装器。<br/> <strong class="it hv"> microjob </strong>帮助您轻松生成新线程，就像调用匿名函数一样，与promises和async/await机制接口。</p><h2 id="4686" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">Node.js简史</h2><p id="92d5" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">Node.js以其<a class="ae le" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">事件循环</strong> </a>而闻名，这是一种高性能处理I/O绑定操作的强大机制。<br/>异步接口的早期实现是通过回调实现的，然后它们演变成承诺，最后演变成众所周知的async/await模式。<br/>今天，<strong class="it hv">使用Node.js进行I/O加载是很常见的</strong>，像HTTP请求、DB查询、文件系统调用、定时器、tickers等等，当然Node.js对于这些操作来说确实很强大。然而，<strong class="it hv"> Node.js一直苦于缺乏一个好的系统来承受繁重的CPU负载</strong>。</p><h2 id="66fd" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">CPU限制的操作</h2><p id="2d18" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">但是那些“<em class="lt">CPU负载重</em>”是什么呢？这里有一个来自Quora回答的很好的解释:</p><ol class=""><li id="d15f" class="lu lv hu it b iu iv iy iz jc lw jg lx jk ly jo lz ma mb mc dt translated">搜索算法</li><li id="2830" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">视频/音频/内容转换/压缩算法</li><li id="c8ef" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">视频流</li><li id="6042" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">图形处理/渲染，例如游戏、视频</li><li id="22ec" class="lu lv hu it b iu md iy me jc mf jg mg jk mh jo lz ma mb mc dt translated">繁重的数学计算，如矩阵乘法、计算阶乘、寻找质数等。</li></ol><p id="2b3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这些操作，Node.js因为其性质一直吃亏:<strong class="it hv">非阻塞单线程事件循环</strong>。等等，什么？Node.js的主要特性是事件循环，这是一种在底层产生和处理线程的机制。然而，这仅适用于异步操作，但是同步操作是在单个线程上执行的，一次只有一个线程在执行。<br/>这意味着如果一个长时间运行的任务被执行，主线程将一直被阻塞，直到执行结束，阻塞整个系统。<br/>为了避免这种不便，Node.js支持<a class="ae le" href="https://nodejs.org/api/cluster.html" rel="noopener ugc nofollow" target="_blank">多重处理</a>，但是<strong class="it hv">进程间的上下文切换代价很高</strong>。</p><h2 id="26f3" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">工作线程</h2><p id="bba4" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">随着10.5版本的发布，Node.js提供了<a class="ae le" href="https://nodejs.org/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank">工作线程</a>，多线程技术无与伦比！<br/>你可以生成一个新线程，让它处理那些繁重的CPU负载。<br/>那么，它是如何工作的呢？<br/>工作线程自带<strong class="it hv">事件接口</strong>，可以通过<strong class="it hv">消息传递</strong>与主线程通信。<br/>文档中的<a class="ae le" href="https://nodejs.org/api/worker_threads.html#worker_threads_example" rel="noopener ugc nofollow" target="_blank">示例是不言自明的。<br/>处理事件和消息传递非常适合长时间工作，在这种情况下，您需要在后台运行一个线程，但是如果我只想在一个单独的线程中运行一个<strong class="it hv">单次函数</strong>呢？</a></p><h2 id="f55b" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">输入微作业</h2><p id="0d86" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">在语言中，比如GoLang，你可以毫不费力地用<strong class="it hv">轻量级例程</strong>来实现:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="23d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那个<em class="lt"> fmt。Println </em>在一个不同的线程中执行，其中定义了一个匿名函数并以内联方式调用。<br/>如果可以用Node.js的worker threads同样的方法制作呢？<br/>这就是为什么我创造了<a class="ae le" href="https://github.com/wilk/microjob" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">微操</strong> </a>:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="2b09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个微小的包装器，允许你使用<a class="ae le" href="https://hackernoon.com/tagged/async" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">async</strong></a><strong class="it hv">/await接口</strong>，跳过实例化一个新线程的枯燥部分，并通过事件与之同步。</p><h2 id="a0de" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">引擎盖下是什么？</h2><p id="2cd6" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">microjob启动一个新线程，向它发送带有所需数据的给定函数，并在指定的上下文中执行(评估)它。<br/>这意味着你可以像在GoLang中一样施展这个魔法:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="2ae7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而且你实际上可以<strong class="it hv">传递自定义数据</strong>:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="58cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在worker内部调用异步函数怎么样？<br/> microjob附带了<strong class="it hv"/><a class="ae le" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Javascript</strong></a>的全部功能，允许您在线程内部使用async/await模式:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mi mj l"/></div></figure><h2 id="a0e1" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">微作业的未来</h2><p id="939d" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated"><strong class="it hv">由于用户的请求和Node.js生态系统的不断变化，microjob正在迅速发展</strong>。<br/>它在社区中获得了良好的反馈，在第一周就在Github上获得了类似<a class="ae le" href="https://github.com/wilk/microjob/stargazers" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> 800+ stars </strong> </a>的成绩，扩大了Github趋势页面。<br/>很快，microjob将拥有自己的<a class="ae le" href="https://github.com/wilk/microjob/issues/3" rel="noopener ugc nofollow" target="_blank">线程池系统</a>，然后它将被<a class="ae le" href="https://github.com/wilk/microjob/issues/4" rel="noopener ugc nofollow" target="_blank">用Typescript </a>重写，并且它将<a class="ae le" href="https://github.com/wilk/microjob/issues/5" rel="noopener ugc nofollow" target="_blank">支持CI/CD </a>进行单元测试。</p><p id="b8b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我很高兴JS的人对Node.js中的多线程这么感兴趣！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mk mj l"/></div></figure></div></div>    
</body>
</html>