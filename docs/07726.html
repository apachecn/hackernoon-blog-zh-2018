<html>
<head>
<title>How to Create Custom Layout Widgets in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Flutter中创建自定义布局小部件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-create-custom-layout-widgets-in-flutter-d9419312a9bd?source=collection_archive---------12-----------------------#2018-09-11">https://medium.com/hackernoon/how-to-create-custom-layout-widgets-in-flutter-d9419312a9bd?source=collection_archive---------12-----------------------#2018-09-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e4256b31083f1cbf8733194c9b5a3886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WC8Nbne_knPtL7HU.jpg"/></div></div></figure><p id="398a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇博客假设你对Flutter有初步的了解。否则，开始学习<a class="ae ka" href="https://flutter.io/docs/" rel="noopener ugc nofollow" target="_blank">基础知识</a>，然后马上回来！</p><p id="7c04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们如何在Flutter中布局小部件？通常我们使用堆栈、行或列。但是如果我们的要求不止这些呢？如果我们想要水平排列一些部件，我们使用一个行部件。如果我们想要垂直排列它们，我们可以将它们包装在一列中，并使用Stack将元素排列在另一个之上。但是我们不能期望我们的UI就这么简单。例如，我需要一个圆形的小部件，上面有五个等间距的按钮(请看下图！).</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/9c4307ae607eeda5c14d637bb1679559.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*eG8iU0l0OXCQUHgu.png"/></div></figure><p id="48fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">放心吧！我们可以用一个只接受两个参数的CustomMultiChildLayout小部件来实现。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="22e2" class="kl km hu kh b fv kn ko l kp kq">CustomMultiChildLayout(<br/>  delegate: _CircularLayoutDelegate(<br/>    itemCount: 5,<br/>    Radius: 150.0,<br/>  ),<br/>  children: products,<br/>)</span></pre><ol class=""><li id="93c9" class="kr ks hu je b jf jg jj jk jn kt jr ku jv kv jz kw kx ky kz dt translated">delegate属于MultiChildLayoutDelegate类型，负责定位子项。</li><li id="90fb" class="kr ks hu je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz dt translated">children —这是要定位的小部件的数组。children参数类似于row和columns中使用的参数，但一个不同之处是数组中的每一项都应该用一个布局id来标记，以标识该子元素。</li></ol><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="dbdc" class="kl km hu kh b fv kn ko l kp kq">for (int i = 0; i &lt; 5; i++) {<br/>  products.add( LayoutId(<br/>    id: ‘BUTTON$i’,<br/>    child: item,<br/>  ));<br/>}</span></pre><p id="616c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，重要的部分是代表。MultiChildLayoutDelegate是一个抽象类。所以，我们必须扩展它以供我们使用。覆盖performLayout方法，我们就可以编写代码来定位其中的项目。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="7fd9" class="kl km hu kh b fv kn ko l kp kq">class _CircularLayoutDelegate extends MultiChildLayoutDelegate {<br/>  static const String actionButton = 'BUTTON';<br/>  Offset center;<br/>  final int itemCount;<br/>  final double radius;<br/><br/>  _CircularLayoutDelegate({<br/>    @required this.itemCount,<br/>    @required this.radius,<br/>  });<br/><br/>  @override<br/>  void performLayout(Size size) {<br/>    center = Offset(size.width / 2, size.height / 2);<br/>    for (int i = 0; i &lt; itemCount; i++) {<br/>      final String actionButtonId = '$actionButton$i';<br/><br/>      if (hasChild(actionButtonId)) {<br/>        final Size buttonSize =<br/>            layoutChild(actionButtonId, BoxConstraints.loose(size));<br/>        final double itemAngle = _calculateItemAngle(i);<br/><br/>        positionChild(<br/>          actionButtonId,<br/>          Offset(<br/>            (center.dx - buttonSize.width / 2) + (radius) * Math.cos(itemAngle),<br/>            (center.dy - buttonSize.height / 2) +<br/>                (radius) * Math.sin(itemAngle),<br/>          ),<br/>        );<br/>      }}}<br/><br/>  @override<br/>  bool shouldRelayout(_CircularLayoutDelegate oldDelegate) =&gt;<br/>      itemCount != oldDelegate.itemCount ||<br/>      radius != oldDelegate.radius ;<br/>}</span></pre><ol class=""><li id="6b57" class="kr ks hu je b jf jg jj jk jn kt jr ku jv kv jz kw kx ky kz dt translated">performLayout方法给出了小部件的大小，从中我们可以计算出圆心。</li><li id="2828" class="kr ks hu je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz dt translated">因为我们必须沿着圆圈布置五个小部件，所以使用for循环。</li><li id="2140" class="kr ks hu je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz dt translated">请记住，我们创建的每个项目都附有一个id。所以我们使用相同的id来检查该项目是否存在。</li><li id="ee8c" class="kr ks hu je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz dt translated">现在，使用layoutChild方法检索按钮的大小。</li><li id="e893" class="kr ks hu je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz dt translated">使用函数_calculateItemAngle计算项目和中心轴之间的角度。</li></ol><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="06f2" class="kl km hu kh b fv kn ko l kp kq">const double _radiansPerDegree = Math.pi / 180;<br/>final double _startAngle = -90.0 * _radiansPerDegree;<br/>double _itemSpacing = 360.0 / 5.0;<br/>double _calculateItemAngle(int index) {<br/> return _startAngle + index * _itemSpacing * _radiansPerDegree;<br/>}</span></pre><p id="46a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">6.最后，使用该项的id和偏移量调用positionChild方法。使用数学公式计算偏移量，</p><p id="3505" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">圆心为(x0，y0)，半径为r的圆上的角为θ的点为(x0+r cosθ，y0+r sinθ)。</p><p id="db58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">7.调用shouldRelayout方法来比较当前布局和旧布局，如果需要重新布局，则返回true。</p><p id="a7bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，这就是在Flutter中创建自定义布局有多容易。如果你想了解更多关于我们的颤振经验，请查看我们最近的<a class="ae ka" href="https://www.sayonetech.com/blog/why-we-chose-flutter-mobile-app-development/#.W0hxRtIzZPY" rel="noopener ugc nofollow" target="_blank">博客</a>。颤振一直是我们的核心专业领域。所以，敬请关注更多类似的更新和信息交流！</p><p id="c269" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在<a class="ae ka" href="https://github.com/sayonetech" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中进一步了解我们对颤振的贡献。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><p id="297f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lm">最初发布于</em><a class="ae ka" href="https://www.sayonetech.com/blog/how-create-custom-layout-widgets-flutter/" rel="noopener ugc nofollow" target="_blank"><em class="lm">https://www . sayone tech . com/blog/how-create-custom-layout-widgets-flutter/</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>