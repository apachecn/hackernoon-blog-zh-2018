<html>
<head>
<title>Python stories, August 2018</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python故事，2018年8月</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/python-stories-august-2018-5af3036ff225?source=collection_archive---------20-----------------------#2018-09-11">https://medium.com/hackernoon/python-stories-august-2018-5af3036ff225?source=collection_archive---------20-----------------------#2018-09-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/af1aa3f33e25c069b2a008bf912a012b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKnFQMq_AopA4wYaelWPsg.jpeg"/></div></div></figure><p id="eda8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在跑<a class="ae ka" href="https://t.me/pythonetc" rel="noopener ugc nofollow" target="_blank"> @pythonetc </a>，一个关于<a class="ae ka" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的电报频道一般。以下是2018年8月最好的帖子。</p><h1 id="331f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">工厂方法</h1><p id="f323" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你在你的<code class="eh le lf lg lh b">__init__</code>中创建新的对象，最好将它们作为参数传递，并拥有一个工厂方法。它将业务逻辑与如何创建对象的技术细节分离开来。</p><p id="b207" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本例中，<code class="eh le lf lg lh b">__init__</code>接受<code class="eh le lf lg lh b">host</code>和<code class="eh le lf lg lh b">port</code>来构建数据库连接:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="c3c7" class="lq kc hu lh b fv lr ls l lt lu">class Query:<br/>    def __init__(self, host, port):<br/>        self._connection = Connection(host, port)</span></pre><p id="aba1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可能的重构是:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="d2a1" class="lq kc hu lh b fv lr ls l lt lu">class Query:<br/>    def __init__(self, connection):<br/>        self._connection = connection<br/>        <br/>    @classmethod<br/>    def create(cls, host, port):<br/>        return cls(Connection(host, port))</span></pre><p id="07cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法至少有以下优点:</p><ul class=""><li id="063f" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated">它使得依赖注入变得容易。你可以在测试中做<code class="eh le lf lg lh b">Query(FakeConnection())</code>。</li><li id="79fb" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">该类可以根据需要拥有任意多的工厂方法；不仅可以通过<code class="eh le lf lg lh b">host</code>和<code class="eh le lf lg lh b">port</code>构建连接，还可以通过克隆另一个连接、读取配置文件或对象、使用默认值等来构建连接。</li><li id="ed9f" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">这样的工厂方法可以转换成异步函数；这对于<code class="eh le lf lg lh b">__init__</code>来说是完全不可能的。</li></ul><h1 id="13a7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">超级VS下一个</h1><p id="7567" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><code class="eh le lf lg lh b">super()</code>函数允许引用基类。当一个派生类想要<em class="mj">添加</em>一些东西到方法实现中，而不是完全重写它时，这是非常有用的:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="af29" class="lq kc hu lh b fv lr ls l lt lu">class BaseTestCase(TestCase):<br/>    def setUp(self):<br/>        self._db = create_db()</span><span id="c22c" class="lq kc hu lh b fv mk ls l lt lu">class UserTestCase(BaseTestCase):<br/>    def setUp(self):<br/>        super().setUp()<br/>        self._user = create_user()</span></pre><p id="3498" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该功能的名称并不意味着<em class="mj">优秀</em>或<em class="mj">非常好</em>。<em class="mj">超</em>这个词在这个语境中暗示<em class="mj">在</em>之上(就像<em class="mj">中的警司</em>)。尽管我之前说过，<code class="eh le lf lg lh b">super()</code>并不总是引用基类，它可以很容易地返回一个兄弟。正确的名称应该是<code class="eh le lf lg lh b">next()</code>,因为根据MRO的下一个类被返回。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8223" class="lq kc hu lh b fv lr ls l lt lu">class Top:<br/>    def foo(self):<br/>        return 'top'</span><span id="448d" class="lq kc hu lh b fv mk ls l lt lu">class Left(Top):<br/>    def foo(self):<br/>        return super().foo()</span><span id="974a" class="lq kc hu lh b fv mk ls l lt lu">class Right(Top):<br/>    def foo(self):<br/>        return 'right'</span><span id="6069" class="lq kc hu lh b fv mk ls l lt lu">class Bottom(Left, Right):<br/>    pass</span><span id="59f5" class="lq kc hu lh b fv mk ls l lt lu"># prints 'right'<br/>print(Bottom().foo())</span></pre><p id="c03a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意<code class="eh le lf lg lh b">super()</code>可能会产生不同的结果，因为它们依赖于原始调用的MRO。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="6138" class="lq kc hu lh b fv lr ls l lt lu">&gt;&gt;&gt; Bottom().foo()<br/>'right'<br/>&gt;&gt;&gt; Left().foo()<br/>'top'</span></pre><h1 id="52dd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">用于创建类的自定义命名空间</h1><p id="1f77" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">创建一个类包括两大步骤。首先，评估类体，就像任何函数体一样。其次，元类(默认为<code class="eh le lf lg lh b">type</code>)使用结果名称空间(由<code class="eh le lf lg lh b">locals()</code>返回的名称空间)来构造实际的类对象。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="9935" class="lq kc hu lh b fv lr ls l lt lu">class Meta(type):<br/>    def __new__(meta, name, bases, ns):<br/>        print(ns)<br/>        return super().__new__(<br/>            meta, name,<br/>            bases, ns<br/>        )</span><span id="a07e" class="lq kc hu lh b fv mk ls l lt lu">class Foo(metaclass=Meta):<br/>    B = 2</span></pre><p id="7ead" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码打印了<code class="eh le lf lg lh b">{'__module__': '__main__', '__qualname__': 'Foo', 'B': 3}</code>。</p><p id="1bd6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然，如果你做了类似于<code class="eh le lf lg lh b">B = 2; B = 3</code>的事情，那么元类只知道<code class="eh le lf lg lh b">B = 3</code>，因为只有那个值在<code class="eh le lf lg lh b">ns</code>中。这个限制是基于这样一个事实，即元类在主体评估之后工作。</p><p id="4493" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，您可以通过提供<em class="mj">自定义名称空间</em>来干预评估。默认情况下，使用一个简单的字典，但是您可以使用元类<code class="eh le lf lg lh b">__prepare__</code>方法提供一个定制的类似字典的对象。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="095e" class="lq kc hu lh b fv lr ls l lt lu">class CustomNamespace(dict):<br/>    def __setitem__(self, key, value):<br/>        print(f'{key} -&gt; {value}')<br/>        return super().__setitem__(key, value)</span><span id="5340" class="lq kc hu lh b fv mk ls l lt lu">class Meta(type):<br/>    def __new__(meta, name, bases, ns):<br/>        return super().__new__(<br/>            meta, name,<br/>            bases, ns<br/>        )</span><span id="2efb" class="lq kc hu lh b fv mk ls l lt lu">@classmethod<br/>    def __prepare__(metacls, cls, bases):<br/>        return CustomNamespace()</span><span id="c456" class="lq kc hu lh b fv mk ls l lt lu">class Foo(metaclass=Meta):<br/>    B = 2<br/>    B = 3</span></pre><p id="1b6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">输出如下所示:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="da3c" class="lq kc hu lh b fv lr ls l lt lu">__module__ -&gt; __main__<br/>__qualname__ -&gt; Foo<br/>B -&gt; 2<br/>B -&gt; 3</span></pre><p id="4679" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是<code class="eh le lf lg lh b">enum.Enum</code>如何被<a class="ae ka" href="https://docs.python.org/3/library/enum.html#duplicating-enum-members-and-values" rel="noopener ugc nofollow" target="_blank">保护免受复制</a>。</p><h1 id="ccdf" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">matplotlib</h1><p id="b409" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><code class="eh le lf lg lh b">matplotlib</code>是一个复杂灵活的Python绘图库。它受到多种产品的支持，包括Jupyter和Pycharm。</p><p id="f30c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是你如何用<code class="eh le lf lg lh b">matplotlib</code>:<a class="ae ka" href="https://repl.it/@VadimPushtaev/myplotlib" rel="noopener ugc nofollow" target="_blank">https://repl.it/@VadimPushtaev/myplotlib</a>绘制一个简单的分形图形，见文章开头的图片。</p><h1 id="e418" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">时区支持</h1><p id="b6fc" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Python提供了强大的库来处理日期和时间:<code class="eh le lf lg lh b">datetime</code>。有趣的是，<code class="eh le lf lg lh b">datetime</code>对象有支持时区的特殊接口(即<code class="eh le lf lg lh b">tzinfo</code>属性)，但是这个模块只对它的接口有有限的支持，剩下的工作留给不同的模块。</p><p id="319a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这份工作最受欢迎的模块是<code class="eh le lf lg lh b">pytz</code>。棘手的是，<code class="eh le lf lg lh b">pytz</code>并没有完全满足<code class="eh le lf lg lh b">tzinfo</code>接口。<code class="eh le lf lg lh b">pytz</code>文档在第一行中陈述了这一点:“这个库不同于所记录的用于tzinfo实现的Python API。”</p><p id="5011" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您不能使用<code class="eh le lf lg lh b">pytz</code>时区对象作为<code class="eh le lf lg lh b">tzinfo</code>属性。如果你尝试，你可能会得到绝对疯狂的结果:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="762c" class="lq kc hu lh b fv lr ls l lt lu">In : paris = pytz.timezone('Europe/Paris')<br/>In : str(datetime(2017, 1, 1, tzinfo=paris))<br/>Out: '2017-01-01 00:00:00+00:09'</span></pre><p id="3b40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看那个<code class="eh le lf lg lh b">+00:09</code>偏移。<code class="eh le lf lg lh b">pytz</code>的正确用法如下:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="e4f1" class="lq kc hu lh b fv lr ls l lt lu">In : str(paris.localize(datetime(2017, 1, 1)))<br/>Out: '2017-01-01 00:00:00+01:00'</span></pre><p id="1cfc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，在任何算术运算之后，您应该<code class="eh le lf lg lh b">normalize</code>您的datetime对象以防偏移改变(例如在DST周期的边缘)。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="d9dc" class="lq kc hu lh b fv lr ls l lt lu">In : new_time = time + timedelta(days=2)<br/>In : str(new_time)<br/>Out: '2018-03-27 00:00:00+01:00'<br/>In : str(paris.normalize(new_time))<br/>Out: '2018-03-27 01:00:00+02:00'</span></pre><p id="c104" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Python 3.6开始，建议用<code class="eh le lf lg lh b">dateutil.tz</code>代替<code class="eh le lf lg lh b">pytz</code>。它与<code class="eh le lf lg lh b">tzinfo</code>完全兼容，可以作为属性传递，不需要<code class="eh le lf lg lh b">normalize</code>，尽管工作起来有点慢。</p><p id="db55" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你对为什么<code class="eh le lf lg lh b">pytz</code>不支持<code class="eh le lf lg lh b">datetime</code> API感兴趣，或者你希望看到更多的例子，可以考虑阅读关于这个主题的体面的<a class="ae ka" href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h1 id="d21a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">停止迭代魔法</h1><p id="a3b5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">除非出现异常，否则每次调用<code class="eh le lf lg lh b">next(x)</code>都会从<code class="eh le lf lg lh b">x</code>迭代器返回新值。如果这是<code class="eh le lf lg lh b">StopIteration</code>，这意味着迭代器已经耗尽，无法提供更多的值。如果一个生成器被迭代，它会在主体结束时自动引发<code class="eh le lf lg lh b">StopIteration</code>:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="750c" class="lq kc hu lh b fv lr ls l lt lu">&gt;&gt;&gt; def one_two():<br/>...     yield 1<br/>...     yield 2<br/>...<br/>&gt;&gt;&gt; i = one_two()<br/>&gt;&gt;&gt; next(i)<br/>1<br/>&gt;&gt;&gt; next(i)<br/>2<br/>&gt;&gt;&gt; next(i)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>StopIteration</span></pre><p id="c3fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">StopIteration</code>由调用<code class="eh le lf lg lh b">next</code>的工具自动处理:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="9c63" class="lq kc hu lh b fv lr ls l lt lu">&gt;&gt;&gt; list(one_two())<br/>[1, 2]</span></pre><p id="6893" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问题是，在生成器中引发的任何意外的<code class="eh le lf lg lh b">StopIteration</code>都会导致它安静地停止，而不是实际引发一个异常:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="7d22" class="lq kc hu lh b fv lr ls l lt lu">def one_two():<br/>    yield 1<br/>    yield 2</span><span id="4f3f" class="lq kc hu lh b fv mk ls l lt lu">def one_two_repeat(n):<br/>    for _ in range(n):<br/>        i = one_two()<br/>        yield next(i)<br/>        yield next(i)<br/>        yield next(i)</span><span id="be12" class="lq kc hu lh b fv mk ls l lt lu">print(list(one_two_repeat(3)))</span></pre><p id="1352" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的最后一个<code class="eh le lf lg lh b">yield</code>是一个错误:<code class="eh le lf lg lh b">StopIteration</code>被引发，使<code class="eh le lf lg lh b">list(...)</code>停止迭代。结果是<code class="eh le lf lg lh b">[1, 2]</code>，出人意料。</p><p id="5246" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，这在Python 3.7中被改变了。此类外来<code class="eh le lf lg lh b">StopIteration</code>现替换为<code class="eh le lf lg lh b">RuntimeError</code>:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="26c5" class="lq kc hu lh b fv lr ls l lt lu">Traceback (most recent call last):<br/>  File "test.py", line 10, in one_two_repeat<br/>    yield next(i)<br/>StopIteration</span><span id="f08c" class="lq kc hu lh b fv mk ls l lt lu">The above exception was the direct cause of the following exception:</span><span id="8e4b" class="lq kc hu lh b fv mk ls l lt lu">Traceback (most recent call last):<br/>  File "test.py", line 12, in &lt;module&gt;<br/>    print(list(one_two_repeat(3)))<br/>RuntimeError: generator raised StopIteration</span></pre><p id="30f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从Python 3.5开始，您可以通过<code class="eh le lf lg lh b">from __future__ import generator_stop</code>启用相同的行为。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>