<html>
<head>
<title>Building a Daytime Server from Scratch with SwiftNIO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftNIO从头构建日间服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-daytime-server-from-scratch-with-swiftnio-965fc4f013ea?source=collection_archive---------9-----------------------#2018-09-12">https://medium.com/hackernoon/building-a-daytime-server-from-scratch-with-swiftnio-965fc4f013ea?source=collection_archive---------9-----------------------#2018-09-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f0a805f2e038f0b9c798271857fd7ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVgSA8lppCUu7idWMgMMyw.png"/></div></div></figure><p id="8b0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自从Swift 1.2发布以来，我已经在业余时间玩了几年Swift和iOS/macOS开发。虽然我仍然认为自己是一个非常敏捷的新手(不要感谢苹果对这种语言的全面改革)，但我发现这是一种非常令人愉快和强大的语言。这些年来，我甚至发布了一些iOS和macOS应用程序，并取得了不同程度的成功。</p><p id="14da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我的大部分专业精力都花在了后端开发上，我在很大程度上把学习Swift的兴趣和时间限制在了我越来越有限的“业余爱好时间”上。既然如此，当通常闭门造车的苹果公司在2015年宣布他们通过A <a class="ae ka" href="https://www.theverge.com/2015/12/3/9842854/apple-swift-open-source-released" rel="noopener ugc nofollow" target="_blank"> pache License 2.0将Swift释放到开源世界时，我可以理解地感到兴奋。在这个声明之后，我</a><a class="ae ka" href="https://www.ibm.com/cloud/swift/swift" rel="noopener ugc nofollow" target="_blank"> BM </a>成为了第一批通过开发一个开源HTTP服务器和一个名为K <a class="ae ka" href="https://github.com/IBM-Swift/Kitura" rel="noopener ugc nofollow" target="_blank"> itura的web服务器来投资这门语言的主要参与者之一。</a></p><p id="1a0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自那以后，各种其他服务器<a class="ae ka" href="https://hackernoon.com/tagged/frameworks" rel="noopener ugc nofollow" target="_blank">框架</a>如雨后春笋般涌现，如<a class="ae ka" href="https://vapor.codes" rel="noopener ugc nofollow" target="_blank"> Vapor </a>和<a class="ae ka" href="https://perfect.org" rel="noopener ugc nofollow" target="_blank"> Perfect </a>，这两个框架似乎都在构建完善、功能丰富、文档完善的工具，用于构建围绕Swift构建的堆栈。我已经阅读了许多关于这些框架的评论和教程，但是我还没有机会深入研究每一个。我打算将来去。</p><p id="7adc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今年三月，<a class="ae ka" href="https://m.imore.com/apple-announces-swiftnio-open-source-framework-network-applications" rel="noopener ugc nofollow" target="_blank">苹果在东京的一次开发会议上宣布了一个异步事件驱动的网络框架</a>。被称为<a class="ae ka" href="https://hackernoon.com/tagged/swiftnio" rel="noopener ugc nofollow" target="_blank"> SwiftNIO </a>的苹果希望该框架将允许创建基于高性能TCP/IP的服务器和用Swift编写的客户端。现在，服务器端Swift生态系统似乎有点成熟，在将堆栈提升到一些高级web框架之前，深入探索Swift中的低级协议似乎是一个好主意。</p><h2 id="90d0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">什么是白天？🗓🕐</h2><p id="49af" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">当我决定从一个较低的层次开始使用Swift时，我真的不知道我可以构建什么来做一个好的介绍。我遇到过一些类似的教程，但我不想明目张胆地敲竹杠，所以我决定采用可靠的决策方法，我问了谷歌。</p><p id="d345" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我就是这样发现了<a class="ae ka" href="https://tools.ietf.org/html/rfc867" rel="noopener ugc nofollow" target="_blank"> Daytime </a>，一个比我还早的超级简单的tcp协议(Daytime已经超过35岁了)，从此被渲染成完全无用。</p><p id="68a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本上，早在NTP出现之前，就有了Daytime，这是一种tcp协议，它只是返回一个字符串，表示客户端在终止所述连接之前建立连接的时间。Daytime甚至没有严格定义返回给客户机的日期格式🤐。</p><h2 id="1a91" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">入门指南</h2><p id="f34d" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">我将假设你在macOS上开发，但是如果你在Linux上，你可以按照<a class="ae ka" href="https://swift.org/download/" rel="noopener ugc nofollow" target="_blank">这些</a>指令来设置Swift。至于macOS…</p><ol class=""><li id="7883" class="lb lc hu je b jf jg jj jk jn ld jr le jv lf jz lg lh li lj dt translated">确保<a class="ae ka" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>是最新的。你可以在App Store里这样做。</li></ol><p id="becb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.安装brew(如果您还没有安装)</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="9f50" class="kb kc hu lp b fv lt lu l lv lw">$ /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></pre><p id="811e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3.检查您安装的Swift版本。你至少需要4.1.1</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="8e94" class="kb kc hu lp b fv lt lu l lv lw">$ swift --version</span></pre><p id="23aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">4.安装SwiftNIO</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="23cd" class="kb kc hu lp b fv lt lu l lv lw">$ brew install swiftxcode/swiftxcode/swift-xcode-nio</span></pre><p id="c5f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">5.更新您的Xcode模板以包含新的服务器模板</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="147b" class="kb kc hu lp b fv lt lu l lv lw">$ swift xcode link-templates</span></pre><h2 id="2bf2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">设置项目</h2><p id="cec3" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">打开Xcode并创建一个新项目。在模板选择对话框中，打开macOS选项卡，在最底部应该有一个名为服务器的部分，其中有一个名为Swift NIO的选项。接下来给你的项目命名，取消选择所有选项，然后点击“下一步”。</p><div class="lk ll lm ln fq ab cb"><figure class="lx iv ly lz ma mb mc paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/b836be4e0649736f95e36822bf650e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*Bnzz43WidRP0vko6PKqN9Q.png"/></div></figure><figure class="lx iv md lz ma mb mc paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/eda5f8e4d042ea7faab3d9b726f85789.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*1VnH6MXhExnzObs83LN8Cw.png"/></div></figure></div><h2 id="ac2e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">代码🆗</h2><p id="23f6" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">通过使用Apple的模板来创建项目，您应该获得一些内置代码，包括Package.swift和main.swift文件，以及让Xcode配置产品和部署目标。虽然这不是您从实际部署中启动脚本的方式，但对于我们的测试目的来说，这使事情变得简单了。我们可能需要稍微调整一下，以便让我们的代码既可以从Xcode运行，也可以从终端运行。</p><p id="cfdd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Package.swift </strong></p><p id="5115" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用Xcode模板，这个文件将已经包含在您的项目中，看起来可能类似于我下面的例子。因为我们的日间服务器没有太多的依赖，所以我们真正需要的是TIO。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="7d94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> main.swift </strong></p><p id="3360" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顾名思义，main.swift是我们服务器真正的核心所在。这里我们定义了我们的<strong class="je hv"> <em class="mg"> Server </em> </strong>类，它包含了运行我们的TCP/IP服务器所需的所有样板代码。</p><p id="1008" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以在第14行的<strong class="je hv"><em class="mg">Configuration</em></strong>struct中看到，我们正在赋值，比如监听主机(localhost)和端口(在我们的例子中是1313)。</p><p id="314a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再往下一点，在第25行，我们在<strong class="je hv"> <em class="mg"> init </em> </strong>函数中初始化我们的服务器。我们将传入在<strong class="je hv"> <em class="mg">配置</em> </strong>结构中设置的配置值，并设置eventLoopGroup，它充当服务器上处理请求的线程池。在本例中，我将该值设置为系统上的核心数，这将使服务器获得最大数量的系统线程。</p><p id="0346" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下函数如<strong class="je hv"> <em class="mg"> listen </em> </strong>和<strong class="je hv"><em class="mg">listenAndWait</em></strong>主要是样板代码，只是定义服务器应该如何监听连接。</p><p id="7ebf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码中需要注意的最后一点是在<strong class="je hv"><em class="mg">make bootstrap</em></strong>函数中，在这里我们完成了服务器设置，特别是在第84行，我们将DaytimeHandler设置为接受的通道的处理程序。</p><p id="27f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，在第98–99行，我们创建了我们的服务器并开始监听服务器。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="5f8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DaytimeHandler.swift </p><p id="acf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DaytimeHandler定义了负责处理传入通道的处理程序，它通过实现<strong class="je hv"><em class="mg">ChannelInboundHandler</em></strong>协议来实现这一点。</p><p id="f0e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们正在实现一个已经存在的协议，所以我们将在这里覆盖该协议的默认方法。</p><blockquote class="mh mi mj"><p id="8c02" class="jc jd mg je b jf jg jh ji jj jk jl jm mk jo jp jq ml js jt ju mm jw jx jy jz hn dt translated">注意:日间协议会丢弃任何客户端输入，并在用当前时间/日期做出响应后终止连接。</p></blockquote><p id="e1d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在第16行和第19行，我们将定义入站和出站数据类型。因此，如果提供了任何输入，我们期待一个ByteBuffer，并且我们也返回一个ByteBuffer。</p><p id="0508" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来我们来看看第22行的<strong class="je hv"> <em class="mg">通道活动</em> </strong>函数。该函数处理新的活动连接和任何提供的输入。首先，我们将连接细节记录到stdout，然后创建一个新的缓冲区，然后在将缓冲区写入通道之前将时间/日期字符串添加到缓冲区，并刷新通道，最后关闭通道。</p><p id="640e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="mg">信道化</em> </strong>和<strong class="je hv"> <em class="mg">错误捕获</em> </strong>基本上只是在连接关闭或发生错误时处理额外的日志记录。</p><p id="60db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们在第43行有我们的<strong class="je hv"> <em class="mg"> getTimestamp </em> </strong>。该方法使用Swift的内置日期和日期格式化程序来获取GMT中的当前服务器时间，并返回时间/日期的字符串表示。我还发现<a class="ae ka" href="http://nsdateformatter.com/" rel="noopener ugc nofollow" target="_blank"> NSDateFormatter </a>是解决Swift中日期格式的极好资源。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><h2 id="a0f8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">运行服务器</h2><p id="4403" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated"><strong class="je hv">从Xcode运行</strong></p><p id="c004" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的最后一步是运行代码。最简单的方法就是在Xcode中点击run按钮。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/8635f84f55adf3cfc8ebb7dee99caf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dpK7KfAMhyjEif2ids2V7A.gif"/></div></div></figure><p id="a2b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">从终端运行</strong></p><p id="76d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它也可以直接从命令行运行。您可以通过在包含Package.swift文件的目录中运行以下命令来实现这一点</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="4cf8" class="kb kc hu lp b fv lt lu l lv lw">$ swift package resolve<br/>$ swift run</span></pre><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/7b95d281339a0314b4d9da4509db01b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jSO2duVrXIXERzd4FZcq6g.gif"/></div></div></figure><p id="a75c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">测试</strong></p><p id="0658" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认情况下，macOS上的较新版本包含netcat (nc)。您可以通过在端口1313(或您在main.swift中指定的任何端口)上连接到您的本地主机来测试日间服务器。</p><pre class="lk ll lm ln fq lo lp lq lr aw ls dt"><span id="f326" class="kb kc hu lp b fv lt lu l lv lw">$ nc 0.0.0.0 &lt;port&gt;</span></pre><h2 id="69c7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">摘要</h2><p id="2aef" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">现在你已经用一种时髦的、前沿的语言实现了一个30年前的tcp协议。在未来，我希望更深入地了解服务器端Swift，以及它如何与其他部署技术(如集装箱化和CI/CD管道)一起使用。</p><p id="253e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在这里找到我的完整代码<a class="ae ka" href="https://github.com/beatsbears/Daytime" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="mp mf l"/></div></figure></div></div>    
</body>
</html>