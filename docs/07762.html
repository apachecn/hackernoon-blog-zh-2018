<html>
<head>
<title>MediatR behaviors to validate API Resource existence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">验证API资源存在的中介行为</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mediatr-behaviors-to-validate-api-resource-existence-f81182e8a36c?source=collection_archive---------12-----------------------#2018-09-12">https://medium.com/hackernoon/mediatr-behaviors-to-validate-api-resource-existence-f81182e8a36c?source=collection_archive---------12-----------------------#2018-09-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/09ebd9e01b38fad249d3184796d6f094.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*UGlyWoUBAwLEzJFPlz8fmQ.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">MediatR logo borrowed from <a class="ae jc" href="https://bit.ly/2N4Jz6S" rel="noopener ugc nofollow" target="_blank">https://bit.ly/2N4Jz6S</a></figcaption></figure><p id="8747" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">在构建健壮的API时，验证和描述性的错误消息和状态代码非常重要。</p><p id="9fba" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">在这篇文章中，我将向您展示如何通过添加MediatR行为来处理资源存在的验证，从而消除请求处理程序中的重复代码。</p><p id="dee0" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><a class="ae jc" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">mediator</a>是。NET支持请求/响应、命令、查询、事件等。如果你没看过，就去看看吧。</p><p id="0fc7" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">在MediatR中，有一种叫做行为的东西，它允许你为请求建立自己的管道。我将它们用于横切关注点，比如日志记录和请求参数的验证。</p><p id="801b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">最近，当一些端点被开发用于微服务时，我在我的请求处理程序中与重复代码作斗争，这是必须的。</p><p id="f2b0" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">为了给你一个例子，让我们从几个API端点开始，以及用重复代码实现请求处理程序。</p><p id="a6a4" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">本例中的端点是:</p><p id="eacf" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><code class="eh kb kc kd ke b">PUT /groups/{id}</code></p><p id="450f" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><code class="eh kb kc kd ke b">POST /groups/{id}/users</code></p><p id="fb39" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">控制器:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="fff8" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">两个端点都需要验证id参数实际上匹配给定的组，以便能够更新组/向组添加用户(在我的示例中，我使用EF Core作为持久性，但是您可以安全地忽略它)。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="87e9" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">正如您所看到的，在两个处理程序中都有一个针对组存在的if-check。</p><p id="5bc9" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我们应该如何摆脱这种重复？在这里使用某种“验证”作为预备步骤，这样请求处理程序看起来就像这样，不是很好吗？</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="60fd" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">为此感谢行为！让我们介绍一个请求:<code class="eh kb kc kd ke b">UpdateGroupRequest</code>和<code class="eh kb kc kd ke b">AddUserToGroupRequest</code>都实现的接口。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="7632" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">然后创建一个对上面定义的接口有通用约束的行为实现类，这样行为只适用于实现<code class="eh kb kc kd ke b">IGroupRequest</code>接口的请求。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="a079" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">以及使用Autofac的注册示例:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="4ead" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">现在，我们可以在没有if语句的情况下重写我们的请求处理程序，但仍然可以获得验证的好处！</p><p id="c788" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">假设我们现在添加了几个端点:</p><p id="f670" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><code class="eh kb kc kd ke b">GET /groups/{id}</code></p><p id="8fcc" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><code class="eh kb kc kd ke b">POST /groups/{id}/permissions</code></p><p id="e3c0" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">将<code class="eh kb kc kd ke b">IGroupRequest</code>接口添加到您的请求中，您将获得开箱即用的特性。相当简单！我发现这种方法非常有用。你怎么想呢?</p><p id="588c" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我们必须记住，这种方法既有优点也有缺点。我发现的是:</p><h1 id="7d64" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">骗局</h1><ul class=""><li id="e8fc" class="lj lk hu jf b jg ll jk lm jo ln js lo jw lp ka lq lr ls lt dt translated">如果您有一个验证存在性的数据库，则需要多次往返。</li><li id="f338" class="lj lk hu jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt dt translated">验证作为一个单独的类，这可能会让一些开发人员感到困惑</li></ul><h1 id="3d3c" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">赞成的意见</h1><ul class=""><li id="2bdc" class="lj lk hu jf b jg ll jk lm jo ln js lo jw lp ka lq lr ls lt dt translated">实际请求处理程序中更干净的代码</li><li id="47d4" class="lj lk hu jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt dt translated">没有分散在所有需要验证实体存在的请求处理程序中的重复代码</li></ul><p id="e880" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如果你喜欢这篇文章。你知道该怎么做！👏</p></div></div>    
</body>
</html>