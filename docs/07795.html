<html>
<head>
<title>Why you should avoid using ES6 Generators to generate keys in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该避免使用ES6生成器在React中生成密钥</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-es6-generators-to-generate-keys-in-react-b781c53d54b3?source=collection_archive---------4-----------------------#2018-09-13">https://medium.com/hackernoon/using-es6-generators-to-generate-keys-in-react-b781c53d54b3?source=collection_archive---------4-----------------------#2018-09-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="fb3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几天前，我开始阅读<strong class="it hv"> ES6发电机</strong>(或发电机功能)，这是一个我想学习和理解很久的新功能。回想起来，这并不是一个很难的概念，但可能需要一些时间来适应发电机的工作方式。当我在阅读Arfat Salman 的这篇精彩的文章时(我建议在继续阅读之前阅读)，我有了一个想法/问题:</p><blockquote class="js jt ju"><p id="27c4" class="ir is jv it b iu iv iw ix iy iz ja jb jw jd je jf jx jh ji jj jy jl jm jn jo hn dt translated">我们可以使用ES6生成器为React中的元素集合生成键吗？</p></blockquote><p id="0ab5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答案是<strong class="it hv">绝对是的</strong>！但是我们应该吗？<strong class="it hv">可能不是</strong>，正如评论中指出的那样，因为这与我最初的预期完全不同！然而，如果你对阅读我所尝试的和为什么失败感兴趣，继续前进！</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="fe ff jz"><img src="../Images/8d94ac3dbfe3cef048817d790a831a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyxuq21keffc5b0d_lMkUw.jpeg"/></div></div><figcaption class="kl km fg fe ff kn ko bd b be z ek">Photo by <a class="ae jp" href="https://unsplash.com/photos/ZMraoOybTLQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae jp" href="https://unsplash.com/search/photos/iteration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c44e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们深入研究代码之前，我想先介绍一些关键概念(双关语，非故意):</p><p id="90eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">生成器:</strong>生成器是一个行为类似于迭代器的函数。它可以中途停止，然后从停止的地方继续，并保持内部状态。生成器的一个非常简单的例子是计数器，它看起来像这样:</p><pre class="ka kb kc kd fq kp kq kr ks aw kt dt"><span id="0274" class="ku kv hu kq b fv kw kx l ky kz">function * Counter() {<br/>  let n = 0;<br/>  while (true) yield n++;<br/>}</span></pre><p id="ce67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">键:</strong>键被React用来惟一地标识集合中的元素(不严格地说是<code class="eh la lb lc kq b">&lt;ul&gt;</code>和<code class="eh la lb lc kq b">&lt;ol&gt;</code>列表和<code class="eh la lb lc kq b">&lt;li&gt;</code>元素)。据我所知，它们在虚拟DOM diff的计算中起着重要的作用，这反过来会影响你的应用程序的性能。你可以在<a class="ae jp" href="https://reactjs.org/docs/lists-and-keys.html#keys" rel="noopener ugc nofollow" target="_blank">官方文档页面</a>上阅读React中按键的工作原理。</p><h2 id="dfb4" class="ku kv hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">生成密钥</h2><p id="54e6" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">基于以上内容，很明显可以使用生成器函数来动态地将键分配给集合中的元素。这个函数唯一要做的事情就是为每个元素生成一个上下文唯一的键。为了将这个例子推广到其他地方(例如，作为一个元素<code class="eh la lb lc kq b">id</code>生成器)，我将为每个集合的键加上一个惟一的标识符。以下是我对密钥生成器函数的理解:</p><pre class="ka kb kc kd fq kp kq kr ks aw kt dt"><span id="6078" class="ku kv hu kq b fv kw kx l ky kz">function * Keymaker(listName, ListComponent) {<br/>  let keyNum = 0;<br/>  while (true) {<br/>    let itemKey = `${listName}_${keyNum}`;<br/>    yield props =&gt; &lt;ListComponent key={itemKey} {...props} /&gt;;<br/>    keyNum++;<br/>  }<br/>}</span></pre><p id="36d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里发生了几件事，需要解释一下:</p><ul class=""><li id="02c9" class="mb mc hu it b iu iv iy iz jc md jg me jk mf jo mg mh mi mj dt translated">由于生成器函数在调用之间保留一个状态，所以使用<code class="eh la lb lc kq b">keyNum</code>和集合的前缀(<code class="eh la lb lc kq b">listName</code>)来为每个元素生成一个惟一的键，然后将它传递给元素，最后，在移动到下一个元素之前递增值。</li><li id="3040" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">生成器函数充当组件的包装器(<code class="eh la lb lc kq b">ListComponent</code>)，组件由集合包装器本身传递。这使得生成器可以在不同的列表和集合之间重用。</li></ul><p id="0f9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，您可能想知道如何使用<code class="eh la lb lc kq b">Keymaker</code>生成器，所以这里有一个展示其用法的代码笔:</p><figure class="ka kb kc kd fq ke"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="d49a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">组件内部唯一神奇的事情是用前缀和组件实例化了<code class="eh la lb lc kq b">KeyMaker</code>,以呈现每个项目，随后是将每个数据对象映射到一个键控元素的后续调用。</p><h2 id="60c8" class="ku kv hu bd ld le lf lg lh li lj lk ll jc lm ln lo jg lp lq lr jk ls lt lu lv dt translated">重新生成密钥</h2><p id="8d71" class="pw-post-body-paragraph ir is hu it b iu lw iw ix iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo hn dt translated">这就是全部的内容——8行代码，你可以永远忘记键控对象了……至少我是这么认为的！事实证明，每次渲染时都会再次调用生成器，为现有元素创建新的键。这正是我们不希望从中获得任何性能好处的情况。哎呦！</p><p id="01c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个例子应该是一个即插即用的解决方案，但是它最终更像是一个应该避免的模式。但是，您可以稍微修改它，以其他有趣的方式利用生成器函数(生成动态的、上下文唯一的<code class="eh la lb lc kq b">id</code>值，或者根据想到的上下文创建不同的组件类型)，特别是如果您将结果分配给不会在每次应用程序渲染时调用生成器而变异的变量！</p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="e01c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jv">感谢您阅读本文。如果你喜欢，记得给它一个或十个掌声！</em></p></div></div>    
</body>
</html>