<html>
<head>
<title>Performance Tracing for GraphQL with Apollo and it’s friends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Apollo及其朋友对GraphQL进行性能跟踪</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/performance-tracing-for-graphql-with-apollo-and-its-friends-877adf733322?source=collection_archive---------5-----------------------#2018-09-13">https://medium.com/hackernoon/performance-tracing-for-graphql-with-apollo-and-its-friends-877adf733322?source=collection_archive---------5-----------------------#2018-09-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1531" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，当您开发应用程序时，性能很重要。就感知性能而言，您拥有的最重要的资产是后端服务的响应时间。如果你使用<a class="ae jp" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的话，它最有可能是在面向用户的应用程序之前出现的系统，所以当涉及到性能时，它应该是需要关注的核心部分。</p><p id="c509" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你只使用一个GraphQL后端，并且没有其他后端系统，也没有前端在你的控制之下，请不要再往下读了。<a class="ae jp" href="https://hackernoon.com/tagged/apollo" rel="noopener ugc nofollow" target="_blank"> Apollo </a> GraphQL为这个用例提供了内置的跟踪解决方案，他们的<a class="ae jp" href="https://www.apollographql.com/docs/engine/features/performance.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">性能分析</strong> </a>。它为您提供了许多关于GraphQL的见解，但只是关于GraphQL，这就是为什么我想向您展示第二个选项，它允许您包括来自所有系统的性能数据:<a class="ae jp" href="https://github.com/DanielMSchmidt/apollo-opentracing" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Apollo-opentracing</strong></a></p><h1 id="0d43" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">入门指南</h1><p id="4821" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Apollo提供了这个伟大的扩展概念，将横切功能引入到GraphQL服务器中。作为扩展的用户，您只需要将它作为返回扩展实例的函数添加到数组中。</p><p id="a4b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的例子中，我们用两个跟踪器启动了<a class="ae jp" href="http://opentracing.io/" rel="noopener ugc nofollow" target="_blank"> Opentracing </a>扩展，一个用于GraphQL服务器内部跟踪，称为local，另一个用于应用程序在其作为服务器的角色中接收的跟踪。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="abce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当GraphQL后端与opentracing兼容的跟踪器一起部署时，例如与<a class="ae jp" href="https://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>和<a class="ae jp" href="https://github.com/DanielMSchmidt/zipkin-javascript-opentracing/" rel="noopener ugc nofollow" target="_blank">Zipkin-JavaScript-opentracing</a>一起部署，您会得到一个开箱后的良好性能图，如下所示:</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="fe ff la"><img src="../Images/c90edd64df0880730e67fecf384b92d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7CAulq4faDmeLZi7q7uWg.png"/></div></div></figure><p id="2b63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理想情况下，您还可以将您的前端添加为第一层，确切地看到哪个前端中的哪个动作花费了多长时间，并且进入了哪个系统。</p><p id="cabf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了这一点，组织中的每个人都可以很容易地对性能进行推理，新开发人员也可以通过探索软件系统来理解软件系统，同时还可以对每个服务的计时有所了解。</p><h1 id="fe36" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">听起来不错，我还需要知道什么？</h1><p id="a1a7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这里有一些小的见解，可以帮助你最大限度地利用这个扩展:</p><h2 id="cdcf" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">我可以使用哪些示踪剂？</h2><p id="ae3f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">据我所知，Javascript有两个Opentracing跟踪器:</p><ul class=""><li id="c157" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated"><a class="ae jp" href="https://github.com/jaegertracing/jaeger-client-node" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">耶格</strong> </a>和<a class="ae jp" href="https://blog.risingstack.com/distributed-tracing-opentracing-node-js/" rel="noopener ugc nofollow" target="_blank">这是<a class="me mf gr" href="https://medium.com/u/558809ba0720?source=post_page-----877adf733322--------------------------------" rel="noopener" target="_blank"> RisingStack </a>的一篇很棒的介绍文章</a></li><li id="f4fb" class="lv lw hu it b iu mg iy mh jc mi jg mj jk mk jo ma mb mc md dt translated"><a class="ae jp" href="https://github.com/openzipkin/zipkin-js" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> zipkin </strong> </a>带Opentracing适配器<a class="ae jp" href="https://github.com/DanielMSchmidt/zipkin-javascript-opentracing" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">zipkin-JavaScript-Opentracing</strong></a><strong class="it hv"/>由我(所以如果文档不清楚，请告诉我！)</li></ul><h2 id="da22" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">费用是多少？</h2><p id="0a05" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在性能跟踪中，您总是用实际性能来购买洞察力。不同的跟踪器可能有不同的性能特征，但是一般来说，它们需要发出HTTP请求来存储它们的跟踪数据，这至少会给系统带来一点压力。</p><p id="1f78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">追踪社区决定采用的方法是添加采样器的概念。采样器是决定是否应该真正跟踪跨度的函数。通过只跟踪一定比例的传入请求，您仍然可以获得足够的数据，使您可以轻松地对性能进行推理，而不会给所有客户带来压力。</p><p id="74dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开发中，我总是以100%的采样率工作，我想看看我的系统中发生了什么。</p><h2 id="8b5d" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">在这里我能学到什么？</h2><ul class=""><li id="1b34" class="lv lw hu it b iu ko iy kp jc ml jg mm jk mn jo ma mb mc md dt translated">您可以了解性能跟踪(参见后续阅读)以及它为什么会对您有所帮助</li><li id="9a8f" class="lv lw hu it b iu mg iy mh jc mi jg mj jk mk jo ma mb mc md dt translated">通过查看<a class="ae jp" href="https://github.com/DanielMSchmidt/apollo-opentracing" rel="noopener ugc nofollow" target="_blank"> apollo-opentracing </a>的非常简单的源代码，您可以了解apollo提供的所有API，这些API用于挂钩解析GraphQL查询的不同生命周期事件</li></ul><h2 id="20b2" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">进一步阅读</h2><p id="29e5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果你对性能跟踪感兴趣，这里有一些我写的介绍性博文:</p><ul class=""><li id="0dfd" class="lv lw hu it b iu iv iy iz jc lx jg ly jk lz jo ma mb mc md dt translated"><a class="ae jp" rel="noopener" href="/@dschmidt1992/performance-monitoring-for-the-frontend-an-introduction-e0ab422f131c">前端性能监控—简介</a></li><li id="fad1" class="lv lw hu it b iu mg iy mh jc mi jg mj jk mk jo ma mb mc md dt translated"><a class="ae jp" rel="noopener" href="/@dschmidt1992/performance-monitoring-for-the-frontend-using-zipkin-bf3aa4a715e5">前端性能监控—使用Zipkin </a></li></ul><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="mo kz l"/></div></figure></div></div>    
</body>
</html>