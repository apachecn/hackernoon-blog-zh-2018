<html>
<head>
<title>Functional programming by example with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin函数式编程示例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-programming-by-example-with-kotlin-27fd7e49b55f?source=collection_archive---------1-----------------------#2018-09-15">https://medium.com/hackernoon/functional-programming-by-example-with-kotlin-27fd7e49b55f?source=collection_archive---------1-----------------------#2018-09-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c927" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我通过展示从命令式编程到函数式编程的方法重构的不同步骤来浏览T2函数式编程的基本概念。这篇文章也允许看到<strong class="it hv">我们可以用<strong class="it hv"> Kotlin作为FP语言</strong>的地方。</strong></p><p id="1b0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">概念:</p><ul class=""><li id="4f5d" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">副作用</li><li id="200c" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">纯函数</li><li id="df37" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">充当一等公民</li><li id="1dec" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">高阶函数</li><li id="14b8" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">封闭参数和闭包</li><li id="1a75" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">货币化/部分应用</li><li id="6cc2" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">λ表达式</li></ul><h2 id="4ca1" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">基础方法</h2><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><h2 id="4d21" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">从命令到程序</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lf"><img src="../Images/c1c07f8e62095d83f77a1879fc1ead8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHxDa11Rxg_RPqww-gXjqw.png"/></div></div></figure><h2 id="4303" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">从程序到功能:<strong class="ak">出现一个</strong>副作用</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lm"><img src="../Images/8ab8893b15b7cdfd5096a0ddb8f0c9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d7CRAL3Y7zfpqMO-6wjwA.png"/></div></div></figure><blockquote class="ln lo lp"><p id="c346" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated"><strong class="it hv">副作用</strong>:如果一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">函数</a>或<a class="ae lu" href="https://en.wikipedia.org/wiki/Expression_(programming)" rel="noopener ugc nofollow" target="_blank">表达式</a>修改了其本地环境之外的某个<a class="ae lu" href="https://en.wikipedia.org/wiki/State_(computer_science)" rel="noopener ugc nofollow" target="_blank">状态</a>，则称其具有<strong class="it hv"> </strong>副作用。— <a class="ae lu" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="4f26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用FP，我们不希望有<strong class="it hv">副作用</strong>，因为我们希望有独立的进程来实现并行化。没有副作用的函数(对于相同的参数返回相同的值)被称为纯函数。</p><blockquote class="ln lo lp"><p id="75c5" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated"><strong class="it hv">纯函数</strong>:具有以下性质:</p><p id="4226" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">*对于相同的<a class="ae lu" href="https://en.wikipedia.org/wiki/Argument_of_a_function" rel="noopener ugc nofollow" target="_blank">参数</a>，其<a class="ae lu" href="https://en.wikipedia.org/wiki/Return_statement" rel="noopener ugc nofollow" target="_blank">返回值</a>相同(不随本地<a class="ae lu" href="https://en.wikipedia.org/wiki/Static_variable" rel="noopener ugc nofollow" target="_blank">静态变量</a>、<a class="ae lu" href="https://en.wikipedia.org/wiki/Non-local_variable" rel="noopener ugc nofollow" target="_blank">非本地变量</a>、可变<a class="ae lu" href="https://en.wikipedia.org/wiki/Value_type_and_reference_type" rel="noopener ugc nofollow" target="_blank">引用参数</a>或来自<a class="ae lu" href="https://en.wikipedia.org/wiki/Input/output" rel="noopener ugc nofollow" target="_blank"> I/O设备</a>的输入流而变化)。</p><p id="f106" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated">*它的求值没有副作用(没有局部静态变量、非局部变量、可变引用参数或I/O流的突变)。— <a class="ae lu" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h2 id="eac9" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">副作用越来越大</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lv"><img src="../Images/396c71779ccb4009ebff02e616ce040d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UBPe41BCbmjB5x75t5uWPg.png"/></div></div></figure><p id="5f34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这一步，我们开始像使用变量一样使用函数(作为参数传递给其他函数，由另一个函数返回或作为值赋给变量)。</p><p id="f429" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种用法叫做<strong class="it hv">充当一等公民</strong></p><p id="40f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以另一个函数为自变量的函数称为<strong class="it hv">高阶函数</strong>。</p><p id="4017" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lq"> add() </em>使用一个参数，<em class="lq"> results </em>，该参数不作为实参传递。这个参数叫做<strong class="it hv">封闭参数</strong>，方法<strong class="it hv">叫做封闭。</strong>该参数是封闭的，因为不可由参数修改，这与作为标准方法参数传递的开放参数相反。</p><h2 id="5463" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">消除副作用</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lw"><img src="../Images/42df9db0c0c66b391c6f163f6680965c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-Jx6Fskl55DnI0-jHCHFw.png"/></div></div></figure><p id="d9a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，通过使用<em class="lq">加</em>操作符完全消除了副作用，该操作符返回另一个包含附加电影的列表。</p><h2 id="ab85" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">第一次</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lx"><img src="../Images/8c9df4f9e9bc4790e52ba03c1e397197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5YWbLEXkalNL86cKjG1BQ.png"/></div></div></figure><blockquote class="ln lo lp"><p id="2775" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated"><strong class="it hv"> Currying </strong>:将带有多个参数的函数的求值转化为一系列函数的求值的技术，每个函数只有一个参数— <a class="ae lu" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> wikipedia </a></p></blockquote><p id="1062" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Currying </strong>启用<strong class="it hv"> lambda calculus </strong>，你可能永远不会在标准应用程序中使用它，但它也允许将函数简化为可能已经存在于你的SDK中的不太复杂的函数，然后减少你的代码。</p><p id="7d4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">部分应用</strong>是一个类似的概念，没有1个参数的要求。</p><blockquote class="ln lo lp"><p id="a8cd" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated"><strong class="it hv">部分应用</strong>:指将多个实参固定在一个函数上，产生另一个实参更小的函数的过程。— <a class="ae lu" href="https://en.wikipedia.org/wiki/Partial_application" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h2 id="d029" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">(删除电影副本)</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff ly"><img src="../Images/34e3146ca3c3b3eb744b1de2a7402449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfIzlAZnUzkSWrtvZf-MJQ.png"/></div></div></figure><h2 id="50c5" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">从匿名到Lambda表达式和最后一个currying</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lz"><img src="../Images/295ac1c2071e6c74d66bd4342e0e1454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5IgaYmB7yDz0NfviKy1MA.png"/></div></div></figure><blockquote class="ln lo lp"><p id="bdea" class="ir is lq it b iu iv iw ix iy iz ja jb lr jd je jf ls jh ji jj lt jl jm jn jo hn dt translated"><strong class="it hv"> Lambda表达式</strong>:带简化符号的匿名函数</p></blockquote><p id="df65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用lambda应该可以帮助我们编写更简洁的代码，我们在这里看到，使用Kotlin，这并不明显...例如，JavaScript允许去掉花括号和类型，以得到一个非常干净的管道。</p><p id="b697" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">int Kotlin中存在一种替代方法，使用类型化变量符号(参见文章末尾)。</p><h2 id="174f" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">通过替换为基本函数:集合来减少代码。过滤器</h2><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff ma"><img src="../Images/0adf6d4ba9f17107cdddc3c81568abca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ACilmqcVfLUK3FOa0x4lw.png"/></div></div></figure><h2 id="9e38" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">最后形状</h2><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="2762" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码现在是一个非常基本的功能的表达式，业务与其余部分明显分离(<em class="lq"> findByTitle() </em>和<em class="lq"> matches())。我们得到一个真正的函数程序。</em></p><h2 id="9f26" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">附录:使用类型化变量符号</h2><p id="0919" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">可以将类型从管道中移除到变量中。对于长管道，它仍然不友好，还会导致类型错误。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="bf9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代码在github上，通过单元测试来确保代码在步骤之间工作。</p><div class="mg mh fm fo mi mj"><a href="https://github.com/jacquesgiraudel/IntroPgmFonct" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab ej"><div class="ml ab mm cl cj mn"><h2 class="bd hv fv z el mo eo ep mp er et ht dt translated">Jacques giraudel/intropgmfoct</h2><div class="mq l"><h3 class="bd b fv z el mo eo ep mp er et ek translated">Kotlin版本的devo xx 2018 conf“Tout ce que you with toujours voulus savoir on the programming functionnelle…</h3></div><div class="mr l"><p class="bd b gc z el mo eo ep mp er et ek translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx lk mj"/></div></div></a></div><p id="b369" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lq">本文灵感来源于这个</em> <a class="ae lu" href="https://www.youtube.com/watch?v=IQ1kDpGeoCk" rel="noopener ugc nofollow" target="_blank"> <em class="lq">现场编码谈</em> </a> <em class="lq">(法语)，我把代码改编成了科特林。一个英文版(略有差异)可以在这里</em>  <em class="lq">找到</em> <a class="ae lu" href="https://www.youtube.com/watch?v=x7j6KeQgZ6k" rel="noopener ugc nofollow" target="_blank"> <em class="lq">。</em></a></p></div></div>    
</body>
</html>