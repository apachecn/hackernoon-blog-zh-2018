<html>
<head>
<title>Thinking in React Part 1: Some love for JSX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应中的思考第一部分:对JSX的爱</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/thinking-in-react-part-1-some-love-for-jsx-5e15a9f599b2?source=collection_archive---------2-----------------------#2018-09-15">https://medium.com/hackernoon/thinking-in-react-part-1-some-love-for-jsx-5e15a9f599b2?source=collection_archive---------2-----------------------#2018-09-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="360c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个框架都使解决某些问题变得容易，而其他问题则不在它的范围之内。React也不例外。当我们理解了React旨在解决的问题时，它的效果最好。这意味着弄清楚框架的边界和限制，并以这样一种方式设计我们的解决方案，它导致最小的认知失调。在这个系列中，我将解释我如何解释React框架的特性，并试图让React对每个人都很直观。这样，本系列将不会讨论React相对于其他前端框架的优缺点。</p><p id="6e4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个让开发人员(尤其是来自其他框架的开发人员)却步的是JSX。现在，JSX或<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> + XML是React定义UI元素的首选方式。将<a class="ae jp" href="https://hackernoon.com/tagged/html" rel="noopener ugc nofollow" target="_blank"> HTML </a>和JavaScript混合在一起给开发者敲响了警钟。他们虔诚地实践关注点分离，相信表示和渲染逻辑应该分开。</p><p id="428d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多经验丰富的开发者并不相信JSX。对他们来说，我认为JSX是建立在JavaScript之上的领域特定语言(DSL)。JSX不是将HTML放在JavaScript中，也不是违反关注点分离。这是一个抽象概念，使用户界面更容易被概念化为由几个独立的、共存的、协同工作的部分组成。JSX DSL的目标是将用户界面分解成可重用的小块，这些小块可以用来组合大型复杂的交互。最后，我想说的是，JSX让我们更容易谈论现代的反应式用户界面。</p><p id="a0f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们一劳永逸地解决这场争论。React中的每个语句都计算为JavaScript。类似XML的语法只是将文件转换成JavaScript函数调用。我们编写的每一点React代码都被添加到body元素内的一个空HTML标记的尾部。因此，整个React DOM树存在于一个最初为空的容器中。可以把这个过程看作是用document.createElement函数创建子节点，并用appendChild函数将它们附加到父节点的一种更优雅的方式。</p><p id="5bb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有两类JSX元素——本地HTML标签和用户创建的React组件。原生HTML标签以小写字母命名，而React组件的名称以大写字母开头。这种区分是为了方便React对原生HTML标签的内部处理。React维护一个包含所有有效HTML标签的白名单，如果JSX元素的名字是小写的，它会检查该元素是否是本地HTML标签。否则，它会将JSX视为反应组件。</p><p id="963d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React组件是React.createElement函数的语法糖。该函数接受一个强制参数，即要创建的React元素的类型HTML标记名或React组件类型。此外，它可以有两个可选参数props对象和子组件。这应该消除了开发人员心中的疑虑，即我们正在合并HTML和JavaScript。我们只是编写JavaScript代码来创建HTML节点，并将它们附加到适当的位置。</p><p id="b262" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了证明JSX是前端开发者的福分，这里有一个练习。用三种不同的方法创建一个三层深度HTML结构:</p><ol class=""><li id="a63c" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">普通JavaScript —使用createElement、createTextNode和appendChild方法</li><li id="b392" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">没有JSX的React使用重复调用React.createElement方法</li><li id="e5fe" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">与JSX反应</li></ol><p id="7548" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要开发第一个和第二个解决方案，您需要首先创建一个最终HTML的外观模型。然后，您需要将每个元素映射到适当的JavaScript函数调用。这包括在头脑中同时保持两个心智模型。我不需要告诉你大脑在两个任务之间不断切换的代价有多大。因此，从纯效率的角度来看，开始使用JSX是有意义的。</p><p id="aa85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">JSX是一个很好的视觉教具。有了JSX，我们可以准确地告诉React我们希望我们的内容是什么样子。声明性语法隐藏了无谓的复杂性。没有必要纠结于不必要的细节，这些细节会让开发人员偏离他们真正的目标。</p><p id="57af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">读完这篇文章后，我希望你会更喜欢JSX。然而，万一我的尝试失败了，我会感谢建设性的反馈。在本系列的第二篇文章中，我将讨论无状态功能组件，以及它们如何在构建复杂的用户界面中发挥重要作用。</p></div><div class="ab cl ke kf hc kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hn ho hp hq hr"><p id="5a95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kl">原载于</em><a class="ae jp" href="http://blog.adityadixit.me/thinking-in-react-part-1-jsx.html" rel="noopener ugc nofollow" target="_blank"><em class="kl">blog . adityadixit . me</em></a><em class="kl">。</em></p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="kr ks l"/></div></figure></div></div>    
</body>
</html>