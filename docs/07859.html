<html>
<head>
<title>Fun with array rotations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组旋转的乐趣</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fun-with-array-rotations-add4a335d79a?source=collection_archive---------2-----------------------#2018-09-17">https://medium.com/hackernoon/fun-with-array-rotations-add4a335d79a?source=collection_archive---------2-----------------------#2018-09-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu"><div class="bz el l di"><div class="iv iw l"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">Source: <a class="ae jb" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com/</a></figcaption></figure><p id="8eaa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数组是最通用的数据结构之一。数组是许多应用程序的基础，许多算法和数据结构都基于数组。</p><p id="cac8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，<a class="ae jb" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>算法的工作方式是因为数组数据结构为我们提供了内容的<strong class="je hv"> <em class="ka">随机存取</em> </strong>。如果我们去掉随机存取，我们就不能像以前一样执行具有相同时间复杂度的著名的二分搜索法算法。</p><p id="432a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类似地，我们有<a class="ae jb" href="https://www.geeksforgeeks.org/priority-queue-set-1-introduction/" rel="noopener ugc nofollow" target="_blank">优先级队列</a>数据结构，它也是基于完整二叉树的数组表示，堆本身是许多应用程序的根。</p><p id="72ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇特别的文章将处理与数组和字符串中的<strong class="je hv">旋转相关的<a class="ae jb" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>问题。</strong>这是一个相当有趣的问题领域，我们将基于数组中的旋转概念来研究一系列不同的问题。</p><p id="55af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在开始实际问题之前，让我们先看一些旋转的例子，并尝试回答以下关于旋转的问题:</p><ol class=""><li id="47e4" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">什么是轮换？</li><li id="5797" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">包含N个元素的数组可以旋转多少次？</li><li id="570c" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">将数组旋转一个元素的时间复杂度是多少？</li><li id="4bef" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">一些<a class="ae jb" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>魔法来实现旋转。</li></ol><h2 id="141a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">什么是轮换？</h2><p id="c163" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">下面的图表将会清楚地说明什么是真正的旋转。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lp"><img src="../Images/ecab949655cc2340e2c51e039286a730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMBbUixxasHdYGs83nKYJQ.png"/></div></div></figure><p id="5639" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本质上，我们删除数组的第一个元素，把它放在最后，把所有剩余的元素左移一步。这是一个<strong class="je hv">向左旋转的例子。</strong></p><p id="ca99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类似地，我们可以让<strong class="je hv">向右旋转。</strong></p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff ma"><img src="../Images/c33f2d0060cfde282297b452c68c83bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U19AaoiY4uRsIaS7kMVU0g.png"/></div></div></figure><h2 id="2b3e" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated"><strong class="ak">转数？</strong></h2><p id="d7ee" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">上面的图表很清楚地说明了这一点。无论我们有左旋还是右旋，对于一个N元素的数组，我们都会有N个可能的旋转数组(包括self)。</p><h2 id="d06f" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated"><strong class="ak">旋转的时间复杂度？</strong></h2><p id="7df1" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">本质上，当我们旋转数组时，我们所做的是移除第一个元素(考虑到我们正在谈论左旋转),我们将所有剩余的元素向左移动一个位置，最后我们将从第一个位置移除的元素插入到数组的最末端。</p><p id="dafb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于每次我们必须做一个旋转步骤，无论是向左旋转还是向右旋转，剩余的N-1个元素也必须被移位<strong class="je hv">以适应旋转，所以这个操作的时间复杂度是<strong class="je hv"> O(N)。</strong></strong></p><h2 id="0eab" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">巨蟒魔法！🧙‍</h2><p id="ebe1" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">我们有很多方法可以解决这个问题。我们将只展示向左旋转的方法，向右旋转也可以用类似的方法实现。所以这是留给读者的练习。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><p id="25ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是在给定数组上实现一步向左旋转的最基本方法。我们简单地将第一个元素放在最后，在此之前，我们将剩余的每个元素都向左移动一步，即从索引1开始(对于基于0的数组索引)。</p><p id="b3d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法实际上会修改底层数组。很多时候，我们只对数组的旋转版本感兴趣，或者我们对给定数组的所有旋转感兴趣，然而，<em class="ka">我们并不真的想要修改底层数组</em>。你可以说给定的数组是一个只读数据结构。</p><p id="1e89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你仔细注意，为了第n次做左旋转，你需要前一次旋转的结果。因此，举例来说，如果给我们的原始数组是<code class="eh mc md me mf b">[1,2,3,4,5]</code>,你按照上面列出的方法，在一次旋转后，它将变成<code class="eh mc md me mf b">[2,3,4,5,1]</code>,然后我们可以对它再进行一次左旋转，得到<code class="eh mc md me mf b">[3,4,5,1,2]</code>。</p><p id="70e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">按照上面的方法，很难得到N次左旋转后剩下的数组。</p><p id="5837" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看一个有趣的方法来实现这一点。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><p id="ca06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的诀窍是<strong class="je hv">模</strong>运算。如果你注意到旋转后的数组，旋转后的数组的起点实际上是原始数组中的某个索引<code class="eh mc md me mf b">i</code>。这个索引<code class="eh mc md me mf b">i</code>可以由数字<code class="eh mc md me mf b">N</code>决定，它代表我们想要对给定数组执行的旋转次数，然后返回结果。</p><p id="40b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，你可以想象，N也可以很大。它可以大于原始数组的长度。然而，在某个时间点之后，旋转后的数组开始<strong class="je hv">重复自身</strong>。因此，对于一个大小为N的数组，在N-1次旋转后，我们得到的下一个旋转后的数组就是原来的数组。</p><p id="fc39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要理解为什么这里的模运算有效，请看下图，它显示了一些旋转。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff mg"><img src="../Images/51938b9d160c1418671fa886f60d2ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpLMk1Qml-vf-Obf82C6pQ.png"/></div></div></figure><p id="58ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望这张图能给你足够的清晰，为什么我们可以简单地做模运算，我们可以直接得到N次旋转后的数组。</p><p id="69f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以用Python编写一个liner，而不是像前面的代码片段那样编写代码。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><p id="d911" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有了旋转的概念，也知道了如何处理数组，我们终于可以看看围绕旋转数组这个概念的一些有趣的问题了。</p><h1 id="e73a" class="mh kq hu bd kr mi mj mk kv ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx dt translated">旋转琴弦</h1><div class="my mz fm fo na nb"><a href="https://leetcode.com/problems/rotate-string/description/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">旋转字符串- LeetCode</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">我们得到两个字符串，A和b。A上的移位包括获取字符串A并将最左边的字符移动到…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">leetcode.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ly nb"/></div></div></a></div><p id="33db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看这个问题要求我们做什么。</p><p id="4b2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它说我们有两个字符串A和B，长度可能相等也可能不等😛(你错过这个了吗？)，如果字符串A的任意特定旋转可以给出字符串b，我们将返回true。</p><p id="3c07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下图中，我们考虑两个字符串<code class="eh mc md me mf b">A = abcde</code>和<code class="eh mc md me mf b">B = cdeab</code>，经过两次旋转后，字符串A等于字符串b。因此在这种情况下，我们返回<code class="eh mc md me mf b">True</code></p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff nq"><img src="../Images/5a900e87c3d65bef2a5356447f637c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EiMGafZknDavI5a6rbF3w.png"/></div></div></figure><p id="7384" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个肯定会返回<code class="eh mc md me mf b">False</code>的简单检查是两个字符串的长度是否不同。在这种情况下，无论我们做什么旋转，弦都不会相等。</p><p id="37cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决这个问题的一个非常天真的方法是找出所有的旋转，然后用字符串B进行字符串匹配，看两个字符串是否相等。我们将首先查看该解决方案，然后查看其复杂性分析，最后我们将查看它在<a class="ae jb" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> leetcode </a>平台上与其他解决方案相比表现如何。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><p id="0b0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">时间复杂度:</strong> O(N)因为对于每一次旋转，我们对两个长度为N的字符串进行字符串匹配，这需要O(N)，我们总共有O(N)次旋转。</p><p id="d7ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">空间复杂度:</strong> O(N)因为我们每次循环都创建一个新的链表。</p><p id="21d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在leetcode平台上，这个解决方案的表现不如预期。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff nr"><img src="../Images/35587a17f4efc333e7b8c05b1aeb8709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4wBFMsKYOqCfNN8A756DQ.png"/></div></div></figure><p id="5a50" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实证明我们可以做得比这更好。</p><blockquote class="ns"><p id="6ccd" class="nt nu hu bd nv nw nx ny nz oa ob jz ek translated">这里的想法是将字符串A附加到自身，然后检查字符串B是否是这个扩展字符串A + A的子字符串</p></blockquote><p id="c31d" class="pw-post-body-paragraph jc jd hu je b jf oc jh ji jj od jl jm jn oe jp jq jr of jt ju jv og jx jy jz hn dt translated">你可能会问，我们为什么要这样做？</p><p id="f2f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实证明，如果我们将一个给定的数组/字符串附加到它自身，那么得到的数组或字符串覆盖了原始数组的所有旋转。让我们看看下面的图表，以了解这种连接操作如何有效地产生所有可能的旋转。下图中我们要考虑的字符串是<code class="eh mc md me mf b">abcde</code>，所以在将这个字符串和它自身连接起来之后，我们得到了<code class="eh mc md me mf b">abcdeabcde</code></p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff oh"><img src="../Images/6f1b98567daaaf8b81ca31d77b448443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujBQcOnZKYLEQo2GsW-cbA.png"/></div></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">Figure showing all possible rotations for string “abcde” covered by “abcdeabcde”</figcaption></figure><p id="2b10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果字符串A或A的任何旋转确实等于字符串B，那么字符串B将是这个扩大的字符串2A的子字符串。</p><p id="1ff8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">时间复杂度:</strong> O(N)因为我们所做的只是一个大小为N的字符串和另一个大小为2N的字符串之间的字符串匹配。</p><p id="c291" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">空间复杂度:</strong> O(N)因为我们要创建一个大小为2N的新字符串来容纳这个字符串a的放大版本。</p><p id="6f84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该算法比前一个算法快得多，并且实现时间也短得多。这是Python中的一行代码🙈。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff oi"><img src="../Images/8be999b32f492c15ff48f1319582dff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kz0XpsWd5aVuRO8PeGJwXA.png"/></div></div></figure><p id="e315" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我得说这已经够快了！</p><p id="8b9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们转到另一个有趣的问题，这个问题看起来很简单，但是在我们得到完美的解决方案之前，有一系列的注意事项需要考虑。</p><h1 id="f7af" class="mh kq hu bd kr mi mj mk kv ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx dt translated">旋转排序数组中的最小值</h1><div class="my mz fm fo na nb"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">在旋转排序数组中查找最小值- LeetCode</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">假设一个按升序排序的数组在某个你事先不知道的支点上旋转。(即[0，1，2，4，5，6，7]…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">leetcode.com</p></div></div><div class="nk l"><div class="oj l nm nn no nk np ly nb"/></div></div></a></div><p id="8500" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在继续之前，我要感谢<a class="ok ol gr" href="https://medium.com/u/842b783318b8?source=post_page-----add4a335d79a--------------------------------" rel="noopener" target="_blank"> Divya Godayal </a>为本文的这一部分做出了贡献。干杯！</p><p id="7053" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以这个问题只是要求我们在数组中找到一个元素</p><ul class=""><li id="25da" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz om kh ki kj dt translated">已排序，</li><li id="86cc" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz om kh ki kj dt translated">旋转，显然</li><li id="fc74" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz om kh ki kj dt translated">不包含任何重复的元素。</li></ul><p id="6ebc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决这个问题的一个非常野蛮的方法是搜索整个数组并找到最小元素。这种方法会简单地忽略给定数组已经排序的事实，这是解决这个问题的幼稚方法。首先，让我们来看看这个问题的一个简单的基于线性搜索的解决方案。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><p id="7577" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">时间复杂度:</strong> O(N)如果给定数组中有N个元素。</p><p id="64f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">空间复杂度:</strong> O(1)</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff on"><img src="../Images/9905272eb46c896c83236c8f24078267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgqvdw3YGUZ1EkpEPgN91w.png"/></div></div></figure><p id="0b0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个其实挺有意思的。一个O(N)的解决方案为我们提供了leetcode的最佳执行时间。然而，就渐近复杂性而言，我们可以做得比这更好。</p><p id="0dd2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定数组被排序的事实本身就是一个巨大的暗示。因为数组是排序的，我们要在数组中找到一个元素，我们可以使用二分搜索法范式。</p><p id="0c7d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，阵列是旋转的。所以简单地应用二分搜索法在这里是行不通的。</p><p id="eead" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个问题中，我们将基本上应用二分搜索法的修改版本，其中决定搜索方向的<code class="eh mc md me mf b">condition</code>将不同于标准的二分搜索法。</p><p id="bc6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在标准的二分搜索法算法中，我们做以下事情</p><pre class="lq lr ls lt fq oo mf op oq aw or dt"><span id="33aa" class="kp kq hu mf b fv os ot l ou ov">1. while left &lt;= right<br/>2.     mid = (left + right) / 2<br/>3.     if element == middle element:<br/>4.         return mid <br/>5.     elif element &lt; middle element:<br/>6.         move to the left i.e. [left, mid - 1]<br/>7.     else:<br/>8.         move to the right i.e. [mid + 1, right].</span></pre><p id="60ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于给定的数组已经排序，我们可以明确地应用二分搜索法算法来搜索元素。唯一的事情是，元素被旋转了，这是我们必须考虑的事情。</p><p id="e7fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们如何检查数组是否旋转了？</p><p id="1e6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果数组没有旋转，并且数组按升序排序，则</p><pre class="lq lr ls lt fq oo mf op oq aw or dt"><span id="697b" class="kp kq hu mf b fv os ot l ou ov">last_element &gt; first_element</span></pre><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff ow"><img src="../Images/22fb421078e0c87558a2d4a97a510ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xsYIqBE6sYlqihsVXa1Sg.png"/></div></div></figure><p id="5737" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子<code class="eh mc md me mf b">7 &gt; 2</code>中。这意味着阵列没有任何旋转。在这种情况下，我们可以简单地返回数组的第一个元素，因为这是最小的元素。</p><p id="f4b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，如果阵列实际上是旋转的，那么阵列中的某个地方将会形成心跳。让我们来看看我们所说的心跳形成是什么意思。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff ox"><img src="../Images/b367d72168dca6728a34ae38d88e4652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2S9mmV3_RgHuzxBt2y32TA.png"/></div></div></figure><p id="4950" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您查看上面的数组元素，它们按照预期的升序排列(因为数组是按升序排序的)。然而，在元素7之后，有一个突然的下降，然后值又开始增加。这就是我们所说的心跳结构。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff oy"><img src="../Images/a90f377da4dbdde3f176a44c9f0e3fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7QzJRtkag0vIo_wDyDzhg.png"/></div></div></figure><p id="c5be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面给出的数组中<code class="eh mc md me mf b">3 &lt; 4</code>。因此阵列被旋转。发生这种情况是因为数组最初是<code class="eh mc md me mf b">[2, 3 ,4 ,5 ,6 ,7]</code>。但是旋转之后，较小的元素<code class="eh mc md me mf b">[2,3]</code>在后面。即【4，5，6，7，<code class="eh mc md me mf b">2, 3]</code>。因此，旋转数组中的第一个元素<code class="eh mc md me mf b">[4]</code>变得比最后一个元素大。</p><p id="0c4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从问题中可以明显看出，心跳结构意味着数组中有一个点会发生变化。这一点将有助于我们解决这个问题。我们称之为<code class="eh mc md me mf b">Inflection Point</code>。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff oz"><img src="../Images/1789efc768fb35a950bd528b4f73d613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsud-p_WPaLZM2uO1ft9gA.png"/></div></div></figure><p id="c55a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">拐点的一个重要属性对解决这个问题至关重要，那就是:</p><blockquote class="ns"><p id="d6d0" class="nt nu hu bd nv nw nx ny nz oa ob jz ek translated">*拐点左边的所有元素&gt;数组的第一个元素。<br/> *拐点右侧的所有元素&lt;数组的第一个元素。</p></blockquote><p id="cd4d" class="pw-post-body-paragraph jc jd hu je b jf oc jh ji jj od jl jm jn oe jp jq jr of jt ju jv og jx jy jz hn dt translated">在看实现之前，让我们先看看解决这个问题的算法。</p><ol class=""><li id="26a1" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">找到数组的<code class="eh mc md me mf b">mid</code>元素。</li><li id="d719" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">如果<code class="eh mc md me mf b">mid element &gt; first element of array</code>这意味着我们需要寻找<code class="eh mc md me mf b">mid</code>右边的拐点。</li><li id="85e2" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">如果<code class="eh mc md me mf b">mid element &lt; first element of array</code>这样，我们需要寻找<code class="eh mc md me mf b">mid</code>左边的拐点。</li></ol><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff pa"><img src="../Images/1fb972c64ba821c90c09b1db86de350f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQRllHEA0BpCYu3-eTUX6Q.png"/></div></div></figure><p id="ad5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们找到拐点时，当两个条件中的任何一个满足时，我们停止搜索:</p><p id="d613" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">→ <code class="eh mc md me mf b">nums[mid] &gt; nums[mid + 1]</code>因此，<code class="eh mc md me mf b">mid+1</code>最小。</p><p id="93c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">→ <code class="eh mc md me mf b">nums[mid - 1] &gt; nums[mid]</code>因此，<code class="eh mc md me mf b">mid</code>最小。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff pb"><img src="../Images/e387f1f35c1c4e002546096321613d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ob6oxgnNw0rwMcV7stlOUQ.png"/></div></div></figure><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><p id="2a2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">时间复杂度: O(logN)因为我们在这里所做的一切都依赖于我们的好朋友二分搜索法，因此利用了原始数组的排序性质。</p><p id="1d2a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">空间复杂度:</strong> O(1)</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff pc"><img src="../Images/682952001acf14dc462fa055c2f7232d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNVQknQsg8xxj1EhaI5Jxg.png"/></div></div></figure><p id="de00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">没有比这更好的了，对吧？😉</p><p id="c9d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个问题最大的问题是数组中没有重复的元素。如果数组中有重复的元素怎么办？我们还能遵循类似的方法来解决问题吗？</p><p id="3d22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个问题的答案是肯定的，也是否定的。我们上面讨论的相同概念也适用于这个问题的修改版本。但是，时间复杂度不再保证为O(logN)。看看下面的例子。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff pd"><img src="../Images/b4a41cac89f42b6882c78f14f98ddaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moyfB_ciu0OzwfxBxhDlJA.png"/></div></div></figure><p id="5102" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面提到的两种情况更容易解决，因为中间的元素不同于第一个和最后一个元素，可以帮助指引二分搜索法(尽管您会被4作为二分搜索法的中点卡住)。</p><p id="6198" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重点是，由于这里允许重复元素，因此可能会出现这样的场景:</p><pre class="lq lr ls lt fq oo mf op oq aw or dt"><span id="ca8b" class="kp kq hu mf b fv os ot l ou ov">leftmost element == middle element == rightmost element</span></pre><p id="4733" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当这种情况发生时，我们如何决定我们需要朝什么方向前进。我们没有可能知道二分搜索法算法可以忽略的方向。因此，我们必须尝试将两者都视为可能的候选，并对它们进行处理，如果数组中的所有元素都相同，即<code class="eh mc md me mf b">[4,4,4,4,4,4,4,4]</code>，那么我们最终将逐个处理每个元素。</p><p id="46e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，怀着沉重的心情😢我们不得不得出结论，在这个问题上没有办法得到一个保证O(logN)复杂度的算法。我们上面看到的二分搜索法算法的修改版本的最坏情况时间复杂度是O(N)。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="pe iw l"/></div></figure><p id="38ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们进入这篇文章的最后一个问题，这将是一个重磅炸弹。相信我！</p><h1 id="3f24" class="mh kq hu bd kr mi mj mk kv ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx dt translated">有序队列</h1><div class="my mz fm fo na nb"><a href="https://leetcode.com/problems/orderly-queue/description/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">有序队列- LeetCode</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">给定一串小写字母S。然后，我们可以走任意多步。在每一步中，我们选择一个…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">leetcode.com</p></div></div><div class="nk l"><div class="pf l nm nn no nk np ly nb"/></div></div></a></div><p id="6fc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在得到解决方案之前，让我们先看看一些可能的字符串旋转。我们将考虑的字符串是<code class="eh mc md me mf b">baaca</code>，K = 3，这意味着我们可以选择前三个字符中的任意一个作为<strong class="je hv">，然后将其从原来的位置移除，将其添加到最末尾，最后将所有字符向左移动一个位置，以在最后容纳这个新元素。</strong></p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff pg"><img src="../Images/f26463b3869c4c0d502c510f2abbedcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Inq12klLO2zUWK51atyEA.png"/></div></div></figure><p id="5987" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设字符串有以下字符:<code class="eh mc md me mf b">a[0], a[1], a[2] … a[n-1]</code>，我们想把某个位置i (i &gt; = 0 &amp; &amp; i &lt; n — 1)和位置i+1互换，或者把a[i]和a[i+1]互换。声明是，我们可以通过对字符串使用旋转，对字符串中的任意两个相邻元素实现这一点。例如:假设字符串由5个字符组成，我们想要交换<code class="eh mc md me mf b">a[2] and a[3]</code>，下面是我们如何通过数组旋转来实现这一点。</p><pre class="lq lr ls lt fq oo mf op oq aw or dt"><span id="20ab" class="kp kq hu mf b fv os ot l ou ov">a[0], a[1], <strong class="mf hv">a[2], a[3]</strong>, a[4], a[5]     ROTATE around first element</span><span id="3ec7" class="kp kq hu mf b fv ph ot l ou ov">a[1], <strong class="mf hv">a[2], a[3]</strong>, a[4], a[5], a[0]     ROTATE around first element</span><span id="38cf" class="kp kq hu mf b fv ph ot l ou ov"><strong class="mf hv">a[2], a[3]</strong>, a[4], a[5], a[0], a[1]     ROTATE around <strong class="mf hv">second </strong>element</span><span id="f047" class="kp kq hu mf b fv ph ot l ou ov"><strong class="mf hv">a[2], </strong>a[4], a[5], a[0], a[1], <strong class="mf hv">a[3]</strong>     ROTATE around <strong class="mf hv">first </strong>element</span><span id="89a4" class="kp kq hu mf b fv ph ot l ou ov">a[5], a[0], a[1], <strong class="mf hv">a[3], a[2], </strong>a[4]     ROTATE around first<strong class="mf hv"> </strong>element</span><span id="dbd9" class="kp kq hu mf b fv ph ot l ou ov">a[0], a[1], <strong class="mf hv">a[3], a[2], </strong>a[4], a[5]     ROTATE around first<strong class="mf hv"> </strong>element</span></pre><p id="6974" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以尝试使用这个想法，但本质上我们可以通过以上面显示的方式执行多次旋转来交换给定字符串中的任意两个相邻元素。</p><blockquote class="ns"><p id="474a" class="nt nu hu bd nv nw nx ny nz oa ob jz ek translated">因为我们可以交换任意两个元素，所以我们可以执行<strong class="ak">冒泡排序！</strong></p></blockquote><p id="c395" class="pw-post-body-paragraph jc jd hu je b jf oc jh ji jj od jl jm jn oe jp jq jr of jt ju jv og jx jy jz hn dt translated">冒泡排序算法本质上涉及相邻元素之间的比较，目的是<strong class="je hv"> <em class="ka">将元素向上/向下冒泡到它们在数组中各自的位置。</em>T11】</strong></p><p id="b456" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们已经实现了字符a[2]和a[3]的交换，而没有扰乱其他字符的顺序(类似地，这可以对任何一对相邻的索引进行)。</p><p id="b74a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，如果问题中的K &gt; 1，我们基本上可以通过使用旋转来执行冒泡排序算法，并且最终我们将得到的最小字典序字符串将是按升序排序的原始字符串。</p><h2 id="f677" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">K = 1时呢？</h2><p id="d50c" class="pw-post-body-paragraph jc jd hu je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hn dt translated">在这种情况下，我们在“选择”将哪个元素移动到数组后面时没有那么大的自由。在这种情况下，我们必须查看原始字符串的所有可能的旋转，并返回字典中最小的一个。</p><p id="66e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你没记错的话，大小为N的字符串的旋转数是N。因此，当K = 1时，我们必须查看数组的所有旋转数(还记得我们在文章中讨论的获取所有旋转数的<strong class="je hv"> mod </strong>方法或<strong class="je hv"> concat </strong>方法吗？)并按字典顺序获得最小的一个。</p><p id="ea59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看一下实现，尽管它非常小。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mb iw l"/></div></figure><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff pi"><img src="../Images/322dba52ae9febb5d35cb55104710021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ0ux-ic-q7EocVnVSGEag.png"/></div></div></figure><p id="cfe8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">时间复杂度:</strong> O(NlogN)因为我们正在为K &gt; 1排序字符串</p><p id="4ab4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">空间复杂度:</strong> O(N)因为如果K = 1，那么我们创建S+S也就是O(N)空间分配。</p><p id="bd62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本文到此为止。希望你在学习数组循环时过得愉快，并且我希望你能够掌握我们在这里讨论的所有概念。</p><blockquote class="ns"><p id="93a0" class="nt nu hu bd nv nw nx ny nz oa ob jz ek translated">所有冰雹编码…</p></blockquote><figure class="pj pk pl pm pn iu"><div class="bz el l di"><div class="po iw l"/></div></figure><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="pp iw l"/></div></figure></div></div>    
</body>
</html>