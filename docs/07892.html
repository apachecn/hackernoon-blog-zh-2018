<html>
<head>
<title>Simple Web Routing with Spock!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的网络路由与斯波克！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simple-web-routing-with-spock-a0a77a26d598?source=collection_archive---------35-----------------------#2018-09-17">https://medium.com/hackernoon/simple-web-routing-with-spock-a0a77a26d598?source=collection_archive---------35-----------------------#2018-09-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/3b1017c7b3df5f51f9e5579790ff4339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*CirlXRPUCCE5rRp20q0wJw.jpeg"/></div></figure><p id="9d03" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们的<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>中，我们将回顾如何用Haskell构建Web应用程序的基础知识。这包括对我们的数据库层使用Persistent，对我们的HTTP层使用Servant。但是在Haskell生态系统中，这些并不是那些任务的唯一库。</p><p id="4594" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们已经了解了如何使用Beam作为另一个潜在的数据库库。在接下来的两篇文章中，我们将研究另一个HTTP库<a class="ae jw" href="https://www.spock.li/" rel="noopener ugc nofollow" target="_blank"> Spock </a>。我们将它与Servant进行比较，看看不同的设计决策是什么。本周我们将从路由的基础知识开始。我们还将看到如何使用全局应用程序状态来协调服务器上的信息。下周，我们将看到如何连接数据库和使用会话。</p><p id="0ebc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于一些有用的库，请确保下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>。它会给你更多关于库的想法，你甚至可以超越这些！此外，您可以通过查看我们的<a class="ae jw" href="https://github.com/jhb563/SpockExample" rel="noopener ugc nofollow" target="_blank"> Github库</a>来了解这里的代码！</p><h1 id="e5f7" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">入门指南</h1><p id="a64f" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">Spock为我们提供了一个制作基本服务器的有用起点。我们将从他们主页上的<a class="ae jw" href="https://www.spock.li/" rel="noopener ugc nofollow" target="_blank">启动代码</a>开始。这是我们最初的改编:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="3962" class="lj jy hu lf b fv lk ll l lm ln">data MySession = EmptySession<br/>data MyAppState = DummyAppState (IORef Int)</span><span id="29df" class="lj jy hu lf b fv lo ll l lm ln">main :: IO ()<br/>main = do<br/>  ref &lt;- newIORef 0<br/>  spockConfig &lt;- defaultSpockCfg EmptySession PCNoDatabase (DummyAppState ref)<br/>  runSpock 8080 (spock spockConfig app)</span><span id="7b2e" class="lj jy hu lf b fv lo ll l lm ln">app :: SpockM () MySession MyAppState ()<br/>app = do<br/>  get root $ text "Hello World!"<br/>  get ("hello" &lt;//&gt; var) $ \name -&gt; do<br/>    (DummyAppState ref) &lt;- getState<br/>    visitorNumber &lt;- liftIO $ atomicModifyIORef' ref $ \i -&gt; (i+1, i+1)<br/>    text ("Hello " &lt;&gt; name &lt;&gt; ", you are visitor number " &lt;&gt; T.pack (show visitorNumber))</span></pre><p id="2c8b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们的main函数中，我们初始化了一个IO ref，我们将用它作为应用程序的唯一“状态”。然后，我们将为我们的服务器创建一个配置对象。最后，我们将使用实际路线的<code class="eh lp lq lr lf b">app</code>规范来运行我们的服务器。</p><p id="1631" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">该配置有几个重要的附加字段。目前，我们对所有这些都使用虚拟值。我们的配置需要一个<code class="eh lp lq lr lf b">Session</code>，我们将其定义为<code class="eh lp lq lr lf b">EmptySession</code>。它还需要某种数据库，我们稍后会添加。最后，它包括一个应用程序状态，现在我们只提供指向一个整数的指针。稍后我们将看到如何给这些参数添加更多的味道。但是现在，让我们更深入地研究一下定义服务器路由的<code class="eh lp lq lr lf b">app</code>表达式。</p><h1 id="3911" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">斯波克姆单子</h1><p id="3312" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">我们的路由器生活在<code class="eh lp lq lr lf b">SpockM</code>单子里。我们可以看到它有三个不同的类型参数。记住<code class="eh lp lq lr lf b">defaultSpockConfig</code>有三个相似的参数！我们将空会话称为<code class="eh lp lq lr lf b">MySession</code>，将<code class="eh lp lq lr lf b">IORef</code>应用状态称为<code class="eh lp lq lr lf b">MyAppState</code>。最后，有一个额外的<code class="eh lp lq lr lf b">()</code>参数对应于我们的空数据库。(我们路由器的返回值也是<code class="eh lp lq lr lf b">()</code>)。</p><p id="1342" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在这个单子的每个元素都是一个路径组件。如您所料，这些路径组件使用HTTP动词。目前，我们的路由器只有几条<code class="eh lp lq lr lf b">get</code>路由。第一个位于我们路径的<code class="eh lp lq lr lf b">root</code>，输出<code class="eh lp lq lr lf b">Hello World!</code>。第二个位于<code class="eh lp lq lr lf b">hello/{name}</code>。它将打印一条指定输入名称的消息，同时跟踪我们有多少访问者。</p><h1 id="e1b6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">构成路线</h1><p id="81b0" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">现在，让我们来谈谈我们的路由器代码的结构。<code class="eh lp lq lr lf b">SpockM</code>单子的工作方式类似于<code class="eh lp lq lr lf b">Writer</code>单子。我们采取的每一个动作都为应用程序增加了一条新的路径。在这种情况下，我们采取两个动作，每个动作响应<code class="eh lp lq lr lf b">get</code>请求(下周我们将看到一个<code class="eh lp lq lr lf b">post</code>请求的例子)。</p><p id="e2b5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于我们的任何HTTP动词，第一个参数将是路径的表示。在我们的第一条路线上，我们使用硬编码的<code class="eh lp lq lr lf b">root</code>表达式来引用<code class="eh lp lq lr lf b">/</code>路径。对于我们的第二个表达式，我们用<code class="eh lp lq lr lf b">&lt;//&gt;</code>组合了几个不同的组件。</p><p id="09c8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我们有一个字符串路径组件<code class="eh lp lq lr lf b">hello</code>。我们也可以组合其他字符串。假设我们想要路线<code class="eh lp lq lr lf b">/api/hello/world</code>。我们会用这样的表达:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="57d7" class="lj jy hu lf b fv lk ll l lm ln">"api" &lt;//&gt; "hello" &lt;//&gt; "world"</span></pre><p id="6abc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是在我们的原始代码中，路径的第二部分是一个<code class="eh lp lq lr lf b">var</code>。这允许我们将信息替换到路径中。当我们访问<code class="eh lp lq lr lf b">/hello/james</code>时，我们将能够得到路径组件<code class="eh lp lq lr lf b">james</code>作为一个变量。Spock将这个参数传递给我们的函数，作为<code class="eh lp lq lr lf b">get</code>组合子的第二个参数。</p><p id="4514" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个论点有一个相当复杂的类型<code class="eh lp lq lr lf b">RouteSpec</code>。这里不需要赘述细节。但是我们可以使用<code class="eh lp lq lr lf b">text</code>组合子返回的最简单的东西是一些原始文本。(如果我们有自己的模板，我们也可以使用<code class="eh lp lq lr lf b">html</code>)。我们通过这样做来结束我们的路由定义。</p><p id="a188" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，第一条路由的表达式没有参数，而第二条路由只有一个参数。正如您可能猜到的那样，第二条路径中的参数指的是由于<code class="eh lp lq lr lf b">var</code>我们可以从路径中取出的变量。路径中的<code class="eh lp lq lr lf b">var</code>元素数量与函数的参数数量相同。Spock使用依赖类型来确保这些匹配。</p><h1 id="66c7" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">使用应用程序状态</h1><p id="e73b" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">现在我们知道了基础知识，让我们开始使用Spock的一些更高级的功能。本周，我们将了解如何使用应用程序状态。</p><p id="9796" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">目前，我们每次访问有名称的路线时都会增加游客数量，即使名称是相同的。所以第一次访问<code class="eh lp lq lr lf b">/hello/michael</code>的结果是:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="2195" class="lj jy hu lf b fv lk ll l lm ln">Hello michael, you are visitor number 1</span></pre><p id="254b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后我们再去看看:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="e762" class="lj jy hu lf b fv lk ll l lm ln">Hello michael, you are visitor number 2</span></pre><p id="6c77" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">相反，让我们把每个名字分配给一个特定的号码。这样，当用户再次访问相同的路线时，他们将看到他们原来的号码。</p><p id="aca6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">做出这种改变相当容易。我们将使用从<code class="eh lp lq lr lf b">Text</code>到<code class="eh lp lq lr lf b">Int</code>的映射，而不是在<code class="eh lp lq lr lf b">Int</code>上使用<code class="eh lp lq lr lf b">IORef</code>来表示我们的状态:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="abd8" class="lj jy hu lf b fv lk ll l lm ln">data AppState = AppState (IORef (M.Map Text Int))</span></pre><p id="c9bd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们将用一个空的map初始化我们的ref，并将其传递给我们的config:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="448d" class="lj jy hu lf b fv lk ll l lm ln">main :: IO ()<br/>main = do<br/>  ref &lt;- newIORef M.empty<br/>  spockConfig &lt;- defaultSpockCfg EmptySession PCNoDatabase (AppState ref)<br/>  runSpock 8080 (spock spockConfig app)</span></pre><p id="0321" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于我们的<code class="eh lp lq lr lf b">hello/{name}</code>路线，我们将按照以下流程对其进行更新:</p><ol class=""><li id="3938" class="ls lt hu ja b jb jc jf jg jj lu jn lv jr lw jv lx ly lz ma dt translated">获取地图参考</li><li id="3876" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated">看看我们是否有这个用户的条目。</li><li id="9750" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated">如果没有，插入地图的长度，并写回我们的<code class="eh lp lq lr lf b">IORef</code></li><li id="56bf" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated">返回消息</li></ol><p id="e2db" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个过程非常简单。让我们看看它是什么样子的:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="702c" class="lj jy hu lf b fv lk ll l lm ln">app :: SpockM () MySession AppState ()<br/>app = do<br/>  get root $ text "Hello World!"<br/>  get ("hello" &lt;//&gt; var) $ \name -&gt; do<br/>    (AppState mapRef) &lt;- getState<br/>    visitorNumber &lt;- liftIO $ atomicModifyIORef' mapRef $ updateMapWithName name<br/>    text ("Hello " &lt;&gt; name &lt;&gt; ", you are visitor number " &lt;&gt; T.pack (show visitorNumber))</span><span id="3463" class="lj jy hu lf b fv lo ll l lm ln">updateMapWithName :: T.Text -&gt; M.Map T.Text Int -&gt; (M.Map T.Text Int, Int)<br/>updateMapWithName name nameMap = case M.lookup name nameMap of<br/>  Nothing -&gt; (M.insert name (mapSize + 1) nameMap, mapSize + 1)<br/>  Just i -&gt; (nameMap, i)<br/>  where<br/>    mapSize = M.size nameMap</span></pre><p id="311e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们创建了一个函数，每当我们的应用程序遇到一个新名称时，它就会更新地图。我们用<code class="eh lp lq lr lf b">atomicModifyIORef</code>更新我们的<code class="eh lp lq lr lf b">IORef</code>。现在，如果我们连续访问<code class="eh lp lq lr lf b">/hello/michael</code>两次，我们将得到相同的输出！</p><h1 id="ac6a" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="3967" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">这是我们这个星期能去的最远的地方！我们讲述了如何在Spock中创建一个基本应用程序的基础知识。我们看到了构成路线的基础。然后我们看到了如何使用应用程序状态来跟踪跨请求的信息。下周，我们将通过在应用程序中添加一个数据库来改进这个过程。我们还将使用会话来跟踪用户。</p><p id="06eb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">想要更多的酷库，请阅读我们的Haskell网络系列。此外，您可以下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>了解更多创意！</p></div></div>    
</body>
</html>