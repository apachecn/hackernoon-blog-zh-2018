<html>
<head>
<title>Swoole: Is it Node in PHP or am I wrong?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swoole:是PHP里的Node还是我错了？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/swoole-is-it-node-in-php-or-am-i-wrong-3068789438a4?source=collection_archive---------17-----------------------#2018-09-18">https://medium.com/hackernoon/swoole-is-it-node-in-php-or-am-i-wrong-3068789438a4?source=collection_archive---------17-----------------------#2018-09-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/0c95cb59c09229ea318ec511b99f920e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1Bqp-qUWpkxng3kS555IQ.jpeg"/></div></div></figure><div class=""/><p id="82f4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt ka translated">任何PHP开发人员在想到他们使用Node的同事时都会嫉妒不已。异步节点系统在协议之间共享代码库，并在代码之外为它们服务。这真的让人想知道切换到节点。实际上，PHP中类似Node的东西已经作为扩展添加进来了。它叫做Swoole。</p><h1 id="ab85" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">PHP中的节点？那个Swoole是什么东西？</h1><p id="876a" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">好吧，让我直接从<a class="ae lm" href="https://www.swoole.co.uk/" rel="noopener ugc nofollow" target="_blank">文档</a>中复制粘贴定义:</p><p id="4df6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">“PHP的生产级异步编程框架<br/>使PHP开发人员能够用PHP编程语言编写高性能、可伸缩、并发的TCP、UDP、Unix socket、HTTP、Websocket服务，而无需太多关于非阻塞I/O编程和低级Linux内核的知识”。</p><p id="5497" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Swoole是PHP的扩展，它是用c语言写的，听起来很有前途，对吗？用PHP托管HTTP服务器？PHP本身的Websockets？许多其他的可能性，有些看起来很奇特？所有这些都需要保持高性能。我们去看看吧！</p><h1 id="650b" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">如何让它运行起来？</h1><p id="909c" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">本机平台上的安装方法各不相同。</p><p id="8410" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于Linux，它归结为一个pecl命令:</p><blockquote class="ln lo lp"><p id="161b" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">pecl安装swoole</p></blockquote><p id="fb6e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于MacOS，可以使用brew:</p><blockquote class="ln lo lp"><p id="3432" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">brew安装swoole <br/> brew安装homebrew/php/php72-swoole</p></blockquote><p id="961b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而在Windows上，原生安装是不可能的，但无论如何我们还是要用Docker。</p><h1 id="9899" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">Dockerizing Swoole</h1><p id="baa7" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">当然，运行PHP和Swoole的最好方法是Docker容器。让我们看看如何创建一个允许我们使用Swoole的容器。首先，我们需要一个Dockerfile文件。</p><blockquote class="ln lo lp"><p id="52d4" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">从php:最新的<br/>运行pecl安装swoole <br/>添加php.ini /usr/local/etc/php <br/>运行usermod -u 1000 www-data</p></blockquote><p id="dd35" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很简单。在扩展了官方的PHP Docker映像，用pecl安装了Swoole，并复制了php.ini之后——我们得到了它。最后一行是MacOS的标准Docker修复程序。</p><p id="33dd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于要复制的php.ini配置文件，它甚至更简单——只需要一行代码:</p><blockquote class="ln lo lp"><p id="fe52" class="jc jd lq je b jf jg jh ji jj jk jl jm lr jo jp jq ls js jt ju lt jw jx jy jz hn dt translated">extension=swoole.so</p></blockquote><h1 id="359f" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">它提供什么？</h1><p id="7396" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">Swoole具有多种功能。大多数都是异步的。以下是一些最有趣的(其他的可以在Swoole <a class="ae lm" href="https://www.swoole.co.uk/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到):</p><ul class=""><li id="587e" class="lu lv if je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated">TCP/UDP服务器和客户端，</li><li id="01b4" class="lu lv if je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">HTTP服务器和客户端，</li><li id="7851" class="lu lv if je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">Websocket服务器和客户端，</li><li id="9660" class="lu lv if je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">Redis协议服务器和客户端，</li><li id="6062" class="lu lv if je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">MySQL客户端，</li><li id="a771" class="lu lv if je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">原子学，</li><li id="6551" class="lu lv if je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">文件系统。</li></ul><p id="9503" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看如何使用其中的三个:HTTP服务器、Websocket服务器和文件系统。这些是我认为最重要的。</p><h1 id="d89a" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">使用Swoole的HTTP服务器</h1><p id="5868" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">Swoole允许我们运行一个简单的异步工作的HTTP服务器。下面的简单代码也将使用异步文件系统访问，用index.html文件响应它处理的每个请求。</p><figure class="mi mj mk ml fq hw"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="b2d9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们所见，它看起来有点像Node。</p><p id="483d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们创建一个类似于http服务器的对象。然后，我们为两个事件绑定两个匿名函数:一个用于<strong class="je ig"> start </strong>，它将在服务器启动时执行，另一个用于<strong class="je ig"> request </strong>，它将为每个请求执行。它将请求和响应对象作为参数<strong class="je ig">。</strong></p><p id="4d5d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">请求对象</strong>包含与请求本身相关的所有数据:请求的路径、头等等。另一方面，它用于提供输出、设置标题等。值得一提的是，这两个对象不符合PSR，而是他们是定制的Swoole对象。</p><p id="7f73" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je ig">请求</strong>事件<strong class="je ig">事件</strong>中，异步文件系统用于从文件中加载数据。一旦数据可用，就会用加载的内容触发一个回调。然后，使用这些内容填充响应对象并关闭响应。这有效地将数据发送回浏览器。</p><p id="2793" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这看起来很整洁，最重要的是——有效。但是性能呢？</p><h1 id="e2de" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">HTTP服务器基准测试</h1><p id="89f0" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">为了测试使用Swoole的HTTP服务器的性能，我在Node中创建了一个应用程序——它可以做与Swoole完全相同的事情——以及一个NGINX服务器，它将index.html作为静态文件。全部装在3个独立的集装箱里。</p><p id="1aa7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我用<strong class="je ig"> wrk </strong>工具用力敲打这些容器。结果令人震惊。</p><figure class="mi mj mk ml fq hw fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/5f8a4ad082dd03470b0fdab688943a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*u4qNhJMdeeP628nZB4qKWg.png"/></div></figure><p id="5699" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Swoole的结果远远好于预期！</p><p id="8f7e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个惊喜。没想到Swoole超越NGINX，居然真的做到了！节点已超出距离。这个扩展的原始能力确实令人印象深刻，但是随着请求中更多工作的完成，它会逐渐消失。不幸的是，Swoole有两个小缺点，使得这些原始基准变得无关紧要。我们稍后会谈到它们。</p><h1 id="15b2" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">使用Swoole的Websocket服务器</h1><p id="9565" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">如前所述，Swoole提供了一种创建websocket服务器的方法。它异步工作，遵循与HTTP和其他Swoole功能相同的方法。在我看来，这是Swoole最重要的部分之一。拜托，PHP里的websockets？我加入。让我们看看它看起来怎么样。</p><figure class="mi mj mk ml fq hw"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="f7e8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看起来类似于HTTP服务器的例子。</p><p id="b211" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们创建一个类似websocket服务器的对象。然后，我们将4个匿名函数绑定到4个事件。一个到<strong class="je ig"> start </strong>事件，这将像从HTTP服务器开始事件一样工作。另一个<strong class="je ig"> open </strong>事件将在新的websocket连接后执行。另一个to <strong class="je ig"> message </strong>事件将在websocket向服务器发送消息时执行。最后websocket断开连接时运行的<strong class="je ig"> close </strong>事件。</p><p id="544a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">连接到服务器的Websockets由随每个新websockets递增的唯一ID来标识。</p><h1 id="122e" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">使用Swoole时遇到的问题</h1><p id="553e" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">到目前为止一切运行良好，但是我在使用Swoole测试一些解决方案时遇到了两个问题。这些是:</p><ul class=""><li id="7c60" class="lu lv if je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated">HTTP服务器中没有真正的HTTPS支持，</li><li id="f227" class="lu lv if je b jf md jj me jn mf jr mg jv mh jz lz ma mb mc dt translated">脚本中不支持全局变量。</li></ul><p id="dd4c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个很容易缓解。我们只需要使用NGINX或任何负载平衡器设置一个反向代理，就完成了。但这样做，我们失去了Swoole提供的极端性能提升。</p><p id="dd10" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个更棘手。Swoole产生了处理请求的工作进程，这意味着如果我们创建一个全局变量，它的值在线程之间是独立的，它不能工作。这里有一个展示这种行为的例子。</p><figure class="mi mj mk ml fq hw"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="fda5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">人们可能会认为响应会返回0，然后是1、2、3等等，但是它总是返回0。</p><p id="b4f9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我联系了Swoole的作者，想看看这是不是一个bug，但不是。为了获得我们期望的行为，我们可以在配置中设置<strong class="je ig"> worker_num = 1 </strong>，但是这会降低性能。</p><h1 id="1bd8" class="kj kk if bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">结论</h1><p id="0ef8" class="pw-post-body-paragraph jc jd if je b jf lh jh ji jj li jl jm jn lj jp jq jr lk jt ju jv ll jx jy jz hn dt translated">Swoole和其他事物一样，有光明的一面，也有黑暗的一面。我认为将异步编程引入PHP仍然是一个好主意。它可以用于各种情况，从快速原型开发，到简洁的单一责任微服务，低延迟游戏服务器，最后成为大型框架的后端服务器。确实很有希望。</p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><p id="aacd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">这篇文章由Adrian Chlubek撰写，最初发表在软件之家博客</strong><a class="ae lm" href="http://www.tsh.io/blog" rel="noopener ugc nofollow" target="_blank"><strong class="je ig"/></a><strong class="je ig">上。访问博客，获得更多关于最佳开发实践和软件外包技巧的文章。</strong></p></div></div>    
</body>
</html>