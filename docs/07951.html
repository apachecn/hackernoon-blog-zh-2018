<html>
<head>
<title>Pseudo-random Beasts and Where to Find Them: A Cheat Sheet for ES6 &amp; Python 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">伪随机野兽和在哪里找到它们:ES6和Python 3的备忘单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/pseudo-random-beasts-and-where-to-find-them-a-cheat-sheet-for-es6-python-3-e0bcd2e412cf?source=collection_archive---------12-----------------------#2018-09-19">https://medium.com/hackernoon/pseudo-random-beasts-and-where-to-find-them-a-cheat-sheet-for-es6-python-3-e0bcd2e412cf?source=collection_archive---------12-----------------------#2018-09-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/43f4a88882615da9aacf7aeea12e9df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lmWJyfCHF9pLhkReUAxPJQ.jpeg"/></div></div></figure><p id="e1fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我喜欢生成艺术，我经常使用伪随机函数给图像或行为添加一点噪声，但每次我用JavaScript实现伪随机数函数时，我都要花一秒钟来记住这是如何工作的。因此，我想写一篇简短的文章，介绍一些在普通ES6和Python 3中实现的最常见的伪随机数函数(以下简称为“随机”数)。当然，有无限多的概率分布和随机过程需要探索，但我会保持简单，将一些有用的概念，如<a class="ae ka" href="https://en.wikipedia.org/wiki/Markov_chain" rel="noopener ugc nofollow" target="_blank">马尔可夫链</a>和<a class="ae ka" href="https://en.wikipedia.org/wiki/Template:Coherent_noise" rel="noopener ugc nofollow" target="_blank">相干噪声</a>留到下一次。</p><h1 id="6e17" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">0.0到1.0之间的小数</h1><p id="9f67" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">JavaScript中生成随机数最基本的方法是函数<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"><em class="le">math . random()</em></strong></a>，该函数在半开区间内返回一个数字<em class="le"> n </em>，使得<strong class="je hv"> 0 ≤ <em class="le"> n </em> &lt; 1 </strong>。</p><p id="ab6b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记住JavaScript不区分整数和小数。JavaScript中的所有数字都是64位浮点，可以用小数也可以不用小数。要编写一个返回0和<em class="le"> n </em>之间的整数的函数，我们可以使用JavaScript函数，这个函数容易混淆地命名为<strong class="je hv"> <em class="le"> Math.floor() </em> </strong>，MDN web文档告诉我们“<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor" rel="noopener ugc nofollow" target="_blank">返回小于或等于给定数字</a>的最大整数。”由于<strong class="je hv"><em class="le">math . random()</em></strong>为<a class="ae ka" href="https://en.wikipedia.org/wiki/Interval_(mathematics)" rel="noopener ugc nofollow" target="_blank">半开</a>，该函数还会返回一个在<strong class="je hv"> 0 ≤ <em class="le"> n </em> &lt; <em class="le">极限</em> </strong> <em class="le">范围内的整数值<em class="le"> n </em>。</em></p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="c24b" class="ll kc hu bd kd lm ln lo kh lp lq lr kl jn ls lt kp jr lu lv kt jv lw lx kx ly dt translated">Python 3</h2><p id="0f54" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Python中的等价函数是来自<a class="ae ka" href="https://docs.python.org/3/library/random.html" rel="noopener ugc nofollow" target="_blank">随机模块</a>(同样返回半开范围)<em class="le">的函数<strong class="je hv"><em class="le">. random()</em></strong><em class="le"/>。</em>(注意常见的Python函数<strong class="je hv"> <em class="le"> random.uniform(a，b) </em> </strong> <em class="le"> </em>不同之处在于它在开区间<strong class="je hv"> <em class="le">返回一个浮点值<em class="le">n</em>a</em>≤<em class="le">n</em>≤<em class="le">b</em></strong>。)</p><h1 id="ec4e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">0.0和1.0之间的小数(不含)</h1><p id="de1d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><em class="le">非常</em>不太可能<strong class="je hv"><em class="le">math . random()</em></strong>实际上会返回整数0——实际上在2⁵⁶只有<a class="ae ka" href="https://stackoverflow.com/questions/3065554/can-javas-random-function-be-zero" rel="noopener ugc nofollow" target="_blank">一次机会</a>——但是对于返回0会产生可怕后果的用例，我们可以明确排除这种可能性。比如我们可以让函数只在<strong class="je hv"> <em class="le"> n == 0 </em> </strong> <em class="le">的情况下递归。在这种情况下，该函数将调用自身并生成一个新值。</em></p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="53c8" class="ll kc hu ma b fv me mf l mg mh">function randomExcludingZero(min, max) {<br/>    n = Math.random() * (max - min) + min;<br/>    if (n &gt; 0) {<br/>      return n;<br/>    }<br/>    else {<br/>      return randomExcludingZero(min, max);<br/>    }<br/>  }</span></pre><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h1 id="b7d2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">范围内的实数</h1><p id="a7da" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在前面的函数的基础上，我们可以编写一个更灵活的半开放范围的随机数函数(<strong class="je hv"><em class="le">a</em>≤<em class="le">n&lt;b</em></strong>)，它可以处理整数或小数。我们可以使用布尔自变量在小数和整数之间切换。</p><p id="30a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(注意，我在这里用一个对象初始化函数。阅读Bill Sourour关于RORO模式的精彩文章，讨论这样做的好处。)</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="ed47" class="ll kc hu ma b fv me mf l mg mh">function randomRange( { min, max, integers=true } ) {<br/>  if (integers) {<br/>    return (Math.floor(Math.random() * (max - min) + min));<br/>  }<br/>  else {<br/>    return (Math.random() * (max - min) + min);<br/>  }<br/>}</span></pre><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="85bd" class="ll kc hu bd kd lm ln lo kh lp lq lr kl jn ls lt kp jr lu lv kt jv lw lx kx ly dt translated">Python 3</h2><p id="ee78" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Python有两个内置函数，可以返回一个范围内的随机数，因此Python中的等效函数要简单得多。(请记住，在Python中，布尔保留字“True”和“False”使用大写字母开头！)</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="4278" class="ll kc hu ma b fv me mf l mg mh">import random<br/>def randomIntInc(min, max, integers=True):<br/>    if integers:<br/>        return random.randint(min, max)<br/>    else:<br/>        return random.uniform(min, max)</span></pre><p id="2f6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些函数适用于所有实数。只要<strong class="je hv"> <em class="le"> min ≤ max </em> </strong> <em class="le">，我们可以将负数传递给任何一个函数。</em></p><h1 id="c897" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">选择1或-1</h1><p id="503b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有时我们想在一个数和它的<a class="ae ka" href="https://en.wikipedia.org/wiki/Additive_inverse" rel="noopener ugc nofollow" target="_blank">加逆</a>之间随机交替。例如，如果我们有一个物体沿着一个向量运动，我们想随机反转这个物体在这个向量上的运动方向，我们可以将这个向量乘以一个在1和-1之间的随机选择。</p><p id="6c63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在JavaScript中，我们可以用一个三元运算符轻松实现这一点。基本上我们用<strong class="je hv"> <em class="le"> Math.random() </em> </strong>生成一个0.0到1.0之间的随机小数。该函数接受一个参数，该参数表示该函数返回-1的可能性。如果随机小数低于此限制，则函数返回-1，否则函数返回1。限值0.5将返回-1和1的大致均匀分布，而其他值(&lt; 1)将返回-1和1的加权分布。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="2d20" class="ll kc hu ma b fv me mf l mg mh">function additiveInverse(chanceOfNegative) {<br/> return (Math.random() &lt; chanceOfNegative ? -1 : 1);<br/>}</span></pre><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="5071" class="ll kc hu bd kd lm ln lo kh lp lq lr kl jn ls lt kp jr lu lv kt jv lw lx kx ly dt translated">Python 3</h2><p id="52b0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在这种情况下，等效的Python代码几乎是相同的。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="3051" class="ll kc hu ma b fv me mf l mg mh">import random<br/>def additiveInverse(chanceOfNegative):<br/>    return 1 if random.random() &lt; chanceOfNegative else -1</span></pre><h1 id="0ec5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">无重复的随机阵列</h1><p id="4807" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有时我们可能需要生成一个填充了唯一随机值的数组。为此，我们需要给函数一个最小和最大范围(从中选择值)并指定要生成的数组的长度。如果我们的范围小于数组的长度，函数将进入无限循环，因为函数将在数组满之前用尽所有可能的值。一个简单的解决方法是抛出一个异常，以防最小值<strong class="je hv"><em class="le"/></strong>和最大值<strong class="je hv"><em class="le"/></strong>之间的绝对值距离没有超过数组长度<strong class="je hv"> <em class="le">。</em> </strong></p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="8a7b" class="ll kc hu ma b fv me mf l mg mh">if (arrayLength &gt; Math.abs(min - max)) {<br/>    throw "Array length fails to exceed range."<br/>}</span></pre><p id="695c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们使用while循环来填充一个空数组。我们生成一个随机数，检查该数是否已经包含在数组中，只有在该数是唯一的情况下，才将该数推送到数组中。</p><p id="f3b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们在函数的初始化中，而不是在函数体中将randomArray设置为空。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="1b10" class="ll kc hu ma b fv me mf l mg mh">function randomArrayWithoutReps( { min, max, arrayLength, <strong class="ma hv">randomArray = []</strong>, integers=true } )</span></pre><p id="40e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们在下一节讨论不重复的数字流时，这将非常有用。以这种方式初始化数组可以让我们在需要的时候传入一个全局范围的数组，而且因为我们用一个对象初始化函数，所以当我们调用函数的时候，如果我们不想传入任何值，我们也不必传入任何值！</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="c11e" class="ll kc hu ma b fv me mf l mg mh">function randomArrayWithoutReps( { min, max, arrayLength, randomArray = [], integers=true } ) {</span><span id="6557" class="ll kc hu ma b fv mi mf l mg mh">  if (arrayLength &gt; Math.abs(min - max)) {<br/>    throw "Array length fails to exceed range."<br/>  }</span><span id="4548" class="ll kc hu ma b fv mi mf l mg mh">  while (randomArray.length &lt; arrayLength) {</span><span id="cb86" class="ll kc hu ma b fv mi mf l mg mh">    const randNum = integers <br/>      ? (Math.floor(Math.random() * (max - min) + min)) <br/>      : (Math.random() * (max - min) + min);</span><span id="c71f" class="ll kc hu ma b fv mi mf l mg mh">    if (!randomArray.includes(randNum)) { <br/>      randomArray.push(randNum);<br/>    }<br/>  }<br/>  return randomArray;<br/>}</span></pre><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="42e5" class="ll kc hu bd kd lm ln lo kh lp lq lr kl jn ls lt kp jr lu lv kt jv lw lx kx ly dt translated">Python 3</h2><p id="a90f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">还是那句话，Python有随机采样的模块函数，我们要做的就是调用<strong class="je hv"><em class="le">random . sample()</em></strong>。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="65e0" class="ll kc hu ma b fv me mf l mg mh">import random<br/>random.sample(range(-10, 10), 12)</span></pre><h1 id="d8ee" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">没有(最近)重复的随机流</h1><p id="101f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有时我们希望生成一个随机数流，而不重复前面<em class="le"> n </em>次函数调用中的任何值。由于函数需要某种“记忆”它最近生成的值，我们可能最终会使用某种类型的数组，并且由于我们已经有了一个函数来生成随机唯一值的数组，我们可以在此基础上构建！</p><p id="fafb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们需要声明一个具有全局范围的空数组，它将作为我们函数的最近生成的随机值的“内存”。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="7e7f" class="ll kc hu ma b fv me mf l mg mh">let randomBuffer = [];</span><span id="9afd" class="ll kc hu ma b fv mi mf l mg mh">function randomArrayWithoutReps({ min, max, arrayLength, <br/>  randomArray = [], integers=true }) {<br/>  [...]<br/>}</span><span id="9d03" class="ll kc hu ma b fv mi mf l mg mh">function randomStream({min, max, lengthWithoutRep, integers=true}) {<br/>  <br/>  [...n] = randomArrayWithoutReps({ <br/>    min: min, <br/>    max: max, <br/>    arrayLength: lengthWithoutRep, <br/>    randomArray: randomBuffer, <br/>    integers: integers });</span><span id="bbd2" class="ll kc hu ma b fv mi mf l mg mh">randomBuffer = n;<br/>  return randomBuffer.shift();<br/>}</span></pre><p id="7720" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的新函数<strong class="je hv"> <em class="le"> randomStream </em> </strong>调用我们之前编写的<strong class="je hv"><em class="le">randomArrayWithoutReps</em></strong>函数。使用<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构</a>我们将随机数组函数的输出复制到全局<strong class="je hv"> <em class="le"> randomBuffer </em> </strong>变量中。<strong class="je hv"> <em class="le">。shift() </em> </strong>方法删除全局数组中的第一个数字，并将其作为我们的流的输出返回。</p><p id="c8a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的诀窍是，每次用新更新的全局数组初始化randomArrayWithoutReps。函数<strong class="je hv"><em class="le">randomArrayWithoutReps</em></strong>查看传入的数组<strong class="je hv"> <em class="le"> </em> </strong>，发现它比它的<strong class="je hv"> <em class="le"> arrayLength、</em> </strong>少一个数字，并计算一个新的唯一值，将其推送到数组的末尾。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="97f1" class="ll kc hu ma b fv me mf l mg mh">while (randomArray.length &lt;= arrayLength) {<br/>  [...]<br/>  if (!randomArray.includes(randNum)) { randomArray.push(randNum); }<br/>  return randomArray;<br/>}</span></pre><p id="1d86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本上<strong class="je hv"><em class="le">randomArrayWithoutReps</em></strong>函数<strong class="je hv"> <em class="le"> </em> </strong>作为滑动窗口函数，确保新的随机值不会重复先前<strong class="je hv"> <em class="le"> n </em> </strong>次函数调用中生成的值。很酷，对吧？</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="bcf5" class="ll kc hu bd kd lm ln lo kh lp lq lr kl jn ls lt kp jr lu lv kt jv lw lx kx ly dt translated">Python 3</h2><p id="ca7d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在上面讨论Python中列表的随机抽样时，我介绍了Python的<strong class="je hv"><em class="le">random . sample()</em></strong>模块函数。如果我们想要在最后返回的<strong class="je hv"> <em class="le"> n </em> </strong>个值中创建一个没有重复的随机数字流，那么使用<strong class="je hv"><em class="le">random . sample()</em></strong>的函数实际上可能不是最佳选择，因为这个全局<strong class="je hv"> <em class="le"> randomBuffer </em> </strong>变量充当了最近生成的值的一种“内存”,所以我们无论如何都必须在每次调用函数时更新这个列表。我们可以像在JavaScript中一样，用while循环轻松地做到这一点。</p><p id="b6ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在函数中使用全局变量通常不是Python中的最佳实践，但在这里我认为它澄清了<strong class="je hv"><em class="le"/></strong>的目的。(不要忘记，我们明确声明<strong class="je hv"> <em class="le"> randomBuffer </em> </strong>是我们每个函数开始时的全局变量。)就像在我们的JavaScript函数中一样，如果我们在缓冲区列表满之前面临用完潜在随机值的危险，我们使用Python的<strong class="je hv"> <em class="le"> assert </em> </strong>语句来抛出错误。其余大部分代码与JavaScript非常相似。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="f23b" class="ll kc hu ma b fv me mf l mg mh">import time<br/>import random<br/>from random import randint</span><span id="dda4" class="ll kc hu ma b fv mi mf l mg mh">randomBuffer = []</span><span id="eb86" class="ll kc hu ma b fv mi mf l mg mh">def randomListWithoutReps(minimum, <br/>                          maximum, <br/>                          listLength, <br/>                          integers=True):<br/>    global randomBuffer<br/>    assert listLength &lt; abs(minimum - maximum), \<br/>    "List length fails to exceed range."<br/>    while len(randomBuffer) &lt;= listLength:<br/>        if integers:<br/>            randNum = randint(minimum, maximum)<br/>        else:<br/>            randNum = random.uniform(minimum, maximum)<br/>        if randNum not in randomBuffer:<br/>            randomBuffer.append(randNum)<br/>    return randomBuffer</span><span id="3c18" class="ll kc hu ma b fv mi mf l mg mh">def randomStream(minimum, <br/>                 maximum, <br/>                 lengthWithoutRep):<br/>    global randomBuffer<br/>    randomBuffer = randomListWithoutReps(minimum, <br/>                                         maximum, <br/>                                         lengthWithoutRep)<br/>    return randomBuffer.pop(0)</span></pre><p id="9090" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要查看运行中的函数，请像这样调用它:</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="e2b1" class="ll kc hu ma b fv me mf l mg mh">while True:<br/>    print(randomStream(0, 6, 5))<br/>    time.sleep(1)</span></pre><h1 id="44b9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">加权随机选择</h1><p id="c745" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">数组加权抽样是一种非均匀抽样方法，其中数组中的每一项都被赋予一个代表该项被选中的几率的权重。加权选择函数在游戏、数字艺术甚至网页设计中非常有用，因为偏斜的概率行为直观地模拟了我们与现实世界中的对象的许多交互。</p><p id="b2db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的目标是编写一个函数，它采用一个相对概率权重列表，并根据指标的相对权重返回一个在<strong class="je hv"><em class="le">【0】</em></strong>和<strong class="je hv"><em class="le">weights . length</em></strong>之间的指标值。然后，这个索引值可用于从另一个相同长度的列表中返回一个项目。</p><p id="20af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一般来说，加权选择函数基于数组中所有权重的总和，然后根据权重的值对其进行分区，然后进行迭代。如果一个随机数属于其中一个分区，则返回该分区的索引值。然而，<a class="ae ka" href="https://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python" rel="noopener ugc nofollow" target="_blank">一个更有效的</a>算法通过从随机值变量中减去列表中的每个权重来避免总数的临时列表。当变量用尽时，我们返回那个索引。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="66b7" class="ll kc hu ma b fv me mf l mg mh">function weightedRandom(weights) {<br/>  let rnd = Math.random() * weights.reduce((x, y) =&gt; x + y);<br/>  for (i = 0; i &lt; weights.length; i++) {<br/>    rnd -= weights[i];<br/>    if (rnd &lt; 0) {<br/>      return i<br/>    }<br/>  }<br/>}</span></pre><p id="f74c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记住，这个函数的典型用例是返回一个索引值，我们用它从一个数组中选择条目。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="b109" class="ll kc hu ma b fv me mf l mg mh">const favoriteFoods = ["sushi", "pizza", "falafel"]</span><span id="656c" class="ll kc hu ma b fv mi mf l mg mh">document.getElementById("output").innerHTML =     favoriteFoods[weightedRandom([1, 1, 2])];</span></pre><p id="bd54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为权重列表是相加的，所以函数返回的索引的相对概率是该权重与数组中所有权重总和的比率。例如，上述实例返回“寿司”、“比萨饼”或“沙拉三明治”的概率分别为25%、25%和50%。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="0d47" class="ll kc hu bd kd lm ln lo kh lp lq lr kl jn ls lt kp jr lu lv kt jv lw lx kx ly dt translated">Python 3</h2><p id="3174" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Python 3在其random模块中没有加权采样方法(尽管如果您想使用Numpy，您可以调用<strong class="je hv"><em class="le">Numpy . random . choice()</em></strong>，它有一个可选参数用于<strong class="je hv"> <em class="le"> </em> </strong>非均匀采样)。Eli Bendersky有一篇很棒的博客文章，他比较了几种加权选择函数的效率，所以我不会在这里重新发明轮子，我会把你引向他2010年的博客文章:“<a class="ae ka" href="https://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python" rel="noopener ugc nofollow" target="_blank">Python中的加权随机生成</a>”其实充分披露一下，我上面的JavaScript函数是把他的<strong class="je hv"><em class="le">weighted _ choice _ sub</em></strong>Python函数移植到ES6中的！</p><h1 id="31bb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">随机游动</h1><p id="a37c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">随机漫步是许多数字艺术中遇到的基本过程，它们也有一些非常酷的高维暗示。随机游走是一种随机过程，通过这种随机过程，允许实体或函数从其起始位置或值“移动”(或返回值)一段距离。然后，该函数采用其新位置的值，并可能根据其“步长”再次移动步长可以是二进制的(例如1或0，即移动或不移动)，或者步长可以是以起始值为中心的范围内的随机值。随机行走也可以被限制在一个范围内，因此当“行走者”到达一个边界时，它会被迫转向相反的方向。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/1c43e64d0970210454f9f623e69c8b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgtPOJ63_qhxXxtCErYv9w.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">A one-dimensional random walk with a step size of [ 0 – 2 ] constrained between [ -7 – 7 ].</figcaption></figure><p id="fcb0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于遍历器的状态会从一个函数调用延续到另一个函数调用，所以我们需要将遍历器定义为一个可变的全局变量。然后，我们需要设置一个函数，它将接受我们的“行走者”，一个步长，以及可能的最小和最大边界，我们将在其中约束行走。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="b755" class="ll kc hu ma b fv me mf l mg mh">let walker = 0;</span><span id="37ff" class="ll kc hu ma b fv mi mf l mg mh">function randomWalk(walker, stepSize, min, max) {<br/>  ...<br/>}</span></pre><p id="5310" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们的一维行走可以增加或减少价值，我们需要一种方法来表示方向的随机变化。这就是我们可以使用上面的加法反函数的地方。我们会得到+/-值的均匀分布。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="504c" class="ll kc hu ma b fv me mf l mg mh">function randomWalk(walker, stepSize, min, max) {<br/>  const direction = (Math.random() &lt; 0.5 ? -1 : 1);<br/>  ...<br/>}</span></pre><p id="949d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们希望每次调用函数时步行者的移动速率都相同，我们可以只使用“stepSize”作为常数:</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="6b3c" class="ll kc hu ma b fv me mf l mg mh">function randomWalk(walker, stepSize, min, max) {<br/>  const direction = (Math.random() &lt; 0.5 ? -1 : 1);<br/>  stepSize *= direction;<br/>  ...<br/>}</span></pre><p id="5a57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是让“步长”定义一个可能值的范围可能更有趣；为此，我们使用一个随机整数范围:</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="b27f" class="ll kc hu ma b fv me mf l mg mh">function randomWalk(walker, stepSize, min, max) {<br/>  const direction = (Math.random() &lt; 0.5 ? -1 : 1);<br/>  const step = Math.floor(Math.random() * stepSize) * direction;<br/>  ...<br/>}</span></pre><p id="82b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们需要一个条件来检查步行者是否将要超越它的上限或下限。请注意，我们没有检查助行器<em class="le">当前是否在其范围之外。</em>我们需要检查步行者<em class="le">是否会</em>在其范围之外，如果它进行下一步。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="aa34" class="ll kc hu ma b fv me mf l mg mh">if (((walker+step) &lt;= max) &amp;&amp; ((walker+step) &gt;= min)) {<br/>  ...<br/>}</span><span id="5986" class="ll kc hu ma b fv mi mf l mg mh">else {<br/>  ...<br/>}</span></pre><p id="d680" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果当前步长在允许的范围内，我们需要更新walker的值，并返回walker的新值。如果当前步骤将步行者置于范围之外，我们反转该步骤的方向并返回该值。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="230b" class="ll kc hu ma b fv me mf l mg mh">if (((walker+step) &lt;= max) &amp;&amp; ((walker+step) &gt;= min)) {<br/>    walker += step;<br/>    return walker;<br/>  }<br/>else {<br/>    step *= -1;<br/>    walker += step;<br/>    return walker;<br/>  }</span></pre><p id="a5d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以总的来说，我们的函数看起来像这样。当然，当我们调用函数时，我们需要记住将“walker”的值设置为函数的返回值，否则walker不会走很远！</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="12cf" class="ll kc hu ma b fv me mf l mg mh">let walker = 0;</span><span id="c214" class="ll kc hu ma b fv mi mf l mg mh">function randomWalk( { walker, stepSize, min, max } ) {<br/>  const direction = (Math.random() &lt; 0.5 ? -1 : 1);<br/>  const step = Math.floor(Math.random() * stepSize) * direction;<br/>  if (((walker+step) &lt;= max) &amp;&amp; ((walker+step) &gt;= min)) {<br/>    walker += step;<br/>    return walker;<br/>  }<br/>  else {<br/>    step *= -1;<br/>    walker += step;<br/>    return walker;<br/>  }<br/>}</span><span id="ce40" class="ll kc hu ma b fv mi mf l mg mh">...</span><span id="147f" class="ll kc hu ma b fv mi mf l mg mh">walker = randomWalk( { walker: walker, stepSize: 3, min: -7, max: 7 } )</span></pre><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="146c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使随机行走本身的步长或行走方向依赖于随机行走，可以获得有趣的效果。例如，如果我们想要更多的<a class="ae ka" href="https://en.wikipedia.org/wiki/Stick-slip_phenomenon" rel="noopener ugc nofollow" target="_blank">粘滑运动</a>，我们可以使用这种技术让一个步行者在一个方向上连续移动一些步，然后改变方向并在另一个方向上移动一些步。</p><h2 id="83a5" class="ll kc hu bd kd lm ln lo kh lp lq lr kl jn ls lt kp jr lu lv kt jv lw lx kx ly dt translated">Python 3</h2><p id="8b2b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Python中的等价函数非常相似。使用上面定义的加法反函数来选择步长方向。</p><pre class="lf lg lh li fq lz ma mb mc aw md dt"><span id="bb51" class="ll kc hu ma b fv me mf l mg mh">import random<br/>walker = 0;</span><span id="09bb" class="ll kc hu ma b fv mi mf l mg mh">def additiveInverse():<br/>    return 1 if random.random() &lt; 0.5 else -1</span><span id="5140" class="ll kc hu ma b fv mi mf l mg mh">def randomWalk(walker, stepSize, minimum, maximum):<br/>    direction = additiveInverse()<br/>    step = random.randint(0, stepSize) * direction<br/>    if (((walker+step) &lt;= maximum) and ((walker+step) &gt;= minimum)):<br/>        walker += step<br/>        return walker<br/>    else:<br/>        step *= -1<br/>        walker += step<br/>        return walker</span><span id="c18f" class="ll kc hu ma b fv mi mf l mg mh">...</span><span id="5069" class="ll kc hu ma b fv mi mf l mg mh">walker = randomWalk(walker, 3, -7, 7)</span></pre><h1 id="70bf" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="014b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">小心Nifflers…</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/953677794b62414e1fa4f135cda47043.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/1*PVEhbBw9gTP7Z8_KV3hYvg.gif"/></div></figure></div></div>    
</body>
</html>