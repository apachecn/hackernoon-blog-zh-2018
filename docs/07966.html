<html>
<head>
<title>The Art of the Helm Chart: Patterns from the Official Kubernetes Charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">舵图的艺术:来自官方Kubernetes图表的模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-art-of-the-helm-chart-patterns-from-the-official-kubernetes-charts-8a7cafa86d12?source=collection_archive---------2-----------------------#2018-09-20">https://medium.com/hackernoon/the-art-of-the-helm-chart-patterns-from-the-official-kubernetes-charts-8a7cafa86d12?source=collection_archive---------2-----------------------#2018-09-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="16bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Helm charts打包应用程序以安装在Kubernetes集群上。安装舵图有点像运行安装向导。因此，helm chart开发人员面临着开发安装程序的开发人员所面临的一些同样的挑战:</p><ul class=""><li id="56e9" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">对于安装运行的环境，可以做出哪些假设？</li><li id="cfa4" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">该应用程序是否意味着能够与其他应用程序进行交互？</li><li id="5efa" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">需要向用户提供哪些配置，应该如何向用户提供这些配置？</li></ul><p id="2b20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这些问题伴随着特定的舵扭曲。要了解原因，让我们从用户运行“helm install”时会发生什么开始。然后我们可以继续看一些官方的Kubernetes图表如何处理这些问题。</p><h1 id="9dab" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">一个头盔安装的图片</h1><p id="cd72" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我想在我的集群中安装mysql。但我不希望stable/mysql chart在官方charts repo 的values.yaml文件中设置<a class="ae kd" href="https://github.com/helm/charts/blob/fce283ced152e4eed93da8574022a5bcaff9b98d/stable/mysql/values.yaml#L5" rel="noopener ugc nofollow" target="_blank">的mysql版本。所以我创建了自己的values.yaml文件，名为mysql-values.yaml，只有一行代码:</a></p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="34ee" class="lq kf hu lm b fv lr ls l lt lu">imageTag: “5.7.10”</span></pre><p id="86cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我跑<code class="eh lv lw lx lm b">helm install stable/mysql --values=mysqlvalues.yaml</code>。Helm为我生成了一个唯一的版本名(` ignore-camel ` ), MySQL部署在我的集群中。<code class="eh lv lw lx lm b">kubectl describe pod ignorant-camel-mysql-5dc6b947b-lf6p8 </code>的输出告诉我，我选择的<code class="eh lv lw lx lm b">imageTag</code>已经被应用。</p><p id="0223" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，我不需要在集群中安装任何东西来查看我对<code class="eh lv lw lx lm b">imageTag</code>的选择是否会被应用。我可以运行<code class="eh lv lw lx lm b">helm install stabe/mysql --values=mysqlvalues.yaml --dry-run --debug</code>，helm会简单地向我展示它生成的kubernetes部署描述符yaml的内容，而不需要安装任何东西。</p><p id="c88c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过思考helm图表的<a class="ae kd" href="https://www.nclouds.com/blog/simplify-kubernetes-deployments-helm-part-2/" rel="noopener ugc nofollow" target="_blank">结构</a>，可以更好地理解获得生成的kubernetes部署描述符的过程:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="f57b" class="lq kf hu lm b fv lr ls l lt lu">├── Chart.yaml<br/>├── README.md<br/>├── templates<br/>│   ├── NOTES.txt<br/>│   ├── _helpers.tpl<br/>│   ├── <strong class="lm hv">deployment.yaml</strong><br/>│   ├── <strong class="lm hv">secrets.yaml</strong><br/>│   └── <strong class="lm hv">...more yaml...</strong><br/>└── <strong class="lm hv">values.yaml</strong></span></pre><p id="dc53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当用户运行<code class="eh lv lw lx lm b">helm install stable/mysql</code>时，图表中values.yaml的条目和helm发布信息(比如惟一的发布名称)被注入到模板化的yaml资源描述符中，因为模板被评估并呈现为纯Kubernetes部署描述符。当用户使用参数或值文件运行<code class="eh lv lw lx lm b">helm install stable/mysql</code>时，参数或值文件将覆盖在图表中的文件上。实际上，图表中的值文件设置了可以被覆盖的默认值。</p><p id="2438" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以values.yaml是我们作为图表开发人员和用户之间的主要接口。我们在values.yaml中公开的内容决定了用户可以对我们的图表做什么，不可以做什么。</p><p id="f419" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的图表和values.yaml文件也需要满足另一种场景。另一个图表开发者可能会喜欢我们的应用程序，并决定将它包含在他们想要发布的包中。因此，他们将我们的图表添加到他们创建的新图表的requirements.yaml中，还有一堆其他的图表。他们通过设置<em class="ly">他们的</em>值. yaml来覆盖我们的一些缺省值，然后他们把它分发给用那个图表做<code class="eh lv lw lx lm b">helm install</code>的用户。</p><p id="0ca7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们的图表进入其他图表，它们反馈给图表食物链中的用户。如何在这个食物链中满足我们的消费者，是编写掌舵图的关键挑战之一。</p><h1 id="a256" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">写舵图的挑战</h1><p id="35d2" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">应用程序通常有许多配置选项，Kubernetes集群可以用许多不同的方式进行配置。因此，在绘制掌舵图时，我们自然会面临这样的问题:</p><ol class=""><li id="65ab" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo lz jv jw jx dt translated">如果我忘记在values.yaml中公开一个配置参数怎么办？如果我的应用程序动态地解析配置，以至于我不能提前说出所有可能的参数名称，该怎么办？</li><li id="3d10" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo lz jv jw jx dt translated">我如何允许用户使用不是直接在我的图表中定义的资源，而是在我的图表被用作子图表的图表中定义的资源？</li><li id="05bd" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo lz jv jw jx dt translated">如果另一个图表开发人员在他们自己的图表中使用我的图表，并且他们需要在我定义的资源中添加重要的部分(例如，向pod或自定义初始化脚本添加额外的容器)，该怎么办？</li><li id="e3bc" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo lz jv jw jx dt translated">我如何让我的用户以他们可能想要的各种方式对外公开应用程序？</li></ol><p id="981a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以从<a class="ae kd" href="https://github.com/helm/charts" rel="noopener ugc nofollow" target="_blank">官方舵手图表库</a>的图表中学到很多关于如何处理这类问题的知识。让我们来看看那些图表使用的一些模式，这样我们就可以了解如何在我们自己的图表中使用相同的模式。</p><p id="ffd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开始之前，值得记住的是，公开图表是相当先进的。如果你在制作你的第一张舵轮图时担心上面的一些问题，试着从更困难的担忧开始。从熟悉<a class="ae kd" href="https://docs.helm.sh/chart_template_guide/#getting-started-with-a-chart-template" rel="noopener ugc nofollow" target="_blank">舵文档</a>开始，试着先建立一个只适用于最简单情况的图表。您可以稍后添加<a class="ae kd" href="https://github.com/helm/helm/blob/master/docs/charts_tips_and_tricks.md" rel="noopener ugc nofollow" target="_blank">高级选项</a>。</p><p id="6696" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，让我们试着从官方图表中获得一个模式的快照。这不会是全面的，我希望当<a class="ae kd" href="https://sweetcode.io/a-first-look-at-the-helm-3-plan/" rel="noopener ugc nofollow" target="_blank"> helm 3 </a>用Lua添加脚本时，新的选项会变得可用，新的模式会出现。但它会让我们看到当前的艺术水平。</p><h1 id="e7a3" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">1公开配置参数的模式</h1><p id="410b" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">假设我们已经在模板中定义了一个部署资源，并且我们已经配置了<code class="eh lv lw lx lm b">env </code>部分，允许从values.yaml:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6dc2" class="lq kf hu lm b fv lr ls l lt lu">- name<strong class="lm hv">: </strong>ENV_VAR1<br/>  value: {{ .Values.var1 }}<br/>- name<strong class="lm hv">: </strong>ENV_VAR2<br/>  value: {{ .Values.var2 }}</span></pre><p id="28b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们图表的用户可以在他们的values.yaml中或者用<code class="eh lv lw lx lm b">—set var1=foo </code>覆盖这些值。但是如果我们忽略了一个，我们的用户能做什么呢？或者更糟的是，如果我们的应用程序可以动态解析配置选项(例如，它可能读取<code class="eh lv lw lx lm b">ENV_VAR1</code>并创建一个名为<code class="eh lv lw lx lm b">var1</code>的内部变量)会怎么样？那么甚至没有一组有限的配置选项名称可以公开。那么，我们如何让用户设置变量名和值呢？</p><p id="4417" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如<a class="ae kd" href="https://docs.helm.sh/chart_template_guide/#variables" rel="noopener ugc nofollow" target="_blank"> helm charts开发者指南</a>所说，我们可以创建一个带有范围函数的配置图。一个很好的例子是稳定/未绑定图表。它包含一个定义其unbound.conf文件的<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/unbound/templates/configmap.yaml" rel="noopener ugc nofollow" target="_blank"> configmap </a>。它<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/unbound/templates/deployment.yaml#L71" rel="noopener ugc nofollow" target="_blank">将这个文件挂载</a>到由它的部署创建的pod中。在配置图中，它有条目<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/unbound/templates/configmap.yaml#L35" rel="noopener ugc nofollow" target="_blank">，如</a>:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="dca5" class="lq kf hu lm b fv lr ls l lt lu">{{- range .Values.localRecords }}<br/>local-data: "{{ .name }} A {{ .ip }}"<br/>local-data-ptr: "{{ .ip }} {{ .name }}"<br/>{{- end }}</span></pre><p id="0e32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和它的<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/unbound/values.yaml#L54" rel="noopener ugc nofollow" target="_blank">值。yaml </a>让<code class="eh lv lw lx lm b">localRecords</code>中的条目被设置为列表，例如:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="00e8" class="lq kf hu lm b fv lr ls l lt lu">localRecords:<br/>- name: "fake3.host.net"<br/>  ip: "10.12.10.10"<br/>- name: "fake4.host.net"<br/>  ip: "10.13.10.10"</span></pre><p id="13be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kd" href="https://github.com/helm/charts/blob/0445fad8d8308f089f5fb6756a5570bc6d6f0bf5/stable/sonarqube/templates/deployment.yaml#L80" rel="noopener ugc nofollow" target="_blank">sonar cube图表</a>将类似的方法直接应用于环境变量，明确定义一些变量，并允许使用<code class="eh lv lw lx lm b">extraEnv</code>集合设置更多变量:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8a55" class="lq kf hu lm b fv lr ls l lt lu">{{- range $key, $value := .Values.extraEnv }}<br/> — name: {{ $key }}<br/>   value: {{ $value }}<br/>{{- end }}</span></pre><p id="7cfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此变量将被设置在values.yaml中，如:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="b576" class="lq kf hu lm b fv lr ls l lt lu">extraEnv:<br/>  ENV_VAR1: var1<br/>  ENV_VAR2: var2</span></pre><p id="0197" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多官方图表对T2的定义略有不同。<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/buildkite/templates/deployment.yaml#L43" rel="noopener ugc nofollow" target="_blank"> buildkite图表</a>以不同的方式定义它，没有使用range。相反，它获取values.yaml部分，并简单地将其放入模板中:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2496" class="lq kf hu lm b fv lr ls l lt lu">{{- if .Values.extraEnv }}<br/>{{ toYaml .Values.extraEnv | indent 12 }}<br/>{{- end }}</span></pre><p id="b692" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，这意味着不是将values.yaml中的extraEnv条目设置为简单的对，我们还需要将对中的每个键(<code class="eh lv lw lx lm b">name</code>)和值(<code class="eh lv lw lx lm b">value</code>)命名为:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6153" class="lq kf hu lm b fv lr ls l lt lu">extraEnv:<br/> — name: ENV_VAR1<br/>   value: "var1"<br/> — name: ENV_VAR2<br/>   value: "var2"</span></pre><p id="a935" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kd" href="https://github.com/helm/charts/blob/0445fad8d8308f089f5fb6756a5570bc6d6f0bf5/stable/keycloak/templates/statefulset.yaml#L67" rel="noopener ugc nofollow" target="_blank">键盘锁图表</a>再次以不同的方式做到了这一点:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="a549" class="lq kf hu lm b fv lr ls l lt lu">{{- with .Values.keycloak.extraEnv }}<br/>{{ tpl . $ | indent 12 }}<br/>{{- end }}</span></pre><p id="ba91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此它将extraEnv视为一个字符串，通过<code class="eh lv lw lx lm b">tpl</code>函数发送它，以便它作为模板的一部分被评估，并确保应用正确的缩进。这很有趣，因为它允许像这样设置值:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="4c64" class="lq kf hu lm b fv lr ls l lt lu">extraEnv: |<br/> — name: KEYCLOAK_LOGLEVEL<br/>   value: DEBUG<br/> — name: HOSTNAME<br/>   value: {{ .Release.Name }}-keycloak</span></pre><p id="d56c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常不可能在values.yaml中使用类似于<code class="eh lv lw lx lm b">{{ .Release.Name }}</code>的模板指令，但是这里我们可以，因为内容将通过<code class="eh lv lw lx lm b"> tpl</code>。在我们将图表包含在正在开发的父图表中，并且我们需要引用作为同一父图表一部分的服务的情况下，这可能是一个很大的优势。(下一节将详细介绍这一点。)缺点是它有点抽象，而且values.yaml中的内容被视为字符串，因此编辑器不一定会发现格式问题。</p><h1 id="4332" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">2引用相互部署的资源</h1><p id="d124" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">通常，通过helm部署的资源都带有一个版本名前缀，这样就可以从同一个图表(和同一个名称空间)安装多个版本，而不会在安装的资源之间产生命名冲突。这意味着，当图表中的一个资源需要引用另一个资源或同一父图表中的资源时，需要使用模板指令作为资源名称的前缀。</p><p id="3486" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要引用相互部署的资源的常见情况是数据库机密。例如，<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/incubator/xray/templates/xray-indexer-deployment.yaml#L56" rel="noopener ugc nofollow" target="_blank">x射线图表</a>中包含了部署postgres数据库的选项。它通过指向postgres secret(它本身作为子图表是图表的一部分，因此也以相同的发布名称为前缀)来设置其索引器组件的部署和凭证:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="4216" class="lq kf hu lm b fv lr ls l lt lu">{{- if .Values.postgresql.enabled }}<br/> — name: POSTGRES_USER<br/>   value: {{ .Values.postgresql.postgresUser }}<br/> — name: POSTGRESS_PASSWORD<br/>   valueFrom:<br/>     secretKeyRef:<br/>       name: {{ .Release.Name }}-postgresql<br/>       key: postgres-password<br/> — name: POSTGRESS_DB<br/>   value: {{ .Values.postgresql.postgresDatabase }}<br/> {{- else }}<br/>...</span></pre><p id="f85b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，x射线图表知道它需要连接到哪个数据库，因为它本身包括postgres图表。但是如果我们为一个用户可以选择提供数据库的应用程序开发一个图表会怎么样呢？然后，可能有必要允许用户将我们的图表包含在他们选择的数据库旁边的父图表中。那么我们如何允许用户设置数据库配置呢？</p><p id="3892" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一种选择是我们已经在钥匙孔图表中看到的<code class="eh lv lw lx lm b">extraEnv</code>方法。然后用户可以设置图表的<code class="eh lv lw lx lm b">extraEnv</code>指向postgres，即使我们在原始图表中没有明确定义它。values.yaml将会有一个类似如下的条目:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="a6f6" class="lq kf hu lm b fv lr ls l lt lu">extraEnv: |<br/>- name: POSTGRES_USER<br/>  value: {{ .Values.postgresql.postgresUser }}<br/>— name: POSTGRESS_PASSWORD<br/>  valueFrom:<br/>    secretKeyRef:<br/>      name: {{ .Release.Name }}-postgresql<br/>      key: postgres-password<br/>— name: POSTGRESS_DB<br/>  value: {{ .Values.postgresql.postgresDatabase }}</span></pre><p id="a029" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有<code class="eh lv lw lx lm b">|</code>,因为该部分被视为要显式传递给<code class="eh lv lw lx lm b">tpl</code>函数的字符串。</p><p id="93c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果需要在加载到配置映射中的文件的条目中使用发布名称前缀，也会出现类似的问题。将整个文件加载到配置图的典型方式是使用<code class="eh lv lw lx lm b">.Files.Get</code>。但是，像values.yaml一样，以这种方式加载的文件内容不是模板的一部分，因此不能在其中使用模板指令。允许在文件中使用模板指令的是用. Files.Get加载<a class="ae kd" href="https://stackoverflow.com/questions/47595295/how-do-i-load-multiple-templated-config-files-into-a-helm-chart/52009992#52009992" rel="noopener ugc nofollow" target="_blank">文件内容，并将其传递给</a> <code class="eh lv lw lx lm b"><a class="ae kd" href="https://stackoverflow.com/questions/47595295/how-do-i-load-multiple-templated-config-files-into-a-helm-chart/52009992#52009992" rel="noopener ugc nofollow" target="_blank">tpl</a></code>。那么配置图的数据部分将包含如下条目:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="95b4" class="lq kf hu lm b fv lr ls l lt lu">conf_file1: {{ tpl (.Files.Get "files/conf_file1") . | quote }}</span></pre><p id="b4c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者为了载入一个秘密，我们需要用base64编码内容:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="3d86" class="lq kf hu lm b fv lr ls l lt lu">conf_file1: {{ tpl (.Files.Get "files/conf_file1") . | b64enc | quote }}</span></pre><p id="61d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不是只有一个文件可以使用 <code class="eh lv lw lx lm b">.Files.Glob</code>将一组<em class="ly">文件加载到配置图<a class="ae kd" href="https://www.nclouds.com/blog/simplify-kubernetes-deployments-helm-part-3-creating-configmaps-secrets/" rel="noopener ugc nofollow" target="_blank">中:</a></em></p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="a222" class="lq kf hu lm b fv lr ls l lt lu">{{ (tpl (.Files.Glob "files/*").AsConfig . ) | indent 2 }}</span></pre><p id="afbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管我们不能对<code class="eh lv lw lx lm b">AsSecret</code>应用同样的方法，因为内容会在通过<code class="eh lv lw lx lm b">tpl </code>之前被编码。要将一组文件加载到一个秘密中，我们可以使用<code class="eh lv lw lx lm b"><a class="ae kd" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/accessing_files.md#glob-patterns" rel="noopener ugc nofollow" target="_blank">Glob</a></code> <a class="ae kd" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/accessing_files.md#glob-patterns" rel="noopener ugc nofollow" target="_blank">来查找文件，使用</a> <code class="eh lv lw lx lm b"><a class="ae kd" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/accessing_files.md#glob-patterns" rel="noopener ugc nofollow" target="_blank">Get</a></code> <a class="ae kd" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/accessing_files.md#glob-patterns" rel="noopener ugc nofollow" target="_blank">来加载它们</a>:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="a01c" class="lq kf hu lm b fv lr ls l lt lu">{{ range $path, $bytes := .Files.Glob "files/*" }}<br/>{{ base $path }}: '{{ tpl ($root.Files.Get $path) . | b64enc }}'<br/>{{ end }}</span></pre><h1 id="aca1" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">3授权给我们的图表开发者伙伴</h1><p id="9447" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">在keycloak图表中使用<code class="eh lv lw lx lm b">extraEnv</code>提出了一种可能的模式，用于处理可能需要注入到图表中的其他类型的定义。例如，keycloak图表需要允许用户将keycloak图表打包到父图表中，父图表还提供用户定义的json文件，用户需要能够将该文件挂载到keycloak窗格中。图表通过<a class="ae kd" href="https://github.com/helm/charts/blob/0445fad8d8308f089f5fb6756a5570bc6d6f0bf5/stable/keycloak/templates/statefulset.yaml#L115" rel="noopener ugc nofollow" target="_blank">暴露</a>和<code class="eh lv lw lx lm b">extraVolumes</code>来支持这一点:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="f487" class="lq kf hu lm b fv lr ls l lt lu">{{- with .Values.keycloak.extraVolumes }}<br/>{{ tpl . $ | indent 8 }}<br/>{{- end }}</span></pre><p id="62b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kd" href="https://github.com/helm/charts/blob/0445fad8d8308f089f5fb6756a5570bc6d6f0bf5/stable/keycloak/templates/statefulset.yaml#L73" rel="noopener ugc nofollow" target="_blank">和</a> <code class="eh lv lw lx lm b">extraVoumeMounts</code>:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8899" class="lq kf hu lm b fv lr ls l lt lu">          volumeMounts:<br/>            - name: scripts<br/>              mountPath: /scripts<br/>{{- with .Values.keycloak.extraVolumeMounts }}<br/>{{ tpl . $ | indent 12 }}<br/>{{- end }}</span></pre><p id="79a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后用户<a class="ae kd" href="https://github.com/helm/charts/tree/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/keycloak#setting-a-custom-realm" rel="noopener ugc nofollow" target="_blank">可以</a>指向他们的秘密(包含json文件)并通过values.yaml:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2372" class="lq kf hu lm b fv lr ls l lt lu">extraVolumes: |<br/> — name: custom-secret<br/>   secret:<br/>     secretName: custom-secret<br/>extraVolumeMounts: |<br/> - name: custom-secret<br/>   mountPath: "/realm/"<br/>   readOnly: true</span></pre><p id="63f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，卷和卷装载的配置被外化为values.yaml。该图表还应用了这种模式，以允许用户向模板中注入更多的资源，如initContainers，甚至添加整个附加容器(或“sidecars”)。这种模式为图表用户提供了很大的能力和灵活性，特别是对于使用我们图表的其他图表开发人员。</p><p id="738a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当与keycloak图表显示的其他参数结合使用时，该模式会特别强大，例如图表初始化脚本中使用的<a class="ae kd" href="https://github.com/helm/charts/blob/0445fad8d8308f089f5fb6756a5570bc6d6f0bf5/stable/keycloak/templates/configmap.yaml#L19" rel="noopener ugc nofollow" target="_blank"> preStartScript </a>变量:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2fdd" class="lq kf hu lm b fv lr ls l lt lu">{{- with .Values.keycloak.preStartScript }}                           echo 'Running custom pre-start script...'                       <br/>{{ . | indent 4 }}                         <br/>{{- end }}</span></pre><p id="e212" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用户可以将他们喜欢的任何shell脚本内容注入到values.yaml中的<code class="eh lv lw lx lm b">.Values.keycloak.preStartScript </code>中。因此，这种方法使用户不仅可以设置自己的配置参数，还可以加载自己的文件，并使用这些文件运行自己的定制脚本。</p><h1 id="0824" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">4以不同的方式对外公开</h1><p id="3fe0" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">由<code class="eh lv lw lx lm b">helm create</code>生成的启动器舵图包括服务规范，但不包括入口。许多公共图表确实定义了入口资源。这需要可配置，因为用户可能不想使用入口。所以<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/rabbitmq/templates/ingress.yaml#L1" rel="noopener ugc nofollow" target="_blank"> rabbitmq图表</a>和其他许多图表一样，用以下内容包装了它的整个入口资源定义:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2231" class="lq kf hu lm b fv lr ls l lt lu">{{- if .Values.ingress.enabled }}<br/>...<br/>{{-end}</span></pre><p id="d28b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这符合官方图表回购的<a class="ae kd" href="https://github.com/helm/charts/blob/master/REVIEW_GUIDELINES.md#ingress" rel="noopener ugc nofollow" target="_blank">审查指南</a>，该指南建议默认情况下应禁用入口。</p><p id="e20e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，rabbitmq图表需要提供是否通过设置基于<a class="ae kd" href="https://github.com/helm/charts/blob/cbd5e811a44c7bac6226b019f1d1810ef5ee45fa/stable/rabbitmq/templates/ingress.yaml#L19" rel="noopener ugc nofollow" target="_blank">主机的</a>入口规则来公开它的选项:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6278" class="lq kf hu lm b fv lr ls l lt lu">rules:<br/>  {{- if .Values.ingress.hostName }}<br/>  - host: {{ .Values.ingress.hostName }}<br/>    http:<br/>  {{- else }}<br/>  - http:<br/>  {{- end }}</span></pre><p id="011a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(实际上，用户可能希望多个主机路由到服务，因此<a class="ae kd" href="https://github.com/helm/charts/blob/master/REVIEW_GUIDELINES.md#ingress" rel="noopener ugc nofollow" target="_blank">审查指南</a>建议对主机使用范围函数。rabbitmq图表只提供了一个主机。)</p><p id="2fa1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">rabbitmq图表还允许不设置主机(上面的else条件)。在这种情况下，用户很可能会覆盖路径(这样rabbitmq就在一个唯一的路径上公开，与其他公开的服务不同):</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="209d" class="lq kf hu lm b fv lr ls l lt lu">- path: {{ default "/" .path }}<br/>  backend:<br/>    serviceName: {{ template "rabbitmq.fullname" . }}<br/>    servicePort: {{ .Values.rabbitmq.managerPort }}</span></pre><p id="d4a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样特别重要的是，用户可以灵活地在入口资源上设置注释，因为这些注释用于控制路由配置选项。<a class="ae kd" href="https://github.com/helm/charts/blob/master/REVIEW_GUIDELINES.md#ingress" rel="noopener ugc nofollow" target="_blank">审核指南</a>建议通过<code class="eh lv lw lx lm b">toYaml</code>对此予以支持:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6a6a" class="lq kf hu lm b fv lr ls l lt lu">{{- with .Values.ingress.annotations }}<br/> annotations:<br/>{{ toYaml . | indent 4 }}<br/>{{- end }}</span></pre><p id="7adf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这允许图表的用户在values.yaml中设置注释，例如:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1861" class="lq kf hu lm b fv lr ls l lt lu">annotations:<br/>  kubernetes.io/ingress.class: nginx<br/>  nginx.ingress.kubernetes.io/rewrite-target: /</span></pre><p id="1283" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，用户可以通过values.yaml在入口设置他们需要的任何注释，而图表不需要知道这些注释可能是什么。仅仅公开这些注释就相当于在入口路由上应用类似脚本的配置。例如，使用nginx入口，用户可以通过配置片段以自定义方式应用规则来设置标头:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="da48" class="lq kf hu lm b fv lr ls l lt lu">annotations:<br/>  kubernetes.io/ingress.class: nginx<br/>  nginx.ingress.kubernetes.io/rewrite-target: /<br/>  nginx.ingress.kubernetes.io/configuration-snippet: |<br/>     more_set_headers 'Access-Control-Allow-Origin: $http_origin';                            </span></pre><h1 id="7508" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">我们从舵图艺术中学到了什么</h1><figure class="lh li lj lk fq mb fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/ff8d6072a9c0d962fb1e578e14e4574f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/0*oOXN1R9rF3Lblnzn"/></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">This <a class="ae kd" href="https://www.pexels.com/photo/grayscale-photo-of-man-wearing-black-dress-shirt-with-hat-sitting-on-folding-armchair-beside-family-sketch-1046123/" rel="noopener ugc nofollow" target="_blank">guy</a> is just chillin because his charts are so good</figcaption></figure><p id="e1fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个好的掌舵图需要预测用户需要什么样的灵活性。更多的灵活性往往意味着更多的复杂性或更高的抽象性，或者两者兼而有之。这会妨碍图表的可读性，并给图表用户带来更多负担。挑战在于选择最适合用户对特定图表的需求的工具。</p><p id="23d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有其他我们没有涉及到的问题需要平衡，比如测试和安全性。这只是官方图表的一个特定部分。我试图把重点放在那些对我特别有帮助的模式上，以确保用户可以用你的图表做他们需要做的事情。在我为<a class="ae kd" href="https://github.com/Activiti" rel="noopener ugc nofollow" target="_blank"> Activiti </a>项目制作<a class="ae kd" href="https://github.com/Activiti/activiti-cloud-charts/" rel="noopener ugc nofollow" target="_blank">舵轮图</a>的经历中，Kubernetes官方海图对我帮助极大。希望这篇文章中的解释可以帮助鼓励其他人深入官方回购，并从其图表中获得灵感。</p></div></div>    
</body>
</html>