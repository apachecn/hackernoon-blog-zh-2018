<html>
<head>
<title>If I were to select the worst Linux syscall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果我选择最差的Linux系统调用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/if-i-were-to-select-the-worst-linux-syscall-669529b233e9?source=collection_archive---------8-----------------------#2018-09-20">https://medium.com/hackernoon/if-i-were-to-select-the-worst-linux-syscall-669529b233e9?source=collection_archive---------8-----------------------#2018-09-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="19ed" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我的选择是精选</h2></div><p id="467b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢我的博客，你可以在我的博客上阅读这篇文章。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/16a18dc40e669768cb0f49dfafa27fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giKw-aB5BYgnAjdADwGiTQ.png"/></div></div></figure><p id="bb83" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Select、poll和epoll都是实现类似目的的<a class="ae kf" href="https://hackernoon.com/tagged/linux" rel="noopener ugc nofollow" target="_blank"> Linux </a>系统调用，它们提供了一种高效的异步I/O方式</p><p id="47ff" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">换句话说，它们等待某个事件在文件描述符上发生。通常，文件描述符代表一个网络套接字，我们正在等待数据从另一台机器通过TCP或UDP传输过来。</p><p id="620e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在一个我们通过网络做很多事情的时代，这些asyncio系统调用对大多数程序员来说至关重要。</p><p id="0f55" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，很少有开发者真正听说过它们中的任何一个。实际上直接使用它们的人更少。尽管如此，几乎每个使用Node、Ruby、Go或Python的人都在不知不觉中依赖它们。</p><p id="907a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们大多数人可能更喜欢在大多数时间避免直接使用系统调用。然而，我们使用的库包装器通常是微不足道的，只要我们需要降低一些性能或灵活性，我们可以在任何时候依靠本机接口。</p><p id="2296" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我敢打赌，几乎所有正派的开发人员都会对他们的Linux线程知识有足够的信心，毫不犹豫地使用pthread.h。我还敢打赌，如果这些开发人员不得不快速创建一个无错误的基于epoll的应用程序，他们几乎100%都会冒冷汗。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><p id="05c2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我认为我们应该看看Linux并发性宝库中的另一个生物，线程。</p><p id="d9cb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看3个使用线程的例子。首先，使用Python(一种“高级”语言)和Rust(一种“低级”语言)的标准库，然后使用Linux为其第一类公民c提供的本机接口。</p><p id="c15a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">巨蟒</strong></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="9b88" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="lb">注意:虽然有人可能听说Python线程由于GIL而不是“真正的线程”,但它们仍然在实现中使用pthread。在python的非GIL实现中，它们可以像“真正的”线程一样工作。</em></p><p id="43dd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">生锈</strong></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="33e2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> C (POSIX API) </strong></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="ea4a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">显然，使用原生pthread API稍显不便，但是pthread上的包装器仍然非常类似于直接使用它，它们只是稍微简化了一下。如果你理解了如何使用任何语言的标准库中的线程，你就会明白如何使用本地API。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><p id="ae25" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，让我们看看Python和Rust中异步I/O的“最低级别”方法，然后让我们看看如何使用本机API来实现它。</p><p id="e4fe" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个例子中，我们将看看通过TCP与两个不同的地址同时通信。</p><p id="61c8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> Python </strong></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="9030" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">生锈</strong></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="kz la l"/></div></figure><p id="11e2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里，我应该提一下我曾有过一点欺骗。因为futures和tokio不是Rust标准库的一部分。然而，rust还没有一个asyncio标准，围绕实现该标准的讨论主要围绕着将tokio &amp; futures集成到标准库中。所以rust中asyncio TCP客户端的最终版本很有可能与上面的代码非常相似。</p><p id="ed3d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> C语言(POSIX API) </strong></p><p id="e762" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">问题来了。</p><p id="8e13" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我很乐意向您展示使用poll、epoll或select通过TCP同步完成两个请求的惯用方法，但我可能会出错。此外，代码会很长，很难浏览。</p><p id="701b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里有一个<a class="ae kf" href="https://gist.github.com/gonzus/f811f4d0926076acccd7" rel="noopener ugc nofollow" target="_blank">非常全面的TCP </a>客户端，它使用轮询。注意到问题了吗？它跨越了700行代码。</p><p id="f0e9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，这部分是C语言的错误和本地网络功能的错误。但是<a class="ae kf" href="http://www.cs.tau.ac.il/~eddiea/samples/IOMultiplexing/TCP-client.c.html" rel="noopener ugc nofollow" target="_blank">编写一个简单的TCP客户端</a>并不难，这是我们必须包含一个asyncio的部分，这使得它不可能正确。</p><p id="3a1e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我向任何有不同想法的读者挑战，让他们给我找出一个使用poll的惯用例子，它甚至接近Rust和Python方法的简单性。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/5df674b18c5dcfabd38f495c577c2520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*U2OWYYwMKvPmfx4L1atn3A.jpeg"/></div></figure><h1 id="e527" class="ld le hu bd lf lg lh li lj lk ll lm ln ja lo jb lp jd lq je lr jg ls jh lt lu dt translated">如何修复异步系统调用</h1><p id="f6d3" class="pw-post-body-paragraph jj jk hu jl b jm lv iv jo jp lw iy jr js lx ju jv jw ly jy jz ka lz kc kd ke hn dt translated">如果上面的C代码对您来说有点难读，让我用一些更小的代码片段来为您解释异步系统调用的用法:</p><ul class=""><li id="c144" class="ma mb hu jl b jm jn jp jq js mc jw md ka me ke mf mg mh mi dt translated">创建一个非阻塞的文件描述符，<a class="ae kf" href="https://gist.github.com/gonzus/f811f4d0926076acccd7#file-tcp-client-poll-c-L598" rel="noopener ugc nofollow" target="_blank">，如这里看到的</a>。</li><li id="3dda" class="ma mb hu jl b jm mj jp mk js ml jw mm ka mn ke mf mg mh mi dt translated">遍历非阻塞文件描述符，查看其中是否发生了任何事件。<a class="ae kf" href="https://gist.github.com/gonzus/f811f4d0926076acccd7#file-tcp-client-poll-c-L529" rel="noopener ugc nofollow" target="_blank">如此处所示，尽管只有一个fd </a>。</li><li id="6c92" class="ma mb hu jl b jm mj jp mk js ml jw mm ka mn ke mf mg mh mi dt translated">如果事件已经发生，处理它然后进行循环。如果什么都没发生，继续。</li></ul><p id="619c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了理解如何编写基于poll/epoll/select的代码和编写它是两个完全不同的概念之外，这似乎不是一个糟糕的接口。</p><p id="b1f5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使假设接口更简单，对于使用任何其他asyncio库的人来说，它仍然是完全陌生的。如果您想使用原生API，基本上是从零开始。</p><p id="ca69" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="lb">要是有更简单的方法就好了……</em></strong></p><p id="8b68" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗯，有一个，几乎所有其他库处理asyncio的方式，使用回调和/或未来。这是每一种具有原生asyncio支持的其他语言的方式，比如Go、Python和Node。所有asyncio库都是这样做的，不管是C、C++、Java、Scala、Ruby、Perl、Php、Rust还是其他语言的库。</p><p id="d9f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是，对于Linux来说，将所有的复杂性隐藏在引擎盖下是合适的吗？拥有一个用户友好的API，让那些不懂真正的<a class="ae kf" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>美学的肮脏农民可以使用。</p><p id="ba42" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对此我回答说，请看pthread。同样，我们使用<code class="eh mo mp mq mr b">pthread_create</code>而不是<code class="eh mo mp mq mr b">clone</code>系统调用。通过函数指针的魔力，我们可以在异步调用上有一个用户友好的包装，而不会失去任何功能。</p><p id="001d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当然，可能存在需要使用原始系统调用的边缘情况，类似于可能需要使用<code class="eh mo mp mq mr b">clone</code>而不是<code class="eh mo mp mq mr b">fork</code>或<code class="eh mo mp mq mr b">pthread</code>的边缘情况。</p><p id="26f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是对于99.9%的情况，我认为我们会更乐意使用这样的包装:</p><p id="9775" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mo mp mq mr b">poll_events(underlying_syscall, fds_array, callback)</code></p><p id="7683" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中回调函数将被标准化以接收文件描述符和特定于底层syscall的任何附加参数。例如<code class="eh mo mp mq mr b">poll</code>的两个shorts(事件和事件)。</p><p id="c7d6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者这个接口甚至可以为同一个函数提供一个标准化的方法来处理这三个系统调用。</p><p id="2a39" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">无论哪种方式，我都不想在这里规定原生Linux异步接口的设计。我只是建议我们可能需要一个更简单的。</p><p id="838c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果人们不能使用你的API，也许这是你的API是垃圾的标志，而不是你的用户是愚蠢的标志。如果面包黄油系统调用只有少数库维护者理解和使用，这意味着你需要一个更好的API。</p><p id="6eca" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">自从select出现以来，有两次机会提供更好的界面。一个是引入poll的时候，另一个是引入epoll的时候。然而，我们被3种繁琐的asyncio机制所困，它们的API和实现略有不同，都同样无法使用。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><p id="c4ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您喜欢这篇文章，您可能还会喜欢:</p><ul class=""><li id="29d8" class="ma mb hu jl b jm jn jp jq js mc jw md ka me ke mf mg mh mi dt translated"><a class="ae kf" href="https://blog.cerebralab.com/#!/a/Encouraging%20the%20Wrong%20State%20of%20Mind%20for%20Creating%20Good%C2%A0Code" rel="noopener ugc nofollow" target="_blank">明智对待所有权</a></li><li id="dbbc" class="ma mb hu jl b jm mj jp mk js ml jw mm ka mn ke mf mg mh mi dt translated"><a class="ae kf" href="https://blog.cerebralab.com/#!/a/Please,%20reinvent%20the%20wheel" rel="noopener ugc nofollow" target="_blank">请重新发明轮子</a></li></ul></div></div>    
</body>
</html>