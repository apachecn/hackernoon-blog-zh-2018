<html>
<head>
<title>Let’s get this `this` once and for all</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们一劳永逸地解决这个问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-get-this-this-once-and-for-all-f59d76438d34?source=collection_archive---------3-----------------------#2018-09-21">https://medium.com/hackernoon/lets-get-this-this-once-and-for-all-f59d76438d34?source=collection_archive---------3-----------------------#2018-09-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk it iu iv iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff is"><img src="../Images/5d550da633ffea24ac8b37d0f125f95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d44hN47JYBt4H91xHyjuwg.jpeg"/></div></div><figcaption class="jd je fg fe ff jf jg bd b be z ek">Credits: Pixabay.com</figcaption></figure><p id="3f91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你对JavaScript的了解可以通过你对<em class="kf">这个</em>的理解得到很好的判断。人们觉得难以理解的事实是，因为它在多种多样的场景中使用。</p><p id="b709" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们一劳永逸地纠正他们。</p><p id="e03f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我从字面意义上来谈论这个<em class="kf">这个</em>，它仅仅意味着——我面前的这个东西。“这件夹克很酷”，我妹妹手里拿着那件夹克说道。我回答说，“不，这个更好！”我指的是我身边的夹克，她指的是她身边的那件，因此在各自的陈述中使用了<em class="kf"> this </em>。</p><p id="76ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该值取决于<br/> 1。执行上下文<br/> 2。祈祷</p><p id="2d3f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">执行上下文</strong></p><p id="8611" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">执行上下文是代码运行的环境。例如，一个函数的局部变量只能在该函数内部访问，而不能在函数外部访问。这被称为功能级作用域或本地执行上下文。在全局范围(任何函数之外)声明的变量在所有底层函数中都是可访问的。这被称为<em class="kf">全局执行上下文</em>。</p><p id="6349" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们考虑这个例子来理解他们两个之间的区别-</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kg"><img src="../Images/8d215c8b6ca7362b8f21fb37e173e16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VhKSBKLQQzrHxLyfxP42A.png"/></div></div></figure><p id="3880" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">全局执行上下文中<em class="kf">这个</em>的值默认为<em class="kf">窗口</em>对象。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kl"><img src="../Images/eb6bcff8982017ed546d437e281fff4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7p5F9rCFV5pfLQdFekowQ.png"/></div></div></figure><p id="34d4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">任何本地上下文中的值都取决于函数被调用的方式。</p><p id="803e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> I .在全局上下文中调用函数会将其<em class="kf"> this </em>值作为</strong> <code class="eh km kn ko kp b"><strong class="jj hv">window</strong></code></p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kq"><img src="../Images/44d735a39d2f7c1dd592db9f9f521b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaCt3c8nI4RqHlnilxcVsg.png"/></div></div></figure><p id="55e4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">二。调用在严格模式下运行JavaScript语句的函数会使<em class="kf"> this </em>成为<em class="kf"> undefined </em> </strong></p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kr"><img src="../Images/d6e8ac060ff9d5e741b74dcbbdebd80e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JuNqMHLVYMVXGYcIvE7yig.png"/></div></div></figure><p id="f5b2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> III。调用对象内部的函数</strong></p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff ks"><img src="../Images/3481eb9532f2ad521fcd379f064f52a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzyhBUSs8VwBUV65UBvGvQ.png"/></div></div></figure><p id="f281" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">功能<em class="kf"> </em> <code class="eh km kn ko kp b">add</code> <em class="kf"> </em>是对象<em class="kf"> </em> <code class="eh km kn ko kp b">obj</code>上的属性之一。当我们引用<code class="eh km kn ko kp b">obj</code> <em class="kf"> </em>作为<code class="eh km kn ko kp b">obj.add()</code>来调用<em class="kf"> add </em>时，它在<code class="eh km kn ko kp b">obj</code>的上下文中被调用。属性<code class="eh km kn ko kp b">a</code> &amp; <code class="eh km kn ko kp b">b</code>在<code class="eh km kn ko kp b">obj</code> <em class="kf">、</em>的上下文中具有确定的值，从而定义了<code class="eh km kn ko kp b">obj.add()</code>的结果。</p><p id="5599" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh km kn ko kp b">cacheAdd</code>变量存储<code class="eh km kn ko kp b">add</code>函数的引用。如果我们在稍后阶段执行这个函数，它将在调用它的上下文中运行。在我们的例子中，我们在全局上下文中调用<code class="eh km kn ko kp b">cacheAdd</code>，所以它将有一个全局对象作为<code class="eh km kn ko kp b">this</code>引用。由于<code class="eh km kn ko kp b">a</code>和<code class="eh km kn ko kp b">b</code>没有在全局上下文中定义，我们将<code class="eh km kn ko kp b">a+b</code>的值作为<code class="eh km kn ko kp b">NaN</code>。</p><p id="3621" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了证明这一点，我们先在全局背景下定义一下<code class="eh km kn ko kp b">a</code>和<code class="eh km kn ko kp b">b</code>。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kt"><img src="../Images/be99a7274ccf0e2fd9fc579d47003001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nD5qhSQeSids2ojIdJHzLg.png"/></div></div></figure><p id="32b4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当obj中定义的<code class="eh km kn ko kp b">a</code>和<code class="eh km kn ko kp b">b</code>的值分别为1 &amp; 2时，<code class="eh km kn ko kp b">obj.add()</code>的计算结果为3。当我们将<code class="eh km kn ko kp b">add</code>缓存在一个变量中然后在全局上下文中执行它之后运行它时，由于全局上下文中a &amp; b的值分别为3 &amp; 4，所以它的计算结果为7。因此，使用<code class="eh km kn ko kp b">this</code>的函数可能会给出不同的结果，这取决于它执行的上下文。</p><p id="2446" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们试试另一个有趣的例子——</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff ku"><img src="../Images/b1382a1c440f6dde143ffa1375101e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdXYaDQZZ28u5UXnYI6SUQ.png"/></div></div></figure><p id="47d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，add函数返回另一个函数，并且在这个内部函数中执行<code class="eh km kn ko kp b">a+b</code>的值。<code class="eh km kn ko kp b">obj.add()</code>将返回一个有一个<code class="eh km kn ko kp b">console</code>语句的函数。因此，我们必须执行这个返回的函数，以便获得a &amp; b的和。但是这个返回的函数(在执行<code class="eh km kn ko kp b"><em class="kf">obj.add()</em></code>时返回)将在全局上下文中运行，因此a+b的值计算为7(全局上下文中a &amp; b的值分别为3 &amp; 4)。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kv"><img src="../Images/a1871dfebaf9795ec2ada824af30c059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgnxaiowvzjtmPNoBXK5vg.png"/></div></div></figure><p id="62af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里，add函数在500ms超时后打印a &amp; b的值。<code class="eh km kn ko kp b">setTimeout</code>在全局环境下运行。</p><p id="ec39" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么setTimeout在全局上下文中运行？(我会在下一篇文章中详细解释。)</p><p id="f951" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> <em class="kf">这个</em>引用了调用函数</strong>的即时对象</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kw"><img src="../Images/dd303fe53844aafb358e16c3e7d587e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPtE9qe5HR9x76GbsVoHhg.png"/></div></div></figure><p id="1840" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里，<em class="kf"> parentObj </em>有<em class="kf"> childObj </em>作为属性之一，add函数是在<em class="kf"> childObj </em>上定义的。当我们调用add作为<em class="kf">parent obj . child obj . add()</em>时，add函数接受<em class="kf"> childObj </em>的<em class="kf"> this </em>引用，并且变量a &amp; b不能从<em class="kf"> childObj </em>的本地上下文中访问。因此a &amp; b的值是<em class="kf">未定义的</em>。</p><p id="3bcf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">链接到原型链</strong></p><p id="1d28" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们实例化<em class="kf"> parentObj </em>来创建<em class="kf"> childObj </em>，那么它的属性将可以在<em class="kf"> childObj </em>上下文中访问。</p><p id="9c5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">使用<em class="kf">object . create</em>T20】</strong></p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kx"><img src="../Images/b8d410d827371a01f157591f53c95243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOJTaDvflpJmD_TA0J_jHQ.png"/></div></div></figure><p id="7fa9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当add函数在<em class="kf"> childObj </em>的上下文中被调用时，它首先尝试在<em class="kf"> childObj </em>的上下文中寻找a，b &amp; c的值，如果这些值中的任何一个是<em class="kf">未定义的</em>，它将查找其父上下文，在本例中是<em class="kf"> parentObj </em>。</p><p id="64fa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">使用<em class="kf">新的</em>操作符</strong></p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff ky"><img src="../Images/c8de9bb611b1bf58bad4a46850cb20a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQWlHxe--WBrWPoaCZ0OWQ.png"/></div></div></figure><p id="8018" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，父属性在子上下文中可用。正如我们在后面的控制台语句中看到的，子级的构造函数被定义为父级。因此，它首先检查被调用的上下文中的值，然后查找它的原型链。</p><p id="9b40" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这不是火箭科学！</p><p id="71d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">默认情况下，代码在全局上下文中运行，即它可以访问在<code class="eh km kn ko kp b">window</code>对象的上下文中定义的变量。在上面的每一个例子中，我们只是将上下文限制在对象上。与此相关的所有操作都将以与上下文为<code class="eh km kn ko kp b">window</code>时完全相同的方式执行。即使在全局上下文中，如果没有定义任何值，它也会查找原型链。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kz"><img src="../Images/45648db83e0f22089ba5629a58c7ddfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VH8woYlYDfKj92sRjlZXtg.png"/></div></div></figure><p id="b668" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以看到，<code class="eh km kn ko kp b">toString</code>函数是在<code class="eh km kn ko kp b"><em class="kf">obj</em></code>的<code class="eh km kn ko kp b"><em class="kf">__proto__</em> </code>属性中定义的，这意味着它是在<em class="kf">对象</em>的原型上定义的(因为<code class="eh km kn ko kp b">obj</code>是通过将<code class="eh km kn ko kp b">new</code>运算符应用于<em class="kf">对象</em>而创建的)。由于<code class="eh km kn ko kp b">toString</code> <em class="kf"> </em>没有在<code class="eh km kn ko kp b">obj</code>的上下文中定义，所以它查找其原型链。</p><p id="b882" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们来解决一个有趣的问题——</p><p id="9fe1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我姐姐顽固地拒绝与我分享糖果，并支持她的主张，她说，她是这块糖果的主人。</p><p id="6e30" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是她的糖果—</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff la"><img src="../Images/65bb7fa723dda3813bcff74272cff0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwVeY3_Q6cZ1dFyN4tNK0Q.png"/></div></div></figure><p id="3aa1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，我不得不修改她的函数<code class="eh km kn ko kp b">whosCandyIsThis</code>正在使用的<code class="eh km kn ko kp b">this</code>引用。这个蹒跚学步的小孩不知道JavaScript是一种非常规的语言。你总是可以按你想要的方式修补它。</p><p id="24a8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">调用，应用&amp;绑定—我来了！</strong></p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff lb"><img src="../Images/f089ac89a26b61720006d4c52677a60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CT4ENgIZUzZaYzu4BPs5zA.png"/></div></div></figure><p id="211e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了这3个漂亮的函数，你可以修改<em class="kf">这个</em>引用的值。在上例中，<em class="kf"> </em> <code class="eh km kn ko kp b">candy.whosCandyIsThis.call(myCandy)</code>将<code class="eh km kn ko kp b">whosCandyIsThis</code>函数的<code class="eh km kn ko kp b">this</code> <em class="kf"> </em>引用修改为<em class="kf"> </em> <code class="eh km kn ko kp b">myCandy</code>。</p><p id="fc5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">打电话是怎么回事？</strong> <br/> <code class="eh km kn ko kp b">call</code>显式传递<code class="eh km kn ko kp b">this</code>对函数的引用。在这种情况下，它告诉<code class="eh km kn ko kp b">whosCandyisThis</code>函数使用<code class="eh km kn ko kp b">this</code>作为<code class="eh km kn ko kp b">myCandy</code>。</p><p id="6de5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">调用的第一个参数是<code class="eh km kn ko kp b">this</code>引用，如果我们必须传入任何额外的参数，你可以这样做</p><pre class="kh ki kj kk fq lc kp ld le aw lf dt"><span id="f263" class="lg lh hu kp b fv li lj l lk ll"><em class="kf">candy.whosCandyisThis.call(myCandy, true)`</em></span></pre><p id="b005" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们再考虑一个例子:</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kx"><img src="../Images/3ae62d02bd5cd31c375dcf8c17b0b67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeFhtZzeAkGbCqWd6n62Dw.png"/></div></div></figure><p id="e49a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里，我们将<code class="eh km kn ko kp b">this</code>引用显式传递给在hotel对象中定义的<code class="eh km kn ko kp b">displayMenu</code>函数，以相应地显示菜单。(这不是很酷吗？)</p><p id="ba99" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是如果我想根据用户的位置显示菜单呢？为此，我们将传递一个额外的参数<em class="kf"> </em> <code class="eh km kn ko kp b">location</code>给<code class="eh km kn ko kp b">displayMenu</code>函数。让我们修改上面的代码来适应我们的需求。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff ky"><img src="../Images/0279042c569664e316270ff97dcacefc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAyRARcgORGKptEEsZYEYA.png"/></div></div></figure><p id="aaae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh km kn ko kp b">call</code>的第一个参数是<code class="eh km kn ko kp b">this</code>引用，然后您可以传入任意数量的参数。<code class="eh km kn ko kp b">displayMenu</code>功能现在可以很好地按照<em class="kf">位置</em>参数显示菜单项列表。(听起来不错？)</p><p id="7363" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh km kn ko kp b">apply</code>的操作方式与<code class="eh km kn ko kp b">call</code>相同，唯一的区别是我们传递参数的方式。Apply将第一个参数作为<em class="kf">接受，这个</em>引用与call的引用相同，但其他参数将作为数组传递。</p><p id="19cc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一个可以修改<code class="eh km kn ko kp b">this</code> <em class="kf"> </em>参照的功能是<code class="eh km kn ko kp b">bind</code>。与返回函数结果的<code class="eh km kn ko kp b">call</code>和<code class="eh km kn ko kp b">apply</code> <em class="kf"> </em>不同，<em class="kf"> </em> <code class="eh km kn ko kp b">bind</code>返回函数。并且这个返回的函数可以在以后的任何阶段被调用。它将在显式传递的有界参数的上下文中运行。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff ky"><img src="../Images/34b384a517ca915ebc828f8808e18802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0d4Z7dOlgBwb7tcJjk51w.png"/></div></div></figure><p id="8dac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh km kn ko kp b"><em class="kf">hotel.displayMenu.bind(ccd)</em></code>返回具有<code class="eh km kn ko kp b">ccd</code>的<code class="eh km kn ko kp b">this</code>引用的函数。当我们运行<code class="eh km kn ko kp b">boundFunction</code>时，它在<code class="eh km kn ko kp b">ccd</code> <em class="kf"> </em>的上下文中运行，因此打印位置a的Espresso</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff ky"><img src="../Images/3d4ef594f39b1bb229bb027b6f374f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRzRtdpQ9mH030RU_wJlPg.png"/></div></div></figure><p id="c233" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我试着用我的直觉做实验。如果我将一个已经绑定的函数绑定到其他引用，这个函数会在后面绑定的上下文中运行吗？如果这是真的，我可以无休止地这样做，用我所有的力量不断改变这个参照物！这不是真的。一个函数只能绑定一次。在上面的例子中，我试图用<em class="kf"> pizzaCentre </em>再次绑定有界函数，但是当我执行这个函数时，它打印了之前的结果，这意味着它的引用仍然指向第一个绑定(<code class="eh km kn ko kp b">ccd</code>)。</p><p id="46e2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，JavaScript是一种非常规的语言。如果有按照你的意愿修改任何东西的自由，就有守卫保护完整性。一个这样的杰作是我们可爱的箭头功能。</p><p id="c928" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是它的工作原理。简单明了。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff kx"><img src="../Images/bb839346a09a6042257a7473a2b7d14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPhb0T2A3ZSi87Chjz1blA.png"/></div></div></figure><p id="bfdc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么我们要在这篇文章中讨论箭头函数呢？他们有什么特别之处？</p><p id="ce21" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在arrow函数中，<code class="eh km kn ko kp b">this</code>的值是其封闭词法上下文<br/> <em class="kf">的值，词法上下文是块级作用域。</em> <br/>它不随<code class="eh km kn ko kp b">call</code>、<code class="eh km kn ko kp b">apply</code>或<code class="eh km kn ko kp b">bind</code> <em class="kf">而变化。</em></p><p id="f64c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">箭头函数维护其封闭词法上下文的绑定。</p><figure class="kh ki kj kk fq iw fe ff paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="fe ff lm"><img src="../Images/6900b98858cf8cebf555d5f98e91de08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaLEqvBTD4C1OWqHYZyswg.png"/></div></div></figure><p id="76b8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">黑纱！这只肥箭拿走了我的糖果。</p><p id="b2e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以看到，<code class="eh km kn ko kp b">whosCandyIsThis</code>被定义为箭头函数。因此它将保持其<em class="kf">词汇上下文</em>的绑定。在实例化糖果时，<code class="eh km kn ko kp b">niks</code>为她的糖果设置所有者和口味。<code class="eh km kn ko kp b">whosCandyIsThis</code> <em class="kf"> </em>函数以<code class="eh km kn ko kp b">niks</code>引用为界。</p><p id="ea02" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，当我试图通过使用call、apply或bind传递这个引用来显式调用它时，它不起作用。无论如何，不能更改<code class="eh km kn ko kp b">niks.whosCandyIsThis</code>函数的绑定！</p><p id="a6be" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能会喜欢我以前写的关于服务人员的文章—</p><p id="463f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">服务人员基础</strong>——<a class="ae ln" href="https://hackernoon.com/service-workers-62a7b14aa63a" rel="noopener ugc nofollow" target="_blank">https://hackernoon.com/service-workers-62a7b14aa63a</a></p><p id="2307" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">构建口袋妖怪App评估浆果的力量&amp;服务人员</strong>—<a class="ae ln" href="https://hackernoon.com/building-pokemon-app-to-evaluate-the-power-of-berries-service-worker-176d7c4e70e3" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/Building-Pokemon-App-to-evaluate-the-power-of-Berries-Service-Worker-176 D7 C4 e 70 e 3</a></p></div></div>    
</body>
</html>