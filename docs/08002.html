<html>
<head>
<title>Migrating from Hyperledger Composer to Convector Framework — Marbles Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Hyperledger Composer迁移到Convector框架Marbles示例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/migrating-from-hyperledger-composer-to-convector-framework-marbles-example-13a24a74faad?source=collection_archive---------8-----------------------#2018-09-21">https://medium.com/hackernoon/migrating-from-hyperledger-composer-to-convector-framework-marbles-example-13a24a74faad?source=collection_archive---------8-----------------------#2018-09-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3708c3db5b5424d9605d44a0f2ac998d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKA0eyB1ckmSUIyhXryCxA@2x.png"/></div></div></figure><p id="38a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几周前，IBM <a class="ae ka" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>团队的首席工程师西蒙·斯通宣布<a class="ae ka" rel="noopener" href="/worldsibu/hyperledger-composer-has-been-put-on-pause-what-are-your-options-now-41cc63026161"> IBM将大幅减少其在Hyperledger Composer项目</a>中的工作，这让许多拥有现有应用程序的开发者<a class="ae ka" rel="noopener" href="/worldsibu/hyperledger-composer-has-been-put-on-pause-what-are-your-options-now-41cc63026161">处于一种不明朗的局面，不知道下一步该做什么</a>。</p><p id="bc8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好消息是，在<a class="ae ka" href="https://worldsibu.io" rel="noopener ugc nofollow" target="_blank"> WorldSibu </a>我们一直致力于一个智能合约框架，该框架<strong class="je hv">在Hyperledger Fabric </strong>中本地运行，因此您不必考虑管理与Fabric直接通信的复杂性，但仍然可以在其上运行本地节点JS链码。此外，在此基础上，我们正在构建几个工具，以使开发人员的生活更加轻松，比如一个开箱即用的开发环境，就像您过去在<a class="ae ka" href="https://hackernoon.com/tagged/composer" rel="noopener ugc nofollow" target="_blank"> Composer </a>中工作一样。</p><blockquote class="kb"><p id="779e" class="kc kd hu bd ke kf kg kh ki kj kk jz ek translated">现在Convector已经支持Hyperledger Fabric，我们计划很快增加对多个区块链技术的支持，敬请关注！</p></blockquote><p id="f9b7" class="pw-post-body-paragraph jc jd hu je b jf kl jh ji jj km jl jm jn kn jp jq jr ko jt ju jv kp jx jy jz hn dt translated">在这个例子中，我将向您展示如何轻松地从Composer迁移到<a class="ae ka" href="https://worldsibu.io/convector" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Convector </strong> </a>。这不需要太多的努力就可以做到，因为我们有非常相似的概念。</p></div><div class="ab cl kq kr hc ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hn ho hp hq hr"><p id="1251" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">两者的第一个区别是语言。Composer决定使用其定制设计的语言来定义智能合约的不同部分。另一方面，Convector是使用<a class="ae ka" href="http://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> Typescript </a>编写的，这是一种基于Javascript的超级set语言，由于其丰富的特性，如可选的强类型和抽象语法树(AST)生成来创建围绕代码的工具，它已经获得了广泛的关注。</p><p id="e562" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Composer中，业务网络模型基本上由三个组件定义:</p><ul class=""><li id="a728" class="kx ky hu je b jf jg jj jk jn kz jr la jv lb jz lc ld le lf dt translated"><strong class="je hv">资产</strong>:房屋和房源</li><li id="3ab9" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><strong class="je hv">参与者:</strong>买家和房主</li><li id="b658" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><strong class="je hv">交易:</strong>买卖房屋，创建和关闭列表</li></ul><p id="d7c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们设计Convector时，我们在这里停下来想:资产和参与者基本上是由不同属性复合而成的模型，甚至，参与者有时可以充当执行某个动作的人，或者该动作被执行的人！</p><p id="425a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们想让事情尽可能简单，并让开发人员能够用一个更加软件开发友好的术语来表达他们的想法，因此我们决定在框架内创建两个基本概念:</p><ul class=""><li id="f8b6" class="kx ky hu je b jf jg jj jk jn kz jr la jv lb jz lc ld le lf dt translated"><strong class="je hv">模型:</strong>对现实世界中<em class="ll">某物</em>的引用，有形或无形，描述其属性。它也可以是网络的参与者。</li><li id="a524" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated">控制器:一组关于你如何与模型互动的规则。</li></ul><p id="df80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于这两个基本概念，您可以构建链代码所需的一切，同时又有足够的灵活性以您需要的方式表达您的逻辑。</p><p id="52a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面这段代码定义了Composer中的Marbles示例。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="068c" class="lv lw hu lr b fv lx ly l lz ma">namespace org.hyperledger_composer.marbles</span><span id="5eb9" class="lv lw hu lr b fv mb ly l lz ma">enum MarbleColor {<br/>  o RED<br/>  o GREEN<br/>  o BLUE<br/>  o PURPLE<br/>  o ORANGE<br/>}</span><span id="4537" class="lv lw hu lr b fv mb ly l lz ma">enum MarbleSize {<br/>  o SMALL<br/>  o MEDIUM<br/>  o LARGE<br/>}</span><span id="9962" class="lv lw hu lr b fv mb ly l lz ma">asset Marble identified by marbleId {<br/>  o String marbleId<br/>  o MarbleSize size<br/>  o MarbleColor color<br/>  --&gt; Player owner<br/>}</span><span id="f756" class="lv lw hu lr b fv mb ly l lz ma">participant Player identified by email {<br/>  o String email<br/>  o String firstName<br/>  o String lastName<br/>}</span></pre><p id="6c82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Convector中，您可以这样写:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="ce83" class="lv lw hu lr b fv lx ly l lz ma">export enum MarbleColor {<br/>  RED,<br/>  GREEN,<br/>  BLUE,<br/>  PURPLE,<br/>  ORANGE<br/>}</span><span id="6af6" class="lv lw hu lr b fv mb ly l lz ma">export enum MarbleSize {<br/>  SMALL,<br/>  MEDIUM,<br/>  LARGE<br/>}</span><span id="17c0" class="lv lw hu lr b fv mb ly l lz ma">export class Marble extends ConvectorModel&lt;Marble&gt; {<br/>  @ReadOnly()<br/>  @Required()<br/>  public type = 'io.worldsibu.marbles.marble';</span><span id="401c" class="lv lw hu lr b fv mb ly l lz ma">  @Validate(yup.number())<br/>  @Default(MarbleSize.MEDIUM)<br/>  public size: MarbleSize;</span><span id="c658" class="lv lw hu lr b fv mb ly l lz ma">  @Validate(yup.number())<br/>  public color: MarbleColor;</span><span id="8439" class="lv lw hu lr b fv mb ly l lz ma">  @Validate(yup.string().email())<br/>  public owner: string;<br/>}</span><span id="69c9" class="lv lw hu lr b fv mb ly l lz ma">export class Player extends ConvectorModel&lt;Player&gt; {<br/>  @Required()<br/>  @ReadOnly()<br/>  public type = 'io.worldsibu.marbles.player';</span><span id="6fbb" class="lv lw hu lr b fv mb ly l lz ma">  @Validate(yup.string().email())<br/>  public id: string;</span><span id="43dc" class="lv lw hu lr b fv mb ly l lz ma">  @Validate(yup.string())<br/>  public firstName: string;</span><span id="05f7" class="lv lw hu lr b fv mb ly l lz ma">  @Validate(yup.string())<br/>  public lastName: string;<br/>}</span></pre><p id="a037" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为Convector运行在Javascript上，所以您可以使用表达式进行验证，并以一种更富于表现力的方式限制模型包含的数据。我们已经创建了一组有用的装饰器来帮助您实现这一点，并为您节省一些代码，同时保持模型的可读性(并降低风险！).一个模型必须有两个属性，一个是这个模型类的唯一标识符<strong class="je hv"> type </strong>，另一个是每个模型实例的唯一标识符<strong class="je hv"> id </strong>。如果您不指定id字段，Convector将为您声明一个字符串字段。</p></div><div class="ab cl kq kr hc ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hn ho hp hq hr"><h2 id="554a" class="lv lw hu bd mc md me mf mg mh mi mj mk jn ml mm mn jr mo mp mq jv mr ms mt mu dt translated">链码逻辑</h2><p id="b1a6" class="pw-post-body-paragraph jc jd hu je b jf mv jh ji jj mw jl jm jn mx jp jq jr my jt ju jv mz jx jy jz hn dt translated">在Composer中，链码逻辑(也称为定义数据用途的规则)位于3个不同的层:ACL、事务模型和事务功能。</p><p id="4d54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，从定义ACL(访问控制列表)中的访问权限开始:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="2377" class="lv lw hu lr b fv lx ly l lz ma">rule Default {<br/>  description: "Allow all participants access to all resources"<br/>  participant: "org.hyperledger_composer.marbles.player"<br/>  operation: ALL<br/>  resource: "org.hyperledger_composer.marbles.*"<br/>  action: ALLOW<br/>}</span></pre><p id="b5c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后定义事务模型:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="f1a3" class="lv lw hu lr b fv lx ly l lz ma">transaction TradeMarble {<br/>  --&gt; Marble marble<br/>  --&gt; Player newOwner<br/>}</span></pre><p id="320b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，定义事务函数:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="2995" class="lv lw hu lr b fv lx ly l lz ma">async function tradeMarble(tradeMarble) {<br/>  tradeMarble.marble.owner = tradeMarble.newOwner;</span><span id="2bb0" class="lv lw hu lr b fv mb ly l lz ma">  const assetRegistry = await getAssetRegistry('org.hyperledger_composer.marbles.Marble');</span><span id="c543" class="lv lw hu lr b fv mb ly l lz ma">  await assetRegistry.update(tradeMarble.marble);<br/>}</span></pre><p id="15cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<strong class="je hv"> Convector </strong>中，我们使用<strong class="je hv">控制器</strong>简化了所有这些逻辑</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="6797" class="lv lw hu lr b fv lx ly l lz ma">@Controller('marble')<br/>export class MarbleController extends ConvectorController {<br/>  <br/>  @Invokable()<br/>  public async create(@Param(Marble) marble: Marble) {<br/>    await marble.save();<br/>  }</span><span id="3356" class="lv lw hu lr b fv mb ly l lz ma">  @Invokable()<br/>  public async trade(<br/>    @Param(yup.string()) marbleId: string,<br/>    @Param(yup.string().email()) newOwner: string<br/>  ): Promise&lt;void&gt; {<br/>    // use this.sender for authorization checks</span><span id="90a5" class="lv lw hu lr b fv mb ly l lz ma">    const marble = await Marble.getOne(marbleId);</span><span id="cef3" class="lv lw hu lr b fv mb ly l lz ma">    marble.owner = newOwner;</span><span id="1fe1" class="lv lw hu lr b fv mb ly l lz ma">    await marble.save();<br/>  }<br/>}</span></pre><p id="f14b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<code class="eh na nb nc lr b">@Invokable</code>和<code class="eh na nb nc lr b">@Param</code>装饰器来定义事务模型。任何可调用的方法都将作为事务公开，参数描述其签名。您不仅限于原语，您还可以传递<strong class="je hv">模型</strong>，Convector将为您解析所有复杂对象。</p><p id="21fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<strong class="je hv"> this.sender </strong>来定义访问权限，这是发送者的指纹，对每个参与者都是唯一的。你可以用它做任何事情，如果你愿意，甚至可以将多个发送者连接到一个参与者。这是它提供的灵活性，因此您可以定义自己的规则。</p><p id="5ef1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，您为事务函数编写所有必要的额外逻辑。您可以在这里进行几乎所有类型的操作，只要它们是确定性的，并且除了分类帐数据之外不使用任何外部数据。为了查询总账，每个模型都有一些有用的CRUD方法，如<code class="eh na nb nc lr b">getOne</code>或<code class="eh na nb nc lr b">getAll</code>、<code class="eh na nb nc lr b">save</code>、<code class="eh na nb nc lr b">update</code>和<code class="eh na nb nc lr b">delete</code>。还有一些其他的，比如<code class="eh na nb nc lr b">history</code>，它检索该模型的更新历史，<code class="eh na nb nc lr b">clone</code>复制一个资产，或者<code class="eh na nb nc lr b">assign</code>为模型批量分配属性。</p></div><div class="ab cl kq kr hc ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hn ho hp hq hr"><h2 id="b10b" class="lv lw hu bd mc md me mf mg mh mi mj mk jn ml mm mn jr mo mp mq jv mr ms mt mu dt translated">客户端访问</h2><p id="3c6f" class="pw-post-body-paragraph jc jd hu je b jf mv jh ji jj mw jl jm jn mx jp jq jr my jt ju jv mz jx jy jz hn dt translated">如果您想在Composer中测试上述方法，您通常会这样做:</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="268e" class="lv lw hu lr b fv lx ly l lz ma">const namespace = 'org.hyperledger_composer.marbles';<br/>const factory = businessNetworkConnection.getBusinessNetwork().getFactory();</span><span id="a7ca" class="lv lw hu lr b fv mb ly l lz ma">const dan = factory.newResource(namespace, 'Player', 'daniel.selman@example.com');<br/>dan.firstName = 'Dan';<br/>dan.lastName = 'Selman';</span><span id="9e26" class="lv lw hu lr b fv mb ly l lz ma">const simon = factory.newResource(namespace, 'Player', 'sstone1@example.com');<br/>simon.firstName = 'Simon';<br/>simon.lastName = 'Stone';</span><span id="e880" class="lv lw hu lr b fv mb ly l lz ma">const playerRegistry = await businessNetworkConnection.getParticipantRegistry(namespace + '.Player');<br/>await playerRegistry.addAll([dan, simon]);</span><span id="e6bb" class="lv lw hu lr b fv mb ly l lz ma">const marble = factory.newResource(namespace, 'Marble', 'MARBLE_001');<br/>marble.size = 'SMALL';<br/>marble.color = 'RED';<br/>marble.owner = factory.newRelationship(namespace, 'Player', dan.$identifier);</span><span id="2a28" class="lv lw hu lr b fv mb ly l lz ma">const marbleRegistry = await businessNetworkConnection.getAssetRegistry(namespace + '.Marble');<br/>await marbleRegistry.add(marble);</span><span id="26f3" class="lv lw hu lr b fv mb ly l lz ma">const tradeMarble = factory.newTransaction(namespace, 'TradeMarble');<br/>tradeMarble.newOwner = factory.newRelationship(namespace, 'Player', simon.$identifier);<br/>tradeMarble.marble = factory.newRelationship(namespace, 'Marble', marble.$identifier);<br/>await businessNetworkConnection.submitTransaction(tradeMarble);</span></pre><p id="701d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Convector中，我们有适配器能够在客户端应用程序中使用相同的控制器和型号。</p><pre class="lm ln lo lp fq lq lr ls lt aw lu dt"><span id="a874" class="lv lw hu lr b fv lx ly l lz ma">const adapter = new FabricControllerAdapter(configuration);<br/>const playerCtrl = new PlayerControllerClient(adapter);<br/>const marbleCtrl = new MarbleControllerClient(adapter);</span><span id="a54c" class="lv lw hu lr b fv mb ly l lz ma">const dan = new Player({<br/>  id: 'daniel.selman@example.com',<br/>  firstName: 'Dan',<br/>  lastName: 'Selman'<br/>});<br/>await playerCtrl.register(dan);</span><span id="5a63" class="lv lw hu lr b fv mb ly l lz ma">const simon = new Player({<br/>  id: 'sstone1@example.com',<br/>  firstName: 'Simon',<br/>  lastName: 'Stone'<br/>});<br/>await playerCtrl.register(simon);</span><span id="bc3a" class="lv lw hu lr b fv mb ly l lz ma">const marble = new Marble({<br/>  id: '1',<br/>  size: MarbleSize.SMALL,<br/>  color: MarbleColor.RED,<br/>  owner: dan.id<br/>});<br/>await marbleCtrl.create(marble);</span><span id="c142" class="lv lw hu lr b fv mb ly l lz ma">await marbleCtrl.trade(marble.id, simon.id);</span></pre><p id="3c8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个适配器都有自己的内部逻辑，例如，<strong class="je hv"> FabricControllerAdapter </strong>处理与Fabric通信的网络配置文件，但Convector与Fabric没有紧密耦合，因此社区可以根据他们的需要创建不同的适配器。这正是我们计划在不久的将来通过用新的实现替换适配器来支持其他区块链的方式。<br/>convector中的适配器没有任何特殊处理，它们只是规定了与区块链层的通信，因此Convector中的标准适配器可以被开发人员或社区提供的自定义实现所替换。</p></div><div class="ab cl kq kr hc ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hn ho hp hq hr"><h2 id="6ef9" class="lv lw hu bd mc md me mf mg mh mi mj mk jn ml mm mn jr mo mp mq jv mr ms mt mu dt translated">结论</h2><p id="dbda" class="pw-post-body-paragraph jc jd hu je b jf mv jh ji jj mw jl jm jn mx jp jq jr my jt ju jv mz jx jy jz hn dt translated">Composer和Convector有很多相似之处，但他们选择了不同的建筑道路。使用Convector控制器，您几乎可以控制链代码中的所有逻辑，并且可以更加灵活地设计您认为适合您的用例的架构决策。</p><p id="9c78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们不断地向框架中添加新功能，我们很乐意听到您关于可能对社区有用的新功能的意见。您可以随时在我们的github 中创建新问题，甚至<a class="ae ka" href="https://github.com/worldsibu/convector" rel="noopener ugc nofollow" target="_blank">删除PR。</a></p></div><div class="ab cl kq kr hc ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hn ho hp hq hr"><ul class=""><li id="a076" class="kx ky hu je b jf jg jj jk jn kz jr la jv lb jz lc ld le lf dt translated"><a class="ae ka" href="http://discord.gg/twRwpWt" rel="noopener ugc nofollow" target="_blank">加入不和谐社区！</a></li><li id="4763" class="kx ky hu je b jf lg jj lh jn li jr lj jv lk jz lc ld le lf dt translated"><a class="ae ka" href="https://github.com/worldsibu" rel="noopener ugc nofollow" target="_blank">获取代码！</a></li></ul><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>