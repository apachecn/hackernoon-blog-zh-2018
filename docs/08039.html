<html>
<head>
<title>React — The State Bait and This Dot Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应——国家诱饵和这个点的问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/es6sential-react-the-state-bait-this-problems-88090a73b8e3?source=collection_archive---------15-----------------------#2018-09-23">https://medium.com/hackernoon/es6sential-react-the-state-bait-this-problems-88090a73b8e3?source=collection_archive---------15-----------------------#2018-09-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="58c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于新用户来说，让<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>颇具威胁性的一点是，在开始之前需要掌握一些概念。</p><p id="fa67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不管怎样，学习ES6是很重要的，但是对于所使用的模式和结构，它对我们最喜欢的组件化框架特别有用。也就是说，你仍然可以使用ES5来让它工作，但是为了一致性，ES6是最好的选择！</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/04e55182c43893ca4da7dee719631188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k8RvKPa9iqlaXM7Y"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Create websites with React.js!</figcaption></figure><p id="e204" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">别活在过去了，跟上时代吧，兄弟！！:P</p><h1 id="4629" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">别改变国家，伙计！</h1><p id="28b6" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">大多数情况下，这无论如何都不是一个好主意，但对于构建前端项目来说尤其如此。当事情出错时，改变最初的初始状态会导致很多问题，它会使跟踪错误来自哪里变得困难。</p><p id="dd88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们有一个商店，让我们添加一个项目…</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="f0bc" class="lo kh hu lk b fv lp lq l lr ls">class App extends Component { <br/>    constructor(props) {  <br/>        super(props);  <br/>            this.state = { shop:[] }; <br/>    }</span><span id="96db" class="lo kh hu lk b fv lt lq l lr ls">...//</span><span id="d6a6" class="lo kh hu lk b fv lt lq l lr ls">onAdd = (item) =&gt; {  <br/>    this.state.shop.push(item);<br/>};</span></pre><p id="dd94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于没有受过训练的人来说，这可能是你认为应该做的。但这是一个典型的常见情况，我们正在改变原始状态，这在函数式编程中是一个大忌。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="6476" class="lo kh hu lk b fv lp lq l lr ls">onAdd = (item) =&gt; { <br/>    let newList = this.state.shop;<br/>    newList = newList.concat(item);<br/>    this.setState({ shop: newList })</span><span id="e12e" class="lo kh hu lk b fv lt lq l lr ls">};</span></pre><p id="b836" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Concat是一种将两个数组合并成一个新数组的方法。这里，我们获取商店数组(目前为空),并将其与商品组合成一个新数组。然后我们用React的setState来修改当前状态，而不是直接自己动手。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="a27b" class="lo kh hu lk b fv lp lq l lr ls">onAdd = (item) =&gt; {<br/>    let newList = this.state.shop;<br/>    newList = [...newList, item];<br/>    this.setState({ shop: newList })</span></pre><p id="b035" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大多数情况下，我们使用ES6“版本”,用spread运算符组合数组。“…”允许引用现有数组，但不允许修改，这意味着我们不会改变原始数组。</p><p id="a801" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">确保我们永远不会直接改变状态是一个很好的实践，我们希望一直保持这样的心态。</p><h1 id="3c6d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">用箭头函数解决你的“这个”问题</h1><p id="0ebe" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">您可能已经注意到了，也可能没有注意到，上面写的函数看起来格式很奇怪。请注意，没有函数关键字，对于更高级的编码器，因此也没有绑定方法。</p><p id="77d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们在组件中传递数据时，我们使用<code class="eh lu lv lw lk b">this.[function]</code>来引用其他地方的函数，但是由于词法范围的原因，<code class="eh lu lv lw lk b">this</code>并没有引用我们想要它引用的地方。</p><p id="29b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">箭头函数是一种不同的编写函数的方式，但是它的主要优点是它阻止了<code class="eh lu lv lw lk b">this</code>关键字被限制在函数中。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="dc32" class="lo kh hu lk b fv lp lq l lr ls">class ParentComponent extends Component {<br/>    render() {<br/>        return (<br/>            &lt;div&gt;<br/>                &lt;ChildComponent <br/>                parentFunction="this.parentFunction" <br/>                /&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    };</span><span id="9c6b" class="lo kh hu lk b fv lt lq l lr ls">function parentFunction() {<br/>        console.log("Button is clicked!")<br/>    }<br/>}</span><span id="11b4" class="lo kh hu lk b fv lt lq l lr ls">class ChildComponent extends Component {<br/>    render() {<br/>        return (<br/>            &lt;div&gt;<br/>                &lt;button onClick={this.handleClick}&gt;<br/>                    Click Me!<br/>                &lt;/button&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    };</span><span id="e5c2" class="lo kh hu lk b fv lt lq l lr ls">    handleClick = () =&gt; {<br/>        this.props.parentFunction();<br/>    }<br/>}</span></pre><p id="6a3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个子组件中，我们有一个按钮，单击它时，会使用从父组件传递过来的parentFunction属性。</p><p id="8991" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh lu lv lw lk b">function</code>关键字传递parentFunction的事实将使<code class="eh lu lv lw lk b">this</code>关键字无法引用我们想要的内容，如果它没有使用箭头函数的话。</p><p id="8041" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ES5解决这个问题的方法是使用<code class="eh lu lv lw lk b">bind</code>方法，但是这意味着传递的每个函数都必须被绑定，并且有很多函数是不可伸缩的。</p><p id="02f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以就用<code class="eh lu lv lw lk b">[name] = () =&gt; {}</code>来拯救自己<code class="eh lu lv lw lk b">this</code>的范围界定问题吧！</p><p id="2943" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个常见的场景是当DOM事件需要一个参数时。</p><pre class="jr js jt ju fq lj lk ll lm aw ln dt"><span id="ace1" class="lo kh hu lk b fv lp lq l lr ls"><strong class="lk hv">Using ES6 Arrow Functions</strong></span><span id="477c" class="lo kh hu lk b fv lt lq l lr ls">&lt;button onClick={(event) =&gt; this.deleteRow(id, event)}&gt;Delete Row&lt;/button&gt;</span><span id="1ebf" class="lo kh hu lk b fv lt lq l lr ls"><em class="lx">// Events as parameters are explicit so can be even shorter!</em></span><span id="ac4e" class="lo kh hu lk b fv lt lq l lr ls">&lt;button onClick={() =&gt; this.deleteRow(id)}&gt;Delete Row&lt;/button&gt;</span><span id="8d0f" class="lo kh hu lk b fv lt lq l lr ls"><strong class="lk hv">Using ES5 Bind</strong></span><span id="2851" class="lo kh hu lk b fv lt lq l lr ls">&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</span></pre><p id="fbfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">绝对看起来更干净，需要更少的维护。我们不必跟踪所有的绑定，因此不容易出错。它的可读性更强，整体看起来更整洁！</p><h1 id="80b5" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">获得2个带ES6的把手！</h1><p id="cc29" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">如果你不知道这些概念，就一头扎进去，理解起来肯定会很困难。学习ES6更新对学习React是非常必要的，这对初学者来说可能很不友好。</p><p id="10e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不管怎样，随着<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>的发展，挑战所有的可能性，继续生存下去，它变得越来越明显，及时更新所有新添加的特性是很重要的。</p><p id="dd86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些天来，我试图通过尽可能多地使用ES6语法和Air Bnb林挺来保持事情的一致性。事实上，对于一个有抱负的新手来说，你可以用不同的方式做很多事情，这可能会令人望而生畏。</p><p id="6b98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何，希望这是有帮助的，有一个伟大的一周！</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure></div></div>    
</body>
</html>