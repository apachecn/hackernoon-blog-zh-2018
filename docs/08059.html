<html>
<head>
<title>Detailed explanation of the new React context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新React上下文的详细说明</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/detailed-explanation-of-the-new-react-context-7d3c71185163?source=collection_archive---------16-----------------------#2018-09-24">https://medium.com/hackernoon/detailed-explanation-of-the-new-react-context-7d3c71185163?source=collection_archive---------16-----------------------#2018-09-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="36c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由<a class="ae jp" href="https://github.com/artalar" rel="noopener ugc nofollow" target="_blank"> artalar </a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/b325eaa56fdd02c9a0cb22fa64d7c229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhtHiWQ-iGPJ7Oh1e7e9Dg.png"/></div></div></figure><h1 id="d044" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">什么是语境</h1><p id="48d0" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">除了只能由直接子组件访问的<code class="eh lf lg lh li b">props</code>之外，React组件还可以定义一个上下文，所有嵌套的子组件都可以访问该上下文。这意味着无论组件嵌套有多深，它都可以访问由树中任意数量的节点创建的上下文。Context API是所有流行库的基础，这些库需要能够从组件树的每一层访问全局值:react-redux、react-mobx、react-router、styled-components(theme provider)。</p><h1 id="e99a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">旧环境的问题</h1><p id="8a8d" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">在旧版本中，可以接收数据，但无法订阅其更新。确切地说，更新——对于props也是如此——发生在父组件重新渲染时。但是由于数据是通过大量(实际上是任意数量)的组件从上下文源传输到上下文消费者的，并且这些组件可以通过它们自己的<code class="eh lf lg lh li b">shouldComponentUpdate</code>停止更新，所以这种订阅不能被称为可靠的。因此，在设计库时，应该为消费组件更新数据，开发人员必须手动创建更新机制——实际上这不是一件容易的工作。阅读文章中的<a class="ae jp" rel="noopener" href="/@mweststrate/how-to-safely-use-react-context-b7e343eff076">或观看MobX creator的演示文稿</a>。</p><h1 id="24d0" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">新API <code class="eh lf lg lh li b">React.createContext</code></h1><p id="159f" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">一些开发人员认为新的上下文(<code class="eh lf lg lh li b"><a class="ae jp" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">React.createContext</a></code>)是对<code class="eh lf lg lh li b">redux</code>(或任何其他状态容器)的替代，但这是在拿苹果和橘子做比较。新环境的主要目标是促进消费者的有效更新(更多细节由Dan Abramov提供)，以便开发人员可以专注于他们库的主要特性。新的上下文还拥有一个改进的、更直观的界面。</p><p id="91f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，<code class="eh lf lg lh li b">redux</code>具有管理状态的最小功能:订阅和更新。这些可以用常规<code class="eh lf lg lh li b">React.Component</code>中的<code class="eh lf lg lh li b">state</code>(和<code class="eh lf lg lh li b">setState</code>)代替。更准确地说，在某些应用程序中，可以使用新的上下文来代替<code class="eh lf lg lh li b">redux</code>，这意味着可以使用<code class="eh lf lg lh li b">React.Component</code>状态和更新，并且可以用React.createContext替换<code class="eh lf lg lh li b">react-redux</code>。没有用上下文“开箱即用”替换<code class="eh lf lg lh li b">redux middleware</code>，但是有<a class="ae jp" href="https://github.com/didierfranc/react-waterfall#redux-devtools" rel="noopener ugc nofollow" target="_blank">第三方库</a>。</p><h2 id="e87d" class="lj kd hu bd ke lk ll lm ki ln lo lp km jc lq lr kq jg ls lt ku jk lu lv ky lw dt translated">渲染道具</h2><p id="96b5" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">如您所见，新的<code class="eh lf lg lh li b">React.createContext</code> API使用render-prop方法与其他订阅的组件共享状态或行为。虽然在<a class="ae jp" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中概述了实施细节和示例代码，但我想强调一下这种方法的优点和缺点:</p><ul class=""><li id="15e1" class="lx ly hu it b iu iv iy iz jc lz jg ma jk mb jo mc md me mf dt translated">(<strong class="it hv"> + </strong>)在多个订阅的情况下防止命名冲突(<code class="eh lf lg lh li b">Consumer</code>)。因为经典的HOC组合了<code class="eh lf lg lh li b">props</code>，如果我们在一行中有多个HOC，并且任何传递的属性具有相同的名称，则值将被覆盖，并且到达组件的最后的<code class="eh lf lg lh li b">props</code>对象将具有最后一个HOC的值。使用render-prop解决了这个问题，因为prop没有组合在一起，订阅的每个传递参数都是在传递的函数中单独访问的。</li><li id="2b18" class="lx ly hu it b iu mg iy mh jc mi jg mj jk mk jo mc md me mf dt translated">(–)“сall back hell”和新函数的生成，或者将呈现部分重新定义为单独的方法(这会干扰设计模式的一致性)。更多细节在<a class="ae jp" href="https://reactjs.org/docs/render-props.html#be-careful-when-using-render-props-with-reactpurecomponent" rel="noopener ugc nofollow" target="_blank">官方文档</a>中。</li></ul><p id="ae21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你不喜欢渲染道具方法，而宁愿使用“古老的”HOCs，这里有一个简单的例子，说明如何通过记忆化来实现它:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="16d3" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">不稳定_观察位</h1><blockquote class="mn mo mp"><p id="29f5" class="ir is mq it b iu iv iw ix iy iz ja jb mr jd je jf ms jh ji jj mt jl jm jn jo hn dt translated"><em class="hu">信息见于</em> <a class="ae jp" href="https://github.com/facebook/react/blob/4ccf58a94dce323718540b8185a32070ded6094b/packages/react/src/ReactContext.js#L18" rel="noopener ugc nofollow" target="_blank"> <em class="hu">源代码</em></a><em class="hu"/><a class="ae jp" href="https://github.com/facebook/react/blob/4ccf58a94dce323718540b8185a32070ded6094b/packages/react-reconciler/src/__tests__/ReactNewContext-test.internal.js#L498-L526" rel="noopener ugc nofollow" target="_blank"><em class="hu">测试</em> </a> <em class="hu">中的React，以及</em> <a class="ae jp" rel="noopener" href="/@koba04/a-secret-parts-of-react-new-context-api-e9506a4578aa"> <em class="hu">这篇文章</em> </a></p></blockquote><p id="370a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然还没有公开宣布或添加到官方文档中(最有可能的是，<a class="ae jp" href="https://github.com/facebook/react/issues/12732#issuecomment-395979669" rel="noopener ugc nofollow" target="_blank">不会是</a>)，<em class="mq"> </em>除了前面提到的功能，<code class="eh lf lg lh li b">React.createContext</code>还有第二个接受函数的参数。组件也接受一个位掩码作为T2属性。该功能类似于<code class="eh lf lg lh li b">React.Component</code>中的<code class="eh lf lg lh li b">shouldComponentUpdate</code>。让我们仔细看看。</p><h2 id="e987" class="lj kd hu bd ke lk ll lm ki ln lo lp km jc lq lr kq jg ls lt ku jk lu lv ky lw dt translated">位掩码</h2><p id="f0cb" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Mask_(computing)" rel="noopener ugc nofollow" target="_blank">位掩码</a>是一项古老的技术，特别是在Linux权限设置中使用。位屏蔽的概念涉及每个位，以特定的顺序，为特定设置设置<code class="eh lf lg lh li b">true</code>或<code class="eh lf lg lh li b">false</code>指示器。位掩码的优点是，要更新值，只需使用规则掩码对原始位掩码执行一次逐位运算。为了将目标位的值设置为<code class="eh lf lg lh li b">true</code>，使用“或”— <code class="eh lf lg lh li b">|</code> —位运算符，目标位=== <code class="eh lf lg lh li b">1</code>，掩码中的其他位设置为<code class="eh lf lg lh li b">0</code>。为了将值设置为<code class="eh lf lg lh li b">false</code>，使用“与”— <code class="eh lf lg lh li b">&amp;</code> —位运算符，目标位=== <code class="eh lf lg lh li b">0</code>，掩码中的其他位设置为<code class="eh lf lg lh li b">1</code>。这在开始时可能会令人困惑，但在实践中，这是一种简单、直观、快速的存储和修改<code class="eh lf lg lh li b">true</code> / <code class="eh lf lg lh li b">false</code>值的方法。</p><h2 id="8e4e" class="lj kd hu bd ke lk ll lm ki ln lo lp km jc lq lr kq jg ls lt ku jk lu lv ky lw dt translated">使用</h2><p id="6b12" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">以下描述和示例中的位掩码用于跟踪状态的变化。位屏蔽中的每一位应该对应于状态中的一个值。</p><p id="62e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React.createContext的第二个参数接受一个接受以前和新状态的函数，并返回更新后的位掩码。反过来，消费者接受一个位掩码，它包含负责我们想要观察的状态值的“真”值的位，作为unstable_observedBits。当消费者收到位掩码时，它<a class="ae jp" href="https://github.com/facebook/react/blob/4ccf58a94dce323718540b8185a32070ded6094b/packages/react-reconciler/src/ReactFiberBeginWork.js#L988" rel="noopener ugc nofollow" target="_blank">将新的位掩码与不稳定的观察位进行比较，并对它们执行按位“与”运算。仅当操作结果不为0时，才会重新呈现使用者。如果未提供React.createContext的第二个参数和unstable_observedBits使用者参数，则只要上下文发生变化，就会调用render-prop。</a></p><h2 id="c5d6" class="lj kd hu bd ke lk ll lm ki ln lo lp km jc lq lr kq jg ls lt ku jk lu lv ky lw dt translated">例子</h2><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="b781" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如参数名所示，这个API不稳定，不应该在生产中使用。</p><h1 id="d61b" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">创建-订阅</h1><p id="21ef" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">React <a class="ae jp" href="https://github.com/facebook/react/tree/master/packages/create-subscription" rel="noopener ugc nofollow" target="_blank">源代码</a>中添加的另一个实用程序是<code class="eh lf lg lh li b"><a class="ae jp" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#adding-event-listeners-or-subscriptions" rel="noopener ugc nofollow" target="_blank">create-subscription</a></code>。以前，为了管理订阅、响应属性更改和重新呈现组件，开发人员必须使用<code class="eh lf lg lh li b">React.Component</code>创建一个包装器，这会触发<code class="eh lf lg lh li b">setState</code>或<code class="eh lf lg lh li b">forceUpdate</code>。为了简化订阅，开发人员现在可以使用来自官方React存储库中<code class="eh lf lg lh li b">create-subscription</code>包的更透明的<code class="eh lf lg lh li b">createSubscription</code> API。</p><h2 id="7b0f" class="lj kd hu bd ke lk ll lm ki ln lo lp km jc lq lr kq jg ls lt ku jk lu lv ky lw dt translated">摘要</h2><p id="6201" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">React 16.3带来了许多有趣的变化，毫无疑问，将提高React框架的使用质量，并简化React支持库的开发。</p><p id="152f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个交互式演示中可以看到新环境的使用:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mu mm l"/></div></figure><p id="75e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个交互式演示中，可以看到上述所有功能:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mu mm l"/></div></figure></div></div>    
</body>
</html>