<html>
<head>
<title>Bridging the Gap Between Design &amp; Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弥合设计和代码之间的差距</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/bridging-the-gap-between-design-code-b6e330e16d93?source=collection_archive---------18-----------------------#2018-09-24">https://medium.com/hackernoon/bridging-the-gap-between-design-code-b6e330e16d93?source=collection_archive---------18-----------------------#2018-09-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="cc9c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">“设计与代码”是AirSwap团队为您带来的一系列关于设计和工程实验、过程和学习的内容。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/9ab0fc033cf1213b58770ce581ca730d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3r7ankFnKgdCCw9jOvX4w.png"/></div></div></figure><p id="0650" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在AirSwap，我们有一个异步和迭代的产品开发方法。然而，我们遇到的最早的挑战之一是在多个产品所有者之间，通过功能工作的迭代来维护一致的产品身份。在开发早期版本的<a class="ae kr" href="https://blog.airswap.io/token-trader-is-live-e24553c2e7b0" rel="noopener ugc nofollow" target="_blank"> AirSwap Token Trader </a>和<a class="ae kr" href="https://blog.airswap.io/airswap-is-here-c83c001d5bbe" rel="noopener ugc nofollow" target="_blank"> AirSwap Widget </a>的过程中，我们很快积累了一些草图文件——每个文件都包含一个符号和风格的抓包，代表了我们当时的产品身份状态。虽然这在开始时有效，但是我们缺乏一个统一的事实来源，很快就变成了一个跨越多个来源的过时风格的混乱。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ks"><img src="../Images/8895b218c3849cba82029305af01a6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpVhPX2cqycpIKSctMYYyw.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">With multiple files and symbols scattered across all of them, it became a hassle managing a consistent identity.</figcaption></figure><p id="e300" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">AirSwap的每一次前端体验都是用React写的。开始时，我们有一个共享组件的目录，如果你愿意的话，可以称之为一个初步的组件库，带有与产品身份相匹配的适当样式。然而，随着我们的迭代，我们的产品身份发生了变化。引用新特性的<a class="ae kr" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>组件使得识别特定组件是否已经存在或者需要实现变得更加困难。我们很早就决定使用<a class="ae kr" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式组件</a>，这允许我们快速迭代和构建特性。样式组件带来的易用性是一个巨大的胜利，但它也无意中让我们在扩展样式时做出了一些糟糕的决定。没有关于如何创建或扩展组件的严格规则，我们的代码库很快就变成了许多只有微小差异的重复代码的家园。这不仅降低了开发者的速度，增加了技术债务，而且还引入了我们产品身份的不一致性。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff kx"><img src="../Images/b7e00b8c166109a65b4611d04bfced3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtUGx7vGFxb_-VUSFenaiA.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Because of the absence of a well-defined system on the design comps, many files in our codebase would introduce new components that were similar to existing ones, or make minor changes to the existing components.</figcaption></figure><p id="fcd1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在寻找这些问题的解决方案时，我们最近开始尝试如何弥合设计和代码之间的差距。</p><h1 id="5bb8" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">设计工艺</h1><p id="e4b4" class="pw-post-body-paragraph jv jw hu jx b jy lq iv ka kb lr iy kd ke ls kg kh ki lt kk kl km lu ko kp kq hn dt translated">设计技术的想法并不新鲜。像<a class="ae kr" href="https://www.invisionapp.com/craft" rel="noopener ugc nofollow" target="_blank"> Craft </a>和<a class="ae kr" href="https://www.invisionapp.com/" rel="noopener ugc nofollow" target="_blank"> Invision </a>这样的工具的存在是为了帮助设计师整合他们的风格，并将这些信息传递给开发者。这允许多个利益相关者在维护一组统一的基础组件或共享组件库的同时处理不同的特性。然而，我们需要的是一种方法，不仅要保持设计之间的平衡，还要保持构成设计的组件和代码中存在的组件之间的平衡。</p><p id="e6a0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">大约一年前，Airbnb的设计技术团队发布了一个名为<code class="eh lv lw lx ly b"><a class="ae kr" href="https://github.com/airbnb/react-sketchapp" rel="noopener ugc nofollow" target="_blank">react-sketchapp</a></code>的开源项目，该项目使React组件能够渲染成Sketch。React社区反应良好，很快，styled components发布了他们库的扩展<code class="eh lv lw lx ly b"><a class="ae kr" rel="noopener" href="/styled-components/announcing-primitives-support-for-truly-universal-component-systems-5772c7d14bc7">styled-components/primitives</a></code>，支持多目标渲染(包括渲染到草图)。这些项目成为我们面临的不一致问题的基础技术解决方案。</p><h1 id="92b9" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">AirSwap组件库</h1><p id="ced4" class="pw-post-body-paragraph jv jw hu jx b jy lq iv ka kb lr iy kd ke ls kg kh ki lt kk kl km lu ko kp kq hn dt translated">在对AirSwap小部件进行了详尽的审计之后，我们在Sketch中确定并重新创建了将在所有当前和未来特性中使用的组件集。然后我们花时间在React中重新创建了整个组件库，使用<code class="eh lv lw lx ly b">styled-components/primitives</code>作为我们的基础。我们的组件通过<code class="eh lv lw lx ly b">react-sketchapp</code>被渲染成符号，为我们的设计创造了一个真实的来源。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lz"><img src="../Images/64799d30d535ba44662f7818edb77841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wG2X_L9TiMJzZhqvKnbwrQ.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">React components rendered to Sketch</figcaption></figure><p id="3daa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">创建组件库成为我们在AirSwap的初步端到端设计流程的基础。首先是组件的设计，然后是实现。因为我们使用了<code class="eh lv lw lx ly b">styled-components</code>和<code class="eh lv lw lx ly b">react-sketchapp</code>，我们可以将实现的代码提交回Sketch进行审查。批准后，渲染的组件将成为新的设计，如有必要，可用于将来的修改。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ma"><img src="../Images/a3b99c243d5eb275ce6bef0234d34c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QKHLe6QoUcWkrEQ1VwB1Q.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Multiple versions of the component library, rendered to Sketch and uploaded to Figma</figcaption></figure><h1 id="4097" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">输入Figma</h1><p id="598d" class="pw-post-body-paragraph jv jw hu jx b jy lq iv ka kb lr iy kd ke ls kg kh ki lt kk kl km lu ko kp kq hn dt translated">这个循环消除了代码和设计之间的差异。然而，当我们开始在<a class="ae kr" href="https://www.figma.com/" rel="noopener ugc nofollow" target="_blank"> Figma </a>上完成大部分设计工作时，我们很快发现了这种解决方案的额外好处。因为我们的设计工具允许我们从组件库中创建草图文档，所以我们将每个新版本上传到Figma。可以在最新修订版上以交互方式提出意见和更改请求，最新修订版为下一个修订版提供了规范，只有在解决了之前的所有意见后才能上传。这还不是完美无缝的，但是它创建了一个UI审查过程，在信息上类似于GitHub pull请求。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mb"><img src="../Images/da06f7d184f33744d152d1ce72d22e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dMqN1dxP7QZciyXx8JO3A.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Using our new component library to build mocks for the new <a class="ae kr" href="https://blog.airswap.io/introducing-conversational-otc-trading-358f15d8e9e4" rel="noopener ugc nofollow" target="_blank">AirSwap Conversational OTC Trading</a></figcaption></figure><p id="8b54" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">此外，使用Figma的共享库功能，我们可以在所有设计组件中访问这些组件。作为工程师，我们可以实时协作地查看和编辑这些组件，这就清楚地表明了正在使用哪个组件。这完全消除了对组件是否已经存在的猜测，因为组件的名称显示在Figma上。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mc"><img src="../Images/798893a6dea68f0e4c8277d41682bd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDkUKo-s8PvQgxQpShZ0UQ.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">The component name is displayed in Figma, which immediately provides information to developers viewing the mocks</figcaption></figure><h1 id="8398" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">下一步是什么</h1><p id="dd11" class="pw-post-body-paragraph jv jw hu jx b jy lq iv ka kb lr iy kd ke ls kg kh ki lt kk kl km lu ko kp kq hn dt translated">展望未来，我们打算改进和调整这一过程，以更好地适应我们的产品开发工作。仍然需要几个手动且低效的步骤。</p><p id="19b6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，Figma目前没有为文档提供可写的API，需要我们手动上传生成的草图文件。有了适当的API支持，我们可以轻松地将这个端到端流程集成到我们的持续集成管道中。我们设想在未来，CI管道会从repo中的标记或分支呈现一个草图文件(或者更好的是，呈现原生Figma对象，而不是遍历草图)，将该文件上传到Figma，并将结果文档链接到一个pull请求。Figma的评论可以交叉发布到GitHub，在设计和代码之间提供无缝的交流和反馈。</p><p id="da5d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">此外，尽管我们已经为组件库创建了技术基础，但是我们还没有建立可行的规则来确定我们应该如何以及何时扩展组件和/或创建新组件。哪些组件的哪些属性可以根据具体情况进行调整，什么时候大量的更改表明需要创建新的组件？我们需要找到这些问题的自然答案，最好是想出自动执行这些决策的方法。</p><p id="f893" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有了这个新的组件库，我们已经注意到从设计到编码的交付的生产率和效率有所提高。虽然远非完美，但这一新流程的完整端到端功能使我们能够提高迭代工作的速度，同时保持产品身份的高度完整性。围绕设计和设计技术的对话正在世界各地的许多产品团队中迅速发展。在AirSwap，设计是我们非常关心的事情，设计技术已经成为产品开发的一个令人兴奋的交叉领域，我们可以利用它来帮助我们推出令人惊叹的产品。</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><ul class=""><li id="6a41" class="mk ml hu jx b jy jz kb kc ke mm ki mn km mo kq mp mq mr ms dt translated">订阅<a class="ae kr" href="https://blog.airswap.io/" rel="noopener ugc nofollow" target="_blank"> AirSwap博客</a></li><li id="cb86" class="mk ml hu jx b jy mt kb mu ke mv ki mw km mx kq mp mq mr ms dt translated">加入我们<a class="ae kr" href="https://t.me/airswapofficial" rel="noopener ugc nofollow" target="_blank">官方频道的电报</a></li><li id="1acc" class="mk ml hu jx b jy mt kb mu ke mv ki mw km mx kq mp mq mr ms dt translated">在<a class="ae kr" href="https://twitter.com/airswap" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我们</li><li id="6a37" class="mk ml hu jx b jy mt kb mu ke mv ki mw km mx kq mp mq mr ms dt translated">在脸书<a class="ae kr" href="https://www.facebook.com/airswapio/" rel="noopener ugc nofollow" target="_blank">找到我们</a></li><li id="2ee1" class="mk ml hu jx b jy mt kb mu ke mv ki mw km mx kq mp mq mr ms dt translated">订阅我们的<a class="ae kr" href="https://www.reddit.com/r/AirSwap/" rel="noopener ugc nofollow" target="_blank">子编辑</a></li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>