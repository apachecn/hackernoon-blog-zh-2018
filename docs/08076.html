<html>
<head>
<title>Why Your Startup Needs Serverless Slack Bots</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你的创业需要无服务器Slack机器人</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-your-startup-needs-serverless-slack-bots-dd02f1d9d21b?source=collection_archive---------33-----------------------#2018-09-24">https://medium.com/hackernoon/why-your-startup-needs-serverless-slack-bots-dd02f1d9d21b?source=collection_archive---------33-----------------------#2018-09-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ed76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将解释我们如何在Epsagon中利用无服务器Slack机器人，展示它们的价值，并提供一个示例——包括相应的开源代码，使用Python和无服务器框架来实现您的定制无服务器Slack机器人。</p><p id="3dc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Slack无疑是初创公司最著名的消息软件。初创公司对速度和敏捷性有独特的需求，而Slack正是这种需求的完美体现。没有开销—只有纯粹的效率。</p><p id="8120" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Slack中我最喜欢的功能之一是它的大量应用程序和集成，以及开发定制应用程序的简单方法，这些应用程序通常被称为“<a class="ae jq" href="https://hackernoon.com/tagged/slack-bots" rel="noopener ugc nofollow" target="_blank"> Slack机器人</a>这些应用背后的要点很简单——你希望所有的信息都在一个位置，如果Slack是沟通和知识共享的主要方式，为什么不把其他来源的信息也放入其中呢？</p><p id="4fa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以找到很多推荐应用的列表，比如<a class="ae jq" href="https://blog.producthunt.com/20-slack-apps-you-ll-love-a295ef2c0f9c" rel="noopener ugc nofollow" target="_blank">这个</a>。我强烈建议寻找符合您需求的现有应用程序并添加它们。内置应用程序很棒，但如果你需要一个特定的、量身定制的、完全符合你要求的应用程序呢？幸运的是，Slack的人想到了这一点，并创造了一种开发定制应用和集成的简单方法。Slack有很好的文档，你可以在这里找到，它将指导你一步一步地构建你的应用。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="ab fr cl jw"><img src="../Images/95cb9311d90a176e422850a08e2fa9a6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Co918UofSnJ_SaxQBf17rQ.png"/></div></figure><p id="0736" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这只是我们在Epsagon使用的一些机器人。通常，每个Slack bot都向一个专用的Slack通道报告。</p><ol class=""><li id="faf3" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo ke kf kg kh dt translated"><strong class="it hv"> GitHub </strong>(内置):跟踪代码和问题变化的最简单方法。</li><li id="aa56" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated"><strong class="it hv"> TravisCI </strong>(内置):这个持续集成工具有一个平滑的松弛集成。</li><li id="78e0" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated"><strong class="it hv">提一下</strong>(内置):一个追踪互联网周围事物的有用工具，里面有一个现成的Slack bot。</li><li id="2b41" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated"><strong class="it hv"> RSS提要</strong>(内置):AWS提要、<a class="ae jq" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a>提醒等等。这些可以使用“/feed …”语句轻松添加。</li><li id="b30d" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated"><strong class="it hv">定制RSS提要</strong>(内部):我们实现了自己的Google Alerts Slack bot，因为我们想改进内置集成的格式。</li><li id="30ea" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated"><strong class="it hv">栈溢出</strong>(内部):观看并评论栈溢出问题。</li><li id="342f" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">Reddit (内部):我们监控互联网首页与我们相关的讨论的方式。</li><li id="2d40" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">Meetup(内部):关于我们可能感兴趣的世界各地的新聚会的通知。</li><li id="7200" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated"><strong class="it hv">生日机器人</strong>(内置):因为好玩！</li></ol><p id="f269" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如你所见，我们喜欢Slack机器人——包括内置的和定制的。开发定制Slack bot最简单的方法是什么？</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="ab fr cl jw"><img src="../Images/9b68dc4e63e6b13971b76109570262dd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6f_WzU7mcKMtOT18_EADfQ.png"/></div></figure><p id="e942" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要运行Slack bot，需要运行代码(很奇怪吧？).这段代码通过Slack API发送事件，然后将它们发布到相应的Slack通道。机器人运行的触发条件是什么？嗯，它可以由用户操作触发(就像交互式Slack机器人一样)，但通常情况下，它是基于时间的。每1分钟、每1小时等等。</p><p id="9d92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码还需要某种计算单元。它可以在服务器上运行，也可以作为无服务器功能运行。</p><p id="3685" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无服务器完全符合Slack机器人的用例。使用AWS Lambda等无服务器计算服务，您可以立即部署Slack机器人，再也不用担心它们了！</p><p id="0c6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将展示我们在Epsagon中实现的Reddit Slack机器人。它跟踪我们跟踪的子编辑中的提交。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="ab fr cl jw"><img src="../Images/d663db072d4108413323d5446934e913.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1ZcIdbFsp_JISaMyth-ZyA.png"/></div></figure><p id="830f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个开源项目，可以在我们的<a class="ae jq" href="https://github.com/epsagon/reddit-slackbot" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到。我不打算介绍配置Slack的整个过程——您可以在网上找到优秀的文档。相反，我将把重点放在我们为使事情对我们更方便而采取的变通办法上。注意:虽然这是一个Reddit机器人，但一般思想对于任何预定的无服务器Slack机器人都是一样的。Reddit机器人可以用作其他机器人的模板。</p><p id="7135" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">松紧网钩</strong>:使用<a class="ae jq" href="https://api.slack.com/incoming-webhooks" rel="noopener ugc nofollow" target="_blank">这个</a>导轨可以很容易地制作出松紧网钩。</p><p id="8f8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">配置文件(config.json) </strong>:该配置包含Slack URL、Reddit客户端参数以及要遵循的子编辑。子编辑是以Reddit的格式编写的。在这种情况下，我们将收到关于在子编辑“编程”和“Python”中包含关键字“lambda”的提交的通知。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="ab fr cl jw"><img src="../Images/f3bbf3e1c96fb00e7411c9565bd5be2c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vp1UxMal6oXY8ISK8tGEoQ.png"/></div></figure><p id="13d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Lambda代码(main.py) </strong>:该代码包含三个函数。</p><ol class=""><li id="5451" class="jz ka hu it b iu iv iy iz jc kb jg kc jk kd jo ke kf kg kh dt translated">handler—Lambda处理程序，在本例中每60分钟调用一次。</li><li id="6682" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">get_submissions —使用Reddit API检索新的提交。</li><li id="2792" class="jz ka hu it b iu ki iy kj jc kk jg kl jk km jo ke kf kg kh dt translated">update_slack —格式化消息并将其发布到slack通道。</li></ol><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="ab fr cl jw"><img src="../Images/a7ca7a8652fc72e8f0810cdc5f6ab427.png" data-original-src="https://miro.medium.com/v2/format:webp/1*k8gQaf2leY5jMqW4H_7TMg.png"/></div></figure><p id="97b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，处理程序函数包含函数配置的更新—具体来说，是LAST_SUBMISSION环境变量。它用于记住最后一次提交的时间，并且只发布新的到Slack。<strong class="it hv">这是一种在功能中保存状态的方法，无需建立数据库</strong>。我们待会再谈。</p><p id="3bd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> serverless.yml </strong>:我们是无服务器框架的大fonds。使用框架部署新的Lambda函数非常简单。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="ab fr cl jw"><img src="../Images/afeedec3acc074fda3ce22fda381219b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*r5GFc_SQhXSqMT6Aof5JpQ.png"/></div></figure><p id="a79d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该serverless.yml文件包含该函数的特殊权限—编辑其配置(lambda:UpdateFunctionConfiguration)。需要此权限，因为处理函数正在更新环境变量LAST_SUBMISSION。可以使用AWS区域、帐户ID(可以使用本指南找到)和函数名(取自文件顶部的服务字段)来计算资源字段。</p><p id="e96b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法确实很“蹩脚”，但是它让我们能够忘记设置额外的AWS资源，比如DynamoDB。因为现在没有办法在Lambda函数中保存状态，所以这是一个简单的解决方案。虽然让一个Lambda函数改变它的配置(包括它的代码)是一个潜在的安全风险——这个函数只由一个预定的定时器触发，并且不公开一个外部API，这将风险最小化。然而——为你所有的Slack机器人设置一个DynamoDB也是一个相当简单的解决方案。</p><p id="cf4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如前所述，该项目在我们的<a class="ae jq" href="https://github.com/epsagon/reddit-slackbot" rel="noopener ugc nofollow" target="_blank">资源库</a>中可用。另外，<strong class="it hv">它可以作为任何基于时间的无服务器Slack bot </strong>的模板。我们在Epsagon使用了相同的模板来创建Google Alerts bot、Stack Overflow bot等。</p><p id="44a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你对Slack机器人有什么体验？你对改进我们的Slack bot有什么想法吗？请与我们分享您的故事，并为该项目做出贡献！</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><p id="0c3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">【blog.epsagon.com】最初发表于<a class="ae jq" href="http://blog.epsagon.com/why-your-startup-needs-serverless-slack-bots" rel="noopener ugc nofollow" target="_blank"><em class="jp"/></a><em class="jp">。</em></p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ku kv l"/></div></figure></div></div>    
</body>
</html>