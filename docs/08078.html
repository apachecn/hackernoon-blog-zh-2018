<html>
<head>
<title>Spock II: Databases and Sessions!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spock II:数据库和会话！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/spock-ii-databases-and-sessions-996c4a4295a4?source=collection_archive---------35-----------------------#2018-09-24">https://medium.com/hackernoon/spock-ii-databases-and-sessions-996c4a4295a4?source=collection_archive---------35-----------------------#2018-09-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/9d68ae7c9ed592e253058fd59fa689af.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*WLzijiiHcbG5_1u9TXHKZA.png"/></div></figure><p id="bfbf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">上周我们学习了<a class="ae jw" href="https://www.spock.li/" rel="noopener ugc nofollow" target="_blank"> Spock库</a>的基础知识。我们看到了如何设置一些简单的路线。像Servant一样，有一点依赖型的路由机制。但是我们不需要学习任何复杂的操作符。我们只需要将参数的数量与我们的路线相匹配。我们还看到了如何使用应用程序状态在请求之间保存一些数据。</p><p id="afc2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">本周，我们将在Spock应用程序中添加一些更复杂的特性。首先，我们将连接到一个数据库。其次，我们将使用会话来跟踪用户。</p><p id="91a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">更多有用的Haskell库的例子，请查看我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">产品清单</a>！</p><h1 id="b0c4" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">添加数据库</h1><p id="8649" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">上周，我们添加了一些全局应用程序状态。即使有了这样的进步，我们的访客数量也没有持续增长。当我们重置服务器时，一切都消失了，我们的用户将看到一个不同的数字。我们可以通过向我们的服务器添加一个数据库连接来改变这一点。我们将按照<a class="ae jw" href="https://www.spock.li/tutorials/rest-api#adding-a-database" rel="noopener ugc nofollow" target="_blank"> Spock教程</a>的例子，通过使用Persistent连接到SQLite数据库。</p><p id="e238" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你以前没有用过Persistent，看看我们Haskell Web系列中的<a class="ae jw" href="https://www.mmhaskell.com/web-skills-1" rel="noopener ugc nofollow" target="_blank">这个教程</a>！您还可以在Github上查看我们的<a class="ae jw" href="https://github.com/jhb563/SpockExample" rel="noopener ugc nofollow" target="_blank">示例代码</a>，寻找您可能遗漏的任何样板文件。下面是我们将使用的超级简单的模式。记住持久化会给我们一个自动递增的主键。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="5f44" class="lj jy hu lf b fv lk ll l lm ln">share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|<br/>  NameEntry json<br/>    name Text<br/>    deriving Show<br/>|]</span></pre><p id="d0f6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Spock希望我们在使用数据库时使用连接池。所以让我们使用<code class="eh lo lp lq lf b">createSqlitePool</code>创建一个SQLite文件。我们需要从一个日志单子上运行这个。此时，我们可以从<code class="eh lo lp lq lf b">main</code>启动函数中迁移我们的数据库。这确保了我们使用最新的模式:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="fcfc" class="lj jy hu lf b fv lk ll l lm ln">import Database.Persist.Sqlite (createSqlitePool)</span><span id="cbab" class="lj jy hu lf b fv lr ll l lm ln">...</span><span id="6123" class="lj jy hu lf b fv lr ll l lm ln">main :: IO ()<br/>main = do<br/>  ref &lt;- newIORef M.empty<br/>  pool &lt;- runStdoutLoggingT $ createSqlitePool "spock_example.db" 5<br/>  runStdoutLoggingT $ runSqlPool (runMigration migrateAll) pool<br/>  ...</span></pre><p id="5a9c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">既然我们已经创建了这个池，我们可以将它传递给我们的配置。我们将使用<code class="eh lo lp lq lf b">PCPool</code>构造函数。我们现在使用一个<code class="eh lo lp lq lf b">SQLBackend</code>作为我们的服务器，所以我们也必须改变路由器的类型来反映这一点:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="65d5" class="lj jy hu lf b fv lk ll l lm ln">main :: IO ()<br/>main = do<br/>  …<br/>  spockConfig &lt;-<br/>    defaultSpockCfg EmptySession (PCPool pool) (AppState ref)<br/>  runSpock 8080 (spock spockConfig app)</span><span id="f4f0" class="lj jy hu lf b fv lr ll l lm ln">app :: SpockM SqlBackend MySession AppState ()<br/>app = ...</span></pre><p id="ac04" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们想更新我们的route操作来访问数据库而不是地图。但是首先，我们将编写一个助手函数，它将允许我们从我们的<code class="eh lo lp lq lf b">SpockM</code>单子中调用任何SQL动作。看起来是这样的:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="1dc3" class="lj jy hu lf b fv lk ll l lm ln">runSQL :: (HasSpock m, SpockConn m ~ SqlBackend)<br/>  =&gt; SqlPersistT (LoggingT IO) a -&gt; m a<br/>runSQL action = runQuery $ \conn -&gt; <br/>  runStdoutLoggingT $ runSqlConn action conn</span></pre><p id="856c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">其核心是Spock库中的<code class="eh lo lp lq lf b">runQuery</code>函数。因为我们的路由器现在使用<code class="eh lo lp lq lf b">SpockM SqlBackend</code>而不是<code class="eh lo lp lq lf b">SpockM ()</code>，所以它工作了。现在让我们写几个可以使用的SQL操作。我们将让一个按名称执行查找，并返回第一个匹配的条目的<code class="eh lo lp lq lf b">Key</code>，如果存在的话。然后我们还会有一个插入新名字并返回它的键的函数。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="1380" class="lj jy hu lf b fv lk ll l lm ln">fetchByName<br/>  :: T.Text<br/>  -&gt; SqlPersistT (LoggingT IO) (Maybe Int64)<br/>fetchByName name = (fmap (fromSqlKey . entityKey)) &lt;$&gt; <br/>  (listToMaybe &lt;$&gt; selectList [NameEntryName ==. name] [])</span><span id="984c" class="lj jy hu lf b fv lr ll l lm ln">insertAndReturnKey<br/>  :: T.Text<br/>  -&gt; SqlPersistT (LoggingT IO) Int64<br/>insertAndReturnKey name = fromSqlKey &lt;$&gt; insert (NameEntry name)</span></pre><p id="8760" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们可以用这些功能代替我们的地图了！</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="6e28" class="lj jy hu lf b fv lk ll l lm ln">app :: SpockM SqlBackend MySession AppState ()<br/>app = do<br/>  get root $ text "Hello World!"<br/>  get ("hello" &lt;//&gt; var) $ \name -&gt; do<br/>    existingKeyMaybe &lt;- runSQL $ fetchByName name<br/>    visitorNumber &lt;- case existingKeyMaybe of<br/>      Nothing -&gt; runSQL $ insertAndReturnKey name<br/>      Just i -&gt; return i<br/>    text ("Hello " &lt;&gt; name &lt;&gt; ", you are visitor number " &lt;&gt; <br/>      T.pack (show visitorNumber))</span></pre><p id="e6fc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">瞧啊。我们可以在运行之间关闭我们的服务器，我们将保留我们已经看到的访问者！</p><h1 id="0961" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">跟踪用户</h1><p id="bb55" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">现在，使用一条路线来识别我们的用户并不是我们想要做的。毕竟任何人都可以参观任何路线！因此，对于服务器的最后一次修改，我们将添加一个小的“登录”功能。我们将使用应用程序的会话来跟踪用户当前正在访问什么。我们新流程将如下所示:</p><ol class=""><li id="e394" class="ls lt hu ja b jb jc jf jg jj lu jn lv jr lw jv lx ly lz ma dt translated">我们将改变进入路线到<code class="eh lo lp lq lf b">/hello</code>。</li><li id="976c" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated">如果用户访问这个，我们将显示一个字段，允许他们输入自己的名字并登录。</li><li id="9eac" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated">按下登录按钮将发送一个post请求到我们的服务器。这将更新会话，使会话ID与用户名相匹配。</li><li id="1ddc" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated">然后，它会将用户发送到<code class="eh lo lp lq lf b">/home</code>页面，该页面会问候用户并显示一个注销按钮。</li><li id="ed46" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated">如果他们退出，我们就取消这个会话。</li></ol><p id="6200" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，使用会话不同于我们在第一部分中使用的应用程序状态图。我们与使用我们服务器的每个人分享应用状态。但是会话将包含用户特定的引用。</p><h1 id="0488" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">添加会话</h1><p id="e954" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">第一步是改变我们的会话类型。同样，我们将在地图周围使用一个<code class="eh lo lp lq lf b">IORef</code>包装器。不过这一次，我们将使用简单的类型同义词来简化事情。这是我们的类型定义和更新后的main函数。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="d71b" class="lj jy hu lf b fv lk ll l lm ln">type MySession = IORef (M.Map T.Text T.Text)</span><span id="2ae0" class="lj jy hu lf b fv lr ll l lm ln">main :: IO ()<br/>main = do<br/>  ref &lt;- newIORef M.empty<br/>  -- Initialize a reference for the session<br/>  sessionRef &lt;- newIORef M.empty<br/>  pool &lt;- runStdoutLoggingT $ createSqlitePool "spock_example.db" 5<br/>  runStdoutLoggingT $ runSqlPool (runMigration migrateAll) pool<br/>  -- Pass that reference!<br/>  spockConfig &lt;-<br/>    defaultSpockCfg sessionRef (PCPool pool) (AppState ref)<br/>  runSpock 8080 (spock spockConfig app)</span></pre><h1 id="fdb8" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">更新Hello页面</h1><p id="e9c4" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">现在让我们更新我们的“Hello”页面。看看下面的附录，看看我们的<code class="eh lo lp lq lf b">helloHTML</code>长什么样。这是一个带有用户名字段和提交按钮的“登录”表单。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="b49a" class="lj jy hu lf b fv lk ll l lm ln">-- Notice we use MySession!<br/>app :: SpockM SqlBackend MySession AppState ()<br/>app = do<br/>  get root $ text "Hello World!"<br/>  get "hello" $ html helloHTML<br/>  ...</span></pre><p id="fdaf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们需要为<code class="eh lo lp lq lf b">/hello</code>的post请求添加一个处理程序。我们将使用<code class="eh lo lp lq lf b">post</code>函数来代替<code class="eh lo lp lq lf b">get</code>。现在，我们将使用<code class="eh lo lp lq lf b">body</code>函数提取post主体，而不是采用参数的操作。如果我们的应用程序更复杂，我们会希望使用一个合适的库来进行表单URL编码和解码。但是对于这个小例子，我们将使用一个简单的助手<code class="eh lo lp lq lf b">decodeUsername</code>。您可以在附录中查看该助手。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="2235" class="lj jy hu lf b fv lk ll l lm ln">app :: SpockM SqlBackend MySession AppState ()<br/>app = do<br/>  …<br/>  post "hello" $ do<br/>    nameEntry &lt;- decodeUsername &lt;$&gt; body<br/>    ...</span></pre><p id="054a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们希望使用我们的会话保存该用户，然后将他们重定向到主页。首先，我们需要获得会话ID和会话本身。为此，我们使用函数<code class="eh lo lp lq lf b">getSessionId</code>和<code class="eh lo lp lq lf b">readSession</code>。然后，我们希望通过将名称与会话ID相关联来更新我们的会话。最后，我们将重定向到<code class="eh lo lp lq lf b">home</code>。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="cbc1" class="lj jy hu lf b fv lk ll l lm ln">post "hello" $ do<br/>  nameEntry &lt;- decodeUsername &lt;$&gt; body<br/>  sessId &lt;- getSessionId <br/>  currentSessionRef &lt;- readSession<br/>  liftIO $ modifyIORef' currentSessionRef $<br/>    M.insert sessId (nameEntryName nameEntry)<br/>  redirect "home"</span></pre><h1 id="f89f" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">主页</h1><p id="94b6" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">现在，在主页上，我们要检查是否有一个用户与会话ID相关联。如果我们这样做了，我们将向用户显示一些问候文本(并显示一个注销按钮)。同样，我们需要调用<code class="eh lo lp lq lf b">getSessionId</code>和<code class="eh lo lp lq lf b">readSession</code>。如果我们没有与会话相关联的用户，我们将把他们弹回<code class="eh lo lp lq lf b">hello</code>页面。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="6a50" class="lj jy hu lf b fv lk ll l lm ln">get "home" $ do<br/>  sessId &lt;- getSessionId <br/>  currentSessionRef &lt;- readSession<br/>  currentSession &lt;- liftIO $ readIORef currentSessionRef<br/>  case M.lookup sessId currentSession of<br/>    Nothing -&gt; redirect "hello"<br/>    Just name -&gt; html $ homeHTML name</span></pre><p id="3a29" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们需要的最后一项功能是“注销”。我们将按照熟悉的模式获取会话ID和会话。这一次，我们将通过清除会话密钥来更改会话。然后我们将用户重定向回<code class="eh lo lp lq lf b">hello</code>页面。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="9708" class="lj jy hu lf b fv lk ll l lm ln">post "logout" $ do<br/>  sessId &lt;- getSessionId <br/>  currentSessionRef &lt;- readSession<br/>  liftIO $ modifyIORef' currentSessionRef $ M.delete sessId<br/>  redirect "hello"</span></pre><p id="859b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们的网站跟踪我们用户的会话！我们可以在不同的会话中以不同用户的身份访问同一个页面！</p><h1 id="6db1" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="4ceb" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">这就结束了我们对斯波克图书馆的探索！我们已经对Spock提供的一些不同特性进行了浅显而广泛的研究。我们看到了在服务器上跨请求保存信息的几种不同方法！连接到数据库是最重要的。但是使用会话是一个非常高级的功能，在Spock中非常简单！</p><p id="6c44" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">想了解更多Haskell web库的例子，请看我们的<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Web技能系列</a>！您还可以下载我们的<a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>来获得更多创意！</p><h1 id="1aff" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">附录— HTML片段和助手</h1><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="3d35" class="lj jy hu lf b fv lk ll l lm ln">helloHTML :: T.Text<br/>helloHTML =<br/>  "&lt;html&gt;\<br/>    \&lt;body&gt;\<br/>      \&lt;p&gt;Hello! Please enter your username!\<br/>      \&lt;form action=\"/hello\" method=\"post\"&gt;\<br/>        \Username: &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;\<br/>        \&lt;input type=\"submit\"&gt;&lt;br&gt;\<br/>      \&lt;/form&gt;\<br/>    \&lt;/body&gt;\<br/>  \&lt;/html&gt;"</span><span id="7fdb" class="lj jy hu lf b fv lr ll l lm ln">homeHTML :: T.Text -&gt; T.Text<br/>homeHTML name =<br/>  "&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello " &lt;&gt; name &lt;&gt; <br/>    "&lt;/p&gt;\<br/>    \&lt;form action=\"logout\" method=\"post\"&gt;\<br/>      \&lt;input type=\"submit\" name=\"logout_button\"&lt;br&gt;\<br/>    \&lt;/form&gt;\<br/>  \&lt;/body&gt;\<br/>  \&lt;/html&gt;" </span><span id="944e" class="lj jy hu lf b fv lr ll l lm ln">-- Note: 61 -&gt; '=' in ASCII<br/>-- We expect input like "username=christopher"<br/>parseUsername :: B.ByteString -&gt; T.Text<br/>parseUsername input = decodeUtf8 $ B.drop 1 tail_<br/>  where<br/>    tail_ = B.dropWhile (/= 61) input</span></pre></div></div>    
</body>
</html>