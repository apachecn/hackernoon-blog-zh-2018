<html>
<head>
<title>Build a React Shuffle Blog using the Spotify API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spotify API创建一个React Shuffle博客</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-react-shuffle-blog-using-the-spotify-api-d5498d47c47b?source=collection_archive---------5-----------------------#2018-09-25">https://medium.com/hackernoon/build-a-react-shuffle-blog-using-the-spotify-api-d5498d47c47b?source=collection_archive---------5-----------------------#2018-09-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4ef6ca8f0503877f31252d22b65dd6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEYAXUdTbNWE-UEH6Y0s7A.jpeg"/></div></div></figure><h1 id="bca1" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">TL；博士:</h1><p id="32e9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><a class="ae ky" href="https://cosmicjs.com/apps/react-spotify-blog" rel="noopener ugc nofollow" target="_blank"> React Spotify博客演示</a> <br/> <a class="ae ky" href="https://github.com/cosmicjs/react-spotify-blog" rel="noopener ugc nofollow" target="_blank"> React Spotify博客源代码</a></p><p id="1a48" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">先决条件</strong></p><p id="23d3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们在这个项目中使用了Node JS和npm，所以在我们开始之前，请确保您已经安装了它们。我还将对React、CSS Grid或Flexbox有所了解，所以在开始之前最好先熟悉一下，没有ES7 async/await来处理AJAX请求之类的异步代码，我就活不下去。如果这些术语中的任何一个对你来说听起来很陌生，我都不会高度推荐来自<a class="ae ky" href="https://wesbos.com/" rel="noopener ugc nofollow" target="_blank">韦斯·博斯</a>的教程——他是我所知道的最聪明、最有魅力的加拿大人！</p><p id="df2d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">最后，如果你真的想按下播放键听音乐，你需要一个Spotify高级会员。如果你没有一个也可以——你只需在Spotify中手动打开你的播放列表，然后打开我们制作的新播放列表。</p><p id="ef8e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">计划好了</strong></p><p id="56b2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我是一个守旧派，所以我总是喜欢从一张纸开始，准确地计划出我想要的东西的样子和用途。但是我的书写很糟糕，所以我的论文基本上是这样的:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/5009c6b7aa8a58a2c2510088e9c04974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n4DHQ1C6bLEwHdzx.png"/></div></div></figure><p id="9466" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我想要两个主要功能:首先，我希望能够向我最喜欢的艺术家之一致敬，并有一个按钮直接连接到他们在Spotify上的专辑播放列表，这样读者就可以立即开始收听。也应该有一种方法让他们阅读关于其他艺术家的帖子。其次，我认为Spotify不让你按专辑进行原生洗牌是犯罪行为(你应该如何进入艺术家的最佳状态？)所以用户应该能够按照专辑来打乱自己的播放列表。如果他们只有一张专辑中的几首歌曲，他们也应该能够自动引入该专辑中的其他歌曲。</p><p id="3b05" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">使用React时的另一个关键计划步骤是列出您将需要的组件。组件是用户界面的小模块，它们可以组合在一起构成完整的用户界面。不是每个元素都必须是它自己的组件，但是我们希望得到主要的东西。根据我的图纸(粗略的线框)，我们需要大约7个组件:</p><p id="ae0f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">应用程序/容器/包装器</strong></p><p id="514c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">特色艺人贴</strong></p><p id="c44c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">作者</p><p id="4c79" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">菜单选择其他岗位</strong></p><p id="0e6f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv"> Spotify容器</strong></p><p id="706a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">连接组件(当用户尚未登录时)</p><p id="6759" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">播放列表选择器</p><p id="54b6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">挑选合适的工具</strong></p><p id="bcfa" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在我知道了我想要什么，下一步是看看是否有任何现有的工具或库给我一个好的开始。有几个，所以很多工作是为我们做的！</p><ul class=""><li id="342f" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">Cosmic JS:优秀的内容管理系统，向我们的应用程序公开一个简单灵活的API和数据。Cosmic JS 比Wordpress之类的东西更简单、更轻便，但给了我们以后添加新艺术家纪念的灵活性，而无需重新部署应用程序。</li><li id="de25" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">create-react-app:我是react的人，但是像这样为一个单页应用程序设置所有的配置可能会很复杂。脸书有一个很棒的回购和工具，叫做<a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>，可以随时定制。</li><li id="de18" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">CSS Grid，Flexbox:说到CSS，我不是老派:Grid和Flexbox比老派更容易预测float:left。我喜欢用实际上有意义的CSS系统开始一个新的项目</li><li id="aa3d" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">Material-UI:扁平设计和<a class="ae ky" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank">材质UI </a>风靡一时，由于我不太喜欢演示，所以有一些像样的基于react的设计组件是很好的。</li><li id="728e" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">Spotify API: Spotify拥有最干净、记录最完整的REST APIs之一。在javascript前端使用JMPerez的优秀包装器库<a class="ae ky" href="https://github.com/jmperez/spotify-web-api-js" rel="noopener ugc nofollow" target="_blank"> spotify-web-api-js </a>会更容易</li></ul><p id="03bb" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">从创建-反应-应用开始</strong></p><p id="c5ae" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们从克隆create-react-app开始。他们在<a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">回购</a>有简单的说明。如果您的npm版本是5.2或更高版本，您可以打开终端，导航到项目的新目录并键入。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="1b89" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我正在运行npm版本4.2.0，因此我必须先安装create-react-app命令行工具(CLI工具)，然后使用CLI工具创建应用程序。记住，一旦完成，还要执行git init，这样就可以保存您的工作。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="dd54" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">使用npm start quick启动示例，以确保一切正常。如果它看起来像这样，那么伟大的工作！如果没有，你将会有一些问题…我不喜欢create-react-app给我们的文件结构，所以我喜欢修改它，把我们的组件放在src下它们自己的子文件夹中。这样，我们可以在src中保存不直接影响UI的帮助文件，并将组件放在它们自己的文件夹中，这样它们更容易浏览。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/ea5d83287d93a70d0e46a21e035a69f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/0*aXTPRBHhOCkXrXUx.png"/></div></figure><p id="5ffd" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">create-react-app默认文件结构</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/95a239dc4f345bd8ff08b4748a2782a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/0*3MInfKNjga1Fxuvv.png"/></div></figure><p id="b796" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我的首选文件结构</p><p id="7d52" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果您执行相同的操作，请记住进入index.js并更改App组件的导入引用，以便index.js可以在new components子文件夹中找到它。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="cddd" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">在</strong>中设置结构</p><p id="2fc2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们先用一些虚拟组件设置整体结构，然后我们可以逐个深入研究。我们只是将组件重新定位为我们的顶级包装器。把JSX代码取出来，换成这个:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="7e09" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">JSX/HTML代码只告诉浏览器元素是什么，所以我们需要一些CSS。我们将使用CSS网格来布局一个类似于线框的结构。针对800像素以下屏幕的媒体查询将所有内容都放在一个移动列中。现在让我们把这段代码复制到App.css中，评论会解释一些亮点。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="fbe8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们看看！使用chrome devtools并高亮显示会显示网格。我们做5行而不是3行的原因是因为我们希望Spotify播放器能够从页眉到页脚，但在左侧，我们希望特色帖子有2/3的垂直空间，其他帖子只有1/3。我们可能有4排，但5排对我来说是对的。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/ce488c3f63a8bb6d0720cae18f14d91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ysu60lmstZxZkibc.png"/></div></div></figure><p id="a89d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">好吧！让我们构建第一个真正的显示组件:首先，让我们从Material UI(又名Mui)中获得一些漂亮的组件。他们的<a class="ae ky" href="https://material-ui.com/getting-started/installation/" rel="noopener ugc nofollow" target="_blank">入门</a>页面会带我们浏览。首先，我们需要安装他们的节点包。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="68fb" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们还需要将Roboto字体添加到我们的index.html中，这样一切都可以正常显示。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="ce0b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">Mui有一个很棒的背景组件，叫做Paper，类似于引导面板。他们还为标题和副标题使用了排版组件。它看起来很经典，而且我听说如果你想改变你的外观，使用排版可以更容易地应用他们的“主题”。</p><p id="b13d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们继续在我们的组件文件夹中创建两个文件:FeaturedPost.js和FeaturedPost.css。我通常复制App.js和App.css，只需将' App '替换为' FeaturedPost ',然后编辑，但您的调用。这些文件应该是这样的:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c611" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果我们在同一个地方，应用程序应该是这样的:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/c179511581c2a59ec88ad336c62ce0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mdTmWR_Un3aa_jep.png"/></div></div></figure><p id="35b4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">好的，太好了。但是没有比静态内容更无聊的了。我们把一些数据连接到这个东西上怎么样？数据意味着内容，这意味着我们已经准备好建立宇宙JS了！</p><p id="a389" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">从Cosmic JS获取动态内容</strong></p><p id="ed98" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">Cosmic JS是一个后端内容管理系统，为我们提供了最好的应用程序开发和内容。在内容方面，我们得到了类似Wordpress界面的所有便利，营销团队或博客可以使用它来轻松地添加新帖子、作者或他们喜欢的任何东西。实际上，我发现Wordpress更容易，因为它更干净、更简单。但在应用程序开发方面，我们得到了一个非常干净、简单的json-API，我们可以将它放入我们的crisp React应用程序(或任何其他您喜欢的框架)。我们不必处理php和插件，以及Wordpress强加给我们的所有杂乱的东西，这些东西会使网站膨胀。耶！</p><p id="af60" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">首先，我们在<a class="ae ky" href="https://cosmicjs.com/" rel="noopener ugc nofollow" target="_blank">宇宙JS </a>创建一个新的免费账户。您必须验证您的电子邮件，或者您可以使用GitHub登录。我推荐使用GitHub，以便以后更容易部署。</p><p id="b983" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一旦你设置了你的帐户，你需要创建一个新的桶，这基本上是我们的应用程序的所有内容数据将去的地方。您将为桶使用一个唯一的名称(我使用了oldschoolshuffle)。选择从头开始并保存存储桶。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/fd228f8608a7edc10433ba84e028d9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xA1Tho_js_-MOwKi.png"/></div></div></figure><p id="f285" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在一个存储桶中，数据被组织成对象、对象类型和文件。这是一个非常轻便灵活的系统。这些分别是什么？</p><ul class=""><li id="0e18" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">对象类型基本上是模式:它们描述了你可能想在你的应用程序中使用的一类东西，以及知道关于那个东西的什么细节是重要的。在我们的情况下，我们需要帖子，我们需要作者来写这些帖子。如果你正在做一个关于世界地理的应用程序，你可能有一个国家对象类型，或者如果你正在做一个旅行社应用程序，你可能有一个飞机航班或酒店的对象类型。重要的是，一个对象类型有元字段(属性),包含你想知道的关于该类型事物的所有信息。</li><li id="5711" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">对象是你可能想在应用中引用的任何离散的东西。关于凯茜·玛斯格蕾芙斯的帖子是post对象类型的对象。奥斯汀到波士顿的AA2345航班可能是旅行社应用程序中航班类型的对象。</li><li id="cd43" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">文件是您可能需要使用的媒体或二进制文件(有时称为“静态”文件)。通常这些是图片，但也可能是可下载的内容、白皮书、MP3或其他任何东西。</li></ul><p id="0461" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你也可以设置多个用户，但是这个意义上的用户是指在Cosmic JS中有权限修改东西的人(比如你作为一个开发者，或者一个博客作者)，而不是你的应用中的用户。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/e60793122f7c46892cd55fdee7846ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9xktPvR9VkY4qoGC.png"/></div></div></figure><p id="14d9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们将首先为作者设置我们的对象类型，因为我们希望每个人都知道谁喜欢老派的倾听。基于我们的线框一个作者需要一个名字和一个头像图像，所以我们有更多的天赋。点击左边菜单中的“添加对象类型”,然后在“基本设置”下，为单数名称添加作者，为复数名称添加作者。</p><p id="e9c9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">接下来，单击元字段模板选项卡。每个对象类型都会自动获得一个标题和一个内容元字段，所以我们不需要添加一个标题元字段，但是我们需要为头像添加一个元字段。点击蓝色加号，你会看到一个不同类型的元字段菜单。我们想要一个图像，所以选择它。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mf"><img src="../Images/a3829b7c94032459c506cf81b0bc7653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Jk2LYTJG1jOPnmgn.png"/></div></div></figure><p id="84a6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">请记住，我们还没有确定一个具体的作者，所以除非你想设置一个默认值，否则请抵制拖放图片的诱惑。更重要的是，我们将标题设置为avatarImage，这样我们可以在以后为它分配内容。我喜欢camelcasetowrithings thillhavetoseinmycodelater，但在这种情况下你不必这样做，因为Cosmic JS会自动分配一个我们将在代码中使用的键。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/9d41df9d52a1551d2769849d05389a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*frWcpSUV3DgiLuMv.png"/></div></div></figure><p id="7f32" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">完成后，单击保存对象类型按钮。现在我们可以创建两个特定的作者。现在，您应该会在左侧菜单下看到一个新的Authors文件夹。点击它，你应该有一个空白部分和一个添加作者按钮。我建议你点击那个按钮。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/3cba56852176903c3eae91a438c1cc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-sSoXXT8_6MPBKHO.png"/></div></div></figure><p id="e0d9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">干得好！把作者的名字(我用埃尔维斯·考斯特罗)作为标题。您还会看到我们在Object类型中创建的avatarImage元字段继续存在，现在我们可以选择一个图像，比如一个老式的RV拖车，用作头像。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/2c9b43362ab3e71c6123d138b1108431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rVCuync8_dAF7LR5.png"/></div></div></figure><p id="3e25" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">当我们完成后，按下发布按钮保存该作者并关闭屏幕。</p><p id="d897" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">对第二个作者做同样的事情，只是为了好玩。然后我们需要通过再次点击菜单中的Add Object Type为我们的文章构建对象类型。将Post/Post设置为单数/复数，然后转到图元字段模板选项卡。</p><p id="1089" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们为帖子添加了两个元字段:spotifyArtistId和author。第一个是spotifyArtistId，它将是一个纯文本输入，我们将在那里存储一个唯一的Id，Spotify使用它来识别API中的音乐艺术家。</p><p id="0832" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">第二个元字段(author)将是一个单一对象关系元字段，这意味着我们将把帖子与我们前面创建的对象类型的单一作者连接起来。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/12fda0a743b77116e7de640c441fd33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3dwaWYHcfDfUNiQp.png"/></div></div></figure><p id="dc13" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">确保为“作者”元字段选择“按对象类型限制搜索”，并从下拉菜单中选择“作者”。一个帖子是一个帖子的作者是没有意义的。完成后，单击保存对象类型，我们将返回到控制面板。</p><p id="b2e1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">亲提示！如果你在作者之前发帖(操之过急！)您可以返回并编辑您的Post对象来添加author元字段。从菜单中选择文章，然后单击齿轮图标。我花了一段时间才想明白！</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/2d9d0f8975792ea8ecf72b15bd842ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/0*8q_H6MyrTEFK1zB5.png"/></div></figure><p id="ec54" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">好了，现在我们只需要发几个帖子，然后我们就可以完成初始的内容设置了！点击帖子，然后App帖子，我们来创建3。使用艺术家的名字作为标题，在内容部分表达你对他们的敬意(去吧，我会等着)，并从下拉菜单中为每个人选择一个作者。请注意，内容区域是支持HTML的，因此您可以在其中发挥一点创造力。您还需要spotifyArtistId，它看起来像这样:70kkdajctXSbqSMJbQO424。您可以在这里查找您最喜欢的艺术家的id，或者您可以使用这些:</p><ul class=""><li id="cecb" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">凯茜·玛斯格蕾芙斯:70kkdajctXSbqSMJbQO424</li><li id="848e" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">瑞安·宾汉:31z9f9AyPawiq0qlBO1M3i</li><li id="1ec7" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">Ted Leo: 5hbH3dvtk49g07qpc1QwPe</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/642893a3ef6f3b21b3f366e2126de4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JhjvoJeYnJue65OU.png"/></div></div></figure><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/c3d2ae319d1ed3c10a2d8f57d723d2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bZEEzE3uueCBnOM9.png"/></div></div></figure><p id="67f6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们终于完成了内容！多好的脑力锻炼啊。让我们回到一些简单的事情上，比如用第三方数据编写移动响应单页面应用程序。</p><p id="999c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">连线宇宙JS内容</strong></p><p id="b9ea" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">首先:如果你对React感到不舒服，你现在应该停止阅读，去看看韦斯·博斯的<a class="ae ky" href="https://reactforbeginners.com/" rel="noopener ugc nofollow" target="_blank"> React初学者</a>课程，你将真正成为一名专家。就像我们在网格CSS方面所做的一样，我将努力保持最高水平。</p><p id="6149" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">听起来不错吧？好了，让我们从React中所有好的东西开始的地方开始——在我们的顶层组件。在React中，一切都与状态(组件的内部条件)和属性(传递给子组件的数据或函数)有关。让我们添加一个构造函数到。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="af1b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">state中的属性是我们将从Cosmic JS中获得的一切，以使博客/敬意成为这项工作的一部分:</p><ul class=""><li id="6d11" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">dataReceived将从false开始，在我们从Cosmic JS中获取数据后变为true。这让我们等到获得正确呈现文章所需的数据后再呈现文章。</li><li id="58fa" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">posts是一个数组，我们将在其中存储从Cosmic JS获得的所有帖子。</li><li id="af91" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">authors是一个数组，我们将在其中存储所有来自宇宙JS的作者。</li><li id="c7a5" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">featuredPostIndex是一个整数，我们将使用posts数组来确定在特色文章组件中显示哪个文章。其他职位将在“其他职位”组件中列出。</li><li id="fd1d" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">其他帖子将始终是帖子的子集，不包括任何当前有特色的帖子。</li></ul><p id="00de" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在，我们需要将React应用程序连接到我们的Cosmic JS API，并获取我们在CMS中输入的数据。React组件真的不应该做太多繁重的工作，所以为了模块化和可读性，转到src文件夹并添加一个名为cosmicFunctions.js的新文件(这将在组件目录之外)。</p><p id="f223" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">Cosmic JS在npm上提供了一个非常方便的节点模块，可以轻松获取我们需要的数据，而无需处理CORS(跨源请求)问题或ajax请求。让我们先用npm安装它。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="910a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们还需要添加一个. env文件，以我们的Bucket命名(也称为slug)。您不希望在代码中暴露这些敏感数据，所以我们将它们存储在一个环境变量中，您不需要将它上传到您的公共存储库中。幸运的是，create-react-app使这变得很容易，所以您只需要在根目录下创建一个. env文件。确保它在根目录中，而不是在您的src目录中，并且以点开始。我们还需要以REACT_APP_开始变量名，否则create-react-app会忽略它。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="8bf5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果你不知道你的桶蛞蝓点击设置-&gt;基本设置在你的宇宙JS仪表板，你会看到它在第二行。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/37ea83140d9fe962b67a38fa8c9de818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FhtSVIQIqJf-URWB.png"/></div></div></figure><p id="c332" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在我们已经设置好了，我们将把Cosmic JS节点模块导入到新的cosmicFunctions.js文件中，并添加两个函数getCosmicJsData和organizeCosmicJsDataByObjectType。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c59d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们来看看getCosmicJsData。首先，在定义函数之前，您会注意到export async。导出让我们稍后可以使用这个函数。async使我们能够在函数中使用异步方法，在我们的例子中是对Cosmic JS的ajax API请求。异步意味着我们向API发送一个请求，开始我们的业务，当我们得到一个响应时，我们的应用程序将返回函数并使用数据。</p><p id="316c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这个异步的东西曾经是一个真正的<a class="ae ky" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">痛苦</a>在<a class="ae ky" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">对接</a>中，但是现在我们可以简单地把关键字await放在任何异步方法之前，代码会自动等待一个有用数据的响应，然后继续。太牛逼了。</p><p id="e83e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们仔细看看第10行:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="1849" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">哇，那里发生了很多事。逻辑是这样的:bucket.getObjects()是一个异步方法，它告诉Cosmic JS向我们发送他们拥有的所有东西的有效载荷。因为我们没有太多的数据，所以最简单的方法就是现在(当页面第一次加载时)从API中获取所有数据，然后自己进行排序。和API一样，许多有效负载的<a class="ae ky" href="https://api.cosmicjs.com/v1/oldschoolshuffle?pretty=true&amp;hide_metafields=true" rel="noopener ugc nofollow" target="_blank">是我们不需要的元数据。因此，我们将该调用放在括号中，只取它的objects属性，这是我们拥有的所有帖子和作者的数组。</a></p><p id="aea5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在我们有了所需的数据，这些数据是我们所有对象类型的混合体，但是为了在我们的状态中干净地存储这些数据，我们希望更加有组织性。这就是我们将arrayOfAllObjectsInBucket传递给organizeCosmicJsDataByObjectType函数的原因。它映射整个数组，并根据不同的对象类型和该类型对象的数组返回带有键的对象。我们可以只查找帖子和作者，但这种方式更灵活，如果我们决定将帖子重命名为HomagesToGreatness或类似的名称，就不需要更改。</p><p id="bb65" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">无论如何，转换后的数据看起来像这样:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="d979" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">看看那会给我们州带来多大的好处？让我们把它钩起来！React组件内置了<a class="ae ky" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">生命周期</a>方法，我们可以告诉它在加载、关闭、重新渲染等时做什么。将外部数据装入组件的最佳时间是在组件首次装入<a class="ae ky" href="https://css-tricks.com/dom/" rel="noopener ugc nofollow" target="_blank"> DOM </a>之后(如果您不知道DOM是什么，您现在应该离开了)所以让我们添加一个componentDidMount方法，并将getCosmicJsData函数放入其中。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="a32d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这段代码的几个要点是:</p><ul class=""><li id="6512" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">记住，您必须导入我们的cosmicFunctions助手库来访问getCosmicJsData。这也是一个目录，所以你必须使用<a class="ae ky" href="https://stackoverflow.com/questions/7591240/what-does-dot-slash-refer-to-in-terms-of-an-html-file-path-location" rel="noopener ugc nofollow" target="_blank">../ </a></li><li id="be1a" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">componentDidMount必须是异步函数。它包含getCosmicJsData，它必须是异步的，因为它包含bucket.getObjects()，后者本来就是异步的。</li><li id="1da1" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我尝试总是将异步代码包装在try/catch块中，因为你永远不知道它们是否会失败。</li><li id="de3b" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">奇怪的const {posts，authors} = …格式是<a class="ae ky" href="https://wesbos.com/destructuring-objects/" rel="noopener ugc nofollow" target="_blank"> ES6析构</a>，基本上和posts = someObject.posts一样，析构对于分解对象很棒。</li><li id="7c88" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">在React中，除了在构造函数中，永远不能将属性赋给this.state。这样做违反了一个叫做<a class="ae ky" href="https://reactjs.org/docs/update.html" rel="noopener ugc nofollow" target="_blank">不变性</a>的概念，但是足以说它破坏了React。相反，您总是使用this.setState和React为您处理它(谢谢React！)</li></ul><p id="dc84" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们也来看看这条粗糙的线:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="6125" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这是怎么回事？简而言之，它告诉我们在收到我们需要的数据之前不要渲染。React将此称为<a class="ae ky" href="https://reactjs.org/docs/conditional-rendering.html" rel="noopener ugc nofollow" target="_blank">条件渲染</a>，它可以防止难看的空白组件或错误。</p><p id="f561" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">实际上，它只是一个三元运算符，如果this.state.dataReceived为真，则传递JSX React组件，否则呈现一个空字符串。由于我们更新了这个. state . data，componentDidMount React现在知道何时显示FeaturedPost是安全的。</p><p id="a6a4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">最后一件可怕的事情:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="eba6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们之前制作的React组件也是如此。它需要Post对象中的数据来显示艺术家姓名和敬意。this.state.posts是我们从Cosmic JS得到的Post对象数组。</p><p id="28fb" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">this.state.featurePostIndex只是一个数组索引，用来挑选数组中我们感兴趣的帖子，比如posts[0]。所以我们所做的就是识别一个Post对象，并将其作为一个名为Post的属性(props)传递给FeaturedPost。这样我们可以使用子组件中的数据，即使我们在父组件中获得了数据！</p><p id="a201" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们继续实际显示数据。</p><p id="760c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">展示我们对凯茜·玛斯格蕾芙斯的敬意</strong></p><p id="1f12" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们直接进入代码，在这里潜水。我们将修改之前编写的代码，从我们刚刚传递的post属性中获取数据。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="b0a0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们还不会处理播放唱片目录按钮，但是我们用{this.props.post.title}替换了艺术家蛋糕，所以现在我们得到了动态的帖子标题/艺术家姓名。我们还用动态内容替换了内容，但它更复杂，因为来自Cosmic JS的内容元字段是HTML，而不仅仅是简单的文本。</p><p id="1ba1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">react<a class="ae ky" href="https://reactjs.org/docs/dom-elements.html" rel="noopener ugc nofollow" target="_blank">非常怀疑</a>将外部来源的HTML直接注入你的应用程序，因为这是一个重大的安全风险，但我们对此没有意见，因为我们控制着我们的宇宙JS数据，因为这只是一个示例应用程序。要使用外部HTML，您必须在div元素上使用dangerouslySetInnerHTML属性，还必须向它传递一个唯一格式化的对象，而不仅仅是作为常规字符串的HTML代码。基本上，他们使它变得很麻烦，所以你不会做错。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="fdf5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们还看到一个新组件，它也传递作者姓名和图片。你的父母给了你什么，总有一天你会传给你自己的孩子。</p><p id="2b55" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">非常简单，所以我们只需要复制代码。请记住，您需要在组件目录中为Author.js和Author.css创建文件，并记住在FeaturedPost.js的顶部导入Author.js。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="8660" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">做一个npm启动，看看它看起来像什么。希望是这样的？</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/8aae93c9e6f1d3483d66d0da712c60d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jgcviaqIMyKe0B9n.png"/></div></div></figure><p id="4945" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="https://www.urbandictionary.com/define.php?term=boom%20shakalaka" rel="noopener ugc nofollow" target="_blank">轰沙拉卡拉卡</a>。快完成内容了！不幸的是，这可能是内容中最棘手的部分。</p><p id="c478" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们分两部分来做。在我们获得动态之前，让我们使用Material UI的扩展面板组件来布局一个基本的哑组件。这意味着在组件目录中创建OtherPosts.js和OtherPosts.css文件。我们还需要进入组件，用新创建的虚拟组件替换占位符文本。代码如下:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="ddd1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">很多代码，但没有太可怕的。扩展面板的东西看起来很奇怪，但它的结构基本上是一样的</p><ul class=""><li id="8203" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">带嵌套</li><li id="ae27" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">元素和一个标签。如果这一切都正常，你应该有一个干净的可点击面板，展开显示我们的虚拟职位。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/04b6ad78bf5496488105c7bdf66d6e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZezZvDLw5rcjYh5w.png"/></div></div></figure><ul class=""><li id="db8d" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">让我们把数据放进去。当我们更新时，我们把其他帖子的道具传给了。因为otherPosts是其他帖子的数组，所以我们应该能够通过将<a class="ae ky" href="https://reactjs.org/docs/lists-and-keys.html" rel="noopener ugc nofollow" target="_blank">映射到other posts数组并使用来自每个帖子的数据来替换我们的虚拟元素。让我们现在就开始吧:</a></li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="49ed" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">那还不算太糟。使用{postObject.title}输入文章名称很简单。唯一令人惊讶的部分是这个关键属性，我们在其中加入了数组索引，这在我们的虚拟组件中是没有的。原因是React使用<a class="ae ky" href="https://reactjs.org/docs/lists-and-keys.html" rel="noopener ugc nofollow" target="_blank">键</a>属性来区分具有相同父元素的相似元素(比如</p><ul class=""><li id="2bd7" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">元素)，所以我们需要一个惟一的键来帮助反应，使它们保持直线。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/0aee23a6b0cc8137714de5068a61d532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*grXPrFOIXFS6grzT.png"/></div></div></figure><ul class=""><li id="6bd9" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">这并不比。那么为什么我认为是如此棘手呢？嗯<a class="ae ky" href="https://en.wikipedia.org/wiki/Mister_Ed" rel="noopener ugc nofollow" target="_blank">威尔伯</a>，难道我们不希望你能够点击另一个帖子并改变吗？哪个帖子被点击看起来像是。等等，是一个不同的组件…这意味着我们正在通过状态上游！我们到底要怎么做？</li><li id="04fa" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">这是心理柔术——你不要错过这个状态。还记得住在父(ie)里的this.state.featuredPostIndex吗？您在中编写一个方法来更改该状态，并将该方法传递给。</li><li id="5b54" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">有多元？想要更具体的东西吗？我们来编码吧。首先:</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="0e0b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这里需要注意一些变化:</p><p id="0892" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">添加了changeFeaturedPost方法:这是我们将传递给它的方法。然后可以使用帖子的正确索引调用该方法。这将依次改变state.featuredPostIndex。因为将state.featuredPostIndex传递给，所以会更新。简单的像馅饼！</p><p id="5c92" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">将所有帖子传递给:将需要所有帖子的数组，以便它可以确定所选帖子的索引。我们一会儿会解释更多细节。</p><p id="51d6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">将changedFeaturedPost方法传递给:通过传递函数本身，而不是状态，我们使能够调用它。请记住将它作为一个箭头函数传递，而不仅仅是{this.changedFeaturedPost}，否则React将会混淆，单击帖子将返回函数本身，而不是函数的结果。</p><p id="7a17" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在让我们更新</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="9fd0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">橡胶终于带着那个漂亮的手柄咔嚓方法上路了！事情是这样的:</p><p id="1fed" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">首先，我们必须将handleClick方法传递给Post的onClick方法。记住onClick是一个事件监听器，所以即使我们不使用它，你也必须传递事件。</p><p id="bdc7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这个方法在一篇文章被点击时被调用，并接收被点击的文章的Post对象。</p><p id="c6b0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">为了调用我们传递来的changeFeaturedPost方法，我们实际上需要查看所有帖子的数组(这就是为什么我们将它作为props.allPosts传递来),并返回与刚刚被点击的帖子相匹配的索引。Javascript有一个很棒的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener ugc nofollow" target="_blank"> array.findIndex </a>函数，我们可以在其中定义对象属性(在我们的例子中，我们正在寻找并返回索引。</p><p id="19b7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一旦我们有了那个索引，我们只需用它调用我们传递的changeFeaturedPost方法，瞧——React做剩下的事情！</p><p id="e1ef" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果一切顺利，我们现在应该能够点击一个帖子，看到被点击的特色帖子的变化，以及我们的其他帖子列表的调整。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/d4fbfa35b6e3a5e09c7bbb8f339c810c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TfnJabGnznu_lSoE.gif"/></div></div></figure><ul class=""><li id="745a" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">在使用Spotify之前有一点:你不是唯一一个讨厌在组件之间传递函数的人。这个应用程序很简单，但对于有十几个组件的应用程序，我强烈推荐使用<a class="ae ky" href="https://redux.js.org/basics/usagewithreact" rel="noopener ugc nofollow" target="_blank"> Redux </a>来管理你的状态和道具。这个想法基本上就像在一个地方有一个包含所有属性和函数的库，然后每个组件都有一个库卡来获取它需要的任何函数。这需要大量的设置，但是一旦你克服了最初的障碍，这是非常值得的。你也可以看看<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">反应环境</a>作为问题的另一个解决方案。</li><li id="f058" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated"><strong class="kc hv">第二部分Spotify整合的攻击</strong></li><li id="34b3" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我们现在将从我们的老学校Shuffle应用程序的第二部分开始，这是与Spotify的集成。我们再次从一张纸上的头脑风暴开始，但这一次我们将首先关注后端，最后处理前端组件。我们需要用Spotify做些什么？</li><li id="9d61" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">Spotify计划</li></ul><p id="e34f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我需要API做什么？</p><p id="a05d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">访问用户的Spotify</p><p id="be20" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">获取他们的播放列表</p><p id="31c4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">获取特定播放列表的曲目</p><p id="0070" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">获取特定播放列表的专辑</p><p id="275d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">获取特定专辑的曲目</p><p id="5048" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">创建播放列表</p><p id="1c94" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">无序播放播放列表</p><p id="a69f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">播放特定艺术家的唱片目录</p><p id="b6ea" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">获取艺术家的专辑</p><p id="40d9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这些工作是否已经完成，并且可以在此基础上进行构建？</p><p id="3f6c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">是啊！JMPerez的优秀<a class="ae ky" href="https://github.com/JMPerez/spotify-web-api-js" rel="noopener ugc nofollow" target="_blank"> spotify-web-api-js </a>包装器库！</p><p id="d359" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">向Spotify注册您的应用</strong></p><ul class=""><li id="03d9" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">Spotify有一个真正的全启动API，它有非常好的文档记录，他们用他们的<a class="ae ky" href="https://developer.spotify.com/documentation/web-api/quick-start/" rel="noopener ugc nofollow" target="_blank"> Web API教程来指导开发者，但是我们会试着快速开始。首先，你必须有一个Spotify听众帐户，如果你在这里，你可能已经有了。之后，你需要去你的</a><a class="ae ky" href="https://developer.spotify.com/dashboard/login" rel="noopener ugc nofollow" target="_blank">仪表盘</a>注册成为开发者，并通过获取客户端Id注册你的应用。</li><li id="64dc" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">登录后，控制面板如下所示:</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/e0a0ac844be9fd0e90d11608a6c5a2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gbVY890jrDt9R9pm.png"/></div></div></figure><ul class=""><li id="bb2f" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">他们会带你注册应用程序并获得一个客户端Id。如果你在做一个非商业应用(像这样的开源应用)是免费的，但我认为他们会对商业访问收费。完成后，您会在仪表板上看到一个客户Id。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/b0753472bfbca54a5028c19255be8e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*lLKeW_y6RTZeEt0o.png"/></div></figure><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/2d306b404c101b3740f9f6d3d5654830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/0*vP_taixg82T2KdQS.png"/></div></figure><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/07130c70da0127850cc8397eaee7558d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ctfHRBIIzc1mSUwB.png"/></div></div></figure><ul class=""><li id="d87d" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">我们将需要那个客户Id(我把我的Id弄模糊了)，所以继续把它保存在你的。env文件格式为REACT_APP_SPOTIFY_CLIENT_ID。如果你没有这样做作为设置的一部分，我们还需要为我们的应用程序设置一个“重定向URI”。单击仪表板中的“编辑设置”按钮，您应该会看到一个弹出窗口，如下所示:</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/e4ae5baf496fe92bb7ad042a581d6d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*l9bLEzybJoW1S7fk.PNG"/></div></figure><ul class=""><li id="b747" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">稍后，您将需要添加您的开发环境(如果您使用create-react-app，应该是<a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>)以及您的生产环境URL。把它保存在你的。env文件也可以作为REACT _ APP _ SPOTIFY _ DEVELOPMENT _ REDIRECT _ URI和REACT _ APP _ SPOTIFY _ PRODUCTION _ REDIRECT _ URI。你可以在你的宇宙JS仪表板中检查你的生产URI。</li><li id="7421" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">当我们发送登录请求时，Spotify将使用重定向URI来确认确实是我们。现在你的。env文件应该看起来像这样:</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="e06d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在我们进行设置的同时，让我们继续安装带有npm的<a class="ae ky" href="https://github.com/JMPerez/spotify-web-api-js" rel="noopener ugc nofollow" target="_blank"> spotify-web-api-js </a>，以及我们将使用的一些特定的<a class="ae ky" href="https://lodash.com/docs/4.17.10" rel="noopener ugc nofollow" target="_blank"> Lodash </a>助手函数。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="cb09" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们也在src目录中创建一个spotifyFunctions.js文件(在cosmicFunctions.js旁边)。不过里面会有很多代码，所以我们先导入我们的库，然后再讨论Spotify的认证是如何工作的。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="68ea" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">认证</strong></p><ul class=""><li id="3ad2" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">授权是每个web开发人员都害怕的事情之一。您必须一直这样做，但是这往往是跨源(CORS)错误、OAuth2服务器、Json Web令牌(JWT)、握手令牌、刷新令牌和授权HTTP头的雷区。</li><li id="f4d6" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">所有这些都是可行的，但是它们让我有点想吐，尤其是在一个小的演示应用程序上。Spotify支持<a class="ae ky" href="https://developer.spotify.com/documentation/general/guides/authorization-guide/" rel="noopener ugc nofollow" target="_blank"> 3种不同的认证方法</a>，但我们很幸运，他们提供了一个隐式的授权流。这不是很安全，但我们谈论的是音乐播放列表而不是银行账户，而且它只能用一个小时，所以你只能引起太多的麻烦。它对我们来说非常完美，因为它不需要任何服务器端代码。这很方便，因为默认情况下，create-react-app会隐藏快速路线。您可以用它来设置一个<a class="ae ky" href="https://medium.freecodecamp.org/how-to-make-create-react-app-work-with-a-node-backend-api-7c5c48acb1b0" rel="noopener ugc nofollow" target="_blank">代理服务器</a>，但是对于这个认证来说，这似乎有点过了。</li><li id="a12d" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">这是Spotify关于隐式Grant如何工作的图表。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/01897fc2ce9d53cbad236b45bb480a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CGRcjFG7VoFu6a5U.png"/></div></div></figure><ul class=""><li id="fd6c" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">与需要ajax请求的OAuth/OAuth2或JWT不同，Implicit Grant非常简单，基于一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Query_string" rel="noopener ugc nofollow" target="_blank">查询字符串</a>，这是一种在网页的URL中传递数据的方式。实际上，我们所做的是让我们的登录按钮成为指向Spotify授权URL的外部链接，包括像查询字符串中的Spotify客户端ID这样的数据。通过点击链接，用户实际上离开了我们的页面，并转到Spotify托管的页面，给予我们的应用程序访问权限。</li><li id="e04f" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">如果他们同意(或者如果他们已经登录到Spotify并在早些时候给了我们权限)，Spotify将根据我们在数据库中注册的应用程序检查数据，然后他们会将用户重定向回我们的页面，但包括一个带有授权令牌的查询字符串。我们所要做的就是在API请求中包含这个令牌(截图中的BQAHoHp…)。我们实际上甚至不需要做授权头，因为spotify-web-api-js会替我们做。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/e70fd10324ae61a0bfbd165eee31a4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mnkvBjgk2WBHUMQ2.png"/></div></div></figure><ul class=""><li id="5980" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">登录前的URL</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/6f027901dc61a4132f4a690c73098f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SPX5Cn986wwtkIdg.png"/></div></div></figure><ul class=""><li id="2274" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">登录后的URL</li><li id="64cb" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">现在，让我们通过构建三个Spotify相关组件中的两个来尝试一下:</li><li id="76a4" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">是Spotify相关用户界面的外部包装</li><li id="cc19" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">是我们将在用户尚未登录Spotify时显示的内容。基本上只是一个登录按钮。</li><li id="3a2a" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">让用户从现有的播放列表中选择，并按专辑随机播放。我们稍后会解决这个问题。</li><li id="6ef5" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我们还需要更新，将我们的虚拟“Spotify Player Here”替换为。我们将为spotifyFunctions.js添加一些函数。下面是代码。</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="88a8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们不会在这些组件上花太多时间:在中，我们将虚拟的Spotify占位符文本替换为。有我们是否登录的状态，如果是，我们从Spotify的访问令牌是什么。如果state.loggedInToSpotify为false，那么我们显示组件(基本上只是一个登录按钮)，或者显示一个带有访问令牌的占位符。</p><ul class=""><li id="d3e9" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">还有一个componentDidMount生命周期方法，它在每次渲染时检查我们是否使用spotifyFunctions.js库中的函数登录。这也是代码。</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="aa47" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们从登录开始。redirectUrlToSpotifyForLogin只是一个字符串连接器，用查询字符串构建一个URL，告诉Spotify我们的应用程序是谁，以及我们想向用户请求什么权限(Spotify称之为<a class="ae ky" href="https://developer.spotify.com/documentation/general/guides/scopes/" rel="noopener ugc nofollow" target="_blank">范围</a>)。它还包括我们的客户Id和我们在Spotify注册的重定向URI。您可以在中看到，我们只是将登录按钮链接到这个生成的URL。</p><ul class=""><li id="5a5e" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">checkUrlForSpotifyAccessToken也很简单。它只是用一个名为access_token的参数检查URL中的查询字符串。这是可行的，因为当我们第一次初始化我们的应用程序时，我们的URL将是<a class="ae ky" href="http://localhost:3000," rel="noopener ugc nofollow" target="_blank"> http://localhost:3000，</a>，但在我们登录后，Spotify将使用我们的重定向URI重定向到我们的应用程序，但附有他们授权的查询字符串。它看起来就像<a class="ae ky" href="http://localhost:3000/#access_token=whatever." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/# access _ token = whatever。</a>此时将再次重新呈现，查看访问令牌，并以文本形式呈现访问代码，而不是连接到Spotify按钮。很简单！</li><li id="8ccc" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">FYI getHashParams只是一个通用的帮助器函数，用于解析来自URL的查询字符串。<br/>现在我们已经准备好了登录Spotify所需的一切。它应该是这样的。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/fe340b2f25ad163b807a9742197ca8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*53XgZAu9AcVm4lx1.png"/></div></div></figure><ul class=""><li id="fe60" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">登录前</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/6fbf1b0143e83a8a101032ae047ca659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HyZLxTnTFjkP5uzo.png"/></div></div></figure><p id="9b6c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">登录后</p><ul class=""><li id="301c" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated"><strong class="kc hv">Spotify用户界面</strong></li><li id="b06b" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">现在我们已经登录了，我们必须添加并连接它。用户应该能够从他们的播放列表列表中进行选择，并产生一个由专辑洗牌的新版本。以防你的播放列表上有单曲(异端！)我们还将包括一个自动添加到整个相册的选项。它应该是这样的:</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/96cc69c4dd0e6e32547acb005c2ef290.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/0*oJEmcZ_P0E-3Ay20.png"/></div></figure><ul class=""><li id="8efd" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">您现在已经是前端React代码的老手了，所以我将一次性向您提供所有代码，而不是填鸭式的。如果你有任何问题，可以在评论中问我。非常注重用户界面，尤其是他们的菜单组件，如果你想了解的话，这个教程可以帮助你理解。别忘了把它连接到。</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="a958" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">您会注意到那里有很多对我们的spotifyFunctions.js helper库的引用，所以在我们处理那部分之前它不会呈现。这是我接下来要关注的地方。</p><p id="4c88" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">认识斑点先生:一个可疑的API </strong></p><p id="cbdc" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">简单回顾一下，下面是我们希望应用程序的API部分做的事情:</p><ul class=""><li id="edd5" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">Spotify计划</li><li id="4748" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我需要API做什么？</li><li id="7f45" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">访问用户的Spotify——完成</li><li id="afaa" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">获取他们的播放列表</li><li id="4114" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">获取特定播放列表的曲目</li><li id="3b21" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">获取特定播放列表的专辑</li><li id="ce3e" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">获取特定专辑的曲目</li><li id="c57b" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">创建播放列表</li><li id="b423" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">无序播放播放列表</li><li id="2782" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">播放特定艺术家的唱片目录</li><li id="a9bd" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">获取艺术家的专辑</li></ul><p id="0d87" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这是所有的代码。对它如何符合我们的要求有一个总体的感觉，但我们将通过每个功能，所以不要担心，如果你不明白一切。我提前道歉，它可能经得起一点点重构。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="9875" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">好吧——让我们从头开始！</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="3e71" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们之前已经解决了从的导入问题，但是我们需要一个spotify-web-api-js包装器库的实际实例来使用它，所以我们在这里创建它，并将其命名为spotifyApi。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="ea9e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这些是我们前面提到的认证功能。这里没什么好说的了。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="1ee1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一旦我们有了访问令牌，我们需要<a class="ae ky" href="https://github.com/JMPerez/spotify-web-api-js" rel="noopener ugc nofollow" target="_blank">将它</a>传递给我们的spotifyApi实例，然后我们就不必担心在以后的函数调用中会记住它。我们必须导出这个函数，因为它是在</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="1693" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一旦我们有了访问令牌，我们希望得到一个用户播放列表的数组，他们可以从中进行选择。像所有调用第三方API的函数一样，这必须是一个异步函数。我们的spotifyApi有一个内置的<a class="ae ky" href="https://doxdox.org/jmperez/spotify-web-api-js#src-spotify-web-api.js-constr.prototype.getuserplaylists" rel="noopener ugc nofollow" target="_blank"> getUserPlaylists </a>方法，但是Spotify给了我们很多我们不需要的关于播放列表的信息。</p><p id="6d2d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">为了细化，我们可以映射从API获得的播放列表对象数组，并使用<a class="ae ky" href="https://wesbos.com/destructuring-objects/" rel="noopener ugc nofollow" target="_blank"> ES6析构</a>返回一个更简单的对象数组，只包含每个播放列表的id和名称。我们可以把它输入到state.playlists中，并用它来填充我们的菜单。</p><p id="489b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">请注意，我们还有一个错误处理程序，如果它无法连接到API，将返回“无法下载您的播放列表”。这也反馈到菜单中，所以如果有连接问题，用户会得到一个有点帮助的消息，而不是崩溃的应用程序。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="9797" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一旦用户选择了一个播放列表，我们需要找出播放列表上的曲目。我们需要曲目的名称和id，它所在专辑的名称和id，它在专辑中的曲目编号，以及演唱这首歌的艺术家的名称和id。Spotify还保存了一个URI，我们只需将它放入浏览器就可以获得曲目，所以我们也会保存它。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="98a2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这非常类似于getSimplePlaylistTracks，但是我们不是接收playlistId，而是传递给它一个albumId、albumName和albumUri。当用户想要添加唱片目录时，这很有帮助，因为我们可以遍历他们的播放列表，获得每个曲目的专辑，然后使用它从同一专辑中获得所有其他曲目。</p><p id="0e58" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这两个函数看起来非常相似，但有细微的不同，因为Spotify API对专辑的响应与播放列表中的数据略有不同。可能有一个聪明的方法可以将它们重构为一个函数——如果你想到了，请告诉我！</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="d776" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">正如我们在上一节中所说的，这个函数接收getSimplePlaylistTracks的输出，并从播放列表中的曲目生成一个albumIds数组。如果我们需要完整的唱片目录，可以将它输入getSimpleAlbumTracks，或者如果我们只需要按专辑对播放列表进行排序，只需返回albumId。returnSimpleArray标志让我们决定我们想要哪种输出。</p><p id="2632" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">请注意，我们首先获取albumIds数组，然后使用Lodash uniq函数从数组中删除重复项，然后对其进行洗牌。在添加曲目之前，先随机播放专辑会更有效率。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="a712" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这只是一个普通的帮助函数，用来随机打乱数组。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="1d63" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这与identifyAlbumsInPlaylist基本相同，只是它使用了artistId。我们将用它来播放艺术家的唱片目录。我们可以再次一起重构这两个函数。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c94d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这是一个棘手的问题。本质上，我们在一个播放列表中获取一个大的曲目数组，并将其从一个内聚数组转换为一个具有相同albumId的较小数组的对象。这些短数组是专辑，所以在每张专辑中，我们根据专辑中的曲目编号对曲目进行排序。稍后我们可以重新组合它们。</p><p id="a23a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">以下是convertPlaylistToObjectByProperty的效果示例:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="6f5c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">酷毙了。这里有一个简单的例子:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="3eed" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这是一个很好的帮助函数，当您将它作为参数提供给array.sort时，它可以根据对象的指定属性对对象进行排序，就像我们在convertPlaylistToPbjectByProperty中所做的那样。我毫不掩饰地把这个从栈溢出来，并欠<a class="ae ky" href="https://stackoverflow.com/a/4760279" rel="noopener ugc nofollow" target="_blank"> Ege Ozcan </a>一份情！</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="69a6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">看那个出口声明！看看这是多么可读！当用户选择按专辑随机播放播放列表而不添加丢失的曲目时，从中的“立即播放”按钮调用此功能。这是一个异步函数，我们现在真正受益于抽象出我们的底层操作。</p><p id="8e5f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们从接收状态开始，提取用户选择的播放列表的名称和id。从那里我们:</p><ul class=""><li id="9ca8" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">获取播放列表中的一组曲目</li><li id="ecd0" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">在播放列表中获取一系列已经被打乱的专辑</li><li id="f8ec" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">使用convertPlaylistToObjectByProperty将大的曲目数组排序到一个对象中，较小的数组按专辑排序</li><li id="1d67" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">将较小的(现在已排序的)曲目数组重新组合成一个大的曲目数组，但现在按专辑分组</li><li id="cd96" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">展平重组后数组，现在它又变成了一个简单的播放列表</li><li id="79d5" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">将平面重组数组传递给createPlaylist函数</li></ul><p id="0e26" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我知道我们还没有解决创建播放列表的问题——留到最后再说。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="3260" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这个和我们上一个函数很像，但是byAlbumWithDiscography中间有不同的逻辑。一旦我们从用户的播放列表中得到混排的专辑，我们就扔掉实际的播放列表。取而代之的是，我们循环遍历albumIds数组，并执行API调用来获取每个albumIds的曲目，然后将它们组合成一个大的播放列表。</p><ul class=""><li id="584e" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">这里有一个稍微不同寻常的代码模式:</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="0fa4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在ES7中，Javascript添加了async/await关键字，但是<a class="ae ky" href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" rel="noopener ugc nofollow" target="_blank">在幕后</a>它仍然在使用Promises。当我们在array.map函数中进行异步API调用时，我们实际上返回了一个未履行承诺的数组，而不是这些承诺的结果。令人困惑的是，尽管它充满了未实现的承诺，但数组本身是同步创建的，这意味着等待promiseArrayOfTracksFromAlbum将不起作用。相反，我们调用wait<a class="ae ky" rel="noopener" href="/@ian.mundy/async-map-in-javascript-b19439f0099">promise . all</a>(promiseArrayOfTracksFromAlbum)，它创建一个新的承诺，一旦数组中的所有承诺都被解析，这个承诺就会被解析。</p><ul class=""><li id="490d" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">在Promise.all解析后，我们有一个轨道数组，所以我们像以前一样将其展平，并将结果传递给createPlaylist。</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="dd78" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这是我们用来创建中显示的艺术家的整个唱片目录的播放列表的功能。它与byAlbumWithDiscography几乎完全相同，只是我们不是从播放列表中获取albumIds数组，而是通过向SpotifyAPI请求与艺术家相关联的专辑来获取它。现在，让我们继续将这个函数与Play Discography按钮连接起来:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="7437" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">最终的spotifyFunction—create playlist</strong></p><ul class=""><li id="dd25" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">女士们先生们，这是spotofyFunctions.js中的最后一个函数，也是项目的最后一段代码！准备好创建播放列表并播放了吗？</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="6adf" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">好吧，Spotify的API并没有让我们轻松。即使我们有看似方便的spotifyApi.createPlaylist和spotifyApi.play函数，它们也有一些条件:</p><ul class=""><li id="a2e7" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">在创建播放列表之前，我们必须获得用户Id</li><li id="2900" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我们必须先创建一个空白的播放列表，然后向其中添加曲目。</li><li id="40e3" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我们不能一次添加超过100个轨道，所以如果超过100个，我们需要多次调用spotifyApi.addTracksToPlaylist。</li><li id="5712" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我们只能播放播放列表，如果用户有一个“活动设备”，但不清楚“活动设备”到底是什么意思。</li><li id="210b" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">不管了！这就是为什么我们有这个自定义的createPlaylist函数来处理复杂性。函数的逻辑基本上遵循我们刚刚列出的挑战。chunk是一个很棒的Lodash库，它可以将一个大数组拆分成更小的数组。还要注意，我们必须再次使用Promise.all构造来添加轨道，因为这是array.map内部的异步操作。</li><li id="4a60" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">哎呦——来自现实生活的教训——API挫折 <br/>我知道，你对完成这件事很兴奋，我也是。但是Spotify有其他计划。长话短说，从我开始这个项目到博客发布，Spotify宣布改变他们的API，然后<a class="ae ky" href="https://developer.spotify.com/community/news/2018/06/12/changes-to-playlist-uris/" rel="noopener ugc nofollow" target="_blank">违背了</a>的改变，从而破坏了我们的应用程序！他们所做的只是改变了创建播放列表的端点，但这意味着我们的spotofy-web-api-js库无法工作！如果我是一个更好的公民，我会在库上做一个pull请求来修复它，但是快速修复是编写我们的临时ajax API调用来创建播放列表，而不是库。一旦库被更新，我们将把它改回来。</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="b1d7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我没有将整个文件复制到要点中，因为我们只修改了几处内容:</p><p id="9582" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">既然我们需要spotify-web-api-js库外部的访问令牌，我们必须添加一个全局变量来保存它，并更新setAccessToken</p><p id="7864" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们需要在上面编写的createPlaylist函数中调用tempCreatePlayist函数。</p><p id="a3c2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们需要创建我们的临时函数，这只是一个对我们需要的端点的ajax调用。</p><p id="264f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">管用！</strong></p><ul class=""><li id="17cc" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">看看吧——你现在应该可以登录Spotify，在你的播放列表中选择，并按专辑随机播放。您还可以添加相关的唱片目录，以及生成凯茜·玛斯格蕾芙斯、瑞安·宾汉和特德·利奥的专辑目录(我强烈建议完整收听)或添加对您自己喜欢的艺术家的纪念！</li><li id="00c7" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">当按钮被点击时，它们不会做任何视觉上的事情，但是如果你的手机打开你旁边的播放列表页面，它应该在几秒钟后开始播放，否则检查你的播放列表，看看新专辑的随机播放方法，并开始听老学校风格！</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/4ac52db51b35e408ee18fec3ff5bfe0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_f81DJIX82VY-lMq.gif"/></div></div></figure><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/f8a2a8315a5a357ee116e2d15fcee95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cRg3fVW0n9hsxvvQ.gif"/></div></div></figure><ul class=""><li id="f7aa" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated"><strong class="kc hv">将create-react-app部署到生产中</strong></li><li id="8d79" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">如果你愿意，最后一步是部署你的应用程序，这样你就可以在互联网上使用它，而不仅仅是在你的本地开发环境中。这并不难，但是当像我们这样使用create-react-app时，这个过程并没有很好地记录下来。</li><li id="85b1" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">create-react-app在启动和运行带有热重装的开发服务器时，为我们提供了许多功能中的一个，但对于生产，构建脚本创建了1个Javascript、1个CSS和1个html文件。</li><li id="dfa5" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">因为我们只有这些文件，这意味着我们需要将它们放在现有的服务器上，或者在Node中启动一个简单的Express服务器来为我们提供这些文件。这就是我们要走的路线，所以在根目录中添加一个名为app.js的新文件。这是一个与components文件夹中的App.js不同的文件，我们将编写一个简单的服务器来提供这些构建文件:</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c8c6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在我们有了一个服务器来托管我们的构建文件，我们需要一个脚本来使用它。打开你的package.json，让我们开始吧。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><ul class=""><li id="ec23" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">create-react-app已经为我们准备了一个很好的构建脚本，所以对于我们的productionstart脚本，我们需要做的就是运行这个构建脚本，然后启动服务器。注意，我们还添加了express作为显式依赖项。这应该不是必要的，因为create-react-app已经在后端使用了它，但保持整洁也不错。</li><li id="257e" class="lj lk hu kc b kd ls kh lt kl lu kp lv kt lw kx lo lp lq lr dt translated">我们需要添加的最后一个文件是Procfile(大写，没有点)，它包含部署服务的指令(最初是Heroku，但是我们将使用Cosmic JS的服务)。Procfile将告诉服务启动单个web节点并运行我们的productionstart脚本。</li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="d48c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如此接近，我们可以品尝它！Cosmic JS使得直接从Github repo进行部署变得极其容易(您已经上传了您的git提交，对吗？).你所要做的就是回到你的Cosmic JS仪表板，在设置下面有一个Web部署选项。从那里你只需点击蓝色的部署到宇宙JS按钮。这将需要几分钟的时间来设置和发送电子邮件给你时，你的生产老派洗牌是现场。</p><ul class=""><li id="03a7" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">现在非常，非常，非常最后的事情是，我们需要在我们的宇宙JS部署中设置我们的环境变量，以反映我们的。开发中的env文件。Protip —不要忘记单击“设置环境变量”按钮，然后给它几分钟时间进行更新。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/66e8e34b33b83d968fcbaade3b911150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PJVJLCss4Bg99KDh.PNG"/></div></div></figure><p id="a096" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">最后的润色</strong></p><ul class=""><li id="b383" class="lj lk hu kc b kd kz kh la kl ll kp lm kt ln kx lo lp lq lr dt translated">现在，我们的应用程序实际上工作了，我更喜欢它了，所以我把CSS分类，给它多一点活力。这些微小的变化没有在github gists中显示出来，但它们在回购协议中得到了反映。</li></ul><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/5eed6d6bf7cc99c171328bf3de911f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*tgW5g-JRhdYyT0OZ.gif"/></div></figure><p id="6457" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">那都是乡亲们！</strong></p><p id="35ff" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在享受你的劳动成果吧！谢谢你的加入，我希望你能喜欢并学到一些东西。这是我的就职编码教程，所以请留下评论，如果我错过了什么…或者如果你有任何意见！</p><p id="4fea" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="https://twitter.com/cosmic_js" rel="noopener ugc nofollow" target="_blank">在Twitter上联系我们</a>和<a class="ae ky" href="https://cosmicjs.com/community" rel="noopener ugc nofollow" target="_blank">加入我们的Slack社区</a>。</p></div></div>    
</body>
</html>