<html>
<head>
<title>One Lambda to call any AWS service via AWS SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个Lambda通过AWS SDK调用任何AWS服务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/one-lambda-to-call-any-aws-service-via-aws-sdk-ad572f0477f5?source=collection_archive---------26-----------------------#2018-09-25">https://medium.com/hackernoon/one-lambda-to-call-any-aws-service-via-aws-sdk-ad572f0477f5?source=collection_archive---------26-----------------------#2018-09-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/213124cc2fead2d07e7552df33bcdbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*49kEK-J3BodP_hyjfheyhA.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">One AWS Lambda. All services via SDK</figcaption></figure><p id="1b66" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近，在设计一个步骤函数来执行ETL作业、训练机器学习模型和执行批量预测时，一个<em class="ka">等待检查</em>模式(如<a class="ae kb" href="https://docs.aws.amazon.com/step-functions/latest/dg/job-status-poller-sample.html" rel="noopener ugc nofollow" target="_blank">作业状态轮询器</a>示例所述)取而代之。由于一些相关服务(如Glue和SageMaker)的异步特性，一些步骤需要等待一项工作完成后才能进入管道的下一阶段。</p><figure class="kd ke kf kg fq iv fe ff paragraph-image"><div class="fe ff kc"><img src="../Images/2da038633fe9c2a3d4e5810e3d5e893b.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*0OvqH3yDUHV9DYH948FiEA.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Job Status Poller Sample</figcaption></figure><p id="289b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，在这种情况下，有六个在管道中。这意味着要写六段代码来做同样的事情。是的，起初，考虑到不同步骤的目标，它们似乎是不同的。要调用的服务及其方法不会相同。但最终，他们都有一个相同的模式，那就是:</p><p id="1b4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">调用一个</em> <strong class="je hv"> <em class="ka">方法</em> </strong> <em class="ka">从一个</em> <strong class="je hv"> <em class="ka">服务</em> </strong> <em class="ka">用下面的</em><strong class="je hv"><em class="ka"/></strong><em class="ka">参数并得到其</em> <strong class="je hv"> <em class="ka">结果</em> </strong> <em class="ka">。</em></p><p id="e2c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，考虑到这一点，我创建了一个通用的<a class="ae kb" href="https://hackernoon.com/tagged/lambda" rel="noopener ugc nofollow" target="_blank"> Lambda </a>来通过AWS SDK调用任何<a class="ae kb" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a>服务。它的来源和文档可以在这里找到:<a class="ae kb" href="https://github.com/DiegoZoracKy/lambda-aws-sdk-call" rel="noopener ugc nofollow" target="_blank">https://github.com/DiegoZoracKy/lambda-aws-sdk-call</a></p><p id="9428" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一点<a class="ae kb" href="https://en.wikipedia.org/wiki/Unix_philosophy" rel="noopener ugc nofollow" target="_blank"> Unix哲学</a>。Eric Raymond的17 Unix规则中的<a class="ae kb" href="https://en.wikipedia.org/wiki/Unix_philosophy#Rule_of_Generation" rel="noopener ugc nofollow" target="_blank">生成规则</a>(我真正相信的一个概念)可以告诉我们这里应用了什么。</p><blockquote class="kh ki kj"><p id="6b78" class="jc jd ka je b jf jg jh ji jj jk jl jm kk jo jp jq kl js jt ju km jw jx jy jz hn dt translated"><strong class="je hv">世代法则</strong></p><p id="1e9c" class="jc jd ka je b jf jg jh ji jj jk jl jm kk jo jp jq kl js jt ju km jw jx jy jz hn dt translated">开发人员应该<strong class="je hv">避免手工编写代码</strong>，而是<strong class="je hv">编写生成代码的抽象高级程序</strong>。这条规则的目的是<strong class="je hv">减少人为错误，节省时间</strong>。</p></blockquote><p id="a5b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望它能对其他人有所帮助，也欢迎任何反馈。</p><p id="f596" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很快我会发表一篇新文章，展示如何在Step函数上使用这个通用Lambda来触发作业并等待它们完成。</p><blockquote class="kh ki kj"><p id="cb3a" class="jc jd ka je b jf jg jh ji jj jk jl jm kk jo jp jq kl js jt ju km jw jx jy jz hn dt translated"><strong class="je hv">更新2018-09-26: </strong></p></blockquote><p id="5adb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据一个用户在Reddit上发给我的关于安全性和最小特权原则的评论，我意识到其他人可能最终只能看到一种应用这里所介绍的方法。与他看到的一样(一个Lambda拥有整个公司使用的所有特权)，这不是最好的方式，可能会导致同样的问题。</p><p id="c7da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，一个是Lambda的源代码，另一个是Lambda本身。你可以有不同的Lambdas，有不同的特权，但都有相同的源代码。</p><p id="a77e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我提到的例子中，一个Step函数需要以至少6种不同的方式与2个不同的服务进行交互。无论如何，一些Lambdas需要有正确的特权来处理这些交互。在这种情况下，您可以:</p><p id="6e83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">A) 6个Lambdas，具有6个不同的源代码，其中每个都具有正确的特权。</p><p id="fd1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">B) 6个Lambdas，带有1个源代码(对所有人都一样)，其中每个人都有适当的特权。</p><p id="0b39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">C) 1个Lambda，1个源代码，仅具有在上述任何情况下都会被给予的相同特权(不是对一切的完全访问)。</p><p id="28b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从安全的角度来看，无论如何都有6个动作要通过Lambdas来执行。不管是通过六个不同的兰姆达还是只通过一个。最后一种策略似乎更容易管理。</p><p id="4c31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">采用最后一种情况的一些好处是:</p><ul class=""><li id="78a1" class="kn ko hu je b jf jg jj jk jn kp jr kq jv kr jz ks kt ku kv dt translated">团队不必停下来编写新代码。这节省了时间，这很重要，但更重要的是，它防止了新的错误诞生。</li><li id="515b" class="kn ko hu je b jf kw jj kx jn ky jr kz jv la jz ks kt ku kv dt translated">只有一个代码需要测试，并保证它按预期工作。不容易出错。错误和意外行为的空间更小。</li><li id="a587" class="kn ko hu je b jf kw jj kx jn ky jr kz jv la jz ks kt ku kv dt translated">统一合同。假设所有调用共享相同的输入和输出结构。</li></ul><p id="50e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一个对我们的团队非常有用，尤其是在阶跃函数的情况下。它让我们可以自由地实现整个管道，只需关注我们的输入和输出数据序列，而不必担心被调用资源的行为。</p><figure class="kd ke kf kg fq iv"><div class="bz el l di"><div class="lb lc l"/></div></figure></div></div>    
</body>
</html>