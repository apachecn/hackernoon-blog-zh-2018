<html>
<head>
<title>Bitcoin Core Bug CVE-2018–17144: An Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比特币核心Bug CVE-2018–17144:分析</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/bitcoin-core-bug-cve-2018-17144-an-analysis-f80d9d373362?source=collection_archive---------0-----------------------#2018-09-27">https://medium.com/hackernoon/bitcoin-core-bug-cve-2018-17144-an-analysis-f80d9d373362?source=collection_archive---------0-----------------------#2018-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b21d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周，<a class="ae jp" href="https://bitcoincore.org/en/2018/09/18/release-0.16.3/" rel="noopener ugc nofollow" target="_blank">0 . 16 . 3</a>向公众发布，并敦促每个人尽快升级，这让比特币世界感到惊讶。表面上的原因是在0.14-0.16.2中发现了一个需要修补的拒绝服务(DoS)载体。<a class="ae jp" href="https://bitcoincore.org/en/2018/09/20/notice/" rel="noopener ugc nofollow" target="_blank">后来</a>，我们发现0.15-0.16.2中同样的bug也有通货膨胀的可能。</p><p id="0402" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我试图澄清发生了什么，危险是什么，它是如何被利用的，以及可能发生了什么。</p><h1 id="54c5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">双重消费的两种方式</h1><p id="67ae" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在我们进入真正的bug之前，一些解释是必要的。我们需要首先定义重复消费，因为这个bug是关于重复消费的。</p><p id="1e7f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">双重消费是指某人，比如说爱丽丝，花了几个硬币给鲍勃，又花了几个硬币给查理。爱丽丝实际上是想开两张支票，她知道其中一张会被退回。当然，当我们考虑支票时，爱丽丝有一些账户因为开了这两张支票而透支了。这很接近，但不完全符合比特币的工作原理。</p><p id="0f65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比特币不支持账户，但支持UTXOs，即未用完的交易输出。交易的输出本质上有一个地址和一个数量。一旦产出被花掉，就不能再花掉。把UTXO想象成寄给你的一枚硬币，可以是任何数量，比如0.413 BTC硬币。</p><p id="fed8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">双重消费意味着一枚硬币(UTXO)被消费两次。通常，这意味着Alice在一个事务中将她的0.413 BTC发送给Bob，在另一个事务中发送给Charlie。比特币解决这一问题的方式是，其中一项交易进入一个区块，这决定了谁实际上获得了报酬。如果两个事务以某种方式在多个块中通过，后一个块将被软件拒绝。如果两个事务都在一个块中通过，该块也会被软件拒绝。本质上，该软件检测重复花费，并且如果有重复花费，块应该被拒绝。</p><p id="9943" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，在两个不同的事务中发送相同的UTXO并不是双重花费的唯一方式。还有一种更病态的情况，同一笔UTXO在同一笔交易中被花了两次<em class="kt"/>。在这种情况下，Alice将一枚硬币发送给Bob两次。所以爱丽丝花了两次0.413 BTC币给鲍勃寄了0.826 BTC。这显然不是一个有效的交易，因为只有1个价值0.413 BTC的UTXO被发送。这相当于爱丽丝两次付给鲍勃同样的10美元，而鲍勃认为他收到了20美元。</p><h1 id="55f8" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">定义Bug</h1><p id="6dec" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以总结一下我们到目前为止所定义的，有两种类型的双重消费企图:</p><ol class=""><li id="42fd" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">使用两个或两个以上的交易花费相同的UTXO。</li><li id="05ba" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">使用一个事务多次花费相同的UTXO。</li></ol><p id="630a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原来(1)是比特币核心软件正确处理的。这是我们关心的问题。任何人都可以构造一个像这样双重花费的事务，但是让节点接受这种事务是另一回事。有两种方法可以将事务放入块中。</p><p id="fba1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">A.用足够的费用将交易广播到网络上，以使矿工将交易包括在块中。</p><p id="0b54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">B.将事务作为挖掘器包含在块中。</p><p id="0c8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(A)除了创建事务并将其广播到网络上的节点之外，不需要太多。(B)要求您找到充分的工作证明。事实证明，对于该漏洞来说，(A)不是可能的攻击媒介，因为这些事务会立即被标记为无效，并被网络上的节点拒绝。没有矿工的合作，交易就无法进入矿工的记忆池，因为他们不会得到传播。(B)是该错误出现的唯一情况。换句话说，要利用这个漏洞，你需要工作证明，或者足够的采矿设备和电力。</p><p id="074d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要明确的是，有4种情况需要处理重复消费:</p><p id="3592" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1A —多个内存池事务使用同一个UTXO</p><p id="ac74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1B —使用相同UTXO的多个大宗交易</p><p id="f1a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2A —单个内存池事务多次使用同一个UTXO</p><p id="f5be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2B —单个块交易多次使用同一个UTXO</p><p id="4d62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种缺陷有两种表现形式。在0.14.x中，存在拒绝服务漏洞，在0.15.x到0.16.2中，存在膨胀漏洞。我们接下来会谈到这些。</p><h1 id="5f9e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">拒绝服务漏洞</h1><p id="1432" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">故事从2009年的比特币0.1开始，这段代码通过拒绝1B和2B的案例(检查区块没有重复花费)来强制执行共识:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/d9811d6c0ab210e22b54675bac75d624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3mlUTuK20BjqXobENf2Sw.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">I’ve deleted a lot of in-between code for clarity</figcaption></figure><p id="dda0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以看到注释“Check for conflicts ”,它检查每一个输入是否都被使用。注释“将输出点标记为失效”下面的代码将UTXO标记为失效。如果任何UTXO被多次使用，这将导致错误。</p><p id="cfe1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2011年，<a class="ae jp" href="https://github.com/bitcoin/bitcoin/pull/443" rel="noopener ugc nofollow" target="_blank"> PR 443 </a>合并。这一改变是为了处理通过内存池传输单tx双花费的情况(上面的2A情况)。这个拉取请求注释清楚地表明了目的(重点是我的):</p><blockquote class="ly lz ma"><p id="1840" class="ir is kt it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">此外，没有具有重复输入的事务被放入块中…几周前有人尝试过，但txes从未以块结束。我假设后来某个地方有一个检查，防止他们被添加到块中，尽管我没有在这个问题上做任何挖掘。<strong class="it hv">这实际上是为了防止这种明显无效的交易被转发。</strong></p></blockquote><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff me"><img src="../Images/6b2b279bc66c858dfc63b41eeddd6ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLfll3cHHv_SGM97tYgZBQ.png"/></div></div></figure><p id="375c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际的代码更改或多或少做了与上面<code class="eh mf mg mh mi b">ConnectInputs</code>中“检查冲突”注释下的代码相同的事情，但是在不同的地方。代码更改在<code class="eh mf mg mh mi b">CheckTransaction</code>中，它针对上述所有4种情况(1A、1B、2A、2B)运行。因此，由于1B和2B的案例被检查了两次，一次在<code class="eh mf mg mh mi b">CheckTransaction</code>，一次在<code class="eh mf mg mh mi b">ConnectInputs</code>，我们现在在整批双重支出共识代码中有了一些冗余。</p><p id="9bef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2013年，<a class="ae jp" href="https://github.com/bitcoin/bitcoin/pull/2224" rel="noopener ugc nofollow" target="_blank"> PR 2224 </a>合并。这一变化的目标是区分共识错误(如重复支出)和系统错误(如用完磁盘空间)，正如这一公关评论所表明的:(强调我的)</p><blockquote class="ly lz ma"><p id="4a38" class="ir is kt it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">它引入了CValidationState，它存储关于正在执行的块或事务验证的元数据。<strong class="it hv">它用于区分验证错误(例如，不符合网络规则)和运行时错误(如磁盘空间不足)，因为以前这些可能会被混淆，导致块因磁盘空间用尽而被标记为无效。</strong>此外，CValidationState还接管了跟踪DoS级别的角色(因此它不需要存储在事务或块中……)。</p></blockquote><p id="4276" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际的相关代码更改如下:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mj"><img src="../Images/b47ce26e91ae457711ad7af684006d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvgQDucaxa8Y8Dpf6IO2JQ.png"/></div></div></figure><p id="631c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到这个时候，<code class="eh mf mg mh mi b">ConnectInputs</code>已经被模块化成多个方法，这个函数成为检查重复花费的函数。这里的关键变化是曾经的<code class="eh mf mg mh mi b">error</code>变成了<code class="eh mf mg mh mi b">assert</code>。</p><p id="7a89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C++中的<code class="eh mf mg mh mi b">assert</code>是做什么的？它完全停止了程序。为什么程序员要在这里暂停程序？这就是拉请求的目的所在。这是当时相关的代码片段。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mk"><img src="../Images/8d2e8a101c845bf7971826955faa2baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHvHZOZrHweeHZ5sN-rlwg.png"/></div></div></figure><p id="7ab8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是对1B和2B案件一如既往处理。函数名已从<code class="eh mf mg mh mi b">ConnectInputs</code>更改为<code class="eh mf mg mh mi b">ConnectBlock</code>，但检查案例1B和2B的冗余仍从PR 443保留。正如我们已经看到的，<code class="eh mf mg mh mi b">UpdateCoins</code>做了第二个双花费检查。<code class="eh mf mg mh mi b">CheckBlock</code>通过调用<code class="eh mf mg mh mi b">CheckTransaction</code>进行第一次双花费检查:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ml"><img src="../Images/bf313f048ac13c03f7574f85c6ecd856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEnynODUC6-WKdGEI3aGsQ.png"/></div></div></figure><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mm"><img src="../Images/50369eee2659a4b0c8f53176a04729be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfOdpMAjQaSCi7rtUL7RBw.png"/></div></div></figure><p id="7a5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为这是第二次检查同一件事，所以<code class="eh mf mg mh mi b">UpdateCoins</code>中的双重花费检查失败的唯一方式是如果有某种UTXO数据库或内存损坏。事实上，这似乎是改为<code class="eh mf mg mh mi b">assert</code>的原因。我们已经知道这些交易不是重复支出，因为T2通过T3在T4之前进行了检查。因此，PR 2224正确地推测，在<code class="eh mf mg mh mi b">UpdateCoins</code>达到这种状态一定是系统错误，而不是共识错误。在这种情况下，为了防止进一步的数据损坏，正确的做法是暂停程序。</p><p id="93a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2017年，<a class="ae jp" href="https://github.com/bitcoin/bitcoin/pull/9049/files" rel="noopener ugc nofollow" target="_blank"> PR 9049 </a>作为比特币0.14的一部分推出。由于Segwit将使块变得更大，这是加速块验证时间的许多变化之一。代码变化非常小:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mn"><img src="../Images/536de1953420113579969c50524a9b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycdtYEFFh00KdMgKCHiHSA.png"/></div></div></figure><p id="481b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以看到布尔型<code class="eh mf mg mh mi b">fCheckDuplicateInputs</code>被添加来加速块检查。正如我们将在下面看到的，这被认为是一个多余的检查。不幸的是，<code class="eh mf mg mh mi b">UpdateCoins</code>中的代码在PR 2224中被更改为<em class="kt">系统损坏检查</em>，而不是一致性检查。到了0.14.0，代码更加模块化，并且<code class="eh mf mg mh mi b">assert</code>看起来有些不同:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mm"><img src="../Images/f6c74c642988673cae5543e2c19b5f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2hfk_fP5WY_FA4KXXV2LQ.png"/></div></div></figure><p id="5c9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">曾经的冗余检查现在负责块级单tx双花费(2B情况)并暂停程序。这仍然在技术上强制执行共识规则，只是非常糟糕，因为它中止了程序。</p><p id="82ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">PR 9049是怎么打通的？Greg Maxwell向我推荐了IRC上的聊天内容:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mo"><img src="../Images/3e2972ffa83f6f0c2f1487bc425281bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4Kw6ylZuM2Chbg3jyKQlA.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Major props to Greg Maxwell who helped spell out for me what happened</figcaption></figure><p id="efb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TL；DR，开发人员在讨论PR 9049时，倾向于认为在PR 443之外的地方检查了块级单tx双花费(案例2B ),而没有考虑PR 2224。这导致开发人员没有密切关注PR 9049。</p><p id="6693" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总而言之:</p><ol class=""><li id="e6a7" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">2011年引入PR 443是为了防止重复支出交易的延续(2A案例)。这产生了一个副作用，就是为整批重复支出(1B和2B的例子)创建了一个冗余的共识检查规则。</li><li id="5002" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">PR 2224是在2013年引入的，作为副作用，它将(1)中用于块验证的代码从冗余升级为共识关键。</li><li id="67a7" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">PR 9049于2017年推出，并跳过了(1)中针对单tx-double-spend-in-a-block情况(1B情况)的代码。开发人员错误地认为代码是多余的，因为他们没有考虑(2)。事实上，这种变化跳过了共识的关键部分。</li></ol><p id="d2a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">公平地说，这是导致bug的各种事件的奇怪汇合。</p><h1 id="8c2f" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">DoS漏洞的严重性</h1><p id="fa5b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这意味着核心0.14.x软件可能会崩溃给一个足够怪异的块。由于代码所处的位置，要导致崩溃，攻击者必须:</p><ol class=""><li id="80b6" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">创建一个使用同一个UTXO两次的事务</li><li id="402f" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">将来自(1)的事务包括到具有足够工作证明的块中</li><li id="8a85" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">将该块广播到0.14.x节点</li></ol><p id="03a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(1)和(3)的成本不是很高。(2)成本最低为12.5 BTC，因为创建一个具有足够工作证明的区块所需的散列功率量与找到一个有效区块所需的能量/采矿设备量相同。</p><p id="4c9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你认为从博弈论的角度来看，分裂网络并没有那么好，那么利用这个漏洞的动机就相当低。作为一名攻击者，最多只能以12.5 BTC的成本拿下一小部分完整节点。由于不太可能从分裂的网络中获利，这需要的不仅仅是能够随意使一些节点崩溃，因此没有太多好处，因为攻击者无法轻松收回攻击的成本。</p><p id="c6f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这是唯一的漏洞，攻击者可能会给许多人带来不便，但这不是持续的不便，因为这些节点可以简单地重新启动并连接到除了向它们提供坏块的节点之外的节点。一旦有了更长的链条，这种糟糕的拦网攻击就会完全失去威力。除非攻击者继续以每块12.5 BTC的成本创建块，并将它们提供给网络上的0.14.x节点，否则攻击或多或少会就此结束。</p><p id="1c52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换句话说，虽然脆弱性肯定存在，但DoS的经济激励相当低。</p><h1 id="e763" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">通货膨胀错误</h1><p id="af41" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">从0.15.0开始，引入了一个使查找和存储UTXOs更快的特性，并且引入了bug的下一次迭代。当一个具有单交易双花费的块进来时，软件没有崩溃，而是认为该块是有效的。</p><p id="ecaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着一个病态的事务(同一个UTXO在同一个事务或上面的2B中花费了多次),它使0.14个节点崩溃，现在在0.15个节点中被视为有效，实质上是凭空创建了BTC。</p><p id="c450" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事情是这样的。在0.15中引入，<a class="ae jp" href="https://github.com/bitcoin/bitcoin/pull/10195/files" rel="noopener ugc nofollow" target="_blank"> PR 10195 </a>包含了很多东西，但它的主要要旨是改变了UTXOs的存储方式，以使它们更有效地查找。结果，出现了许多变化，包括前面的<code class="eh mf mg mh mi b">UpdateCoins</code>函数:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mp"><img src="../Images/41fafaeb0571db7c2121e121cc1bb866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-a-mGWBL4SEtDpldLJZHeA.png"/></div></div></figure><p id="62fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意<code class="eh mf mg mh mi b">assert(false)</code>周围的代码是如何被完全删除的。注意到这一点，<a class="ae jp" href="https://github.com/bitcoin/bitcoin/pull/10537" rel="noopener ugc nofollow" target="_blank"> PR 10537 </a>也在0.15.0中修改了代码，使得断言被放回。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mq"><img src="../Images/3fd886cf6ef6ae3b6bfe867e6f221fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMkwoZKpIU9IuhXXO8G2aQ.png"/></div></div></figure><p id="1034" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">断言失败的条件取决于<code class="eh mf mg mh mi b">inputs.SpendCoin</code>,如下所示:</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff mr"><img src="../Images/bbd86016ba5dd47980765802e79be031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8_y_ZNGhAGa7sFrOedd2g.png"/></div></div></figure><p id="e7ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从本质上讲，<code class="eh mf mg mh mi b">SpendCoin</code>返回false的唯一方式是硬币不存在于UTXO集合中。但是你可以看到，这要求硬币是<code class="eh mf mg mh mi b">FRESH</code>而不是<code class="eh mf mg mh mi b">DIRTY</code>。这些都不是显而易见的术语，但谢天谢地，核心开发者周立铭在这里解释了<a class="ae jp" href="https://bitcoin.stackexchange.com/questions/79481/how-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work/79484#79484" rel="noopener ugc nofollow" target="_blank"/>:</p><blockquote class="ly lz ma"><p id="57de" class="ir is kt it b iu iv iw ix iy iz ja jb mb jd je jf mc jh ji jj md jl jm jn jo hn dt translated">所以现在的问题是，UTXOs什么时候被标记为<code class="eh mf mg mh mi b">FRESH</code>？当它们被添加到UTXO数据库时，它们被标记为<code class="eh mf mg mh mi b">FRESH</code>。但是UTXO数据库仍然只存在于内存中(作为缓存)。当它被保存到磁盘时，内存中的条目不再被标记为<code class="eh mf mg mh mi b">FRESH</code>。这种保存到磁盘的操作在每个数据块之后都会发生(其他时候也会发生，但这并不重要)。</p></blockquote><p id="02a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mf mg mh mi b">FRESH</code>硬币是进入记忆池的硬币。攻击者可以通过<code class="eh mf mg mh mi b">UpdateCoins</code>中的断言语句使节点崩溃。但更糟糕的是，如果硬币是<code class="eh mf mg mh mi b">DIRTY</code>(本质上是从磁盘读取的)，那么这会导致通货膨胀。</p><p id="4072" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，从0.15.0到0.16.2的核心软件可能会接受一个奇怪的、无效的阻塞，从而增加供应。</p><h1 id="fc0a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">通货膨胀脆弱性的严重性</h1><p id="ad47" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这种攻击的经济性似乎明显优于拒绝服务的情况，因为攻击者可能会凭空创建BTC。你仍然需要采矿设备来执行攻击，但是潜在的通货膨胀可能会使这变得值得，或者看起来是这样。</p><p id="dc43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是利用这个漏洞对比特币进行的幼稚攻击:</p><ol class=""><li id="731b" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">创建一个交易块，该交易两次花费一定数量的BTC给自己。比如说BTC 50号→BTC 100号。</li><li id="a578" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">0.15/0.16把区块播给大家</li></ol><p id="fb1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是可能发生的情况:</p><ul class=""><li id="665d" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo ms la lb lc dt translated">0.14.x节点将会崩溃</li><li id="2a61" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo ms la lb lc dt translated">较旧的节点和许多替代客户端会拒绝该块</li><li id="8296" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo ms la lb lc dt translated">许多块浏览器运行在定制软件上，而不是核心软件上，因此至少有些会拒绝该块，不会显示该块的任何事务</li><li id="c4d6" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo ms la lb lc dt translated">根据矿工运行的软件，我们可能已经结束了链分裂。</li></ul><p id="8c23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有可能所有的矿工都在运行比特币核心0.15+版本，在这种情况下，非易受攻击的客户端会简单地停止运行。也有可能一名矿工正在运行其他的东西，在这种情况下，一旦他们发现一个区块，就会发生链叉。</p><p id="6b4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于这些不规则性，网络上的人很快就会发现这一点，可能会提醒一些开发人员，核心开发人员会修复它。如果有一个分叉，关于哪条链是正确的社会共识将开始被讨论，而产生意外通胀的链可能会失败。如果有停顿，很可能会有一个自愿的回滚来惩罚攻击者。</p><p id="aae4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以对于攻击者来说，这不会导致+50 BTC，但更有可能是-12.5 BTC。如果攻击者加倍花费更大的金额，比如200 BTC，那么通货膨胀阻滞持续存在的可能性就更小，因为攻击会更加明目张胆。</p><p id="b99d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，从攻击者的角度来看，这不会是一个很好的投资回报。</p><p id="e02a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">攻击者可能获利的另一种方式是做空BTC，然后实施攻击。这也是有风险的，因为不能保证BTC价格会下跌，尤其是如果危机得到迅速果断的处理。此外，考虑到大多数交易所提供保证金的反洗钱/KYC，这可能会导致攻击者在相当短的时间内获得doxxed。</p><p id="ca63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">攻击者不仅面临巨大的金钱风险，还面临身体风险。投资回报率并不真正存在，从经济角度来看，这并不是一个容易利用的利润。</p><p id="ef5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，一个州级演员可能会用这种方式来吓唬比特币制造者。ROI会更抽象，所以从理论上讲，这可以实现州级参与者的目的。</p><h1 id="f774" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="0f3c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当然，这是一个相当严重的错误。尽管我和很多人有分歧，但我很感激这个人选择负责任地披露。也就是说，考虑到漏洞利用的经济博弈理论，我不认为漏洞有像他这样的人所说的那么严重。</p><p id="d942" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使错误在被发现之前就被坏人发现了，攻击者也不会选择利用它，因为这在经济学上并不合理。可以肯定的是，技术部分应该得到修复并变得更好，但这种利用实际上有用的人群非常少(基本上是想摧毁比特币的国家级行动者)。</p><p id="2e46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">比特币核心的教训有很多:</p><ol class=""><li id="9587" class="ku kv hu it b iu iv iy iz jc kw jg kx jk ky jo kz la lb lc dt translated">任何共识的改变(即使是9049这样微小的改变)都需要更多人的审核。</li><li id="3d3c" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">病理病例需要写更多的检测。</li><li id="eb17" class="ku kv hu it b iu ld iy le jc lf jg lg jk lh jo kz la lb lc dt translated">代码库中关于哪些检查是多余的，哪些不是，以及实际代码应该做什么的更加清晰。</li></ol><p id="face" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">过去有bug，将来也会有bug。现在重要的是学习和吸收这些教训。</p></div></div>    
</body>
</html>