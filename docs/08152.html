<html>
<head>
<title>Understanding Postgres connection pooling with PgBouncer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PgBouncer了解Postgres连接池</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-postgres-connection-pooling-with-pgbouncer-unlisted-draft-bdb7ebf073ab?source=collection_archive---------3-----------------------#2018-09-27">https://medium.com/hackernoon/understanding-postgres-connection-pooling-with-pgbouncer-unlisted-draft-bdb7ebf073ab?source=collection_archive---------3-----------------------#2018-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="d0a1" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">PgBouncer内部</h1><p id="3ed0" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae kn" href="https://hackernoon.com/tagged/pgbouncer" rel="noopener ugc nofollow" target="_blank"> PgBouncer </a>是Postgres的连接池<a class="ae kn" href="https://hackernoon.com/tagged/service" rel="noopener ugc nofollow" target="_blank">服务</a>。它有各种内部限制和有限的资源。从客户的角度来看，比如说，从某个网络应用的角度来看，它是这样的:</p><ol class=""><li id="5bf3" class="ko kp hu jr b js kq jw kr ka ks ke kt ki ku km kv kw kx ky dt translated">客户端连接到PbBouncer。</li><li id="a418" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">客户端发出SQL请求/查询/事务</li><li id="d90a" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">得到响应。</li><li id="d98f" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km kv kw kx ky dt translated">根据需要多次重复步骤2-3。</li></ol><p id="7310" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">这是客户端的连接状态图:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/a38a5823bde769059dfe6340f8758aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wVmktZYFm7vU1FCN.jpeg"/></div></div></figure><p id="6526" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">在登录阶段/状态(<code class="eh lt lu lv lw b">CL_</code>代表<code class="eh lt lu lv lw b">client</code>)期间，Pgbouncer可能会基于一些本地信息(如auth_file、证书、PAM或hba文件)或以远程方式授权一个客户端—通过<a class="ae kn" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>中的<code class="eh lt lu lv lw b">auth_query</code>。因此，登录时的客户端连接可能需要并正在执行查询。让我们显示为<code class="eh lt lu lv lw b">Executing</code>子状态:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/1fe43a17fa199097753782abc39cf48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AqBgLx0NrWmW-cuS.png"/></div></div></figure><p id="599a" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">但是<code class="eh lt lu lv lw b">CL_ACTIVE</code>查询也可能实际执行一些查询，因此通过PgBouncer链接到实际的<a class="ae kn" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>服务器连接，或者空闲，什么也不做。这种客户端和服务器连接的链接/匹配是PgBouncer存在的全部理由。PgBouncer仅在一段时间内将这些客户端与服务器链接，这取决于<code class="eh lt lu lv lw b">pool_mode</code>——针对一个会话、一个事务或仅仅一个请求。</p><blockquote class="lx ly lz"><p id="9548" class="jp jq ma jr b js kq ju jv jw kr jy jz mb le kc kd mc lf kg kh md lg kk kl km hn dt translated">由于事务池是最常见的，我们将在本文的其余部分假设它</p></blockquote><p id="652e" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">因此，处于<code class="eh lt lu lv lw b">cl_active</code>状态的客户端实际上可能链接到也可能不链接到服务器连接。为了说明这一点，我们将这个状态一分为二:<code class="eh lt lu lv lw b">active</code>和<code class="eh lt lu lv lw b">active-linked/executing</code>。这是一张新的图表:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/3499c7320e9c53a644edb011163f1a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B03PDy-IwA31zj7H.png"/></div></div></figure><p id="17f6" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">客户机链接到的这些服务器连接被“汇集”——数量有限并可重复使用。因此，当客户端发送一些请求(开始一个事务或执行一个查询)时，可能会出现相应的服务器连接池被耗尽的情况，即pgbouncer打开了它所允许的尽可能多的连接，并且所有这些连接都被一些其他客户端占用(链接到)的情况。这个场景中的PgBouncer将客户机放入一个队列，这个客户机的连接进入一个<code class="eh lt lu lv lw b">CL_WAITING</code>状态。当客户端仅登录时，这也可能发生，因此也有<code class="eh lt lu lv lw b">CL_WAITING_LOGIN</code>用于此:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff me"><img src="../Images/e683fcfe68fb0cc911d8573741091c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1UjrQVd9Dq_phwQ1.png"/></div></div></figure><p id="ffbb" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">另一端是这些服务器连接:从PgBouncer到实际的数据库。那些有尊重的状态:<code class="eh lt lu lv lw b">SV_LOGIN</code>当授权时，<code class="eh lt lu lv lw b">SV_ACTIVE</code>当它与客户端的连接链接时(并且被使用或不被使用)，或者如果它是免费的— <code class="eh lt lu lv lw b">SV_IDLE</code>。</p><p id="c9a7" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">PgBouncer有一个管理界面，通过连接到一个名为<code class="eh lt lu lv lw b">pgbouncer</code>的特殊“虚拟”数据库。其中有许多<code class="eh lt lu lv lw b">SHOW</code>命令，其中一个命令<code class="eh lt lu lv lw b">SHOW POOLS </code>将显示每个池在每个状态下的连接数:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mf"><img src="../Images/69d737adbd165eeab2c5f8758d52dd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YHQXhZ0EndaHJL2S.png"/></div></div></figure><p id="59fc" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">我们在这里看到4个客户端的连接都打开了，它们都是— <code class="eh lt lu lv lw b">cl_active</code>。和5个服务器连接:4 — <code class="eh lt lu lv lw b">sv_active</code>一个在<code class="eh lt lu lv lw b">sv_used</code>中。这里有一篇关于如何监控这些状态的精彩文章。但基本上，你会希望以任何监控方式跟踪它们，这样你就有了历史画面。</p><h1 id="621b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">库大小</h1><p id="d513" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">没那么简单，PgBouncer有<strong class="jr hv"> 5个不同的设置</strong>与限制连接数有关！</p><ul class=""><li id="fb4e" class="ko kp hu jr b js kq jw kr ka ks ke kt ki ku km mg kw kx ky dt translated">您可以为每个代理数据库指定<code class="eh lt lu lv lw b">pool_size</code>。如果未设置，则默认为<code class="eh lt lu lv lw b">default_pool_size</code>设置，同样默认为<code class="eh lt lu lv lw b">20</code>值。</li><li id="1b40" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km mg kw kx ky dt translated"><code class="eh lt lu lv lw b">max_db_connections</code>非常适合解决这个问题——它限制了到任何数据库的连接总数，因此表现不佳的客户端将无法创建太多Postgres后端。</li><li id="bed0" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km mg kw kx ky dt translated"><code class="eh lt lu lv lw b">reserve_pool_size</code> —是对额外保留池的限制，如果常规池耗尽，即存在<code class="eh lt lu lv lw b">pool_size</code>打开的服务器连接，则保留池将发挥作用。据我所知，它旨在帮助服务一批客户。</li><li id="bf63" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km mg kw kx ky dt translated"><code class="eh lt lu lv lw b">max_user_connections</code> —这限制了从一个用户到任何数据库的连接总数<em class="ma">。从我的角度来看，这是一个非常奇怪的限制，只有在相同用户的多个数据库的情况下才有意义。</em></li><li id="2092" class="ko kp hu jr b js kz jw la ka lb ke lc ki ld km mg kw kx ky dt translated"><code class="eh lt lu lv lw b">max_client_conn</code> —限制传入客户端连接的总数。它与<code class="eh lt lu lv lw b">max_user_connections</code>不同，因为它包括来自任何用户的连接。</li></ul><p id="08b0" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">除了<code class="eh lt lu lv lw b">SHOW POOLS</code>之外，Pgbouncer的管理界面数据库也有<code class="eh lt lu lv lw b">SHOW DATABASES</code>命令，显示实际应用的限制以及所有已配置和当前存在的池:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mh"><img src="../Images/c85514c1eaa50b203ea21784fef7c4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QlyCtKb_oKMk7V4J.jpeg"/></div></div></figure><p id="9a96" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">因此用<code class="eh lt lu lv lw b">current_connections</code>除以<code class="eh lt lu lv lw b">pool_size</code>将得到池利用率，因此如果它接近100%，您就可以触发警报。</p><p id="fce2" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">PgBouncer还提供了<code class="eh lt lu lv lw b">SHOW STATS</code>命令，该命令提供了每个代理数据库的请求和流量的统计数据(据我所知，这不是一个惊喜):</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mi"><img src="../Images/99e41af45b908cf7b23556cb044b81a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1xOem_uDO7ef1dTS.png"/></div></div></figure><p id="6d23" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">在这里，为了测量池利用率，我们最感兴趣的是<code class="eh lt lu lv lw b">total_query_time</code>——当<em class="ma">主动连接到PostgreSQL，执行查询</em>时，pgbouncer花费的总微秒数。将此除以相应的池大小(将池大小视为一个挂钟秒内所有服务器连接可能花费在服务查询上的总秒数)，我们得到池利用率的另一个度量/估计值，我们称之为“查询时间利用率”。</p><p id="78c0" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">这是我写的关于<a class="ae kn" href="https://blog.okmeter.io/use-red-and-real-world-pgbouncer-monitoring-61b34ebeebb8" rel="noopener ugc nofollow" target="_blank">用ans RED监控方法监控PgBouncer的文章。</a></p><h1 id="247b" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">为什么仅仅观察利用率是不够的，还需要饱和度指标？</h1><p id="cde6" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">问题是，即使有像<code class="eh lt lu lv lw b">total_query_time</code>这样的累积统计数据，当我们查看统计数据时，也无法判断两个时刻之间是否有短时间的高利用率。例如，您将一些cron作业配置为同时启动并对数据库进行一些查询。如果这些查询足够短，即短于统计数据收集周期，那么测得的利用率可能仍然很低，而在crons启动时，它们可能会耗尽池。但是，如果只看利用率指标，您将无法做出诊断。</p><p id="8d44" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">我们如何在PgBouncer上追踪它？一种简单(且天真)的方法是在我们讨论过的<code class="eh lt lu lv lw b">cl_waiting</code>状态下计算<code class="eh lt lu lv lw b">SHOW POOLS</code>输出中的客户端。在正常情况下你不会看到它们，而看到等待的客户端数量大于0意味着池饱和。</p><p id="b3d5" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">但是如你所知，你只能采样<code class="eh lt lu lv lw b">SHOW POOLS</code>，这导致了错过这种等待的可能性。</p></div><div class="ab cl mj mk hc ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hn ho hp hq hr"><p id="fa91" class="pw-post-body-paragraph jp jq hu jr b js kq ju jv jw kr jy jz ka le kc kd ke lf kg kh ki lg kk kl km hn dt translated">查看我关于<a class="ae kn" href="https://blog.okmeter.io/postgres/home" rel="noopener ugc nofollow" target="_blank"> Postgres和监控</a>的其他文章。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="mq mr l"/></div></figure></div></div>    
</body>
</html>