<html>
<head>
<title>Running PHPUnit Tests with Code Coverage in PHPStorm When Working in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker中使用PHPStorm中的代码覆盖率运行PHPUnit测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/running-phpunit-tests-with-code-coverage-in-phpstorm-when-working-in-docker-12724c8b0f58?source=collection_archive---------22-----------------------#2018-09-27">https://medium.com/hackernoon/running-phpunit-tests-with-code-coverage-in-phpstorm-when-working-in-docker-12724c8b0f58?source=collection_archive---------22-----------------------#2018-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7917" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">作者:阿尔特姆·亨瓦尔德</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/87cc3983ac521d3faae7fca1bb9d4394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gv8cFGdp3UUj9bbCxS4vxQ.png"/></div></div></figure><p id="a068" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<strong class="jx hv"> PhpStorm </strong>中，可以创建<em class="kr">运行/调试配置</em>并从IDE中运行它们。它允许项目参与者使用设置中的“共享”标志共享通用配置。其中一个操作是在开发过程中运行单元测试。让我们讨论如何通过<strong class="jx hv"> Docker </strong>来微调这个过程。</p><p id="4358" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有一个插件<strong class="jx hv"> PHPUnit代码覆盖率</strong>，用于显示PhpStorm测试的代码覆盖率。PhpUnit可以使用生成代码覆盖率报告的选项来运行。该报告将包含测试执行期间对每个操作员的呼叫次数的信息。使用这些统计数据，我们可以计算测试代码覆盖率的百分比，因为如果文件中有操作符在测试期间从未被调用过，那么这段代码就没有被测试覆盖。这就是插件以表格的形式显示的文件和目录导航。该插件还可以用绿色或红色突出显示文件中的行，这些行相应地被测试覆盖或不被测试覆盖:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ks"><img src="../Images/be611cae84faa64219b59fc455d8c70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WYsQweNXJKrV_yGV.png"/></div></div></figure><p id="8fbd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了让这个插件在PhpStorm中正确工作，并从Docker容器中配置PHP CLI，应该采取一系列额外的操作。</p><p id="fe8e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，到目前为止，已经运行的容器的工作还没有正确实现。这是一个众所周知的缺点，在这里<a class="ae kt" href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000062320-Docker-compose-PHPUnit-kill-my-container-after-running-the-test" rel="noopener ugc nofollow" target="_blank">讨论</a>。有一个<a class="ae kt" href="https://youtrack.jetbrains.com/issue/PY-18901" rel="noopener ugc nofollow" target="_blank">问题</a>是用户建议可能的解决方案，还有一个<a class="ae kt" href="https://youtrack.jetbrains.com/issue/WI-37986" rel="noopener ugc nofollow" target="_blank">问题</a>是计划解决这个问题。我建议你订阅它们以保持消息灵通。简而言之，当您从Docker设置运行<em class="kr">运行配置</em>时，只要脚本在容器中执行，PhpStorm就会用PHP重启容器，之后，容器就会停止。从PhpStorm的测试运行结果中可以观察到:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="5876" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种方法使得永久开发成为不可能。当您在IDE中编写测试和特性，然后运行测试，之后切换到浏览器并手动测试特性，您需要手动重启PHP容器，因为PhpStorm在从<em class="kr"> Run/Debug </em>菜单运行控制台脚本后会停止它。为了避免这种副作用，直到JetBrains开发人员解决它，社区已经制定了最简单的解决方案。您需要创建另一个PHP容器，它将专门用于PhpStorm中的<em class="kr">运行/调试配置</em>。IDE将运行它，停止它或其他什么。同时，您的主要PHP容器不会被终止，您将能够从web浏览器(或任何其他用于HTTP调用的客户端)运行您的代码。在这种情况下，配置如下所示:</p><p id="de90" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> docker-compose.yml </strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="3d15" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> php_cli </strong>容器应该继承自<strong class="jx hv"> PHP </strong>容器或者是它的副本。根据具体的PHP映像和具体的平台，容器内的root访问对于代码覆盖插件的正确工作是必要的。我们已经通过在控制台PHP的映像中添加额外的指令解决了这个问题。如果在代码覆盖生成期间，PhpStorm通知您它不能访问某个类别，那么，您需要添加到<strong class="jx hv">中。/docker-configs/PHP-image/docker file</strong>将以下内容归档:</p><p id="2d39" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">。/docker-configs/PHP-image/docker file</strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="5a0e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，我们需要从Docker中为我们来自<em class="kr">运行/调试</em>的脚本设置并选择PHP服务器。为此，在PhpStorm的设置中，选择语言&amp;框架→PHP→CLI解释器并添加一个新的服务器。此外，勾选“仅对该项目可见”选项，因为对于每个项目，您都应该有一个单独的docker-compose.yml，以避免PhpStorm中的项目间连接共享。选择Docker Composer的配置，然后在服务下拉菜单中选择我们已经创建的配置，<strong class="jx hv"> php_cli </strong>:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff kw"><img src="../Images/4e052ba76374b0b8258b1ea0b929809f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VmAZFn2P3Q1xMIFW.png"/></div></div></figure><p id="4464" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你还需要进入<em class="kr">语言&amp;框架→ PHP →测试框架</em>设置，通过远程解释器为<em class="kr"> PHPUnit创建一个新的配置。在解释器的下拉列表中，选择我们之前设置的那个，PHP 7.1 Docker Compose。您可以默认配置<strong class="jx hv"> PHPUnit </strong>设置。由于测试是从Docker运行的，我们需要根据文件在容器中的位置来指定文件的路径。在我们的例子中，项目在<code class="eh kx ky kz la b">/app</code>文件夹中，这就是为什么自动加载器的路径被指定为<code class="eh kx ky kz la b">/app/vendor/autoload.php</code>，而配置文件的路径是<code class="eh kx ky kz la b">/app/phpunit.xml.dist</code>。正确地指定这个路径很重要，因为不会有来自PhpStorm的线索。</em></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lb"><img src="../Images/4546d76fa75ccd118be4dcaa6b4c751f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cc5d0M76gkuQwZpE.png"/></div></div></figure><p id="c8da" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们还应该提到，为了让PhpStorm正确地处理包含覆盖率结果的文件，您需要正确地指定文件的路径。为此，在为Docker设置的配置的T <em class="kr"> est框架</em>设置中，您必须向<em class="kr">路径映射</em>中添加一个新规则。本地路径应该指源代码本地存储的目录。例子中是<code class="eh kx ky kz la b">home/user/sites/project_name</code>。<em class="kr">远程路径</em>是指向Docker容器中项目根目录的路径。在我们的例子中是<code class="eh kx ky kz la b">/app</code>:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lc"><img src="../Images/98c28ae048e8eb5df9318b90b37a570e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TDizYwlYtvegylUL.png"/></div></div></figure><p id="419e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">应该这样做，因为代码覆盖率报告存储了PHPUnit处理的文件的路径。Docker中生成的报告相应地保存了文件的路径，这些路径与文件在容器中的位置有关。当报告中提到的文件在PhpStorm中打开时，PhpStorm会突出显示其中的行覆盖。相反，如果本地文件路径和报告文件路径不一致，PhpStorm将无法理解Docker容器路径符合本地路径，因此应该突出显示该文件。</p><p id="eb63" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">完成所有设置后，我们重新组装容器，运行它们，并在浏览器中处理项目。同时，我们在PhpStorm中运行测试。它们在<strong class="jx hv"> php_cli </strong>容器中执行，不影响<strong class="jx hv"> PHP </strong>容器。部署一个单独的容器来运行控制台实用程序不受PHPUnit的限制。现在您已经有了一个来自<strong class="jx hv"> php_cli </strong>容器的配置解释器，您可以在PhpStorm中创建其他<em class="kr">运行/调试配置</em>，例如，任何也将在这个短命容器中运行的php脚本。因此，您可以在IDE中立即看到实现结果，而不必切换到终端并手动键入命令。它还允许优化开发过程，因为在<em class="kr">运行/调试配置</em>中，您可以在PhpStorm中分配专用热键，以便例行任务的运行将被限制在键盘上的快捷键中。</p><p id="3656" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">PhpStorm中Docker问题的另一个可能来源是一个<strong class="jx hv"> docker-compose </strong>实用程序。别忘了更新。我自己也遇到过PhpStorm不想运行的情况，因为我的电脑上安装了一个太早的版本。当前版本的更新解决了这个问题。你可以在这里查看当前版本<a class="ae kt" href="https://github.com/docker/compose/releases" rel="noopener ugc nofollow" target="_blank">，你可以在这里</a>找到<strong class="jx hv"> docker-compose </strong>更新<a class="ae kt" href="https://docs.docker.com/compose/install/#install-compose" rel="noopener ugc nofollow" target="_blank">的指南。</a></p><p id="c411" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">P.S .如果JetBrains开发人员最终改进了他们IDE中docker-compose实用程序的行为(这个问题不仅对PhpStorm来说很紧迫)，那么就不再需要所描述的方法了。</p><p id="6d46" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kr">原载于stfalcon.com</em><a class="ae kt" href="https://stfalcon.com/en/blog/post/phpstorm-docker-code-coverage" rel="noopener ugc nofollow" target="_blank"><em class="kr"/></a><em class="kr">。</em></p></div></div>    
</body>
</html>