<html>
<head>
<title>Techniques for animating on the canvas in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的画布动画技术</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/techniques-for-animating-on-the-canvas-in-react-d0e9fd53e9da?source=collection_archive---------23-----------------------#2018-09-27">https://medium.com/hackernoon/techniques-for-animating-on-the-canvas-in-react-d0e9fd53e9da?source=collection_archive---------23-----------------------#2018-09-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/75ab6cd75c6b63c45885d2b1ca17bd1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KBGdMaU_emZX4XR1AvkD4A.gif"/></div></div></figure><p id="9723" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近在Twilio博客上尝试了React中的<a class="ae ka" href="https://www.twilio.com/blog/audio-visualisation-web-audio-api--react" rel="noopener ugc nofollow" target="_blank">音频可视化。当我打算自学更多关于web audio API的知识时，我发现我学到了一些在React项目中制作canvas动画的技巧。如果你正在React中创建一个画布动画，那么这可能也会对你有所帮助。</a></p><h1 id="4358" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">好的推荐信</h1><p id="f01d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">首先，如果你以前用过React，你会知道你应该避免接触DOM，让React来处理它。如果你以前使用过HTML5 <code class="eh le lf lg lh b">&lt;canvas&gt;</code>的话，你也会知道要获得在画布上绘制的上下文，你需要直接调用画布元素本身。值得庆幸的是，这是一个边缘案例，<a class="ae ka" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">通过引用</a>来支持React。</p><p id="8683" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要在React组件中获取对canvas元素的引用，首先需要使用<code class="eh le lf lg lh b">React.createRef</code>在构造函数中创建引用。当您开始渲染画布元素时，添加一个名为<code class="eh le lf lg lh b">ref</code>的道具，它指向您创建的ref。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="c7e5" class="lq kc hu lh b fv lr ls l lt lu">class Animation extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.canvasRef = React.createRef();<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;canvas ref={this.canvasRef} /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="7d96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样设置好之后，就可以通过ref的<code class="eh le lf lg lh b">current</code>属性引用canvas元素，例如在<code class="eh le lf lg lh b">componentDidMount</code>中:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="a6df" class="lq kc hu lh b fv lr ls l lt lu">  componentDidMount() {<br/>    const canvas = this.canvasRef.current;<br/>    const context = canvas.getContext('2d');<br/>    context.fillRect(0, 0, canvas.width, canvas.height);<br/>  }</span></pre><p id="a297" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你有了可以随意绘制和制作动画的背景。</p><h1 id="6d9b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">分离动画和绘图</h1><p id="e85b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">许多使用React的构建都是为了维护视图的状态。我第一次在React的画布上制作动画时，我保存了状态和代码，以便在同一个组件中绘制它。在网上浏览示例后，我在CodePen 上偶然发现了<a class="ae ka" href="https://codepen.io/vasilly/pen/NRKyWL" rel="noopener ugc nofollow" target="_blank">这个旋转的正方形。这个例子中我真正喜欢的是使用两个组件将状态从绘图中分离出来的方式。然后，绘图的状态通过props从动画组件传递到绘图组件。</a></p><p id="046c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我重新创作了原作来展示这种分离。</p><p id="0db0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先定义一个<code class="eh le lf lg lh b">Canvas</code>组件，它使用道具作为参数来绘制图像。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="af62" class="lq kc hu lh b fv lr ls l lt lu">class Canvas extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.canvasRef = React.createRef();<br/>  }<br/><br/>  componentDidUpdate() {<br/>    // Draws a square in the middle of the canvas rotated<br/>    // around the centre by this.props.angle<br/>    const { angle } = this.props;<br/>    const canvas = this.canvasRef.current;<br/>    const ctx = canvas.getContext('2d');<br/>    const width = canvas.width;<br/>    const height = canvas.height;<br/>    ctx.save();<br/>    ctx.beginPath();<br/>    ctx.clearRect(0, 0, width, height);<br/>    ctx.translate(width / 2, height / 2);<br/>    ctx.rotate((angle * Math.PI) / 180);<br/>    ctx.fillStyle = '#4397AC';<br/>    ctx.fillRect(-width / 4, -height / 4, width / 2, height / 2);<br/>    ctx.restore();<br/>  }<br/><br/>  render() {<br/>    return &lt;canvas width="300" height="300" ref={this.canvasRef} /&gt;;<br/>  }<br/>}</span></pre><p id="d1a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后创建一个使用<code class="eh le lf lg lh b"><a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame</a></code>运行动画循环的<code class="eh le lf lg lh b">Animation</code>组件。每次动画循环运行时，更新状态中的动画参数，并让React使用更新的道具渲染<code class="eh le lf lg lh b">Canvas</code>。</p><p id="d37f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要忘记实现<code class="eh le lf lg lh b">componentWillUnmount</code>来停止<code class="eh le lf lg lh b">requestAnimationFrame</code>循环。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="a20c" class="lq kc hu lh b fv lr ls l lt lu">class Animation extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { angle: 0 };<br/>    this.updateAnimationState = this.updateAnimationState.bind(this);<br/>  }<br/><br/>  componentDidMount() {<br/>    this.rAF = requestAnimationFrame(this.updateAnimationState);<br/>  }<br/><br/>  updateAnimationState() {<br/>    this.setState(prevState =&gt; ({ angle: prevState.angle + 1 }));<br/>    this.rAF = requestAnimationFrame(this.updateAnimationState);<br/>  }<br/><br/>  componentWillUnmount() {<br/>    cancelAnimationFrame(this.rAF);<br/>  }<br/><br/>  render() {<br/>    return &lt;Canvas angle={this.state.angle} /&gt;;<br/>  }<br/>}</span></pre><p id="b203" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在这支笔中看到<a class="ae ka" href="https://codepen.io/philnash/pen/QVeOrd" rel="noopener ugc nofollow" target="_blank">的动作。</a></p><h1 id="abe8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">重新渲染</h1><p id="c489" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在React中制作动画或进行其他密集的视觉更新时，一个问题是过于频繁地重新渲染子元素，导致<a class="ae ka" href="http://jankfree.org/" rel="noopener ugc nofollow" target="_blank"> jank </a>。当我们在画布上绘图时，我们从不希望画布元素本身被重新渲染。那么，暗示我们不希望这种情况发生的最好方式是什么呢？</p><p id="03d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会想到<code class="eh le lf lg lh b"><a class="ae ka" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate</a></code>生命周期法。从<code class="eh le lf lg lh b">shouldComponentUpdate</code>返回<code class="eh le lf lg lh b">false</code>会让React知道这个组件不需要改变。然而，如果我们使用上面的模式，从<code class="eh le lf lg lh b">shouldComponentUpdate</code>返回<code class="eh le lf lg lh b">false</code>将跳过运行<code class="eh le lf lg lh b">componentDidUpdate</code>，这是我们绘图的原因。</p><p id="1f33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最终在StackOverflow 上看到了丹·阿布拉莫夫对一个问题的回答。我们可以创建一个实现<code class="eh le lf lg lh b">shouldComponentUpdate</code>并返回<code class="eh le lf lg lh b">false</code>的<code class="eh le lf lg lh b">PureCanvas</code>组件，并使用一个<a class="ae ka" href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs" rel="noopener ugc nofollow" target="_blank">回调引用</a>来获取对父<code class="eh le lf lg lh b">Canvas</code>组件中canvas元素的引用。</p><p id="a5d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lv">注意:在</em> <a class="ae ka" href="https://stackoverflow.com/a/49803151/28376" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Dan的回答中</em> </a> <em class="lv">他说使用上面的模式应该没问题，下面的技术可能只有在你已经对你的应用程序进行了概要分析并发现它有所不同时才是必要的。</em></p><p id="67ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更新上面的例子，我们将<code class="eh le lf lg lh b">Canvas</code>组件分成一个<code class="eh le lf lg lh b">Canvas</code>和一个<code class="eh le lf lg lh b">PureCanvas</code>。首先，<code class="eh le lf lg lh b">PureCanvas</code>使用回调ref和通过props提供的回调将画布上下文返回给父组件。它还呈现画布元素本身。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="c341" class="lq kc hu lh b fv lr ls l lt lu">class PureCanvas extends React.Component {<br/>  shouldComponentUpdate() {<br/>    return false;<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;canvas<br/>        width="300"<br/>        height="300"<br/>        ref={node =&gt;<br/>          node ? this.props.contextRef(node.getContext('2d')) : null<br/>        }<br/>      /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="365c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后<code class="eh le lf lg lh b">Canvas</code>组件传递一个回调函数<code class="eh le lf lg lh b">saveContext</code>，作为渲染<code class="eh le lf lg lh b">PureCanvas</code>时的<code class="eh le lf lg lh b">contextRef</code>道具。当函数被调用时，我们保存上下文(并缓存画布元素的宽度和高度)。其余与之前的不同之处是将对<code class="eh le lf lg lh b">ctx</code>的引用改为<code class="eh le lf lg lh b">this.ctx</code>。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="c75c" class="lq kc hu lh b fv lr ls l lt lu">class Canvas extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.saveContext = this.saveContext.bind(this);<br/>  }<br/><br/>  saveContext(ctx) {<br/>    this.ctx = ctx;<br/>    this.width = this.ctx.canvas.width;<br/>    this.height = this.ctx.canvas.height;<br/>  }<br/><br/>  componentDidUpdate() {<br/>    const { angle } = this.props;<br/>    this.ctx.save();<br/>    this.ctx.beginPath();<br/>    this.ctx.clearRect(0, 0, this.width, this.height);<br/>    this.ctx.translate(this.width / 2, this.height / 2);<br/>    this.ctx.rotate((angle * Math.PI) / 180);<br/>    this.ctx.fillStyle = '#4397AC';<br/>    this.ctx.fillRect(<br/>      -this.width / 4,<br/>      -this.height / 4,<br/>      this.width / 2,<br/>      this.height / 2<br/>    );<br/>    this.ctx.restore();<br/>  }<br/><br/>  render() {<br/>    return &lt;PureCanvas contextRef={this.saveContext} /&gt;;<br/>  }<br/>}</span></pre><p id="1ca1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管这不是必须的，但我发现动画、绘图和呈现画布元素本身之间的这种分离非常令人愉快。你也可以在CodePen上看到这个例子。</p><h1 id="062c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">画布vs反应</h1><p id="8b27" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在React中使用画布元素是一段有趣的旅程。他们的工作方式彼此感觉非常不同，所以让他们同步并不一定简单。希望如果你有这个问题，那么这些技术可以帮助你。</p><p id="6c14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你对React中的其他动画感兴趣，请查看我关于React 中<a class="ae ka" href="https://www.twilio.com/blog/audio-visualisation-web-audio-api--react" rel="noopener ugc nofollow" target="_blank">音频可视化的文章。</a></p><p id="3bd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你有另外一种在React中使用canvas的方法，我很乐意听听。在Twitter上给我留言，地址是<a class="ae ka" href="https://twitter.com/philnash" rel="noopener ugc nofollow" target="_blank"> @philnash </a>。</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="1fb6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lv">原载于2018年9月27日</em><a class="ae ka" href="https://philna.sh/blog/2018/09/27/techniques-for-animating-on-the-canvas-in-react/" rel="noopener ugc nofollow" target="_blank"><em class="lv">philna . sh</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>