<html>
<head>
<title>Tutorial on How to Merge Django ORM with SQLAlchemy for Easier Data Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于如何将Django ORM与SQLAlchemy合并以简化数据分析的教程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/merging-django-orm-with-sqlalchemy-for-easier-data-analysis-75b85e2cc0b9?source=collection_archive---------3-----------------------#2018-09-28">https://medium.com/hackernoon/merging-django-orm-with-sqlalchemy-for-easier-data-analysis-75b85e2cc0b9?source=collection_archive---------3-----------------------#2018-09-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d2ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Django框架开发产品通常简单明了；优秀的文档，许多现成的工具，大量的开源库和大型社区。Django ORM完全控制SQL层，防止您出错，并控制查询的底层细节，因此您可以花更多时间用Python代码设计和构建应用程序结构。然而，有时这种行为可能会造成伤害——例如，当您正在构建一个与数据分析相关的项目时。用Django构建高级查询并不容易；如果不在某处记录或打印生成的SQL查询，就很难阅读(用Python)和理解SQL级别的内容。此外，这样的查询可能不够高效，所以当您将更多的数据加载到DB中进行处理时，这将对您产生不利影响。在某个时刻，您会发现自己通过Django cursor做了太多的原始SQL，这时您应该休息一下，看看另一个有趣的工具，它位于ORM层和原始SQL查询层之间。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/6d86e4a148577b3744e434b91d991560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TriFQN0BAedzS312EW6IwA.png"/></div></div></figure><p id="fc4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你在文章标题中看到的，我们成功地将Django ORM和SQLAlchemy Core混合在一起，我们对结果非常满意。我们构建了一个应用程序，通过将数据汇总到图表和表格中，根据吞吐量/效率/员工成本进行评分，并突出显示异常值来帮助分析EMR系统产生的数据，从而优化诊所的业务流程并节省资金。</p><blockquote class="kc kd ke"><p id="2ca0" class="ir is jp it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated"><strong class="it hv"> <em class="hu">注意:</em> </strong> <em class="hu">由于降价，代码样本可能显示不正确。我们推荐</em> <a class="ae ki" href="https://djangostars.com/blog/merging-django-orm-with-sqlalchemy-for-easier-data-analysis/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%20orm&amp;utm_content=continue%20reading%20on%20ds%20blog" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="hu">继续阅读我们博客</em></strong></a><strong class="it hv"><em class="hu"/></strong><em class="hu">上的原文，以确保所有的例子都能正确显示。</em></p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kj"><img src="../Images/6b99c691f1c123ff8eada3bd7b363c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrZdO8PCQE_MTpss5-09lA.png"/></div></div></figure><h1 id="d9f1" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">把Django ORM和SQLAlchemy混在一起有什么意义？</h1><p id="5a06" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">我们从Django ORM中走出来完成这个任务有几个原因:</p><ul class=""><li id="6032" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv dt translated">对于ORM world，一个对象就是数据库中的一条记录，但是这里我们只处理聚合数据。</li><li id="c21b" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">一些聚合非常棘手，Django ORM功能不足以满足需求。老实说，有时在一些简单的情况下，很难(甚至不可能)让ORM完全按照您想要的方式产生SQL查询，当您处理一个<strong class="it hv">大数据</strong>时，它会对性能产生很大影响。</li><li id="9510" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">如果您正在通过Django ORM构建高级查询，那么很难阅读和理解Python中的这类查询，也很难预测哪个SQL查询将被生成并处理给数据库。</li></ul><p id="0d2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得一提的是，我们还建立了第二个数据库，由Django ORM处理，以涵盖其他web应用程序相关的任务和业务逻辑需求，它很好地做到了这一点。Django ORM正从一个版本发展到另一个版本，提供越来越多的功能。例如，在最近的版本中，添加了许多简洁的功能，如支持<a class="ae ki" href="https://docs.djangoproject.com/en/1.11/ref/models/expressions/#subquery-expressions" rel="noopener ugc nofollow" target="_blank">子查询表达式</a>或<a class="ae ki" href="https://docs.djangoproject.com/en/2.1/ref/models/database-functions/#window-functions" rel="noopener ugc nofollow" target="_blank">窗口函数</a>以及许多其他功能，如果您的问题比修复几个查询更复杂，那么您一定要在使用原始SQL或查看SQLAlchemy等工具之前尝试一下这些功能。</p><p id="0115" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是为什么我们决定看看SQLAlchemy。它由两部分组成— ORM和Core。SQLAlchemy ORM类似于Django ORM，但同时，它们又有所不同。与Django的活动记录方法相比，SQLAlchemy ORM使用了不同的概念，即数据映射器。就你在Django上构建项目而言，你绝对不应该切换ORM(如果你没有非常特殊的原因要这么做)，因为你想使用Django REST框架、Django-admin和其他与Django模型相关的好东西。</p><p id="13ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SQLAlchemy的第二部分称为核心。它位于高级ORM和低级SQL之间。核心非常强大灵活；它让您能够构建任何您想要的SQL查询，当您在Python中看到这样的查询时，很容易理解发生了什么。例如，请看文档中的一个示例查询:</p><pre class="jr js jt ju fq mb mc md me aw mf dt"><span id="5e8a" class="mg kl hu mc b fv mh mi l mj mk">q = session.query(User).filter(User.name.like('e%')).\  <br/>    limit(5).from_self().\<br/>    join(User.addresses).filter(Address.email.like('q%')).\<br/>    order_by(User.name)</span></pre><p id="ffe1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将导致</p><pre class="jr js jt ju fq mb mc md me aw mf dt"><span id="5421" class="mg kl hu mc b fv mh mi l mj mk">SELECT anon_1.user_id AS anon_1_user_id,  <br/>       anon_1.user_name AS anon_1_user_name<br/>FROM (SELECT "user".id AS user_id, "user".name AS user_name  <br/>FROM "user"  <br/>WHERE "user".name LIKE :name_1  <br/> LIMIT :param_1) AS anon_1<br/>JOIN address ON anon_1.user_id = address.user_id  <br/>WHERE address.email LIKE :email_1 ORDER BY anon_1.user_name</span></pre><p id="720c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:有了这些技巧，我们就不会陷入<code class="eh ml mm mn mc b">N+1 problem</code> : <code class="eh ml mm mn mc b">from_select</code>对查询进行了额外的<code class="eh ml mm mn mc b">SELECT</code>包装，所以我们首先减少了行数(通过<code class="eh ml mm mn mc b">LIKE</code>和<code class="eh ml mm mn mc b">LIMIT</code>)，然后才加入地址信息。</p><h1 id="d5fa" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">如何混合Django应用程序和SQLALchemy</h1><p id="dbbe" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">因此，如果您感兴趣并想尝试将SQLAlchemy与Django应用程序混合使用，这里有一些提示可以帮助您。</p><p id="469f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，你需要<a class="ae ki" href="http://docs.sqlalchemy.org/en/latest/core/engines.html#engine-configuration" rel="noopener ugc nofollow" target="_blank">用Engine创建</a>一个全局变量，但是与DB的实际连接将在第一次<code class="eh ml mm mn mc b">connect</code>或<code class="eh ml mm mn mc b">execute</code>调用时建立。</p><pre class="jr js jt ju fq mb mc md me aw mf dt"><span id="eebb" class="mg kl hu mc b fv mh mi l mj mk">sa_engine = create_engine(settings.DB_CONNECTION_URL, pool_recycle=settings.POOL_RECYCLE)</span></pre><p id="ac70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建<em class="jp">引擎接受连接的附加配置。MySQL/MariaDB/AWS Aurora(MySQL兼容)有一个交互式</em>超时设置，默认为8h，所以如果没有pool_recycle额外参数，你会变得很烦人<code class="eh ml mm mn mc b">SQLError: (OperationalError) (2006, ‘MySQL server has gone away’)</code>。所以<code class="eh ml mm mn mc b">POOL_RECYCLE</code>应该比<code class="eh ml mm mn mc b">interactive_timeout</code>小。例如它的一半:<code class="eh ml mm mn mc b">POOL_RECYCLE = 4 * 60 * 60</code></p><p id="60c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步是构建您的查询。根据您的应用程序架构，您可以使用 <code class="eh ml mm mn mc b">Table</code>和<code class="eh ml mm mn mc b">Column</code>类来声明表和字段<a class="ae ki" href="http://docs.sqlalchemy.org/en/latest/core/metadata.html" rel="noopener ugc nofollow" target="_blank">(这些类也可以用于ORM)，或者如果您的应用程序已经以另一种方式存储了表和列名，您可以通过table ( <code class="eh ml mm mn mc b">table_name</code>)和column ( <code class="eh ml mm mn mc b">col_name</code>)函数(如此处的</a><a class="ae ki" href="http://docs.sqlalchemy.org/en/latest/core/selectable.html#sqlalchemy.sql.expression.table" rel="noopener ugc nofollow" target="_blank">所示</a>)就地完成。</p><p id="02d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的应用程序中，我们选择了第二个选项，因为我们在自己的声明性语法中存储了关于聚合、公式和格式的信息。然后，我们构建了一个层，它读取这样的结构并根据提供的指令执行查询。</p><p id="3949" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您的查询准备好时，只需调用<code class="eh ml mm mn mc b">sa_engine.execute(query)</code>。游标将一直打开，直到您读取所有数据或者显式关闭它。</p><p id="b8da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一件很烦的事情值得一提。正如<a class="ae ki" href="http://docs.sqlalchemy.org/en/latest/faq/sqlexpressions.html#how-do-i-render-sql-expressions-as-strings-possibly-with-bound-parameters-inlined" rel="noopener ugc nofollow" target="_blank">文档所说的</a>，SQLAlchemy进行查询字符串化的能力有限，所以不容易得到最终要执行的查询。您可以单独打印查询:</p><pre class="jr js jt ju fq mb mc md me aw mf dt"><span id="2f77" class="mg kl hu mc b fv mh mi l mj mk">print(query)</span><span id="39cb" class="mg kl hu mc b fv mo mi l mj mk">SELECT  <br/>role_group_id, role_group_name, nr_patients  <br/>FROM "StaffSummary"  <br/>WHERE day &gt;= :day_1 AND day &lt;= :day_2 AND location_id = :location_id_1 AND service_id = :service_id_1</span></pre><p id="c29e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(这个看起来没有那么可怕，但是对于更复杂的查询，它可能有大约20多个占位符，手动填充这些占位符非常烦人而且非常耗时，以便稍后在SQL控制台中播放。)</p><p id="9502" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您只有字符串和数字要插入到查询中，这将为您工作</p><pre class="jr js jt ju fq mb mc md me aw mf dt"><span id="5097" class="mg kl hu mc b fv mh mi l mj mk">print(s.compile(compile_kwargs={"literal_binds": True}))</span></pre><p id="d909" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于约会来说，这样的伎俩是行不通的。StackOverflow上有一个关于如何实现预期结果的讨论，但是解决方案看起来没有吸引力。</p><p id="48f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种选择是通过数据库配置将查询记录到文件中，但是在这种情况下，您可能会面临另一个问题；如果Django ORM也连接到这个数据库，就很难找到想要调试的查询。</p><h2 id="296a" class="mg kl hu bd km mp mq mr kq ms mt mu ku jc mv mw ky jg mx my lc jk mz na lg nb dt translated">您可能还喜欢:</h2><div class="nc nd fm fo ne nf"><a href="https://djangostars.com/blog/python-and-django-beginners-pack-books-tutorials-newsletters/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%20orm&amp;utm_content=youmayalsolike1" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hv fv z el nk eo ep nl er et ht dt translated">适合初学者的最佳Python &amp; Django书籍和教程</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">无论你是计划扩展你的编程技能，还是作为一名软件开发人员开始一个新的职业生涯，学习…</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">djangostars.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ka nf"/></div></div></a></div><div class="nc nd fm fo ne nf"><a href="https://djangostars.com/blog/django-performance-optimization-tips/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%20orm&amp;utm_content=youmayalsolike2" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hv fv z el nk eo ep nl er et ht dt translated">Django性能优化技巧</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">当开发人员接到一个在Django上进行性能优化的任务时，我经常会遇到这种情况…</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">djangostars.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ka nf"/></div></div></a></div><h1 id="b948" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">测试</h1><p id="f233" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">注意:Pytest <a class="ae ki" href="http://pytest-django.readthedocs.io/en/latest/database.html#tests-requiring-multiple-databases" rel="noopener ugc nofollow" target="_blank"> multidb注意</a>说“目前pytest-django没有明确支持django的多数据库支持。不过，您可以使用普通的Django TestCase实例来使用它的multi_db支持。”</p><p id="6e24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么这意味着什么——不支持？默认情况下，Django将为<code class="eh ml mm mn mc b">DATABASES</code>定义中列出的每个db创建并删除(在所有测试结束时)一个测试数据库。这个特性也能与<code class="eh ml mm mn mc b">pytests</code>完美配合。</p><p id="adcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Django <code class="eh ml mm mn mc b">TestCase</code>和<code class="eh ml mm mn mc b">TransactionTestCase</code>与<code class="eh ml mm mn mc b">multi_db=True</code>能够在测试之间清除多个数据库中的数据。也可以通过<code class="eh ml mm mn mc b">django-fixtures</code>将数据加载到第二个数据库中，但最好使用<a class="ae ki" href="https://model-mommy.readthedocs.io/en/latest/basic_usage.html" rel="noopener ugc nofollow" target="_blank">型号<em class="jp">妈咪</em> </a> <em class="jp">或</em> <a class="ae ki" href="https://model-mommy.readthedocs.io/en/latest/basic_usage.html" rel="noopener ugc nofollow" target="_blank"> <em class="jp">工厂</em>男孩</a>来代替，它们不受该属性的影响。</p><p id="03c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae ki" href="https://github.com/pytest-dev/pytest-django/issues/76" rel="noopener ugc nofollow" target="_blank"> pytest-django讨论</a>中有一些建议如何解决这个问题并使<code class="eh ml mm mn mc b">multi_db</code>能够继续pytesting。</p><p id="8f3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一个重要的建议——对于有Django模型的表，您应该通过Django-ORM将数据保存到DB。否则，您将在编写测试时面临问题。<code class="eh ml mm mn mc b">TestCase</code>将无法回滚在Django DB连接之外发生的其他事务。如果您遇到这种情况，您可以将<code class="eh ml mm mn mc b">TransactionalTestCase</code>与<code class="eh ml mm mn mc b">multi_db=True</code>一起用于触发功能的测试，这将通过SQLAlchemy连接产生DB写入，但是请记住，这种测试比常规的<code class="eh ml mm mn mc b">TestCase</code>要慢。</p><p id="97c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外，另一个场景也是可能的——您只有一个数据库中的Django-models，并且您通过SQLAlchemy使用第二个数据库。这种情况下，<code class="eh ml mm mn mc b">multi_db</code>根本不影响你。在这种情况下，您需要编写一个pytest-fixture(或者在<code class="eh ml mm mn mc b">setUp</code>中作为mixin和触发器逻辑，如果您使用unittests的话),它将从SQL文件创建DB结构。这样的文件应该在<code class="eh ml mm mn mc b">CREATE TABLE</code>之前包含<code class="eh ml mm mn mc b">DROP TABLE IF EXISTS</code>语句。这个fixture应该被应用到每个操作这个数据库的测试用例中。其他设备可以将数据加载到创建的表中。</p><p id="e4e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:这样的测试会比较慢，因为每次测试都要重新创建表。理想情况下，应该创建一次表(声明为<code class="eh ml mm mn mc b">@pytest.fixture(scope='session', autouse=True)</code>)，并且每个事务应该回滚每个测试的数据。这并不容易实现，因为不同的连接:Django &amp; SQLAlchemy或SQLAlchemy连接池的不同连接，例如，在您的测试中，您启动事务，用测试数据填充DB，然后运行测试并回滚事务(它没有被提交)。但是在测试过程中，您的应用程序代码可能会像connection.execute(query)一样对数据库进行查询，这些查询是在创建测试数据的事务之外执行的。因此，使用默认的事务隔离级别，应用程序将看不到任何数据，只能看到空表。对于SQLAlchemy连接，可以将事务隔离级别更改为<code class="eh ml mm mn mc b">READ UNCOMMITTED</code>，一切都将按预期工作，但这绝对不是一个解决方案。</p><h1 id="1fd7" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">结论</h1><p id="20aa" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">综上所述，SQLAlchemy Core是一个很棒的工具，它让您更接近SQL，并让您理解和完全控制查询。如果您正在构建需要高级聚合的应用程序(或其中的一部分),那么作为Django ORM工具的替代，值得一试SQLAlchemy核心功能。</p><p id="02da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请继续阅读，了解如何更轻松地为数据分析项目构建高级查询。了解我们如何设法混合Django ORM和SQLAlchemy Core，以及我们从中获得了什么。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://djangostars.com/about-us/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%20orm&amp;utm_content=banner_end"><div class="fe ff nv"><img src="../Images/6d17f1f498aa416fd7fa01921bc012f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_uHZvyUk2wIql_cXIsZcw.png"/></div></a></figure><blockquote class="kc kd ke"><p id="d910" class="ir is jp it b iu iv iw ix iy iz ja jb kf jd je jf kg jh ji jj kh jl jm jn jo hn dt translated">这篇关于<a class="ae ki" href="https://djangostars.com/blog/merging-django-orm-with-sqlalchemy-for-easier-data-analysis/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%20orm&amp;utm_content=MergingDjangoORM" rel="noopener ugc nofollow" target="_blank">合并Django ORM </a>的文章是由<strong class="it hv"> Gleb Pushkov </strong>撰写的——Django Stars的高级软件开发人员</p></blockquote><blockquote class="nw"><p id="b4ea" class="nx ny hu bd nz oa ob oc od oe of jo ek translated">如果你觉得这篇文章有用，请点击👏下面的按钮:)</p></blockquote><figure class="og oh oi oj ok jv"><div class="bz el l di"><div class="ol om l"/></div></figure></div></div>    
</body>
</html>