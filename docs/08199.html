<html>
<head>
<title>How to do Novelty Detection in Keras with Generative Adversarial Network (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用生成对抗网络在Keras中进行新颖性检测(上)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-do-novelty-detection-in-keras-with-generative-adversarial-network-part-1-e288ba745b9d?source=collection_archive---------21-----------------------#2018-09-28">https://medium.com/hackernoon/how-to-do-novelty-detection-in-keras-with-generative-adversarial-network-part-1-e288ba745b9d?source=collection_archive---------21-----------------------#2018-09-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b241fde449c86c03d372cd7bfa8e3391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kg89-ce0p4LaSb3z.png"/></div></div></figure><p id="8dc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新颖性检测的任务是对测试数据进行分类，这些测试数据在某些方面不同于训练期间可用的数据。这可以被视为“一类分类”，其中构建模型来描述“正常的”训练数据。当可用的“异常”数据的数量不足以构建非正常类的显式模型时，通常使用新颖性检测方法。一个应用包括来自关键系统的数据集中的推断，其中可用的正态数据的数量是巨大的，使得“正态性”可以被精确地建模。</p><p id="14e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些包括医疗诊断问题的检测、复杂工业系统中的故障和失效检测、结构损坏、电子安全系统中的入侵，例如信用卡或移动电话欺诈检测、视频监控、移动机器人、传感器网络、天文目录和文本挖掘。</p><p id="ed74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本系列教程中，我将向您展示如何使用Keras框架实现一个用于新颖性检测的生成式对抗网络。第1部分介绍了该模型的一般工作原理，而第2部分介绍了Keras的实现。</p><h1 id="da67" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">模型结构</h1><p id="1d50" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们要建立的模型被命名为对抗学习单类分类器或简称为ALOCC，如我的源代码所示。下图显示了该模型包含一个连接到CNN分类器的自动编码器，作为您可能在GAN中听说过的鉴别器。在继续之前，让我们快速回顾一下这两种独立的网络架构。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/ba53a75e50049be6cb92da0d1eae1bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wz5-8ldWc-jXocAq.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">ALOCC model structure</figcaption></figure><h1 id="97ec" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">自动编码器评论</h1><p id="a6d9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Autoencoder是一种数据压缩算法，其中有两个主要部分，编码器和解码器。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/e79ec3a3ba020d8e7fedff2028b07fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1Am-RxQCrkUfCe8y.jpg"/></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Auto-encoder</figcaption></figure><p id="1d3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编码器的工作是将输入数据压缩到较低的维度特征。例如，28x28 MNIST图像的一个样本总共有784个像素，我们构建的编码器可以将其压缩到一个只有10个浮点数的数组，也称为图像的特征。另一方面，解码器部分将压缩的特征作为输入，并重建尽可能接近原始图像的图像。Autoencoder本质上是一种无监督学习算法，因为在训练过程中，它只需要图像本身，而不需要标签。由于它是一种无监督的学习算法，所以它可以用于未标记数据的聚类，正如我在以前的帖子中看到的那样— <a class="ae ka" href="https://www.dlology.com/blog/how-to-do-unsupervised-clustering-with-keras/" rel="noopener ugc nofollow" target="_blank">如何用Keras进行无监督聚类</a>。</p><p id="e2c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" rel="noopener" href="/@curiousily/credit-card-fraud-detection-using-autoencoders-in-keras-tensorflow-for-hackers-part-vii-20e0c85301bd">以前</a>，对来自目标类的样本进行训练的自动编码器的重构误差已被证明是新颖样本检测的有用度量。</p><h1 id="5e91" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">甘评论</h1><p id="b5e4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">虽然GANs非常高级，对初学者来说可能令人望而生畏，但我发现新手画家(生成器)与新手鉴赏家(鉴别器)的类比非常容易理解。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/42e4b166cf66676e61edb9557a59088c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*4Sq2BwlVrjF4YHtl.png"/></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Painter(Generator) vs. connoisseur(Discriminator)</figcaption></figure><p id="1ffe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">两个雄心勃勃的人，一个画家和一个鉴赏家，正在向艺术行业迈出第一步。画家想哄骗鉴赏家给自己的画尽可能高的评分，而鉴赏家则想尽可能准确地辨别好画和坏画。所以他们一遍又一遍地重复这三个步骤，玩一个无限的游戏。</p><ol class=""><li id="081e" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated"><strong class="je hv">画师</strong>根据自己之前的经验和鉴赏家的反馈(如果有的话)画了几幅画。</li><li id="259a" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><strong class="je hv">鉴赏家学会</strong>分辨好的(例如梵高的杰作)和坏的(画家的画)。</li><li id="5368" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><strong class="je hv">画家学会</strong>愚弄鉴赏家，让他把自己的画评为和梵高一样好——这里鉴别器网络(鉴赏家)的权重被冻结，只训练生成器(画家)。</li></ol><p id="a614" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经过数百甚至数千轮的相互竞争，新手画家变成了印刷大师，他的画几乎与梵高的画难以区分，而新的鉴赏家变成了专家，他能以无与伦比的精确度从成吨的复制品中识别出真正的真迹。</p><p id="7710" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个比喻告诉我们的是，在GAN中有两个独立的网络，生成器和鉴别器，它们被分别训练以最小化它们的损失，同时对抗性地改善彼此。</p><h1 id="103d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">模型——对抗学习的一类分类器</h1><p id="e42e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">类似于GANs，所提出的体系结构包括两个模块，这两个模块在为检测任务而相互协作的同时竞争学习。</p><p id="67cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">表示为R或重建模块的第一模块看起来类似于自动编码器，同时被对立地训练以联合最小化两个损失函数，</p><ol class=""><li id="0a2d" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated">正常输入的重建损失，重建的数据尽可能接近输入。</li><li id="2aec" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">欺骗鉴别器预测其生成的图像是真实图像，即欺骗鉴别器输出类别标签一。</li></ol><p id="ec2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">表示为D或鉴别器的第二模块学习区分原始正常(类标签1)样本和重构样本(类标签0)。</p><p id="9912" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">r学会有效地重构正的正常样本，而对于负的或新的样本，它不能精确地重构输入，因此，对于负的样本，它充当抽取器或非正式的失真器。</p><p id="e55a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在测试阶段，D充当实际的新奇检测器，而R通过充分重构阳性或目标样本以及抽取(或扭曲)任何给定的阴性或新奇样本来提高检测器的性能。</p><h1 id="3db9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论和进一步阅读</h1><p id="721b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在这篇文章中，我们介绍了对抗性学习的一类分类器，首先快速回顾了两个紧密相关的模型结构，自动编码器和GAN，然后介绍了我们将在下一篇文章<a class="ae ka" href="https://www.dlology.com/blog/how-to-do-novelty-detection-in-keras-with-generative-adversarial-network-part-2/" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"/></a>中使用Keras实现的主要模型架构。</p><p id="f5cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的Keras实现很大程度上受作者论文【https://arxiv.org/abs/1802.09088<a class="ae ka" href="https://arxiv.org/abs/1802.09088" rel="noopener ugc nofollow" target="_blank">的影响</a></p><h2 id="fe7b" class="md kc hu bd kd me mf mg kh mh mi mj kl jn mk ml kp jr mm mn kt jv mo mp kx mq dt translated">准备好真正的Keras实现了吗？</h2><h2 id="1fa6" class="md kc hu bd kd me mf mg kh mh mi mj kl jn mk ml kp jr mm mn kt jv mo mp kx mq dt translated">继续下一部分</h2><h2 id="ca05" class="md kc hu bd kd me mf mg kh mh mi mj kl jn mk ml kp jr mm mn kt jv mo mp kx mq dt translated"><a class="ae ka" rel="noopener" href="/@chengweizhang2012/how-to-do-novelty-detection-in-keras-with-generative-adversarial-network-part-2-546d97632f63">如何用生成对抗网络进行Keras中的新颖性检测(下)</a></h2><p id="38bb" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://twitter.com/intent/tweet?url=https%3A//www.dlology.com/blog/how-to-do-novelty-detection-in-keras-with-generative-adversarial-network/&amp;text=How%20to%20do%20Novelty%20Detection%20in%20Keras%20with%20Generative%20Adversarial%20Network%20%28Part%201%29" rel="noopener ugc nofollow" target="_blank">在Twitter上分享</a> <a class="ae ka" href="https://www.facebook.com/sharer/sharer.php?u=https://www.dlology.com/blog/how-to-do-novelty-detection-in-keras-with-generative-adversarial-network/" rel="noopener ugc nofollow" target="_blank">在脸书分享</a></p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="c13b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="my">原载于</em><a class="ae ka" href="https://www.dlology.com/blog/how-to-do-novelty-detection-in-keras-with-generative-adversarial-network/" rel="noopener ugc nofollow" target="_blank"><em class="my">www.dlology.com</em></a><em class="my">。</em></p></div></div>    
</body>
</html>