<html>
<head>
<title>Need faster code? Try Multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">需要更快的代码？尝试多线程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/need-faster-code-try-multithreading-5dc30c83837c?source=collection_archive---------0-----------------------#2018-10-01">https://medium.com/hackernoon/need-faster-code-try-multithreading-5dc30c83837c?source=collection_archive---------0-----------------------#2018-10-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f11309a3358224c464a3b770a75e37ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y9UVar3ATIDrWsVq.jpg"/></div></div></figure><p id="f2da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在程序员的职业生涯中，有时他们会意识到他们的代码只需要运行得更快。无论是创建低延迟API还是解析数十亿个数据点的程序，速度都是一个重要因素。</p><p id="8661" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你的代码运行太慢时，你能做什么？</p><p id="0e04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，编程工具包中有许多工具可以让代码运行得更快。你首先想到的可能是缓存。但是当缓存不是一个选项时呢？</p><p id="9a40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个可行的选择是多线程。为了讨论多线程，讨论什么是进程和线程是很重要的。用最简单的术语来说，你可以把一个进程想象成一个正在执行的程序。</p><p id="0f4e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，在终端中运行<code class="eh ka kb kc kd b">ps aux</code>来查看您的计算机上当前运行的所有进程。所有这些过程都对应于一个程序或应用程序。您正在阅读的web浏览器正在使用一个或多个进程。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ke"><img src="../Images/4a3759d10fbeef517664708866d85172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYDQn1pDxcfLMryMIsLf-g.png"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">Processes running on my computer</figcaption></figure><p id="32ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以将线程视为进程的工作线程。如果过程是老板，那么线程就是忠实的员工。每个进程启动一个线程，但是如果需要的话可以创建更多的线程。</p><p id="8188" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个进程中的所有线程共享相同的堆内存，但包含各自的执行堆栈。这意味着线程可以共享数据，但不能共享函数调用。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kn"><img src="../Images/3d3e9bfdb839da8112555c0fc22bc3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-EBky8iHr3toJJ7u7SzwA.png"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">Credit: <a class="ae ko" href="https://workerholic.github.io" rel="noopener ugc nofollow" target="_blank">https://workerholic.github.io</a></figcaption></figure><p id="d8b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">多线程之所以有用，是因为正在执行的程序可以将任务委托给许多不同的线程。这相当于一个雇主雇佣50名程序员来开发整个SaaS产品，而不仅仅是一个。展示这一点的最好方式是用一个例子。</p><p id="0747" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kp">注意，本文中的所有代码示例都将使用Ruby编写，并将使用</em> <code class="eh ka kb kc kd b"><em class="kp">Thread</em></code> <em class="kp">类来运行新线程。</em></p><p id="5f2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">比方说，你有一个程序需要遍历一系列任务并完成它们。在这个例子中，我们假设每个任务大约需要1秒钟来执行。如果您依靠单线程来执行这个循环，则需要10秒钟才能完成。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="8386" class="kw kx hu kd b fv ky kz l la lb">$ ruby 01_serial_loop.rb</span><span id="df29" class="kw kx hu kd b fv lc kz l la lb">1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10</span><span id="48a5" class="kw kx hu kd b fv lc kz l la lb"><strong class="kd hv">10.02504587173462 seconds to complete.</strong></span></pre><p id="2e71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，如果我们将每个任务分配给不同的工作人员，只需要1秒钟，因为所有的工作人员将同时工作。在Ruby中，这就像创建一个新的<code class="eh ka kb kc kd b">Thread.new</code>实例并传递给它一个块来执行一样简单。每个<code class="eh ka kb kc kd b">Thread.new</code>返回一个线程的新实例。</p><p id="8a23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，仅仅增加新的线程是不够的。程序必须确保这些线程在退出前完成。如果一个程序没有明确地等待线程完成，这个程序就会过早地退出。</p><p id="908b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Ruby中，必须在每个线程实例上调用<code class="eh ka kb kc kd b">join</code>方法，以便每个线程与主线程连接。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="114b" class="kw kx hu kd b fv ky kz l la lb">$ ruby 02_multithread_loop.rb</span><span id="0c95" class="kw kx hu kd b fv lc kz l la lb">5<br/>4<br/>8<br/>6<br/>10<br/>2<br/>1<br/>9<br/>3<br/>7</span><span id="31a1" class="kw kx hu kd b fv lc kz l la lb"><strong class="kd hv">1.0051839351654053 seconds to complete.</strong></span></pre><h1 id="8a81" class="ld kx hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">并发性和并行性</h1><p id="71f8" class="pw-post-body-paragraph jc jd hu je b jf ma jh ji jj mb jl jm jn mc jp jq jr md jt ju jv me jx jy jz hn dt translated">您可能已经从并发示例中注意到了一点，即线程以随机顺序返回。线程结束的顺序不同于它们被启动的顺序。它们是异步的。这是并发性和并行性背后的主要概念。每个线程以自己的速度开始和结束，而不考虑其他线程。</p><p id="7e12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然并发性和并行性不同，但它们是相似的。每个概念之间的区别超出了本文的范围，但是<a class="ae ko" href="https://blog.golang.org/concurrency-is-not-parallelism" rel="noopener ugc nofollow" target="_blank">可以在这里阅读</a>。</p><p id="16cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">需要注意的一点是，由于Ruby语言的限制——特别是<strong class="je hv"> Matz Ruby解释器(MRI) </strong>和<strong class="je hv">全局解释器锁(GIL)</strong>——标准版本的Ruby无法实现真正的并行。然而，它可以很好地处理并发。</p><p id="e227" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kp">注意:MRI在Ruby 1.8之前一直使用。从1.9版本开始，默认的解释器是</em> <a class="ae ko" href="http://www.atdot.net/yarv/" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> YARV </em> </a> <em class="kp">(另一个Ruby VM) </em></p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mf"><img src="../Images/5b20ffcb20d271b128551a946b9147d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdGSLohJPgbb-pBMGSVIPA.png"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">The MRI and GIL prevent parallelism in standard Ruby versions. Credit: <a class="ae ko" href="https://workerholic.github.io" rel="noopener ugc nofollow" target="_blank">https://workerholic.github.io</a></figcaption></figure><h1 id="e8c6" class="ld kx hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">竞赛条件</h1><p id="46b3" class="pw-post-body-paragraph jc jd hu je b jf ma jh ji jj mb jl jm jn mc jp jq jr md jt ju jv me jx jy jz hn dt translated">理解并发性很重要，因为如果不小心的话，它会导致难以修复的错误。多线程中可能出现的一个错误叫做<strong class="je hv">竞争条件</strong>。</p><p id="c4aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最常见的竞争情况是多个线程试图同时访问同一块内存。这种情况的问题是许多操作可能被忽略，或者更糟的是，内存可能被破坏。</p><p id="3037" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看一个例子，在这个例子中，许多线程试图增加一个全局计数器。我们从0开始计数，创建1000个线程，所有的任务都是将计数器加1。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="9ba6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果一切顺利，计数器最终应该是1000。但是请记住，每个单独的线程都是在一个变量或一块内存上操作的。由于在单个状态上发生如此多的不同操作，可能会发生数据损坏。让我们看看在这种情况下会发生什么。</p><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="74ac" class="kw kx hu kd b fv ky kz l la lb">$ ruby 03_global_counter.rb</span><span id="94e2" class="kw kx hu kd b fv lc kz l la lb">count = 1000</span></pre><p id="9e49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">瞧啊。成功了！但是为什么呢？如此多的操作发生在一个州上，肯定会破坏它，对吗？不总是。</p><p id="2c5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，每个线程必须执行的操作非常快，以至于在创建下一个线程时，第一个线程已经完成了。根本没有足够的时间让多个线程互相覆盖。</p><p id="32bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果事实并非如此呢？如果每个线程在处理一个状态之前都必须做一些工作，比如API调用，那会怎么样？我们可以通过让每个线程在递增计数器之前随机休眠一段时间来模拟额外的工作。这将阻止线程立即结束。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="1f82" class="kw kx hu kd b fv ky kz l la lb">$ ruby 04_sleeping_threads.rb</span><span id="01cb" class="kw kx hu kd b fv lc kz l la lb">count = 1000</span></pre><p id="21d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">“嗯，”你可能会想。“看来它还是起作用了。我认为这家伙不知道自己在说什么。”</p><p id="7aed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">别太舒服了。这个例子成功的原因是标准的Ruby运行时不具备并行性。默认情况下，线程一次只会对一个全局变量执行一次。有了标准的Ruby运行时，你就不必太担心竞态条件。</p><p id="62a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果你没有使用标准的Ruby运行时呢？如果您使用一种不同的语言或运行时，比如JRuby，能够实现并行，那会怎么样？如果我们将Ruby版本切换到JRuby，我们可以看到竞争条件的结果。</p><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="f992" class="kw kx hu kd b fv ky kz l la lb"><strong class="kd hv"># Change ruby version to JRuby<br/></strong>$ rbenv local jruby-9.1.10.0<br/>$ ruby 04_sleeping_threads.rb</span><span id="8c6a" class="kw kx hu kd b fv lc kz l la lb">count = 864</span></pre><p id="8d88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">呀。看起来我们的计数器少了136项。这意味着在一个或多个点上，多个线程会相互覆盖。</p><p id="64f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于JRuby运行在Java虚拟机上，并且具有并行性，所以我们的程序容易受到竞争条件的影响。在<a class="ae ko" href="https://en.wikipedia.org/wiki/Thread_safety" rel="noopener ugc nofollow" target="_blank">螺纹安全</a>方面，非常不安全。</p><h1 id="b377" class="ld kx hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">多个全局变量</h1><p id="59dd" class="pw-post-body-paragraph jc jd hu je b jf ma jh ji jj mb jl jm jn mc jp jq jr md jt ju jv me jx jy jz hn dt translated">如果我们在线程中访问多个共享数据，这个漏洞会更加明显。在下面的程序中，我有两个递增的计数器，它们之间的差值被计算出来。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="ea86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果一切顺利，我们应该看到两个最终计数都应该是1000，diff应该等于0，这意味着计数值在任何时候都不会不同步。</p><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="158a" class="kw kx hu kd b fv ky kz l la lb">$ ruby 05_multiple_counters.rb</span><span id="85fb" class="kw kx hu kd b fv lc kz l la lb">count1 : 1000<br/>count2 : 1000<br/>diff : 0</span></pre><p id="afd5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">执行两个增量和计算差值所花费的时间对于多个线程来说太快了，以至于不能互相重叠。正如你可能想象的那样，如果我们增加额外的计算随机性并启用并行性，情况就不是这样了。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="39fa" class="kw kx hu kd b fv ky kz l la lb"><strong class="kd hv">$ rbenv local jruby-9.1.10.0</strong><br/>$ ruby 06_mulitple_values_sleep.rb</span><span id="87ac" class="kw kx hu kd b fv lc kz l la lb">count1 : 890<br/>count2 : 869<br/>diff : 253904</span></pre><p id="765b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，有趣的是，在这种情况下，即使是普通的Ruby运行时也会出错。</p><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="8fc8" class="kw kx hu kd b fv ky kz l la lb"><strong class="kd hv">$ rbenv local 2.4.1</strong><br/>$ ruby 06_mulitple_values_sleep.rb</span><span id="3cbd" class="kw kx hu kd b fv lc kz l la lb">count1 : 1000<br/>count2 : 1000<br/>diff : 339498</span></pre><p id="0dba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然一次只有一个线程可以访问计数器，并且两个计数都以预期的1000计数值结束，但它们并不总是同步的。当一个线程递增<code class="eh ka kb kc kd b">count2</code>时，另一个线程递增<code class="eh ka kb kc kd b">count1</code>导致值不同。这种差异在<code class="eh ka kb kc kd b">diff</code>中被捕捉到了。虽然标准的Ruby MRI防止了许多典型的竞态条件，但它也不能幸免。</p><h1 id="cf7e" class="ld kx hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">防止竞态条件</h1><p id="8855" class="pw-post-body-paragraph jc jd hu je b jf ma jh ji jj mb jl jm jn mc jp jq jr md jt ju jv me jx jy jz hn dt translated">对于那些不熟悉竞态条件的人，你可能想知道如何防止它们。"必须有一种方法使我们的程序具有确定性和线程安全性，对吗？"你可能会问。幸好有。我们可以使用一个叫做<strong class="je hv">互斥对象</strong>的东西。<strong class="je hv">互斥</strong>，简称。</p><p id="01a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">互斥体将确保一次只有一个线程可以访问一块内存。在Ruby中使用互斥体非常容易。您所需要做的就是创建一个互斥类的新实例，并将易受攻击的代码包装在一个<code class="eh ka kb kc kd b">synchronize</code>块中。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="5380" class="kw kx hu kd b fv ky kz l la lb">$ ruby 07_thread_safe.rb</span><span id="4daa" class="kw kx hu kd b fv lc kz l la lb">count1 : 1000<br/>count2 : 1000<br/>diff : 0</span></pre><h1 id="d02e" class="ld kx hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">多线程并不总是最好的解决方案</h1><p id="6055" class="pw-post-body-paragraph jc jd hu je b jf ma jh ji jj mb jl jm jn mc jp jq jr md jt ju jv me jx jy jz hn dt translated">使用互斥体的代价是，由于线程必须等待，你的程序会比没有互斥体时运行得慢。虽然长时间运行的程序比不精确的程序要好，但是使用互斥体可能会违背多线程的目的。程序串行运行可能更好。</p><p id="88a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，如果我们以最后一个例子为例，将线程数减少到100，并计算运行时间，您可以看到多线程和非多线程之间的差异很小。事实上，由于创建线程和线程间上下文切换的开销，多线程可能会更慢。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="27c5" class="kw kx hu kd b fv ky kz l la lb"><strong class="kd hv"># Non-Multithreading Result</strong><br/>$ ruby 08_single_thread_multiple_counter.rb</span><span id="9ea1" class="kw kx hu kd b fv lc kz l la lb">count1 : 100<br/>count2 : 100<br/>diff : 0<br/><strong class="kd hv">96 seconds to finish</strong></span><span id="4a0b" class="kw kx hu kd b fv lc kz l la lb"><strong class="kd hv"># Multithreading Result</strong><br/>$ ruby 09_multi_thread_mutex.rb</span><span id="74f4" class="kw kx hu kd b fv lc kz l la lb">count1 : 100<br/>count2 : 100<br/>diff : 0<br/><strong class="kd hv">99 seconds to finish</strong></span></pre><p id="e0ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于创建100个线程并迫使它们都等待<code class="eh ka kb kc kd b">mutex</code>的开销，多线程程序的性能更差。严重依赖访问全局变量的程序可能不会从多线程中受益。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/76e19194ae38934bbbe493ba54e2d110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSPWbzOPzhZS9zP6dnpzsA.png"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">Too much context switching can lead to poorer performance. Credit: <a class="ae ko" href="https://workerholic.github.io" rel="noopener ugc nofollow" target="_blank">https://workerholic.github.io</a></figcaption></figure><p id="c418" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，必须按特定顺序执行的任务不适合多线程。正如我们在本文前面看到的，线程不会以确定的顺序结束。</p><h1 id="6972" class="ld kx hu bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">理想的用例</h1><p id="4d93" class="pw-post-body-paragraph jc jd hu je b jf ma jh ji jj mb jl jm jn mc jp jq jr md jt ju jv me jx jy jz hn dt translated">虽然多线程可能不适合每种情况，但有许多情况下它是完美的。一个例子是当你的程序需要多次请求获取数据时，无论是从内部服务还是第三方。</p><p id="64df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您正在创建一个API端点，它返回关于用户帐户的数据。回复中是贵公司既不拥有也不管理的数据，比如GitHub Repos。为了获得用户的GitHub信息，程序需要向GitHub发出许多请求。</p><p id="e934" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个API的要求是数据必须准确，延迟必须小于一秒。越快越好。</p><p id="8a84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下面的API示例中，程序从一个文件中提取所有repo名称(模拟对数据库的请求)。然后，该程序遍历每个repo名称，并向GitHub API发出请求，以检索关于它的更多数据。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="5fb4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您所想象的，这会导致用户的响应时间很长。</p><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="1e8d" class="kw kx hu kd b fv ky kz l la lb">$ curl localhost:4567/slow_response</span><span id="96ee" class="kw kx hu kd b fv lc kz l la lb">{<br/> “response”: [<br/> …<br/> ],<br/><strong class="kd hv"> “time”: 7.479549884796143</strong><br/>}</span></pre><p id="c35b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本例中，检索用户数据需要7秒多的时间。这是不能接受的。我们需要将这一时间缩短到一秒钟以下，以便它可以扩展并提供更好的用户体验。</p><p id="6938" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">缩短响应时间的一个可能方法是在数据库中缓存所有回购数据。这种解决方案的问题是回购数据经常变化。标题、观看者数量、星星数量和分叉。这些值都会发生变化，这会使结果不准确。不允许错误的结果。</p><p id="89dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个要考虑的工具是多线程。不是一次向GitHub发出一个API请求，而是为每个请求运行一个单独的线程。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kq kr l"/></div></figure><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="d65e" class="kw kx hu kd b fv ky kz l la lb">$ curl localhost:4567/fast_response</span><span id="e99e" class="kw kx hu kd b fv lc kz l la lb">{<br/> “response”: [<br/> …<br/> ],<br/><strong class="kd hv"> “time”:0.5799121856689453</strong><br/>}</span></pre><p id="11fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过更改3行代码，我们将响应时间从超过7秒降低到不到1秒。通过启用并行性，可以使这段代码的性能更高。</p><pre class="kf kg kh ki fq ks kd kt ku aw kv dt"><span id="1398" class="kw kx hu kd b fv ky kz l la lb"><strong class="kd hv">$ rbenv local jruby-9.1.10.0</strong><br/>$ ruby sinatra_demo_fast_response.rb</span><span id="9a05" class="kw kx hu kd b fv lc kz l la lb">[2018–09–29 11:47:21] INFO WEBrick 1.3.1<br/>[2018–09–29 11:47:21] INFO ruby 2.3.3 (2017–05–25) [java]<br/>== Sinatra (v1.4.8) has taken the stage on 4567 for development with backup from WEBrick</span><span id="117f" class="kw kx hu kd b fv lc kz l la lb"><strong class="kd hv"># In a new terminal tab<br/></strong>$ curl localhost:4567/fast_response</span><span id="ef58" class="kw kx hu kd b fv lc kz l la lb">{<br/> “response”: [<br/> …<br/> ],<br/><strong class="kd hv"> “time”:0.3163459300994873</strong><br/>}</span></pre><p id="12f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了并行技术，响应时间可以缩短到三分之一秒。我们的用户会对这样的表现非常满意。</p></div><div class="ab cl mh mi hc mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hn ho hp hq hr"><p id="148c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望你对多线程有一些新的见解。并发是一种语言无关的工具，非常适合优化您的代码。大多数语言以某种方式支持多线程或多重处理。</p><p id="606c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你觉得这篇文章是有益的或有见地的，请留下一些👏。下一次你发现自己需要创建一个快速的程序时，我希望你考虑多线程作为一个可能的解决方案。</p><p id="986e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ko" rel="noopener" href="/subscribe/@SunnyB"> <em class="kp">订阅我的个人资料</em> </a> <em class="kp">如果你想在我上传新故事时得到通知。</em></p></div></div>    
</body>
</html>