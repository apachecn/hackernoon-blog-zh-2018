<html>
<head>
<title>A crash course on Serverless with AWS — Image resize on-the-fly with Lambda and S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS无服务器速成班——使用Lambda和S3动态调整图像大小</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-crash-course-on-serverless-with-aws-image-resize-on-the-fly-with-lambda-and-s3-850be95d5833?source=collection_archive---------2-----------------------#2018-10-01">https://medium.com/hackernoon/a-crash-course-on-serverless-with-aws-image-resize-on-the-fly-with-lambda-and-s3-850be95d5833?source=collection_archive---------2-----------------------#2018-10-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9351f926546a4c67c2aacf236f706024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXVxlNCjuF_g96DKuqb1ag.jpeg"/></div></div></figure><div class=""/><p id="0840" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自从我开始写代码以来，处理大型图像一直是我的一大苦恼。最近，它开始对页面速度和SEO排名产生巨大影响。如果你的网站的图片优化的很差，它在谷歌灯塔上的得分不会很高。如果评分不好，就上不了谷歌首页。太糟糕了。</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/111f198826182b7d639e1782c8ad9b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*fzU6CjhveJRTm-N3.gif"/></div></figure><h1 id="858c" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="76cc" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我已经构建并开源了一段代码，用一个简单的命令就可以自动创建和部署一个图像大小调整函数和一个S3桶。在这里查看<a class="ae ka" href="https://github.com/adnanrahic/serverless-docker-image-resize" rel="noopener ugc nofollow" target="_blank">的代码</a>。</p><p id="ba8d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果你想跟随并学习如何自己做，继续阅读。</p><h1 id="39a5" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">我们从哪里开始？</h1><p id="3074" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">幸运的是，有一种方法可以毫不费力地解决糟糕的图像优化问题。今天我们将构建一个<a class="ae ka" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>函数来动态调整图像大小。</p><p id="93b5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些图像将被存储在一个<a class="ae ka" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>桶中，一旦被请求，就会从桶中被提供。如果您需要调整大小的版本，您将请求图像并提供高度和宽度。这将触发一个函数。它将获取现有的图像，调整其大小，将其返回到桶中，然后从桶中提供它。</p><p id="be56" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种情况下，对于给定的一组尺寸，将只调整一次图像的大小。对该大小的图像的每个后续请求都将从桶中得到服务。很酷吧？这里有个图，因为谁不爱图。</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lj"><img src="../Images/56f83eda0ecce0864a7e9fd46cfe85b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7PN37QpD2fH7dKVJ.png"/></div></div></figure><p id="fc88" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我已经假设你知道如何使用<a class="ae ka" href="https://serverless.com/framework/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>，并且已经了解了<a class="ae ka" href="https://martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank">无服务器</a>、<a class="ae ka" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae ka" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>的基础知识，所以我将立即切入要点。这是我们将要做的事情的概述。</p><ul class=""><li id="3600" class="lk ll if je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">创建项目结构</li><li id="8279" class="lk ll if je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">创建机密文件</li><li id="2b12" class="lk ll if je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">编写AWS Lambda函数配置</li><li id="257a" class="lk ll if je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">写AWS Lambda函数源代码</li><li id="eb6d" class="lk ll if je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">写入S3存储桶配置</li><li id="784c" class="lk ll if je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">使用Docker部署</li><li id="4c6f" class="lk ll if je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">用<a class="ae ka" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank">仪表板进行测试</a></li></ul><p id="acb5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="ly">注意</em> </strong> <em class="ly">:请安装</em><a class="ae ka" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"><em class="ly">Docker</em></a><em class="ly">和</em> <a class="ae ka" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> <em class="ly"> Docker撰写</em> </a> <em class="ly">后再继续本教程。</em></p><p id="af49" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有趣的是，由于<a class="ae ka" href="https://github.com/lovell/sharp" rel="noopener ugc nofollow" target="_blank"> Sharp </a>，我们需要使用Docker来部署这个服务。这个image-resize模块有二进制文件，需要在运行它的同一操作系统上构建。因为AWS Lambda运行在Amazon Linux上，所以在运行<code class="eh lz ma mb mc b">sls deploy</code>之前，我们需要在Amazon Linux实例上运行<code class="eh lz ma mb mc b">npm install</code>包。</p><p id="c0f9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这些，让我们来建造一些东西。</p><h1 id="7719" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">创建项目结构</h1><p id="0637" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">解释这种复杂结构的最佳方式是用图像。</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div class="fe ff md"><img src="../Images/7783d3b5b69eeb2cc3c6f56c1be15ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/0*DoJ28y9TyCiTldXl.png"/></div></figure><p id="8472" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">绿色的文件夹和蓝色的文件。查看<a class="ae ka" href="https://github.com/adnanrahic/serverless-docker-image-resize" rel="noopener ugc nofollow" target="_blank">回购</a>了解更多信息。</p><h1 id="71fe" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">创建机密文件</h1><p id="afe2" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我们将在<strong class="je ig"> secrets </strong>文件夹中创建一个<code class="eh lz ma mb mc b">secrets.env</code>文件来保存我们的秘密，并在Docker容器启动后将它们注入其中。</p><pre class="kc kd ke kf fq me mc mf mg aw mh dt"><span id="e845" class="mi kh if mc b fv mj mk l ml mm">SLS_KEY=XXX # replace with your IAM User key <br/>SLS_SECRET=YYY # replace with your IAM User secret <br/>STAGE=dev <br/>REGION=us-east-1 <br/>BUCKET=images.yourdomain.com</span></pre><p id="a45b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="ly">注意</em></strong><em class="ly">:</em><code class="eh lz ma mb mc b"><em class="ly">deploy.sh</em></code><em class="ly">脚本将创建一个二级</em> <code class="eh lz ma mb mc b"><em class="ly">secrets.json</em></code> <em class="ly">文件，仅保存我们的API网关端点的域名。</em></p><h1 id="0f3d" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">编写AWS Lambda函数配置</h1><p id="522e" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">打开<strong class="je ig">功能</strong>文件夹，开始创建<code class="eh lz ma mb mc b">package.json</code>文件。把这个贴进去。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="3686" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不需要运行任何安装，因为我们需要先运行Docker容器。请注意，我们正在添加一个跟踪插件来启用<a class="ae ka" href="https://aws.amazon.com/xray/" rel="noopener ugc nofollow" target="_blank"> X射线</a>，因为它太棒了。</p><p id="baec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续，让我们创建<code class="eh lz ma mb mc b">serverless.yml</code>文件来配置我们的功能。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="b042" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如你所见，我们从<code class="eh lz ma mb mc b">env</code>中获取了一堆值，并允许该函数访问我们指定的<code class="eh lz ma mb mc b">BUCKET</code>和一些X射线遥测数据。</p><h1 id="f8e0" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">写AWS Lambda函数源代码</h1><p id="39bf" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">现在只剩下代码了。这是我们要做的。因为图像可能会变得非常大，我们不想冒险将几兆字节加载到lambda函数的内存中，所以我将向您展示如何使用<a class="ae ka" href="https://nodejs.org/dist/latest-v8.x/docs/api/stream.html" rel="noopener ugc nofollow" target="_blank"> Node.js streams </a>从S3流中读取图像，将其通过管道传输到Sharp，然后再一次作为流写回S3。</p><p id="91aa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">准备好了吗？让我们分两步做。首先，定义创建流所需的助手函数，然后创建lambda将调用的处理函数本身。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="f3d0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们为我们的流定义常量和构造函数。值得注意的是，S3并没有一个默认的用流写入存储的方法。所以你需要创建一个。使用<code class="eh lz ma mb mc b">stream.PassThrough()</code>助手是可行的。上面的抽象将用一个流写数据，并在完成后解析一个承诺。</p><p id="7965" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续，让我们检查一下处理程序。就在上面的代码下面，把这个粘贴进去。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="131d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查询字符串参数将类似于这个<code class="eh lz ma mb mc b">/1280x720/image.jpg</code>。这意味着我们通过使用正则表达式匹配从参数中获取图像尺寸。<code class="eh lz ma mb mc b">newKey</code>值设置为尺寸，后跟一个<code class="eh lz ma mb mc b">/</code>和图像的原始名称。这将创建一个名为<code class="eh lz ma mb mc b">1280x720</code>的新文件夹，里面有图片<code class="eh lz ma mb mc b">image.jpg</code>。相当酷。</p><p id="54d9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们触发了流并等待解决的承诺，我们就可以注销数据并返回一个301重定向到桶中图像的位置。请注意，我们将在下一段中在我们的桶上启用静态网站托管。</p><h1 id="d08f" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">写入S3存储桶配置</h1><p id="a2f1" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">bucket配置主要由默认的<a class="ae ka" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>模板组成，所以如果你有点生疏，我建议你稍微复习一下。但是，它的要点很容易理解。打开<strong class="je ig">桶</strong>文件夹，创建一个<code class="eh lz ma mb mc b">serverless.yml</code>文件。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="8f6b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们在我们的桶上启用静态网站托管选项，它将像任何网站一样运行。这让我们可以从它提供图像，并利用404错误重定向规则。</p><p id="4936" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果没有找到图像，桶将触发404，它重定向到我们的lambda函数。然后将原始图像的大小调整到请求的尺寸，并将其放回桶中请求它的确切路径。</p><p id="5d37" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像魔法一样！</p><h1 id="3dad" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">使用Docker部署</h1><p id="3e8f" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">有趣的部分来了！我们将创建一个<code class="eh lz ma mb mc b">Dockerfile</code>和<code class="eh lz ma mb mc b">docker-compose.yml</code>文件来创建我们的Amazon Linux容器，并用<code class="eh lz ma mb mc b">.env</code>值加载它。那很简单。困难的部分将是编写bash脚本来运行所有命令并部署我们的函数和bucket。</p><p id="4daa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从<code class="eh lz ma mb mc b">Dockerfile</code>开始，这里是你需要添加的。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="4205" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为Amazon Linux相当基础，所以我们需要一开始就安装gcc和Node.js。那么它就像你见过的任何Dockerfile文件一样简单。全局安装无服务器框架，复制源代码，在<strong class="je ig"> functions </strong>目录下安装npm模块，运行<code class="eh lz ma mb mc b">deploy.sh</code>脚本。</p><p id="6107" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lz ma mb mc b">docker-compose.yml</code>文件实际上仅用于加载<code class="eh lz ma mb mc b">.env</code>值。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="91f2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。码头部分完成了。让我们写一些狂欢。</p><p id="43a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从简单开始，我们将定义初始变量，配置我们的无服务器安装并部署我们的功能。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="ce1a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们部署了它，我们需要获取API网关端点的域名，并将其放入一个<code class="eh lz ma mb mc b">secrets.json</code>文件中，该文件将从<strong class="je ig"> bucket </strong>目录加载到我们的<code class="eh lz ma mb mc b">serverless.yml</code>文件中。为了做到这一点，我只是做了一些正则表达式的魔术。把这个加在你<code class="eh lz ma mb mc b">deploy.sh</code>的底部。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="188a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在您在<strong class="je ig"> secrets </strong>目录中有了一个<code class="eh lz ma mb mc b">secrets.json</code>文件。剩下的工作就是运行铲斗部署。将这个最后的片段粘贴到<code class="eh lz ma mb mc b">deploy.sh</code>脚本的底部。</p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="c2ce" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们做到了！编码部分做好了。你相信我吗？我们现在只需要运行一个命令。在项目的根目录下打开一个终端窗口并运行:</p><pre class="kc kd ke kf fq me mc mf mg aw mh dt"><span id="91e9" class="mi kh if mc b fv mj mk l ml mm">$ docker-compose up --build</span></pre><p id="ba06" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让它发挥它的魔力，你会看到一切都是自动创造的！请注意，终端将向您显示用于访问图像的bucket端点。</p><h1 id="9672" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">用Dashbird测试</h1><p id="8387" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">最后一步是检查是否一切正常。让我们上传一张图片到桶中，这样我们就有东西可以调整大小了。去找一张你喜欢并想调整大小的图片，或者就拿这张<a class="ae ka" href="https://github.com/adnanrahic/cdn/raw/master/image-resize-on-the-fly/the-earth.jpg" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c7ba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它相当大，大约6 MB。下面是您想要运行来上传它的命令。</p><pre class="kc kd ke kf fq me mc mf mg aw mh dt"><span id="2456" class="mi kh if mc b fv mj mk l ml mm">$ aws s3 cp --acl public-read IMAGE s3://BUCKET</span></pre><p id="1d03" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，如果您的bucket名称是<strong class="je ig"> images </strong>并且您的映像名称是<strong class="je ig">the-earth.jpg</strong>，那么如果您从映像所在的目录运行该命令，它应该是这样的。</p><pre class="kc kd ke kf fq me mc mf mg aw mh dt"><span id="f2a2" class="mi kh if mc b fv mj mk l ml mm">$ aws s3 cp --acl public-read the-earth.jpg s3://images</span></pre><p id="b55f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，您需要在您的机器上安装<a class="ae ka" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>，或者通过AWS控制台上传图像。</p><p id="7fa2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，尝试通过桶请求图像。在你的浏览器中输入S3桶网址。</p><pre class="kc kd ke kf fq me mc mf mg aw mh dt"><span id="cfee" class="mi kh if mc b fv mj mk l ml mm"><a class="ae ka" href="http://BUCKET.s3-website.REGION.amazonaws.com/the-earth.jpg" rel="noopener ugc nofollow" target="_blank">http://BUCKET.s3-website.REGION.amazonaws.com/the-earth.jpg</a></span></pre><p id="449b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您将看到原始图像出现。但是，现在向URL添加维度。</p><pre class="kc kd ke kf fq me mc mf mg aw mh dt"><span id="f43e" class="mi kh if mc b fv mj mk l ml mm"><a class="ae ka" href="http://BUCKET.s3-website.REGION.amazonaws.com/400x400/the-earth.jpg" rel="noopener ugc nofollow" target="_blank">http://BUCKET.s3-website.REGION.amazonaws.com/400x400/the-earth.jpg</a></span></pre><p id="a225" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将触发resize函数并创建一个400x400像素版本的图像。创建需要几百毫秒，一旦完成，浏览器会将你重定向到新创建的图像。当您尝试刷新URL时，您会看到它现在正在获取新图像，而没有调用resize函数。</p><p id="7cb2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们检查一下<a class="ae ka" href="https://dashbird.io/features/" rel="noopener ugc nofollow" target="_blank">仪表盘</a>的日志，确保引擎盖下一切正常。</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mp"><img src="../Images/86aa539cabb718be9809d8132c7e03b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pqK5xrVes_caYqjc.gif"/></div></div></figure><p id="eab2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看起来不错，但是当我第一次尝试设置这个功能时，我犯了一些初学者的错误。其中之一是忘记在使用模块之前需要它。幸运的是，我立即得到了一个警报，解释了什么是错的。<a class="ae ka" href="https://dashbird.io/docs/user-guide/alerting/" rel="noopener ugc nofollow" target="_blank">懈怠警报</a>是救命稻草。</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mq"><img src="../Images/125edb646235aecaa79cf63906b5400e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9aw0fjzEjE9VfH1Y.png"/></div></div></figure><p id="23ea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我解决这个问题的方法是使用<a class="ae ka" href="https://dashbird.io/docs/user-guide/debugging/#live-tailing" rel="noopener ugc nofollow" target="_blank">实时跟踪</a>功能。它让我在几秒钟的延迟后检查调用日志，这样我就可以调试这个问题。相当酷。</p><figure class="kc kd ke kf fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mp"><img src="../Images/f56a7a79c35f669ad6409f3718a8a05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wnzQr5AE07vKrzfb.gif"/></div></div></figure><h1 id="dd4a" class="kg kh if bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">包扎</h1><p id="e14a" class="pw-post-body-paragraph jc jd if je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">在结束这个简短的<em class="ly">show dev</em>会议之前，我想指出使用无服务器作为助手来支持您现有的基础设施是不可思议的。它与语言无关，并且易于使用。</p><p id="0d3c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://dashbird.io/team/" rel="noopener ugc nofollow" target="_blank">我们在Dashbird </a>使用容器集群作为我们的核心功能，这些核心功能与我们的数据库有大量交互，同时将所有其他功能卸载到lambda函数、队列、流和AWS上的其他无服务器服务。</p><p id="31e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，<a class="ae ka" href="https://github.com/adnanrahic/serverless-docker-image-resize" rel="noopener ugc nofollow" target="_blank">这里是回购</a>再一次，如果你想让更多人在GitHub上看到它，给它一颗星。如果您按照那里的说明操作，您将能够让这个映像即时调整大小微服务立即启动并运行。</p><p id="9cd9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想阅读我以前的一些无服务器思考，请前往<a class="ae ka" href="https://dev.to/adnanrahic" rel="noopener ugc nofollow" target="_blank">我的简介</a>或<a class="ae ka" href="https://upscri.be/b6f3d5/" rel="noopener ugc nofollow" target="_blank">加入我的无服务器时事通讯！</a></p><figure class="kc kd ke kf fq hw"><div class="bz el l di"><div class="mr mo l"/></div></figure><p id="f5c0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">写这段开源代码片段让我兴奋不已。写文章也没那么差！希望你们喜欢读它，就像我喜欢写它一样。如果你喜欢它，拍一下那个小独角兽，这样dev.to上会有更多的人看到这篇文章。直到下次，保持好奇，玩得开心。</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="665c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ly">原载于</em> <a class="ae ka" href="https://dev.to/adnanrahic/a-crash-course-on-serverless-with-aws---image-resize-on-the-fly-with-lambda-and-s3-4foo" rel="noopener ugc nofollow" target="_blank"> <em class="ly"> dev.to </em> </a> <em class="ly">。</em></p></div></div>    
</body>
</html>