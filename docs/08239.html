<html>
<head>
<title>Building an Excellent Mock Server in Swift using Vapor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vapor在Swift中构建一个优秀的模拟服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-an-excellent-mock-server-in-swift-with-vapor-7e25aaa985e6?source=collection_archive---------5-----------------------#2018-10-01">https://medium.com/hackernoon/building-an-excellent-mock-server-in-swift-with-vapor-7e25aaa985e6?source=collection_archive---------5-----------------------#2018-10-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e162" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">Swift，它不再仅仅适用于移动设备…</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/8fb4842915dc27b9b7f5e033f05d44bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfvN4lb5vt2BvGXkku5jag.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank">vapor</a>.<a class="ae jz" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank">codes</a></figcaption></figure><h2 id="b3aa" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">什么是蒸汽？💧</h2><p id="9710" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated"><a class="ae jz" href="https://vapor.codes" rel="noopener ugc nofollow" target="_blank"> Vapor </a>是用Swift编写的非阻塞、事件驱动的服务器架构，构建在苹果<a class="ae jz" href="https://github.com/apple/swift-nio/" rel="noopener ugc nofollow" target="_blank"> SwiftNIO </a> <a class="ae jz" href="https://hackernoon.com/tagged/framework" rel="noopener ugc nofollow" target="_blank">框架</a>之上。它很容易上手，有一个庞大且不断增长的社区，并且是为性能和易用性而构建的。挺甜蜜的。</p><p id="d138" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">在新一批服务器端Swift框架中，Vapor并不孤单。还有IBM的<a class="ae jz" href="https://www.kitura.io/" rel="noopener ugc nofollow" target="_blank"> Kitura </a>、<a class="ae jz" href="https://github.com/PerfectlySoft/Perfect" rel="noopener ugc nofollow" target="_blank"> Perfect </a>和<a class="ae jz" href="https://github.com/Zewo/Zewo" rel="noopener ugc nofollow" target="_blank"> Zewo </a>。这些都有其利弊，我不太敢说目前在这个领域有一个明显的领先者。将来我可能会更多地关注那些其他的框架，但是现在我将把重点放在<a class="ae jz" href="https://hackernoon.com/tagged/vapor" rel="noopener ugc nofollow" target="_blank"> Vapor </a>上。</p><h2 id="2d5f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">正在设置</h2><p id="5b82" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">如今，在为项目选择技术时，易用性可能是一个主要的决定因素。Vapor团队似乎认识到了这一点，因为设置起来很容易。他们甚至创办了Vapor大学，作为管理Vapor教程的仓库。</p><p id="40d3" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">我的安装说明是基于macOS的，但是你也可以跟着使用Ubuntu !</p><ol class=""><li id="1e3f" class="lw lx hu la b lb lr le ls kl ly kp lz kt ma lq mb mc md me dt translated">确保<a class="ae jz" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>是最新的。你可以在App Store里这样做。</li><li id="fcc5" class="lw lx hu la b lb mf le mg kl mh kp mi kt mj lq mb mc md me dt translated">检查您的swift版本(至少需要4.1.x) <br/> <code class="eh mk ml mm mn b">$ swift — version</code></li><li id="7890" class="lw lx hu la b lb mf le mg kl mh kp mi kt mj lq mb mc md me dt translated">如果您还没有<br/>T1，请安装<a class="ae jz" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> brew </a></li><li id="a277" class="lw lx hu la b lb mf le mg kl mh kp mi kt mj lq mb mc md me dt translated">安装<a class="ae jz" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank">蒸汽</a>使用brew <br/> <code class="eh mk ml mm mn b">$ brew tap vapor/homebrew-tap</code> <br/> <code class="eh mk ml mm mn b">$ brew update</code> <br/> <code class="eh mk ml mm mn b">$ brew install vapor</code></li><li id="ba67" class="lw lx hu la b lb mf le mg kl mh kp mi kt mj lq mb mc md me dt translated">检查你的蒸汽安装<br/>T3】</li><li id="8797" class="lw lx hu la b lb mf le mg kl mh kp mi kt mj lq mb mc md me dt translated">为您的项目创建新目录。我已经给我的工作服取名为<em class="mo"/>。<br/> <code class="eh mk ml mm mn b">$ mkdir smock</code></li><li id="691e" class="lw lx hu la b lb mf le mg kl mh kp mi kt mj lq mb mc md me dt translated">移动到新目录并创建一个新的vapor项目。我在这里传递了<code class="eh mk ml mm mn b">—-api</code>标志，因为我们只关心为本教程构建一个后端服务器。<br/> <code class="eh mk ml mm mn b">$ cd smock</code> <br/> <code class="eh mk ml mm mn b">$ vapor new smock --api</code></li></ol><div class="jk jl jm jn fq ab cb"><figure class="mp jo mq mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/e89ecf6a122fbc5c48388e6c5ba8fbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*M6y27HMr1_M9-lBENQ6yYQ.gif"/></div></figure><figure class="mp jo mq mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/47fbf47e37c0881060ae8b32e39263e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*pd9d-PzuD7PI8OV7VeAb4A.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek mv di mw mx">gifs 👌</figcaption></figure></div><h2 id="a3c5" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">什么是模拟服务器？</h2><p id="dae5" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">在解释什么是模拟服务器之前，我们将从什么是模拟服务器以及为什么使用模拟服务器开始。我还将避免深入研究mock、stub和fake之间的区别。只知道他们都<em class="mo">差不多</em>一样。尽管已经有很多关于这个主题的文章(例如<a class="ae jz" href="https://martinfowler.com/articles/mocksArentStubs.html" rel="noopener ugc nofollow" target="_blank"/>)但是在专业人士中仍然很难达成共识。</p><p id="e62a" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">一般来说，一个mock，在某种程度上是一个stub/fake，只是你为了测试需要替换的代码的一部分。我喜欢的区别是一个<em class="mo">模拟</em>本身没有预定义的行为。</p><p id="c612" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">我将在这里分享的模拟服务器旨在充当测试应用程序的任何HTTP或HTTPS操作的替身。</p><p id="6541" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">我认为像这样的服务器在组件或集成级别的测试中工作得很好，在那里您可能有一个或多个不同的服务，您的代码依赖于这些服务，而在测试时向这些服务发出请求是不实际的。虽然使用存根可以获得类似的结果，但是使用模拟服务器将允许您充分使用您可能正在使用的任何HTTP客户端代码。</p><h2 id="3f1e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">代码</h2><p id="ee82" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">方便的是，当你创建一个新的vapor API服务器时，vapor会在你的新应用中创建一个简单的<em class="mo"> hello，world </em>和<em class="mo"> todo </em>应用。虽然我们最终会删除大部分代码，但是看看如何使用vapor构造一个简单的MVC还是很有帮助的。由于这个示例应用程序也经历了引导SQLite数据库的麻烦，我们将继续使用它来存储我们的模拟响应。在正常情况下，我会建议将它们作为字典存储在内存中，但是既然数据库已经连接好了，我们也可以使用它。</p><p id="740e" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">模拟响应模型</strong></p><p id="660e" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv"> <em class="mo">模拟响应</em> </strong>将是我们在模拟服务器中处理的主要对象类型。这个类将扩展SQLiteModel类，它将允许我们使用方便的内置方法来存储和检索记录。</p><p id="8388" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv"> <em class="mo"> MockResponse </em> </strong>将包括几个属性，包括唯一ID、相关路由、http方法、响应代码、自定义头，最后是有效载荷。</p><p id="1e97" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">因为这是一个通用的模拟服务器，所以它应该能够支持各种不同的有效负载格式。Swift使用名为<a class="ae jz" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank"><strong class="la hv"><em class="mo">Codable</em></strong></a>的协议对JSON进行编码/解码。不幸的是，<strong class="la hv"> <em class="mo"> Codable </em> </strong>不支持动态字典结构，所以我求助于一个名为<a class="ae jz" href="https://github.com/yonaskolb/Codability" rel="noopener ugc nofollow" target="_blank"><strong class="la hv"><em class="mo">Codability</em></strong></a>的库，它提供了一个名为<strong class="la hv"> <em class="mo"> AnyCodable </em> </strong>的类，这将允许任意字典结构符合<strong class="la hv"> <em class="mo"> Codable </em> </strong>协议，而不必事先定义。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="d33b" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">模拟控制器</strong></p><p id="d29c" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv"> <em class="mo">模拟控制器</em> </strong>将在我们的应用程序中充当控制器。为简单起见，它缺乏更新现有模拟记录的能力，只处理记录的创建、删除、列表，以及最重要的检索和响应格式化。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="dd13" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">路由器</strong></p><p id="64b7" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><em class="mo"> routes.swift </em>处理vapor app内的路由，并扩展Vapor <strong class="la hv"> <em class="mo"> Router </em> </strong>类。</p><p id="fe03" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><em class="mo"> router.swift </em>包括用于模拟创建、列表和删除的静态路由，以及支持您最终可能添加的任何模拟端点的动态路由。为了完全支持任何url路径，我需要依赖于<strong class="la hv"><em class="mo">path component . catchall</em></strong>，或者只是“<strong class="la hv"> <em class="mo"> all </em> </strong>”，因为它可以被访问。这与标准的vapor路由有点不同，它实际上是作为一个通用的请求处理器，这意味着一些正常的路由支持范例是不可用的，比如参数处理。</p><p id="646a" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">我不建议将<strong class="la hv"> <em class="mo"> all </em> </strong>参数用于任何类型的生产服务。这只是将你自己暴露给潜在的可用性和安全性问题。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="939b" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated"><strong class="la hv">响应映射器</strong></p><p id="3518" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">我最终编写了一个新类来包含我的实用程序方法，这样我就不需要弄乱我的模型或控制器类。这些<strong class="la hv"> <em class="mo"> ResponseMapper </em> </strong>函数通常用于通过解密<strong class="la hv"> <em class="mo"> MockResponse </em> </strong>对象上的<strong class="la hv"><em class="mo">any codable</em></strong>payload属性来准备模拟响应，并使用这些细节来生成正确的响应体和头。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="my mz l"/></div></figure><h2 id="c54b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">运行服务器</h2><p id="d8c5" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">您可以通过运行以下命令从命令行构建并运行vapor应用程序。</p><pre class="jk jl jm jn fq na mn nb nc aw nd dt"><span id="4923" class="ka kb hu mn b fv ne nf l ng nh">$ vapor build &amp;&amp; vapor run</span></pre><p id="8ec3" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">您也可以在XCode中打开应用程序并在那里运行。</p><pre class="jk jl jm jn fq na mn nb nc aw nd dt"><span id="2566" class="ka kb hu mn b fv ne nf l ng nh">$ vapor xcode</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ni"><img src="../Images/28ce66361dada49c5ff98419179a5b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*drNmJElWIP-pgZUE-x5-Zg.gif"/></div></div></figure><h2 id="42e3" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">外卖</h2><p id="3441" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">开始使用Vapor 3真是轻而易举。虽然我还没有检查它的竞争对手，如果你的目标是建立一个简单的MVC应用程序，我会给它一个机会。</p><p id="aeab" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">在这个项目中，我遇到的唯一问题是找到准确的文档(自Vapor 2以来有些事情发生了变化，文档似乎不太完整),了解更多关于Swift的<strong class="la hv"> <em class="mo">可编码</em> </strong>协议，并使用<strong class="la hv"> <em class="mo">可编码</em> </strong>来符合它。</p><p id="b15c" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">总的来说，我会推荐Vapor，并期待将来更多地使用它。</p><p id="3c9b" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">你可以在这里找到我的完整代码<a class="ae jz" href="https://github.com/beatsbears/smock" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nj mz l"/></div></figure></div></div>    
</body>
</html>