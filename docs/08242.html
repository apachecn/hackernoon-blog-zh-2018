<html>
<head>
<title>How We’re Designing a Better Virtual Machine than Ethereum and EOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何设计比以太坊和EOS更好的虚拟机</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-were-designing-a-better-virtual-machine-than-ethereum-and-eos-7b60ba62fc5a?source=collection_archive---------8-----------------------#2018-10-01">https://medium.com/hackernoon/how-were-designing-a-better-virtual-machine-than-ethereum-and-eos-7b60ba62fc5a?source=collection_archive---------8-----------------------#2018-10-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7134" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">作者李海锋— </strong> <a class="ae jp" href="https://iost.io/" rel="noopener ugc nofollow" target="_blank"> IOST </a>高级工程师</p><p id="bb79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">前腾讯高级工程师，成功企业家。负责领导腾讯新闻和田甜快报的重组，实现了超过1.5亿的日访问量。IOST虚拟机的首席工程师。</em></p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="4ec1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有<a class="ae jp" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>开发者都认识到<strong class="it hv">虚拟机设计</strong>和性能——以及智能合约功能——对于成功采用主流DApp至关重要。因此，这些核心功能的实施已成为主要公共区块链网络之间竞争和差异化的主要焦点。正是这些实现可能会决定哪个<a class="ae jp" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>会成功，并最终赢得现实世界的采用和用户增长。</p><p id="8296" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周<strong class="it hv"> IOST </strong>向公众发布了我们测试网络的第二次迭代——<a class="ae jp" rel="noopener" href="/p/c75dd7c91342">珠穆朗玛峰v1.0 </a>。除了支持使用JavaScript的智能合约编程、智能联系域名系统(DNS)和多版本并发控制(MVCC)之外，此次更新还包括部署我们基于V8引擎的新虚拟机。</p><p id="8b9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下面的技术文章中，我对以太坊和EOS的虚拟机开发进行了分析和评论，并概述了IOST的实施和设计选择，这些实施和设计选择专门解决了我们竞争对手网络面临的几个问题。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><h1 id="7678" class="jy jz hu bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">以太坊虚拟机(EVM)</h1><p id="e028" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated"><strong class="it hv">以太坊</strong>虚拟机(EVM)是一个“准图灵完全”的256位虚拟机，是以太坊网络最重要和不可或缺的组件之一。</p><p id="39c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着EVM智能合约开发的逐步完善，网络上推出的DApp应用程序也越来越复杂，例如最近流行的Fomo3D游戏。</p><p id="c387" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，随着这种发展，有几个障碍和问题限制了以太坊DApp的发展，最终阻碍了该网络的功能和长期潜力。</p><h2 id="d29b" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak">首先，以太坊虚拟机(EVM)不是图灵完全的</strong></h2><p id="04b9" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">目前有一种普遍的误解，认为以太坊虚拟机是图灵完全的，然而事实并非如此。</p><p id="340c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">图灵完备性意味着任何可计算的问题都可以被解决。编程语言或虚拟机的本质是图灵机。如果一种编程语言或虚拟机是图灵完备的，就意味着它能做图灵能做的所有事情，也就是说它能无一例外地解决所有的计算问题。</p><p id="869f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在以太坊虚拟机的设计中，由于指令的计算受到gas的约束，这就限制了可以完成的计算数量。这是图灵不完全的一个常见原因，因为循环、递归或计算边界会导致程序终止，所以在EVM上运行的应用程序会受到许多限制，从而使EVM不是图灵完全的。</p><h2 id="b4e2" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak">其次，EVM的设计不合理</strong></h2><p id="c468" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">随着使用智能合约的DApps的开发增加，EVM的原始设计的一些缺陷逐渐显现，其中一些导致了严重的安全问题。在以太坊虚拟机上，我们认为在设计和安全级别上存在以下问题:</p><h2 id="f8de" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> 1。智能合同设计级别</strong></h2><ul class=""><li id="9946" class="lp lq hu it b iu kw iy kx jc lr jg ls jk lt jo lu lv lw lx dt translated"><strong class="it hv"> EVM缺乏完整的标准库支持。</strong>即使是最基本的字符串类型支持，在EVM也是很难的，比如字符串拼接、剪切、搜索等——都需要开发者自己实现。同时，自实现的类库在时间和空间复杂度上可能过高，导致消耗大量不必要的气体。或者，开发人员可以从开源项目本身借用相关的类库代码，但这将再次引入更多的安全问题，并增加合同代码审计的复杂性，这将使该过程非常低效。</li><li id="26f3" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">DApps很难调试和测试。除了抛出OfGas异常，EVM不会向开发者返回任何信息。无法打印日志、制作断点、单步调试。虽然事件机制可以部分改善问题，但是事件机制本身的设计决定了它并不是一个优雅易用的调试工具。</li><li id="0f74" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><strong class="it hv">不支持浮点数</strong>。以太坊以卫为最小单位。Wei只有整数，不支持其他粒度度量。这种设计产生了由浮点数的引入引起的精度问题。为了表示一个ETH变量，变量后面会有大量的零，使得代码维护异常复杂。同时不可否认的是，浮点数在某些场景下还是有很大价值的，不能完全抛弃。</li><li id="c929" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">合同不能升级。合同升级是智能合同开发中的一项强烈要求。这是每个合同开发者必须为他们的项目考虑的问题。合同升级可以为现有部署实施安全补丁，并扩展其可用性、功能等。EVM完全不支持升级，这意味着开发商只能通过签订新合同来解决这个问题，这既费时又费钱。</li></ul><h2 id="acba" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> 2。智能合同安全级别</strong></h2><ul class=""><li id="293c" class="lp lq hu it b iu kw iy kx jc lr jg ls jk lt jo lu lv lw lx dt translated"><strong class="it hv">溢出攻击的忧虑。</strong>默认情况下不使用EVM的safeMath库。例如，当开发人员计算实度uint256时，如果最终结果大于uint256的最大值，溢出将被更改为一个较小的数字，从而产生溢出漏洞。BEC、SMT等令牌都遭受过溢出攻击，带来了极其严重的后果。BEC的溢出漏洞示例如下:</li></ul><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="1792" class="lb jz hu mi b fv mm mn l mo mp">function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {<br/> uint cnt = _receivers.length;<br/> uint256 amount = uint256(cnt) * _value; // overflow occurred here<br/> require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);<br/> require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);   <br/>// require is always established after overflow, generating a vulnerability<br/> <br/> balances[msg.sender] = balances[msg.sender].sub(amount);<br/> for (uint i = 0; i &lt; cnt; i++) {<br/> balances[_receivers[i]] = balances[_receivers[i]].add(_value);<br/> Transfer(msg.sender, _receivers[i], _value);<br/> }<br/> return true;<br/>}</span></pre><ul class=""><li id="b785" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated"><strong class="it hv">再入攻击。</strong>solidity的一大特点是可以调用其他外部契约，但是当你发送ETH到外部地址或者调用外部契约时，需要提交外部调用。如果外部地址是恶意契约，攻击者可以向回退函数添加恶意代码。当这种传输发生时，回退函数被调用来执行恶意代码。恶意代码执行调用约定的易受攻击的函数，导致传输被重新提交。最严重的重入攻击发生在以太坊早期，即众所周知的DAO漏洞。以下合同段具体演示了重入攻击:</li></ul><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="c85d" class="lb jz hu mi b fv mm mn l mo mp">contract weakContract {<br/> mapping (address =&gt; uint) public balances;<br/> function withdraw() {<br/>// Transfer the caller's balance out and set the caller's balance map to 0<br/> //As long as the un-executed balance map is set to 0, you can always call msg.sender to transfer funds, and reenter here.<br/> if (!msg.sender.call.value(balances[msg.sender])()) {<br/> throw;<br/> }<br/> balances[msg.sender] = 0;<br/> }<br/>}<br/>contract attack{<br/> weakContract public weak;<br/>// This is a fallback function. It will be triggered when an external call is transferred. It will always trigger the withdraw method of weak Contract to perform a re-entrant attack.<br/> function () payable {<br/> if (weak.balance &gt;= msg.value) {<br/> weak.withdraw();<br/> }<br/> }<br/>}</span></pre><ul class=""><li id="e24e" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated"><strong class="it hv">意外的功能执行。</strong> EVM没有严格检查函数调用，如果契约地址作为传入参数是可控的，可能会导致如下意外行为:</li></ul><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="08cf" class="lb jz hu mi b fv mm mn l mo mp">contract A {<br/> function withdraw(uint) returns (uint);<br/>}<br/>// When executing contract B, it will only check if contract A has a withdraw method, and if so, the contract will be called normally.<br/>// If the transferred parameter does not have the withdraw method, A's Fallback function will not be called, resulting in unexpected behavior<br/>contract B {<br/> function put(A a){ a.withdraw(42);<br/>}</span></pre><p id="390d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总之，EVM在设计和安全方面有几个问题。尽管EVM团队开发了一种新的合同开发语言——Vyper——但它仍处于试验阶段，目前还不能使用。目前，当以太坊被大规模使用时，这些安全和设计问题的积累最终将导致网络及其用户面临严重的漏洞。</p><h1 id="c060" class="jy jz hu bd ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv dt translated">EOS虚拟机</h1><p id="b37e" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated"><strong class="it hv"> EOS </strong>是最近推出的另一款备受瞩目的区块链应用，紧随以太坊的脚步。它有自己的一套基于WebAssembly的智能合约引擎。然而，EOS的合同开发存在几个明显的问题:</p><ul class=""><li id="a1fe" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated">账户系统不容易进入。 EOS需要一个已有的账户来创建一个新的账户，只有在创建账户之后，才可以签发合同。要求朋友或第三方提供EOS帐户是一个糟糕的解决方案，并且会对该网络的可访问性造成障碍。要创建一个没有推荐的帐户，您需要首先购买RAM，这又是一个财务障碍。创建账户后，需要以EOS为赌注，换取在EOS网络上运行的CPU使用时间和网络带宽。对于潜在的开发者来说，这些需求过于复杂和繁琐。</li><li id="6b6d" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><strong class="it hv">公羊很贵。</strong>与带宽和CPU不同，EOS网络上的RAM没有固定的汇率。开发人员暴露于RAM和EOS之间的汇率风险，并且通常不会收到他们下注的相同数量的代币。这也造成了RAM“交易”的问题，为投机创造了机会，这反过来又消除了开发人员对成本的可预测性。</li><li id="0603" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><strong class="it hv">发展中的困难。</strong>使用C++作为契约语言，大大增加了开发者社区契约开发的壁垒。C++本身极其复杂，需要调用EOS的C++ API来完成智能合约开发。因此，在EOS网络上开发Dapp所需的技能和知识非常广泛，导致能够在该平台上进行开发的开发人员数量不断减少。</li></ul><p id="9b4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">面对所有这些问题，EOS智能合约开发对开发人员来说不是很有吸引力，我们已经看到这是开发人员放弃EOS用于其他项目的原因之一。</p><h1 id="0487" class="jy jz hu bd ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv dt translated">IOST虚拟机</h1><p id="4eee" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">在<strong class="it hv"> IOST </strong>，我们相信一个成功的虚拟机必须为开发者提供易用性，确保强大的安全性，以及实现优雅的架构设计。在这方面，我们旨在解决EVM和EOS中目前存在的不合理设计和安全问题。在比较了EVM、EOS、C Lua、V8等虚拟机的优缺点后。，并且基于V8在NodeJs和Chrome上的优异表现，我们最终决定基于V8打造IOST虚拟机。</p><h2 id="2893" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> IOST VMManager系统架构</strong></h2><p id="9c29" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">V8VM架构的核心是VMManger，它有以下三个功能:</p><ul class=""><li id="9265" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated"><strong class="it hv">虚拟机入口</strong>。它连接来自其他模块的外部请求，包括RPC请求、块验证、Tx验证等。在预处理和格式化之后，工作被移交给VMWorker。它为所有请求提供了统一的入口。</li><li id="b2ac" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><strong class="it hv"> VMWorker生命周期管理</strong>。工作线程(VMManager线程)的数量是根据系统负载动态设置的，从而实现高效的重用。在workers中，JavaScript热启动和hotspot沙盒快照的持久性有助于减少虚拟机的频繁创建，并在加载相同代码时避免CPU和内存的繁重负载。这将提高系统的吞吐量，使IOST V8VM即使在处理高交易量的合同(如fomo3D)时也能实现高性能。</li><li id="db9b" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><strong class="it hv">与状态数据库的接口管理</strong>。这确保了每个IOST事务的原子性(防止对数据库的部分更新)，当出现资金不足的错误时，拒绝整个事务。同时，在刷新到<a class="ae jp" href="https://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>之前，在状态数据库中实现两级缓存。这确保了不同版本数据的访问时间更短，并优化了临时数据的性能。</li></ul><figure class="md me mf mg fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff my"><img src="../Images/8585e9e7787b26500ba480410af80d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4KOS-t3H70HyzM3V"/></div></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek"><em class="nk">Architecture of the IOST Virtual Machine</em></figcaption></figure><h2 id="a29f" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> IOST沙盒系统架构</strong></h2><p id="030f" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">作为JavaScript智能合约最终执行的载体，IOST沙盒完成对V8VM和Chrome V8下一个包的调用，分为编译和执行两个阶段:</p><h2 id="81c5" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak">编译阶段</strong></h2><p id="3a0e" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">主要用于合同开发和缠绕，主要有两个功能:</p><ul class=""><li id="7c12" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated"><strong class="it hv">合同包。</strong>基于webpack实现的打包智能合同将当前合同项目下的所有JavaScript代码打包，并自动安装依赖项，使IOST V8VM开发大型合同项目成为可能。同时，IOST V8VM和Node.js模块系统完全兼容，可以无缝使用require、module.exports、exports等方法，给合约开发者原生的JavaScript开发体验。</li><li id="3b49" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated"><strong class="it hv">合同快照。</strong>借助V8的快照技术，IOST的虚拟机消除了初始默认的空状态，从而提高了性能。真正的实现只需要对快照进行反序列化就可以完成执行，大大提高了JavaScript的加载速度和执行速度。</li></ul><h2 id="45f6" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak">执行阶段</strong></h2><p id="cc98" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">对于连锁契约的真正实现，有两个主要功能:</p><ul class=""><li id="a507" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated"><strong class="it hv"> LoadVM </strong>。<strong class="it hv"> </strong>完成VM初始化，包括生成Chrome V8对象，设置系统执行参数，导入相关JavaScript类库等。，从而完成智能合同执行前的所有准备工作。一些JavaScript类库如下:</li></ul><figure class="md me mf mg fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nl"><img src="../Images/47f59a2fcd07d9255b231b2b671571c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dgyf6TGPLSW8cPbVlZxDw.png"/></div></div></figure><ul class=""><li id="b3bc" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated"><strong class="it hv">执行</strong>。JavaScript智能契约在IOST V8VM上的最终实现将打开一个单独的线程执行契约，并监控当前的执行状态。如果发生异常，资源的使用超过了限制或者执行时间超过了最大限制，那么将调用Terminate来结束当前的契约执行，从而返回异常结果。</li></ul><figure class="md me mf mg fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nm"><img src="../Images/d21c17fc8d58134226ff794b2a22836e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQlXdyHQqhdbdCyQ"/></div></div></figure><h2 id="acdc" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> IOST V8VM性能</strong></h2><p id="42ec" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">构成公共区块链基础架构核心的虚拟机必须提供卓越的性能，以满足网络的需求和要求。在设计和虚拟机选择之初，IOST就把性能作为最重要的指标之一。</p><p id="b3a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Chrome V8使用JIT、内联缓存、延迟加载等等来实现JavaScript解释。得益于Chrome V8的高性能，IOST V8VM的JavaScript执行速度大幅提升。在测试了EVM、EOS、C Lua和V8VM在递归斐波那契、内存复制和复杂CPU操作中的性能后，我们观察到以下结果:</p><figure class="md me mf mg fq mz fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff nn"><img src="../Images/df57ffbe3a49b9eac210aa3dfcd757e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A73pCjwpwfY7cf6gW7gHBQ.png"/></div></div></figure><p id="2e5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些结果清楚地表明，IOST V8VM在主流VM实现中表现良好。上述测试包含虚拟机启动和加载配置的时间。可以看出，IOST V8VM直接冷启动也有很多性能优势。稍后，我们还将加入VM对象池、LRU缓存等。提高虚拟机CPU和内存的使用率，以更好地增强IOST处理智能合同的能力。</p><h1 id="33d9" class="jy jz hu bd ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv dt translated"><strong class="ak">结论</strong></h1><p id="c16f" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">目前，我们的测试网络正在运行IOST V8VM虚拟机的第一个版本。在第一个版本中，我们实现了所有预期的功能，并验证了许多设计概念，如投票、合同域名、令牌功能等..展望未来，我们将继续围绕以下重点改进IOST V8VM:</p><ul class=""><li id="e481" class="lp lq hu it b iu iv iy iz jc mq jg mr jk ms jo lu lv lw lx dt translated">提高所有层和系统的安全性</li><li id="1370" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">高性能和提高合同执行速度</li><li id="14b4" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">易于开发和使用，包括增加和改进标准库</li><li id="4b59" class="lp lq hu it b iu ly iy lz jc ma jg mb jk mc jo lu lv lw lx dt translated">支持大型项目建设、调试和完整的工具链</li></ul><p id="bb94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更多新功能将在未来几周的测试网络更新中实现。我们在部署行业领先的虚拟机的最终目标方面取得了巨大进展，该虚拟机能够超越并改进所有当前可用的网络，不仅对当前的发展，而且对整个IOST生态系统都感到非常兴奋。</p><h1 id="337a" class="jy jz hu bd ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv dt translated"><strong class="ak">附录:虚拟机基准程序</strong></h1><h2 id="241b" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated">EVM电码</h2><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="4409" class="lb jz hu mi b fv mm mn l mo mp">package evm<br/> <br/>import (<br/> “math/big”<br/> “testing”<br/> <br/> “github.com/ethereum/go-ethereum/accounts/abi/bind”<br/> “github.com/ethereum/go-ethereum/accounts/abi/bind/backends”<br/> “github.com/ethereum/go-ethereum/common”<br/> “github.com/ethereum/go-ethereum/core”<br/> “github.com/ethereum/go-ethereum/crypto”<br/>)<br/> <br/>var bm *Benchmark<br/> <br/>func init() {<br/> key, err := crypto.GenerateKey()<br/> <br/> auth := bind.NewKeyedTransactor(key)<br/> gAlloc := map[common.Address]core.GenesisAccount{<br/> auth.From: {Balance: big.NewInt(1000000)},<br/> }<br/> sim := backends.NewSimulatedBackend(gAlloc)<br/> <br/> _, _, bm, err = DeployBenchmark(auth, sim)<br/> <br/> if err != nil {<br/> panic(err)<br/> }<br/> sim.Commit()<br/>}<br/> <br/>func BenchmarkFibonacci(b *testing.B) {<br/> for i := 0; i &lt; b.N; i++ {<br/> _, err := bm.Fibonacci(nil, big.NewInt(32))<br/> if err != nil {<br/> b.Fatalf(“fibonacci run error: %v\n”, err)<br/> }<br/> }<br/>}<br/> <br/>func BenchmarkStrConcat(b *testing.B) {<br/> for i := 0; i &lt; b.N; i++ {<br/> _, err := bm.StrConcat(nil, “This is vm benchmark, tell me who is slower”, big.NewInt(10000))<br/> if err != nil {<br/> b.Fatal(err)<br/> }<br/> }<br/>}<br/> <br/>func BenchmarkCalculate(b *testing.B) {<br/> for i := 0; i &lt; b.N; i++ {<br/> _, err := bm.Calculate(nil, big.NewInt(5000))<br/> if err != nil {<br/> b.Fatal(err)<br/> }<br/> }<br/>}</span></pre><h2 id="e3c4" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> Lua代码</strong></h2><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="cf41" class="lb jz hu mi b fv mm mn l mo mp">function fibonacci(number)<br/> if number == 0<br/> then<br/> return 0<br/> end<br/> <br/> if number == 1<br/> then<br/> return 1<br/> end<br/> <br/> return fibonacci(number — 1) + fibonacci(number — 2)<br/>end<br/> <br/>function strConcat(str, cycles)<br/> local result = “”<br/> for i = 1, cycles do<br/> result = result .. str<br/> end<br/> <br/> return result<br/>end<br/> <br/>function calculate(cycles)<br/> local rs = 0<br/> for i = 0, cycles-1 do<br/> rs = rs + math.pow(i, 5)<br/> end<br/> <br/> return rs<br/>end</span></pre><h2 id="f0a4" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> EOS代码</strong></h2><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="1960" class="lb jz hu mi b fv mm mn l mo mp">class fibonacci : public eosio::contract {<br/>public:<br/> using contract::contract;<br/> <br/> /// @abi action<br/> void calcn(int64_t n) {<br/> int64_t r = calc(n);<br/> print(r);<br/> }<br/> int calc( int64_t n ) {<br/> if (n &lt; 0)<br/> {<br/> return -1;<br/> }<br/> if (n == 0 || n == 1)<br/> {<br/> return n;<br/> }<br/> return calc(n — 1) + calc(n — 2);<br/> }<br/>};<br/> <br/>EOSIO_ABI( fibonacci, (calcn) )<br/> <br/> <br/>class stringadd : public eosio::contract {<br/>public:<br/> using contract::contract;<br/> <br/> /// @abi action<br/> void calcn(std::string s, int64_t cycles) {<br/> std::string ss(s.size() * cycles, ‘\0’);<br/> int32_t k = 0;<br/> for (int i = 0; i &lt; cycles; ++i)<br/> {<br/> for (int j = 0; j &lt; s.size(); ++j)<br/> {<br/> ss[k++] = s[j];<br/> }<br/> }<br/> print(ss);<br/> }<br/>};<br/> <br/>EOSIO_ABI( stringadd, (calcn) )<br/> <br/> <br/>class calculate : public eosio::contract {<br/>public:<br/> using contract::contract;<br/> <br/> /// @abi action<br/> void calcn(uint64_t cycles) {<br/> uint64_t rs = 0;<br/> for (uint64_t i = 0; i &lt; cycles; ++i)<br/> {<br/> rs = rs + i * i * i * i * i;<br/> }<br/> print(rs);<br/> }<br/>};<br/> <br/>EOSIO_ABI( calculate, (calcn) )</span></pre><h2 id="bb1a" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak"> V8代码</strong></h2><pre class="md me mf mg fq mh mi mj mk aw ml dt"><span id="028e" class="lb jz hu mi b fv mm mn l mo mp">function fibonacci(cycles)<br/>{<br/> if (cycles == 0) return 0<br/> if (cycles == 1) return 1<br/> return fibonacci(cycles — 1) + fibonacci(cycles — 2)<br/>}<br/> <br/>function strConcat(str, cycles)<br/>{<br/> let rs = ‘’<br/> for (let i = 0; i &lt; cycles; i++) {<br/> rs += str<br/> }<br/> return rs<br/>}<br/> <br/>function calculate(cycles)<br/>{<br/> let rs = 0<br/> for (let i = 0; i &lt; cycles; i++) {<br/> rs = rs + Math.pow(i, 3)<br/> }<br/> return rs<br/>}</span></pre></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><h2 id="9756" class="lb jz hu bd ka lc ld le ke lf lg lh ki jc li lj km jg lk ll kq jk lm ln ku lo dt translated"><strong class="ak">关于IOST </strong></h2><p id="9cfb" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated"><a class="ae jp" href="https://iost.io/" rel="noopener ugc nofollow" target="_blank"> IOST </a>正在建设超高TPS的区块链基础设施，以满足分散经济的安全性和可扩展性需求。在一个久经考验的创始人团队的领导下，在包括红杉资本和Matrix Partners在内的世界级投资者的支持下，我们的使命是成为未来在线服务的底层架构。</p><p id="d61a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过设计POB共识机制和第二层扩展方案，实现了水平扩展和高吞吐量。IOST为第三方开发者、企业家和企业提供了一个平台，通过提高交易性能来实现价值，而不会牺牲去中心化的关键属性:隐私、开放参与和社区免受恶意攻击。IOST比EOS的DPoS机制更加去中心化，比以太坊智能合约平台更具可扩展性。</p><p id="c004" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://iost.io/" rel="noopener ugc nofollow" target="_blank">迷路了的io </a></p><figure class="md me mf mg fq mz"><div class="bz el l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>