<html>
<head>
<title>Introduction to WebAssembly for the Uno Platform (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Uno平台的WebAssembly介绍(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introduction-to-webassembly-for-the-uno-platform-part-1-61c0db29de28?source=collection_archive---------6-----------------------#2018-10-03">https://medium.com/hackernoon/introduction-to-webassembly-for-the-uno-platform-part-1-61c0db29de28?source=collection_archive---------6-----------------------#2018-10-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ee42cd87052763b0863fd41b43f69822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vvPtBIIz06VRM7fXatD2w.jpeg"/></div></div></figure><div class=""/><p id="a416" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebAssembly，或简称Wasm，是近来的热门话题，理由很充分。它有很多承诺，对于Uno平台，它承诺向其他语言和框架开放Web。</p><h1 id="908d" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">什么是WebAssembly？</h1><p id="3bc5" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">WebAssembly 是一个低级的web字节码，旨在用作任何语言的编译目标，就像ARM或x86一样。它是由一个W3C小组在过去几年中建立起来的，该小组主要由来自浏览器、框架和硬件供应商的不同人员组成。他们有一个简单而具体的目标，那就是能够<a class="ae ld" href="https://webassembly.org/docs/high-level-goals/" rel="noopener ugc nofollow" target="_blank">安全地运行任意二进制代码，并具有接近本机的性能</a>。</p><p id="1afa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前所有主流浏览器都支持它，这使得它成为一个可行的目标。</p><p id="4fbd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebAssembly的定义是不可知的。尽管它的名字包含“Web ”,但它被设计成一种通用的字节码。这就是允许像<a class="ae ld" href="https://github.com/ewasm/design" rel="noopener ugc nofollow" target="_blank">以太坊</a>、<a class="ae ld" rel="noopener" href="/perlin-network/life-a-secure-blazing-fast-cross-platform-webassembly-vm-in-go-ea3b31fa6e09">生命</a>、<a class="ae ld" href="https://github.com/nebulet/nebulet" rel="noopener ugc nofollow" target="_blank">星云</a>或<a class="ae ld" href="https://github.com/RyanLamansky/dotnet-webassembly" rel="noopener ugc nofollow" target="_blank"> WebAssembly的项目。NET </a>在没有任何浏览器的情况下运行。正如<a class="ae ld" href="https://twitter.com/_jayphelps/status/1034663875839504384" rel="noopener ugc nofollow" target="_blank"> Jay Phelps经常提到的</a>，WebAssembly既不是Web也不是Assembly，可以适用于很多场景。它有潜力最终成为真正的通用二进制格式，适用于任何类型的编程。</p><p id="1db4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其他好的资源可以在Matteo Basso的Awesome Wasm策划列表中找到。</p><h1 id="1f8e" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">WebAssembly是什么样子的？</h1><p id="03c2" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">WebAssembly是一种二进制格式，它不是人类可读的，但它有一个文本表示，这使得推理更容易。</p><p id="c4ad" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ld" href="http://webassembly.studio/" rel="noopener ugc nofollow" target="_blank"> WebAssembly Studio </a>是一个窥视生成的WebAssembly内部的好方法，在那里构建这个C代码:</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div class="fe ff le"><img src="../Images/4e965fc2d081c101f3a99069b3f3c116.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*IH2Oh9XdhySPMy6S.png"/></div></figure><p id="60a2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">变成这个WebAssembly文字代码:</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lj"><img src="../Images/a427bbfe8679495010c840f54f965ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uomQHgWgFxGz20SY.png"/></div></div></figure><p id="529c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它不像任何类似的汇编代码那样容易阅读，但是它给出了一个基于堆栈的虚拟机语言是如何工作的概念。</p><p id="4076" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebAssembly是大多数开发人员永远不必直接与之交互的目标，同样，大多数开发人员永远不必直接与x86_64或ARM64交互。它在很大程度上仍然是一个构建目标，是x86和ARM64旁边的下拉列表中的一个元素。</p><p id="6300" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">消费一个WebAssembly模块一般由一个<code class="eh lk ll lm ln b">.wasm</code>文件和一个JS <em class="lo"> glue </em>文件组成，可以在<a class="ae ld" href="http://webassembly.studio/" rel="noopener ugc nofollow" target="_blank"> WebAssembly Studio </a>的默认<code class="eh lk ll lm ln b">main.js</code>示例中找到。JS文件用于使用<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate" rel="noopener ugc nofollow" target="_blank"> WebAssembly.instantiate </a>方法加载WebAssembly代码。</p><h1 id="99fe" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">为什么选择WebAssembly？</h1><p id="d5ec" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">WebAssembly主要试图解决使大型应用程序难以优化性能的问题，提供对二进制语言的访问，并提高运行结果代码的安全性。</p><p id="cb33" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebAssembly模块被定义为字节码的自包含单元。可以使用<a class="ae ld" href="https://webassembly.github.io/spec/web-api/index.html#streaming-modules" rel="noopener ugc nofollow" target="_blank">流编译</a>在下载字节码的同时处理字节码，不像Javascript需要对源文件进行完全解析才能有意义。</p><p id="ad6f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它还为任何语言提供了一种针对Web的编译后端(如LLVM和<a class="ae ld" href="http://emscripten.org/" rel="noopener ugc nofollow" target="_blank"> Emscripten </a>)的方式。这就为C，C++，Rust，<a class="ae ld" href="https://github.com/mono/mono/tree/master/sdks/wasm" rel="noopener ugc nofollow" target="_blank">打开了一条路。基于. NET的语言通过Mono </a>、Java、Go和许多其他语言最终到达web。它为以Web为目标的开发人员提供了选择，无论他们是否需要完整的类型安全，都可以重用复杂的C++库，而事实证明这是很难移植到Javascript的。这种可移植性也使得运行时和框架能够跟上，例如<a class="ae ld" href="https://wiki.qt.io/Qt_for_WebAssembly" rel="noopener ugc nofollow" target="_blank"> QT-Wasm </a>，以及Mono和。网络生态系统。</p><p id="4601" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在安全性方面，WebAssembly与以前在浏览器中运行任意二进制代码的尝试有很大不同，例如Flash、Java小程序、VBA、Silverlight、ActiveX等等，这些都有(并将继续有)安全性和可移植性问题。例如，安全特性包括不能执行任意内存位置。虽然这使得可选的JIT语言(例如NET为基础的语言)是一个困难的目标，它承诺一个比类似的基于插件的前辈更安全的执行环境。</p><h1 id="d3a1" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">WebAssembly和。网</h1><p id="f7b9" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">微软已经在Mono运行时的WebAssembly <a class="ae ld" href="https://www.mono-project.com/news/2017/08/09/hello-webassembly/" rel="noopener ugc nofollow" target="_blank">端口上工作了一段时间</a>，自2018年初以来<a class="ae ld" href="https://www.mono-project.com/news/2018/01/16/mono-static-webassembly-compilation/" rel="noopener ugc nofollow" target="_blank">进展一直</a>稳定。使用<a class="ae ld" href="https://github.com/nventive/Uno" rel="noopener ugc nofollow" target="_blank"> Uno平台</a>作为参考点，运行时看起来像在iOS和Android上一样稳定，这是相当大的成就。</p><p id="902c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有。NET核心运行时(CoreRT)团队，他们正在。NET原生引擎，并且也取得了重大进展。</p><p id="6be8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebAssembly的安全性方面，由于<a class="ae ld" href="https://webassembly.org/docs/modules/#function-index-space" rel="noopener ugc nofollow" target="_blank">无法执行内存</a>的数据段，使得运行IL代码变得困难。通常，实时(JIT)编译用于使用底层平台的指令在数据内存段中发出代码，然后CPU将数据作为代码执行。WebAssembly中的安全约束类似于iOS和watchOS中的约束，它们不允许这样的编译技术。Mono团队已经在这些限制下工作，WebAssembly支持需要同样的处理来绕过这个限制。</p><p id="e32d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对此显而易见的答案是使用<em class="lo">提前编译</em> (AOT)，采用与iOS和watchOS相同的技术。<a class="ae ld" href="https://gitter.im/aspnet/Blazor?at=5b1ab670dd54362753f8a168" rel="noopener ugc nofollow" target="_blank">由于技术上的考虑</a>，比如<a class="ae ld" href="https://kripken.github.io/emscripten-site/index.html" rel="noopener ugc nofollow" target="_blank"> Emscripten </a>的集成及其在Javascript上的<code class="eh lk ll lm ln b">libc</code>实现，AOT还不可用。而<a class="ae ld" href="https://github.com/mono/mono/issues/10222" rel="noopener ugc nofollow" target="_blank"> AOT集成目前正由微软在</a>上进行，目前的运行路径。WebAssembly环境中的. NET代码是通过复活的Mono解释器实现的。</p><p id="c0ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Mono解释器类似于一段已经存在了很长时间的代码(<a class="ae ld" href="https://www.mono-project.com/news/2017/11/13/mono-interpreter/" rel="noopener ugc nofollow" target="_blank"> mint </a>)，在Mono的早期使用，当时JIT引擎(mini)还不可用。它的作用是逐个获取IL指令，并在本机编译的运行时之上执行它们。它允许IL代码立即在适当的环境中运行，代价是执行性能。</p><p id="dd54" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这是一个很好的启动解决方案，但这样的实现包含一个用于IL规范中每个可用操作码的<a class="ae ld" href="https://github.com/mono/mono/blob/7c19f9d443136cd76bd50bde3e13c4b43c98000f/mono/mini/interp/interp.c#L2686" rel="noopener ugc nofollow" target="_blank"> <em class="lo">巨型开关</em> </a>。这是<a class="ae ld" href="https://bugs.chromium.org/p/v8/issues/detail?id=7838" rel="noopener ugc nofollow" target="_blank">在经历这个热执行路径时给浏览器一个艰难的时刻</a>。它也不能很好地处理CPU数据缓存，例如i5或更低CPU的设备，其L2缓存大小有限。</p><p id="4664" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，这种情况只是暂时的。当Mono的AOT可用时，代码将立即快得多，尽管快多少还有待观察。生成的WASM二进制文件的大小也是一个未知的变量，而且也很难从其他看起来相似的AOT目标CPU架构中推断出来。</p><p id="49ea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解释器模式将作为混合执行模式留在Mono中。这将允许使用罗斯林的动态代码生成的<a class="ae ld" href="https://github.com/jeromelaban/Wasm.Samples/blob/master/RoslynTests/RoslynTests/Program.cs" rel="noopener ugc nofollow" target="_blank">场景在非JIT友好的环境中是可行的，并使诸如</a><a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.expression-1.compile?redirectedfrom=MSDN&amp;view=netframework-4.7.2#System_Linq_Expressions_Expression_1_Compile" rel="noopener ugc nofollow" target="_blank">表达式编译</a>之类的BCL片段能够正常工作。</p><h1 id="752b" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">引导mono-wasm SDK</h1><p id="5d4a" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">使用mono-wasm SDK的当前挑战是它的进入壁垒。仍然有很多东西需要修改，而且它没有以任何方式集成到Visual Studio或VS代码中。</p><p id="aa83" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于Frank A. Krueger在OOui 上的工作，我们构建了<a class="ae ld" href="https://github.com/nventive/Uno.Wasm.Bootstrap" rel="noopener ugc nofollow" target="_blank"> Uno。Wasm.Bootstrap </a>，一个简单的NuGet包，除了mono-wasm之外，与任何框架(甚至Uno平台)都没有关系。这允许用户采取简单的。NET Standard 2.0库，并在浏览器中运行，使用<code class="eh lk ll lm ln b">Console.WriteLine</code>将文本写入浏览器的调试控制台。任何与浏览器交互的更高级的东西都需要通过Javascript评估API。</p><p id="91c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们预计这一方案在不久的将来会有重大改变。这包括添加新的Mono特性(如AOT和调试器支持)，Nuget集成，VS集成等…</p><p id="889b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前往Uno。Wasm.Bootstrap readme 创建自己的应用程序，并在几分钟内在浏览器中体验C#。关于使用Json.NET和罗斯林的其他场景，请参见这两个<a class="ae ld" href="https://github.com/jeromelaban/Wasm.Samples" rel="noopener ugc nofollow" target="_blank">示例。</a></p><h1 id="c204" class="ka kb if bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">接下来…</h1><p id="c164" class="pw-post-body-paragraph jc jd if je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在本文的第二部分，我们将触及更多关于Mono在WebAssembly中的集成和即将推出的特性的高级主题。</p></div><div class="ab cl lp lq hc lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hn ho hp hq hr"><figure class="lf lg lh li fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lw"><img src="../Images/329b8a3927009df234efaf210a19a1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UeYulj197DUiNl7YlK1kzQ.png"/></div></div></figure></div></div>    
</body>
</html>