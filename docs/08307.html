<html>
<head>
<title>DotNetify: Multicast View Model for Building Collaborative Web Apps with SignalR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DotNetify:使用SignalR构建协作Web应用的多播视图模型</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dotnetify-multicast-view-model-for-building-collaborative-web-apps-with-signalr-6a6272f203ab?source=collection_archive---------9-----------------------#2018-10-03">https://medium.com/hackernoon/dotnetify-multicast-view-model-for-building-collaborative-web-apps-with-signalr-6a6272f203ab?source=collection_archive---------9-----------------------#2018-10-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5dccb1172b9078b1631423d06d53b7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sjawLEpO2I7azOPxSKUvQ.jpeg"/></div></div></figure><p id="1f55" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DotNetify3.1版本发布了，随之而来的是在跨平台ASP.NET服务器上编写多播视图模型类的新功能。</p><p id="0da7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">什么是多播视图模型？假设你已经熟悉<a class="ae ka" href="https://hackernoon.com/https-hackernoon-com-dotnetify-react-released-efc7de44a47e" rel="noopener ugc nofollow" target="_blank"> dotNetify和它的服务器端MVVM web应用程序开发方法</a>，它是一个服务器端视图模型，你可以通过多个<a class="ae ka" href="https://hackernoon.com/tagged/signalr" rel="noopener ugc nofollow" target="_blank"> SignalR </a>客户端连接共享同一个实例。对视图模型的任何数据更新，无论是由服务器还是任何客户端，都将被同时发送到所有。</p><h1 id="eb7c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为什么选择多播视图模型？</h1><p id="7c01" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这有许多应用，几乎所有需要与多个客户端进行实时通信的应用，例如简单的物联网广播、聊天应用、多人游戏和各种在线协作工具。</p><p id="0663" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，当然这一切都可以用一个SignalR hub类来完成，就像每个聊天教程喜欢展示的那样？答案是肯定的，但是……让我们来看看这些聊天应用的例子。它简单得令人难以置信，因为如果您继续沿着这条路走下去并开始构建更高级的特性，您可能会以复杂、紧耦合的代码而告终——无论是在客户端还是在服务器端——这不容易编写测试！</p><p id="114b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">MVVM设计模式通过将业务逻辑从基础设施中分离出来，有助于保持代码的高度可测试性。DotNetify抽象出SignalR的本质，在很大程度上你甚至不知道它的存在，所以你可以专注于构建你的客户想要的功能。</p><h1 id="d908" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">它是如何工作的</h1><p id="a33d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这是定义多播视图模型的方法:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="874a" class="ln kc hu lj b fv lo lp l lq lr">public class MyChatApp : <strong class="lj hv">MulticastVM</strong><br/>{<br/>}</span></pre><p id="16b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个普通的C#类，继承自一个dotNetify的基类。对于客户端脚本，我们将使用React，我们将添加一个组件来连接到这个视图模型:</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/d0ae54fe21f34446f7117c1250c697d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*NVxqr_R6cL7pMtHeXssZtg.png"/></div></figure><p id="2bfd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当这个组件在多个浏览器上呈现时，服务器总是给它相同的视图模型实例。</p><p id="854c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们添加一些基本聊天的文本框:</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/c9e287cb1b51d01df735aae761fd7fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*uZYvqWdvAnM2Fk_mm0UAcA.png"/></div></figure><p id="7676" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里是完整的服务器端视图模型，它将产生与官方SignalR聊天示例相同的结果:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="4916" class="ln kc hu lj b fv lo lp l lq lr">public class MyChatApp : <strong class="lj hv">MulticastVM</strong><br/>{<br/>   public List&lt;string&gt; Messages { get; } = new List&lt;string&gt;();<br/>   public Action&lt;string&gt; Message =&gt; this.<strong class="lj hv">AddList</strong>("Messages", msg);<br/>}</span></pre><p id="896d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们已经从代码中完全删除了直接的SignalR方法调用，并使用属性/命令绑定来让数据在服务器和连接到该视图模型的所有客户端浏览器之间无缝流动。</p><p id="5a42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您需要获得更多关于连接客户端的信息时，您可以将<code class="eh lt lu lv lj b">IPrincipalContextAccessor</code>和<code class="eh lt lu lv lj b">IConnectionContext</code>注入到视图模型中。这些接口提供了当前正在连接的客户端的环境上下文，例如SignalR连接ID、基于声明的身份、使用的IP地址等等。</p><h1 id="415e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">分区实例</h1><p id="6587" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">除了单个实例之外，一些用例还希望为不同的连接组提供不同的实例。例如，通过身份验证的用户可以同时从桌面和智能手机连接，并共享一个不能与其他用户共享的视图模型实例。</p><p id="70c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">SignalR具有定义和广播到组的能力，当Redis被配置时，它可扩展到多个服务器。使用<code class="eh lt lu lv lj b">MulticastVM</code>，定义一个组就像覆盖<code class="eh lt lu lv lj b">GroupName</code>属性一样简单:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d469" class="ln kc hu lj b fv lo lp l lq lr">public class PerUserVM : <strong class="lj hv">MulticastVM</strong><br/>{<br/>   private readonly <strong class="lj hv">IPrincipalAccessor</strong> _principalAccessor;    </span><span id="6bcb" class="ln kc hu lj b fv lw lp l lq lr">   public override string GroupName<br/>   {<br/>      get =&gt; _principalAccessor.Principal.Identity.Name;<br/>   } </span><span id="9420" class="ln kc hu lj b fv lw lp l lq lr">   public PerUserVM(<strong class="lj hv">IPrincipalAccessor</strong> principalAccessor)   <br/>   {     <br/>      _principalAccessor = principalAccessor;   <br/>   }<br/>}</span></pre><p id="58c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于调用连接的上下文，<code class="eh lt lu lv lj b">GroupName</code>值将是动态的。其工作方式是，当身份名为<em class="lx"> UserA </em>的经过身份验证的客户端连接时，将创建一个新实例，并将其与客户端的组名“UserA”相关联。当<em class="lx"> UserA </em>再次从不同的设备连接时，即不同的连接，它将被赋予任何具有匹配组名的现有实例。由于身份名称相同，两台设备将使用相同的视图模型实例。但是当<em class="lx"> UserB </em>连接时，将没有匹配的组名，将创建另一个实例并与‘UserB’组名关联。</p><p id="7066" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用这种机制，您可以扩展它来检查来自数据存储的连接用户的组成员资格，并为任何特定的组创建分区视图模型实例。</p><h1 id="c76b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">直接信息</h1><p id="e718" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果我们只需要向某些用户发送消息，该怎么办？使用<code class="eh lt lu lv lj b">IConnectionContext</code>，您可以将连接的用户与他们的SignalR连接id相关联，一旦有了这些id，就可以使用<code class="eh lt lu lv lj b">Send</code>基本方法向您选择的一个或多个连接发送消息:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b0d4" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">Send</strong>(new List&lt;string&gt;{ connId, ... }, stateName, stateValue);</span></pre><h1 id="cedb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">如何开始</h1><p id="7423" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您是dotNetify的新手，您可能对上面的示例代码有很多疑问。请访问dotnetify.net网站，那里有关于API的详细解释。那里有大量的其他材料:现场演示、模板，甚至React的UI工具包。一切都是免费开源的。</p><p id="0987" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读！</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="ly lz l"/></div></figure></div></div>    
</body>
</html>