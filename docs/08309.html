<html>
<head>
<title>Python stories, September 2018</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python故事，2018年9月</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/python-stories-september-2018-d34e526edde2?source=collection_archive---------11-----------------------#2018-10-03">https://medium.com/hackernoon/python-stories-september-2018-d34e526edde2?source=collection_archive---------11-----------------------#2018-10-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/51ff2571eb373983bb1ea7972f32621c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jct3DcUSr6FdyTCF.png"/></div></div></figure><p id="595c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在跑<a class="ae ka" href="https://t.me/pythonetc" rel="noopener ugc nofollow" target="_blank"> @pythonetc </a>，一个关于<a class="ae ka" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae ka" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>的电报频道一般。以下是2018年9月最好的帖子。</p><h1 id="63ec" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">重写与重载</h1><p id="a667" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有两个名称相似的概念很容易混淆:重写和重载。</p><p id="97b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当一个子类定义了一个已经被它的父类提供的方法来有效地替换它时，就会发生重写。在一些语言中，你必须显式地标记覆盖方法(C#需要<code class="eh le lf lg lh b">override</code>修饰符)，在一些语言中，它是可选的(Java中的<code class="eh le lf lg lh b">@Override</code>注释)。Python不需要任何特殊的修饰符，也没有标准的方法来标记这样的方法(有些人喜欢使用自定义的<code class="eh le lf lg lh b">@override</code>装饰器，它实际上什么也不做，只是为了可读性)。</p><p id="bba9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">超载是另一回事。重载是有多个同名但不同签名的函数。它受Java和C++等语言的支持，并且经常被用作提供默认参数的一种方式:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="abee" class="lq kc hu lh b fv lr ls l lt lu">class Foo {<br/>    public static void main(String[] args) {<br/>        System.out.println(Hello());<br/>    }</span><span id="6940" class="lq kc hu lh b fv lv ls l lt lu">public static String Hello() {<br/>        return Hello("world");<br/>    }</span><span id="befc" class="lq kc hu lh b fv lv ls l lt lu">public static String Hello(String name) {<br/>        return "Hello, " + name;<br/>    }<br/>}</span></pre><p id="1b12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Python不支持通过函数的签名来查找函数，只支持通过它们的名字。您可以编写代码来显式分析参数的类型和数量。这通常看起来很笨拙，通常不是一件好事:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="1c84" class="lq kc hu lh b fv lr ls l lt lu">def quadrilateral_area(*args):<br/>    if len(args) == 4:<br/>        quadrilateral = Quadrilateral(*args)<br/>    elif len(args) == 1:<br/>        quadrilateral = args[0]<br/>    else:<br/>        raise TypeError()</span><span id="23bc" class="lq kc hu lh b fv lv ls l lt lu">return quadrilateral.area()</span></pre><p id="3aae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你需要类型提示，<code class="eh le lf lg lh b">typing</code>模块可以帮助你使用<code class="eh le lf lg lh b">@overload</code>装饰器:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="aa05" class="lq kc hu lh b fv lr ls l lt lu">from typing import overload</span><span id="9197" class="lq kc hu lh b fv lv ls l lt lu">@overload<br/>def quadrilateral_area(<br/>    q: Quadrilateral<br/>) -&gt; float: ...</span><span id="ab9b" class="lq kc hu lh b fv lv ls l lt lu">@overload<br/>def quadrilateral_area(<br/>    p1: Point, p2: Point,<br/>    p3: Point, p4: Point<br/>) -&gt; float: ...</span></pre><h1 id="68b5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">自动逼真化</h1><p id="c439" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><code class="eh le lf lg lh b">collections.defaultdict</code>允许您创建一个字典，如果所请求的键丢失，该字典将返回默认值(而不是引发<code class="eh le lf lg lh b">KeyError</code>)。要创建一个<code class="eh le lf lg lh b">defaultdict</code>，你不应该提供一个缺省值，而应该提供一个这样的值的工厂。</p><p id="2702" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这允许你创建一个包含无限嵌套字典的字典，允许你做类似于<code class="eh le lf lg lh b">d[a][b][c]...[z]</code>的事情。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8cf3" class="lq kc hu lh b fv lr ls l lt lu">&gt;&gt;&gt; def infinite_dict():<br/>...     return defaultdict(infinite_dict)<br/>...<br/>&gt;&gt;&gt; d = infinite_dict()<br/>&gt;&gt;&gt; d[1][2][3][4] = 10<br/>&gt;&gt;&gt; dict(d[1][2][3][5])<br/>{}</span></pre><p id="62de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种行为被称为“自动逼真化”，这个术语来自Perl语言。</p><h1 id="81a6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">对象实例化</h1><p id="6fab" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对象实例化包括两个重要步骤。首先，调用一个类的<code class="eh le lf lg lh b">__new__</code>方法。它创建并返回一个全新的对象。其次，Python调用该对象的<code class="eh le lf lg lh b">__init__</code>方法。它的工作是建立物体的初始状态。</p><p id="f0d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，如果<code class="eh le lf lg lh b">__new__</code>返回一个不是原始类实例的对象，就不会调用<code class="eh le lf lg lh b">__init__</code>。原因是它可能是由另一个类创建的，因此已经为该对象调用了<code class="eh le lf lg lh b">__init__</code>:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="3fe8" class="lq kc hu lh b fv lr ls l lt lu">class Foo:<br/>    def __new__(cls, x):<br/>        return dict(x=x)</span><span id="469a" class="lq kc hu lh b fv lv ls l lt lu">    def __init__(self, x):<br/>        print(x)  # Never called</span><span id="9b6a" class="lq kc hu lh b fv lv ls l lt lu">print(Foo(0))</span></pre><p id="6281" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这也意味着你不应该用常规构造函数(<code class="eh le lf lg lh b">Foo(...)</code>)在<code class="eh le lf lg lh b">__new__</code>中创建同一个类的实例。这可能导致双<code class="eh le lf lg lh b">__init__</code>执行，甚至无限递归。</p><p id="3bd4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无限递归:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="25fa" class="lq kc hu lh b fv lr ls l lt lu">class Foo:<br/>    def __new__(cls, x):<br/>        return Foo(-x)  # Recursion</span></pre><p id="bc70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">双<code class="eh le lf lg lh b">__init__</code>:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="cb24" class="lq kc hu lh b fv lr ls l lt lu">class Foo:<br/>    def __new__(cls, x):<br/>        if x &lt; 0:<br/>            return Foo(-x)<br/>        return super().__new__(cls)</span><span id="9230" class="lq kc hu lh b fv lv ls l lt lu">    def __init__(self, x):<br/>        print(x)<br/>        self._x = x</span></pre><p id="6d7b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正确的方式:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="e7a7" class="lq kc hu lh b fv lr ls l lt lu">class Foo:<br/>    def __new__(cls, x):<br/>        if x &lt; 0:<br/>            return cls.__new__(cls, -x)<br/>        return super().__new__(cls)</span><span id="e4a1" class="lq kc hu lh b fv lv ls l lt lu">    def __init__(self, x):<br/>        print(x)<br/>        self._x = x</span></pre><h1 id="2e33" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt">[]</h1><p id="b7fa" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在Python中，可以通过定义<code class="eh le lf lg lh b">__getitem__</code>魔术方法来覆盖方括号运算符(<code class="eh le lf lg lh b">[]</code>)。这就是如何创建一个虚拟地包含无限数量的重复元素的对象:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="1f28" class="lq kc hu lh b fv lr ls l lt lu">class Cycle:<br/>    def __init__(self, lst):<br/>        self._lst = lst</span><span id="eb5b" class="lq kc hu lh b fv lv ls l lt lu">    def __getitem__(self, index):<br/>        return self._lst[<br/>            index % len(self._lst)<br/>        ]</span><span id="daa3" class="lq kc hu lh b fv lv ls l lt lu">print(Cycle(['a', 'b', 'c'])[100])  # 'b'</span></pre><p id="7791" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里不寻常的是<code class="eh le lf lg lh b">[]</code>操作符支持一种独特的语法。不仅可以这样用——<code class="eh le lf lg lh b">[2]</code>，还可以这样——<code class="eh le lf lg lh b">[2:10]</code>，或者<code class="eh le lf lg lh b">[2:10:2]</code>，或者<code class="eh le lf lg lh b">[2::2]</code>，甚至<code class="eh le lf lg lh b">[:]</code>。语义是<code class="eh le lf lg lh b">[start:stop:step]</code>，但是您可以对您的定制对象使用它。</p><p id="3679" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果你使用这个语法调用它，那么<code class="eh le lf lg lh b">__getitem__</code>会得到什么作为索引参数呢？切片对象正是为此而存在的。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="c7e3" class="lq kc hu lh b fv lr ls l lt lu">In : class Inspector:<br/>...:     def __getitem__(self, index):<br/>...:         print(index)<br/>...:<br/>In : Inspector()[1]<br/>1<br/>In : Inspector()[1:2]<br/>slice(1, 2, None)<br/>In : Inspector()[1:2:3]<br/>slice(1, 2, 3)<br/>In : Inspector()[:]<br/>slice(None, None, None)</span></pre><p id="bc66" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您甚至可以组合元组和片语法:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="0b90" class="lq kc hu lh b fv lr ls l lt lu">In : Inspector()[:, 0, :]<br/>(slice(None, None, None), 0, slice(None, None, None))</span></pre><p id="c6c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了简单地存储<code class="eh le lf lg lh b">start</code>、<code class="eh le lf lg lh b">stop</code>和<code class="eh le lf lg lh b">step</code>属性外，<code class="eh le lf lg lh b">slice</code>没有为您做任何事情。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="c339" class="lq kc hu lh b fv lr ls l lt lu">In : s = slice(1, 2, 3)<br/>In : s.start<br/>Out: 1<br/>In : s.stop<br/>Out: 2<br/>In : s.step<br/>Out: 3</span></pre><h1 id="3112" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">协同程序取消</h1><p id="5089" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">任何正在运行的<code class="eh le lf lg lh b">asyncio</code>协程都可以通过<code class="eh le lf lg lh b">cancel()</code>方法取消。<code class="eh le lf lg lh b">CancelledError</code>将被抛出到协程中，这将导致它和所有包装协程被终止，除非错误被捕获和抑制。</p><p id="e912" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">CancelledError</code>是<code class="eh le lf lg lh b">Exception</code>的子类，这意味着它可能会被本该捕捉“任何错误”的<code class="eh le lf lg lh b">try ... except Exception</code>意外捕捉。为了在协程中安全地做到这一点，您坚持这样做:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="2269" class="lq kc hu lh b fv lr ls l lt lu">try:<br/>    await action()<br/>except asyncio.CancelledError:<br/>    raise<br/>except Exception:<br/>    logging.exception('action failed')</span></pre><p id="92af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh le lf lg lh b">asyncio</code>中，将一些代码安排在稍后执行的常见做法是生成一个任务，该任务执行<code class="eh le lf lg lh b">await asyncio.sleep(x)</code>:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="feb5" class="lq kc hu lh b fv lr ls l lt lu">import asyncio</span><span id="9316" class="lq kc hu lh b fv lv ls l lt lu">async def do(n=0):<br/>    print(n)<br/>    await asyncio.sleep(1)<br/>    loop.create_task(do(n + 1))<br/>    loop.create_task(do(n + 1))</span><span id="04b0" class="lq kc hu lh b fv lv ls l lt lu">loop = asyncio.get_event_loop()<br/>loop.create_task(do())<br/>loop.run_forever()</span></pre><p id="c0ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，创建一个新任务可能会很昂贵，如果您不打算进行任何异步操作(比如示例中的<code class="eh le lf lg lh b">do</code>函数)，那么就没有必要这样做。另一种方法是使用<code class="eh le lf lg lh b">loop.call_later</code>和<code class="eh le lf lg lh b">loop.call_at</code>函数来调度要调用的异步回调:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="705b" class="lq kc hu lh b fv lr ls l lt lu">import asyncio                     <br/>                                   <br/>def do(n=0):                       <br/>    print(n)                       <br/>    loop = asyncio.get_event_loop()<br/>    loop.call_later(1, do, n+1)    <br/>    loop.call_later(1, do, n+1)    <br/>                                   <br/>loop = asyncio.get_event_loop()    <br/>do()                               <br/>loop.run_forever()</span></pre><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>