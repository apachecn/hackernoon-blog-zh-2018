<html>
<head>
<title>How to design scalable and maintainable ETLs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设计可伸缩和可维护的ETL</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-design-scalable-and-maintainable-etls-bfd1664211a7?source=collection_archive---------3-----------------------#2018-10-04">https://medium.com/hackernoon/how-to-design-scalable-and-maintainable-etls-bfd1664211a7?source=collection_archive---------3-----------------------#2018-10-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="206c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们经常低估ETL设计，并从一个简单的想法开始，然后发展到包括额外的特性和转换，直到他们以相当混乱的东西结束。这让IT部门头痛不已，同时祈祷一切都不会失败。这样的ETL应该是这样的:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/b116d3282c1a8cac40776748227a8a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*YgCKyOJdLAVna9LL3wXwog.jpeg"/></div></figure><p id="d206" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有几个需求有助于ETL的维护:</p><ul class=""><li id="2573" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo kc kd ke kf dt translated">重启/恢复流程的能力</li><li id="5301" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">关于执行历史和问题的结构化信息</li><li id="cea4" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">外部配置</li><li id="c702" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">用于监视和控制的API</li><li id="3596" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kc kd ke kf dt translated">易于故障恢复</li></ul><p id="adee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以遵循几个步骤来实现上述所有目标。</p><p id="a89b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> ETL原子性</strong></p><p id="cd3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这只是将我们的ETL分解成小的独立作业的一个花哨术语。那是<strong class="it hv">能够实现你的目标的最重要的</strong>要求。简单的工作容易理解，容易改变，容易维护。我知道我们大多数人可能认为他们无论如何都会这样做，但是以我在T4一家定制软件开发公司的经验来看，这一点经常被忽视。让我们看下面的例子:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff km"><img src="../Images/99dd93d79b637bf70350873791aa1a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vz32mstjDN8ICDpZ01UJA.png"/></div></div></figure><p id="57e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这看起来很简单，但是如果您需要在不加载表2的情况下执行它呢？您需要重新创建作业并部署新版本。或者当加载表3由于数据库崩溃而失败时，您重新启动所有东西，而不是只加载那个表。</p><p id="f36f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下，如果该作业被分割成小等幂作业，如下所示:</p><p id="97f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从FTP加载</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/d4c6874cc0be782c8e99055cd1c13a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*dGXva84r2fWNOLkhCKv-Xg.png"/></div></figure><p id="db6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和3个装载表作业(可以是带有参数的重复使用的同一作业)</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/783f8ee998615237d5059cb0f93274f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*VQYx_JEx_5zXsM453-FLcw.png"/></div></figure><p id="2dcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(注意drop表和load数据是如何在同一个作业中的。我们不想把它们一分为二，因为加载数据不再是等幂的，如果我们运行它两次，我们将使行加倍)</p><p id="7ac3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">可配置执行</strong></p><p id="8917" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们的ETL过程包含许多小的原子任务时，我们需要一种方法来执行它们。一个简单的解决方案是将它们都链接到一个主作业中，但这不是很灵活，并且不允许我们轻松地配置它。更好的方法是创建一个主任务，从外部配置中读取所需的作业并执行它们。这样，我们可以修改执行流，而无需重新部署ETL，也无需修改代码。</p><p id="b3c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于一个小项目来说，存储配置的简单YAML可能就足够了。但是为了使它灵活并能够扩展，可以使用数据库。在我们的ETL例子中，有两个表就很简单。版本控制将用于保存正确的执行历史:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/24af41fef614a057ffd7d3280e257c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*wAjnMgpJU3LpaxXTitB2ag.png"/></div></figure><p id="8c3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的主要工作可以是这样的:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/804b134b0265b387ac3355aeb27df74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*Q7C93DHEhPivPX07CQhK2g.png"/></div></figure><p id="b56c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">维护执行流程历史</strong></p><p id="71d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">搜索大型ETL的日志文件可能是一场噩梦。因为我们已经有了一个专门用于ETL的数据库，所以很容易扩展主任务来跟踪执行流。这样，我们的作业就不必担心日志记录和故障处理(记住——它们是做简单事情的小的原子代码片段)。因此，让我们在数据库中添加另外两个表:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kv"><img src="../Images/efa1a533a13747ddc427bef5d4b077c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*LWe6QM1y7AWa1HBCDNMBvA.png"/></div></figure><p id="a9fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每次运行ETL时，我们都会读取当前版本所需的作业，在ETL执行运行表中添加一条记录，并在ETL运行作业表中添加所有计划作业的记录。这使得我们(以及我们的主任务)可以轻松地跟踪执行情况。我们还有关于以前ETL运行的信息，包括它们的作业、时间、状态等。主任务负责这些表并控制流程。我们可以通过添加额外的字段(或额外的表)来扩展元信息，如加载的行、处理的文件等。</p><p id="d07e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">从ETL中分离ETL执行引擎</strong></p><p id="6ca3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们将ETL作为小型作业的结构化列表，并将主任务与数据库一起跟踪执行时，我们可以很容易地看到这两者不需要耦合在一起。这种主任务可以运行由不同作业组成的不同ETL，并维护它们的轨迹。它是一个简单的“ETL服务器”的例子，但是要使它成为一个真正的服务器还需要一些东西。</p><ol class=""><li id="8b11" class="jx jy hu it b iu iv iy iz jc jz jg ka jk kb jo kw kd ke kf dt translated">首先，它需要一个简单的API来允许更容易地访问关于执行运行的信息并控制这些执行运行。对于管理员来说，它可以是一个简单的CLI，甚至可以是一个允许不同用户访问和操作的web服务。最后，即使不访问服务器，查看ETL的状态和恢复/重启/停止也应该很简单。数据库有查看哪个步骤失败所需的所有信息，并且我们已经创建了我们的步骤幂等，因此它们可以重新启动。</li><li id="afa3" class="jx jy hu it b iu kg iy kh jc ki jg kj jk kk jo kw kd ke kf dt translated">我们需要一种简单的方法来部署新的ETL。有许多可能性，但是归结起来就是提供一个包含作业和配置的包。</li></ol><p id="b078" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个简单的打包是一个包含所有作业的. zip文件和一个位于根文件夹中的config.yml文件。当我们的服务器获得那个etl.zip时，它可以部署它，安排它，并开始执行它。ETL开发人员不需要知道服务器是如何工作的，他们只需要以约定的格式描述流程。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff kx"><img src="../Images/aa548b23bc79b8eb1e936cf354d4b5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bMAZB0VEYKnuiFTWkjvEA.png"/></div></div></figure><p id="e1bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">结论</strong></p><p id="04bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当我们有了基础知识，就要靠我们来扩展服务器，使其为生产做好准备。在一次又一次地用不同的ETL处理相同的问题之后，我确信它可以做得更好。我们从上面的步骤开始，甚至为一个简单的ETL使用非常相似的表结构，并从那里继续。最终，我们得到了一个运行多个ETL的生产就绪型服务器，它具有简单的监控、故障恢复和企业级客户所需的一切。这里的例子是在Pentaho <a class="ae kl" href="https://hackernoon.com/tagged/data" rel="noopener ugc nofollow" target="_blank">数据</a>集成中制作的，但是相同的基本原理适用于所有的<a class="ae kl" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>。</p><p id="edb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ky">请不要犹豫，如果你有任何问题，请分享建议！</em></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kz la l"/></div></figure></div></div>    
</body>
</html>