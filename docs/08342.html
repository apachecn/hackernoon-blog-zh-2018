<html>
<head>
<title>Incorporate AWS Fargate into Step Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将AWS Fargate合并到阶跃函数中</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/incorporate-aws-fargate-into-step-functions-8003d688d027?source=collection_archive---------2-----------------------#2018-10-05">https://medium.com/hackernoon/incorporate-aws-fargate-into-step-functions-8003d688d027?source=collection_archive---------2-----------------------#2018-10-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="3b5d" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated"><a class="ae jj" href="https://aws.amazon.com/step-functions/" rel="noopener ugc nofollow" target="_blank">步骤功能</a>是编排<a class="ae jj" href="https://aws.amazon.com/serverless/" rel="noopener ugc nofollow" target="_blank">无服务器工作流</a>的好方法。由于Lambda函数的执行时间限制，长时间运行的流程通常是不可避免的，并且它们通常依赖于“永远在线”的基础设施。如何将这些长时间运行的流程集成到您的工作流程中，同时仍然保持无服务器状态？</h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/58caa7a194fc726865edcd382e029d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uM6Elil2Oz5toahI"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">photo by <a class="ae jj" href="https://unsplash.com/@elcarito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">elCarito</a> on <a class="ae jj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="588d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">人们已经听说过，或者使用<a class="ae jj" href="https://hackernoon.com/tagged/aws" rel="noopener ugc nofollow" target="_blank"> AWS </a> Step函数来协调云原生任务(即Lambda函数)来处理他们的部分/全部生产工作负载。在这篇文章中，我将介绍如何在Step函数中将非lambda任务合并到状态机中。</p><h2 id="2379" class="kw kx hu bd ky kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq dt translated">在高层次上，阶跃函数到底是什么？</h2><p id="8575" class="pw-post-body-paragraph ka kb hu kc b kd lr iv kf kg ls iy ki kj lt kl km kn lu kp kq kr lv kt ku kv hn dt translated">这可能是每个新接触阶跃函数的人都会问的第一个问题。经过一番思考后，我得出这样的结论:</p><blockquote class="lw"><p id="7f5a" class="lx ly hu bd lz ma mb mc md me mf kv ek translated">它<!-- -->仅仅是一个编排工具，让你从分布式的、单独管理的服务中组成一个工作流。</p></blockquote><p id="4c72" class="pw-post-body-paragraph ka kb hu kc b kd mg iv kf kg mh iy ki kj mi kl km kn mj kp kq kr mk kt ku kv hn dt translated">因此，Step函数，不像它的名字所暗示的那样，并不是你为了把应用程序的组件连接在一起而需要编写的实际函数。其核心是一个<strong class="kc hv">状态机</strong>，或者更准确地说，是一个<em class="ml">有限</em>状态机，这是一种通过定义单个<em class="ml">状态</em>和这些状态之间的<em class="ml">转换</em>来说明应用程序流程的方式。实际上，一个状态通常注定要执行一个<strong class="kc hv">任务</strong> <em class="ml">。</em>AWS是这样定义任务的:</p><blockquote class="mm mn mo"><p id="cd72" class="ka kb ml kc b kd ke iv kf kg kh iy ki mp kk kl km mq ko kp kq mr ks kt ku kv hn dt translated">任务可以是活动或Lambda函数。</p></blockquote><p id="c078" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们都知道Lambda函数是什么，对吧？那么究竟什么是活动呢？我们开始吧:</p><blockquote class="mm mn mo"><p id="8a99" class="ka kb ml kc b kd ke iv kf kg kh iy ki mp kk kl km mq ko kp kq mr ks kt ku kv hn dt translated">活动是AWS步骤函数的一个特性，它使您能够在状态机中拥有一个任务，该任务由一个<em class="hu">工作器</em>执行，该工作器可以托管在亚马逊弹性计算云(Amazon EC2)、亚马逊弹性容器服务(Amazon ECS)、移动设备上——基本上在任何地方。</p></blockquote><p id="f26e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">简单地说，一项活动是一个符号，它必须由做实际工作的<em class="ml">工人</em>来实现。worker基本上是您单独管理的服务，只要它可以通过HTTP连接到Step函数，它就可以托管在任何地方。工作者将不得不对活动进行<a class="ae jj" href="https://en.wikipedia.org/wiki/Polling_(computer_science)" rel="noopener ugc nofollow" target="_blank">轮询</a>,以检查状态机是否已经达到该状态。一旦该状态中的活动被激活，工作者将开始工作，然后向该状态报告，以便状态机继续进行。</p><h2 id="317d" class="kw kx hu bd ky kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq dt translated">那么，法盖特是如何融入这一切的呢？</h2><p id="8d14" class="pw-post-body-paragraph ka kb hu kc b kd lr iv kf kg ls iy ki kj lt kl km kn lu kp kq kr lv kt ku kv hn dt translated">在这一点上，人们可能会问，为什么AWS不能直接从状态机内部触发一个托管在别处的任务，就像它执行Lambda函数一样？好问题。这是我对AWS的期望之一。我没有答案，但我猜这是由于员工的移动性/未知性，这将使定义您的状态变得非常棘手。</p><p id="183e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如前所述，在任务可以执行之前，工作者必须轮询处于某个状态的任务。这实质上意味着您必须在某个地方托管它，以维护一个套接字来单步执行函数，以便在需要时启动。如果您致力于AWS，那么您很有可能将您的工作人员托管在EC2上或ECS集群上的容器中。这样做的主要缺点是，当你的员工下班时，你可能最终要为资源付费。为了节省成本，许多人最终不得不在工人执行之前和之后连接Lambda函数，从而引入了更多的状态，这些状态的唯一工作是预热/退役底层基础设施。</p><p id="c0ab" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">那次，一直痛苦到<a class="ae jj" href="https://aws.amazon.com/blogs/aws/aws-fargate/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> Fargate </strong> </a>发布。在我看来，这是在AWS中运行许多东西的游戏改变者。它基本上是一个<a class="ae jj" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a> ECS产品，使用它，您不需要为容器生命周期之外的任何资源付费。这也意味着你的容器会一直保持关闭状态，直到有东西把它唤醒。</p><h2 id="ff48" class="kw kx hu bd ky kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq dt translated">在实践中，您将如何实现这一点？</h2><blockquote class="mm mn mo"><p id="1efb" class="ka kb ml kc b kd ke iv kf kg kh iy ki mp kk kl km mq ko kp kq mr ks kt ku kv hn dt translated">那么，如果容器在默认情况下是关闭的，它如何在步骤函数中轮询任务呢？</p></blockquote><p id="eec6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我的一位同事问道。我刚才已经回答了这个问题。如果您知道如何预热ECS集群来运行您的ECS worker，那么您肯定知道如何通过使用AWS SDK API来唤醒“fargated”容器。所以我实现它的方法是在指定ECS worker的状态之前引入一个额外的状态。这个额外的状态将运行Lambda函数中的一个任务，该任务运行容器。一旦这个Lambda函数完成，状态机就进入下一个状态，这就是被触发的容器将要轮询的状态。我从我的生产用例中提取了这一部分，并将其简化为下图。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ms"><img src="../Images/698146fd620c7b11d643f16e0d922331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFjMuOmIJV79b0k0Yt_n5w.png"/></div></div></figure><p id="f653" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">处于<code class="eh mt mu mv mw b">trigger-ecs</code>状态的任务运行一个Lambda函数，它的工作是调用<code class="eh mt mu mv mw b">runTask</code> API来唤醒和运行ECS容器，如下所示</p><pre class="jl jm jn jo fq mx mw my mz aw na dt"><span id="7875" class="kw kx hu mw b fv nb nc l nd ne">exports.handler = async (event) =&gt; {<br/>    <br/>    var params = {<br/>        taskDefinition: 'step-functions-task',<br/>        cluster: 'ecs-test',<br/>        launchType: 'FARGATE',<br/>        networkConfiguration: {<br/>            awsvpcConfiguration: {<br/>                subnets: ['my-subnet'],<br/>                assignPublicIp: 'ENABLED'<br/>            }<br/>        }<br/>    }<br/>    <br/>    await ecs.runTask(params).promise()<br/>    <br/>    console.log('ECS has been triggered.')<br/>};</span></pre><p id="8650" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在上面的Lambda函数中需要注意的一点是<code class="eh mt mu mv mw b">assignPublicIp</code>必须设置为ENABLED才能工作，因为fargated容器需要一个公共IP地址来建立到Step函数的HTTP连接以进行轮询。</p><p id="e7cd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在完成这个Lambda函数后，状态机转换到下一个状态<code class="eh mt mu mv mw b">execute-ecs</code>。在容器预热并开始运行后，工人将从<code class="eh mt mu mv mw b">execute-ecs</code>状态收到一个任务令牌，知道它准备好行动了。下面NodeJS中的代码显示了一个工人如何轮询一个任务，并在任务完成后报告。</p><pre class="jl jm jn jo fq mx mw my mz aw na dt"><span id="bf61" class="kw kx hu mw b fv nb nc l nd ne">var AWS = require('aws-sdk')</span><span id="5190" class="kw kx hu mw b fv nf nc l nd ne">var options = {<br/>  'region': 'ap-southeast-2'<br/>}</span><span id="f72a" class="kw kx hu mw b fv nf nc l nd ne">var client = new AWS.StepFunctions(options);</span><span id="8cb5" class="kw kx hu mw b fv nf nc l nd ne">var getStepFunctionActivity = () =&gt; {<br/>  let params = {<br/>    activityArn: 'arn:aws:states:ap-southeast-2:&lt;account-id&gt;:activity:run-ecs-task'<br/>  }<br/>  return client.getActivityTask(params).promise()<br/>}</span><span id="0a5b" class="kw kx hu mw b fv nf nc l nd ne">var reportBack = (token) =&gt; {<br/>  let params = {<br/>    taskToken: token,<br/>    output: JSON.stringify({result: 'ecs done'})<br/>  }<br/>  return client.sendTaskSuccess(params).promise()<br/>}</span><span id="d86f" class="kw kx hu mw b fv nf nc l nd ne">var executeTask = () =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve('job done')<br/>    }, 10000)<br/>  })<br/>}</span><span id="ee1d" class="kw kx hu mw b fv nf nc l nd ne">var execute = async () =&gt; {<br/>  while (true) {<br/>    var task = await getStepFunctionActivity()<br/>    if (task.taskToken) {<br/>      await executeTask()<br/>      await reportBack(task.taskToken)<br/>      break<br/>    }<br/>  }<br/>}</span><span id="2406" class="kw kx hu mw b fv nf nc l nd ne">execute()</span></pre><p id="ae61" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">注意到我是如何模拟<code class="eh mt mu mv mw b">executeTask</code>函数在10秒内返回的吗？这是你真正的逻辑所在。在执行结束时，代码将通过json字符串输出向状态机报告。下面是整个状态机的执行历史。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ng"><img src="../Images/d4930d1406d70f90aee051ac4200ff9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tApW3W1d3B3_bvU5iCwDsg.png"/></div></div></figure><p id="c5fa" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">注意到9和10之间有大约10秒的间隔吗？这就是法盖特容器的执行过程。ID 10还显示了容器执行的输出。</p><p id="e59d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">就是这样。希望您喜欢这次演练。我会感谢任何反馈，并乐意指出我哪里做错了。</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>