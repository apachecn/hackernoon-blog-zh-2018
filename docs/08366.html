<html>
<head>
<title>Single Core Parallel Programming: SIMD Assembly Performance Boost and Benchmarks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单核并行编程:SIMD汇编性能提升和基准测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/harnessing-the-power-of-simd-sse-assembly-instructions-for-good-fdaa8ce34e9a?source=collection_archive---------4-----------------------#2018-10-06">https://medium.com/hackernoon/harnessing-the-power-of-simd-sse-assembly-instructions-for-good-fdaa8ce34e9a?source=collection_archive---------4-----------------------#2018-10-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3a7495ee6a4e67708326b44ca8fd7e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYlMRXuuB2m0iPkhZQxEjw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">When things get this complicated, you know it’s usually Intel’s fault. Source: <a class="ae jg" href="https://pixabay.com/en/cooler-computer-fan-technology-pc-933691/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="ba2a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">SIMD汇编指令允许你在一个内核中并行处理大量数据。我已经说过一次了，现在我要再说一次:编程是我们所拥有的最接近魔法的东西。</p><p id="6f3a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="http://www.dataden.tech/programming/shell-first-steps-how-to-boost-your-productivity/" rel="noopener ugc nofollow" target="_blank"> Shell命令</a>就像小的cantrips，Python脚本是没什么帮助的Tulpas。我们甚至有自己的守护进程！但是，每当我们需要将性能压缩到最后一个字节时——当我们知道一个失误就会使程序大幅变慢……这时，最黑暗的黑魔法——汇编——就出现了。</p><p id="873b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我最近没有经常写信，你可能没有注意到(顺便说一句，如果这是你第一次读我，欢迎！很高兴见到你！).那是因为我上周有一个相当严厉的考试，我必须准备很多。这个主题叫做“计算机的组织II”，要跟上它是一个巨大的挑战。<br/>所以我决定把我练习时做的一个练习变成一篇文章。那样我可以一石二鸟(杀鸟不好，你应该难受)。</p><p id="fc03" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不再拖延，让我们直接切入正题。像往常一样，代码可以在这个<a class="ae jg" href="https://github.com/StrikingLoo/average-char" rel="noopener ugc nofollow" target="_blank"> Github项目</a>中获得。</p><h1 id="6749" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么是处理器指令？</h1><p id="cc65" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们编写的所有代码，无论是Python、Java还是C，最终都被解释或编译成微小的、原子的(从程序员的角度来看)CPU指令。这些指令数以千计，每一个都做一件很小的事情，直接与硬件交互。</p><p id="37d8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">举例来说，一条指令可能会将一个值写入内存(这就是变量赋值的意思)，打开或关闭某个位，或者执行逻辑<em class="li">和</em>。</p><p id="5706" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的电脑有一个英特尔处理器，这也是我们在课堂上学习的架构，所以对不起所有我的手臂使用读者，我今天不会足够包容。</p><p id="6324" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">编写这些指令的语言(1:1翻译成文字二进制)称为汇编。</p><h1 id="bd79" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">把C翻译成汇编:让我们暂时成为编译器。</h1><p id="7287" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在这篇文章中，我们将使用一个非常小的C函数。这是它的全部代码:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="4d59" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个函数将一个指向字节流的指针(一个<em class="li">字符</em>代表一个字节)、一个<em class="li">字符</em>和一个<em class="li">字符</em>作为参数。它将假设流以0结尾(如果不是这样，就会崩溃为分段错误)，并逐字节迭代，用want替换每个“have”实例。就C而言，这已经是最快的速度了——而且远远快于Python(当我运行一些基准测试时，这个函数的Python版本花了两分钟，而在C中输入大小需要6秒)。</p><p id="1ef4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个函数在汇编语言中是什么样子的，经过编译器？大概是这样的:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="f5ea" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">运行汇编函数而不是C版本不会提高我们的性能。它甚至可能降低它，因为编译器知道一些我们可能不知道的技巧，并对这种代码做了一些优化。</p><p id="0b6c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不过，有一种优化是它通常不会使用的，即使使用了，它也不会充分发挥它的潜力。</p><h1 id="874a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">SIMD指令:单指令，多数据</h1><p id="93aa" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">每当我们想到并行，我们就会想到多核进程，甚至是集群。但是如果我们让一个单核同时做很多事情会怎么样呢？这是英特尔的人几十年前的想法，从那以后，图像处理的世界就不一样了。</p><p id="c47c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你看，通常数据存储在通用寄存器中，就像我们刚刚使用的，在我们的CPU中。它们大部分是64位大小，因此可以存储一个<em class="li"> long、</em>一个<em class="li"> float、</em>或一个<em class="li"> int。</em>嗯，从技术上来说是两个<em class="li">int</em>，但仍然不足以让指令并行使用它们。</p><p id="5f3f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，大多数处理器有更大的可用寄存器:<em class="li"> XMMs </em>，上面有128位。这足够16个完整字节了！</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d40377ae70221b24330503b898b96b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIBc1g169XN3RnYbZh8njA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Let’s get this party started. source: <a class="ae jg" href="https://pixabay.com/en/cheers-beverage-drink-booze-839865/" rel="noopener ugc nofollow" target="_blank">Pixabay</a>.</figcaption></figure><p id="021f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想象一下，如果我们可以一次处理16个字节，让我们的程序快16倍，我们会做些什么。从内存中读取一次并获取16个不同的字节？检查。成批处理它们，然后一次全部写入内存？检查。可能性是无限的。</p><p id="f690" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">特别是在图像或信号处理方面，这为加快普通的并行计算提供了可能。好像，快了整整一个数量级。你知道什么函数是普通的并发函数吗？处理相互之间没有依赖关系的字节流。</p><p id="0ba5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不过，这里有一个陷阱:如果常规的英特尔指令对你来说似乎违反直觉或者很难看，那就准备好接受SIMD指令吧。它们的名字叫batpoop crazy，我们大多数人不查官方手册都写不出5个(谢天谢地<a class="ae jg" href="https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-2a-2b-2c-and-2d-instruction-set-reference-a-z" rel="noopener ugc nofollow" target="_blank">免费</a>)。</p><p id="f131" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">处理完所有这些注意事项后，让我来指导您完成我刚才展示的函数的SIMD实现。让我警告你:这并不漂亮，但也太快了。</p><h1 id="101f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第一个例子:用SIMD汇编指令得到一个字符串的长度。</h1><p id="62ab" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">首先，我迭代一次流来估计它的大小。为了简单起见，这个函数假设流的大小可以被16整除(结尾用零填充，至少有一个0字节表示流的结尾)，因为否则我只需添加一个新的<em class="li"> if </em>并运行size函数的非SIMD版本。<br/>让我们假设我们的用户愿意在将他们的阵列传递给我们之前填充它们以使它们可分，以换取性能提升和节省治疗会话。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="89d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你们谁想呕吐，或者去洗澡，我会理解的。将这篇文章加入书签，一小时后回来。<br/>但是，我们<em class="li">是</em>每16个字节从内存中读取一次。这使得这个程序比C版本快16倍！</p><p id="b07c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，对于第二部分，让我们实际上做我们被要求的:让我们替换一些字节！</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="2df0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就是这样。因为逐字节的布尔运算是并发的，比较也是并发的，所以我们实际上可以完全并行地处理每组16个字节。</p><p id="c8ba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">声明:对于那些真正关心性能的人，请注意，我每次都进行两次内存读取来获取相同的数据:一次是计算长度，另一次是进行替换。</p><p id="f8ce" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最好是一次完成所有的事情，但是代码会难看很多，也没有教育意义。这就是为什么我们应该期望这个程序只比C版本快8倍，而不是16倍。这仍然是一个非常好的改进。</p><h1 id="f166" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">使用SIMD有多快？基准！</h1><p id="ddfd" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">为了运行这些基准测试，我只是在一个小程序中使用了<em class="li"> time.h </em> C库(可在<a class="ae jg" href="https://github.com/StrikingLoo/average-char" rel="noopener ugc nofollow" target="_blank"> Github项目</a>中获得)。我所做的只是:</p><ul class=""><li id="0ea6" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">选择数组大小(16的倍数)</li><li id="7ec3" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated">用给定大小的交替值初始化字节数组</li><li id="d2a4" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated">运行该函数的C版本，并测量完成该循环所需的时间。</li><li id="c723" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated">对SIMD装配版进行同样的操作。</li></ul><p id="a4ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我用1.6e7、1.6e8和1.6e9的输入大小重复了这些步骤。我在这里停下来，因为下一个步骤会比我希望等待的时间长一些，但是趋势非常明显:</p><pre class="lj lk ll lm fq md me mf mg aw mh dt"><span id="53aa" class="mi kg hu me b fv mj mk l ml mm">INPUT_SIZE | ASM  | C (Seconds)<br/>  1.6e7  |  0.005 | 0.069 <br/>  1.6e8  |  0.050 | 0.687 <br/>  1.6e9  |  0.466 | 6.868</span></pre><p id="5eb7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">比我预想的还要线性！这个比率大约是13，所以比我估计的还要好。我想这与减少内存读取有关，但请在评论中留下你自己的假设。</p><h1 id="05ea" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="d52f" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我的第一个结论是，学习汇编很有趣。我的第二个结论是，我不可能通过考试。</p><p id="cebd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">出于实用性的考虑，我的第三个结论是编写SIMD程序是非常高效的，无论何时我们需要做一些更快的事情，我们都可以尝试使用它。</p><p id="e54a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者，如果你更喜欢高级语言，你可以寻找一个已经在实现中使用SIMD指令的框架(cough，NumPy，Pandas)。</p><p id="db31" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">无论如何，我认为了解底层的东西和我们处理器的内部工作方式可以帮助我们编写更好的代码，并更好地了解事情是如何在幕后工作的。</p><p id="801b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">今天到此为止。我希望你觉得这篇文章有趣，甚至有用。如果您希望深入了解这个主题，我建议您考虑一个并行处理可能有用的问题，尝试使用SIMD编写它，然后每隔几个步骤查阅英特尔手册以了解新的指令。</p><p id="3a41" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">像往常一样，如果你在我的代码中发现任何错误，或者我可以进一步优化的方法，甚至是一个打字错误，请在评论中告诉我！同样的道理也适用于任何积极的反馈，因为这总是值得赞赏的。</p><p id="77c2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回头见，继续编码！</p><p id="3c4f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="li">关注我的</em> <a class="ae jg" href="http://twitter.com/strikingloo" rel="noopener ugc nofollow" target="_blank"> <em class="li"> Twitter </em> </a> <em class="li">或</em><a class="ae jg" href="http://www.medium.com/@strikingloo" rel="noopener"><em class="li">Medium</em></a><em class="li">继续接收更多文章和教程。请在你使用的任何社交媒体上分享这篇文章。<br/>也许你有一个朋友最近想学习更多汇编语言？用这个打他！</em></p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="9da1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="li">原载于2018年10月6日</em><a class="ae jg" href="http://www.dataden.tech/programming/power-simd-assembly-instructions/" rel="noopener ugc nofollow" target="_blank"><em class="li">www . dataden . tech</em></a><em class="li">。</em></p></div></div>    
</body>
</html>