<html>
<head>
<title>Efficiently paging geospatial data with MongoDB — forwards and backwards (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB高效地分页地理空间数据——向前和向后(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/efficiently-paging-geospatial-data-with-mongodb-forwards-and-backwards-part-1-685e059a67b0?source=collection_archive---------8-----------------------#2018-10-08">https://medium.com/hackernoon/efficiently-paging-geospatial-data-with-mongodb-forwards-and-backwards-part-1-685e059a67b0?source=collection_archive---------8-----------------------#2018-10-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bda4ad7eaf7742703c4a637de0b4f350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z68F4SMRusBjJ7Q8ox4Waw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/Q1p7bh3SHj8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NASA</a> on <a class="ae jg" href="https://unsplash.com/search/photos/earth?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dd5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本系列文章中，我将描述在MongoDB中查询地理空间数据的一些基本技术，如果您希望您的应用程序或API提供对基于特定位置的距离排序的信息的访问，这些技术会很有用。例如:</p><ul class=""><li id="0c68" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">商业(餐馆、商店等。)或其他名胜古迹，</li><li id="154d" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">应用程序的其他用户(如约会应用程序)。</li></ul><p id="f003" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些技术将允许您的服务扩展并保持高效，因为它们支持对数据的持续时间访问(不管数据库中的数据量有多少)并最小化客户端所需的缓存。</p><h1 id="c9d9" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">你将学到什么</h1><p id="8ca8" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">在以下几节中，我将向您展示如何:</p><ol class=""><li id="4359" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke lw kl km kn dt translated">在MongoDB文档中存储位置数据(经度、纬度对)</li><li id="a303" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke lw kl km kn dt translated">使用位置数据查询此类文档，结果按离指定点的距离排序(从最近到最远)</li><li id="a9f3" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke lw kl km kn dt translated">高效地翻阅这些查询的结果</li></ol><p id="ea23" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使你以前没有使用过MongoDB，你也应该能够理解这篇教程。另一方面，如果前两点听起来很熟悉，你可能想直接跳到第三部分。</p><p id="f011" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用Node.js和官方的Javascript MongoDB驱动程序。代码片段将在Coffeescript 2中。</p><p id="ea05" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您想在本地运行代码示例，克隆伴随repo 的<a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code" rel="noopener ugc nofollow" target="_blank">，并遵循<code class="eh lx ly lz ma b">README.md</code>中的指令。</a></p><h1 id="3099" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">存储位置数据。</h1><p id="fc5e" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">对于经度、纬度对，我们需要使用<a class="ae jg" href="https://docs.mongodb.com/manual/reference/geojson/#overview" rel="noopener ugc nofollow" target="_blank"> GeoJSON </a>点<a class="ae jg" href="https://docs.mongodb.com/manual/reference/geojson/#point" rel="noopener ugc nofollow" target="_blank">对象格式。</a></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="ea36" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的<code class="eh lx ly lz ma b">doc</code>是您将插入到mongo集合中的内容，它有一个名为<code class="eh lx ly lz ma b">location</code>的字段，其值是GeoJSON点对象。字段的名称并不重要，我们可以使用任何其他有效的键名来代替<code class="eh lx ly lz ma b">location</code>。我们也可以将GeoJSON更深地嵌入到对象结构中，但是将<code class="eh lx ly lz ma b">type</code>和<code class="eh lx ly lz ma b">coordinates</code>放在<code class="eh lx ly lz ma b">doc</code>的顶层是行不通的。还可以在一个文档中存储多个GeoJSON对象，例如:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="4a1a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意:</p><ul class=""><li id="c97c" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">首先是经度(这与您可能习惯使用的相反，例如，google maps查询)</li><li id="167f" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">经度值需要在-180到180之间(包括180和180)</li><li id="741c" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">纬度值需要在-90和90之间(包括90和90)</li></ul><p id="6cb0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在您已经了解了基础知识，让我们生成一些数据来使用。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="8d68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们已经创建了6个文档，位置从赤道开始，以相等的间隔增加纬度，同时保持经度固定为0。以下是绘制在球体上的点:</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/05a562248608168b0837098623efd42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCtF-9NQl8eLcjIFzA_XlQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">See code used to generate this on <a class="ae jg" href="https://jsfiddle.net/adrian_gierakowski/8jqx0mr9/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a>.</figcaption></figure><p id="debd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，在下面的代码示例中，我们将省略获取mongodb集合对象并向其中插入文档所需的样板文件。在伴随repo 的<a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code https://github.com/adrian-gierakowski/paging_geospatial_data_code" rel="noopener ugc nofollow" target="_blank">中，这个样板文件已经包含在<code class="eh lx ly lz ma b"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/helpers/with_collection.coffee" rel="noopener ugc nofollow" target="_blank">with_collection</a></code>和<code class="eh lx ly lz ma b"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/helpers/with_collection_with_points" rel="noopener ugc nofollow" target="_blank">with_collection_with_points</a></code>助手函数中。</a></p><h1 id="73cb" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">基于位置的文档查询。</h1><p id="08d8" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">为了根据文档与特定点的距离来查询文档，我们将使用<code class="eh lx ly lz ma b"><a class="ae jg" href="https://docs.mongodb.com/manual/reference/operator/query/near/index.html" rel="noopener ugc nofollow" target="_blank">$near</a></code> <a class="ae jg" href="https://docs.mongodb.com/manual/reference/operator/query/near/index.html" rel="noopener ugc nofollow" target="_blank">查询操作符</a>。但在此之前，我们需要在包含GeoJSON点对象的字段上创建一个<a class="ae jg" href="https://docs.mongodb.com/manual/core/2dsphere/" rel="noopener ugc nofollow" target="_blank"> 2dsphere索引</a>。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/00_create_index.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="88a9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在实时数据库上创建索引时，设置后台选项非常重要，因为在创建索引时，默认情况下<a class="ae jg" href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/index.html#behaviors" rel="noopener ugc nofollow" target="_blank"> createIndex </a>将<strong class="jj hv">阻止数据库</strong>上的所有其他操作(如果集合很大，这可能需要一段时间)。</p><p id="539c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在是基本查询，根据文档中的<code class="eh lx ly lz ma b">location</code>字段的数据，返回从<code class="eh lx ly lz ma b">[ 0, 0 ]</code>点开始按距离(准确地说是<a class="ae jg" href="https://en.wikipedia.org/wiki/Great-circle_distance" rel="noopener ugc nofollow" target="_blank">大圆距离</a>)排序的<strong class="jj hv">所有</strong>文档:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/01_query_all.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="53e3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除非您打算处理集合中的所有<strong class="jj hv">文档(在这种情况下，您可能会调用<code class="eh lx ly lz ma b"><a class="ae jg" href="http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html#stream" rel="noopener ugc nofollow" target="_blank">.stream</a></code>而不是<code class="eh lx ly lz ma b"><a class="ae jg" href="http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html#toArray" rel="noopener ugc nofollow" target="_blank">.toArray</a></code>)，否则您会希望限制返回文档的数量。这是如何做到的:</strong></p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/02_query_wlth_limit.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="ae8f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在下图中，白点标记了上述查询中使用的位置(<code class="eh lx ly lz ma b">[ 0, 0 ]</code>)，用绿色圈出的点表示<code class="eh lx ly lz ma b">limit</code>设置为<code class="eh lx ly lz ma b">2</code>的查询结果。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/7f85152e8c312c85fdee481ff9a1d430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NeqQAoEW_YcvgtL3PKAeow.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">see code used to generate this on <a class="ae jg" href="https://jsfiddle.net/adrian_gierakowski/2gst7vma/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a></figcaption></figure><h1 id="be34" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">从最近到最远(向前)翻阅结果。</h1><p id="8019" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">注意:本节中讨论的技术已经由A. Jesse Jiryu Davis在之前的<a class="ae jg" href="https://emptysqua.re/blog/paging-geo-mongodb/" rel="noopener ugc nofollow" target="_blank">中描述过，他实现了MondoDB特性，使得这种技术成为可能。他的文章详细介绍了为什么这个方法是高性能的，因此值得一读，但是代码示例是用python编写的，因此为了Node.js社区的利益，我们将在这里一步一步地介绍它。</a></p><p id="3ae2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">基于我们在前一节中定义的查询，实现分页的最简单方法是使用<code class="eh lx ly lz ma b">limit</code>来控制页面/批处理大小，使用<code class="eh lx ly lz ma b"><a class="ae jg" href="https://docs.mongodb.com/manual/reference/method/cursor.skip/index.html" rel="noopener ugc nofollow" target="_blank">skip</a></code> <a class="ae jg" href="https://docs.mongodb.com/manual/reference/method/cursor.skip/index.html" rel="noopener ugc nofollow" target="_blank">方法</a>来设置所需的页面偏移量。例如:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/03_page_with_skip.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="d333" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当查询我们的测试数据时，上面的查询将返回结果的第二页，如下所示。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/69c6d9151d2ce0e2ae95db5935f7fa8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIjtRGkrxpFu3H_FW49YWQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">see code used to generate this on <a class="ae jg" href="https://jsfiddle.net/adrian_gierakowski/dhsL1c4u/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a></figcaption></figure><p id="f639" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而<code class="eh lx ly lz ma b">skip</code>的性能随着偏移量的增加而线性下降(如上面提到的文章中的<a class="ae jg" href="https://emptysqua.re/blog/paging-geo-mongodb/" rel="noopener ugc nofollow" target="_blank">所示)，因为MongoDB服务器需要从头开始扫描所有查询结果，直到达到偏移量。</a></p><p id="1ddd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个恒定时间替代方案包括使用<code class="eh lx ly lz ma b"><a class="ae jg" href="https://docs.mongodb.com/manual/reference/operator/query/minDistance/index.html" rel="noopener ugc nofollow" target="_blank">$minDistance</a></code> <a class="ae jg" href="https://docs.mongodb.com/manual/reference/operator/query/minDistance/index.html" rel="noopener ugc nofollow" target="_blank">查询操作符</a>，排除位于查询点给定半径内的结果。</p><p id="9d17" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设我们知道查询点和离给定结果页最远的文档之间的距离，我们可以如下查询下一页:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="4c42" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我们从哪里得到距离呢？我们可以试着用一个手工滚动的公式来计算球体上两点之间的距离。或者使用类似Geolib 中的<code class="eh lx ly lz ma b"><a class="ae jg" href="https://github.com/manuelbieh/Geolib/blob/8273a52d86f7dfbd3b0e2aa2b7473ef5149c5374/src/geolib.js#L237" rel="noopener ugc nofollow" target="_blank">getDistance</a></code> <a class="ae jg" href="https://github.com/manuelbieh/Geolib/blob/8273a52d86f7dfbd3b0e2aa2b7473ef5149c5374/src/geolib.js#L237" rel="noopener ugc nofollow" target="_blank">的东西。然而，我们必须确保我们选择的实现与MongoDB使用的实现相匹配。幸运的是，我们不必经历所有这些麻烦，因为我们可以要求MongoDB在查询结果中为每个文档附加一个动态计算的距离。我们只需将我们的<code class="eh lx ly lz ma b">find</code>查询转换成一个等价的</a><a class="ae jg" href="https://docs.mongodb.com/manual/aggregation/" rel="noopener ugc nofollow" target="_blank">聚合</a>管道，使用<a class="ae jg" href="https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/" rel="noopener ugc nofollow" target="_blank"> $geoNear </a>阶段及其<code class="eh lx ly lz ma b">distanceField</code>选项。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="50d4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们可以使用查询结果中最后一个文档的<code class="eh lx ly lz ma b">calculated_distance</code>属性(因为它们是按距离升序排列的)来获取下一页。让我们使用上面的函数来获取前两页。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/04_page_with_min_distance.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="7519" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是对第二次调用<code class="eh lx ly lz ma b">fetch_page</code>的结果的可视化，用黄色圆圈圈出使用<code class="eh lx ly lz ma b">minDistance</code>从查询中排除的区域。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/0ec6d6cc1ab2cc2f15e9334c43e14bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyaVuOKb-jecVdyOCaVfAw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">see code used to generate this on <a class="ae jg" href="https://jsfiddle.net/adrian_gierakowski/6ub2qy4z/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a></figcaption></figure><p id="02bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，这并不完全是我们想要的:上一页的最后一个文档包含在下一页中，因为<code class="eh lx ly lz ma b">minDistance</code>只排除距离小于给定值的文档。为了防止这种情况，我们需要将下面的查询添加到我们的<code class="eh lx ly lz ma b">$geoNear</code>聚合阶段。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/06_page_with_min_distance_and_exclude_one_id.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="4ffb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在收集结果时，该查询使用<code class="eh lx ly lz ma b"><a class="ae jg" href="https://docs.mongodb.com/manual/reference/operator/query/nin/" rel="noopener ugc nofollow" target="_blank">$nin</a></code> <a class="ae jg" href="https://docs.mongodb.com/manual/reference/operator/query/nin/" rel="noopener ugc nofollow" target="_blank">操作符</a>跳过具有给定<code class="eh lx ly lz ma b">_id</code>的文档。完事了吗？差不多了！考虑以下几点。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="e7d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，第二和第三个点与<code class="eh lx ly lz ma b">[ 0, 0 ]</code>点的距离完全相同。现在，如果我们将<code class="eh lx ly lz ma b">query_point</code>设置为<code class="eh lx ly lz ma b">[ 0, 0 ]</code>，将<code class="eh lx ly lz ma b">page_size</code>设置为<code class="eh lx ly lz ma b">3</code>，那么获取第二页的结果会是什么呢？假设第一个查询返回的点按照上面的数组排序(<code class="eh lx ly lz ma b">[ 0, -15 ]</code> last)，下面是它的样子。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mh"><img src="../Images/041d3ff6e2759cdcb43061385c6f5aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFMGpPwtuS19mMBUMWoaVg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">see code used to generate this on <a class="ae jg" href="https://jsfiddle.net/adrian_gierakowski/jo1q0xe8/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a></figcaption></figure><p id="e49d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是因为<code class="eh lx ly lz ma b">minDistance</code>和<code class="eh lx ly lz ma b">$nin</code>都不排除坐标为<code class="eh lx ly lz ma b">[ 0, 15 ]</code>的文档。因此，我们需要收集距离等于<code class="eh lx ly lz ma b">last_doc</code>的所有文档的<code class="eh lx ly lz ma b">_id</code>，而不是仅仅使用最后一个文档的<code class="eh lx ly lz ma b">_id</code>。将所有这些放在一起:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="2175" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">给定<code class="eh lx ly lz ma b">current_page</code>以下是你获取下一个的方法:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/07_page_with_min_distance_and_exclude_ids_from_one_page.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="3796" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，<code class="eh lx ly lz ma b">get_last_distance</code>和<code class="eh lx ly lz ma b">get_ids_to_exclude</code>中的逻辑最有可能在客户端执行，因此它没有包含在<code class="eh lx ly lz ma b">fetch_page</code>函数中，该函数期望预先计算的<code class="eh lx ly lz ma b">exclude_ids</code>和<code class="eh lx ly lz ma b">last_distance</code>被传入。这是为了尽量减少通过网络发送的数据量。或者，服务器可以包含一个HTTP链接头，其中包含获取下一个页面所需的所有信息，在这种情况下，上面的所有代码都将在服务器上执行。</p><p id="ff45" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们需要处理这样一种情况，有很多文档具有相同的距离，以至于一个页面中的最后一个文档与用于获取该页面的<code class="eh lx ly lz ma b">last_distance</code>具有相同的距离。例如，当从下面的一组点中取出第三页时(用<code class="eh lx ly lz ma b">query_point = [ 0, 0 ]</code>和<code class="eh lx ly lz ma b">page_size = 2</code>):</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="2539" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用上面的实现，我们将得到点<code class="eh lx ly lz ma b">[ [ 0, -15 ], [ 0, 30 ] ]</code>而不是期望的<code class="eh lx ly lz ma b">[ [ 0, 30 ], [ 0, 45 ] ]</code>，因为来自第1页的最后一个点的<code class="eh lx ly lz ma b">_id</code>(<code class="eh lx ly lz ma b">[ 0, -15 ]</code>)没有被排除，即使它的距离与<code class="eh lx ly lz ma b">minDistance</code>相同。因此，在这种情况下，我们需要将<code class="eh lx ly lz ma b">exclude_ids</code>从前一个查询转移到下一个查询。</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code/tree/f7014c4418c185a06dc3a83d2da0c72ce158e193/src/08_page_forwards_final.coffee" rel="noopener ugc nofollow" target="_blank">runnable example</a> on github</figcaption></figure><p id="cf7e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">值得注意的是，在所有文档都具有相同距离的极端情况下，<code class="eh lx ly lz ma b">exclude_ids</code>数组的大小，以及每个请求中通过网络发送的数据量，会随着页面的进展而线性增加。除此之外，查询性能本身也会以类似的方式降低(我敢打赌，这将比单纯依赖于<code class="eh lx ly lz ma b">skip</code>的简单实现更糟糕)。为了减轻这种情况，我们可以记录要跳过的文档数(并与<code class="eh lx ly lz ma b">minDistance</code>结合使用)，而不是累积<code class="eh lx ly lz ma b">exclude_ids</code>。这将保持请求的大小不变，并且查询性能在简单的<code class="eh lx ly lz ma b">skip</code>解决方案的范围内。然而，在查询的数据是高度动态的情况下(当预期在读取之间会发生变化时)，跟踪要排除的<code class="eh lx ly lz ma b">_id</code>比使用skip有一些优势，我们可能会在以后的文章中讨论这一点。</p><p id="2f03" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我想提醒您注意这样一个事实，上面的方法不便于直接跳转到一个特定的页面(不获取中间的所有页面)。然而，这可以通过向查询添加适当的<code class="eh lx ly lz ma b">skip</code>(等于<code class="eh lx ly lz ma b">page_size * pages_to_skip_count</code>)来实现。使用<code class="eh lx ly lz ma b">skip</code>显然会导致与跳过的文档数量成比例的性能损失，但是确实没有办法避免(除非您的用例可以使用<code class="eh lx ly lz ma b">minDistance</code>跳过未知数量的文档，而不是指定要跳过的页面/文档数量)。幸运的是，我们只需要为每次页面跳转支付一次这个价格，因为一旦使用<code class="eh lx ly lz ma b">skip</code>获取了想要的页面，就可以只使用<code class="eh lx ly lz ma b">minDistance</code>和<code class="eh lx ly lz ma b">exclude_ids</code>查询下一个页面。</p><h1 id="698b" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">结论</h1><p id="997d" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">我们演示了如何在mongodb中存储和查询地理空间数据，并讨论了如何高效地浏览大量此类数据(从最近的位置到最远的位置)。在本系列的第2部分中，您将学习如何使用一个巧妙的技巧来以相反的顺序浏览各个位置。</p><p id="f8ee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要忘记克隆伴随repo 的<a class="ae jg" href="https://github.com/adrian-gierakowski/paging_geospatial_data_code" rel="noopener ugc nofollow" target="_blank">,并使用可以从命令行轻松运行的代码示例。</a></p></div></div>    
</body>
</html>