<html>
<head>
<title>Fire in production!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产中的火！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fire-in-production-c5ece4794212?source=collection_archive---------21-----------------------#2018-10-08">https://medium.com/hackernoon/fire-in-production-c5ece4794212?source=collection_archive---------21-----------------------#2018-10-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/533c6d5abdd4d1e42b6826e13169eb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2unV_AgA8S9ccgvlmLa-pg.png"/></div></div></figure><p id="3b4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想我们大多数人都有一些关于在生产中运行应用程序的恐怖故事要分享。事情没有按预期进行。事情很快就失控了。甚至是莫名其妙停止工作的东西。一本包含许多这类恐怖故事的好书即将发行！:由<em class="kb">迈克尔·t·尼加德</em>设计和部署生产就绪软件(务实的程序员)。</p><p id="b20f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问我们自己一个合理的问题是:为什么在设计和开发软件的所有努力之后，生产系统的质量却很差。在一天结束的时候，所有开发工作的成果就是我们构建的系统，如果系统不能满足用户的期望，那么这些工作就没有什么意义了。</p><p id="7b0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几乎每个系统/应用都有bug。这篇文章的主题是，当他们的系统上线时，工程师应该有什么样的心态。生产中总会有意想不到的情况，但底线是如何限制它们的数量，如何不引入新的情况，最重要的是，如何从错误中学习。</p><h1 id="56e9" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">原因</h1><p id="9082" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">无论<a class="ae ka" href="https://hackernoon.com/let-the-code-speak-52d1cebf0394" rel="noopener ugc nofollow" target="_blank">如何清理我们的代码是</a>，或者我们使用什么开发流程，通常生产中出现问题的原因都是开发和生产之间有差距。</p><p id="6745" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在基础设施和工作负载方面，生产环境不同于开发环境。通常，生产和开发环境之间的差距随着我们系统的复杂性而增长。试运行和测试环境可以(部分)填补这一空白，但前提是它们能够反映生产环境，而这通常是不现实的。(可悲的)事实是，建立和维护一个与生产类似的环境的成本很高，而且往往是第一个被削减的成本。</p><p id="8d8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在微服务中，开始开发没有CI/CD的服务被认为是一个阻碍。微服务本来就很复杂，所以经验早已证明，如果你一开始就没有CI/CD，那你玩起来胜算很大。</p><p id="0a27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，我们倾向于在设计和开发阶段用假设来填补这个空白。这些假设需要一些创造力和想象力，自然会降低信心。我们希望把它们做好。因此，如果我们没有办法验证这些假设，那么不可避免地，它们将在最糟糕的时刻被证明是错误的(相信我<em class="kb">墨菲定律</em>是一个东西)。</p><p id="986f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">软件的整个生命周期，从分析到部署，应该有最少的假设。</p><h1 id="e92b" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">格外小心地对待生产</h1><p id="24f1" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">当事情失去控制时，我们需要立即采取行动。我们的主要目标是解决问题，使系统回到健康状态。此外，我们应该能够为一些事后分析收集数据。</p><p id="6878" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在让系统回到健康状态的过程中，我们可能会尝试做一些手工修改。这些攻击可能包括手动更改一些配置文件，重新启动正在运行的服务的实例，甚至更改代码/工件。虽然这些黑客可以通过重新启动系统来拯救我们，但它们通常需要付出一些代价。我们需要记录我们所做的一切；否则，我们将最终在未知的生产环境中运行配置。</p><p id="1684" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无论如何，我们应该避免这种可怕的情况。拥有一个未知配置的系统比根本没有系统更糟糕，因为没有人知道系统是如何运行的。这就像赌博，它损害了软件生命周期的前几个阶段的所有努力。</p><p id="9f77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记住:一个过程的质量是所有子过程的最低质量。如果我们不关注生命周期的某一部分，我们最终会有一个糟糕的整体生命周期。</p><h1 id="823f" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">如何处理生产问题</h1><p id="856f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">处理生产问题的最佳方式是事先做一些分析，并建立问题发生时将遵循的流程。使用错误跟踪系统来记录已经发生的问题。如果需要，有一个定义良好的过程来更改数据。在系统处于有问题的状态时拍摄快照，以便稍后进行检查。</p><p id="69ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但最重要的是，对你认为可能出现的任何事情都要有一个流程。不管这听起来有多微不足道，您都会惊讶于缺少流程会带来多大的痛苦。我们需要像对待一级公民一样对待问题和错误，而不是罕见的事件。事情会出错，我们必须接受这一点！</p><p id="39fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">生产系统中可能出现两类问题:与业务相关的问题和操作问题。</p><h1 id="3e20" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">与业务相关的问题</h1><p id="366f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">与业务相关的问题包括妨碍我们的用户完成工作的任何事情。它们通常是由于我们系统中的一个bug或缺失的特性而发生的，但并不总是这样，我们将在下面的段落中看到。</p><p id="2d04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们应该以一种支持变化的方式设计我们的软件，这样我们就不必直接手动编辑数据库中的数据。我们总是需要改变系统中的数据，如果我们直接在数据库中进行，那么我们可能会使系统处于不一致的状态。比方说，我们有一个用户抱怨他们不能在购物车中添加商品，因为前端的一些东西坏了，你必须手动添加。</p><p id="922f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要特殊的端点/服务/工具来完成这项工作，避免手动添加。这样做有两个原因。首先，在购物车中添加一个商品可能不仅仅意味着数据库中的一条记录。我们的应用程序可能会向一些外部系统发送消息进行分析等。其次，这些特殊服务通常由支持工程师(SREs)使用，他们可能不知道系统的内部，即使他们知道，他们也可能不了解系统的最新变化。我们系统中的操作越复杂，如果手工操作就越容易出错。</p><h1 id="5c08" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">操作问题</h1><p id="01c3" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">与操作相关的问题包括我们部署应用程序的机器故障、网络问题等。我们的基础设施越复杂，手动处理问题就越困难。想象一下，我们的基础架构中有数十或数百个节点，其中一些开始出现故障，几乎不可能一次处理所有节点并解决所有问题。即使是应用程序的简单升级也可能需要数周时间，并且容易出现可能非常严重的错误。</p><p id="6d38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要使用工具来自动化这些过程。从简单的数据库迁移到所有节点的大规模重新部署，我们需要尽可能消除人为干扰。谢天谢地，有很多工具和技术可以帮助我们应对这种情况。我们应该使用CI/CDs工具和实践来自动化应用程序的部署。将处理基础设施部署和管理的痛苦委托给Kubernetes等工具，通过使用蓝/绿部署等技术减少部署的停机时间，使用ELK或New Relic等工具跟踪系统中发生的一切。</p><p id="f751" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，对于我们的情况来说，其中一些工具可能过于复杂或昂贵，我们可以考虑创建自己的工具。在我们开始构建自己的工具之前，有一些事情我们应该考虑。首先，这些工具构建起来非常复杂。它们已经在生产中发展了几年，创造它们的人是这个领域的专家。其次，大多数开发定制工具的尝试都是这样结束的:有一个工具只有少数人知道它是如何工作的，但是它已经过时了，但是这些人被其他任务压得喘不过气来，他们没有时间去维护这个工具。由于它的重要性和缺乏文档，新人们害怕接触这个工具。因此，我们系统生命周期的关键部分依赖于一些没有能力的人。</p><p id="dff7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对操作问题的建议很简单。除非这类工具的开发会给你带来一些竞争优势，否则就使用标准工具并雇佣一些开发人员。不要冒险尝试重新发明轮子，以免被淘汰出局。这就是现在的工作方式。</p><h1 id="a9ef" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">从你的错误中学习</h1><p id="58e1" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">积极主动意味着开发防止错误发生的流程和实践，但总会有我们以前没有面对过的新情况。我认为这些情况很有价值，因为我可以从中学习。在这种情况下，我们需要积极应对，接受失败，并在失败发生时制定计划。</p><h1 id="0e16" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">按性质分类</h1><p id="0aea" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">一旦报告了一个错误，我们必须能够评估它的重要性和影响。错误的严重程度各不相同。它们只会在极少数情况下出现，它们会影响特定用户，或者会导致整个服务崩溃。</p><h1 id="4828" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">充当故障检修员</h1><p id="2949" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">好的系统在设计上是可调试的。可调试意味着任何(支持)工程师都应该拥有检查系统健康和状态所需的工具。这可以是日志、仪表板或调试API(微服务架构还应该关联请求，以便可以端到端地跟踪它们)。当你试图理解一个问题时，日志是非常重要的。我们需要确保开发人员正确使用不同的日志级别(错误、警告、信息等)。)并提供关于发生了什么以及为什么发生的有用见解。仅仅记录堆栈跟踪是不够的。服务器和框架暴露了内存/CPU、请求数量、延迟等指标。我们还应该提供关于我们系统的各种关键过程的调试仪表板或API。如果我们有一个必须定期运行的预定的关键作业，那么我们应该提供一个调试API，至少提供正在运行的作业的成功/失败比率和进度。</p><h1 id="5f8b" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">死后和历史</h1><p id="0e39" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我们应该努力为我们在生产中遇到的每个错误报告创建测试。拥有一个自动化测试套件是一个积极主动的过程，并且确保bug不会再次出现(除非套件有一些偷偷摸摸的<a class="ae ka" href="https://hackernoon.com/flaky-tests-a-war-that-never-ends-9aa32fdef359" rel="noopener ugc nofollow" target="_blank">古怪的测试</a>)。此外，写(<a class="ae ka" href="https://landing.google.com/sre/book/chapters/postmortem.html" rel="noopener ugc nofollow" target="_blank">事后</a>)关于已经发生的事件的报告将帮助我们更详细地理解问题，为什么和如何发生。</p><p id="3524" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当问题出现时，我们应该尽最大努力找出其根源，并防止它再次发生。拥有一个不时因为我们无法理解的原因而失败的系统是一场噩梦。</p><p id="4fbb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">念着<em class="kb">“释放它！:设计和部署生产就绪软件(务实的程序员)”</em>作者Michael T. Nygard，你会了解有多少不同的看似无辜的事情会让我们的系统瘫痪。阅读关于他们如何处理问题的工程博客。研究类似的系统。借鉴别人的经验！</p><h1 id="69cc" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">监控您的系统</h1><p id="b9f9" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">正如前面提到的，有很多工具可以监控我们的系统。我们可以看到尖峰工作负载如何给基础架构带来压力，当我们达到某些资源的极限时会发出警报，或者在我们的应用程序日志上有一些聚合视图。</p><p id="b25d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们应该始终关注这些监控工具，因为它们可以显示未来问题的迹象。例如，如果由于某种原因数据库过载，但工作负载正常，这可能表明即将出现问题。</p><p id="b868" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些监控工具的数据应该用来驱动我们系统行为的文档化。</p><p id="6bea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们必须知道我们系统的容量是多少，它在特定配置中的表现如何，以及系统的限制和问题。</p><h1 id="40ba" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">结论</h1><p id="0ab6" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">无论我们做什么，生产中总会出现问题。这是我们不得不接受的事实。我们唯一能做的就是教育自己将问题的风险降到最低，并以专业的态度对待系统。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><blockquote class="ll"><p id="6f66" class="lm ln hu bd lo lp lq lr ls lt lu jz ek translated">"愿询问源源不断，而传呼机保持沉默."</p><p id="aaa6" class="lm ln hu bd lo lp lv lw lx ly lz jz ek translated">—传统的SRE祝福</p></blockquote></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><h1 id="4116" class="kc kd hu bd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz dt translated">进一步阅读</h1><ol class=""><li id="22c5" class="mm mn hu je b jf la jj lb jn mo jr mp jv mq jz mr ms mt mu dt translated"><a class="ae ka" href="https://www.amazon.com/Release-Production-Ready-Software-Pragmatic-Programmers/dp/0978739213" rel="noopener ugc nofollow" target="_blank">发布吧！:设计和部署生产就绪软件(务实的程序员)</a>由<em class="kb">迈克尔·t·尼加德</em></li><li id="8cc6" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><a class="ae ka" href="https://landing.google.com/sre/book.html" rel="noopener ugc nofollow" target="_blank">网站可靠性工程:谷歌如何运行生产系统</a>作者<em class="kb">贝齐·拜尔、克里斯·琼斯、詹妮弗·佩托夫</em>和<em class="kb">尼尔·理查德·墨菲</em></li><li id="9def" class="mm mn hu je b jf mv jj mw jn mx jr my jv mz jz mr ms mt mu dt translated"><a class="ae ka" href="https://landing.google.com/sre/book/chapters/postmortem.html" rel="noopener ugc nofollow" target="_blank">死后示例</a></li></ol></div></div>    
</body>
</html>