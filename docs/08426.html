<html>
<head>
<title>Deploying frontend applications — the fun way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署前端应用程序—有趣的方式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deploying-frontend-applications-the-fun-way-bc3f69e15331?source=collection_archive---------0-----------------------#2018-10-09">https://medium.com/hackernoon/deploying-frontend-applications-the-fun-way-bc3f69e15331?source=collection_archive---------0-----------------------#2018-10-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/efe65c6b344453ac06f12ff113068b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HE8CErTHdA05ap52yqxbOQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Word cloud with DevOps and FrontEnd technologies</figcaption></figure><p id="da7f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这篇文章中，我将告诉你我如何使用GitHub、Jenkins、Docker和<a class="ae ke" href="https://m.do.co/c/4dc4ded1ea2f" rel="noopener ugc nofollow" target="_blank"> Digital Ocean </a>部署我的前端应用程序。<a class="ae ke" href="https://stackoverflow.com/questions/49472695/how-to-run-container-in-a-remote-docker-host-with-jenkins" rel="noopener ugc nofollow" target="_blank">在我的学习旅程中，我有一些疑问</a>，所以我决定把我所学到的贴在这个帖子上，作为一个自我记录。</p><p id="4e8e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">注意:</strong>这篇文章不是为你我的朋友，专家和顾问大师15年以上exp DevOps建筑师；这是为我们这些刚刚开始发现CI/CD技术之美的人准备的。本帖可能包含一些不良做法，请半信半疑。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="c2b6" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">废话少说，把TL射我；速度三角形定位法(dead reckoning)</h1><p id="a278" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">你和我一样，四处找子弹，然后离开。这是TL。为你博士:</p><blockquote class="lp lq lr"><p id="5fe2" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">1.启动安装了Docker的2台服务器:构建和生产服务器</p><p id="fd91" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">2.在您的构建服务器中安装Jenkins(或任何其他CI)</p><p id="d526" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">3.在您的CI中创建一个任务，在docker映像中克隆、安装和构建您的项目<strong class="ji hv"/></p><p id="c436" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">4.在GitHub中设置webhooks，在每次推送时触发作业</p><p id="a2f6" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">5.将docker映像推送到您的个人Docker Hub</p><p id="d738" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">6.SSH到您的生产服务器</p><p id="4bbb" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">7.从Docker Hub中提取映像并运行容器</p><p id="0aad" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">8.利润</p></blockquote><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lw"><img src="../Images/910e52c72132ea9572844f79a2d33f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T6i6rIASG-lujJuC_Ivu2w.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Docker based continuous deployment workflow</figcaption></figure><p id="cb6a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">感谢阅读。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><p id="37d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">希望我引起了你的注意，你现在想要更多的细节。在下面的段落中，我将概述我的思考过程，并解释我的部署管道是如何工作的。我不会深入讨论技术细节，而是会提供一些有用的链接供你进一步研究。</p><h1 id="4e3f" class="km kn hu bd ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf mf lh li lj dt translated">问题是</h1><p id="9494" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">简单:我在Angular中开发了一个<a class="ae ke" href="https://github.com/caroso1222/ast-viewer" rel="noopener ugc nofollow" target="_blank"> TypeScript AST交互式查看器</a>，我想部署它。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/3013fb7dd3d656e36d2de645b4950921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pVi41c1uXwh4PYd3S0YC3g.gif"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae ke" href="https://ast.carlosroso.com/" rel="noopener ugc nofollow" target="_blank">TypeScript AST Interactive Viewer</a></figcaption></figure><p id="5346" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ls"> Bu…但是，为什么不用Firebase，Google Engine，vanilla FTP，GH pages呢？你可能会问，就像“一键部署”一样。所有这些工具都很棒，但大多数要么太贵，要么感觉太神奇(没有什么比“gcloud app deploy”更好)，而且<strong class="ji hv">学起来并不那么有趣</strong>！我希望了解、自动化并完全控制整个部署流程。我想要挑战，我想要学习，我想要享受乐趣(见鬼，我很有灵感)。</em></p><h2 id="2858" class="mh kn hu bd ko mi mj mk ks ml mm mn kw jr mo mp la jv mq mr le jz ms mt li mu dt translated">归根结底是什么</h2><p id="1d55" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">我设置了自己的挑战，看起来像这样:</p><ol class=""><li id="afe7" class="mv mw hu ji b jj jk jn jo jr mx jv my jz mz kd na nb nc nd dt translated">我想推送代码并让它自动部署——也就是持续交付。</li><li id="62c5" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">我想支付一个便宜的托管服务</li></ol><p id="1edc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们在黑盒图中画出这些非功能性需求:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/7f9ebbbeb8f52f5b8bdb8737d3dae34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*imyfQi6O0bSnkBWmBMi6Iw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Problem illustration. From GitHub to Live App. Icon: magic by ✦ Shmidt Sergey ✦ from the Noun Project</figcaption></figure><h1 id="0c4b" class="km kn hu bd ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf mf lh li lj dt translated">解开魔盒</h1><p id="fa63" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">我将这一章分成三个部分。每一部分将展示我的魔法盒的一小部分:</p><ol class=""><li id="426f" class="mv mw hu ji b jj jk jn jo jr mx jv my jz mz kd na nb nc nd dt translated">从GitHub到Magic</li><li id="1533" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">发展魔法</li><li id="50e9" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">从魔术到直播App</li></ol></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h2 id="62aa" class="mh kn hu bd ko mi mj mk ks ml mm mn kw jr mo mp la jv mq mr le jz ms mt li mu dt translated">1.从GitHub到Magic</h2><p id="5aef" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">推送代码，坐着休息，刷新直播app，盈利。这就是我想要的。</p><p id="89bc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">选择我的VPS(虚拟专用服务器)</em> </strong></p><p id="9ce7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">第一步是建立一个服务器，它可以从GitHub获取我的代码并执行一系列命令(<em class="ls">NPM I&amp;&amp;NPM run build</em>)。不太清楚下一步该做什么，但我知道我必须从那里开始。</p><p id="2006" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在阅读了最好的VPS提供商之后，我最终选择了<a class="ae ke" href="https://m.do.co/c/4dc4ded1ea2f" rel="noopener ugc nofollow" target="_blank">数字海洋</a>。很棒的教程，对新手来说很容易，体面的DNS管理和不错的价格——这是显而易见的。</p><p id="5d0e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls"> CI工具无处不在</em> </strong></p><p id="8d1c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">注册后，我知道我需要某种工具，让我获取代码并自动化构建过程——CI工具<em class="ls">(持续集成)</em>。已经有几个了，其中一些是针对开源项目的，一些主要是为自我托管而设计的，一些是高级的，一些是免费的。我选择Jenkins主要是因为它的管道概念，也因为我对这个工具有些熟悉。</p><p id="0fd2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通过阅读一些教程，让我的Jenkins实例运行起来相对容易。现在，我需要告诉詹金斯，每当我按下按钮时，就获取我的代码。原来有几十个帖子在讨论如何设置GitHub webhook，从你的repo指向你的Jenkins Droplet IP。设置这个比我预期的要快(虽然对于私有的GitHub repos来说不是很简单)。</p><p id="81b6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">我们来回顾一下</em> </strong></p><p id="8bbb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此时，我有一个DO droplet运行Linux，Jenkins实例在每次git推送时从GitHub提取代码。多酷啊。让我们看看我们的魔盒是如何开始显现的:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/f32b87a4a767ebd59eed4b7d15a900b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*3LI8drY9sq0GHcbKZe8JCg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Black box diagram with Digital Ocean Droplet and Jenkins</figcaption></figure><p id="6137" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">有用链接:</em> </strong></p><ol class=""><li id="869a" class="mv mw hu ji b jj jk jn jo jr mx jv my jz mz kd na nb nc nd dt translated"><a class="ae ke" href="https://www.digitalocean.com/docs/droplets/how-to/create/" rel="noopener ugc nofollow" target="_blank">如何在数字海洋中创建一个水滴</a>。</li><li id="68bc" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated"><a class="ae ke" href="https://www.digitalocean.com/community/tutorials/how-to-install-jenkins-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">如何在一个DO滴里安装詹金斯</a>。</li><li id="1984" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated"><a class="ae ke" href="https://jenkins.io/doc/book/pipeline/" rel="noopener ugc nofollow" target="_blank">如何设置和詹金斯的管道</a>。</li><li id="7cca" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated"><a class="ae ke" href="https://www.digitalocean.com/community/tutorials/how-to-set-up-continuous-integration-pipelines-in-jenkins-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">如何整合GitHub和Jenkins </a>。</li></ol></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h2 id="cb74" class="mh kn hu bd ko mi mj mk ks ml mm mn kw jr mo mp la jv mq mr le jz ms mt li mu dt translated">2.发展魔法</h2><p id="7571" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">在接下来的几段中，我将开发我的策略的核心，利用Docker和DO droplets。让我们开始吧。</p><p id="1065" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">把所有的事情都归档</em> </strong></p><p id="b488" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此时，我有了一个<em class="ls"> dist </em>文件夹，其中有一个【index.html】和的<em class="ls">依赖项，准备好了。我知道我需要启动一个网络服务器来通过网络提供这些文件。然后让我们在同一个服务器上安装<em class="ls"> nginx </em>(或者<em class="ls"> Apache </em>)并提供服务。我还需要安装节点和几个全局节点包。简单，让我们开始吧…</em></p><blockquote class="lp lq lr"><p id="3b01" class="jg jh ls ji b jj jk jl jm jn jo jp jq lt js jt ju lu jw jx jy lv ka kb kc kd hn dt translated">“但是，等等，Carlos，嗯……这感觉不像是正确的做法—你最终会在服务器上安装一大堆东西，管理你的依赖项将是一个地狱……只是说“<em class="hu"> —内在自我</em></p></blockquote><p id="66be" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">事实上，我需要一种方法来封装依赖项、dist工件甚至web服务器，这样它就不会搞乱我的服务器。让我们使用<strong class="ji hv"> Docker </strong>。它可以让我用运行在我的服务器端口上的web服务器构建一个映像，而我的服务器文件系统几乎不会注意到我刚才做了什么。多酷啊。</p><p id="33b7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我为我的应用程序设置了一个<a class="ae ke" href="https://github.com/caroso1222/ast-viewer/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>，并在Jenkins中编辑了这个作业，以构建一个docker映像并运行暴露了80端口的容器。它非常有效。我可以从<em class="ls"> http://my.server.ip </em>访问我的应用程序。</p><p id="2667" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">关于缩放和填充</em> </strong></p><p id="cdf1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我计划使用相同的服务器，用相同的模式部署许多应用程序。在同一个服务器上运行Jenkins和我所有的容器是没有意义的。我只是觉得我可以做得更好——我想把关注点分开。当然，我可以应付不同的用户，让Jenkins生活在自己的用户中，等等，但是我真的想拥有一台专门用于构建我的应用程序的机器。</p><p id="96c9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">基于这个前提，我创建了另一个droplet ( <em class="ls"> aka server </em>)，它具有更少的内存(没有繁重的工作，只是为了服务webapps)，并且安装了Docker，因为它应该能够运行Docker容器。然后我会在这个服务器上运行我所有的应用程序。这将使我可以很好地伸缩，因为我可以很容易地改变我的构建服务器上的内存分配，而不影响我的应用程序。</p><p id="e4bb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">我们来回顾一下</em> </strong></p><p id="2f8e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们已经取得了相当大的进步。我们已经满足于将Docker作为我们的核心构建机制，并且我们还决定通过在另一个服务器中构建一个独立的产品服务器来分离关注点，以利于可维护性。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/6edf483d877702af6420839289fbf330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RrbIviKsUwOb10BqXsGyA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Deployment workflow with Docker and 2 DO droplets</figcaption></figure><p id="6449" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">有用链接:</em> </strong></p><ol class=""><li id="5afc" class="mv mw hu ji b jj jk jn jo jr mx jv my jz mz kd na nb nc nd dt translated">如何对接<a class="ae ke" rel="noopener" href="/@tiangolo/angular-in-docker-with-nginx-supporting-environments-built-with-multi-stage-docker-builds-bb9f1724e984">角度</a>、<a class="ae ke" rel="noopener" href="/ai2-blog/dockerizing-a-react-application-3563688a2378">反应</a>和<a class="ae ke" href="https://vuejs.org/v2/cookbook/dockerize-vuejs-app.html" rel="noopener ugc nofollow" target="_blank"> Vue </a>应用？</li><li id="1ccb" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated"><a class="ae ke" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04" rel="noopener ugc nofollow" target="_blank">如何在Ubuntu中安装Docker</a>。</li></ol></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h2 id="9c09" class="mh kn hu bd ko mi mj mk ks ml mm mn kw jr mo mp la jv mq mr le jz ms mt li mu dt translated">3.从魔术到直播App</h2><p id="8f07" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">我不确定如何集成我的服务器(构建+生产)。在<a class="ae ke" href="https://stackoverflow.com/questions/49472695/how-to-run-container-in-a-remote-docker-host-with-jenkins" rel="noopener ugc nofollow" target="_blank">寻求帮助</a>和研究之后，我得出结论，对于我的特定用例，我可以实现以下工作流:</p><ol class=""><li id="a61d" class="mv mw hu ji b jj jk jn jo jr mx jv my jz mz kd na nb nc nd dt translated">在<em class="ls">构建服务器</em>中构建docker镜像</li><li id="8a25" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">将docker图像推送到我的<em class="ls"> Docker Hub </em></li><li id="6a84" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">通过SSH登录到我的生产服务器</li><li id="c6e5" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">从<em class="ls"> Docker Hub </em>中拉出图像并运行容器</li></ol><p id="bb58" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是有意义的，因为我不必求助于使用docker-machine或kubernetes这样的工具来编排我的服务器。<em class="ls">很好用，</em>很简单，对我来说看起来足够干净。</p><p id="c4d3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ls">关于安全性的注意事项:</em>建议在您的生产服务器上禁用基于密码的认证，而仅从您的构建服务器启用<a class="ae ke" href="https://hostpresto.com/community/tutorials/how-to-enable-key-based-authentication-for-ssh-on-your-linux-server/" rel="noopener ugc nofollow" target="_blank">基于密钥的认证。也就是说，如果不是从您的构建服务器登录到您的生产服务器，实际上是不可能的。</a></p><p id="6315" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">给我看一些代码</em> </strong></p><p id="48f3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在你展示一些代码之前，一篇技术文章不是一篇技术文章。让我们看看整合整体时，CI中的Jenkins管道是什么样的:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nm"><img src="../Images/595fb394d9ad7eaeed4d7ea9509bcc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sxfmc-ggSPTcFf4deOVMDw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Jenkins Scripted Pipeline. Visit <a class="ae ke" href="https://gist.github.com/caroso1222/e2fcd6fd274d82d91334ebe6e4ce0586" rel="noopener ugc nofollow" target="_blank">gist here</a>.</figcaption></figure><p id="21fc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我在代码片段中标记了一些行，让我们快速浏览一下:</p><ol class=""><li id="c7d9" class="mv mw hu ji b jj jk jn jo jr mx jv my jz mz kd na nb nc nd dt translated">基于<a class="ae ke" href="https://github.com/caroso1222/ast-viewer/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">docker文件</a>构建docker映像。</li><li id="be60" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">将docker图片推送至我的<em class="ls"> Docker Hub </em>账户。</li><li id="fadc" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">SSH到生产服务器</li><li id="4e99" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">从我的Docker Hub <em class="ls">中提取图像。</em></li><li id="cc73" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated">运行我们刚提取的图像中的容器。我在端口8080上运行容器，但这是因为我设置nginx通过子域<em class="ls"> proxy_pass </em>将流量路由到同一个服务器中的几个容器(例如，domainA.com服务容器A，domainB.com服务容器B)。我不会详细阐述这种技术，因为它超出了本文的范围。</li></ol><p id="6e72" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如本文开头所述，这条管道运行在master中的每一个<em class="ls"> git推送</em>上。下图显示了每次部署在Jenkins上发生的情况。顺便说一句，<strong class="ji hv">我喜欢这张图片，因为它描绘了潜水前我脑海中的挑战。</strong></p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/22f6a5dea68bf042947315b2bbb5b13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNxe3JwGouNbCpyIItYX4g.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Stage view of the Jenkins pipeline. Each line represents a deployment triggered by a git push.</figcaption></figure><p id="0991" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">让我们总结一下</em> </strong></p><p id="d6e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们终于成功了。我们已经解开了我们的黑盒。每一个秘密已经被揭露，我们已经能够覆盖它的每一个组成部分。<strong class="ji hv">现在让我们来看看我们最终的部署工作流程是什么样的！</strong></p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nl"><img src="../Images/b1a4b6a0d8a24eef6c5714a2a6e11252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-n1GvBiN7_luWjXLwdVVzQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Diagram of the full deployment strategy covered in this post. A Docker image is built in the build server, goes through the Docker Hub and finally made it to the production server.</figcaption></figure><p id="37c6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="ls">有用链接</em> </strong></p><ol class=""><li id="c5b2" class="mv mw hu ji b jj jk jn jo jr mx jv my jz mz kd na nb nc nd dt translated"><a class="ae ke" href="https://hostpresto.com/community/tutorials/how-to-enable-key-based-authentication-for-ssh-on-your-linux-server/" rel="noopener ugc nofollow" target="_blank">在Ubuntu中启用基于密钥的认证</a>。</li><li id="636c" class="mv mw hu ji b jj ne jn nf jr ng jv nh jz ni kd na nb nc nd dt translated"><a class="ae ke" href="https://medium.freecodecamp.org/expose-vs-publish-docker-port-commands-explained-simply-434593dbc9a3" rel="noopener ugc nofollow" target="_blank">运行Docker容器并暴露端口</a>。</li></ol></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="df57" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">结论</h1><p id="e0b8" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">有大量的部署策略，每一种都有其优点和缺点，每一种都依赖于不同的堆栈，各有各的特色。这就是它的美妙之处。在本文中，我只介绍了这些策略中的一种，它允许我使用两个服务器(CI和Docker)来完全控制我的定制部署管道。</p><p id="d564" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你不太熟悉我们介绍的概念，这听起来可能会让人望而生畏。我说，不要害怕。这是一篇很长的帖子，主要是因为它总结了一个跨越近3个月的学习之旅，每天晚上花1-2个小时研究这些服务器并阅读我不太熟悉的内容。</p><p id="9e13" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">即使你是一个专注于浏览器领域的前端开发人员，我仍然认为你熟悉整个堆栈是非常有价值的。当你在公司讨论DevOps的事情时，它会给你一些工具来进行一个可靠的对话并形成一个观点。最好说<em class="ls">“你们是专家，但这是我对此事的看法……”</em>而不是说“<em class="ls">嗯，那不是我的事，你们运营部门的人自己解决吧”。</em></p><p id="90e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我希望您能从中获得一些灵感，继续实施您的个人部署管道，并了解所有这些DevOps技术——未来会有很多乐趣！</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="50f4" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">无耻的自我推销</h1><p id="9419" class="pw-post-body-paragraph jg jh hu ji b jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd hn dt translated">我不是一个业余的SoundCloud说唱歌手，也没有在Patreon寻找资金。我只是想让你看看我的其他帖子，比如<a class="ae ke" href="https://hackernoon.com/how-to-create-fancy-revealing-animations-with-these-simple-css-tricks-5b34614ae69a" rel="noopener ugc nofollow" target="_blank">这个</a>或者<a class="ae ke" href="https://codeburst.io/how-i-got-accepted-into-the-best-remote-working-platforms-a9250041531f" rel="noopener" target="_blank">这个</a>，也许你可以抓住一两件你喜欢的东西。</p><p id="a9c2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在twitter上找到我，别忘了问好！</p></div></div>    
</body>
</html>