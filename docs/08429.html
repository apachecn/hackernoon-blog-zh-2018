<html>
<head>
<title>Rendering “External Texture”: A Flutter Optimization Story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">渲染“外部纹理”:一个颤振优化的故事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rendering-external-texture-an-flutter-optimization-by-alibaba-c5ed143af747?source=collection_archive---------3-----------------------#2018-10-09">https://medium.com/hackernoon/rendering-external-texture-an-flutter-optimization-by-alibaba-c5ed143af747?source=collection_archive---------3-----------------------#2018-10-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3586" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">优化开源SDK Flutter处理Android和iOS应用外部纹理的方式</em></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/68293d7dc380ba45e41c540dcbb8b505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6V0zxof1-xUBKpBSDoXR_w.png"/></div></div></figure><p id="5e4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">本文是阿里巴巴</em> <a class="ae kc" rel="noopener" href="/@alitech_2017/utilizing-flutter-best-practice-from-alibaba-236a53aa32c8"> <strong class="it hv"> <em class="jp">利用旋舞</em> </strong> </a> <em class="jp">系列的一部分。</em></p><p id="c5c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">In computing, as in much of life, any given method can see a lot of use before its latent flaws reach a decisive impasse. For Alibaba, discovering one such flaw in software development kit Flutter meant the difference between success and failure in the group’s recent work on a mobile app for its Xianyu(闲鱼) second-hand trading platform.</p><p id="e3da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，阿里巴巴团队已经成功优化了Flutter，用于仙游市场特有的一系列新用途，为整个UI渲染过程实施了OpenGL流程，以减少CPU和GPU资源开销。</p><p id="2541" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在今天的文章中，我们在详细了解Flutter的内部工作和“外部纹理”的同时，还将关注该团队的优化工作，技术观众可以在自己的工作中探索这些细节。</p><h1 id="62a9" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">颤振渲染框架</h1><p id="b955" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Flutter渲染框架被组织成一系列的层，每一层都建立在前一层之上。颤振渲染框架的架构设计如下所示:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lg"><img src="../Images/301aaeb4329a27c5ef20b77563d8cc6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olqkEHVdiDNo4yUgr381nA.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">The Flutter rendering framework, by layer</figcaption></figure><p id="aab0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.<strong class="it hv">图层树</strong>:渲染管道是Dart API在运行时输出的树状结构。树上的每个叶节点代表一个界面元素，比如按钮、图像等等。</p><p id="7cc2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv"> Skia </strong>:由Google发起并管理的跨平台渲染框架。它充当iOS/Android应用程序的图形引擎。Skia的底层被称为OpenGL绘图。Vulkan支持非常有限，金属不提供支持。</p><p id="618b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<strong class="it hv"> Shell </strong>:平台特性，包括iOS/Android平台实现、EAGLContext管理、在屏幕上返回数据以及外部纹理实现。</p><p id="7e93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">布局过程在Dart运行时执行，并输出一个层树。在流水线中遍历层树的每个叶节点，以调用Skia引擎来完成界面元素的绘制。</p><p id="7fd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完成上述过程后，执行以下操作:</p><p id="0d21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.iOS: <strong class="it hv"> </strong>运行<strong class="it hv"> glPresentRenderBuffer </strong>命令在屏幕上显示渲染缓冲区的内容。<br/> Android:运行<strong class="it hv"> glSwapBuffer </strong>命令对当前窗口使用的层执行缓冲交换。</p><p id="4c16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.单击完整的屏幕显示链接。</p><p id="4e0a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基于这个原理，Flutter可以在Native和Flutter引擎上实现UI隔离。它还捕获UI代码，而不分析跨平台解决方案上的平台实现。</p><h1 id="d92f" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">实施问题</h1><p id="7f94" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这种实现有优点也有缺点。Flutter和Native是隔离的，有时候会让人觉得有一座大山把Flutter Engine和Native隔开。当Flutter想要捕获本机端的高内存图像，如相机帧、视频帧、相册图像等时，这就带来了问题。</p><p id="073e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">传统应用程序(RN、Weex等)可以通过桥接NativeAPI直接获取这些数据。同时，Flutter根据定义的通道机制决定是否可以直接捕获数据并发送通知消息，在传输数据的同时不可避免地导致巨大的内存使用和CPU占用。</p><h1 id="5b15" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">用外部纹理弥合差距</h1><p id="362b" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">颤动提供了一种称为外部纹理的特殊机制。请注意，纹理是可以应用于颤振视图区域的图像。它们使用特定于平台的纹理注册表来创建、管理和更新。这通常是通过与主机平台视频播放器、相机或OpenGL APIs或类似图像源集成的插件来完成的。</p><p id="c11e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">LayerTree的架构图如下所示:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ll"><img src="../Images/c133f031ec1fc74bcf1cf9a57b0d77d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8noeUsFldevNzWrSmGeX0g.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">LayerTree architecture</figcaption></figure><p id="9bab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个叶节点代表一个dart代码布局控件。末端的TextureLayer节点对应于Flutter中的纹理控制。当在Flutter中创建一个纹理控件时，它表示这个控件上显示的数据需要由Native提供。注意这个纹理和GPU的纹理不一样。这是为了颤振的控制。</p><p id="8890" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是iOS平台上TextureLayer节点的最终绘制代码。Android平台的代码类似，但是它获取纹理的方法略有不同。</p><p id="2132" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">建议按照以下三个步骤运行代码:</p><p id="1369" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.调用外部纹理的copyPixelBuffer函数来获取CVPixelBuffer</p><p id="12c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.创建OpenGL ES纹理—CVOpenGLESTextureCacheCreateTextureFromImage</p><p id="b7d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.将OpenGL ES纹理捕获到SKImage中，调用Skia的DrawImage函数完成绘制。</p><pre class="jr js jt ju fq lm ln lo lp aw lq dt"><span id="fc8d" class="lr ke hu ln b fv ls lt l lu lv">void IOSExternalTextureGL::Paint(SkCanvas&amp; canvas, const SkRect&amp; bounds) {<br/>  if (!cache_ref_) {<br/>    CVOpenGLESTextureCacheRef cache;<br/>    CVReturn err = CVOpenGLESTextureCacheCreate(kCFAllocatorDefault, NULL,<br/>                                                [EAGLContext currentContext], NULL, &amp;cache);<br/>    if (err == noErr) {<br/>      cache_ref_.Reset(cache);<br/>    } else {<br/>      FXL_LOG(WARNING) &lt;&lt; "Failed to create GLES texture cache: " &lt;&lt; err;<br/>      return;<br/>    }<br/>  }<br/>  fml::CFRef&lt;CVPixelBufferRef&gt; bufferRef;<br/>  bufferRef.Reset([external_texture_ copyPixelBuffer]);<br/>  if (bufferRef != nullptr) {<br/>    CVOpenGLESTextureRef texture;<br/>    CVReturn err = CVOpenGLESTextureCacheCreateTextureFromImage(<br/>        kCFAllocatorDefault, cache_ref_, bufferRef, nullptr, GL_TEXTURE_2D, GL_RGBA,<br/>        static_cast&lt;int&gt;(CVPixelBufferGetWidth(bufferRef)),<br/>        static_cast&lt;int&gt;(CVPixelBufferGetHeight(bufferRef)), GL_BGRA, GL_UNSIGNED_BYTE, 0,<br/>        &amp;texture);<br/>    texture_ref_.Reset(texture);<br/>    if (err != noErr) {<br/>      FXL_LOG(WARNING) &lt;&lt; "Could not create texture from pixel buffer: " &lt;&lt; err;<br/>      return;<br/>    }<br/>  }<br/>  if (!texture_ref_) {<br/>    return;<br/>  }<br/>  GrGLTextureInfo textureInfo = {CVOpenGLESTextureGetTarget(texture_ref_),<br/>                                 CVOpenGLESTextureGetName(texture_ref_), GL_RGBA8_OES};<br/>  GrBackendTexture backendTexture(bounds.width(), bounds.height(), GrMipMapped::kNo, textureInfo);<br/>  sk_sp&lt;SkImage&gt; image =<br/>      SkImage::MakeFromTexture(canvas.getGrContext(), backendTexture, kTopLeft_GrSurfaceOrigin,<br/>                               kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr);<br/>  if (image) {<br/>    canvas.drawImage(image, bounds.x(), bounds.y());<br/>  }<br/>}</span></pre><p id="df93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">external_texture_object从哪里来？在本机端调用RegisterExternalTexture之前，创建一个用于实现FlutterTexture协议的对象，该对象被分配给external_texture对象。外部纹理是Flutter和Native之间的桥梁，用于连续获取要显示的图像数据。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lw"><img src="../Images/6df6265f7d4e4809713fae46d80fe05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3GvGjCJcs3QBOPzIXQ0iw.png"/></div></div></figure><p id="455a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如图，PixelBuffer是Flutter和Native在使用外部纹理时传输数据的载体。原生端的数据源(相机、播放器等)将数据传输到PixelBuffer。Flutter取PixelBuffer，转换成OpenGL ES纹理，供Skia完成绘制。</p><p id="e1f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至此，Flutter可以轻松绘制出原生端想要绘制的所有数据。除了动态图像数据(相机播放器)之外，图像的显示提供了图像控件之外的另一种可能，特别是对于原生端，当有像SDWebImage这样的大规模图像加载库时。当需要在Flutter端用dart写副本时，这个过程非常费时费力。</p><h1 id="94be" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">优化处理速度</h1><p id="9c43" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">上面描述的整个过程似乎解决了Flutter显示原生端大数据的问题，但它有以下限制:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lx"><img src="../Images/0125378bc7a123d9c83ff81768c06cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fdth8yqf_hHSGYwaw2i4g.png"/></div></div></figure><p id="7fc9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如上图所示，视频图像数据处理一般采用原生端的GPU处理来提升性能。copyPixelBuffer接口由Flutter侧定义。整个数据流经过GPU &gt; CPU &gt; GPU进程。请注意，CPU和GPU之间的内存交换是所有操作中最耗时的。一次往返通常比整个管道的处理时间更长。</p><p id="f010" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Skia渲染引擎需要GPU纹理，原生数据处理输出是GPU纹理。这个GPU纹理可以直接使用EAGLContext的共享资源。EAGLContext对象管理OpenGL ES渲染上下文，即使用OpenGL ES进行绘制所需的状态信息、命令和资源。</p><p id="6b0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">颤振的螺纹结构介绍如下:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ly"><img src="../Images/7db2ffd66867f8b165982e1469f30eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Taz0EB-t4cSwNEXvjk1BVg.png"/></div></div></figure><p id="fb3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">颤动通常产生4个跑步者。TaskRunner就像iOS的大中央调度(GCD)。它是一种在队列中执行任务的机制。通常，TaskRunner与一个线程通信，而Platform Runner运行在主线程上。</p><p id="a794" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下3个任务运行者与本文相关:</p><p id="de13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.<strong class="it hv"> GPU TaskRunner </strong>:负责GPU渲染相关操作。</p><p id="e044" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv"> IO TaskRunner </strong>:负责资源的加载。</p><p id="756a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<strong class="it hv">平台TaskRunner </strong>:负责本机和颤振引擎之间的所有交换，并在主线程上运行。</p><p id="74cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，使用OpenGL的应用程序线程设计会有两个线程——一个线程用于加载资源(从图像到纹理)，另一个线程用于渲染。但是，通常情况下，为了使load线程创建的纹理能够在render线程中使用，这两个线程共享一个EAGLContext。这不是标准做法，因为不安全。用锁多线程访问同一个对象必然会影响性能。代码处理不好甚至会造成死锁。</p><p id="9b63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了避免这个问题，Flutter为EAGLContext的使用提供了一种新的机制——每个线程都使用自己的EAGLContext，并通过iOS应用的ShareGroup和Android应用的shareContext共享纹理数据。</p><p id="fd7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(虽然两个上下文的用户分别是GPU和IO Runner，但是现有的Flutter逻辑的两个上下文都是在Platform Runner下创建的。Flutter设计的这一方面相当令人困惑，并且会产生各种各样的问题，但是这些都超出了本文的范围。)</p><p id="1ebd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于在本机端使用OpenGL的模块，这也创建了一个对应于它自己的线程的上下文。要将在此上下文下创建的纹理交付给Flutter，并将此数据发送给Skia以完成绘制，请在Flutter中创建两个内部上下文时公开iOS应用程序的ShareGroup，然后在本机端保存ShareGroup。当本机创建上下文时，它也将使用此共享组来创建它。这样Native和Flutter就可以共享纹理了。</p><p id="7972" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是使用external_texture的两个好处:</p><p id="2f59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.<strong class="it hv">减少计算时间</strong> <br/>阿里巴巴的测试得出结论，一帧720P RGBA格式的视频在Android机型上从GPU读取到CPU大约需要5毫秒，然后再从CPU读取到GPU需要5毫秒。即使引入PBO，也有5ms左右的时间消耗，这对于高帧率场景来说显然是无法接受的。</p><p id="53ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv">减少CPU内存消耗</strong> <br/>正如你可能会直觉到的，数据是在GPU上传递的，尤其是在图片场景中(因为有很多图片要同时显示)。</p><h1 id="e6cc" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">一些旁注</h1><p id="9442" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">既然已经介绍了颤振外部纹理和优化策略的基本原理，本节将讨论这些原理的一些缺点和例外。</p><h2 id="5bb2" class="lr ke hu bd kf lz ma mb kj mc md me kn jc mf mg kr jg mh mi kv jk mj mk kz ml dt translated">Flutter纹理的完整性与Pixelbuffer</h2><p id="73c7" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">许多人在这一点上提出的一个问题是:如果直接使用纹理作为外部纹理就像声称的那样好，那么谷歌为什么要使用Pixelbuffer？</p><p id="db78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果使用Texture，就要公开ShareGroup，也就是说Flutter的GL环境是开放的。如果外部OpenGL不能正常工作，OpenGL对象对CPU来说只是一个数字、一个纹理或一个帧缓冲区，对用户来说是一个GLuint(无符号二进制整数)当断点。如果环境是隔离的，用户可以随心所欲地操作deleteTexture和deleteFrameBuffer，而不会影响其他环境中的对象。否则，这些操作可能会影响颤振环境下的对象。作为一个框架设计者，最重要的是确保框架是一个封闭的环境，以保持其完整性。</p><h2 id="fcbe" class="lr ke hu bd kf lz ma mb kj mc md me kn jc mf mg kr jg mh mi kv jk mj mk kz ml dt translated">故障排除:崩溃</h2><p id="f986" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在开发过程中，团队遇到了一个奇怪的问题:Flutter在渲染过程中会经常崩溃，但没有人能找出原因。</p><p id="a3b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">经过大量搜索，最终确定原因是在主线程没有setCurrentContext时调用了glDeleteFrameBuffer，这意味着Flutter的FrameBuffer被意外删除。如果您选择使用此程序，本机端的相关总账操作应至少遵循以下几点之一:</p><p id="fdd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.尽量不要在主线程上执行GL操作；</p><p id="b630" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.在使用GL操作调用函数之前，始终添加setCurrentContext。</p><h2 id="e8f1" class="lr ke hu bd kf lz ma mb kj mc md me kn jc mf mg kr jg mh mi kv jk mj mk kz ml dt translated">iOS与Android</h2><p id="d937" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">本文的大部分逻辑都是基于iOS的例子。对于Android来说，总体原则是相同的，但实现略有不同。</p><p id="1fc1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Android端的Flutter的外部纹理是通过SurfaceTexture实现的。该机制实际上是从CPU到GPU内存的复制。Android OpenGL中没有ShareGroup这个概念。相反，它使用shareContext，这意味着上下文直接传输出去。</p><p id="e756" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外，Android在Shell层的GL实现是基于C++的，所以Context是C++对象。要与Android原生端的Java Context对象共享这个C++对象，需要在jni层进行如下调用:</p><pre class="jr js jt ju fq lm ln lo lp aw lq dt"><span id="03ce" class="lr ke hu ln b fv ls lt l lu lv">static jobject GetContext(JNIEnv* env,<br/>                          jobject jcaller,<br/>                          jlong shell_holder) {<br/>    jclass eglcontextClassLocal = env-&gt;FindClass("android/opengl/EGLContext");<br/>    jmethodID eglcontextConstructor = env-&gt;GetMethodID(eglcontextClassLocal, "&lt;init&gt;", "(J)V");<br/>    <br/>    void * cxt = ANDROID_SHELL_HOLDER-&gt;GetPlatformView()-&gt;GetContext();<br/>    <br/>    if((EGLContext)cxt == EGL_NO_CONTEXT)<br/>    {<br/>        return env-&gt;NewObject(eglcontextClassLocal, eglcontextConstructor, reinterpret_cast&lt;jlong&gt;(EGL_NO_CONTEXT));<br/>    }<br/>    <br/>    return env-&gt;NewObject(eglcontextClassLocal, eglcontextConstructor, reinterpret_cast&lt;jlong&gt;(cxt));<br/>}</span></pre><p id="b84e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">(Original article by Chen Lujun陈炉军)</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><h1 id="2010" class="kd ke hu bd kf kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae kc" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">“阿里巴巴科技”</strong> </a>。推特:<a class="ae kc" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">【阿里巴巴技术】</strong> </a>。</p></div></div>    
</body>
</html>