<html>
<head>
<title>How We Improved React Native List Performance by 5X</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何改进React原生列表性能(5X)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-improve-react-native-list-performance-5x-times-b299c8a23b5d?source=collection_archive---------1-----------------------#2018-10-10">https://medium.com/hackernoon/how-to-improve-react-native-list-performance-5x-times-b299c8a23b5d?source=collection_archive---------1-----------------------#2018-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b30c78be51d35d61d48db19c4794fc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ar5PzM5ii-OhMuXcheRPaw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/iZp4h1gXiEQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sanjeevan SatheesKumar</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="774d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近，我的团队已经开始开发第一款大型React原生应用。很快，我不得不实现一个带有过滤器列表的页面:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kf"><img src="../Images/0911da193cd274e39afaee93bce30e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjR-SNWy_xV1mGzJs3IZnA.png"/></div></div></figure><h1 id="7e6d" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">问题</h1><p id="9a87" class="pw-post-body-paragraph jh ji hu jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">在页面的初始版本中，单击checkbox元素会导致明显的延迟。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/b485194c6c4ce7fc2f9e73440d8cd2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*qc47w6iM0C0X5DmWdgn4zg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="lo">FlatList[update]</em> takes most of <strong class="bd lp">250ms</strong></figcaption></figure><p id="39e6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">列表中有75个元素，在某一时刻只有11个可见。所以我期望<a class="ae jg" href="https://facebook.github.io/react-native/docs/flatlist" rel="noopener ugc nofollow" target="_blank"> FlatList </a>(它有现成的虚拟化特性)只重新呈现一个改变的元素(在最坏的情况下——只有可见的元素)。但是它<strong class="jj hv">重新渲染所有项目</strong>。</p><p id="6426" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">原来的方法</strong> <br/>显示一个可选的类别列表，我从redux状态中检索<code class="eh lq lr ls lt b">Categories</code>，并创建一个新的数组<code class="eh lq lr ls lt b">extendedCategories</code>，其中包含类别数据和标志<code class="eh lq lr ls lt b">isShown</code>:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lu lv l"/></div></figure><h1 id="42e5" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">解决办法</h1><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/d220d94169f698e3d8213732503ba5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*IemsQTesgCzsSbKfekwkig.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">After the small change, render time went down to <strong class="bd lp">56ms.</strong></figcaption></figure><p id="97bc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了将渲染时间缩短5倍，我不得不停止改变平面列表的数据源，只有当它们发生变化时才重新渲染。</p><ol class=""><li id="4040" class="lx ly hu jj b jk jl jo jp js lz jw ma ka mb ke mc md me mf dt translated">我没有在每次重新呈现后创建新的数据源对象，而是使用现有的<code class="eh lq lr ls lt b">categories</code>数组进行映射。并在<code class="eh lq lr ls lt b">FlatList</code>级别上计算<code class="eh lq lr ls lt b">isShown</code>。现在数据源总是同一个对象，只有当checkbox改变它的值时,<code class="eh lq lr ls lt b">isShown</code> prop才会获得新值。</li></ol><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="05bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.将<code class="eh lq lr ls lt b">PureComponent </code>用于<code class="eh lq lr ls lt b">renderItem</code></p><blockquote class="mg mh mi"><p id="0f2c" class="jh ji mj jj b jk jl jm jn jo jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd ke hn dt translated"><code class="eh lq lr ls lt b">PureComponent</code>类似于<code class="eh lq lr ls lt b">Component</code>。两者的区别在于<code class="eh lq lr ls lt b">Component</code>不实现<code class="eh lq lr ls lt b">shouldComponentUpdate()</code>，而<code class="eh lq lr ls lt b">PureComponent</code>用一个浅层的道具和状态比较来实现。<code class="eh lq lr ls lt b">PureComponent</code>的<code class="eh lq lr ls lt b">shouldComponentUpdate()</code>只是浅浅的比较对象。如果这些包含复杂的数据结构，可能会对更深层次的差异产生假阴性。</p></blockquote><figure class="kg kh ki kj fq iv fe ff paragraph-image"><a href="https://calendly.com/oleg-kalyta/30min"><div class="fe ff mn"><img src="../Images/5491b85ab8a637c82385f2a42e9a9bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8IxRX6KgxGcUIceWUyzbw.png"/></div></a></figure><h1 id="4d30" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">还原状态</h1><ul class=""><li id="8164" class="lx ly hu jj b jk li jo lj js mo jw mp ka mq ke mr md me mf dt translated"><code class="eh lq lr ls lt b">Categories</code> —关于类别的所有元信息的数组</li><li id="5e9a" class="lx ly hu jj b jk ms jo mt js mu jw mv ka mw ke mr md me mf dt translated"><code class="eh lq lr ls lt b">SelectedCategories</code> —仅包含选定类别{id，name}的数组</li></ul><p id="59de" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">点击类别后，添加到<code class="eh lq lr ls lt b">SelectedCategories</code>数组，<code class="eh lq lr ls lt b">Categories</code>对象始终不变，没有突变。如果用户点击一个已经选择的类别，它将从<code class="eh lq lr ls lt b">SelectedCategories</code>数组中删除。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lu lv l"/></div></figure><h1 id="377f" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">压型</h1><p id="728b" class="pw-post-body-paragraph jh ji hu jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">根据我的经验，与React不同，React Native中的额外rerender对用户体验的影响要糟糕得多。寻找额外渲染的最快方法是在渲染函数中使用旧的<code class="eh lq lr ls lt b">console.log</code>。发现问题后，使用开发者工具中的Chrome Profiler选项卡深入研究。或者<a class="ae jg" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html#reading-performance-data" rel="noopener ugc nofollow" target="_blank">新的React Profiler</a>(16.5版即将推出)。</p><p id="193d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想玩代码？查看GitHub回购！</p><div class="mx my fm fo mz na"><a href="https://github.com/ProductCrafters/rn_perf" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab ej"><div class="nc ab nd cl cj ne"><h2 class="bd hv fv z el nf eo ep ng er et ht dt translated">产品制造商/rn_perf</h2><div class="nh l"><h3 class="bd b fv z el nf eo ep ng er et ek translated">在GitHub上创建一个帐户，为ProductCrafters/rn_perf开发做贡献。</h3></div><div class="ni l"><p class="bd b gc z el nf eo ep ng er et ek translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ja na"/></div></div></a></div><p id="1b55" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mj">附:如果你喜欢这篇文章，还想要更多这样的，请拍下</em> <em class="mj">和</em> <strong class="jj hv"> <em class="mj">分享给可能需要的朋友</em> </strong> <em class="mj">。</em></p><p id="8ec3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">🚀<a class="ae jg" href="http://productcrafters.io" rel="noopener ugc nofollow" target="_blank">我的团队</a> <strong class="jj hv">使用JS和React构建生产应用超过3年</strong>。我们帮助初创公司的创始人将他们的想法付诸实践。如果你需要帮助，发消息给✉️<a class="ae jg" href="mailto:oleg@productcrafters.io" rel="noopener ugc nofollow" target="_blank">Oleg @ product crafters . io</a></p></div></div>    
</body>
</html>