<html>
<head>
<title>When Procedural Is Better Than Declarative Programing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当过程式编程优于声明式编程时</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/when-procedural-is-better-than-declarative-51b24aaaf227?source=collection_archive---------7-----------------------#2018-10-10">https://medium.com/hackernoon/when-procedural-is-better-than-declarative-51b24aaaf227?source=collection_archive---------7-----------------------#2018-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c7a8" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">过程化编程允许您通过复杂的过程进行推理，这可以帮助您解决无法解决的问题，即使需要做更多的工作。</h2></div><p id="22f0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近，我开始关注youtube上的一个魔术师/解谜频道。该频道作者是克里斯拉姆齐，他的视频令人惊讶地令人满意。如果你想知道这与程序性和声明性的<a class="ae kf" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>有什么关系，我向你保证我们会谈到这一点，如果你能耐心一分钟的话。</p><p id="050c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">克里斯在他的频道上解决了几个不同的难题:</p><h1 id="be44" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">谜题1:不可能的瓶子</h1><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">The Impossible Bottle Puzzle</figcaption></figure><h1 id="0aaa" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">谜题2:雷神之锤</h1><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">Only those worthy can wield the hammer of Thor</figcaption></figure><h1 id="f99e" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">那么有什么区别呢？</h1><p id="423f" class="pw-post-body-paragraph jj jk hu jl b jm lj iv jo jp lk iy jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我认为谜题是编程的伟大隐喻，它可以帮助非程序员理解编程的困难。通常，我们不知道一件事要花多长时间，或者最好的方法是什么，直到我们做出努力。两个不同的程序员可以用非常不同的方式处理和解决同样的挑战。</p><p id="5b98" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这两个谜题都被贴上了“不可能”的标签，但实际上它们所涉及的挑战有着非常明显的区别。不可能的瓶子让你清楚地看到发生了什么，但操纵零件和零件的过程很难执行。要不是瓶子挡住通路，解决起来也是小事一桩。</p><p id="ea4b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在“雷神之锤”的谜题中，情况正好相反。每个部分都可以触摸和操作，但是它们之间的关系隐藏在内部，程序员看不到。。。我是说，解谜者。</p><h1 id="2fe6" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">声明式编程隐藏了过程，揭示了关系</h1><p id="4a24" class="pw-post-body-paragraph jj jk hu jl b jm lj iv jo jp lk iy jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">声明式编程有许多不同的形式。最广为人知的声明式编程形式之一是函数式编程。函数式编程简单地描述了输入和输出之间的数学关系。它很大程度上依赖于像递归和组合这样的想法。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/2d7e533fa75ba3f5f7c2215f8f5e62f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*D6xjxEeDCo72lQl-PTkmLA.png"/></div><figcaption class="lf lg fg fe ff lh li bd b be z ek">functions are simply mathematical maps between inputs and outputs</figcaption></figure><p id="154a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了突出函数式编程和命令式编程的优缺点，最常见的例子之一是计算斐波那契数列。</p><p id="e712" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以下是在Haskell中计算斐波那契数列的几种不同方法:</p><pre class="ky kz la lb fq lr ls lt lu aw lv dt"><span id="1442" class="lw kh hu ls b fv lx ly l lz ma">-- zip<br/>fibs = 0 : 1 : zipWith (+) fibs (tail fibs)</span><span id="0cee" class="lw kh hu ls b fv mb ly l lz ma">-- recursive<br/>fib :: Int -&gt; Int<br/>fib 0 = 0<br/>fib 1 = 1<br/>fib n = fib (n-1) + fib (n-2)</span><span id="f0ad" class="lw kh hu ls b fv mb ly l lz ma">n = 37<br/>main = do<br/>    print "zip lists"<br/>    print (fibs !! n)<br/>    print (fibs !! (n+1))<br/>    print (fibs !! (n+2))<br/>    print (fibs !! 2000)</span><span id="bd4e" class="lw kh hu ls b fv mb ly l lz ma">    print ""<br/>    print "recursive"<br/>    print (fib n)<br/>    print (fib (n + 1))<br/>    print (fib (n + 2))</span><span id="22e6" class="lw kh hu ls b fv mb ly l lz ma">-- edited Nov 2018</span></pre><p id="9dfd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码改编自<a class="ae kf" href="https://stackoverflow.com/questions/1105765/generating-fibonacci-numbers-in-haskell#1105840" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出问题</a>。以下是解释带有“zip”的版本如何工作的描述:</p><blockquote class="mc"><p id="3e9f" class="md me hu bd mf mg mh mi mj mk ml ke ek translated">因此，斐波纳契数列的无限列表可以通过将元素1和<code class="eh mm mn mo ls b">1</code>加到使用<code class="eh mm mn mo ls b">+</code>运算符压缩斐波纳契数列的无限列表的尾部的结果上来计算。</p></blockquote><p id="8e42" class="pw-post-body-paragraph jj jk hu jl b jm mp iv jo jp mq iy jr js mr ju jv jw ms jy jz ka mt kc kd ke hn dt translated">尽管使用“zip”实现斐波那契数列非常简洁，但正如这个答案所展示的，还有很多工作要做。</p><p id="6783" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在递归Haskell版本中，我们描述了有关数学关系的非常具体的事情。类型签名告诉我们这个函数接受一个整数并返回另一个整数。然后我们使用一个叫做<a class="ae kf" href="http://learnyouahaskell.com/syntax-in-functions#pattern-matching" rel="noopener ugc nofollow" target="_blank">模式匹配</a>的特殊haskell技巧来描述函数的初始值。根据这些值，我们递归地描述如何计算进一步的值。</p><p id="d27c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将这些实现与我用C写的这个版本进行比较:</p><pre class="ky kz la lb fq lr ls lt lu aw lv dt"><span id="d84c" class="lw kh hu ls b fv lx ly l lz ma">#include &lt;stdio.h&gt;<br/>int fibonacci(n){<br/>    int a = 1;<br/>    int b = 1;<br/>    int i;<br/>    int tmp;<br/>    for(i = 0; i &lt; n - 1; ++i){<br/>        // swap a and b<br/>        tmp = a;<br/>        a = b;<br/>        b = tmp;<br/>        // add a and b<br/>        a = b + a;<br/>   }<br/>   return a;<br/>}</span><span id="2ee5" class="lw kh hu ls b fv mb ly l lz ma">int main(){<br/>    printf("\nfibonacci(0) = %d", fibonacci(0));<br/>    printf("\nfibonacci(1) = %d", fibonacci(1));<br/>    printf("\nfibonacci(2) = %d", fibonacci(2));<br/>    printf("\nfibonacci(3) = %d", fibonacci(3));<br/>    printf("\nfibonacci(4) = %d", fibonacci(4));<br/>    printf("\nfibonacci(5) = %d", fibonacci(5));<br/>    printf("\nfibonacci(6) = %d", fibonacci(6));<br/>    printf("\nfibonacci(10) = %d", fibonacci(10));<br/>    printf("\nfibonacci(20) = %d", fibonacci(20));<br/>    printf("\nfibonacci(40) = %d", fibonacci(40));<br/>    printf("\nfibonacci(50) = %d", fibonacci(50));<br/>    printf("\nfibonacci(100) = %d", fibonacci(100));<br/>    printf("\ndone");<br/>    printf("\n");<br/>    return 0;<br/>}</span></pre><p id="6179" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码需要明确存储什么值，循环中涉及多少步，等等。这可能会令人困惑，因为经常会有一些小的调整来处理边缘情况，或者正确的初始化。在这种情况下，我们必须循环<em class="mu"> n -1 </em>次，可能不清楚为什么。此外，如果你运行代码，你会发现最终它给出了错误的答案，因为在过程化编程中，程序员要对溢出之类的事情负责，而在这种情况下我们不处理它。在haskell中，语言会帮我们解决这个问题。</p><h1 id="689c" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">声明式编程非常适合需要细节帮助的常见任务</h1><p id="27af" class="pw-post-body-paragraph jj jk hu jl b jm lj iv jo jp lk iy jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">有些人可能认为过程式编程和声明式编程是互斥的，但通常我们会混合使用这两种方法。一个很好的例子是，即使在过程语言中，使用声明性语句进行内存管理<a class="ae kf" href="https://hackernoon.com/tagged/management" rel="noopener ugc nofollow" target="_blank">已经成为规范。</a></p><p id="da4a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想想<strong class="jl hv">新的</strong>关键词。这个关键字存在于几种语言中，包括Java、C++和Javascript，实际上在每一种语言中它几乎都是可比较的。</p><p id="f465" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae kf" href="https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html" rel="noopener ugc nofollow" target="_blank">这里的</a>是来自在线Java文档的一个例子:</p><pre class="ky kz la lb fq lr ls lt lu aw lv dt"><span id="637d" class="lw kh hu ls b fv lx ly l lz ma"><strong class="ls hv">Point originOne</strong> = new Point(23, 94);<br/><strong class="ls hv">Rectangle rectOne</strong> = new Rectangle(originOne, 100, 200);<br/><strong class="ls hv">Rectangle rectTwo</strong> = new Rectangle(50, 100);</span></pre><p id="2478" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在C #中，malloc和free用于手动分配和取消分配堆上的内存。在这些其他语言中，new关键字为我们自动处理了很多这样的事情。首先，它决定了我们将要创建什么对象，以及所需的内存大小。此外，在表达式的上下文中，new关键字指示应该使用提供的参数调用对象构造函数。最后，带有<strong class="jl hv"> new </strong>的表达式解析为一个可以根据其对象类型使用的值。在上面的语句中，它被用在赋值的右边，但是我们也可以匿名调用它的一个方法，或者把它传递给另一个对象的方法。</p><p id="bf2d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就像不可能的瓶子难题一样，声明性编程使细节变得不可访问，但使看到相关的关系变得容易。</p><h1 id="e4f0" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">当你关心步骤时，程序性更好</h1><p id="e713" class="pw-post-body-paragraph jj jk hu jl b jm lj iv jo jp lk iy jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">最近，我试图为一个web开发任务编写一些复杂的MySQL查询。SQL是一个很好的例子，说明声明式编程不仅仅包括函数式编程。</p><p id="0057" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于这个特殊的问题，我需要执行计算来转换我的数据，使用数据库中不同表的数据。SQL非常适合查询和选择数据集，但它并不总是用这些数据进行计算的最佳选择。</p><p id="ff84" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最初，我在django的服务器上使用命令式方法处理我的数据。但是这对于我来说太慢了，因为当python解释器试图执行计算时，查询会超时。</p><p id="9bb0" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我决定将计算转移到MySQL中，以加快查询时间。虽然看起来这已经足够快了，但是很快就很难对查询、步骤和涉及的关系进行推理。我发现自己在MySQL中使用循环和过程，MySQL支持循环和过程，但这不是该语言的理想用例。</p><p id="41a5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">相反，我将使用SQL查询来选择适当的数据集，然后用javascript在客户机上执行计算。我以前对需要从数据库计算的其他统计数据也是这样做的，我真的很喜欢这种方法，因为计算被卸载到客户端，所以这是对资源的有效利用，页面呈现也很快。此外，javascript是一种以灵活方式处理数据集的优秀语言，因为它支持JSON，即使浏览器不是支持数学或会计计算的最佳环境。</p><h1 id="da59" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">最后的想法:过程化编程给了你更多的控制，但是值得吗？</h1><p id="08c3" class="pw-post-body-paragraph jj jk hu jl b jm lj iv jo jp lk iy jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们勇敢无畏的youtube解谜者克里斯·拉姆齐(Chris Ramsey)决定烧掉雷神之锤，而不是试图把它重新组装起来，因为这项任务充满了挫折和挑战。但是如果他记录了拆卸的步骤，他可以简单地颠倒步骤重新组装。我认为这是一个很好的例子，说明了过程化编程的优点和缺点。跟踪所有涉及的步骤，可以让您执行更复杂的挑战，更好地控制细节，但是否值得取决于任务，以及是否可以用库或不同的方法解决。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="mv le l"/></div></figure></div></div>    
</body>
</html>