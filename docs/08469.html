<html>
<head>
<title>Announcing BuildInfer for C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">宣布C++的BuildInfer</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/announcing-buildinfer-for-c-3dfa3eb15feb?source=collection_archive---------10-----------------------#2018-10-10">https://medium.com/hackernoon/announcing-buildinfer-for-c-3dfa3eb15feb?source=collection_archive---------10-----------------------#2018-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9495" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">分析、可视化和在构建系统之间迁移</h2></div><blockquote class="jj jk jl"><p id="67e2" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">你的C++构建是缓慢的还是难以理解的？我们目前正在寻找更多的案例研究。如果您对改进基于Linux的构建(商业或开源)感兴趣，请<a class="ae kj" href="mailto:hello@buckaroo.pm" rel="noopener ugc nofollow" target="_blank">联系</a>！</p><p id="b3ef" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">https://buildinfer.loopperfect.com/<a class="ae kj" href="https://buildinfer.loopperfect.com/" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><figure class="kl km kn ko fq kp fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/c16cb35622494d4d7a5014e13c3a6131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*YZgG5MjrKJ9nV_a7bJtHuA.png"/></div></figure><p id="9fa2" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">由于使用了各种各样的构建系统，C++社区变得支离破碎。这种分散使得难以:</p><ul class=""><li id="20f9" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated">了解第三方库是如何工作的</li><li id="90c1" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">将两个库集成在一起</li><li id="b5e5" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">跨库优化(例如LTO)</li><li id="dcbb" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">为C++源代码构建工具(头文件在哪里？)</li><li id="6280" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">实现人工缓存</li><li id="487e" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">确定构建过程中的哪些步骤会减慢您的速度</li></ul><p id="f0fe" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">对于C++社区来说，这意味着:</p><ul class=""><li id="9546" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated">浪费时间将项目粘在一起</li><li id="e433" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">浪费时间等待缓慢的构建</li><li id="856d" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">浪费时间重写已经存在但难以集成的代码</li></ul><h2 id="bebc" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ks lu lv lw kt lx ly lz ku ma mb mc md dt translated"><strong class="ak">如果我们能够提取任何C++项目的可读构建描述，而不管使用的是什么构建系统，这不是很好吗？</strong></h2><h1 id="1fc3" class="me lk hu bd ll mf mg mh lp mi mj mk lt ja ml jb lw jd mm je lz jg mn jh mc mo dt translated">宣布BuildInfer</h1><p id="1d21" class="pw-post-body-paragraph jm jn hu jp b jq mp iv js jt mq iy jv ks mr jy jz kt ms kc kd ku mt kg kh ki hn dt translated">通过记录系统级的构建过程，我们可以推断出项目结构的高级信息。由于BuildInfer在这个底层记录，我们的技术适用于任何C++构建系统。</p><p id="3b99" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">一旦我们有了一个高层次的构建描述，我们就可以将复杂的构建系统可视化、转换甚至移植到更强大的构建系统，比如<a class="ae kj" href="https://buckbuild.com/" rel="noopener ugc nofollow" target="_blank"> Buck </a>和Bazel。</p><h1 id="7199" class="me lk hu bd ll mf mg mh lp mi mj mk lt ja ml jb lw jd mm je lz jg mn jh mc mo dt translated">初步调查结果</h1><p id="c939" class="pw-post-body-paragraph jm jn hu jp b jq mp iv js jt mq iy jv ks mr jy jz kt ms kc kd ku mt kg kh ki hn dt translated">我们已经成功地将以下项目移植到<a class="ae kj" href="https://buckbuild.com/" rel="noopener ugc nofollow" target="_blank"> Buck </a>:</p><ul class=""><li id="a0ae" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated"><a class="ae kj" href="https://mapnik.org/" rel="noopener ugc nofollow" target="_blank"> Mapnik </a></li><li id="981a" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated"><a class="ae kj" href="https://llvm.org/" rel="noopener ugc nofollow" target="_blank"> LLVM </a></li><li id="9b01" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated"><a class="ae kj" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a></li></ul><p id="6139" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">此外，我们发现这些项目都没有附带一个可重现的构建系统！通过将它们移植到Buck，我们可以保证这一点。</p><p id="520e" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">可重现的构建对于安全性、缓存性能和调试至关重要。有关更多信息，请参见:</p><ul class=""><li id="4434" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated"><a class="ae kj" href="https://reproducible-builds.org/" rel="noopener ugc nofollow" target="_blank">https://reproducible-builds.org/</a></li><li id="b957" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated"><a class="ae kj" href="https://martinfowler.com/bliki/ReproducibleBuild.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/bliki/ReproducibleBuild.html</a></li></ul><h2 id="0df4" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ks lu lv lw kt lx ly lz ku ma mb mc md dt translated">Mapnik</h2><blockquote class="jj jk jl"><p id="0a2d" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">Mapnik是一个开源的地图绘制工具包，用于基于桌面和服务器的地图渲染，用C++编写。</p></blockquote><ul class=""><li id="6493" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated">将Mapnik从SCons移植到Buck将构建时间从<em class="jo"> 30分钟</em>减少到<em class="jo"> 6分钟</em>。</li><li id="ef70" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">我们估计启用预编译头文件将进一步缩短10%的构建时间。</li><li id="835d" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">Mapnik不使用版本脚本，需要<code class="eh mu mv mw mx b">-fvisibility=inline</code>和共享版本来防止符号冲突。使用BuildInfer的输出，我们发现核心问题是这个<a class="ae kj" href="https://github.com/mapnik/mapnik/compare/master...nikhedonia:fix/nonstatic-definition?expand=1" rel="noopener ugc nofollow" target="_blank">头文件</a>中的非静态定义。</li><li id="f77a" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">我们生成了一个图表，显示了各个文件组和可执行文件之间的交互:</li></ul><figure class="kl km kn ko fq kp fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff my"><img src="../Images/0b47349c1d5e22057d944986c9bd534f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*db3lfHzuY1BKG-iUnsU5eg.jpeg"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">View the <a class="ae kj" href="https://gist.github.com/nikhedonia/143746a8cde43d8c991626f385d2702a#file-mapnik-minimal-svg" rel="noopener ugc nofollow" target="_blank">full SVG image on GitHub</a></figcaption></figure><p id="c2f3" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">该图告诉我们以下信息:</p><ul class=""><li id="fce7" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated">Mapnik不使用版本脚本</li><li id="5f34" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">一些目标文件有一个<code class="eh mu mv mw mx b">*.os</code>扩展名</li><li id="2eee" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">几个翻译单位都是由<code class="eh mu mv mw mx b">scons/scons.py</code>生成的</li></ul><h2 id="12a7" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ks lu lv lw kt lx ly lz ku ma mb mc md dt translated">LLVM &amp; Clang</h2><blockquote class="jj jk jl"><p id="c3b5" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">LLVM编译器基础设施项目是一个“模块化和可重用的编译器和工具链技术的集合”，用于开发编译器前端和后端。</p></blockquote><ul class=""><li id="f13f" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated">默认情况下，LLVM强制实施一种“超级项目”结构，迫使您以一种特定的方式来布局项目。使用BuildInfer，LLVM可以被重构为许多小模块。</li><li id="8860" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">类似的直线构建时间，但大量改进的增量构建。</li><li id="cb21" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">我们可以缓存LLVM Tablegen工件——这对于<a class="ae kj" href="https://ccache.samba.org/" rel="noopener ugc nofollow" target="_blank"> CCache </a>是不可能的。</li><li id="dca2" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">我们估计使用预编译头文件可以将直线构建时间提高20%。使用BuildInfer提取的信息实现起来要容易得多。</li></ul><p id="0aec" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">我们还在依赖图的上下文中对构建时间进行了简单的分析。这些表格显示了在LLVM中更改各种文件的估计成本，方法是合计构建每个文件及其所有依赖项所花费的时间。</p><p id="d555" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">这些文件是增量构建的“热点”,可能是重构的良好候选。</p><p id="4070" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated"><em class="jo">请注意，这些数字是假设单线程构建的；一个真正的构建需要这些时间的一些比例因子。</em></p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nh ni l"/></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek"><strong class="ak">10 Most Impactful Headers</strong></figcaption></figure><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nh ni l"/></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek"><strong class="ak">10 Most Impactful Translation-units</strong></figcaption></figure><p id="1e6b" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">标题<code class="eh mu mv mw mx b">llvm-config.h</code>特别有意思。它定义了在整个项目中引用的一些常量:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="c614" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">所以每次版本字符串或默认目标改变时，LLVM都会引发一个<code class="eh mu mv mw mx b">15,264 second</code>构建！这些值有可能被重构为一个翻译单元:</p><figure class="kl km kn ko fq kp"><div class="bz el l di"><div class="nh ni l"/></div></figure><p id="c618" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">我们还生成了一个图表，显示各个文件组和可执行文件的交互:</p><figure class="kl km kn ko fq kp fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff my"><img src="../Images/9d56eea924facbb2c79e780771e9d59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skPXBVTHSBskaZ_L8HseLw.jpeg"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">View the <a class="ae kj" href="https://gist.github.com/nikhedonia/143746a8cde43d8c991626f385d2702a#file-llvm-minimal-svg" rel="noopener ugc nofollow" target="_blank">full SVG image on GitHub</a></figcaption></figure><p id="4e2f" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">图表向我们展示了:</p><ul class=""><li id="612b" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated">版本脚本通过Bash生成，称为<code class="eh mu mv mw mx b">*.export</code></li><li id="e644" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated"><code class="eh mu mv mw mx b">*.td</code>文件被<code class="eh mu mv mw mx b">tblgen</code>用来生成<code class="eh mu mv mw mx b">*.inc</code>头文件。</li><li id="19ce" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">Clang和LLVM各有各的<code class="eh mu mv mw mx b">tblgen</code>(怎么区别？)</li><li id="06fc" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">很多文件都是由CMake直接生成的。</li></ul><h2 id="b9f4" class="lj lk hu bd ll lm ln lo lp lq lr ls lt ks lu lv lw kt lx ly lz ku ma mb mc md dt translated">OpenCV</h2><blockquote class="jj jk jl"><p id="9345" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">OpenCV是一个主要针对实时计算机视觉的编程函数库。</p></blockquote><ul class=""><li id="f8ad" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated">OpenCV实际上可以拆分成多个独立的模块。</li><li id="afeb" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">BuildInfer发现其中一个模块依赖于另一个模块的实现细节，所以我们提交了一个补丁。</li><li id="ea3e" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">使用Buck，OpenCV的增量编译时间可以通过在完整编译完成后禁用预编译头文件来改进。</li></ul><p id="ccbf" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv ks jx jy jz kt kb kc kd ku kf kg kh ki hn dt translated">我们还生成了一个图表，显示各个文件组和可执行文件的交互:</p><figure class="kl km kn ko fq kp fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff my"><img src="../Images/b16f0156e1fc5f95e101fb028920a1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmPimwRAs3pYoVcaLUCC0Q.jpeg"/></div></div><figcaption class="nd ne fg fe ff nf ng bd b be z ek">View the <a class="ae kj" href="https://gist.github.com/nikhedonia/143746a8cde43d8c991626f385d2702a#file-opencv-minimal-svg" rel="noopener ugc nofollow" target="_blank">full SVG image on GitHub</a></figcaption></figure><ul class=""><li id="82b4" class="kv kw hu jp b jq jr jt ju ks kx kt ky ku kz ki la lb lc ld dt translated"><code class="eh mu mv mw mx b">*.cl</code>文件被<code class="eh mu mv mw mx b">cl2cpp.cmake</code>用来生成<code class="eh mu mv mw mx b">*.cpp</code>文件</li><li id="1b2a" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">由<code class="eh mu mv mw mx b">OpenCVGenPkgconfig.cmake</code>产生一个<code class="eh mu mv mw mx b">pkg-config</code></li><li id="db23" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">使用预编译头文件<code class="eh mu mv mw mx b">*.gch</code>，不生成头文件入口点。</li><li id="729b" class="kv kw hu jp b jq le jt lf ks lg kt lh ku li ki la lb lc ld dt translated">OpenCV的构建系统用的是Prolog！</li></ul><h1 id="a6ee" class="me lk hu bd ll mf mg mh lp mi mj mk lt ja ml jb lw jd mm je lz jg mn jh mc mo dt translated">好奇吗？</h1><p id="31c8" class="pw-post-body-paragraph jm jn hu jp b jq mp iv js jt mq iy jv ks mr jy jz kt ms kc kd ku mt kg kh ki hn dt translated">你的C++构建是缓慢的还是难以理解的？我们目前正在寻找更多的案例研究。如果您对改进基于Linux的构建(商业或开源)感兴趣，请<a class="ae kj" href="mailto:hello@buckaroo.pm" rel="noopener ugc nofollow" target="_blank">联系</a>！</p><h1 id="bdc6" class="me lk hu bd ll mf mg mh lp mi mj mk lt ja ml jb lw jd mm je lz jg mn jh mc mo dt translated">您可能也对…感兴趣</h1><div class="nj nk fm fo nl nm"><a href="https://hackernoon.com/7-reasons-to-use-buck-build-5b44d7413585" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab ej"><div class="no ab np cl cj nq"><h2 class="bd hv fv z el nr eo ep ns er et ht dt translated">使用降压构建的7个理由</h2><div class="nt l"><h3 class="bd b fv z el nr eo ep ns er et ek translated">Buck是一个跨平台、跨语言构建系统，在脸书为大规模编译而设计。所有牛仔…</h3></div><div class="nu l"><p class="bd b gc z el nr eo ep ns er et ek translated">hackernoon.com</p></div></div></div></a></div></div></div>    
</body>
</html>