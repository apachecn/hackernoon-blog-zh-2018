<html>
<head>
<title>Client Side Encryption in Firebase Database and Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase数据库和存储中的客户端加密</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/client-side-encryption-in-firebase-database-60dd55abadb2?source=collection_archive---------5-----------------------#2018-10-11">https://medium.com/hackernoon/client-side-encryption-in-firebase-database-60dd55abadb2?source=collection_archive---------5-----------------------#2018-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1952" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">声明:我绝不是</em> <a class="ae jq" href="https://hackernoon.com/tagged/security" rel="noopener ugc nofollow" target="_blank"> <em class="jp">安全</em> </a> <em class="jp">专家。我的项目只需要一些客户端加密，并尽我所能理解选项，并在这里展示出来。欢迎所有的反馈和更正，我为任何错误提前道歉！</em></p><p id="32e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的几个月里，我一直在做一个兼职项目，SoulSaga。我想建立一个空间，让人们能够反思他们的生活、身份和个人成长。换句话说，一个拥有大量敏感用户信息的应用程序。</p><p id="a768" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Firebase解决了很多这样的问题，包括安全传输和服务器端加密。但是，任何使用过Firebase数据库或存储的人都会很快意识到，作为管理员，您可以看到存储在其中的任何用户数据。因此，开箱即用的Firebase是好的，但还不够好——用户信任需要并且应该得到全面保护，因此某种形式的客户端加密(发送到数据库之前的加密)是必要的。</p><p id="70d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我希望列举一些我考虑过的解决方案，最后一个是我选定的。</p><p id="c553" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">加密本身很简单，可以用现有的库来执行，使用对称密钥(既可以加密数据，也可以解密加密数据的密钥)，如AES。通常的问题是，我们现在需要找到一个安全的地方来存储这个万能的密钥。</p><p id="2579" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果存储在你自己的服务器上，它不提供安全，因为你自己可以用这个密钥来解密你的用户数据，因此任何入侵你系统的人都可以这样做。它甚至不应该是一个选项，所以我们称它为选项0 :P</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/aacf33ec7378cdd7920cf9eceb6dc69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zP4cGvApbq3n5JrJP0HMwA.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Option 0: Storing Key With Data</figcaption></figure><p id="820d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">选项1:密码加密密钥</strong></p><p id="d426" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以将密钥存储在您的服务器上，并要求用户保留一个强密码来加密密钥。这并不理想，因为它需要在用户端进行工作，如果用户忘记了密码，密钥很可能无法恢复。也就是说，这种选择有其优点，而且似乎是一种相对受欢迎的选择。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff kh"><img src="../Images/48256767689b1f453bdd33592fbcf0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jAGEAiH-4UgFV21YqrkZA.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Option 1: Password Encrypted Keys</figcaption></figure><p id="f9db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">选项2:在用户设备上存储密钥</strong></p><p id="d686" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这与端到端加密非常相似，它将密钥存储在用户的设备上，因此密钥永远不会在应用服务器上。但是这种方法的问题是，密钥以及数据不能从其他设备访问。这是一个不错的解决方案，取决于具体情况，但肯定不是我想要的。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff ki"><img src="../Images/2fdcbe646b652e7709372e480c3918d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YmUdh7TfmW4KoTiE1sRdAw.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Option 2: Storing Key in User Device</figcaption></figure><p id="e937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">选项3:用于密钥加密的谷歌密钥管理服务(KMS)</strong></p><p id="aacc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">至此，我们已经穷尽了在这条管道上放置密钥的所有选项，但是通过添加其他系统，还有更多的选项可以考虑。</p><p id="79eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Andy Geers提出了一个广受欢迎且经过深思熟虑的解决方案<a class="ae jq" href="http://www.geero.net/2017/05/how-to-encrypt-a-google-firebase-realtime-database/" rel="noopener ugc nofollow" target="_blank">,该方案涉及使用存储在谷歌</a><a class="ae jq" href="https://cloud.google.com/kms/" rel="noopener ugc nofollow" target="_blank">密钥管理服务</a>中的另一个数据密钥对密钥进行加密。用户的密钥对数据进行加密，然后用KMS密钥对密钥进行加密，并存储在数据库中。正如安迪指出的那样，</p><blockquote class="kj kk kl"><p id="39ad" class="ir is jp it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated">重要的是，KMS密钥与Firebase数据库属于不同的Google帐户，因此任何用户(例如我)都无权读取数据和解密数据。黑客需要破坏两个帐户才能访问未加密的数据。</p></blockquote><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff kp"><img src="../Images/b89f8743a487cec1f69a0dc308fabb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNyY9ke2t9leI7HhaNXZWQ.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Option 3: Storing Key with Key Management Service</figcaption></figure><p id="f71d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我个人希望设计一个系统，其中密钥仍然在用户手中，并且不希望有管理两个帐户的负担。</p><p id="db04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">选项4:把密钥藏在用户的谷歌账户里！(经用户同意)</strong></p><p id="c684" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经在使用Firebase认证作为我的Google账户认证解决方案，所以这个解决方案是它的自然延伸。现在，锁定Google作为唯一的身份验证提供者是这种方法的一个相当大的缺点，但是我希望这个概念可以启发一些人，或者其他身份验证提供者也有类似的API。</p><p id="4f3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当用户登录时，我们从用户的Google帐户获得OAuth凭证来请求用户的个人加密密钥，或者如果我们找不到，就创建一个。这样，密钥总是完全掌握在用户手中，但他们永远不会直接处理它。获取密钥需要侵入用户的谷歌账户，此时黑客可以读取应用程序中的数据。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff kh"><img src="../Images/f9a840efa3241f50a06ce529a9957884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtKR0IdUyRhbifkxveeaKA.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Option 4: Storing Key in User’s Google Account</figcaption></figure><p id="dd5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，把密钥“藏”在某人的谷歌账户里是什么意思呢？Google Drive <a class="ae jq" href="https://developers.google.com/drive/api/v3/appdata" rel="noopener ugc nofollow" target="_blank">提供了一个API </a>用于创建一个特殊的应用数据文件夹(OAuth期间需要用户同意)。这个文件夹的内容对用户是不可见的，并且只能通过您的应用程序的凭证来访问！</p><p id="bd2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">警告——用户可以看到应用程序在他们的驱动器中占用了多少空间，并有能力清除应用程序的数据，因此这种方法依赖于用户不会意外删除他们自己的加密密钥。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff kq"><img src="../Images/cd0acabb2d18ca00bbdf201ee8bcaff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWHvONXz_vEHiWz1wBUZsA.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Key Storage in App Data folder in Google Drive</figcaption></figure><p id="fef9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读！</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="kr ks l"/></div></figure></div></div>    
</body>
</html>