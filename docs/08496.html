<html>
<head>
<title>Inheritance and Interfaces in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP中的继承和接口</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/inheritance-and-interfaces-in-php-d46b61c65b84?source=collection_archive---------9-----------------------#2018-10-11">https://medium.com/hackernoon/inheritance-and-interfaces-in-php-d46b61c65b84?source=collection_archive---------9-----------------------#2018-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/607c419e32cdffb7ea807cfd91b13b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lMeZxlGr6wf3jLrX.jpg"/></div></div></figure><h1 id="c850" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="9693" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">从前，</p><p id="1cf1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">曾经有一个Web开发人员花了一周又一周的时间更新相同的代码行。</p><p id="dc80" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这使他非常头疼。</p><p id="10d2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一天，在浏览博客的帖子时，他看到了“面向对象编程”这几个字，接下来发生的事情令人震惊…</p><p id="351a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在上一篇文章中，您发现了PHP 中OOP范例的<a class="ae ld" href="http://anastasionico.uk/blog/object-oriented-programming-in-php" rel="noopener ugc nofollow" target="_blank">基础，</a></p><p id="bc53" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">从其简单的语法到以简单而强大的方式重用相同代码的优势。</p><p id="8cf8" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">今天你将学习如何最好地管理这些对象，并使用继承和接口在它们之间创建长期安全的关系。</strong></p><h1 id="be6d" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">遗产</h1><h1 id="f562" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">OOP上有哪些继承？</h1><p id="2c5f" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在<a class="ae ld" href="https://hackernoon.com/tagged/php" rel="noopener ugc nofollow" target="_blank"> PHP </a>中，我们现在进入面向对象<a class="ae ld" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程的4个基本支柱之一。</a></p><p id="4181" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">继承以及封装、抽象和多态都需要掌握，才能精通编程并真正提高你的技能。</p><p id="b241" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">继承所做的是在父子模型中将类相互联系起来。</strong></p><p id="4fc6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这在提取相关类必须共有的特征时非常有用，并且允许实现进一步的方法和属性，而无需再次重写。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/3c31cebd96e863d3127fe50119f550b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*luE-nXA0YdYBSY3e.jpg"/></div></div></figure><p id="5130" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">像上一篇文章一样，我们仍然使用<em class="lj"> Building </em>类作为例子，<br/>在这个例子中，我们假设当你想要实例化一个新的建筑物时，构建它的工作已经完成，并且对公众开放。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="4e7a" class="lp jd hu ll b fv lq lr l ls lt">class<!-- --> <!-- -->Building</span><span id="c95a" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="7908" class="lp jd hu ll b fv lu lr l ls lt">    $inConstruction<!-- --> <!-- -->= false;</span><span id="cd56" class="lp jd hu ll b fv lu lr l ls lt">    $isOpen<!-- --> <!-- -->= true;</span><span id="e597" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->closeBuilding()</span><span id="519a" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="0280" class="lp jd hu ll b fv lu lr l ls lt">        return<!-- --> <!-- -->$this-&gt;isOpen = false;</span><span id="a190" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="6632" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->openBuilding()</span><span id="a8b9" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="7612" class="lp jd hu ll b fv lu lr l ls lt">        return<!-- --> <!-- -->$this-&gt;isOpen = true;</span><span id="900e" class="lp jd hu ll b fv lu lr l ls lt">    }<br/>}</span><span id="aeda" class="lp jd hu ll b fv lu lr l ls lt">class<!-- --> <!-- -->School extends<!-- --> <!-- -->Building</span><span id="20d6" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="f89a" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="cd80" class="lp jd hu ll b fv lu lr l ls lt">class<!-- --> <!-- -->Office extends<!-- --> <!-- -->Building</span><span id="8530" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="bdda" class="lp jd hu ll b fv lu lr l ls lt">    $isOpen<!-- --> <!-- -->= false;</span><span id="86f8" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="b71e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们这里有三节课，</p><p id="9289" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">作为building类的父类及其继承Building特性、属性和方法的子类。</p><p id="573d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们现在可以实例化具体的学校和办公室，而不是抽象的班级建筑</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="8ec7" class="lp jd hu ll b fv lq lr l ls lt">$mySchool<!-- --> <!-- -->= new<!-- --> <!-- -->School();</span><span id="ca73" class="lp jd hu ll b fv lu lr l ls lt">$myOffice<!-- --> <!-- -->= new<!-- --> <!-- -->Office();</span><span id="71a2" class="lp jd hu ll b fv lu lr l ls lt">echo<!-- --> <!-- -->$myShool-&gt;closeBuilding(); // The output will be “false” because of the parent Building</span><span id="a907" class="lp jd hu ll b fv lu lr l ls lt">echo<!-- --> <!-- -->$myOffice-&gt;isOpen; // The output will be “false” because of the child Office</span></pre><p id="ce4f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如你所见，我实际上没有在学校类中写任何东西，但是它仍然继承了它的父类Building的所有属性和方法。</p><p id="b722" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">这个原则叫做DRY(不要重复自己)，它的目标是减少我们一遍又一遍写的文字。</strong></p><p id="48fa" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我相信你也注意到了<em class="lj"> Office </em>类在<em class="lj"> $isOpen </em>变量上的值与其父类不同，</p><p id="4955" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">事实上，</p><p id="eaab" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">通过将父级的中的相同属性或方法写入子级，我们覆盖了它的功能。</p><p id="2488" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">基本上，</p><p id="34c8" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">当实例化的<em class="lj"> $myOffice </em>关闭，而不是<em class="lj"> $mySchool </em>跟随建筑的行为并保持<em class="lj"> $isOpen </em>保持假(<em class="lj"> $mySchool </em>开放访问)。</p><h1 id="d146" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">为什么使用继承？</h1><p id="ee37" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">关于这个话题有几种思潮，</p><p id="2936" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">有人说继承是好的，如果你只是想在一个活的项目中使用它，一些高级开发人员会杀了你，</p><p id="4882" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我认为大部分时间真相都在中间。</p><p id="343e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">继承是一种节省时间的神奇方法，可以避免重复写同样的东西</strong>，</p><p id="de40" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这很容易理解，对于OOP新手来说，这是一条正确的道路。</p><p id="ea8d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">同样真实的是<strong class="kc hv">继承有几个限制</strong>，对于一个有经验的web开发人员来说，有相当多的更好的选择，一个在所有组合之上。</p><p id="b60c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">看看这个来自from Fun Fun Function的视频</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="9467" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我的建议是使用继承，只要你对这种技术100%熟悉，你知道如何使用它，什么时候使用它来共享功能，什么时候使用其他技术，如组合、设计模式(工厂模式是一个非常接近的例子)，或者甚至只是在类中添加一个特征。</p><h1 id="14d1" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">extends关键字</h1><p id="980e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">没有人知道为什么创建继承的关键字不是继承或更一致和容易记住的东西，但我们在这里。</p><p id="729d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">为了允许一个类从另一个类继承，我们需要在子类名称之后和左括号之前指定关键字“extends”和父类。</strong></p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/39b26eec6ff1c8190f2dd630aa3ae83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Gr6w9_wqIiUEW1U_.jpg"/></div></figure><p id="de67" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">需要注意的一个情况是，子类必须总是只依赖于单个父类，这意味着不支持多重继承。</p><p id="5c30" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">请这样想:<br/>我们在前面的例子中使用的Office类不能同时从Building类和Animal类继承特性。</p><p id="4146" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">他们只是没有共同的特点。</p><h1 id="fbd4" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">“最终”关键字</h1><p id="e6f9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">最后一个关键词是php5中首次引入的非常简单的概念。</p><p id="1976" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">简单来说，</p><p id="6f1e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它防止方法或类被扩展。</p><p id="7ed1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们看一个简单的例子。</p><p id="989e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">假设我们想象中的城市的市长决定所有的建筑必须至少有一个紧急出口，现在看看下面的代码示例。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="f157" class="lp jd hu ll b fv lq lr l ls lt">class<!-- --> <!-- -->Building</span><span id="49dc" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="f530" class="lp jd hu ll b fv lu lr l ls lt">    ...</span><span id="745c" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->setFireExtinguisher()</span><span id="6ea3" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="3770" class="lp jd hu ll b fv lu lr l ls lt">        $this-&gt;fireExtinguisherCount = 1;</span><span id="909b" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="8704" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="2d8c" class="lp jd hu ll b fv lu lr l ls lt"><br/>class<!-- --> <!-- -->Office extends<!-- --> <!-- -->Building</span><span id="0c08" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="1a5c" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->setFireExtinguisher()</span><span id="6a50" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="4edb" class="lp jd hu ll b fv lu lr l ls lt">        $this-&gt;fireExtinguisheCount = 0;</span><span id="70cf" class="lp jd hu ll b fv lu lr l ls lt">    }<br/>}</span></pre><p id="bbe4" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在这种情况下，</p><p id="0ebd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="lj"> Office </em>类的<em class="lj">setfire灭火器()</em>方法已经覆盖了<em class="lj"> Building </em>类并将<em class="lj">fire灭火器计数</em>设置为0，</p><p id="2599" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">市长认为这是非法的。</p><p id="2429" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一种防止它和避免架构师入狱的方法是将final关键字添加到方法中。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="fd01" class="lp jd hu ll b fv lq lr l ls lt">class<!-- --> <!-- -->Building</span><span id="e1d2" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="607b" class="lp jd hu ll b fv lu lr l ls lt">    ...</span><span id="3c1a" class="lp jd hu ll b fv lu lr l ls lt">    final<!-- --> <!-- -->function<!-- --> <!-- -->setFireExtinguisher()</span><span id="ebc5" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="38c1" class="lp jd hu ll b fv lu lr l ls lt">        $this-&gt;fireExtinguisherCount = 1;</span><span id="174a" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="2b4b" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="fe10" class="lp jd hu ll b fv lu lr l ls lt">class<!-- --> <!-- -->Office extends<!-- --> <!-- -->Building</span><span id="ca9e" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="2b7c" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->setFireExtinguisher()</span><span id="82fa" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="560c" class="lp jd hu ll b fv lu lr l ls lt">        $this-&gt;fireExtinguisheCount = 0;</span><span id="1051" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="f82b" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="61af" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">现在<em class="lj"> Office </em>类的<em class="lj">setfire灭火器()</em>方法的代码无法使用，实际上会导致致命错误<em class="lj">“无法覆盖最终方法构建-&gt;setfire灭火器()”</em>。</p><p id="0550" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">非常简单的概念，非常容易实现。</p><p id="7035" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">文章的这一部分只有一个规则:</p><p id="8c03" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">不能在属性上使用final。</p><p id="bbea" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">属性是变量，顾名思义，它们需要能够变化。</p><p id="f4de" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">您可以在不想扩展的类或不能被覆盖的方法上使用final。</p><h1 id="5419" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">接口</h1><p id="ef9b" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">建筑师和建造者需要遵循哪些强制性步骤来建造一座建筑？</p><p id="becd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">有几项规定需要遵守，尤其是在公共场所，比如增加一些急救设备，制定疏散计划等。</p><p id="e92a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一个接口可以让你预先安排这些步骤，并迫使类相应地实现它们。</p><p id="6179" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">非常简单地说，如果一个类是一个对象的蓝图，你可以把接口想象成类的蓝图。</p><p id="be03" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">把接口看作一个纯粹的模板。</p><p id="8e5a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我解释一下，</p><p id="f0da" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">为什么首先需要对象接口？</p><p id="6e33" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">在PHP中，接口定义了一个类必须实现哪些方法，</strong></p><p id="5535" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">同时接口没有指定这些方法需要如何实现，</strong></p><p id="b7da" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你很快就会看到，最后一句话给了你在管理班级时很大的自由度。</p><h1 id="8ad5" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">“接口”关键字</h1><p id="1f83" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">创建接口的语法几乎与创建类的语法相同，</p><p id="2cb7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">命名一个接口通常遵循一些约定，这样会让其他人更容易理解你的代码，最常用的约定有:</p><ul class=""><li id="29aa" class="ly lz hu kc b kd ky kh kz kl ma kp mb kt mc kx md me mf mg dt translated">ThingInterface</li><li id="a6b7" class="ly lz hu kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg dt translated">IThing</li><li id="69ec" class="ly lz hu kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg dt translated">I _ Thing</li></ul><p id="c123" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在下面的例子中，我将创建我将在<em class="lj"> Building </em>类中使用的接口。</p><p id="5153" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们城市已经很有名的市长非常关心安全问题，他决定我们城市的每一栋建筑都必须有火灾报警器和集合点，以防灾难发生。</p><p id="cb06" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们编写这些接口的代码。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="3c12" class="lp jd hu ll b fv lq lr l ls lt">interface<!-- --> <!-- -->FireAlarmInterface</span><span id="2697" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="4e02" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->setFireAlarm();</span><span id="6ed6" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="b0bb" class="lp jd hu ll b fv lu lr l ls lt">interface<!-- --> <!-- -->AssemblyPointInterface</span><span id="14ad" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="5a11" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->setAssemblyPoint();</span><span id="602d" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="759b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在前面的代码片段中，您应该注意两件事，</p><p id="e776" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">第一个是接口看起来非常类似于类，</p><p id="6afe" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">第二，在方法中没有打开代码块的大括号，原因是接口并不决定方法需要如何实现，它们只是决定需要实现什么方法。</p><h1 id="d3e3" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">“实现”关键字</h1><p id="7508" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">既然已经创建了接口，我们需要在我们的<em class="lj">构建</em>类中实现它们。</p><p id="db51" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">要实现一个接口，你需要使用implements关键字。</p><p id="506b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">您必须注意的一个重要的基本特性是:<strong class="kc hv">接口中的所有方法都必须包含在实现接口</strong>的类中。</p><p id="2212" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这是强制性规定，没有例外；</p><p id="7674" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">PHP会通过在屏幕上抛出一个致命错误来让你知道你是否忘记了方法。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="05c5" class="lp jd hu ll b fv lq lr l ls lt">class<!-- --> <!-- -->Building implements<!-- --> <!-- -->FireAlarmInterface</span><span id="80d6" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="6ba8" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->setFireAlarm()</span><span id="a1b6" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="0004" class="lp jd hu ll b fv lu lr l ls lt">        $this-&gt;fireAlarm = true;</span><span id="492e" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="fbf1" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="ea02" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如前所述，接口中的所有方法都必须在一个类中实现；</p><p id="8db5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">否则将导致致命错误。</p><p id="fce9" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">与继承不同，一个类可以实现多个接口。</p><p id="3023" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">事实上，</p><p id="1367" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果需要，您可以列出尽可能多的接口，并用逗号分隔每个接口。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="e9fb" class="lp jd hu ll b fv lq lr l ls lt">class<!-- --> <!-- -->Building implements<!-- --> <!-- -->FireAlarmInterface, AssemblyPointInterface</span><span id="c1b2" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="6bd1" class="lp jd hu ll b fv lu lr l ls lt">    …</span><span id="9c9b" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="b017" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">尽管这是PHP的一个令人印象深刻的特性，但让我再次强调，实现的每个接口的每个方法都必须包含在类中，这可能会导致很多混乱。</p><p id="d5b0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">因此，请谨慎使用您的接口，只有在您研究了所有可能出现的问题之后才使用它们。</p><h1 id="d60e" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">PHP包含的内置接口列表</h1><p id="1e39" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">PHP有一些集成到语言中的接口。</p><p id="b0b3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">虽然它们中的大部分不太可能在日常生活中使用，但有些可能非常有用，肯定会在项目开发过程中为您节省一些时间。</p><h1 id="0e1c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">可否定的</h1><p id="cac2" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">顾名思义，<strong class="kc hv"> <em class="lj">可遍历</em>接口分析一个类并返回一个布尔值，这取决于该类是否使用foreach </strong>来实现可遍历。</p><p id="332b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这个接口没有方法，它的目的是作为可遍历类的基础。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="968d" class="lp jd hu ll b fv lq lr l ls lt">Traversable {</span><span id="180d" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="6001" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">您可以在条件语句中使用该接口来检查如果使用foreach，某些内容是否可用。</p><p id="5a05" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这里有一个简单的例子</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="8c1a" class="lp jd hu ll b fv lq lr l ls lt">if( $buildings<!-- --> <!-- -->instanceof<!-- --> <!-- -->Traversable ){</span><span id="9b1a" class="lp jd hu ll b fv lu lr l ls lt">    foreach<!-- --> <!-- -->($buildings<!-- --> <!-- -->as<!-- --> <!-- -->$building){</span><span id="ba37" class="lp jd hu ll b fv lu lr l ls lt">        …<!-- --> </span><span id="00d9" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="5fbe" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="7ac2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">请注意，该接口不能在数组和对象上工作，<br/>，这意味着您不能使用<em class="lj"> Traversable </em>来检查这些类型的变量是否可以在数组中使用。</p><p id="8dce" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">为什么一开始就需要验证它们呢？</p><h1 id="153c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">迭代程序</h1><p id="dc35" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这个<em class="lj">接口</em>作用于可以重复自身的对象或迭代器。</p><p id="127f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">上面的句子只是意味着您可以将<em class="lj">迭代器</em>接口扩展到任何可遍历的元素，并在类中包含以下方法。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="3138" class="lp jd hu ll b fv lq lr l ls lt">Iterator extends<!-- --> <!-- -->Traversable {</span><span id="8ed6" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->current ()</span><span id="2a95" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="fa41" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="f685" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->key ()</span><span id="3a0e" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="f876" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="53d3" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->next ()</span><span id="4107" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="4280" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="5f84" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- -->  <!-- -->rewind<!-- --> <!-- -->()</span><span id="1ccb" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="f202" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="79ae" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->valid ()</span><span id="4924" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="d406" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="1199" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="d9a0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">明白了吗？？<br/>这里有一个真实的例子，展示了该接口可能如何真正用于:</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="92f8" class="lp jd hu ll b fv lq lr l ls lt">public<!-- --> <!-- -->function<!-- --> <!-- -->rewind()</span><span id="78a6" class="lp jd hu ll b fv lu lr l ls lt">{</span><span id="8d11" class="lp jd hu ll b fv lu lr l ls lt">    $this-&gt;position = 0;</span><span id="26e4" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="b8ed" class="lp jd hu ll b fv lu lr l ls lt">public<!-- --> <!-- -->function<!-- --> <!-- -->current() {</span><span id="4b45" class="lp jd hu ll b fv lu lr l ls lt">    return<!-- --> <!-- -->$this-&gt;array[$this-&gt;position];</span><span id="e14e" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="f21b" class="lp jd hu ll b fv lu lr l ls lt">public<!-- --> <!-- -->function<!-- --> <!-- -->key() {</span><span id="f6d9" class="lp jd hu ll b fv lu lr l ls lt">    return<!-- --> <!-- -->$this-&gt;position;</span><span id="3b8b" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="de2b" class="lp jd hu ll b fv lu lr l ls lt">public<!-- --> <!-- -->function<!-- --> <!-- -->next() {</span><span id="387b" class="lp jd hu ll b fv lu lr l ls lt">    ++$this-&gt;position;</span><span id="bf27" class="lp jd hu ll b fv lu lr l ls lt">}</span><span id="b2b1" class="lp jd hu ll b fv lu lr l ls lt">public<!-- --> <!-- -->function<!-- --> <!-- -->valid() {</span><span id="941f" class="lp jd hu ll b fv lu lr l ls lt">    return<!-- --> <!-- -->isset($this-&gt;array[$this-&gt;position]);</span><span id="875c" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><h1 id="840e" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">迭代器聚合</h1><p id="33a2" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><em class="lj"> IteratorAggregate </em>接口只是在代码中实现迭代器的另一种方法。</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="c75c" class="lp jd hu ll b fv lq lr l ls lt">IteratorAggregate extends<!-- --> <!-- -->Traversable {</span><span id="158d" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getIterator ()</span><span id="53b3" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="7d90" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="c413" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="441e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">使用这个接口的好处是速度快，</p><p id="a92e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">事实上，<em class="lj"> IteratorAggregate </em>比其他选项要快得多，</p><p id="4d94" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你需要注意，尽管名字如此，这不是一个迭代器，但它是一个<em class="lj">可遍历的</em>。<br/>这意味着没有下一个、关键、当前、有效、倒带方法可用。</p><h1 id="e620" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">可投掷的</h1><p id="5dea" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><em class="lj"> Throwable </em>接口用于所有可以通过throw语句抛出的对象，<br/>包括错误和异常。<br/>以下是接口及其完整的方法列表:</p><pre class="lf lg lh li fq lk ll lm ln aw lo dt"><span id="d54f" class="lp jd hu ll b fv lq lr l ls lt">interface<!-- --> <!-- -->Throwable {</span><span id="b4c4" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getMessage ()</span><span id="0ccd" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="9a19" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="7897" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getCode ()</span><span id="20d2" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="2b40" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="babe" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getFile ()</span><span id="6829" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="7387" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="c52a" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getLine ()</span><span id="f5b6" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="7b1f" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="c9aa" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getTrace ()</span><span id="ba21" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="5a26" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="1663" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getTraceAsString ()</span><span id="2178" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="3ba7" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="3a40" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->getPrevious ()</span><span id="ad3d" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="0b5c" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="d0e7" class="lp jd hu ll b fv lu lr l ls lt">    function<!-- --> <!-- -->__toString ()</span><span id="64ab" class="lp jd hu ll b fv lu lr l ls lt">    {</span><span id="a16d" class="lp jd hu ll b fv lu lr l ls lt">    }</span><span id="3140" class="lp jd hu ll b fv lu lr l ls lt">}</span></pre><p id="5c71" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">PHP不能直接实现这个接口，</p><p id="9c0e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它只能通过异常来扩展。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><a href="http://eepurl.com/dIZqjf"><div class="fe ff mm"><img src="../Images/81f240e8dd073aab6ad31da0e0d28d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FKpkkhRhWP0iLk7FpzTbQ.jpeg"/></div></a></figure></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><h1 id="8334" class="jc jd hu bd je jf mu jh ji jj mv jl jm jn mw jp jq jr mx jt ju jv my jx jy jz dt translated">第二部分的结论</h1><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9c8417bcd9597d7d53e1d71f25602b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L0zKla3y-khFYODf.jpg"/></div></div></figure><p id="d9a5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><a class="ae ld" href="https://www.amazon.co.uk/dp/B07J47L6PB" rel="noopener ugc nofollow" target="_blank">一体化版的《面向对象编程完全指南》的完整版在亚马逊上有Kindle格式的版本</a></p><p id="7356" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">不过不要担心，以下部分将在接下来的几周内发布。</p><p id="0cf2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">…这位Web开发人员真的相信他的工作非常出色，说实话，他是对的。</p><p id="3780" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">他已经能够创建他脑海中的一切，他可以从头开始创建应用程序，甚至是让他的老板和客户满意的复杂系统，</p><p id="7c0b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">他意识到的是，他的领域是一个不停的学习，一件事情之后是另一件，然后是另一件，然后是另一件。</p><p id="44e3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">今天你像他一样，</p><p id="f042" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你已经学习了OOP基础知识 ，现在你知道了更多的关键词，明天你将沉浸在其他信息中。</p><p id="98c0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">编程永无止境，你认为你知道的越少，你就变得越好。</strong></p><p id="70df" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你在开发知识的哪一部分？你已经学会了所有的东西，还是刚刚开始接触面向对象的原则？</p><p id="680f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">请在下面的评论中告诉我…</p><p id="673c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="lj">如果你喜欢这个内容，并且你渴望更多的内容</em> <a class="ae ld" href="https://www.facebook.com/anastasionico.uk/" rel="noopener ugc nofollow" target="_blank"> <em class="lj">加入脸书的社区</em> </a> <em class="lj">，在这里我们可以像这样分享信息和新闻！</em></p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="mz lw l"/></div></figure></div></div>    
</body>
</html>