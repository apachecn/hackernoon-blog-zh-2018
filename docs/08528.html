<html>
<head>
<title>(Even) More Reasons to Use Buck Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(甚至)更多使用降压构建的理由</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/even-more-reasons-to-use-buck-build-9e2f6bf451d4?source=collection_archive---------15-----------------------#2018-10-12">https://medium.com/hackernoon/even-more-reasons-to-use-buck-build-9e2f6bf451d4?source=collection_archive---------15-----------------------#2018-10-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/46388a8c8a59a980e46a6387712ee6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DQJ5cEQtHxZdtYBk"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“Why? signage near grass during daytime” by <a class="ae jg" href="https://unsplash.com/@kentreloar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ken Treloar</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="74ff" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">出色的预编译头文件支持</h1><p id="1642" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">大多数人对预编译头文件又爱又恨(PCH)。一方面，它们可以极大地加速你的构建时间(30%并非闻所未闻)，但另一方面，它们<em class="ld">可以</em>对你的增量构建时间产生毁灭性的影响。</p><p id="6a12" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">一旦使用，预编译头必须在每次包含的头改变时更新。现在，每个使用PCH的翻译单元也需要重新编译，这可能比必要的要频繁得多。PCHs有效地使每个翻译单元依赖于PCH中的每个头文件。</p><p id="40c2" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">然而，有了巴克，你就可以两全其美。通过从头开始为您的构建(例如CI构建)切换<code class="eh lj lk ll lm b">enable_pch</code>，然后为增量构建(例如开发)禁用它，您可以仅在适当的时候使用PCHs。Buck将PCH编码为一个高级抽象，因此在构建脚本中不需要任何模板代码来实现它。</p><p id="6736" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">此外，Buck确保所有PCH、库和可执行文件使用相同的编译器和预处理器标志集。</p><h1 id="24df" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">缓存共享是内置的</h1><p id="ae2f" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">您是否曾在审查PR时犹豫过切换分支，因为这可能会触发全面重建？Buck可以通过您的文件系统或HTTP共享您的缓存。这意味着您可以切换到不同的分支并返回，同时维护您的构建缓存。</p><h1 id="18ce" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">构建是可复制的</h1><p id="3a74" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">构建步骤可能非常复杂，相同的构建会导致二进制级别的细微差异。因此，人工产物的散列是不可再现的，由于缓存未命中而导致许多不必要的重建。Buck编排了GCC之类的常用工具，以确保artefact hash只随其输入而变化。有了巴克，你就不会经常重建。</p><h1 id="c872" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">对定制构建脚本的良好支持</h1><p id="bacc" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">与大多数构建系统不同，Buck缓存每一个人工制品，包括生成的文件。每个人工制品只有在其依赖关系的散列改变时才被重建。这比只缓存C++编译器工件的解决方案(如CCache)更全面。</p><h1 id="3843" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">强大的工具链支持</h1><p id="cc5b" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">没有很多抽象的构建系统，比如Make，依赖于约定来定义你的工具链。例如，C++编译器可能被定义为<code class="eh lj lk ll lm b">$CXX</code>。这是很脆弱的，因为它要求每个人都遵循相同的约定，当你有很多依赖时，这可能是一场噩梦。Buck在一个更高的抽象层次上工作，所以你一旦定义了你的工具链，它就能保证它在你的整个项目中得到尊重。</p><h1 id="ebaa" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">额外:对云雀的实验支持</h1><p id="f09f" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">Buck和Bazel正在汇聚到同一个构建描述语言:Skylark。Skylark是Python的一个子集，它提供了更快的解析时间。在一些大型项目中，这将解析时间从几分钟减少到几秒钟。</p><h1 id="1a9a" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">您可能也对…感兴趣</h1><div class="ln lo fm fo lp lq"><a href="https://hackernoon.com/7-reasons-to-use-buck-build-5b44d7413585" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab ej"><div class="ls ab lt cl cj lu"><h2 class="bd hv fv z el lv eo ep lw er et ht dt translated">使用降压构建的7个理由</h2><div class="lx l"><h3 class="bd b fv z el lv eo ep lw er et ek translated">Buck是一个跨平台、跨语言构建系统，在脸书为大规模编译而设计。所有牛仔…</h3></div><div class="ly l"><p class="bd b gc z el lv eo ep lw er et ek translated">hackernoon.com</p></div></div></div></a></div><div class="ln lo fm fo lp lq"><a href="https://hackernoon.com/lessons-learned-from-porting-300-projects-to-buck-build-ff6463b65142" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab ej"><div class="ls ab lt cl cj lu"><h2 class="bd hv fv z el lv eo ep lw er et ht dt translated">将300个C/C++项目移植到Buck Build的经验教训</h2><div class="lx l"><h3 class="bd b fv z el lv eo ep lw er et ek translated">有了Buckaroo，我们正在将C/C++项目的庞大生态系统转变为一系列易于组装的构建…</h3></div><div class="ly l"><p class="bd b gc z el lv eo ep lw er et ek translated">hackernoon.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me ja lq"/></div></div></a></div></div></div>    
</body>
</html>