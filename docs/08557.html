<html>
<head>
<title>RxSwift: Benefits and Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift:优势和使用案例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rxswift-benefits-and-use-cases-e9ddc59a7bbe?source=collection_archive---------13-----------------------#2018-10-14">https://medium.com/hackernoon/rxswift-benefits-and-use-cases-e9ddc59a7bbe?source=collection_archive---------13-----------------------#2018-10-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/5cebe5b1d0333357cbdec7a20e91c25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*q_rypx6eoLBS8NjHrFK1sQ.jpeg"/></div></figure><p id="d7ea" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">自2014年发布以来，Swift因其灵活性和相对容易的学习曲线而成为最常用的编程语言之一。除了与众所周知的面向对象编程(OOP)范式兼容之外，该语言还允许以函数式反应式编程(FRP)风格编写代码(尽管是以稍微定制的、不真实的形式)。</p><p id="523c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">特别是，出于FRP的目的，<a class="ae jw" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"> RXSwift </a>库是在Swift首次发布两年后创建的。它在很短的时间内变得非常流行。</p><p id="9520" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我们将讨论这个库的概念，回答问题“为什么使用RXSwift？”，并描述在您的应用程序中使用它的好处。</p><h1 id="e1e7" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">定义:什么是函数式反应式编程？</h1><p id="ca36" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">RXSwift是什么？为了充分理解它的目的，并回答这个问题，你应该发现一些相关术语的含义。</p><p id="6f4a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">那么，什么是函数反应式编程(FRP)？基本上，它是反应式编程和函数式编程的结合使用。所以，如果你想正确地定义每件事，弄清每个方法的意义是必须的。</p><p id="4d9f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae jw" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应式编程</a>是一种特殊的编程范式，它会自动改变“附属于”应用性能变化的所有变量。例如，如果在命令式编程中，赋值语句z = x + y仅在当前时刻影响z值，那么在反应式编程的情况下，z将根据应用程序执行期间x和y的定制方式自动转换。</p><p id="7f16" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就像打开电灯开关一样:开关和灯泡是耦合组件。用编码术语来说:假设灯泡对开关做出反应，并相应地转换其状态，那么它是<strong class="ja hv">反应性的</strong>，开关是<strong class="ja hv">可观察的，</strong>因为它只观察灯泡状态的变化。</p><p id="a33c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">总而言之，反应式编程就是编写定义如何对变化做出反应的代码:用户输入、来自流的数据、系统状态的变化等等。</p><p id="fcbd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae jw" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>是命令式编码的对立面。它允许通过数学关系(即函数)来表达系统代码逻辑，而不是严格的动作序列(这是命令式编码的一个特征)。它允许显著地减少一般的代码量，使其更容易进行单元测试，并且减少了出现在独立变量之间的连接定义中的错误数量。</p><p id="3b8b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因此，<a class="ae jw" href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="noopener ugc nofollow" target="_blank">功能反应式编程</a>是一种全新的解决方案，用于在互连变量中分配定制。FRP的解释之一是RxSwift库——用同一种语言编写的带有反应式扩展的Swift版本。其目的是当应用程序在用户移动设备上运行时，处理在后台执行的异步代码。</p><p id="8379" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外:</p><ul class=""><li id="fb47" class="la lb hu ja b jb jc jf jg jj lc jn ld jr le jv lf lg lh li dt translated">它是一个借助可观察序列来编写异步和基于事件的程序的工具。无需担心同步、低级线程、非阻塞I/O、线程安全和并发数据结构。observer模式被扩展以支持数据序列和/或事件，并且添加了操作符，以便您能够以声明的方式将序列组合在一起。</li><li id="4776" class="la lb hu ja b jb lj jf lk jj ll jn lm jr ln jv lf lg lh li dt translated">“可观察的”可以被用作一个通用的、高度可组合的模式。这样，你就不必一次使用大量的模式，比如完成块、目标动作、委托以及其他许多模式。</li></ul><h1 id="3a59" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">在哪些情况下应该使用RxSwift？</h1><p id="5c6d" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">首先，你必须认识到RxSwift的身体和灵魂是可观察的序列，即基于可观察序列中的状态变化而执行的事物。</p><p id="2e5d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">大多数iOS开发人员注意到，学习RXSwift基础知识很难。然而，事实是，异步调用是一件复杂的事情。由于处理它们的困难和技术的年轻，许多没有经验的程序员有时宁愿忽略RxSwift。它三年前才出现，还没有足够的时间收集完整的文档和专题文章。这正是我们决定尝试帮助您了解何时以及为何使用RXSwift的原因，以便您可以评估自己花时间学习这项技术的合理性。</p><p id="2255" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">事实上，如果您能够很好地理解FRP概念，那么您可能已经得出结论，RxSwift可以极大地简化您的工作。让我们弄清楚这个库解决了哪些特定的问题。总而言之，在以下情况下使用它:</p><h2 id="d2ce" class="lo jy hu bd jz lp lq lr kd ls lt lu kh jj lv lw kl jn lx ly kp jr lz ma kt mb dt translated">你被频繁使用KVO的必要性所困扰</h2><p id="c760" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated"><a class="ae jw" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" rel="noopener ugc nofollow" target="_blank"> KVO(键值观察)</a>是Objective-C中实践的一种技术，它允许通知对象关于其他对象状态的特定变化。然而，尽管KVO有明显的强大功能，它在程序员中并不流行。这通常被认为是一种绝望的措施，只有在没有其他解决办法的情况下才使用。问题是，这项技术有一个相当大的缺点——严重的性能消耗。经常用的时候肯定有感觉。反过来，RXSwift的创建者通过最小化使用这个API的必要性，从根本上解决了这个问题。</p><h2 id="c950" class="lo jy hu bd jz lp lq lr kd ls lt lu kh jj lv lw kl jn lx ly kp jr lz ma kt mb dt translated">您需要同步两个请求</h2><p id="af2f" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">在某些情况下，开发人员必须调用API来重新设计当前的UI表示。这是因为<a class="ae jw" href="http://adamborek.com/practical-introduction-rxswift/" rel="noopener ugc nofollow" target="_blank">并不是所有的REST API</a>都适合为移动平台创建应用。即使对于有经验的开发人员来说，为调用提供同步也是困难的。为此，您必须记住一些布尔变量(在处理用户请求时，它们的值可能会有所不同)，并努力创建一个类来组织变量之间的相互联系。如果您使用的是RxSwift，那么您可以简单地使用一个<a class="ae jw" href="http://reactivex.io/documentation/operators/zip.html" rel="noopener ugc nofollow" target="_blank"> zip </a>操作符，该操作符将两个观察值结合起来，并在处理完两个API请求时发送一个应答。</p><h2 id="64c7" class="lo jy hu bd jz lp lq lr kd ls lt lu kh jj lv lw kl jn lx ly kp jr lz ma kt mb dt translated">你不想让自己忙于代表</h2><p id="06eb" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">事实上，RxSwift消除了使用大量委托的严格必要性。为什么？UI开发与对各种异步任务的反应密切相关。最简单的反应方式是使用观察者模板。就Swift而言，这些模板就是众所周知的代表。我们相信，代理极大地帮助了开发人员解决了异步调用的问题。它们用于将方法作为参数传递给其他方法。</p><p id="a031" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然而，为此，他们需要编写大量的代码，包括变量的创建、协议的创建和定义，以及变量的安装。在这种方式下，虽然开发人员(或开发团队)必须在一个单一的接口上工作，但委托的实现和进一步使用需要记住大量的信息。</p><p id="a5a4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">反过来，RxSwift设法彻底解决了这个问题。这个库引入了以声明性风格编写代码的能力，而不增加UIViewController的大小，也不需要objc(通常，需要objc来获得一些额外的必需函数)。</p><h2 id="c78f" class="lo jy hu bd jz lp lq lr kd ls lt lu kh jj lv lw kl jn lx ly kp jr lz ma kt mb dt translated">你努力创造模块化代码</h2><p id="572c" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">有时，开发人员需要使用属性观察器来跟踪与被观察对象相关的任何定制，并立即对其做出反应。它们与didSet(用于在自定义属性后执行代码)和willSet操作(用于在自定义属性前执行代码)一起操作。另一方面，使用属性观察者的代码构造可能看起来过于庞大。使用RxSwift，你可以减少代码的总量，将代码的某些部分分成独立的功能。</p><h1 id="4c12" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">总结RxSwift的优点</h1><p id="f7a2" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">用几句话总结上述所有内容，开始使用RxSwift，您可能会获得以下优势:</p><ul class=""><li id="d4e5" class="la lb hu ja b jb jc jf jg jj lc jn ld jr le jv lf lg lh li dt translated">编写多用途代码的能力；</li><li id="77d5" class="la lb hu ja b jb lj jf lk jj ll jn lm jr ln jv lf lg lh li dt translated">声明式编码风格的优势；</li><li id="4580" class="la lb hu ja b jb lj jf lk jj ll jn lm jr ln jv lf lg lh li dt translated">代码结构的简洁性和可读性；</li><li id="1e3b" class="la lb hu ja b jb lj jf lk jj ll jn lm jr ln jv lf lg lh li dt translated">合理管理app资源；</li><li id="1528" class="la lb hu ja b jb lj jf lk jj ll jn lm jr ln jv lf lg lh li dt translated">与MVVM模板完美兼容；</li><li id="62bf" class="la lb hu ja b jb lj jf lk jj ll jn lm jr ln jv lf lg lh li dt translated">发展迅速，支持广泛；</li><li id="596e" class="la lb hu ja b jb lj jf lk jj ll jn lm jr ln jv lf lg lh li dt translated">程序员职业生涯进一步发展的最佳条件(类似的技术也存在于Java和JavaScript中，所以即使是基本的RxSwift知识也会帮助你在React-Native上编写跨平台的应用程序，例如)。</li></ul><h1 id="f699" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">Swift的反应式编程:结论</h1><p id="95d4" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">正如你所看到的，尽管掌握理论上的RxSwift很复杂，但这项技术能够简化iOS开发人员的生活。我们强烈建议学习RXSwift的基础知识。另一方面，你可以把你的iOS项目<a class="ae jw" href="https://applikeysolutions.com/" rel="noopener ugc nofollow" target="_blank">的技术实现的责任放在我们</a>身上！我们将为您提供一个完全现成的解决方案，不需要任何额外的修复或增强(至少在很长一段时间内——进步不会停滞不前)。填写<a class="ae jw" href="https://applikeysolutions.com/contact" rel="noopener ugc nofollow" target="_blank">这张表格</a>以便讨论我们合作的所有细节，我们将很快与您联系！</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><p id="95fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">【applikeysolutions.com】最初发表于<a class="ae jw" href="https://applikeysolutions.com/blog/rxswift-benefits-and-use-cases" rel="noopener ugc nofollow" target="_blank"><em class="mj"/></a><em class="mj">。</em></p></div></div>    
</body>
</html>