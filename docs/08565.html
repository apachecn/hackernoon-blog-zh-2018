<html>
<head>
<title>Golang — handling errors gracefully</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang —优雅地处理错误</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/golang-handling-errors-gracefully-8e27f1db729f?source=collection_archive---------1-----------------------#2018-10-15">https://medium.com/hackernoon/golang-handling-errors-gracefully-8e27f1db729f?source=collection_archive---------1-----------------------#2018-10-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0edef751d2aef868d97a5c933338b23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCY6kikgN2Lu-5MYIVxHcw.jpeg"/></div></div></figure><p id="26fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然<strong class="je hv"> go </strong>有一个简单的错误模型，但是乍一看，事情并没有想象中那么简单。在本文中，我想提供一个很好的策略来处理错误并克服您可能会遇到的问题。</p><p id="81a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们要分析什么是围棋中的失误。</p><p id="403f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们将看到错误创建和错误处理之间的流程，并分析可能的缺陷。</p><p id="806a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们将探索一种解决方案，它允许我们在不损害应用程序设计的情况下克服这些缺陷。</p><h1 id="5f34" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">围棋中什么是错误</h1><p id="1ac1" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">查看内置错误类型，我们可以得出一些结论:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="c4c9" class="lm kb hu li b fv ln lo l lp lq">// The error built-in interface type is the conventional interface for<br/>// representing an error condition, with the nil value representing no error.<br/>type error interface {<br/>	Error() string<br/>}</span></pre><p id="15fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们看到一个错误是一个接口实现了一个简单的方法错误返回一个字符串。</p><p id="c3ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个定义告诉我们，创建一个错误只需要一个简单的字符串，所以如果我创建以下结构:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="3634" class="lm kb hu li b fv ln lo l lp lq">type MyCustomError string</span><span id="8cf9" class="lm kb hu li b fv lr lo l lp lq">func (err MyCustomError) Error() string {<br/>  return string(err)<br/>}</span></pre><p id="a169" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想出了最简单的错误定义。</p><p id="bf2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:这只是举个例子。我们可以使用go标准包<em class="ls"> fmt </em>和<em class="ls"> errors </em>创建一个错误:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="7433" class="lm kb hu li b fv ln lo l lp lq">import (<br/>  "errors"<br/>  "fmt"<br/>)</span><span id="4450" class="lm kb hu li b fv lr lo l lp lq">simpleError := errors.New("a simple error")</span><span id="876e" class="lm kb hu li b fv lr lo l lp lq">simpleError2 := fmt.Errorf("an error from a %s string", "formatted")</span></pre><p id="f2c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一条简单的消息足以优雅地处理错误吗？让我们最后回答这个问题，探索我将提供的解决方案。</p><h1 id="5932" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">误差流</h1><p id="e652" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">因此，我们已经知道什么是错误，下一步是可视化他的生命周期中的流程。</p><p id="e845" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简单和不重复自己的原则，在一个地方对一个错误采取行动是可取的。</p><p id="29e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们举下面的例子来看看为什么:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="7c8b" class="lm kb hu li b fv ln lo l lp lq">// bad example of handling and returning the error at the same time<br/>func someFunc() (Result, error) {<br/> result, err := repository.Find(id)<br/> if err != nil {<br/>   log.Errof(err)</span><span id="60e7" class="lm kb hu li b fv lr lo l lp lq">   return Result{}, err<br/> }</span><span id="f14d" class="lm kb hu li b fv lr lo l lp lq">  return result, nil<br/>}</span></pre><p id="ec99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码有什么问题？</p><p id="e2c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们处理了两次错误，首先记录错误，然后返回给这个函数的调用者。</p><p id="a8cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可能你的一个团队同事会使用这个函数，当错误返回时，他会再次记录这个错误。然后在系统日志中出现一个错误噩梦。</p><p id="f923" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们的应用程序有3层，分别是<strong class="je hv">存储库</strong>、<strong class="je hv">交互器</strong>和<strong class="je hv"> web服务器</strong>:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="6e76" class="lm kb hu li b fv ln lo l lp lq">// The repository uses an external depedency orm<br/>func getFromRepository(id int) (Result, error) {<br/>  result := Result{ID: id}<br/>  err := orm.entity(&amp;result)<br/>  if err != nil {<br/>    return Result{}, err<br/>  }</span><span id="b0db" class="lm kb hu li b fv lr lo l lp lq">  return result, nil <br/>}</span></pre><p id="2cd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据我之前提到的原则，这是通过返回到顶部来处理错误的正确方法。稍后，它将被记录，检索正确的反馈到web服务器，所有这一切都在一个地方。</p><p id="003f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是前面的代码有一个问题。不幸的是，go builtin错误不提供堆栈跟踪。除此之外，错误是在一个外部依赖项上生成的，我们需要知道项目内部的哪段代码对这个错误负责。</p><p id="d13a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">github.com/pkg/errors</strong>前来救援。</p><p id="c7ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将通过添加堆栈跟踪和添加存储库未能获得结果的消息来重做前面的函数。我想在不损害原始错误的情况下这样做:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="ea22" class="lm kb hu li b fv ln lo l lp lq">import "github.com/pkg/errors"</span><span id="5753" class="lm kb hu li b fv lr lo l lp lq">// The repository uses an external depedency orm<br/>func getFromRepository(id int) (Result, error) {<br/>  result := Result{ID: id}<br/>  err := orm.entity(&amp;result)<br/>  if err != nil {<br/>    return Result{}, <strong class="li hv">errors.Wrapf(err, "error getting the result with id %d", id);</strong><br/>  }</span><span id="5f3b" class="lm kb hu li b fv lr lo l lp lq">  return result, nil <br/>}</span><span id="70a9" class="lm kb hu li b fv lr lo l lp lq">// after the error wraping the result will be <br/>// err.Error() -&gt; error getting the result with id 10: whatever it comes from the orm</span></pre><p id="7599" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个函数的作用是包装来自ORM的错误，在不破坏原始错误的情况下构建堆栈跟踪。</p><p id="f5be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，让我们看看其他层将如何处理错误。首先是互动者:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="4b3b" class="lm kb hu li b fv ln lo l lp lq">func getInteractor(idString string) (Result, error) {<br/>  id, err := strconv.Atoi(idString)<br/>  if err != nil {<br/>    return Result{}, errors.Wrapf(err, "interactor converting id to int")<br/>  }</span><span id="a8df" class="lm kb hu li b fv lr lo l lp lq">  return repository.getFromRepository(id) <br/>}</span></pre><p id="10c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在是顶层，web服务器:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="844a" class="lm kb hu li b fv ln lo l lp lq">r := mux.NewRouter()<br/>r.HandleFunc("/result/{id}", ResultHandler)</span><span id="cfa0" class="lm kb hu li b fv lr lo l lp lq">func ResultHandler(w http.ResponseWriter, r *http.Request) {<br/>  vars := mux.Vars(r)<br/>  result, err := interactor.getInteractor(vars["id"])<br/>  if err != nil { <br/>    handleError(w, err) <br/>  }</span><span id="e8ac" class="lm kb hu li b fv lr lo l lp lq">  fmt.Fprintf(w, result)<br/>}</span><span id="4942" class="lm kb hu li b fv lr lo l lp lq">func handleError(w http.ResponseWriter, err error) { <br/>   w.WriteHeader(http.StatusIntervalServerError)<br/>   log.Errorf(err)<br/>   fmt.Fprintf(w, err.Error())<br/>}</span></pre><p id="7bb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你看到的，我们只是在顶层处理了错误。完美？不。如果你注意到我们总是返回500作为HTTP响应代码。除此之外，我们总是记录错误。一些错误如“没有找到结果”只是给我们的日志增加了噪音。</p><h1 id="fc3b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">我的解决方案</h1><p id="90eb" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我们在上一个主题中看到，当处理顶层的错误时，一个字符串不足以做出决策。</p><p id="ee3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们知道，如果我们在一个错误中引入一些新的东西，我们会在错误产生的地方和错误最终被处理的时候，以某种方式引入一种依赖性。</p><h2 id="2779" class="lm kb hu bd kc lt lu lv kg lw lx ly kk jn lz ma ko jr mb mc ks jv md me kw mf dt translated">因此，让我们探索一个定义了3个目标的解决方案:</h2><ul class=""><li id="7bbd" class="mg mh hu je b jf ky jj kz jn mi jr mj jv mk jz ml mm mn mo dt translated">提供良好的错误堆栈跟踪</li><li id="659b" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">记录错误(例如web基础设施层)</li><li id="60ee" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">必要时向用户提供上下文错误信息。(例如，提供的电子邮件格式不正确)</li></ul><p id="53d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们创建一个错误类型:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="b874" class="lm kb hu li b fv ln lo l lp lq">package errors</span><span id="6dd9" class="lm kb hu li b fv lr lo l lp lq">const(<br/>  NoType = ErrorType(iota)<br/>  BadRequest<br/>  NotFound <br/>  //add any type you want<br/>)</span><span id="bc0a" class="lm kb hu li b fv lr lo l lp lq">type ErrorType uint</span><span id="854b" class="lm kb hu li b fv lr lo l lp lq">type customError struct {<br/>  errorType ErrorType <br/>  originalError error <br/>  contextInfo map[string]string <br/>}</span><span id="d095" class="lm kb hu li b fv lr lo l lp lq">// Error returns the mssage of a customError<br/>func (error customError) Error() string {<br/>   return error.originalError.Error()<br/>}</span><span id="fcd3" class="lm kb hu li b fv lr lo l lp lq">// New creates a new customError<br/>func (type ErrorType) New(msg string) error {<br/>   return customError{errorType: type, originalError: errors.New(msg)}<br/>}<br/><br/>// New creates a new customError with formatted message<br/>func (type ErrorType) Newf(msg string, args ...interface{}) error {    <br/>   err := fmt.Errof(msg, args...)<br/>   <br/>   return customError{errorType: type, originalError: err}<br/>}<br/><br/>// Wrap creates a new wrapped error<br/>func (type ErrorType) Wrap(err error, msg string) error {<br/>   return type.Wrapf(err, msg)<br/>}<br/><br/>// Wrap creates a new wrapped error with formatted message<br/>func (type ErrorType) Wrapf(err error, msg string, args ...interface{}) error { <br/>   newErr := errors.Wrapf(err, msg, args..)   <br/>   <br/>   return customError{errorType: errorType, originalError: newErr}<br/>}</span></pre><p id="fe39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以你可以看到，我只公开了错误类型和错误类型。我们可以创建新的错误并包装现有的错误。</p><p id="bad1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我们遗漏了两件事。</p><p id="85f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何在不导出customError的情况下检查错误类型？</p><p id="75f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何向错误添加/获取上下文，甚至是从外部依赖中预先存在的错误？</p><p id="5634" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们采用<strong class="je hv">github.com/pkg/errors.</strong>的策略，首先包装这些库方法。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="3b04" class="lm kb hu li b fv ln lo l lp lq">// New creates a no type error<br/>func New(msg string) error {<br/>   return customError{errorType: <em class="ls">NoType</em>, originalError: errors.New(msg)}<br/>}<br/><br/>// Newf creates a no type error with formatted message<br/>func Newf(msg string, args ...interface{}) error {<br/>   return customError{errorType: <em class="ls">NoType</em>, originalError: errors.New(fmt.Sprintf(msg, args...))}<br/>}<br/><br/>// Wrap wrans an error with a string<br/>func Wrap(err error, msg string) error {<br/>   return Wrapf(err, msg)<br/>}<br/><br/>// Cause gives the original error<br/>func Cause(err error) error {<br/>   return errors.Cause(err)<br/>}<br/><br/>// Wrapf wraps an error with format string<br/>func Wrapf(err error, msg string, args ...interface{}) error {<br/>   wrappedError := errors.Wrapf(err, msg, args...)<br/>   if customErr, ok := err.(customError); ok {<br/>      return customError{<br/>         errorType: customErr.errorType,<br/>         originalError: wrappedError,<br/>         contextInfo: customErr.contextInfo,<br/>      }<br/>   }<br/><br/>   return customError{errorType: <em class="ls">NoType</em>, originalError: wrappedError}<br/>}</span></pre><p id="ff68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们构建我们的方法来处理任何一般错误的上下文和类型:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="5c99" class="lm kb hu li b fv ln lo l lp lq"><br/>// AddErrorContext adds a context to an error<br/>func AddErrorContext(err error, field, message string) error {<br/>   context := errorContext{Field: field, Message: message}<br/>   if customErr, ok := err.(customError); ok {<br/>      return customError{errorType: customErr.errorType, originalError: customErr.originalError, contextInfo: context}<br/>   }<br/><br/>   return customError{errorType: <em class="ls">NoType</em>, originalError: err, contextInfo: context}<br/>}<br/><br/>// GetErrorContext returns the error context<br/>func GetErrorContext(err error) map[string]string {<br/>   emptyContext := errorContext{}<br/>   if customErr, ok := err.(customError); ok || customErr.contextInfo != emptyContext  {<br/><br/>      return map[string]string{"field": customErr.context.Field, "message": customErr.context.Message}<br/>   }<br/><br/>   return nil<br/>}<br/><br/>// GetType returns the error type<br/>func GetType(err error) ErrorType {<br/>   if customErr, ok := err.(customError); ok {<br/>      return customErr.errorType<br/>   }<br/><br/>   return <em class="ls">NoType<br/></em>}</span></pre><p id="7bbc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在回到我们的例子，我们将应用这个新的错误包:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="388d" class="lm kb hu li b fv ln lo l lp lq">import "github.com/our_user/our_project/errors"</span><span id="7ccc" class="lm kb hu li b fv lr lo l lp lq">// The repository uses an external depedency orm<br/>func getFromRepository(id int) (Result, error) {<br/>  result := Result{ID: id}<br/>  err := orm.entity(&amp;result)<br/>  if err != nil {    <br/>    msg := fmt.Sprintf("error getting the  result with id %d", id)</span><span id="b924" class="lm kb hu li b fv lr lo l lp lq">    switch err {<br/>    case orm.NoResult:<br/>        <strong class="li hv">err = errors.Wrapf(err, msg);<br/>    </strong>default: <strong class="li hv"><br/>        err = errors.NotFound(err, msg); </strong> <br/>    }</span><span id="4033" class="lm kb hu li b fv lr lo l lp lq">    return Result{}, err<br/>  }</span><span id="7f8a" class="lm kb hu li b fv lr lo l lp lq">  return result, nil <br/>}</span><span id="e287" class="lm kb hu li b fv lr lo l lp lq">// after the error wraping the result will be <br/>// err.Error() -&gt; error getting the result with id 10: whatever it comes from the orm</span></pre><p id="9c1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在互动者:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="1645" class="lm kb hu li b fv ln lo l lp lq">func getInteractor(idString string) (Result, error) {<br/>  id, err := strconv.Atoi(idString)<br/>  if err != nil { <br/>    err = <strong class="li hv">errors.BadRequest.Wrapf(err, "interactor converting id to int")</strong><br/>    err = <strong class="li hv">errors.AddContext(err, "id", "wrong id format, should be an integer)</strong><br/> <br/>    return Result{}, err<br/>  }</span><span id="122b" class="lm kb hu li b fv lr lo l lp lq">  return repository.getFromRepository(id) <br/>}</span></pre><p id="8cba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后是web服务器:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="71ad" class="lm kb hu li b fv ln lo l lp lq">r := mux.NewRouter()<br/>r.HandleFunc("/result/{id}", ResultHandler)</span><span id="fba1" class="lm kb hu li b fv lr lo l lp lq">func ResultHandler(w http.ResponseWriter, r *http.Request) {<br/>  vars := mux.Vars(r)<br/>  result, err := interactor.getInteractor(vars["id"])<br/>  if err != nil { <br/>    handleError(w, err) <br/>  }</span><span id="15d5" class="lm kb hu li b fv lr lo l lp lq">  fmt.Fprintf(w, result)<br/>}</span><span id="25e2" class="lm kb hu li b fv lr lo l lp lq">func handleError(w http.ResponseWriter, err error) { <br/>   var status int<br/>   errorType := errors.GetType(err)<br/>   switch errorType {<br/>     case BadRequest: <br/>      status = http.StatusBadRequest<br/>     case NotFound: <br/>      status = http.StatusNotFound<br/>     default: <br/>      status = http.StatusInternalServerError<br/>   }</span><span id="33e1" class="lm kb hu li b fv lr lo l lp lq">   w.WriteHeader(status) <br/>   <br/>   if errorType == errors.NoType {<br/>     log.Errorf(err)<br/>   }</span><span id="4b81" class="lm kb hu li b fv lr lo l lp lq">   fmt.Fprintf(w,"error %s", err.Error()) <br/>   <br/>   errorContext := errors.GetContext(err) <br/>   if errorContext != nil {<br/>     fmt.Printf(w, "context %v", errorContext)<br/>   }<br/>}</span></pre><p id="3f38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你所看到的，有了导出的类型和一些导出的值，我们可以更容易地处理错误。我喜欢这个解决方案的一点是，通过设计，当创建一个错误时，我们显式地显示他的类型。</p><p id="ce0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你有什么建议吗？下面评论。</p><p id="a522" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> github资源库</strong>:【https://github.com/henrmota/errors-handling-example】T4</p></div></div>    
</body>
</html>