<html>
<head>
<title>Tips for Getting Started with Helm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Helm入门提示</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tips-for-getting-started-with-helm-99b01efdab90?source=collection_archive---------7-----------------------#2018-10-15">https://medium.com/hackernoon/tips-for-getting-started-with-helm-99b01efdab90?source=collection_archive---------7-----------------------#2018-10-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="63b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您有一个想要用Helm部署的应用程序。大概你已经看到了<a class="ae jp" href="https://docs.helm.sh/" rel="noopener ugc nofollow" target="_blank">官方文件</a>和一些例子。但是你不确定如何将它们应用到你的应用程序中。这里有一些提示。</p><h1 id="f9dd" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">1了解你的码头工人形象</h1><p id="bffe" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">首先为您的应用程序准备一个docker图像，并确保您可以使用它。首先使用普通的Kubernetes描述符进行部署，或者从docker-compose开始。</p><p id="4be4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您使用普通k8s描述符完成所有工作后，您将需要考虑如何使部署更加灵活。您可能希望为不同的配置或不同的环境传递部署开关。这是介绍赫尔姆的好时机。</p><h1 id="977c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">2了解价值观文件的作用</h1><p id="0fc9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">为了确保这一点是清楚的，让我们提醒自己舵轮图的<a class="ae jp" href="https://www.nclouds.com/blog/simplify-kubernetes-deployments-helm-part-2/" rel="noopener ugc nofollow" target="_blank">结构</a>:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="f57b" class="lc jr hu ky b fv ld le l lf lg">├── Chart.yaml<br/>├── README.md<br/>├── templates<br/>│   ├── NOTES.txt<br/>│   ├── _helpers.tpl<br/>│   ├── <strong class="ky hv">deployment.yaml</strong><br/>│   ├── <strong class="ky hv">secrets.yaml</strong><br/>│   └── <strong class="ky hv">...more yaml...</strong><br/>└── <strong class="ky hv">values.yaml</strong></span></pre><p id="dc53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当用户运行<code class="eh lh li lj ky b">helm install</code>时，图表中values.yaml的条目和helm发布信息(比如惟一的发布名称)被注入到模板化的yaml资源描述符中，因为模板被评估并呈现为纯Kubernetes部署描述符。当用户使用参数或值文件运行<code class="eh lh li lj ky b">helm install</code>时，参数或值文件将覆盖在图表中的文件上。实际上，图表的值文件设置了可以被覆盖的默认值。</p><p id="9041" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这还不清楚，试试看。创建一个名为mysql-values.yaml的文件:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="472d" class="lc jr hu ky b fv ld le l lf lg">imageTag: “5.7.10”</span></pre><p id="dfbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后跑<code class="eh lh li lj ky b">helm install stable/mysql --values=mysqlvalues.yaml</code>。Helm为我们生成了一个唯一的版本名(` ignore-camel ` ), MySQL部署在集群中。<code class="eh lh li lj ky b">kubectl describe pod ignorant-camel-mysql-5dc6b947b-lf6p8 </code>的输出告诉我们，我们选择的<code class="eh lh li lj ky b">imageTag</code>已经被应用。</p><h1 id="3585" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">尝试一些东西</h1><p id="207c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当您完成安装和覆盖值后，尝试创建一个基本图表。您可以使用<code class="eh lh li lj ky b">helm create</code>来获得一个您可以修改的起始图表——在官方文档中有一个关于如何做到这一点的示例<a class="ae jp" href="https://docs.helm.sh/chart_template_guide/" rel="noopener ugc nofollow" target="_blank">。试试看。</a></p><p id="0e4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者在网上找到一个部署应用程序的指南，该应用程序使用的语言与您正在使用的语言相同。如果你能找到一个与你的应用足够相似的图表示例，那么你可以复制粘贴并以此为起点。甚至有一些工具可以给你入门的例子——比如Jenkins-X就有这些，它称之为<a class="ae jp" href="https://github.com/jenkins-x/draft-packs" rel="noopener ugc nofollow" target="_blank">草稿包</a>。</p><h1 id="150b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">4从简单开始</h1><p id="bcdf" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">大多数图表是为单个docker图像设计的。如果你有一个微服务应用程序，它有几个相互作用的部分，你可以选择你认为可以独立部署的应用程序的一小部分，并尝试为此编写一个掌舵图。</p><h1 id="40f0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">5从环境变量和<code class="eh lh li lj ky b">`if` </code>条件开始</h1><p id="cad8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">大多数图表都包括将环境变量注入Pod中的docker容器。所以你会在一个<code class="eh lh li lj ky b">deployment.yaml</code>中看到这样的东西:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="5393" class="lc jr hu ky b fv ld le l lf lg">- name<strong class="ky hv">: </strong>ENV_VAR1<br/>  value: {{ .Values.var1 }}<br/>- name<strong class="ky hv">: </strong>ENV_VAR2<br/>  value: {{ .Values.var2 }</span></pre><p id="8b19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样，图表的用户可以在他们的values.yaml中或者用<code class="eh lh li lj ky b">—set var1=foo </code>覆盖这些值。</p><p id="4f68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常还有控制是否启用配置的选项。因此，您可能会发现类似这样的内容:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ddad" class="lc jr hu ky b fv ld le l lf lg">- name<strong class="ky hv">: </strong>ENV_VAR1<br/>  value: {{ .Values.var1 }}<br/>{{- if .Values.var2 }}<br/>- name<strong class="ky hv">: </strong>ENV_VAR2<br/>  value: {{ .Values.var2 }<br/>{{- end }}</span></pre><p id="663e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么只有在为<code class="eh lh li lj ky b">var2</code>设置了值的情况下，才会设置<code class="eh lh li lj ky b">ENV_VAR2 </code>。或者你可以</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="9749" class="lc jr hu ky b fv ld le l lf lg">- name<strong class="ky hv">: </strong>ENV_VAR1<br/>  value: {{ .Values.var1 }}<br/>{{- if .Values.var2enabled }}<br/>- name<strong class="ky hv">: </strong>ENV_VAR2<br/>  value: {{ .Values.var2 }<br/>{{- end }}</span></pre><p id="14d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么只有当<code class="eh lh li lj ky b">var2enabled </code>为真时<code class="eh lh li lj ky b">ENV_VAR2 </code>才会被设置。</p><p id="0e43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lh li lj ky b">if </code>指令是一个容易理解的舵<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/control_structures.md#ifelse" rel="noopener ugc nofollow" target="_blank">控制结构</a>，允许你做很多事情。</p><h1 id="f6df" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">6你可以使用不同的值文件</h1><p id="1aad" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们已经看到，我们可以创建一个定制的<code class="eh lh li lj ky b">mysqlvalues.yaml</code>文件，并将其传递到官方的mysql图表中。我们也可以用自己的图表做到这一点。如果我们有不同的配置要应用于不同的环境，例如转移和生产，这将非常方便。</p><h1 id="a792" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">7期望调试</h1><p id="d80d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">带<code class="eh lh li lj ky b">--dry-run --debug</code>选项的舵安装非常有用。它不会真正部署您的图表，但它会运行部署中涉及的检查，因此您会知道自己是否做了一些根本错误的事情。它还显示了生成的Kubernetes描述符。这可以让你检查你的图表是否如你所愿。</p><h1 id="1707" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">8先不要担心发布</h1><p id="173a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">最终，您可能会想要<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/helm/helm_package.md" rel="noopener ugc nofollow" target="_blank">打包</a>您的图表，并在<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/chart_repository.md" rel="noopener ugc nofollow" target="_blank">图表存储库</a>中发布它们。但是，只有当你希望别人能够消费你的图表并在它们的基础上构建时，才需要这样做。首先，你可以只从源代码开始工作，因为这会使事情变得更容易。如果它们在源代码控制中，那么其他人可以像您一样将它们从源代码控制中签出，直到您建立了图表存储库。</p><h1 id="3ee0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">9了解版本名称</h1><p id="f2c2" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们之前看到过，当我们安装mysql chart Helm时，它为我们创建的安装生成了发布名称“ignored-camel”。helm将这个发布名称注入到helm从我们的图表中生成的kubernetes部署描述符中。这确保了部署的每个资源都有一个惟一的名称(<a class="ae jp" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/" rel="noopener ugc nofollow" target="_blank">和kubernetes需要它来</a>)，即使我们多次安装图表。发生这种情况是因为模板包含如下内容:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="3b90" class="lc jr hu ky b fv ld le l lf lg">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name:  {{ .Release.Name }}-myservice</span></pre><p id="016f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以<code class="eh lh li lj ky b">{{ .Release.Name }}</code>是一个占位符，Helm将在其中注入发布名称。对于许多图表，您更可能会看到这种情况:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="ec63" class="lc jr hu ky b fv ld le l lf lg">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: {{ template "fullname" . }}</span></pre><p id="9f2c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这相当于在图表中的<code class="eh lh li lj ky b">_helpers.tpl</code>中定义了模板全名函数，并使用发布名称和图表名称。</p><p id="1252" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您开始在图表中部署需要相互引用多个资源时，您需要意识到这一点。如果资源是在您的图表中定义的，那么您需要注意通过使用相同的函数来使用定义中使用的相同名称。因此，如果您想将一个环境变量注入到包含上述服务名称的Pod中，那么您可以:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c9e5" class="lc jr hu ky b fv ld le l lf lg">- name: SERVICE_NAME<br/>  value: {{ template "fullname" . }}</span></pre><h1 id="5748" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">10互动很棘手</h1><p id="daef" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">假设你有一堆微服务，它们作为一个应用程序协同工作。如果服务只是一起使用，不需要单独部署，这可能是一个大图表。但最有可能的是你需要能够分开。因此，棘手的是如何为每个部分建立单独的图表，并让它们相互交流。</p><p id="971c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以你会想要使用<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/subcharts_and_globals.md" rel="noopener ugc nofollow" target="_blank">子图</a>。这使我们可以在图表中包含其他图表，以创建复合/伞状图表。我们通过引用想要包含在<code class="eh lh li lj ky b">requirements.yaml</code>中的图表并将其包含在图表的<code class="eh lh li lj ky b">charts </code>目录中来实现这一点。如果我们包含一个我们自己定义的(还没有发布)叫做<code class="eh lh li lj ky b">mysubchart</code>的图表，我们可以把它放在需求中。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="8c25" class="lc jr hu ky b fv ld le l lf lg">- name: mysubchart<br/>  version: 0.1.0</span></pre><p id="d65b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并且把<code class="eh lh li lj ky b">mysubchart </code>(它的整个目录)的整个源代码放到我们伞图的<code class="eh lh li lj ky b">charts </code>目录里。如果我们包括一个官方/出版的图表，那么我们会在需求中包括它的出版位置。yaml:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="73b2" class="lc jr hu ky b fv ld le l lf lg">- name: postgresql                         <br/>  repository: <a class="ae jp" href="https://kubernetes-charts.storage.googleapis.com" rel="noopener ugc nofollow" target="_blank">https://kubernetes-charts.storage.googleapis.com</a><br/>  version: 0.11.0</span></pre><p id="f4d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将在部署图表之前执行<code class="eh lh li lj ky b">helm dep build</code>。</p><p id="eb3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当图表拥有需要引用其他子图表的资源时，事情就变得有点棘手了。您需要知道您正在寻找的资源的名称。这些名称通常是动态生成的，包括一个版本名称。</p><p id="b5e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望图表能在其文档中清楚地说明这一点，但您可能需要查看其源代码。例如，<a class="ae jp" href="https://github.com/helm/charts/tree/master/stable/postgresql" rel="noopener ugc nofollow" target="_blank">官方postgresql图表</a>可以创建一个包含我们为postgresql实例设置的密码的秘密。如果我们在应用程序中使用postgresql(将其添加为子图表),那么我们需要引用它并将其注入到环境变量中。</p><p id="9874" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看看这个<a class="ae jp" href="https://github.com/helm/charts/blob/master/stable/postgresql/templates/secrets.yaml" rel="noopener ugc nofollow" target="_blank">秘密是如何定义的</a>或者参考<a class="ae jp" href="https://github.com/helm/charts/blob/f7cfc026e69a5b5109a5ba97caf9b4115659d57b/stable/xray/templates/xray-persist-deployment.yaml#L54" rel="noopener ugc nofollow" target="_blank">例子</a>它是如何被使用的，我们需要使用:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="c265" class="lc jr hu ky b fv ld le l lf lg">— name: POSTGRESS_PASSWORD<br/>  valueFrom:<br/>    secretKeyRef:<br/>      name: {{ .Release.Name }}-postgresql<br/>      key: postgres-password</span></pre><p id="4d34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是可行的，因为postgres图表包含在我们的图表中。它的资源是同一个版本的一部分，所以使用同一个版本名。</p><p id="066a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些引用的复杂性可能会增加，这取决于图表需要如何交互以及它们将如何被使用。例如，如果您需要支持随图表一起创建postgres或者指向一个现有的postgres，该怎么办呢？或者提供切换到mysql的选项？这种事情会变得复杂。官方图表<a class="ae jp" href="https://hackernoon.com/the-art-of-the-helm-chart-patterns-from-the-official-kubernetes-charts-8a7cafa86d12" rel="noopener ugc nofollow" target="_blank">显示了处理这种情况的模式</a>，但是你最好从限制选项开始，这样一开始你只需要处理简单的情况。</p><h1 id="0a30" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">11跨图表复制可以接受</h1><p id="5ec6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">每个图表用于部署一个或多个特定的docker映像。(同一图像的不同标签或版本通常由同一图表处理。)但是如果你有几个非常相似的图像呢？我们可以在不同的图表中重用部分吗？</p><p id="ee71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">官方helm文档给了<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/subcharts_and_globals.md#overriding-values-from-a-parent-chart" rel="noopener ugc nofollow" target="_blank">一个例子</a>，告诉你如何从父图表“继承”特性。它定义了一个名为<code class="eh lh li lj ky b">mychart</code>的图表，在其<code class="eh lh li lj ky b">charts</code>目录中包含一个名为<code class="eh lh li lj ky b">mysubchart</code>的子图表。<code class="eh lh li lj ky b">mysubchart</code>的values.yaml包含:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="7605" class="lc jr hu ky b fv ld le l lf lg">dessert: cake</span></pre><p id="7da9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该值进入由<code class="eh lh li lj ky b">mysubchart</code>创建的配置映射资源。然后，mychart的values.yaml可以用以下内容覆盖它:</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="173d" class="lc jr hu ky b fv ld le l lf lg">mysubchart:<br/>  dessert: ice cream</span></pre><p id="bd49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以<code class="eh lh li lj ky b">mychart</code>可以定义由<code class="eh lh li lj ky b">mysubchart</code>定义的相同的配置图，因为它包括<code class="eh lh li lj ky b">mysubchart</code>，但是它可以通过覆盖这些值给它不同的内容。</p><p id="3f8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，您可以使用一个基础图表来定义公共资源，并让其他图表包含该图表，并根据需要覆盖它们。例如，您可以想象有一个java应用程序的基础图表。然而，您目前并没有看到这种模式以那种方式被大量使用。实际上，许多官方的掌舵图都包含了许多图表中几乎相同的部分。批次以同样的方式处理入口。他们复制，而不是试图重用一个共同的父节点。(实际上，他们试图广泛地遵循一个共同的指导方针。)为什么？</p><p id="ade1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个原因是helm没有抽象父代的概念。每个图表，包括父图表，都可以单独部署。如果不是，那么测试起来就有点棘手了。</p><p id="2d54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在面向对象语言中，子图表更像是图表中可重写的成员，而不是父图表。每个都必须有一个前缀(在我们的例子中是<code class="eh lh li lj ky b">mysubchart</code>)。如果你有多个层，这些名字会变得很难用。您不能修改子图表中的资源，除非它们通过值公开。这意味着必须去改变子图表，以便改变消耗它的图表，这在图表被发布时变得更加笨拙，因为每个改变都是版本改变，并且需要重建和发布。</p><p id="e4b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，如果有一个定义入口的公共父类，那么它将需要引用被公开的服务。这意味着必须将服务名注入入口资源。由于父图表实际上是一个包含的第三方图表，这将带来我们在上一节中看到的所有复杂的交互。</p><p id="9f4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这并不是说我们不应该试图避免重复。如果我们有几个一起部署的图表，并且都需要相同的环境变量集，那么使用<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/subcharts_and_globals.md#global-chart-values" rel="noopener ugc nofollow" target="_blank"> globals </a>或指向<a class="ae jp" href="https://dzone.com/articles/configuring-java-apps-with-kubernetes-configmaps-a" rel="noopener ugc nofollow" target="_blank"> common ConfigMap </a>的选项会很有意义。用名为模板的<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/named_templates.md" rel="noopener ugc nofollow" target="_blank">来减少模板内容的重复也是可能的，但是这有点复杂(尽管这里的例子</a><a class="ae jp" href="https://stackoverflow.com/questions/43923749/kubernetes-how-to-avoid-duplicating-env-in-multiple-deployments" rel="noopener ugc nofollow" target="_blank">是</a>)。</p><p id="fa6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关键是，如果你发现重复是一个问题，你可以先复制内容，然后再减少重复，这样你就可以省去一些麻烦。(希望在Helm3 中这部分会<a class="ae jp" href="https://github.com/helm/helm/issues/3920" rel="noopener ugc nofollow" target="_blank">变得更流畅，因为该区域正在</a><a class="ae jp" href="https://github.com/helm/helm/issues/4535" rel="noopener ugc nofollow" target="_blank">讨论中</a>。)</p><h1 id="b871" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">12你不必马上自动测试你的舵</h1><p id="059e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">无论如何，你可能是在部署之后测试你的应用程序。如果是这样，不要觉得你必须完全TDD你的图表部署过程。Helm确实有这方面的选项，使用它们会很棒，但还需要学习。</p><h1 id="72a1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">13把赫尔姆当成一盒戏法没关系</h1><p id="c6ff" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">许多程序员习惯于遵循既定的设计模式。从这个角度来看，你很快就会看到掌舵<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/charts_tips_and_tricks.md" rel="noopener ugc nofollow" target="_blank">“提示和技巧”页面</a>或<a class="ae jp" href="https://github.com/helm/helm/blob/master/docs/chart_template_guide/functions_and_pipelines.md#template-functions-and-pipelines" rel="noopener ugc nofollow" target="_blank">模板函数的文档</a>。接受这一点。官方的Kubernetes图表中有很多变化。以适合你的方式做事是可以的。</p><h1 id="93fc" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated"><strong class="ak"> 14请随意使用官方图表</strong></h1><p id="d067" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">官方图表处理的是你不会想到的事情，它们被维持着。因此，如果你需要一个mysql数据库或者任何你能在官方图表中找到的东西，去使用它，而不是为此创建你自己的图表。</p><p id="84f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，<a class="ae jp" href="https://hub.kubeapps.com/" rel="noopener ugc nofollow" target="_blank">官方图表</a>相当复杂，因为它们必须在许多方面可用。不要觉得你需要钻研他们的代码，马上效仿他们，<a class="ae jp" href="https://hackernoon.com/the-art-of-the-helm-chart-patterns-from-the-official-kubernetes-charts-8a7cafa86d12" rel="noopener ugc nofollow" target="_blank">，尽管你以后可能会从中受益。最初，你可以根据自己的情况使用它们。每个都应该有如何使用它的解释。</a></p><h1 id="8bef" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">15使用Helm社区</h1><p id="e2d8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果你加入了<a class="ae jp" href="http://slack.k8s.io/" rel="noopener ugc nofollow" target="_blank">官方的kubernetes slack </a>，那里有舵和舵图的频道。你可以在那里得到很好的建议。也不要害怕在<a class="ae jp" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> stackoverflow </a>上提问。你并不孤单。</p><h1 id="8e61" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">外卖食品</h1><figure class="kt ku kv kw fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff lk"><img src="../Images/18ff27695732d184da352f3e824bfd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQTLNJuF4FItLXYUZ4mPcw.png"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek"><a class="ae jp" href="https://vimeo.com/127298945" rel="noopener ugc nofollow" target="_blank">Getting the hang of Helm now</a></figcaption></figure><p id="4bb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Helm有很多东西需要学习，它与许多程序员习惯的方法有很大不同。分解一下，一步一步来。你兴风作浪的速度会比你想象的要快。</p></div></div>    
</body>
</html>