<html>
<head>
<title>Talkin’ ‘bout my generation: How the Uno Platform generates code, part 2 — Under the hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谈论我这一代:Uno平台如何生成代码，第2部分——引擎盖下</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/talkin-bout-my-generation-how-the-uno-platform-generates-code-part-2-under-the-hood-9970ac38ad06?source=collection_archive---------17-----------------------#2018-10-15">https://medium.com/hackernoon/talkin-bout-my-generation-how-the-uno-platform-generates-code-part-2-under-the-hood-9970ac38ad06?source=collection_archive---------17-----------------------#2018-10-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b143dd05c7b08e8021ed7ca25f4eaaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3b215RmYdY7wdoUkt5PLw.jpeg"/></div></div></figure><div class=""/><p id="7578" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" rel="noopener" href="/@unoplatform/talkin-bout-my-generation-how-the-uno-platform-generates-code-part-1-under-the-hood-7664d83c4f90">之前</a>我们看了<a class="ae ka" href="https://platform.uno/" rel="noopener ugc nofollow" target="_blank"> Uno平台</a>如何将XAML标记文件转换成C#代码。在这篇文章中，我将谈论Uno使用代码生成的另一种方式，允许我们使原生Android和iOS视图符合UWP的API，并解决<a class="ae ka" href="https://en.wikipedia.org/wiki/Multiple_inheritance" rel="noopener ugc nofollow" target="_blank">多重继承</a>的棘手问题。</p><h1 id="0a93" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">想要这一切</h1><p id="5df2" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Android和iOS上的Uno的部分功能是能够轻松地混合UWP视图类型和纯本地视图。这是可能的，因为在Uno中，所有视图都继承自本机基本视图类型:Android上的<a class="ae ka" href="https://developer.android.com/reference/android/view/View" rel="noopener ugc nofollow" target="_blank"> View </a>，iOS上的<a class="ae ka" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank"> UIView </a>。</p><p id="97cf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是正如我在以前的一篇文章中提到的，这给复制UWP的继承层次结构带来了挑战。UIElement是UWP中的基本视图类型，但它又派生自DependencyObject类。<code class="eh le lf lg lh b">DependencyObject</code>是任何有<code class="eh le lf lg lh b">DependencyProperties</code>的东西的基类，也就是任何支持数据绑定的东西。这包括所有视图，以及一些非视图框架类型，如<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/design/layout/transforms" rel="noopener ugc nofollow" target="_blank">变换</a>和<a class="ae ka" href="https://docs.microsoft.com/en-us/windows/uwp/design/style/brushes" rel="noopener ugc nofollow" target="_blank">笔刷</a>。</p><p id="6ba4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们想继承<code class="eh le lf lg lh b">ViewGroup</code>或<code class="eh le lf lg lh b">UIView</code>。我们也想从<code class="eh le lf lg lh b">DependencyObject.</code>继承，C#不允许多重继承，那么我们该怎么办？由于我们不能改变iOS或Android框架，我们选择在Uno内部将<code class="eh le lf lg lh b">DependencyObject</code>变成了<a class="ae ka" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/index" rel="noopener ugc nofollow" target="_blank">界面</a>。这允许一个Uno <code class="eh le lf lg lh b">FrameworkElement</code>成为一个<code class="eh le lf lg lh b">UIView</code>，同时也成为一个<code class="eh le lf lg lh b">DependencyObject</code>。但仅此还不够。</p><p id="c238" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你的应用程序中有这样的代码会怎么样？</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="e1a2" class="lq kc if lh b fv lr ls l lt lu">public class MyBindableObject : DependencyObject </span><span id="a8ff" class="lq kc if lh b fv lv ls l lt lu">    { </span><span id="e9b3" class="lq kc if lh b fv lv ls l lt lu">        public string MyProperty </span><span id="bf8e" class="lq kc if lh b fv lv ls l lt lu">        { </span><span id="5900" class="lq kc if lh b fv lv ls l lt lu">            get { return (string)GetValue(MyPropertyProperty); } </span><span id="263a" class="lq kc if lh b fv lv ls l lt lu">            set { SetValue(MyPropertyProperty, value); } </span><span id="7795" class="lq kc if lh b fv lv ls l lt lu">        } </span><span id="c420" class="lq kc if lh b fv lv ls l lt lu">        // Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc... </span><span id="33ed" class="lq kc if lh b fv lv ls l lt lu">        public static readonly DependencyProperty MyPropertyProperty = </span><span id="8218" class="lq kc if lh b fv lv ls l lt lu">            DependencyProperty.Register("MyProperty", typeof(string), typeof(MyBindableObject), new PropertyMetadata(default(string))); </span><span id="34c1" class="lq kc if lh b fv lv ls l lt lu">    }</span></pre><p id="8193" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们从<code class="eh le lf lg lh b">DependencyObject</code>继承并使用标准语法定义了一个<code class="eh le lf lg lh b">DependencyProperty</code>，该语法使用了<code class="eh le lf lg lh b">DependencyObject.GetValue</code>和<code class="eh le lf lg lh b">DependencyObject.SetValue</code>方法。在UWP，这些是在基类中定义的，但是如果<code class="eh le lf lg lh b">DependencyObject</code>是一个接口，那么<em class="lw">就没有基类。事实上，如果它只是一个接口，那么代码不会编译，因为接口还没有实现。</em></p><p id="cdc7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是<code class="eh le lf lg lh b">DependencyObject</code>不仅仅是<em class="lw">在Uno中的一个接口，上面的代码将在Android和iOS上按原样编译，就像在UWP上一样。代码生成实现了这一点。这里有一些程序员艺术来说明这一点。详细解释如下。</em></p><figure class="li lj lk ll fq hw fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/78411d4d88c5d3ee9007185fe4fb62a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*cP1J_D79vhpIFV8N.png"/></div></figure><p id="d237" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lw">在UWP上，</em> <code class="eh le lf lg lh b"><em class="lw">UIElement</em></code> <em class="lw">继承自</em> <code class="eh le lf lg lh b"><em class="lw">DependencyObject</em></code> <em class="lw">类。</em></p><figure class="li lj lk ll fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ly"><img src="../Images/dca0e85c240b930b7e075d878d3dde37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rmVOcZrUy1o9zTMr.png"/></div></div></figure><p id="255a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">多重继承——不是一个选项。</p><figure class="li lj lk ll fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lz"><img src="../Images/439f76cc2c3307429e41858fbb6fb411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ESL41p6hzMaZMZHZ.png"/></div></div></figure><p id="bb38" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lw">在Uno中，</em> <code class="eh le lf lg lh b"><em class="lw">DependencyObject</em></code> <em class="lw">是一个接口，由代码生成自动提供实现。</em></p><p id="0f72" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们面临这个问题的一种较弱形式——希望有两个基类型——在其他情况下也是如此。在框架中的一些地方，我们从一个更加派生的本地视图类型中继承。比如<code class="eh le lf lg lh b">ScrollContentPresenter</code>继承了Android和iOS上的原生滚动视图。但是我们也希望<code class="eh le lf lg lh b">ScrollContentPresenter</code>公开<code class="eh le lf lg lh b">FrameworkElement</code>的方法和属性。</p><p id="6351" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们通过使用代码生成在C#中实现mixins成功地解决了这两个问题。</p><h1 id="e657" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">把事情混在一起</h1><p id="238e" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">大多数静态类型语言不允许多个基类，因为这会增加复杂性，也就是所谓的<a class="ae ka" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" rel="noopener ugc nofollow" target="_blank">‘钻石问题’</a>。(C++是一个明显的例外。)然而，在动态类型语言中，用<a class="ae ka" href="https://en.wikipedia.org/wiki/Mixin" rel="noopener ugc nofollow" target="_blank"> mixins </a>以可重用的方式将额外的功能附加到一个类中是很常见的。</p><p id="106e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">C#作为一种静态类型语言，不支持mixins作为一级语言特性。不过，代码生成允许我们模拟它。Uno使用代码生成以(至少)两种不同的方式添加mixins。</p><p id="932b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将从更简单的方法开始:使用“T4”模板。引用微软的文档:</p><blockquote class="ma mb mc"><p id="069e" class="jc jd lw je b jf jg jh ji jj jk jl jm md jo jp jq me js jt ju mf jw jx jy jz hn dt translated"><em class="if">在Visual Studio中，T4文本模板是可以生成文本文件的文本块和控制逻辑的混合物。在Visual C#或Visual Basic中，控制逻辑是作为程序代码片段编写的。在Visual Studio 2015 Update 2和更高版本中，可以在T4模板指令中使用6.0版功能。生成的文件可以是任何类型的文本，如网页、资源文件或任何语言的程序源代码。</em></p></blockquote><p id="c739" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lw">来源:</em><a class="ae ka" href="https://docs.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates?view=vs-2017" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/visual studio/modeling/code-generation-and-T4-text-templates？view=vs-2017 </a></p><p id="7fc6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">T4模板('。tt文件)已经存在很长时间了。它们本质上是静态文本(在我们的例子中是C#代码)和条件逻辑的混合。这里有一个片段:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="cf81" class="lq kc if lh b fv lr ls l lt lu">namespace &lt;#= mixin.NamespaceName #&gt; <br/>{ <br/>    public partial class &lt;#= mixin.ClassName #&gt; : IFrameworkElement <br/>    {  <br/>    #if !&lt;#= mixin.IsFrameworkElement #&gt; <br/>        /// &lt;summary&gt; <br/>        /// Gets the parent of this FrameworkElement in the object tree. <br/>        /// &lt;/summary&gt; <br/>        public DependencyObject Parent =&gt; ((IDependencyObjectStoreProvider)this).Store.Parent as DependencyObject; <br/>#endif <br/> <br/>#if &lt;#= mixin.HasAttachedToWindow #&gt; <br/>    partial void OnAttachedToWindowPartial() <br/>    { <br/>        OnLoading(); <br/>        OnLoaded(); <br/>    } <br/>�</span></pre><p id="d05d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这来自于在Uno中增加了功能的<code class="eh le lf lg lh b">IFrameworkElement</code>模板。它实现了<code class="eh le lf lg lh b">Width</code> / <code class="eh le lf lg lh b">Height</code>、<code class="eh le lf lg lh b">Opacity</code>、<code class="eh le lf lg lh b">Style</code>等属性。在编译时，模板运行并创建一个<a class="ae ka" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods" rel="noopener ugc nofollow" target="_blank">分部类</a>，其中包含<code class="eh le lf lg lh b">ScrollContentPresenter</code>和其他几个类的成员(包括<code class="eh le lf lg lh b">FrameworkElement</code>本身)。</p><p id="2e14" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">T4方法经过了很好的测试，在这种情况下效果很好。但是它有一些限制:</p><ol class=""><li id="0870" class="mg mh if je b jf jg jj jk jn mi jr mj jv mk jz ml mm mn mo dt translated">它需要手动设置:每个想要使用mixin的类都必须显式注册。</li><li id="3b55" class="mg mh if je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">它需要手动标记来确保生成的代码不会“踩踏”创作的代码，例如，当创作的代码已经定义了<code class="eh le lf lg lh b">Foo()</code>时，生成一个<code class="eh le lf lg lh b">Foo()</code>方法。</li><li id="41f2" class="mg mh if je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">它不支持外部代码。你不能在你的应用中使用上面的mixin(除了将模板复制粘贴到应用中)。</li></ol><p id="84cb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于这个原因，为了有一个mixin来实现<code class="eh le lf lg lh b">DependencyObject</code>的特性，我们做了一些更复杂和更神奇的事情。</p><h1 id="8fbe" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">DependencyObjectGenerator —创造奇迹</h1><p id="50f1" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">罗斯林的发布，又名。NET编译器平台”是代码生成的福音。在Roslyn中，微软开源了C#编译器，但他们也公开了一个强大的代码分析API。使用Roslyn，很容易访问编译器拥有的所有语法和语义信息。</p><p id="38bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了利用这种能力进行代码生成，我们创建了<a class="ae ka" href="https://github.com/nventive/Uno.SourceGeneration" rel="noopener ugc nofollow" target="_blank"> Uno。SourceGeneration </a>包。就像Uno平台一样，它是免费和开源的。它创建一个构建任务，并允许您根据Roslyn对您的解决方案的分析，轻松地添加生成的代码。这可能是扩充现有类型的部分类定义，也可能是全新的类。</p><p id="6b10" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Uno中，这由<a class="ae ka" href="https://github.com/nventive/Uno/blob/master/src/SourceGenerators/Uno.UI.SourceGenerators/DependencyObject/DependencyObjectGenerator.cs" rel="noopener ugc nofollow" target="_blank">dependency object generator</a>类使用。这个生成器寻找解决方案中实现了<code class="eh le lf lg lh b">DependencyObject</code>接口的每个类，就像上面的<code class="eh le lf lg lh b">MyBindableObject</code>例子一样。对于每个这样的类，它自动生成<code class="eh le lf lg lh b">DependencyObject</code>的方法和属性。</p><p id="ab4d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于生成器拥有来自Roslyn的全套语义信息，它可以以一种智能的方式来完成这项工作。例如，如果它检测到该类是一个视图类型，它会添加一些方法，以便在加载或卸载视图时更新绑定信息。</p><p id="612b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是来自<code class="eh le lf lg lh b">DependencyObjectGenerator</code>的一小段<a class="ae ka" href="https://github.com/nventive/Uno/blob/74ba91756c446107e7394e0423527de273154f5d/src/SourceGenerators/Uno.UI.SourceGenerators/DependencyObject/DependencyObjectGenerator.cs#L218-L250" rel="noopener ugc nofollow" target="_blank">代码:</a></p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="f179" class="lq kc if lh b fv lr ls l lt lu">private void WriteAndroidAttachedToWindow(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)<br/>			{<br/>				var isAndroidView = typeSymbol.Is(_androidViewSymbol);<br/>				var isAndroidActivity = typeSymbol.Is(_androidActivitySymbol);<br/>				var isAndroidFragment = typeSymbol.Is(_androidFragmentSymbol);<br/>				var isUnoViewGroup = typeSymbol.Is(_unoViewgroupSymbol);<br/>				var implementsIFrameworkElement = typeSymbol.Interfaces.Any(t =&gt; t == _iFrameworkElementSymbol);<br/>				var hasOverridesAttachedToWindowAndroid = isAndroidView &amp;&amp;<br/>					typeSymbol<br/>					.GetMethods()<br/>					.Where(m =&gt; IsNotDependencyObjectGeneratorSourceFile(m))<br/>					.None(m =&gt; m.Name == "OnAttachedToWindow");</span><span id="cbad" class="lq kc if lh b fv lv ls l lt lu">				if (isAndroidView || isAndroidActivity || isAndroidFragment)<br/>				{<br/>					if (!isAndroidActivity &amp;&amp; !isAndroidFragment)<br/>					{<br/>						WriteRegisterLoadActions(typeSymbol, builder);<br/>					}</span><span id="dfba" class="lq kc if lh b fv lv ls l lt lu">					builder.AppendLine($@"<br/>#if {hasOverridesAttachedToWindowAndroid} //Is Android view (that doesn't already override OnAttachedToWindow)<br/>#if {isUnoViewGroup} //Is UnoViewGroup<br/>					// Both methods below are implementation of abstract methods<br/>					// which are called from onAttachedToWindow in Java.<br/>					protected override void OnNativeLoaded()<br/>					{{<br/>						_loadActions.ForEach(a =&gt; a.Item1());<br/>						BinderAttachedToWindow();<br/>					}}</span></pre><p id="8841" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个方法中，我们有一个<a class="ae ka" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.inamedtypesymbol?view=roslyn-dotnet" rel="noopener ugc nofollow" target="_blank"> INamedTypeSymbol </a>，一个来自Roslyn的对象，它封装了关于类型的信息。我们已经确定<code class="eh le lf lg lh b">typeSymbol</code>实现了<code class="eh le lf lg lh b">DependencyObject</code>；这里我们检查它是否是一个Android <code class="eh le lf lg lh b">View</code>，如果是，覆盖加载的方法。你可以注意到，我们还检查了类型没有<em class="lw">已经</em>覆盖相同的方法，所以我们不会意外地生成与编写的代码冲突并导致编译器错误的代码。每当你的应用程序编译时，所有这一切都在没有用户干预的情况下进行。</p><p id="8d25" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最终结果是<code class="eh le lf lg lh b">DependencyObject</code>在Uno中的使用方式几乎和在UWP中完全一样，尽管它是一个接口而不是一个类！存在边缘情况:例如，一些通用约束不会以同样的方式工作。但总的来说，它工作得非常好。</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="7aba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前就这些。让我们知道你还想了解Uno的哪些“幕后”方面！</p><figure class="li lj lk ll fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nb"><img src="../Images/9289c79ecb6e83095c577997480a3ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuA1qdX7eUziOMnkRBJ_Gw.png"/></div></div></figure></div></div>    
</body>
</html>