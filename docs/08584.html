<html>
<head>
<title>Fluttering Above the Rest: Transforming E-commerce Across Multiple Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">凌驾于其他之上:跨多个系统转变电子商务</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/fluttering-above-the-rest-transforming-e-commerce-across-multiple-systems-b0b4e5a0a38?source=collection_archive---------20-----------------------#2018-10-15">https://medium.com/hackernoon/fluttering-above-the-rest-transforming-e-commerce-across-multiple-systems-b0b4e5a0a38?source=collection_archive---------20-----------------------#2018-10-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f12d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">为高保真电子商务调整iOS和Android系统中的颤振依赖性</em></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/646e589fe7cbc243170833c0d94539b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0G2dkqrqwINegRRo1KUGEw.jpeg"/></div></div></figure><p id="d8f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">本文是阿里巴巴</em> <a class="ae kc" rel="noopener" href="/@alitech_2017/utilizing-flutter-best-practice-from-alibaba-236a53aa32c8"> <strong class="it hv"> <em class="jp">利用旋舞</em> </strong> </a> <em class="jp">系列的一部分。</em></p><p id="b2ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">电子商务平台传统上分为iOS和Android系统，要求开发者设计和开发两个不同的系统。现在，由于Flutter技术，开发人员可以从单一代码库为iOS和Android创建高性能和高保真的应用程序。</p><p id="7436" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">This development, however, poses the problem of integrating the technology with existing and live projects. In this article, the technical team at Alibaba’s Xianyu (闲鱼, China’s emerging, second-hand market platform) presents a general engineering transformation plan for project practitioners hoping to address common concerns, and provides a reference for preparing to transform projects to Flutter.</p><h1 id="bd19" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">仙宇的扑技</h1><p id="2cff" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">2018年上半年，鲜宇技术团队在客户端开发统一中率先利用了Flutter技术，成功转型推出了复杂商品细节服务。在这个过程中，无缝桥接Flutter与初始iOS和Android项目之间的连接的优先级问题出现了，并且必须确保开发效率不受影响。</p><h1 id="6e9a" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">积分颤振</h1><p id="b4e6" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Flutter有一个特殊的工程结构，由Flutter目录组成，其中包含了原生iOS和Android项目的目录。默认情况下，引入Flutter的本地项目不能独立于父目录构建和运行，因为它相反依赖于Flutter的相关库和资源。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lg"><img src="../Images/2f714ff84e1bf0aa27914cff6507ff04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3U8INTtuBOm8VX5-NBBAQ.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek"><em class="ll">Typical Flutter directory structure</em></figcaption></figure><p id="79b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于原生项目，开发人员不太可能创建一个新的Flutter项目来重写整个项目。因此，颤振项目将包含现有的原生项目，这将引入以下问题:</p><p id="7ef4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">构建包</strong></p><p id="3922" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">引入Flutter后，原生项目与Flutter耦合，无法独立编译构建。在Flutter环境中，项目的构建从Flutter的构建命令开始，其执行过程包括本地项目的构建。开发人员必须配置Flutter运行时环境来完成整个过程。</p><p id="6523" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">混合编译导致开发效率降低</strong></p><p id="f80f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过渡到Flutter的过程中，肯定有许多服务仍在原生环境中开发。项目结构的改变不允许在原生环境中进行开发。此外，对颤振工程结构的适应为纯本地开发创建了不必要的构建步骤，从而导致开发效率降低。</p><h1 id="733e" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">目标</h1><p id="32db" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">针对上述问题，先宇技术团队提出以下改造目标，并努力将原生项目对Flutter相关文件的依赖降至最低，从而:</p><p id="bd60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原生项目可以独立编译和调试，从而最大限度地减少对相关开发人员的干扰，使打包平台摆脱对Flutter环境和相关进程的依赖。</p><p id="cf9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter环境中的原生项目(即iOS或Android子目录)可以依赖于相关的库和文件，实现各种类型的Flutter功能，如dart代码构造、调试、热重装等。这样才能保证颤振环境下开发的正确性。</p><h1 id="604b" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">颤振依赖性</h1><p id="d544" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">为了实现上述目标，仙寓的技术团队为这两个目录整合了两种模式，组织了依赖关系，并引入了如下所述的依赖关系。</p><h2 id="5622" class="lm ke hu bd kf ln lo lp kj lq lr ls kn jc lt lu kr jg lv lw kv jk lx ly kz lz dt translated">两种模式，两个目录</h2><p id="f1dd" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">技术团队的解决方案是根据目录类型区分项目；独立目录环境中的本地项目被定义为独立模式，而Flutter目录中的本地项目被定义为Flutter模式。纯本机开发或平台打包被视为独立模式。在这种模式下，Flutter对开发人员和打包平台保持透明，不影响构造和调试。Flutter的代码是在Flutter模式下开发的，相关库的生成、编译、调试都遵循Flutter定义的过程。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ma"><img src="../Images/f6fea945377651e1f6b48b852ea3f902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOVaL73ZQN68QonNu4PFHg.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek"><em class="ll">Different modes for each directory type</em></figcaption></figure><h2 id="983e" class="lm ke hu bd kf ln lo lp kj lq lr ls kn jc lt lu kr jg lv lw kv jk lx ly kz lz dt translated">组织依赖性</h2><p id="973b" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">从上面的定义来看，转换的核心是提取独立模式，然后整理出独立模式对Flutter的依赖，并将其提取到第三方库、资源或源文件中。以iOS为例，通过读取Flutter构建的源代码，Xcode项目对Flutter有如下依赖:</p><p id="e3c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> .App.framework </strong></p><p id="4c43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">dart写的应用源代码的相关文件。</p><p id="5378" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> .Flutter.framework </strong></p><p id="4303" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">颤振发动机库文件。</p><p id="2051" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">。pubs插件目录和索引文件</strong></p><p id="efc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter的插件，包括各种系统和自定义频道。</p><p id="04c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">。扑_资产</strong></p><p id="aa47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flutter依赖的资源，比如字体，图片等等。</p><h2 id="23a1" class="lm ke hu bd kf ln lo lp kj lq lr ls kn jc lt lu kr jg lv lw kv jk lx ly kz lz dt translated">引入依赖性</h2><p id="dda7" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在转换过程中，先宇科技团队尝试了两种策略来引入依赖:本地依赖和远程依赖。</p><p id="8c60" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">本地依赖</strong></p><p id="fdce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一种策略是用本地依赖修改Flutter构造过程，其中库文件、源代码和资源放在原生项目的子目录中以供参考。对于iOS ,. flutter . framework和相关插件被做成本地pod依赖，资源也被复制到本地存储库进行维护。</p><p id="b72c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，独立模式获得了独立构建和执行的能力。对于纯本地开发人员，可以选择忽略Flutter，因为它只是第二方库和资源的集合。</p><p id="9307" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在颤振模式下，dart源代码的构造过程不变，不影响编译和调试。同时，由于本地依赖性，颤振模式下的各种变更可以实时同步到原生项目的子目录中，这样一旦提交变更，单机模式也具有最新的颤振相关功能。</p><p id="0ea4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本地依赖性允许将相关颤动内容的改变方便地同步到独立模式，这是一个显著的优点。然而，主要的缺点在于Flutter的原始构造过程需要稍微复杂的修改，这将与随后的Flutter代码合并相冲突。原生项目和Flutter项目的内容仍然是耦合的，所以它们不是完全独立的。</p><p id="696a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">远程依赖</strong></p><p id="e71b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二个策略是用远程依赖修改Flutter构建过程，其中Flutter依赖的所有内容都放在一个单独的远程存储库中。在独立模式下，引用远程存储库中的相关资源、源代码和库文件，而在Flutter模式下，构建过程和引用方法不变。</p><p id="68c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">远程依赖的优点是它不会大幅度修改Flutter自身的构造过程，有效地解决了本地耦合的问题。然而，这种策略也导致更麻烦的同步过程。此外，Flutter内容的更改必须首先同步到远程存储库，然后同步到独立模式才能生效。</p><p id="3ec7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了克服这些缺点，由于本地耦合解决方案的主要好处，仙寓技术团队最终决定采用远程依赖策略来引入依赖。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mb"><img src="../Images/07fe65f0f98696b5348d1af975abbdef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNiMfMR1k2cM8rP01ihYlA.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek"><em class="ll">Remote dependency model outline</em></figcaption></figure><h1 id="adac" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">转换实现</h1><p id="3dbb" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">实现转换包括有效地组织目录和实现远程依赖，如下所述。</p><h2 id="3d13" class="lm ke hu bd kf ln lo lp kj lq lr ls kn jc lt lu kr jg lv lw kv jk lx ly kz lz dt translated">目录组织</h2><p id="1c1a" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">目录的组织方式对实现转换有着重要的影响。在Flutter模式下，父项目目录下的iOS和android子目录分别包含对应的原生项目。在代码管理方面，子项目可以使用git的子模块形式来确保目录之间的独立性。</p><h2 id="5768" class="lm ke hu bd kf ln lo lp kj lq lr ls kn jc lt lu kr jg lv lw kv jk lx ly kz lz dt translated">远程依赖实现</h2><p id="7602" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在独立模式下，Flutter的依赖内容指向远程存储库中的相应文件，而Flutter模式下的依赖方法不变。为了实现远程依赖，需要考虑以下问题:</p><p id="d0b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">同步颤振变化到独立模式</strong></p><p id="e870" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于繁琐的变更同步是远程依赖的主要问题，所以Xianyu团队开发了一系列脚本工具来尽可能自动化这个过程。假设Flutter内容(可能是服务源代码、引擎库或某些资源文件)发生了变化，一旦在Flutter模式下完成了构建，脚本就会将所有生成的依赖文件提取到远程存储库中，提交并标记，然后根据标记生成新的远程依赖描述(例如，iOS下的podspec)。最后，Flutter的依赖关系将在独立模式下修改为最新版本，以完成整个同步过程。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/4977b26c0dc7739d5549274273fddf44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*6NihxLcc8wY72BeFNULhKg.png"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek"><em class="ll">Process synchronization</em></figcaption></figure><p id="1629" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">同步定时</strong></p><p id="b858" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">建议在评估和灰度期间，每次提交Flutter服务都会触发同步脚本的执行和应用程序的打包，并且在开发期间每天保持一次同步。</p><h1 id="b44b" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">常见问题的解决方法</h1><p id="7324" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">本节概述了转换实现的常见问题，并提供了先宇科技团队认为最有效的解决方案。</p><h2 id="02ca" class="lm ke hu bd kf ln lo lp kj lq lr ls kn jc lt lu kr jg lv lw kv jk lx ly kz lz dt translated">iOS项目名称问题</h2><p id="8d8c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Flutter要求默认使用Runner.xcodeproj作为iOS项目名，否则，构造会失败。可以通过修改flutter工具的代码来定制项目名称(代码可以在flutter/packages/flutter_tools找到，相关逻辑可以通过全局搜索Runner.xcodeproj查看)，但是合并代码时可能会出现未来的冲突。仙寓团队已经解决了这个问题，并将其项目名称改为Runner。其他项目名称可根据自身实际情况确定。</p><h2 id="4121" class="lm ke hu bd kf ln lo lp kj lq lr ls kn jc lt lu kr jg lv lw kv jk lx ly kz lz dt translated">Pod问题</h2><p id="f5fb" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">构建颤振时，如果满足某些条件，可以自动执行pod安装。然而，在阿里巴巴的taobaoenv环境中，经常会出现错误。即使构建成功，pod安装通常也需要很长时间才能完成执行。在执行之后，整个项目必须重新编译，这非常耗时。因此，仙域团队已经注释掉了Flutter对pod的处理，并让开发人员手动执行pod操作。</p><p id="09a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可能需要手动执行来切换分支和升级库版本，并且很可能重新更新pod是一个真正的需求。此外，当Flutter的构建选项在发布、调试和概要文件之间切换，并且它们引入的Flutter.framework有不同的来源时，可能需要手动执行。在这种情况下，可以特别注意pod的重新更新。</p><h1 id="13f3" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">摘要</h1><p id="7de2" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">为了解决引入Flutter后的工程适配问题，先宇tech团队将Flutter的相关依赖提取出来，放在远程仓库上，供纯原生项目引用，从而保证了Flutter和纯原生开发的相互独立和并行执行。</p><p id="23af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该方案已在仙域多个版本中实现，并已导出回颤振团队，为其后续混合项目的组织计划提供方向和参考。同时，该计划还可以用来帮助团队将他们的工作转变为Flutter。显然，不同的项目导致不同的计划，因此团队期待着交流更好的方法和意见。</p><p id="fed5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">(Original article by Kang Kai康凯)</p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><h1 id="c1cc" class="kd ke hu bd kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae kc" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">“阿里巴巴科技”</strong> </a>。推特:<a class="ae kc" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">【阿里巴巴技术】</strong> </a>。</p></div></div>    
</body>
</html>