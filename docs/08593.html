<html>
<head>
<title>Micro-Services, and Co-ordination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微观服务和协调</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/micro-services-and-co-ordination-eed1fca963d4?source=collection_archive---------29-----------------------#2018-10-15">https://medium.com/hackernoon/micro-services-and-co-ordination-eed1fca963d4?source=collection_archive---------29-----------------------#2018-10-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0916014452f5686b33727821e48fff72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OR_QEjdG_K_KuPqO.jpg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Irreducible Complexity</figcaption></figure><p id="6965" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从理论上来说，将你的monolith换成微服务——或者首先使用微服务——是一件显而易见的事情。毕竟，你的巨石越大(“一件大事”！)越多，你就越难掌握其中的一切。建筑最终会到达一个你无法在脑海中想象的地方。哦，松散耦合是有帮助的，组件化、分层架构、队列/服务总线等等，但是，最终，你会受到系统不可简化的复杂性的限制。所以，你做了显而易见的事情。实际上，通过将单个组件分解成不同的微服务，您将松散耦合扩展到了临界点。现在，这些微服务中的每一个都可以被<em class="ke">的</em>开发团队完全可视化，并且你可以让其他人来可视化所有单个组件是如何组合在一起的。</p><p id="c000" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就这么简单，对吧？你基本上已经<em class="ke">分离了</em>你系统的各个组件，并开创了一个速度、效率和午餐苹果派的新时代。</p><p id="bdd7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">还是你有？</p><p id="bb45" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">事情是“<em class="ke">解耦</em>”上面带着<em class="ke">很多</em>的水！例如，如果其中一个组件的API是<em class="ke">不断变化的</em>，那么任何其他使用该API的团队都需要不断重构<em class="ke">他们的</em>实现，以保持其最新。所以，是的，你需要预先花很多时间来确保你拥有强大而稳定的！—组件之间的APIs接口/契约。<br/> ( <em class="ke">这是一件好事，不仅仅是对微服务而言，对你构建的一切都是如此</em>🙌)<br/>也就是说，你的单个服务也有<em class="ke">软</em>依赖。也许您决定使用Cassandra来处理组件中的时序数据。你知道其他人都在用Postgres 吧？虽然使用Postgres对你来说没那么糟糕，但是维护和支付的操作负荷！—卡珊德拉会更高吗？</p><p id="b910" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里的要点是，虽然有些东西是<em class="ke">必需的</em>——比如确保组件之间的契约清晰且定义明确，但其他的——比如实现的不透明性——则更加松散且定义不清。你需要为了更大的利益而牺牲个人效率(上面的<em class="ke">Cassandra</em>vs<em class="ke">Postgres</em>)，这种协调负担实际上会比你刚刚处理那块巨石时更大。毕竟，在monolith-world中，每个人都使用Postgres (" <em class="ke">那是数据库，这是不言自明的。你想存储时间序列数据？用它！</em>”)，但是现在架构决策需要跨团队协调！</p><p id="9850" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我的朋友们，这就是我想要表达的观点。就实施而言，转向微服务不是免费的。在一天结束的时候，你正在构建一个分布式系统，如果你想要一个容错的系统，<em class="ke">你必须意识到你的选择会影响其他人</em>。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/8ea5bd7be55086b42392fb8052c2bfd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*DXUzPuWVLwAswOd-bShh3g.gif"/></div></figure><p id="fd78" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当你分离你的系统时，所有这些交互并没有神奇地消失，它们只是进入了一个不同的领域。在一个典型的整体建筑中，虽然你得到的架构决策在整个系统中相当一致，但你有人类协调的问题，这是一个正义的皮塔饼。例如，更新的数据库模式可能会波及整个系统，导致一群不同的团队不得不协调他们的开发和发布日期！—要实现这一点，需要减慢几乎所有其他事情的速度。你的系统越大，越…有趣🙄…实际发布的过程。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/31070e753d9b17dd6e26e98d6c114e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*0Uo1pastARL6lptYW6KpIA.png"/></div></figure><p id="6f62" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而对于微服务，<em class="ke">你用系统协调问题来交换这些人类协调问题</em>。实际上，你正在构建一个分布式系统，为了确保它的健壮性和弹性，你必须确保你已经把所有的事情都安排好了。依赖性管理、版本控制、部署管道、并发性和死锁，哦，这个世界上出现了无数的问题，你需要处理所有这些问题。</p><p id="5979" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">复杂性永远不会消失，它只是沿着食物链向上移动。是真的，你也是这么做的。你放弃了人类协调的皮塔，换来了完全不同的——但同样可怕的——系统协调的皮塔。如果你认为你的生活变得轻松了，那么，事实并非如此。只不过，在系统协调问题上，控制的错觉要大得多，这种错觉让我们能够推迟不可避免的清算日，直到我们真正有能力处理它，或者我们已经破产。提醒你，现在我想起来了，这并不是一个糟糕的交易…</p><ol class=""><li id="51ab" class="km kn hu ji b jj jk jn jo jr ko jv kp jz kq kd kr ks kt ku dt translated">我记得有一个场景，一个团队使用<a class="ae kl" href="https://www.influxdata.com/time-series-platform/" rel="noopener ugc nofollow" target="_blank"> TICK stack </a>，而所有其他团队使用<a class="ae kl" href="https://prometheus.io" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>。原因是该团队的主要开发人员从未使用过Prometheus，而使用TICK是因为“快速上市”。花了相当长的时间才解开这一团乱麻…</li></ol><p id="6e89" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ke"> ( </em> <a class="ae kl" href="https://dieswaytoofast.blogspot.com/2018/10/micro-services-and-co-ordination.html" rel="noopener ugc nofollow" target="_blank"> <em class="ke">这篇文章也出现在我的博客上</em> </a> <em class="ke"> ) </em></p></div></div>    
</body>
</html>