<html>
<head>
<title>How to Get to The Best Readability Without More Abstraction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在没有更多抽象的情况下获得最佳可读性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-get-to-the-best-readability-without-more-abstraction-4de9621f75c5?source=collection_archive---------4-----------------------#2018-10-16">https://medium.com/hackernoon/how-to-get-to-the-best-readability-without-more-abstraction-4de9621f75c5?source=collection_archive---------4-----------------------#2018-10-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b07b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我用各种方法重构了一个复杂的“if”语句。我发现了一个有趣的趋势。使用简单的重构步骤，当追求代码的更高可读性时，您通常可以走不同的方向。每一个小的重构都是可读性的增加，有时是复杂性或抽象性的降低、或增加、或中性。</p><p id="ae02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">TL；DR:从这个实验中，我明白了在重构的时候，我们不应该急于增加新的抽象层次。也许有一种方法可以在当前抽象的范围内提高可读性。</p><p id="e1e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您不希望您的代码看起来像这样:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/9c54dd5b039156a57962a8559b801829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wN5t9ILU0fpnhbMX2vtng.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Abstraction going wild! 🦌 source: <a class="ae kf" href="https://www.pexels.com/photo/abstract-art-blur-bright-373543/" rel="noopener ugc nofollow" target="_blank">pexels</a></figcaption></figure><h1 id="51f6" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">代码示例</h1><p id="5263" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我给你举个例子。我对石头剪子布编码的形有如下的实现:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">That “!=” is screwing with understandability. 😖</figcaption></figure><h1 id="55a0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">第一条重构路径</h1><p id="ba1e" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我的第一个直觉是，这些“如果”陈述正在验证第一次投掷是否胜过第二次投掷。所以我认为可以提高可读性的抽象应该是:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Oh, that is exactly what I want to say there in the code! 👏</figcaption></figure><p id="d126" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这只是解决了一个问题。“beats”方法中的代码仍然没有很好地表达意图。您几乎必须在大脑中执行代码，才能理解它与您的业务规则的关系:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Oh no! The same problem has just popped somewhere else! 🐜</figcaption></figure><p id="f722" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经引入了一个抽象层次。条件的可读性没有提高，只是被移动了一下。“播放”功能的可读性仅略有提高。</p><p id="8a9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的直觉为“beats”中的可读性问题提出了一个直接的解决方案:将enum类转换成一个接口，并为每种类型的throw提供三个具体的实现:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Abstraction, abstraction, and abstraction. 🏚</figcaption></figure><p id="d48b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，显而易见，被否定的条件(如<code class="eh ll lm ln lo b">other != ROCK</code>)不是我们真正需要谈论的。相反，我们需要讨论当前的“其他投掷”击败了哪一个:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Yeah, should’ve dealt with this “!=” long before. Poor me. 😞</figcaption></figure><p id="e394" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个重构路径可以更进一步，用字段“winsAgainst”实例化剪刀、石头和布，并在“beats”方法的默认实现中使用它:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">That looks cute. Could make it a data class with 3 pre-defined values. 🗃</figcaption></figure><p id="5a0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，在一天结束时，我们必须增加两层抽象，使“play”函数中的逻辑更可读，并使“if”条件更好地表示意图。</p><p id="b80d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">众所周知，更抽象意味着孤立地理解每一点更容易，但从整体上把握更难。</p><p id="d9fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和抽象泄漏。</p><h1 id="f5df" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">这种抽象在新特性中表现如何？</h1><p id="cfc3" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">让我们看看当前的抽象是否如此。让我们把经典的石头剪子布问题转化为文化上更现代的石头剪子布蜥蜴史波克问题。以下是规则列表:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Wow! DSL!!! 😻</figcaption></figure><p id="eb2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(顺便说一下，这其实是一个可运行的测试。感谢科特林的DSL善良！参见<a class="ae kf" href="https://iwillteachyoukotlin.com/2018/10/15/how-to-make-your-tests-read-like-business-rules-w-infix-functions/" rel="noopener ugc nofollow" target="_blank">我是如何用完整的TDD流程编写这个测试的</a>。)</p><p id="2fa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个断言错误是“岩石应该击败蜥蜴”，但如果我只是替换“winsAgainst”字段的值，它会以“岩石应该击败剪刀”失败。</p><p id="60ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着我们必须打破Throw接口和它的实现者之间的API。现在我们需要“winsAgainst”作为一个列表:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Abstraction leaked. 💦🔫</figcaption></figure><p id="ac73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然泄漏被很好地包含在一个文件中，但是抽象仍然泄漏。如果与最初的“如果”语句相比，这种抽象的复杂性是非常不和谐的。</p><h1 id="482d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">撤销！并且限制我们自己使用更少的抽象层次。</h1><p id="164a" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">让我们回过头来，尽量限制自己不要引入任何沉重的抽象。我们能不能把“play”函数中原来的“if”语句变得可读性更强一点？</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Back to square one. Feels goooood! 😊</figcaption></figure><h1 id="192b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">解释变量</h1><p id="fc21" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">是的。解释变量。让我们把否定从“第二！= ROCK”和类似的东西，正如我们在其他重构路径中已经了解到的:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Let me explain! 🕵</figcaption></figure><p id="227c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有点可爱。它更容易阅读，也更像业务规则。</p><p id="c9d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我有一个疯狂的问题:我能在这里创建一个DSL来使代码看起来更接近人类对规则的描述吗？</p><h1 id="5769" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">疯狂DSL</h1><p id="4193" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我可以！(不确定我是否应该):</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Don’t do this at home! 🔥</figcaption></figure><p id="4ef0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哇，这看起来很酷。而且读起来很好。</p><p id="67af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了“规则(第一、第二)”部分。这到底是怎么回事？</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Magic, magic, and more magic! 🎩</figcaption></figure><p id="b76e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“在这里，你失去了我，奥莱克西！”—在这一点上，我会告诉自己。Kotlin DSL有很多神奇之处，比如中缀扩展函数和lambda扩展函数。</p><p id="6ab8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过，在那一点上，我把注意力集中在“rules(…) {…}”块的形状上。看起来有点眼熟。</p><h1 id="e29f" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">DSL只是模式匹配。简化！</h1><p id="98f4" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">模式匹配！</p><p id="cc89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在这里试着将“第一和第二”配对成某种组合，比如“剪刀和布”，“布和石头”，“石头和成功”</p><p id="7be9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以通过“when”语句来实现(Kotlin的经典“switch”语句的高级版本):</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Beauty, simplicity, and readability! (if you know Pair&lt;A,B&gt;) 👟</figcaption></figure><p id="6ff7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，由于我们直接提到“真”和“假”，并在“如果”语句中使用它，让我们通过删除布尔变量来简化“播放”函数:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">The final solution. ✅</figcaption></figure><h1 id="7d18" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">这个解决方案的新特性怎么样？</h1><p id="fea8" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">所以我们没有更多的抽象层(除了很少使用<code class="eh ll lm ln lo b">Pair&lt;A, B&gt;</code>类和它的<code class="eh ll lm ln lo b">to</code>中缀扩展函数)。让我们看看引入新规则有多难:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Umm… Lizard… 🦎</figcaption></figure><p id="6c49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那很容易！</p><h1 id="8878" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">使用函数别名的更多表达式。如果你喜欢那个…</h1><p id="1c10" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">而如果想让它更有表现力，可以为中缀函数“to:”创建两个别名vs和beats(绝对可选):</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Icing on the cake in the form of infix extension function aliases. Wait, what? 🍰</figcaption></figure><h1 id="a2ab" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">重构之旅的收获</h1><p id="ff0f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">重构时，我们的解空间似乎是一个多维函数，我们试图找到一个足够好的局部最大值。</p><p id="308e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像教神经网络一样。你的重构步骤是梯度下降。</p><p id="3a42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果你只探索单一下降，你会有好的东西。但这可能是次优的局部最大值。如果我们回头尝试一些不同的重构步骤(不一定更好)会怎么样？。</p><p id="5eb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，我的第一条重构路径产生了可读的代码，但是它引入了两个抽象层次(1个接口和几个实现)。</p><p id="e73b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当回到过去，尝试不同的选择，例如尝试最多引入1或0级抽象，它产生的代码同样可读，但是其中的抽象更少；因此，更容易理解它是如何工作的，并且抽象泄漏的机会也更少。</p><p id="fec6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我要说的是，我不得不在最初的几个步骤中使代码变得更糟糕，然后在接下来的步骤中迅速使它变得更简单。</p><h1 id="0141" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">秘密武器</h1><p id="86fc" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">不要总是凭直觉进行重构，要探索替代方案，了解可读性、复杂性和抽象性的多维功能。</p><p id="794a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你应该考虑探索玩具代码的选项，而不是生产代码:<a class="ae kf" href="http://kata-log.rocks/" rel="noopener ugc nofollow" target="_blank">编码卡塔</a>是完美的选择。从重构的道路上退出，并朝着完全不同的方向前进，这是绝对正确的。</p><p id="a41c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于生产代码，这也是可行的。你没有浪费任何东西。代码没什么价值。你获得的、现在可以应用的知识是金子，它会留在那里。</p><p id="8904" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一定要看看我的4集电子书，350页长的《T2终极教程:科特林入门》除了Kotlin，它还有很多好东西，比如TDD、干净的代码、软件架构、业务影响、5个为什么、验收标准、人物角色等等。下载并<a class="ae kf" href="https://iwillteachyoukotlin.com/" rel="noopener ugc nofollow" target="_blank">学习科特林语</a>。</p><h1 id="3618" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">谢谢大家！</h1><p id="c38d" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">感谢您的阅读！此外，如果你喜欢你刚刚阅读的内容，可以考虑在Medium(最多50个)上给我鼓掌，并在社交媒体上分享这篇文章。那会让我超级开心的！:)</p></div></div>    
</body>
</html>