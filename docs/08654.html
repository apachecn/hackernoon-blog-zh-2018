<html>
<head>
<title>Web Application from Scratch, Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始的Web应用程序，第一部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/web-application-from-scratch-part-i-314ea8203e64?source=collection_archive---------3-----------------------#2018-10-18">https://medium.com/hackernoon/web-application-from-scratch-part-i-314ea8203e64?source=collection_archive---------3-----------------------#2018-10-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bb9d0d4dad1ea654d6700931e4d36e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dVmP6SGphhvC5IMrxEAgA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Yes, this is how all servers start out.</figcaption></figure><p id="6db8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是我将从头开始用Python构建一个web应用程序(及其web服务器)的过程的系列文章中的第一篇。出于本系列的目的，我将只依赖Python标准库，而忽略WSGI标准。</p><p id="cf0e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">事不宜迟，我们开始吧！</p><h1 id="3ce2" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">网络服务器</h1><p id="596d" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">首先，我们将编写支持我们的web应用程序的HTTP服务器。但是首先，我们需要花一点时间了解HTTP协议是如何工作的。</p><h2 id="3751" class="lh kf hu bd kg li lj lk kk ll lm ln ko jr lo lp ks jv lq lr kw jz ls lt la lu dt translated">HTTP如何工作</h2><p id="98c5" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">简单地说，HTTP客户端通过网络连接到HTTP服务器，并向它们发送一串表示请求的数据。然后，服务器解释该请求，并向客户端发回响应。在<a class="ae lv" href="https://tools.ietf.org/html/rfc2616" rel="noopener ugc nofollow" target="_blank"> RFC2616 </a>中描述了整个协议以及这些请求和响应的格式，但是我将在下面非正式地描述它们，这样您就不必阅读全部内容。</p><h2 id="4aa2" class="lh kf hu bd kg li lj lk kk ll lm ln ko jr lo lp ks jv lq lr kw jz ls lt la lu dt translated">请求格式</h2><p id="eba2" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">请求由一系列用<code class="eh lw lx ly lz b">\r\n</code>分隔的行表示，第一行称为“请求行”。请求行由一个HTTP方法、一个空格、被请求文件的路径、另一个空格、客户端使用的HTTP协议版本以及回车符(<code class="eh lw lx ly lz b">\r</code>)和换行符(<code class="eh lw lx ly lz b">\n</code>)组成:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="38ee" class="lh kf hu lz b fv mi mj l mk ml">GET /some-path HTTP/1.1\r\n</span></pre><p id="3411" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在请求行之后是零个或多个标题行。每个标题行由标题名、冒号、可选值和<code class="eh lw lx ly lz b">\r\n</code>组成:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="b52d" class="lh kf hu lz b fv mi mj l mk ml">Host: example.com\r\n<br/>Accept: text/html\r\n</span></pre><p id="3c9c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">标题部分的结尾由一个空行表示:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="ea38" class="lh kf hu lz b fv mi mj l mk ml">\r\n</span></pre><p id="c1ef" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，请求可能包含一个“主体”——随请求发送到服务器的任意有效负载。</p><p id="a458" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">综上所述，这里有一个简单的<code class="eh lw lx ly lz b">GET</code>请求:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="140b" class="lh kf hu lz b fv mi mj l mk ml">GET / HTTP/1.1\r\n<br/>Host: example.com\r\n<br/>Accept: text/html\r\n<br/>\r\n</span></pre><p id="feb5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里有一个简单的<code class="eh lw lx ly lz b">POST</code>请求:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="499b" class="lh kf hu lz b fv mi mj l mk ml">POST / HTTP/1.1\r\n<br/>Host: example.com\r\n<br/>Accept: application/json\r\n<br/>Content-type: application/json\r\n<br/>Content-length: 2\r\n<br/>\r\n<br/>{}</span></pre><h2 id="78e1" class="lh kf hu bd kg li lj lk kk ll lm ln ko jr lo lp ks jv lq lr kw jz ls lt la lu dt translated">响应格式</h2><p id="40a4" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">像请求一样，响应由一系列用<code class="eh lw lx ly lz b">\r\n</code>分隔的行组成。响应中的第一行称为“状态行”，它由HTTP协议版本、后跟空格、响应状态代码、另一个空格、状态代码原因和<code class="eh lw lx ly lz b">\r\n</code>组成:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="390d" class="lh kf hu lz b fv mi mj l mk ml">HTTP/1.1 200 OK\r\n</span></pre><p id="6844" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在状态行之后是响应标题，然后是一个空行，然后是可选的响应正文:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="04f4" class="lh kf hu lz b fv mi mj l mk ml">HTTP/1.1 200 OK\r\n<br/>Content-type: text/html\r\n<br/>Content-length: 15\r\n<br/>\r\n<br/>&lt;h1&gt;Hello!&lt;/h1&gt;</span></pre><h1 id="4272" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">简单的服务器</h1><p id="c87a" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">基于我们目前对该协议的了解，让我们编写一个服务器，不管传入的请求是什么，它都发送相同的响应。</p><p id="d617" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，我们需要创建一个套接字，将其绑定到一个地址，然后开始监听连接。</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="befe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你现在尝试运行这段代码，它会打印出它正在监听<code class="eh lw lx ly lz b">127.0.0.1:9000</code>的标准输出，然后退出。为了实际处理传入的连接，我们需要在套接字上调用<code class="eh lw lx ly lz b">accept</code>方法。这样做将阻塞进程，直到客户端连接到我们的服务器。</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="31cb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦我们有了到客户机的套接字连接，我们就可以开始与它通信了。使用<code class="eh lw lx ly lz b">sendall</code>方法，让我们向连接客户端发送一个示例响应:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="b2f6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您现在运行代码，然后在您最喜欢的浏览器中访问<a class="ae lv" href="http://127.0.0.1:9000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:9000 </a>，它应该会呈现字符串“Hello！”。不幸的是，服务器将在发送响应后退出，因此刷新页面将失败。让我们来解决这个问题:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="e56c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此时，我们有了一个web服务器，它可以为每个请求提供一个简单的HTML网页，全部代码只有25行。那还不算太糟！</p><h1 id="dcb4" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">文件服务器</h1><p id="0ea4" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">让我们扩展HTTP服务器，使它能够提供磁盘外的文件。</p><h2 id="df3b" class="lh kf hu bd kg li lj lk kk ll lm ln ko jr lo lp ks jv lq lr kw jz ls lt la lu dt translated">请求抽象</h2><p id="1876" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">在这样做之前，我们必须能够读取和解析来自客户端的请求数据。因为我们知道请求数据由一系列行表示，每一行由<code class="eh lw lx ly lz b">\r\n</code>字符分隔，所以让我们编写一个从套接字读取数据并生成每一行的生成器函数:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="f666" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这看起来可能有点令人畏惧，但本质上它所做的是从套接字中读取尽可能多的数据(以<code class="eh lw lx ly lz b">bufsize</code>块的形式)，在一个缓冲区中将这些数据结合在一起(<code class="eh lw lx ly lz b">buff</code>)，并不断地将缓冲区分割成单独的行，一次产生一行。一旦它发现一个空行，它就返回它读取的额外数据。</p><p id="2f9e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用<code class="eh lw lx ly lz b">iter_lines</code>，我们可以开始打印我们从客户那里得到的请求:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="32ce" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您现在运行服务器并访问<a class="ae lv" href="http://127.0.0.1:9000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:9000 </a>，您应该会在控制台中看到如下内容:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="0bb0" class="lh kf hu lz b fv mi mj l mk ml">Received connection from ('127.0.0.1', 62086)...<br/>b'GET / HTTP/1.1'<br/>b'Host: localhost:9000'<br/>b'Connection: keep-alive'<br/>b'Cache-Control: max-age=0'<br/>b'Upgrade-Insecure-Requests: 1'<br/>b'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36'<br/>b'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'<br/>b'Accept-Encoding: gzip, deflate, br'<br/>b'Accept-Language: en-US,en;q=0.9,ro;q=0.8'</span></pre><p id="46f3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">相当整洁！让我们通过定义一个<code class="eh lw lx ly lz b">Request</code>类来抽象这些数据:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="2885" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，请求类只知道方法、路径和请求头。我们将把解析查询字符串参数和读取请求体留到以后。</p><p id="ddd8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了封装构建请求所需的逻辑，我们将向<code class="eh lw lx ly lz b">Request</code>添加一个名为<code class="eh lw lx ly lz b">from_socket</code>的类方法:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="dade" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它使用我们之前定义的<code class="eh lw lx ly lz b">iter_lines</code>函数来读取请求行。这就是它获取<code class="eh lw lx ly lz b">method</code>和<code class="eh lw lx ly lz b">path</code>的地方，然后它读取每个单独的标题行并解析它们。最后，它构建<code class="eh lw lx ly lz b">Request</code>对象并返回它。如果我们将它插入到我们的服务器循环中，它应该是这样的:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="2bf0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您现在连接到服务器，您应该会看到这样的行被打印出来:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="0e1d" class="lh kf hu lz b fv mi mj l mk ml">Request(method='GET', path='/', headers={'host': 'localhost:9000', 'user-agent': 'curl/7.54.0', 'accept': '*/*'})</span></pre><p id="f736" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为<code class="eh lw lx ly lz b">from_socket</code>可以在某些情况下引发异常，如果现在给出一个无效的请求，服务器可能会崩溃。为了模拟这种情况，您可以使用telnet连接到服务器，并向其发送一些虚假数据:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="323d" class="lh kf hu lz b fv mi mj l mk ml">~&gt; telnet 127.0.0.1 9000<br/>Trying 127.0.0.1...<br/>Connected to localhost.<br/>Escape character is '^]'.<br/>hello<br/>Connection closed by foreign host.</span></pre><p id="cc7e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">果然，服务器崩溃了:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="3943" class="lh kf hu lz b fv mi mj l mk ml">Received connection from ('127.0.0.1', 62404)...<br/>Traceback (most recent call last):<br/>  File "server.py", line 53, in parse<br/>    request_line = next(lines).decode("ascii")<br/>ValueError: not enough values to unpack (expected 3, got 1)</span><span id="4b3e" class="lh kf hu lz b fv mo mj l mk ml">During handling of the above exception, another exception occurred:</span><span id="a35b" class="lh kf hu lz b fv mo mj l mk ml">Traceback (most recent call last):<br/>  File "server.py", line 82, in &lt;module&gt;<br/>    with client_sock:<br/>  File "server.py", line 55, in parse<br/>    raise ValueError("Request line missing.")<br/>ValueError: Malformed request line 'hello'.</span></pre><p id="2f46" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了更好地处理这类问题，让我们将对<code class="eh lw lx ly lz b">from_socket</code>的调用封装在一个try-except块中，当我们收到一个格式错误的请求时，向客户端发送一个“400 Bad Request”响应:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="eebc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果我们现在尝试破坏它，我们的客户端将得到一个响应，服务器将保持运行:</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="9dcd" class="lh kf hu lz b fv mi mj l mk ml">~&gt; telnet 127.0.0.1 9000<br/>Trying 127.0.0.1...<br/>Connected to localhost.<br/>Escape character is '^]'.<br/>hello<br/>HTTP/1.1 400 Bad Request<br/>Content-type: text/plain<br/>Content-length: 11</span><span id="57cd" class="lh kf hu lz b fv mo mj l mk ml">Bad RequestConnection closed by foreign host.</span></pre><p id="ce7a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此时，我们准备开始实现文件服务部分，但首先让我们将默认响应设为“404 Not Found ”:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="60e3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此外，让我们添加一个“不允许405方法”响应。除了<code class="eh lw lx ly lz b">GET</code>请求之外，我们还需要它。</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="87da" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们定义一个<code class="eh lw lx ly lz b">SERVER_ROOT</code>常量来表示服务器应该从哪里提供文件，以及一个<code class="eh lw lx ly lz b">serve_file</code>函数。</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="1f2c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh lw lx ly lz b">serve_file</code>获取客户端套接字和文件路径。然后，它尝试将该路径解析为<code class="eh lw lx ly lz b">SERVER_ROOT</code>内部的一个真实文件，如果该文件在服务器根目录之外解析，则返回“not found”响应。然后，它尝试打开文件并计算出它的mime类型和大小(使用<code class="eh lw lx ly lz b">os.fstat</code>)，然后构造响应头并使用<code class="eh lw lx ly lz b">sendfile</code>系统调用将文件写入套接字。如果它在磁盘上找不到该文件，那么它会发送一个“未找到”响应。</p><p id="79d1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果我们将<code class="eh lw lx ly lz b">serve_file</code>加入到这个组合中，我们的服务器循环应该是这样的:</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="468a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您在您的<code class="eh lw lx ly lz b">server.py</code>文件旁边添加一个名为<code class="eh lw lx ly lz b">www/index.html</code>的文件，并访问<a class="ae lv" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9000 </a>，您应该会看到该文件的内容。酷吧。</p><h1 id="2325" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">逐渐减少</h1><p id="5d78" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">第1部分到此为止。在第2部分中，我们将讨论提取<code class="eh lw lx ly lz b">Server</code>和<code class="eh lw lx ly lz b">Response</code>抽象，以及让服务器处理多个并发连接。如果你想查看完整的源代码并跟随，你可以在这里找到它<a class="ae lv" href="https://github.com/Bogdanp/web-app-from-scratch/tree/part-01" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a2e5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下次见！</p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><p id="76e2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="mw">感谢阅读！如果你喜欢这篇文章，给它一个掌声！你也可以在我的网站</em><a class="ae lv" href="https://defn.io" rel="noopener ugc nofollow" target="_blank"><em class="mw">https://defn . io</em></a><em class="mw">，在</em><a class="ae lv" href="https://github.com/Bogdanp" rel="noopener ugc nofollow" target="_blank"><em class="mw">GitHub</em></a><em class="mw">和</em><a class="ae lv" href="https://twitter.com/Bogdanp" rel="noopener ugc nofollow" target="_blank"><em class="mw">Twitter</em></a><em class="mw">上找到我。</em></p><div class="mx my fm fo mz na"><a href="https://twitter.com/bogdanp" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab ej"><div class="nc ab nd cl cj ne"><h2 class="bd hv fv z el nf eo ep ng er et ht dt translated">波格丹一世·波帕(@波格丹)|推特</h2><div class="nh l"><h3 class="bd b fv z el nf eo ep ng er et ek translated">波格丹一世·波帕的最新推文。程序员，https://t.co/FFd6cPhKk5和…</h3></div><div class="ni l"><p class="bd b gc z el nf eo ep ng er et ek translated">twitter.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ja na"/></div></div></a></div></div></div>    
</body>
</html>