<html>
<head>
<title>The Myth about Golang Frameworks and External Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Golang框架和外部库的神话</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-myth-about-golang-frameworks-and-external-libraries-93cb4b7da50f?source=collection_archive---------2-----------------------#2018-10-19">https://medium.com/hackernoon/the-myth-about-golang-frameworks-and-external-libraries-93cb4b7da50f?source=collection_archive---------2-----------------------#2018-10-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e0e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我写Go投入生产已经有一段时间了，真的很享受它的速度和可靠性。更小的构建规模，go-routines提供的并发性，以及您可以直接在机器上运行构建的事实，使得<a class="ae jp" href="https://hackernoon.com/tagged/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a>非常可爱。</p><p id="c8cb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">标准包的性能非常好，你可以创建一个生产就绪的微服务，而不需要任何外部库或框架。但这并不意味着Go中没有提供更大灵活性或更快速度的框架，它们只是不被优先考虑。</p><p id="c512" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你问一个Go开发者你可以使用什么样的web框架或库，典型的答案是坚持使用标准库。具有讽刺意味的是,“golang框架”在google上的最高搜索结果是关于为什么你不应该使用它们。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/8f74636fe53b64940b332035ddfa8172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*erxlNaeuTgbDpn6V"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">The top comment to a question about Go frameworks on HN</figcaption></figure><p id="5233" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对标准库的替代品做了一些研究，看看它们的性能如何，并对它们进行了基准测试。我将它们归类为构成微服务的基本组件。</p><p id="9361" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有性能指标评测都是在以下配置下进行的。虽然标准的<a class="ae jp" href="https://hackernoon.com/tagged/benchmark" rel="noopener ugc nofollow" target="_blank">基准</a>时间仅仅是<code class="eh kg kh ki kj b">1s</code>，但是我运行了<code class="eh kg kh ki kj b">10s</code>的所有测试，以便每个测试都有一致的周期。</p><pre class="jr js jt ju fq kk kj kl km aw kn dt"><span id="2807" class="ko kp hu kj b fv kq kr l ks kt">Processor  - 2.7 GHz Intel Core i7</span><span id="5edf" class="ko kp hu kj b fv ku kr l ks kt">RAM - 16GB - 16 GB 2133 MHz LPDDR3</span><span id="50d1" class="ko kp hu kj b fv ku kr l ks kt">OS - MacOS High Sierra</span><span id="da15" class="ko kp hu kj b fv ku kr l ks kt">go version  - go1.11.1</span><span id="66d1" class="ko kp hu kj b fv ku kr l ks kt">Bench Time 10s instead of standard 1s</span><span id="5f11" class="ko kp hu kj b fv ku kr l ks kt">go test -bench=. -benchtime=10s</span></pre><h2 id="2a72" class="ko kp hu bd kv kw kx ky kz la lb lc ld jc le lf lg jg lh li lj jk lk ll lm ln dt translated">按指定路线发送</h2><p id="f949" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">标准的http Go服务器提供了一个很好的路由器，它可以读取查询参数，但是不能读取命名参数，</p><pre class="jr js jt ju fq kk kj kl km aw kn dt"><span id="427a" class="ko kp hu kj b fv kq kr l ks kt">/students/:studentID/grades/:gradeID</span></pre><p id="fb3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">任何具有上述嵌套资源的REST服务都必须使用外部路由库来解析它们。Gin，Echo，Beego，Gorilla Mux，Goji都是比较受欢迎的几个(根据他们的Github以下)。<br/>其中一些是成熟的中间件框架，也提供路由，一些只是路由库。</p><p id="a757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对这些库的单个命名参数进行了基准测试，结果如下。Gin拥有最快的路由器，紧随其后的是紧随其后的Echo。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lt"><img src="../Images/9c6a77ab770f19b0585eef522b8aad62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yvajGjiyDQtXDTKw"/></div></div></figure><h2 id="4583" class="ko kp hu bd kv kw kx ky kz la lb lc ld jc le lf lg jg lh li lj jk lk ll lm ln dt translated">JSON序列化和反序列化</h2><p id="b107" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">一旦一个API请求通过路由器命中并传递给控制器或处理程序，下一步就是解码请求JSON或编码，同时返回响应。</p><p id="11d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Go有一个非常好的<code class="eh kg kh ki kj b">encoding</code>包，支持像<code class="eh kg kh ki kj b">json, XML, csv</code>这样的多种格式，但是快速浏览一下备选方案，你会看到大量的库。我用标准的<code class="eh kg kh ki kj b">encoding/json</code>软件包对Jsoniter、EasyJson进行了基准测试，下面是结果。</p><p id="2a04" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是编码的结果，结果表明性能差异并不显著。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lt"><img src="../Images/bc47bbbd34e25608e3e456d991edda54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wNA_n90NbJxB7p-H"/></div></div></figure><p id="255e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是对于解码JSON，<code class="eh kg kh ki kj b">jsoniter</code>比标准编码包执行5X更快。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lt"><img src="../Images/42ddb64dda1fb134272cb256e887478b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jj6vx5RJR5kQwU5j"/></div></div></figure><p id="79f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果您的请求被解码，下一步可能是应用您的业务逻辑，可能是做一些数据库操作。</p><h2 id="6054" class="ko kp hu bd kv kw kx ky kz la lb lc ld jc le lf lg jg lh li lj jk lk ll lm ln dt translated">ORM还是不是？</h2><p id="3941" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">大多数流行语言依靠框架来构建与数据库交互的微服务。在Java世界中，Hibernate、Active Record for Rails和Django ORM都非常流行。ORM(对象关系映射器)有时有助于更好地处理事务、表之间的关系，并有助于避免为简单的连接编写复杂的SQL。</p><p id="414f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是Go again有一个非常好的<code class="eh kg kh ki kj b">database</code>标准库，它使得连接到关系数据库变得非常容易，也非常快。但是，一个棘手的问题是查询。当您查询一些行时，您必须手动映射行中的每个字段，然后将它们分配给一个<code class="eh kg kh ki kj b">struct</code>。这是可行的，但很快就会变得混乱，并让您编写大量代码。<code class="eh kg kh ki kj b"><strong class="it hv">sqlx</strong></code>是一个库，它允许你将整行扫描到你的结构变量中。</p><p id="8983" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然<code class="eh kg kh ki kj b">sqlx</code>减少了构建CRUD所需的典型行数，但你仍然会多次重复编写代码。使用ORM有助于减少这种情况，并专注于您的业务逻辑。</p><p id="4878" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对<code class="eh kg kh ki kj b">database, database + sqlx, gorm , go-pg</code>进行了基准测试，下面是结果。令人惊讶的是，<code class="eh kg kh ki kj b">go-pg</code>，一个ORM的执行速度比标准包甚至<code class="eh kg kh ki kj b">sqlx</code>都要快。GORM虽然在生态系统中非常有名，但速度相对较慢。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lu"><img src="../Images/a6a271bc97384b17b9c8042d9f16fcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xFtM30OimcKlGRsT"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Querying 200K records from a postgres DB</figcaption></figure><p id="c775" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在API调用的每一步中，都有更好的框架或外部库，这将使您的响应更快，并提供一些灵活性。</p><h2 id="7572" class="ko kp hu bd kv kw kx ky kz la lb lc ld jc le lf lg jg lh li lj jk lk ll lm ln dt translated">警告</h2><p id="49b7" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">虽然一些速度上的改进是显而易见的，但这本身并不应该成为远离标准库的理由。测试代码的难易程度，开源库的长期维护，团队的学习曲线都应该考虑在内。</p><p id="1ef7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管如此，我认为像<code class="eh kg kh ki kj b">echo + jsoniter + go-pg</code>这样的东西以及Go标准库的所有令人惊叹的特性将是构建你的微服务和避免冗余代码的最快方法。</p><p id="b5f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请分享你对Go图书馆的想法和经验。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lv lw l"/></div></figure></div></div>    
</body>
</html>