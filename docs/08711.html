<html>
<head>
<title>How to Add Chuck Norris Jokes to Bitrise Build Logs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Chuck Norris笑话添加到Bitrise构建日志中</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-add-chuck-norris-jokes-to-bitrise-build-logs-6a02a4a72c7?source=collection_archive---------24-----------------------#2018-10-19">https://medium.com/hackernoon/how-to-add-chuck-norris-jokes-to-bitrise-build-logs-6a02a4a72c7?source=collection_archive---------24-----------------------#2018-10-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fd6004f33f5dcefc99ae65679e4209f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iZG29IUZQcNIa_2t.png"/></div></div></figure><p id="1907" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能认为CI(持续集成)只包括技术任务，如单元测试、代码编译或静态代码分析。然而，<strong class="je hv">有时候你可能想给无聊的构建日志</strong>:)增加一点乐趣，如果你熟悉Jenkins <strong class="je hv">你可能听说过</strong> <a class="ae ka" href="https://plugins.jenkins.io/chucknorris" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">查克·诺里斯插件</strong> </a> <strong class="je hv"> </strong>，其中<strong class="je hv">给构建</strong>增加了关于 <a class="ae ka" href="https://en.wikipedia.org/wiki/Chuck_Norris" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">查克·诺里斯</strong> </a> <strong class="je hv">的有趣事实/笑话。</strong></p><p id="84dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我向您展示如何将这样的功能添加到<a class="ae ka" href="https://www.bitrise.io/" rel="noopener ugc nofollow" target="_blank"> Bitrise.io </a>之前，让我解释一下，什么是Bitrise.io。</p><h2 id="2366" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">什么是Bitrise.io？</h2><p id="bde4" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated"><a class="ae ka" href="https://devcenter.bitrise.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Bitrise </strong> </a> <strong class="je hv">是一家持续集成和交付(CI/CD)平台即服务(PaaS)，主要专注于移动应用开发。几年前，在Droids On Roids，我们将CI/CD平台从<a class="ae ka" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>换成了Bitrise。这次迁移的主要原因是更好地适应移动(原生Android和iOS项目)和更快地修复错误(例如，Jenkins Android emulator插件中的<a class="ae ka" href="https://github.com/jenkinsci/android-emulator-plugin/pull/61" rel="noopener ugc nofollow" target="_blank"> this my PR </a>已经等待了大约1.5年的审查)。然而，Bitrise上缺少了一个额外的小功能…没有查克·诺里斯笑话的<a class="ae ka" href="https://www.bitrise.io/integrations/steps" rel="noopener ugc nofollow" target="_blank">集成</a>。</strong></p><h2 id="4990" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">实现Chuck Norris笑话集成</h2><p id="b7e3" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">向构建日志添加笑话的过程非常简单。我们只需要获得一个笑话文本，并将其打印到日志中。当然，我们不能忘记适当的错误处理。</p><p id="45a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从安装<a class="ae ka" href="https://app.bitrise.io/cli" rel="noopener ugc nofollow" target="_blank"> Bitrise CLI </a>和调用<code class="eh lb lc ld le b">bitrise :step create</code>开始。你可以在我之前的博客文章中找到更多关于步骤创建的信息:<a class="ae ka" href="https://www.thedroidsonroids.com/blog/how-to-create-bitrise-step-in-go-flutter-example" rel="noopener ugc nofollow" target="_blank">如何在Go-Flutter示例中创建Bitrise步骤</a>。</p><p id="0b04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Bitrise <strong class="je hv">官方支持两个编写集成的工具包(所谓的步骤):</strong><a class="ae ka" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">bash</strong></a><strong class="je hv">(shell脚本)和</strong> <a class="ae ka" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> go </strong> </a> <strong class="je hv">。</strong>乍一看，这个集成看起来微不足道，因此它可能是shell脚本的一个很好的候选。然而，由于我们需要一些基本的逻辑，如验证或错误处理，而Bitrise提供了可以帮助我们的库，我们将使用golang toolkit。</p><h2 id="6e48" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">➡笑话的来源</h2><p id="99e5" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">詹金斯插件使用<a class="ae ka" href="https://github.com/jenkinsci/chucknorris-plugin/blob/master/src/main/java/hudson/plugins/chucknorris/FactGenerator.java" rel="noopener ugc nofollow" target="_blank">硬编码笑话文本</a>。这是实现起来最简单的源代码。然而，它也有一个主要的缺点。添加一个新笑话需要每次发布一个新版本的Bitrise步骤。这些版本中的每一个都需要得到批准，用户需要在他们的<a class="ae ka" href="https://devcenter.bitrise.io/getting-started/getting-started-workflows/" rel="noopener ugc nofollow" target="_blank">工作流</a>中<a class="ae ka" href="https://devcenter.bitrise.io/getting-started/getting-started-steps/#managing-step-versions" rel="noopener ugc nofollow" target="_blank">更新步骤版本</a>(除非他们选择了“总是最新”版本)。通常，将数据从逻辑中分离出来是一个好主意。</p><p id="27b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以从外部免费的API获取笑话。比如<a class="ae ka" href="https://api.chucknorris.io" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">chuck Norris . io</strong></a><strong class="je hv">。这个包含许多不同的笑话，它是开源的，支持纯文本回复，所以它完全符合我们的需求。不过，也有<a class="ae ka" href="https://www.google.com/search?q=chuck+norris+api" rel="noopener ugc nofollow" target="_blank">其他替代方案</a>。</strong></p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/ef44ef1ae427739d246b9787a08ad0a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*oOZDplxol9tATL5B.gif"/></div></figure><h2 id="1bf4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">➡配置</h2><p id="526b" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">虽然这一步执行的任务看起来很简单——我们只需要下载笑话并显示它们，但是通过允许配置一些参数来引入一点灵活性也是有用的。首先是API主机URL，出于隐私原因，可能需要使用不同于公共chucknorris.io的URL，例如自托管实例。chucknorris.io的所有后端组件都是<a class="ae ka" href="https://github.com/chucknorris-io" rel="noopener ugc nofollow" target="_blank">开源的</a>，所以应该不成问题。</p><p id="a05d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其次，我们可能要<strong class="je hv">定制段子类别</strong>。人们可能更喜欢某个特定的。API中有一个查询参数。</p><p id="8f00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">配置参数使用</strong> <a class="ae ka" href="https://devcenter.bitrise.io/bitrise-cli/step-inputs/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">步进输入</strong> </a> <strong class="je hv">指定。</strong>它们在工作流编辑器GUI中显示为表单字段，并作为环境变量注入到构建中。新生成的步骤包含样本输入。当添加实际输入时，我们可以基于它。定制后，输入部分应该如下所示:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="4271" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意以下几点:</p><ol class=""><li id="5ab4" class="lm ln hu je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu dt translated">输入名称(<code class="eh lb lc ld le b">category</code>和<code class="eh lb lc ld le b">api_base_url</code>)使用小写字母书写。</li><li id="23e8" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated"><code class="eh lb lc ld le b">api_base_url</code>被标记为必填项，这一事实将在工作流编辑器中得到反映。</li><li id="9189" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated"><code class="eh lb lc ld le b">api_base_url</code>的默认值设置为<code class="eh lb lc ld le b">https://api.chucknorris.io</code>，因此用户不需要明确指定。</li></ol><p id="1d21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好了，我们已经定义了输入。现在我们可以尝试读取它们的值。幸运的是，Bitrise提供了<a class="ae ka" href="https://github.com/bitrise-tools/go-steputils" rel="noopener ugc nofollow" target="_blank"> steputils </a>库，它为我们做了所有的工作。我们只需要为配置定义数据结构:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="a91c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意Go和YAML不同的命名规则。使用<a class="ae ka" rel="noopener" href="/golangspec/tags-in-golang-3e5db0b8ef3e"> struct标签</a>指定名称映射以及附加属性(值是否需要)。现在我们可以简单地从环境中读取输入:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="5c35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果出现错误(例如，所需的输入不存在)，我们会在构建日志中打印一条消息，并以失败代码退出，不会执行后续指令。</p><h2 id="579f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">➡听懂了笑话</h2><p id="77d5" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">下载笑话的过程可以分为几个阶段。首先，我们需要基于配置参数(API主机URL和类别)创建一个HTTP请求:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="8f2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我们请求纯文本响应，因此不需要在接下来的步骤中处理它来获得实际的笑话文本。所有的错误都会传播给调用者，我们将在顶层函数中处理它们。</p><p id="9524" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们执行请求:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="8121" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里唯一的定制是超时设置为20秒。这很重要，因为默认情况下超时是无限的，所以step可能会挂起构建。</p><p id="81b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们可以从响应中读取文本:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="4aa0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要显式地检查HTTP状态代码。如果没有这些，在出现错误的情况下，我们可以开玩笑说文本是<em class="ma"> 500内部服务器错误</em>。请注意，错误消息以小写字母开头。将它们大写是错误的，因为它们以后会被附加到前缀上。</p><p id="8dec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将所有这些步骤连接在一起后，我们应该得到如下代码:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="e24d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了调用上述函数，我们还有延迟响应体关闭。它将在封闭函数完成后关闭。请注意，如果关闭失败，我们不能将此错误返回给调用者。我们记录下来，而不仅仅是忽略。吞咽错误被认为是一种不好的做法，像<a class="ae ka" href="https://github.com/kisielk/errcheck" rel="noopener ugc nofollow" target="_blank"> errcheck </a>这样的静态代码分析工具会抱怨这一点。</p><h2 id="07b6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">➡展示输出</h2><p id="6340" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">当我们有一个笑话文本时，我们唯一需要做的就是将它打印到构建日志中，其中包含了在构建过程中打印到标准输出和标准错误的所有内容。此外，我们可以将笑话文本作为步骤<a class="ae ka" href="https://devcenter.bitrise.io/bitrise-cli/step-outputs/" rel="noopener ugc nofollow" target="_blank">输出</a>导出，这样它可能会被后续步骤使用，例如通过在slack消息中发布。最后，我们的主(顶层)函数如下所示:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="9604" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们使用了来自<a class="ae ka" href="https://github.com/bitrise-io/go-utils" rel="noopener ugc nofollow" target="_blank"> go-utils </a>的<code class="eh lb lc ld le b">log</code>来打印彩色消息。如果成功，我们不需要用代码<code class="eh lb lc ld le b">0</code>显式退出，因为这是默认值。此外，导出需要使用<a class="ae ka" href="https://devcenter.bitrise.io/tips-and-tricks/expose-environment-variable/" rel="noopener ugc nofollow" target="_blank"> envman </a>来完成，envman 将导出添加到后续步骤可访问的envstore中。如果我们只是<a class="ae ka" href="https://golang.org/pkg/os/#Setenv" rel="noopener ugc nofollow" target="_blank">为当前进程设置</a>环境变量，它将在步骤完成后丢失。请记住，输出应该在<code class="eh lb lc ld le b">step.yml</code>中声明，以便在工作流编辑器中可见。按照惯例，输出名称用大写字母书写:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><h2 id="cf71" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">步骤属性</h2><p id="2f0e" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">默认情况下，当Bitrise上的步骤失败时，整个构建被视为失败，并且不会执行后续步骤。这些行为不符合我们的用例。我们希望总是得到笑话(即使前面的一些步骤已经失败了)，并且<strong class="je hv">我们不希望在得到笑话的过程中那些失败影响到整体的构建结果</strong>。例如，用户很不高兴<a class="ae ka" href="https://help.github.com/articles/about-status-checks/" rel="noopener ugc nofollow" target="_blank">拉取请求状态检查</a>仅因下载Chuck Norris笑话期间的错误而失败，并且PR无法合并。</p><p id="a9ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">为了实现期望的行为，我们需要通过将</strong> <code class="eh lb lc ld le b"><strong class="je hv">is_always_run</strong></code> <strong class="je hv">和</strong> <code class="eh lb lc ld le b"><strong class="je hv">is_skippable</strong></code> <strong class="je hv">设置为true来调整步骤配置。</strong>第一个步骤告诉我们，即使构建被标记为失败(前面的一些步骤已经失败)，也应该开始该步骤。用户将能够在工作流编辑器中覆盖该设置。Skippable step意味着它的失败不会影响整个构建状态——它仍然可以成功。如果你真的需要一个笑话，可以在<code class="eh lb lc ld le b">bitrise.yml</code>配置文件中覆盖这个设置。</p><h2 id="dd4d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">需要一个成功的团队？</h2><p id="7340" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">我们是100%基于办公室的团队，在移动&amp; web应用程序开发方面有7年的经验<br/></p><p id="bb3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://www.thedroidsonroids.com/estimate-project" rel="noopener ugc nofollow" target="_blank">估算项目</a></p><h2 id="d781" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">词中之词</h2><p id="f356" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">Bitrise steplib提交清单<a class="ae ka" href="https://github.com/bitrise-io/bitrise-steplib/blob/master/PULL_REQUEST_TEMPLATE.md" rel="noopener ugc nofollow" target="_blank">中的一个元素</a>表示该步骤应该在其repo中包含测试工作流。默认情况下，它包括运行步骤。然而，Bitrise提供了几个实用程序，用于持续集成Go中编写的步骤:<a class="ae ka" href="https://www.bitrise.io/integrations/steps/golint" rel="noopener ugc nofollow" target="_blank"> golint </a>，<a class="ae ka" href="https://www.bitrise.io/integrations/steps/errcheck" rel="noopener ugc nofollow" target="_blank"> errcheck </a>和<a class="ae ka" href="https://www.bitrise.io/integrations/steps/go-test" rel="noopener ugc nofollow" target="_blank"> Go test </a>。所有这些步骤都需要知道哪个是被测试的Go包。最简单的方法是使用<a class="ae ka" href="https://www.bitrise.io/integrations/steps/go-list" rel="noopener ugc nofollow" target="_blank"> Go list </a> step。完整的工作流程如下所示:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="5516" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，我们在那里添加了<a class="ae ka" href="https://golang.org/cmd/vet/" rel="noopener ugc nofollow" target="_blank"> go vet </a>。这是Golang的官方静态分析工具。</p><h2 id="576b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">出版</h2><p id="5caa" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">Bitrise devcenter包含<a class="ae ka" href="https://devcenter.bitrise.io/bitrise-cli/create-your-own-step/#sharing-a-new-step" rel="noopener ugc nofollow" target="_blank">教程</a>关于分享自己的步骤。然而，还有一个<code class="eh lb lc ld le b">share-this-step</code>工作流，它结合了所有这些指令。步骤共享过程需要<code class="eh lb lc ld le b">MY_STEPLIB_REPO_FORK_GIT_URL</code>环境变量。可以使用<code class="eh lb lc ld le b">.bitrise.secrets.yml</code>文件提供，如下所示:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="8a5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认情况下，该文件被忽略，不会签入版本控制。我们还增加了一点改进。我们检索当前的git标签:<code class="eh lb lc ld le b">--tag $(git describe --tags --exact-match)</code>，而不是在<code class="eh lb lc ld le b">BITRISE_STEP_VERSION</code>变量中硬编码步骤版本。在这种情况下，没有必要在两个不同的地方分配相同的版本——在git标签和<code class="eh lb lc ld le b">bitrise.yml</code>中。真理只有一个来源。</p><h2 id="8547" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">包裹</h2><p id="2f7b" class="pw-post-body-paragraph jc jd hu je b jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv la jx jy jz hn dt translated">正如你所看到的，持续集成不仅包括技术任务，你也可以做有趣的事情:)在Bitrise CI平台的情况下，我们可以很容易地以steps的形式开发和共享我们自己的扩展。</p><p id="7b8f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完整的源代码可以在<a class="ae ka" href="https://github.com/DroidsOnRoids/bitrise-step-chuck-norris" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/d4cba39f5c96ca701676dd5bb82885ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/0*s0lVaSiWQ_TeTiP4.gif"/></div></figure></div></div>    
</body>
</html>