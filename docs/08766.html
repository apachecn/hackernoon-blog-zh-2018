<html>
<head>
<title>Elm: Functional Frontend!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elm:功能前端！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/elm-more-functional-frontend-c7d8c21c8bce?source=collection_archive---------23-----------------------#2018-10-22">https://medium.com/hackernoon/elm-more-functional-frontend-c7d8c21c8bce?source=collection_archive---------23-----------------------#2018-10-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/2a92fd2482d05f6ffc7ca0e08739f7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*bmCmkh_N7WnTPg_KZjr2FA.png"/></div></figure><p id="f6a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们的<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>涵盖了许多在制作Web应用程序时可以使用的酷库。但是有一件事我们在这个博客上还没有涉及，那就是使用Haskell进行前端web开发。有许多库和框架。<a class="ae jw" href="https://www.yesodweb.com/" rel="noopener ugc nofollow" target="_blank"> Yesod </a>和<a class="ae jw" href="http://snapframework.com/" rel="noopener ugc nofollow" target="_blank"> Snap </a>浮现脑海。另一种选择是<a class="ae jw" href="https://github.com/reflex-frp/reflex" rel="noopener ugc nofollow" target="_blank">反射玻璃钢</a>，它在引擎盖下使用GHCJS。</p><p id="60fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是对于这个新系列，我决定采取不同的方法。接下来的几周，我们将关注榆树！</p><p id="4f87" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我喜欢榆树有几个原因。Elm建立在我的坚定信念之上，即我们可以将函数式编程的原则付诸实践。语言是严肃的，文档也很好。Elm有一些语法上的怪癖。它还缺少一些Haskell的关键特性。然而，我们仍然可以用它做很多事情。</p><p id="93df" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">本周我们将了解基本安装、区别和用法。下周，我们将在Elm中编写一个简单的Todo应用程序。这将让我们感受到我们是如何设计Elm应用程序的。最后，我们将探索如何为我们的应用程序添加更多效果，以及如何将Elm类型与Haskell集成。</p><p id="a93b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当然，前端只是故事的一部分。要了解更多关于使用Haskell进行后端web的信息，请查看我们的Haskell Web系列<a class="ae jw" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank">！您也可以下载我们的</a><a class="ae jw" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>了解更多创意！</p><h1 id="074e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">基本设置</h1><p id="e8f8" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">和任何语言一样，第一次在我们的机器上使用Elm时会有一些设置。对于Windows和Mac，你可以运行这里提供的安装程序。Linux有单独的指令，但是它们足够简单。您获取二进制文件，<code class="eh la lb lc ld b">tar</code>它，并移动到您的<code class="eh la lb lc ld b">bin</code>。</p><p id="afe8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一旦我们安装了<code class="eh la lb lc ld b">elm</code>可执行文件，我们就可以开始了。当您使用了足够多的包管理程序后，这个过程就变得更容易理解了。<code class="eh la lb lc ld b">elm</code>命令与<code class="eh la lb lc ld b">stack</code>和<code class="eh la lb lc ld b">npm</code>有一些基本的共同点。</p><p id="0a2e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，我们可以运行<code class="eh la lb lc ld b">elm init</code>来创建一个新项目。这将为我们创建一个<code class="eh la lb lc ld b">src</code>文件夹和一个<code class="eh la lb lc ld b">elm.json</code>文件。这个JSON文件类似于Node.js的<code class="eh la lb lc ld b">.cabal</code>文件或<code class="eh la lb lc ld b">package.json</code>,在这里我们将指定所有不同的包依赖关系。这个的默认版本将提供您的大多数基本web包。然后我们将在<code class="eh la lb lc ld b">/src</code>中制作我们的<code class="eh la lb lc ld b">.elm</code>源文件。</p><h1 id="0e40" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">运行基本页面</h1><p id="62db" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">Elm开发看起来不同于我使用过的大多数普通Javascript系统。当我们编写代码时，我们不需要指定应用程序的特定入口点。我们制作的每个文件都是我们可以查看的潜在网页。因此，我们可以从最简单的应用开始:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="0fa1" class="lm jy hu ld b fv ln lo l lp lq">import Browser<br/>import HTML exposing (Html, div, text)</span><span id="7584" class="lm jy hu ld b fv lr lo l lp lq">type Message = Message</span><span id="40ed" class="lm jy hu ld b fv lr lo l lp lq">main : Program () Int Message<br/>main =<br/>  Browser.sandbox { init = 0, update = update, view = view }</span><span id="4c00" class="lm jy hu ld b fv lr lo l lp lq">update : Message -&gt; Int -&gt; Int<br/>update _ x = x</span><span id="49db" class="lm jy hu ld b fv lr lo l lp lq">view : Int -&gt; Html Message<br/>view _ = div [] [text "Hello World!"]</span></pre><p id="1e4e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Elm使用模型/视图/控制器系统。我们在<code class="eh la lb lc ld b">main</code>函数中定义我们的程序。我们的<code class="eh la lb lc ld b">Program</code>型有三个参数。第一个与我们可以传递给程序的标志有关。我们暂时忽略这些。第二个是我们程序的模型类型。我们从一个简单的整数开始。最后一种类型是消息。我们的视图将通过发送这种类型的消息来引起更新。<code class="eh la lb lc ld b">sandbox</code>函数意味着我们的程序很简单，并且没有副作用。除了传递初始状态，我们还传递了一个<code class="eh la lb lc ld b">update</code>函数和一个<code class="eh la lb lc ld b">view</code>函数。</p><p id="442d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh la lb lc ld b">update</code>功能允许我们获取新消息，并在必要时更改我们的模型。然后<code class="eh la lb lc ld b">view</code>是一个接受我们的模型并决定HTML组件的函数。您可以将<code class="eh la lb lc ld b">view</code>的类型理解为“发送<code class="eh la lb lc ld b">Message</code>类型消息的HTML组件”。</p><p id="8a7c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以运行<code class="eh la lb lc ld b">elm-reactor</code>命令，将浏览器指向<code class="eh la lb lc ld b">localhost:8000</code>。这将我们带到一个仪表板，在那里我们可以检查任何我们想要的文件。我们只想看看有<code class="eh la lb lc ld b">main</code>功能的那些。然后，我们将在屏幕上看到带有div的简单页面。(如果我们选择一个纯库文件，它会奇怪地旋转)。</p><p id="9ecc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">按照<a class="ae jw" href="https://guide.elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm教程</a>的说法，我们可以通过在模型中使用<code class="eh la lb lc ld b">Int</code>来让它变得更有趣。我们将改变我们的<code class="eh la lb lc ld b">Message</code>类型，这样它既可以代表<code class="eh la lb lc ld b">Increment</code>也可以代表<code class="eh la lb lc ld b">Decrement</code>。然后我们的更新函数将根据消息改变模型。</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="e183" class="lm jy hu ld b fv ln lo l lp lq">type Message = Increment | Decrement</span><span id="086b" class="lm jy hu ld b fv lr lo l lp lq">update : Message -&gt; Int -&gt; Int<br/>update msg model = case msg of<br/>  Increment -&gt; model + 1<br/>  Decrement -&gt; model - 1</span><span id="3387" class="lm jy hu ld b fv lr lo l lp lq">view : Int -&gt; Html Message<br/>view model = div [] [String.fromInt model]</span></pre><p id="ddac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">作为最后的改变，我们将在界面上添加<code class="eh la lb lc ld b">+</code>和<code class="eh la lb lc ld b">-</code>按钮。这将允许我们向我们的类型发送<code class="eh la lb lc ld b">Increment</code>和<code class="eh la lb lc ld b">Decrement</code>消息。</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="446c" class="lm jy hu ld b fv ln lo l lp lq">view model = div []<br/>  [ button [onClick Decrement] [text "-"]<br/>  , div [] [ text (String.fromInt model) ]<br/>  , button [onClick Increment] [text "+"]<br/>  ]</span></pre><p id="49dc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们有一个界面，我们可以按下每个按钮，屏幕上的数字会改变！这是我们的基本应用！</p><h1 id="6f55" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">Make命令</h1><p id="bb48" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated"><code class="eh la lb lc ld b">elm reactor</code>命令构建了一个虚拟界面，供我们使用和检查页面。但是我们的最终目标是让它能够从我们的elm代码中生成HTML和Javascript。然后，我们将导出这些资产，以便我们的后端可以将它们作为资源。我们可以用<code class="eh la lb lc ld b">elm make</code>命令来完成。这里有一个例子:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="c43d" class="lm jy hu ld b fv ln lo l lp lq">elm make Main.elm --output=main.html</span></pre><p id="df40" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们希望使用脚本将所有这些元素放在一起，并将其转储到assets文件夹中。几周后，当我们完成一个完整的Elm + Haskell项目时，我们将会在这方面获得一些经验。</p><h1 id="9d13" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">与Haskell的区别</h1><p id="adca" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">在比较Elm和Haskell时，有一些语法上的问题。我们不会涵盖所有这些，但这里有一些基本的。</p><p id="e69c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们已经可以看到导入和模块语法有一点不同。我们在导入定义中使用<code class="eh la lb lc ld b">exposing</code>关键字来从该模块中挑选出我们想要的特定表达式。</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="47a0" class="lm jy hu ld b fv ln lo l lp lq">import HTML exposing (Html, div, text)</span><span id="3b8a" class="lm jy hu ld b fv lr lo l lp lq">import Types exposing (Message(..))</span></pre><p id="ade2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们定义自己的模块时，我们也将使用<code class="eh la lb lc ld b">exposing</code>关键字来代替模块定义中的<code class="eh la lb lc ld b">where</code>:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="2bda" class="lm jy hu ld b fv ln lo l lp lq">module Types exposing<br/>  (Message(..))</span><span id="b2a8" class="lm jy hu ld b fv lr lo l lp lq">type Message = Increment | Decrement</span></pre><p id="a8d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还可以看到，Elm在Haskell中使用<code class="eh la lb lc ld b">data</code>的地方使用了<code class="eh la lb lc ld b">type</code>。如果我们想要一个类型同义词，Elm提供了<code class="eh la lb lc ld b">type alias</code>组合:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="9f4d" class="lm jy hu ld b fv ln lo l lp lq">type alias Count = Int</span></pre><p id="51ee" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">从上面的类型操作符可以看出，Elm反转了<code class="eh la lb lc ld b">:</code>操作符和<code class="eh la lb lc ld b">::</code>。单个冒号指的是类型签名。双冒号表示列表附加:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="440f" class="lm jy hu ld b fv ln lo l lp lq">myNumber : Int<br/>myNumber = 5</span><span id="1a68" class="lm jy hu ld b fv lr lo l lp lq">myList : [Int]<br/>myList = 5 :: [2, 3]</span></pre><p id="e596" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Elm还缺少Haskell的一些更好的语法元素。例如，Elm在功能和防护上缺乏模式匹配。Elm也没有<code class="eh la lb lc ld b">where</code>子句。只有<code class="eh la lb lc ld b">case</code>和<code class="eh la lb lc ld b">let</code>语句存在。对于函数组合，您可以使用<code class="eh la lb lc ld b">&lt;&lt;</code>而不是<code class="eh la lb lc ld b">.</code>操作符。data-preserve-html-node="true "以下是这些要点的几个示例:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="00bb" class="lm jy hu ld b fv ln lo l lp lq">isBigNumber : Int -&gt; Bool<br/>isBigNumber x = let forComparison = 5 in x &gt; forComparison</span><span id="4d06" class="lm jy hu ld b fv lr lo l lp lq">findSmallNumbers : List Int -&gt; List Int<br/>findSmallNumbers numbers = List.filter (not &lt;&lt; isBigNumber) numbers</span></pre><p id="b112" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">作为本节的最后一点，Elm是严格评估的。Elm编译成Javascript，因此可以在浏览器中运行。而且用严格的语言生成合理的Javascript要容易得多。</p><h1 id="832e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">榆树唱片公司</h1><p id="2eac" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">Elm的另一个关键区别是记录语法的工作方式。它榆树，一个“记录”是一个特定的类型。这些模拟Javascript对象。在这个例子中，我们为一个记录定义了一个类型同义词。虽然我们通常没有模式匹配，但我们可以对记录使用模式匹配:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="f3b6" class="lm jy hu ld b fv ln lo l lp lq">type alias Point2D =<br/>  { x: Float<br/>  , y: Float<br/>  }</span><span id="962c" class="lm jy hu ld b fv lr lo l lp lq">sumOfPoint : Point2D -&gt; Float<br/>sumOfPoint {x, y} = x + y</span></pre><p id="233d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了让我们的代码更像Javascript，我们可以使用<code class="eh la lb lc ld b">.</code>操作符以不同的方式访问记录。我们可以使用类似Javascript的语法，或者像普通函数一样使用句点和字段名。</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="bfdb" class="lm jy hu ld b fv ln lo l lp lq">point1 : Point2D<br/>point1 = {x = 5.0, y = 6.0}</span><span id="f6e3" class="lm jy hu ld b fv lr lo l lp lq">p1x : Float<br/>p1x = point1.x</span><span id="6023" class="lm jy hu ld b fv lr lo l lp lq">p1y : Float<br/>p1y = .y point1</span></pre><p id="b9f2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还可以轻松地更新记录的特定字段。这种方法适用于许多领域:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="ba0b" class="lm jy hu ld b fv ln lo l lp lq">newPoint : Point2D<br/>newPoint = { point1 | y = 3.0 }</span></pre><h1 id="70fe" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">类型类和单子</h1><p id="83f5" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">Haskell和Elm之间更有争议的区别在于这两个概念。Elm没有typeclasses。对于像我这样的Haskell老手来说，这是一个很大的限制。正因为如此，Elm也缺少<code class="eh la lb lc ld b">do</code>语法。记住<code class="eh la lb lc ld b">do</code>语法依赖于<code class="eh la lb lc ld b">Monad</code>类型类存在的想法。</p><p id="bbad" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这些遗漏是有原因的。榆树的创造者写了一篇关于它的有趣的文章。</p><p id="ef01" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">他的主要观点是(不像我)，大多数Elm用户来自Javascript而不是Haskell。他们往往没有多少函数式编程和相关概念的背景知识。所以对于Elm来说，获取这些结构并不是一个优先考虑的事情。那么有什么替代方案呢？</p><p id="b521" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">说到类型类，每种类型都有自己的函数定义。就拿<code class="eh la lb lc ld b">map</code>这个简单的例子来说吧。在Haskell中，我们有<code class="eh la lb lc ld b">fmap</code>函数。它允许我们在不知道容器是什么的情况下对容器应用函数:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="8426" class="lm jy hu ld b fv ln lo l lp lq">fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></pre><p id="1b5c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">无论我们有一个列表还是一个字典，我们都可以应用这个函数。但是在Elm中，每个库都有自己的<code class="eh la lb lc ld b">map</code>函数。所以我们必须限定它的用法:</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="e99b" class="lm jy hu ld b fv ln lo l lp lq">import List<br/>import Dict</span><span id="d7dd" class="lm jy hu ld b fv lr lo l lp lq">double : List Int -&gt; List Int<br/>double l = List.map (* 2) l</span><span id="f490" class="lm jy hu ld b fv lr lo l lp lq">doubleDict : Dict String Int -&gt; Dict String Int<br/>doubleDict d = Dict.map (* 2) d</span></pre><p id="47b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Elm使用了一个名为<code class="eh la lb lc ld b">andThen</code>的函数，而不是单子。这很像Haskell的<code class="eh la lb lc ld b">&gt;&gt;=</code>操作符。我们在Java等面向对象语言中更经常看到这种模式。作为文档中的一个例子，我们可以看到这如何与<code class="eh la lb lc ld b">Maybe</code>一起工作。</p><pre class="le lf lg lh fq li ld lj lk aw ll dt"><span id="a6a2" class="lm jy hu ld b fv ln lo l lp lq">toInt : String -&gt; Maybe Int</span><span id="65b9" class="lm jy hu ld b fv lr lo l lp lq">toValidMonth : Int -&gt; Maybe Int<br/>toValidMonth month =<br/>    if month &gt;= 1 &amp;&amp; month &lt;= 12<br/>        then Just month<br/>        else Nothing</span><span id="699f" class="lm jy hu ld b fv lr lo l lp lq">toMonth : String -&gt; Maybe Int<br/>toMonth rawString =<br/>    toInt rawString `andThen` toValidMonth</span></pre><p id="71c8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以Elm并没有给我们Haskell中那么多的功能。也就是说，Elm首先是一个前端语言。它表达了如何显示我们的数据，以及我们如何将组件组合在一起。如果我们需要复杂的功能元素，我们可以使用Haskell并将其放在后端。</p><h1 id="ade6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="5b8a" class="pw-post-body-paragraph iy iz hu ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hn dt translated">我们暂时就此打住。下周我们将通过编写一个更复杂的程序来扩展我们对Elm的理解。我们将编写一个简单的待办事项列表应用程序，并看看Elm的架构在运行。</p><p id="89e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要想听到更多来自周一早晨哈斯克尔的消息，请确保<a class="ae jw" href="https://www.mmhaskell.com/subscribe" rel="noopener ugc nofollow" target="_blank">为</a>订阅我们的时事通讯！这也将让您访问我们令人敬畏的<a class="ae jw" href="https://www.mmhaskell.com/resources" rel="noopener ugc nofollow" target="_blank">资源</a>页面！</p></div></div>    
</body>
</html>