<html>
<head>
<title>Alternate React Patterns — Part 1: MVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">备选反应模式—第1部分:MVC</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/alternate-react-patterns-part-1-mvc-b1f949d2f189?source=collection_archive---------7-----------------------#2018-10-23">https://medium.com/hackernoon/alternate-react-patterns-part-1-mvc-b1f949d2f189?source=collection_archive---------7-----------------------#2018-10-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="16d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章是关于React.js，一个用于构建用户界面的JavaScript库，以及我们如何接受在React社区中不太流行的设计模式。</p><p id="798c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在构建<a class="ae jp" href="https://builderx.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> BuilderX </strong> </a>时，一个将设计&amp;代码带到一个公共场所的设计工具，我遇到了不同的设计模式，随着旅程的继续，这篇文章是我分享我的学习的一个小小的努力</p><p id="cd63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React或多或少是基于函数式编程概念的，这是React宣称的领导者已经接受的核心概念，如不变性。</p><h1 id="0813" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">但是，我们有空间选择其他模式吗？</h1><p id="543c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">React及其社区慷慨地提供可供选择的模式，这就是它的美妙之处。例如，MobX基于OOPs的概念，因此允许状态的可变性和嵌套。用React探索面向对象的概念！</p><h1 id="5324" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated"><strong class="ak">用React探索面向对象的概念！</strong></h1><p id="fb5e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们在面向对象模式方面有几十年的工作经验，数以千计的应用程序都是使用这种模式构建的。我不打算比较函数性和OOPs概念，因为本文的目标是探索在React中采用这种模式的想法！</p><p id="4657" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在OOPs中，我们有这样的模式</p><ul class=""><li id="88a2" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">MVC模式</li><li id="8369" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">MVVM模式</li><li id="c6f5" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">MVP模式</li><li id="facc" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">命令模式</li></ul><h1 id="f40d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">首先，MVC模式</h1><p id="6106" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">MVC代表模型-视图-控制器，下面是来自维基百科的正式定义:</p><blockquote class="lh li lj"><p id="6e15" class="ir is lk it b iu iv iw ix iy iz ja jb ll jd je jf lm jh ji jj ln jl jm jn jo hn dt translated">模型-视图-控制器是一种架构模式，通常用于开发用户界面，将应用程序分成三个相互连接的部分。这样做是为了将信息的内部表示与信息呈现给用户和用户接受信息的方式分开。[1][2]MVC设计模式将这些主要组件解耦，允许高效的代码重用和并行开发。</p></blockquote><figure class="lp lq lr ls fq lt fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/c0c73cfbcbebb63270ed6a0b3dc5285c.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*xa9A0wBaUIfPF57VIo23nA.png"/></div></figure><h1 id="bbc3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">实验</h1><p id="ce37" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">为了简化这个实验，我将构建一个简单的应用程序，它包含以下内容:</p><figure class="lp lq lr ls fq lt fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/7027ae5180abfd6a3a5e7ca493d6fd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*iupiWKTp5z87PIcf4nwgsQ.png"/></div></figure><p id="2d39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个简单的应用程序</p><ul class=""><li id="5072" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">一个输入框</li><li id="9c6f" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">显示在它旁边键入的任何内容</li></ul><p id="d92a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个特定的实验中，模型可以被命名为<strong class="it hv"> UserInputModel </strong>。视图是在屏幕上看到的HTML呈现，控制器处理用户动作。</p><h2 id="1ee3" class="lx jr hu bd js ly lz ma jw mb mc md ka jc me mf ke jg mg mh ki jk mi mj km mk dt translated">模型</h2><p id="e7d9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><em class="lk"> UserInputModel.js </em></p><figure class="lp lq lr ls fq lt"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="3526" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">视图和控制器</h1><p id="3a25" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在React中，视图和控制器通常位于同一位置。姑且称之为<strong class="it hv">user input view controller</strong>(或者我们甚至可以称之为UserInputComponent)。</p><figure class="lp lq lr ls fq lt"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="7f61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以后它可以像这样使用</p><figure class="lp lq lr ls fq lt"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="53f1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated"><strong class="ak">但是有一个问题</strong></h1><p id="c1f8" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在上面的实验中，如果模型是从控制器之外的来源更新的，这个组件不会更新，这就是为什么MVC设计模式建议视图应该监听来自模型的变化。怎么才能做到呢？让我们看看！</p><p id="fc21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们改进模型，以发出变化:</p><figure class="lp lq lr ls fq lt"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="fe61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，这就是MVC在React中的实现方式！这是对React如何整合一系列设计模式的快速浏览，我希望在我的下一篇博客中涵盖其他模式。</p><p id="1a33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到时候见！</p></div></div>    
</body>
</html>