<html>
<head>
<title>React Higher-Order Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应高阶成分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-higher-order-components-5a8e918106f4?source=collection_archive---------16-----------------------#2018-10-23">https://medium.com/hackernoon/react-higher-order-components-5a8e918106f4?source=collection_archive---------16-----------------------#2018-10-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a7709ada0f9ac70a42095ccae075ee52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVbWGtpaFV8S4Q1aSrsJNg.png"/></div></div></figure><p id="f068" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">本帖是我们</em> <a class="ae kb" href="https://tylermcginnis.com/courses/react-fundamentals/" rel="noopener ugc nofollow" target="_blank"> <em class="ka"> React基础</em> </a> <em class="ka">课程的一部分。如果你喜欢这篇文章，就去看看吧。</em></p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><blockquote class="kj kk kl"><p id="702d" class="jc jd ka je b jf jg jh ji jj jk jl jm km jo jp jq kn js jt ju ko jw jx jy jz hn dt translated">在我们开始之前，有两件重要的事情需要注意。首先，我们要讨论的只是一种模式。与其说它是React，不如说它是组件架构。其次，这不是构建React应用程序所必需的知识。你可以跳过这篇文章，永远不知道我们将要谈论的内容，但仍然可以构建良好的React应用程序。然而，就像建造任何东西一样，你拥有的工具越多，结果就越好。如果你编写React应用程序，你的“工具箱”里没有这个东西会给你自己造成伤害。</p></blockquote><p id="0629" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在你听到<code class="eh kp kq kr ks b">Don't Repeat Yourself</code>或<code class="eh kp kq kr ks b">D.R.Y</code>(近乎狂热)的咒语之前，你无法深入研究软件开发。有时这可能有点过分，但在大多数情况下，这是一个有价值的目标。在这篇文章中，我们将看看在React代码库中实现DRY的最流行的模式，高阶组件。然而，在我们探索解决方案之前，我们必须首先充分了解问题。</p><p id="28c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们负责重新创建一个类似Stripe的仪表板。正如大多数项目一样，直到最后，一切都很顺利。就在您认为即将完成时，您注意到仪表板上有一堆不同的工具提示，当鼠标悬停在某些元素上时，它们需要出现。</p><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kt"><img src="../Images/05df659210b80b4e3fce6d6c6c6e656d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*57Kctm4l_Jj3Dgps.gif"/></div></div></figure><p id="a6f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有几种方法可以解决这个问题。您决定采用的方法是检测各个组件的悬停状态，并根据该状态显示或不显示工具提示。您需要添加三个组件来实现悬停检测功能— <code class="eh kp kq kr ks b">Info</code>、<code class="eh kp kq kr ks b">TrendChart</code>和<code class="eh kp kq kr ks b">DailyChart</code>。</p><p id="6d27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">先说<code class="eh kp kq kr ks b">Info</code>。现在它只是一个简单的SVG图标。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="a8ae" class="lc ld hu ks b fv le lf l lg lh">class Info extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;svg<br/>        className="Icon-svg Icon--hoverable-svg"<br/>        height={this.props.height}<br/>        viewBox="0 0 16 16" width="16"&gt;<br/>          &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>      &lt;/svg&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="d006" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们需要给它添加功能，这样它就可以检测到它是否被悬停。我们可以使用React附带的<code class="eh kp kq kr ks b">onMouseOver</code>和<code class="eh kp kq kr ks b">onMouseOut</code>鼠标事件。当组件悬停时，我们传递给<code class="eh kp kq kr ks b">onMouseOver</code>的函数将被调用，当组件不再悬停时，我们传递给<code class="eh kp kq kr ks b">onMouseOut</code>的函数将被调用。为了以React的方式做到这一点，我们将向组件添加一个<code class="eh kp kq kr ks b">hovering</code>状态属性，这样当<code class="eh kp kq kr ks b">hovering</code>状态改变时，我们可以重新呈现，显示或隐藏我们的工具提示。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="f8e9" class="lc ld hu ks b fv le lf l lg lh">class Info extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id} /&gt;<br/>          : null}<br/>        &lt;svg<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>          className="Icon-svg Icon--hoverable-svg"<br/>          height={this.props.height}<br/>          viewBox="0 0 16 16" width="16"&gt;<br/>            &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>        &lt;/svg&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="526e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看起来不错。现在我们需要向另外两个组件<code class="eh kp kq kr ks b">TrendChart</code>和<code class="eh kp kq kr ks b">DailyChart</code>添加相同的功能。如果没有坏，就不要修。我们对<code class="eh kp kq kr ks b">Info</code>的悬停逻辑工作得很好，所以让我们再次使用相同的代码。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="863f" class="lc ld hu ks b fv le lf l lg lh">class TrendChart extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id}/&gt;<br/>          : null}<br/>        &lt;Chart<br/>          type='trend'<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>        /&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="263e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你大概知道下一步。我们可以对最后的<code class="eh kp kq kr ks b">DailyChart</code>组件做同样的事情。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="76e0" class="lc ld hu ks b fv le lf l lg lh">class DailyChart extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id}/&gt;<br/>          : null}<br/>        &lt;Chart<br/>          type='daily'<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>        /&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="da07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就这样，我们都完了。你可能以前写过这样的React。不是世界末日(#shipit)，但也不是很“干”。如你所见，我们在每个组件中重复完全相同的悬停逻辑。</p><p id="95ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，<strong class="je hv">问题</strong>应该很清楚了，<strong class="je hv">我们希望避免在新组件需要时复制我们的悬停逻辑</strong>。那么有什么<strong class="je hv">解决方案</strong>？在我们开始之前，让我们来谈谈一些编程概念，这些概念将使理解解决方案变得更加容易，<code class="eh kp kq kr ks b">callbacks</code>和<code class="eh kp kq kr ks b">higher-order functions</code>。</p><p id="8429" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在JavaScript中，函数是“第一类对象”。这意味着，就像对象/数组/字符串可以赋给变量，作为参数传递给函数，或者从函数返回一样，其他函数也可以。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="e344" class="lc ld hu ks b fv le lf l lg lh">function add (x, y) {<br/>  return x + y<br/>}</span><span id="b9f8" class="lc ld hu ks b fv li lf l lg lh">function addFive (x, addReference) {<br/>  return addReference(x, 5)<br/>}</span><span id="e239" class="lc ld hu ks b fv li lf l lg lh">addFive(10, add) // 15</span></pre><p id="7de2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不习惯，你的大脑可能会有点奇怪。我们将<code class="eh kp kq kr ks b">add</code>函数作为参数传递给<code class="eh kp kq kr ks b">addFive</code>函数，将其重命名为<code class="eh kp kq kr ks b">addReference</code>，然后我们调用它。</p><p id="a52c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你这样做的时候，你作为参数传递的函数叫做<strong class="je hv">回调</strong>函数，你传递回调函数的函数叫做<strong class="je hv">高阶函数</strong>。</p><p id="6064" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为词汇很重要，所以这里是相同的代码，变量被重新命名以匹配它们所演示的概念。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="84c1" class="lc ld hu ks b fv le lf l lg lh">function add (x,y) {<br/>  return x + y<br/>}</span><span id="ba1c" class="lc ld hu ks b fv li lf l lg lh">function higherOrderFunction (x, callback) {<br/>  return callback(x, 5)<br/>}</span><span id="887d" class="lc ld hu ks b fv li lf l lg lh">higherOrderFunction(10, add)</span></pre><p id="908f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种模式应该看起来很熟悉，到处都是。如果您曾经使用过任何JavaScript数组方法、jQuery或类似lodash的库，那么您已经使用过高阶函数和回调。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="d3a6" class="lc ld hu ks b fv le lf l lg lh">[1,2,3].map((i) =&gt; i + 5)</span><span id="b8ec" class="lc ld hu ks b fv li lf l lg lh">_.filter([1,2,3,4], (n) =&gt; n % 2 === 0 );</span><span id="5389" class="lc ld hu ks b fv li lf l lg lh">$('#btn').on('click', () =&gt;<br/>  console.log('Callbacks are everywhere')<br/>)</span></pre><p id="0db6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们回到我们的例子。如果不仅仅是创建一个<code class="eh kp kq kr ks b">addFive</code>函数，我们还想要一个<code class="eh kp kq kr ks b">addTen</code>函数、<code class="eh kp kq kr ks b">addTwenty</code>函数等等，那会怎么样？使用我们当前的实现，每当我们需要一个新功能时，我们都必须复制大量的逻辑。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="388c" class="lc ld hu ks b fv le lf l lg lh">function add (x, y) {<br/>  return x + y<br/>}</span><span id="7255" class="lc ld hu ks b fv li lf l lg lh">function addFive (x, addReference) {<br/>  return addReference(x, 5)<br/>}</span><span id="40ac" class="lc ld hu ks b fv li lf l lg lh">function addTen (x, addReference) {<br/>  return addReference(x, 10)<br/>}</span><span id="d0a8" class="lc ld hu ks b fv li lf l lg lh">function addTwenty (x, addReference) {<br/>  return addReference(x, 20)<br/>}</span><span id="c22f" class="lc ld hu ks b fv li lf l lg lh">addFive(10, add) // 15<br/>addTen(10, add) // 20<br/>addTwenty(10, add) // 30</span></pre><p id="dc0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再说一次，这并不可怕，但是我们在重复很多相同的逻辑。这里的目标是能够根据我们的需要创建尽可能多的“加法器”函数(<code class="eh kp kq kr ks b">addFive</code>、<code class="eh kp kq kr ks b">addTen</code>、<code class="eh kp kq kr ks b">addTwenty</code>等)，同时尽量减少代码重复。为了实现这一点，如果我们创建一个<code class="eh kp kq kr ks b">makeAdder</code>函数会怎么样？这个函数可以接受一个数字和对最初的<code class="eh kp kq kr ks b">add</code>函数的引用。因为这个函数的目标是创建一个新的加法器函数，所以我们可以让它返回一个全新的函数，接受要相加的数字。说了很多话。让我们看一些代码。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="238b" class="lc ld hu ks b fv le lf l lg lh">function add (x, y) {<br/>  return x + y<br/>}</span><span id="43c9" class="lc ld hu ks b fv li lf l lg lh">function makeAdder (x, addReference) {<br/>  return function (y) {<br/>    return addReference(x, y)<br/>  }<br/>}</span><span id="716e" class="lc ld hu ks b fv li lf l lg lh">const addFive = makeAdder(5, add)<br/>const addTen = makeAdder(10, add)<br/>const addTwenty = makeAdder(20, add)</span><span id="ab3a" class="lc ld hu ks b fv li lf l lg lh">addFive(10) // 15<br/>addTen(10) // 20<br/>addTwenty(10) // 30</span></pre><p id="ca08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">酷毙了。现在，我们可以根据需要创建尽可能多的“加法器”功能，同时尽量减少我们必须编写的重复代码。</p><blockquote class="kj kk kl"><p id="534a" class="jc jd ka je b jf jg jh ji jj jk jl jm km jo jp jq kn js jt ju ko jw jx jy jz hn dt translated">如果你在意的话，这种让一个多参数函数返回一个参数更少的新函数的概念被称为“部分应用”，这是一种函数式编程技术。JavaScript的”。bind”方法就是一个常见的例子。</p></blockquote><p id="c844" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，但是这和React有什么关系，以及我们之前看到的在新组件需要时复制悬停逻辑的问题？正如创建我们的<code class="eh kp kq kr ks b">makeAdder</code>高阶函数允许我们最小化代码重复一样，制作一个类似的“高阶组件”也能以同样的方式帮助我们。然而，不是高阶函数返回调用回调的新函数，而是高阶组件可以返回呈现“回调”组件的新组件🤯。太多了。我们来分解一下。</p><p id="ab1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(我们的)高阶函数</p><ul class=""><li id="05bd" class="lj lk hu je b jf jg jj jk jn ll jr lm jv ln jz lo lp lq lr dt translated">是一个函数</li><li id="bd84" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">接受回调函数作为参数</li><li id="5a30" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">返回一个新函数</li><li id="8aeb" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">它返回的函数可以调用传入的原始回调函数</li></ul><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="67e3" class="lc ld hu ks b fv le lf l lg lh">function higherOrderFunction (callback) {<br/>  return function () {<br/>    return callback()<br/>  }<br/>}</span></pre><p id="fc5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">(我们的)高阶分量</p><ul class=""><li id="bf9a" class="lj lk hu je b jf jg jj jk jn ll jr lm jv ln jz lo lp lq lr dt translated">是一个组件</li><li id="e2c5" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">接受一个组件作为参数</li><li id="07b6" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">返回一个新组件</li><li id="047c" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">它返回的组件可以呈现传入的原始组件</li></ul><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="68c1" class="lc ld hu ks b fv le lf l lg lh">function higherOrderComponent (Component) {<br/>  return class extends React.Component {<br/>    render() {<br/>      return &lt;Component /&gt;<br/>    }<br/>  }<br/>}</span></pre><p id="5f60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们已经对高阶器件的功能有了基本的了解，让我们开始构建自己的器件。如果你还记得，之前的问题是我们在所有需要该功能的组件之间复制了我们所有的悬停逻辑。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="f067" class="lc ld hu ks b fv le lf l lg lh">state = { hovering: false }<br/>mouseOver = () =&gt; this.setState({ hovering: true })<br/>mouseOut = () =&gt; this.setState({ hovering: false })</span></pre><p id="ebeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到这一点，我们希望我们的高阶组件(我们称之为<code class="eh kp kq kr ks b">withHover</code>)能够将悬停逻辑封装在其自身中，然后将<code class="eh kp kq kr ks b">hovering</code>状态传递给它所呈现的组件。这将允许我们避免复制所有的悬停逻辑，而是将它放入一个单独的位置(<code class="eh kp kq kr ks b">withHover</code>)。</p><p id="87b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最终，这是最终目标。每当我们想要一个知道它的<code class="eh kp kq kr ks b">hovering</code>状态的组件时，我们可以将原始组件传递给我们的<code class="eh kp kq kr ks b">withHover</code>高阶组件。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="3149" class="lc ld hu ks b fv le lf l lg lh">const InfoWithHover = withHover(Info)<br/>const TrendChartWithHover = withHover(TrendChart)<br/>const DailyChartWithHover = withHover(DailyChart)</span></pre><p id="d0c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，每当<code class="eh kp kq kr ks b">withHover</code>返回的任何组件被渲染时，他们将渲染原始组件，传递给它一个<code class="eh kp kq kr ks b">hovering</code>道具。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="8627" class="lc ld hu ks b fv le lf l lg lh">function Info ({ hovering, height }) {<br/>  return (<br/>    &lt;&gt;<br/>      {hovering === true<br/>        ? &lt;Tooltip id={this.props.id} /&gt;<br/>        : null}<br/>      &lt;svg<br/>        className="Icon-svg Icon--hoverable-svg"<br/>        height={height}<br/>        viewBox="0 0 16 16" width="16"&gt;<br/>          &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>      &lt;/svg&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="34ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们需要做的最后一件事就是实际实施<code class="eh kp kq kr ks b">withHover</code>。正如我们在上面看到的，它需要做三件事</p><ul class=""><li id="ae81" class="lj lk hu je b jf jg jj jk jn ll jr lm jv ln jz lo lp lq lr dt translated">接受一个“组件”参数。</li><li id="79c6" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">返回新组件</li><li id="26b0" class="lj lk hu je b jf ls jj lt jn lu jr lv jv lw jz lo lp lq lr dt translated">呈现“组件”参数，传递给它一个“悬停”道具。</li></ul><p id="937d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接受一个“组件”参数。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="0471" class="lc ld hu ks b fv le lf l lg lh">function withHover (Component) { }</span></pre><p id="c456" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">返回新组件</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="76b3" class="lc ld hu ks b fv le lf l lg lh">```js<br/>function withHover (Component) {<br/>  return class WithHover extends React.Component {</span><span id="4937" class="lc ld hu ks b fv li lf l lg lh">  }<br/>}</span></pre><h2 id="94bf" class="lc ld hu bd lx ly lz ma mb mc md me mf jn mg mh mi jr mj mk ml jv mm mn mo mp dt translated">呈现“组件”参数，传递给它一个“悬停”道具。</h2><p id="779b" class="pw-post-body-paragraph jc jd hu je b jf mq jh ji jj mr jl jm jn ms jp jq jr mt jt ju jv mu jx jy jz hn dt translated">现在问题变成了，我们如何得到<code class="eh kp kq kr ks b">hovering</code>状态？我们已经有了之前构建的代码。我们只需要将它添加到新组件中，然后在呈现参数<code class="eh kp kq kr ks b">Component</code>时将<code class="eh kp kq kr ks b">hovering</code>状态作为道具传递。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="c7d1" class="lc ld hu ks b fv le lf l lg lh">function withHover(Component) {<br/>  return class WithHover extends React.Component {<br/>    state = { hovering: false }<br/>    mouseOver = () =&gt; this.setState({ hovering: true })<br/>    mouseOut = () =&gt; this.setState({ hovering: false })<br/>    render() {<br/>      return (<br/>        &lt;div <br/>          onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;<br/>            &lt;Component hovering={this.state.hovering} /&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }<br/>  }<br/>}</span></pre><p id="9b1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我喜欢这样想(以及在React文档中是如何提到的)是<strong class="je hv">一个组件将props转换成UI，一个高阶组件将一个组件转换成另一个组件。</strong>在我们的例子中，我们将我们的<code class="eh kp kq kr ks b">Info</code>、<code class="eh kp kq kr ks b">TrendChart</code>和<code class="eh kp kq kr ks b">DailyChart</code>组件转换成新的组件，这些组件通过<code class="eh kp kq kr ks b">hovering</code> prop知道它们的悬停状态。</p><p id="20b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至此，我们已经讨论了高阶元件的所有基础知识。不过，还有几个更重要的项目需要讨论。</p><p id="d3ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你回头看看我们的<code class="eh kp kq kr ks b">withHover</code> HOC，它的一个弱点是它假设消费者可以接受一个名为<code class="eh kp kq kr ks b">hovering</code>的道具。在大多数情况下，这可能是好的，但在某些用例中却不是这样。例如，如果组件已经有了一个名为<code class="eh kp kq kr ks b">hovering</code>的道具该怎么办？我们会有一个命名冲突。我们可以做的一个改变是允许我们的<code class="eh kp kq kr ks b">withHover</code> HOC的消费者指定当悬停状态作为道具传递给他们的组件时，他们希望悬停状态的名称是什么。因为<code class="eh kp kq kr ks b">withHover</code>只是一个函数，让我们把它改为接受第二个参数，它指定了我们将传递给组件的道具的名称。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="0b89" class="lc ld hu ks b fv le lf l lg lh">function withHover(Component, propName = 'hovering') {<br/>  return class WithHover extends React.Component {<br/>    state = { hovering: false }<br/>    mouseOver = () =&gt; this.setState({ hovering: true })<br/>    mouseOut = () =&gt; this.setState({ hovering: false })<br/>    render() {<br/>      const props = {<br/>        [propName]: this.state.hovering<br/>      }</span><span id="1bb5" class="lc ld hu ks b fv li lf l lg lh">      return (<br/>        &lt;div <br/>          onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;<br/>            &lt;Component {...props} /&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }<br/>  }<br/>}</span></pre><p id="7864" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经设置了默认的道具名为<code class="eh kp kq kr ks b">hovering</code>(通过ES6的默认参数)，但是如果<code class="eh kp kq kr ks b">withHover</code>的消费者想要改变它，他们可以通过传入新的道具名作为第二个参数。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="f1f4" class="lc ld hu ks b fv le lf l lg lh">function withHover(Component, propName = 'hovering') {<br/>  return class WithHover extends React.Component {<br/>    state = { hovering: false }<br/>    mouseOver = () =&gt; this.setState({ hovering: true })<br/>    mouseOut = () =&gt; this.setState({ hovering: false })<br/>    render() {<br/>      const props = {<br/>        [propName]: this.state.hovering<br/>      }</span><span id="74da" class="lc ld hu ks b fv li lf l lg lh">      return (<br/>        &lt;div <br/>          onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;<br/>            &lt;Component {...props} /&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }<br/>  }<br/>}</span><span id="5c42" class="lc ld hu ks b fv li lf l lg lh">function Info ({ showTooltip, height }) {<br/>  return (<br/>    &lt;&gt;<br/>      {showTooltip === true<br/>        ? &lt;Tooltip id={this.props.id} /&gt;<br/>        : null}<br/>      &lt;svg<br/>        className="Icon-svg Icon--hoverable-svg"<br/>        height={height}<br/>        viewBox="0 0 16 16" width="16"&gt;<br/>          &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>      &lt;/svg&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="e0f2" class="lc ld hu ks b fv li lf l lg lh">const InfoWithHover = withHover(Info, 'showTooltip')</span></pre><p id="68e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能已经注意到了我们的<code class="eh kp kq kr ks b">withHover</code>实现的另一个问题。查看我们的<code class="eh kp kq kr ks b">Info</code>组件，您会注意到它还应该接受一个<code class="eh kp kq kr ks b">height</code>属性。按照目前我们设置的方式，<code class="eh kp kq kr ks b">height</code>将是未定义的。原因是因为我们的<code class="eh kp kq kr ks b">withHover</code>组件是呈现<code class="eh kp kq kr ks b">Component</code>的组件。目前我们是如何设置的，除了我们创建的<code class="eh kp kq kr ks b">hovering</code>道具之外，我们没有传递任何道具给<code class="eh kp kq kr ks b">&lt;Component /&gt;</code>。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="afac" class="lc ld hu ks b fv le lf l lg lh">const InfoWithHover = withHover(Info)</span><span id="b4ac" class="lc ld hu ks b fv li lf l lg lh">...</span><span id="ff43" class="lc ld hu ks b fv li lf l lg lh">return &lt;InfoWithHover height="16px" /&gt;</span></pre><p id="c7d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kp kq kr ks b">height</code>属性被传递给<code class="eh kp kq kr ks b">InfoWithHover</code>组件。但是那个组件到底是什么呢？这是我们从<code class="eh kp kq kr ks b">withHover</code>返回的组件。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="d436" class="lc ld hu ks b fv le lf l lg lh">function withHover(Component, propName = 'hovering') {<br/>  return class WithHover extends React.Component {<br/>    state = { hovering: false }<br/>    mouseOver = () =&gt; this.setState({ hovering: true })<br/>    mouseOut = () =&gt; this.setState({ hovering: false })<br/>    render() {<br/>      console.log(this.props) // { height: "16px" }</span><span id="663b" class="lc ld hu ks b fv li lf l lg lh">      const props = {<br/>        [propName]: this.state.hovering<br/>      }</span><span id="7c9e" class="lc ld hu ks b fv li lf l lg lh">      return (<br/>        &lt;div <br/>           onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;<br/>              &lt;Component {...props} /&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }<br/>  }<br/>}</span></pre><p id="9478" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh kp kq kr ks b">WithHover</code>组件<code class="eh kp kq kr ks b">this.props.height</code>的内部是<code class="eh kp kq kr ks b">16px</code>，但是从那里我们不做任何事情。我们需要确保将它传递给我们正在呈现的<code class="eh kp kq kr ks b">Component</code>参数。</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="db03" class="lc ld hu ks b fv le lf l lg lh">render() {<br/>      const props = {<br/>        [propName]: this.state.hovering,<br/>        ...this.props,<br/>      }</span><span id="fbb2" class="lc ld hu ks b fv li lf l lg lh">      return (<br/>        &lt;div <br/>          onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;<br/>            &lt;Component {...props} /&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }</span></pre><p id="a687" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">至此，我们已经看到了使用高阶组件在各种组件之间重用组件逻辑而不重复代码的好处。但是，它有什么缺陷吗？是的，我们已经看到了。</p><p id="e1da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用HOC时，会发生<a class="ae kb" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">控制反转</a>。想象一下，我们正在使用像React路由器的<code class="eh kp kq kr ks b">withRouter</code> HOC那样的第三方HOC。根据他们的文档，“无论何时渲染，<code class="eh kp kq kr ks b">withRouter</code>都会将<code class="eh kp kq kr ks b">match</code>、<code class="eh kp kq kr ks b">location</code>和<code class="eh kp kq kr ks b">history</code>道具传递给被包装的组件。”</p><pre class="ku kv kw kx fq ky ks kz la aw lb dt"><span id="c144" class="lc ld hu ks b fv le lf l lg lh">class Game extends React.Component {<br/>  render() {<br/>    const { <br/>      match, <br/>      location, <br/>      history <br/>    } = this.props // From React Router</span><span id="7b5d" class="lc ld hu ks b fv li lf l lg lh">    ...<br/>  }<br/>}</span><span id="ee1b" class="lc ld hu ks b fv li lf l lg lh">export default withRouter(Game)</span></pre><p id="5e16" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意我们不是创建<code class="eh kp kq kr ks b">Game</code>元素的人(即<code class="eh kp kq kr ks b">&lt;Game /&gt;</code>)。我们把我们的组件完全交给了React Router，我们相信他们不仅会渲染它，还会传递给它正确的道具。我们之前在讨论与<code class="eh kp kq kr ks b">hovering</code>的命名冲突时看到了这个问题。为了解决这个问题，我们决定让我们的<code class="eh kp kq kr ks b">withHover</code> HOC的消费者传入第二个参数来配置正确的名称。有了第三方<code class="eh kp kq kr ks b">withRouter</code>特设，我们没有那个选项。如果我们的<code class="eh kp kq kr ks b">Game</code>组件已经在使用<code class="eh kp kq kr ks b">match</code>、<code class="eh kp kq kr ks b">location</code>或<code class="eh kp kq kr ks b">history</code>，我们就不走运了。我们要么必须在组件中修改这些名称，要么必须停止使用<code class="eh kp kq kr ks b">withRouter</code> HOC。</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="fe32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">这篇文章最初发表于tylermcginnis.com</strong><a class="ae kb" href="https://tylermcginnis.com/react-higher-order-components/" rel="noopener ugc nofollow" target="_blank"><strong class="je hv"/></a><strong class="je hv">，是他们</strong> <a class="ae kb" href="https://tylermcginnis.com/courses/react-fundamentals/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">反应基础</strong> </a> <strong class="je hv">课程的一部分。</strong></p><p id="a494" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://twitter.com/tylermcginnis" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">泰勒</strong> </a></p></div></div>    
</body>
</html>