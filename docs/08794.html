<html>
<head>
<title>Visibility and Static keyword in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP中的可见性和静态关键字</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/visibility-and-static-keyword-in-php-f03c751c0c03?source=collection_archive---------20-----------------------#2018-10-23">https://medium.com/hackernoon/visibility-and-static-keyword-in-php-f03c751c0c03?source=collection_archive---------20-----------------------#2018-10-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4b5b52c8780a9c73762f4f67ce188b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_Ez9F5GD2krwglJwIStrQ.jpeg"/></div></div></figure><h1 id="b2be" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">跟随系列…</h1><p id="28ac" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这篇博文是“<a class="ae ky" href="https://amzn.to/2OfCZej" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">面向对象编程完全指南”的第四部分:</strong> </a>从过程化<a class="ae ky" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>到OOP专家<a class="ae ky" href="https://hackernoon.com/tagged/php" rel="noopener ugc nofollow" target="_blank"> PHP </a></p><p id="1446" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果你还没有阅读其他部分</p><p id="de7f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你可以查看下面链接的其他博文<br/> <a class="ae ky" href="http://anastasionico.uk/blog/the-complete-guide-to-object-oriented-programming" rel="noopener ugc nofollow" target="_blank">面向对象编程简介</a>，<br/><a class="ae ky" href="http://anastasionico.uk/blog/inheritance-and-interfaces-in-php" rel="noopener ugc nofollow" target="_blank">PHP中的继承和接口</a>，<br/> <a class="ae ky" href="http://anastasionico.uk/blog/visibility-and-static-keyword-in-php" rel="noopener ugc nofollow" target="_blank">可见性和静态关键字</a>，<br/> <a class="ae ky" href="http://anastasionico.uk/blog/visibility-and-static-keyword-in-php#" rel="noopener ugc nofollow" target="_blank">构造函数和魔法方法<em class="le">尚未发布，订阅获取通知</em> </a>和<br/> <a class="ae ky" href="http://anastasionico.uk/blog/visibility-and-static-keyword-in-php#" rel="noopener ugc nofollow" target="_blank">抽象类和额外的位<em class="le">尚未发布，订阅获取通知</em> </a></p><h1 id="8f80" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">可见性概念介绍</h1><p id="d823" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">理解可见性和范围非常简单，</p><p id="8876" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">但如果背景不够强大，会导致一些混乱。</p><p id="ce26" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我不知道为什么，但是程序员总是喜欢定义一些花哨的词语来描述简单的概念。</p><p id="5871" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你已经看到了一些多态、继承例子，现在你将发现另一个词:</p><p id="bb11" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">封装。这个精心设计的词只意味着以一种代码的其余部分不会影响的方式收集数据。</strong></p><p id="a4b4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在下面的例子中，您将了解范围的概念。</p><p id="ed0f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">给定两个名为<em class="le"> $schoolsCount </em>的同名变量，一个统计我们城市所有的<br/>所学校，另一个只统计主要街道上的学校数量，你会发现结果会有所不同。</p><p id="09ed" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">发生这种情况是因为第二个变量被封装在函数中，因此被分配在不同的范围内。</p><p id="6309" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们可以通过使用超级全局变量<em class="le">GLOBALS[' school count ']</em><br/>来使用全局作用域，但是，这不是一个好的做法，它将很快使代码变得非常混乱。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="7f69" class="lo jd hu lk b fv lp lq l lr ls">$schoolsCount<!-- --> <!-- -->= 7;</span><span id="2ac1" class="lo jd hu lk b fv lt lq l lr ls">function<!-- --> <!-- -->getSchoolsCountInMainStreet () {</span><span id="9ef0" class="lo jd hu lk b fv lt lq l lr ls">    $schoolsCount<!-- --> <!-- -->= 4;</span><span id="6f96" class="lo jd hu lk b fv lt lq l lr ls">    return<!-- --> <!-- -->var_dump($schoolsCount);</span><span id="872e" class="lo jd hu lk b fv lt lq l lr ls">}</span><span id="347f" class="lo jd hu lk b fv lt lq l lr ls">var_dump($schoolsCount); // This will output the total amount</span></pre><p id="207a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在PHP的面向对象编程中，你有三个不同的可见性级别。</p><p id="bc95" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">它们是:</p><ul class=""><li id="28cb" class="lu lv hu kc b kd kz kh la kl lw kp lx kt ly kx lz ma mb mc dt translated">公共</li><li id="db8e" class="lu lv hu kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc dt translated">保护</li><li id="5a05" class="lu lv hu kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc dt translated">私人的</li></ul><h1 id="caf4" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">公共</h1><p id="42ac" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">公共是第一个也是最不受限制的级别，</p><p id="ca5a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这个级别的属性和方法可以从代码中的任何地方访问、查看和更新，在一个类中，在一个子类中，甚至在类之外。</p><p id="3868" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">可见性是在PHP4之后出现的，为了回溯兼容性<br/>声明它不是强制的，实际上如果你没有在一个元素上声明可见性<br/>，代码会认为它是公共的。</p><p id="cac1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">所以，</p><p id="064d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">考虑到目前为止你在本文中看到的所有例子都是公开声明的。</p><p id="2933" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">有消息称，这种情况不会持续太久，部署在PHP4上并且仍然在线的web应用非常少。</p><p id="ccfe" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这意味着您需要养成声明可见性的习惯，即使出于未来兼容性的原因，方法和属性是公共的</p><h1 id="04ad" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">保护</h1><p id="a56f" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">受保护是第二个层次。</p><p id="c025" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这很容易理解，所以我不会在这上面花太多时间。</p><p id="8215" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">当声明一个受保护的属性时，你是在说这个变量在类内部的任何地方都是可用的，并且在任何扩展它的类中都是可用的。</strong></p><p id="033c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="http://anastasionico.uk/blog/inheritance-and-interfaces-in-php" rel="noopener ugc nofollow" target="_blank">(关于这个主题的更多信息请参见继承和接口)</a></p><h1 id="518c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">私人的</h1><p id="7253" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">第三个层次更加有限，</p><p id="6855" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">私有属性和方法只能从声明它们的类中访问。</strong></p><p id="a2d0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">没有子类，其他地方也没有。</p><p id="b315" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这种类型的可见性用于非常敏感的信息，例如当您使用密码或处理支付数据时。</p><p id="8a07" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">PHP语法命令我们在编写元素之前定义可见性。</p><p id="784d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们重写一个先前的例子:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="7f49" class="lo jd hu lk b fv lp lq l lr ls">class<!-- --> <!-- -->Building</span><span id="1b31" class="lo jd hu lk b fv lt lq l lr ls">{</span><span id="ac74" class="lo jd hu lk b fv lt lq l lr ls">    public<!-- --> <!-- -->$inCostruction<!-- --> <!-- -->= false;</span><span id="7ffc" class="lo jd hu lk b fv lt lq l lr ls">    protected<!-- --> <!-- -->$isOpen<!-- --> <!-- -->= true;</span><span id="9763" class="lo jd hu lk b fv lt lq l lr ls">    private<!-- --> <!-- -->$safePassword<!-- --> <!-- -->= “qwerty”</span><span id="3472" class="lo jd hu lk b fv lt lq l lr ls">    public<!-- --> <!-- -->function<!-- --> <!-- -->closeBuilding()</span><span id="0904" class="lo jd hu lk b fv lt lq l lr ls">    {</span><span id="5375" class="lo jd hu lk b fv lt lq l lr ls">        return<!-- --> <!-- -->$this-&gt;isOpen = false;</span><span id="4b1d" class="lo jd hu lk b fv lt lq l lr ls">    }</span><span id="802f" class="lo jd hu lk b fv lt lq l lr ls">    protected<!-- --> <!-- -->function<!-- --> <!-- -->openBuilding()</span><span id="1aa5" class="lo jd hu lk b fv lt lq l lr ls">    {</span><span id="35b4" class="lo jd hu lk b fv lt lq l lr ls">        return<!-- --> <!-- -->$this-&gt;isOpen = true;</span><span id="e61d" class="lo jd hu lk b fv lt lq l lr ls">    }</span><span id="f75f" class="lo jd hu lk b fv lt lq l lr ls">}</span><span id="4a82" class="lo jd hu lk b fv lt lq l lr ls">class<!-- --> <!-- -->School extends<!-- --> <!-- -->Building</span><span id="7a23" class="lo jd hu lk b fv lt lq l lr ls">{</span><span id="2dd9" class="lo jd hu lk b fv lt lq l lr ls">}</span><span id="f355" class="lo jd hu lk b fv lt lq l lr ls">class<!-- --> <!-- -->Office extends<!-- --> <!-- -->Building</span><span id="181f" class="lo jd hu lk b fv lt lq l lr ls">{</span><span id="9fae" class="lo jd hu lk b fv lt lq l lr ls">$isOpen<!-- --> <!-- -->= false;</span><span id="d3bd" class="lo jd hu lk b fv lt lq l lr ls">}</span></pre><p id="93ee" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">目前<em class="le">$ in construction</em>变量在程序中的任何地方都是可访问的，</p><p id="4605" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><em class="le"> $isOpen </em>在子类中的<em class="le"> Building </em>类中可见，而<em class="le"> $safePassword </em>仅在<em class="le"> Building </em>类中可见。</p><p id="69c0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">学校和办公室都不能访问和更新safePassword变量。</p><p id="644b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这是PHP的一个非常基本的特性，但是必须清楚地理解。</p><p id="113d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">当一个变量的作用域出错时，由于可见性的原因，大多数错误都是致命的</p><p id="1ee4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果没有显示错误，要找到问题是非常困难的。</p><h1 id="6a88" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">静态</h1><p id="3a4f" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这里是一个新的PHP关键字供你学习。</p><p id="d240" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">它们永远不够，</p><p id="3e7e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">不是吗？</p><p id="fc77" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">static关键字用于改变属性和<br/>方法的可访问性。</p><p id="8c99" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">通过将一个类的元素(属性或方法)声明为静态的，你是在对代码说，该元素将对所有程序可用，而不需要实例化该类。</p><p id="b987" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">由于没有实例化的类，关键字<em class="le"> $this </em>在这些方法中不可用。</p><p id="2e55" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">取而代之的是<strong class="kc hv"> self:: </strong>关键字。</p><p id="6ec3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">迷茫？</p><p id="6a31" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们把事情弄清楚一点。</p><h2 id="b4e6" class="lo jd hu bd je mi mj mk ji ml mm mn jm kl mo mp jq kp mq mr ju kt ms mt jy mu dt translated">为什么首先要使用静态？</h2><p id="a5f0" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在前面的例子中，当我们创建我们的城市时，我们使用同一类建筑作为蓝图，从那里我们提取我们需要的数据，并且我们已经创建了实际的对象，办公室、学校等等。</p><p id="ee24" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">为此，我们需要创建<em class="le"> Building </em>类的副本，我们执行的所有操作将只改变实例化的对象，而不会改变类本身。</p><p id="5060" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这意味着在我们想象的城市中，我们可以有几十个、几百个甚至几千个办公室，我们可以编辑其中的每一个，而不会影响到其他的。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1b8e" class="lo jd hu lk b fv lp lq l lr ls">$officeInMainStreet<!-- --> <!-- -->= new<!-- --> <!-- -->Office()</span><span id="15eb" class="lo jd hu lk b fv lt lq l lr ls">$officeInPiccadillyBoulevard= new<!-- --> <!-- -->Office()</span></pre><p id="99f0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这两个对象是同一类的两个不同实例，</p><p id="bf75" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">他们使用相同的蓝图建造，但他们不是同一个办公室</p><p id="7ee0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你可以在其中一个物体上增加一个窗口或者重新粉刷墙壁，这不会有任何问题，因为另一个物体永远不会知道。</p><p id="5f8f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">嗯，当使用静态的东西是不同的。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0e10" class="lo jd hu lk b fv lp lq l lr ls">class<!-- --> <!-- -->Building</span><span id="9c36" class="lo jd hu lk b fv lt lq l lr ls">{</span><span id="5205" class="lo jd hu lk b fv lt lq l lr ls">    public<!-- --> <!-- -->static<!-- --> <!-- -->$planningPermission<!-- --> <!-- -->= ‘accepted’;</span><span id="52f7" class="lo jd hu lk b fv lt lq l lr ls">}</span><span id="de40" class="lo jd hu lk b fv lt lq l lr ls">echo<!-- --> <!-- -->Building::$planningPermission; // this command will echo “accepted”</span></pre><p id="22b8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在上面的例子中，我们不再试图访问对象，而是直接访问属性，</p><p id="0097" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">所以，</p><p id="782a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">您看到的是实际类的实际静态参数。</p><p id="48df" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果你要创建一个方法来结束对参数的编辑，那么它将会是类的参数，而不是某个实例之后创建的参数。</p><p id="1a5f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">静态方法的相同价值:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="8f88" class="lo jd hu lk b fv lp lq l lr ls">class<!-- --> <!-- -->Building</span><span id="5a34" class="lo jd hu lk b fv lt lq l lr ls">{</span><span id="c6d9" class="lo jd hu lk b fv lt lq l lr ls">    public<!-- --> <!-- -->static<!-- --> <!-- -->$planningPermission<!-- --> <!-- -->= ‘accepted’;</span><span id="97b7" class="lo jd hu lk b fv lt lq l lr ls">    public<!-- --> <!-- -->static<!-- --> <!-- -->function<!-- --> <!-- -->setDeniedPermission()</span><span id="9a25" class="lo jd hu lk b fv lt lq l lr ls">    {</span><span id="402b" class="lo jd hu lk b fv lt lq l lr ls">        self::$planningPermission<!-- --> <!-- -->= ‘denied’;</span><span id="e997" class="lo jd hu lk b fv lt lq l lr ls">        return<!-- --> <!-- -->self::$planningPermission;</span><span id="ab45" class="lo jd hu lk b fv lt lq l lr ls">    }</span><span id="8081" class="lo jd hu lk b fv lt lq l lr ls">}</span><span id="8d8f" class="lo jd hu lk b fv lt lq l lr ls">echo<!-- --> <!-- -->Building::setDeniedPermission(); // this command will echo “denied”</span></pre><p id="494e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这种想法使得static关键字非常强大，但同时也不被许多开发人员看好，他们认为使用static关键字和全局范围通常是一种不好的做法。</p><h1 id="9ac2" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">第四部分结论</h1><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mv"><img src="../Images/897543be0fa5e5c45e7d93a5a384a12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fTTTm4txGVES6CY_.jpg"/></div></div></figure><p id="e31c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="https://www.amazon.co.uk/dp/B07J47L6PB" rel="noopener ugc nofollow" target="_blank"> <em class="le">一体化版的《面向对象编程完全指南》的完整版在亚马逊上以Kindle格式出售</em> </a> <em class="le">反正下面的部分很快就会出版。</em></p><p id="a698" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">这是一篇简短的文章，向你展示了PHP中可见性和静态关键字使用的简单概念。</strong></p><p id="ec8a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">尽管这些要素只需要基本的知识水平并且可以直接应用，</p><p id="8e7f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">没有人能否认使用它们的重要性，</p><p id="91c4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">尤其是，如果运用得当。</p><p id="93d0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在许多方面，</p><p id="e1fc" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">选择受保护的或私有的可见性级别有助于web开发人员定义什么是可共享的，什么留在友好的墙内更好。</p><p id="9f7f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">与此同时，</p><p id="75a3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">您已经知道现在可以声明类，而不需要实例化它们。</p><p id="8445" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">static关键字是该语言的另一个强大但危险的特性。</p><p id="6b2c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">学习一些新的关键字并开始在你的脚本中到处使用它们是一个基本的错误。</p><p id="0411" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">但是要小心，</p><p id="b637" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">误用它，尤其是在开始的时候，会导致已经完成的特性的完全重写(这发生在我身上，从我的错误中学习)。</p><p id="ac79" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">下一集，</strong></p><p id="6959" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">我们将关注魔法方法</strong></p><p id="a119" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我准备了一个完整的列表，里面有详细的描述和代码示例。</p><p id="09d5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">由于这个原因，</p><p id="9a02" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">请继续关注并使用下面的表格订阅，以便在它出版时得到通知。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><a href="http://eepurl.com/dIZqjf"><div class="fe ff mw"><img src="../Images/81f240e8dd073aab6ad31da0e0d28d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FKpkkhRhWP0iLk7FpzTbQ.jpeg"/></div></a></figure></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="f6c2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">现在轮到你了:</strong></p><p id="fa21" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><em class="le">你打算用受保护的和私有的关键字来更新你的方法和属性吗？还是你更喜欢到处传播静态关键字？<br/>在下面的评论框里告诉我吧！</em></p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>