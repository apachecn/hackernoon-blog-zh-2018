<html>
<head>
<title>React Render Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应渲染道具</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-render-props-4809fe8ca966?source=collection_archive---------3-----------------------#2018-10-24">https://medium.com/hackernoon/react-render-props-4809fe8ca966?source=collection_archive---------3-----------------------#2018-10-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="e93d" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">这篇文章是我们<a class="ae jt" href="https://tylermcginnis.com/courses/react-fundamentals/" rel="noopener ugc nofollow" target="_blank">反应基础</a>课程的一部分。如果你喜欢这篇文章，就去看看吧。</p></blockquote><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="fe ff ju"><img src="../Images/87e3001522ee0192621494e139a2cb2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Iwq9JBi36HRABr7F6C3-w.png"/></div></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><blockquote class="ir is it"><p id="12e9" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">如果你想读一篇类似的文章，但却是关于高阶元件的，请查阅</em> <a class="ae jt" href="https://tylermcginnis.com/react-higher-order-components" rel="noopener ugc nofollow" target="_blank"> <em class="hu">反应高阶元件</em> </a></p></blockquote></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><blockquote class="ir is it"><p id="c7f1" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">在我们开始之前，有两件重要的事情需要注意。首先，我们要讨论的只是一种模式。与其说它是React，不如说它是组件架构。其次，这不是构建React应用程序所必需的知识。你可以跳过这篇文章，永远不知道我们将要谈论的内容，但仍然可以构建良好的React应用程序。然而，就像建造任何东西一样，你拥有的工具越多，结果就越好。如果你编写React应用程序，你的“工具箱”里没有这个东西会给你自己造成伤害。在你听到<code class="eh kn ko kp kq b">Don't Repeat Yourself</code>或<code class="eh kn ko kp kq b">D.R.Y</code>(近乎狂热的)咒语之前，你无法深入研究软件开发。有时这可能有点过分，但在大多数情况下，这是一个有价值的目标。在这篇文章中，我们将看看在React代码库中实现DRY的最流行的模式，高阶组件。然而，在我们探索解决方案之前，我们必须首先充分了解问题。</p></blockquote><p id="3df7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">假设我们负责重新创建一个类似Stripe的仪表板。正如大多数项目一样，直到最后，一切都很顺利。就在您认为即将完成时，您注意到仪表板上有一堆不同的工具提示，当鼠标悬停在某些元素上时，它们需要出现。</p><p id="dcc6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">有几种方法可以解决这个问题。您决定采用的方法是检测各个组件的悬停状态，并根据该状态显示或不显示工具提示。您需要添加三个组件来实现悬停检测功能— <code class="eh kn ko kp kq b">Info</code>、<code class="eh kn ko kp kq b">TrendChart</code>和<code class="eh kn ko kp kq b">DailyChart</code>。</p><p id="493a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">先说<code class="eh kn ko kp kq b">Info</code>。现在它只是一个简单的SVG图标。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="1a1c" class="ky kz hu kq b fv la lb l lc ld">class Info extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;svg<br/>        className="Icon-svg Icon--hoverable-svg"<br/>        height={this.props.height}<br/>        viewBox="0 0 16 16" width="16"&gt;<br/>          &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>      &lt;/svg&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="966b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">现在我们需要给它添加功能，这样它就可以检测到它是否被悬停。我们可以使用React附带的<code class="eh kn ko kp kq b">onMouseOver</code>和<code class="eh kn ko kp kq b">onMouseOut</code>鼠标事件。我们传递给<code class="eh kn ko kp kq b">onMouseOver</code>的函数将在组件悬停时被调用，传递给<code class="eh kn ko kp kq b">onMouseOut</code>的函数将在组件不再悬停时被调用。为了用React的方式做到这一点，我们将向组件添加一个<code class="eh kn ko kp kq b">hovering</code>状态属性，这样当<code class="eh kn ko kp kq b">hovering</code>状态改变时，我们可以重新呈现，显示或隐藏我们的工具提示。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="d2c4" class="ky kz hu kq b fv la lb l lc ld">class Info extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id} /&gt;<br/>          : null}<br/>        &lt;svg<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>          className="Icon-svg Icon--hoverable-svg"<br/>          height={this.props.height}<br/>          viewBox="0 0 16 16" width="16"&gt;<br/>            &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>        &lt;/svg&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="8ece" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">看起来不错。现在我们需要向另外两个组件<code class="eh kn ko kp kq b">TrendChart</code>和<code class="eh kn ko kp kq b">DailyChart</code>添加相同的功能。如果没有坏，就不要修。我们的<code class="eh kn ko kp kq b">Info</code>悬停逻辑工作得很好，所以让我们再次使用相同的代码。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="d95c" class="ky kz hu kq b fv la lb l lc ld">class TrendChart extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id}/&gt;<br/>          : null}<br/>        &lt;Chart<br/>          type='trend'<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>        /&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="5ce2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">你大概知道下一步。我们可以对最后的<code class="eh kn ko kp kq b">DailyChart</code>组件做同样的事情。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="5f88" class="ky kz hu kq b fv la lb l lc ld">class DailyChart extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id}/&gt;<br/>          : null}<br/>        &lt;Chart<br/>          type='daily'<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>        /&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="4b48" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">就这样，我们都完了。你可能以前写过这样的React。不是世界末日(#shipit)，但也不是很“干”。如你所见，我们在每个组件中重复完全相同的悬停逻辑。</p><p id="acec" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">此时，<strong class="ix hv">问题</strong>应该很清楚了，<strong class="ix hv">我们希望避免在新组件需要时复制我们的悬停逻辑</strong>。那么什么是<strong class="ix hv">解决方案</strong>？在此之前，我们需要了解一下React的两个基本方面。它们是不呈现UI和传递函数的组件。</p><p id="81b4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">没有UI组件</p><p id="b45b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">在大多数情况下，无论何时构建React组件，最终目标都是在屏幕上显示一些UI。</p><p id="bd73" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">然而，情况并不总是如此。让组件充当“包装”组件是完全合理的。他们负责处理一些逻辑，但不是呈现他们自己的UI，而是呈现另一个传递数据的组件。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="0f7a" class="ky kz hu kq b fv la lb l lc ld">class Users extends React.Component {<br/>  state = {<br/>    users: null<br/>  }<br/>  componentDidMount() {<br/>    getUsers()<br/>      .then((users) =&gt; {<br/>        this.setState({ users })<br/>      })<br/>  }<br/>  render() {<br/>    &lt;Grid data={this.state.users} /&gt;<br/>  }<br/>}</span></pre><p id="efcb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">在上面的例子中，<code class="eh kn ko kp kq b">Users</code>负责获取用户，然后将他们传递给<code class="eh kn ko kp kq b">Grid</code>组件。它没有自己的UI，而是使用来自<code class="eh kn ko kp kq b">Grid</code>组件的UI。</p><p id="fcc0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">传递函数作为道具</p><p id="d28f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">众所周知，props是React的组件API的一部分，它允许您将数据传递到组件中。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="6a5b" class="ky kz hu kq b fv la lb l lc ld">&lt;User id='tylermcginnis' /&gt;</span></pre><p id="935b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">然后在<code class="eh kn ko kp kq b">User</code>组件内部，<code class="eh kn ko kp kq b">props</code>对象会有一个引用字符串<code class="eh kn ko kp kq b">tylermcginnis</code>的<code class="eh kn ko kp kq b">id</code>属性。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="9165" class="ky kz hu kq b fv la lb l lc ld">function User (props) {<br/>  const id = props.id // tylermcginnis<br/>}</span></pre><p id="4df0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">如果我们传递一个函数，而不是一个字符串作为道具呢？</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="ebca" class="ky kz hu kq b fv la lb l lc ld">&lt;User id={() =&gt; 'tylermcginnis'} /&gt;</span></pre><p id="3edd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">现在，<code class="eh kn ko kp kq b">props</code>对象仍然有一个<code class="eh kn ko kp kq b">id</code>属性，只是现在它不是一个字符串，而是引用了一个函数。所以为了获得id，我们需要调用函数。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="cdbc" class="ky kz hu kq b fv la lb l lc ld">function User (props) {<br/>  const id = props.id() // tylermcginnis<br/>}</span></pre><p id="4d60" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">如果我们想给函数prop传递一些数据呢？这只是一个函数，所以我们可以像平常一样，给它传递一个参数。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="f8e3" class="ky kz hu kq b fv la lb l lc ld">function User (props) {<br/>  const id = props.id(true) // tylermcginnis<br/>}</span><span id="2224" class="ky kz hu kq b fv le lb l lc ld">&lt;User id={(isAuthed) =&gt; isAuthed === true ? 'tylermcginnis' : null} /&gt;</span></pre><p id="03ef" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">好的……但是这两者和我们之前看到的问题有什么关系呢？每当一个新的组件需要时，我们就复制我们的悬停逻辑。我们可以结合这两个简单的概念来解决我们的问题。</p><p id="0716" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">首先，我们想创建一个负责管理悬停状态的“包装”组件。我们自然会称它为<code class="eh kn ko kp kq b">Hover</code>，它将包含我们之前复制的所有悬停逻辑。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="6064" class="ky kz hu kq b fv la lb l lc ld">class Hover extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;div onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;</span><span id="3b53" class="ky kz hu kq b fv le lb l lc ld">      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="1aa3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">接下来的问题就变成了<code class="eh kn ko kp kq b">Hover</code>应该渲染什么？这就是功能特性知识发挥作用地方。让<code class="eh kn ko kp kq b">Hover</code>得到一个叫做<code class="eh kn ko kp kq b">render</code>的道具。这个<code class="eh kn ko kp kq b">render</code>道具将是一个函数，我们可以将<code class="eh kn ko kp kq b">hovering</code>状态传递给它，它将返回一些UI。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="7b66" class="ky kz hu kq b fv la lb l lc ld">&lt;Hover render={(hovering) =&gt;<br/>  &lt;div&gt;<br/>    Is hovering? {hovering === true ? 'Yes' : 'No'}<br/>  &lt;div&gt;<br/>} /&gt;</span></pre><p id="b5bd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">现在我们需要做的最后一个改变是在我们的<code class="eh kn ko kp kq b">Hover</code>组件中。我们需要做的就是调用<code class="eh kn ko kp kq b">this.props.render</code>并传递它<code class="eh kn ko kp kq b">this.state.hover</code>。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="a31e" class="ky kz hu kq b fv la lb l lc ld">class Hover extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;div onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;<br/>        {this.props.render(this.state.hovering)}<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="379c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">你能看看那个吗？现在我们有了我们的<code class="eh kn ko kp kq b">Hover</code>组件，任何时候我们需要一个组件知道它的悬停状态，我们只需将它包装在一个<code class="eh kn ko kp kq b">Hover</code> s <code class="eh kn ko kp kq b">render</code> prop中。</p><p id="f922" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">最后，让我们回到原来的代码，看看我们如何不再需要复制所有的悬停逻辑，因为我们有了<code class="eh kn ko kp kq b">Hover</code>组件。</p><p id="0ba0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">这是我们以前有的。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="e5f8" class="ky kz hu kq b fv la lb l lc ld">class Info extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id} /&gt;<br/>          : null}<br/>        &lt;svg<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>          className="Icon-svg Icon--hoverable-svg"<br/>          height={this.props.height}<br/>          viewBox="0 0 16 16" width="16"&gt;<br/>            &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>        &lt;/svg&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span><span id="3979" class="ky kz hu kq b fv le lb l lc ld">class TrendChart extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id}/&gt;<br/>          : null}<br/>        &lt;Chart<br/>          type='trend'<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>        /&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span><span id="f1fa" class="ky kz hu kq b fv le lb l lc ld">class DailyChart extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        {this.state.hovering === true<br/>          ? &lt;Tooltip id={this.props.id}/&gt;<br/>          : null}<br/>        &lt;Chart<br/>          type='daily'<br/>          onMouseOver={this.mouseOver}<br/>          onMouseOut={this.mouseOut}<br/>        /&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span><span id="ab44" class="ky kz hu kq b fv le lb l lc ld">function App () {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Info /&gt;<br/>      &lt;TrendChart /&gt;<br/>      &lt;DailyChart /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="78c6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">现在有了我们的<code class="eh kn ko kp kq b">Hover</code>组件，而不是每个组件都必须复制悬停逻辑，我们可以将每个组件包装在我们传递给<code class="eh kn ko kp kq b">Hover</code>的<code class="eh kn ko kp kq b">render</code>道具中，然后将<code class="eh kn ko kp kq b">hovering</code>参数作为道具传递下去。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="351b" class="ky kz hu kq b fv la lb l lc ld">function Info (props) {<br/>  return (<br/>    &lt;&gt;<br/>      {props.hovering === true<br/>        ? &lt;Tooltip id={this.props.id} /&gt;<br/>        : null}<br/>      &lt;svg<br/>        onMouseOver={this.mouseOver}<br/>        onMouseOut={this.mouseOut}<br/>        className="Icon-svg Icon--hoverable-svg"<br/>        height={this.props.height}<br/>        viewBox="0 0 16 16" width="16"&gt;<br/>          &lt;path d="M9 8a1 1 0 0 0-1-1H5.5a1 1 0 1 0 0 2H7v4a1 1 0 0 0 2 0zM4 0h8a4 4 0 0 1 4 4v8a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4zm4 5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" /&gt;<br/>      &lt;/svg&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="ad92" class="ky kz hu kq b fv le lb l lc ld">function TrendChart (props) {<br/>  return (<br/>    &lt;&gt;<br/>      {props.hovering === true<br/>        ? &lt;Tooltip id={this.props.id}/&gt;<br/>        : null}<br/>      &lt;Chart<br/>        type='trend'<br/>        onMouseOver={this.mouseOver}<br/>        onMouseOut={this.mouseOut}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="c14b" class="ky kz hu kq b fv le lb l lc ld">function DailyChart (props) {<br/>  return (<br/>    &lt;&gt;<br/>      {props.hovering === true<br/>        ? &lt;Tooltip id={this.props.id}/&gt;<br/>        : null}<br/>      &lt;Chart<br/>        type='daily'<br/>        onMouseOver={this.mouseOver}<br/>        onMouseOut={this.mouseOut}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="bc7f" class="ky kz hu kq b fv le lb l lc ld">function App () {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Hover render={(hovering) =&gt;<br/>        &lt;Info hovering={hovering}&gt;<br/>      }&gt;</span><span id="ca61" class="ky kz hu kq b fv le lb l lc ld">      &lt;Hover render={(hovering) =&gt;<br/>        &lt;TrendChart hovering={hovering}&gt;<br/>      }&gt;</span><span id="331f" class="ky kz hu kq b fv le lb l lc ld">      &lt;Hover render={(hovering) =&gt;<br/>        &lt;DailyChart hovering={hovering}&gt;<br/>      }&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="fdab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">你现在可能已经猜到了，这种模式叫做<code class="eh kn ko kp kq b">Render Props</code>。在React文档中总结道，“术语渲染属性指的是一种使用属性在React组件之间共享代码的技术，该属性的值是一个函数”。</p><p id="e045" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">利用渲染道具模式的另一种方法是使用React的<code class="eh kn ko kp kq b">children</code>道具。如果你以前从未使用过<code class="eh kn ko kp kq b">props.children</code>,它就像任何其他的道具一样，接受而不是你显式地把它传递给组件，React自动为你做，它引用组件主体中的任何东西。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="5f89" class="ky kz hu kq b fv la lb l lc ld">function User (props) {<br/>  return (<br/>    &lt;div&gt;<br/>      {props.children}<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="494b" class="ky kz hu kq b fv le lb l lc ld">&lt;User&gt;<br/>  This is props.children<br/>&lt;/User&gt;</span></pre><p id="76cc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">在上面的例子中，要呈现给用户界面的是一个包含单词<code class="eh kn ko kp kq b">This is props.children</code>的<code class="eh kn ko kp kq b">div</code>。</p><p id="6214" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">如果<code class="eh kn ko kp kq b">props.children</code>不是一个字符串，而是一个函数，会怎么样？正如我们前面看到的，我们需要调用它来获取值。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="84d1" class="ky kz hu kq b fv la lb l lc ld">function User (props) {<br/>  return (<br/>    &lt;div&gt;<br/>      {props.children()}<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="5371" class="ky kz hu kq b fv le lb l lc ld">&lt;User&gt;<br/>  {() =&gt; This is props.children}<br/>&lt;/User&gt;</span></pre><p id="7590" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">利用我们新形成的<code class="eh kn ko kp kq b">props.children</code>知识，让我们更新之前的例子。现在不要用<code class="eh kn ko kp kq b">Hover</code>来代替<code class="eh kn ko kp kq b">render</code>道具，让我们一起去掉它，用<code class="eh kn ko kp kq b">props.children</code>来代替。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="f96a" class="ky kz hu kq b fv la lb l lc ld">function App () {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Hover&gt;<br/>        {(hovering) =&gt; &lt;Info hovering={hovering}&gt;}<br/>      &lt;/Hover&gt;</span><span id="146a" class="ky kz hu kq b fv le lb l lc ld">      &lt;Hover&gt;<br/>        {(hovering) =&gt; &lt;TrendChart hovering={hovering}&gt;}<br/>      &lt;/Hover&gt;</span><span id="2bf0" class="ky kz hu kq b fv le lb l lc ld">      &lt;Hover&gt;<br/>        {(hovering) =&gt; &lt;DailyChart hovering={hovering}&gt;}<br/>      &lt;/Hover&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="2cac" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">看起来不错。现在我们需要更新<code class="eh kn ko kp kq b">Hover</code>，所以它不调用<code class="eh kn ko kp kq b">this.props.render</code>，而是调用<code class="eh kn ko kp kq b">this.props.children</code>。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="0287" class="ky kz hu kq b fv la lb l lc ld">class Hover extends React.Component {<br/>  state = { hovering: false }<br/>  mouseOver = () =&gt; this.setState({ hovering: true })<br/>  mouseOut = () =&gt; this.setState({ hovering: false })<br/>  render() {<br/>    return (<br/>      &lt;div onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}&gt;<br/>        {this.props.children(this.state.hovering)}<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="c483" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">很好。这样更好吗？不完全是，只是不一样。我更喜欢它，但客观上没有比它更好的了。</p><p id="e911" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">如果你读了我们关于<a class="ae jt" href="https://tylermcginnis.com/react-higher-order-components" rel="noopener ugc nofollow" target="_blank">高阶元件</a>的帖子，你就会熟悉hoc是如何有一些陷阱的。最大的问题是控制反转和命名冲突。因为您必须将组件传递给更高级的组件，所以您无法控制它的呈现方式。我们看了一个React路由器的<code class="eh kn ko kp kq b">withRouter</code> HOC的例子。无论何时渲染，<code class="eh kn ko kp kq b">withRouter</code>都会将<code class="eh kn ko kp kq b">match</code>、<code class="eh kn ko kp kq b">location</code>和<code class="eh kn ko kp kq b">history</code>道具传递给被包装的组件。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="42a4" class="ky kz hu kq b fv la lb l lc ld">class Game extends React.Component {<br/>  render() {<br/>    const { match, location, history } = this.props // From React Router</span><span id="b817" class="ky kz hu kq b fv le lb l lc ld">    ...<br/>  }<br/>}</span><span id="faf4" class="ky kz hu kq b fv le lb l lc ld">export default withRouter(Game)</span></pre><p id="aa73" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">如果我们的游戏组件已经收到了<code class="eh kn ko kp kq b">match</code>、<code class="eh kn ko kp kq b">location</code>或<code class="eh kn ko kp kq b">history</code>作为道具，我们将会有一个命名冲突，这将是一个很难追踪的bug。</p><p id="ba79" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">渲染道具也有同样的问题吗？没有。我们不是交出组件，而是交出一个功能。然后，当这个函数被调用时，我们需要的数据就会传递给它。没有控制反转和命名冲突，因为我们可以决定如何渲染组件。</p><pre class="jv jw jx jy fq ku kq kv kw aw kx dt"><span id="5570" class="ky kz hu kq b fv la lb l lc ld">&lt;Hover&gt;<br/>  {(hovering) =&gt; {<br/>    // We can do whatever we want here.<br/>    // We decide how and when to render the component<br/>    return &lt;Info anyNameWeWant={hovering} /&gt;<br/>  }}<br/>&lt;/Hover&gt;</span></pre><p id="69ce" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated">现在最大的问题是，你应该使用渲染道具还是高阶组件？这取决于你。你现在知道如何使用它们，这意味着你有足够的信息为自己做出明智的决定。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="897a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated"><strong class="ix hv"> <em class="iw">这原本是发表在</em></strong><a class="ae jt" href="https://tylermcginnis.com/react-render-props/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hv"><em class="iw"/></strong></a><strong class="ix hv"><em class="iw">作为他们</em> </strong> <a class="ae jt" href="https://tylermcginnis.com/courses/react-fundamentals/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv"> <em class="iw">反应基础</em> </strong> </a> <strong class="ix hv"> <em class="iw">课程的一部分。</em> </strong></p><p id="e237" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hn dt translated"><strong class="ix hv">在推特上关注</strong> <a class="ae jt" href="https://twitter.com/tylermcginnis" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">泰勒</strong> </a> <strong class="ix hv"/></p></div></div>    
</body>
</html>