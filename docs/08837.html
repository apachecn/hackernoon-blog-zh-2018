<html>
<head>
<title>3 JavaScript Performance Mistakes You Should Stop Doing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该停止的3个JavaScript性能错误</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/3-javascript-performance-mistakes-you-should-stop-doing-ebf84b9de951?source=collection_archive---------0-----------------------#2018-10-25">https://medium.com/hackernoon/3-javascript-performance-mistakes-you-should-stop-doing-ebf84b9de951?source=collection_archive---------0-----------------------#2018-10-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f194" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我告诉你你所知道的一切都是谎言，会发生什么呢？如果你知道我们亲爱的ECMAScript在最近几年发布的一些关键特性实际上是危险的性能陷阱，包裹在一行漂亮的回调函数代码中，会发生什么呢？这个故事开始于几年前，回到ES5的天真时代…</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/d264241f54bb268dec0351ecd0e6cb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ZI7OIRHE7ARhiuK"/></div></div></figure><p id="7bde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我仍然清晰地记得这一天，ES5发布了，伟大的新数组函数引入了我们亲爱的JavaScript。其中有forEach、reduce、map、filter——它们让我们感觉到语言在成长，功能越来越多，编写代码变得更加有趣和流畅，结果也更容易阅读和理解。</p><p id="1e39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约在同一时间，一个新的环境出现了——node . js，它让我们能够从前端平稳过渡到后端，同时真正重新定义了全栈开发。</p><p id="9ae2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如今，Node.js使用最新的ECMAScript over V8，正试图被视为主要服务器端开发语言的一部分，因此，它需要证明其性能是值得的。是的，有这么多的参数需要考虑，是的，没有比所有语言都优越的银弹语言。但是，使用像上面提到的数组函数这样的现成特性编写JavaScript对您的应用程序性能有帮助还是有害呢？</p><p id="5a01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，随着最终用户的计算机变得更强大，网络变得更快，客户端javascript声称不仅仅是表示\视图的合理解决方案——但是当我们的应用程序需要极快的性能，并且可能是非常大而复杂的应用程序时，我们能依靠它吗？</p><p id="789e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了测试这些问题，我尝试比较几个场景，并深入了解我得到的结果。我在macOS上的Node.js v10.11.0和Chrome浏览器上执行了以下测试。</p><h2 id="8937" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak"> 1。循环遍历一个数组</strong></h2><p id="0fb5" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我想到的第一个场景是对一个10k项的数组求和，这是一个有效的现实解决方案，我是在尝试从数据库中获取一个很长的项目表并用总和来增强它时偶然发现的，无需对数据库进行额外的查询。</p><p id="f32f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我使用for、for-of、while、forEach和reduce比较了随机10k项的总和。运行测试10，000次会返回以下结果:</p><pre class="jq jr js jt fq lb lc ld le aw lf dt"><span id="ae68" class="kb kc hu lc b fv lg lh l li lj">For Loop, average loop time: ~10 microseconds<br/>For-Of, average loop time: ~110 microseconds<br/>ForEach, average loop time: ~77 microseconds<br/>While, average loop time: ~11 microseconds<br/>Reduce, average loop time: ~113 microseconds</span></pre><p id="ee7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在谷歌搜索如何对数组求和时，reduce是最好的解决方案，但它是最慢的。我的目标也没好多少。即使是最新的for-of (ES6)也只能提供较低的性能。事实证明，良好的旧for循环(以及while)提供了迄今为止最好的性能——好10倍！</p><p id="52ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最新推荐的解决方案怎么会让JavaScript慢这么多？这种痛苦的原因来自两个主要原因，reduce和forEach需要执行一个回调函数，该函数被递归调用并使堆栈膨胀，以及对执行的代码进行额外的操作和验证(此处描述<a class="ae lk" href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.21" rel="noopener ugc nofollow" target="_blank">为</a>)。</p><h2 id="c897" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak"> 2。复制数组</strong></h2><p id="4f4b" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">虽然这听起来不那么有趣，但这是不可变函数的支柱，它在生成输出时不会修改输入。</p><p id="87d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的性能测试结果再次显示了同样有趣的趋势—当复制10k随机项目的10k数组时，使用旧的学校解决方案会更快。同样，最时髦的ES6扩展操作`[…arr]'和Array from `Array.from(arr)`加上ES5映射` arr.map(x =&gt; x)`不如老牌切片` arr.slice()`和concatenate `[]。concat(arr)`。</p><pre class="jq jr js jt fq lb lc ld le aw lf dt"><span id="ebc0" class="kb kc hu lc b fv lg lh l li lj">Duplicate using Slice, average: ~367 microseconds<br/>Duplicate using Map, average: ~469 microseconds<br/>Duplicate using Spread, average: ~512 microseconds<br/>Duplicate using Conct, average: ~366 microseconds<br/>Duplicate using Array From, average: ~1,436 microseconds<br/>Duplicate manually, average: ~412 microseconds</span></pre><h2 id="0753" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak"> 3。迭代对象</strong></h2><p id="e074" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">另一个常见的场景是遍历对象，这主要是当我们试图遍历JSON的和对象，而不是寻找一个特定的键值时所必需的。还有一些老的解决方案，比如for-in `for(let key in obj)`，或者后来的` Object.keys(obj)`(在es6中出现)和` Object.entries(obj)`(来自ES8 ),它们返回键和值。</p><p id="e64d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用上述方法对10k个对象迭代进行性能分析，每个迭代包含1，000个随机键和值，结果如下。</p><pre class="jq jr js jt fq lb lc ld le aw lf dt"><span id="8df3" class="kb kc hu lc b fv lg lh l li lj">Object iterate For-In, average: ~240 microseconds<br/>Object iterate Keys For Each, average: ~294 microseconds<br/>Object iterate Entries For-Of, average: ~535 microseconds</span></pre><p id="a081" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">原因是在后面的两个解决方案中创建了值的可枚举数组，而不是在没有键数组的情况下直接遍历对象。但是底线结果仍然引起了关注。</p><h2 id="bbfa" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak">底线</strong></h2><p id="1dce" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">我的结论很明确——如果超快的性能对您的应用程序至关重要，或者如果您的服务器需要处理一些负载——使用最酷、可读性更强、更简洁的选项将对您的应用程序性能产生重大影响——速度可能会慢10倍！</p><p id="3109" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一次，在盲目采用最聪明的新趋势之前，确保它们也符合您的需求——对于小型应用程序，编写快速且可读性更好的代码是完美的——但是对于压力很大的服务器和大型客户端应用程序，这可能不是最佳实践。</p><p id="9526" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以上是在创建我的<a class="ae lk" href="https://www.resty.co.il/?locale=en" rel="noopener ugc nofollow" target="_blank">特拉维夫顶级餐厅</a>网站时调查和实施的。</p></div></div>    
</body>
</html>