<html>
<head>
<title>Ethereum Oracle Contracts: Solidity Code Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊Oracle合同:可靠性代码特征</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ethereum-oracle-contracts-solidity-code-features-15d767776e44?source=collection_archive---------14-----------------------#2018-10-26">https://medium.com/hackernoon/ethereum-oracle-contracts-solidity-code-features-15d767776e44?source=collection_archive---------14-----------------------#2018-10-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ef7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">原载于</em><a class="ae jq" href="https://www.toptal.com/ethereum/ethereum-solidity-oracle-contracts-pt2" rel="noopener ugc nofollow" target="_blank"><em class="jp">【www.toptal.com】</em></a><em class="jp">，作者</em> <a class="ae jq" href="https://www.toptal.com/resume/john-r-kosinski" rel="noopener ugc nofollow" target="_blank"> <em class="jp">约翰·r·科辛斯基</em> </a> <em class="jp">。</em></p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/abc2bf5969136fd456bad2e9fa9247d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOH1tma9uiG5-gt718alKg.png"/></div></div></figure><p id="01e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">原载于</em><a class="ae jq" href="https://www.toptal.com/ethereum/ethereum-solidity-oracle-contracts-pt2" rel="noopener ugc nofollow" target="_blank"><em class="jp">www.toptal.com</em></a><em class="jp">，作者为</em> <a class="ae jq" href="https://www.toptal.com/resume/john-r-kosinski" rel="noopener ugc nofollow" target="_blank"> <em class="jp">约翰·r·科辛斯基</em> </a> <em class="jp">。</em></p><p id="35f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个三部分的第一部分中，我们经历了一个<a class="ae jq" href="https://www.toptal.com/ethereum/ethereum-oracle-contracts-tutorial-pt1" rel="noopener ugc nofollow" target="_blank">小教程，它为我们提供了一个简单的与oracle的合同对</a>。描述了设置(使用truffle)、编译代码、部署到测试网络、运行和调试的机制和过程；然而，代码的许多细节都被掩盖了。现在，正如承诺的那样，我们将开始研究一些语言特性，这些特性是<a class="ae jq" href="https://www.toptal.com/ethereum" rel="noopener ugc nofollow" target="_blank">Solidity smart contract development</a>所独有的，也是这个特定的contract-oracle场景所独有的。虽然我们不可能仔细研究每一个细节(如果你愿意，我会把这个问题留给你以后的研究)，但我们会尽力发现代码中最引人注目、最有趣和最重要的特征。</p><p id="0a48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了方便起见，我建议您打开项目的您自己的版本(如果您有)，或者将代码放在手边以供参考。</p><p id="8e6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于这一点的完整代码可以在这里找到:<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/tree/part2-step1" rel="noopener ugc nofollow" target="_blank">https://github . com/jrkosinski/Oracle-example/tree/part 2-step 1</a></p><h1 id="e757" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">以太坊和坚固</h1><p id="f50b" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Solidity不是唯一可用的智能合约开发语言，但我认为它是以太坊智能合约中最常见和最受欢迎的语言。当然，在我写这篇文章的时候，它拥有最受欢迎的支持和信息。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/fd6c9e639fd75d6632629d6cb238ef3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zQJs5dm0IImjCrFy.png"/></div></div></figure><p id="e5a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">坚固性是面向对象的，是图灵完备的。也就是说，您将很快意识到它的内置(并且完全是有意的)限制，这使得智能合约编程感觉与普通的“让我们做这件事”黑客行为截然不同。</p><h1 id="8843" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">坚固性版本</h1><p id="d8c1" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">以下是每首Solidity代码诗的第一行:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="0dd1" class="ll ke hu lh b fv lm ln l lo lp">pragma solidity ^0.4.17;</span></pre><p id="c6ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你看到的版本号将会有所不同，因为Solidity还处于年轻阶段，正在快速变化和发展。版本0.4.17是我在例子中使用的版本；本出版物发布时的最新版本是0.4.25。</p><p id="288f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在你读这篇文章的时候，最新的版本可能是完全不同的。许多好的特性正在为可靠性而工作(或者至少是计划好的),我们将在下面讨论。</p><p id="9341" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是不同<a class="ae jq" href="https://github.com/ethereum/solidity/releases" rel="noopener ugc nofollow" target="_blank">实度版本</a>的概述。</p><p id="4da9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">专业提示:</strong> <em class="jp">你也可以指定一个版本范围(虽然我不常看到这样做)，比如:</em></p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="775d" class="ll ke hu lh b fv lm ln l lo lp">pragma solidity &gt;=0.4.16 &lt;0.6.0;</span></pre><h1 id="1190" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">Solidity编程语言的特点</h1><p id="5c90" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Solidity有许多现代程序员熟悉的语言特性，也有一些独特的(至少对我来说)不寻常的特性。据说它的灵感来自C++、Python和JavaScript——所有这些对我个人来说都很熟悉，然而Solidity似乎与这些语言中的任何一种都截然不同。</p><h2 id="92d1" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">合同</h2><p id="19df" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">的。sol文件是代码的基本单位。在<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>中，注意第9行:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="e3a9" class="ll ke hu lh b fv lm ln l lo lp">contract BoxingOracle is Ownable {</span></pre><p id="1049" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于类是面向对象语言中逻辑的基本单位，所以契约是固态逻辑的基本单位。现在简单地说，契约是可靠性的“类”就足够了(对于面向对象的程序员来说，这是一个简单的飞跃)。</p><h2 id="f1e8" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">遗产</h2><p id="38a7" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">可靠契约完全支持继承，并且如你所料；私有契约成员不被继承，而受保护的和公共的成员被继承。正如你所期望的，重载和多态是被支持的。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="c233" class="ll ke hu lh b fv lm ln l lo lp">contract BoxingOracle is Ownable {</span></pre><p id="c760" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的语句中，“is”关键字表示继承。BoxingOracle继承自Ownable。Solidity中也支持多重继承。多重继承由逗号分隔的类名列表表示，如下所示:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="8f38" class="ll ke hu lh b fv lm ln l lo lp">contract Child is ParentA, ParentB, ParentC { <br/>…</span></pre><p id="afdb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然(在我看来)在构建继承模型时过于复杂并不是一个好主意，但这里有一篇关于所谓的<a class="ae jq" href="https://ethereum.stackexchange.com/questions/21060/multiple-inheritance-and-linearization" rel="noopener ugc nofollow" target="_blank">钻石问题</a>的关于可靠性的有趣文章。</p><h2 id="1ef1" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">枚举</h2><p id="6164" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">实体支持枚举:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="c989" class="ll ke hu lh b fv lm ln l lo lp">enum MatchOutcome { <br/>     Pending, //match has not been fought to decision <br/>     Underway, //match has started &amp; is underway <br/>     Draw, //anything other than a clear winner (e.g., cancelled)<br/>     Decided //index of participant who is the winner }</span></pre><p id="fb28" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您所料(与熟悉的语言没有什么不同)，每个枚举值都被赋予一个整数值，从0开始。如Solidity文档中所述，枚举值可转换为所有整数类型(例如，uint、uint16、uint32等)。)，但不允许隐式转换。这意味着它们必须被显式转换(例如转换为uint)。</p><blockquote class="md me mf"><p id="8633" class="ir is jp it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated"><a class="ae jq" href="https://solidity.readthedocs.io/en/develop/types.html#enums" rel="noopener ugc nofollow" target="_blank"> <em class="hu">实体文档:枚举</em> </a> <em class="hu"> </em> <a class="ae jq" href="https://boostlog.io/@bily809/solidity-tutorial-5-5abf43ed0814730093a2f00e" rel="noopener ugc nofollow" target="_blank"> <em class="hu">枚举教程</em> </a></p></blockquote><h2 id="37ae" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">结构</h2><p id="2e4f" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">像枚举一样，结构是创建用户定义的数据类型的另一种方式。结构是所有C/C++基础程序员和像我这样的老家伙所熟悉的。一个结构的例子，来自<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第17行:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="9344" class="ll ke hu lh b fv lm ln l lo lp">//defines a match along with its outcome <br/>     struct Match { <br/>          bytes32 id; <br/>          string name; <br/>          string participants; <br/>          uint8 participantCount; <br/>          uint date; <br/>          MatchOutcome outcome; <br/>          int8 winner; <br/>}</span></pre><p id="6cfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">所有老C程序员注意:</strong><em class="jp">Solidity中的Struct“打包”是一个东西，但是有一些规则和注意事项。不一定要假设它的工作原理和C中的一样；检查文件，了解你的情况，以确定在特定情况下打包是否有助于你。</em></p><blockquote class="md me mf"><p id="a1ef" class="ir is jp it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated"><a class="ae jq" href="https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html" rel="noopener ugc nofollow" target="_blank"> <em class="hu">坚固结构包装</em> </a></p></blockquote><p id="af4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结构一旦创建，就可以在代码中作为本机数据类型进行寻址。下面是上面创建的结构类型的“实例化”语法示例:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="29df" class="ll ke hu lh b fv lm ln l lo lp">Match match = Match(id, "A vs. B", "A|B", 2, block.timestamp, MatchOutcome.Pending, 1);</span></pre><h1 id="2bf9" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">Solidity中的数据类型</h1><p id="1b68" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这就把我们带到了Solidity中数据类型的最基本的主题。solidity支持哪些数据类型？Solidity是静态类型的，在撰写本文时，数据类型必须显式声明并绑定到变量。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/a189878acd2f9bf0d1028de0fd78c4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vNnh6deVOEE0fzty.png"/></div></div></figure><blockquote class="md me mf"><p id="970b" class="ir is jp it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated"><a class="ae jq" href="https://solidity.readthedocs.io/en/v0.4.24/types.html" rel="noopener ugc nofollow" target="_blank"> <em class="hu">实度数据类型</em> </a></p></blockquote><h2 id="3e52" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">布尔运算</h2><p id="92c2" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">布尔类型在名称<em class="jp"> bool </em>和值<em class="jp"> true </em>或<em class="jp"> false </em>下受支持</p><h2 id="fc5e" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">数字类型</h2><p id="ad04" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">支持整数类型，无论有符号还是无符号，从int8/uint8到int256/uint256(分别是8位整数到256位整数)。uint类型是uint256的缩写(同样，int也是int256的缩写)。</p><p id="7042" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得注意的是，<em class="jp">不支持浮点类型。为什么不呢？首先，在处理货币价值时，众所周知浮点变量是个坏主意(当然是一般情况下)，因为价值可能会消失得无影无踪。乙醚值用wei表示，它是乙醚的1/1，000，000，000，000，000，000，这对于所有目的来说必须足够精确；你不能把以太分解成更小的部分。</em></p><p id="4262" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目前部分支持定点值。根据Solidity文档:<em class="jp">“Solidity还不完全支持定点数。它们可以被声明，但不能被赋值给或来自。</em></p><blockquote class="md me mf"><p id="c0ef" class="ir is jp it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated"><a class="ae jq" href="https://hackernoon.com/a-note-on-numbers-in-ethereum-and-javascript-3e6ac3b2fad9" rel="noopener ugc nofollow" target="_blank"><em class="hu">https://hacker noon . com/a-note-on-numbers-in-ether eum-and-JavaScript-3e 6 AC 3 B2 fad 9</em></a></p></blockquote><p id="134e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong> <em class="jp">在大多数情况下，最好只使用uint，因为减小变量的大小(例如减小到uint32)，实际上可能会增加汽油成本，而不是像您所期望的那样降低成本。作为一般的经验法则，使用uint，除非你确定你有一个好的理由不这样做。</em></p><h2 id="9c37" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">字符串类型</h2><p id="9dd8" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Solidity中的字符串数据类型是一个有趣的主题；根据你和谁交谈，你可能会得到不同的意见。Solidity中有一个字符串数据类型，这是事实。我的观点，可能也是大多数人的观点，是它没有提供太多的功能。字符串解析、连接、替换、修剪，甚至计算字符串的长度:这些您可能期望从字符串类型中得到的东西都不存在，因此它们是您的责任(如果您需要它们)。有人用bytes32代替string这也可以做到。</p><blockquote class="md me mf"><p id="4e80" class="ir is jp it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated"><a class="ae jq" href="https://hackernoon.com/working-with-strings-in-solidity-c4ff6d5f8008" rel="noopener ugc nofollow" target="_blank"> <em class="hu">关于坚固琴弦的趣味文章</em> </a></p></blockquote><p id="283d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的观点是:编写自己的字符串类型并发布供一般使用可能是一个有趣的练习。</p><h2 id="e84b" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">地址类型</h2><p id="2dc7" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">也许对Solidity来说是独一无二的，我们有一个<em class="jp">地址</em>数据类型，专门用于以太坊钱包或合同地址。它是一个20字节的值，专门用于存储特定大小的地址。此外，它还有专门针对该类地址的类型成员。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="51af" class="ll ke hu lh b fv lm ln l lo lp">address internal boxingOracleAddr = 0x145ca3e014aaf5dca488057592ee45305d9b3a22;</span></pre><blockquote class="md me mf"><p id="6edb" class="ir is jp it b iu iv iw ix iy iz ja jb mg jd je jf mh jh ji jj mi jl jm jn jo hn dt translated"><a class="ae jq" href="https://ethereum.stackexchange.com/questions/34024/when-exactly-address-datatype-should-be-used" rel="noopener ugc nofollow" target="_blank"> <em class="hu">地址数据类型</em> </a></p></blockquote><p id="d011" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在Solidity中没有本地日期或日期时间类型，而在JavaScript中却有。(哦，不——每一段都越来越不可靠了！？)日期作为uint (uint256)类型的时间戳进行本机寻址。它们通常作为Unix风格的时间戳来处理，单位是秒而不是毫秒，因为块时间戳是Unix风格的时间戳。如果您发现自己出于各种原因需要人类可读的日期，可以使用开源库。您可能会注意到我在BoxingOracle中使用了一个:<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/DateLib.sol" rel="noopener ugc nofollow" target="_blank"> DateLib.sol </a>。OpenZeppelin也有日期工具以及许多其他类型的通用工具库(我们很快会谈到Solidity的<em class="jp">库</em>特性)。</p><p id="6fab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">专业提示:</strong><a class="ae jq" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"><em class="jp">OpenZeppelin</em></a><em class="jp">对于知识和预先编写的通用代码来说都是一个很好的来源(但当然不是唯一的好来源)，可以帮助您建立合同。</em></p><h2 id="c092" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">映射</h2><p id="f34b" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">注意<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第11行定义了一个叫做<em class="jp">映射</em>的东西:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="6665" class="ll ke hu lh b fv lm ln l lo lp">mapping(bytes32 =&gt; uint) matchIdToIndex;</span></pre><p id="3605" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Solidity中的映射是用于快速查找的特殊数据类型；本质上是一个查找表或类似的哈希表，其中包含的数据位于区块链本身上(当映射被定义时，就像这里一样，作为类成员)。在契约的执行过程中，我们可以将数据添加到映射中，类似于将数据添加到散列表中，然后查找我们添加的那些值。请再次注意，在这种情况下，我们添加的数据被添加到区块链本身，因此它将持续存在。如果我们今天把它添加到纽约的地图上，一周后伊斯坦布尔的某个人就能看到它。</p><p id="3b51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加到映射的示例，来自<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第71行:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="7aed" class="ll ke hu lh b fv lm ln l lo lp">matchIdToIndex[id] = newIndex+1</span></pre><p id="d325" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第51行读取映射的示例:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="b8c7" class="ll ke hu lh b fv lm ln l lo lp">uint index = matchIdToIndex[_matchId];</span></pre><p id="f0e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也可以从映射中删除项目。这个项目中没有使用它，但它看起来像这样:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="25cc" class="ll ke hu lh b fv lm ln l lo lp">delete matchIdToIndex[_matchId];</span></pre><h2 id="e68f" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">返回值</h2><p id="e223" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">正如您可能已经注意到的，Solidity可能与JavaScript有一点表面上的相似，但它没有继承Javascript在类型和定义方面的松散性。契约代码必须以相当严格和受限的方式定义(考虑到用例，这可能是一件好事)。记住这一点，考虑来自<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第40行的函数定义</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="64c3" class="ll ke hu lh b fv lm ln l lo lp">function _getMatchIndex(bytes32 _matchId) private view returns (uint) { ... }</span></pre><p id="c88d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好，那么，让我们先快速概述一下这里包含的内容。<code class="eh mj mk ml lh b">function</code>将其标记为函数。<code class="eh mj mk ml lh b">_getMatchIndex</code>是函数名(下划线是表示私有成员的约定——我们将在后面讨论)。它有一个类型为<code class="eh mj mk ml lh b">bytes32</code>的参数，名为<code class="eh mj mk ml lh b">_matchId</code>(这次使用下划线约定来表示函数参数)。关键字<code class="eh mj mk ml lh b">private</code>实际上是让成员在作用域上私有，<code class="eh mj mk ml lh b">view</code>告诉编译器这个函数不修改区块链上的任何数据，最后:~~~ solidity返回(uint) ~~~</p><p id="7aca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这表示函数返回一个uint(返回void的函数在这里没有<code class="eh mj mk ml lh b">returns</code>子句)。uint为什么在括号里？这是因为Solidity函数能够并且经常返回<em class="jp">元组</em>。</p><p id="5f2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在考虑第166行的以下定义:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="8d09" class="ll ke hu lh b fv lm ln l lo lp">function getMostRecentMatch(bool _pending) public view returns (<br/>     bytes32 id, <br/>     string name, <br/>     string participants, <br/>     uint8 participantCount, <br/>     uint date, <br/>     MatchOutcome outcome, <br/>     int8 winner) { ... }</span></pre><p id="6ad2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看看这个的退货条款！它返回一个，两个…七个不同的东西。这个函数以元组的形式返回这些东西。为什么？在开发过程中，您会经常发现自己需要返回一个struct(如果是JavaScript，您可能会希望返回一个JSON对象)。好吧，在撰写本文时(尽管将来这可能会改变)，Solidity不支持从公共函数返回结构。所以你必须返回元组。如果你是一个Python爱好者，你可能已经习惯了元组。但是许多语言并不真正支持它们，至少不是以这种方式。</p><p id="c84c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">见第159行返回一个元组作为返回值的例子:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="ae42" class="ll ke hu lh b fv lm ln l lo lp">return (_matchId, "", "", 0, 0, MatchOutcome.Pending, -1);</span></pre><p id="b563" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们如何接受这样的东西的返回值呢？我们可以这样做:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="de9c" class="ll ke hu lh b fv lm ln l lo lp">var (id, name, part, count, date, outcome, winner) = getMostRecentMatch(false);</span></pre><p id="77af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，您可以事先用正确的类型显式声明变量:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="9715" class="ll ke hu lh b fv lm ln l lo lp">//declare the variables <br/>bytes32 id; <br/>string name; <br/>... etc... <br/>int8 winner; </span><span id="fe2b" class="ll ke hu lh b fv mm ln l lo lp">//assign their values <br/>(id, name, part, count, date, outcome, winner) = getMostRecentMatch(false);<!-- --> </span></pre><p id="7339" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经声明了7个变量来保存7个返回值，我们现在可以使用它们了。否则，假设我们只需要一两个值，我们可以说:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="b3da" class="ll ke hu lh b fv lm ln l lo lp">//declare the variables <br/>bytes32 id; <br/>uint date; </span><span id="4ef1" class="ll ke hu lh b fv mm ln l lo lp">//assign their values <br/>(id,,,,date,,) = getMostRecentMatch(false);</span></pre><p id="d426" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看到我们在那里做了什么吗？我们只得到我们感兴趣的两个。检查所有这些逗号。我们得仔细数一数！</p><h2 id="bbfa" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">进口</h2><p id="c4a3" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第3行和第4行是导入:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="de55" class="ll ke hu lh b fv lm ln l lo lp">import "./Ownable.sol"; <br/>import "./DateLib.sol";</span></pre><p id="8a45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您可能预料的那样，这些是从与BoxingOracle.sol位于同一个contracts项目文件夹中的代码文件中导入定义。</p><h2 id="6cbf" class="ll ke hu bd kf lq lr ls kj lt lu lv kn jc lw lx kr jg ly lz kv jk ma mb kz mc dt translated">修饰语</h2><p id="e506" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">请注意，函数定义附带了许多修饰符。首先是可见性:私有、公共、内部和外部— <a class="ae jq" href="https://forum.ethereum.org/discussion/3344/function-visibility-whats-the-difference-between-private-and-internal-if-any" rel="noopener ugc nofollow" target="_blank">函数可见性</a>。</p><p id="6907" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，您会看到关键字<code class="eh mj mk ml lh b">pure</code>和<code class="eh mj mk ml lh b">view</code>。这些向编译器表明函数将做出什么样的改变，如果有的话。这很重要，因为这是运行该功能的最终气体成本的一个因素。参见此处解释:<a class="ae jq" href="https://solidity.readthedocs.io/en/v0.4.24/contracts.html" rel="noopener ugc nofollow" target="_blank">固化文档</a>。</p><p id="1fca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我真正想讨论的是自定义修饰符。看一下<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第61行:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="2297" class="ll ke hu lh b fv lm ln l lo lp">function addMatch(string _name, string _participants, uint8 _participantCount, uint _date) onlyOwner public returns (bytes32) {</span></pre><p id="e1fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意“公共”关键字前面的<code class="eh mj mk ml lh b">onlyOwner</code>修饰符。这表明<em class="jp">只有契约的所有者</em>可以调用这个方法！虽然非常重要，但这并不是坚固性的固有特征(尽管将来可能会是)。实际上，<code class="eh mj mk ml lh b">onlyOwner</code>是我们自己创建并使用的自定义修饰符的一个例子。让我们看一看。</p><p id="1def" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，修改器在文件<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> Ownable.sol </a>中定义，你可以看到我们已经在<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank"> BoxingOracle.sol </a>的第3行导入了它:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="d744" class="ll ke hu lh b fv lm ln l lo lp">import "./Ownable.sol"</span></pre><p id="812d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，为了使用这个修饰符，我们让<code class="eh mj mk ml lh b">BoxingOracle</code>继承了<code class="eh mj mk ml lh b">Ownable</code>。在<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> Ownable.sol </a>的第25行，我们可以在“Ownable”契约中找到修饰符的定义:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="d358" class="ll ke hu lh b fv lm ln l lo lp">modifier onlyOwner() { <br/>     require(msg.sender == owner); <br/>     _; <br/>}</span></pre><p id="c49e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(顺便说一下，这份可拥有的合同来自于<a class="ae jq" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>的一份公开合同。)</p><p id="6377" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这个东西被声明为修饰符，表明我们可以像我们所拥有的那样使用它，来修改一个函数。请注意，修饰语的核心是“要求”语句。Require语句有点像断言，但不用于调试。如果require语句的条件失败，那么函数将抛出一个异常。所以，套用这句“要求”的话:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="237f" class="ll ke hu lh b fv lm ln l lo lp">require(msg.sender == owner);</span></pre><p id="6bed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以说它的意思是:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="4374" class="ll ke hu lh b fv lm ln l lo lp">if (msg.send != owner) <br/>      throw an exception;</span></pre><p id="6e11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，在Solidity 0.4.22和更高版本中，我们可以向require语句添加一条错误消息:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="3313" class="ll ke hu lh b fv lm ln l lo lp">require(msg.sender == owner, "Error: this function is callable by the owner of the contract, only");</span></pre><p id="2b4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，在看起来很奇怪的一行中:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="8f65" class="ll ke hu lh b fv lm ln l lo lp">_;</span></pre><p id="9181" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下划线是“在这里，执行修改后的函数的全部内容”的简写因此实际上，require语句将首先被执行，然后是实际的函数。这就像在修改后的函数前加上这条逻辑线。</p><p id="baac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，你可以用修改器做更多的事情。查看单据:<a class="ae jq" href="https://solidity.readthedocs.io/en/v0.4.24/common-patterns.html" rel="noopener ugc nofollow" target="_blank">单据</a>。</p><h1 id="feea" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">固体图书馆</h1><p id="b05a" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">有一种语言特性叫做<em class="jp">库</em>。我们的项目中有一个例子在<a class="ae jq" href="https://uploads.toptal.io/blog/image/127425/toptal-blog-image-1540462147637-42133106791559b652ee7f4bb29c2f6e.png" rel="noopener ugc nofollow" target="_blank"> DateLib.sol </a>。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/0559d218ab1eb1198b2679fc321dca8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RL4bz5vjh5CteueE.png"/></div></div></figure><p id="ba53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个更好更容易处理日期类型的库。它在第4行被导入到BoxingOracle:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="0894" class="ll ke hu lh b fv lm ln l lo lp">import "./DateLib.sol";</span></pre><p id="5ef2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它用在第13行:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="df22" class="ll ke hu lh b fv lm ln l lo lp">using DateLib for DateLib.DateTime;</span></pre><p id="c7af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mj mk ml lh b">DateLib.DateTime</code>是从DateLib协定中展开的结构(它作为成员公开；参见<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/DateLib.sol" rel="noopener ugc nofollow" target="_blank"> DateLib.sol </a>的第4行)我们在这里声明我们“使用”特定数据类型的DateLib库。因此，该库中声明的方法和操作将应用于我们说过应该应用的数据类型。这就是库在Solidity中的用法。</p><p id="8645" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更清楚的例子是，查看一些<a class="ae jq" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>的数字库，比如<a class="ae jq" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol" rel="noopener ugc nofollow" target="_blank"> SafeMath </a>。这些可以应用于本地(数字)实体数据类型(而这里我们将一个库应用于自定义数据类型)，并且被广泛使用。</p><h1 id="d990" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">接口</h1><p id="6544" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">和主流面向对象语言一样，支持接口。Solidity中的接口被定义为契约，但是函数的函数体被省略了。有关接口定义的示例，请参见<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/client/contracts/OracleInterface.sol" rel="noopener ugc nofollow" target="_blank"> OracleInterface.sol </a>。在此示例中，接口用作oracle契约的替代，其内容驻留在具有单独地址的单独契约中。</p><h1 id="baa0" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">命名规格</h1><p id="f88c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">当然，命名约定不是一个全局规则；作为程序员，我们知道我们可以自由地遵循吸引我们的编码和命名惯例。另一方面，我们确实希望其他人能够舒服地阅读和使用我们的代码，所以某种程度的标准化是可取的。</p><h1 id="ad37" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">项目概述</h1><p id="76fb" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">现在我们已经讨论了代码文件中的一些通用语言特性，我们可以开始更具体地看看这个项目的代码本身。</p><p id="8d29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，让我们再一次澄清这个项目的目的。这个项目的目的是提供一个半现实(或伪现实)的示范和使用甲骨文的智能合同的例子。本质上，这只是一个调用另一个单独契约的契约。</p><p id="48da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该示例的业务案例可以陈述如下:</p><ul class=""><li id="8641" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">一个用户想要在拳击比赛中下不同大小的赌注，为赌注支付金钱(乙醚),并在他们赢了的时候收取他们的奖金。</li><li id="8f07" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">用户通过智能合约下注。(在现实生活的用例中，这将是一个完整的带有web3前端的DApp；但是我们只检查合同方面。)</li><li id="b251" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">一个独立的智能合同(oracle)由第三方维护。它的工作是维护一个列表，列出拳击比赛的当前状态(待定、进行中、结束等)。)还有，如果完成了，就是赢家。</li><li id="c8e0" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">主合同从oracle获得未决匹配的列表，并将这些列表作为“可下注的”匹配呈现给用户。</li><li id="3b9e" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">主合同接受赌注，直到比赛开始。</li><li id="65f3" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">比赛结束后，主合同根据一个简单的算法来分配输赢，自己提成，并根据要求支付赢款(输者只是输掉他们的全部股份)。</li></ul><p id="1f2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下注规则:</p><ul class=""><li id="cb8e" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">有一个明确的最低赌注(定义在魏)。</li><li id="2a18" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">没有最大赌注；用户可以下注超过最低金额的任意金额。</li><li id="71aa" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">用户可以下注，直到比赛变成“进行中”</li></ul><p id="691a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">分配奖金的算法:</p><ul class=""><li id="59e8" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">收到的所有赌注都放入“彩池”</li><li id="e43d" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">一小部分从锅里拿出来，给房子用。</li><li id="7080" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">每个赢家都会得到一部分奖金，与他们下注的相对大小成正比。</li><li id="cf82" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">比赛结束后，一旦第一个用户请求结果，就开始计算奖金。</li><li id="361b" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">根据用户的请求奖励奖品。</li><li id="4f28" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">在平局的情况下，没有人会赢——每个人都拿回他们的赌注，而房子没有提成。</li></ul><h1 id="a246" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">甲骨文合同</h1><h1 id="d21f" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">提供的主要功能</h1><p id="74fd" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">oracle有两个接口，你可以说:一个呈现给合同的“所有者”和维护者，另一个呈现给公众；即消耗神谕的契约。作为维护者，它提供了将数据输入到契约中的功能，本质上是从外部世界获取数据并将其放到区块链上。对公众而言，它提供对所述数据的只读访问。值得注意的是，合同本身限制非所有者编辑任何数据，但是对该数据的只读访问是公开授予的，没有任何限制。</p><p id="cee0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">给用户:</p><ul class=""><li id="87a5" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">列出所有匹配项</li><li id="73cc" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">列出待定匹配项</li><li id="ab02" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">获取特定匹配的详细信息</li><li id="7991" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">获取特定比赛的状态和结果</li></ul><p id="f773" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">致所有者:</p><ul class=""><li id="6ee2" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">输入匹配项</li><li id="9618" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">改变比赛状态</li><li id="11b1" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">设定比赛结果</li></ul><p id="0eb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用户故事:</p><ul class=""><li id="4929" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">一场新的拳击比赛已经宣布并确定于5月9日举行。</li><li id="4ac6" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">我，合同的维护者(也许我是一个知名的体育网络或新的出路)，将即将到来的比赛添加到区块链的甲骨文数据中，状态为“待定”任何人或任何合同现在都可以随意查询和使用这些数据。</li><li id="8400" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">当比赛开始时，我将比赛的状态设置为“进行中”</li><li id="bb76" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">当比赛结束时，我将比赛的状态设置为“completed ”,并修改比赛数据以表示获胜者。</li></ul><h1 id="f95f" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">甲骨文代码审查</h1><p id="cb85" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这篇评论完全基于<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/oracle/contracts/BoxingOracle.sol" rel="noopener ugc nofollow" target="_blank">boxing Oracle . sol</a>；行号引用该文件。</p><p id="43cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第10行和第11行，我们声明了匹配的存储位置:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="9957" class="ll ke hu lh b fv lm ln l lo lp">Match[] matches; mapping(bytes32 =&gt; uint) matchIdToIndex;</span></pre><p id="e028" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mj mk ml lh b">matches</code>只是一个简单的数组，用于存储匹配实例，映射只是一个工具，用于将唯一的匹配ID(一个bytes32值)映射到它在数组中的索引，这样如果有人给我们一个匹配的原始ID，我们就可以使用这个映射来定位它。</p><p id="3dae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第17行，我们的匹配结构被定义和解释:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="a84c" class="ll ke hu lh b fv lm ln l lo lp">//defines a match along with its outcome <br/>     struct Match { <br/>          bytes32 id; //unique id <br/>          string name; //human-friendly name (e.g., Jones vs. Holloway) <br/>          string participants; //a delimited string of participant names <br/>          uint8 participantCount; //number of participants (always 2 for boxing matches!) <br/>          uint date; //GMT timestamp of date of contest MatchOutcome outcome; //the outcome (if decided) <br/>          int8 winner; //index of the participant who is the winner<br/>} </span><span id="087f" class="ll ke hu lh b fv mm ln l lo lp">//possible match outcomes <br/>     enum MatchOutcome { <br/>          Pending, //match has not been fought to decision <br/>          Underway, //match has started &amp; is underway <br/>          Draw, //anything other than a clear winner (e.g., cancelled) <br/>          Decided //index of participant who is the winner }</span></pre><p id="dacf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第61行:函数<code class="eh mj mk ml lh b">addMatch</code>仅供合同业主使用；它允许向存储的数据添加新的匹配。</p><p id="8c26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第80行:函数<code class="eh mj mk ml lh b">declareOutcome</code>允许合同所有者将一场比赛设置为“已决定”，设置获胜的参与者。</p><p id="fae9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第102–166行:下面的函数都可以被公众调用。这是通常向公众开放的只读数据:</p><ul class=""><li id="7064" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">函数<code class="eh mj mk ml lh b">getPendingMatches</code>返回当前状态为“待定”的所有匹配的id列表</li><li id="1487" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">函数<code class="eh mj mk ml lh b">getAllMatches</code>返回所有匹配的id列表。</li><li id="1330" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">函数<code class="eh mj mk ml lh b">getMatch</code>返回由ID指定的单个匹配的完整细节。</li></ul><p id="0259" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第193–204行声明了主要用于测试、调试和诊断的函数。</p><ul class=""><li id="9a3e" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">函数<code class="eh mj mk ml lh b">testConnection</code>只是测试我们是否能够调用契约。</li><li id="cde5" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">函数<code class="eh mj mk ml lh b">getAddress</code>返回这个契约的地址。</li><li id="5947" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">函数<code class="eh mj mk ml lh b">addTestData</code>将一组测试匹配添加到匹配列表中。</li></ul><p id="63d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在进入下一步之前，请随意探索一下代码。我建议在调试模式下再次运行oracle contract(如本系列第1部分所述)，调用不同的函数，并检查结果。</p><h1 id="b9fc" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">装箱数:客户合同</h1><p id="a8f9" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">定义客户合同(下注合同)负责什么和不负责什么是很重要的。客户合同<em class="jp">不</em>负责维护真实拳击比赛的列表或宣布其结果。我们“信任”(是的，我知道，有一个敏感词—哦—我们将在第3部分中讨论)该服务的oracle。客户合同负责接受赌注。它负责分配奖金的算法，并根据比赛结果(从神谕处收到)将奖金转移到赢家的账户。</p><p id="0ff4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，一切都是基于拉的，没有事件或推。契约从oracle获取数据。该契约从oracle中提取比赛结果(响应用户请求)，并计算奖金，然后根据用户请求进行转移。</p><h1 id="0fad" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">提供的主要功能</h1><ul class=""><li id="488f" class="mn mo hu it b iu lb iy lc jc nb jg nc jk nd jo ms mt mu mv dt translated">列出所有待定匹配</li><li id="8615" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">获取特定匹配的详细信息</li><li id="1052" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">获取特定比赛的状态和结果</li><li id="eb2b" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">下注</li><li id="7f0e" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">申请/接受奖金</li></ul><h1 id="5077" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">客户代码审查</h1><p id="d0f6" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这篇评论完全基于<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/client/contracts/BoxingBets.sol" rel="noopener ugc nofollow" target="_blank">boxing bets . sol</a>；行号引用该文件。</p><p id="f3d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第12行和第13行是契约中的第一行代码，定义了一些映射，我们将在其中存储契约的数据。</p><p id="d8a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第12行将用户地址映射到id列表。这是将用户映射到属于该用户的赌注id列表。因此，对于任何给定的用户地址，我们可以快速获得该用户所下的所有赌注的列表。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="762e" class="ll ke hu lh b fv lm ln l lo lp">mapping(address =&gt; bytes32[]) private userToBets;</span></pre><p id="8c23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第13行将一个匹配的惟一ID映射到一个bet实例列表。有了这个，对于任何给定的比赛，我们都可以得到该比赛的所有赌注的列表。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="b806" class="ll ke hu lh b fv lm ln l lo lp">mapping(bytes32 =&gt; Bet[]) private matchToBets;</span></pre><p id="1a48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第17行和第18行与我们的oracle的连接有关。首先，在<code class="eh mj mk ml lh b">boxingOracleAddr</code>变量中，我们存储oracle契约的地址(默认设置为零)。我们可以对先知的地址进行硬编码，但这样我们就永远无法改变它。(不能更改oracle的地址可能是一件好事，也可能是一件坏事——我们可以在第3部分讨论这个问题)。下一行创建oracle接口的实例(在<a class="ae jq" href="https://github.com/jrkosinski/oracle-example/blob/part2-step1/client/contracts/OracleInterface.sol" rel="noopener ugc nofollow" target="_blank"> OracleInterface.sol </a>中定义)并将其存储在一个变量中。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="409a" class="ll ke hu lh b fv lm ln l lo lp">//boxing results oracle <br/>address internal boxingOracleAddr = 0; <br/>OracleInterface internal boxingOracle = OracleInterface(boxingOracleAddr);</span></pre><p id="78b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您跳到第58行，您将看到<code class="eh mj mk ml lh b">setOracleAddress</code>函数，在这个函数中，这个oracle地址可以被更改，并且在这个函数中，<code class="eh mj mk ml lh b">boxingOracle</code>实例被用一个新地址重新实例化。</p><p id="768e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第21行定义了我们的最小下注额，单位是100威.这当然实际上是很小的量，只有0.000001以太。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="aa05" class="ll ke hu lh b fv lm ln l lo lp">uint internal minimumBet = 1000000000000;</span></pre><p id="418c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">分别在第58行和第66行，我们有<code class="eh mj mk ml lh b">setOracleAddress</code>和<code class="eh mj mk ml lh b">getOracleAddress</code>函数。<code class="eh mj mk ml lh b">setOracleAddress</code>有<code class="eh mj mk ml lh b">onlyOwner</code>修饰符，因为只有契约的所有者可以用另一个甲骨文替换掉这个甲骨文(可能<em class="jp">不是</em>一个好主意，但是我们将在第3部分详细阐述)。另一方面，<code class="eh mj mk ml lh b">getOracleAddress</code>函数是可公开调用的；任何人都可以看到使用的是什么oracle。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="391f" class="ll ke hu lh b fv lm ln l lo lp">function setOracleAddress(address _oracleAddress) external onlyOwner returns (bool) {... <br/>function getOracleAddress() external view returns (address) { ....</span></pre><p id="4d93" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第72行和第79行，我们分别有<code class="eh mj mk ml lh b">getBettableMatches</code>和<code class="eh mj mk ml lh b">getMatch</code>函数。请注意，这些只是将调用转发给oracle，并返回结果。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="6eec" class="ll ke hu lh b fv lm ln l lo lp">function getBettableMatches() public view returns (bytes32[]) {... </span><span id="b4d0" class="ll ke hu lh b fv mm ln l lo lp">function getMatch(bytes32 _matchId) public view returns ( ....</span></pre><p id="59a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mj mk ml lh b">placeBet</code>函数是一个非常重要的函数(第108行)。</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="a892" class="ll ke hu lh b fv lm ln l lo lp">function placeBet(bytes32 _matchId, uint8 _chosenWinner) public payable { ...</span></pre><p id="084e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个的一个显著特征是<code class="eh mj mk ml lh b">payable</code>修改器；我们一直忙于讨论一般的语言特性，以至于我们还没有触及核心的重要特性，即能够随函数调用一起发送资金！这就是它的基本内容——它是一个函数，可以接受一定数量的钱，以及发送的任何其他参数和数据。</p><p id="4635" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在这里需要它，因为这是用户同时定义他们要下什么注，他们打算在那个注上押多少钱，并实际发送钱的地方。<code class="eh mj mk ml lh b">payable</code>修改器可以实现这一点。在接受赌注之前，我们会进行一系列检查，以确保赌注的有效性。第111行的第一个检查是:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="4637" class="ll ke hu lh b fv lm ln l lo lp">require(msg.value &gt;= minimumBet, "Bet amount must be &gt;= minimum bet");</span></pre><p id="15c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">发送的金额存储在<code class="eh mj mk ml lh b">msg.value</code>中。假设所有检查都通过了，在第123行，我们将把该金额转移到oracle的所有权中，将该金额的所有权从用户手中夺走，并转移到契约的所有人手中:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="3211" class="ll ke hu lh b fv lm ln l lo lp">address(this).transfer(msg.value);</span></pre><p id="2ef4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，在第136行，我们有一个测试/调试助手函数，它将帮助我们知道该契约是否连接到有效的oracle:</p><pre class="js jt ju jv fq lg lh li lj aw lk dt"><span id="d92e" class="ll ke hu lh b fv lm ln l lo lp">function testOracleConnection() public view returns (bool) { <br/>     return boxingOracle.testConnection(); <br/>}</span></pre><h1 id="a7ba" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">包扎</h1><p id="5d42" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><em class="jp">这个例子实际上已经到此为止了；只是接受赌注。</em>为了使这个例子足够简单，我们特意省略了划分奖金和支付的功能以及一些其他逻辑，这只是为了演示oracle与合同的使用。更完整和复杂的逻辑存在于当前的另一个项目中，它是这个例子的扩展，并且仍在开发中。</p><p id="cb77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在我们对代码库有了更好的理解，并把它作为一个载体和出发点来讨论Solidity提供的一些语言特性。这个由三部分组成的系列文章的主要目的是演示和讨论如何使用oracle合同。这一部分的目的是更好地理解这个特定的代码，并将其作为理解可靠性和智能契约开发的一些特性的起点。第三部分也是最后一部分的目的是讨论oracle使用的策略和理念，以及它如何在概念上融入智能合同模型。</p><h1 id="8b5e" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">其他可选步骤</h1><p id="6975" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我强烈建议希望了解更多信息的读者阅读并使用这段代码。实现新功能。修复任何错误。实现未实现的功能(如支付接口)。测试函数调用。修改它们并重新测试，看看会发生什么。添加一个web3前端。添加删除匹配或修改其结果的功能(以防出错)。取消的比赛怎么办？实现第二个oracle。当然，一个契约可以自由地使用尽可能多的神谕，但是这会引发什么问题呢？从中得到乐趣；这是一种很好的学习方式，当你这样做(并从中获得乐趣)时，你肯定会记住更多你所学到的东西。</p><p id="6755" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个简单的、不全面的尝试清单:</p><ul class=""><li id="8ca8" class="mn mo hu it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv dt translated">在本地testnet(在truffle中，如第1部分所述)中运行契约和oracle，并调用所有可调用函数和所有测试函数。</li><li id="6fac" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">增加计算奖金的功能，并在比赛结束后支付奖金。</li><li id="bc31" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">增加了在抽奖的情况下退还所有赌注的功能。</li><li id="c755" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">添加一个功能，要求退款或取消赌注，比赛开始前。</li><li id="68e1" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">添加一个功能，以考虑到比赛有时会被取消的事实(在这种情况下，每个人都需要退款)。</li><li id="1227" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">实现一个功能，以保证用户下注时所在的oracle就是将用于确定匹配结果的oracle。</li><li id="3cf0" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">实现另一个(第二个)oracle，它具有一些不同的相关特性，或者可能提供拳击以外的运动(注意，参与者计数和列表允许不同类型的运动，所以我们实际上并不仅限于拳击)。</li><li id="5e67" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">实现<code class="eh mj mk ml lh b">getMostRecentMatch</code>,以便它实际上返回最近添加的匹配，或者在发生时间方面最接近当前日期的匹配。</li><li id="aef0" class="mn mo hu it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv dt translated">实现异常处理。</li></ul><p id="fcc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦您熟悉了契约和oracle之间的关系机制，在这个三部分系列的第3部分中，我们将讨论这个例子提出的一些战略、设计和哲学问题。</p></div><div class="ab cl ne nf hc ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hn ho hp hq hr"><p id="9995" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">最初发表于</em><a class="ae jq" href="https://www.toptal.com/ethereum/ethereum-solidity-oracle-contracts-pt2" rel="noopener ugc nofollow" target="_blank"><em class="jp">【www.toptal.com】</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>