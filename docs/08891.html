<html>
<head>
<title>How to Not Destroy Millions in Smart Contracts (Pt.2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在智能合约中不毁掉数百万美元(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-not-destroy-millions-in-smart-contracts-pt-2-85c4d8edd0cf?source=collection_archive---------2-----------------------#2018-10-27">https://medium.com/hackernoon/how-to-not-destroy-millions-in-smart-contracts-pt-2-85c4d8edd0cf?source=collection_archive---------2-----------------------#2018-10-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="9e1c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">介绍</h1><p id="fff9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><a class="ae kn" href="https://hackernoon.com/how-to-not-destroy-millions-in-smart-contracts-pt-1-bdefac3656b7" rel="noopener ugc nofollow" target="_blank">在本系列的第1部分</a>，我们学习了Solidity编程语言、智能合约初级读本，并了解了一些被利用来从智能合约中榨干资金的基本攻击和漏洞。在本文中，我们将通过研究现实世界中的黑客并对其进行遍历来进一步了解这些知识。</p><h1 id="b380" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">示例#1:奇偶校验“破解”#1</h1><ul class=""><li id="1491" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">TL；DR —在<a class="ae kn" href="https://twitter.com/paritytech?lang=en" rel="noopener ugc nofollow" target="_blank">奇偶校验Multisig </a>钱包版本1.5+上发现了一个漏洞，该漏洞允许攻击者窃取<strong class="jr hv"> 15万以太(当时为3000万美元，今天为1.05亿美元以太/700美元)。</strong></li><li id="a8dd" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">加文·伍德，最初的Solidity开发者之一，是奇偶校验的CTO。我们要检查的代码实际上是他写的。</li><li id="bc0b" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">奇偶校验提供给用户的一个功能是multisig。Multisig是一个拥有M个所有者的钱包，它需要M个签名(确认)中的N个来使用这些资金。基本上，奇偶校验提供了开箱即用的“托管人”。</li><li id="e37a" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">恶意黑客能够锁定特定的multisig钱包，窃取上述金额。如果不是一个白人黑客组织，攻击者可能会窃取更多。白人黑客利用这一漏洞抽干了他们能找到的所有钱包，这样恶意黑客就无法获得更多资金。几周后，白人黑客归还了他们抽走的所有资金。按今天的价格计算，白人黑客节省了大约2 . 64亿美元。</li></ul><p id="8646" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated"><strong class="jr hv">那么这里发生了什么？</strong></p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/d4430d4c3186b426e36ee1dd4ffa5e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AgCRxYgdgcSRkOJ5cq00jQ.png"/></div></div></figure><p id="7124" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">奇偶校验有一个图书馆叫做WalletLibrary。它被部署到以太坊网络，并由multisig wallets智能合约重用，这样人们就不会花太多的时间重新部署图书馆。这个钱包库有很好的修饰符，只有<em class="lc">个所有者</em>和<em class="lc">个所有者。</em>需要注意的是，所有这些修饰符都使用状态变量来查看谁是所有者、有多少确认等等。看看下面的两个片段。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lu"><img src="../Images/604ceba545228146b6b9eff3dbfd5d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6ZhJw3c_VXuQWIYFDyAbg.png"/></div></div></figure><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lv"><img src="../Images/293316f68313bc1a1318b903fa11c77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBJ1Mt2HEpd5-vlQhrgmzA.png"/></div></div></figure><p id="9d2d" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">然后我们有了这个有趣而可疑的函数，名为<em class="lc"> initWallet </em>，用于在构造函数中初始化钱包。该函数的参数是一个所需的<em class="lc">所有者数组，代表确认交易所需的所有者数量。这里有什么引人注目的？该函数没有显式声明的可见性！</em></p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lw"><img src="../Images/6b7e3bf4c819686f0d81f0af40f6b35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Hn89QUuKN8a-q20UafmxQ.png"/></div></div></figure><p id="d5fe" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">等等，也许initDayLimit 或initMultiOwned 有某种类型的保护或修改？</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lx"><img src="../Images/45256de3d3d00fb83fa12c16d84152d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39_hxC6w2w0ri5Ws4UejNQ.png"/></div></div></figure><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ly"><img src="../Images/38073beaa266937b22fabdb3780d6155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Nv66q23f0Y73aTm2OU_kQ.png"/></div></div></figure><p id="894e" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated"><strong class="jr hv"> <em class="lc">不，它们也没有定义可见性！所以基本上initWallet谁都可以调用！！！！</em>T25】</strong></p><p id="7bc9" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">但是，等等……在这之前，我们已经检查了WalletLibrary。这个库被钱包契约使用，它实际上不是它的一部分。所以如果钱包合同没问题，这就不是问题了？我们来看看钱包合同。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lz"><img src="../Images/7a25484362478110bbc8906dd7317a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRTxu6AOIVOD5vzBMJhjcg.png"/></div></div></figure><p id="4866" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">你可以看到在钱包中我们有一个钱包库状态变量，我们有那些<em class="lc">委托调用。</em></p><blockquote class="ma mb mc"><p id="2ee6" class="jp jq lc jr b js ld ju jv jw le jy jz md lf kc kd me lg kg kh mf lh kk kl km hn dt translated"><em class="hu">此外:</em> delegateCalls <em class="hu">接受编码的消息数据、编码的函数名和编码的参数。</em></p></blockquote><p id="fd1f" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">这正是所发生的事情。</p><p id="7b1d" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">关注带有应付款修饰符的<em class="lc"> fallback函数，我们看到它是公共的。<strong class="jr hv">我们可以注意到上面的3个委托调用都来自公共方法！</strong>这很有意义，因为我们希望任何人都能够调用它。但是因为其余的函数也是公共的，所以攻击者可以使用代表initWallet函数名、数据和预期参数的编码数据来调用delegateCall，并将自己设置为所有者！这正是所发生的事情。攻击者利用了这一点，简单地将契约的<strong class="jr hv"> m_owners </strong>状态变量更改为一个只包含其地址的列表，并且只需要<strong class="jr hv">一次</strong>确认就可以执行任何事务。</em></p><h2 id="3914" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">减轻</h2><ul class=""><li id="3988" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">复杂性是一个弱点。<strong class="jr hv">保持简单愚蠢。过度优化和复杂是所有罪恶的根源！</strong></li><li id="f904" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">总是明确定义可见性。</li><li id="46f0" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">不要将构造器逻辑提取到库契约中。避免过早优化！</li><li id="629e" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">不要使用delegateCall作为一种无所不包的转发机制。</li></ul><h2 id="9b67" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">缓解:奇偶校验开发人员的修复:</h2><p id="79b9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">奇偶校验开发者做了两件事。</p><ol class=""><li id="7c26" class="ko kp hu jr b js ld jw le ka mu ke mv ki mw km mx ku kv kw dt translated">他们声明initDayLimit和initMultiowned是内部的。</li><li id="1810" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km mx ku kv kw dt translated">他们添加了一个名为<em class="lc">only _ un initialized</em>的修饰符，表示如果我已经有了所有者，那么就恢复。他们将这个修饰符添加到了initWallet，，所以本质上它不能被调用两次。看起来不错…但是有一个巨大的bug！我们稍后再讨论这个问题！</li></ol><p id="b504" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated"><a class="ae kn" href="https://github.com/paritytech/parity-ethereum/commit/b640df8fbb964da7538eef268dffc125b081a82f" rel="noopener ugc nofollow" target="_blank">这里有一个链接</a>指向为修复这个漏洞而部署的补丁。评论跟帖很有意思！</p><h1 id="3225" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">例2: Rubixi</h1><ul class=""><li id="13ac" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">Rubixi是一份合同，其执行让人联想到据称的金字塔计划。(虽然不是传销！)</li><li id="9617" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">投资者可以存入资金。</li><li id="640e" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated"><strong class="jr hv">所有者</strong>可以收集所有的资金。</li><li id="3606" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">如果你带更多的人加入这个智能合同，你会得到他们的部分费用。</li></ul><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff my"><img src="../Images/73dd6642e5cf0b700704b8a01c5eac98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*mMe6yG0ysrNy3araw7touw.png"/></div></figure><p id="157e" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">有一个名为creator的成员在构造函数中初始化。我们有<em class="lc"> onlyOwner </em>修饰符，只有当你是正确的所有者时，它才会执行代码。此外，我们有办法根据这个修改量来收费。</p><h2 id="8afb" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">那么这里出了什么问题呢？！</h2><p id="2d48" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最初的合同名称和建造商是<em class="lc"> DynamicPyramid。</em></p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/a021a782e06d0c56755fbe2aa0f2190a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*5X-S4bZ0jXbnEjf2nqNsag.png"/></div></figure><p id="ae66" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">创造者们改变了主意，认为也许带有“金字塔”这个词的东西市场前景不好。他们把名字改成了Rubixi，忘了改构造函数方法的名字；)因为<em class="lc"> DynamicPyramid </em>函数是公共的，任何人都可以调用它，并设置自己是合同创建者！有一份合同损失了100吨乙醚，另一份合同损失了约0.1吨乙醚。</p><h2 id="57e0" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">减轻</h2><ul class=""><li id="cd9e" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">嗯，首先，尽量不要误命名函数…</li><li id="db11" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">保持警惕！！骗子越来越厉害了。</li><li id="10eb" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">从<strong class="jr hv"> 0.4.22开始，</strong>你现在可以使用安全的<strong class="jr hv">构造函数</strong>方法来代替。这意味着您可以改为执行以下操作。</li></ul><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff na"><img src="../Images/227db22269af532251362696ca312ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*KL8kcKGw6oPRt7lAxTygBg.png"/></div></figure><h1 id="bc74" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">示例#3:银行，智能合同(重入)</h1><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/b634dc53f68eae5d6fdc731a7679d905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*x-VHElJVNiFqBpNmnpudCw.png"/></div></figure><p id="376a" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">我们有一个叫做银行的智能合约。每个用户都有余额，用户可以存入资金，这将立即用多少资金可用来更新状态变量。我们可以使用<em class="lc">取款</em>功能取出资金，然后这些资金被发送给我们。</p><h2 id="1211" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">有什么问题？</h2><p id="aa95" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">首先，需要注意的是<em class="lc">断言</em>是一个<strong class="jr hv">阻塞同步调用。</strong>因此，在assert语句完成之前，余额不会更新。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/2d5b07c5f20d755ccee5a6c8b21bb360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*rMIpg5SOvivQW9yqSAQUbA.png"/></div></figure><p id="861a" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">如果存款实体是一个用户，这很好，但是如果它是一个智能契约，会发生什么呢？如果存放资金的实体<strong class="jr hv">是智能合同而不是用户</strong>，那么<strong class="jr hv">将这些资金发送到智能合同将触发应付回退功能</strong>(如果它存在或失败)。该回退功能将在原始交易完成之前返回银行并再次取款。银行合同通过更新余额来防止这种情况，但这只是在潜在攻击者可以提取两次之后。这种类型的攻击(bug？)叫做<strong class="jr hv">再入</strong>。</p><p id="579e" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">让我们来看一个名为<em class="lc"> Robber </em>的恶意智能合约的例子，它将通过一个可重入错误来利用<em class="lc"> Bank </em>智能合约。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/dde6acc45d5e80cc926df38ed55875dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*5GiLK231NJqL_eb8BsCymg.png"/></div></figure><p id="6b5f" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">每份合同我们只能做两次。但是，如果它的工作，我们可以创建和部署许多合同，并重复这样做，直到我们耗尽银行！</p><p id="59fc" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated"><strong class="jr hv">缓解#1:检查-效果-交互模式</strong></p><ul class=""><li id="a636" class="ko kp hu jr b js ld jw le ka mu ke mv ki mw km kt ku kv kw dt translated"><strong class="jr hv">执行检查</strong>(谁调用了函数，参数是否在范围内，他们是否发送了足够的以太，这个人是否有令牌，等等。).</li><li id="5b92" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">如果所有检查都通过，<strong class="jr hv">应对当前合同的状态变量产生影响</strong>。</li><li id="6221" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated"><strong class="jr hv">最后，与其他账户/合同进行任何互动。为了让例子更清楚，这就是我们的合同失败的地方。它在完成<strong class="jr hv">影响</strong>所有状态变量之前，与<em class="lc">强盗</em>智能契约进行了交互。</strong></li></ul><p id="82c9" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">通过利用这种模式，我们可以确保即使有一个<strong class="jr hv">重入</strong>问题，检测<strong class="jr hv">也会失败。因此，按照这种模式，对我们的<em class="lc">银行契约</em>的修复将首先影响状态变量——在本例中是余额，然后调用智能契约/用户:</strong></p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/63a2d623dc96e30965209ccc0014e012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*k0sMTciuBFgBNJlK1khGpw.png"/></div></figure><h2 id="57e7" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">缓解#2:避免call.value()()</h2><p id="628e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在以太坊中，有3种方式可以与其他智能合约进行隐式交互。当发送以太网时，我们应该意识到它们的使用之间的相对权衡:</p><ol class=""><li id="1c25" class="ko kp hu jr b js ld jw le ka mu ke mv ki mw km mx ku kv kw dt translated"><strong class="jr hv"> address.call.value(): </strong>将发送所提供的以太和触发代码执行给定<strong class="jr hv">所有可用气体。因此，在银行/劫匪的例子中，</strong>如果用户/智能合同发送了足够的gas，他可以完成执行重入。</li><li id="00ad" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km mx ku kv kw dt translated"><strong class="jr hv"> address.send(): </strong>将发送提供的以太网并触发代码执行，给定<strong class="jr hv">2300燃气的有限津贴。</strong>这是相似的，但天然气是有上限的，基本上足以一直获得资金。任何更复杂的事情都会因一个<strong class="jr hv"> <em class="lc">出气异常</em> </strong>而失败。</li><li id="e6f5" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km mx ku kv kw dt translated"><strong class="jr hv"> address.transfer(): </strong>相当于<strong class="jr hv"> require(address.send())。如果发送失败，它会自动恢复。</strong></li></ol><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/dd9bb890372a651db88e87ce1c301f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*C16UzonxyZNQqBzgzva-IQ.png"/></div></figure><h1 id="4118" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">例4:“道”</h1><ul class=""><li id="5f9a" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">“DAO”是一个特定DAO(去中心化自治组织)的名称，由德国start Slock.it背后的团队构思和编程，该公司建造“智能锁”，让人们在Airbnb的去中心化版本中共享他们的东西(汽车、船、公寓)。</li><li id="500c" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">它将作为<a class="ae kn" href="https://www.coindesk.com/ethereum-classic-explained-blockchain/" rel="noopener ugc nofollow" target="_blank">分散风险投资基金</a>资助dapp(分散应用),参与者可以投票决定哪些dapp获得资助。</li><li id="de01" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">它于2016年4月30日推出，资金窗口为28天。</li><li id="2a95" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">这是历史上最大的众筹，从11，000多名热情的成员那里筹集了超过150，000，000美元(按照今天的价格是几十亿美元)。</li><li id="d096" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">2016年6月18日，攻击者开始使用相对复杂的重入攻击来耗尽“道”。</li><li id="d776" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">攻击者已经设法消耗了超过3，600，000乙醚(当时为72，000，000美元；今天达到惊人的25.2亿美元瑞士法郎/美元700元)</li><li id="b856" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">以太坊社区是如何回应的？</li></ul><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ne"><img src="../Images/990c7f4ece1587c50cb44aafbe916c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*le11sO3Rqpzh9oqIv_UKYw.png"/></div></div></figure><p id="2939" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">社区的反应是分裂成两个，又名<strong class="jr hv"> <em class="lc">硬分叉</em> </strong>！那些相信黑客是合法的(<strong class="jr hv">代码就是法律)</strong>留在了网络上，被称为<strong class="jr hv">以太坊经典。分叉者形成了一个新的网络，在那里他们恢复了所有丢失的钱，并被称为(普通的)以太坊。</strong></p><h1 id="95ad" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">例子5:蜜罐</h1><p id="e2da" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这里我们有一个资产智能合同。这是一个演示概念的玩具例子，请耐心听我说；)本来资产合同的创建者就是这个资产的所有者。任何人都可以向此合同发送资金。如果有人出价高于该智能合约中的资金金额，那么您将成为该资产的所有者，并获得该资产的所有资金。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/23f206db29d208ec1bf2a2fee6dce543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*NPcl_lrFkK4WdGt95urhnw.png"/></div></figure><p id="a39d" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">有哪些情况下<em class="lc"> if语句可以成立</em>？</p><p id="b3b4" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">这永远不会是真的！这是因为在到达该代码之前，余额已用值<strong class="jr hv">更新。这种类型的合同有两个版本，其中第一个消耗20以太，第二个消耗5以太，从出价的人</strong></p><h1 id="b1e8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">“替代”乙醚转移</h1><p id="c6cf" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">到目前为止，我们已经研究了转移以太的显式方法。让我们看看一些不太为人所知/受欢迎的转会选择。</p><p id="d22b" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">除了发送以太网的常规方式(如呼叫、发送/转移)，还有两种方式<strong class="jr hv">绕过回退功能。</strong></p><ul class=""><li id="0348" class="ko kp hu jr b js ld jw le ka mu ke mv ki mw km kt ku kv kw dt translated"><strong class="jr hv">自毁</strong>:从<a class="ae kn" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>中删除代码的唯一可能是当该地址的一个契约执行<strong class="jr hv">自毁</strong>操作时(以前称为<strong class="jr hv">自杀)。这是实现自毁调用以从网络中移除不再有用的合同的动机。</strong>自毁程序接收一个地址参数，该参数指定将被销毁的合同的资金转移到哪里。</li><li id="0ca7" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">如果接收地址是一个<strong class="jr hv">合同，</strong>它的回退功能<strong class="jr hv">不会被执行。这是一个奇怪的边角案例/ <a class="ae kn" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>在坚固性上的选择。</strong></li><li id="52e8" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">作为一名矿工，将目标地址设置为coinbase地址，以便获得区块挖掘奖励。</li></ul><p id="4098" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">让我们看一个例子。每次有人向<strong class="jr hv">genous attack</strong>契约发送资金时，我们都会自毁并将资金发送到<strong class="jr hv">genous attack</strong>构造函数中确定的地址。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/806304f6b717cab5cd3f7ccd492ae6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*j-5bX_5LgQhjfaG9n19tag.png"/></div></figure><p id="6fef" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">因此，每次用户向该合同转账时，存储在该合同中的值都会被转移到预先确定的目标，而无需显式转移。当心！如果你不完全了解这门语言，你可以通读它，并认为它是无辜的！</p><h1 id="d5b8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">缓解:小心假设</h1><ul class=""><li id="6741" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">永远不要用合约的余额作为警戒</li><li id="ca94" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">一般来说，要注意语言/框架特定的特性和更新。</li></ul><ol class=""><li id="0651" class="ko kp hu jr b js ld jw le ka mu ke mv ki mw km mx ku kv kw dt translated">小心编译器优化和错误，并进行相应的测试。</li><li id="41bc" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km mx ku kv kw dt translated">当心编译器特定的错误，并且总是使用严格的编译器版本。</li><li id="ca02" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km mx ku kv kw dt translated">小心潜在矿工的干预(例如，抢跑，链重组等)。</li></ol><h1 id="8a53" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">示例#6:奇偶校验“破解”#2</h1><h2 id="7f7a" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">TL；博士:</h2><p id="1c52" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">有人打开了平价钱包的Github问题，并说“嘿，我不小心杀了它”。实际上，他找到了删除智能合同的方法。突然间，他们的许多钱包都在使用一个可以被删除并不复存在的库！</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff nh"><img src="../Images/cf5acbf71555dc87ca9fae18889715d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFf6h22uqESryKsfG6UCEg.png"/></div></div></figure><ul class=""><li id="8b1b" class="ko kp hu jr b js ld jw le ka mu ke mv ki mw km kt ku kv kw dt translated">大约513，000 ETH被锁定在受影响的合同中。</li><li id="64be" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">没有资金被“盗”；只是因为一场意外而无法触及。</li><li id="c33b" class="ko kp hu jr b js kx jw ky ka kz ke la ki lb km kt ku kv kw dt translated">有一些关于恢复损失资金的方法的建议，甚至是新的治理模式，但这不太可能很快发生。</li></ul><h2 id="b5ad" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">这里发生了什么？</h2><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ni"><img src="../Images/f586f26b17d85da06db180b4208827b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qTaLATFGdtXlox322xPMA.png"/></div></div></figure><p id="1e5a" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">如果你还记得，我们有这个唯一的未具体化修饰符。你可以看到这个库使用了许多状态变量。但是这些状态变量在哪里声明和初始化呢？</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff nj"><img src="../Images/885a6a46954d0b2febb13eef04a434d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uwGtpQG2NIadlO2bBfHqg.png"/></div></div></figure><p id="a420" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">我们搜索了所有用于创建奇偶钱包的契约，发现这些状态变量是在<strong class="jr hv">钱包契约中定义的。</strong></p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff nk"><img src="../Images/0cca5997f9124ab34c8c49438b1a603f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKEX6wdi7y6RWULApVOFPw.png"/></div></div></figure><p id="d8e0" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated"><strong class="jr hv"> WalletLibrary </strong>契约包含状态变量，它期望这些变量被调用契约自身的状态<strong class="jr hv">遮蔽</strong>。</p><p id="a016" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">一旦部署，WalletLibrary契约只是未初始化，所以<strong class="jr hv"> m_numOwners </strong>是0。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/936990c4f1114ac9ba6061ea9700bb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*_53Ik1nALxmTfnJ598Humg.png"/></div></figure><ul class=""><li id="f534" class="ko kp hu jr b js ld jw le ka mu ke mv ki mw km kt ku kv kw dt translated">如果WalletLibrary没有在<strong class="jr hv"> Wallet契约的上下文中执行，m_numOwners为0，</strong>允许任何人调用这个修饰符保护的方法，其中一个是<strong class="jr hv"> initWallet </strong>。</li></ul><h2 id="fa57" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">这是如何被利用的？</h2><p id="6b34" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">某开发者调用<strong class="jr hv"> <em class="lc"> initWallet </em> </strong>并将自己设置为唯一拥有者，然后通过调用<strong class="jr hv"> <em class="lc"> kill </em> </strong>函数进行杀死。发现这个bug的开发者有一个Github句柄<strong class="jr hv"> devops199 </strong>然后发了这个</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff nm"><img src="../Images/563a284f06bff5ea34eb3fbd448ea069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bU2Jhtl5DitrWxOAIFBJtg.png"/></div></div></figure><h1 id="b8ba" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">例7:拍卖合同</h1><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/8a0e659f25d61cde618a8cb2cbaf588e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*GOcZBcP1R2Ym4PkmUYr5xg.png"/></div></figure><p id="00b6" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">因此，用户可以进行拍卖出价，如果出价最高，他们就可以获得资金。但是如果<strong class="jr hv"> <em class="lc">转移</em> </strong>方法失败了会怎么样呢？</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/911f3e04c4c847107b5c7f689c6e0680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*E477xsM-obaUqDcj2mNG-A.png"/></div></figure><p id="c619" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">想象一下，就在拍卖开始时，我们出价很低，成为了所有者。然后，如果有人出价高于我们，我们不知何故使转让失败，那么我们将永远成为拍卖的领导者，但仍然保持新的最高出价！让我们来看看这是如何工作的。让我们简单地创建一个不实现可支付回退功能的合同，这样就不可能向我们发送资金。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div class="fe ff no"><img src="../Images/1a0774b1ef2919a0b38f70b7016c243f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*HipfyfefZu5Tr4n_3-raJA.png"/></div></figure><h2 id="80e7" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">缓解#1:支持拉推</h2><ul class=""><li id="b526" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">永远记住，你不仅是在与人类互动，也是在与其他契约互动。</li></ul><p id="c4c8" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">我们还可以通过实施退款机制来缓解这一问题。本质上，我们将持有每个用户贡献的资金的地图，并实现一个<em class="lc">取款</em>功能，允许每个人都要求他们的资金回来。</p><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lw"><img src="../Images/698c50641d8b02a8e74fd58ebf5ab088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCSKK6sor1Eu8EzhRIjTCg.png"/></div></div></figure><h2 id="67e5" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">缓解#2:忽略合同</h2><ul class=""><li id="c2a1" class="ko kp hu jr b js jt jw jx ka kq ke kr ki ks km kt ku kv kw dt translated">通常不建议或不希望这样做，但是也可以通过以下检查选择不与合同交互:</li></ul><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff np"><img src="../Images/4fafb5f4f6c4401d1c15166a0b446459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*GoWPnaBeS9jdH5oX0uaVkw.png"/></div></div></figure><h1 id="4554" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="c79a" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">智能合同是一个术语，通常与<strong class="jr hv"> <em class="lc">不信任环境同义。尽管智能合同去除了中间人和集中的合同执行者，但这些黑客行为证明确实存在信任因素。我们不相信一家公司或一群律师，而是相信代码以及编写和审核这些合同的开发人员。</em></strong></p><p id="a5e8" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">虽然代码容易出错，但我相信智能合同社区将继续提高他们编写智能合同的熟练程度。开发人员变得越来越有经验，从过去的错误中学习，并且不断开发更好的工具来帮助分析契约逻辑/测试。我对未来的智能合约感到兴奋，并相信它们在未来几年将越来越受欢迎。</p><p id="2a03" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">我的下一篇文章将探索智能合约和分布式应用程序开发(dapps ),敬请关注！</p><p id="a2b6" class="pw-post-body-paragraph jp jq hu jr b js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km hn dt translated">如果你正在寻找区块链世界的资源，我强烈推荐(再次)去看看Youtube频道的<a class="ae kn" href="https://www.youtube.com/channel/UCZ0z9fRKhW-GEjQs-_Jxfyg" rel="noopener ugc nofollow" target="_blank"> Kin生态系统</a>，那里有很多高质量的技术讨论和讲座。非常感谢<a class="ae kn" href="https://www.linkedin.com/in/leonidb/" rel="noopener ugc nofollow" target="_blank"> Leonid Beder </a>建立这个讲座并在区块链学院教授它！</p><h2 id="8656" class="mg is hu bd it mh mi mj ix mk ml mm jb ka mn mo jf ke mp mq jj ki mr ms jn mt dt translated">如果这篇文章有帮助，请订阅并点击鼓掌👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">你可以在<a class="ae kn" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae kn" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>、<a class="ae kn" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我。</p><figure class="lj lk ll lm fq ln"><div class="bz el l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>