<html>
<head>
<title>Learn C++ Multi-Threading in 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5分钟学会C++多线程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/learn-c-multi-threading-in-5-minutes-8b881c92941f?source=collection_archive---------0-----------------------#2018-10-28">https://medium.com/hackernoon/learn-c-multi-threading-in-5-minutes-8b881c92941f?source=collection_archive---------0-----------------------#2018-10-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4783" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated"><strong class="ak">摘要</strong>:一个非常简洁的关于C++14多线程结构的速成班</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/7405a263272b45c6e0466d8d5df522b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*IIVCDmZJ2gAdnaWw8sKUxA.png"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Multi Threading in C++</figcaption></figure><p id="2795" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">新的C++多线程结构非常容易学习。如果你熟悉C或C++并且想开始编写多线程程序，那么这篇文章就是为你准备的！</p><p id="9b29" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我使用C++14作为参考，但是我描述的内容在C++17中也是受支持的。我只介绍常见的构造。看完这篇文章，你应该能够编写自己的多线程程序了。</p><h1 id="2069" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">更新(2020年6月):</h1><p id="dd05" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">我制作了几个关于C++多线程的视频。请点击此处查看:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lo lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">C++ Multi Threading (Part 1) Creating Threads and Tasks</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lo lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Multi Threading (Part 2): Mutex and Conditional Variables in C++</figcaption></figure><h1 id="9a38" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">创建线程</h1><p id="0b07" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">可以通过多种方式创建线程:</p><ol class=""><li id="f422" class="lq lr hu jx b jy jz kb kc ke ls ki lt km lu kq lv lw lx ly dt translated">使用函数指针</li><li id="4fc0" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">使用函子</li><li id="dc2a" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">使用<a class="ae me" href="https://en.cppreference.com/w/cpp/language/lambda" rel="noopener ugc nofollow" target="_blank">λ函数</a></li></ol><p id="02c2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这些方法非常相似，只有细微的差别。接下来我将解释每种方法及其区别。</p><h2 id="221d" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">使用函数指针</h2><p id="56dc" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">考虑下面的函数，它有一个向量引用<code class="eh mt mu mv mw b">v</code>，一个对结果的引用<code class="eh mt mu mv mw b">acm</code>，以及向量中的两个索引<code class="eh mt mu mv mw b">v</code>。该功能添加了<code class="eh mt mu mv mw b">beginIndex</code>和<code class="eh mt mu mv mw b">endIndex</code>之间的所有元素。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">A function calculating the sum of all elements between <code class="eh mt mu mv mw b">beginIndex and endIndex in a vector v</code></figcaption></figure><p id="8aca" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，假设您想将向量分成两个部分，并在单独的线程<code class="eh mt mu mv mw b">t1</code>和<code class="eh mt mu mv mw b">t2</code>中计算每个部分的总和:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Creating threads using function pointers</figcaption></figure><h2 id="4f78" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">你需要带走什么？</h2><ol class=""><li id="7161" class="lq lr hu jx b jy lj kb lk ke my ki mz km na kq lv lw lx ly dt translated"><code class="eh mt mu mv mw b">std::thread</code>创建一个新线程。第一个参数是函数指针的名字<code class="eh mt mu mv mw b">accumulator_function2</code>。因此，每个线程都会执行这个函数。</li><li id="40e5" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">传递给<code class="eh mt mu mv mw b">std::thread</code>构造函数的其余参数是我们需要传递给<code class="eh mt mu mv mw b">accumulator_function2</code>的参数。</li><li id="b598" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated"><strong class="jx hv">重要提示:</strong>所有传递给<code class="eh mt mu mv mw b">accumulator_function2</code>的参数都是按值传递的，除非你把它们包装在<code class="eh mt mu mv mw b">std::ref</code>里。这就是为什么我们把<code class="eh mt mu mv mw b">v</code>、<code class="eh mt mu mv mw b">acm1</code>和<code class="eh mt mu mv mw b">acm2</code>包在了<code class="eh mt mu mv mw b">std::ref</code>里。</li><li id="7e30" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">由<code class="eh mt mu mv mw b">std::thread</code>创建的线程没有返回值。如果你想返回某个东西，你应该把它存储在一个通过引用传递的参数中，也就是<code class="eh mt mu mv mw b">acm</code>。</li><li id="792b" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">每个线程一创建就启动。</li><li id="3059" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">我们使用<code class="eh mt mu mv mw b">join()</code>函数来等待一个线程完成</li></ol><h2 id="6c1e" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">使用函子</h2><p id="1106" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">你可以用仿函数做同样的事情。以下是使用仿函数的代码:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Functor Definition</figcaption></figure><p id="4be6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">创建线程的代码是:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Creating threads using functors</figcaption></figure><h2 id="29ba" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">你需要带走什么？</h2><p id="5201" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">一切都与函数指针非常相似，除了:</p><ol class=""><li id="cdea" class="lq lr hu jx b jy jz kb kc ke ls ki lt km lu kq lv lw lx ly dt translated">第一个参数是仿函数对象。</li><li id="5e3f" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">我们可以将它的返回值存储在仿函数内部的一个成员变量中，也就是存储在<code class="eh mt mu mv mw b">_acm</code>中，而不是将一个引用传递给仿函数来存储结果。</li></ol><h2 id="0e23" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">使用Lambda函数</h2><p id="4ced" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">作为第三种选择，我们可以在lambda函数中定义每个线程，如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Creating threads using lambda functions</figcaption></figure><p id="0b9a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">同样，一切都非常类似于函数指针，除了:</p><ol class=""><li id="48ce" class="lq lr hu jx b jy jz kb kc ke ls ki lt km lu kq lv lw lx ly dt translated">作为传递参数的替代方法，我们可以使用lambda capture传递对lambda函数的引用。</li></ol><h1 id="36e6" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">任务、未来和承诺</h1><p id="e120" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">作为<code class="eh mt mu mv mw b">std::thread</code>的替代，你可以使用<code class="eh mt mu mv mw b">tasks</code>。</p><p id="751f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">任务的工作方式与线程非常相似，但主要区别在于它们可以返回值。因此，你可以把它们作为定义线程的一种更抽象的方式来记忆，并在线程返回值时使用它们。</p><p id="0bc6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面是使用任务编写的相同示例:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div></figure><h2 id="c6cb" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">你需要带走什么？</h2><ol class=""><li id="ff2e" class="lq lr hu jx b jy lj kb lk ke my ki mz km na kq lv lw lx ly dt translated">使用<code class="eh mt mu mv mw b">std::async</code>定义和创建任务(而不是使用<code class="eh mt mu mv mw b">std::thread)</code>创建线程)</li><li id="12d3" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">从<code class="eh mt mu mv mw b">std::async</code>返回的值称为<code class="eh mt mu mv mw b">std::future</code>。不要被它的名字吓到。它只是意味着<code class="eh mt mu mv mw b">t1</code>和<code class="eh mt mu mv mw b">t2</code>是变量，它们的值将在未来被赋值。我们通过调用<code class="eh mt mu mv mw b">t1.get()</code>和<code class="eh mt mu mv mw b">t2.get()</code>获得它们的值</li><li id="61ee" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">如果未来值未准备好，在调用<code class="eh mt mu mv mw b">get()</code>时，主线程阻塞，直到未来值准备好(类似于<code class="eh mt mu mv mw b">join()</code>)。</li><li id="6e15" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">注意，我们传递给<code class="eh mt mu mv mw b">std::async</code>的函数返回值。这个值通过一个名为<code class="eh mt mu mv mw b">std::promise</code>的类型传递。同样，不要被它的名字吓到。在很大程度上，你不需要知道<code class="eh mt mu mv mw b">std::promise</code>的细节或者定义任何<code class="eh mt mu mv mw b">std::promise.</code>类型的变量——c++库在幕后完成这些工作。</li><li id="e3cc" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">默认情况下，每个任务一创建就开始(有一种方法可以改变这一点，但我不介绍)。</li></ol><h1 id="50cb" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">创建线程摘要</h1><p id="48ae" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">这就是了。创建线程就像我上面解释的那样简单。您可以使用<code class="eh mt mu mv mw b">std::thread</code>:</p><ol class=""><li id="6015" class="lq lr hu jx b jy jz kb kc ke ls ki lt km lu kq lv lw lx ly dt translated">使用函数指针</li><li id="9f86" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">使用函子</li><li id="568d" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">使用λ函数</li></ol><p id="9fba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">或者您可以使用<code class="eh mt mu mv mw b">std::async</code>创建一个任务，并在<code class="eh mt mu mv mw b">std::future</code>中获得返回值。任务也可以使用函数指针、仿函数或lambda函数。</p><h1 id="414a" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">共享内存和共享资源</h1><p id="936c" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">简而言之，线程在读取/写入共享内存和资源(如文件)时应该小心，以避免竞争情况。</p><p id="bba0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">C++14提供了几个结构来同步线程，以避免这种竞争情况。</p><h2 id="750f" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">使用互斥、lock、()和unlock()(不推荐)</h2><p id="3c41" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">下面的代码显示了我们如何创建一个临界区，使得每个线程独占访问<code class="eh mt mu mv mw b">std::cout</code>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div></figure><h2 id="4096" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">你需要带走什么？</h2><ol class=""><li id="7e5b" class="lq lr hu jx b jy lj kb lk ke my ki mz km na kq lv lw lx ly dt translated">互斥体被创建<code class="eh mt mu mv mw b">std::mutex</code></li><li id="3e49" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">使用<code class="eh mt mu mv mw b">lock()</code>创建一个临界区(即保证每次只由一个线程运行)</li><li id="deb2" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">临界区在调用<code class="eh mt mu mv mw b">unlock()</code>时结束</li><li id="2dc2" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">每个线程在<code class="eh mt mu mv mw b">lock()</code>等待，只有当临界区内没有其他线程时，才进入临界区。</li></ol><p id="e008" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">虽然上述方法可行，但不推荐使用，因为:</p><ol class=""><li id="2796" class="lq lr hu jx b jy jz kb kc ke ls ki lt km lu kq lv lw lx ly dt translated">它不是异常安全的:如果lock之前的代码产生异常，<code class="eh mt mu mv mw b">unlock()</code>将不会被执行，我们也不会释放可能导致死锁的互斥体</li><li id="0c69" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">我们必须时刻小心不要忘记打电话给<code class="eh mt mu mv mw b">unlock()</code></li></ol><h2 id="de5c" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">使用std::lock_guard(推荐)</h2><p id="2ca8" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">不要被它的名字<code class="eh mt mu mv mw b">lock_guard</code>吓到。这只是创建临界区的一种更抽象的方式。</p><p id="b42d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面是使用<code class="eh mt mu mv mw b">lock_guard</code>的相同临界区。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">critical section using <code class="eh mt mu mv mw b">lock_guard</code></figcaption></figure><h2 id="8abd" class="mf ks hu bd kt mg mh mi kx mj mk ml lb ke mm mn ld ki mo mp lf km mq mr lh ms dt translated">你需要带走什么？</h2><ol class=""><li id="dabf" class="lq lr hu jx b jy lj kb lk ke my ki mz km na kq lv lw lx ly dt translated">在<code class="eh mt mu mv mw b">std::lock_guard</code>创建后出现的代码被自动锁定。不需要显式的<code class="eh mt mu mv mw b">lock()</code>和<code class="eh mt mu mv mw b">unlock()</code>函数调用。</li><li id="ec63" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">当<code class="eh mt mu mv mw b">std::lock_guard</code>超出范围时，临界段自动结束。这使得它异常安全，而且我们也不需要记得调用<code class="eh mt mu mv mw b">unlock()</code></li><li id="6c7c" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated"><code class="eh mt mu mv mw b">lock_guard</code>仍然需要在其构造函数中使用<code class="eh mt mu mv mw b">std::mutex</code>类型的变量。</li></ol><h1 id="6894" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">我们应该创建多少线程？</h1><p id="37fc" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">您可以创建任意数量的线程，但是如果活动线程的数量超过了可用CPU内核的数量，那么创建线程可能就没有意义了。</p><p id="8789" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了获得最大数量的内核，您可以调用:<code class="eh mt mu mv mw b">std::thread::hardware_concurrency()</code>如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mx lp l"/></div></figure><h1 id="9d6c" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">我没有提到的是</h1><p id="c12e" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">我介绍了创建线程所需的大部分内容。还有几个不太常见的细节，我没有在这里列出，但你可以自己研究一下:</p><ol class=""><li id="8593" class="lq lr hu jx b jy jz kb kc ke ls ki lt km lu kq lv lw lx ly dt translated">标准::移动</li><li id="f31d" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">标准::承诺的详细信息</li><li id="9f08" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">标准::打包任务</li><li id="67fe" class="lq lr hu jx b jy lz kb ma ke mb ki mc km md kq lv lw lx ly dt translated">条件变量</li></ol></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><p id="feb0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">希望这能帮助你快速学习C++多线程。</p><p id="7c71" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你喜欢这篇文章，请点击拍手并给我反馈。</p><p id="75dc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">查看我的<a class="ae me" href="https://youtu.be/335zQkHDWRY" rel="noopener ugc nofollow" target="_blank">其他视频</a>关于回溯算法及其在C++中的实现:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="9ee6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另外，查看我的视频“使用Google Test (GTest)和Google Mock (GMock)的C++单元测试教程”:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lo lp l"/></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/8fe7336c94f568de57a15a755200894c.png" data-original-src="https://miro.medium.com/v2/resize:fit:2/format:webp/0*GWjoewTQm_MPm1Lo.png"/></div></figure></div></div>    
</body>
</html>