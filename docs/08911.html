<html>
<head>
<title>The Request Sent Bad Data; What’s the Response?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">请求发送了错误数据；有什么回应？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-request-sent-bad-data-whats-the-response-94088bd290a?source=collection_archive---------7-----------------------#2018-10-28">https://medium.com/hackernoon/the-request-sent-bad-data-whats-the-response-94088bd290a?source=collection_archive---------7-----------------------#2018-10-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3647" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">看看HTTP 4xx状态码RFC是如何发展的</em></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/512bb42d64aa6c52054e1a1f26152210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8QWRDs0GTovKaLXFlpw_w.jpeg"/></div></div></figure><p id="f19a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">阅读4xx身份代码可能看起来很无聊，但它一直是(<a class="ae kc" href="https://www.bennadel.com/blog/2434-http-status-codes-for-invalid-data-400-vs-422.htm" rel="noopener ugc nofollow" target="_blank">宗教</a>)的来源？)多年来的争论。互联网工程任务组(IETF)已经澄清了<a class="ae kc" href="https://www.quora.com/Which-HTTP-code-is-best-suited-for-validation-errors-400-or-422" rel="noopener ugc nofollow" target="_blank">模糊性</a>的一个<a class="ae kc" href="https://www.quora.com/Is-HTTP-Error-Code-422-WebDAV-specific" rel="noopener ugc nofollow" target="_blank">lot</a>(<em class="jp">改变了</em>可能是一个更好的词)，所以我将看看它过去是什么，现在是什么，以及对你的后果，我的开发伙伴。</p><h1 id="e0a0" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">选择你的毒药</h1><p id="b6a3" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">这里有一个伪测试用例，使用了一个看似合理但不明确的请求库:</p><pre class="jr js jt ju fq lg lh li lj aw lk dt"><span id="95e5" class="ll ke hu lh b fv lm ln l lo lp">const body = {<br/>    title: "Ethel the Aardvark goes Quantity Surveying",<br/>    ISBN: "no clue"<br/>};</span><span id="a2ae" class="ll ke hu lh b fv lq ln l lo lp">request(url, body, {"Content-type":"application/json"})<br/>.then(success)<br/>.catch(failure =&gt; {...})</span></pre><p id="dcb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一切都是正确的:标题是正确的，数据是格式良好的。但是，其中一个值无效(ISBN)，服务器无法处理该请求。有哪些选择？</p><ol class=""><li id="5192" class="lr ls hu it b iu iv iy iz jc lt jg lu jk lv jo lw lx ly lz dt translated">返回<a class="ae kc" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.1" rel="noopener ugc nofollow" target="_blank"> 400错误请求</a>状态</li><li id="7a47" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated">返回一些其他的<a class="ae kc" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4" rel="noopener ugc nofollow" target="_blank"> 4xx状态</a></li><li id="9a82" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated">返回<a class="ae kc" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.1" rel="noopener ugc nofollow" target="_blank"> 200 OK </a>，并在响应体中编码一个错误</li></ol><h1 id="7313" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">关于400状态码的标准曾经说过什么</h1><pre class="jr js jt ju fq lg lh li lj aw lk dt"><span id="280e" class="ll ke hu lh b fv lm ln l lo lp">The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications.</span></pre><p id="a9c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约在1999年。注意，它指定了“格式错误的语法”。在所示的ISBN示例中，没有格式错误的语法…问题只是一个错误的数据值。出于这个原因，人们反对因为坏数据而退回400，因为标准对400的含义非常明确。</p><p id="2908" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">后来，添加了状态代码<a class="ae kc" href="https://tools.ietf.org/html/rfc4918#page-78" rel="noopener ugc nofollow" target="_blank">422</a>。这个状态代码是关于请求的语义，而不是它的语法。如果请求数据无法解释，那么422响应似乎更符合标准。</p><p id="b6e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">唉，时代变了，发送一个422来回应糟糕的数据是<a class="ae kc" href="https://www.keycdn.com/support/422-unprocessable-entity" rel="noopener ugc nofollow" target="_blank">似乎不赞成</a>。</p><h1 id="bb4a" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">现在的标准是什么</h1><p id="2a5c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">大约2014年。下面是<a class="ae kc" href="https://tools.ietf.org/html/rfc7231#section-6.5.1" rel="noopener ugc nofollow" target="_blank">最新正文</a>:</p><pre class="jr js jt ju fq lg lh li lj aw lk dt"><span id="6773" class="ll ke hu lh b fv lm ln l lo lp">The 400 (Bad Request) status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</span></pre><p id="39ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个比原来更广泛的定义，不限于语法错误，但它没有具体提到数据错误。这是怎么回事？通过查看<a class="ae kc" href="https://tools.ietf.org/html/rfc7231#page-47" rel="noopener ugc nofollow" target="_blank">中关于自定义状态代码的内容</a>可以找到一条线索:</p><pre class="jr js jt ju fq lg lh li lj aw lk dt"><span id="f4ed" class="ll ke hu lh b fv lm ln l lo lp">HTTP status codes are extensible. HTTP clients are not required to<br/> understand the meaning of all registered status codes, though such<br/> understanding is obviously desirable. However, a client MUST<br/> understand the class of any status code, as indicated by the first<br/> digit, and treat an unrecognized status code as being equivalent to<br/> the x00 status code of that class, with the exception that a<br/> recipient MUST NOT cache a response with an unrecognized status code.</span></pre><p id="6ab7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，您的客户端代码现在不必处理每个状态代码，只需处理状态代码的类(第一个数字)。好吧，但是你怎么处理第一个数字？</p><pre class="jr js jt ju fq lg lh li lj aw lk dt"><span id="a5d7" class="ll ke hu lh b fv lm ln l lo lp">For example, if an unrecognized <strong class="lh hv">status code of 471 </strong>is received by a client, the client can assume that there was something wrong with its request and treat the response <strong class="lh hv">as if it had received a 400</strong> (Bad<br/>Request) status code.  The response message will usually contain a<br/>representation that explains the status.</span></pre><p id="b6c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是相关的线索，我已经标出来了。第一个是<a class="ae kc" href="https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml" rel="noopener ugc nofollow" target="_blank">没有在互联网号码分配机构(IANA)注册的471状态码</a>。因此，该规范并没有提到“标准”状态代码。它继续说，如果一个状态代码是不可识别的，那么处理它就像一个400状态代码。</p><p id="7b88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的含义是，您的400状态代码处理逻辑与用于未识别状态代码的<em class="jp">逻辑相同。因此，客户端的400状态代码处理程序逻辑是您的<em class="jp">后备、通用、通用处理程序。</em> <strong class="it hv">发生的任何</strong> 4xx错误都应该能够被您的400状态代码处理逻辑处理(即使不太理想)。</em></p><h1 id="96e5" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">那么，我可以定义我自己的4xx状态代码吗？</h1><p id="7f45" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">你<em class="jp">可以，</em>但是这样做应该有理由。不用说，所有的错误状态，不管是自定义的还是其他的，都应该<strong class="it hv">记录在API中</strong>。</p><p id="14cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用非标准代码的唯一好理由(<a class="ae kc" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#Unofficial_codes" rel="noopener ugc nofollow" target="_blank">并且有很多这样的代码</a>)，是因为你希望它的处理方式与400错误不同。换句话说，您正在使用一个特殊的状态代码(希望如此)来触发客户端中更好的处理行为。</p><h2 id="5271" class="ll ke hu bd kf mf mg mh kj mi mj mk kn jc ml mm kr jg mn mo kv jk mp mq kz mr dt translated">如果我后来发现我的自定义状态代码与其他地方定义的其他自定义状态代码冲突，该怎么办？</h2><p id="f1b6" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated"><strong class="it hv">您</strong>定义您的服务器状态代码的含义，并且您<strong class="it hv">为您支持的每个请求记录它们</strong>。你永远不要让你的服务代理另一个服务的状态码！那就糟了。如果您需要将信息从出于其他原因使用状态代码的另一个服务中继到客户端，那么在错误消息中传递该信息(使用任何适当的记录状态代码)，或者记录它。</p><h1 id="02ff" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">选项#3: 200 OK with error body怎么样？</h1><p id="dd51" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我给你我的看法，基于个人的挫败感:</p><p id="d6d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请求<strong class="it hv">真的</strong>可以吗？如果不是，为什么你说它是通过传回200 OK，然后，在响应的主体中，说它不是？你这样做自相矛盾，让客户做额外的工作。</p><p id="087b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个问题是:你的错误响应的<strong class="it hv">形状</strong>是什么？是简单的字符串吗？一个物体？期望客户端有自定义代码来解析和显示你的错误体，以及B的、C的和D的服务的错误体是合理的吗？这不是不规范吗？你不使用4xx代码来坚持标准(就像你解释的那样)的全部意义不就在于此吗？</p><h1 id="56ce" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">在大多数情况下，400英镑是可以的</h1><p id="f9c0" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">400状态代码处理程序是后备处理程序。按照标准，它必须处理其他地方没有处理的所有状态代码。这些可能是注册的状态码，或自定义。</p><p id="ea5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个例外可能是优先顺序。通常的与数据相关的400状态可能是由于数据验证错误，被服务器捕获，但被客户端错过。需要修理的东西，但可能不紧急。另一方面，服务器上可能会出现一些情况(例如，SQL语法错误)，需要数据库管理员立即注意。发送到客户端并由客户端处理的更具体的状态代码可能会提醒用户呼叫帮助台(或者让服务器发送5xx代码)。</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="6f3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，标准一直在更新和完善，因此不时阅读它们会有所帮助，不要依赖他人(可能已经过时)的解释。这也适用于这里所说的内容。</p></div></div>    
</body>
</html>