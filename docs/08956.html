<html>
<head>
<title>Durable Function Recipe — Webhooks Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">耐用功能配方——让Webhooks变得简单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/durable-function-recipe-webhooks-made-easy-4878b1972417?source=collection_archive---------8-----------------------#2018-10-30">https://medium.com/hackernoon/durable-function-recipe-webhooks-made-easy-4878b1972417?source=collection_archive---------8-----------------------#2018-10-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b156f111e047128a07ca079965928c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rH1PRA1-14K_93QLvt3shA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/NYDTneTcSdo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Johannes Plenio</a> on <a class="ae jg" href="https://unsplash.com/search/photos/webhook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a8ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">处理webhooks是后端开发中非常常见的模式。你调用第三方API，API立刻成功返回。然后第三方做一些漂亮的事情，比如发送信息，或者使用神经网络。当它完成时，它调用<em class="kf">您的</em> API并给出结果。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/17e3f554e04ef2bde6e377fd8b16d3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gj7Uh-9K0udWSN9N1CJdew.png"/></div></div></figure><p id="0491" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个非常简单的模式，在理论上很有意义。但是在实践中会变得复杂。一旦调用了API，就完全失去了状态。当服务调用您的webhook时，您需要弄清楚它在谈论您的哪个实体。然后您需要在调用API之前重新创建它的状态。这通常涉及到对数据库的大量回调，以重新创建几秒钟前的数据。</p><p id="c2af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些年来，我已经构建了无数的webhook处理程序。我觉得我已经尽可能地优化了webhook模式。<em class="kf">然后我建了一个具有Azure持久功能的。</em></p><p id="3ab1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你是持久功能的新手，看看我的<a class="ae jg" href="https://hackernoon.com/durable-functions-backend-development-made-easy-and-cheap-cbab7acc7050" rel="noopener ugc nofollow" target="_blank">第一印象</a>或者微软的<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview" rel="noopener ugc nofollow" target="_blank">概述</a>。基本上，你用代码定义工作流，同时享受无服务器的好处。</p><h1 id="e29d" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">耐用功能网钩</h1><p id="3bc3" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">对于webhooks，我们将使用<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-phone-verification" rel="noopener ugc nofollow" target="_blank">人类交互</a>模式。这种模式包括:</p><ul class=""><li id="a86c" class="lo lp hu jj b jk jl jo jp js lq jw lr ka ls ke lt lu lv lw dt translated">执行一些动作</li><li id="a721" class="lo lp hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">等待某个外部事件(通常是人)引发任意长的时间。</li><li id="3c2a" class="lo lp hu jj b jk lx jo ly js lz jw ma ka mb ke lt lu lv lw dt translated">继续执行。</li></ul><p id="ead7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，外部事件将是一个webhook。这个食谱将包括使用流行的Twilio服务发送短信。发送消息后，Twilio可以用传递状态进行回复。例如，如果消息发送失败，您可能希望执行一些业务逻辑。</p><p id="6377" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我已经为许多用例用多种语言构建了Twilio处理程序。但是持久的功能使它成为最容易的。通常是这样的:</p><p id="6108" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我已经得到了关于我要给其发送信息的人的各种信息。我发送消息，记下Twilio给我的唯一消息ID，就这样。一切都没了。现在我在等待。</p><p id="68ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一段时间后(通常在几秒钟内)，Twilio用一个惟一的消息ID访问我的API。这一般是在app完全独立的部分。我使用ID来查找消息，现在我必须重新创建发送给Twilio之前的所有内容。但是我<em class="kf">刚刚</em>有了！这可能看起来不多，但在规模上，所有这些返回数据存储的次数真的会增加。</p><p id="56ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在持久函数中，webhook逻辑在发送消息后一行发生<strong class="jj hv">。让我们看看它是如何工作的。</strong></p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mc md l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Video Tutorial for This Article</figcaption></figure><h1 id="4015" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">获取设置</h1><p id="202f" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我将在Mac上运行VS代码，但这将在任何操作系统上运行。我们将从使用VS代码中的<a class="ae jg" href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>扩展开始，在一个空目录中创建新的C# function项目。</p><p id="e467" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我们需要一些包裹。运行这些命令来获取持久函数、Azure表存储和Twilio的扩展。</p><p id="b62c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh me mf mg mh b">dotnet add package Microsoft.Azure.WebJobs.Extensions.DurableTask --version 1.6.2<br/>dotnet add package Microsoft.Azure.WebJobs.Extensions.Storage --version 3.0.1<br/>dotnet add package Microsoft.Azure.WebJobs.Extensions.Twilio --version 3.0.0</code></p><p id="a172" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在其中创建一个<code class="eh me mf mg mh b">Models</code>目录和名为<code class="eh me mf mg mh b">MessageInput.cs</code>的文件。这将包含发送消息所需的属性:</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mi md l"/></div></figure><h1 id="9a8c" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">启动器</h1><p id="a2fa" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们需要某种方式开始发送信息。我们将使用HTTP触发器。如果您不熟悉持久函数，可以忽略函数参数。</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mi md l"/></div></figure><p id="99b3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们读取主体(作为我们之前创建的一个<code class="eh me mf mg mh b">MessageInput</code>对象),并将其传递给orchestrator以启动工作流。然后我们返回编排状态。就是这样！现在我们需要创建一个管弦乐队。</p><h1 id="a035" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">管弦乐队</h1><p id="63cb" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">这是真正的奇迹发生的地方。发送消息和获得响应的整个工作流程只需五行代码。</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mi md l"/></div></figure><p id="386a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个业务流程都有一个唯一的ID。这个ID通常应该保密，所以我们将创建一个映射，将编排ID映射到一个惟一的ID。我们将把唯一的ID发送给第三方，当他们把它返回给我们时，我们将使用它来查找编排ID。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/a1b9ef14da54684732c55a837d638002.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*cL85TxMc8M2LYcU55zZLkg.png"/></div></figure><p id="e099" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们发完信息，然后给<code class="eh me mf mg mh b">WaitForExternalEvent</code>打电话。这将无限期暂停编排，直到触发<code class="eh me mf mg mh b">TwilioCallback</code>事件。在这一点上，我们将有状态，并可以继续我们的业务逻辑。</p><h1 id="eac1" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">这些活动</h1><h2 id="ceb8" class="mk km hu bd kn ml mm mn kr mo mp mq kv js mr ms kz jw mt mu ld ka mv mw lh mx dt translated">创建映射</h2><p id="1eeb" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">我们将使用Azure表存储(持久函数无论如何都会使用)来保存我们的映射。Azure函数支持一个<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-table" rel="noopener ugc nofollow" target="_blank">表绑定</a>，它允许你用很少的代码从数据库中提取数据。</p><p id="236f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们需要一个类来保存映射:</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mi md l"/></div></figure><p id="fa91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">表格存储需要一个<code class="eh me mf mg mh b">PartitionKey</code>和一个<code class="eh me mf mg mh b">RowKey</code>。我们将保存<code class="eh me mf mg mh b">OrchestrationId</code>并使用<code class="eh me mf mg mh b">RowKey</code>发送到Twilio，并再次找到我们的编排。</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mi md l"/></div></figure><p id="8215" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个函数只是将映射保存到表存储中，并返回<code class="eh me mf mg mh b">RowKey</code>供以后使用。我们可以使用表绑定来指定函数参数中我们感兴趣的表。</p><h2 id="dbe7" class="mk km hu bd kn ml mm mn kr mo mp mq kv js mr ms kz jw mt mu ld ka mv mw lh mx dt translated">发送消息</h2><p id="4f32" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">Azure函数还支持用很少的代码发送短信的Twilio绑定。这里，我们创建一个<code class="eh me mf mg mh b">CreateMessageOptions</code>对象，并用输入的数字填充它。</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mi md l"/></div></figure><p id="3539" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个<code class="eh me mf mg mh b">StatusCallback</code>，是Twilio将点击的URL，告诉我们消息的状态。我们在URL中包含了<code class="eh me mf mg mh b">RowKey</code>来查找我们的映射。接下来，我们将创建该路线。</p><h2 id="0dff" class="mk km hu bd kn ml mm mn kr mo mp mq kv js mr ms kz jw mt mu ld ka mv mw lh mx dt translated">Webhook处理程序</h2><p id="64ce" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">最后要做的事情是处理Twilio何时用状态响应我们的API。当然，这只是另一个HTTP触发的函数。函数参数与上一个HTTP函数没有太大的不同。</p><p id="624f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">唯一的区别是它使用表绑定来查找Twilio传回的ID。这将返回一个带有编排ID的记录，这意味着我们现在可以向该编排引发一个事件。</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mi md l"/></div></figure><p id="7f40" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您还记得的话，orchestrator目前正在等待一个<code class="eh me mf mg mh b">TwilioCallback</code>事件的触发，所以让我们不要再让它等待了！我们传入状态，编排可以从停止的地方继续<em class="kf">右</em>。</p><p id="db4a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">注意:Azure函数目前不支持x-www-form-urlencoded响应，这是Twilio提供的。</em> <code class="eh me mf mg mh b"><em class="kf">ParseForm</em></code> <em class="kf">为我们处理这个。详见</em> <a class="ae jg" href="https://github.com/KevinDJones/DF_Webhook/blob/master/Starters.cs#L47" rel="noopener ugc nofollow" target="_blank"> <em class="kf">全码</em> </a> <em class="kf">。</em></p><h2 id="fa0a" class="mk km hu bd kn ml mm mn kr mo mp mq kv js mr ms kz jw mt mu ld ka mv mw lh mx dt translated">结论</h2><p id="51b7" class="pw-post-body-paragraph jh ji hu jj b jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke hn dt translated">就是这样！发送消息的五个函数<em class="kf">和处理回调的</em>。最棒的是，我们可以从开始等待webhook之前停止的地方重新开始。不再需要重复返回数据库。这是我体验过的实现webhooks最干净的方式。</p><p id="4ea2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">查看<a class="ae jg" href="https://github.com/KevinDJones/DF_Webhook" rel="noopener ugc nofollow" target="_blank">完整代码</a>或上面的视频了解完整细节！</p></div></div>    
</body>
</html>