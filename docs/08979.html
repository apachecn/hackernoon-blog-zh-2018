<html>
<head>
<title>How to run asynchronous web requests in parallel with Python 3.5 (without aiohttp)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python 3.5并行运行异步web请求(没有aiohttp)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-run-asynchronous-web-requests-in-parallel-with-python-3-5-without-aiohttp-264dc0f8546?source=collection_archive---------0-----------------------#2018-10-31">https://medium.com/hackernoon/how-to-run-asynchronous-web-requests-in-parallel-with-python-3-5-without-aiohttp-264dc0f8546?source=collection_archive---------0-----------------------#2018-10-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9951af2175a6ace754bb42e40f3f8592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7E8FmqFW488FASvN0nNcdQ.png"/></div></div></figure><p id="49b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近在我的工作场所，我们的IT团队终于将我们的分布式Python版本升级到了3.5.0。虽然这是对2.6的巨大升级，但这仍然伴随着一些成长的烦恼。不幸的是，Python 3.5.0不满足一些流行库的一些最低要求，包括<a class="ae ka" href="https://aiohttp.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> aiohttp </a>。</p><p id="543e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管有这些限制，我仍然需要编写一个脚本来调用数百个。csv文件并操作数据。Python本身不是事件驱动的，也不是天生异步的(像NodeJS)，但是仍然可以达到同样的效果。这篇文章将有助于详述我所学到的东西，同时也展示异步操作的好处。</p><p id="01ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">免责声明:</strong>如果你有更高版本的Python可用(3.5.2+)，我强烈推荐你改用aiohttp。这是一个非常健壮的库，是解决这类问题的好方法。网上有很多教程详细介绍了如何最好地使用这个库。</p><h1 id="a87a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">假设</h1><p id="8c14" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这篇文章做了如下假设:</p><ul class=""><li id="c014" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">您已经熟悉Python及其大部分语法</li><li id="4af4" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">您已经熟悉了基本的web请求</li><li id="e1fb" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">您对异步操作有一个模糊的概念</li></ul><p id="cedf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你只是在寻找解决方案，向下滚动到底部，完整的代码已经公布。尽情享受吧！</p><h1 id="f04e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">设置</h1><p id="2e0d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在开始之前，确保您的机器上安装了<a class="ae ka" href="http://docs.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank">请求</a>。最简单的安装方法是在终端中键入以下命令:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="26f0" class="mb kc hu lx b fv mc md l me mf">$ python -m pip install requests</span></pre><p id="3c4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，如果您没有管理权限，可以使用以下命令安装该库:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="93dc" class="mb kc hu lx b fv mc md l me mf">$ python -m pip install requests --user</span></pre><h1 id="3ffe" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">错误的方法:同步请求</h1><p id="76d4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了展示我们的并行方法的好处，让我们首先来看看以同步的方式处理问题。我还将概述代码中发生了什么。最终，我们希望能够对包含。csv文件，并测量读取其中的文本所需的时间。</p><p id="7ce9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们会下载多个。来自<a class="ae ka" href="https://people.sc.fsu.edu/~jburkardt/data/csv/" rel="noopener ugc nofollow" target="_blank">https://people.sc.fsu.edu/~jburkardt/data/csv</a>/的不同大小的csv文件，为我们的例子提供了大量的数据。</p><p id="58f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为免责声明，我们将使用来自<code class="eh mg mh mi lx b">requests</code>库的<code class="eh mg mh mi lx b">Session</code>对象来执行我们的GET请求。</p><p id="ac21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们需要一个执行web请求的函数:</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="e96c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个函数接受一个<code class="eh mg mh mi lx b">Session</code>对象和。csv文件，执行web请求，然后在响应中返回文本。</p><p id="ea67" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们需要一个函数，它可以有效地循环我们想要的文件列表，并测量执行请求所需的时间:</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="86ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个函数创建我们的<code class="eh mg mh mi lx b">Session</code>对象，然后遍历每个对象。csv文件在<code class="eh mg mh mi lx b">csvs_to_fetch</code>列表中。一旦<code class="eh mg mh mi lx b">fetch</code>操作完成，测量的时间就会被计算出来并以一种易于阅读的格式显示出来。</p><p id="55a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们的<code class="eh mg mh mi lx b">main</code>函数将是简单的(目前如此),并调用我们的函数:</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="a468" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们将所有这些放在一起，下面是我们的同步示例的代码:</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="5d32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看运行这个脚本的结果:</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/6f3d2c3571d8432c1c7ea602083bca52.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*zS9RmwBXJwE96_sMPwc-Ow.png"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">Synchronous example. Notice how each operation doesn’t start until the last one is completed</figcaption></figure><p id="120b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谢天谢地，我们可以通过Python 3的内置<code class="eh mg mh mi lx b">asyncio</code>库极大地提高这个性能！</p><h1 id="0a13" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">正确的方法:异步地一次执行多个请求</h1><p id="d32d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了让这个工作，我们将不得不返工我们现有的一些功能。从<code class="eh mg mh mi lx b">fetch</code>开始:</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="0363" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们需要使我们的<code class="eh mg mh mi lx b">get_data</code>函数异步:</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="f4ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码现在将为每个线程创建多个线程。csv文件，并对每个需要下载的文件执行<code class="eh mg mh mi lx b">fetch</code>函数。</p><p id="f4fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们的<code class="eh mg mh mi lx b">main</code>函数需要一点小调整来正确初始化我们的异步函数:</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="01fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们运行新代码，看看结果:</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/ad55990cb00681d25c66da27b2cdf06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*AWWu5oeFhITmtoRAELgbhQ.png"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">Asynchronous example. Notice how the files are not being obtained in order.</figcaption></figure><p id="7674" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这个小小的改变，所有的12个。csv文件的下载时间从3.43秒缩短到10.84秒。下载时间缩短了近70%。</p><h1 id="cd47" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">异步代码</h1><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="d6a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望您喜欢这篇文章，并且可以将这些技能用于任何需要旧版本Python(或者没有那么多依赖)的项目。尽管Python可能没有直接的async / await模式，但要获得惊人的结果并不困难。</p><p id="5779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽情享受吧！</p></div></div>    
</body>
</html>