<html>
<head>
<title>(Don’t) Blame It On React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(不)归咎于React Native</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/dont-blame-it-on-react-native-2eb0be3000b6?source=collection_archive---------4-----------------------#2018-11-03">https://medium.com/hackernoon/dont-blame-it-on-react-native-2eb0be3000b6?source=collection_archive---------4-----------------------#2018-11-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9b9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">摘要</strong> <br/>把我们生活中的一切错误归咎于<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank">反应</a>当地人总是很有趣。然而，我们一次又一次地发现，在大多数情况下，编写性能更好的react代码可以修复我们的应用程序的性能和落后的UI问题。</p><p id="3371" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Part 1 —责备React Native </strong> <br/>我的故事要从三年前说起，当时React Native在0.12版本的时候，甚至还不支持android！我们刚刚在我的公司(<a class="ae jp" href="https://www.wix.com" rel="noopener ugc nofollow" target="_blank">wix.com</a>)做出了一个重大决定，孤注一掷，在react native上孤注一掷，只用react native编写我们的主要应用程序，尽可能少用原生代码。你看，Wix是一家网络公司。我们有数百名前端开发人员在开发数十种产品。对我们来说，为ios和android重新编写这些产品太痛苦了。我们看到了react native的潜力，并努力去做。<br/>往前跳两年，我们现在有了一款适用于android和ios的令人惊叹的应用。我们正在为react native编写和维护几十个<a class="ae jp" href="https://github.com/wix" rel="noopener ugc nofollow" target="_blank">开源库</a>和数千个stars，我们有大约60名开发人员不断为Wix应用贡献代码。</p><p id="d675" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管react native自0.12版本以来已经有了很大的改进，但事情并不像他们经常描述的那样美好。如果你曾经写过一个真实的、复杂的、流量很大的react原生应用，那么你应该知道我在说什么。<br/>归结起来就是这两张图片:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/fbeb8b4ff9d08396d3e045f0971405c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tF4GTxa_ydKv4lqv7GS0ZQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">When I think about React Native I want to…</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/a405a990b00c875c1bfb9e7fb7f14b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UuOb29orEAHiAf1ENY3rRw.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">But eventually I just…</figcaption></figure><p id="3215" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不想撒谎，react native给了你一个简单的方法(如果你是一个前端开发人员)来编写原生应用，<strong class="it hv">编写react native不是在公园散步。</strong></p><p id="1e66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很难，因为反应自然…</p><ul class=""><li id="950c" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">在本机API上添加一个抽象层</li><li id="6e28" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">表演糟透了</li><li id="3c6e" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">是单线程</li><li id="a8ed" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">使得在常规的本地应用中很容易完成的事情变得很困难(比如高效的长列表)</li><li id="54ff" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">构建更加复杂</li></ul><p id="9fe4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有一个引语，每个RN开发人员都至少对自己说过或想过一次</p><blockquote class="ku kv kw"><p id="4e6f" class="ir is kx it b iu iv iw ix iy iz ja jb ky jd je jf kz jh ji jj la jl jm jn jo hn dt translated"><strong class="it hv"> " <em class="hu">对于一个真正高性能的应用来说，我们唯一的选择就是编写一个纯粹的原生应用</em> " <br/> -一个<em class="hu"> ny react原生开发者</em> </strong></p></blockquote><p id="f873" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然这确实是一个选项，而且可能是一个有效的选项，但这取决于您的用例。我声称它不是唯一的一个！</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="498d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第二部分——啊哈时刻</strong></p><p id="3ff5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约一年前，我们对应用程序进行了大量性能改进。一次又一次，一个又一个错误，一个又一个问题，我们发现有了性能更好的javascript和react代码，我们可以解决大多数问题。这是我的“啊哈时刻”。它改变了我的生活。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff li"><img src="../Images/4c1b1393e05e5035216223be72b9ddd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*iX95dA6Lpg5imCIqekNIHQ.jpeg"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">What if I told you we can solve 90% of the problems in javascript</figcaption></figure><p id="e39d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过一些代码片段和案例研究来演示这一点。</p><p id="df5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kx">问题# 1——发送按钮启用/禁用</em> </strong></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lj"><img src="../Images/6c2866b9884c2a113e70a2a7e88bc10e.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/1*qoh6ILL-VVPPWVy7903Pkw.gif"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek"><em class="lk">Send button enable / disable</em></figcaption></figure><p id="d6d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的应用程序的一部分包括一个聊天模块，所以网站所有者可以在他们的网站上与访问者交谈。功能超级简单。有一个输入框和一个“发送”按钮。当输入为空时应禁用该按钮，当输入不为空时应启用该按钮。所发生的是，在用户开始输入之后，大约过了一秒钟(有时甚至更久)按钮才被激活。</p><p id="a932" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们发现我们呈现了整个聊天室列表，即使我们在一个单独的聊天室屏幕上。发生这种情况是因为在任何其他聊天室发生变化后，我们为每个聊天室创建了一个新的<strong class="it hv">聊天室对象</strong>。对我们来说，这听起来可能是一个可怕的错误，但是当以功能性的方式写作时，它看起来是正确的，无害的。我们选择解决这个问题的方法是使用记忆化来保存未改变的聊天室。</p><p id="11e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kx">问题#2-消息延迟到达</em> </strong></p><p id="efb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们解决的第二个问题是聊天信息实时显示的速度很慢。这里有两个视频(之前和之后)展示了这个问题。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Before</figcaption></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">After</figcaption></figure><p id="da65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你所看到的，这两个版本有很大的不同。问题是<em class="kx">componentWillReceiveProps</em>被调用<em class="kx">方式</em>太多次。每次调用它时，它都会触发一个新的渲染周期，因为调用了<em class="kx"> setState。</em></p><p id="2b84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kx">问题三——打字动画</em> </strong></p><p id="8965" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个我很喜欢。我们非常有才华和创造性的设计师用一个超级光滑和花式打字动画挑战我们。就是那种泡泡头互相滑动，把前面的信息推上去，上下滑动，神奇地变成信息泡泡。你是知道的...任何前端开发人员的噩梦。:)起初，我们采用天真的方法，用动画计算javascript上的动画。好吧，那没用。由于动画的工作方式，当使用“useNativeDriver”标志时，您不能设置我们需要制作动画的属性，如“height”。这意味着所有的动画计算都是在javascript端完成的，这使得动画看起来非常滞后。在这里阅读更多关于为什么使用原生驱动<a class="ae jp" href="https://github.com/facebook/react-native/issues/13150" rel="noopener ugc nofollow" target="_blank">时不能改变高度的信息。</a></p><p id="a260" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们说，等一下！React native给了你用native做任何你想做的事情的承诺。我们照做了。我们试过本地的，但也很烂。虽然动画本身在本机上工作得非常顺利，但当我们试图将它嵌入到react本机控制的视图中时，我们遇到了麻烦。为什么？我们的动画的一部分包括改变动画部分的高度的容器，这反过来又改变了用rn编写的它的兄弟的布局。因此，我们又回到了起点。我们本来可以在原生面制作动画，但是我们需要告诉RN我们已经这样做了(改变了高度)。反过来，rn需要在他只能在javascript线程上做的基础上做他的动画，因为和以前一样的问题。</p><p id="31e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就在放弃之前，我们发现可以使用react native的<a class="ae jp" href="https://facebook.github.io/react-native/docs/animations#layoutanimation-api" rel="noopener ugc nofollow" target="_blank"> LayoutAnimations </a>来实现。</p><p id="0273" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kx">问题# 4——模块加载时间</em> </strong></p><p id="57c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一个想和大家分享的是一个简单的“需求vs导入”的故事。我们的应用程序由许多独立的模块组成。你可以把它想象成每个模块都有一个不同的包。我们发现，通过仅在需要时才要求导入语句来延迟导入语句，为我们节省了大量时间。我说的是跨应用的秒。</p><p id="c94e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，我们所做的只是从文件顶部删除了“import”语句(您可能认为这是无害的),取而代之的是只在我们需要时才要求我们需要的东西。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="44d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第3部分——这就是javascript和react的工作方式</strong></p><p id="d299" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我到底在说什么呢？基本上，我想说的是，在这些情况下，react native不应受到指责。这就是javascript和react的工作方式。由于react native桥和移动设备的低计算能力，在react native中更容易看到结果。</p><p id="ce18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了证明我的观点，我开始创建一个简单的react web应用程序，该应用程序的性能会很差，并且可以通过更改很少几行代码来修复(实际上只需要一行代码)。我把这个项目叫做<em class="kx">“好卡/坏卡”</em>。这是一个非常简单的react应用程序。它显示了一个卡片列表，总共100张，没有什么疯狂的。每张卡都有一个输入字段。在bad卡中，当您在输入字段中输入时，您可以看到UI中的延迟。键盘的反应不像你预期的那样。好卡工作完美。我已经把这个项目放到了github上，我鼓励你去看看。代码非常简单，只有一行代码就能产生巨大的效果。对于那些没有时间的人，你可以在这里查看两个版本:</p><ul class=""><li id="0de1" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated"><a class="ae jp" href="https://ofirdagan.github.io/good-card-bad-card/dist/bad-card/" rel="noopener ugc nofollow" target="_blank">坏卡</a></li><li id="f3c8" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated"><a class="ae jp" href="https://ofirdagan.github.io/good-card-bad-card/dist/good-card/" rel="noopener ugc nofollow" target="_blank">好牌</a></li></ul></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="6fd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第4部分——由我们决定</strong></p><p id="ebe6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们知道了这一切。我们能做些什么呢？这取决于我们。我们必须更加仔细和负责任地对待开发者。</p><p id="a202" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过遵循以下准则来做到这一点:</p><ul class=""><li id="d08c" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated"><strong class="it hv">了解您的关键应用程序流并持续监控它们</strong> <br/> -只要您能确保您的关键应用程序流得到覆盖，并在性能下降时得到通知，您如何监控您的应用程序并不重要</li><li id="7fa9" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated"><strong class="it hv">避免编写匿名函数作为道具</strong><br/>——这些可能会产生巨大的影响</li><li id="f569" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated"><strong class="it hv">了解你的组件</strong> <br/>不要以为只写<em class="kx"> PureComponents </em>就能解决一切</li><li id="1463" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated"><strong class="it hv">了解你的组件生命周期方法</strong> <br/>每个组件都是不同的，可能需要使用不同的生命周期方法</li></ul><p id="2a4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后但同样重要的是<strong class="it hv">了解你的减速器</strong>。对于熟悉redux的人来说。我想给你看一个数据库和reducers之间的很酷的类比</p><p id="48a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">先说数据库。假设我们有一个表，其中一个字段有许多写操作，另一个字段有许多读操作。任何写操作都会锁定表并延迟读操作。解决方案是将字段分成两个表。</p><p id="b7ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在redux中，假设我们有很多改变一个字段(它也可以是某个对象的内部字段)的操作，但是对这个字段的读取并不多。任何状态变化都会触发渲染周期。这里的解决方案是相同的，分开到两个减速器。</p></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="e27c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">第四部分——结语</strong></p><p id="7439" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你可能会想，这很好，但是我应该从哪里以及如何开始分析我的应用程序呢？这也太F***含糊和硬了吧！</p><p id="ea2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，我有一个好消息。帮助就在眼前，它的名字是<em class="kx">“你为什么更新”</em>。“你为什么更新”是一个库，当潜在的不必要的重新渲染发生时，monkey patches会在控制台中做出反应并通知你。我强烈建议你去github上看看，我保证你不会失望的。此外，欢迎你打印这个惊人的性能小抄，我做了这篇文章的关键要点。干杯。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/4946401ba407b3c2cafb2bf0adbe8d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0W5isalVkx9QB7_m5KY9Q.jpeg"/></div></div></figure><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ln lm l"/></div></figure></div></div>    
</body>
</html>