<html>
<head>
<title>Writing a Frontend Web Framework with WebAssembly And Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用WebAssembly和Go编写前端Web框架</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-a-frontend-web-framework-with-webassembly-and-go-ff84cd1346fe?source=collection_archive---------4-----------------------#2018-11-04">https://medium.com/hackernoon/writing-a-frontend-web-framework-with-webassembly-and-go-ff84cd1346fe?source=collection_archive---------4-----------------------#2018-11-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/ab3000817dec53023b582a526c0230d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LRkt5ifeRaCfstSc.jpg"/></div></div></figure><div class=""/><p id="1f13" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">毫无疑问，JavaScript 前端框架有助于拓展以前在浏览器环境中可能实现的边界。在React、Angular和VueJS(仅举几个例子)的基础上出现了更复杂的应用程序，还有一个众所周知的笑话，一个新的前端<a class="ae ka" href="https://hackernoon.com/tagged/framework" rel="noopener ugc nofollow" target="_blank">框架</a>似乎每天都在出现。</p><p id="e8a5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，这种发展速度对于全世界的开发者来说是一个非常好的消息。对于每一个新的框架，我们都发现了更好的处理状态的方法，或者用shadow DOM之类的东西高效地呈现。</p><p id="380a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，最新的趋势似乎是用JavaScript之外的语言编写这些框架，并将它们编译成WebAssembly。我们开始看到JavaScript和WebAssembly通信方式的重大改进，这要感谢像<a class="ae ka" href="https://twitter.com/linclark" rel="noopener ugc nofollow" target="_blank"> Lin Clark </a>这样的人，随着WebAssembly开始在我们的生活中变得更加突出，我们无疑会看到更多的重大改进。</p><h1 id="3fb2" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">介绍</h1><p id="85dd" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">因此，在本教程中，我认为构建一个用Go编写的极其简单的前端框架并编译成WebAssembly是一个好主意。至少，这将包括以下功能:</p><ul class=""><li id="bed5" class="le lf if je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">功能注册</li><li id="c14f" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">成分</li><li id="fdae" class="le lf if je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">超级简单路由</li></ul><p id="ba25" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我现在警告你，虽然这些将是难以置信的简单，并没有接近生产准备就绪。如果这篇文章有点受欢迎，我希望继续下去，并尝试构建一些满足半体面前端框架要求的东西。</p><blockquote class="ls lt lu"><p id="859f" class="jc jd lv je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated"><strong class="je ig"> <em class="if"> Github: </em> </strong> <em class="if">这个项目的完整源代码可以在我的Github账号上找到。如果你想为这个项目做贡献，请随意，我很乐意接受任何请求！</em></p></blockquote><div class="ht hu fm fo hv lz"><a href="https://github.com/elliotforbes/oak" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd ig fv z el me eo ep mf er et ie dt translated">Elliot福布斯/橡树</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">一个基于Go的WebAssembly框架，用于在Go！-埃利奥特福布斯/奥克</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ib lz"/></div></div></a></div><h1 id="82f6" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">出发点</h1><p id="7112" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好了，让我们进入我们选择的编辑器，开始编码吧！我们要做的第一件事是创建一个非常简单的<code class="eh mo mp mq mr b">index.html</code>,作为我们前端框架的入口点:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="73bf" class="na kc if mr b fv nb nc l nd ne">&lt;!doctype html&gt;<br/>&lt;!--<br/>Copyright 2018 The Go Authors. All rights reserved.<br/>Use of this source code is governed by a BSD-style<br/>license that can be found in the LICENSE file.<br/>--&gt;<br/>&lt;html&gt;<br/><br/>&lt;head&gt;<br/>	&lt;meta charset="utf-8"&gt;<br/>	&lt;title&gt;Go wasm&lt;/title&gt;<br/>	&lt;script src="./static/wasm_exec.js"&gt;&lt;/script&gt;<br/>	&lt;script src="./static/entrypoint.js"&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;	<br/><br/>  &lt;div class="container"&gt;<br/>    &lt;h2&gt;Oak WebAssembly Framework&lt;/h2&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;<br/><br/>&lt;/html&gt;</span></pre><p id="fa75" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你会注意到在顶部有2个<code class="eh mo mp mq mr b">js</code>文件被导入，这些允许我们执行我们完成的WebAssembly二进制文件。第一部分大约有414行，因此，为了保持本教程的可读性，我建议您从这里下载:<a class="ae ka" href="https://github.com/elliotforbes/oak/blob/master/examples/blog/static/wasm_exec.js" rel="noopener ugc nofollow" target="_blank">https://github . com/Elliot Forbes/oak/blob/master/examples/blog/static/wasm _ exec . js</a></p><p id="3499" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个是我们的<code class="eh mo mp mq mr b">entrypoint.js</code>档。这将获取并运行我们即将构建的<code class="eh mo mp mq mr b">lib.wasm</code>。</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="1f61" class="na kc if mr b fv nb nc l nd ne">// static/entrypoint.js<br/>const go = new Go();<br/>WebAssembly.instantiateStreaming(fetch("lib.wasm"), go.importObject).then((result) =&gt; {<br/>    go.run(result.instance);<br/>});</span></pre><p id="226f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，现在我们已经解决了这个问题，我们可以开始研究一些Go代码了！创建一个名为<code class="eh mo mp mq mr b">main.go</code>的新文件，它将包含我们Oak Web框架的入口点！</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="9d2d" class="na kc if mr b fv nb nc l nd ne">// main.go<br/>package main<br/><br/>func main() {<br/>	println("Oak Framework Initialized")<br/>}</span></pre><p id="6eab" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这再简单不过了。我们已经创建了一个非常简单的Go程序，当我们打开我们的web应用程序时，它应该会打印出<code class="eh mo mp mq mr b">Oak Framework Initialized</code>。为了验证一切正常，我们需要使用以下命令来编译它:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="7b21" class="na kc if mr b fv nb nc l nd ne">$ <strong class="mr ig">GOOS=js GOARCH=wasm go build -o lib.wasm main.go</strong></span></pre><p id="13cd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将构建我们的Go代码并输出我们在<code class="eh mo mp mq mr b">entrypoint.js</code>文件中引用的<code class="eh mo mp mq mr b">lib.wasm</code>文件。</p><p id="5183" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太棒了，如果一切正常，那么我们就可以在浏览器中试用了！我们可以使用这样一个非常简单的文件服务器:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="894a" class="na kc if mr b fv nb nc l nd ne">// server.go<br/>package main<br/><br/>import (<br/>	"flag"<br/>	"log"<br/>	"net/http"<br/>)<br/><br/>var (<br/>	listen = flag.String("listen", ":8080", "listen address")<br/>	dir    = flag.String("dir", ".", "directory to serve")<br/>)<br/><br/>func main() {<br/>	flag.Parse()<br/>	log.Printf("listening on %q...", *listen)<br/>	log.Fatal(http.ListenAndServe(*listen, http.FileServer(http.Dir(*dir))))<br/>}</span></pre><p id="8c9c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，您可以通过键入<code class="eh mo mp mq mr b">go run server.go</code>来提供您的应用程序，您应该能够从<code class="eh mo mp mq mr b"><a class="ae ka" href="http://localhost:8080." rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></code> <a class="ae ka" href="http://localhost:8080." rel="noopener ugc nofollow" target="_blank">访问您的应用程序。</a></p><h1 id="8dbd" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">功能注册</h1><p id="c146" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好了，我们已经有了一个相当基本的打印声明，但是从大的方面来看，我不认为它是一个Web框架。</p><p id="abfd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看如何在Go中构建函数并注册这些函数，以便在我们的<code class="eh mo mp mq mr b">index.html</code>中调用它们。我们将创建一个新的效用函数，它将接受一个<code class="eh mo mp mq mr b">string</code>，这将是我们函数的名称，以及它将映射到的Go函数。</p><p id="3bdd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将以下内容添加到现有的<code class="eh mo mp mq mr b">main.go</code>文件中:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="c0fa" class="na kc if mr b fv nb nc l nd ne">// main.go<br/>import "syscall/js"<br/><br/>// RegisterFunction<br/>func RegisterFunction(funcName string, myfunc func(i []js.Value)) {<br/>	js.Global().Set(funcName, js.NewCallback(myfunc))<br/>}</span></pre><p id="7853" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，这就是事情开始变得更有用的地方。我们的框架现在允许我们注册函数，因此框架的用户可以开始创建他们自己的功能。</p><p id="d77b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用我们框架的其他项目可以开始注册它们自己的函数，这些函数随后可以在它们自己的前端应用程序中使用。</p><h1 id="1646" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">成分</h1><p id="1f56" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">所以，我想我们需要考虑添加到框架中的下一件事是组件的概念。基本上，我希望能够在一个使用它的项目中定义一个<code class="eh mo mp mq mr b">components/</code>目录，并且在这个目录中，我希望能够构建一个类似于<code class="eh mo mp mq mr b">home.go</code>的组件，包含我的主页所需的所有代码。</p><p id="66c7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，我们如何着手做这件事呢？</p><p id="a707" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，React倾向于以<code class="eh mo mp mq mr b">render()</code>函数为特色的特性类，这些函数返回HTML/JSX/你想为所述组件呈现的任何代码。让我们窃取它并在我们自己的组件中使用它。</p><p id="a9a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我本质上希望能够在使用这个框架的项目中做这样的事情:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="a90a" class="na kc if mr b fv nb nc l nd ne">package components<br/><br/>type HomeComponent struct{}<br/><br/>var Home HomeComponent<br/><br/>func (h HomeComponent) Render() string {<br/>	return "&lt;h2&gt;Home Component&lt;/h2&gt;"<br/>}</span></pre><p id="4398" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在我的<code class="eh mo mp mq mr b">components</code>包中，我定义了一个<code class="eh mo mp mq mr b">HomeComponent</code>,它具有一个返回HTML的<code class="eh mo mp mq mr b">Render()</code>方法。</p><p id="8331" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了给我们的框架添加组件，我们将保持简单，只定义一个<code class="eh mo mp mq mr b">interface</code>,我们随后定义的任何组件都必须遵守它。在我们的Oak框架内创建一个名为<code class="eh mo mp mq mr b">components/comopnent.go</code>的新文件:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="ee1a" class="na kc if mr b fv nb nc l nd ne">// components/component.go<br/>package component<br/><br/>type Component interface {<br/>	Render() string<br/>}</span></pre><p id="75ea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想给我们的各种组件添加新功能，会发生什么？这让我们可以做到这一点。我们可以在组件的<code class="eh mo mp mq mr b">init</code>函数中使用<code class="eh mo mp mq mr b">oak.RegisterFunction</code>调用来注册我们想要在组件中使用的任何函数！</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="d91b" class="na kc if mr b fv nb nc l nd ne">package components<br/><br/>import (<br/>	"syscall/js"<br/><br/>	"github.com/elliotforbes/oak"<br/>)<br/><br/>type AboutComponent struct{}<br/><br/>var About AboutComponent<br/><br/>func init() {<br/>	oak.RegisterFunction("coolFunc", CoolFunc)<br/>}<br/><br/>func CoolFunc(i []js.Value) {<br/>	println("does stuff")<br/>}<br/><br/>func (a AboutComponent) Render() string {<br/>	return `&lt;div&gt;<br/>						&lt;h2&gt;About Component Actually Works&lt;/h2&gt;<br/>						&lt;button onClick="coolFunc();"&gt;Cool Func&lt;/button&gt;<br/>					&lt;/div&gt;`<br/>}</span></pre><p id="549a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们将它与路由器结合起来时，我们应该能够看到我们的<code class="eh mo mp mq mr b">HTML</code>被渲染到我们的页面上，我们应该能够单击那个调用<code class="eh mo mp mq mr b">coolFunc()</code>的按钮，它将在我们的浏览器控制台中打印出<code class="eh mo mp mq mr b">does stuff</code>！</p><p id="9b27" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太棒了，现在让我们来看看如何构建一个简单的路由器。</p><h1 id="ae43" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构建路由器</h1><p id="77b0" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好了，我们已经了解了web框架中的<code class="eh mo mp mq mr b">components</code>的概念。我们差不多完成了，对吗？</p><p id="4473" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不完全是，我们可能需要的下一件事是在不同组件之间导航的方法。大多数框架似乎都有一个带有特定<code class="eh mo mp mq mr b">id</code>的<code class="eh mo mp mq mr b">&lt;div&gt;</code>，它们绑定到这个<code class="eh mo mp mq mr b">&lt;div&gt;</code>并在其中呈现所有组件，所以我们将在Oak中借鉴同样的策略。</p><p id="0724" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们在oak框架内创建一个<code class="eh mo mp mq mr b">router/router.go</code>文件，这样我们就可以开始破解了。</p><p id="cf06" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们想要将<code class="eh mo mp mq mr b">string</code>路径映射到组件，我们不会做任何URL检查，为了简单起见，我们暂时将所有内容保存在内存中:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="a39b" class="na kc if mr b fv nb nc l nd ne">// router/router.go<br/>package router<br/><br/>import (<br/>	"syscall/js"<br/><br/>	"github.com/elliotforbes/oak/component"<br/>)<br/><br/>type Router struct {<br/>	Routes map[string]component.Component<br/>}<br/><br/>var router Router<br/><br/>func init() {<br/>	router.Routes = make(map[string]component.Component)<br/>}</span></pre><p id="5b7b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在这里，我们创建了一个新的包含<code class="eh mo mp mq mr b">Routes</code>的<code class="eh mo mp mq mr b">Router</code>结构，它是我们在上一节中定义的组件的字符串映射。</p><p id="b513" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的框架中，路由不是一个强制性的概念，我们希望用户选择何时初始化一个新的路由器。因此，让我们创建一个新函数，它将注册一个<code class="eh mo mp mq mr b">Link</code>函数，并将地图中的第一条路线绑定到我们的<code class="eh mo mp mq mr b">&lt;div id="view"/&gt;</code> html标签:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="0f22" class="na kc if mr b fv nb nc l nd ne">// router/router.go<br/>// ...<br/>func NewRouter() {<br/>	js.Global().Set("Link", js.NewCallback(Link))<br/>	js.Global().Get("document").Call("getElementById", "view").Set("innerHTML", "")<br/>}<br/><br/>func RegisterRoute(path string, component component.Component) {<br/>	router.Routes[path] = component<br/>}<br/><br/>func Link(i []js.Value) {<br/>	println("Link Hit")<br/><br/>	comp := router.Routes[i[0].String()]<br/>	html := comp.Render()<br/><br/>	js.Global().Get("document").Call("getElementById", "view").Set("innerHTML", html)<br/>}</span></pre><p id="92e1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该注意到，我们已经创建了一个<code class="eh mo mp mq mr b">RegisterRoute</code>函数，允许我们注册一个<code class="eh mo mp mq mr b">path</code>给一个给定的组件。</p><p id="66e5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的<code class="eh mo mp mq mr b">Link</code>功能也很酷，它允许我们在一个项目的不同组件之间导航。我们可以指定非常简单的<code class="eh mo mp mq mr b">&lt;button&gt;</code>元素来导航到注册的路径，如下所示:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="0349" class="na kc if mr b fv nb nc l nd ne">&lt;button onClick="Link('link')"&gt;Clicking this will render our mapped Link component&lt;/button&gt;</span></pre><p id="81cc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太棒了，我们现在已经有了一个非常简单的路由器，如果我们想在一个简单的应用中使用它，我们可以这样做:</p><pre class="ms mt mu mv fq mw mr mx my aw mz dt"><span id="59b4" class="na kc if mr b fv nb nc l nd ne">// my-project/main.go<br/>package main<br/><br/>import (<br/>	"github.com/elliotforbes/oak"<br/>	"github.com/elliotforbes/oak/examples/blog/components"<br/>	"github.com/elliotforbes/oak/router"<br/>)<br/><br/>func main() {<br/>	// Starts the Oak framework<br/>	oak.Start()<br/><br/>	// Starts our Router<br/>	router.NewRouter()<br/>	router.RegisterRoute("home", components.Home)<br/>	router.RegisterRoute("about", components.About)<br/><br/>	// keeps our app running<br/>	done := make(chan struct{}, 0)<br/>	&lt;-done<br/>}</span></pre><h1 id="387d" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">完整的例子</h1><p id="13a9" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">将所有这些放在一起，我们就可以开始构建真正简单的、以组件和路由为特色的web应用程序了。如果你想看几个例子来说明这是如何工作的，那么看看官方回购中的例子:<a class="ae ka" href="https://github.com/elliotforbes/oak/tree/master/examples" rel="noopener ugc nofollow" target="_blank">Elliot Forbes/oak/examples</a></p><h1 id="f82d" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">未来的挑战</h1><p id="8eff" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这个框架中的代码还没有准备好投入生产，但是我希望这篇文章能够引发关于我们如何在Go中开始构建更多的生产准备好的框架的讨论。</p><p id="a6d9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果没有别的，它开始了一段旅程，确定还需要做什么才能使它成为React/Angular/VueJS之类的可行替代方案，所有这些都是显著提高开发人员生产率的框架。</p><p id="72af" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望这篇文章能激励你们中的一些人开始考虑如何在这个极其简单的起点上进行改进。</p><h1 id="9596" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="4ecf" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你喜欢这个教程，那么请随意分享给你的朋友，在你的twitter上，或者任何你喜欢的地方，它真的对网站有帮助，并直接支持我写更多！</p><p id="2713" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我也在YouTube上，请随时订阅我的频道，了解更多Go内容:</p><div class="ht hu fm fo hv lz"><a href="https://youtube.com/tutorialedge" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd ig fv z el me eo ep mf er et ie dt translated">教学大纲</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">嗨伙计们！欢迎来到我的频道，TutorialEdge！这是我将张贴我所有视频教程的地方…</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">youtube.com</p></div></div><div class="mi l"><div class="nf l mk ml mm mi mn ib lz"/></div></div></a></div><blockquote class="ls lt lu"><p id="c91f" class="jc jd lv je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated"><em class="if">Oak框架的完整源代码可以在这里找到:</em><a class="ae ka" href="https://github.com/elliotforbes/oak/" rel="noopener ugc nofollow" target="_blank"><em class="if">github.com/elliotforbes/oak</em></a><em class="if">。请随意提交PRs！</em></p></blockquote></div><div class="ab cl ng nh hc ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hn ho hp hq hr"><p id="ea86" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lv">最初发表于</em><a class="ae ka" href="https://tutorialedge.net/golang/writing-frontend-web-framework-webassembly-go/" rel="noopener ugc nofollow" target="_blank"><em class="lv">【tutorialedge.net】</em></a><em class="lv">。</em></p><figure class="ms mt mu mv fq hw"><div class="bz el l di"><div class="nn no l"/></div></figure></div></div>    
</body>
</html>