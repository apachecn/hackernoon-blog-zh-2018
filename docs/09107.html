<html>
<head>
<title>Service Mesh with Envoy 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理101的服务网格</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/service-mesh-with-envoy-101-e6b2131ee30b?source=collection_archive---------2-----------------------#2018-11-05">https://medium.com/hackernoon/service-mesh-with-envoy-101-e6b2131ee30b?source=collection_archive---------2-----------------------#2018-11-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="39a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我们将简要讨论“服务网格”到底是什么，以及我们如何使用“特使”来构建一个服务网格</p><h2 id="c684" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">WTH是一个服务网？</h2><p id="16a7" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">服务网格是微服务设置中的通信层。所有往来于每个服务的请求都将通过网格。每个服务都有自己的代理服务，所有这些代理服务一起构成了“服务网格”。因此，如果一个服务想要调用另一个服务，它不会直接调用目标服务，而是首先将请求路由到本地代理，然后代理再将请求路由到目标服务。本质上，您的服务实例对外部世界没有任何概念，只知道本地代理。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div class="fe ff kp"><img src="../Images/742f306230a4199525c3c8aafc28b409.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*Lu9RqRH4ncHpKLQiDUN_lQ.png"/></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">services with local proxies</figcaption></figure><p id="4dc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您谈到“服务网格”时，您肯定会听到术语“边车”，一个“边车”是可用于您的服务的每个实例的代理，每个“边车”负责一个服务的一个实例。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/a7c78ef664cebd4979831e746f40f339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*gNauLpEhjfsQ1un6ytEvMQ.jpeg"/></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">sidecar pattern</figcaption></figure><h2 id="9d9e" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">服务网格提供什么？</h2><ol class=""><li id="2461" class="lc ld hu it b iu kk iy kl jc le jg lf jk lg jo lh li lj lk dt translated">服务发现</li><li id="4afb" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">可观察性(度量)</li><li id="4450" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">限速</li><li id="ef73" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">断路</li><li id="8e4c" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">交通转移</li><li id="740b" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">负载平衡</li><li id="fe2c" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">认证和授权</li><li id="79ea" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">分布式跟踪</li></ol><h2 id="325c" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">使者</h2><p id="7de6" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Envoy是一个用C++编写的高性能代理。使用Envoy来构建你的“服务网格”并不是强制性的，你可以使用其他的代理，比如Nginx，Traefik等等…但是在这篇文章中，我们将继续使用Envoy。</p><p id="bb1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，让我们建立一个包含3个服务的“服务网格”设置。这就是我们正在努力建设的</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="fe ff lq"><img src="../Images/ef78995fa282a37150cd1ae892a28704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGqNp9rNZqsYg2sZ71UkYQ.png"/></div></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">services setup with sidecar proxies</figcaption></figure><h2 id="1e51" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">前线特使</h2><p id="79f1" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">“前端特使”是我们设置中的边缘代理，您通常会在其中执行TLS终止、身份验证、生成请求头等操作</p><p id="bca1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看“前线特使”的配置</p><figure class="kq kr ks kt fq ku"><div class="bz el l di"><div class="lv lw l"/></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">Front Envoy configuration</figcaption></figure><p id="126b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">特使配置主要包括</p><ol class=""><li id="9f69" class="lc ld hu it b iu iv iy iz jc lx jg ly jk lz jo lh li lj lk dt translated">听众</li><li id="644a" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">路线</li><li id="b6e6" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">簇</li><li id="bec1" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">端点</li></ol><p id="f8c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们逐一看一下</p><h2 id="50f7" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">听众</h2><p id="d2c6" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">您可以在单个特使实例中运行一个或多个侦听器。第9–36行，您提到了当前监听器的地址和端口，每个监听器也可以有一个或多个网络过滤器。有了这些过滤器，您可以实现大多数事情，如路由、tls终止、流量转移等……“envoy . http _ connection _ manager”是我们在这里使用的内置过滤器之一，除此之外，envoy还有其他几个<a class="ae ma" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/network_filters/network_filters#config-network-filters" rel="noopener ugc nofollow" target="_blank">过滤器</a>。</p><h2 id="95dc" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">路线</h2><p id="997b" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">第22–34行为我们的过滤器配置路由规范，您应该从哪些域接受请求，以及一个路由匹配器，它匹配每个请求并将请求发送到适当的集群。</p><h2 id="8b85" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">簇</h2><p id="f2e4" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">集群是Envoy将流量路由到的上游服务的规范。</p><p id="a4b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第41-50行定义了“服务A ”,它是“前线特使”将与之对话的唯一上游。</p><p id="10fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“connect_timeout”是在返回503之前连接到上游服务的时间限制。</p><p id="ed24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常“服务A”会有多个实例，envoy支持<a class="ae ma" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/load_balancing#supported-load-balancers" rel="noopener ugc nofollow" target="_blank">多负载平衡算法</a>来路由流量。这里我们使用一个简单的循环赛。</p><h2 id="aed3" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">端点</h2><p id="d23f" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">“主机”指定了我们希望将流量路由到的服务A的实例，在我们的例子中，我们只有一个实例。</p><p id="8f44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你注意到，第48行，正如我们所讨论的，我们不直接与“服务A”对话，我们与服务A的特使代理的实例对话，然后将它路由到本地服务A实例。</p><p id="fb5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以提到一个服务名，它将返回服务A的所有实例，比如kubernetes中的一个无头服务。</p><p id="4770" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是的，我们正在做客户端负载平衡。Envoy缓存“服务A”的所有主机，每5秒钟刷新一次主机列表。</p><p id="e8ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Envoy支持主动和被动健康检查。如果要将其激活，可以在集群配置中配置运行状况检查。</p><h2 id="6330" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">其他人</h2><p id="a566" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">第2–7行配置管理服务器，该服务器可用于查看配置、更改日志级别、查看统计数据等</p><p id="9bbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第8行，“static_resources”，意思是我们手动加载所有的配置，我们也可以动态加载，我们将在这篇文章的后面讨论如何加载。</p><p id="8a6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">配置比我们看到的要多得多，我们的目标是不要经历所有可能的配置，而是要有最少的配置来开始。</p><h2 id="db44" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">服务A</h2><p id="49ea" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">下面是“服务A”的特使配置</p><figure class="kq kr ks kt fq ku"><div class="bz el l di"><div class="lv lw l"/></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">Service A Envoy configuration</figcaption></figure><p id="c169" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第11–39行定义了一个侦听器，用于将流量路由到实际的“服务A”实例，您可以在第103–111行找到service_a实例各自的集群定义。</p><p id="380d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“服务A”与“服务B”和“服务C”对话，所以我们分别多了两个监听器和集群。这里，我们为每个上游(本地主机、服务B &amp;服务C)设置了单独的侦听器，另一种方法是设置一个侦听器，并基于url或报头路由到任何上游。</p><h2 id="f377" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">服务B &amp;服务C</h2><p id="5a5f" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">服务B和服务C位于叶级别，不与本地主机服务实例之外的任何其他上游进行对话。所以配置会很简单</p><figure class="kq kr ks kt fq ku"><div class="bz el l di"><div class="lv lw l"/></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">Service B &amp; Service C Envoy configuration</figcaption></figure><p id="5fbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里没有什么特别的，只有一个监听器和一个集群。</p><p id="0f24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经完成了所有的配置，我们可以将这个设置部署到kubernetes或者使用docker-compose来测试它。运行<code class="eh mb mc md me b">docker-compose build and docker-compose up</code>并点击<code class="eh mb mc md me b">localhost:8080</code>，您应该看到请求成功地通过了所有服务和特使代理。您可以使用日志来验证。</p><h2 id="3ea8" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">特使xDS</h2><p id="5483" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">我们通过为每个侧车提供配置来实现所有这些，根据服务的不同，配置会有所不同。最初用2或3个服务手工制作和手动管理这些侧车配置似乎没问题，但是当服务数量增加时，就变得困难了。此外，当侧车配置更改时，您必须重新启动特使实例，以使更改生效。</p><p id="cd74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如前所述，我们可以完全避免手动配置，并使用api服务器加载所有组件、集群(CD)、端点(ed)、监听器(LD)和路由(RDS)。因此，每台侧车将与api服务器通信以获取配置，当api服务器中的新配置更新时，它会自动反映在envoy实例中，从而避免重新启动。</p><p id="0f42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更多关于动态配置的信息<a class="ae ma" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview#dynamic" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ma" href="https://github.com/tak2siva/Envoy-Pilot" rel="noopener ugc nofollow" target="_blank">这里</a>是一个你可以使用的xDS服务器的例子。</p><h2 id="4c31" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">库伯内特斯</h2><p id="bdf0" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在本节中，让我们看看，如果我们在Kubernetes中实现这个设置，它会是什么样子</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/684f6bddd8906da5b43e29cde9c5546e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*UQQLPnMzHUn_hAL-lAvRQA.png"/></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">single service with envoy side car</figcaption></figure><p id="b0bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们需要改变</p><ol class=""><li id="4592" class="lc ld hu it b iu iv iy iz jc lx jg ly jk lz jo lh li lj lk dt translated">豆荚</li><li id="c34e" class="lc ld hu it b iu ll iy lm jc ln jg lo jk lp jo lh li lj lk dt translated">服务</li></ol><h2 id="2fbd" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">豆荚</h2><p id="8e18" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">通常Pod规范中只定义了一个容器。但是根据定义，一个容器可以容纳一个或多个容器。因为我们希望为每个服务实例运行一个侧车代理，所以我们将把Envoy容器添加到每个pod中。因此，为了与外界通信，服务容器将通过本地主机与特使容器对话。这是部署文件的样子</p><figure class="kq kr ks kt fq ku"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="58f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您看到集装箱部分，我们已经在那里添加了我们的特使侧车。我们从configmap的第33–39行安装我们的特使配置文件。</p><h2 id="c908" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">服务</h2><p id="4e97" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Kubernetes服务负责维护它可以将流量路由到的Pod端点列表。通常kube-proxy会在这些pod端点之间进行负载平衡。但是在我们的例子中，如果你还记得，我们正在进行客户端负载平衡，所以我们不希望kube-proxy进行负载平衡，我们希望获得Pod端点的列表并自己进行负载平衡。为此，我们可以使用“无头服务”，它将返回端点列表。这是它看起来的样子</p><figure class="kq kr ks kt fq ku"><div class="bz el l di"><div class="lv lw l"/></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">headless service in k8s</figcaption></figure><p id="e61a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第6行使服务无头化。您还应该注意到，我们没有将kubernetes服务端口映射到app的服务端口，但是我们映射了它的Envoy listeners端口。交通先去特使。</p><p id="414a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了它，你也可以和kubernetes搭配。</p><p id="d6a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样。期待您的评论。</p><p id="d715" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章是从使节<a class="ae ma" rel="noopener" href="/@dnivra26/microservices-monitoring-with-envoy-service-mesh-prometheus-grafana-a1c26a8595fc">跟随使节&amp;格拉法纳</a> &amp; <a class="ae ma" href="https://hackernoon.com/service-mesh-moving-from-bare-bones-envoy-to-istio-e0fef88fc1e3" rel="noopener ugc nofollow" target="_blank">迁移到伊斯蒂奥</a>的文章<a class="ae ma" rel="noopener" href="/@dnivra26/distributed-tracing-with-envoy-service-mesh-jaeger-c365b6191592">的先决条件。如果你感兴趣，请浏览它们。</a></p><p id="bff5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在这里找到所有的配置和代码<a class="ae ma" href="https://github.com/dnivra26/envoy_servicemesh" rel="noopener ugc nofollow" target="_blank"/>。</p><div class="mg mh fm fo mi mj"><a href="https://github.com/dnivra26/envoy_servicemesh" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab ej"><div class="ml ab mm cl cj mn"><h2 class="bd hv fv z el mo eo ep mp er et ht dt translated">dnivra26/envoy_servicemesh</h2><div class="mq l"><h3 class="bd b fv z el mo eo ep mp er et ek translated">在GitHub上创建一个帐户，为dnivra26/envoy_servicemesh开发做出贡献。</h3></div><div class="mr l"><p class="bd b gc z el mo eo ep mp er et ek translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kv mj"/></div></div></a></div></div></div>    
</body>
</html>