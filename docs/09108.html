<html>
<head>
<title>Build a CRUD API with MongoDB, Express, and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MongoDB、Express和Docker构建CRUD API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-crud-api-with-mongodb-express-and-docker-70510c6f706b?source=collection_archive---------3-----------------------#2018-11-05">https://medium.com/hackernoon/build-a-crud-api-with-mongodb-express-and-docker-70510c6f706b?source=collection_archive---------3-----------------------#2018-11-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9eb8750d5f9777576a80a6c2066f6c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wj9h4hHfFeRrtQRd9MI6Iw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/KjNGa3HvGgY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tim Easley</a> on <a class="ae jg" href="https://unsplash.com/search/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c830" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">世界正在被CRUD APIs蚕食，为什么不学着造一个呢？类似这个的项目是很常见的面试带回家的项目。在本教程中，我们将使用Express.js构建一个API，由MongoDB数据库支持，所有这些都用Docker Compose部署，并用Mocha和Travis CI测试。该API及其各种组件的设计大致基于<a class="ae jg" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank"> 12因子应用方法</a>。</p><h1 id="b364" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">设置</h1><p id="6121" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">您需要安装Node.js、Docker和Docker Compose。此外，您还需要一个免费的Github帐户和一个免费的Travis CI帐户。本教程假设您对Javascript(也会用到一些ES6特性，比如arrow函数)和Bash(或者您的操作系统的shell)有基本的了解。本教程的所有代码也可以在Github上找到。</p><p id="8215" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先让我们创建一个新目录(<code class="eh li lj lk ll b">mkdir</code>)并将<code class="eh li lj lk ll b">cd</code>放入其中。然后用<code class="eh li lj lk ll b">npm init</code>在里面创建一个新的Node.js包。还用<code class="eh li lj lk ll b">git init</code>初始化一个新的Git存储库。接下来，我们将使用<code class="eh li lj lk ll b">npm i --save express mongodb body-parser</code>和<code class="eh li lj lk ll b">npm i --save-dev mocha tape supertest</code>安装npm依赖项。之后，创建如下所示的目录结构:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="75e6" class="lu kg hu ll b fv lv lw l lx ly">crud-api<br/>├── docker/<br/>├── models/<br/>├── routes/<br/>└── tests/</span></pre><p id="9bd3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来的几个步骤是环境和忽略的辅助文件。首先让我们创建一个<code class="eh li lj lk ll b">.dockerignore</code>和一个<code class="eh li lj lk ll b">.gitignore</code>。Docker ignore文件通知您的Docker构建不包括哪些文件，而Git ignore为您的Git提交做同样的事情。我的看起来像这样:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="5b03" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">之后，你需要一个看起来像我的<code class="eh li lj lk ll b">example.env</code>的<code class="eh li lj lk ll b">.env</code>文件。这为Docker Compose提供了对我们的应用程序至关重要的信息，但是不应该存储在版本控制中。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="6722" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可选地，但是强烈推荐，您可以创建一个<code class="eh li lj lk ll b">README.md</code>和一个<code class="eh li lj lk ll b">LICENSE</code>。我们写点代码吧！</p><h1 id="6a1a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">编写服务器</h1><p id="4439" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们将跨3个文件构建这个Express服务器:<code class="eh li lj lk ll b">index.js</code>、<code class="eh li lj lk ll b">routes/routes.js</code>和<code class="eh li lj lk ll b">models/Document.js</code>。Express.js是一个极简的Node.js web框架，它利用了中间件的概念。当一个请求进入服务器时，它依次流经每个中间件，直到它到达终点并出错，或者某个函数基于它进行一些计算并返回。让我们从<code class="eh li lj lk ll b">index.js</code>开始。</p><h2 id="e64e" class="lu kg hu bd kh mb mc md kl me mf mg kp js mh mi kt jw mj mk kx ka ml mm lb mn dt translated">索引. js</h2><p id="22bc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果您以前使用过Express.js，这应该看起来很熟悉，但是我们将一节一节地介绍这一部分。首先是导入，<code class="eh li lj lk ll b">body-parser</code>可能不是一个显而易见的包，但它是中间件中非常重要的一部分。它解析传入请求的主体，以便在下一节中更容易地在我们的路由内部处理。接下来，我们根据开发或生产环境设置数据库名称，从环境变量中分配MongoDB url，并为MongoDB客户机设置选项。第一个选项使用较新的解析器，否则会得到一个方法弃用错误，另外两个选项控制数据库客户机失去连接时的行为。接下来，我们导入路由器，从环境中设置我们的服务器端口，但默认为80，接下来的两行是样板快速设置。</p><p id="a36f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们进入服务器的核心部分，中间件堆栈。您通常希望您的<code class="eh li lj lk ll b">body-parser</code>中间件解析器首先出现在API中，这样每个请求都会得到解析。然后你的请求到达你的服务器的路由器，如果它匹配里面描述的任何一条路由，那么相应的函数将被触发，一切正常。如果没有匹配的路线，那么我们的服务器将返回一个<code class="eh li lj lk ll b">404 Not Found</code>。</p><p id="5a16" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的最后一部分将我们的<code class="eh li lj lk ll b">MongoClient</code>连接到我们的MongoDB实例。总是以某种方式处理您的错误，但在这种情况下，我们希望记录一个错误并退出。在错误处理之后，我们将数据库连接分配给一个服务器全局变量，并启动服务器。当我们的服务器已经正确启动时,<code class="eh li lj lk ll b">app.emit</code>向我们的测试套件发出警报，我们导出服务器，这样我们就可以在测试中导入它。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="2a5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦你写完了所有这些，让我们开始规划我们的路线吧！</p><h2 id="cf55" class="lu kg hu bd kh mb mc md kl me mf mg kp js mh mi kt jw mj mk kx ka ml mm lb mn dt translated">routes/routes.js</h2><p id="991c" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在这个文件中，我们初始化并导出一个包含所有API路由的Express路由器。每个路由都采用router对象的形式，后跟HTTP方法。在每条路由中，我们定义路径和一个箭头lambda来处理我们的请求(<code class="eh li lj lk ll b">req</code>)和响应(<code class="eh li lj lk ll b">res</code>)。如果函数没有返回，而是希望将请求进一步传递到中间件堆栈，那么通常会调用<code class="eh li lj lk ll b">next</code>变量。在箭头lambda内的每一条路径中，我们首先从我们的服务器级变量<code class="eh li lj lk ll b">req.app.locals.db</code>获取MongoDB连接，然后是我们想要的集合。在这种情况下，我们只有一个集合，<code class="eh li lj lk ll b">documents</code>。然后在每种情况下，我们调用一个方法从数据库返回一些数据或错误。以下是这些功能及其对应的路径:</p><ul class=""><li id="4512" class="mo mp hu jj b jk jl jo jp js mq jw mr ka ms ke mt mu mv mw dt translated"><code class="eh li lj lk ll b">find()</code>获取集合中的所有文档— <code class="eh li lj lk ll b">/documents/all</code></li><li id="4320" class="mo mp hu jj b jk mx jo my js mz jw na ka nb ke mt mu mv mw dt translated"><code class="eh li lj lk ll b">findOne()</code>在这种情况下，根据客户端提供的文档id获取特定的文档— <code class="eh li lj lk ll b">/documents/:id</code></li><li id="2729" class="mo mp hu jj b jk mx jo my js mz jw na ka nb ke mt mu mv mw dt translated"><code class="eh li lj lk ll b">insertOne()</code>上传新文档到数据库— <code class="eh li lj lk ll b">/documents/new</code></li><li id="2a77" class="mo mp hu jj b jk mx jo my js mz jw na ka nb ke mt mu mv mw dt translated"><code class="eh li lj lk ll b">deleteOne()</code>根据客户提供的文档id删除文档— <code class="eh li lj lk ll b">/documents/delete/:id</code></li><li id="7b57" class="mo mp hu jj b jk mx jo my js mz jw na ka nb ke mt mu mv mw dt translated"><code class="eh li lj lk ll b">updateOne()</code>基于客户端发送的JSON请求体修改文档— <code class="eh li lj lk ll b">/documents/edit/:id</code></li></ul><p id="c0dc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">route中单词前面的冒号表示在处理程序中使用<code class="eh li lj lk ll b">req.params</code>访问的参数。由MongoDB自动分配给每个文档，这就是为什么我们的数据模型中没有唯一标识符或其他主键。在我们进行数据库查询之后，我们要么得到数据(<code class="eh li lj lk ll b">result</code>)要么得到错误(<code class="eh li lj lk ll b">err</code>)。我们的错误处理行为是使用我们的<code class="eh li lj lk ll b">res</code>对象发回一个包含错误的HTTP 400和JSON。否则，我们发回HTTP 200和查询结果。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="b520" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">之后，我们导出路由器对象，这样我们就可以在<code class="eh li lj lk ll b">index.js</code>中将它用作<code class="eh li lj lk ll b">/api</code>路由的路由中间件。这意味着我们每个API路径的完整路径是<code class="eh li lj lk ll b">/api/documents/</code>。最后，我们继续定义我们的数据模型。</p><h2 id="cc64" class="lu kg hu bd kh mb mc md kl me mf mg kp js mh mi kt jw mj mk kx ka ml mm lb mn dt translated">模型/文档. js</h2><p id="0afa" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">这份文件应该相当清楚。这是一个Javascript类，带有一个构造函数，接受3个字符串并存储它们。这充当了MongoDB中数据的模式。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="140e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">处理好服务器后，让我们继续用Docker部署我们的服务器！</p><h1 id="5016" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">将你的API分类</h1><p id="37bf" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">首先，我们需要为我们的生产构建编写<code class="eh li lj lk ll b">Dockerfile.production</code>。我们从基于<code class="eh li lj lk ll b">node:10.12.0-alpine</code>图像的容器开始。之后的第一层下载一个脚本，它将等待任意服务启动，这样服务就不会在没有依赖关系的情况下上线，我们用<code class="eh li lj lk ll b">chmod +x</code>使它可执行。之后，我们设置我们的工作目录。接下来，我们通过分配环境变量<code class="eh li lj lk ll b">NODE_ENV</code>让我们的应用程序知道我们正在生产中(在我们的服务器中，我们只检查<code class="eh li lj lk ll b">NODE_ENV === 'dev'</code>，但是我们稍后可能想要明确地检查<code class="eh li lj lk ll b">'prod'</code>)。在复制其他文件之前，我们复制我们的<code class="eh li lj lk ll b">package.json</code>并安装我们的依赖项，以便Docker可以缓存它们用于后续的构建。接下来，我们从<code class="eh li lj lk ll b">docker-compose.yml</code>和<code class="eh li lj lk ll b">.env</code>获取ARG端口，并将其暴露给内部Docker网络。成功复制了我们所有的文件。最后，我们执行脚本来等待MongoDB上线，然后运行我们的服务器。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="171d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的<code class="eh li lj lk ll b">Dockerfile.test</code>和第一个类似，其实就是基于第一个。拉出生产容器后，我们安装<code class="eh li lj lk ll b">dev-dependencies</code>和我们的测试转轮摩卡。最后，我们使用我们的测试运行器(<code class="eh li lj lk ll b">--exit</code>指定了一个旧版本的行为，所以Mocha一旦完成就退出)。该文件的其余部分应该与生产版本几乎相同。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="3fef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们已经准备好了两个docker文件，让我们构建将所有容器联机的<code class="eh li lj lk ll b">docker-compose.yml</code>。我们使用的是<code class="eh li lj lk ll b">docker-compose.yml</code>的<code class="eh li lj lk ll b">3.0</code>版本，与<code class="eh li lj lk ll b">2.x</code>版本有些不同，所以在查看堆栈溢出或其他教程时要小心。我们的主要部分是<code class="eh li lj lk ll b">services</code>，由我们的Node.js/Express.js<code class="eh li lj lk ll b">backend</code>和我们的MongoDB <code class="eh li lj lk ll b">database</code>组成。在<code class="eh li lj lk ll b">backend</code>中我们第一次遇到<code class="eh li lj lk ll b">build</code>；由于我们的文件在<code class="eh li lj lk ll b">docker/</code>中，我们需要将上下文设置为项目根目录，指定一个相对于根目录的Dockerfile，并注入我们的port环境变量。接下来，我们加载包含重要应用程序机密的<code class="eh li lj lk ll b">.env</code>,这些机密不打算提交给Git。我们希望我们的服务器经常并且优雅地失败，所以我们让Docker Compose总是重启它。接下来，我们绑定容器的暴露端口。最后，对于我们的脚本来说<code class="eh li lj lk ll b">WAIT_HOSTS</code>是必要的，它确保我们的服务器不会在我们的数据库之前上线。接下来我们有我们的<code class="eh li lj lk ll b">database</code>，它基于Docker Hub上发布的图像，而不是需要构建的本地Docker图像。我们再次为这个部分导入我们的<code class="eh li lj lk ll b">.env</code>。然后我们安装一个存储数据的地方，这样它将在容器之间持久化。接下来我们<code class="eh li lj lk ll b">expose</code> MongoDB到内部Docker网络的端口，但不是主机操作系统。最后，我们发出一个命令，以便Docker Compose可以启动我们的MongoDB实例。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="764b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个文件中只有几处不同，但它们相当重要。首先我们将Dockerfile更改为<code class="eh li lj lk ll b">Dockerfile.test</code>。其次，我们使用不同的数据存储位置进行测试，以免污染我们的生产数据。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="68cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们来看看我们的npm脚本。这些只是<code class="eh li lj lk ll b">docker-compose</code>命令的别名，所以我们没有输入长命令，如果需要，我们有一个单一的位置来改变命令。<code class="eh li lj lk ll b">-f</code>标志指示了<code class="eh li lj lk ll b">docker-compose.yml</code>的位置，因为我们没有将它们存储在项目根中。在所有容器联机或失败后，<code class="eh li lj lk ll b">up</code>后的<code class="eh li lj lk ll b">-d</code>标志使过程后台化。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="1ea7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦你完成了所有这些，就该进入最后一部分，测试我们的代码和部署了。</p><h1 id="1c0a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">测试您的代码</h1><p id="9aa0" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们要写一个集成测试。对于实际的生产应用程序，除了至少一个集成测试之外，您可能还需要一系列的单元测试。对于单元测试，你需要一个独特的<code class="eh li lj lk ll b">it()</code>函数用于每个测试，一个<code class="eh li lj lk ll b">beforeEach()</code>函数用于插入测试文档，一个<code class="eh li lj lk ll b">afterEach()</code>函数用于在测试完成后移除文档。</p><p id="287f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们从编写一个<code class="eh li lj lk ll b">before()</code>函数开始，该函数等待<code class="eh li lj lk ll b">app.emit</code>在<code class="eh li lj lk ll b">index.js</code>触发，表示我们的服务器已经成功启动。一旦完成，我们就调用<code class="eh li lj lk ll b">done()</code>回调，这样Mocha就知道要继续测试了。</p><p id="b241" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们从包含单个<code class="eh li lj lk ll b">it()</code>函数的<code class="eh li lj lk ll b">describe()</code>块开始，因为我们只有一个测试。每个连续步骤被描述为一个<code class="eh li lj lk ll b">test()</code>功能。为了插入一个新文档，获取所有文档并存储一个用于其他测试的文档id，获取一个特定的文档，更新一个特定的文档，最后删除一个特定的文档。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="81e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦我们完成了所有的测试，我们就可以进入Travis CI配置了。默认情况下，Travis不启动大多数服务，所以我们显式启动Docker。然后我们检查我们的Docker版本(不是绝对必要的，方便调试版本不匹配或者Docker没有运行)，将我们的<code class="eh li lj lk ll b">example.env</code>复制到<code class="eh li lj lk ll b">.env</code>以便我们的构建正确运行，并且我们停止一些不必要的服务以便我们的构建和测试运行得更快。之后，我们使用我们的npm脚本来构建我们的生产容器，并使用它们作为运行我们测试的资源。</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="c510" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦你写完了所有这些，你就应该能够进入Github，并在Travis CI上查看你的存储库页面，以获得一个通过的版本！要在本地运行您的服务，键入<code class="eh li lj lk ll b">npm run build</code>，一旦完成<code class="eh li lj lk ll b">npm run production</code>。一旦这些都完成了，你就可以运行<code class="eh li lj lk ll b">docker ps</code>来显示所有正在运行的容器，这将显示你的MongoDB容器和一个名为<code class="eh li lj lk ll b">docker_backend</code>的容器。你现在可以运行<code class="eh li lj lk ll b">curl localhost:80/api/documents/all</code>，它将返回<code class="eh li lj lk ll b">{“error": “No documents in database"}</code>。我建议使用下面的Markdown代码片段将当前的构建状态嵌入到您的<code class="eh li lj lk ll b">README.md</code>中:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="f408" class="lu kg hu ll b fv lv lw l lx ly">[![Build Status](<a class="ae jg" href="https://travis-ci.org/torchhound/mongo-crud.svg?branch=master)](https://travis-ci.org/torchhound/mongo-crud)" rel="noopener ugc nofollow" target="_blank">https://travis-ci.org/&lt;your Github username&gt;/&lt;your repository name&gt;.svg?branch=master)](https://travis-ci.org/</a><a class="ae jg" href="https://travis-ci.org/torchhound/mongo-crud.svg?branch=master)](https://travis-ci.org/torchhound/mongo-crud)" rel="noopener ugc nofollow" target="_blank">&lt;your Github username&gt;</a><a class="ae jg" href="https://travis-ci.org/torchhound/mongo-crud.svg?branch=master)](https://travis-ci.org/torchhound/mongo-crud)" rel="noopener ugc nofollow" target="_blank">/</a><a class="ae jg" href="https://travis-ci.org/torchhound/mongo-crud.svg?branch=master)](https://travis-ci.org/torchhound/mongo-crud)" rel="noopener ugc nofollow" target="_blank">&lt;your repository name&gt;</a><a class="ae jg" href="https://travis-ci.org/torchhound/mongo-crud.svg?branch=master)](https://travis-ci.org/torchhound/mongo-crud)" rel="noopener ugc nofollow" target="_blank">)</a></span></pre><p id="4448" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢阅读，如果这篇教程对你有帮助，请留下一个或几个掌声！</p><p id="39ac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> <em class="nc"> Joe Cieslik是Whiteboard Dynamics的CEO，这是一个专门从事函数式编程和Android的全栈开发团队。你可以雇佣我或我的团队在</em></strong><a class="ae jg" href="https://whiteboarddynamics.co/" rel="noopener ugc nofollow" target="_blank"><strong class="jj hv"><em class="nc">【whiteboarddynamics.co】</em></strong></a><strong class="jj hv"><em class="nc">打造你的下一个杀手级app。</em>T13】</strong></p></div></div>    
</body>
</html>