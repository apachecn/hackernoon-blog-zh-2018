<html>
<head>
<title>An in-depth look at 100% Zero Downtime deployments with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Terraform的100%零停机部署</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform-checkly-58cdda2784e8?source=collection_archive---------21-----------------------#2018-11-05">https://medium.com/hackernoon/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform-checkly-58cdda2784e8?source=collection_archive---------21-----------------------#2018-11-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/6af03d2338b1bcf874cbbe7c6e9c0071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hygTwxW1DyF54Jfz.jpg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“Sailing on a Blue Ocean” by Shotei Takahashi (1871–1945) — <a class="ae jg" href="http://www.jaodb.com/db/ItemDetail.asp?item=38681" rel="noopener ugc nofollow" target="_blank">Japanese Open Art Database</a></figcaption></figure><p id="c5d8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Checkly，我们在Terraform管理的AWS EC2实例上运行我们的<a class="ae jg" href="https://checklyhq.com/docs/browser-checks/quickstart/" rel="noopener ugc nofollow" target="_blank">浏览器检查</a>。在发布新版本时，我们不想中断服务，因此我们需要零停机部署。Hashicorp】有他们自己的关于零停机升级的文章，但它只介绍了Terraform配置，而没有很多在现实生活中实际实现该配置所需的上下文、工作流程或其他细节。</p><p id="3778" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是自发布以来，我们在生产中对大约150万基于Chrome的浏览器进行检查的全部内幕。</p><h1 id="5988" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">问题</h1><p id="64af" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">对于那些对“作为代码的基础结构”和“不可变基础结构”不太熟悉的人，让我们更仔细地看看这个问题。您将会看到，您必须以特定的方式构建您的应用程序，并准备好一些特定的中间件(即队列)才能从这种方法中受益。如果你是一个头发花白的老兵，跳过这一步。</p><p id="1307" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以把这个问题分成许多部分。有些与地形有关，有些与地形无关，但它们都需要在不打扰用户的情况下完成。</p><p id="18a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">举个例子，这个应用可以被定义为一个“工作者”。工作者基于工作队列处理传入的请求。在<a class="ae jg" href="https://checklyhq.com/blog/2018/08/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform/#architecture" rel="noopener ugc nofollow" target="_blank">架构</a>部分会有更多相关信息。现在，让我们看看我们对员工和员工部署流程的要求:</p><p id="0a10" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">架构问题</strong></p><ol class=""><li id="03ac" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">工人应该是“可杀死的”,而不影响用户体验。</li><li id="234f" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">多个版本的工人应该能够共存。</li><li id="3f91" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">工人应该独立升级。</li></ol><p id="1f28" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">部署问题(由Terraform解决)</strong></p><ol class=""><li id="8ffd" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">新工人一旦准备好就应该开始接受生产工作。</li><li id="4363" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">只有当新员工开始工作并接受工作时，才能终止旧员工。</li><li id="b051" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">拙劣的版本应该会停止推出。</li><li id="4eac" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">它应该在多个AWS区域上工作。</li></ol><p id="44b6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">操作问题</strong></p><ol class=""><li id="76cb" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">新工人应该自动加入你的监控库。</li><li id="fa80" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">拙劣的发布应该会触发警报。</li></ol><p id="bcbf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中一些问题应该在推广过程中解决，而其他问题应该在您的应用程序架构中解决。</p><h1 id="5bbc" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">建筑</h1><p id="946f" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">上面提到的一些问题可以通过遵循典型的扇出/扇入模式或主/工作模式来解决。这对于Checkly用例特别有用，因为用户不直接与工作人员交互。</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lw"><img src="../Images/8815f9f0309df54fd93e3d2185b89888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a3KZjDlaAVDCUOkL.png"/></div></div></figure><p id="63c0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Checkly的例子中，架构如下:</p><ol class=""><li id="bd2a" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">cron进程将支票推送到SQS队列。每张支票都是一条JSON格式的消息，代表客户账户中一张支票的一次运行。</li><li id="795a" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">工作人员订阅队列。每个EC2实例有5个活动的工作线程。worker是Docker容器中的Node.js进程。Docker不是必需的，但是它使部署变得更容易，这一点你将在下一章中看到。工人使用<a class="ae jg" href="https://github.com/bbc/sqs-consumer" rel="noopener ugc nofollow" target="_blank"> SQS消费者图书馆</a>。当一个作业完成时，它调用一个<code class="eh mb mc md me b">done()</code>回调，从队列中删除消息。</li><li id="08c4" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">如果工作没有成功完成，<code class="eh mb mc md me b">done()</code>回调就不会被调用，或者调用时出现错误<code class="eh mb mc md me b">done(err)</code>。这触发了SQS特有的行为，消息在队列中再次可见，其他工作人员可以拾取它。这是关键，因为我们现在可以自由地杀死一个工人而不会错过任何工作。这是一个SQS函数，但是几乎任何排队平台都有。</li><li id="597d" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">如果工作成功完成，结果将被发送到另一个队列进行处理和存储。</li></ol><p id="7a64" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">应用这种模式解决了与模式固有的负载平衡和解耦属性相关的架构问题。当然，这种模式也允许非常容易的伸缩。更多消息===更多工人。</p><p id="6f07" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，这还允许基于负载特征的<strong class="jj hv">自动伸缩</strong>，比如队列中的消息数量(以及它们的相对年龄)或者EC2实例的1m、5m和15m平均负载。这是因为向上扩展很容易，但是在不打扰用户或影响您的服务的情况下向下扩展要困难得多。解决部署的这个问题也解决了自动扩展的问题。一石二鸟。</p><blockquote class="mf mg mh"><p id="67b2" class="jh ji mi jj b jk jl jm jn jo jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd ke hn dt translated"><em class="hu">用于任何远程有状态或交互的东西(即具有会话状态、数据源等的API / Web服务器)。)如果没有类似请求排出、基于粘性会话的路由或中央会话存储，这种模式几乎就是一个nogo。</em></p></blockquote><h1 id="5af3" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Terraform模块和配置</h1><p id="fa9b" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如前所述，Terraform为您提供了两个原语来实现零停机部署。</p><ul class=""><li id="6f1a" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke mm lo lp lq dt translated"><code class="eh mb mc md me b">lifecycle</code>配置块中的<code class="eh mb mc md me b">create_before_destroy</code>标志。有点不言自明。在新服务器上线之前，你不能关闭现有的服务器。</li><li id="ee0e" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated"><code class="eh mb mc md me b">local-exec</code>或<code class="eh mb mc md me b">remote-exec</code>供应器。这将执行一个命令。当它返回时，Terraform继续其计划执行。</li></ul><p id="5966" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您将会发现，要在多个地区实现这一目标，您还需要一系列其他东西。让我们看看Checkly的. tf文件中的<code class="eh mb mc md me b">aws_instance</code>配置。</p><pre class="lx ly lz ma fq mn me mo mp aw mq dt"><span id="bd02" class="mr kg hu me b fv ms mt l mu mv">// workers/module.tf<br/><br/>resource "aws_instance" "browser-check-worker" {<br/>  ami = "${data.aws_ami.default.id}" // AWS Linux AMI<br/>  instance_type = "${var.instance_type}"<br/>  count = "${var.count}"<br/>  tags {<br/>    Name = "browser-check-worker-${count.index}"<br/>    Version = "0.9.0",<br/>    Env = "${var.env}" // prod or test<br/>  }<br/>  user_data = "${var.user_data}" // User data pulls &amp; starst the app<br/>  <br/>  key_name = "checkly"<br/><br/>  lifecycle  {<br/>    create_before_destroy = true<br/>  }<br/><br/>  // Every 5 seconds, check if the launcher.js process is up.<br/>  <br/>  provisioner "remote-exec" { <br/>    inline = [<br/>      "until ps -ef | grep [l]auncher.js &gt; /dev/null; do sleep 5; done"<br/>    ]<br/><br/>    connection {<br/>      type     = "ssh"<br/>      user     = "ec2-user"<br/>      private_key = "${file("~/.ssh/checkly.pem")}"<br/>    }<br/>  }<br/>}</span></pre><p id="5c6b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该文件的一些要点:</p><ol class=""><li id="37d2" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">我们可以调整AMI类型、实例类型和每个区域的总实例数。</li><li id="213b" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">我们用每个EC2实例运行的代码版本来明确标记它。</li><li id="98fd" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">我们引入一个<code class="eh mb mc md me b">user-data.yml</code>文件来引导应用程序。更多详情见下文。</li><li id="fa9a" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">我们提供了一个SSH密钥，这样我们就可以连接到实例。</li></ol><p id="34a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回报在于使用<code class="eh mb mc md me b">remote-exec</code> provisioner(它使用SSH密钥)。它每5秒检查一次<code class="eh mb mc md me b">launcher.js</code>进程是否正在运行。注意我们使用<code class="eh mb mc md me b">grep [l]auncher.js</code>语法从进程列表中排除grep命令本身。不这样做将会立即返回这个命令并破坏整个目的。</p><p id="60c8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不可否认，这是相当简单的，但是对于我们的用例来说，这正是我们所需要的。启动器进程的存在意味着我们的代码正在运行，它已经准备好从SQS队列中读取新消息。</p><p id="1df1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了充分理解这一点，我们需要查看一个用户数据文件。</p><pre class="lx ly lz ma fq mn me mo mp aw mq dt"><span id="e18d" class="mr kg hu me b fv ms mt l mu mv">#cloud-config<br/>packages:<br/>  - docker<br/><br/>write_files:<br/>  - path: /root/.profile<br/>    owner: root:root<br/>    permissions: '0644'<br/>    content: |<br/>      # ~/.profile: executed by Bourne-compatible login shells.<br/><br/>      if [ "$BASH" ]; then<br/>        if [ -f ~/.bashrc ]; then<br/>          . ~/.bashrc<br/>        fi<br/>      fi<br/><br/>      export NODE_ENV=production<br/>      export AWS_REGION=ap-south-1    <br/>      export WORK_QUEUE=https://sqs.ap-south-1.amazonaws.com/xxxx/checks<br/>      export RESULTS_QUEUE=https://sqs.ap-south-1.amazonaws.com/xxxx/results<br/>runcmd:<br/>  - service docker start<br/>  - [., /root/.profile]<br/>  - [docker, login, -u, checkly, -p, "pwd"]<br/>  - [docker, pull, "checkly/browser-checks-launcher:latest"]<br/>  - . /root/.profile &amp;&amp; docker run -d -e NODE_ENV=$NODE_ENV ... checkly/browser-checks-launcher:latest</span></pre><ol class=""><li id="d903" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated">我们将<code class="eh mb mc md me b">docker</code>包作为一个要求。我们用的AWS AMI预装了Docker，但是谁知道…</li><li id="541e" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">我们创建一个<code class="eh mb mc md me b">.profile</code>文件，其中包含我们的工作人员需要操作的必要环境变量，比如它与之通信的两个队列的地址、它服务的区域以及它工作的环境(生产或测试)。</li><li id="f984" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated">在启动时，我们启动Docker并登录到我们的私有Docker repo。我们取出我们工人的最新图像，并<code class="eh mb mc md me b">docker run</code>传入所有的环境变量。</li></ol><p id="db9a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请记住，从Terraform的角度来看，这些都没有标志着我们的新实例已经“完成”。<code class="eh mb mc md me b">remote-exec</code>命令只在docker容器完全运行并启动相关节点进程后返回。</p><p id="9402" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">结果如下所示:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/43915a643654b4c6a02abc964f88c83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MZ8DKlKtlF-paBBA.png"/></div></div></figure><p id="bba2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，这个过程相当普通。你可以对任何Dockerized应用程序或任何Ruby、Python、Java等应用程序做同样的事情。</p><p id="c510" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">AWS多区域地形配置对于AWS如何管理命名、资源、访问等非常具体。每个地区。我们也有数字海洋的地形配置，它们使实现这一目标变得更加简单。我们利用这篇博文中描述的地形策略<a class="ae jg" rel="noopener" href="/@ctindel/multi-region-aws-app-deployments-with-terraform-modules-859c9ecb64f4">。</a></p><p id="8e73" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要掌握的主要事情是，对于每个AWS区域，您在您的<code class="eh mb mc md me b">main.tf</code>文件中创建一个模块，并使用<code class="eh mb mc md me b">source</code>属性引用a模板。</p><pre class="lx ly lz ma fq mn me mo mp aw mq dt"><span id="ab3e" class="mr kg hu me b fv ms mt l mu mv">// main.tf<br/><br/>module "workers-us-east-1" {<br/>  source = "workers"<br/>  region = "us-east-1"<br/>  count = 1<br/>  user_data = "${file("user-data-us-east-1.yml")}"<br/>  env = "prod"<br/>}<br/><br/>module "workers-us-west-1" {<br/>  source = "workers"<br/>  region = "us-west-1"<br/>  count = 3<br/>  user_data = "${file("user-data-us-west-1.yml")}"<br/>  env = "prod"<br/>}</span></pre><p id="3776" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这利用了Terraform的模块层次结构，并允许您针对不同的区域使用不同的变量。更重要的是，它允许用一个命令部署到多个区域。</p><blockquote class="mf mg mh"><p id="a66e" class="jh ji mi jj b jk jl jm jn jo jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd ke hn dt translated">但是为什么要创建新的实例呢？worker被发布为Docker容器，难道我们不能拉一个新的容器，循环旧的容器，然后结束它吗？是的，那行得通。我们一直在开发过程中使用它。但是，对于生产，我们希望确保配置没有因手动干预而漂移</p></blockquote><h1 id="1009" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">部署工作流程</h1><p id="9f3f" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">设置好所有这些之后，我们如何发布我们worker的新版本呢？一般来说，步骤如下:</p><p id="14d5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们构建一个新的Docker容器。将其标记为最新，并将其推送到我们的私人回购。这里没什么特别的。</p><p id="ffdf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其次，我们更新我们的<code class="eh mb mc md me b">module.tf</code>文件中的版本。</p><p id="2644" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们使用Terraform <code class="eh mb mc md me b">taint</code>命令强制执行创建/销毁循环。为什么？因为Terraform没有办法知道我们想要拉一个新的容器。仅仅修改版本不足以触发EC2实例的替换。</p><pre class="lx ly lz ma fq mn me mo mp aw mq dt"><span id="53fc" class="mr kg hu me b fv ms mt l mu mv">terraform taint -module=runners-us-west-1 aws_instance.browser-check-worker</span></pre><p id="2dfd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意，<code class="eh mb mc md me b">-module</code>根据<code class="eh mb mc md me b">main.tf</code>文件中的模块声明将AWS区域作为目标。从这里开始，这是一个简单的<code class="eh mb mc md me b">terraform plan</code>和/或<code class="eh mb mc md me b">terraform apply</code>，✨看到了零停机时间的魔力。✨</p><p id="c460" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不需要天才就能看出，这可以很容易地转换成在CI/CD平台上运行的脚本。它遵循以下一般模式:</p><ul class=""><li id="80bd" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke mm lo lp lq dt translated">建设</li><li id="b15d" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated">试验</li><li id="c289" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated">包裹</li><li id="3c37" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated">部署</li><li id="1f4b" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated">班长</li></ul><p id="6926" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其中每个阶段可以中断并将控制返回给操作者。当这种情况发生时，你的CI/CD平台可能会给你发一封电子邮件。</p><h1 id="2f82" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">监视</h1><p id="2bd2" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">以上所有方法都可能失败。失败的原因可能很迟钝，比如AWS改变了一些API(破坏了Terraform)，你的错误代码，或者仅仅是星期五下午。一般来说，失败分为两类:</p><ol class=""><li id="5d6f" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke ln lo lp lq dt translated"><strong class="jj hv">部署失败</strong>。这些既容易又棘手。首先，它们在您部署时出现。您的Terraform命令返回错误。这可能会使您的多区域部署处于不确定状态。我建议以这样一种方式编写您的代码，使您的应用程序能够处理这种情况。另一种方法是完全回滚，这可能会更加困难。可能需要一些手工操作。</li><li id="412f" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke ln lo lp lq dt translated"><strong class="jj hv">代码故障</strong>。您的新版本可能会部署甚至启动良好。它只是可能在开始接收流量时由于一些逻辑错误而失败。为此，您应该使用错误跟踪服务(如Sentry、Bugsnap或Rollbar)来检测您的代码。其次，我强烈建议在x时间内“当什么都没发生时”触发某种警报。举个例子，我们运行<a class="ae jg" href="https://appoptics.com/" rel="noopener ugc nofollow" target="_blank">appoptics.com</a>(以前的Librato)，当某个特定区域的工人“什么都没发生”时，它会提醒我们。</li></ol><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/163ec140c0fd98793d1264d49fbe443a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hJTWild2jr5ZF7pc.png"/></div></div></figure><p id="64ac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，这只是因为我们的代码在每次运行时都显式地调用了AppOptics API，以及一些关于worker正在哪个区域运行的基本细节，使用下面的代码。</p><pre class="lx ly lz ma fq mn me mo mp aw mq dt"><span id="9a38" class="mr kg hu me b fv ms mt l mu mv">const <em class="mi">axios</em> = <em class="mi">require</em>('axios')<br/><br/><em class="mi">axios</em>.defaults.<em class="mi">baseURL</em> = `https://${<em class="mi">config</em>.appOptics.apiToken}@api.appoptics.com/v1`<br/><br/>const <em class="mi">namespace</em> = 'checkly'<br/><br/>const trackRunCount = function () {<br/>  const <em class="mi">payload</em> = {<br/>    <em class="mi">tags</em>: {<br/>      <em class="mi">region</em>: process.<em class="mi">env</em>.AWS_REGION || 'local'<br/>    },<br/>    <em class="mi">measurements</em>: [<br/>      {<br/>        <em class="mi">name</em>: `${<em class="mi">namespace</em>}.browser-check-worker.count`,<br/>        <em class="mi">value</em>: 1<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="fe52" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这也是我们的具体情况，因为用户不直接与工作人员交互。在典型的客户机/web服务器场景中，500个错误或缺少200个响应代码可以作为类似的触发。最后，<strong class="jj hv">您需要确定您的应用程序正在成功处理用户请求，而不管您的部署是否成功</strong>。</p><p id="bdf2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Terraform还<a class="ae jg" href="https://www.terraform.io/docs/providers/type/monitor-index.html" rel="noopener ugc nofollow" target="_blank">提供了大量的监控提供者</a>，你可以把它们钩入你的部署程序。如果您有特定的监控解决方案，请使用它。</p><h1 id="23aa" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="27ea" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在不造成服务中断的情况下，使用Terraform进行零停机部署比仅仅使用正确的Terraform命令和配置要复杂得多。要点是:</p><ul class=""><li id="8a73" class="li lj hu jj b jk jl jo jp js lk jw ll ka lm ke mm lo lp lq dt translated">您的体系结构决定了实现零停机部署的难易程度。</li><li id="58e2" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated">有效的基础设施不等于有效的服务。</li><li id="21d5" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated">一切都有可能中断，请在基础架构和服务级别使用监控。</li><li id="2e2c" class="li lj hu jj b jk lr jo ls js lt jw lu ka lv ke mm lo lp lq dt translated">当事情发生时，将需要人类。</li></ul></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="b543" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">【checklyhq.com】最初发表于<a class="ae jg" href="https://checklyhq.com/blog/2018/08/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform/" rel="noopener ugc nofollow" target="_blank"><em class="mi"/></a><em class="mi">。</em></p><p id="ad1f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">附:如果你喜欢这篇文章，请用<strong class="jj hv">鼓掌</strong>来表达你的欣赏👏下面还有<a class="ae jg" href="https://twitter.com/tim_nolet" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">在Twitter上关注我</strong> </a> <strong class="jj hv">！</strong>但是等等，还有更多！</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><a href="https://checklyhq.com"><div class="ab fr cl nf"><img src="../Images/c046e98b4cae453aaa2487ddb1784866.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vLER_jsAmfiKdYAa5EXEZA.png"/></div></a></figure></div></div>    
</body>
</html>