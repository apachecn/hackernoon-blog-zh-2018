<html>
<head>
<title>Common Misconceptions of C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对C++的常见误解</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/common-misconceptions-of-c-4f49f36b92a?source=collection_archive---------0-----------------------#2018-11-06">https://medium.com/hackernoon/common-misconceptions-of-c-4f49f36b92a?source=collection_archive---------0-----------------------#2018-11-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/23ae344cd743df9460ca7fcabb3c120f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VnRpBjBGlsoVhY0M"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“black swirl of letters” by <a class="ae jg" href="https://unsplash.com/@nshuman1291?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nathaniel Shuman</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c9ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">C++在最近几年有了很大的发展，但许多人仍然认为它是21世纪初的语言。让我们驱散一些迷思…</p><h2 id="8003" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">C++是一种濒临死亡的语言</h2><p id="0788" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">C++居然在成长！即使计算机变得越来越快，我们对用它们做什么的需求也一直在增加。C++是允许我们最大化硬件潜力的少数语言之一。</p><p id="2156" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Stroustrup在CPP Con上的演讲展示了C++的成长轨迹。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="bcec" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">C++冗长而低效</h2><p id="7634" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">有了新的<code class="eh ll lm ln lo b">auto</code>关键字和λ语法，C++可以正确、快速<em class="lp">和</em>简洁。</p><p id="80e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，比较JavaScript和C++ 14中的这两个程序:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">JavaScript</figcaption></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">C++</figcaption></figure><p id="c023" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，C++稍微长一点，但是想想你得到的回报:</p><ul class=""><li id="7603" class="lr ls hu jj b jk jl jo jp js lt jw lu ka lv ke lw lx ly lz dt translated">强类型系统和编译时类型检查</li><li id="eeac" class="lr ls hu jj b jk ma jo mb js mc jw md ka me ke lw lx ly lz dt translated">没有类似Node.js的运行时依赖</li><li id="c851" class="lr ls hu jj b jk ma jo mb js mc jw md ka me ke lw lx ly lz dt translated"><em class="lp">执行时间的分数</em></li></ul><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><h2 id="5e7d" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">C是C++的子集</h2><p id="4e02" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">虽然在C++中经常可能包含C代码，但情况并非总是如此。以下代码片段是有效的C，但不是有效的C++:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><h2 id="be00" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">你需要了解C才能理解C++</h2><p id="6f1d" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">C++是它自己的语言，有自己的习惯用法和最佳实践。如果你只学习C++作为C的扩展，那么你就不会学习这些模式，很可能会写出容易出错的代码！</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><p id="b7c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">凯特·格雷戈里做了一个非常精彩的演讲，非常值得你花时间去做。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="c1d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有多少开发人员因为被教着像C一样使用C++而有过负面体验？</p><h2 id="6b7e" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">C比C++快</h2><p id="55be" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">C++允许你编写抽象，编译成等价的C。这意味着只要小心，C++程序将至少和C一样快。与C相比，C++的优势在于它使我们能够用模板、面向对象和功能组合来构建可重用的抽象。</p><p id="8c05" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">C++给了你在类型系统中编码你的意图的工具。这允许编译器从您的代码中生成最佳的二进制文件。</p><h2 id="8885" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">C++不是跨平台的</h2><p id="6867" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">C++ <em class="lp">语言</em>是完全跨平台的。许多人声称C++不是的原因是标准库不像Java这样的语言那样提供文件系统、网络访问等平台抽象。</p><p id="b977" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">相反，C++要求你使用一个库，或者自己写一个。这可能看起来很痛苦(尽管有了<a class="ae jg" href="https://github.com/loopperfect/buckaroo" rel="noopener ugc nofollow" target="_blank">包管理器</a>就没那么痛苦了)。)，但其实是好事。</p><ol class=""><li id="186e" class="lr ls hu jj b jk jl jo jp js lt jw lu ka lv ke mf lx ly lz dt translated">为了瞄准一个新的平台，编译器实现者需要实现的东西更少了。</li><li id="9b61" class="lr ls hu jj b jk ma jo mb js mc jw md ka me ke mf lx ly lz dt translated">能力有限的平台目标可以支持C++。如果标准需要某个平台由于硬件限制而无法提供的特性，会发生什么？</li><li id="8b2e" class="lr ls hu jj b jk ma jo mb js mc jw md ka me ke mf lx ly lz dt translated">您可以自由选择最适合您的应用程序的库。这不是一个放之四海而皆准的办法。</li></ol><h2 id="44b9" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">apt-get是C++的包管理器</h2><p id="894a" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们在<a class="ae jg" href="https://hackernoon.com/approaches-to-c-dependency-management-or-why-we-built-buckaroo-26049d4646e7" rel="noopener ugc nofollow" target="_blank">之前的一篇文章</a>中详细介绍了这一点，但简短的版本是:</p><ul class=""><li id="a666" class="lr ls hu jj b jk jl jo jp js lt jw lu ka lv ke lw lx ly lz dt translated">仅适用于Debian变体</li><li id="b0ee" class="lr ls hu jj b jk ma jo mb js mc jw md ka me ke lw lx ly lz dt translated"><code class="eh ll lm ln lo b">apt-get</code>突变你的系统，在项目间切换时不方便</li><li id="cc8d" class="lr ls hu jj b jk ma jo mb js mc jw md ka me ke lw lx ly lz dt translated"><code class="eh ll lm ln lo b">apt-get</code>不是新版本和实验版本库的好来源</li></ul><h2 id="7356" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">C++是关于类的</h2><p id="a4ac" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在早期，C和C++的最大区别是C++提供了类。这仍然是正确的，但是类不再是C++的主要特征。在现代C++中，重点是RAII模式。C++实际上不是关于类的，它是关于确定性资源管理的。</p><h2 id="e015" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">对于可靠的软件来说，垃圾收集是强制性的，因此C++对于大型项目来说是不好的</h2><p id="fba2" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">C++的资源管理方法(内存只是其中的一种)是使用RAII模式，而不是集中式垃圾收集器。</p><p id="7f60" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这有点像其他语言中看到的“using”模式。例如，在C#中，我们可能会写:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><p id="3a26" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在C++中，处理应该由<em class="lp">析构函数</em>来完成:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><p id="61c5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，这实际上不太冗长；另外，我们可以对内存<em class="lp">和</em>其他资源使用相同的模式。</p><p id="9623" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是还有另一个优点:对象处理的顺序和时机是由它们的使用范围决定的。这使得在函数级控制垃圾收集过程成为可能，而大多数垃圾收集语言只允许在全局级进行(<em class="lp">有限的</em>)控制。</p><p id="185f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这在大型项目中有更大的好处，因为它防止一个模块将垃圾收集延迟引入另一个模块。这就是为什么C++是游戏开发和音频处理的首选语言。</p><h2 id="9f1b" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">为了提高性能，您必须编写低级代码</h2><p id="fc52" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">C++编译器在优化高级代码方面做得非常出色。这可以让你避免低水平的编写，同时仍然获得很好的性能。有时性能甚至更好，因为编译器可以执行手工编写起来太复杂的优化。</p><p id="4c74" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们最喜欢的例子是使用我们新的C++序列库<a class="ae jg" href="https://github.com/LoopPerfect/conduit" rel="noopener ugc nofollow" target="_blank">管道</a>。这个程序使用lambdas、协同程序等计算各种Fibonacci数的和:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><p id="b5f9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，它编译成:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lq lk l"/></div></figure><p id="207c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这意味着优化器能够计算60个斐波那契数，并在编译时将最后50个相加！</p><h1 id="fa19" class="mg kg hu bd kh mh mi mj kl mk ml mm kp mn mo mp ks mq mr ms kv mt mu mv ky mw dt translated">既然你在这里…</h1><p id="a66b" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们最近发布了<a class="ae jg" href="https://buildinfer.loopperfect.com/" rel="noopener ugc nofollow" target="_blank"> BuildInfer </a>，这是一款优化C/C++构建脚本的新工具。<a class="ae jg" href="https://buildinfer.loopperfect.com/" rel="noopener ugc nofollow" target="_blank">看一看</a>！</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/c16cb35622494d4d7a5014e13c3a6131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*YZgG5MjrKJ9nV_a7bJtHuA.png"/></div></figure></div></div>    
</body>
</html>