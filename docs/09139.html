<html>
<head>
<title>Angular 7 — HTTP and Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 7 — HTTP和身份验证</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/angular-7-http-exploration-ffadddc8d745?source=collection_archive---------1-----------------------#2018-11-06">https://medium.com/hackernoon/angular-7-http-exploration-ffadddc8d745?source=collection_archive---------1-----------------------#2018-11-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/0d450e371bb2293b9dae59309c87f6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKb9TdxSYjVzWindUWaGUg.png"/></div></div></figure><div class=""/><p id="aa4c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很长一段时间没有发帖，空闲时间和无聊激发了我的灵感，所以让我们分享一点我在过去几个月里一直在学习的东西。这个帖子将是关于<em class="kb"> Angular 7 </em>中的<a class="ae ka" href="https://hackernoon.com/tagged/http" rel="noopener ugc nofollow" target="_blank"> Http </a>请求。</p><p id="c523" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb"> Angular 7 </em>应用程序中的Http请求与我们习惯的第一版Angular略有不同，一个根本的区别是<em class="kb"> Angular 7 </em>中的<em class="kb"> HttpClient </em>返回可观察的对象。</p><p id="22da" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">公平地说，大多数<em class="kb"> Angular 7 </em>看起来与<em class="kb"> Angular 1.x </em>完全不同，Http <a class="ae ka" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>也不例外。<em class="kb"> Angular 1.x </em>为我们提供的<em class="kb"> $http </em>服务在大多数情况下都非常有效，并且易于使用。在Angular 7 <em class="kb">中，HttpClient </em>要求我们学习一些新概念，包括如何处理<em class="kb">可观察对象。</em></p><h1 id="c558" class="kc kd if bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">Angular 1.x $http和Angular 7 HttpClient的区别</h1><p id="f156" class="pw-post-body-paragraph jc jd if je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在<em class="kb"> Angular 7 </em>中，Http实现提供了一种简单的处理请求的方式，但是有一些重要的区别。</p><p id="7b4a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，<em class="kb"> Angular 7 </em>中的HTTP调用默认通过<em class="kb"> RxJS </em>返回对象可观察，而<em class="kb"> Angular 1.x </em>中的<em class="kb"> $http </em>返回承诺。当处理来自Http请求的响应时，可观察流的使用为我们提供了更大的灵活性。</p><p id="02d4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，如何修复失败的Http请求是自动转发的，这对于用户网络通信缓慢或断断续续的情况很有用。</p><p id="527f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将在本文后面看到如何在我们的observables中实现<em class="kb"> RxJS </em>操作符。</p><p id="9583" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="kb"> Angular 7、</em> <em class="kb">中，HttpClient </em>已经被用作一个可注入类，就像其他类一样，当我们想要在我们的组件中使用它时，我们会导入它，并且还附带了一组Http可注入拦截器，它们是通过HTTP_INTERCEPTORS导入的。</p><p id="e934" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="kb"> Angular 1.x </em>中，我们将通过为我们的<em class="kb"> $http </em>选项提供<em class="kb"> transformRequest </em>函数或<em class="kb"> transformResponse </em>来实现这一点，我们可以在应用程序配置中全局转换请求。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="79a6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<em class="kb"> Angular 7 </em>中，我们将实现<em class="kb"> HttpInterceptor </em>接口。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><h1 id="5011" class="kc kd if bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">探索HttpClient</h1><p id="5a44" class="pw-post-body-paragraph jc jd if je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在本文的过程中，我们将看到如何处理POST和GET请求，这将要求我们检索和存储一个JWT(令牌)，因此我们将实现一个基本的身份验证。</p><h2 id="0148" class="ll kd if bd ke lm ln lo ki lp lq lr km jn ls lt kq jr lu lv ku jv lw lx ky ly dt translated">获取请求</h2><p id="30fb" class="pw-post-body-paragraph jc jd if je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">让我们从一个简单的GET请求开始，该请求针对<strong class="je ig"> <em class="kb"> /api/clients </em> </strong>路由，不需要认证。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="ab2c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">getAll方法看起来很熟悉——我们发出一个http.get请求，将一个URL作为参数传递。记住，在1.x Angular $http案例中，这是我们消费我们开始的承诺的地方，并且将使用。然后，但正如你在这里看到的，我们正在做一些相当不同的事情。</p><p id="f64a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如前所述，<em class="kb"> Angular 7 </em>中的Http调用返回可观察对象，所以我们需要使用<em class="kb"> RxJS </em>方法对它们进行操作。</p><h2 id="7623" class="ll kd if bd ke lm ln lo ki lp lq lr km jn ls lt kq jr lu lv ku jv lw lx ky ly dt translated">发布请求</h2><p id="0a7b" class="pw-post-body-paragraph jc jd if je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我们的身份验证方法需要向后端发出POST请求，并指定内容类型，这样我们就可以提交凭据。为此，我们将使用标题。</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="ab49" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">身份验证方法接受提交表单时从视图传输的数据。我们正在获取他的用户名和密码，并以服务器等待的方式制作一串凭证。</p><p id="0c00" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请求发生了，从这里返回的可观察对象以我们在GET请求中看到的相同方式被处理。随后，我们将收到的令牌存储在本地存储中。</p><p id="7523" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有关在<em class="kb"> Angular 7 </em>中实现Http请求的更多细节，请访问<a class="ae ka" href="https://angular.io/guide/http" rel="noopener ugc nofollow" target="_blank">完整文档</a>。</p><h1 id="2246" class="kc kd if bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">结论</h1><p id="75b9" class="pw-post-body-paragraph jc jd if je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">与在<em class="kb"> Angular 1.x </em>中所做的相比，在<em class="kb"> Angular 7 </em>中的Http请求无疑是一种不同的方法，但是随着这种改变，在能力上有了很大的提高。返回是可观察对象的请求非常好，因为我们可以对它们使用<em class="kb"> RxJS </em>操作符，并且返回的流将按照我们喜欢的方式运行。</p><p id="9db1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文中，我们已经看到了如何使用HTTP让<em class="kb"> GET </em>和<em class="kb"> POST </em>请求进行身份验证，但是我们也可以使用其他类型的Http请求，比如<em class="kb"> PUT、DELETE、</em>和<em class="kb"> PATCH </em>。我们还看到了如何使用<em class="kb"> Headers </em>类定制我们发送的消息头。</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lz"><img src="../Images/75d1b418f18e43379eb833623525f304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_Lht61Cu0eVF9D_rLue-w.jpeg"/></div></div></figure><p id="26d5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好好学习，留下你的评论，下次见！！！</p><p id="e54e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">本帖是</em> <a class="ae ka" rel="noopener" href="/opensanca/angular-2-http-e-autenticação-32c2ed320fa"> <em class="kb">葡文版</em> </a> <em class="kb">的翻译。所以，如果你发现任何错误，请原谅我，并让我知道如何改正。</em></p><p id="a73f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谢谢❤</p><h1 id="39ae" class="kc kd if bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">参考</h1><div class="ht hu fm fo hv ma"><a href="https://angular.io/guide/http" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd ig fv z el mf eo ep mg er et ie dt translated">角度文档</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">编辑描述</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">angular.io</p></div></div></div></a></div><div class="ht hu fm fo hv ma"><a href="http://reactivex.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd ig fv z el mf eo ep mg er et ie dt translated">ReactiveX</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">编辑描述</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">reactivex.io</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ib ma"/></div></div></a></div><div class="ht hu fm fo hv ma"><a href="https://docs.angularjs.org/api/ng/service/$http" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd ig fv z el mf eo ep mg er et ie dt translated">安古拉吉斯</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">AngularJS就是HTML，如果它是为构建网络应用程序而设计的话。带有…的声明性模板</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">docs.angularjs.org</p></div></div></div></a></div><div class="ht hu fm fo hv ma"><a href="https://auth0.com/blog/angular-2-series-part-3-using-http/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd ig fv z el mf eo ep mg er et ie dt translated">使用Angular $Http和Angular 2 Http - Angular 2系列第3部分</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">了解Angular 1.x中的$http和Angular 2中的http的区别。了解如何使用RxJS观察仪…</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">auth0.com</p></div></div><div class="mj l"><div class="mp l ml mm mn mj mo ib ma"/></div></div></a></div><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="mq lk l"/></div></figure></div></div>    
</body>
</html>