<html>
<head>
<title>Messaging System — Hands On!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">消息传递系统—动手操作！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/messaging-system-hands-on-7dda1afded37?source=collection_archive---------5-----------------------#2018-11-06">https://medium.com/hackernoon/messaging-system-hands-on-7dda1afded37?source=collection_archive---------5-----------------------#2018-11-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="f019" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">所以，我才了解到微服务。这是我得到的。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/be703ed41ec3d58b89d53d4002b0bf2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wRJlQ0PpOSfluKGp8jbcA.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Took from <a class="ae jz" href="https://sub.watchmecode.net/guides/microservices-with-rabbitmq/" rel="noopener ugc nofollow" target="_blank">https://sub.watchmecode.net/guides/microservices-with-rabbitmq/</a></figcaption></figure><p id="207e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">微服务的主要概念之一是分离每个服务。为了分离服务，我们可以应用领域驱动的开发概念，这意味着我们需要按照服务的领域来分离服务。在按服务的域分离服务之后，我们知道应该在每个服务之间建立一个通信机制。所以现在我想实现它。</p><p id="62a0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">之前我已经创建了一个整体系统。该系统的主要目的是用户可以上传提要，如果在提要的标题上发现一些标签，它们应该与提要的ID一起存储到数据库中。基于微服务的概念，我应该在我的系统上分离服务。我可以创建的服务是处理提要的服务和处理标签的服务。所以，这里的问题陈述</p><blockquote class="kw"><p id="4556" class="kx ky hu bd kz la lb lc ld le lf kv ek translated">用户可以通过提要服务创建新的提要，提要包含位置和标题。Hashtag API应该处理来自提要标题的Hashtag。每个服务可以用不同的语言编写。</p></blockquote><p id="2907" class="pw-post-body-paragraph ka kb hu kc b kd lg iv kf kg lh iy ki kj li kl km kn lj kp kq kr lk kt ku kv hn dt translated">因为我想保持简单，所以我决定使用Lumen构建Feed服务，使用Golang构建Hashtag服务。所以这个系统看起来会像这样</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/3aec8a0a708e1ee714f02abb0755933b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*TSSXvjexryGxiDfj1O7xiQ.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">First Design</figcaption></figure><p id="17df" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">直到这一步，一切看起来都没问题。当用户创建新的提要时，提要服务将处理它。下面是用户创建新提要时JSON数据的样子</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="c127" class="lr ls hu ln b fv lt lu l lv lw">{<br/>  "location": "Sitoluama",<br/>  "caption" : "Today is a beautiful day #sunset #beach #love"<br/>}</span></pre><p id="603b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在新的提要被存储后，<code class="eh lx ly lz ln b">feed_id</code>和<code class="eh lx ly lz ln b">feed_caption</code>将发送到hashtag服务，从提要的标题中获取所有的Hashtag，并将它们存储到Hashtag DB中。提要服务将通过REST API调用将提要数据作为JSON发送给Hashtag服务。有效载荷将是这样的</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="391c" class="lr ls hu ln b fv lt lu l lv lw">{<br/>  "feed_id": 23,<br/>  "feed_caption": "Today is a beautiful day #sunset #beach #love"<br/>}</span></pre><p id="b517" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">Hashtag服务收到请求后，将从标题中过滤所有hashtag。extract hashtag函数很简单，只需迭代标题中的每个字符，并将它们存储到一个数组中。数组中的每个hashtag都将与<code class="eh lx ly lz ln b">feed_id</code>配对，并将它们存储到Hashtag DB中。所以，这里提取的标签</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="b1ef" class="lr ls hu ln b fv lt lu l lv lw">[<br/>  {<br/>    "feed_id" : 23,<br/>    "name" : "#sunset"<br/>  },<br/>  {<br/>    "feed_id" : 23,<br/>    "name" : "#beach"<br/>  },<br/>  {<br/>    "feed_id" : 23,<br/>    "name" : "#love"<br/>  },<br/>]</span></pre><p id="69eb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">直到这一步，一切都很好，从技术上来说是可行的。但是现在我添加了这个案例。</p><blockquote class="kw"><p id="fb8b" class="kx ky hu bd kz la lb lc ld le lf kv ek translated">使用微服务架构的一个优势是服务的可重用性。一个服务可以被多个服务使用。当我们扩展我们系统时，现在我们的用户可以在我们的应用程序中创建评论和事件。所以我们需要创建评论服务和事件服务。因此，我们可以重用hashtag服务来处理来自评论服务和事件服务的Hashtag</p></blockquote><p id="6b4c" class="pw-post-body-paragraph ka kb hu kc b kd lg iv kf kg lh iy ki kj li kl km kn lj kp kq kr lk kt ku kv hn dt translated">根据上面的问题陈述，我们可以重新设计我们的系统。这里看起来会像。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/eabe798042b743d8a2e5b65aec700612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Qcc3_vn2g-YGDwD4LsTGRg.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Second Design</figcaption></figure><p id="c84a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">从技术上讲，它仍然有效。但是如果有很多来自Feed服务、评论服务和事件服务的请求要发送给Hashtag服务，该怎么办呢？单一Hashtag服务如何处理所有请求？<strong class="kc hv">记住，我们尽可能不想错过哪怕一个标签</strong>。所以我们需要确保每个标签都得到处理。</p><p id="1ba8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">简单的解决方案是将Hashtag服务与其他服务配对。如果有三个不同的服务使用Hashtag服务，我们需要为三个实例创建Hashtag服务。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/616b38155948c951461071973c598b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*XcgRq8E5dGUQOqatU20GLw.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Naive Solution</figcaption></figure><p id="dddc" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">从技术上讲，这是可行的。但这种设计正在打破可重复使用的概念。从设计中，我们知道我们不是重用Hashtag服务，而是创建新的。那么还有什么其他解决方案可以帮助我们呢？</p><h1 id="c8d8" class="mc ls hu bd md me mf mg mh mi mj mk ml ja mm jb mn jd mo je mp jg mq jh mr ms dt translated">信息系统，你是什么？</h1><p id="e9b7" class="pw-post-body-paragraph ka kb hu kc b kd mt iv kf kg mu iy ki kj mv kl km kn mw kp kq kr mx kt ku kv hn dt translated">这里我不解释什么是消息系统，但是你可以在这里找到它<a class="ae jz" rel="noopener" href="/@xaviergeerinck/an-introduction-to-message-brokers-9bd203b4ebbd"/>，<a class="ae jz" href="https://www.techopedia.com/definition/16959/message-broker" rel="noopener ugc nofollow" target="_blank">这里</a>，还有<a class="ae jz" href="https://www.cloudamqp.com/blog/2014-12-03-what-is-message-queuing.html" rel="noopener ugc nofollow" target="_blank">这里</a>。一些流行的消息系统有<a class="ae jz" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>、<a class="ae jz" href="https://cloud.google.com/pubsub/docs/overview" rel="noopener ugc nofollow" target="_blank"> Google Pub/Sub </a>和<a class="ae jz" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>。</p><p id="8c82" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在阅读了什么是消息传递系统之后，也许您还阅读了发布-订阅模式。简单地说，发布-订阅模式是指系统将消息发布到主题中，而订阅该主题的其他系统将接收到消息。在理解了什么是消息传递系统之后，现在我将在我的设计中实现它。</p><h1 id="8956" class="mc ls hu bd md me mf mg mh mi mj mk ml ja mm jb mn jd mo je mp jg mq jh mr ms dt translated">让我们摇滚吧，我可爱的兔子！</h1><p id="9360" class="pw-post-body-paragraph ka kb hu kc b kd mt iv kf kg mu iy ki kj mv kl km kn mw kp kq kr mx kt ku kv hn dt translated">这是我的新系统设计。这里我尝试使用RabbitMQ。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff my"><img src="../Images/03d608287ddd5d8e932a964db6ded68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*zC9d7J3RLiQiFvRU7yQVew.jpeg"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">RabbitMQ Applied</figcaption></figure><p id="17a1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">播种交流将如何进行？让我解释一下。在一个提要、一条评论或一个事件存储到数据库中之后，处理它的服务将发送一个有效负载，其中包含ID和包含hashtag的字段。</p><p id="8df8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这里是Feed服务的有效负载</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="396e" class="lr ls hu ln b fv lt lu l lv lw">{<br/>  "feed_id": 23,<br/>  "feed_caption": "Today is a beautiful day #sunset #beach #love"<br/>}</span></pre><p id="7af0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这里是来自评论服务的有效负载</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="b39d" class="lr ls hu ln b fv lt lu l lv lw">{<br/>  "commnet_id": 1,<br/>  "comment_body": "Hi Jude, don't make it bad #keepfighting"<br/>}</span></pre><p id="956a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这里是来自事件服务的有效负载</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="5f5d" class="lr ls hu ln b fv lt lu l lv lw">{<br/>  "event_id": 97,<br/>  "event_description": "We are always welcome for every body that want to learn togerher with us. So don't miss the tutorail session. #tutorail #bootcamp #rabbitmq #microservices"<br/>}</span></pre><p id="82fc" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是在这里，有效载荷没有直接发送给Hashtag服务。来自每个服务的有效负载将被发布到RabbitMQ服务器中的一个主题上。Hashtag服务将从RabbitMQ服务器接收发布的消息——当然，Hashtag服务应该订阅相同的主题。</p><p id="30a4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">实际上，这就够了。但是我们需要修改我们的有效负载，以便Hashtag服务知道哪个服务发布了消息。我们还需要修改有效负载，使所有的有效负载都具有相同的结构——就像Hashtag服务的契约一样。以下是新的有效载荷示例。</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="2221" class="lr ls hu ln b fv lt lu l lv lw">{<br/>  "message_type": "feed"<br/>  "message_id": 23,<br/>  "message": "Today is a beautiful day #sunset #beach #love"<br/>}</span></pre><h1 id="0d88" class="mc ls hu bd md me mf mg mh mi mj mk ml ja mm jb mn jd mo je mp jg mq jh mr ms dt translated">其他人有什么优点？</h1><h2 id="d738" class="lr ls hu bd md mz na nb mh nc nd ne ml kj nf ng mn kn nh ni mp kr nj nk mr nl dt translated">消息持久性</h2><p id="b523" class="pw-post-body-paragraph ka kb hu kc b kd mt iv kf kg mu iy ki kj mv kl km kn mw kp kq kr mx kt ku kv hn dt translated">发布到RabbitMQ服务器上的消息将一直保留在那里，直到有订阅者取走。即使有一条消息没有被完全处理，这条消息也不会直接从队列中删除。RabbitMQ服务器收到<a class="ae jz" href="https://www.rabbitmq.com/tutorials/tutorial-two-go.html" rel="noopener ugc nofollow" target="_blank">消息确认</a>——<em class="nm">后会删除，我们需要在</em>之前配置好。在订户可用之后，RabbitQM服务器将从其队列中向订户发送消息。</p><p id="6e39" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是如果RabbitMQ服务器瘫痪了呢？我们也会丢失数据。阅读<a class="ae jz" href="https://www.rabbitmq.com/reliability.html" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多详细信息。</p><pre class="jk jl jm jn fq lm ln lo lp aw lq dt"><span id="9889" class="lr ls hu ln b fv lt lu l lv lw">Marking messages as persistent doesn't fully guarantee that a message won't be lost. Although it tells RabbitMQ to save the message to disk, there is still a short time window when RabbitMQ has accepted a message and hasn't saved it yet. Also, RabbitMQ doesn't do fsync(2) for every message -- it may be just saved to cache and not really written to the disk. The persistence guarantees aren't strong, but it's more than enough for our simple task queue. If you need a stronger guarantee then you can use <a class="ae jz" href="https://www.rabbitmq.com/confirms.html" rel="noopener ugc nofollow" target="_blank">publisher confirms</a>.</span><span id="cc99" class="lr ls hu ln b fv nn lu l lv lw">- <a class="ae jz" href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" rel="noopener ugc nofollow" target="_blank">RabbitMQ-Tutorial Two</a></span></pre><h2 id="f16a" class="lr ls hu bd md mz na nb mh nc nd ne ml kj nf ng mn kn nh ni mp kr nj nk mr nl dt translated">易于扩展</h2><p id="b816" class="pw-post-body-paragraph ka kb hu kc b kd mt iv kf kg mu iy ki kj mv kl km kn mw kp kq kr mx kt ku kv hn dt translated">实现消息代理，我们可以很容易地扩展我们的系统设计。如上所述，我们向系统添加了另外两个服务，并重用了现有的服务。如果稍后我们添加Place Service，Place有一个包含hashtags的描述，我们只需将有效负载发布到RabbitQM服务器。</p><h2 id="8036" class="lr ls hu bd md mz na nb mh nc nd ne ml kj nf ng mn kn nh ni mp kr nj nk mr nl dt translated">灵活的技术堆栈</h2><p id="32df" class="pw-post-body-paragraph ka kb hu kc b kd mt iv kf kg mu iy ki kj mv kl km kn mw kp kq kr mx kt ku kv hn dt translated">另一个优点是我们可以使用不同的编程语言和不同的数据库，就像我以前做的那样。我们可以灵活地选择我们想要使用的堆栈，因此我们可以获得所有技术堆栈的优势。例如，我们可以考虑使用NoSQL实现速度性能，使用SQL实现数据完整性，使用Node JS实现动态类型，使用Java实现静态类型。</p><p id="8671" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我想这就是我能为你分享的一切。我自己仍然需要探索更多关于消息系统和微服务的知识。如果有任何批评或反馈，请随时回复本文或通过<code class="eh lx ly lz ln b">ecojuntak@gmail.com</code>联系我。哦对了，你也可以在这里找到完整的标签服务代码。</p><p id="23e9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">卡皮·霍丁！💻</p></div></div>    
</body>
</html>