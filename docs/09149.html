<html>
<head>
<title>Abstract Classes and OOP extras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象类和OOP extras</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/abstract-classes-and-oop-extras-d087eeb1aca9?source=collection_archive---------11-----------------------#2018-11-06">https://medium.com/hackernoon/abstract-classes-and-oop-extras-d087eeb1aca9?source=collection_archive---------11-----------------------#2018-11-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/510d24251203763dc65b9487de1f2a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l4Oe8EU2b1zoTLvgZN9HuQ.jpeg"/></div></div></figure><h1 id="e9e5" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="5275" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">本系列的最后一章。</p><p id="5e7c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果您已经阅读了这些博客文章，那么您现在完全有能力使用面向对象的范例来创建项目。</p><p id="ae0a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我很高兴你已经完成了所有的部分，在这一部分，你将结束你已经开始的。</p><p id="c3ee" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">事实上，</p><p id="dc19" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">现在你将学习如何使用抽象类和PHP其他一些不常用的特性，比如反射API和单例设计模式。</p><p id="2318" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">继续读下去，你会发现，和包括我在内的许多其他web开发人员一样，这些资源会让你实现你正在寻找的突破。</p><h1 id="a49c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">跟随系列…</h1><p id="2bc7" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这篇博文是“<a class="ae ld" href="https://amzn.to/2OfCZej" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">面向对象编程完全指南:</strong> </a>的第六部分</p><p id="cd19" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在<a class="ae ld" href="https://hackernoon.com/tagged/php" rel="noopener ugc nofollow" target="_blank"> PHP </a>中从过程化编程成为OOP专家。”</p><p id="cd4f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果你还没有阅读其他部分</p><p id="38f2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你可以查看下面链接的其他博客文章<br/> <a class="ae ld" href="http://anastasionico.uk/blog/the-complete-guide-to-object-oriented-programming" rel="noopener ugc nofollow" target="_blank">【面向对象编程简介】</a><br/><a class="ae ld" href="http://anastasionico.uk/blog/inheritance-and-interfaces-in-php" rel="noopener ugc nofollow" target="_blank">PHP中的继承和接口</a><br/><a class="ae ld" href="http://anastasionico.uk/blog/interfaces-and-polymorphism-in-php" rel="noopener ugc nofollow" target="_blank">更多接口和多态</a><br/><a class="ae ld" href="http://anastasionico.uk/blog/visibility-and-static-keyword-in-php" rel="noopener ugc nofollow" target="_blank">可见性和静态关键字</a><br/><a class="ae ld" href="http://anastasionico.uk/blog/php-magic-methods" rel="noopener ugc nofollow" target="_blank">构造函数和魔法方法</a>和<br/> <a class="ae ld" href="http://anastasionico.uk/blog/abstract-classes-and-oop-extras" rel="noopener ugc nofollow" target="_blank">抽象类和额外的位</a></p><h1 id="767a" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">目录</h1><ul class=""><li id="be45" class="le lf hu kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm dt translated"><a class="ae ld" href="http://anastasionico.uk/blog/abstract-classes-and-oop-extras#abstract" rel="noopener ugc nofollow" target="_blank">抽象类</a></li><li id="7d08" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated"><a class="ae ld" href="http://anastasionico.uk/blog/abstract-classes-and-oop-extras#chaining" rel="noopener ugc nofollow" target="_blank">方法链接</a></li><li id="c7a0" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated"><a class="ae ld" href="http://anastasionico.uk/blog/abstract-classes-and-oop-extras#autoloading" rel="noopener ugc nofollow" target="_blank">自动加载</a></li><li id="4bcb" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated"><a class="ae ld" href="http://anastasionico.uk/blog/abstract-classes-and-oop-extras#anonymous" rel="noopener ugc nofollow" target="_blank">匿名类</a></li><li id="be9f" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated"><a class="ae ld" href="http://anastasionico.uk/blog/abstract-classes-and-oop-extras#reflection" rel="noopener ugc nofollow" target="_blank">反射API </a></li><li id="143c" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated"><a class="ae ld" href="http://anastasionico.uk/blog/abstract-classes-and-oop-extras#singleton" rel="noopener ugc nofollow" target="_blank">单身</a></li></ul><h1 id="7ed6" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">抽象类</h1><p id="f6a8" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">抽象类与接口非常相似，但是它们有不同的规则，web开发人员需要了解这些规则。</p><p id="9a76" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">定义非常简单，基本上，抽象类是包含抽象方法的类，</p><p id="7e60" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">抽象方法是代码中已经声明但没有实现的方法。</p><p id="3419" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这类类不能被构造成一个对象，事实上，它们需要被扩展。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="0208" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">扩展抽象类的“普通”类必须实现父类中的所有方法。</p><p id="7113" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">需要注意的是，子类必须用相同或更少限制的可见性定义抽象方法，</p><p id="109e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这意味着，如果抽象类中有一个受保护的方法，它只能作为公共方法或受保护方法来实现。</p><p id="d2a8" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">另一个规则是，所需参数的数量和类型需要与形参相同。</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="429a" class="md jd hu lz b fv me mf l mg mh">abstract<!-- --> <!-- -->class<!-- --> <!-- -->Building {</span><span id="24c9" class="md jd hu lz b fv mi mf l mg mh">    abstract<!-- --> <!-- -->protected<!-- --> <!-- -->function<!-- --> <!-- -->getWindowsCount();</span><span id="fb13" class="md jd hu lz b fv mi mf l mg mh">    public<!-- --> <!-- -->function<!-- --> <!-- -->__construct()</span><span id="5c3a" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="5a59" class="md jd hu lz b fv mi mf l mg mh">        echo<!-- --> <!-- -->“Building cannot be constructed”;</span><span id="bfe9" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="6346" class="md jd hu lz b fv mi mf l mg mh">}</span><span id="bdb5" class="md jd hu lz b fv mi mf l mg mh">class<!-- --> <!-- -->Office extends<!-- --> <!-- -->Building {</span><span id="1c92" class="md jd hu lz b fv mi mf l mg mh">    public<!-- --> <!-- -->function<!-- --> <!-- -->getWindowsCount()</span><span id="9a0f" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="4bd5" class="md jd hu lz b fv mi mf l mg mh">        return<!-- --> <!-- -->12;</span><span id="6e06" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="7fc8" class="md jd hu lz b fv mi mf l mg mh">}</span><span id="0da6" class="md jd hu lz b fv mi mf l mg mh">$myOffice<!-- --> <!-- -->= new<!-- --> <!-- -->Office;</span><span id="bbc7" class="md jd hu lz b fv mi mf l mg mh">// This command will return “Building cannot be constructed”</span><span id="9fec" class="md jd hu lz b fv mi mf l mg mh">$myOffice-&gt;getWindowsCount();</span><span id="8a14" class="md jd hu lz b fv mi mf l mg mh">// This command will return 12</span></pre><p id="3458" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我已经定义了扩展抽象类<em class="mj">建筑</em>的Office类。</p><p id="c89e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我已经实现了<em class="mj"> getWindowsCount() </em>，并将其可见性从protected更改为public。</p><p id="5728" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在<em class="mj"> Office </em>类中没有抽象方法，因此，我可以从它构造一个对象。</p><p id="e40a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我在抽象类中添加了一个构造函数，这样你就能意识到当对象被实例化时，父类的构造函数被调用了。</p><p id="7257" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">接口和抽象类的区别是什么？</p><p id="f947" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">总而言之，</p><p id="eea1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">把一个接口当做一个空壳。</strong></p><p id="38aa" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">它只有方法的签名，这意味着方法没有主体。</strong></p><p id="44d6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">接口不做任何事情，它只是一个模式，一组你需要复制的方法。</p><p id="1b31" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">另一方面，抽象类是适当的类。</p><p id="4b8f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">尽管它们看起来像具有某些特定特征的接口。</strong></p><p id="5a96" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">您可以通过给定的方法名来指定它们的用途。</p><p id="a07f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">下面的例子突出了两者之间的区别:</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="bf73" class="md jd hu lz b fv me mf l mg mh">interface<!-- --> <!-- -->Building</span><span id="13d5" class="md jd hu lz b fv mi mf l mg mh">{</span><span id="e288" class="md jd hu lz b fv mi mf l mg mh">     public<!-- --> <!-- -->function<!-- --> <!-- -->build();</span><span id="7036" class="md jd hu lz b fv mi mf l mg mh">     public<!-- --> <!-- -->function<!-- --> <!-- -->getWindowsCount();</span><span id="de2b" class="md jd hu lz b fv mi mf l mg mh">}</span><span id="4528" class="md jd hu lz b fv mi mf l mg mh">class<!-- --> <!-- -->Office implements<!-- --> <!-- -->Building</span><span id="b957" class="md jd hu lz b fv mi mf l mg mh">{</span><span id="07ca" class="md jd hu lz b fv mi mf l mg mh">    public<!-- --> <!-- -->$windows;</span><span id="8407" class="md jd hu lz b fv mi mf l mg mh">    public<!-- --> <!-- -->function<!-- --> <!-- -->build()</span><span id="2147" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="9536" class="md jd hu lz b fv mi mf l mg mh">        echo<!-- --> <!-- -->“Office built”;</span><span id="dc05" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="7ebd" class="md jd hu lz b fv mi mf l mg mh">    public<!-- --> <!-- -->function<!-- --> <!-- -->getWindowsCount()</span><span id="c0ad" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="521f" class="md jd hu lz b fv mi mf l mg mh">        return<!-- --> <!-- -->$this-&gt;windows;</span><span id="319a" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="1c67" class="md jd hu lz b fv mi mf l mg mh">}</span></pre><p id="d998" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在这里，我们说所有的建筑应该看起来像这样，而不是由<em class="mj"> Office </em>类来改变功能。</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="eb3d" class="md jd hu lz b fv me mf l mg mh">abstract class Building<br/>{<br/>    public $windows;<br/>    public function getWindowsCount()<br/>    {<br/>         return $this-&gt;windows;<br/>    }<br/>    abstract public function build();<br/>}</span><span id="0b8a" class="md jd hu lz b fv mi mf l mg mh">class Office extends Building<br/>{<br/>    public function build()<br/>    {<br/>        echo “Office built”;<br/>    } <br/>}</span></pre><p id="81d7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">相反，在抽象类中，我们是说所有的建筑都必须有<em class="mj"> getWindowsCount() </em>。</p><p id="6f40" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">然后我们说方法<em class="mj"> build() </em>可以不同，所以我们预留了<em class="mj"> Office </em>类根据其需求提供实现。</p><h1 id="bca8" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">额外/奖金</h1><p id="48b7" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们差不多已经完成了PHP中面向对象编程的介绍，</p><p id="5522" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">很多信息已经被分享，我希望你能全部理解(如果没有，请在下面写下你的问题)。</p><p id="89a9" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">然而，有几件事情刚刚被快速提到，我很想更深入地让你对这个话题有一个更广泛的理解。</p><h1 id="e4e3" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">方法链接</h1><p id="e726" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">方法链是一种OOP技术，它允许程序员以一种连续的方式执行几个不同但相关的动作。</p><p id="d14a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们把这句话分解一下，<br/>“执行不同的动作”是指调用不同的方法或函数；</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/3e62f5a7212cff05a3f105f1e4db79b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*DVezRUFAi1lJElIo.jpg"/></div></figure><p id="a30e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">执行关联动作</strong>可以翻译成与类的相同对象或实例相关的动作；</p><p id="1ec8" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">按顺序</strong>简单的说就是一个接一个的调用方法。</p><p id="19c1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这里有一个例子可以阐明这个概念:</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="4b8a" class="md jd hu lz b fv me mf l mg mh">class<!-- --> <!-- -->Building</span><span id="5638" class="md jd hu lz b fv mi mf l mg mh">{</span><span id="614c" class="md jd hu lz b fv mi mf l mg mh">    public<!-- --> <!-- -->$message;</span><span id="d45e" class="md jd hu lz b fv mi mf l mg mh">    function<!-- --> <!-- -->__construct()</span><span id="1558" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="35cc" class="md jd hu lz b fv mi mf l mg mh">        $this-&gt;message = "Foundation poured - ";</span><span id="8840" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="e538" class="md jd hu lz b fv mi mf l mg mh">    function<!-- --> <!-- -->stepOne()</span><span id="e99d" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="8192" class="md jd hu lz b fv mi mf l mg mh">        $this-&gt;message .= "framing, plumbing, electrical and HVAC completed -";</span><span id="a06d" class="md jd hu lz b fv mi mf l mg mh">        return<!-- --> <!-- -->$this;</span><span id="ca34" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="92d5" class="md jd hu lz b fv mi mf l mg mh">    function<!-- --> <!-- -->stepTwo()</span><span id="30ac" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="900e" class="md jd hu lz b fv mi mf l mg mh">        $this-&gt;message .= "interior and exterior completed";</span><span id="4cd7" class="md jd hu lz b fv mi mf l mg mh">        return<!-- --> <!-- -->$this;</span><span id="3dbc" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="d759" class="md jd hu lz b fv mi mf l mg mh">    function<!-- --> <!-- -->getMessage()</span><span id="2058" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="fcb4" class="md jd hu lz b fv mi mf l mg mh">        return<!-- --> <!-- -->$this-&gt;message;</span><span id="df15" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="ed44" class="md jd hu lz b fv mi mf l mg mh">}</span><span id="eb95" class="md jd hu lz b fv mi mf l mg mh">$myHome<!-- --> <!-- -->= new<!-- --> <!-- -->Building();</span><span id="6ec8" class="md jd hu lz b fv mi mf l mg mh">echo<!-- --> <!-- -->$myHome-&gt;stepOne()-&gt;stepTwo()-&gt;getMessage();</span></pre><p id="1b96" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">给你，</p><p id="c546" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">所有<em class="mj">构建</em>类的方法都有一个共同的特点，它们都通过使用关键字<em class="mj"> $this </em>，</strong>返回对象本身</p><p id="058b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果你需要重温一下你的记忆，我已经在<a class="ae ld" href="http://anastasionico.uk/blog/the-complete-guide-to-object-oriented-programming" rel="noopener ugc nofollow" target="_blank">面向对象编程介绍</a>中解释了<em class="mj"> $this </em>关键字的作用。</p><p id="6157" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">最后一个命令是链接该类中所有必要的方法，以便构建我们的句子。</p><p id="a9ea" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">最后一个命令的结果如下所示:</p><p id="582e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">“基础浇筑—框架、管道、电气和HVAC完成—内部和外部完成”。</p><p id="789d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这非常简单，您可以毫无问题地直接在代码中实现它，只是要小心返回对象。</p><h1 id="a37a" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">半自动的</h1><p id="ce43" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">任何类在需要使用之前都必须定义，</p><p id="5cc5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">忘记这样做将导致抛出一个错误。</p><p id="99e2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">PSR-4标准旁边的自动加载允许您在需要类别时定义它们。</p><p id="fca5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我确信我不需要说这是一个非常重要的特性。</p><p id="d8a9" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">在PHP中，自动加载是由<em class="mj">spl _ autoload _ register()</em>完成的，它接受一个函数作为参数，</strong></p><p id="4648" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这完全是题外话，为了详细解释它是如何工作的，我需要再写一篇文章，</p><p id="17f7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">所以我会给你一个容易理解的例子:</p><p id="0ff2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">假设您想要自动加载的类位于“classes/”路径中，</p><p id="7877" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你应该这么做。</p><p id="2d25" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这或多或少是大多数PHP开发框架背后发生的事情。</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="a1f3" class="md jd hu lz b fv me mf l mg mh">function<!-- --> <!-- -->myAutoloader($className) {</span><span id="8918" class="md jd hu lz b fv mi mf l mg mh">    include<!-- --> <!-- -->'classes/'<!-- --> <!-- -->. $className<!-- --> <!-- -->. '.php';</span><span id="9569" class="md jd hu lz b fv mi mf l mg mh">}</span><span id="2537" class="md jd hu lz b fv mi mf l mg mh">spl_autoload_register(myAutoloader);</span></pre><p id="b74f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">spl_autoload_register还有两个参数，</p><p id="2698" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">第二个是布尔值，定义当autoload_function无法注册时<em class="mj"> spl_autoload_register </em>是否需要抛出异常，</p><p id="891e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">第三个参数也是boolean，如果为true，它将预先设置自动加载程序，而不是附加它。</p><p id="0c0a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果发生错误，并且函数无法找到指定的类，它将抛出致命错误。</p><h1 id="e75f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">匿名类</h1><p id="7e93" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果PHP允许web开发人员动态地创建和实例化对象，这不是很好吗？</p><p id="025e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">PHP 7的发行版在其特性列表中包括了这个礼物。</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="5a3b" class="md jd hu lz b fv me mf l mg mh">$myAnonymousBuilding<!-- --> <!-- -->= new<!-- --> <!-- -->class(“Main Street”)</span><span id="ef4c" class="md jd hu lz b fv mi mf l mg mh">{</span><span id="8b1d" class="md jd hu lz b fv mi mf l mg mh">    public<!-- --> <!-- -->function<!-- --> <!-- -->__construct(string $address)</span><span id="17fb" class="md jd hu lz b fv mi mf l mg mh">    {</span><span id="8635" class="md jd hu lz b fv mi mf l mg mh">        echo<!-- --> <!-- -->“a new<!-- --> <!-- -->class<!-- --> <!-- -->has been constructed in ” . $address;</span><span id="d54f" class="md jd hu lz b fv mi mf l mg mh">    }</span><span id="dfc0" class="md jd hu lz b fv mi mf l mg mh">}</span></pre><p id="7692" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">很酷，对吧？</p><p id="cef7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">注意，内嵌实现这个类是多么容易，它甚至可以像普通类一样接受参数。</p><p id="a563" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">示例中的代码将输出字符串“Main Street中构造了一个新类”。</p><p id="e5a4" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">匿名类的主要用途是在需要扩展命名类的情况下。</p><p id="624e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">例如，如果您需要覆盖属性或方法，而不是声明它，您可以在您当前拥有的同一工作流中创建一个内嵌实现。</p><h1 id="351d" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">反射API</h1><p id="b638" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">反射是一个非常有用的特性，随着PHP 5.0的发布而引入，并在5.3以后成为一个标准。</p><p id="167f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">这个API允许你在运行时检查PHP元素并获取关于它们的信息。</strong></p><p id="48a0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">对我来说，</p><p id="d090" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">使用反射API最有用的地方之一是在自动化测试中，特别是在PHP单元中。</p><p id="e384" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">例如，当测试类中私有属性的值时，可以通过API输入属性，然后根据测试做出断言。</p><p id="f1df" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">有不同的反射类，每一个都允许你检查不同类型的变量。</p><p id="eced" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">以下是一些类别:</p><ul class=""><li id="e617" class="le lf hu kc b kd ky kh kz kl ml kp mm kt mn kx lj lk ll lm dt translated">反射类</li><li id="efe5" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">反射对象</li><li id="614e" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">反射法</li><li id="174f" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">反射函数</li><li id="65bb" class="le lf hu kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm dt translated">反射属性</li></ul><p id="4fe5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">下面是如何使用ReflectionClass的快速示例:</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="7842" class="md jd hu lz b fv me mf l mg mh">$ReflectionObject<!-- --> <!-- -->= new<!-- --> <!-- -->ReflectionClass(“Building”);</span><span id="98b0" class="md jd hu lz b fv mi mf l mg mh">print_r($ReflectionObject-&gt;getMethods());</span></pre><p id="4ed3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">该示例将输出Building类中所有可用方法的数组。</p><p id="5b19" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">传递给ReflectionClass的参数可以有两种类型，要么是带有类名的字符串，要么是该类本身的真实实例。</p><p id="24a7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">每个反射类都有一些方法，允许您检索关于正在检查的元素的不同信息。</p><h1 id="21f7" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">一个</h1><p id="48f0" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">任何有自尊的web开发人员迟早都会在掌握编程艺术的道路上遇到设计模式。</p><p id="192c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">那些模式只不过是以预先定义的方式解决问题的既定方法。</strong></p><p id="f59f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">99%的PHP框架使用它们来提高性能和代码质量。</p><p id="c54f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果你从未听说过设计模式这个词，那么这就是你的机会。</p><p id="76ef" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我想给你介绍其中最简单的。</p><p id="962a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们将再次使用我们想象中的城市，我们已经有了一些<em class="mj">建筑、办公室、学校</em>等等，</p><p id="7517" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">市政厅怎么样？市长需要关注所有这些类、实例化、方法和属性。</p><p id="9ead" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在一个城市里，只有一个市长，而且他只在市政厅一个大楼里工作。</p><p id="7bb2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一个城市不能有一个以上的市政厅。</p><p id="5097" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">嗯…</p><p id="adf0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们如何在编程中加入这个规则？</p><p id="3ba6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一个</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="e0f9" class="md jd hu lz b fv me mf l mg mh">class cityHall<br/>{<br/>    private static $instance = null;<br/>    private function __construct()<br/>    {<br/>        ...<br/>    }<br/>    public static function getInstance()<br/>    {<br/>        if (self::$instance == null){<br/>            self::$instance = new Singleton();<br/>        }<br/>        return self::$instance;<br/>    }<br/>}</span></pre><p id="f971" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在这里，</p><p id="5779" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这是单例设计模式的一个实现。</p><p id="3818" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它实际上是如何工作的？</p><p id="4497" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如您所见，构造函数的可见性被设置为private，它阻止了对象的创建。</p><p id="dff8" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">为了创建类的实例，您需要调用静态方法<em class="mj"> getInstance() </em>。</p><p id="1685" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它检查是否已经创建了实例，如果没有，它使用命令创建一个新的实例</p><pre class="ls lt lu lv fq ly lz ma mb aw mc dt"><span id="6c39" class="md jd hu lz b fv me mf l mg mh">self::$instance = new Singleton();</span></pre><p id="ac54" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">否则，它只返回已经创建的对象。</p><p id="ccc1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">结果是，在这种情况下，在你所有的程序中，你总是只有一个市政厅。</p><p id="ec3a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">在真实案例中，在哪里使用单体设计模式？</strong></p><p id="90bd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">Singleton非常简单，但处理起来也会有问题，每当你必须有一个类的单一实例时，就考虑一下这种设计模式。</p><p id="f1cd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">而且必须是长期的。</p><p id="e605" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一个简单的实现是创建一个数据库类来连接数据库和代码，在大多数情况下，每个项目只有一个数据库。</p><p id="4ef7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这是它的完美用途。</p><h1 id="6e1f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">结论</h1><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/af441b07a426abca92056c493f4792e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2dENNPkL7NN4Ls_r.jpg"/></div></div></figure><p id="70a6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><a class="ae ld" href="https://www.amazon.co.uk/dp/B07J47L6PB" rel="noopener ugc nofollow" target="_blank"> <em class="mj">一体化版的《面向对象编程完全指南》完整版在亚马逊上有Kindle格式。</em> </a></p><p id="cb72" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果您已经阅读了本文的所有部分，那么这将是一次不平凡的旅程。</p><p id="3ebd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你已经意识到面向对象编程或OOP并不像局外人看起来那么困难。</p><p id="532a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">事实是，作为web开发人员，我们喜欢使用行话。</p><p id="091a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">属性，参数，接口，抽象类，依赖注入。</p><p id="a26b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这些话会很快让你头疼。</p><p id="30aa" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">然而，</p><p id="01d4" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">只要坚持下去，每次一点点，你会发现应用这些新知识不仅是可能的，而且比你想象的更容易。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/81f240e8dd073aab6ad31da0e0d28d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FKpkkhRhWP0iLk7FpzTbQ.jpeg"/></div></div></figure><h1 id="ec97" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">下一步是什么？</h1><p id="d566" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果您理解了本文的基本概念，您就准备好学习PHP框架了，</p><p id="b546" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">外面有很多，选择其中一个可能会让人不知所措。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/55092481b09b7997dbbcbe0d3fbe674e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T53ExgSYOFrXIYQS.jpg"/></div></div></figure><p id="1448" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">下面是我写的一个非常深刻的比较，比较其中的24个，你在其他地方找不到任何类似的东西。<br/><a class="ae ld" href="http://anastasionico.uk/blog/guide-to-php-frameworks-part-1" rel="noopener ugc nofollow" target="_blank">PHP框架指南。</a></p><p id="a8fe" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="mj">如果你喜欢这个内容，并且你渴望更多的内容</em> <a class="ae ld" href="https://www.facebook.com/anastasionico.uk/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">加入脸书的社区</em> </a> <em class="mj">，在这里我们像这样分享信息和新闻！</em></p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mr lx l"/></div></figure></div></div>    
</body>
</html>