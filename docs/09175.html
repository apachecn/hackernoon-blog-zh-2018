<html>
<head>
<title>How to Compile Node.js Code Using Bytenode?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Bytenode编译Node.js代码？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-compile-node-js-code-using-bytenode-11dcba856fa9?source=collection_archive---------0-----------------------#2018-11-07">https://medium.com/hackernoon/how-to-compile-node-js-code-using-bytenode-11dcba856fa9?source=collection_archive---------0-----------------------#2018-11-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3bbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更新</strong> (2019/11/06):显然，黑客正午网站存在问题，使得GitHub gists只显示我的个人资料图片。<br/> <strong class="it hv">请</strong>阅读Medium上的故事(<a class="ae jp" rel="noopener" href="/hackernoon/how-to-compile-node-js-code-using-bytenode-11dcba856fa9">此处</a>)以避免这个恼人的错误。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/7b70d6a3d53f26ef48d741964d3f7e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mf7iHbOO_2F_DhbMbqYukw.png"/></div></div></figure><p id="9355" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将向您展示如何“真正地”将Node.js (JavaScript)代码编译成V8字节码。这使你能够以一种比混淆或其他效率不高的技巧更好的方式隐藏或保护你的源代码(比如使用秘密密钥加密你的代码，这将被嵌入到你的应用程序二进制文件中，这就是为什么我在上面说“真正地”)。</p><p id="c39a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，使用<code class="eh kc kd ke kf b">bytenode</code>工具，您可以分发JavaScript文件的二进制版本<code class="eh kc kd ke kf b">.jsc</code>。您也可以使用Browserify捆绑所有的<code class="eh kc kd ke kf b">.js</code>文件，然后将单个文件编译成<code class="eh kc kd ke kf b">.jsc</code>。</p><p id="982e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查Github上的<a class="ae jp" href="https://github.com/OsamaAbbas/bytenode" rel="noopener ugc nofollow" target="_blank">字节节点库</a>。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h2 id="82dd" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jc ky kz la jg lb lc ld jk le lf lg lh dt translated">长话短说..</h2><ol class=""><li id="729a" class="li lj hu it b iu lk iy ll jc lm jg ln jk lo jo lp lq lr ls dt translated">全局安装byte node:<br/><code class="eh kc kd ke kf b">[sudo] npm install -g bytenode</code></li><li id="2f68" class="li lj hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">要编译您的<code class="eh kc kd ke kf b">.js</code>文件，运行这个命令:<br/> <code class="eh kc kd ke kf b">bytenode --compile my-file.js my-file.jsc</code></li><li id="7f76" class="li lj hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">将<code class="eh kc kd ke kf b">bytenode</code>也安装到您的项目中:<br/> <code class="eh kc kd ke kf b">npm install --save bytenode</code></li><li id="b74a" class="li lj hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">在您的代码中，要求<code class="eh kc kd ke kf b">bytenode</code>、<br/>、<code class="eh kc kd ke kf b">const bytenode = require('bytenode');<br/></code>在Node.js模块系统中注册<code class="eh kc kd ke kf b">.jsc</code>扩展。这也是我们在本地安装它的原因。</li><li id="a97a" class="li lj hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">你现在可以要求<code class="eh kc kd ke kf b">my-file.jsc</code>作为一个模块:<br/> <code class="eh kc kd ke kf b">const myFile = require('./my-file.jsc');<br/></code>你也可以从产品构建中移除<code class="eh kc kd ke kf b">my-file.js</code>。</li><li id="e52a" class="li lj hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">如果您想使用<code class="eh kc kd ke kf b">bytenode</code> cli运行<code class="eh kc kd ke kf b">my-file.jsc</code>:<br/><code class="eh kc kd ke kf b">bytenode --run my-file.jsc</code></li></ol><p id="a9fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在您知道了如何编译<code class="eh kc kd ke kf b">.js</code>文件，如何在代码中要求编译后的版本，以及如何从终端运行<code class="eh kc kd ke kf b">.jsc</code>文件。让我们继续说这个长故事。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="3e9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">V8引擎(Node.js基于该引擎)使用了所谓的即时编译(JIT ),即JavaScript代码在执行前编译，然后随后进行优化。</p><p id="9328" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从Node.js v5.7.0开始，<code class="eh kc kd ke kf b">vm</code>模块在<code class="eh kc kd ke kf b">vm.Script</code>构造函数中引入了一个名为<code class="eh kc kd ke kf b">produceCachedData</code>的属性，所以如果你这样做:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="94a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，获取字节码或<code class="eh kc kd ke kf b">cachedData</code>缓冲区:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="6cbf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过将这个<code class="eh kc kd ke kf b">helloBuffer</code>传递给<code class="eh kc kd ke kf b">vm.Script</code>构造函数，它可以用来创建一个相同的脚本，该脚本将在运行时执行相同的指令:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="0d21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这将失败，V8引擎将抱怨第一个参数(即空字符串<code class="eh kc kd ke kf b">''</code>)，当它检查它是否与最初用于生成<code class="eh kc kd ke kf b">helloBuffer</code>缓冲区的代码相同时。然而，这个检查过程非常简单，重要的是代码的长度。所以，这是可行的:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="2529" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们给它一个空字符串，长度(28)和原码一样(<code class="eh kc kd ke kf b">console.log("Hello World!");</code>)。就是这样！</p><p id="d0da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这很有趣，使用缓存的缓冲区和原始代码长度，我们能够创建一个相同的脚本。两个脚本都可以使用<code class="eh kc kd ke kf b">.runInThisContext();</code>功能运行。所以如果你运行它们:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="5e6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会看到“你好，世界！”两次。</p><p id="d7a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(注意，如果你使用了错误的长度，或者你使用了另一个版本的Node.js/V8:<code class="eh kc kd ke kf b">anotherHelloScript</code>将不会运行，它的属性<code class="eh kc kd ke kf b">cachedDataRejected</code>将被设置为<code class="eh kc kd ke kf b">true</code>)。</p><p id="71e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在到我们的最后一步，当我们定义<code class="eh kc kd ke kf b">anotherHelloScript</code>时，我们使用硬编码值(28)作为我们的代码长度。我们如何改变这一点，以便在运行时我们不必知道原始源代码到底有多长？</p><p id="723e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在V8源代码中做了一些挖掘之后，我发现头信息在这里<a class="ae jp" href="https://github.com/v8/v8/blob/9bcb5eb590643db0c1f688fea316c7f1f4786a3c/src/snapshot/code-serializer.h#L103-L113" rel="noopener ugc nofollow" target="_blank">定义</a>(在这个文件<code class="eh kc kd ke kf b">code-serializer.h</code>):</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="728b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，Node.js缓冲区是Uint8Array类型的数组。这意味着来自<code class="eh kc kd ke kf b">uint32</code>数组的每个条目将占用<code class="eh kc kd ke kf b">uint8</code>缓冲区中的四个条目。因此，有效载荷长度(在索引<code class="eh kc kd ke kf b">[2]</code>处为<code class="eh kc kd ke kf b">source hash</code>，在节点缓冲区中为<code class="eh kc kd ke kf b">[8, 9, 10, 11]</code>字节)将为:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="efeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大概是这样的:<code class="eh kc kd ke kf b">&lt;Buffer 1c 00 00 00&gt;</code>，是小端的，所以是:<code class="eh kc kd ke kf b">0x0000001c</code>。这就是我们的代码长度(十进制28)。</p><p id="f19e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要将这四个字节转换成一个数值，您可以这样做:</p><p id="5c39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kc kd ke kf b">firstByte + (secodeByte * 256) + (thirdByte * 256**2) + (forthByte * 256**3)</code>，</p><p id="76fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者用更优雅的方式，你可以这样做:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="8670" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我在我的图书馆<a class="ae jp" href="https://github.com/OsamaAbbas/bytenode/blob/4c3058e12f29ca33449a126c77ceaa57e967d45d/index.js#L29-L30" rel="noopener ugc nofollow" target="_blank">这里</a>所做的，查看完整的食谱。</p><p id="8a59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，我们可以使用<code class="eh kc kd ke kf b"><a class="ae jp" href="https://nodejs.org/api/buffer.html#buffer_buf_readintle_offset_bytelength" rel="noopener ugc nofollow" target="_blank">buf.readIntLE()</a></code>函数，它完全符合我们的要求:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="8e63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦你读取了原始代码的长度(用来生成<code class="eh kc kd ke kf b">cachedData</code>缓冲区)，你现在可以创建你的脚本了:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ly lz l"/></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="0bc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，这种技术对性能有影响吗？好吧，在v8(和Node.js)的最近版本中，性能都差不多。使用octance基准测试，我没有发现任何性能差异。我知道Google反对octance(因为浏览器和JS引擎作弊)，但是在我们的情况下结果是显著的，因为我们在相同的JS引擎上比较相同的代码。所以，最后的答案是:Bytenode对性能没有负面影响。</p><p id="768b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看我的<a class="ae jp" href="https://github.com/OsamaAbbas/bytenode" rel="noopener ugc nofollow" target="_blank"> Github库</a>，在那里你可以找到完整的工作示例。我为electronic(它完全没有源代码保护)和<a class="ae jp" href="https://github.com/OsamaAbbas/bytenode/tree/master/examples/nwjs-hello-world" rel="noopener ugc nofollow" target="_blank"> NW.js </a>(它有一个类似的工具<code class="eh kc kd ke kf b">nwjc</code>，但它只对浏览器端代码有效)添加了一个<a class="ae jp" href="https://github.com/OsamaAbbas/bytenode/tree/master/examples/electron-hello-world" rel="noopener ugc nofollow" target="_blank">示例。我将很快添加更多的例子(和测试)，希望如此。</a></p></div></div>    
</body>
</html>