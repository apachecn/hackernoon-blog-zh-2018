<html>
<head>
<title>Functional JavaScript — Functors, Monads, and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript —函子、单子和承诺</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/functional-javascript-functors-monads-and-promises-679ce2ab8abe?source=collection_archive---------5-----------------------#2018-11-07">https://medium.com/hackernoon/functional-javascript-functors-monads-and-promises-679ce2ab8abe?source=collection_archive---------5-----------------------#2018-11-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b39012dde84e772a699570e1fc3b0616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l7qpSg3swpubAQIv"/></div></div></figure><p id="a2a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有人说过一个<code class="eh ka kb kc kd b">Promise</code>就是一个<code class="eh ka kb kc kd b">Monad</code>。别人都说一个<code class="eh ka kb kc kd b">Promise</code>不是一个<code class="eh ka kb kc kd b">Monad</code>。他们都错了...他们都是对的。</p><p id="0983" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你读完这篇文章时，你会明白什么是<code class="eh ka kb kc kd b">Functor</code>和<code class="eh ka kb kc kd b">Monad</code>，以及它们与<code class="eh ka kb kc kd b">Promise</code>的相似和不同之处。</p><p id="bf8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">https://dev.to/joelnet/functional-javascript-函子-单子-承诺-1pol 。如果你想看到彩色的代码，请在DEV.to上阅读。</p><h1 id="9c3a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">为什么没人能解释一个单子？</h1><p id="5700" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">如果没有理解单子所需的必备词汇，很难解释单子是什么。</p><p id="f7b0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我喜欢理查德·费曼的这个视频，当他被要求描述两个磁铁之间“发生了什么”时。</p><p id="0028" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">整个视频是惊人的和令人兴奋的，但是如果你对学习有些厌恶，你可以直接跳到6:09。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><blockquote class="lo lp lq"><p id="70f9" class="jc jd lr je b jf jg jh ji jj jk jl jm ls jo jp jq lt js jt ju lu jw jx jy jz hn dt translated"><em class="hu">我无法用你所熟悉的其他事物来解释这种吸引力——理查德·费曼@ </em> <a class="ae ke" href="https://www.youtube.com/watch?v=MO0r930Sn_8#t=6m9s" rel="noopener ugc nofollow" target="_blank"> <em class="hu"> 6:09 </em> </a></p></blockquote><p id="f7e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以让我们后退几步，学习理解什么是<code class="eh ka kb kc kd b">Monad</code>所需的词汇。</p><h1 id="c5da" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">我们准备好理解函子了吗？</h1><p id="7363" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">定义:“函子”是“可映射”的东西，或者是可以在一个类别中的对象之间映射的东西。</p><p id="cc6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧…还没有。但是不要害怕，如果你用过<code class="eh ka kb kc kd b">Array</code>的<code class="eh ka kb kc kd b">map</code>功能，你就已经熟悉<code class="eh ka kb kc kd b">Functors</code>了。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="3613" class="lz kg hu kd b fv ma mb l mc md">[1, 2, 3].map(x =&gt; x * 2) //=&gt; [2, 4, 6]</span></pre><p id="2aff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们能够完全理解一个<code class="eh ka kb kc kd b">Functor</code>之前，我们也必须理解成为<code class="eh ka kb kc kd b">Mappable</code>意味着什么，并且理解我们也必须理解一个<code class="eh ka kb kc kd b">Category</code>是什么。所以让我们从这里开始。</p><h1 id="ee91" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated"><strong class="ak">类别、对象和贴图(态射)</strong></h1><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff me"><img src="../Images/00c113d15fffef633e30a53f4c2da309.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/0*OXp6yGo5kW5Onpmm"/></div></figure><p id="ba8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个<code class="eh ka kb kc kd b">category</code>由节点(对象)和态射(函数)的集合组成。一个对象可以是数字、字符串、URL、客户，或者任何其他你想组织的东西。(图中的X、Y和Z是对象。)</p><p id="4dea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">map</code>是一个将某物从一个对象转换到另一个对象的函数。(f，g，雾是贴图)。🔍谷歌提示:对象之间的一个<code class="eh ka kb kc kd b">map</code>被称为一个<code class="eh ka kb kc kd b">Morphism</code>。</p><p id="c0b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例:使用<code class="eh ka kb kc kd b">toString()</code>方法可以将对象<code class="eh ka kb kc kd b">Number Type</code>中的对象转换为对象<code class="eh ka kb kc kd b">String Type</code>。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="6b00" class="lz kg hu kd b fv ma mb l mc md">// A map of Number -&gt; String<br/>const numberToString = num =&gt; num.toString()</span></pre><p id="2fa8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你也可以创建<code class="eh ka kb kc kd b">maps</code>回自己的对象或更复杂的对象类型。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="31df" class="lz kg hu kd b fv ma mb l mc md">// A map of Number -&gt; Number<br/>const double = num =&gt; num * 2</span><span id="ffbe" class="lz kg hu kd b fv mf mb l mc md">// A map of Array -&gt; Number<br/>const arrayToLength = array =&gt; array.length</span><span id="e2ab" class="lz kg hu kd b fv mf mb l mc md">// A map of URL -&gt; Promise (JSON)<br/>const urlToJson = url =&gt;<br/>  fetch(url)<br/>    .then(response =&gt; response.json())</span></pre><p id="e574" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以一个对象可以很简单，比如一个数字或者一个字符串。对象也可以更抽象，如用户名、用户API URL、用户API HTTP请求、用户API响应、用户API响应JSON。然后我们可以在每个对象之间创建映射或变形来获得我们想要的数据。</p><p id="e2cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">态射的例子:</p><ul class=""><li id="a0a7" class="mg mh hu je b jf jg jj jk jn mi jr mj jv mk jz ml mm mn mo dt translated">用户名-&gt;用户API Url</li><li id="cbe4" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">用户API Url -&gt;用户API HTTP请求</li><li id="4b6e" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">用户API HTTP请求-&gt;用户API响应</li><li id="5621" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">用户API响应-&gt;用户API响应JSON</li></ul><p id="9a10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">🔍Google提示:<code class="eh ka kb kc kd b">Function Composition</code>是一种组合多个<code class="eh ka kb kc kd b">map</code>或<code class="eh ka kb kc kd b">morphisms</code>来创建新的<code class="eh ka kb kc kd b">maps</code>的方法。使用<code class="eh ka kb kc kd b">Function Composition</code>我们可以创建一个从<code class="eh ka kb kc kd b">Username</code>直接到<code class="eh ka kb kc kd b">User API Response JSON</code>的地图</p><h1 id="c194" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">回到函子</h1><p id="450c" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">现在我们明白了成为<code class="eh ka kb kc kd b">Mappable</code>意味着什么，我们终于可以明白什么是<code class="eh ka kb kc kd b">Functor</code>了。</p><p id="29e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个<code class="eh ka kb kc kd b">Functor</code>是一个<code class="eh ka kb kc kd b">Mappable</code>的东西，或者可以在一个类别中的对象之间映射的东西。</p><p id="f637" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个<code class="eh ka kb kc kd b">Array</code>是<code class="eh ka kb kc kd b">Mappable</code>，所以是一个<code class="eh ka kb kc kd b">Functor</code>。在这个例子中，我将一个<code class="eh ka kb kc kd b">Array of Numbers</code>变形为一个<code class="eh ka kb kc kd b">Array of Strings</code>。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="9b59" class="lz kg hu kd b fv ma mb l mc md">const numberToString = num =&gt; num.toString()</span><span id="644b" class="lz kg hu kd b fv mf mb l mc md">const array = [1, 2, 3]</span><span id="5e9a" class="lz kg hu kd b fv mf mb l mc md">array.map(numberToString)<br/>//=&gt; ["1", "2", "3"]</span></pre><p id="f71e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:一个<code class="eh ka kb kc kd b">Functor</code>的特性之一是它们总是保持同一类型的<code class="eh ka kb kc kd b">Functor</code>。您可以将包含<code class="eh ka kb kc kd b">Strings</code>的<code class="eh ka kb kc kd b">Array</code>变形为<code class="eh ka kb kc kd b">Numbers</code>或任何其他对象，但是<code class="eh ka kb kc kd b">map</code>将确保它始终是一个<code class="eh ka kb kc kd b">Array</code>。你不能把<code class="eh ka kb kc kd b">Number</code>的一个<code class="eh ka kb kc kd b">map</code>变成仅仅一个<code class="eh ka kb kc kd b">Number</code>。</p><p id="f25e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以将这种<code class="eh ka kb kc kd b">Mappable</code>用途扩展到其他物体上！让我们举一个简单的<code class="eh ka kb kc kd b">Thing</code>的例子。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="63be" class="lz kg hu kd b fv ma mb l mc md">const Thing = value =&gt; ({<br/>  value<br/>})</span></pre><p id="34f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想让<code class="eh ka kb kc kd b">Thing</code>像<code class="eh ka kb kc kd b">Array</code>一样可映射，我们只需要给它一个<code class="eh ka kb kc kd b">map</code>函数。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="c443" class="lz kg hu kd b fv ma mb l mc md">const Thing = value =&gt; ({<br/>  value,<br/>  map: morphism =&gt; Thing(morphism(value))<br/>//                 ----- -------- -----<br/>//                /        |            \<br/>// always a Thing          |             value to be morphed<br/>//                         |<br/>//             Morphism passed into map<br/>})</span><span id="f806" class="lz kg hu kd b fv mf mb l mc md">const thing1 = Thing(1)               // { value: 1 }<br/>const thing2 = thing1.map(x =&gt; x + 1) // { value: 2 }</span></pre><p id="8d4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那是一个<code class="eh ka kb kc kd b">Functor</code>！真的就这么简单。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/e0d87ebb8a09490e037e85e1b4f4e6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/0*29o2qihaLTJwbPjo"/></div></figure><p id="eda9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">🔍谷歌提示:我们创建的<code class="eh ka kb kc kd b">"Thing"</code> <code class="eh ka kb kc kd b">Functor</code>被称为<code class="eh ka kb kc kd b">Identity</code>。</p><h1 id="1390" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">回到单子上</h1><p id="268e" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">有时函数会返回一个已经包装好的值。这可能不方便与<code class="eh ka kb kc kd b">Functor</code>一起使用，因为它会将<code class="eh ka kb kc kd b">Functor</code>重新包裹在另一个<code class="eh ka kb kc kd b">Functor</code>中。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="0be9" class="lz kg hu kd b fv ma mb l mc md">const getThing = () =&gt; Thing(2)</span><span id="83c3" class="lz kg hu kd b fv mf mb l mc md">const thing1 = Thing(1)</span><span id="c4f2" class="lz kg hu kd b fv mf mb l mc md">thing1.map(getThing) //=&gt; Thing (Thing ("Thing 2"))</span></pre><p id="d6a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该行为与<code class="eh ka kb kc kd b">Array</code>的行为相同。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="fa73" class="lz kg hu kd b fv ma mb l mc md">const doSomething = x =&gt; [x, x + 100]<br/>const list = [1, 2, 3]</span><span id="70f7" class="lz kg hu kd b fv mf mb l mc md">list.map(doSomething) //=&gt; [[1, 101], [2, 102], [3, 103]]</span></pre><p id="49eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是<code class="eh ka kb kc kd b">flatMap</code>派上用场的地方。它类似于<code class="eh ka kb kc kd b">map</code>，除了态射也被期望执行包装值的工作。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="22c5" class="lz kg hu kd b fv ma mb l mc md">const Thing = value =&gt; ({<br/>  value,<br/>  map: morphism =&gt; Thing(morphism(value)),<br/>  flatMap: morphism =&gt; morphism(value)<br/>})</span><span id="8bce" class="lz kg hu kd b fv mf mb l mc md">const thing1 = Thing(1)                          //=&gt; Thing (1)<br/>const thing2 = thing1.flatMap(x =&gt; Thing(x + 1)) //=&gt; Thing (2)</span></pre><p id="96e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样看起来更好！</p><p id="d9b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你可能需要从<code class="eh ka kb kc kd b">Just</code>切换到<code class="eh ka kb kc kd b">Nothing</code>时，这在<code class="eh ka kb kc kd b">Maybe</code>中会派上用场，例如当道具丢失时。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="395b" class="lz kg hu kd b fv ma mb l mc md">import Just from 'mojiscript/type/Just'<br/>import Nothing from 'mojiscript/type/Nothing'</span><span id="e78e" class="lz kg hu kd b fv mf mb l mc md">const prop = (prop, obj) =&gt;<br/>  prop in obj<br/>    ? Just(obj[prop])<br/>    : Nothing</span><span id="ecc9" class="lz kg hu kd b fv mf mb l mc md">Just({ name: 'Moji' }).flatMap(x =&gt; prop('name', x))<br/>//=&gt; Just ("Moji")</span><span id="ea38" class="lz kg hu kd b fv mf mb l mc md">Just({}).flatMap(x =&gt; prop('name', x))<br/>//=&gt; Nothing</span></pre><p id="2506" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该代码可以缩短为:</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="cee7" class="lz kg hu kd b fv ma mb l mc md">const Just = require('mojiscript/type/Just')<br/>const Nothing = require('mojiscript/type/Nothing')<br/>const { fromNullable } = require('mojiscript/type/Maybe')</span><span id="a9c0" class="lz kg hu kd b fv mf mb l mc md">const prop = prop =&gt; obj =&gt; fromNullable(obj[prop])</span><span id="413d" class="lz kg hu kd b fv mf mb l mc md">Just({ name: 'Moji' }).flatMap(prop('name'))<br/>//=&gt; Just ("Moji")</span><span id="47da" class="lz kg hu kd b fv mf mb l mc md">Just({}).flatMap(prop('name'))<br/>//=&gt; Nothing</span></pre><p id="cd97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">🔍Google提示:这个代码缩短是通过<code class="eh ka kb kc kd b">currying</code>、<code class="eh ka kb kc kd b">partial application</code>和<code class="eh ka kb kc kd b">point-free style</code>实现的。</p><p id="8423" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望在这一点上，你认为这是一个比你最初认为的更容易的旅程。我们已经讲述了<code class="eh ka kb kc kd b">Functors</code>和<code class="eh ka kb kc kd b">Monads</code>以及接下来的<code class="eh ka kb kc kd b">Promise</code>！</p><h1 id="90dd" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">承诺</h1><p id="a907" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">如果这些代码看起来很熟悉，那是因为<code class="eh ka kb kc kd b">Promise</code>的行为类似于<code class="eh ka kb kc kd b">map</code>和<code class="eh ka kb kc kd b">flatMap</code>。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="8ea3" class="lz kg hu kd b fv ma mb l mc md">const double = num =&gt; num * 2</span><span id="f6ef" class="lz kg hu kd b fv mf mb l mc md">const thing1 = Thing(1)             //=&gt; Thing (1)<br/>const promise1 = Promise.resolve(1) //=&gt; Promise (1)</span><span id="580d" class="lz kg hu kd b fv mf mb l mc md">thing1.map(double)    //=&gt; Thing (2)<br/>promise1.then(double) //=&gt; Promise (2)</span><span id="267a" class="lz kg hu kd b fv mf mb l mc md">thing1.flatMap(x =&gt; Thing(double(x)))<br/>//=&gt; Thing (2)</span><span id="1927" class="lz kg hu kd b fv mf mb l mc md">promise1.then(x =&gt; Promise.resolve(double(x)))<br/>//=&gt; Promise (2)</span></pre><p id="a990" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你所看到的，当返回一个展开的值时，<code class="eh ka kb kc kd b">Promise</code>方法<code class="eh ka kb kc kd b">then</code>像<code class="eh ka kb kc kd b">map</code>一样工作，当它被包装在<code class="eh ka kb kc kd b">Promise</code>中时，像<code class="eh ka kb kc kd b">flatMap</code>一样工作。这样，<code class="eh ka kb kc kd b">Promise</code>类似于<code class="eh ka kb kc kd b">Functor</code>和<code class="eh ka kb kc kd b">Monad</code>。</p><p id="2427" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这也是它与众不同的地方。</p><pre class="li lj lk ll fq lv kd lw lx aw ly dt"><span id="32ac" class="lz kg hu kd b fv ma mb l mc md">thing1.map(x =&gt; Thing(x + 1))              // Thing (Thing (2))<br/>promise1.then(x =&gt; Promise.resolve(x + 1)) // Promise (2)</span><span id="fd17" class="lz kg hu kd b fv mf mb l mc md">thing1.flatMap(x =&gt; x + 1) //=&gt; 2<br/>promise1.then(x =&gt; x + 1)  //=&gt; Promise (2)</span></pre><p id="7190" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我想包装一个值两次(想想嵌套的<code class="eh ka kb kc kd b">Arrays</code>)或者控制返回类型，我不能用<code class="eh ka kb kc kd b">Promise</code>。这样，它违反了<code class="eh ka kb kc kd b">Functor</code>定律，也违反了<code class="eh ka kb kc kd b">Monad</code>定律。</p><h1 id="f0ea" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">摘要</h1><ul class=""><li id="9cef" class="mg mh hu je b jf ld jj le jn mv jr mw jv mx jz ml mm mn mo dt translated">一个<code class="eh ka kb kc kd b">Functor</code>是一个<code class="eh ka kb kc kd b">Mappable</code>或者可以在一个类别中的对象之间映射的东西。</li><li id="1c2f" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">一个<code class="eh ka kb kc kd b">Monad</code>类似于一个<code class="eh ka kb kc kd b">Functor</code>，但是在类别之间是<code class="eh ka kb kc kd b">Flat Mappable</code>。</li><li id="6e3f" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated"><code class="eh ka kb kc kd b">flatMap</code>与<code class="eh ka kb kc kd b">map</code>相似，但是产生了对映射函数返回类型包装的控制。</li><li id="b103" class="mg mh hu je b jf mp jj mq jn mr jr ms jv mt jz ml mm mn mo dt translated">承诺违反了<code class="eh ka kb kc kd b">Functor</code>和<code class="eh ka kb kc kd b">Monad</code>定律，但仍有很多相似之处。相同但不同。</li></ul><p id="5f00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续阅读:<a class="ae ke" href="https://dev.to/joelnet/null-the-billion-dollar-mistake-maybe-just-nothing-1cak" rel="noopener ugc nofollow" target="_blank">空，“十亿美元的错误”，也许什么都没有</a></p><p id="6548" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的文章展示了对函数式JavaScript的热爱。如果你需要更多的FP，在这里或者在Twitter上关注我<a class="ae ke" href="https://twitter.com/joelnet" rel="noopener ugc nofollow" target="_blank"> @joelnet </a>！</p><p id="acde" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢我的好友Joon证明了这一点:)</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/30b90d46a9b2745d8e966e41afc4649a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*mDOf9L4OtuaRexe8.jpg"/></div></figure></div></div>    
</body>
</html>