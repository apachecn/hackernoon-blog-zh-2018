<html>
<head>
<title>Why Not Make?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不做？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-not-make-db142ccb2081?source=collection_archive---------7-----------------------#2018-11-07">https://medium.com/hackernoon/why-not-make-db142ccb2081?source=collection_archive---------7-----------------------#2018-11-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/5d83cb7c2961bbfd655fdb9430d2f991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H9N5ljeBhAHjvZUG"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">“blue building block lot” by <a class="ae ih" href="https://unsplash.com/@iurte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Iker Urteaga</a> on <a class="ae ih" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="d898" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Make是一个概念上简单的构建系统，它与主要的Linux发行版打包在一起。然而，在开始一个新的C++项目时，Make很少会成为您的构建系统的选择。</p><p id="799d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个大胆的主张，所以这里是为什么…</p><h2 id="a693" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">编写一个大而正确的Makefile真的很难</h2><p id="fc3d" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">C++库的依赖图实际上相当复杂。每次一个链接的目标文件改变时，它必须被重建…但是每次一个目标文件的翻译单元改变，或者编译标志改变，或者它包含的任何头文件改变，或者编译器改变时，它都应该被重建…</p><p id="29ba" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可以使用编译器查询这些信息，并将所有这些信息编码到Makefile中，但是这会变得非常冗长。</p><p id="2f50" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很有可能你会错过一个依赖。如果发生这种情况，那么在一个改变之后，你可能会有陈旧的工件。提示一个干净的构建！</p><h2 id="8117" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">没有沙盒</h2><p id="ce05" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">缺少沙盒是根本问题。Make有一个依赖图，但它实际上并不强制执行它。这意味着一个构建规则可以读取一个文件，即使它在Make中没有被声明为依赖项！</p><h2 id="1166" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">缓存是不可移植的</h2><p id="dd7e" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">Make不允许你跨网络共享构建工件，所以你的开发团队中的每个人都将一遍又一遍地执行相同的构建步骤！</p><p id="12a4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">是的，您可以使用CCache，但这并不普遍(只有编译器调用被缓存)，而且它不是现成的。</p><h2 id="3200" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">没有提供语言抽象</h2><p id="be5c" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">Make的简洁是一大优点，但也是一大弱点。Make不提供任何特定于语言的抽象，所以必须自己编写。这可能会变得非常乏味，而且出错的几率很高。</p><p id="888c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这也适用于测试、部署等等。你需要自己创造一切。</p><h2 id="8650" class="kf kg ik bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">时间戳，而不是哈希</h2><p id="760d" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在确定何时重建时，Make使用构建输入的时间戳，而不是它们的散列。当文件已被触摸，但实际上并未更改时，这会导致许多不必要的重建。如果这发生在依赖关系树的深处，那么重建将花费很长时间！</p><h1 id="a41e" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">那么什么时候应该使用Make呢？</h1><p id="c418" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">也不全是坏事；Make仍然是一个引导工具。如果您有极端的依赖性需求(例如，您正在从源代码构建Linux)，那么您需要一些简单且自包含的东西。但是对于大多数开发者来说，情况并非如此。我们已经获得了Clang、GCC和Visual Studio作为预构建的二进制文件，那么为什么不下载一个预构建的构建系统呢？</p><h1 id="e5ef" class="lf kg ik bd kh lg lh li kl lj lk ll kp lm ln lo ks lp lq lr kv ls lt lu ky lv dt translated">既然你在这里…</h1><p id="a66b" class="pw-post-body-paragraph jh ji ik jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我们最近发布了<a class="ae ih" href="https://buildinfer.loopperfect.com/" rel="noopener ugc nofollow" target="_blank"> BuildInfer </a>，这是一款优化C/C++构建脚本的新工具。<a class="ae ih" href="https://buildinfer.loopperfect.com/" rel="noopener ugc nofollow" target="_blank">看一看</a>！</p><figure class="lx ly lz ma fq hw fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/5b29e7d89e98091a3ce03d7088438ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pkwieX1RSK5S0LXbFyaEJg.png"/></div></figure></div></div>    
</body>
</html>