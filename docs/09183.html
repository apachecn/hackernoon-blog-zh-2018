<html>
<head>
<title>The Bcrypt Protocol… is kind of a mess</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bcrypt协议…有点乱</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-bcrypt-protocol-is-kind-of-a-mess-4aace5eb31bd?source=collection_archive---------8-----------------------#2018-11-07">https://medium.com/hackernoon/the-bcrypt-protocol-is-kind-of-a-mess-4aace5eb31bd?source=collection_archive---------8-----------------------#2018-11-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/424d1b16905ce88f8e44aa21b2415610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nnp9MK5uVf5e2ncH6aftw.jpeg"/></div></div></figure><div class=""/><p id="dbd2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">在编写自己的Bcrypt库时，由于对当前Java事实上的标准实现jBcrypt不满意，我发现了许多围绕bcrypt协议的奇怪事情(请注意:不是底层加密原语‘Eksblowfish’)。</em></p><p id="c39c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt kb translated"><span class="l kc kd ke bm kf kg kh ki kj di"> B </span> crypt是一个密码哈希函数<a class="ae kk" href="http://www.usenix.org/events/usenix99/provos/provos_html/node1.html" rel="noopener ugc nofollow" target="_blank">，由Niels Provos和David Mazières </a>于1999年设计，作为OpenBSD <a class="ae kk" href="https://en.wikipedia.org/wiki/Bcrypt" rel="noopener ugc nofollow" target="_blank"> </a>的默认密码哈希算法而流行。与简单的<a class="ae kk" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="noopener ugc nofollow" target="_blank">加密哈希函数</a>(像SHA-256)相比，使用bcrypt的主要好处是开发者可以设置计算哈希的成本。这被称为<a class="ae kk" href="https://en.wikipedia.org/wiki/Key_stretching" rel="noopener ugc nofollow" target="_blank">键拉伸</a>，应该与任何(通常是脆弱的)用户提供的密码一起使用，以防止暴力攻击(即简单的猜测)。</p><h2 id="d973" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">Bcrypt简介</h2><p id="b75f" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">那么它是如何工作的呢？首先，您需要一个密码，并将迭代次数设置为一个介于4-31之间的对数工作因子，每增加一次就需要加倍计算。例如，它可能是这样的:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="d5ba" class="kl km if lq b fv lu lv l lw lx">bcrypt("secretPassword", 8)</span></pre><p id="cb9b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其可以输出</p><figure class="ll lm ln lo fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ly"><img src="../Images/264f5aeb4b34bcfd13227a12f947e75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFASmAwFFZot0rTrJv1W1Q.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">$2a$08$0SN/h83Gt1jZMR6924.Kd.HaK3MyTDt/W8FCjUOtbY3Pmres5rsma</figcaption></figure><p id="40ae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是OpenBSD定义和使用的<a class="ae kk" href="https://passlib.readthedocs.io/en/stable/modular_crypt_format.html" rel="noopener ugc nofollow" target="_blank">模块化crypt格式</a>。第一部分<code class="eh md me mf lq b">$2a$</code>是协议版本标识符。历史上bcrypt曾经是<code class="eh md me mf lq b">$2$</code>,但是因为当时没有人考虑Unicode处理，所以必须定义一个新版本。下一部分<code class="eh md me mf lq b">08$</code>是传递给函数的工作因子。接下来的22个ASCII字符(原始16字节)<code class="eh md me mf lq b">0SN/h83Gt1jZMR6924.Kd.</code>代表编码的salt。大多数实现会自动为调用者创建一个salt，这很好。这种措施可以防止彩虹表，即使用预先计算的常用密码哈希列表。</p><p id="6a55" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，最后23个字节或编码的31个ASCII字符是实际的bcrypt散列:<code class="eh md me mf lq b">HaK3MyTDt/W8FCjUOtbY3Pmres5rsma</code>。这种格式对于存储密码散列特别方便，因为除了实际的密码之外，所有的参数都包括在内。</p><h2 id="d7bb" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">问题1:非标准编码</h2><p id="d292" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">bcrypt的一个奇怪之处是，它使用非标准的Base64方言对salt和hash进行编码。这种方言被列在<a class="ae kk" href="https://en.wikipedia.org/wiki/Base64#Radix-64_applications_not_compatible_with_Base64" rel="noopener ugc nofollow" target="_blank">维基百科</a>的“Radix-64应用”部分，并归于<a class="ae kk" href="https://man7.org/linux/man-pages/man3/crypt.3.html" rel="noopener ugc nofollow" target="_blank"> crypt(3) </a>，现代用法仅限于bcrypt。虽然它使用与标准Base64相同的字母表，但它被置换，使其与<a class="ae kk" href="https://tools.ietf.org/html/rfc4648#section-5" rel="noopener ugc nofollow" target="_blank"> RFC 4648 </a>不兼容。这使得实现它变得不必要的困难和更容易出错，因为几乎所有的编程语言都有Base64的RFC 4648实现或对它的支持。</p><h2 id="bffa" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">问题2:使用23字节而不是完整的24字节哈希</h2><p id="8db1" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如前所述，几乎所有bcrypt实现都输出一个23字节长的散列。然而，bcrypt算法通过使用密码派生的blowfish密钥加密三个8字节块来生成24字节的密码散列。然而，最初的参考实现选择截断散列输出，据传原因是将其限制在更易于管理的60个字符的长度内(如果你问我，这是一个奇怪的原因)。<a class="ae kk" href="https://news.ycombinator.com/item?id=2654586" rel="noopener ugc nofollow" target="_blank">共识似乎是</a>删除一个散列字节的问题并不是一个有意义的安全性降级，所以它仍然是从参考实现继承来的一个奇怪的东西。</p><h2 id="6620" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">问题3:白皮书的衍生与参考实施</h2><p id="b3b6" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">根据<a class="ae kk" href="http://javadox.com/org.bouncycastle/bcprov-jdk15on/1.53/org/bouncycastle/crypto/generators/BCrypt.html" rel="noopener ugc nofollow" target="_blank"> BouncyCastle Javadoc </a>的说法，OpenBSD参考实现衍生自<a class="ae kk" href="http://www.openbsd.org/papers/bcrypt-paper.ps" rel="noopener ugc nofollow" target="_blank">白皮书</a>中描述的算法:</p><blockquote class="mg mh mi"><p id="6531" class="jc jd ka je b jf jg jh ji jj jk jl jm mj jo jp jq mk js jt ju ml jw jx jy jz hn dt translated">与本文相反，键设置和盐设置的顺序是相反的:声明</p></blockquote><p id="7cca" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">There is no reference to a potential security vulnerability because of that (and I wouldn’t expect one). Since basically everybody copied the behavior of the reference implementation, the specification seems to be superseded.</p><h2 id="5699" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">Issue 4: No handling for passwords longer than 56/72 bytes</h2><p id="f7f5" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">According to the <a class="ae kk" href="http://www.openbsd.org/papers/bcrypt-paper.ps" rel="noopener ugc nofollow" target="_blank">白皮书</a>:</p><blockquote class="mg mh mi"><p id="fb69" class="jc jd ka je b jf jg jh ji jj jk jl jm mj jo jp jq mk js jt ju ml jw jx jy jz hn dt translated">(…)key参数是一个秘密加密密钥，它可以是用户选择的最长为56个字节的密码(当密钥是ASCII字符串时，包括一个终止的零字节)。</p></blockquote><p id="f182" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其他人<a class="ae kk" href="https://security.stackexchange.com/questions/39849/does-bcrypt-have-a-maximum-password-length" rel="noopener ugc nofollow" target="_blank">指出</a>该算法在内部将事物管理为18个32位字，总共72个字节(包括一个空终止符字节)。请注意，一个UTF-8字符可以占用多达4个字节的空间，这将在最坏的情况下将密码限制为14个字符。</p><p id="3bcb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对实际限制的混淆和缺乏对长密码做什么的规范会产生许多兼容性问题，也可能产生bcrypt的许多不同方言。</p><h2 id="34f9" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">问题5:许多非标准版本</h2><p id="7a19" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如前所述，bcrypt最初的版本<code class="eh md me mf lq b">$2$</code>缺乏如何处理非ASCII字符的定义，所以最流行的版本<code class="eh md me mf lq b">$2a$</code>解决了这个问题。但是当然其他的实现也有问题，所以PHP版本有一个<code class="eh md me mf lq b">$2x$</code>和<code class="eh md me mf lq b">$2y$</code>，还有<a class="ae kk" href="http://undeadly.org/cgi?action=article&amp;sid=20140224132743" rel="noopener ugc nofollow" target="_blank"> talk将原来的版本输出</a>转移到<code class="eh md me mf lq b">$2b$</code>。这些版本更改中的大部分解决了特定实现中的错误，可能不适用于其他实现。然而，这使得不同系统(通常是PHP和其他系统使用的数据库，例如<a class="ae kk" href="https://stackoverflow.com/questions/49878948/hashing-password-with-2y-identifier" rel="noopener ugc nofollow" target="_blank"> this </a>)之间更难实现互操作性</p><h2 id="bc66" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">问题6:效率稍低的格式</h2><p id="f1c2" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">输出格式</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="b672" class="kl km if lq b fv lu lv l lw lx">$2a$08$0SN/h83Gt1jZMR6924.Kd.HaK3MyTDt/W8FCjUOtbY3Pmres5rsma</span></pre><p id="ef2e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然已经过优化，便于用户阅读。解析起来也有点低效:首先整个字符串必须作为ASCII读入，然后必须逐个字符地解析，直到最后的<code class="eh md me mf lq b">$</code>。之后，接下来的22和32个字符被分别解码。使用更紧凑的消息格式，并且只编码一次，例如:</p><figure class="ll lm ln lo fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mm"><img src="../Images/9a98c3dc2fe3fa1cf32ae8106a4ad3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUs9KREMBXKziDZFXL0H2w.png"/></div></div></figure><p id="173e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">存储需求从60字节减少到约56字节(Base64编码)。这在大多数用例中是不相关的，但是在存储数百万或数十亿个密码散列的授权范围内，这可以稍微减少存储需求和解析计算时间。</p><h2 id="2a86" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">问题7:没有官方的测试载体</h2><p id="1fa0" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">当试图实现bcrypt时，开发人员面临着缺乏官方测试向量(也称为测试用例)来验证算法的问题。除了一些随机的测试案例，无论是白皮书还是谷歌搜索都没有发现很多有用的例子。这使得很难验证与其他实现的兼容性。这实际上是我张贴我自己的一些的原因，试图捕捉大多数边缘情况；他们可以在这里找到。</p><h2 id="775f" class="kl km if bd kn ko kp kq kr ks kt ku kv jn kw kx ky jr kz la lb jv lc ld le lf dt translated">问题8:不太适合作为密钥派生函数</h2><p id="0154" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">OpenBSD上的Bcrypt是为密码存储而设计的。然而，很多时候需要从用户密码创建秘密密钥，这需要密钥导出函数(KDF)。缺少的两个属性是设置任意out长度以满足不同键类型的能力，以及只输出原始散列而不输出整个消息格式的能力。目前，需要解析散列消息的最后31个字符，然后用适当的KDF扩展它。<a class="ae kk" href="https://en.wikipedia.org/wiki/HKDF" rel="noopener ugc nofollow" target="_blank"> HKDF </a>。</p><p id="eb23" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">注意</strong> : Bcrypt不是KDF不一定是Bcrypt的问题(它从未声称是)。然而，开发人员经常在没有真正了解潜在问题的情况下误用它。提供一个选项来使用KDF将有所帮助。</p><h1 id="e306" class="mn km if bd kn mo mp mq kr mr ms mt kv mu mv mw ky mx my mz lb na nb nc le nd dt translated">结论</h1><p id="7bfb" class="pw-post-body-paragraph jc jd if je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">缺乏权威的强有力的规范、年龄以及许多实现中的各种怪癖和错误使得很难正确地实现这个经过时间考验的密码散列函数。</p><p id="48d5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安全问题很难解决。因此，即使有些问题看起来很挑剔(也许确实如此)，也没有理由去追求最简单、最直接的实现和API，从而得到可以用作实现基础的经过评审的规范。相信我，我也经历过。</p><p id="8284" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="ka">只是重申一下</em> </strong>:我不挑战底层“Eksblowfish”(“昂贵的密钥表blowfish”)的安全强度，那些<a class="ae kk" href="https://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage" rel="noopener ugc nofollow" target="_blank">分析</a>应该留给密码专家。不过，我想总结一下，bcrypt仍然属于推荐的密码散列函数的范畴。</p><p id="290e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请继续关注第2部分，在那里我提出了一个基于bcrypt和改进的密码散列协议的KDF。</p></div><div class="ab cl ne nf hc ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hn ho hp hq hr"><p id="790e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个小插件:解释的大多数问题都可以用我的bcrypt的Java实现来克服(使用jBcrypt的<em class="ka"> Eksblowfish </em>算法)。这个库的主要目标是尽可能简单明了，让不熟悉bcrypt的人很难弄错，但仍然允许尽可能多的灵活性。看看吧，你可能会发现它很有用(它是Apache v2):</p><div class="ht hu fm fo hv nl"><a href="https://github.com/patrickfav/bcrypt" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab ej"><div class="nn ab no cl cj np"><h2 class="bd ig fv z el nq eo ep nr er et ie dt translated">patrickfav/bcrypt</h2><div class="ns l"><h3 class="bd b fv z el nq eo ep nr er et ek translated">这是OpenBSD Blowfish密码散列算法的一个实现，如“适应未来的……</h3></div><div class="nt l"><p class="bd b gc z el nq eo ep nr er et ek translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ib nl"/></div></div></a></div></div></div>    
</body>
</html>