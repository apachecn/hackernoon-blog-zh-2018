<html>
<head>
<title>Efficient development with Docker and docker-compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker和docker-compose进行高效开发</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/efficient-development-with-docker-and-docker-compose-e354b4d24831?source=collection_archive---------0-----------------------#2018-11-09">https://medium.com/hackernoon/efficient-development-with-docker-and-docker-compose-e354b4d24831?source=collection_archive---------0-----------------------#2018-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d817aa09787ba817d44f7dfd3cf062b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7fb5vghcVeF5S2DYxrhiA.jpeg"/></div></div></figure><p id="0a22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将为一个包含各种服务的项目建立一个开发环境。所有这些服务都将被Docker容器化，它们将在开发期间使用docker-compose同时运行。</p><p id="c1f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的环境将具有即时代码重载、测试驱动开发、数据库连接、依赖性管理等特性。使用docker-compose或Rancher可以很容易地将它部署到产品中。作为奖励，我们将在Gitlab上建立持续集成。</p><p id="eb0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">文章讲的是效率，我就开门见山了。</p><h2 id="0a33" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">目标</h2><p id="e2a9" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我们希望:</p><ul class=""><li id="fac4" class="la lb hu je b jf jg jj jk jn lc jr ld jv le jz lf lg lh li dt translated">在我们的Docker容器中尽快键入代码并观察变化，最好没有手动操作；</li><li id="f394" class="la lb hu je b jf lj jj lk jn ll jr lm jv ln jz lf lg lh li dt translated">拥有代表实际部署环境的本地环境；</li><li id="0bb3" class="la lb hu je b jf lj jj lk jn ll jr lm jv ln jz lf lg lh li dt translated">支持多种工作流。</li></ul><p id="c90f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们实现它。</p><h2 id="272e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">先决条件</h2><p id="23f5" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">您将需要安装以下工具:</p><ul class=""><li id="9be4" class="la lb hu je b jf jg jj jk jn lc jr ld jv le jz lf lg lh li dt translated"><a class="ae lo" href="https://docs.docker.com/engine/installation/linux/" rel="noopener ugc nofollow" target="_blank">码头工人</a> (CE没事)</li><li id="0207" class="la lb hu je b jf lj jj lk jn ll jr lm jv ln jz lf lg lh li dt translated"><a class="ae lo" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> docker-compose </a></li></ul><h2 id="938f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">前提</h2><p id="4e70" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我们将建立一个由Python和Java服务以及Postgres数据库组成的项目。Postgres数据库将在开发环境中运行在我们自己的机器上，但是在生产过程中被认为是外部的(例如，它可能使用Amazon RDS)。</p><p id="9f61" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Python服务包含Pytest支持的单元测试，我们将为此设置测试驱动开发。Java服务在构建过程中使用Maven。</p><p id="7eb6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们将使用Gitlab的容器注册表和Gitlab的CI服务。下面描述的代码也可以在<a class="ae lo" href="https://github.com/larsderidder/docker-compose-development-env" rel="noopener ugc nofollow" target="_blank"> Github </a>或<a class="ae lo" href="https://gitlab.com/lars_xithing/docker-compose-development-env" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>库中获得。</p><p id="fc8f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个设置应该演示最基本的概念。然而，下面描述的方法应该不管技术如何都可以工作。</p><h2 id="a2a1" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">设置</h2><p id="9800" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">文件结构:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="fc55" class="ka kb hu lu b fv ly lz l ma mb">|/myproject<br/>| /python<br/>|  /mypackage<br/>|   run.py<br/>|  /tests<br/>|   my test.py<br/>|  Dockerfile<br/>|  setup.py<br/>|  requirements.txt<br/>|<br/>| /java<br/>|  Dockerfile<br/>|  pom.xml<br/>|  /src<br/>|   /main<br/>|    /java<br/>|     /com<br/>|      /example<br/>|       /Main.java<br/>|<br/>| docker-compose.common.yml<br/>| docker-compose.dev.yml<br/>| docker-compose.prod.yml<br/>| Makefile<br/>| python-tests.sh<br/>| .gitlab-ci.yml</span></pre><p id="c645" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Python服务的docker文件如下:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="cf4d" class="ka kb hu lu b fv ly lz l ma mb">FROM python:3.6-slim</span><span id="e965" class="ka kb hu lu b fv mc lz l ma mb">COPY . /code<br/>WORKDIR /code</span><span id="5ec6" class="ka kb hu lu b fv mc lz l ma mb">RUN pip install --no-cache-dir -r requirements.txt<br/>RUN pip install -e .</span><span id="fcac" class="ka kb hu lu b fv mc lz l ma mb">ENTRYPOINT python ./mypackage/run.py</span></pre><p id="efc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将服务代码添加到容器中，安装它的依赖项(包含在requirements.txt中，在本例中它将包含<code class="eh md me mf lu b">pytest</code>和<code class="eh md me mf lu b">watchdog</code>)，并安装Python服务本身。它还定义了容器启动时要执行的命令。</p><p id="1905" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Java服务的docker文件可以在下面找到:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="3f8b" class="ka kb hu lu b fv ly lz l ma mb">FROM maven:3.5-jdk-8</span><span id="0f63" class="ka kb hu lu b fv mc lz l ma mb">COPY . /usr/src/app<br/>WORKDIR /usr/src/app</span><span id="9071" class="ka kb hu lu b fv mc lz l ma mb">RUN apt-get update &amp;&amp; apt-get install entr -y</span><span id="1d36" class="ka kb hu lu b fv mc lz l ma mb">RUN mvn clean package --batch-mode<br/>ENTRYPOINT java -jar target/docker-compose-java-example-1.0-SNAPSHOT.jar</span></pre><p id="ea10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像Python Dockerfile一样，这也首先将代码添加到容器中。然后继续安装Unix实用程序<code class="eh md me mf lu b">entr</code>,我们稍后会用到它。Maven用于创建JAR文件，之后我们定义容器命令来执行JAR文件。</p><p id="24cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，docker-compose.common.yml文件构成了我们的环境的基础，它包含了对应用程序很重要的所有配置，而不管它是在什么环境中执行的。这相当简单:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="3776" class="ka kb hu lu b fv ly lz l ma mb">version: '2'</span><span id="89ff" class="ka kb hu lu b fv mc lz l ma mb">services:<br/>  python:<br/>    build: ./python<br/>    environment:<br/>      - POSTGRES_USER<br/>      - POSTGRES_PASSWORD<br/>      - POSTGRES_DB<br/>      - POSTGRES_HOST</span><span id="8b50" class="ka kb hu lu b fv mc lz l ma mb">  java:<br/>    build: ./java<br/>    environment:<br/>      - POSTGRES_USER<br/>      - POSTGRES_PASSWORD<br/>      - POSTGRES_DB<br/>      - POSTGRES_HOST</span></pre><p id="bf4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这为我们提供了创建开发配置的所有要素。</p><h2 id="c19a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">开发配置</h2><p id="1c1d" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我们来看看docker-compose.dev.yml文件。这可能看起来令人生畏，但是不要担心，我们将在下面一步一步地完成它。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="864b" class="ka kb hu lu b fv ly lz l ma mb">version: '2'</span><span id="8010" class="ka kb hu lu b fv mc lz l ma mb">services:<br/>  python:<br/>    image: registry.gitlab.com/mycompany/myproject/python:dev<br/>    volumes:<br/>      - ./python/:/code<br/>    entrypoint: watchmedo auto-restart --recursive --pattern="*.py" --directory="." python mypackage/run.py<br/>    depends_on:<br/>      - postgres<br/>    links:<br/>      - postgres<br/>    environment:<br/>      - POSTGRES_USER=user<br/>      - POSTGRES_PASSWORD=password<br/>      - POSTGRES_DB=myproject<br/>      - POSTGRES_HOST=postgres</span><span id="0a15" class="ka kb hu lu b fv mc lz l ma mb">python-tests:<br/>    image: registry.gitlab.com/mycompany/myproject/python:dev<br/>    volumes:<br/>      - ./python/:/code<br/>    entrypoint: watchmedo auto-restart --recursive --pattern="*.py" --directory="." pytest<br/>    depends_on:<br/>      - python<br/><br/>  java:<br/>    image: registry.gitlab.com/mycompany/myproject/java:dev<br/>    volumes:<br/>      - ./java/:/usr/src/app<br/>    entrypoint: sh -c 'find src/ | entr mvn clean compile exec:java --batch-mode --quiet'<br/>    depends_on:<br/>      - postgres<br/>    links:<br/>      - postgres<br/>    environment:<br/>      - POSTGRES_USER=user<br/>      - POSTGRES_PASSWORD=password<br/>      - POSTGRES_DB=myproject<br/>      - POSTGRES_HOST=postgres</span><span id="752e" class="ka kb hu lu b fv mc lz l ma mb">  postgres:<br/>    image: postgres:9.6<br/>    environment:<br/>      - POSTGRES_USER=user<br/>      - POSTGRES_PASSWORD=password<br/>      - POSTGRES_DB=myproject<br/>    volumes:<br/>      - /data/aedspy/postgres:/var/lib/postgresql/data</span><span id="d6fa" class="ka kb hu lu b fv mc lz l ma mb">  pgadminer:<br/>    image: clue/adminer<br/>    ports: <br/>      - "99:80"</span></pre><h2 id="f58a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">开发配置— Python</h2><p id="34f1" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">让我们从Python服务开始。我会指出有趣的部分。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="f61c" class="ka kb hu lu b fv ly lz l ma mb">volumes:<br/>  - ./python/:/code</span></pre><p id="a07d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里实际发生的是我们主机上的<code class="eh md me mf lu b">python</code>子目录，包含我们Python服务的代码，现在被映射到我们容器中的<code class="eh md me mf lu b">/code</code>目录。要回答为什么这是相关的问题，让我们快速地再看一下Python Dockerfile文件中的相关行:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="9b27" class="ka kb hu lu b fv ly lz l ma mb">COPY . /code<br/>WORKDIR /code</span></pre><p id="5f0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果docker-compose.dev.yml文件中没有<code class="eh md me mf lu b">volumes</code>语句，<code class="eh md me mf lu b">python</code>子目录的内容将被简单地添加到容器中。如果在主机上进行了更改，那么在我们可以在容器中看到这些更改之前，必须重新构建容器。</p><p id="d873" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，使用docker-compose.dev.yml文件中包含的<code class="eh md me mf lu b">volumes</code>语句，您所做的任何更改都会立即反映在容器内部。这是因为两个目录现在都指向<em class="mg">完全相同的文件</em>。</p><p id="7ce1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">docker-compose.dev.yml文件中的下几行利用了这一点:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="e59f" class="ka kb hu lu b fv ly lz l ma mb">entrypoint: watchmedo auto-restart --recursive --pattern="*.py" --directory="." python mypackage/run.py</span></pre><p id="07fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一行覆盖了容器的<code class="eh md me mf lu b">entrypoint</code>(这是启动容器时执行的命令)。默认的<code class="eh md me mf lu b">entrypoint</code>在Dockerfile文件中定义，如下所示:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="bb8d" class="ka kb hu lu b fv ly lz l ma mb">ENTRYPOINT python ./mypackage/run.py</span></pre><p id="0c51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，由于docker compose文件中的<code class="eh md me mf lu b">entrypoint</code>语句，这个入口点现在将被以<code class="eh md me mf lu b">watchmedo</code>开头的命令替换。<code class="eh md me mf lu b">watchmedo</code>命令是我们包含在<code class="eh md me mf lu b">requirements.txt</code>文件中的<a class="ae lo" href="https://pypi.python.org/pypi/watchdog" rel="noopener ugc nofollow" target="_blank">看门狗</a>包的一部分。它监控给定目录中具有所提供模式的文件(在本例中是所有的<code class="eh md me mf lu b">*.py</code>文件)，如果其中任何一个文件被修改，<code class="eh md me mf lu b">watchmedo</code>将重启运行进程并执行所提供的命令(在本例中是<code class="eh md me mf lu b">python ./mypackage/run.py</code>)。</p><p id="69be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一行，结合我们前面提到的卷映射，意味着对我们主机上的<code class="eh md me mf lu b">./python</code>目录中的任何Python文件的每次修改都将重启我们的应用程序。如果你打开任何Python文件并修改它，你会看到你所做的每一个改变都会立即反映在运行的容器中。</p><p id="270b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可能只有我，但这是我见过的最酷的事情之一。</p><p id="64fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:请记住，如果添加新的依赖项，您确实需要重新构建映像。</p><h2 id="9a2c" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">开发配置——Python单元测试和测试驱动开发</h2><p id="40d9" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">让我们来看看Python单元测试服务的docker-compose.dev.yml文件，名为<code class="eh md me mf lu b">python-tests</code>:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="6974" class="ka kb hu lu b fv ly lz l ma mb">python-tests:<br/>  image: registry.gitlab.com/mycompany/myproject/python:dev<br/>  entrypoint: watchmedo auto-restart --recursive --pattern="*.py" --directory="." pytest<br/>  depends_on:<br/>   - python</span></pre><p id="ca8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有趣的是，该图像与Python服务的图像相同。这意味着它将使用与Python服务完全相同的环境；该映像将只构建一次。</p><p id="6771" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh md me mf lu b">depends_on</code>语句建议docker-compose在运行<code class="eh md me mf lu b">python-tests</code>服务之前构建<code class="eh md me mf lu b">python</code>服务。</p><p id="51b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是最重要的一行还是<code class="eh md me mf lu b">entrypoint</code>。我们在这里做的事情与我们在常规Python服务中做的事情非常相似，但是我们现在让<code class="eh md me mf lu b">watchemedo</code>在每次修改时执行<code class="eh md me mf lu b">pytest</code>(如果您还记得，这也包含在<code class="eh md me mf lu b">requirements.txt</code>文件中)。</p><p id="05ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样做的结果是，每次代码变更<em class="mg">都会自动执行<em class="mg">py test可以找到的所有测试</em>，给你<em class="mg">关于测试状态的即时反馈</em>。</em></p><p id="4d31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这使得用Docker进行测试驱动开发变得微不足道。</p><h2 id="9597" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">开发配置— Java</h2><p id="4c3a" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">Java是一种编译语言，使用起来稍微复杂一点。幸运的是，Maven在很大程度上帮助了我们。</p><p id="704a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先要注意的是docker文件中的下面一行:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="e932" class="ka kb hu lu b fv ly lz l ma mb">RUN apt-get update &amp;&amp; apt-get install entr -y</span></pre><p id="4b0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里发生的是安装了命令行工具<code class="eh md me mf lu b"><a class="ae lo" href="http://entrproject.org/" rel="noopener ugc nofollow" target="_blank">entr</a></code>。它的功能与我们在Python中使用的watchdog的<code class="eh md me mf lu b">watchmedo</code>命令非常相似，但优点是它不需要Python就可以工作；这只是一个通用的Unix实用程序。事实上，我们也可以在Python服务中使用它，但是，我们没有这样做。</p><p id="950a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以在<code class="eh md me mf lu b">docker-compose.dev.yml</code>文件和<code class="eh md me mf lu b">java</code>服务的入口点中看到它的作用:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="140b" class="ka kb hu lu b fv ly lz l ma mb">entrypoint: sh -c 'find src/ | entr mvn clean compile exec:java --batch-mode --quiet'</span></pre><p id="ac8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这表示‘无论何时目录<code class="eh md me mf lu b">src/</code>中的任何文件发生变化，请让maven清理、编译然后执行Java项目’。</p><p id="ff4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些都不是现成的；Maven首先需要在<code class="eh md me mf lu b"> pom.xml</code>文件中进行一些相当广泛的配置。更具体地说，我们需要几个插件，即<a class="ae lo" href="https://maven.apache.org/plugins/maven-compiler-plugin/" rel="noopener ugc nofollow" target="_blank"> Maven编译器插件</a>、执行容器默认入口点的<a class="ae lo" href="https://maven.apache.org/plugins/maven-jar-plugin/" rel="noopener ugc nofollow" target="_blank"> Maven JAR插件</a>和在开发期间运行的<a class="ae lo" href="http://www.mojohaus.org/exec-maven-plugin/usage.html" rel="noopener ugc nofollow" target="_blank"> Exec Maven插件</a>(使用Java目标)。</p><p id="fd94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦这些都配置好了，再加上构成有效的<code class="eh md me mf lu b">pom.xml</code>文件的其他内容，结果就和Python服务一样了(实际上还稍微好一点):对Java源文件的每一次更改都会重启应用程序，编译Java文件，安装新的依赖项(谢谢Maven！)并重新启动应用程序。</p><h2 id="9620" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">开发配置—PostgresDB</h2><p id="4045" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">让我们再次看看docker-compose.dev.yml文件中的相关行:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="12e7" class="ka kb hu lu b fv ly lz l ma mb">postgres:<br/>  image: postgres:9.6<br/>  environment:<br/>    - POSTGRES_USER=user<br/>    - POSTGRES_PASSWORD=password<br/>    - POSTGRES_DB=myproject<br/>  volumes:<br/>    - /data/myproject/postgres:/var/lib/postgresql/data</span><span id="51c4" class="ka kb hu lu b fv mc lz l ma mb">pgadminer:<br/>  image: clue/adminer<br/>  ports: <br/>    - "99:80"</span></pre><p id="3f95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh md me mf lu b">postgres</code>服务使用标准的Postgres映像，这是默认配置。环境变量通过定义一个名为“myproject”的数据库来配置Postgres，用户名为“user”，密码为“password”。</p><p id="6650" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Python和Java服务也定义了这些环境变量。他们应该在应用程序代码中使用这些来连接数据库。在<code class="eh md me mf lu b">docker-compose.dev.yml</code>文件中，这些值都是硬编码的。然而，在构建生产容器时，生产值应该作为环境变量从外部源传入。这允许与适当的秘密管理工具链集成。</p><p id="0597" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为<code class="eh md me mf lu b">postgres</code>服务的最后指令，定义了一个<code class="eh md me mf lu b">volume</code>。这会将Postgres数据库数据映射到主机上的某个位置。虽然不是绝对必要的，但是如果容器由于某种原因被删除，这对于持久化Postgres的数据是有用的。</p><p id="9983" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们还定义了<code class="eh md me mf lu b">pgadminer</code>服务，它启动<a class="ae lo" href="https://www.adminer.org/" rel="noopener ugc nofollow" target="_blank"> adminer </a>，这是一个通过web界面进行数据库管理的有用工具。有了这个配置，就可以通过主机上的端口99访问它(所以<a class="ae lo" href="http://127.0.0.1:99)." rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:99)。</a>作为主机名，您应该使用Postgres服务的名称，在本例中为<code class="eh md me mf lu b">postgres</code>，因为它们共享同一个docker网络，因为它们是在同一个Docker合成文件中定义的，因此DNS会自动为您执行。</p><h2 id="ed0d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">开发配置—构建和执行</h2><p id="299d" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">现在让我们兜一圈。</p><p id="0a21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们必须为开发构建所有的容器。从命令行:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="7f99" class="ka kb hu lu b fv ly lz l ma mb">docker-compose -f docker-compose.common.yml -f docker-compose.dev.yml build</span></pre><p id="1b62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并启动所有服务:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="e971" class="ka kb hu lu b fv ly lz l ma mb">docker-compose -f docker-compose.common.yml -f docker-compose.dev.yml up</span></pre><p id="f493" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于需要键入的内容很多，而且我喜欢自文档化的入口点，所以我倾向于在Makefile中定义这些和其他基本的项目范围的命令:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="21d3" class="ka kb hu lu b fv ly lz l ma mb">dev-build:<br/>  docker-compose -f docker-compose.common.yml -f docker-compose.dev.yml build --no-cache</span><span id="6e5b" class="ka kb hu lu b fv mc lz l ma mb">dev:<br/>  docker-compose -f docker-compose.common.yml -f docker-compose.dev.yml up</span></pre><p id="e2b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在某些时候，您可能想要运行Python单元测试，而不需要启动所有的服务。因此，我们将python-tests.sh定义如下:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="dd39" class="ka kb hu lu b fv ly lz l ma mb">#!/bin/bash<br/>docker-compose -f docker-compose.common.yml -f docker-compose.dev.yml run --rm --entrypoint pytest python $*</span></pre><p id="edb3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将执行<code class="eh md me mf lu b">python</code>容器中的<code class="eh md me mf lu b">pytest</code>，执行所有的测试。提供给脚本的任何参数都将直接传递给容器中的pytest命令(多亏了<code class="eh md me mf lu b">$*</code>)，允许您像正常运行pytest一样运行它。最后，我们用以下代码扩展Makefile:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="b5f5" class="ka kb hu lu b fv ly lz l ma mb">test:<br/> ./python-tests.sh</span></pre><h1 id="362d" class="mh kb hu bd kc mi mj mk kg ml mm mn kk mo mp mq kn mr ms mt kq mu mv mw kt mx dt translated">生产配置</h1><p id="a729" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">快到了。我们来看看docker-compose.prod.yml:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="7bee" class="ka kb hu lu b fv ly lz l ma mb">version: '2'</span><span id="c339" class="ka kb hu lu b fv mc lz l ma mb">services:<br/>  python:<br/>    image: $IMAGE/python:$TAG<br/>    restart: always</span><span id="d18d" class="ka kb hu lu b fv mc lz l ma mb">  java:<br/>    image: $IMAGE/java:$TAG<br/>    restart: always</span></pre><p id="57e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是事情的全部。大部分配置应该在docker-compose.common.yml中，命令和入口点都在docker文件中。您确实需要传入还没有值的环境变量(在docker-compose.common.yml和这个文件中定义),但是这应该由您的构建脚本来处理。</p><p id="bade" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，我们就可以为生产构建服务了。让我们就这么做吧，用Gitlab的CI服务来构建它。让我们来看看。gitlab-ci.yml文件。它非常简单，允许优化，但是它完成了工作。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="bd1c" class="ka kb hu lu b fv ly lz l ma mb">stages:<br/>  - build<br/>  - test</span><span id="c12f" class="ka kb hu lu b fv mc lz l ma mb">variables:<br/>  TAG: $CI_BUILD_REF<br/>  IMAGE: $CI_REGISTRY_IMAGE</span><span id="06b4" class="ka kb hu lu b fv mc lz l ma mb">services:<br/>  - docker:dind</span><span id="3a26" class="ka kb hu lu b fv mc lz l ma mb">image: docker</span><span id="f5ad" class="ka kb hu lu b fv mc lz l ma mb">before_script:<br/>  - apk add --update py-pip<br/>  - pip install docker-compose<br/>  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY</span><span id="8091" class="ka kb hu lu b fv mc lz l ma mb">build:<br/>  stage: build<br/>  script:<br/>    - docker-compose -f docker-compose.common.yml -f docker-compose.prod.yml build<br/>    - docker-compose -f docker-compose.common.yml -f docker-compose.prod.yml push</span><span id="b3ce" class="ka kb hu lu b fv mc lz l ma mb">test-python:<br/>  stage: test<br/>  script:<br/>    - docker-compose -f docker-compose.common.yml -f docker-compose.prod.yml pull python<br/>    - docker-compose -f docker-compose.common.yml -f docker-compose.prod.yml run --rm --entrypoint pytest python</span></pre><p id="d83e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一些Gitlab CI特有的东西，比如<code class="eh md me mf lu b">docker:dind</code>服务的定义和运行构建的映像，这两者都需要docker可用。此外，<code class="eh md me mf lu b">before_script</code>部分很重要，因为它安装了<code class="eh md me mf lu b">docker-compose</code>(因为我找不到最新版本的好图片)。您还会注意到，默认情况下，<code class="eh md me mf lu b">$TAG</code>和<code class="eh md me mf lu b">$IMAGE</code>变量是使用Gitlab的CI runner 在<a class="ae lo" href="https://docs.gitlab.com/ee/ci/variables/" rel="noopener ugc nofollow" target="_blank">中传递的环境变量来设置的。</a></p><p id="d874" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，Gitlab有一个概念，即<a class="ae lo" href="https://docs.gitlab.com/ee/ci/variables/#secret-variables" rel="noopener ugc nofollow" target="_blank">秘密变量</a>，它们作为环境变量在您的构建中传递。只需设置正确的值，然后<code class="eh md me mf lu b">docker-compose</code>就会选择它们。如果您使用另一个CI环境，我敢肯定它也有这方面的一些机制。如果您喜欢稍微低一点的技术，您当然也可以编写自己的部署脚本。</p><h1 id="b752" class="mh kb hu bd kc mi mj mk kg ml mm mn kk mo mp mq kn mr ms mt kq mu mv mw kt mx dt translated">包扎</h1><p id="bab1" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">所以你有它；一个高效但并不复杂的设置来编排和开发Docker中的大多数项目。</p><p id="739a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你感兴趣，我还写了一篇关于在Gitlab 上用docker-compose设置简单部署的<a class="ae lo" rel="noopener" href="/@Empanado/simple-continuous-deployment-with-docker-compose-docker-machine-and-gitlab-ci-9047765322e1">文章。这将把您从基于Gitlab CI的开发环境直接带到docker-compose的持续部署。</a></p></div></div>    
</body>
</html>