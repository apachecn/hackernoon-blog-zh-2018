<html>
<head>
<title>MVVM + RxSwift on iOS part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS上的MVVM + RxSwift第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mvvm-rxswift-on-ios-part-1-69608b7ed5cd?source=collection_archive---------1-----------------------#2018-11-09">https://medium.com/hackernoon/mvvm-rxswift-on-ios-part-1-69608b7ed5cd?source=collection_archive---------1-----------------------#2018-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3ad600943df000d64d5c2ff25b99d812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBFqJmaLduJLbjYleVVOqQ.jpeg"/></div></div></figure><p id="1b77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将介绍iOS编程中的MVVM设计模式，当然还有RxSwift。本文分为两部分。在第1部分简要介绍了RxSwift的设计模式和基础知识，在<a class="ae ka" href="https://link.medium.com/3YSCtHCUqV" rel="noopener">第2部分</a>中，我们有一个使用RxSwift的MVVM的示例项目。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="d691" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated"><strong class="ak">设计模式</strong>:</h1><p id="bde2" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt ll translated"><span class="l lm ln lo bm lp lq lr ls lt di">在</span>首先，最好解释一下为什么我们要使用设计模式？简而言之:为了避免我们的代码变成意大利面条🍝当然这不是唯一的原因。原因之一是可测试性。有很多设计模式，我们可以指出一些流行的模式，如<strong class="je hv"> MVC </strong>、<strong class="je hv"> MVVM </strong>、<strong class="je hv"> MVP </strong>和<strong class="je hv"> VIPER </strong>。NSLondon幻灯片中有一个很好的图片，它将设计模式与分布、可测试性和易用性进行了比较。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lu"><img src="../Images/1054b4ab3b12d9186cbaec1b8cc8817b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRnW_Qb2Q0rPTjbqQ96dhQ.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Compare of design patterns ( from NSLondon )</figcaption></figure><p id="bbd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些设计模式都有自己的优点和缺点，但最终，它们都使我们的代码更干净、更简单、更易读。这篇文章的重点是<strong class="je hv"> MVVM，</strong>我希望你在<a class="ae ka" href="https://link.medium.com/3YSCtHCUqV" rel="noopener">第二部</a>结束时明白原因。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="e492" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，让我们简要地看一下MVC，然后我们继续讨论MVVM</p><h2 id="1061" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated">MVC:</h2><p id="88a0" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如果你在iOS中做过一段时间的编码，你大概对<strong class="je hv"> MVC </strong>很熟悉(苹果建议用MVC进行iOS编程)。该模式由<strong class="je hv">模型</strong>、<strong class="je hv">视图</strong>和<strong class="je hv">控制器</strong>组成，其中控制器负责连接模型和视图。理论上看起来视图和控制器是两回事但是在iOS世界中，很不幸，这两者变成了一件事(大部分)。当然，在小项目中，一切似乎都井井有条，但是一旦你的项目变得更大，控制器几乎承担了大部分责任(也被称为大规模视图控制器:D)，这导致你的代码变得一团糟，但是如果你能以正确的方式编写MVC并尽可能多地划分你的控制器，问题将会得到解决(大部分)。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/1342ea88eb0edfe7d32ff8cb19d074b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*la8KCs0AKSzVGShoLQo2oQ.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">MVC from apple docs</figcaption></figure><h2 id="ace5" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated">MVVM:</h2><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/f7a65c3e328911165221b936dce00c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VoIppMaaG6ZwRuE6zpctlg.jpeg"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">picture from github</figcaption></figure><p id="d971" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">井<strong class="je hv"> MVVM </strong>代表<strong class="je hv">模型</strong>、<strong class="je hv">视图</strong>、<strong class="je hv">视图模型</strong>，其中控制器、视图和动画发生在<strong class="je hv">视图</strong>中，业务逻辑、api调用发生在<strong class="je hv">视图模型中。</strong>事实上，这一层是模型和视图之间的接口，它将根据需要向<strong class="je hv">视图</strong>提供数据。有一点是，如果您在ViewModel文件中看到以下代码，您可能在某个地方犯了错误:</p><pre class="lv lw lx ly fq mt mu mv mw aw mx dt"><span id="c9c2" class="md kj hu mu b fv my mz l na nb">import UIKit</span></pre><p id="cd2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为ViewModel不应该知道视图中的任何内容，所以在第二部分中，我们将通过一个精确的例子来分析本文。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="4910" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">RxSwift:</h1><p id="949e" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">MVVM的一个特性是数据和视图的绑定，这使得它与RxSwift的结合非常愉快。当然，你可以用delegate、KVO或闭包来实现这一点，但是RxSwift的一个特性是，如果你用一种语言学习它，你也可以在其他语言上重用它，因为Rx的basic在它所支持的语言中是相同的(你可以在这里找到语言列表<a class="ae ka" href="http://reactivex.io/languages.html" rel="noopener ugc nofollow" target="_blank"/>)。现在，在这一部分，我们将解释RxSwift的基础知识，这也是Rx world的基础知识。然后在第二部分，我们将与RxSwift在MVVM开展一个项目。</p><h2 id="11bf" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated">反应式编程:</h2><p id="4f17" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">RxSwift基于反应式编程，这意味着什么呢？</p><pre class="lv lw lx ly fq mt mu mv mw aw mx dt"><span id="eccd" class="md kj hu mu b fv my mz l na nb">In computing, reactive programming is a programming paradigm oriented around data flows and the propagation of change. This means that it should be possible to express static or dynamic data flows with ease in the programming languages used, and that the underlying execution model will automatically propagate changes through the data flow. — Wikipedia</span></pre><p id="5828" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很可能你读完这一段后什么都不明白。我们也许用下面的例子来理解它会更好:</p><p id="548d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设你有三个变量(a，b，c ),比如:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/0fd798257ca67bd7e65a4d340dc25485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*itRGsvQIT3NE7ceswB7_iw.png"/></div></figure><p id="eeac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果我们将<code class="eh nd ne nf mu b">a</code>从1改为2，并打印<code class="eh nd ne nf mu b">c</code>,它的值仍然是3。但是在无功世界里事情是不同的，<code class="eh nd ne nf mu b">c</code>值取决于<code class="eh nd ne nf mu b">a</code>和<code class="eh nd ne nf mu b">b</code>，这意味着如果你把<code class="eh nd ne nf mu b">a</code>从1变到2 <code class="eh nd ne nf mu b">c</code>值会自动地从3变到4，而不需要你自己去改变。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/84d92d6f435e53b800e50754d3fd404b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*JLHnWaaUf5doo76E6BIXeA.png"/></div></figure><p id="350d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们开始RxSwift基础知识:</p><p id="a803" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在RxSwift(当然还有Rx)世界中，一切都是事件流(包括UI事件、网络请求……)现在请记住这一点，我将用现实生活中的例子来解释:</p><p id="d0b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你的手机是一个<strong class="je hv">可观察的</strong>，它产生事件，例如响铃、推送通知……这让你注意，事实上你<strong class="je hv">订阅了</strong>你的手机，并决定如何处理这些事件，例如你有时会忽略一些通知或回复一些通知……(事实上这些事件是<strong class="je hv">信号</strong>，而你是一个<strong class="je hv">观察者</strong>并做出决定)</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/8a27ffd1cd21bad5ae308f34b6001cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/1*iq8fm2j0k2b5xlpQorNiuA.gif"/></div></figure><p id="9fab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们看看代码:</p><h2 id="bb33" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated">可观察对象和观察者(订户):</h2><p id="4fb3" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">在Rx世界中，一些变量是<strong class="je hv">可观察的</strong>，另一些是<strong class="je hv">观察者(或订户)。</strong></p><p id="8b4a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此<strong class="je hv">可观察的</strong>是通用的，如果它符合ObservableType协议，你可以使它成为你想要的任何类型的可观察的。</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/c3462fda33443e62adb3193b36d42d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_7m7BB05qfWrK4opp5xDA.png"/></div></div></figure><p id="d094" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们定义一些可观察到的现象:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nj"><img src="../Images/6789b767dfddbfcccae72661c5da9c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Lzu5Qp3f0j8PTyJ76QM3Q.png"/></div></div></figure><p id="4170" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面例子的第一行，我们有字符串的可观察值，在第二行，我们有Int的可观察值，最后我们有字典的可观察值，现在我们应该<strong class="je hv">订阅</strong>我们的可观察值，这样我们就可以从发出的信号中读取</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/f9715089efa82ed3a5ca108882e847b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*aV60Aj4zGQ8O4jkSXE-BWQ.png"/></div></figure><p id="fd50" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会问输出中的<code class="eh nd ne nf mu b">next</code>和<code class="eh nd ne nf mu b">completed</code>是什么，为什么“hello world”没有打印好。我必须说，这可能是Observables最重要的特征:</p><p id="99ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上每个可观测量都是<strong class="je hv">序列</strong>，它与<a class="ae ka" href="https://developer.apple.com/documentation/swift/sequence" rel="noopener ugc nofollow" target="_blank">快速序列</a>的主要区别在于它的值可以异步。(如果你不明白这两行并不重要，希望你能通过下面的描述理解)如果我们想用图像来说:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/08c7aef9081fd3960368cfe4cddd44ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*sXgodZ2an2tnAixXOsEoWg.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">sequence of events</figcaption></figure><p id="6a1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的图像中，我们有三个可观察的对象，第一个是Int类型，并及时发出1到6的6个值，然后它就完成了。在第二行中，我们观察到字符串，并及时发出“a，b，c，d，e，f ”,然后出现了一些错误，它已经完成。最后，我们有了可观察到的姿态，但它还没有完成，还在继续。</p><p id="01f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些显示可观察事件的图像被称为大理石图。欲了解更多信息，您可以访问<a class="ae ka" href="http://rxmarbles.com/" rel="noopener ugc nofollow" target="_blank">网站</a>或从<a class="ae ka" href="https://itunes.apple.com/us/app/rxmarbles/id1087272442?ls=1&amp;mt=8" rel="noopener ugc nofollow" target="_blank">应用商店</a>下载该应用。(这也是<a class="ae ka" href="https://github.com/RxSwiftCommunity/RxMarbles" rel="noopener ugc nofollow" target="_blank">开源</a>👍😎)</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="0714" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Rx世界中，每个可观察对象在其持续时间内发出0到…个事件(上例),这些事件由三个可能值组成:</p><ol class=""><li id="f1e7" class="nm nn hu je b jf jg jj jk jn no jr np jv nq jz nr ns nt nu dt translated"><strong class="je hv">。下一个</strong>(值:T)</li></ol><p id="b17d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.<strong class="je hv">。错误</strong>(错误:错误)</p><p id="60a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3.<strong class="je hv">。已完成</strong></p><p id="fc9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当Observable增加一个/多个值时，调用<code class="eh nd ne nf mu b">next</code>事件，并通过相关的值属性(上面示例中的1到6个数字，a到f和抽头)将一个/多个值传递给订户(观察者)。</p><p id="9636" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果可观察对象面临错误❌，则发出错误事件，可观察对象结束。(在发出上述示例中的<code class="eh nd ne nf mu b">f</code>后)</p><p id="ea4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果观察完成。发出完成的事件(在上述示例中发出6之后)</p><p id="71df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们想取消订阅并取消订阅一个可观察对象，我们可以调用<strong class="je hv"> <em class="nv"> dispose </em> </strong>方法，或者如果你想在你的视图定义时调用这个方法，你应该使用<strong class="je hv"> <em class="nv"> DisposeBag </em> </strong>类型创建一个变量，当你的类被初始化时，这个变量为你工作。<strong class="je hv"> <em class="nv">我必须说如果你不记得这个你的订户会让内存泄露</em> </strong> ☠️💀<strong class="je hv"> <em class="nv">。</em> </strong>例如，观察值应该这样订阅:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/0e5b8f1a7e4217aa3264f936ae8b29bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFPgU5V4UW8A5yNf32mssA.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">observable with disposeBag</figcaption></figure></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="a687" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们看看将Rx与函数式编程结合起来的好处。假设你有一个Int的observable，你订阅了它，现在observable会给你一堆Int，你可以对observable发出的信号做很多改变，例如:</p><h2 id="f128" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated"><strong class="ak">地图:</strong></h2><p id="0f5c" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">为了在信号到达其订户之前改变信号，您可以使用映射方法，例如，我们有Int的observable，它发出3个数字2，3，4，现在我们希望数字在到达其订户之前乘以10，我们可以使用以下代码来实现这一点:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nx"><img src="../Images/0634548e9ce3cff98c3de197491ea274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fba7HHwf1BBKRiM8ka6WjQ.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">map marble</figcaption></figure><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff ny"><img src="../Images/65f47419ce0afe74073002412ffcac9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*EI9Th1KK6ZzzJLef3nCfzA.png"/></div></figure><h2 id="eef5" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated">过滤器:</h2><p id="19b1" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">您可能希望在联系订户之前过滤一些值，例如，在上面的示例中，您希望号码大于25:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div class="fe ff nz"><img src="../Images/71be87a913769109a4e3e6ee419b470a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*bY-E-8wc2aAyC9LcVvFQBQ.png"/></div></figure><h2 id="6822" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated">平面图:</h2><p id="74ca" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">假设你有两个可观测量，你想把它们合并成一个可观测量:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oa"><img src="../Images/b9fc2b194dcf00f05149163cc60b7015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIhBMXe5aD1WFKeIbUTnaQ.png"/></div></div></figure><p id="4b99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，可观察对象A和可观察对象B被组合并成为新的可观察对象:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ob"><img src="../Images/f6f01b8437f67b7c1250704b08187500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzEoC5ds45mcvgux7fm_UQ.png"/></div></div></figure><h2 id="0ed8" class="md kj hu bd kk me mf mg ko mh mi mj ks jn mk ml kw jr mm mn la jv mo mp le mq dt translated"><strong class="ak">区分时间变化或去抖:</strong></h2><p id="7954" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">这两种方法是搜索中最有用的方法之一。例如，用户想要搜索一个单词，当用户键入每个字符时，您可能会调用search api。好吧，如果用户输入得很快，你会向服务器发出许多不必要的请求。实现这一点的正确方法是当用户停止输入时调用搜索api。要解决这个问题，您可以使用去抖功能:</p><figure class="lv lw lx ly fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oc"><img src="../Images/ff04f0c715f1a74fb9ff6579245e5401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnjfihjNN8ImbJN9CrWGGw.png"/></div></div></figure><p id="8867" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上述示例中，如果用户名文本字段在0.3秒内发生变化，则这些信号不会到达订户，因此不会调用搜索方法，只有当用户在0.3秒后停止时，订户才会收到信号并调用搜索方法。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="f85a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DistinctUntilChanged函数对变化很敏感，这意味着如果两个信号获得相同的信号，直到信号没有变化，它将不会被发送到订阅者。</p><p id="3e6f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rx世界比你能想到的要大得多，我只是讲了几个基本概念，我认为在文章的下一部分会用到，这是一个与RxSwift的真实项目。</p><p id="92cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来自<a class="ae ka" href="https://store.raywenderlich.com/products/rxswift" rel="noopener ugc nofollow" target="_blank"> raywenderlich </a>的RxSwift很好地描述了来自0的RxSwift，我强烈推荐阅读。</p><p id="ff1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能不会仅从一篇文章中注意到RxSwift，因为它是Swift的高级概念之一，您可能需要每天阅读不同的文章才能找到答案。在<a class="ae ka" href="https://github.com/mohammadZ74/handsomeIOS" rel="noopener ugc nofollow" target="_blank">这个链接</a>中你可以看到他的RxSwift版块的几篇好文章。</p><p id="4f57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望在Rx引入MVVM真实项目的文章的下一部分，你会理解RxSwift的概念，因为用真实的例子会更容易理解。</p><p id="cff4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的推特账号是<a class="ae ka" href="https://twitter.com/Mohammad_z74" rel="noopener ugc nofollow" target="_blank"> Mohammad_z74 </a>，我的邮箱是mohammad_z74@icloud.com✌️</p></div></div>    
</body>
</html>