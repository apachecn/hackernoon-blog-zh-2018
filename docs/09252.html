<html>
<head>
<title>C++ Coroutine TS — It’s about inversion of control!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++协程TS——它是关于控制反转的！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/c-coroutine-ts-its-about-inversion-of-control-d1588c4c4c31?source=collection_archive---------2-----------------------#2018-11-09">https://medium.com/hackernoon/c-coroutine-ts-its-about-inversion-of-control-d1588c4c4c31?source=collection_archive---------2-----------------------#2018-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/44206b5402ac9606ad5ffe99c14ca37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R0g5uVEYkznCQn34"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">“person flip skiing above snow during daytime” by <a class="ae ih" href="https://unsplash.com/@joerga?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jörg Angeli</a> on <a class="ae ih" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="cc7f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">许多人看到协程TS时会想，这有什么好大惊小怪的？</p><p id="b971" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本文给出了一个激励性的例子，在这个例子中，惰性序列使您能够<em class="kf">分离您的关注点</em>，并且在不增加复杂性的情况下最大化代码重用。</p><h1 id="3caa" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated"><strong class="ak">举例:近似黄金比例</strong></h1><p id="60d3" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">每个学数学的学生都知道如何通过斐波那契数列逼近黄金分割率:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="240d" class="ls kh ik lo b fv lt lu l lv lw">fib(n+1) / fib(n) -&gt; φ = 1.6180… </span></pre><p id="ca30" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者使用C++…</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="75cf" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">函数<code class="eh lz ma mb lo b">golden</code>计算给定近似值的黄金比例。在每一次迭代中，我们都更接近黄金比例，一旦我们足够接近，函数就会返回。</p><p id="2abc" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这很简单，但是如果我们对<code class="eh lz ma mb lo b">golden</code>有一些额外的用例呢？</p><ul class=""><li id="c5b2" class="mc md ik jj b jk jl jo jp js me jw mf ka mg ke mh mi mj mk dt translated">也许我们想限制最大迭代次数</li><li id="c99a" class="mc md ik jj b jk ml jo mm js mn jw mo ka mp ke mh mi mj mk dt translated">或者我们想在每次迭代后打印</li><li id="d7f7" class="mc md ik jj b jk ml jo mm js mn jw mo ka mp ke mh mi mj mk dt translated">或者我们想返回一个<code class="eh lz ma mb lo b">{ fib(n+1), fib(n) }</code>的元组</li><li id="615a" class="mc md ik jj b jk ml jo mm js mn jw mo ka mp ke mh mi mj mk dt translated">或者可能有一个我们还没有想到的用例，但是有人可能已经想到了</li></ul><p id="15b7" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了满足所有这些要求，我们需要修改算法并提供一些定制点。我们可以添加一组配置选项，或者使用通用功能:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="a9a4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以看到，当我们将其一般化以处理更多用例时，这个函数的复杂性增加了。这个版本的<code class="eh lz ma mb lo b">golden</code>可读性比原版差很多！</p><p id="77fe" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一种方法是为每个特定的用例编写这个函数的变体。以下是打印每个迭代的版本:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="d24e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这应该是可读的，但是现在我们必须维护多个函数！</p><blockquote class="mq"><p id="e132" class="mr ms ik bd mt mu mv mw mx my mz ke ek translated">我们如何实现可重用性和简单性？</p></blockquote><p id="a1d5" class="pw-post-body-paragraph jh ji ik jj b jk na jm jn jo nb jq jr js nc ju jv jw nd jy jz ka ne kc kd ke hn dt translated">问题来了。模板化的版本很灵活，但并不简单。函数变量很简单，但不灵活。我们如何实现可重用性和简单性？</p><h2 id="cae9" class="ls kh ik bd ki nf ng nh km ni nj nk kq js nl nm ku jw nn no ky ka np nq lc nr dt translated">我们为什么要在它们之间做出选择呢？</h2><p id="6cc7" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">这个问题是由算法控制序列的<em class="kf">迭代和序列</em>的<em class="kf">表示引起的。这些问题应该分开。</em></p><p id="8379" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，我们需要什么样的抽象才能两全其美呢？</p><h1 id="407c" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">经由协程TS的控制反转</h1><p id="a916" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">协程TS使您能够定义惰性序列。惰性序列只是一组有序的值，其中每个值只在被请求时才被计算。</p><p id="9206" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您可能会认为惰性序列是一个具有两个属性的容器:</p><ul class=""><li id="8d43" class="mc md ik jj b jk jl jo jp js me jw mf ka mg ke mh mi mj mk dt translated"><code class="eh lz ma mb lo b">bool hasNext()</code>这个序列里还有别的值吗？</li><li id="8f00" class="mc md ik jj b jk ml jo mm js mn jw mo ka mp ke mh mi mj mk dt translated"><code class="eh lz ma mb lo b">T takeNext()</code>返回序列中的下一个值，并前进1。</li></ul><p id="afb5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们能够分离计算和表示，同时保持对序列的完全控制。</p><p id="08d6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">协程TS是相当低级的，所以下面的例子是使用我们的<a class="ae ih" href="https://github.com/loopperfect/conduit" rel="noopener ugc nofollow" target="_blank">管道</a>库构建的。这个库为我们提供了各种原语，我们可以用它们来创建惰性序列。我们不会在这里深入讨论实现细节(GitHub 上有完整的<a class="ae ih" href="https://github.com/LoopPerfect/conduit" rel="noopener ugc nofollow" target="_blank">源代码)，而是看看所有这些是如何有用的！</a></p><p id="0480" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好的。因此，使用<a class="ae ih" href="https://github.com/loopperfect/conduit" rel="noopener ugc nofollow" target="_blank">管道</a>我们可以为斐波那契定义一个惰性序列:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="cb93" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于黄金比例是斐波那契数的一种变换，我们可以使用<code class="eh lz ma mb lo b">scan</code>来计算它们:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="e53a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们使用该序列打印前10个斐波那契比率:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="0ee1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们有了一个iterable，我们可以像以前一样通过计算一个delta来控制迭代:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="0d61" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它的美妙之处在于，我们可以只取序列的一个定义，但在多个地方使用它。与我们之前看到的模板化解决方案不同，代码仍然紧密地映射到数学定义。</p><p id="a785" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想知道如何使用协程TS，<br/>实现懒惰序列，请查看我们的<a class="ae ih" href="https://github.com/loopperfect/conduit" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><h1 id="145b" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结论</h1><p id="f111" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">协程TS允许我们将控制权交还给算法的消费者。这使得实现者不必向最终用户提供定制挂钩来修改算法的行为。</p><h1 id="1035" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">既然你在这里…</h1><p id="a66b" class="pw-post-body-paragraph jh ji ik jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我们最近发布了<a class="ae ih" href="https://buildinfer.loopperfect.com/" rel="noopener ugc nofollow" target="_blank"> BuildInfer </a>，这是一款优化C/C++构建脚本的新工具。<a class="ae ih" href="https://buildinfer.loopperfect.com/" rel="noopener ugc nofollow" target="_blank">看一看</a>！</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/5b29e7d89e98091a3ce03d7088438ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pkwieX1RSK5S0LXbFyaEJg.png"/></div></figure><h1 id="55ce" class="kg kh ik bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">您可能也会对…感兴趣</h1><div class="ht hu fm fo hv nt"><a href="https://hackernoon.com/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab ej"><div class="nv ab nw cl cj nx"><h2 class="bd il fv z el ny eo ep nz er et ij dt translated">C++中的错误处理或:为什么你应该使用这两者之一来支持异常和错误代码</h2><div class="oa l"><h3 class="bd b fv z el ny eo ep nz er et ek translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="ob l"><p class="bd b gc z el ny eo ep nz er et ek translated">hackernoon.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ib nt"/></div></div></a></div><div class="ht hu fm fo hv nt"><a href="https://hackernoon.com/value-ptr-the-missing-c-smart-pointer-1f515664153e" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab ej"><div class="nv ab nw cl cj nx"><h2 class="bd il fv z el ny eo ep nz er et ij dt translated">value_ptr —丢失的C++智能指针</h2><div class="oa l"><h3 class="bd b fv z el ny eo ep nz er et ek translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="ob l"><p class="bd b gc z el ny eo ep nz er et ek translated">hackernoon.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh ib nt"/></div></div></a></div></div></div>    
</body>
</html>