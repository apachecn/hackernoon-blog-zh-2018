<html>
<head>
<title>Scaling Node.js Socket Server with Nginx and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx和Redis扩展Node.js套接字服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scaling-node-js-socket-server-with-nginx-and-redis-d19bf5c07fa8?source=collection_archive---------7-----------------------#2018-11-09">https://medium.com/hackernoon/scaling-node-js-socket-server-with-nginx-and-redis-d19bf5c07fa8?source=collection_archive---------7-----------------------#2018-11-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/467c23c47ec8c4539ae09e1723e0a652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sxy3Paafj6f8S6P_.jpg"/></div></div></figure><p id="0dcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">后端开发中最有趣的话题之一是服务器的伸缩和分布。</p><p id="9779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多方法可以扩展你的应用程序，处理大量的请求和连接。在本文中，我们将解释Node.js应用程序最流行的扩展方式之一，特别是<strong class="je hv">套接字连接</strong>。</p><p id="164d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您有一个每秒接收300个请求的节点应用程序。它工作得很好，但是有一天请求数会增加10到100倍。那么，你就有大问题了。节点应用程序并不意味着每秒处理30k个请求(在某些情况下，它们可以，但这仅仅是由于CPU和RAM)。</p><p id="b715" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们所知，Node是一个单线程，并不占用你的机器资源(CPU，RAM)。反正会无效。</p><p id="3ce4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您无法保证您的应用程序不会崩溃，或者您无法在不停止服务器的情况下更新服务器。在任何情况下，如果您只有一个实例，那么您的应用程序很可能会经历一些停机时间。</p><p id="5b00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何减少停机时间？如何才能有效利用RAM和CPU？我们如何在不停止所有系统的情况下更新应用程序？</p><h1 id="69fe" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">NGINX负载平衡器</h1><p id="ad4e" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">其中一个解决方案是<strong class="je hv">负载平衡器</strong>。在某些情况下，您也可以使用<strong class="je hv">集群</strong>——但是我们建议您不要使用节点集群，因为负载平衡器更有效，并且提供更多有用的东西。</p><p id="fee4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文中，我们将只使用负载平衡器。在我们的例子中，它将是Nginx。这里有一篇文章将向你解释如何安装Nginx。</p><p id="b27d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，我们继续吧。</p><p id="d880" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以运行一个节点应用程序的多个实例，并使用Nginx服务器代理所有到节点服务器的请求/连接。默认情况下，Nginx会使用<code class="eh le lf lg lh b">round robin</code>逻辑将请求按顺序发送到不同的服务器。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/582b3f80777f140108dd7978c5102993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5z5bX10o0u-aWqj5.png"/></div></div></figure><p id="6f0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，我们有一个Nginx服务器，它接收客户端发送的所有请求，并转发到不同的节点服务器。我们已经说过，Nginx默认使用<code class="eh le lf lg lh b">round robin</code>逻辑，这就是为什么第一个请求到达服务器:8000，第二个到达8001，第三个到达8002，等等...</p><p id="6e1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Nginx还有更多的功能(即创建备份服务器，这将有助于当服务器崩溃时，Nginx会自动将所有请求移动到备份服务器)，但在本文中，我们将只使用代理。</p><p id="8557" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个基本的Express.js服务器，我们将在Nginx中使用它。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="2bc9" class="lr kb hu lh b fv ls lt l lu lv">// server.js</span><span id="b1cd" class="lr kb hu lh b fv lw lt l lu lv">const  express  =  require('express');<br/>const  app  =  express();</span><span id="43f2" class="lr kb hu lh b fv lw lt l lu lv">app.get('/', (req, res) =&gt; {<br/>    res.end(`Hi, PID: ${process.pid}`);<br/>});</span><span id="5c91" class="lr kb hu lh b fv lw lt l lu lv">app.listen(process.env.PORT);</span><span id="b5e8" class="lr kb hu lh b fv lw lt l lu lv">console.log(`Server running on ${process.env.PORT} port, PID: ${process.pid}`);</span></pre><p id="1dfa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<code class="eh le lf lg lh b">env</code>,我们可以从终端发送端口号，express应用程序将监听该端口号。</p><p id="4135" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们跑过去看看会发生什么。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="5185" class="lr kb hu lh b fv ls lt l lu lv">PORT=8000 node server.js</span></pre><p id="53f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在控制台和浏览器中，我们可以看到服务器PID，这将有助于识别哪个服务器收到了我们的调用。</p><p id="308a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们在<code class="eh le lf lg lh b">8001</code>和<code class="eh le lf lg lh b">8002</code>端口再运行两个服务器。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="344e" class="lr kb hu lh b fv ls lt l lu lv">PORT=8001 node server.js PORT=8002 node server.js</span></pre><p id="bc17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们在不同的端口有三个节点服务器。</p><ul class=""><li id="ca46" class="lx ly hu je b jf jg jj jk jn lz jr ma jv mb jz mc md me mf dt translated"><code class="eh le lf lg lh b"><a class="ae ld" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a></code></li><li id="e210" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated"><code class="eh le lf lg lh b"><a class="ae ld" href="http://localhost:8001/" rel="noopener ugc nofollow" target="_blank">http://localhost:8001/</a></code></li><li id="62de" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated"><code class="eh le lf lg lh b"><a class="ae ld" href="http://localhost:8002/" rel="noopener ugc nofollow" target="_blank">http://localhost:8002/</a></code></li></ul><p id="9134" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们运行Nginx服务器。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="b109" class="lr kb hu lh b fv ls lt l lu lv">upstream nodes {<br/>    server 127.0.0.1:8000;<br/>    server 127.0.0.1:8001;<br/>    server 127.0.0.1:8002;<br/>}</span><span id="2bc4" class="lr kb hu lh b fv lw lt l lu lv">server {<br/>    listen 3000;</span><span id="afea" class="lr kb hu lh b fv lw lt l lu lv">location / {<br/>        proxy_pass <a class="ae ld" href="http://nodes" rel="noopener ugc nofollow" target="_blank">http://nodes</a>;<br/>    }<br/>}</span></pre><p id="ee5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的Nginx服务器监听<code class="eh le lf lg lh b">3000</code>端口，并代理到<code class="eh le lf lg lh b">upstream node</code>服务器。</p><p id="979d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重启Nginx服务器并转到<code class="eh le lf lg lh b"><a class="ae ld" href="http://127.0.0.1:3000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/</a></code></p><p id="c16f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">多次刷新，会看到不同的<code class="eh le lf lg lh b">PID</code>号。我们刚刚创建了一个基本的负载平衡器服务器，它将请求转发到不同的节点服务器。这样，您可以处理大量的请求，并充分利用CPU和RAM。</p><p id="9662" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看套接字是如何工作的，以及我们如何以这种方式平衡套接字服务器。</p><h1 id="da87" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">套接字服务器负载平衡</h1><p id="5625" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">首先，我们来看看Socket在浏览器中是如何工作的。</p><p id="a662" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Socket打开连接和监听事件有两种方式。它们是<strong class="je hv">长轮询</strong>和<strong class="je hv">web socket</strong>——它们被称为传输。</p><p id="fdb6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认情况下，所有浏览器都通过轮询启动套接字连接，然后，如果浏览器支持WebSocket，它将切换到WebSocket传输。但是我们可以添加可选的<code class="eh le lf lg lh b">transports</code>选项，并指定我们想要使用哪个或哪些传输进行连接。然后我们可以使用WebSocket传输一次打开套接字连接，或者相反只会使用轮询传输。</p><p id="fdf4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看轮询和WebSocket的区别。</p><h1 id="be78" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">长轮询</h1><p id="bfc6" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">套接字允许从服务器接收事件，而无需请求任何东西，这可以用于游戏、信使等等。你不知道你的朋友什么时候会给你发消息请求服务器并得到响应。使用套接字，服务器将自动向您发送一个事件，您将接收该数据。</p><p id="a930" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何实现一个仅使用HTTP请求的功能，并提供一个能够从服务器接收一些数据而无需请求该数据的层？换句话说，我们如何仅使用HTTP请求来实现套接字？</p><p id="18e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一下，你有一个<strong class="je hv">层</strong>，它向服务器发送请求，但是服务器没有立即响应你——换句话说，你只是等待。当服务器有东西需要发送给你时，它会使用你刚才打开的HTTP连接把数据发送给你。</p><p id="360e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦收到响应，您的<strong class="je hv">层</strong>将自动向服务器发送一个新请求，并再次等待另一个响应，而不检查前一个请求的响应。</p><p id="0720" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，您的应用程序可以随时从服务器接收数据/事件，因为您总是有一个等待服务器响应的打开请求。</p><p id="aab5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是投票的工作方式。这是它工作的可视化。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/294e66588bc6257ac2d274149c117b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MTGyjq_y82uyJbA4.png"/></div></div></figure><h1 id="be14" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">WebSocket</h1><p id="3609" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">WebSocket是一种协议，它只允许打开一个<code class="eh le lf lg lh b">TCP</code>连接并保持很长时间。这是另一个可视化图像，展示了WebSocket是如何工作的。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/05764bfc2793182ac512ea8c8732d650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*1nPRDJMoYd2hFoFh.png"/></div></figure><p id="945f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们所说，默认情况下，大多数浏览器使用<strong class="je hv">轮询传输</strong>(使用XHR请求)连接套接字服务器。然后，服务器请求将传输更改为WebSocket。但是，如果浏览器不支持WebSockets，它可以继续使用轮询。对于一些不能使用WebSocket传输的旧浏览器，应用程序将继续使用轮询传输，而不会升级传输层。</p><p id="12f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们创建一个基本的套接字服务器，看看它如何在Chrome的Inspect网络中工作。</p><p id="5f2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">index.html</strong></p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="ee18" class="lr kb hu lh b fv ls lt l lu lv">&lt;!Doctype html&gt;</span><span id="f600" class="lr kb hu lh b fv lw lt l lu lv">&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;Hello World&lt;/title&gt;<br/>        &lt;script src="<a class="ae ld" href="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js</a>"&gt;&lt;/script&gt;<br/>        &lt;script&gt;<br/>            const socket = io('<a class="ae ld" href="http://0.0.0.0:3000'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000'</a>, {<br/>                transports: ['polling']<br/>                // transports: ['websocket']<br/>            });</span><span id="c099" class="lr kb hu lh b fv lw lt l lu lv">socket.on('connect', () =&gt; {<br/>                console.log(`Socket connected id: ${socket.id}`);<br/>            });<br/>        &lt;/script&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;Basic Socket connection&lt;/h1&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="ee3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> server.js </strong></p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="debf" class="lr kb hu lh b fv ls lt l lu lv">const io = require('socket.io')(process.env.PORT);</span><span id="12c9" class="lr kb hu lh b fv lw lt l lu lv">io.on('connection', (socket) =&gt; {<br/>    console.log(`${socket.id} connected`);<br/>});</span><span id="daea" class="lr kb hu lh b fv lw lt l lu lv">console.log(`Socket Server running on ${process.env.PORT} port, PID: ${process.pid}`);</span></pre><p id="dbf0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在端口<code class="eh le lf lg lh b">3000</code>上运行Node.js服务器，在Chrome中打开<code class="eh le lf lg lh b">index.html</code>。</p><p id="f6f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，我们使用<code class="eh le lf lg lh b">polling</code>连接到套接字，因此在幕后，它发出HTTP请求。这意味着，如果我们在“检查网络”页面中打开XHR，我们将看到它是如何向服务器发送请求的。</p><p id="1161" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从浏览器的检查模式中打开网络选项卡，查看网络中的最后一个XHR请求。它总是在等待的过程中，没有回应。一段时间后，该请求将被终止，新的请求将被发送——因为，如果一个请求长时间没有得到服务器的响应，您将得到超时错误。因此，如果服务器没有响应，它将更新请求并发送新的请求。</p><p id="a64f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，请注意服务器发送给客户端的第一个请求的响应。响应数据如下所示:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="aaf8" class="lr kb hu lh b fv ls lt l lu lv">96:0{"sid":"EHCmtLmTsm_H8u3bAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}2:40</span></pre><p id="4e76" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经说过，服务器向客户端发送选项，将传输从“轮询”升级到“websocket”。然而，由于我们在选项中只有“轮询”传输，它不会切换。</p><p id="1e01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尝试用以下内容替换连接线:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="9d93" class="lr kb hu lh b fv ls lt l lu lv">const socket = io('http://0.0.0.0:3000');</span></pre><p id="7acf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开控制台，从“检查网络”页面中选择“全部”。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/4996c870dc33e0fb3e3a8b6428919dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lx4FQdVZVBfxIUqC.jpg"/></div></div></figure><p id="dd9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您刷新页面时，您会注意到，在一些XHR请求后，客户端升级到了“websocket”。注意网络控制台中网络项目的类型。正如您所看到的，“投票”是基本的XHR，而网络套接字是“网络套接字”的类型。当你点击它时，你会看到框架。当服务器发出新事件时，您将收到一个新帧。还有一些事件(仅仅是数字，即2，3)，客户机/服务器只是发送给彼此以保持连接，否则，我们将得到一个超时错误。</p><p id="1fd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，您已经对套接字的工作原理有了基本的了解。但是，像前面的例子一样，当我们试图使用Nginx平衡套接字服务器时，会有什么样的问题呢？</p><h1 id="fc1d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">问题</h1><p id="feb9" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">有两个主要问题。</p><p id="8e81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">首先</strong>，当我们有一个带有多个节点服务器的Nginx负载平衡器并且客户端使用轮询时，会出现一个问题。</p><p id="4d41" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能还记得，Nginx使用循环逻辑来平衡请求，所以客户端发送给Nginx的每个请求都会被转发给Node服务器。</p><p id="7721" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您有三个节点服务器和一个Nginx负载平衡器。用户使用轮询(XHR请求)请求连接服务器，Nginx将该请求平衡到Node:8000，服务器注册客户端的Session ID，以获知连接到该服务器的客户端。第二次，当用户做任何动作时，客户端发送一个新的请求，Nginx将其转发给Node:8001。</p><p id="eb62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二台服务器应该做什么？它从未连接的客户端接收事件。服务器将返回一个带有<code class="eh le lf lg lh b">Session ID unknown</code>消息的错误。</p><p id="2d41" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于使用轮询的客户端来说，平衡成了一个问题。通过网络套接字的方式，您将不会得到任何这样的错误，因为您连接一次，然后接收/发送帧。</p><p id="88d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个问题应该在哪里解决:在客户端还是在服务器端？</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/6057a6c2ae250d0939743de1264fe75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_zH6V_swUWaeQ4j9.png"/></div></div></figure><p id="c226" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">肯定在服务器里！更具体地说，是在Nginx中。</p><p id="013b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们应该改变用于平衡负载的Nginx逻辑的形式。我们可以使用的另一个逻辑是<code class="eh le lf lg lh b">ip_hash</code>。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="e3be" class="lr kb hu lh b fv ls lt l lu lv">upstream nodes {<br/>    ip_hash;<br/>    server 127.0.0.1:8000;<br/>    server 127.0.0.1:8001;<br/>    server 127.0.0.1:8002;<br/>}</span></pre><p id="3f1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个客户端都有一个IP地址，因此Nginx使用该IP地址创建一个哈希，并将客户端请求转发给Node服务器，这意味着来自同一IP地址的每个请求都将被转发给同一服务器。</p><p id="bc29" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，这是这个问题的最小解决方案；还有其他的可能。如果您想走得更远，有时这个解决方案会很短。您可以研究Nginx/ <a class="ae ld" href="https://www.nginx.com/products/nginx/" rel="noopener ugc nofollow" target="_blank"> Nginx PLUS </a>的其他逻辑或使用其他负载平衡器(即<a class="ae ld" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>)。</p><p id="616b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转到<strong class="je hv">第二个问题</strong>:用户连接到一台服务器。</p><p id="ab84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一种情况，你连接到Node:8000，你的一个朋友连接到Node:8001，你想给他/她发消息。你通过socket发送，服务器收到一个事件，想把你的消息发给另一个用户(你的朋友)。我想你已经猜到了我们会遇到什么问题:服务器想要向用户发送数据，而用户并没有连接到它，而是连接到系统中的另一个服务器。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/11b5bacf502cdbc5ffab8734f2f2a884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SEKQZ6OCSddOAzt2.png"/></div></div></figure><p id="d259" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决方案只有一个，可以通过多种方式实现。</p><blockquote class="mm mn mo"><p id="e3e2" class="jc jd mp je b jf jg jh ji jj jk jl jm mq jo jp jq mr js jt ju ms jw jx jy jz hn dt translated"><em class="hu">为服务器创建内部通信层。</em></p></blockquote><p id="c36b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着每台服务器都能够向其他服务器发送请求。</p><p id="6b8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，<code class="eh le lf lg lh b">Node:8000</code>向<code class="eh le lf lg lh b">Node:8001</code>和<code class="eh le lf lg lh b">Node:8002</code>发送请求，它们检查<em class="mp">用户2 </em>是否连接到它。如果<em class="mp"> user2 </em>连接，该服务器将发出<code class="eh le lf lg lh b">Node:8000</code>提供的数据。</p><p id="aef0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们讨论一种最流行的技术，它提供了一个通信层，我们可以在节点服务器中使用它。</p><h1 id="1b23" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">雷迪斯</h1><p id="9137" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">正如<a class="ae ld" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank">官方文件</a>中所写:</p><blockquote class="mm mn mo"><p id="ad04" class="jc jd mp je b jf jg jh ji jj jk jl jm mq jo jp jq mr js jt ju ms jw jx jy jz hn dt translated"><em class="hu"> Redis是用作数据库的内存中数据结构存储</em></p></blockquote><p id="66d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，它允许你在内存中创建<code class="eh le lf lg lh b">key-value</code>对。另外，Redis提供了一些有用的特性。让我们来谈谈其中一个流行的功能。</p><p id="149c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个消息系统，它为我们提供了一个<strong class="je hv">订阅者</strong>和一个<strong class="je hv">发布者</strong>。</p><p id="afe0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Redis客户机中使用Subscriber，您可以订阅一个<strong class="je hv">频道</strong>并收听消息。使用Publisher，您可以将消息发送到订户将接收的特定通道。</p><p id="243b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像Node.js <code class="eh le lf lg lh b">EventEmitter</code>。但是当节点应用程序需要向另一个节点应用程序发送数据时,<code class="eh le lf lg lh b">EventEmitter</code>将无济于事。</p><p id="df40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看它是如何与Node.js一起工作的</p><p id="b5be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">订户</strong></p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="574e" class="lr kb hu lh b fv ls lt l lu lv">// subscriber.js<br/>const redis = require('redis');</span><span id="3d0f" class="lr kb hu lh b fv lw lt l lu lv">const subscriber = redis.createClient();</span><span id="c1a8" class="lr kb hu lh b fv lw lt l lu lv">subscriber.on('message', (channel, message) =&gt; {<br/>    console.log(`Message "${message}" on channel "${channel}" arrived!`)<br/>});</span><span id="798d" class="lr kb hu lh b fv lw lt l lu lv">subscriber.subscribe('my channel');</span></pre><p id="5f13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">发布者</strong></p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="7372" class="lr kb hu lh b fv ls lt l lu lv">// publisher.js<br/>const redis = require('redis');</span><span id="8419" class="lr kb hu lh b fv lw lt l lu lv">const publisher = redis.createClient();</span><span id="1b96" class="lr kb hu lh b fv lw lt l lu lv">publisher.publish('my channel', 'hi');</span><span id="c1ca" class="lr kb hu lh b fv lw lt l lu lv">publisher.publish('my channel', 'hello world');</span></pre><p id="e5e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，为了能够运行这段代码，我们需要安装<code class="eh le lf lg lh b">redis</code>模块。另外，不要忘记在本地机器上安装Redis。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="30ab" class="lr kb hu lh b fv ls lt l lu lv">npm i -S redis</span></pre><p id="011c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们跑一跑，看看结果。</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="0967" class="lr kb hu lh b fv ls lt l lu lv">node subscriber.js</span></pre><p id="b345" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="ec2e" class="lr kb hu lh b fv ls lt l lu lv">node publisher.js</span></pre><p id="efd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在“订阅者”窗口中，您将看到以下输出:</p><pre class="lj lk ll lm fq ln lh lo lp aw lq dt"><span id="e238" class="lr kb hu lh b fv ls lt l lu lv">Message "hi" on channel "my channel" arrived!<br/>Message "hello world" on channel "my channel" arrived!</span></pre><p id="aa6c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">恭喜你！您刚刚在不同的节点应用程序之间建立了通信。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/82f90c3e4d8985602d6258d6d73cd333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6B7Sj0gNBA_spO0t.png"/></div></div></figure><p id="3eec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，我们可以在一个应用程序中拥有订阅者和发布者，以便能够在彼此之间接收和发送数据。</p><p id="5113" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在官方文档上阅读更多关于Redis PUB/SUB的内容。此外，您可以查看<a class="ae ld" href="https://www.npmjs.com/package/node-redis-pubsub" rel="noopener ugc nofollow" target="_blank"> node-redis-pubsub </a>模块，该模块提供了一种使用Redis PUB/SUB的简单方法。</p><h1 id="52b3" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">连接所有这些部分</h1><p id="0562" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">最后，我们来到了最有趣的部分之一。</p><p id="4d72" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了处理大量连接，我们<strong class="je hv">运行Node.js应用程序</strong>的多个实例，然后我们<strong class="je hv">使用Nginx </strong>平衡这些服务器的负载。</p><p id="db38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用Redis发布/订阅，我们在Node.js服务器之间建立通信。每当任何服务器想要发送数据给没有连接到它的客户机时，服务器就发布数据。然后，每台服务器都会收到它，并检查用户是否连接到它。最后，该服务器将提供的数据发送给客户端。</p><p id="5936" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是后端体系结构组织方式的大致情况:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff li"><img src="../Images/50634d914399a31c226c04321eef11bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*McDtTWsS0TMMciuq.png"/></div></div></figure><p id="8e2a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看如何在Node.js中实现这一点。您不需要从头开始创建所有这些。已经有一些软件包完成了部分工作。</p><ul class=""><li id="3c10" class="lx ly hu je b jf jg jj jk jn lz jr ma jv mb jz mc md me mf dt translated"><a class="ae ld" href="https://github.com/socketio/socket.io-redis" rel="noopener ugc nofollow" target="_blank"> socket.io-redis </a></li><li id="2719" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated"><a class="ae ld" href="https://github.com/socketio/socket.io-emitter" rel="noopener ugc nofollow" target="_blank">插座. io-发射器</a></li></ul><p id="696d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这两个包为<a class="ae ld" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>工作。</p><p id="6b5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh le lf lg lh b">socket.io-emitter</code>依赖项提供的一件有趣的事情是从套接字服务器外部向用户发出事件。如果您可以将服务器将接收的有效数据发布到Redis，那么其中一个服务器就可以将套接字事件发送到客户机。这意味着拥有一个能够向用户发送事件的套接字服务器并不重要。您可以运行一个自定义服务器，它将连接到同一个Redis，并使用PUBLISH向客户机发送套接字事件。</p><p id="6582" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另外，还有一个名为<a class="ae ld" href="https://socketcluster.io/" rel="noopener ugc nofollow" target="_blank"> SocketCluster </a>的包。<em class="mp"> SocketCluster </em>更高级——它使用集群，集群有代理和工人。Brokers帮助我们处理Redis发布/订阅部分，workers是我们的Node.js应用程序。</p><p id="eb80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有<a class="ae ld" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank">推动器</a>帮助构建大型可扩展应用。它为他们托管的<em class="mp">发布/订阅</em>消息系统提供了一个API，并且它还为一些平台提供了一个SDK(<em class="mp">例如</em>，Android，IOS，Web)。但是，注意这是付费服务。</p><h1 id="f690" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="87b9" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在本文中，我们解释了如何平衡套接字服务器，可能会出现什么样的问题，以及如何解决这些问题。</p><p id="1953" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用Nginx来平衡多个节点的服务器负载。有很多负载平衡器，但我们推荐Nginx/Nginx Plus或HAProxy。此外，我们看到了套接字如何工作以及轮询和websocket传输层之间的区别。最后，我们看到了如何在Node.js实例之间建立通信并一起使用它们。</p><p id="9a06" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们有一个负载平衡器，它将请求转发到多个Node.js服务器。请注意，您必须配置负载平衡器逻辑以避免任何问题。我们还为Node.js服务器提供了一个通信层。在我们的例子中，我们使用了Redis PUB/SUB，但是您也可以使用其他通信工具。</p><p id="2b48" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我用过Socket.io(用Redis)和SocketCluster，建议你无论大小项目都用。有了这些策略，就有可能拥有一个可以处理30k套接字连接的SocketCluster游戏。实际上，SocketCluster库有点老，它的社区也不是很大，但是它可能不会给你带来任何问题。</p><p id="d0ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有许多工具可以帮助您平衡负载或分配系统。我们建议您也了解Docker和Kubernetes。尽快开始研究它们吧！</p><p id="dd62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢您阅读这篇文章。欢迎提问或发推文<a class="ae ld" href="https://twitter.com/nairihar" rel="noopener ugc nofollow" target="_blank"> @nairihar </a>。</p></div><div class="ab cl mt mu hc mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hn ho hp hq hr"><p id="6396" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mp">原载于</em><a class="ae ld" href="https://blog.jscrambler.com/scaling-node-js-socket-server-with-nginx-and-redis/" rel="noopener ugc nofollow" target="_blank"><em class="mp">【blog.jscrambler.com】</em></a><em class="mp">作者</em> <a class="ae ld" href="https://blog.jscrambler.com/author/nairi" rel="noopener ugc nofollow" target="_blank">乃日·哈若提欧年</a>。</p></div></div>    
</body>
</html>