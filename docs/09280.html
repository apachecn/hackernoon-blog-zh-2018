<html>
<head>
<title>Webpack, Babel, and React from Scratch — BUT WHY?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack、Babel和React从零开始——但为什么呢？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/webpack-babel-and-react-from-scratch-but-why-889a385ff32f?source=collection_archive---------0-----------------------#2018-11-11">https://medium.com/hackernoon/webpack-babel-and-react-from-scratch-but-why-889a385ff32f?source=collection_archive---------0-----------------------#2018-11-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/29e24054a8e75484a4de6db283c94de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*KpImd6VctvHpmNeyeZKeWQ.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Webpack, Babel, and React</figcaption></figure><p id="29ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在研究生院和其他事情之间，我一直在深入挖掘JavaScript生态系统。作为一个热爱React的人，我对<em class="kb">的create-react-app </em>产生了好奇。在您的命令行上使用一个简单的<em class="kb">NPM install-g create-React-app</em>，您将能够安装最流行的React starter pack。然而，你有没有想过<em class="kb"> create-react-app </em>是如何工作的？或者他们如何让这些应用在网络请求相对较小的浏览器上快速运行？也许也许在运行<em class="kb"> npm run build </em>之后捆绑和生成静态文件是如何发生的？这些东西耐人寻味。在这些开源项目的神秘面纱下，是简单的代码行，你我都可以学习和理解。</p><p id="7de2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我决定在webpack和babel的帮助下从头开始构建一个React应用程序，并将其部署到Netlify。你可以查看我的GitHub回购<a class="ae ka" href="https://github.com/jsphbtst/react-webpack-simple" rel="noopener ugc nofollow" target="_blank">这里</a>。我还在这里部署了静态站点来实现<a class="ae ka" href="https://agitated-hoover-cdafcd.netlify.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="266d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这个项目，我们将制作一个简单的React应用程序，通过点击按钮来改变网页的背景颜色。开始在脑海中想象那会是什么样子。我们需要基于类的组件还是功能组件？onClick会怎么做？你需要国家吗？</p><p id="55fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你在考虑这些事情的时候，是时候设置webpack和babel了。确保您的计算机上安装了Node，并遵循以下命令。这将包括创建一个名为<em class="kb"> react-webpack-simple </em>的新文件夹——或者您真正想要的任何名称——并运行<em class="kb"> npm init </em>。继续安装下面列出的库。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="1d4e" class="kl km hu kh b fv kn ko l kp kq">mkdir react-webpack-simple<br/>cd react-webpack-simple<br/>npm init<br/>npm install --save-dev @babel/core @babel/preset-env @babel/preset-react babel-loader<br/>mkdir src<br/>cd src<br/>touch index.html index.js<br/>cd ..</span></pre><p id="e2d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb"> Babel-core </em>用于将ES2015+代码转换成向后兼容版本的JavaScript。@ <em class="kb"> babel/preset-env </em>和<em class="kb"> @babel/preset-react，</em>则是一组分别支持babel和react功能的插件——它们在后台为我们做了很多繁重的工作。最后，<em class="kb"> Babel-loader </em>传输我们的JavaScript代码，给出我们已经设置好的所有预置。</p><p id="b4d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转到您的目录的根目录，在我们的例子中是<em class="kb"> react-webpack-simple，</em>并创建一个名为<em class="kb">的文件。babelrc </em>。在这个文件中，我们将定义Babel将使用的所有预设。如上所述，那就是<em class="kb"> @babel/preset-env </em>和<em class="kb"> @babel/preset-react </em>。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff kr"><img src="../Images/15ffa80b20b893ed606e624cc1c6d077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7P0yGOC0VsxggsoqN4Cmg.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek"><em class="kw">.babelrc</em></figcaption></figure><p id="027c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了！我们正朝着完成这个项目最难的部分缓慢前进——相信我，反应是最容易的部分。现在在根文件夹中创建一个名为<em class="kb"> webpack.config.js </em>的新文件。这是Webpack的配置文件。记住，在它的核心，Webpack只是一个模块捆绑器。不同的项目有不同的目标，这需要不同类型的方法来为生产中的文件提供服务。我们希望css文件在主html文件中有一个样式标签吗？我们要启用缓存吗？这是所有奇迹发生的地方。</p><p id="bef8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是首先，webpack有一些你需要熟悉的核心概念——你可以在<a class="ae ka" href="https://webpack.js.org/concepts/" rel="noopener ugc nofollow" target="_blank">文档</a>中读到它们。入口，顾名思义，是webpack开始构建其内部依赖图的入口点。任何不是进口的东西，在我们的例子中，在<em class="kb">。/src/index.js </em>将不会是该图的一部分。确保您的JavaScript文件和其他文件被正确导入。另一方面，输出是webpack转储它创建的所有包的地方。由于webpack只能理解JavaScript或JSON，所以必须有一些函数或“中间件”来帮助webpack理解静态图像、css文件等内容。这些“中间件”是在加载器中定义的，webpack将使用这些“中间件”来理解这些非JavaScript和JSON文件，以便正确地将这些文件放入内部依赖图中。最后，插件通过在捆绑过程、资产管理和其他方面提供帮助来帮助加载程序。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="bcce" class="kl km hu kh b fv kn ko l kp kq">// Install these dependencies before writing webpack.config.js</span><span id="defd" class="kl km hu kh b fv kx ko l kp kq">npm install --save-dev html-webpack-plugin mini-css-extract-plugin react react-dom</span></pre><p id="188d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的<em class="kb"> webpack.config.js </em>文件就是上面理论的应用。VENDOR_LIBS包含了我们在react应用程序中需要的所有库。我们创建这个数组是因为我们不想马上加载所有的库——那样会耗尽网络请求。相反，如果我们按需加载这些库会更好。</p><p id="73a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">【姓名】。您看到的[chunkhash].bundle.js </em>格式是用于缓存的。为了增加用户体验，我们不希望我们的用户每次加载我们的站点时都下载应用程序中使用的依赖项。如果所述依赖关系以某种方式被缓存，那么每次访问时加载网站会更快，因为我们的用户在过去已经下载了那些依赖关系。如果我们进行更新，那么用户只需要下载新版本，而不是从头开始。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff ky"><img src="../Images/2da635b556455ecb642324cdc51da8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Em14hqul92GZ4dxAifONGA.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">webpack.config.js</figcaption></figure><p id="de44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在模块部分，<em class="kb"> babel-loader </em>用于传输JavaScript代码。还记得我说过的非JavaScript代码吗？HTML和CSS文件是非JavaScript文件，所以<em class="kb"> html加载器</em>和<em class="kb"> css加载器</em>被用来帮助处理这些文件。测试只是意味着如果一个文件以[在此插入扩展名]结尾，webpack将使用[在此插入加载程序]。例如，如果一个文件以<em class="kb"> html </em>结尾，webpack将使用<em class="kb"> html-loader。</em></p><p id="4a0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在插件部分，<em class="kb"> HtmlWebpackPlugin </em>用于从HTML文档导入JavaScript文件——每次构建项目时，手动更新脚本标记的名称(注意那些散列值)会很麻烦。同时，<em class="kb">minicsextractplugin</em>用于为导入CSS文件的每个JavaScript文件生成单独的CSS文件。最后，<em class="kb">网络包。DefinePlugin </em>用于为生产准备我们的项目——React在生产和开发中的表现不同。</p><p id="ff78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还和我在一起吗？我们要做的最后一个webpack配置是使用npm下载<em class="kb"> rimraf </em>和<em class="kb"> webpack-dev-server </em>。rimraf 是一个库，它可以让我们删除以前的构建文件，并用新的替换它们。这样，我们就不会因为旧的构建文件和新的构建文件而使我们的工作空间变得混乱——那样会变得令人困惑。webpack-dev-server 用于开发目的，因为每次代码更改都会自动刷新浏览器，使开发变得更容易，而不是每次都构建您的项目并不时打开<em class="kb">index.html</em>。另外，将package.json的<em class="kb">脚本</em>修改为如下内容。<em class="kb"> npm运行构建</em>将创建构建文件，而<em class="kb"> npm运行启动</em>将启动开发服务器。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="24b3" class="kl km hu kh b fv kn ko l kp kq">// Don't forget to run npm install --save-dev rimraf webpack-dev-server first<br/>"scripts": {<br/>    "clean": "rimraf dist",<br/>    "start": "webpack-dev-server --open --mode development",<br/>    "build": "NODE_ENV=production npm run clean &amp;&amp; webpack -p"<br/>}</span></pre><p id="434f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在所有这些修补之后，你的文件夹结构应该看起来像这样。注意,<em class="kb"> dist </em>文件夹包含我们的构建文件。当我们输入<em class="kb"> npm run build </em>命令时，这个文件夹会自动生成。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/cd271065f1dd959089e403646bbab174.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*55Ec7_AqGajbOaNBulCfVg.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Your folder structure</figcaption></figure><p id="4f34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从现在开始就很简单了。<em class="kb">index.html</em>包含以下代码:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff la"><img src="../Images/be78d2e7ec9972f8af21e1fd45b4fa0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOyN-XZswPbubH0Ma5sXQw.png"/></div></div></figure><p id="c970" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你以前用过<em class="kb"> create-react-app </em>，那么带有<em class="kb">根</em> id的<strong class="je hv"> div </strong>标签应该看起来很熟悉。注意这篇文章不是关于学习React，因为我假设你已经知道如何使用这个框架。下面是我们将使用的React代码。它使用Bootstrap 3并在DOM上呈现四个按钮，每个按钮对应不同的背景颜色变化。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff lb"><img src="../Images/d1f249dc8f55bd43b5acdb003d87bd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aced8_bs6CYxHIGXc7CNrA.png"/></div></div></figure><p id="d01e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个漫长的过程，但值得努力！进入终端，输入<em class="kb"> npm run build，</em>将<em class="kb"> dist </em>文件夹中的<em class="kb">index.html</em>文件拖放到你首选的web浏览器中，你应该就可以了！我在Netlify中部署了我的项目，正如我在这篇博文中提到的，这允许我只需将我的静态文件拖放到dist文件夹中，等待几秒钟，就可以看到它被部署了。</p><p id="ca98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">展望未来，我将从头开始构建更多这样的应用程序，以研究所有正在发生的事情。我们在这里建立的是一个静态网站，不使用后端服务器。我将构建的下一个项目将包括一个节点后端，也许还包括套接字，以使它实时。迭代的过程意味着添加更多的功能，但也意味着更多的研究，以了解我到底在做什么。学习永不停止。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lc ld l"/></div></figure></div></div>    
</body>
</html>