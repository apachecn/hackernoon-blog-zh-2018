<html>
<head>
<title>How to use NodeJS without frameworks and external libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有框架和外部库如何使用NodeJS</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-use-nodejs-without-frameworks-and-external-libraries-97eb6acac9e3?source=collection_archive---------1-----------------------#2018-11-12">https://medium.com/hackernoon/how-to-use-nodejs-without-frameworks-and-external-libraries-97eb6acac9e3?source=collection_archive---------1-----------------------#2018-11-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b4dcd594c863fc05fe6562142e3d2cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CnuDqpgLH9Cs2BdB"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">“timelapse photography of pink vehicle lights near buildings” by <a class="ae jg" href="https://unsplash.com/@emrekaratas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Emre Karataş</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b90a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>最常用于Express框架。NodeJS还使用了许多其他外部库。</p><p id="92c1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些<a class="ae jg" href="https://hackernoon.com/tagged/frameworks" rel="noopener ugc nofollow" target="_blank">框架</a>和库与NodeJS一起使用的原因是为了使开发更加容易和快速。</p><p id="5150" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在进行任何真正的项目时，最好在任何需要的地方使用框架和库来加快开发😄</p><p id="bc1e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">也就是说，在这篇文章中，我将展示如何在不使用express framework或任何其他外部库的情况下用NodeJS构建简单的REST API。本文将只使用NodeJS本身提供的那些功能。</p><p id="e92f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这样做的原因是为了展示如何在没有框架和库的情况下使用NodeJS😄。这也将给出一个关于NodeJS如何工作的更好的想法😄</p><h1 id="5dff" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">先决条件</h1><p id="f704" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">从<a class="ae jg" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org</a>安装节点</p><h1 id="737c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">密码</h1><p id="31cc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">这篇文章的代码可以在我的<a class="ae jg" href="https://github.com/aditya-sridhar/simple-rest-apis-nodejs-without-frameworks" rel="noopener ugc nofollow" target="_blank"> github repo </a>中找到。</p><h1 id="241f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">让我们从代码开始😄</h1><p id="6ddd" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">创建一个名为<strong class="jj hv">simple-rest-APIs-nodejs-without-frameworks</strong>的文件夹。这将是我们的NodeJS项目文件夹。</p><p id="e81c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">进入项目文件夹，使用<code class="eh li lj lk ll b">npm init</code>使项目成为节点项目。执行此操作的命令有</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="d80b" class="lu kg hu ll b fv lv lw l lx ly">cd simple-rest-apis-nodejs-without-frameworks<br/>npm init</span></pre><h1 id="2e19" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">package.json</h1><p id="b7ef" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">运行<code class="eh li lj lk ll b">npm init</code>之后，在项目文件夹中会创建一个<strong class="jj hv"> package.json </strong>文件。</p><p id="80d9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">json有关于你的项目的信息，比如项目名称，版本，描述等等。另外，package.json是您添加节点依赖项的地方。在本文中，我们不会有任何依赖，因为我们只使用NodeJS本身提供的功能。</p><h1 id="307f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">首个API</h1><p id="6f43" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在项目文件夹中创建一个名为<strong class="jj hv"> server.js </strong>的文件。这将是我们应用程序的起点。</p><p id="4a2d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将以下代码复制到server.js中</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="dcc0" class="lu kg hu ll b fv lv lw l lx ly"><strong class="ll hv">const</strong> hostname <strong class="ll hv">=</strong> '127.0.0.1';<br/><strong class="ll hv">const</strong> port <strong class="ll hv">=</strong> 3000;</span><span id="9600" class="lu kg hu ll b fv lz lw l lx ly"><strong class="ll hv">const</strong> server <strong class="ll hv">=</strong> require('./controller.js');</span><span id="cdcb" class="lu kg hu ll b fv lz lw l lx ly">server.listen(port, hostname, () <strong class="ll hv">=&gt;</strong> {<br/>    console.log(`Server running at http://${hostname}:${port}/`);<br/>});</span></pre><p id="abbd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码实际上依赖于一个名为<strong class="jj hv"> controller.js </strong>的文件，我们很快就会添加这个文件。这段代码告诉我们服务器需要监听端口3000和本地主机T21</p><p id="64fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">服务器创建在<strong class="jj hv"> controller.js </strong>中完成</p><h1 id="be25" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">controller.js</h1><p id="088e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">这是我们将在其中创建服务器和定义rest端点的文件。创建一个名为<strong class="jj hv"> controller.js </strong>的文件</p><p id="7660" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们首先在<strong class="jj hv"> controller.js </strong>中创建一个GET端点</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="3f9f" class="lu kg hu ll b fv lv lw l lx ly"><strong class="ll hv">const</strong> http <strong class="ll hv">=</strong> require('http');<br/><strong class="ll hv">const</strong> url <strong class="ll hv">=</strong> require('url');</span><span id="b88f" class="lu kg hu ll b fv lz lw l lx ly">module.exports <strong class="ll hv">=</strong> http.createServer((req, res) <strong class="ll hv">=&gt;</strong> {</span><span id="88e5" class="lu kg hu ll b fv lz lw l lx ly">    <strong class="ll hv">var</strong> service <strong class="ll hv">=</strong> require('./service.js');<br/>    <strong class="ll hv">const</strong> reqUrl <strong class="ll hv">=</strong> url.parse(req.url, <strong class="ll hv">true</strong>);</span><span id="107f" class="lu kg hu ll b fv lz lw l lx ly">    <em class="ma">// GET Endpoint</em><br/>    <strong class="ll hv">if</strong> (reqUrl.pathname <strong class="ll hv">==</strong> '/sample' <strong class="ll hv">&amp;&amp;</strong> req.method <strong class="ll hv">===</strong> 'GET') {<br/>        console.log('Request Type:' <strong class="ll hv">+</strong><br/>            req.method <strong class="ll hv">+</strong> ' Endpoint: ' <strong class="ll hv">+</strong><br/>            reqUrl.pathname);</span><span id="b8e8" class="lu kg hu ll b fv lz lw l lx ly">        service.sampleRequest(req, res);<br/>    } <br/>});</span></pre><p id="a0d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先导入<strong class="jj hv"> http </strong>和<strong class="jj hv"> url </strong>模块。这些模块都是NodeJS自己提供的。</p><p id="dd1b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">http 模块能够创建web应用程序。它支持客户端和服务器操作。</p><p id="369a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> url </strong>模块帮助解析url</p><p id="7929" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">行<code class="eh li lj lk ll b">http.createServer((req, res) =&gt; {</code>表示需要创建一个http服务器，其中<strong class="jj hv">请求作为req，响应作为res </strong></p><p id="2067" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> module.exports </strong>用于将该文件导出为一个模块。这就是为什么我们可以使用<code class="eh li lj lk ll b">const server = require('./controller.js');</code>在<strong class="jj hv"> server.js </strong>中导入<strong class="jj hv"> controller.js </strong></p><p id="de9c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以看出这个文件需要<strong class="jj hv"> service.js </strong>这个我们后面会讲到。</p><p id="dffb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">代码<code class="eh li lj lk ll b">const reqUrl = url.parse(req.url, true);</code>获取请求url并解析它，这样我们就可以在上面运行一些url函数。</p><p id="9f50" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们要创建的第一个端点是一个端点url为<strong class="jj hv"> /sample </strong>的<strong class="jj hv"> GET </strong>端点</p><p id="db60" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了进行url路由，我们将使用<strong class="jj hv">如果其他条件</strong></p><p id="290b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">行<code class="eh li lj lk ll b">if (reqUrl.pathname == '/sample' &amp;&amp; req.method === 'GET') {</code>检查被请求的url是否是<strong class="jj hv"> /sample </strong>，还检查请求类型是否是<strong class="jj hv"> GET </strong></p><p id="8ba0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个get请求的逻辑存在于<strong class="jj hv"> service.sampleRequest(req，res)中；</strong>是<strong class="jj hv"> service.js </strong>中定义的功能</p><h1 id="4293" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">服务网</h1><p id="550b" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">这是实际的api逻辑将出现的地方。创建一个名为<strong class="jj hv"> service.js </strong>的文件。</p><p id="0e94" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将以下代码复制到<strong class="jj hv"> service.js </strong>中</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="f325" class="lu kg hu ll b fv lv lw l lx ly"><strong class="ll hv">const</strong> url <strong class="ll hv">=</strong> require('url');</span><span id="6263" class="lu kg hu ll b fv lz lw l lx ly">exports.sampleRequest <strong class="ll hv">=</strong> <strong class="ll hv">function</strong> (req, res) {<br/>    <strong class="ll hv">const</strong> reqUrl <strong class="ll hv">=</strong> url.parse(req.url, <strong class="ll hv">true</strong>);<br/>    <strong class="ll hv">var</strong> name <strong class="ll hv">=</strong> 'World';<br/>    <strong class="ll hv">if</strong> (reqUrl.query.name) {<br/>        name <strong class="ll hv">=</strong> reqUrl.query.name<br/>    }</span><span id="790b" class="lu kg hu ll b fv lz lw l lx ly">    <strong class="ll hv">var</strong> response <strong class="ll hv">=</strong> {<br/>        "text": "Hello " <strong class="ll hv">+</strong> name<br/>    };</span><span id="66af" class="lu kg hu ll b fv lz lw l lx ly">    res.statusCode <strong class="ll hv">=</strong> 200;<br/>    res.setHeader('Content-Type', 'application/json');<br/>    res.end(JSON.stringify(response));<br/>};</span></pre><p id="b403" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码检查请求URL是否有一个名为<strong class="jj hv"> name </strong>的查询参数，并将它存储在name变量中。如果没有查询参数，则默认为字符串<strong class="jj hv"> World </strong></p><p id="0757" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">响应状态设置为<strong class="jj hv"> 200 </strong>，响应的内容类型为<strong class="jj hv"> JSON </strong>，最后使用<code class="eh li lj lk ll b">res.end(JSON.stringify(response));</code>发回响应</p><p id="37df" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为<strong class="jj hv">响应变量</strong>是一个JSON对象，所以我们在发回http响应之前，对它使用<strong class="jj hv"> JSON.stringify </strong>将其转换为字符串</p><p id="33d6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们可以使用命令运行应用程序</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="f4c9" class="lu kg hu ll b fv lv lw l lx ly">node server.js</span></pre><h1 id="0e7d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">测试</h1><p id="fa0f" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">为了测试端点，使用<strong class="jj hv"> postman </strong>。你可以从<a class="ae jg" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank">这里</a>下载</p><p id="104a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在postman中选择Get request并输入url为<code class="eh li lj lk ll b">http://localhost:3000/sample?name=aditya</code>然后点击send</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/d48c4f2bbbf7c06e5344299445c9f31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uR6Erv6q7IfouRjw.jpg"/></div></div></figure><p id="9792" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个请求的输出如下所示</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="1782" class="lu kg hu ll b fv lv lw l lx ly">{<br/>    "text": "Hello aditya"<br/>}</span></pre><p id="7ec2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在输入网址为<code class="eh li lj lk ll b">http://localhost:3000/sample</code>并点击发送</p><p id="9145" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个请求的输出如下所示</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="3c13" class="lu kg hu ll b fv lv lw l lx ly">{<br/>    "text": "Hello World"<br/>}</span></pre><h1 id="864c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">第二个API</h1><p id="06aa" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在本节中，我们将构建第二个API，它是一个<strong class="jj hv"> POST </strong>请求。此外，如果用户点击一些随机的网址，我们将需要指出这是一个无效的路线。我们将在这里添加逻辑。</p><h1 id="5191" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">controller.js</h1><p id="a3de" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">将<strong class="jj hv"> controller.js </strong>中的代码更新为如下所示</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="e0d3" class="lu kg hu ll b fv lv lw l lx ly"><strong class="ll hv">const</strong> http <strong class="ll hv">=</strong> require('http');<br/><strong class="ll hv">const</strong> url <strong class="ll hv">=</strong> require('url');</span><span id="cc91" class="lu kg hu ll b fv lz lw l lx ly">module.exports <strong class="ll hv">=</strong> http.createServer((req, res) <strong class="ll hv">=&gt;</strong> {</span><span id="6fba" class="lu kg hu ll b fv lz lw l lx ly">    <strong class="ll hv">var</strong> service <strong class="ll hv">=</strong> require('./service.js');<br/>    <strong class="ll hv">const</strong> reqUrl <strong class="ll hv">=</strong> url.parse(req.url, <strong class="ll hv">true</strong>);</span><span id="52ca" class="lu kg hu ll b fv lz lw l lx ly">    <em class="ma">// GET Endpoint</em><br/>    <strong class="ll hv">if</strong> (reqUrl.pathname <strong class="ll hv">==</strong> '/sample' <strong class="ll hv">&amp;&amp;</strong> req.method <strong class="ll hv">===</strong> 'GET') {<br/>        console.log('Request Type:' <strong class="ll hv">+</strong><br/>            req.method <strong class="ll hv">+</strong> ' Endpoint: ' <strong class="ll hv">+</strong><br/>            reqUrl.pathname);</span><span id="34d0" class="lu kg hu ll b fv lz lw l lx ly">        service.sampleRequest(req, res);</span><span id="a519" class="lu kg hu ll b fv lz lw l lx ly">        <em class="ma">// POST Endpoint</em><br/>    } <strong class="ll hv">else</strong> <strong class="ll hv">if</strong> (reqUrl.pathname <strong class="ll hv">==</strong> '/test' <strong class="ll hv">&amp;&amp;</strong> req.method <strong class="ll hv">===</strong> 'POST') {<br/>        console.log('Request Type:' <strong class="ll hv">+</strong><br/>            req.method <strong class="ll hv">+</strong> ' Endpoint: ' <strong class="ll hv">+</strong><br/>            reqUrl.pathname);</span><span id="4979" class="lu kg hu ll b fv lz lw l lx ly">        service.testRequest(req, res);</span><span id="5b0e" class="lu kg hu ll b fv lz lw l lx ly">    } <strong class="ll hv">else</strong> {<br/>        console.log('Request Type:' <strong class="ll hv">+</strong><br/>            req.method <strong class="ll hv">+</strong> ' Invalid Endpoint: ' <strong class="ll hv">+</strong><br/>            reqUrl.pathname);</span><span id="bc99" class="lu kg hu ll b fv lz lw l lx ly">        service.invalidRequest(req, res);</span><span id="3d47" class="lu kg hu ll b fv lz lw l lx ly">    }<br/>});</span></pre><p id="b3d2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">post端点将拥有url <strong class="jj hv"> /test </strong>。该代码有一个检查<strong class="jj hv">/测试</strong>端点的条件。<strong class="jj hv"> /test </strong>端点的逻辑将在<strong class="jj hv"> service.testRequest(req，res)中；</strong>在<strong class="jj hv"> service.js </strong>中</p><p id="2683" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该代码还有一个针对无效路由的else条件。无效路由的逻辑在<strong class="jj hv"> service.invalidRequest(req，res)中处理；</strong></p><h1 id="fd5d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">服务网</h1><p id="c537" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">将下面这段代码添加到<strong class="jj hv"> service.js </strong>中。不要删除service.js中的现有代码，请将此代码添加到现有代码的下方。</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="86e4" class="lu kg hu ll b fv lv lw l lx ly">exports.testRequest <strong class="ll hv">=</strong> <strong class="ll hv">function</strong> (req, res) {<br/>    body <strong class="ll hv">=</strong> '';</span><span id="c61a" class="lu kg hu ll b fv lz lw l lx ly">    req.on('data', <strong class="ll hv">function</strong> (chunk) {<br/>        body <strong class="ll hv">+=</strong> chunk;<br/>    });</span><span id="7f39" class="lu kg hu ll b fv lz lw l lx ly">    req.on('end', <strong class="ll hv">function</strong> () {</span><span id="a875" class="lu kg hu ll b fv lz lw l lx ly">        postBody <strong class="ll hv">=</strong> JSON.parse(body);</span><span id="d75d" class="lu kg hu ll b fv lz lw l lx ly">        <strong class="ll hv">var</strong> response <strong class="ll hv">=</strong> {<br/>            "text": "Post Request Value is  " <strong class="ll hv">+</strong> postBody.value<br/>        };</span><span id="14d2" class="lu kg hu ll b fv lz lw l lx ly">        res.statusCode <strong class="ll hv">=</strong> 200;<br/>        res.setHeader('Content-Type', 'application/json');<br/>        res.end(JSON.stringify(response));<br/>    });<br/>};</span></pre><p id="d16b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于POST请求，调用端点时会给出一个输入POST主体。</p><p id="78ac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在代码中，我们需要从请求中获取POST主体。</p><p id="53ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面的代码可以做到这一点</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="87a1" class="lu kg hu ll b fv lv lw l lx ly">req.on('data', <strong class="ll hv">function</strong> (chunk) {<br/>    body <strong class="ll hv">+=</strong> chunk;<br/>});</span></pre><p id="94b4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请求以<strong class="jj hv">流</strong>的形式出现。这段代码获取数据流，并不断将其附加到<strong class="jj hv">主体</strong>中。</p><p id="30a4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只有在流式传输完成并且收到完整的<strong class="jj hv"> post主体</strong>后，才会执行<code class="eh li lj lk ll b">req.on('end', function () {</code>。</p><p id="889e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh li lj lk ll b">postBody = JSON.parse(body);</code>这段代码将输入的post主体转换成JSON格式，这样我们就可以使用其中的值。</p><p id="bcab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在代码中，我们使用了<strong class="jj hv">后置体</strong>中的<strong class="jj hv">值</strong>字段。</p><p id="6f92" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">响应的设置类似于我们对GET请求的设置。</p><h1 id="2f5d" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">无效请求的逻辑</h1><p id="a6dc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">将下面这段代码添加到<strong class="jj hv"> service.js </strong>中。不要删除service.js中的现有代码，请将此代码添加到现有代码的下方。</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="aa57" class="lu kg hu ll b fv lv lw l lx ly">exports.invalidRequest <strong class="ll hv">=</strong> <strong class="ll hv">function</strong> (req, res) {<br/>    res.statusCode <strong class="ll hv">=</strong> 404;<br/>    res.setHeader('Content-Type', 'text/plain');<br/>    res.end('Invalid Request');<br/>};</span></pre><p id="48aa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于无效请求，状态设置为<strong class="jj hv"> 404 </strong>，内容类型设置为<strong class="jj hv">文本</strong>。发回的实际内容是<strong class="jj hv">无效请求</strong></p><h1 id="3f4e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">测试</h1><p id="d6d0" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">去找邮递员。选择请求类型为<strong class="jj hv">帖子</strong>，并键入以下url <code class="eh li lj lk ll b"><a class="ae jg" href="http://localhost:3000/test." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/test</a></code> <a class="ae jg" href="http://localhost:3000/test." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mc"><img src="../Images/20be79e114f83c737569d5161076319f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XJQx1MtoVzW19DUF.jpg"/></div></div></figure><p id="cb03" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同时选择<strong class="jj hv">主体</strong>、<strong class="jj hv">原始</strong>和<strong class="jj hv">应用/json </strong>，如图所示</p><p id="7d7f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">输入贴体如下所示</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="a3f2" class="lu kg hu ll b fv lv lw l lx ly">{<br/>	"value" : "nodejs"<br/>}</span></pre><p id="93a7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">点击邮递员发送</p><p id="c937" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">API输出如下所示</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="d28f" class="lu kg hu ll b fv lv lw l lx ly">{<br/>    "text": "Post Request Value is  nodejs"<br/>}</span></pre><p id="c8db" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您也可以尝试使用无效的请求。在postman中选择<strong class="jj hv"> GET </strong>并输入url为<code class="eh li lj lk ll b"><a class="ae jg" href="http://localhost:3000/test123" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/test123</a></code></p><p id="3d0a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对此的响应将是<strong class="jj hv">无效文本</strong></p><h1 id="ed10" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">祝贺😄</h1><p id="be20" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">您现在知道了如何在NodeJS中创建REST API，而无需使用任何框架或外部库😄</p><p id="55ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">在实际项目中，尽可能使用框架或库，以使开发周期更容易、更快</strong></p><h1 id="8036" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">关于作者</h1><p id="8f94" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我热爱技术，关注该领域的进步。我也喜欢用我的技术知识帮助别人。</p><p id="9779" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请随时联系我的LinkedIn账户<a class="ae jg" href="https://www.linkedin.com/in/aditya1811/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/aditya1811/</a></p><p id="f09e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你也可以在推特上关注我<a class="ae jg" href="https://twitter.com/adityasridhar18" rel="noopener ugc nofollow" target="_blank">https://twitter.com/adityasridhar18</a></p><p id="6d2b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的网站:<a class="ae jg" href="https://adityasridhar.com/" rel="noopener ugc nofollow" target="_blank">https://adityasridhar.com/</a></p><h1 id="7169" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">我的其他帖子</h1><p id="7ce1" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated"><a class="ae jg" href="https://medium.freecodecamp.org/what-is-git-and-how-to-use-it-c341b049ae61" rel="noopener ugc nofollow" target="_blank">Git简介</a></p><p id="7435" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://medium.freecodecamp.org/how-to-use-git-efficiently-54320a236369" rel="noopener ugc nofollow" target="_blank">如何高效使用Git</a></p><p id="9221" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" rel="noopener" href="/swlh/how-did-that-weird-bug-come-in-the-code-70111ee1480b">代码中那个奇怪的bug是怎么来的</a></p></div><div class="ab cl md me hc mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hn ho hp hq hr"><p id="a9a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="ma">原载于</em><a class="ae jg" href="https://adityasridhar.com/posts/how-to-use-nodejs-without-frameworks-and-external-libraries" rel="noopener ugc nofollow" target="_blank"><em class="ma">adityasridhar.com</em></a><em class="ma">。</em></p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure></div></div>    
</body>
</html>