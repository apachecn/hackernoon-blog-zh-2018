<html>
<head>
<title>Easiest Way to Build a GraphQL Server from Scratch using Express- (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express从头构建GraphQL服务器的最简单方法-(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-graphql-server-from-scratch-using-express-part-1-304341f9adba?source=collection_archive---------1-----------------------#2018-11-13">https://medium.com/hackernoon/build-a-graphql-server-from-scratch-using-express-part-1-304341f9adba?source=collection_archive---------1-----------------------#2018-11-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ed9daae41d287809b68684053a40fdf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zx_NMu8pRkZ0NrnAfo0Lvg.jpeg"/></div></div></figure><p id="0a78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以说，GraphQL是为前端获取或呈现数据，甚至为后端存储和更新数据的最流行的约定之一。嗯，Rest-API也是GraphQL的一个替代方案，但是使用Rest-API约定有很多缺点。</p><p id="5a1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不会深入探究GraphQL和Rest-API之间的区别，因为这个主题是关于构建一个GraphQL服务器的。</p><p id="16fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将制作一个GraphQL服务器，并将使用Express来托管我们的服务器，其余的将使用GraphQL来操作。</p><p id="f840" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先<strong class="je hv">打开你的终端</strong>并确保你的机器上安装了Nodejs。您可以使用node -v或npm - v命令进行交叉检查，这将显示node的工作版本。</p><p id="c8d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用命令<strong class="je hv"> mkdir </strong>创建一个名为<strong class="je hv"> gserver </strong>的目录，然后将cd放入gserver文件夹。</p><p id="3d96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来点击命令NPM init--是的，这将为我们的项目创建一个json包。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ka"><img src="../Images/46f428edfa0e1b221ab19b6c22d0d404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vf2UzTAxrmMhD_I2MZDiQ.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Building up the Package.json</figcaption></figure><p id="2845" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一步是将<strong class="je hv"> Express </strong>添加到我们的项目中，因此运行<strong class="je hv"> npm install express - save </strong>，</p><p id="7009" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在代码编辑器中创建一个名为server.js 的<strong class="je hv">新文件。这是我们的服务器将要执行的主文件，所以请访问<strong class="je hv"> package.json </strong>并更改</strong></p><p id="0242" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">“main”:“index . js”到“main”:“server . js”。</strong></p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff kj"><img src="../Images/064015b26fae37d749a44d39143a2f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*zFXktsILKs1d2my86z2J2A.jpeg"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">renaming index.js to server.js</figcaption></figure><p id="216b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开server.js文件夹，键入以下代码:</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/8922354df8572be5596fbbbda5bb3780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spqogOD_pbFvHXO0QKc3OQ.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">starter code</figcaption></figure><p id="d67f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们需要安装2个依赖express-graphql和graphql，因此在您的终端上运行:<strong class="je hv">NPM I express-graph QL graph QL</strong></p><p id="aba6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行我们的express服务器需要express，express-graphql将与graphql和Express进行桥接。</p><p id="483c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用const app = express()创建应用程序的实例；</p><p id="59f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">app.use()像我们传入app.use的任何东西一样充当中间件，函数将充当GraphQL和Express的连接。</p><p id="b0fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">app.use接受两个参数，一个是路由，另一个是将在路由中使用的文件，现在，我们有设置为true的graphql。这是一个基本的代码，你必须为即将开始的项目编写。</p><p id="1a78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">app.listen()用于指示我们的应用程序将在哪个端口上运行。</p><p id="1df2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要运行我们的服务器，运行:node server.js</p><p id="ad8f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们的基本服务器已经准备好运行了，但是你会在你的<strong class="je hv"> localhost: 4000/graphql </strong>上看到一个错误，但是我希望你运行并检查这个错误，因为理解错误会使你成为一个更好的学习者。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kl"><img src="../Images/436a15c26e6fbad39fe46e255b23c66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAdgu2DGMN0_mUBC98DYlA.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">GraphQL middleware doesn't have a schema.</figcaption></figure><p id="69a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您会看到一个错误，指出GraphQL中间件不包含模式文件，所以现在我们必须创建一个模式文件。</p><p id="798e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么这个<strong class="je hv">模式文件</strong>是什么呢？简单地说，模式文件是我们的graphQL将包含的结构，准确地说，它就像一本书的内容或一个项目的索引。</p><p id="90d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们在您的项目文件夹上创建一个文件夹，并在其中创建一个schema.js文件(Schema folder -&gt; schema.js</p><p id="39e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在模式文件中，我们将导入到目前为止的需求表达和GraphQL依赖项。</p><p id="b3f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在schema.js文件中键入代码:</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff km"><img src="../Images/9f48ccff15372a671f6aff21a690b2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1WhQTp2bnzQi3FmTSEFOA.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Schema.js</figcaption></figure><p id="e917" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要太担心我们为什么要把所有的内容都析构到graphql，现在只需要知道我们以后会需要所有这些东西。</p><p id="a932" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们做点别的事情来构建我们的JSON数据服务器，<strong class="je hv"> Json-server </strong>是我们制作一个伪API数据库所需要的依赖项。</p><p id="9aca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以在windows上按ctrl+C，在mac上按command+C，就可以停止终端中当前正在运行的程序。</p><p id="0a4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">添加-&gt; npm安装JSON-服务器-保存</p><p id="5b62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在在gserver文件夹中创建一个db.json文件。</p><p id="73c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在db.json中键入以下代码:-</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kn"><img src="../Images/cffa00177ddf731b0aa343912d8ef96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eD1Yor4VMxdg3wMY-t2ieQ.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">db.json</figcaption></figure><p id="d0fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将有两种类型的领域用户和公司。</p><p id="9d51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">仔细阅读一遍有数据的JSON文件，了解用户和公司的领域。你可以看到用户和公司都有一个id字段，这是最重要的，因为用户或公司的ID可以告诉你所有的细节。</p><p id="2ad8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在用户内部添加了一个<strong class="je hv">“公司id”</strong>字段，这样我们也可以从用户字段本身评估哪个用户在哪个公司工作。</p><p id="5403" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将进一步努力与用户和公司建立关系。</p><p id="2dc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们添加第二台服务器来托管JSON数据库，打开第二台终端并运行命令<strong class="je hv">JSON-server--watch db . JSON .</strong></p><p id="7753" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在您的网络浏览器上访问:<a class="ae ko" href="http://localhost:3000/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/users</a>或公司以查看其字段。</p><p id="c009" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们构建我们的schema.js，打开schema.js并创建用户字段。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kp"><img src="../Images/deedaf474b35b154ae671afd0227c956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQgB4hWAGrQV8Ktan9vu8g.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">user.js</figcaption></figure><p id="ac59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们正在创建一个新的构造函数，将一个名称和一个字段作为对象传递。在字段内部，我们将输入字段及其类型作为对象。</p><p id="1312" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您一定想知道为什么我们在fields对象内部传递一个匿名函数，我们这样做是因为javascript闭包。因为我们将用户链接到公司，也将公司链接到用户，所以我们需要使用As函数来避免错误。</p><p id="7525" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来的工作是创建一个根查询，根查询是查询字段首先被执行的地方，然后根查询将决定把查询传递到哪里。</p><p id="f96f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">示例:</strong> -假设您传递一个查询来查找一个id为“23”的用户，因此该查询将传递给RootQuery，在那里我们有一个称为解析器的东西，解析器将检查将查询传递到哪里，然后它将查询传递给相关的字段，然后执行该字段。</p><p id="9165" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们可以使用fetch()或axios.get()从JSON服务器获取数据，这里我将使用我最喜欢的axios.get()。</p><p id="cbe9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在终端上输入<strong class="je hv"> npm install axios - save来安装axios。</strong></p><p id="5ed9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过在schema.js上键入这一行进行下一次导入:</p><p id="ee39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">const axios = require(' axios ')；</strong></p><p id="605a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在在schema中输入这段代码。用户类型下的js:</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kq"><img src="../Images/f25d86533263faf1589b3e99b4a139bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-rvsCgDASfwPt-ePDlZUA.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">User’s resolver</figcaption></figure><p id="df1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们对RootQuery做了同样的事情，让构造函数传递两个对象作为名称和字段。</p><p id="9ceb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在字段中，我们有user，因为我们将为user创建解析器，在字段中，我们有一个类型:UserType，与构造函数的名称相同。</p><p id="dff3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">args基本上是我们希望查询执行的参数，这里我们希望graphQl查询id。</p><p id="a7cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">之后我们有了主解析器，我们传递了两个参数root和args，在大多数情况下，在RootQuery中，我们不会使用root，但我们必须将它作为一个参数。</p><p id="80d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">之后，我们简单地用axios获取id，因为我们将id作为参数传递。</p><p id="cbf1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，最后，您必须导出RootQuery，因为这是我们的主查询。将此添加到<strong class="je hv"> schema.js </strong>文件的最后:</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kr"><img src="../Images/b8579cefe184d9404f0fbebfc9a146f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uggvSIEzqRjRs2-EeD-eTw.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">module.exports</figcaption></figure><p id="2aa2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要运行，我们必须在server.js中做另一件事，记得当我们第一次尝试运行graphQL服务器时我们得到一个错误，我们得到一个错误，比如中间件的schema missing，它需要将我们刚刚创建的schema导入server.js</p><p id="4274" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将schema文件导入server.js并将schema添加到中间件中，注意:schema在中间件中是区分大小写的，它始终是小写的schema。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ks"><img src="../Images/93be837acf4c21d9b2798908ec47c46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-FHxKNRvrtr7Cop-scd0g.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">importing schema to server.js</figcaption></figure><p id="f858" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们运行我们的GraphQl服务器，在我们的浏览器上再次打开链接:<a class="ae ko" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">http://localhost:4000/graph QL</strong></a><strong class="je hv">。</strong>你会看到GraphQL游乐场即将到来。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kt"><img src="../Images/a4db4836751c457cb11d8e0e24c9068d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3N5YGJpVRhNmMNTbsWqoA.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">GraphQL server</figcaption></figure><p id="c39f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们的GraphQL游乐场，我们可以在这里编写查询。在右边，你可以看到文档浏览器:当我们编写复杂的查询时，它非常有用，它显示了我们字段的总体结构。</p><p id="aa2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">点击RootQueryType，你会看到这个:<strong class="je hv">用户(id: String):用户</strong></p><p id="c21a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们准备运行我们的第一个查询:</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ku"><img src="../Images/207a59e25a1a6d211ce66d0380143705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jd1McCbAj9ZGSR88d4X2Zg.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Query</figcaption></figure><p id="1fc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">左边是我们的查询，右边是我们从查询中获取的数据。我们得到的数据只是一个JSON对象。</p><p id="64c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您得到类似于<strong class="je hv"> user: null </strong>的消息，请再次检查代码或书面查询。</p><p id="dcf0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">哇，仅仅是运行我们的第一个查询就已经是一个很大的任务了，我承认当你第一次输入这个查询时，它看起来很大，但是一旦你输入了你的查询，你会发现一切都是重复的。</p><p id="7cab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来是你的工作，我希望你自己编码的公司字段看用户字段。这和我们将要做的几乎是一样的。</p><p id="ef59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在Github上关注我:-</strong><a class="ae ko" href="https://github.com/sandipguchait" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">https://github.com/sandipguchait</strong></a></p><p id="0c0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是下一部分:</p><div class="kv kw fm fo kx ky"><a rel="noopener follow" target="_blank" href="/@sandip21/easiest-way-to-build-a-graphql-server-from-scratch-using-express-part-2-6758dcd7154"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hv fv z el ld eo ep le er et ht dt translated">使用Express从头构建GraphQL服务器的最简单方法-(第2部分)</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">在上一篇文章中，我们成功地编写了用户字段，并在图形中运行了我们的查询</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">medium.com</p></div></div><div class="lh l"><div class="li l lj lk ll lh lm ja ky"/></div></div></a></div></div></div>    
</body>
</html>