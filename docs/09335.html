<html>
<head>
<title>Using graphqlgen for our cloud stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将graphqlgen用于我们的云堆栈</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-graphqlgen-for-our-cloud-stack-ae30c4b017a1?source=collection_archive---------8-----------------------#2018-11-13">https://medium.com/hackernoon/using-graphqlgen-for-our-cloud-stack-ae30c4b017a1?source=collection_archive---------8-----------------------#2018-11-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="df07" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">TL；灾难恢复— Apollo服务器和类型脚本graphqlgen</h2></div><p id="f565" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Meeshkan，我们为GraphQL模式的JS对象表示编写自己的typescript接口，这被证明是容易出错和费力的。</p><p id="85f4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Prisma 的新<code class="eh kf kg kh ki b"><a class="ae kj" href="https://github.com/prisma/graphqlgen" rel="noopener ugc nofollow" target="_blank">graphqlgen</a></code>包让这个疯狂的过程变得简单，但是如果你还不习惯GraphQL模式，它就像是在一个已经无法理解的堆栈中的另一层不理解。我想花一点时间来分享使用这一新工具的一些重要收获，以防您难以入门:</p><ul class=""><li id="5892" class="kk kl hu jl b jm jn jp jq js km jw kn ka ko ke kp kq kr ks dt translated">Apollo服务器中的解析器实际上是如何工作的。</li><li id="9d83" class="kk kl hu jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks dt translated">为什么<code class="eh kf kg kh ki b">graphqlgen</code>牛逼。</li><li id="ea70" class="kk kl hu jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks dt translated">为什么<em class="ky">永远不要</em>使用prisma类型作为服务器模式的类型。</li><li id="4c9e" class="kk kl hu jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks dt translated">奖金:如何单元您的测试解析器。</li></ul><h1 id="3ce0" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">解析器如何在Apollo服务器中工作</h1><p id="285f" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">在您能够有效地使用<code class="eh kf kg kh ki b">graphqlgen</code>之前，您需要了解解析器在Apollo Server中如何工作的基础知识。</p><p id="fed8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">帮助我寻找解析器的主要事情是了解它们是如何级联的，就像<code class="eh kf kg kh ki b">redux</code>减速器一样。来自Apollo Server的<a class="ae kj" href="https://www.apollographql.com/docs/apollo-server/essentials/data.html" rel="noopener ugc nofollow" target="_blank">文档</a>是一个有益的开始，但是我不太明白所有的事情是如何联系在一起的，我编造了一个糟糕的例子来展示他们试图解决的问题。</p><p id="7ba4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们假设您的模式是:</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="2c34" class="me la hu ki b fv mf mg l mh mi">type User {<br/>  id: ID! @unique<br/>  posts: [Post!]!<br/>}</span><span id="dbe0" class="me la hu ki b fv mj mg l mh mi">type Post {<br/>  id: ID! @unique<br/>  author: User!<br/>}</span><span id="0216" class="me la hu ki b fv mj mg l mh mi">type Query {<br/>  user(id): User<br/>}</span></pre><p id="5cea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">编写解析器的一种(不好的)方式是这样的:</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="5206" class="me la hu ki b fv mf mg l mh mi">export const Query: MyQueryResolverType = {<br/>  user: async (_, { id }, __) =&gt; {<br/>    const user = await getUserFromDatabase(id); // fetch user<br/>    const posts = await getUserPostsFromDatabase(id); // fetch posts<br/>    return {<br/>       ...user,<br/>       posts,<br/>    }<br/>  }<br/>}</span><span id="6369" class="me la hu ki b fv mj mg l mh mi">export const User: MyUserResolverType {<br/>  id: ({ id }, _, __) =&gt; id,<br/>  posts: ({ posts }, _, __) =&gt; posts,<br/>}</span><span id="c366" class="me la hu ki b fv mj mg l mh mi">export const Post: MyPostResolverType {<br/>  id: ( { id }, _, __) =&gt; id,<br/>  author: ({ author }, _, __) =&gt; author,<br/>}</span></pre><p id="7c17" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的代码有很多问题:我们不得不为像<code class="eh kf kg kh ki b">MyQueryResolverType</code>、<code class="eh kf kg kh ki b">MyUserResolverType</code>和<code class="eh kf kg kh ki b">MyPostResolverType</code>这样的解析器编写自己的类型。<code class="eh kf kg kh ki b">graphqlgen</code>将为我们处理这些问题，稍后我们会看到这一点，但目前我们仍受困于这种脆弱性。</p><p id="93c8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一部分的主要问题是<code class="eh kf kg kh ki b">user</code>查询做的工作太少又太多。我们不知道传入的graphql查询是否会要求发布，那么我们为什么要在这里获取它们呢？此外，如果这个人做了如下事情:</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="87d3" class="me la hu ki b fv mf mg l mh mi">{<br/>  user(id) {<br/>    posts {<br/>      author {<br/>        posts {<br/>          author {<br/>            id<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="b404" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">…这将会断开，因为它不会沿树向下递归。所以让我们用合适的解决方案来解决它。</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="b8e0" class="me la hu ki b fv mf mg l mh mi">export const Query: MyQueryResolverType = {<br/>  user: (_, { id }, __) =&gt; getUserFromDatabase(id); // a promise<br/>}</span><span id="3320" class="me la hu ki b fv mj mg l mh mi">export const User: MyUserResolverType {<br/>  id: ({ id }, _, __) =&gt; id,<br/>  posts: ({ id }, _, __) =&gt; getPostsFromUser(id), // a promise<br/>}</span><span id="c205" class="me la hu ki b fv mj mg l mh mi">export const Post: MyPostResolverType {<br/>  id: ({ id }, _, __) =&gt; id,<br/>  author: ({ id }, _, __) =&gt; getUserFromPost(id); // a promise<br/>}</span></pre><p id="8a9c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不会再有破损。ApolloServer沿树向下遍历，根据需要调用正确的解析器。这是因为传递给解析器函数的第一个参数是从上一个解析器返回的对象的表示，我们用它来获取关于对象的重要信息，如<code class="eh kf kg kh ki b">id</code>。在ApolloServer文档中，这个对象被称为<code class="eh kf kg kh ki b">parent</code>，我认为这是一个糟糕的名字选择。我会选择<code class="eh kf kg kh ki b">partial_obj</code>或者<code class="eh kf kg kh ki b">obj_hint</code>或者<code class="eh kf kg kh ki b">obj_with_stuff_missing</code>。</p><h1 id="a8c0" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">为什么<code class="eh kf kg kh ki b">graphqlgen</code>很牛逼</h1><p id="d55f" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">上面这个“好”的例子(至少)有两个讨厌的反模式:解析器类型需要手写，还有像<code class="eh kf kg kh ki b">Post.id</code>这样基本上是身份函数的函数。<code class="eh kf kg kh ki b">graphqlgen</code>修复这个问题。它将自动生成解析器类型的类型脚本接口<em class="ky">和解析器的默认解析器</em>。再见样板！</p><p id="9595" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要使用<code class="eh kf kg kh ki b">graphqlgen</code>，只需在您的根目录中包含一个<code class="eh kf kg kh ki b">graphqlgen.yml</code>文件，然后在您的构建中的某个位置包含<code class="eh kf kg kh ki b">yarn add --dev graphqlgen</code>和<code class="eh kf kg kh ki b">npx graphqlgen</code>来生成商品。在撰写本文时，<code class="eh kf kg kh ki b">graphqlgen.yml</code>文件有六个我们使用的键，所有这些键都是不言自明的:</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="91a1" class="me la hu ki b fv mf mg l mh mi"># The target programming language for the generated code<br/>language: typescript</span><span id="3e84" class="me la hu ki b fv mj mg l mh mi"># The file path pointing to your GraphQL schema<br/>schema: ./src/schema.graphql</span><span id="14b5" class="me la hu ki b fv mj mg l mh mi"># Type definition for the resolver context object<br/># The context object is passed into ApolloServer.<br/># It usually contains stuff like a database connection<br/># or user id or whatever.<br/>context: ./src/types.ts:IContext</span><span id="b27e" class="me la hu ki b fv mj mg l mh mi"># Find TS models that correspond to the graphql schema and map them<br/># NOTE: this part is tricky and is the subject of the next section,<br/># so read on to find out more.<br/>models:<br/>  files:<br/>    - path: path/to/my/resolver/types.ts<br/>      defaultName: 'I${typeName}' # my convention<br/>    - path: path/to/my/generated/prisma/types<br/>      defaultName: '${typeName}Node' # prisma convention</span><span id="4c3b" class="me la hu ki b fv mj mg l mh mi"># Where all of this boilerplate code is written<br/>output: ./src/generated/graphqlgen.ts</span><span id="8f47" class="me la hu ki b fv mj mg l mh mi"># In case you need inspiration for your resolvers, this generates<br/># stubs that you can fill in<br/>resolver-scaffolding:<br/>  output: ./src/generated/tmp-resolvers/<br/>  layout: file-per-type # one file per type in the </span></pre><p id="c2c6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果我们重温之前的例子，事情就变得简单多了:</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="b683" class="me la hu ki b fv mf mg l mh mi">export const Query: QueryResolvers.Type = {<br/>  user: (_, { id }, __) =&gt; getUserFromDatabase(id); // a promise<br/>}</span><span id="d713" class="me la hu ki b fv mj mg l mh mi">export const User: UserResolvers.Type {<br/>  ...UserResolvers.defaultResolvers,<br/>  posts: ({ id }, _, __) =&gt; getPostsFromUser(id), // a promise<br/>}</span><span id="dd34" class="me la hu ki b fv mj mg l mh mi">export const Post: PostResolvers.Type {<br/>  ...PostResolvers.defaultResolvers,<br/>  author: ({ id }, _, __) =&gt; getUserFromPost(id); // a promise<br/>}</span></pre><p id="3822" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所有类型的解析器都在<code class="eh kf kg kh ki b">src/generated/graphqlgen</code>中出现，我们不再需要推出自己的解析器。此外，为每种类型都生成了默认的解析器，因此我们不再需要编写所有的样板文件。太棒了。</p><h1 id="5c7c" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">为什么不应该使用prisma类型作为服务器模式的类型</h1><p id="cc6e" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">Prisma非常有效率。效率如此之高，以至于您只想使用GraphQL和Apollo Server的dispense从客户端ping您的数据库。这相当于直接从网页上读写数据库，简而言之，这是一个非常糟糕的想法。</p><p id="82ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在<code class="eh kf kg kh ki b">graphqlgen</code>已经出现了，以创纪录的速度创建一个Apollo服务器更加方便，在这样做的时候，您可能会尝试使用Prisma生成的接口作为表示模式中类型的接口。这也是个馊主意。例如，假设您的棱镜<code class="eh kf kg kh ki b">datamodel.prisma</code>包含:</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="c677" class="me la hu ki b fv mf mg l mh mi">type UserNode {<br/>  id: ID! @unique<br/>  email: String!<br/>  internalFieldUsedByDevs: String!<br/>  anotherInternalField: String!<br/>}</span></pre><p id="5122" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">鉴于我们的<code class="eh kf kg kh ki b">schema.graphql</code>包含:</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="8c01" class="me la hu ki b fv mf mg l mh mi">type IUserNode {<br/>  id: ID! @unique<br/>  email: String<br/>}</span></pre><p id="76b7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您不希望<code class="eh kf kg kh ki b">internalFieldUsedByDevs</code>和<code class="eh kf kg kh ki b">anotherInternalField</code>被您的客户端访问，您可能不希望与prisma生成的类型相同。更明智的选择是编写自己的类型并使用它。没问题，除了<code class="eh kf kg kh ki b">graphqlgen</code>怎么知道怎么用你的而不是prisma的？让我们回到<code class="eh kf kg kh ki b">graphqlgen.yml</code>。</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="186d" class="me la hu ki b fv mf mg l mh mi">models:<br/>  files:<br/>    - path: path/to/my/resolver/types.ts<br/>      defaultName: 'I${typeName}' # my convention<br/>    - path: path/to/my/generated/prisma/types<br/>      defaultName: '${typeName}Node' # prisma convention</span></pre><p id="9e2f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里，<strong class="jl hv">顺序事项</strong>。<code class="eh kf kg kh ki b">graphqlgen</code>将首先使用<code class="eh kf kg kh ki b">types.ts</code>中的类型，然后尝试从生成的prisma类型中获取它没有找到的任何内容。这样，<code class="eh kf kg kh ki b">Query.me</code>将被正确地记录和类型检查为我们编写的<code class="eh kf kg kh ki b">IUserNode</code>,而不是prisma生成的<code class="eh kf kg kh ki b">UserNode</code>。</p><p id="0764" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然这乍一看似乎微不足道，但是当您的服务器模式和prisma模式开始出现分歧时，您最终会发现您的服务器模式并不是prisma模式的严格子集。因此，将两者分开将变得至关重要，最好尽早养成习惯。</p><h1 id="5bf1" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">额外收获:如何对解析器进行单元测试</h1><p id="9390" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">与<code class="eh kf kg kh ki b">graphqlgen</code>没有任何关系，但是，嘿，既然我们在讨论编写解析器，那就别忘了测试它们！</p><pre class="lw lx ly lz fq ma ki mb mc aw md dt"><span id="a9ce" class="me la hu ki b fv mf mg l mh mi">import * as request from "supertest";<br/>import app from "../../path/to/my/express/app";</span><span id="b26a" class="me la hu ki b fv mj mg l mh mi">const ENDPOINT = "/graphql";</span><span id="e041" class="me la hu ki b fv mj mg l mh mi">test("test hello", async () =&gt; {<br/>  const { text } = await request(app)<br/>      .post(ENDPOINT)<br/>      .send({query: "{ hello }"});<br/>  expect(JSON.parse(text).data.hello).toBe("Hello!");<br/>});</span></pre><p id="4731" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">平淡无奇，我知道，但最干净的东西往往是。因为我在网上找不到任何简洁明了的东西，所以我想把它放在这里。</p><p id="31bf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这假设您已经在服务器的单独文件中设置了一个express应用程序，这样您就不必在每次测试时启动和停止服务器，这可能会导致各种与端口相关的奇怪错误。</p><p id="faa7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在Meeshkan使用Jest，但摩卡或其他任何东西都可以。在某些时候，您将需要模拟您的数据库通信对象(在我们的例子中，是由<code class="eh kf kg kh ki b">prisma generate</code>生成的<code class="eh kf kg kh ki b">prisma</code>实例)，这在这些平台上都非常简单。</p><p id="9fc2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以你有它！几乎没有痛苦的类型检查、默认解析器搭建和单元测试。w00t！</p><figure class="lw lx ly lz fq mm fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff ml"><img src="../Images/a2cf0d1db3947d990d8c6919c3ee502c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1G3EqT6WQ1uQ4BMvIFmTQ.png"/></div></div></figure></div></div>    
</body>
</html>