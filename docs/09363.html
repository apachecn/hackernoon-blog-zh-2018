<html>
<head>
<title>Achieving Blockchain Scalability with Sparse Merkle Trees and Bloom Filters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用稀疏Merkle树和Bloom过滤器实现区块链可扩展性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/achieving-blockchain-scalability-with-sparse-merkle-trees-and-bloom-filters-3b9945f003f?source=collection_archive---------6-----------------------#2018-11-14">https://medium.com/hackernoon/achieving-blockchain-scalability-with-sparse-merkle-trees-and-bloom-filters-3b9945f003f?source=collection_archive---------6-----------------------#2018-11-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8871" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">安德鲁·巴里瑟</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff jr"><img src="../Images/8cad6d9ad9ba0dedf2a6de865563ee06.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*2ZLfmh8Uo21qK0gUEd9YNA.png"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Merkle Trees in Bitcoin</figcaption></figure><p id="e953" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">规模问题是阻碍比特币等区块链技术被广泛采用的主要因素。现有的这些系统根本无法扩展。我们被迫一次又一次地问这个问题，如果为了保持不信任，每个用户都必须验证每笔交易，我们如何才能将无信任范式扩展到数百万甚至数十亿用户？</p><p id="1859" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将阐述我对这个问题的想法，并提出一个包含稀疏Merkle树和Bloom过滤器的系统。它将保留比特币的许多功能，即工作证明和块头确认。但是我提出了一个建议，我希望这个建议可以比当前系统获得10倍或更多的可伸缩性，当前系统依赖于全局状态验证。提高可伸缩性的关键是不需要用所有事务的全局视图来验证任何单个事务的有效性。</p><h2 id="636f" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">稀疏的Merkle树</h2><p id="348a" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">首先，让我介绍稀疏Merkle树。这些是<a class="ae ld" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank"> Merkle树</a>，除了它们在潜在的极端深度只有稀疏的子节点。例如，我们可以想象一棵深度为256的Merkle树。这样的树将有2个⁵⁶叶节点，比可见宇宙中的亚原子粒子数还要多。然而，想象一下，只有这些叶节点的有限子集被填充了数据。其余的是“空的”叶节点。空叶节点的父节点本身是可预测的。整个树是稀疏的，因为只有很少的可用路径被占用。要了解更多信息，请查看我的稀疏Merkle树的<a class="ae ld" href="https://github.com/barisser/smerkle" rel="noopener ugc nofollow" target="_blank"> Python实现</a>(即SMT)。</p><h2 id="9167" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">布隆过滤器</h2><p id="5068" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated"><a class="ae ld" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布隆过滤器</a>是概率数据结构，其允许固定长度的表示来缓存集合中元素的存在。它没有假阴性。诀窍是，它有概率误报。误报率是分配给布隆过滤器的空间量和其中存储的元素数量之间的比率的函数。有计算最佳布鲁姆过滤器结构的公式，你可以在这里找到一个漂亮的计算器<a class="ae ld" href="https://krisives.github.io/bloom-calculator/" rel="noopener ugc nofollow" target="_blank"/>。例如，可以创建具有44比特/存储元素的10^-9假阳性错误率的布隆过滤器。因此，预计存储多达1000个元素的过滤器将消耗44kB的空间，并为任何非成员元素提供0.0000001%的误报概率。</p><p id="d5c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">布隆过滤器通常用于许多不同的应用中。</p><h2 id="05de" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">验证交易的关键要素</h2><p id="231b" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">区块链允许用户独立验证所有交易，而不必信任任何单一实体。我们可以将其归结为完全验证任何一个事务所必需的几个核心操作。</p><ol class=""><li id="818a" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm dt translated">验证所有块标题，并找到块的最长工作证明分支。验证块头建立了真实的规范来源，但是它不验证块内的<strong class="it hv">的一致性；据我们所知，如果我们不进一步观察，这可能是自相矛盾的胡言乱语。</strong></li><li id="36b2" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">验证给定的事务在“内部”是正确的。换句话说，交易从发送方到接收方被正确签名，格式良好，等等。这非常简单，不需要区块链，只需要椭圆曲线加密。这是一个已经解决的问题，但是为了完整起见，我把它包含在这里。</li><li id="c04e" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">验证一个事务在应该发生的时候“发生了”。这可以被重新表述为确认事务是给定块的成员。</li><li id="52e0" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">验证事务没有在其他地方花费<strong class="it hv">，无论是在当前块中，还是在任何先前的块中。如果有人花了未用完的产出给我送比特币，我必须验证同样的未用完的产出是真正未用完的。在比特币中，我通过查看所有交易来实现这一点。通过维护国家的全局视图，我可以排除重复支出。这直接导致了可伸缩性问题。仅仅知道1笔交易是正确的是不够的。我必须知道，其他地方都不正确！因此，我必须检查每个块中的每个事务。</strong></li></ol><p id="dfaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题#1由比特币解决，并在<a class="ae ld" href="https://en.bitcoin.it/wiki/Thin_Client_Security#Thin_Clients" rel="noopener ugc nofollow" target="_blank">瘦比特币客户端</a>中实现。这些仅确认块标题。这些都是非常节省空间和可伸缩的。瘦客户机解决了问题3。因为比特币块头包括交易的Merkle根，所以很容易证明块中交易的成员资格。问题#2不需要区块链解决方案，并且用20世纪70年代的加密技术解决。但是瘦客户机不能解决问题4。即使我可以证明一个有效的事务发生在一个块中，<strong class="it hv">我也不能证明它没有发生在同一个块中的其他地方</strong>，或者在一个先前的块中，仅具有块头信息。</p><p id="21d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题#4是要解决的关键问题。</p><h2 id="5608" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">实现可扩展性</h2><p id="8167" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">既然我已经框定了问题，让我简洁地列出一个可能的解决方案。</p><p id="38cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一种新的加密货币拥有工作证明算法和块头，就像今天的比特币一样。所有参与者自行验证块标题和PoW解决方案。这部分非常容易扩展。</p><p id="7f75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们想象一下，我们的新加密货币由有限数量的不可替代令牌组成。每枚硬币都有标签和历史，而不是捆绑和重新洗牌。可能有一些方案来创建抽象在不可替换令牌之上的可替换令牌，但这与我们的讨论无关。</p><p id="16b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在每个街区，我们做不同的事情。我们添加两个数据结构。首先，我们添加一个稀疏Merkle树(SMT)。利用SMT，我们证明<strong class="it hv">的会员资格</strong>的交易。SMT中的每一片叶子代表一个不可替换硬币的地址。这可以简单地认为是一个唯一的二进制数，表示从Merkle根到叶节点的左右顺序。我们创建一个语义规则。关于ID=N的给定不可替换令牌的任何事务必须在块中的SMT的叶节点N上发布。可以忽略不正确叶节点位置的任何事务。</p><p id="2a94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SMT的使用为我们的系统提供了一个很好的特性；对于任何给定的块和任何给定的令牌，只有一个地方可以发生消费交易。因此，我只需要在每个块的一个地方寻找；不，其他地方都有效。</p><p id="7e70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用SMT证明成员资格是相当简单的，今天可以很容易地做到。困难的部分是证明自己不是所有其他集团的成员。</p><p id="26fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输入布隆过滤器。</p><p id="a019" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个块还具有某个长度M的布隆过滤器，其可以包含最多N个元素，并且误报率为p。布隆过滤器的目的是验证块中是否存在事务。所以我们创建了一个新规则。为了使交易有效，我们采取以下步骤:</p><ol class=""><li id="2821" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm dt translated">签署从发送者A向接收者b发送令牌T的交易</li><li id="db51" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">将leaf_node_position=T的事务H的散列提交给矿工。</li><li id="83d1" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">挖掘器将散列(H)包括在SMT中的叶节点位置t处的block=Q处。块中列出了每个叶节点。</li><li id="21ae" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">发送者查看块Q中的SMT，并计算从他们的事务散列到Merkle根的Merkle路径。他们确认这是正确构建的。然后，发送方<strong class="it hv">丢弃</strong>该块的SMT数据，仅保留报头数据(仅包括SMT根)。</li><li id="15dc" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">在块Q+1，发送者向矿工提交第二个项目。它们产生以下级联项目的确定性签名:事务散列、token_id、来自块q的Merkle根。该签名被散列并被提交给挖掘器以包含在布隆过滤器中。</li><li id="b6be" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">发送者现在有了交易证明。来自块Q的SMT Merkle路径和来自块Q+1的Bloom滤波器。这些被转发给令牌接收者以进行离线验证，以及底层交易本身。发送方还创建确定性签名，因为它们<strong class="it hv">对于所有先前的块&lt; Q+1将已经存在</strong>，并将这些签名转发给接收方。</li><li id="0467" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">令牌接收器验证所有块报头。然后他们验证交易的内部正确性。然后，它们在正确的叶节点位置t验证来自块Q的SMT中的事务散列的成员资格。这仅涉及验证所提供的Merkle路径。</li><li id="8483" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">在块Q+1，接收者需要确认正确的签名存在于布隆过滤器中。他们验证所提供的Q+1签名是正确的。然后，他们在Q+1验证布隆过滤器中签名的成员资格。</li><li id="38ab" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm dt translated">最后，必须验证前面块中的非成员。发送者已经发送了块&lt; Q+1中所有布隆过滤器的所有先前块<q the="" receiver="" verifies="" these="" signatures.="" then="" he="" that="" they="" are="" class="it hv">而非成员的每个追溯数字签名。</q></li></ol><p id="a83d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于Bloom Filter中Q+1块处的签名的成员资格是事务有效所必需的，因此它在前面的块中不存在意味着它从未被花费！我相信这巧妙地避开了非会员问题#4 <strong class="it hv">而不需要</strong>维护所有交易的全局视图。</p><h2 id="5ac2" class="kd ke hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">问题和答案</h2><p id="165f" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">问:如果矿工没有如实公布正确的SMT怎么办？</p><p id="93f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答:事务发送者只需要在正确的叶节点验证他们自己的Merkle路径。如果剩下的是胡言乱语也没关系。任何人都无法证实。</p><p id="199f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果发送方提交了一个事务，但它没有包含在SMT中，或者SMT构造出现了任何问题，则不会丢失任何东西，发送方可以稍后再试。这就是为什么SMT构造和布隆过滤器签名添加在不同的块中。前者出了问题可以忽略，后者不可以！</p><p id="b8e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:如果矿工没有如实公布正确的布隆过滤器怎么办？</p><p id="a476" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答:这个比较棘手。我们必须添加约束。布隆过滤器必须具有不超过N个元素，其中N是每个块固定的某个数字。这可以通过断言填充位数不超过某个数来验证。</p><p id="64ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个攻击媒介是挖掘者恶意地将事务签名添加到块布隆过滤器，其中事务从未真正被花费。这将使交易<strong class="it hv">对验证者来说看起来</strong>已花费，因此实际上是不可用的。这就是为什么我引入了确定性签名的概念，它包括在块的Merkle根之前的<strong class="it hv">。在不知道发件人地址的私钥的情况下，这些签名是无法伪造的，因为在发布时，发件人地址的私钥是未知的。通过包含对前面Merkle根的引用，它们仅对引用已知SMT Merkle路径证明的块有效，并且不能在Merkle路径不适用的分叉分支上使用。</strong></p><p id="464f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在将数字签名添加到布隆过滤器之前，不允许矿工预测数字签名的值是必要的，因为他们可能会恶意地将数字签名包含在错误的块中。这就是为什么在签名中使用一个秘密是必要的，这个秘密稍后会被披露。如果提前知道，就不行了。</p><p id="4be5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，数字签名包括对适当SMT的引用，使得签名不能在cousin或其他块中重复使用。</p><p id="16a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:为什么SMT和布隆过滤器都是必要的？</p><p id="e360" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答:每一个都给了我们不同的东西。SMT允许我们将任何数据附加到具有相关ID号的特定叶子下的特定块。布隆过滤器允许我们检查所有块的检查器预先知道的元素的存在和不存在。</p><p id="035d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:这是如何实现区块链可扩展性的？</p><p id="89bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的建议中，木块由三块组成</p><ul class=""><li id="8eb4" class="le lf hu it b iu iv iy iz jc lg jg lh jk li jo ls lk ll lm dt translated">一个短的块头，包括SMT Merkle根</li><li id="bec6" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo ls lk ll lm dt translated">长布隆过滤器</li><li id="71d7" class="le lf hu it b iu ln iy lo jc lp jg lq jk lr jo ls lk ll lm dt translated">SMT的所有被占用的叶子(仅哈希)</li></ul><p id="4ac9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">验证者只需要存储块头和布隆过滤器。SMT leaves仅适用于<strong class="it hv">发送方。</strong>他们使用SMT leaves来计算自己的Merkle路径，然后可能会丢弃SMT数据。换句话说，SMT数据对于发送方来说只是暂时需要的，他们可能只存储该数据的一小部分。</p><p id="916a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个公式将允许每个块有更多的事务。在10^-9的假阳性率下，1mB布隆过滤器可以存储大约200，000个元素。块头信息非常小。SMT数据虽然更大(64字节乘以元素数)，但可以很快被丢弃，并且在发送者计算出它们的(各自短得多的)Merkle路径之后，不需要任何人存储。因此，SMT数据大小可以打折扣。</p><p id="8e4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果每个块有200，000个元素，那么每1mB块实际上有200，000个事务。目前，比特币每个相同大小的区块只能管理3000到4000个最大交易。因此，对于相同的保留数据量，如果我的提议正确，它提供的容量将是现在比特币的50-70倍。</p><p id="272b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:布隆过滤器的误报怎么办？</p><p id="70eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答:布隆过滤器有一个假阳性概率。因此，在任何时候，未用完的交易都可能出现用完，这完全是偶然的，并且实际上毁坏了硬币。我们可以以可伸缩性为代价来控制这个速率。</p><p id="bad3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们使用p的假阳性率，我们发现:</p><p id="5200" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随机硬币衰变的概率= 1-(1–p)^ n</p><p id="1287" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中N是块数。</p><p id="68b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在p = 10^-9(正如我在上面的例子中使用的200，000个事务/块)和每个块10分钟的情况下，我们发现</p><p id="19cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">1-(1–10**-9)**(144*365*100) = 0.00524</p><p id="b203" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着我们可以实现每10分钟200，000次交易，并且每100年随机损失0.524%的硬币。</p><p id="23b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们选择p = 10^-12，则每1mB数据块有140，000个事务，每100年损失0.000525%。</p><p id="a3ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对我来说，这似乎是一个很好的权衡。</p><p id="5f6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:这不会给接收器带来大量计算负担吗？转移样张不是挺大的吗？</p><p id="bad6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答:这个方案无疑将更多的负担转移到发送方和接收方，以从相对稀疏的块数据中构造和验证证明。我相信计算量是可以控制的。</p><p id="8836" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:这个数字签名的公式有多可靠？有没有其他方法？</p><p id="f139" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答:这部分不是超级扎实，要复习。我没有描述确定性签名构造的细节，但是这可以用大素数上的模运算来完成。</p><p id="0a57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:提供/确认/检查Q-1数字签名和布隆过滤器是不是很繁琐？</p><p id="f3bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是的，这部分很乏味。它也许可以改进。然而，这是客户端计算，比全球区块链数据便宜得多。</p><p id="48bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:这经过审查了吗？</p><p id="3e92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">答:没有！请用建设性的反馈和批判性的审视来帮助我。有可能我错过了什么…我只是不确定是什么。</p><p id="f2eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问:以前有没有想过这个问题？</p><p id="b469" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不确定。很多这样的概念已经存在:SMT，瘦客户机，bloom filters。但我不知道有这样的提法。</p><p id="cb03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总之，我提出了一个新的区块链公式，它似乎比几乎所有区块链实现所采用的“全局视图”模型提供了显著改进的可伸缩性。它链接了两个关键的数据结构，SMT和Bloom Filters来证明成员和非成员。它还对验证中的硬币衰减和客户端计算进行了折衷，这使得提高数据可伸缩性成为可能。本质上，繁重的工作被委托给发送方和接收方，仅利用区块链中节省空间的“锚”进行验证。</p><p id="24d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的提议还没有被仔细审查，如果能得到评论、反馈和仔细的审查，我将不胜感激。</p><p id="61eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关注我的<a class="ae ld" href="https://twitter.com/abarisser" rel="noopener ugc nofollow" target="_blank"> @abarisser </a>了解更多…</p></div></div>    
</body>
</html>