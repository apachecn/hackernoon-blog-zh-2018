<html>
<head>
<title>Complete Guide to Unit Testing Durable Functions with VS Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用VS代码测试持久函数的完整指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/complete-guide-to-unit-testing-durable-functions-with-vs-code-46d343789c75?source=collection_archive---------0-----------------------#2018-11-15">https://medium.com/hackernoon/complete-guide-to-unit-testing-durable-functions-with-vs-code-46d343789c75?source=collection_archive---------0-----------------------#2018-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="348b" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">依赖注入、代码覆盖、调试等等</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/77d2f73bd566df7ce13f03d0288bd7c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RNsWU6QnZc8DyeKOjSlvg.png"/></div></div></figure><p id="a545" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我喜欢VS代码。我也喜欢Azure耐用功能。单元测试是非常美妙的。把它们放在一起，你会得到…一些未知的领域。</p><p id="0e76" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">大多数。NET Core 2单元测试原则适用于持久函数，但是还有一些补充。尤其是当您只运行Visual Studio代码时。这应该可以让您从以下内容开始:</p><ul class=""><li id="3044" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq kw kx ky kz dt translated">项目设置</li><li id="7bc5" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">包和扩展</li><li id="a2e1" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">依赖注入和Azure函数</li><li id="80a2" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">测试持久功能</li><li id="d2d6" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">运行测试</li><li id="891b" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">代码覆盖率</li><li id="195a" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">调试单元测试</li></ul><h1 id="1bf2" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">项目设置</h1><p id="8e17" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">。NET单元测试应该在他们自己的目录下，有他们自己的项目，都是整个解决方案的一部分。假设您已经在<code class="eh mc md me mf b">src</code>目录中测试了一些代码，按照以下步骤设置您的测试目录:</p><ol class=""><li id="039d" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq mg kx ky kz dt translated">创建一个新目录来存放单元测试。<code class="eh mc md me mf b">test</code>大概是个好名字。</li><li id="a209" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq mg kx ky kz dt translated">创建一个单元测试项目<br/> a .移动到测试目录<br/> b .运行<code class="eh mc md me mf b">dotnet new mstest</code>(使用MSTest创建一个新的单元测试项目)你也可以通过<code class="eh mc md me mf b">NUnit</code>或者<code class="eh mc md me mf b">xUnit</code>。<br/> c .将主项目添加到该测试项目- <code class="eh mc md me mf b">dotnet add reference ../src/MyProject.csproj</code></li><li id="6afb" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq mg kx ky kz dt translated">移回根目录，并将单元测试项目添加到解决方案中— <code class="eh mc md me mf b">dotnet sln add test/MyProject.Tests.csproj</code></li></ol><h1 id="3a3a" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">包和扩展</h1><p id="9ee7" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">您需要将下面的包安装到<strong class="jx hv">单元测试</strong>项目中。</p><ul class=""><li id="4cf2" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq kw kx ky kz dt translated"><a class="ae mh" href="https://www.nuget.org/packages/moq/" rel="noopener ugc nofollow" target="_blank">最小起订量</a> —用于嘲讽和揶揄。</li><li id="9c72" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated"><a class="ae mh" href="https://www.nuget.org/packages/coverlet.msbuild/" rel="noopener ugc nofollow" target="_blank">封面</a> —用于跨平台代码覆盖</li></ul><p id="cb8f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还推荐以下VS代码扩展:</p><ul class=""><li id="2351" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq kw kx ky kz dt translated"><a class="ae mh" href="https://marketplace.visualstudio.com/items?itemName=formulahendry.dotnet-test-explorer&amp;WT.mc_id=-blog-scottha" rel="noopener ugc nofollow" target="_blank">。NET Core测试浏览器</a>——一个运行测试的UI</li><li id="645e" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated"><a class="ae mh" href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters&amp;WT.mc_id=-blog-scottha" rel="noopener ugc nofollow" target="_blank"> Coverage Gutters </a> —在VS代码中显示被覆盖的代码行。</li></ul><h1 id="8fbd" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">依赖注入和Azure函数</h1><p id="1e81" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">由于Azure函数的<code class="eh mc md me mf b">static</code>本质，它们目前不支持依赖注入(DI)。这是一个问题，因为DI对于C#中的单元测试是必不可少的。幸运的是，有一些方法可以实现DI。这是我找到的最简单的。</p><ol class=""><li id="3ef9" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq mg kx ky kz dt translated">安装<a class="ae mh" href="https://www.nuget.org/packages/Willezone.Azure.WebJobs.Extensions.DependencyInjection" rel="noopener ugc nofollow" target="_blank">这个</a>包，它“包含依赖注入的绑定扩展”。</li><li id="f82b" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq mg kx ky kz dt translated">在<strong class="jx hv">主</strong>项目的根目录下创建一个名为<code class="eh mc md me mf b">Startup.cs</code>的文件，内容如下:</li></ol><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="face" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">3.这与普通的。NET Core项目，您可以在启动文件中添加单例引用。</p><p id="13f7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">4.注意<code class="eh mc md me mf b">ConfigureServices</code>是实例化抽象函数或接口的地方。在上面的例子中，我们创建了一个<code class="eh mc md me mf b">ISendGridClient</code>的实例(用于发送电子邮件)。然后我们将它作为单例添加，现在任何时候<code class="eh mc md me mf b">ISendGridClient</code>被<code class="eh mc md me mf b">Inject</code>调用，这个实例都会被传入。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="e86a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">5.现在，单元测试可以像平常一样通过自己的类模拟:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="0c28" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">注意:有一个已知的<a class="ae mh" href="https://github.com/Azure/azure-functions-host/issues/3386#issuecomment-419565714" rel="noopener ugc nofollow" target="_blank">问题</a>会在Azure中抛出错误。根据医生的说法，有一种变通方法对我很有效。放这个<a class="ae mh" href="https://github.com/BorisWilhelms/azure-function-dependency-injection/blob/master/tools/Directory.Build.targets" rel="noopener ugc nofollow" target="_blank">目录。函数应用程序根目录下的Build.target </a>文件。这将复制Azure中丢失的文件。</p><h1 id="708a" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">测试持久功能</h1><p id="b2bb" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">持久函数在C#世界中是非常独特的。所以应该预料到测试它们也是非常独特的。当然，持久函数项目中的任何普通函数都可以像普通函数一样进行测试。对于那些特定于持久功能的，请遵循以下步骤。更多信息请参见微软的这篇文章。</p><h2 id="9943" class="mk lg hu bd lh ml mm mn ll mo mp mq lp ke mr ms lr ki mt mu lt km mv mw lv mx dt translated">开胃菜</h2><p id="f7af" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">您应该将<code class="eh mc md me mf b">Base</code>添加到<code class="eh mc md me mf b">DurableOrchestrationClient</code>参数中。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="c5b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个<code class="eh mc md me mf b">DurableOrchestrationClientBase</code>类现在可以被模仿，然后直接传递给starter函数。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="68e1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> HTTP启动器</strong></p><p id="f9ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">HTTP启动器有一个<code class="eh mc md me mf b">HttpRequestMessage</code>参数，这个参数不容易被模仿(一点都不)！参见示例<code class="eh mc md me mf b">TestHelper</code>文件，该文件在<a class="ae mh" href="https://gist.github.com/KevinDJones/f9dce0e790ff2784ec3aba4aaf8a8353" rel="noopener ugc nofollow" target="_blank">要点</a>中进行了必要的设置。</p><p id="ab14" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一旦有了<code class="eh mc md me mf b">SetupHttp</code>函数，就可以在这个完整的例子中如下使用它:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><h2 id="45bc" class="mk lg hu bd lh ml mm mn ll mo mp mq lp ke mr ms lr ki mt mu lt km mv mw lv mx dt translated">管弦乐队</h2><p id="0789" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">您应该将<code class="eh mc md me mf b">Base</code>追加到<code class="eh mc md me mf b">DurableOrchestrationContext</code>参数中。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="ec5b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个<code class="eh mc md me mf b">DurableOrchestrationContextBase</code>类现在可以被模仿，然后直接传递给orchestrator函数。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><h2 id="ce58" class="mk lg hu bd lh ml mm mn ll mo mp mq lp ke mr ms lr ki mt mu lt km mv mw lv mx dt translated">活动</h2><p id="1fe2" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">活动可以像其他任何活动一样进行测试。网络功能。您可以像平常一样传递参数，尽管有<code class="eh mc md me mf b">ActivityTrigger</code>装饰器</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="6995" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可以像平常一样直接传入<code class="eh mc md me mf b">MyClass</code>模型。如果你正好在用<code class="eh mc md me mf b">DurableActivityContext</code>而不是直接用模型，像这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="1b57" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">目前没有可以嘲讽的<code class="eh mc md me mf b">Base</code>职业。但这目前在持久函数的<a class="ae mh" href="https://github.com/Azure/azure-functions-durable-extension/pull/494" rel="noopener ugc nofollow" target="_blank">开发分支</a>中。确保<code class="eh mc md me mf b">DurableActivityContext</code>是必需的，你也许可以直接使用模型。如果没有，很难😃。它来了！</p><h1 id="5669" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">运行测试</h1><p id="eac6" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">一旦进入测试目录，<code class="eh mc md me mf b">dotnet test</code>是运行测试最简单的方法。您也可以运行<code class="eh mc md me mf b">dotnet watch test</code>，每次您更改文件时，测试都会重新运行。</p><p id="0a05" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果不喜欢打字，可以用VS代码创建一个任务。打开<code class="eh mc md me mf b">tasks.json</code>并添加以下JSON代码片段。确保将<code class="eh mc md me mf b">MyProject</code>替换为项目的位置。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="0d55" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，您可以打开VS代码命令面板并运行“任务:运行测试任务”</p><h1 id="4062" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">代码覆盖率</h1><p id="8c99" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">代码覆盖率内置于。NET核心，但不能跨平台工作。我们将使用之前安装的床罩包。要运行一个启用了代码覆盖率的测试，您可以运行<code class="eh mc md me mf b">dotnet test /p:CollectCoverage=true</code>。</p><p id="8ad4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们之前安装的Coverage Gutters扩展可以在VS代码中显示被覆盖的行。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff my"><img src="../Images/9cb898ff2b67638dc738515f7234062c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZi0UVaMmPUhpImQ_BYsHw.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Taken from <a class="ae mh" href="https://www.hanselman.com/blog/AutomaticUnitTestingInNETCorePlusCodeCoverageInVisualStudioCode.aspx" rel="noopener ugc nofollow" target="_blank">Scott Hanselman’s</a> Article on Coverage Gutters</figcaption></figure><p id="93bc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这需要特定的文件格式。要创建正确的文件格式，运行这个非常短的命令:</p><p id="aad4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><code class="eh mc md me mf b">dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=lcov /p:CoverletOutput=./lcov.info</code></p><p id="5c15" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这只是告诉dotnet收集覆盖率并以<code class="eh mc md me mf b">lcov</code>格式创建它，这是Coverage Gutters所要求的。然后，您可以使用命令选项板，运行“覆盖率槽:显示覆盖率”或“覆盖率槽:观察”。Watch很酷，因为它会随着测试的增加而自动更新。结合<code class="eh mc md me mf b">dotnet watch test</code>，这一切都很好，而且自动化。</p><h1 id="2c72" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">调试单元测试</h1><p id="24da" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">调试是有趣的，也是必要的。它不能很好地与上面所有有趣的东西一起玩，但它仍然是可行的。</p><p id="2acf" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，您需要一个debug命令来附加到一个进程。打开<code class="eh mc md me mf b">launch.json</code>并添加新配置:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="46aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这将允许您将VS代码调试器附加到任何进程。让我们准备好VS代码。</p><ul class=""><li id="34c3" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq kw kx ky kz dt translated">运行命令<code class="eh mc md me mf b">export VSTEST_HOST_DEBUG=1</code>。这告诉VS代码准备好做一些调试。</li><li id="e388" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">跑<code class="eh mc md me mf b">dotnet test</code></li><li id="1ef5" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">它将等待您附加到进程，而不是运行测试:</li></ul><pre class="jk jl jm jn fq nd mf ne nf aw ng dt"><span id="c52c" class="mk lg hu mf b fv nh ni l nj nk">Host debugging is enabled. Please attach debugger to testhost process to continue.<br/>Process Id: 60143, Name: dotnet</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nl"><img src="../Images/bc4dcc9e6485ebe67be0958deb7d4931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRF33zCpYSXbrgyMj0RLUQ.png"/></div></div></figure><ul class=""><li id="f2a6" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq kw kx ky kz dt translated">从debug选项卡运行您的<code class="eh mc md me mf b">.NET Core Attach</code>命令。选择前面显示的流程ID(在本例中为<code class="eh mc md me mf b">60143</code>)。</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/3521747b90b01e1a0a979c1c78161b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*l0tQFmrWi3UNTRHhmrO_2w.png"/></div></figure><ul class=""><li id="5744" class="kr ks hu jx b jy jz kb kc ke kt ki ku km kv kq kw kx ky kz dt translated">快到了。所有这些都让你联系上了，但是还没有完全进入你的测试。在“调用堆栈”标签中，您应该会看到“<no name="">在断点处暂停”的内容</no></li><li id="98b4" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">单击“在断点处暂停”,现在您可以在调试器中点击“继续”,您应该会被带到您设置的第一个断点处！</li><li id="a139" class="kr ks hu jx b jy la kb lb ke lc ki ld km le kq kw kx ky kz dt translated">当你发现你的问题时，你可以运行<code class="eh mc md me mf b">export VSTEST_HOST_DEBUG=0</code>来恢复正常。</li></ul><h1 id="1f99" class="lf lg hu bd lh li lj lk ll lm ln lo lp ja lq jb lr jd ls je lt jg lu jh lv lw dt translated">结论</h1><p id="505a" class="pw-post-body-paragraph jv jw hu jx b jy lx iv ka kb ly iy kd ke lz kg kh ki ma kk kl km mb ko kp kq hn dt translated">就是这样！希望这对你有所帮助。这有点复杂，但是通过一点点设置，你可以在VS代码中做任何你想做的事情来单元测试持久函数。</p></div></div>    
</body>
</html>