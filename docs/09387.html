<html>
<head>
<title>Similar concepts JavaScript and React Native share with Swift: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类似概念JavaScript和React与Swift的本地共享:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/similar-concepts-javascript-and-react-native-share-with-swift-part-1-2f520accb019?source=collection_archive---------9-----------------------#2018-11-15">https://medium.com/hackernoon/similar-concepts-javascript-and-react-native-share-with-swift-part-1-2f520accb019?source=collection_archive---------9-----------------------#2018-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3bd255eed936f3c2a95b256ae35a0a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kulcPy01OhQaMneRN_iTQQ.png"/></div></div></figure><p id="d515" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在React Native上读到的大多数博客帖子都是从一个JavaScript开发人员的角度来看移动设备的。相反，这将是从一个iOS开发人员的角度来看React Native &amp; JavaScript。</p><p id="3d65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望从iOS &amp; Swift进入React Native的任何其他开发人员会发现这很有用。同样，任何对Swift感兴趣的JS开发人员也会发现这份参考资料很有用。这样做的目的不是为了强调哪种方式更好或更差，而是为了突出相同点和不同点，以便任何其他开发人员可以方便他们学习。</p><p id="5b3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这也不会涵盖<em class="ka">每一个单独的</em>的相似性和差异性。本来我是打算接近那个的(对，对！)，但我走上了写百科全书和从不出版的道路，而不是写博客。相似之处也不会是100%的相似或者100%的不存在，但大部分是。</p><h1 id="8309" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">从JS，到iOS，再回到未来</h1><p id="18ed" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在感觉像是上辈子的时候，我从CS专业毕业后，主要在<a class="ae le" href="https://en.wikipedia.org/wiki/MAMP" rel="noopener ugc nofollow" target="_blank">【MAMP】</a>&amp;<a class="ae le" href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noopener ugc nofollow" target="_blank">阿贾克斯</a>开发了两年。然后从2010年末开始，我几乎只在原生iOS (Objective-C &amp; Swift)和一点点原生Android上工作。直到我决定拓宽我在移动开发各个方面的知识，并在2018年年中加入了<a class="ae le" href="https://highlinebeta.com" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Highline BETA </strong> </a>。</p><p id="d53a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">起初，回到JavaScript就像马蒂·小飞侠回到了1985年毕夫帝国的平行世界。这有点像…我依稀认得这个世界，只是不确定自己在哪里。不是说它不好(不像比夫的帝国)，只是没有什么是有意义的，尽管它和我以前在的世界是一样的。</p><p id="01cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以在第一天，我的Highline BETA工程师同事建议，在深入研究React Native和FRP之前，我应该研究一下JavaScript中的ES6。</p><p id="b395" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于任何不知道ES6的移动开发人员，这里有一个不用谷歌的快速分解:<em class="ka">基本上ECMAScript标准(JS所基于的)很少更新。这包括从1999年到2009年的一个很长的空白和/或犹豫，然后是从2011年到2015年的另一个很长的空白。就好像他们默默地希望JS会消失一样…当它显然不会消失的时候，他们最终想出了如何在不引入跨WWW的突破性变化的情况下发展标准。他们将标准改名为ES6，并在连续几年内自由开创了ES7、ES8、&amp; ES9的先例。</em></p><p id="94fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也许JavaScript中需要习惯的一个核心概念，并不是专门的核心编程概念，而是一个哲学概念，任何事情都可以发生。React Native的价值观之一是它试图标准化这一点——它试图<a class="ae le" href="https://code.fb.com/android/react-native-bringing-modern-web-techniques-to-mobile/" rel="noopener ugc nofollow" target="_blank">标准化一个<em class="ka">练习</em> </a>。我将尝试触及与Swift类似的ES6概念(使用<a class="ae le" href="http://2ality.com/2015/07/favorite-es6-features.html" rel="noopener ugc nofollow" target="_blank"> Axel Rauschmayer的列表</a>作为指南，排名不分先后)，然后我将在后续的博客文章中介绍React Native。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="7d03" class="kb kc hu bd kd ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky dt translated">相似的概念</h1><h2 id="f67c" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">1.箭头功能</h2><p id="69f1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">基本上像<em class="ka">速记语法</em>，但是针对函数。</p><p id="8a07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">声明一个函数，如:</p><p id="e823" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">function foo(param) {}</code></p><p id="28d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相当于在ES6中将函数声明为常量:</p><p id="05e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">const arrowFoo = (param) =&gt; {}</code></p><p id="e59b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">据我所知，arrow函数源于传统JavaScript函数的限制，传统函数阻止您在回调中通过<code class="eh mf mg mh mi b">this</code>访问对象的范围，即所谓的上下文。更复杂的是执行上下文，它适用于作用域而不是上下文，这阻止了被执行的原始函数绑定到不同的执行上下文。</p><p id="465c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它令人困惑，我不想深入解释，因为它会劫持这篇已经很长的博文，但是<a class="ae le" href="http://ryanmorr.com/understanding-scope-and-context-in-javascript" rel="noopener ugc nofollow" target="_blank">这个链接很好地解释了它。</a></p><p id="dff6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">因为Swift是一种支持多线程平台的语言，所以它在执行上下文方面没有同样的问题。但是它仍然通过小心使用它的等价物来维护线程安全。对于Swift版本的</em> <code class="eh mf mg mh mi b">this</code> <em class="ka">，</em> <code class="eh mf mg mh mi b">self</code> <em class="ka">，我们还是要在闭包中使用</em> <code class="eh mf mg mh mi b">[weak self]</code> <em class="ka">来保证可以安全访问。但是这更多的是与安全有关，而不是与任何无法从技术上访问实例方法&amp;属性有关。</em></p><p id="5d63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">此外，因为箭头函数通常返回一个函数(或者更好地解释它，箭头函数是以函数为值的常量)，所以它们在Swift: </em>中将常量 <a class="ae le" rel="noopener" href="/ios-os-x-development/introduction-to-closures-in-swift-3-1d46dfaf8a20"> <em class="ka">声明为闭包</em> </a> <em class="ka">时是相似的</em></p><p id="a653" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">let arrowFoo = (param: ParamType) -&gt; ReturnType</code></p><h2 id="954e" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">2.可变和常量变量</h2><p id="27bc" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">JS曾经有<code class="eh mf mg mh mi b">var</code>，但是现在它已经被弃用了，取而代之的是<code class="eh mf mg mh mi b">let</code>(可重赋值)和<code class="eh mf mg mh mi b">const</code>(可单次赋值)。</p><p id="c7d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">const setOnce = 101</code></p><p id="eb7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">let setWhenever = 202</code></p><p id="e0a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JS的<code class="eh mf mg mh mi b">var</code>和<code class="eh mf mg mh mi b">let</code>之间存在范围差异，虽然这不值得在快速比较的上下文中深入讨论，但还是值得稍微讨论一下。<code class="eh mf mg mh mi b">let</code>默认情况下，变量被限制在声明它们的范围内，无论是函数还是<code class="eh mf mg mh mi b">for</code>循环等等。</p><p id="7980" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka"> Swift的等价物是JS的逆。</em> <code class="eh mf mg mh mi b">let</code> <em class="ka">用于常量，</em> <code class="eh mf mg mh mi b">var</code> <em class="ka">关键字用于可重分配变量:</em></p><p id="bb2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">let setOnce = 101</code></p><p id="2d6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">var setWhenever = 202</code></p><p id="3306" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个微小的区别，但却是一个很难打破的习惯，就像驾驶汽车从左舵驾驶到右舵驾驶一样。</p><p id="7b75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">关于JS的</em> <code class="eh mf mg mh mi b"><em class="ka">let</em></code> <em class="ka">的限定范围，在Swift函数中</em> <code class="eh mf mg mh mi b"><em class="ka">var</em></code> <em class="ka">和</em> <code class="eh mf mg mh mi b"><em class="ka">let</em></code> <em class="ka">都受到范围的限制，或者在闭包中等同于没有在变量前加上</em> <code class="eh mf mg mh mi b"><em class="ka">__block</em></code> <em class="ka">，或者在声明为私有的对象中。</em></p><h2 id="2075" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">3.对象文字</h2><p id="5bf0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在JavaScript中，你从来没有真正能够创建对象，至少在某种意义上，你可以在强类型OOP语言中用类、构造函数等创建对象。JS中的对象默认情况下不从一个对象继承，尽管它们可以使用原型继承来通过工厂模式实现继承，比如<code class="eh mf mg mh mi b">create()</code>。</p><p id="81d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有的对象文字本质上都是键值结构。定义对象时，用冒号将键和值分隔开，例如定义咖啡杯:</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="bf28" class="lr kc hu mi b fv mr ms l mt mu">const CoffeeMug = {<br/>	millileters: 300,<br/>	artworkPath: "./images/coffee-mug-logo.png",<br/>	coffeeType: "espresso",<br/>	onRefill: refill()<br/>}</span></pre><p id="94ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您在对象中所期望的，您可以为属性定义任何类型，包括其他对象、数组或函数。</p><p id="f800" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">在Swift中，这相当于两件事。</em></p><p id="9a19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，定义对象文字在语法和功能上等同于声明一个字典。此外，Swift中的枚举或结构可以用来提供比字典更大的灵活性，而且不需要显式的构造器、获取器或设置器。</p><p id="5771" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">其次，隐式设置一个对象，不需要通过类型推断定义其类型。这从一开始就是JS的一个特性，但是在Swift中，任何被推断的类型都将在其生命周期中保持该类型</em>。<em class="ka">这在Swift中完全有效，如果我们要将它声明为一个字典:</em></p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="43c6" class="lr kc hu mi b fv mr ms l mt mu">let CoffeeMug = [<br/>	"millileters": "300",<br/>	"artworkPath": "./images/coffee-mug-logo.png",<br/>	"coffeeType": "espresso",<br/>	"onRefill": "refill"<br/>]</span></pre><p id="2995" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想将这些值保留为任何类型，你就必须包含类型注释。下面是修改后的版本，将 <code class="eh mf mg mh mi b">millileters</code> <em class="ka">值设置为int，</em> <code class="eh mf mg mh mi b">coffeeType</code> <em class="ka">设置为枚举类型，</em> <code class="eh mf mg mh mi b">refill</code> <em class="ka">设置为闭包:</em></p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="6b3f" class="lr kc hu mi b fv mr ms l mt mu">let refill: () -&gt; () = { /** refill code here… */ }<br/>enum type { case espresso, drip, pourover }</span><span id="a266" class="lr kc hu mi b fv mv ms l mt mu">let CoffeeMug: [String: Any] = [<br/>	"millileters": 300,<br/>	"artworkPath": "./images/coffee-mug-logo.png",<br/>	"coffeeType": type.espresso,<br/>	"onRefill": refill<br/>]</span></pre><h2 id="cec7" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">4.模板文字</h2><p id="4788" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">字符串插值最近在JS中变得可能，消除了向变量追加+字符串的多余需要。</p><p id="3cd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">模板文字是JavaScript的字符串插值所需的语法，由<code class="eh mf mg mh mi b">`${...}`</code>实现。例如，下面的字符串引用了一个人的身体质量指数:</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="4ebb" class="lr kc hu mi b fv mr ms l mt mu">const bmi = weight / height</span><span id="4230" class="lr kc hu mi b fv mv ms l mt mu">const bmiReading = "Your BMI is: `${bmi}`"</span></pre><p id="002f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">Swift中的对应词是:</em></p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="c4b0" class="lr kc hu mi b fv mr ms l mt mu">let bmi = weight / height</span><span id="89b0" class="lr kc hu mi b fv mv ms l mt mu">let bmiReading = "Your BMI is: \(bmi)"</span></pre><h2 id="1507" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">5.模块</h2><p id="86ee" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这是JS鼓励代码模块化重用的一种方式。我不确定模块之前是什么(script标签看起来有点相似，但又有些不同)，但对我来说，这似乎是任何现代编程语言的一个要求。或者，也许我在Swift的世界里呆得太久了，这是理所当然的。</p><p id="2e1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，您可以在它自己的文件中声明和定义一个常量，目的是成为一个外部模块。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="cd3d" class="lr kc hu mi b fv mr ms l mt mu">const ButtonModule = () =&gt; { ... }</span><span id="fbc6" class="lr kc hu mi b fv mv ms l mt mu">export default ButtonModule</span></pre><p id="cc03" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mf mg mh mi b">export</code>关键字也是一种指定内部模块或使用它的其他模块的私有或公共内容的方式。虽然这是你用结构或类得到的那种封装，但是请记住，JS最好的服务是当它没有被塑造成基于类的语言的时候。这就是为什么模块服务于这里的工作，它适合JS！</p><p id="1cfc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">话虽如此，Swift并没有完全相同的功能。如果我们按照我之前的假设运行，模块是JavaScript“鼓励”代码模块化重用的方式，Swift并没有以同样的方式指导您。</em></p><p id="88f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">Swift中最接近的比较是框架，但这并不完全符合JS模块的用途。尽管框架可能很轻，但它们通常是完整的库，而不是单一的抽象。框架也必须显式导入，尽管这是比较的终点。</em></p><p id="caa9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与单一抽象最接近的比较可能是协议。协议定义了行为或外观可能需要什么，而不像结构或类那样存储状态。您创建的任何协议也不必显式导入(除非处理Objective-C，它从C的头文件导入中获得提示)。</p><h2 id="d787" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">6.默认&amp; Rest运算符</h2><p id="cc8d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><strong class="je hv">默认</strong>参数在Swift中有对应的参数。它们的工作方式是一样的，因为调用者可以省略任何带有默认值的参数。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="b55c" class="lr kc hu mi b fv mr ms l mt mu">function find(searchTerm, sort=true) {...}</span><span id="9472" class="lr kc hu mi b fv mv ms l mt mu">//You are able to call this as...<br/>find(“toronto”)</span></pre><p id="4094" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">Swift中的对应词是相同的:</em></p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="53e7" class="lr kc hu mi b fv mr ms l mt mu">func find(_ searchTerm: String, _ sort: Bool=true) -&gt; Bool <br/>{...}</span><span id="a605" class="lr kc hu mi b fv mv ms l mt mu">//You are able to call this as...<br/>find(“toronto”)</span></pre><p id="881e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Rest允许不确定数量的参数。当一个参数被<code class="eh mf mg mh mi b">…</code>前置时，这意味着许多参数已经作为数组传入。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="0b68" class="lr kc hu mi b fv mr ms l mt mu">function outputArgLength(...groupedArguments) {<br/>  return 'output: ' + groupedArguments.length<br/>}</span><span id="0164" class="lr kc hu mi b fv mv ms l mt mu">outputArgLength(2, 4, 6)<br/>//output: 3</span></pre><p id="6992" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更新:</p><p id="36e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">在Swift中，其实有一个和这个等价的叫做Variadic parameters(我只是不太倾向于用它)。语法略有不同，只是将</em> <code class="eh mf mg mh mi b"><em class="ka">…</em></code> <em class="ka">附加到类型上，而不是添加到参数名的前面。</em></p><p id="93f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">请记住，Swift中的参数确实需要类型，因为它是一种强类型语言。虽然这可以采取泛型的形式，而不是原语或对象，但这是这篇博文之外的主题。</em></p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="11bf" class="lr kc hu mi b fv mr ms l mt mu">func outputArgLength(_ groupedArguments: Int...) -&gt; String {<br/>  return "output: \(groupedArguments.count)"<br/>}</span><span id="6f80" class="lr kc hu mi b fv mv ms l mt mu">outputArgLength(2, 4, 6)<br/>//output: 3</span></pre><h2 id="372d" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">7.承诺</h2><p id="b3ef" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">承诺存在的原因很大程度上是我多年前从JS逃到iOS的主要原因——以减轻后来被称为(但最初令人沮丧地被接受)回调地狱的痛苦。</p><p id="5205" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">承诺是异步回调，可以方便地封装用于捕获或继续流。任何返回承诺的东西都为您提供了使用带有<code class="eh mf mg mh mi b">.then</code>(传入成功结果)或<code class="eh mf mg mh mi b">.catch</code>(传入错误)的链接的能力。像这样定义一个承诺:</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="ceee" class="lr kc hu mi b fv mr ms l mt mu">function refill() {<br/>  return new Promise(<br/>    function (resolve, reject) {<br/>	  resolve(result)<br/>	  reject(error)<br/>    }<br/>  )<br/>}</span></pre><p id="1c82" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果随后执行了两个或更多的异步调用(嵌套的承诺等价物)会怎样？很方便，错误会一直传播下去，直到错误被处理:</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="72d0" class="lr kc hu mi b fv mr ms l mt mu">refill()<br/>.then(refillResult =&gt; { <br/>  return requestMoreBeans()<br/>})<br/>.then(moreBeansResult =&gt; {})<br/>.catch(error =&gt; {});</span></pre><p id="fc33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">在Swift中，闭包填补了异步执行功能的空白。一个闭包本身不是异步的，但是这个需要可以用</em><a class="ae le" href="https://developer.apple.com/documentation/dispatch" rel="noopener ugc nofollow" target="_blank"><em class="ka">【GCD】</em></a><em class="ka">来填充。下面是一个如何异步执行闭包的基本例子:</em></p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="74b6" class="lr kc hu mi b fv mr ms l mt mu">DispatchQueue.global().async {<br/>  refill()<br/>  DispatchQueue.main.async {<br/>	//Perform UI related code on the main thread...<br/>  }<br/>}</span></pre><p id="2d28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然在这个实现中也有可能成为回调地狱的牺牲品，但是回调主线程的习惯，以及遵循良好的设计模式和坚实的原则，缓解了这个问题。</p><p id="9d45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka"> GCD本质上是FIFO，但是如果你需要更多地控制你的队列的依赖和状态，以及暂停和取消操作的能力，还有</em><a class="ae le" href="https://developer.apple.com/documentation/foundation/operationqueue" rel="noopener ugc nofollow" target="_blank"><em class="ka">operation queue</em></a><em class="ka">。虽然这听起来可能不太直观，因为OperationQueue在技术上使用GCD，而GCD是一个较低级别的API，所以使用OperationQueue通常是多余的。因为承诺拥有3种状态(待定、已完成、已拒绝)，所以它可能在本质上更符合OperationQueue，但在语法上更类似于较低级别的GCD。</em></p><p id="4cc6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">默认情况下，OperationQueue中的操作在后台线程上执行，这与GCD不同，在GCD中您必须指定这一点。两个GCD &amp; OperationQueue都提供了直接创建线程的抽象(在GCD中，异步和同步的决策留给您)。有了这些抽象，线程管理已经够复杂了，更不用说没有它们了，但它在mobile中是必不可少的。如果你在Swift工作，你会经常使用这两个库或者其中之一。</em></p><h2 id="28ac" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">8.作为返回类型的函数类型</h2><p id="39cf" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这需要值得一提，因为声明返回函数的函数的模式在React &amp; React Native中非常常见。在Swift中可以实现类似的目标，虽然我没有经常使用它，但React的启发可能会成为我下次深入Swift时尝试类似方法的基础。</p><p id="3359" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JavaScript中唯一的区别是，您可以将一个常量声明为一个函数，而无需先定义函数(尽管这可以通过Swift中的闭包来实现，如前所述):</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="8795" class="lr kc hu mi b fv mr ms l mt mu">const refillDone = () =&gt; {<br/>  //do stuff: refill the coffee, then return how long it took...<br/>  return 0<br/>}</span><span id="0c8f" class="lr kc hu mi b fv mv ms l mt mu">function refillToFull(full) {<br/>  return refillDone<br/>}</span></pre><p id="b165" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">在Swift中，这不要与作为参数的闭包混淆，后者在某种程度上允许函数执行作为参数传入的函数。这里的主要区别在于，当一个函数被返回时，调用者决定何时或者是否执行它。然而，闭包是由函数决定执行的。</em></p><p id="53b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">再用我们的</em> <code class="eh mf mg mh mi b">refill</code> <em class="ka">例子。我们将把refill定义为返回函数的函数。它返回的函数将是我们定义的另一个函数，叫做</em> <code class="eh mf mg mh mi b">refillDone</code> <em class="ka">，它返回一个</em> <code class="eh mf mg mh mi b">TimeInterval</code> <em class="ka">表示重新装满咖啡所用的时间:</em></p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="c57d" class="lr kc hu mi b fv mr ms l mt mu">func refillDone() -&gt; TimeInterval {<br/>  //do stuff: refill the coffee, then return how long it took...<br/>  return 0<br/>}</span><span id="044d" class="lr kc hu mi b fv mv ms l mt mu">func refill(toFull full: Bool) -&gt; () -&gt; TimeInterval {<br/>  return refillDone<br/>}</span></pre></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="a80a" class="kb kc hu bd kd ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky dt translated">概念不太相似</h1><h2 id="e7b4" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">1.扩展运算符</h2><p id="a959" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><strong class="je hv"> Spread </strong>作为一个参数遍历数组中的所有元素(图a为参数级的循环)。没有快速的对等物。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="7641" class="lr kc hu mi b fv mr ms l mt mu">function sumArguments(x, y, z) {<br/>  //You are appearing within the scope of the function as arguments...<br/>  return x + y + z<br/>}</span><span id="9deb" class="lr kc hu mi b fv mv ms l mt mu">//You are being passed in as an array...<br/>sumArguments([2, 4, 6])</span></pre><h2 id="13b4" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">2.解构</h2><p id="a047" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">也许更奇怪的JS特性之一。它可以提供模式匹配来暗示变量的设置。最适合用在集合结构中，如数组。</p><p id="c4a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Swift中没有真正的对等物。可能遍历范围的方法是最接近的比较。</p><p id="a4fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据我的理解，假设你从数组中取出第一个、中间和最后一个元素，你可以像下面这样使用析构:</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="a565" class="lr kc hu mi b fv mr ms l mt mu">var arrayToUse = [1, 2, 3, 4, 5]<br/>var [head,, middle,, tail] = arrayToUse<br/>console.log(head, middle, tail)<br/>// 1, 3, 5</span></pre><p id="911b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要析构一个对象，可以使用以下语法(为新变量name和city赋值)，因为如果属性名匹配，则变量名是隐含的:</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="1966" class="lr kc hu mi b fv mr ms l mt mu">var { name, city } = { name: “dwight”, city: “toronto” };<br/>console.log(name);<br/>// "dwight"<br/>console.log(city);<br/>// "toronto"</span></pre><p id="8e66" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Swift开发者特别注意——如果你发现变量声明的方式有任何奇怪之处，你可能会参考析构来寻找答案:<a class="ae le" href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/" rel="noopener ugc nofollow" target="_blank">https://hacks . Mozilla . org/2015/05/es6-in-depth-destructing/</a></p><h2 id="19ae" class="lr kc hu bd kd ls lt lu kh lv lw lx kl jn ly lz kp jr ma mb kt jv mc md kx me dt translated">3.发电机</h2><p id="9a66" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果声明时在函数名前面加上了<code class="eh mf mg mh mi b">*</code>，那么函数就是生成器。</p><p id="1c79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">生成器提供了一种使用next()引用集合中元素的默认方式，非常类似于LinkedList。所以我想如果你使用类似列表的实现，这可能会删除很多样板代码。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="9143" class="lr kc hu mi b fv mr ms l mt mu">function* incrementer() {<br/>  let index = 0<br/>  while(true)<br/>    yield index++<br/>}</span><span id="d018" class="lr kc hu mi b fv mv ms l mt mu">let gen = incrementer()<br/>const first = gen.next().value<br/>const second = gen.next().value</span></pre></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><p id="2350" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在第2部分中，我将采用类似的方法来比较React Native和Swift之间的任何相似之处。</p><p id="3461" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">特别感谢Highline BETA的Rohan和Jeanette审核了本文的准确性和内容，并感谢整个团队在撰写本文之前对我的教育。</em></p></div></div>    
</body>
</html>