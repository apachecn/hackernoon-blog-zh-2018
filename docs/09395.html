<html>
<head>
<title>Slack’n Go: Batch Presence Aware Bot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Slack'n Go:批量在线感知机器人</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/slackn-go-batch-presence-aware-bot-bcea4d7ae672?source=collection_archive---------17-----------------------#2018-11-15">https://medium.com/hackernoon/slackn-go-batch-presence-aware-bot-bcea4d7ae672?source=collection_archive---------17-----------------------#2018-11-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0d0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在<a class="ae jp" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>中创建一个<a class="ae jp" href="https://slack.com/" rel="noopener ugc nofollow" target="_blank"> Slack </a> Bot，它可以感知批量存在变更事件。</p><p id="2ec1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本质上，我们将构建并运行这里给出的示例:<a class="ae jp" href="https://github.com/nlopes/slack/blob/master/examples/connparams/connparams.go" rel="noopener ugc nofollow" target="_blank">https://github . com/nlopes/slack/blob/master/examples/conn params/conn params . go</a>。本教程给出了如何运行它的更详细的操作，这样即使是一个相对较新的人也可以很容易地遵循它。</p><p id="321c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">存在改变事件的一个例子是当聊天组的成员将他们的状态从活动改变为离开。</p><p id="9a9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Slack为他们的API提供了一个<a class="ae jp" href="https://api.slack.com/changelog/2017-06-batch-presence-and-presence-subscriptions" rel="noopener ugc nofollow" target="_blank">更新</a>,通过批量更新来实现更有效的存在变化检测。这与具有大量空闲成员的群组的激增相一致，其中存在的改变可能导致在短时间内对许多事件的昂贵处理，或者以错过一些事件为代价。</p><p id="d862" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本教程中，我们认为Golang已经安装。你也可以参考<a class="ae jp" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">https://golang.org/doc/install</a>的相关内容。</p><p id="6abd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于更清晰的分步活动，我们可以参考<a class="ae jp" href="https://github.com/suekto-andreas/tutorial-go/commits/TUT-001" rel="noopener ugc nofollow" target="_blank">https://github . com/suekto-Andreas/tutorial-go/commits/TUT-001</a>的提交。</p><h1 id="8027" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">如何扩展这个基本代码</h1><p id="fe90" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">通过遵循本教程创建的代码，您可以将其扩展为更复杂的bot，其中一个非常初步的扩展可以发生在创建事件处理程序时。(本教程只是简单的做打印。)</p><p id="5112" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更不用说一旦你生成处理程序和创建一个更复杂的业务流程/用例，照顾面向包的设计，提供自动化单元测试。我个人更喜欢将Go项目视为一个库的概念，而可执行文件被分组在<code class="eh kt ku kv kw b">cmd</code>目录中。</p><h1 id="aea1" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">创建备用令牌</h1><p id="c233" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">首先，我们需要访问API的令牌。请参考以下链接:<a class="ae jp" href="https://get.slack.help/hc/en-us/articles/215770388-Create-and-regenerate-API-tokens" rel="noopener ugc nofollow" target="_blank">https://get . slack . help/HC/en-us/articles/215770388-Create-and-regenerate-API-tokens</a></p><h1 id="dc61" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">获取依赖关系</h1><p id="64fc" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们使用下面的库与Slack通信:<a class="ae jp" href="https://github.com/nlopes/slack" rel="noopener ugc nofollow" target="_blank">https://github.com/nlopes/slack</a>。让我们去得到它，在终端中运行以下命令</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b32e" class="lf jr hu kw b fv lg lh l li lj">$ go get github.com/nlopes/slack</span></pre><h1 id="4e20" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">创建我们的项目目录</h1><p id="5a2b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">为此，我们只需创建一个可执行的命令行，我将它的结构如下:</p><figure class="kx ky kz la fq ll fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/1c2e6ae86931b5649f2d7e314dc6d904.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*6hWTIgA9s5sOzbR8cFjJ5g.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">this tutorial project structure</figcaption></figure><p id="1547" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您的目标是构建一个特定的slack bot项目时，您可能更喜欢这里的层次结构，因为上面的结构是为将更多的教程代码放在1个存储库下而准备的。一个例子是<em class="ls"> batchaware </em>成为根项目目录，而不是<em class="ls"> tutorial-go </em>。</p><h1 id="2e03" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">写代码</h1><p id="896c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们的代码应该是一个简单的主函数。首先，让我们实例化一个Slack对象。将“您的令牌”替换为我们在上一步中创建的令牌。(如果您正在考虑生产代码，请确保这里的令牌以更好的方式提供，而不是硬编码，例如将其作为环境变量。)</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e261" class="lf jr hu kw b fv lg lh l li lj">package main</span><span id="53f0" class="lf jr hu kw b fv lt lh l li lj">import (<br/>   "fmt"<br/>   "log"<br/>   "net/url"<br/>   "os"</span><span id="5edd" class="lf jr hu kw b fv lt lh l li lj">   "github.com/nlopes/slack"<br/>)</span><span id="3d83" class="lf jr hu kw b fv lt lh l li lj">func main() {<br/>    api := slack.New(<br/>        "YOUR TOKEN HERE",<br/>        slack.OptionDebug(true),<br/>        slack.OptionLog(<br/>            log.New(os.Stdout, "slack-bot: ",<br/>            log.Lshortfile|log.LstdFlags)),<br/>    )<br/>}</span></pre><p id="f1d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们要与Slack建立一个RTM(实时消息)连接。这是我们传入的选项参数，它表明我们的Bot已经准备好进行批处理存在感知。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="f43b" class="lf jr hu kw b fv lg lh l li lj">rtm := api.NewRTM(<br/>    slack.RTMOptionConnParams(<br/>        url.Values{"batch_presence_aware": {"1"}}))</span></pre><p id="131c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们开始连接</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="98e5" class="lf jr hu kw b fv lg lh l li lj">go rtm.ManageConnection()</span></pre><p id="4d8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">之后，我们甚至可以通过查看IncomingEvents通道来监听，使用以下for循环</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="b4b6" class="lf jr hu kw b fv lg lh l li lj">for msg := range rtm.IncomingEvents {<br/>    fmt.Print("Event Received: ")<br/>}</span></pre><p id="8ff2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将把hello world发送到我们希望机器人监听的频道。我们使用ConnectedEvent来完成这项工作，这是库的内部事件，而不是Slack事件。在这个事件发生时，我们发送一条消息，指出我们希望机器人监听的相应的松弛信道ID。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="08ac" class="lf jr hu kw b fv lg lh l li lj">for msg := range rtm.IncomingEvents {<br/>    fmt.Print("Event Received: ")</span><span id="4adf" class="lf jr hu kw b fv lt lh l li lj">    switch ev := msg.Data.(type) {<br/>    case *slack.ConnectedEvent:<br/>        fmt.Println("Infos:", ev.Info)<br/>        fmt.Println("Connection counter:", ev.ConnectionCount)<br/>        // Replace ABCDEFGH with your Channel ID<br/>        rtm.SendMessage(<br/>            rtm.NewOutgoingMessage("Hello world", "ABCDEFGH"))</span><span id="215a" class="lf jr hu kw b fv lt lh l li lj">    default:<br/>        // Ignore other events..<br/>        fmt.Printf("Unexpected: %v\n", msg.Data)<br/>  }<br/>}</span></pre><p id="53e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要激活状态更改活动，我们需要首先订阅此活动(自2018年1月起，这是一个强制步骤。)我们将在HelloEvent期间订阅，当Bot成功连接时，这是一个松弛事件。对于这一步，我们需要USER-id，一种简单的检索方法可以通过执行这一步<a class="ae jp" href="https://stackoverflow.com/questions/40940327/what-is-the-simplest-way-to-find-a-slack-team-id-and-a-channel-id/41653047" rel="noopener ugc nofollow" target="_blank">这里</a>来完成。(对于更自动化的方式，下面的<a class="ae jp" href="https://stackoverflow.com/questions/38939233/display-all-online-users-in-a-slack-channel" rel="noopener ugc nofollow" target="_blank">链接</a>可以启发你。)</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="945e" class="lf jr hu kw b fv lg lh l li lj">for msg := range rtm.IncomingEvents {<br/>    fmt.Print("Event Received: ")</span><span id="a484" class="lf jr hu kw b fv lt lh l li lj">    switch ev := msg.Data.(type) {<br/>    case *slack.ConnectedEvent:<br/>        fmt.Println("Infos:", ev.Info)<br/>        fmt.Println("Connection counter:", ev.ConnectionCount)<br/>        // Replace ABCDEFGH with your Channel ID<br/>        rtm.SendMessage(<br/>            rtm.NewOutgoingMessage("Hello world", "ABCDEFGH"))</span><span id="2e9b" class="lf jr hu kw b fv lt lh l li lj">    case *slack.HelloEvent:<br/>        fmt.Printf("Hello: %v\n", ev)<br/>        // Replace USER-ID-N here with your User IDs<br/>        rtm.SendMessage(rtm.NewSubscribeUserPresence([]string{<br/>            "USER-ID-1",<br/>            "USER-ID-2",<br/>        }))</span><span id="0205" class="lf jr hu kw b fv lt lh l li lj">    default:<br/>        // Ignore other events..<br/>        fmt.Printf("Unexpected: %v\n", msg.Data)<br/>    }<br/>}</span></pre><p id="6eb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在所有的设置和完成之后，我们现在应该听听这篇文章中的主要目标，存在改变事件！</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="52fe" class="lf jr hu kw b fv lg lh l li lj">for msg := range rtm.IncomingEvents {<br/>    fmt.Print("Event Received: ")</span><span id="3324" class="lf jr hu kw b fv lt lh l li lj">    switch ev := msg.Data.(type) {<br/>    case *slack.ConnectedEvent:<br/>        fmt.Println("Infos:", ev.Info)<br/>        fmt.Println("Connection counter:", ev.ConnectionCount)<br/>        // Replace ABCDEFGH with your Channel ID<br/>        rtm.SendMessage(<br/>            rtm.NewOutgoingMessage("Hello world", "ABCDEFGH"))</span><span id="d954" class="lf jr hu kw b fv lt lh l li lj">    case *slack.HelloEvent:<br/>        fmt.Printf("Hello: %v\n", ev)<br/>        // Replace USER-ID-N here with your User IDs<br/>        rtm.SendMessage(rtm.NewSubscribeUserPresence([]string{<br/>            "USER-ID-1",<br/>            "USER-ID-2",<br/>        }))<br/>    <br/>    case *slack.PresenceChangeEvent:<br/>       fmt.Printf("Presence Change: %v\n", ev)</span><span id="4dc3" class="lf jr hu kw b fv lt lh l li lj">    default:<br/>        // Ignore other events..<br/>        fmt.Printf("Unexpected: %v\n", msg.Data)<br/>    }<br/>}</span></pre><h1 id="0910" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">运行机器人</h1><p id="a9bb" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">运行bot(给定本教程中的目录结构)</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e784" class="lf jr hu kw b fv lg lh l li lj">$ go run slacktut/batchaware/cmd/batchaware.go</span></pre><p id="645e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，机器人将开始监听空闲信道。尝试让频道中的一个成员改变它的存在(比如从活动到离开。)</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3f63" class="lf jr hu kw b fv lg lh l li lj">switch ev := msg.Data.(type) {<br/>    case *slack.ConnectedEvent:<br/>        fmt.Println("Infos:", ev.Info)<br/>        fmt.Println("Connection counter:", ev.ConnectionCount)<br/>        // Replace ABCDEFGH with your Channel ID<br/>        rtm.SendMessage(<br/>            rtm.NewOutgoingMessage("Hello world", "ABCDEFGH"))</span><span id="f8b8" class="lf jr hu kw b fv lt lh l li lj">case *slack.HelloEvent:<br/>        fmt.Printf("Hello: %v\n", ev)<br/>        // Replace USER-ID-N here with your User IDs<br/>        rtm.SendMessage(rtm.NewSubscribeUserPresence([]string{<br/>            "USER-ID-1",<br/>            "USER-ID-2",<br/>        }))</span><span id="a5c6" class="lf jr hu kw b fv lt lh l li lj">default:<br/>        // Ignore other events..<br/>        fmt.Printf("Unexpected: %v\n", msg.Data)<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>