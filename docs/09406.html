<html>
<head>
<title>Building a dashboard with React &amp; GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React &amp; GraphQL构建仪表板</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-dashboard-with-react-graphql-de4203eee6c9?source=collection_archive---------1-----------------------#2018-11-16">https://medium.com/hackernoon/building-a-dashboard-with-react-graphql-de4203eee6c9?source=collection_archive---------1-----------------------#2018-11-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ae035cbab40ad3cb43456356ab37ab01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyDjHo8jlgDIGMV6NZ5vCw.png"/></div></div></figure><p id="4888" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一名前端开发人员，你不可能在超过一年的时间里不承担构建某种仪表板的任务。今年，它是一个实时仪表板，全天提供实时性能洞察。</p><p id="847b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从技术角度来看，我们只有一个限制；数据必须来自弹性搜索，其余的都是待价而沽。所以，抓住公平贸易，有机的，用爱和茶制造的，让我们开始一次书呆子的冒险…</p><h2 id="9eda" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">概观</h2><p id="d357" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">等等，什么是弹性搜索？简单地说，它是一个RESTful API，位于搜索和分析引擎之上。它的核心是存储您的数据，并提供一种通过查询访问数据的方式。对于这个项目的目的，我们所关心的是要求ES提供一些数据，并返回正确的数据。</p><p id="1e8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">范围:仪表板将由两个计数器、两个十篇文章的列表和一个条形图组成。复制的小部件的变化要么是数据类型，要么是时间范围。</p><p id="52bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使我们的ES查询简单快速地处理，它将只返回一个ID和相关的stat。然后，我们将能够使用这个ID来查询一个更快、更全面的API。</p><h2 id="cb63" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">又一个API</h2><p id="eb7b" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">第一个决定是前端应该直接调用ES还是应该在中间有一个API。API将允许我们管理ES集群上的负载，并创建一个更具可伸缩性的解决方案。想象一下，10多个客户端要求ES运行查询。事情要慢下来，代价很大！</p><p id="b9bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑到这一点，我们现在需要一个API来获取所有必要的数据并缓存响应。一个简单的Node.js应用程序可以为我们实现这一点，但是我们需要通过API将数据暴露给前端。这就是REST vs <a class="ae la" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的另一场争论。我不打算在这里谈论细节，因为网上有大量的<a class="ae la" href="https://philsturgeon.uk/api/2017/01/24/graphql-vs-rest-overview/" rel="noopener ugc nofollow" target="_blank">文章</a>。对我们来说，这提供了一个学习GraphQL的好机会，同时也简化了前端。</p><p id="bc4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">web应用程序完全由来自该API的数据驱动；除了获取数据，还有最小的应用程序状态。通过选择GraphQL并将其与<a class="ae la" href="https://www.apollographql.com/client/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a>配对，我们能够消除对Redux这样的状态管理系统的需求。有了这种结构，我们可以简单地将组件包装在更高阶的组件中，这些组件将注入获取状态(加载、错误、数据)和一些其他有用的功能。</p><h2 id="39eb" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">结构</h2><p id="3d4c" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">概括来说，我们有一个包含三个核心组件的<a class="ae la" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a> web应用程序，每个组件都可以通过Apollo客户端注入数据。Apollo将通过查询一个GraphQL服务器来获取这些数据，该服务器只是从以前对es和另一个API的调用中解析内存中的一些数据。类似下面的内容:</p><figure class="lc ld le lf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lb"><img src="../Images/df883cd5c7abb808f90dee14bfc149eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVb0PSUIKjri6UJlhwjt2A.png"/></div></div></figure><h2 id="7f98" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">API详细信息</h2><p id="b2c8" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">这篇<a class="ae la" href="https://dev-blog.apollodata.com/tutorial-building-a-graphql-server-cddaa023c035" rel="noopener ugc nofollow" target="_blank">教程</a>包含了构建基本GraphQL服务器所需的一切。以此为基础，我们可以直接从es中查询解析数据。</p><p id="4853" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们需要缓存这些数据，然后根据请求对其进行解析。为此，我们有一个名为responses的对象，它每30秒填充一次来自es查询的数据，这在服务器上作为一个连续的进程运行。graphQL解析器只是简单地返回响应</p><p id="a062" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为额外的，我还添加了订阅，这允许web应用程序最初通过查询获得所需的数据，然后只订阅任何数据更改。这节省了每个组件每30秒重新获取数据的时间，减少了每次发送全新响应的次数，并确保了一切同步。这也意味着直到上图中的REST部分都是实时的，这给了我们调整其他API调用的选项，使数据尽可能接近实时。</p><h2 id="12c3" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated">Web应用程序详细信息</h2><p id="967c" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我们正在使用React构建我们的视图，并用我之前制作的样板文件引导它，更多细节<a class="ae la" rel="noopener" href="/@mitchclay0/creating-a-react-boilerplate-53f4a540f380">在这里</a>。然而，我们如上所述移除了Redux，并添加了类型检查流程，以确保代码质量。</p><p id="220f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">仪表板索引页面由多个组件组成，每个组件都可以通过将数据包装在所需的GraphQL高阶组件中来获取自定义数据。</p><h2 id="22b3" class="ka kb hu bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku dt translated"><strong class="ak">部署</strong></h2><p id="8f73" class="pw-post-body-paragraph jc jd hu je b jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv kz jx jy jz hn dt translated">我们正在利用由Jenkins、Docker和AWS支持的持续集成和部署设置。Jenkins允许我们远程构建我们的项目，而Docker确保我们的环境是一致的，并且可以轻松地部署到本地机器上进行测试，以及部署到AWS上进行生产。</p><p id="7350" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过一个已部署的应用程序和API，我们在一个易于扩展的前端和后端架构上创建了一个实时仪表板。</p><figure class="lc ld le lf fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure></div></div>    
</body>
</html>