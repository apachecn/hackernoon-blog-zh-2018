<html>
<head>
<title>JavaScript Decorators: fun with function parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Decorators:函数参数的乐趣</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/playing-around-with-your-standard-run-of-the-mill-javascript-decorator-example-28d0445307e1?source=collection_archive---------6-----------------------#2018-11-17">https://medium.com/hackernoon/playing-around-with-your-standard-run-of-the-mill-javascript-decorator-example-28d0445307e1?source=collection_archive---------6-----------------------#2018-11-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2f838e13dd820f3e31245422179d0c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIJHOxHU9FV2-1R8gVvl2Q.jpeg"/></div></div></figure><p id="b2af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自ES2015 问世以来，JavaScript decorators一直是<a class="ae ka" rel="noopener" href="/google-developers/exploring-es7-decorators-76ecb65fb841">的一种语言特性，但在支持它的JavaScript引擎中，它们在很大程度上仍然是“实验性的”。它们是什么？如果你熟悉Java，你会知道如何通过注释包装方法。要点是:装饰器将一个JavaScript类方法包装在另一个函数中，并由注释调用。</a></p><p id="f053" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将为<a class="ae ka" href="https://github.com/JeffML/JSDeco" rel="noopener ugc nofollow" target="_blank">示例代码</a>使用NodeJS，因此需要几个模块、插件和配置。</p><h1 id="6e1e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">装置</h1><ol class=""><li id="89d7" class="kz la hu je b jf lb jj lc jn ld jr le jv lf jz lg lh li lj dt translated">初始化npm项目</li><li id="96e9" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">安装babel命令行工具；我们将需要这个来传输修饰的方法</li><li id="abd7" class="kz la hu je b jf lk jj ll jn lm jr ln jv lo jz lg lh li lj dt translated">安装传输所需的插件</li></ol><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="c535" class="ly kc hu lu b fv lz ma l mb mc">npm init -y</span><span id="fe7d" class="ly kc hu lu b fv md ma l mb mc">npm install --save babel-cli</span><span id="3859" class="ly kc hu lu b fv md ma l mb mc">npm install --save-dev babel-eslint babel-plugin-transform-decorators-legacy babel-polyfill babel-preset-env babel-register eslint eslint-plugin-node</span></pre><p id="4d83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">4.使用以下设置向您的项目添加一个<code class="eh me mf mg lu b">.babelrc</code>文件:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="dc1e" class="ly kc hu lu b fv lz ma l mb mc">{<br/>  "presets": ["env"],<br/>  "plugins": ["transform-decorators-legacy"]<br/>}</span></pre><p id="24cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">附加说明</strong>:如果你使用VSCode作为编辑器，进入设置，打开实验装饰器，让任何警告消失。</p><p id="5668" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">5.要运行示例代码，请在package.json中添加以下运行目标:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="cdf7" class="ly kc hu lu b fv lz ma l mb mc">"scripts": {<br/>    "start": "babel-node yourdecoratedcode.js --require babel-polyfill"<br/>  },</span></pre><h1 id="bac0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">标准日志示例</h1><p id="e008" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">然后，我将查看无处不在的<code class="eh me mf mg lu b">@log</code>示例，并在稍后对其进行一点调整。这是一个计划香草装饰，你可以找到许多变化。</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="7c19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">评论应该说清楚发生了什么。<code class="eh me mf mg lu b">log</code>函数是decorator，它包装了decorator <code class="eh me mf mg lu b">@log</code>注释后面的类方法。为了使用它，类方法被注释为:</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="6594" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">底部显示为注释的控制台输出来自前面清单的第15行。</p><h1 id="b7e1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用参数名记录日志</h1><p id="1b56" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">经过一点挖掘，我能够<a class="ae ka" href="https://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically" rel="noopener ugc nofollow" target="_blank">找到代码示例</a>，这些代码示例说明了从方法签名中获取参数名的方法。现在让装饰器不仅转储参数值，还转储参数名:</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><h1 id="6b22" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">添加合成参数</h1><p id="26c8" class="pw-post-body-paragraph jc jd hu je b jf lb jh ji jj lc jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz hn dt translated">实际上，您并不局限于给定的参数，而是可以从装饰器内部推断参数值，并将它们传递给包装的方法。这可能看起来有点疯狂，但是我已经在我从事的一个项目中发现了这个特性的用途。</p><p id="7ceb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的decorator要通过参数名 <strong class="je hv"> <em class="mm"> </em> </strong>来推断<em class="mm">传入的参数值。我将让包装函数转储它的参数值，而不是装饰器将字符串转储到控制台。</em></p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="a57d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个装饰器将把调用函数时<code class="eh me mf mg lu b">MyClass.newStuff.isWombat and MyClass.newStuff.sugar</code>中的内容作为参数传递给原始函数:</p><figure class="lp lq lr ls fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="ddc5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">输出是…</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="70d9" class="ly kc hu lu b fv lz ma l mb mc">{ isWombat: true,<br/>  sugar: [ 'in the morning', 'in the evening', 'at suppertime' ] }<br/>{ isWombat: true,<br/>  sugar: [ 'You are my candy, girl', 'and you keep me wanting you' ] }</span></pre><p id="5df6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，那就结束了。代码库可以在这里找到<a class="ae ka" href="https://github.com/JeffML/JSDeco" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>