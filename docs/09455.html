<html>
<head>
<title>Practical smart contract security analysis and exploitation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用智能合约安全性分析与开发</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/practical-smart-contract-security-analysis-and-exploitation-part-1-6c2f2320b0c?source=collection_archive---------3-----------------------#2018-11-19">https://medium.com/hackernoon/practical-smart-contract-security-analysis-and-exploitation-part-1-6c2f2320b0c?source=collection_archive---------3-----------------------#2018-11-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="758c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"><em class="jp">2019年7月6日更新，反映新的命令行语法和功能。</em> </strong></p><p id="0077" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一系列文章中，我将解释如何使用<a class="ae jq" href="https://github.com/ConsenSys/mythril" rel="noopener ugc nofollow" target="_blank"><em class="jp">myth RIL</em></a><em class="jp">来发现部署在以太网上的Solidity代码和智能合约中的安全漏洞。我将介绍基本原理和高级技术，比如验证定制属性、分析多合同系统、检测有效合同中的bug以及自动生成漏洞有效载荷。</em></p><p id="5655" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文是一系列文章中的第一篇，这些文章解释了使用Mythril和开源工具时应该熟悉的核心概念，开源工具被称为“智能契约安全的瑞士军刀”。</p><p id="bae2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于以前从未使用过Mythril的用户，我们通常建议第一步安装它。如果你想遵循本文中的例子，你也应该这样做(如果安装遇到麻烦，你可以在我们的<a class="ae jq" href="https://discord.gg/E3YrVtG" rel="noopener ugc nofollow" target="_blank"> Discord服务器</a>寻求帮助)。在Python 3环境中，它通常应该像运行:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="e540" class="ka kb hu jw b fv kc kd l ke kf">$ pip install mythril</span></pre><p id="b8ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">成功安装后,<code class="eh kg kh ki jw b">myth</code>命令行工具将在您的系统上可用。确保您的版本为0.21.7或更高版本:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="cdbe" class="ka kb hu jw b fv kc kd l ke kf">$ myth version<br/>Mythril version v0.21.15</span></pre><p id="d494" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">执行安全分析的基本命令是<code class="eh kg kh ki jw b">myth analyze</code>:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="c5e9" class="ka kb hu jw b fv kc kd l ke kf">$ <!-- -->myth analyze &lt;Solidity file&gt;<br/>$ myth analyze -a &lt;contract address&gt;</span></pre><p id="ffc5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没有任何额外的参数，这将执行一个通用的分析，在大多数情况下工作得相当好。在我们开始之前，让我们先看看幕后发生了什么。</p><h2 id="3596" class="ka kb hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">Mythril的工作原理</h2><p id="02ff" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Mythril通过在以太坊虚拟机的定制实现中运行智能合约字节码来检查安全问题。它使用一种叫做符号执行的技术来探索可能的程序状态。分析过程包括以下步骤:</p><ol class=""><li id="7255" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo lm ln lo lp dt translated">通过编译Solidity文件或从以太坊节点加载获得合约字节码；</li><li id="9f14" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">通过运行创建字节码(如果提供了源代码)或通过按需从以太坊节点检索数据来初始化契约帐户状态；</li><li id="0d70" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">象征性地执行代码以探索在<em class="jp"> n个</em>事务中所有可能的程序状态，其中<em class="jp"> n </em>默认为2，但可以设置为任意数；</li><li id="c5ab" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">每当遇到不期望的状态时(例如“合同被终止”)，在给定某些假设的情况下(例如“给定正确的输入<em class="jp">任何人</em>都可以终止合同”)，逻辑地证明或否定这些状态的可达性。</li></ol><p id="4370" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当找到一个易受攻击的状态时，我们可以计算达到该状态所需的输入事务。这不仅有助于确定问题的根本原因，也有助于发现漏洞。</p><p id="6e24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想知道更多关于符号执行是如何工作的，看看Joran Honig的<a class="ae jq" rel="noopener" href="/@joran.honig/introduction-to-mythril-classic-and-symbolic-execution-ef59339f259b">介绍文章</a>。</p><h2 id="ae2d" class="ka kb hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">基本用法</h2><p id="5d36" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">解决了这个问题，让我们来试试Mythril在<a class="ae jq" href="https://capturetheether.com" rel="noopener ugc nofollow" target="_blank">capturethether</a>中的智能合同开发挑战。<a class="ae jq" href="https://capturetheether.com/challenges/math/token-sale/" rel="noopener ugc nofollow" target="_blank"> TokenSale </a>是一个简单的智能合约，允许用户以一生一次的特价1 ETH买卖代币。下面是源代码。</p><figure class="jr js jt ju fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff lv"><img src="../Images/22d4c8880508adbf52f822684f972bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gAIfJon8AB3FDuQrLMZBg.png"/></div></div></figure><p id="c965" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Solidity代码比使用链上契约实例更容易:如果您提供源代码，Mythril可以向您展示它发现的每个bug的代码位置。将代码复制/粘贴到一个名为<code class="eh kg kh ki jw b">tokensale.sol</code>的文件中，并运行以下命令(如果您安装了solc 0.5.x，您可以编译<a class="ae jq" href="https://gist.github.com/b-mueller/a4bd649153c86aa74d21bfa498060ad4" rel="noopener ugc nofollow" target="_blank">这个版本的代码</a>)。</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="ca08" class="ka kb hu jw b fv kc kd l ke kf">$ myth analyze -mether_thief tokensale.sol</span></pre><p id="1a49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意<code class="eh kg kh ki jw b">-m</code>参数的使用，它接受要执行的<a class="ae jq" href="https://github.com/ConsenSys/mythril-classic/tree/develop/mythril/analysis/modules" rel="noopener ugc nofollow" target="_blank">分析模块</a>的逗号分隔列表。让我们仔细看看一个特别有用的模块，叫做<em class="jp">以太贼</em>。</p><h2 id="b6e4" class="ka kb hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated"><strong class="ak">偷那珍贵的ETH </strong></h2><p id="bc0f" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">顾名思义，<em class="jp"> Ether Thief </em>模块<em class="jp"> </em>检查从契约中提取ETH的事务序列。具体来说，它查找满足以下条件的状态:</p><ol class=""><li id="30ee" class="lh li hu it b iu iv iy iz jc lj jg lk jk ll jo lm ln lo lp dt translated">可以从合同中提取非零金额的ETH</li><li id="b53e" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">撤回ETH的发送方是<em class="jp">而不是</em>合同创建人；</li><li id="03dc" class="lh li hu it b iu lq iy lr jc ls jg lt jk lu jo lm ln lo lp dt translated">提取的ETH金额可能大于同一发送方先前支付给合同的总金额。</li></ol><p id="ad00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一种很好的方式来发现“泄露”给匿名攻击者的合同，不会产生很多误报。现在，我们来看一下令牌销售合同的这一模块:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="f596" class="ka kb hu jw b fv kc kd l ke kf">$ myth analyze -m ether_thief tokensale.sol</span><span id="1f21" class="ka kb hu jw b fv md kd l ke kf">==== Unprotected Ether Withdrawal ====<br/>SWC ID: 105<br/>Severity: High<br/>Contract: TokenSaleChallenge<br/>Function name: sell(uint256)<br/>PC address: 696<br/>Estimated Gas Usage: 6373 - 27034<br/>Anyone can withdraw ETH from the contract account.</span><span id="3575" class="ka kb hu jw b fv md kd l ke kf">Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent an equivalent amount of ETH to it. This is likely to be a vulnerability.<br/>--------------------<br/>In file: tokensale.sol:25</span><span id="72e7" class="ka kb hu jw b fv md kd l ke kf">msg.sender.transfer(numTokens * PRICE_PER_TOKEN)</span><span id="5b73" class="ka kb hu jw b fv md kd l ke kf">--------------------</span><span id="5874" class="ka kb hu jw b fv md kd l ke kf">Transaction Sequence:</span><span id="e904" class="ka kb hu jw b fv md kd l ke kf">Caller: [CREATOR], data: [CONTRACT CREATION], value: 0xde0b6b3a7640000<br/>Caller: [ATTACKER], data: 0xd96a094ab000000000000000000000000000000000000000000000000000000000000000, value: 0x0<br/>Caller: [ATTACKER], data: 0xe4849b323000180504000000000300013b45000000380000000002c00000020400801080, value: 0x0</span></pre><p id="450c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Myhril声称已经在取款功能中发现了一个问题，但根本原因并不明显。如果您还没有发现这个bug，请再仔细查看一下代码，并尝试找出攻击。</p><p id="acc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能已经推断出这里存在整数溢出问题。为了利用这个问题，您需要向<code class="eh kg kh ki jw b">buy()</code>函数传递一个非常具体的值。不过，现在还不要启动计算器，有一些好消息:Mythril已经自动计算出了正确的输入事务。再看一下Mythril输出的“事务序列”部分:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="1e01" class="ka kb hu jw b fv kc kd l ke kf">Transaction Sequence:</span><span id="a1a7" class="ka kb hu jw b fv md kd l ke kf">Caller: [CREATOR], data: [CONTRACT CREATION], value: 0xde0b6b3a7640000<br/>Caller: [ATTACKER], data: 0xd96a094a2000000000000000000000000000000000000000000000000000000000000000, value: 0x0<br/>Caller: [ATTACKER], data: 0xe4849b323000180504000000000300013b45000000380000000002c00000020400801080, value: 0x0</span></pre><p id="ae70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本节列出了三个事务:契约创建事务(由创建者发送)和攻击者发送的两个事务。查看<code class="eh kg kh ki jw b">value</code>字段显示，攻击者没有将ETH转移到<em class="jp">合同中。让我们仔细看看通话数据:</em></p><figure class="jr js jt ju fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff me"><img src="../Images/005dc618834430b290a233c6510fb018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_rMJqyAc1sm0IUdJob5yw.png"/></div></div></figure><p id="411a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个事务包含<code class="eh kg kh ki jw b">buy(uint256 num_tokens)</code>的函数签名散列的前四个字节，以及一个看起来没有恶意的额外字节——<code class="eh kg kh ki jw b">0x20</code>——它表示<code class="eh kg kh ki jw b">uint256 num_tokens </code>的最左边的字节(剩余的零不必显式发送，因为EVM会将未初始化的调用数据解释为<code class="eh kg kh ki jw b">0x00</code>)。传递给<code class="eh kg kh ki jw b">num_tokens</code>的值算出为:</p><p id="64a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jw b">buy(0x2000000000000000000000000000000000000000000000000000000000000000)</code></p><p id="00c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看这个输入对第16行的<code class="eh kg kh ki jw b">require</code>语句的影响:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="60bc" class="ka kb hu jw b fv kc kd l ke kf">require(msg.value == numTokens * PRICE_PER_TOKEN);</span></pre><p id="d467" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jw b">PRICE_PER_TOKEN</code>设为1乙醚对应1e18卫。事实证明，将这个数量乘以Mythril为<code class="eh kg kh ki jw b">numTokens</code>计算的值会导致整数溢出。更具体地说，二进制乘法<code class="eh kg kh ki jw b">uint256(1e18) * uint256(numTokens)</code>的结果是零——注意，这里可以使用其他输入值。</p><p id="f6ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此<code class="eh kg kh ki jw b">require</code>语句通过，大量令牌被记入发送者的账户，即使他们没有发送任何ETH。</p><p id="3661" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在交易二中，非法令牌随后被出售以换取ETH(调用<code class="eh kg kh ki jw b">sell(uint256)</code>)。因为Mythril象征性地表示合约余额，所以它为<code class="eh kg kh ki jw b">numTokens</code>输出一个大的随机值。实际上，攻击者会使用与帐户中ETH的实际数量相对应的较低值。</p><p id="0bd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还没有这样做，现在是时候启动<a class="ae jq" href="https://metamask.io" rel="noopener ugc nofollow" target="_blank">超屏蔽</a>和<a class="ae jq" href="https://capturetheether.com/challenges/math/token-sale/" rel="noopener ugc nofollow" target="_blank">给挑战一个机会</a>。</p><h2 id="1ed0" class="ka kb hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated"><strong class="ak">配置交易计数</strong></h2><p id="9a70" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">使用Mythril时需要知道的一个重要概念是<em class="jp">事务计数</em>。这个变量象征性地指定要执行的事务数量。默认值2足以检测许多常见的错误，如整数溢出、未初始化的存储变量和命名错误的构造函数。然而，深入两个事务的搜索将<em class="jp">而不是</em>发现需要三个或更多事务才能发现的错误。</p><p id="8c52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为每个事务可以有多个有效的最终状态，所以要探索的状态空间随着事务的数量呈指数增长——至少在理论上是这样。幸运的是，Mythril在处理多个事务方面很聪明:通过分析程序路径在读写状态变量时如何相互关联，它缩小了后续事务的搜索空间。这意味着您通常可以在合理的时间范围内运行多个事务。</p><p id="a1c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了证明这一点，我们来看另一个例子。看看你是否能发现安全问题(小心合同名称中的破坏者):</p><figure class="jr js jt ju fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mf"><img src="../Images/e14afb13493dfa2c4c824439b429fe48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cw6jeig-DOa9ru_Y4y-Bfw.png"/></div></div></figure><p id="4c41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个契约有一个“后门”,允许任何知道秘密密码的人成为所有者(但是正如我们所知，私有状态变量并不是真正的秘密——唯一的区别是solc没有为它们生成访问函数)。</p><p id="589f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个受欢迎的Mythril模块是<em class="jp">自杀</em>。该模块检查交易，如果交易由合同创建者之外的任何人发送，将“意外”终止合同。对上面的代码运行Mythril会返回以下输出(<a class="ae jq" href="https://gist.github.com/b-mueller/e0eadc272d29aeff39627a70a7d4add3" rel="noopener ugc nofollow" target="_blank">源代码</a>):</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="3d6b" class="ka kb hu jw b fv kc kd l ke kf">$ myth analyze killme.sol<br/>The analysis was completed successfully. No issues were detected.</span></pre><p id="0cdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Mythril似乎忽略了这个漏洞。这样做的原因是至少需要三次交易才能杀死合同:发送者必须提供正确的密码以<code class="eh kg kh ki jw b">activatePassword(bytes11 password),</code>呼叫<code class="eh kg kh ki jw b">pwnContract()</code>成为所有者，最后呼叫<code class="eh kg kh ki jw b">kill()</code>触发自杀。</p><p id="e45e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看如果使用<code class="eh kg kh ki jw b">-t </code>参数增加执行的事务数量会发生什么:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="8ebe" class="ka kb hu jw b fv kc kd l ke kf">$ myth analyze killme.sol -t3</span><span id="a60c" class="ka kb hu jw b fv md kd l ke kf">==== Unprotected Selfdestruct ====</span><span id="ece3" class="ka kb hu jw b fv md kd l ke kf">SWC ID: 106<br/>Severity: High<br/>Contract: Killme<br/>Function name: kill()<br/>PC address: 371<br/>Estimated Gas Usage: 613 - 1038</span><span id="4c6e" class="ka kb hu jw b fv md kd l ke kf">The contract can be killed by anyone.<br/>Anyone can kill this contract and withdraw its balance to an arbitrary address.<br/>--------------------<br/>In file: killme.sol:19</span><span id="e0ec" class="ka kb hu jw b fv md kd l ke kf">selfdestruct(msg.sender)<br/>--------------------<br/>Transaction Sequence:</span><span id="5c81" class="ka kb hu jw b fv md kd l ke kf">Caller: [CREATOR], data: [CONTRACT CREATION], value: 0x0<br/>Caller: [ATTACKER], data: 0xa6e0e35e63727970746f6b69747479747474747474747474747474747474747474747474, value: 0x0<br/>Caller: [ATTACKER], data: 0x2eb00c1b, value: 0x0<br/>Caller: [ATTACKER], data: 0x41c0e1b5, value: 0x0</span></pre><p id="6336" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一次检测到了问题，我们得到了三个事务的序列。更仔细地检查calldata可以发现被调用函数的名称和参数:</p><figure class="jr js jt ju fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mg"><img src="../Images/7d4e959aa31153cbfb8b6cd7d8f4dd70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYLXcyONJ1_2K8hEjULScw.png"/></div></div></figure><p id="482e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:事务1中的字节序列<code class="eh kg kh ki jw b"> 0x747474(…)</code>是用于填充<code class="eh kg kh ki jw b">uint256</code>参数的随机数据，这部分调用数据可以是任意值。</p><h2 id="0867" class="ka kb hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">执行超时</h2><p id="9697" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">默认情况下，Mythril将尝试完全执行用<code class="eh kg kh ki jw b">-t</code>参数<em class="jp">配置的事务数量。然而，有时最好对执行时间设置一个界限。如果添加了<code class="eh kg kh ki jw b">--execution-timeout</code>参数，Mythril仍然会尝试完全执行所有事务，但是如果超时就会终止，并返回到那时为止发现的所有问题。</em></p><p id="0e4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，您可以随时使用<code class="eh kg kh ki jw b">CTRL+ C</code>中断分析，在这种情况下，Mythril将返回到目前为止发现的所有漏洞。例如，您可以在奇偶校验的<code class="eh kg kh ki jw b">WalletLibrary</code>上运行myth RIL 10分钟:</p><pre class="jr js jt ju fq jv jw jx jy aw jz dt"><span id="a0ca" class="ka kb hu jw b fv kc kd l ke kf">$ myth analyze --execution-timeout 600 -t2 -mether_thief,suicide -c [WALLETLIBRARY-BYTECOE]<br/>==== Unprotected Ether Withdrawal ====<br/>SWC ID: 105<br/>Severity: High<br/>Contract: MAIN<br/>Function name: execute(address,uint256,bytes)<br/>PC address: 4384<br/>Estimated Gas Usage: 9518 - 32483<br/>Anyone can withdraw ETH from the contract account.</span><span id="76cb" class="ka kb hu jw b fv md kd l ke kf">Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent an equivalent amount of ETH to it. This is likely to be a vulnerability.<br/>--------------------<br/>Transaction Sequence:</span><span id="1513" class="ka kb hu jw b fv md kd l ke kf">Caller: [CREATOR], data: [CONTRACT CREATION], value: 0x0<br/>Caller: [ATTACKER], data: 0xe46dcfeb4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080, value: 0x0<br/>Caller: [ATTACKER], data: 0xb61d27f6000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef000000000000000000010000000000000000000000000000000000000000000108, value: 0x0</span><span id="c87e" class="ka kb hu jw b fv md kd l ke kf">real    10m3.260s<br/>user    9m11.115s<br/>sys     0m7.727s</span></pre><h1 id="f4ac" class="mh kb hu bd kj mi mj mk kn ml mm mn kr mo mp mq ku mr ms mt kx mu mv mw la mx dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="3c96" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Mythril的<em class="jp">乙醚窃贼</em>和<em class="jp">自杀</em>模块检测安全漏洞，这些漏洞允许攻击者窃取甚至杀死可怜的无辜智能合约。Mythril还生成触发每个检测到的bug所需的输入事务的输出。增加<em class="jp">事务计数</em>有助于Mythril检测更多的bug，但也会成倍增加执行时间。</p><h1 id="52f0" class="mh kb hu bd kj mi mj mk kn ml mm mn kr mo mp mq ku mr ms mt kx mu mv mw la mx dt translated">关于Mythril和MythX</h1><p id="621b" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">Mythril是一个免费的开源智能合同安全分析器。它使用符号执行来检测各种安全漏洞。</p><p id="b77d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jq" href="https://mythx.io" rel="noopener ugc nofollow" target="_blank"> MythX </a>是一个基于云的智能合约安全服务，可以无缝集成到智能合约开发环境中并构建管道。它将多个领先的安全分析流程捆绑到一个易于使用的API中，允许任何人创建专门构建的智能合同安全工具。MythX兼容以太坊、Tron、Vechain、Quorum、Roostock和其他基于EVM的平台。</p></div></div>    
</body>
</html>