<html>
<head>
<title>New features of PHP 7.3 [Complete guide]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP 7.3的新特性[完整指南]</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/new-features-of-php-7-3-complete-guide-49d254e43ee1?source=collection_archive---------2-----------------------#2018-11-20">https://medium.com/hackernoon/new-features-of-php-7-3-complete-guide-49d254e43ee1?source=collection_archive---------2-----------------------#2018-11-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c6e015b0e35c83cd7298b57e9fe61bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLAHrwy11AF0dF2QgzkGAA.jpeg"/></div></div></figure><h1 id="f4f4" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="dc25" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">几天前，</p><p id="4fa0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我的一个同事给我看了几年前在电视上播出的一个电视广告。</p><p id="b06f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这个地方属于一家著名的英国连锁超市，讲述了一个真实发生在第一次世界大战圣诞节的故事。</p><p id="006d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">经过几个月的冲突，英国和德国士兵走出战壕，在欢笑和足球比赛中休战</p><p id="0273" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我必须承认，那几秒钟足以让我的一天振奋起来，并让我思考那个时代的人是如何度过一年中这个时候的日子的。</p><p id="5592" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在视频之后的对话中，我意识到，在那些时候，尽管我不需要提及明显的原因，</p><p id="6d6d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">技术进步令人难以置信，想想莫滕·泰杜姆的电影《模仿游戏》就知道了。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="fa10" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">相信<a class="ae lj" href="https://hackernoon.com/tagged/php" rel="noopener ugc nofollow" target="_blank"> PHP </a>也是如此，</p><p id="2dfa" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">对语言、语法和代码的改进，即使是很小的改进，总的来说都会带来好的幽默和希望，事实是在这几个月里，</strong></p><p id="926d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">即使在未来几年，</p><p id="9c45" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">他们可以让我们成为更好的程序员，并创建让我们和我们的客户满意的应用程序。</p><p id="cb7e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">今年，负责更新的团队实现了一些决定性的变化，</p><p id="3754" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">有些新功能已经被要求了好几年了，</p><p id="ba11" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">其他的是令人愉快的惊喜，就像我们在节日期间从我们所爱的人那里收到的那些，就像在圣诞节那天士兵们收到的那些。</p><p id="223a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在这篇文章中，你将会了解到新的PHP 7.3将会实现哪些特性，以及你可以从它的发布中展示哪些轴。</p><h1 id="3f36" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">跟随系列…</h1><p id="5000" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这篇博文是“<a class="ae lj" href="https://amzn.to/2OfCZej" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv"> PHP 7.3及其圣诞礼物</strong> </a>的第二部分</p><p id="7ad0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果你还没有阅读其他部分</p><p id="c082" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你可以点击下面的链接查看其他博客文章<br/><a class="ae lj" href="http://anastasionico.uk/blog/php-73" rel="noopener ugc nofollow" target="_blank">PHP 7.3简介和新语法</a>，<br/><a class="ae lj" href="http://anastasionico.uk/blog/php-7-3-new-features#" rel="noopener ugc nofollow" target="_blank">PHP 7.3的新特性</a>，<br/> <a class="ae lj" href="http://anastasionico.uk/blog/php-7-3-new-features#" rel="noopener ugc nofollow" target="_blank">弃用和变更— <em class="lk">尚未发布，如果你现在想阅读的话可以获取电子书</em> </a></p><h1 id="21e4" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">新功能</h1><h1 id="03d6" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">JSON _ THROW _ ON _错误</h1><p id="af3a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">很长一段时间以来，在使用JSON时没有足够的方法来处理错误一直是一个问题，全世界的web开发人员都认为这是该语言的一个巨大缺点，</p><p id="47c4" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">PHP 7.3的RFC以23比0的投票结果接受了这个更新，这表明了这个特性被请求的程度。</p><p id="2c28" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在PHP v7.2之前，我们需要使用一种变通方法来从JSON获得一个错误，它既不可靠，也不精通它的工作；</p><p id="03c9" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这里有一个例子:</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="0458" class="lq jd hu lm b fv lr ls l lt lu">json_decode("{");</span><span id="e468" class="lq jd hu lm b fv lv ls l lt lu">json_last_error() === JSON_ERROR_NONE // the result is false</span><span id="e414" class="lq jd hu lm b fv lv ls l lt lu">json_last_error_msg() // The result is "Syntax error"</span></pre><p id="a692" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">是的，</p><p id="3972" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们可以确定JSON是否有错误，</p><p id="f35f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">但是，这显然不是最好的方法。</p><p id="aded" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我将要展示的新标志是一个很好的选择，因为它让程序员有机会使用可以在“try-catch”代码块中管理的异常。</p><p id="8612" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们看一个实际的例子，好吗？：</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="2acb" class="lq jd hu lm b fv lr ls l lt lu">use JsonException;<br/> <br/>try {<br/>    $json = json_encode("{", JSON_THROW_ON_ERROR);<br/>    return base64_encode($json);<br/>} catch (JsonException $e) {<br/>    throw new EncryptException('Could not encrypt the data.', 0, $e);<br/>}</span></pre><p id="0840" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">从前面的代码中可以看出，json_encode函数现在有了一个可选参数<strong class="kc hv"> JSON_THROW_ON_ERROR，它将捕获错误并使用以下异常方法显示错误:</strong></p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="7c42" class="lq jd hu lm b fv lr ls l lt lu">$e-&gt;getMessage(); // like json_last_error_msg()</span><span id="c58c" class="lq jd hu lm b fv lv ls l lt lu">$e-&gt;getCode(); // like json_last_error()</span></pre><p id="df1b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">PHP7.3对现有代码的默认修改是中性的，因为它是一个可选参数，所以在你更新PHP后，一切都将正常工作。</p><p id="cb0f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这是此次更新最重要的特性之一，所以如果你想深入了解更多，请看一下<a class="ae lj" href="https://wiki.php.net/rfc/json_throw_on_error" rel="noopener ugc nofollow" target="_blank">官方的JSON _ THROW _ ON _ ERROR</a>RFC</p><h1 id="0a03" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">是_可数的</h1><p id="1005" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">代码中的可数元素可以是数组格式的变量，也可以是其类实现可数接口的对象。</p><p id="69cc" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">去年，PHP 7.2增加了一个警告，每当web开发人员计算或试图循环一个不可数元素时，就会出现这个警告。</strong></p><p id="db37" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">解决这个问题是可能的，目前使用的最佳解决方案之一是应用类似下面代码片段的检查:</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="c28d" class="lq jd hu lm b fv lr ls l lt lu">if (is_array($santa) || $santa instanceof Countable) {<br/>    // $santa is countable<br/>}</span></pre><p id="51c1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">代码检查变量是数组还是可数接口的实例。</p><p id="807b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它可以工作，但看起来有点“拥挤”,因为你们中的许多人长时间工作，过一会儿看到这种线条会累坏你的眼睛。</p><p id="07d6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">开发新版本的团队考虑到了这一点，并添加了一个新功能，这将极大地帮助web开发人员。</p><p id="05b5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">is _ countable函数将一个变量作为参数，然后根据该函数是否可数返回一个布尔值。</strong></p><p id="00da" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">参数的格式没有限制，当然，如果你放了一个不可数的变量，返回将是false。</p><p id="1bf7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们在实践中看到它</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="a687" class="lq jd hu lm b fv lr ls l lt lu">if (is_countable($santa)) {<br/>    // $santa is countable<br/>}</span></pre><p id="4446" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这段代码基本上做了和上一段相同的事情，但是更容易记忆，对我来说最重要的是可读性更好。</p><p id="043c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">更不用说您可以使用这个函数，或者在一个三元条件操作符中使用它，这样看起来会更令人满意。</p><p id="a004" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><a class="ae lj" href="https://wiki.php.net/rfc/is-countable" rel="noopener ugc nofollow" target="_blank"> <em class="lk">更多关于is_countable的信息请看官方RFC </em> </a></p><h1 id="7905" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">array_key_first()，array_key_last()</h1><p id="4454" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">根据PHP 5.6版本，有超过75个属于数组类别的内置函数。</p><p id="62ed" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">尽管有大量的工具可用，但目前，如果我们需要检索数组的第一个或最后一个键，我们必须使用<em class="lk"> array_keys() </em>获取所有的键，然后只获取数组的第一个或最后一个值。</p><p id="f1f3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">另一种方法是选择<em class="lk">结束()</em>或<em class="lk">复位()</em>。</p><p id="5eaf" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">正如你可能知道的，所有的方法都描述了修改数组指针，这是你可能不想做的事情(除了消耗资源)。</p><p id="2bb3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">下一版本的RFC提出引入4种全新的方法来解决这个问题。</p><p id="41e9" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这四种方法是:</p><ul class=""><li id="e065" class="lw lx hu kc b kd ky kh kz kl ly kp lz kt ma kx mb mc md me dt translated">array_key_first()</li><li id="10ff" class="lw lx hu kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">array_key_last()</li><li id="abe7" class="lw lx hu kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">数组值优先()</li><li id="4b60" class="lw lx hu kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">数组值最后一个()</li></ul><p id="df8c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在这四组中，只有取出钥匙的那一组以18比14的票数被接受。</p><p id="4ac7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它们适用于数值数组和关联数组。</p><p id="fb52" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">下面是一个数字的例子:</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="b485" class="lq jd hu lm b fv lr ls l lt lu">$reindeers<!-- --> <!-- -->= [</span><span id="dd21" class="lq jd hu lm b fv lv ls l lt lu">1 =&gt; "Rudolph",</span><span id="0709" class="lq jd hu lm b fv lv ls l lt lu">2 =&gt;  "Dasher",</span><span id="3c90" class="lq jd hu lm b fv lv ls l lt lu">3 =&gt;  "Dancer",</span><span id="f322" class="lq jd hu lm b fv lv ls l lt lu">4 =&gt;  "Prancer",</span><span id="f13c" class="lq jd hu lm b fv lv ls l lt lu">5 =&gt;  "Vixen",</span><span id="2c4e" class="lq jd hu lm b fv lv ls l lt lu">6 =&gt;  "Comet",</span><span id="5e61" class="lq jd hu lm b fv lv ls l lt lu">7 =&gt;  "Cupid",</span><span id="9928" class="lq jd hu lm b fv lv ls l lt lu">8 =&gt;  "Donner",</span><span id="f4cf" class="lq jd hu lm b fv lv ls l lt lu">9 =&gt;  "Blitzen"];</span><span id="41ef" class="lq jd hu lm b fv lv ls l lt lu">$first<!-- --> <!-- -->= array_key_first($reindeers); // $first is equal to 1</span><span id="a30e" class="lq jd hu lm b fv lv ls l lt lu">$last<!-- --> <!-- -->= array_key_last($reindeers); // $last is equal to 9</span></pre><p id="ca60" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这是一个关联数组的例子:</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="e0a1" class="lq jd hu lm b fv lr ls l lt lu">$reindeers<!-- --> <!-- -->= [</span><span id="111f" class="lq jd hu lm b fv lv ls l lt lu">"Rudolph"<!-- --> <!-- -->=&gt; 1,</span><span id="b31d" class="lq jd hu lm b fv lv ls l lt lu">"Dasher"<!-- --> <!-- -->=&gt; 2,</span><span id="fac2" class="lq jd hu lm b fv lv ls l lt lu">"Dancer"<!-- --> <!-- -->=&gt; 3,</span><span id="663d" class="lq jd hu lm b fv lv ls l lt lu">"Prancer"<!-- --> <!-- -->=&gt; 4,</span><span id="706e" class="lq jd hu lm b fv lv ls l lt lu">"Vixen"<!-- --> <!-- -->=&gt; 5,</span><span id="6167" class="lq jd hu lm b fv lv ls l lt lu">"Comet"<!-- --> <!-- -->=&gt; 6,</span><span id="23e8" class="lq jd hu lm b fv lv ls l lt lu">"Cupid"<!-- --> <!-- -->=&gt; 7,</span><span id="3173" class="lq jd hu lm b fv lv ls l lt lu">"Donner"<!-- --> <!-- -->=&gt; 8,</span><span id="ac0a" class="lq jd hu lm b fv lv ls l lt lu">"Blitzen"<!-- --> <!-- -->=&gt; 9];</span><span id="ec64" class="lq jd hu lm b fv lv ls l lt lu">$first<!-- --> <!-- -->= array_key_first($reindeers); // $first is equal to "Rudolph"</span><span id="3c55" class="lq jd hu lm b fv lv ls l lt lu">$last<!-- --> <!-- -->= array_key_last($reindeers); // $last is equal to "Blitzen"</span></pre><p id="df65" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这同样适用于本章array_value_*中说明的其他两个函数</p><p id="0d60" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">澄清一下，让我重复一遍，</p><p id="6c75" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这些功能以18个“否”和15个“是”被拒绝。</p><p id="f14f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在我看来，这两个函数也很有用，但是根据一些web开发人员的说法，在某些情况下，返回的值可能是不明确的。</p><p id="7199" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">原因如下:</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="6786" class="lq jd hu lm b fv lr ls l lt lu">$reindeers<!-- --> <!-- -->= [];</span><span id="b845" class="lq jd hu lm b fv lv ls l lt lu">$first<!-- --> <!-- -->= array_value_first($reindeers<!-- --> <!-- -->); // $first is equal to null</span><span id="e79c" class="lq jd hu lm b fv lv ls l lt lu">$last<!-- --> <!-- -->= array_value_last($reindeers<!-- --> <!-- -->);// $last is equal to null</span></pre><p id="3114" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我在浏览论坛和与其他web开发人员交谈时遇到的另一个选项是返回一个类似[$key =&gt; $value]的元组。</p><p id="4345" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">尽管这个选项在新版本中不可用，但是看到了积极的响应，它可能会随以下RFC一起出现。</p><p id="266f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">由于这是一个以前不存在的函数，所以不会有任何向后兼容性问题，唯一的问题可能会出现，如果您已经创建并使用了自己版本的<em class="lk"> array_key_first() </em>和<em class="lk"> array_key_last() </em>。</p><h1 id="1a53" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">相同站点cookie</h1><p id="893a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">部署安全的应用程序必须始终是每个程序员的主要关注点。</p><p id="ee06" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们每个人每天都面临的一项任务是减少CSRF和信息泄露攻击的风险。</p><p id="0c30" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">同站点烹饪声明cookies必须仅在从同一个域发起请求时发送。</strong></p><p id="d4cd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这不是一个官方标准，但是Google Chrome和几个最好的PHP框架已经实现了它，而Firefox和其他框架的新版本证实了他们正在计划这样做。</p><p id="fcd5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><a class="ae lj" href="http://https//caniuse.com/#search=samesite" rel="noopener ugc nofollow" target="_blank">这是来自caniuse.com的相同站点cookie的支持模式</a></p><p id="6722" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">目前，</p><p id="1a54" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">cookie由set-cookie报头发布，</p><p id="251c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">web开发人员可以在浏览器的标志旁边设置一个键值对，以便就cookie是否可用达成一致。</p><p id="6edc" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这种做法使得CSRF容易受到攻击。</p><p id="9f6c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">新的RFC增加了一个新的参数，并修改了该语言的四个主要功能，从而解决了非中断模式的问题。</p><ul class=""><li id="8ace" class="lw lx hu kc b kd ky kh kz kl ly kp lz kt ma kx mb mc md me dt translated">setcookie</li><li id="f014" class="lw lx hu kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">setrawcookie</li><li id="df78" class="lw lx hu kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me dt translated">会话集cookie参数</li></ul><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="37bb" class="lq jd hu lm b fv lr ls l lt lu">setcookie($name [,$value [,$expire [,$path [,$domain [, $secure [,$httponly [,$samesite]]]]]]]);</span></pre><p id="b840" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">提出了两种方法。</p><p id="3561" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">向函数中添加一个新的参数，或者允许一个选项数组来移动cookies中的所有选项。</p><p id="9b25" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它将如何工作？</p><p id="0562" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">可以将两个值添加到上述函数中的同一个站点标志中</p><p id="d094" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">他们宽松而严格。</p><p id="5ea7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">使用Lax的Cookies在来自另一个域的Get请求中是可访问的，而相反，Strict在GET请求中是不可访问的。</p><p id="da57" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">例如，当使用一个更宽松的标志时，标题将如下所示:</p><pre class="ld le lf lg fq ll lm ln lo aw lp dt"><span id="ab89" class="lq jd hu lm b fv lr ls l lt lu">Set-Cookie: key=value; path=/; domain=example.org; HttpOnly; SameSite=Lax</span></pre><p id="a4df" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在代码中包含增加安全性的特性似乎总是显而易见的，但是在决定将它们应用到我们的脚本中之前，我们需要正确地评估我们选择的利弊</p><p id="8d89" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">使用相同的站点标志作为这些功能的补充参数所隐含的主要风险是，它可能永远不会成为官方标准。</p><p id="e1cc" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这意味着最终浏览器将降低旗帜。</p><p id="d34c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果这种情况发生，并且你已经实现了它，它将导致你的应用程序塞满了需要删除的垃圾代码。</p><p id="d7c3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我个人的建议是等等看会发生什么。</p><p id="187f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果这个标志会被更多地使用，并最终被定义为一个标准，那就去做吧！</p><p id="7ec8" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">说到向后更改，就像本文中看到的大多数以前的更改一样，在您的代码中实现它不会有任何问题。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/81f240e8dd073aab6ad31da0e0d28d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FKpkkhRhWP0iLk7FpzTbQ.jpeg"/></div></div></figure><h1 id="bb32" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">结论</h1><p id="0d59" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">正如我所料，这个新版本不涉及突破性的变化，</p><p id="3aca" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">既然不是新版本，就这样吧。</p><p id="dd11" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv"> PHP正在采取小而持续的步骤，允许它随着时间的推移不断进步和改进</strong>，尽管多年来人们已经转向更时髦的<a class="ae lj" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程语言</a>。</p><p id="0b3f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在下一篇文章中，您将看到其他杂项变化和不再使用的功能列表，这些功能最终被弃用，以便为新项目腾出空间。</p><p id="abad" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果你喜欢这些帖子的内容，并且不想等待，那么在下面的链接中，你可以在亚马逊的kindle上找到单一格式的完整文章。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/e7e4f400e1d8420cfbee51c604e266d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R999jOgEwC_-b-Nf.jpg"/></div></div></figure><p id="e5f6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="lk">这篇博文是Kindle book " </em> <a class="ae lj" href="https://amzn.to/2PpbxeS" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> PHP 7.3及其圣诞礼物</em></a><em class="lk"/>的一段</p><h1 id="8965" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">现在轮到你了</h1><p id="144a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">现在我想听听你的意见:</p><p id="d70d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">你对这种语言带来的新特性满意吗？<br/>你打算更经常使用什么？</p><p id="19bf" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">请在下面留言告诉我。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="mm li l"/></div></figure></div></div>    
</body>
</html>