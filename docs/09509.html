<html>
<head>
<title>React Web Project Building. Part 2 — HOCs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Web项目构建。第2部分— HOCs</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-web-project-building-part-2-hocs-4416f4721168?source=collection_archive---------25-----------------------#2018-11-20">https://medium.com/hackernoon/react-web-project-building-part-2-hocs-4416f4721168?source=collection_archive---------25-----------------------#2018-11-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="92a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上一部分中，我们创建了<strong class="it hv"> AppKernel </strong> <strong class="it hv"> HOC </strong>(高阶组件)来为你的应用添加一些有用的特性。</p><p id="89e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一部分中，我们将继续学习HOCs和函数式编程。我们将把我们的大HOC分成一些小的部分，你可以重用它们来构建你自己的应用程序。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/4198ee8773f29086616a7e4b65dd286c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbLaG-BSP_uTQf6o3Q2Gzw.jpeg"/></div></div></figure></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><div class="jq jr js jt fq ki"><a href="https://hackernoon.com/react-web-project-building-5e9cc4ff54da" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">React Web项目构建</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">在这篇文章中，我将向你展示如何用一个新的React特性创建React web项目内核:React悬念和…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">hackernoon.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw jz ki"/></div></div></a></div><p id="d5ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在开始之前，我们需要记住一些函数式编程的基础知识。</p><p id="1117" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> HOC </strong>(高阶分量)是<strong class="it hv">高阶函数</strong>的一种。这是一个以组件作为参数的函数，它返回一个新的组件。</p><p id="42e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一部分，我们将使用功能组合和某种咖喱。</p><p id="07bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们记住上一部分的<strong class="it hv"> AppKernel </strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="03da" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>React, { StrictMode, Suspense } <em class="li">from </em>'react';<br/><em class="li">import </em>{ <br/>  ErrorBoundary, <br/>  FallbackView,<br/>} <em class="li">from </em>'react-error-boundaries';<br/><em class="li">import </em>{ Provider } <em class="li">from </em>'react-redux';<br/><em class="li">import </em>{ BrowserRouter <em class="li">as </em>Router } <em class="li">from </em>'react-router-dom';<br/><br/><em class="li">import </em>store <em class="li">from </em>'../store';<br/><br/><em class="li">const </em>AppKernel = (Component) =&gt; {<br/>    <em class="li">return </em>() =&gt; (<br/>        <strong class="ky hv">&lt;StrictMode&gt;<br/>            &lt;ErrorBoundary <em class="li">FallbackComponent</em>={FallbackView}&gt;<br/>                &lt;Provider <em class="li">store</em>={store}&gt;<br/>                    &lt;Router&gt;<br/>                        &lt;Suspense <em class="li">fallback</em>={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>                            &lt;Component /&gt;<br/>                        &lt;/Suspense&gt;<br/>                    &lt;/Router&gt;<br/>                &lt;/Provider&gt;<br/>            &lt;/ErrorBoundary&gt;<br/>        &lt;/StrictMode&gt;</strong><br/>    );<br/>};<br/><br/><em class="li">export default </em>AppKernel;</span></pre><p id="99bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下我们的目标:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="6a2a" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>{ compose } <em class="li">from </em>'./helpers';<br/><br/><em class="li">import </em>strictMode <em class="li">from </em>'./hocs/strictMode';<br/><em class="li">import </em>errorBoundary <em class="li">from </em>'./hocs/errorBoundary';<br/><em class="li">import </em>redux <em class="li">from </em>'./hocs/redux';<br/><em class="li">import </em>router <em class="li">from </em>'./hocs/router';<br/><em class="li">import </em>suspense <em class="li">from </em>'./hocs/suspense';<br/><br/><em class="li">const </em>AppKernel = <strong class="ky hv">compose(<br/>    strictMode,<br/>    errorBoundary,<br/>    redux,<br/>    router,<br/>    suspense,<br/>)</strong>;<br/><br/><em class="li">export default </em>AppKernel;</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff lj"><img src="../Images/0b8a1174091aefaebbc5d9a006e318c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*jEHMduzj03G6hWzJevXHoA.png"/></div></div></figure><p id="4e98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它看起来更具声明性——功能相同但代码更少。和其他好处——您可以在HOC中组合任何部分，并在任何其他React应用程序中重用它。</p><p id="57dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在谁想看全部代码，我创建了一个<a class="ae lk" href="https://github.com/evheniy/react-web-project-builder" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> github库</strong> </a>。</p><p id="d0dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，让我们从头开始。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="2e42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们需要创建compose函数。为此，我在我们的<strong class="it hv"> src/app </strong>目录中创建了一个助手。我没有创建自己的合成功能，因为我们使用redux，它有自己的合成功能，它对我们来说非常完美。</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="4a9c" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>{ compose } <em class="li">from </em>'redux';</span></pre><p id="f942" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主要的想法是为每一层制作小的hoc。为此，我创建了一个<strong class="it hv">包装器</strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="876d" class="lc ld hu ky b fv le lf l lg lh"><em class="li">const </em>wrapper = (WrapperComponent, wrapperProps = {}, Component) =&gt; () =&gt; (<br/>    &lt;WrapperComponent {...wrapperProps}&gt;<br/>        &lt;Component /&gt;<br/>    &lt;/WrapperComponent&gt;<br/>);</span></pre><p id="29f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将<strong class="it hv">包装组件</strong>如<strong class="it hv">严格模式</strong>或<strong class="it hv">悬念</strong>并包装<strong class="it hv">组件</strong>。如果我们需要，我们可以添加任何属性，例如，如果我们需要通过<strong class="it hv">Redux</strong><strong class="it hv">Provider</strong>中的<strong class="it hv"> store </strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="a6d4" class="lc ld hu ky b fv le lf l lg lh">&lt;Provider <em class="li">store</em>={store}&gt;</span></pre><p id="1289" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是要在构图中使用它，我们需要实现这个功能:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="418f" class="lc ld hu ky b fv le lf l lg lh"><em class="li">const </em>hocCreator = (WrapperComponent, wrapperProps, Component) =&gt; {<br/>  <em class="li">if </em>(!WrapperComponent) {<br/>      <em class="li">throw new </em>Error('WrapperComponent should be set!');<br/>  }<br/><br/>  <em class="li">return </em>Component<br/>      ? wrapper(WrapperComponent, wrapperProps, Component)<br/>      : Cmp =&gt; {<br/>          <em class="li">if </em>(!Cmp) {<br/>              <em class="li">throw new </em>Error('Component should be set!');<br/>          }<br/><br/>          <em class="li">return </em>wrapper(WrapperComponent, wrapperProps, Cmp);<br/>      }<br/>};</span></pre><p id="92ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它使用带有一些检查的包装函数:如果我们没有放入<strong class="it hv">组件</strong>，它将返回另一个函数。</p><p id="fe36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以及我们助手的所有代码:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="28cc" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>React <em class="li">from </em>'react';<br/><em class="li">import </em>{ compose } <em class="li">from </em>'redux';<br/><br/><em class="li">const </em>wrapper = (WrapperComponent, wrapperProps = {}, Component) =&gt; () =&gt; (<br/>    &lt;WrapperComponent {...wrapperProps}&gt;<br/>        &lt;Component /&gt;<br/>    &lt;/WrapperComponent&gt;<br/>);<br/><br/><em class="li">const </em>hocCreator = (WrapperComponent, wrapperProps, Component) =&gt; {<br/>  <em class="li">if </em>(!WrapperComponent) {<br/>      <em class="li">throw new </em>Error('WrapperComponent should be set!');<br/>  }<br/><br/>  <em class="li">return </em>Component<br/>      ? wrapper(WrapperComponent, wrapperProps, Component)<br/>      : Cmp =&gt; {<br/>          <em class="li">if </em>(!Cmp) {<br/>              <em class="li">throw new </em>Error('Component should be set!');<br/>          }<br/><br/>          <em class="li">return </em>wrapper(WrapperComponent, wrapperProps, Cmp);<br/>      }<br/>};<br/><br/><em class="li">export </em>{<br/>    hocCreator,<br/>    compose,<br/>};</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/55753c52837fb79686860579a7a3f816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*DLsUoq539jcj_OayW7eOXg.png"/></div></figure><p id="5929" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们准备为每一层创建一个特设。</p><h1 id="75cb" class="lm ld hu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi dt translated">严格模式</h1><p id="24d3" class="pw-post-body-paragraph ir is hu it b iu mj iw ix iy mk ja jb jc ml je jf jg mm ji jj jk mn jm jn jo hn dt translated"><strong class="it hv">src/app/hocs/strict mode . js</strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="2a24" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>{ StrictMode } <em class="li">from </em>'react';<br/><br/><em class="li">import </em>{ hocCreator } <em class="li">from </em>'../helpers';<br/><br/><em class="li">export default </em>hocCreator(StrictMode);</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/f638cc2bae2372394541e4f9a46a0c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*PO319AKmQ_UwTbWG6zsyuQ.png"/></div></figure><p id="152e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太容易了。我们使用我们的<strong class="it hv"> hocCreator </strong>助手函数从<strong class="it hv"> React StrictMode </strong>组件创建一个HOC。</p><p id="ef50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想象它是如何工作的，我们会得到这样的结果:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="1879" class="lc ld hu ky b fv le lf l lg lh">() =&gt; (<br/>  &lt;StrictMode&gt;<br/>    &lt;Component /&gt;<br/>  &lt;/StrictMode&gt;<br/>)</span></pre><h1 id="f99f" class="lm ld hu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi dt translated">误差边界</h1><p id="1ed6" class="pw-post-body-paragraph ir is hu it b iu mj iw ix iy mk ja jb jc ml je jf jg mm ji jj jk mn jm jn jo hn dt translated"><strong class="it hv">src/app/hocs/error boundary . js</strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="c9a7" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>{ ErrorBoundary, FallbackView } <em class="li">from </em>'react-error-boundaries';<br/><br/><em class="li">import </em>{ hocCreator } <em class="li">from </em>'../helpers';<br/><br/><em class="li">export default </em>hocCreator(ErrorBoundary, { FallbackComponent: FallbackView });</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/3d86edd81572dcc30c95fea5c51c747b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*geSdPJFIsmz_NBjuz5TzSQ.png"/></div></figure><p id="0af5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里我们可以看到我如何使用<strong class="it hv"> ErrorBoundary </strong>组件的属性。</p><p id="00bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它是这样工作的:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="6197" class="lc ld hu ky b fv le lf l lg lh">() =&gt; (<br/>  &lt;ErrorBoundary FallbackComponent={FallbackView}&gt;<br/>    &lt;Component /&gt;<br/>  &lt;/ErrorBoundary&gt;<br/>)</span></pre><h1 id="ee50" class="lm ld hu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi dt translated">Redux</h1><p id="6791" class="pw-post-body-paragraph ir is hu it b iu mj iw ix iy mk ja jb jc ml je jf jg mm ji jj jk mn jm jn jo hn dt translated"><strong class="it hv"> src/app/hocs/redux.js </strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="4965" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>{ Provider } <em class="li">from </em>'react-redux';<br/><br/><em class="li">import </em>{ hocCreator } <em class="li">from </em>'../helpers';<br/><em class="li">import </em>store <em class="li">from </em>'../../store';<br/><br/><em class="li">export default </em>hocCreator(Provider, { store });</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/1967e1387f0d3def0a9a2ad1c0395eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*_tg_O1DdHa5XI6ct8BknQA.png"/></div></figure><h1 id="787f" class="lm ld hu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi dt translated">路由器</h1><p id="035a" class="pw-post-body-paragraph ir is hu it b iu mj iw ix iy mk ja jb jc ml je jf jg mm ji jj jk mn jm jn jo hn dt translated"><strong class="it hv"> src/app/hocs/router.js </strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="4af2" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>{ BrowserRouter } <em class="li">from </em>'react-router-dom';<br/><br/><em class="li">import </em>{ hocCreator } <em class="li">from </em>'../helpers';<br/><br/><em class="li">export default </em>hocCreator(BrowserRouter);</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/0925b93f0c053ae53361c02b6058e7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*dBY5jAzC5veU8MklPM_Wbg.png"/></div></figure><h1 id="515b" class="lm ld hu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi dt translated">焦虑</h1><p id="55cf" class="pw-post-body-paragraph ir is hu it b iu mj iw ix iy mk ja jb jc ml je jf jg mm ji jj jk mn jm jn jo hn dt translated"><strong class="it hv">src/app/hocs/悬念. js </strong>:</p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="6c86" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>React, { Suspense } <em class="li">from </em>'react';<br/><br/><em class="li">import </em>{ hocCreator } <em class="li">from </em>'../helpers';<br/><br/><em class="li">export default </em>hocCreator(Suspense, { fallback: &lt;div&gt;Loading...&lt;/div&gt; });</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/e1d1a30c81f9772729988854c7091a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*YvdyYv6ovxTHoEsL-HpZyQ.png"/></div></figure></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="1b9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有小额奖金。我更新了我们的页面组件，只使用纯组件。纯组件使用与纯函数相同的思想——没有副作用。</p><p id="1230" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个带参数的函数，它返回JSX:</p><p id="1aa8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">道具= &gt; JSX </strong></p><p id="dfad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> src/page/index.js: </strong></p><pre class="jq jr js jt fq kx ky kz la aw lb dt"><span id="89db" class="lc ld hu ky b fv le lf l lg lh"><em class="li">import </em>React <em class="li">from </em>'react';<br/><em class="li">import </em>logo <em class="li">from </em>'../logo.svg';<br/><em class="li">import </em>'./index.css';<br/><br/><em class="li">const </em>PageComponent = () =&gt; (<br/>    &lt;div <em class="li">className</em>="App"&gt;<br/>        &lt;header <em class="li">className</em>="App-header"&gt;<br/>            &lt;img <em class="li">src</em>={logo} <em class="li">className</em>="App-logo" <em class="li">alt</em>="logo" /&gt;<br/>            &lt;p&gt;<br/>                Edit &lt;code&gt;src/page/index.js&lt;/code&gt; and save to reload.<br/>            &lt;/p&gt;<br/>            &lt;a<br/>                <em class="li">className</em>="App-link"<br/>                <em class="li">href</em>="https://reactjs.org"<br/>                <em class="li">target</em>="_blank"<br/>                <em class="li">rel</em>="noopener noreferrer"<br/>            &gt;<br/>                Learn React<br/>            &lt;/a&gt;<br/>        &lt;/header&gt;<br/>    &lt;/div&gt;<br/>);<br/><br/><em class="li">export default </em>PageComponent;</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/529097c806e997bd1236203b2dd84284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*xifuE4jlK1vrcGRZQz3OuQ.png"/></div></figure></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="47a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仅此而已。</p><p id="f5e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，您可以使用<strong class="it hv"> hocCreator </strong> helper轻松创建任何HOC，并创建自己的<strong class="it hv"> AppKernel </strong>，为您的应用程序提供任何有用的功能。</p><div class="mt mu fm fo mv ki"><a href="https://github.com/evheniy/react-web-project-builder" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">evheniy/react-web-project-builder</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">https://hacker noon . com/react-we b-project-building-5e 9 cc 4 ff 54 da-evheniy/react-we b-project-builder</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">github.com</p></div></div><div class="kr l"><div class="mw l kt ku kv kr kw jz ki"/></div></div></a></div><div class="mt mu fm fo mv ki"><a href="https://blog.cloudboost.io/react-functional-way-c533fceda2ce" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab ej"><div class="kk ab kl cl cj km"><h2 class="bd hv fv z el kn eo ep ko er et ht dt translated">反应:功能方式</h2><div class="kp l"><h3 class="bd b fv z el kn eo ep ko er et ek translated">正如您可能知道的，使用react可以使用函数或类——使用无状态和有状态组件。在…</h3></div><div class="kq l"><p class="bd b gc z el kn eo ep ko er et ek translated">blog.cloudboost.io</p></div></div><div class="kr l"><div class="mx l kt ku kv kr kw jz ki"/></div></div></a></div></div></div>    
</body>
</html>