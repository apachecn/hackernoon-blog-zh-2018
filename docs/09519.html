<html>
<head>
<title>Creating Simple API Gateway using Node JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用节点JS创建简单的API网关</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-simple-api-gateway-using-node-js-6d5933c214b8?source=collection_archive---------0-----------------------#2018-11-21">https://medium.com/hackernoon/creating-simple-api-gateway-using-node-js-6d5933c214b8?source=collection_archive---------0-----------------------#2018-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8f3e0b3eb7981e645ea906f28c34992f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jehblAlXk4FyRwbb"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@nknezevic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nikola Knezevic</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="438b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我的<a class="ae jg" href="https://hackernoon.com/messaging-system-hands-on-7dda1afded37" rel="noopener ugc nofollow" target="_blank">上一篇</a>文章中，我解释了消息传递系统如何帮助我们的系统更具可伸缩性。</p><p id="45ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回到我们使用微服务架构的时候，主要的概念是分离每个服务。分离服务后，现在我们有多个部署在不同主机上的服务。这意味着我们的客户端Web、Mobile或CLI等前端服务——应该从不同的主机检索数据。当我们有更多的服务时，这种情况会变得更加困难。我们应该记住每个服务的主机，这样我们就可以检索数据。这是系统的样子。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/540869e625f8ff630c2d03acc0a97eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kjpeE29Z871gsRq8ubo1JA.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The current system design</figcaption></figure><p id="28d0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们需要一种机制来使我们的前端服务调用后端服务，而不知道后端服务托管在哪里。我们如何创造这种机制？</p><h1 id="c010" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">API网关——你逃离的大门</h1><p id="655c" class="pw-post-body-paragraph jh ji hu jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">我们能做的解决方案是使用API网关。我不想在这里解释什么是API Gateway，因为有很多很棒的文章解释了它，你可以在这里找到<a class="ae jg" href="https://microservices.io/patterns/apigateway.html" rel="noopener ugc nofollow" target="_blank"/>，<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/architecture/microservices/gateway" rel="noopener ugc nofollow" target="_blank">这里</a>，和<a class="ae jg" href="https://smartbear.com/learn/api-design/api-gateways-in-microservices/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="472a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">基于<a class="ae jg" href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/" rel="noopener ugc nofollow" target="_blank"> Nginx的伟大文章</a>，API Gateway的目标之一就是启用请求重路由。请求重新路由将使我们的前端服务调用后端服务，API网关将为我们做这件事。当我们在服务上实现API网关时，这里将是我们的系统设计。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/6cbe84d595df6c3ed1ed27ecf1ab4e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*akappoVc0eREE22MsA2ndw.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">After API Gateway implemented</figcaption></figure><h1 id="9605" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">请为我创建一个API网关</h1><p id="7f68" class="pw-post-body-paragraph jh ji hu jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">实际上，API网关提供商很少，比如<a class="ae jg" href="https://www.nginx.com/solutions/api-gateway/" rel="noopener ugc nofollow" target="_blank"> Nginx Plus </a>、<a class="ae jg" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank">亚马逊API网关</a>、<a class="ae jg" href="https://developer.ibm.com/apiconnect/" rel="noopener ugc nofollow" target="_blank"> IBM API Connect </a>和<a class="ae jg" href="https://azure.microsoft.com/en-us/services/api-management/" rel="noopener ugc nofollow" target="_blank">微软Azure API管理</a>。但在这里，我想创造我自己的东西，因为动手做的东西让我更了解它是什么样的东西。</p><p id="b96b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我想用Express JS创建自己的API网关。在此之前，我需要解释一下当前的系统是怎样的。目前，我有两个服务，Feed服务和Hashtag服务。API网关将把传入的请求重新路由给应该处理它的服务。</p><p id="714d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我的Feed服务上，我有三个端点</p><ul class=""><li id="dd72" class="lo lp hu jj b jk jl jo jp js lq jw lr ka ls ke lt lu lv lw dt translated">获取所有的饲料</li><li id="be0d" class="lo lp hu jj b jk mb jo mc js md jw me ka mf ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">GET /feeds/{hashtag}</code>获取包含标签的所有提要</li><li id="442a" class="lo lp hu jj b jk mb jo mc js md jw me ka mf ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">POST /feeds</code>创造新的饲料</li></ul><p id="b256" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我的标签服务上，我有两个端点</p><ul class=""><li id="2d06" class="lo lp hu jj b jk jl jo jp js lq jw lr ka ls ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">GET /hashtags </code>获取所有标签</li><li id="e617" class="lo lp hu jj b jk mb jo mc js md jw me ka mf ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">GET /hashtags/{name}</code>按名字获取单个标签</li></ul><p id="f60b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">目标是当前端服务向API网关发送请求时，请求将被重新路由到应该处理它的服务。请看下图，API网关是如何重新路由请求的。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/3157489fecbea49b882838f80c3f8354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKgcjXIRvTZldqu49TGnDQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">API Gateway reroute upcoming request</figcaption></figure><h2 id="f1e6" class="mh kl hu bd km mi mj mk kq ml mm mn ku js mo mp ky jw mq mr lc ka ms mt lg mu dt translated">创建新的Express JS项目</h2><p id="6f41" class="pw-post-body-paragraph jh ji hu jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">创建一个新的Express JS项目，可以关注官网<a class="ae jg" href="https://expressjs.com/en/starter/installing.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="56f0" class="mh kl hu bd km mi mj mk kq ml mm mn ku js mo mp ky jw mq mr lc ka ms mt lg mu dt translated">创建index.js</h2><p id="acee" class="pw-post-body-paragraph jh ji hu jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hn dt translated">在创建index.js之前，安装<a class="ae jg" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> body-parser </a>以便我们能够解析POST数据。运行这个命令来安装主体解析器</p><pre class="kg kh ki kj fq mv ma mw mx aw my dt"><span id="334b" class="mh kl hu ma b fv mz na l nb nc">npm install -s body-parser</span></pre><p id="025c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lx ly lz ma b">index.js</code>将成为我们的切入点。这里是我们的<code class="eh lx ly lz ma b">index.js</code></p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="1fab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要运行服务器，请运行以下命令</p><pre class="kg kh ki kj fq mv ma mw mx aw my dt"><span id="05e3" class="mh kl hu ma b fv mz na l nb nc">node index.js</span></pre><p id="9204" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后访问<code class="eh lx ly lz ma b">localhost:3000</code>并确保它正常工作。现在，我们将创建路由器作为API网关的入口点。首先，在根文件夹下创建一个新目录，命名为<code class="eh lx ly lz ma b">routers</code>。其次，在<code class="eh lx ly lz ma b">router</code>目录下创建四个文件，分别是<code class="eh lx ly lz ma b">router.js</code>、<code class="eh lx ly lz ma b">apiAdapter.js</code>、<code class="eh lx ly lz ma b">feedService.js</code>和<code class="eh lx ly lz ma b">hashtagService.js</code>。这里每个文件的用途</p><ul class=""><li id="bf10" class="lo lp hu jj b jk jl jo jp js lq jw lr ka ls ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">router.js</code>是组合所有的服务端点</li><li id="c5bc" class="lo lp hu jj b jk mb jo mc js md jw me ka mf ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">apiAdapter.js</code>是为每个服务构建API端点</li><li id="b5bc" class="lo lp hu jj b jk mb jo mc js md jw me ka mf ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">feedService.js</code>是重新路由请求到Feed服务的文件</li><li id="0217" class="lo lp hu jj b jk mb jo mc js md jw me ka mf ke lt lu lv lw dt translated"><code class="eh lx ly lz ma b">hashtagService.js</code>是将请求重新路由到Hashtag服务的文件</li></ul><p id="2e1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使您的<code class="eh lx ly lz ma b">router.js</code>、<code class="eh lx ly lz ma b">feedService.js</code>和<code class="eh lx ly lz ma b">hashtagService.js</code>像下面的代码一样</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="769c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更新这些文件后，尝试重新运行服务器并访问每个端点，确保一切正常。但在此之前，我们没有重新路由任何请求。那么我们该怎么做呢？</p><p id="3a10" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们需要先安装<a class="ae jg" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>。我们使用Axios来构建HTTP客户端。要安装Axios，请运行以下命令</p><pre class="kg kh ki kj fq mv ma mw mx aw my dt"><span id="bdec" class="mh kl hu ma b fv mz na l nb nc">npm install -s axios</span></pre><p id="fed9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">安装Axios后，现在在你的<code class="eh lx ly lz ma b">apiAdapter.js</code>上写这段代码</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="834d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，更新你的<code class="eh lx ly lz ma b">feedService.js</code>和<code class="eh lx ly lz ma b">hashtagService.js</code>像下面的代码</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="3746" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面代码的目的是为每个服务创建HTTP客户端。我们为每个服务构造新的Axios对象，并将<code class="eh lx ly lz ma b">BASE_URL</code>作为参数传递。<code class="eh lx ly lz ma b">BASE_URL</code>是每个服务的基本URL。因此，当API网关收到请求时，它将由之前使用<code class="eh lx ly lz ma b">BASE_URL</code>构建的Axios对象处理。搞定了。就这么简单。</p></div><div class="ab cl nf ng hc nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hn ho hp hq hr"><p id="8906" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是我如何使用Express JS创建自己的API网关。实际上，API网关并不仅仅用于重新路由请求。API网关还用作认证器服务、处理数据缓存和响应聚合器。</p><p id="4f72" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">非常感谢Jonathan Natanael Siahaan教我如何写一个好的代码设计。哦，对了，我的存储库上的API网关已经被修改了，JWT添加来处理认证。你可以在这里找到我的完整代码</p><div class="no np fm fo nq nr"><a href="https://github.com/ecojuntak/api-gateway" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hv fv z el nw eo ep nx er et ht dt translated">ecojuntak/API-网关</h2><div class="ny l"><h3 class="bd b fv z el nw eo ep nx er et ek translated">使用Express JS的简单API网关。通过在GitHub上创建一个帐户，为ecojuntak/api-gateway开发做出贡献。</h3></div><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ja nr"/></div></div></a></div><div class="no np fm fo nq nr"><a href="https://github.com/ecojuntak/hashtag-api" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hv fv z el nw eo ep nx er et ht dt translated">ecojuntak/hashtag-api</h2><div class="ny l"><h3 class="bd b fv z el nw eo ep nx er et ek translated">使用Golang的简单REST API。通过在GitHub上创建一个帐户，为ecojuntak/hashtag-api开发做出贡献。</h3></div><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">github.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ja nr"/></div></div></a></div><div class="no np fm fo nq nr"><a href="https://github.com/ecojuntak/feed-api" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hv fv z el nw eo ep nx er et ht dt translated">ecojuntak/feed-api</h2><div class="ny l"><h3 class="bd b fv z el nw eo ep nx er et ek translated">使用Lumen的简单REST API。在GitHub上创建一个帐户，为ecojuntak/feed-api的开发做出贡献。</h3></div><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">github.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ja nr"/></div></div></a></div><p id="de6e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">卡皮·霍丁！😎 💻 ☕️</p></div></div>    
</body>
</html>