<html>
<head>
<title>Shortest and Longest Path Algorithms: Job Interview Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最短和最长路径算法:工作面试备忘单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/shortest-and-longest-path-algorithms-job-interview-cheatsheet-2adc8e18869?source=collection_archive---------3-----------------------#2018-11-21">https://medium.com/hackernoon/shortest-and-longest-path-algorithms-job-interview-cheatsheet-2adc8e18869?source=collection_archive---------3-----------------------#2018-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2df26aabe5484d9a6183830e028e8ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyXj-vEMCv4ypMVV0PrQuQ.png"/></div></div></figure><p id="d56e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">图中最短和最长路径算法的快速概述和比较。</p><p id="e95f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于图中看似简单的最短和最长路径问题，有很多小问题需要记住。关于这个话题的问题在计算机程序员的技术性工作面试中很常见。然而，经常很难保持你的记忆新鲜并记住这些问题及其算法的所有细节。</p><p id="864d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如:</p><ul class=""><li id="3a86" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">你知道在图中寻找最短的简单路径是NP难的吗？(如果不是，请参见下面的最长路径部分)</li><li id="c288" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><strong class="je hv">你知道在一些图中最短路径可以在线性时间内找到吗？</strong></li></ul><p id="a961" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我在一个地方提供了关于每个著名算法的快速总结和重要观点，可以在每次面试前快速回顾。</p><p id="ffda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在我们开始之前:</strong></p><p id="6194" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们假设图是<em class="ko"> G(V，E) </em> has，其中</p><ul class=""><li id="d0e3" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated"><em class="ko"> V = {1，2，…，n}，|V| = n </em></li><li id="1256" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated"><em class="ko"> |E| = m </em></li></ul><p id="11d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看我的C++图形表示视频:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="kt ku l"/></div></figure><p id="8702" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于最短路径问题，我们假设我们在寻找最短的<strong class="je hv">非简单</strong>路径，即顶点可以重复。此外，我们假设边权重可以是整数值，即正、负或零。</p><p id="30c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">最短距离</strong>问题只要求节点间的最短距离，而<strong class="je hv">最短路径问题</strong>要求节点间的实际最短路径。我们在这里讨论最短距离问题。最短路径通常可以通过对算法进行较小的改进来找到。</p><h1 id="3597" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">弗洛伊德-沃肖尔算法</h1><p id="8030" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">Floyd-Warshall是最简单的算法:</p><p id="8f0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">快速直觉</strong>:我们仅使用集合<em class="ko"> {1，2，…，k} </em> <strong class="je hv"> <em class="ko">中的节点作为它们之间的中间点</em> </strong>，计算从节点<em class="ko"> i </em>到<em class="ko"> j </em>的最短可能路径。d(i，j，k)表示仅使用k个节点的I，j之间的最短距离。我们可以写:</p><blockquote class="ly"><p id="509d" class="lz ma hu bd mb mc md me mf mg mh jz ek translated"><strong class="ak"> d(i，j，k) = min(d(i，j，k-1)，d(i，k，k-1)+ d(k，j，k-1)) </strong></p></blockquote><p id="5c47" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn mk jp jq jr ml jt ju jv mm jx jy jz hn dt translated">下图是直觉:</p><figure class="kp kq kr ks fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/d6853cf7b87fd63a15d3bc5842caaaeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLyDAO3piCVRNVX4vgoJ6Q.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Shortest path from i,j using k nodes can be calculated by comparing the shortest path from i to j using k-1 nodes and the sum of i to k and k to j using k-1 nodes</figcaption></figure><p id="2023" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一段清晰解释弗洛伊德-沃肖尔算法的视频:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="kt ku l"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">A video clearly explaining Floyd-Warshall Algorithm in 9 minutes</figcaption></figure><p id="a3fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是C++中的实现:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ms ku l"/></div></figure><h2 id="b3dc" class="mt kw hu bd kx mu mv mw lb mx my mz lf jn na nb lj jr nc nd ln jv ne nf lr ng dt translated">关于Floyd-Warshal算法你需要知道的是:</h2><ul class=""><li id="de30" class="ka kb hu je b jf lt jj lu jn nh jr ni jv nj jz kf kg kh ki dt translated">它查找所有节点对之间的最短距离。</li><li id="fe8d" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">是<em class="ko"> O(n ) </em></li><li id="3ce4" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">这是一种递归算法，可以使用动态编程来实现</li><li id="173f" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">图形可以有负边</li><li id="9129" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它可以报告负循环</li></ul><h1 id="6ab6" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated"><strong class="ak"> Dijkstra算法</strong></h1><p id="8f13" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">Dijkstra算法寻找单个源和所有其他节点之间的最短路径。</p><p id="93ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">直觉:</strong>保留访问过的节点列表。在每一步:</p><ol class=""><li id="a3e0" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz nk kg kh ki dt translated">找到距离最短的未访问节点<em class="ko"> u </em></li><li id="85b2" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz nk kg kh ki dt translated">放宽<em class="ko"> u </em>邻居的距离</li><li id="6857" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz nk kg kh ki dt translated">将<em class="ko"> u </em>添加到已访问列表中，然后重复</li></ol><p id="c2ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是Dijkstra在C++中的实现:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ms ku l"/></div></figure><h2 id="5de8" class="mt kw hu bd kx mu mv mw lb mx my mz lf jn na nb lj jr nc nd ln jv ne nf lr ng dt translated">关于Dijkstra算法你需要知道的是:</h2><ul class=""><li id="2156" class="ka kb hu je b jf lt jj lu jn nh jr ni jv nj jz kf kg kh ki dt translated">运行时是:<em class="ko"> O(n </em> <em class="ko"> ) </em>的简单形式。带min-heap: <em class="ko"> O( (m+n)log(n))。</em>用斐波那契堆:<em class="ko"> O(m+n log n) </em></li><li id="1a4e" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">这是一个贪婪的算法</li><li id="e163" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它不能处理负边沿或负周期</li></ul><p id="f464" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是Dijkstra在C++中使用优先级队列的算法:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ms ku l"/></div></figure><h1 id="870f" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">贝尔曼-福特算法</h1><p id="35a9" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">该算法寻找从源到所有其他节点的最短距离。</p><p id="ada8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">直觉:我们有两个循环:</p><ul class=""><li id="ed86" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">内部循环:我们在所有的边上迭代。在每次迭代中，我们通过使用从<em class="ko"> 0 </em>到<em class="ko"> j </em>的边来放宽距离。</li><li id="d26e" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">外循环:我们重复内循环<em class="ko"> n-1次</em></li></ul><figure class="kp kq kr ks fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/e9a796d42ed6176457c1874e1166541d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*1fvRQirCA8AEt0OObCwlTg.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Bellman-Ford Algorithm. Picture taken from <a class="ae nm" href="https://courses.csail.mit.edu/6.006/spring11/lectures/lec15.pdf" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="3363" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在外循环的第<em class="ko"> i次</em>迭代后，计算最多有<em class="ko"> i条</em>边的最短路径。任何简单路径中最多可以有<em class="ko"> n - 1 </em>条边，所以我们重复<em class="ko"> n - 1 </em>次。</p><p id="588b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是贝尔曼-福特算法在C++中的实现。</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ms ku l"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Bellman-Ford Algorithm. Notice that we use an adjacency matrix to iterate edges</figcaption></figure><p id="e1b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">关于贝尔曼-福特算法你需要知道的事情</strong></p><ul class=""><li id="12a4" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">运行时间:<em class="ko"> O(m.n)。</em></li><li id="e097" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">如果我们使用邻接矩阵(如上面的代码)来迭代边，运行时间是<em class="ko"> O(n ) </em></li><li id="2a25" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它可以处理负边缘</li><li id="3df5" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它可以报告负循环</li></ul><h1 id="318f" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">DAGs中的最短距离</h1><p id="d544" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">DAG(有向无环图)中的最短距离可以在线性时间内计算。</p><p id="e054" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用拓扑排序来查找单个源到所有其他节点的距离。</p><p id="fcaa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">直觉:</strong>按拓扑顺序迭代图的节点<em class="ko"> u </em>。对于作为<em class="ko"> u </em>的邻居的每个节点<em class="ko"> v </em>，使用以下方式放松<em class="ko">d【v】</em></p><blockquote class="ly"><p id="d0cf" class="lz ma hu bd mb mc md me mf mg mh jz ek translated">d[v]=min(d[v]，d[u] + w(u，v))</p></blockquote><p id="8f08" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn mk jp jq jr ml jt ju jv mm jx jy jz hn dt translated"><strong class="je hv">你需要知道的:</strong></p><ul class=""><li id="baa4" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">运行时间:<em class="ko"> O(m+n) </em></li><li id="b8c4" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它可以处理负边缘</li><li id="1b70" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它不能处理负周期(Dag中没有周期)</li></ul><p id="b594" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是使用拓扑排序的DAG中最短路径的实现:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ms ku l"/></div></figure><p id="e67b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">拓扑排序在C++中的具体实现如下:</p><figure class="kp kq kr ks fq iv"><div class="bz el l di"><div class="ms ku l"/></div></figure><h1 id="c465" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated"><strong class="ak">广度优先搜索算法</strong></h1><p id="8beb" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">广度优先搜索，BFS，可以在一个非加权图或一个加权图中找到最短路径，如果所有的边都具有相同的非负权重。不失一般性，假设所有重量为<em class="ko"> 1 </em>。</p><p id="7134" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">直觉:</strong> BFS拉平一个图，即在每次迭代中<em class="ko"> i </em>它访问距离源<em class="ko"> i </em>的节点。因此，如果从源到一个节点的最短路径是<em class="ko"> i </em>，我们一定会在迭代中找到它<em class="ko"> i. </em></p><p id="1578" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于BFS你需要知道的:</p><ul class=""><li id="3ad1" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">运行时间:O(m+n)</li><li id="f948" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">所有权重应该相等</li><li id="590d" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它不能处理负权重</li><li id="f9a4" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它不能处理负循环</li></ul></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><h1 id="b159" class="kv kw hu bd kx ky nu la lb lc nv le lf lg nw li lj lk nx lm ln lo ny lq lr ls dt translated"><strong class="ak">最长距离问题</strong></h1><p id="71d9" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">寻找最短路径的姊妹问题是寻找最长路径。但是首先请注意，当我们谈论最长路径时，有一个巨大的困惑:</p><blockquote class="ly"><p id="3809" class="lz ma hu bd mb mc md me mf mg mh jz ek translated">最长路径问题通常意味着寻找最长的<strong class="ak">简单</strong>路径。</p><p id="be07" class="lz ma hu bd mb mc md me mf mg mh jz ek translated">然而，最短路径问题(如上所述)侧重于寻找最短(简单或非简单)路径。</p></blockquote><p id="1287" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn mk jp jq jr ml jt ju jv mm jx jy jz hn dt translated">因此，在文献中，即使当人们谈论寻找最长路径时，他们通常指的是寻找最长的<strong class="je hv">简单</strong>路径。</p><h2 id="1f0a" class="mt kw hu bd kx mu mv mw lb mx my mz lf jn na nb lj jr nc nd ln jv ne nf lr ng dt translated">转换到<em class="nz"> -G </em></h2><p id="e829" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">最长简单路径问题可以通过将<em class="ko"> G </em>转换为<em class="ko"> -G(即</em>将原<em class="ko"> G </em>中每条边的权重的符号取反)来解决，然后计算<strong class="je hv">最短简单路径</strong>。</p><p id="c236" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，如果<em class="ko"> -G </em>没有负环，寻找最短的简单路径与使用上述算法寻找可以在多项式时间内解决的最短路径是相同的。</p><p id="4c9d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">关于最长简单路径问题你需要知道什么</strong></p><ul class=""><li id="c6f2" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">寻找最长的简单路径通常是NP难的。这可以很容易地从哈密顿回路问题中推导出来。</li><li id="afec" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">由此可见，在<em class="ko"> G </em>中存在正循环的情况下，寻找最长的简单路径是NP难的。</li><li id="17c9" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">如果<em class="ko"> G </em>中没有正循环，那么在<em class="ko"> -G </em>上运行上述最短路径算法之一，可以在多项式时间内解决最长简单路径问题。</li></ul><p id="56c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于在我们不常听到的图中寻找最短的简单路径，这里有一个有趣的观点:</p><blockquote class="ly"><p id="d416" class="lz ma hu bd mb mc md me mf mg mh jz ek translated">在图中寻找最短的简单路径是NP难的。</p></blockquote><p id="d478" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn mk jp jq jr ml jt ju jv mm jx jy jz hn dt translated">这可以用<em class="ko"> -G </em>变换到求最长简单路径的问题来证明。</p><p id="55bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了更好的理解，假设<em class="ko"> G </em>中有一个负循环。在这种情况下，我们著名的算法都找不到最短路径，因为它不存在。然而，在图中仍然有最短的简单的<strong class="je hv">路径，其中没有顶点重复。寻找最短的简单路径是NP难的！</strong></p><h2 id="401a" class="mt kw hu bd kx mu mv mw lb mx my mz lf jn na nb lj jr nc nd ln jv ne nf lr ng dt translated">DAGs中最长的路径</h2><p id="0a32" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">如果<em class="ko"> G </em>是一个DAG，因为没有圈，所以在线性时间内使用拓扑排序可以解决寻找最长简单路径的问题。该解决方案类似于在Dag中寻找最短距离的解决方案，除了我们在放宽距离时取最大值。</p></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><p id="c917" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请告诉我你是否在工作面试中听说过关于最短和最长路径算法的有趣问题。祝你面试好运！</p></div></div>    
</body>
</html>