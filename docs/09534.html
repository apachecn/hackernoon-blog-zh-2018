<html>
<head>
<title>Never mock an API again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再也不要嘲笑API了</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/never-mock-an-api-again-daac4a15d105?source=collection_archive---------15-----------------------#2018-11-21">https://medium.com/hackernoon/never-mock-an-api-again-daac4a15d105?source=collection_archive---------15-----------------------#2018-11-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ff97" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">为什么我们对整个堆栈使用unmock</h2></div><p id="9716" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">面对现实吧，嘲讽很烂。每种编程语言和平台都有不同的工具来帮助您模拟API调用，但是它们都有一些共同的弱点:</p><ul class=""><li id="b456" class="kf kg hu jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn dt translated">没有明确的方法来验证模拟是否是API的正确表示。</li><li id="5dbf" class="kf kg hu jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn dt translated">无法避免对你嘲笑的API进行逆向工程。</li><li id="136a" class="kf kg hu jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn dt translated">没有办法快速模仿内部API。</li><li id="7c51" class="kf kg hu jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn dt translated">如果您的测试模拟与您在野外获得的数据相似，那么就无法在生产中进行监控。</li></ul><p id="2441" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">结果，团队失去了大量的时间和精力来为他们的单元和集成测试编写模拟，这导致了错误的测试，更少的测试覆盖，并最终导致更不可靠的生产环境。</p><h1 id="6c76" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">卸下</h1><p id="5408" class="pw-post-body-paragraph jj jk hu jl b jm ll iv jo jp lm iy jr js ln ju jv jw lo jy jz ka lp kc kd ke hn dt translated">进入<a class="ae lq" href="https://unmock.io" rel="noopener ugc nofollow" target="_blank">解锁</a>。Unmock很棒，因为它基本上为你处理了所有这些事情。YouTube上有一个关于这项服务的很好的概述(目前处于封闭测试阶段)，但我想我会向你介绍unmock如何加快我们在Meeshkan的团队的速度。</p><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="2d9d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关于unmock，要知道的第一件重要的事情是，您编写的测试代码的数量大大减少了，因为您没有滚动自己的模拟。在Meeshkan中，我们基本上删除了所有的嘲讽代码，包括将它捆绑在一起的逻辑，并使用unmock作为API调用的替代。调整模拟响应非常直观，因此，我们已经能够快速编写各种糟糕的API调用的极限情况测试——意外的空值、空字符串等。我们还发现了几个关于我们正在使用的API的错误假设，当你试图快速构建一个产品时，这是一个真正的救命稻草。</p><p id="90d6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们特别欣赏的一个特性是unmock在同一个测试中处理API调用的方式。基本上，通过点击app.unmock.io上的“Parent ”,你可以在你的模拟上及时倒退，以真正快速地看到进入你的测试的数据。当然，您可以瞬间修改所有这些，通过您的测试来讲述您想要讲述的故事。</p><p id="ef7f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">虽然unmock提供了一个保存功能来本地下载模拟，但我们实际上发现这是该产品最没用的功能。起初，我们将模拟签入版本控制，但我们很快意识到，由于各种原因，让模拟在unmock上运行要好得多。最主要的一点是，当您向测试中添加越来越多的调用时，您不必担心哪些模拟是本地制作的，哪些是从unmock中提取的——您有一个单一的模拟源。此外，对于graphql模式，unmock将在模式发布时自动更新模式，这避免了冻结陈旧的模仿。另一个杀手级功能是unmock的生产监控:如果您从unmock API获得模拟，它会自动跟踪您的API调用看到的数据，然后知道在生产中，这些数据是否有任何问题——丢失、扭曲等等。</p><p id="972d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Unmock已经迅速成为我们跨多个平台(Android、iOS和Web)的测试堆栈的中心，因此我们可以快速构建准确的测试，而不必担心测试中来自逆向工程供应商代码的可怕的401错误和bug。如果可以的话，试着加入测试赛。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff ly"><img src="../Images/9a14cd9ac30362899d2ff9a14bd72fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98_YBWwwLVTER6WQvpUIdQ.png"/></div></div></figure></div></div>    
</body>
</html>