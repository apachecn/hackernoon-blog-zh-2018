<html>
<head>
<title>Getting Started with Feign Client in Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring中的Feign Client入门</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-started-with-feign-client-in-spring-9ab33d0be152?source=collection_archive---------3-----------------------#2018-11-22">https://medium.com/hackernoon/getting-started-with-feign-client-in-spring-9ab33d0be152?source=collection_archive---------3-----------------------#2018-11-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="413f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本教程中，我们将看看<em class="jp"> FeignClient </em>以及如何在Spring Boot应用程序中使用它。</p><p id="b98f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp"> FeignClient </em>是一个以声明方式创建REST API客户端的库。因此，我们声明一个客户端定义，其余的在运行时生成供使用，而不是手动为远程API编写客户端代码，或者使用Springs <em class="jp"> RestTemplate </em>。</p><h1 id="4bab" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">应用程序</h1><p id="18d6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们将构建一个小的命令行应用程序，它模拟我们之前创建的看板API的完整测试。示例应用程序将创建一个新用户，登录，检索所有的董事会和注销用户。它捕获了最常见的用例(POST、GET、DELETE + AuthN)</p><h1 id="5366" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">先决条件</h1><p id="7c8a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在本教程中，我们将使用我们的看板API教程项目。RESTful API展示在<a class="ae kt" href="http://kanbanbackend.com/" rel="noopener ugc nofollow" target="_blank">看板后端</a>上，我们将使用运行的默认实现。</p><p id="310f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将在相应的章节中介绍与本教程相关的端点。完整的API文档，见<a class="ae kt" href="https://kanbanbackend.herokuapp.com/swagger-ui.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="66db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看板API是我在Learnletter上运行的一个教程，你可以在博客中找到所有的部分。</p><h1 id="94f9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">添加依赖关系</h1><p id="1650" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们在本教程中使用Maven。由于我们不想弄乱版本号，最简单的方法是在Maven POM的<em class="jp"> dependencyManagement </em>中包含Spring Cloud设置。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="a646" class="ld jr hu kz b fv le lf l lg lh">&lt;dependencyManagement&gt; <br/>  &lt;dependencies&gt;<br/>    &lt;dependency&gt;<br/>      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  <br/>      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; <br/>      &lt;version&gt;Finchley.SR1&lt;/version&gt;<br/>      &lt;type&gt;pom&lt;/type&gt;<br/>      &lt;scope&gt;import&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>  &lt;/dependencies&gt;<br/>&lt;/dependencyManagement&gt;</span></pre><p id="2950" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以用一个经典的Spring Boot启动器将依赖关系添加到<em class="jp"> Feign </em>中:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="ecc2" class="ld jr hu kz b fv le lf l lg lh">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;</span></pre><h1 id="3acb" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">FeignClient基础知识</h1><p id="7801" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Feign客户端使用声明性方法来访问API。要使用它，我们必须首先在我们的Spring Boot应用程序上启用Spring Cloud对它的支持，在一个<em class="jp"> @Configuration </em>类的类级别上使用<em class="jp"> @EnableFeignClients </em>注释。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="a745" class="ld jr hu kz b fv le lf l lg lh">@SpringBootApplication<br/>@EnableFeignClients <br/>public class FeignIntroductionApplication implements ApplicationRunner <br/>{ //omitted <br/>}</span></pre><p id="8c85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一步是声明一个接口来访问我们的API。我们将其命名为<em class="jp"> KanbanClient </em>，因为它将提供调用我们的远程API的方法。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="0457" class="ld jr hu kz b fv le lf l lg lh">@FeignClient(name="KanbanClient", <br/>             url= "https://kanbanbackend.herokuapp.com/") <br/>public interface KanbanClient { }</span></pre><p id="d7f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要把它变成一个虚拟客户端，我们必须在接口上设置<em class="jp"> @FeignClient </em>注释，用<em class="jp"> name </em>属性给它命名，并且用<em class="jp"> url </em>属性设置远程URL。这里支持SpEL，所以我们可以将值外部化到属性文件中。除了URL，我们还可以在这里使用Eureka来使用服务发现。然而，这超出了本教程的范围。</p><p id="e9ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要定义一个远程调用，我们必须声明一个方法，并使用Spring MVC的一些注释，这些注释通常用在服务器端的<em class="jp"> @Controller </em>上。它们的行为是一样的，只是现在在客户端。</p><p id="034a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，让我们从增加功能开始。</p><h1 id="830a" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">拨打POST电话</h1><p id="58c0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在一个方法上添加<em class="jp"> @PostMapping </em>注释并在其中传递一个参数，会将该方法转换为POST调用。在注释中，我们提供了相对于我们在<em class="jp"> @FeignClient </em>注释中设置的URL的端点。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="85a5" class="ld jr hu kz b fv le lf l lg lh">@PostMapping(value = "/register") String registerUser(User user);</span></pre><p id="8521" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">用户</em>是一个简单的POJO，有一个<em class="jp">用户名</em>和<em class="jp">密码</em>字段。Feign，Spring会自动把它转换成JSON。</p><h1 id="43d0" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">拨打接听电话</h1><p id="d996" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">同样的原理，但是我们在方法上使用了<em class="jp"> @GetMapping </em>。我们还发送认证头。API使用<em class="jp"> X-Auth-Token </em>。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="7b11" class="ld jr hu kz b fv le lf l lg lh">@GetMapping("/boards")<br/>List&lt;Board&gt; listBoards(<br/>  @RequestHeader("X-Auth-Token") <br/>  String authHeader<br/>);</span></pre><p id="8fd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp"> /boards </em>端点将返回用户所有看板的列表。<em class="jp">板卡</em>是该板卡的POJO，只包含<em class="jp"> id </em>和<em class="jp">名称</em>。</p><h1 id="ea3c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">拨打看跌电话</h1><p id="5c3a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">同样的，只是这次用了一个<em class="jp"> @PutMapping </em>注释。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="c305" class="ld jr hu kz b fv le lf l lg lh">@PutMapping("/board/{id}")<br/>Board changeBoard(<br/>  @RequestHeader("X-Auth-Token") String authHeader, <br/>  @PathVariable("id") Long id, <br/>  Board board<br/>);</span></pre><p id="9324" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过对棋盘的端点进行PUT来更改棋盘的名称(<em class="jp"> /board/{id} </em>)。关于路径变量，请参见下面的<em class="jp">节使用变量</em>进行调用。</p><h1 id="a871" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">拨打删除电话</h1><p id="9975" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">有点无聊，但它看起来和另一个一样，只是有一个<em class="jp"> @DeleteMapping </em>注释。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="63b6" class="ld jr hu kz b fv le lf l lg lh">@DeleteMapping("/unregister")<br/>ResponseEntity&lt;Void&gt; unregisterUser(<br/>  @RequestHeader("X-Auth-Token") String authToken, <br/>  Confirmation user<br/>);</span></pre><p id="f54a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该端点需要一个带有用户密码的<em class="jp">确认</em>对象来删除帐户，如果成功，还将返回一个200。</p><h1 id="08f9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用变量进行调用</h1><p id="8c5b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果我们的端点需要一个基于实体的变量，比如ids，我们可以在方法参数上使用<em class="jp"> @PathVariable </em>注释。它的行为与Spring MVC @控制器相同。</p><p id="6c6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后可以在<em class="jp"> @PutMapping( </em>上的端点声明中使用定义的变量，就像:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="d77d" class="ld jr hu kz b fv le lf l lg lh">@PutMapping("/board/{id}") <br/>Board changeBoard(<br/>  @RequestHeader("X-Auth-Token") String authHeader, <br/>  @PathVariable("id") Long id, <br/>  Board board<br/>);</span></pre><h1 id="1c62" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">带认证的呼叫</h1><p id="5309" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">为此，我们将使用<em class="jp">登录</em>端点。它需要用户凭证作为基本身份验证发送，并将返回一个令牌用于进一步的身份验证。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="b2f9" class="ld jr hu kz b fv le lf l lg lh">@PostMapping("/login")<br/>ResponseEntity&lt;Void&gt; loginUser(<br/>  @RequestHeader("Authorization") String authHeader<br/>);</span></pre><p id="5028" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将附加信息作为header down传递的第一种方法是添加一个带有<em class="jp"> @RequestHeader </em>注释的方法参数。参数的值将被设置为注释中定义的HTTP头的值。</p><p id="c8d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在认证的情况下，是<em class="jp">授权</em>头。作为一个值，我们给它基本的auth编码字符串。</p><p id="23ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在对看板API的后续调用中，我们将使用带有令牌的<em class="jp"> X-Auth-Token </em>头。</p><p id="f145" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">响应头不能直接作为方法返回值返回，但是我们可以使用Spring的<em class="jp"> ResponseEntity </em>，它是一个响应包装器。</p><p id="7b59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们成功调用<em class="jp"> /login </em>端点时，它将在响应头中返回auth令牌。该方法将类似于:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="6ad2" class="ld jr hu kz b fv le lf l lg lh">@PostMapping("/login")<br/>ResponseEntity&lt;Void&gt; loginUser(<br/>  @RequestHeader("Authorization") String authHeader<br/>);</span></pre><p id="aea3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要将<em class="jp"> Void </em>作为参数化类型，因为我们的端点在响应体中不返回任何内容。</p><p id="787f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在看板API中使用Spring Session，所以授权令牌通过<em class="jp"> X-Auth-Token </em>头进行交换。</p><p id="f779" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了检索我们称之为:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="77c1" class="ld jr hu kz b fv le lf l lg lh">String token = response.getHeaders().getFirst("X-Auth-Token");</span></pre><p id="0074" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">响应</em>的类型为<em class="jp">响应实体</em>。</p><h1 id="f4b9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">认证备选方案</h1><p id="3c04" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们总是可以在每个方法上使用<em class="jp"> @RequestHeader </em>注释来传递认证头。然而，还有一种全局指定的替代方法。</p><p id="aafe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像Spring MVC一样，Feign也有一个拦截器的概念，可以用来在远程调用之前做一些特定的事情。入口点是<em class="jp"> RequestInterceptor </em>接口。</p><p id="ece7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Spring，我们只需要提供一个Bean来实现Spring上下文的特定接口，它就会被自动拾取。</p><p id="cb2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="6005" class="ld jr hu kz b fv le lf l lg lh">@Bean <br/>AuthInterceptor authFeign() { <br/>  return new AuthInterceptor(); <br/>}</span><span id="4e70" class="ld jr hu kz b fv li lf l lg lh">class AuthInterceptor implements RequestInterceptor { <br/>  @Override <br/>  public void apply(RequestTemplate template) { <br/>    template.header("Authorization", "&lt;your token&gt;"); <br/>  }<br/>}</span></pre><p id="aa33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的拦截器是一个Spring Bean，因此我们可以使用Spring的强大功能，将authN信息外部化到属性中，甚至可以从会话范围的Bean中检索它，我们在每个用户的基础上保存信息。</p><h1 id="3dd6" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用FeignClient</h1><p id="b39a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在，我们可以像任何其他Spring Bean一样将<em class="jp"> KanbanClient </em>注入到我们的代码中。在启动时，Spring Cloud将为我们设置Feign客户端，并给我们一个常规的Spring代理，这样我们就可以简单地开始使用远程端了。</p><h1 id="198e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">我们的最终客户</h1><p id="b4be" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们使用Feign的客户最终看起来是这样的:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="ac5d" class="ld jr hu kz b fv le lf l lg lh">@FeignClient(name="KanbanClient", <br/>             url= "https://kanbanbackend.herokuapp.com/")<br/>public interface KanbanClient {</span><span id="ca49" class="ld jr hu kz b fv li lf l lg lh">  @PostMapping(value = "/register") <br/>  String registerUser(User user); </span><span id="8638" class="ld jr hu kz b fv li lf l lg lh">  @DeleteMapping("/unregister")<br/>  ResponseEntity&lt;Void&gt; unregisterUser(<br/>    @RequestHeader("X-Auth-Token") String authToken, <br/>    Confirmation user<br/>  );</span><span id="4e5e" class="ld jr hu kz b fv li lf l lg lh">  @PostMapping("/login") <br/>  ResponseEntity&lt;Void&gt; loginUser(<br/>    @RequestHeader("Authorization") String authHeader<br/>  );</span><span id="7317" class="ld jr hu kz b fv li lf l lg lh">  @GetMapping("/boards")<br/>  List&lt;Board&gt; listBoards(<br/>    @RequestHeader("X-Auth-Token") String authHeader<br/>  );</span><span id="f28c" class="ld jr hu kz b fv li lf l lg lh">  @PostMapping("/boards") <br/>  Board createBoard(<br/>    @RequestHeader("X-Auth-Token") String authHeader,<br/>    Board board<br/>  );</span><span id="4258" class="ld jr hu kz b fv li lf l lg lh">  @PutMapping("/board/{id}")<br/>  Board changeBoard(<br/>    @RequestHeader("X-Auth-Token") String authHeader, <br/>    @PathVariable("id") Long id,<br/>    Board board<br/>  );<br/>}</span></pre><h1 id="bf3d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">示例应用程序</h1><p id="0f00" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><a class="ae kt" href="https://github.com/azarai/spring-boot-tutorials-codeboje/tree/master/feign-introduction" rel="noopener ugc nofollow" target="_blank">全工作样本</a>在GitHub上。</p><p id="0676" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将注册一个新用户，登录，创建一个董事会，改变董事会的名称，列出所有董事会，然后在最后注销用户。</p></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><p id="07dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">最初发布于</em><a class="ae kt" href="http://codeboje.de/getting-started-feignclient/" rel="noopener ugc nofollow" target="_blank"><em class="jp">codeboje . de</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>